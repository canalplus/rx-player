"use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __defProps = Object.defineProperties;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b)) {
        if (__propIsEnum.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      }
    return a;
  };
  var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
  var __objRest = (source, exclude) => {
    var target = {};
    for (var prop in source)
      if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
        target[prop] = source[prop];
    if (source != null && __getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(source)) {
        if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
          target[prop] = source[prop];
      }
    return target;
  };
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // <define:__ENVIRONMENT__>
  var define_ENVIRONMENT_default;
  var init_define_ENVIRONMENT = __esm({
    "<define:__ENVIRONMENT__>"() {
      define_ENVIRONMENT_default = { PRODUCTION: 0, DEV: 1, CURRENT_ENV: 0 };
    }
  });

  // <define:__LOGGER_LEVEL__>
  var define_LOGGER_LEVEL_default;
  var init_define_LOGGER_LEVEL = __esm({
    "<define:__LOGGER_LEVEL__>"() {
      define_LOGGER_LEVEL_default = { CURRENT_LEVEL: "INFO" };
    }
  });

  // node_modules/core-js/internals/global.js
  var require_global = __commonJS({
    "node_modules/core-js/internals/global.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var check = function(it) {
        return it && it.Math === Math && it;
      };
      module.exports = // eslint-disable-next-line es/no-global-this -- safe
      check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || // eslint-disable-next-line no-restricted-globals -- safe
      check(typeof self == "object" && self) || check(typeof global == "object" && global) || check(typeof exports == "object" && exports) || // eslint-disable-next-line no-new-func -- fallback
      /* @__PURE__ */ function() {
        return this;
      }() || Function("return this")();
    }
  });

  // node_modules/core-js/internals/fails.js
  var require_fails = __commonJS({
    "node_modules/core-js/internals/fails.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      module.exports = function(exec) {
        try {
          return !!exec();
        } catch (error) {
          return true;
        }
      };
    }
  });

  // node_modules/core-js/internals/descriptors.js
  var require_descriptors = __commonJS({
    "node_modules/core-js/internals/descriptors.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var fails = require_fails();
      module.exports = !fails(function() {
        return Object.defineProperty({}, 1, { get: function() {
          return 7;
        } })[1] !== 7;
      });
    }
  });

  // node_modules/core-js/internals/function-bind-native.js
  var require_function_bind_native = __commonJS({
    "node_modules/core-js/internals/function-bind-native.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var fails = require_fails();
      module.exports = !fails(function() {
        var test = function() {
        }.bind();
        return typeof test != "function" || test.hasOwnProperty("prototype");
      });
    }
  });

  // node_modules/core-js/internals/function-call.js
  var require_function_call = __commonJS({
    "node_modules/core-js/internals/function-call.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var NATIVE_BIND = require_function_bind_native();
      var call = Function.prototype.call;
      module.exports = NATIVE_BIND ? call.bind(call) : function() {
        return call.apply(call, arguments);
      };
    }
  });

  // node_modules/core-js/internals/object-property-is-enumerable.js
  var require_object_property_is_enumerable = __commonJS({
    "node_modules/core-js/internals/object-property-is-enumerable.js"(exports) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $propertyIsEnumerable = {}.propertyIsEnumerable;
      var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
      var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);
      exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
        var descriptor = getOwnPropertyDescriptor(this, V);
        return !!descriptor && descriptor.enumerable;
      } : $propertyIsEnumerable;
    }
  });

  // node_modules/core-js/internals/create-property-descriptor.js
  var require_create_property_descriptor = __commonJS({
    "node_modules/core-js/internals/create-property-descriptor.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      module.exports = function(bitmap, value) {
        return {
          enumerable: !(bitmap & 1),
          configurable: !(bitmap & 2),
          writable: !(bitmap & 4),
          value
        };
      };
    }
  });

  // node_modules/core-js/internals/function-uncurry-this.js
  var require_function_uncurry_this = __commonJS({
    "node_modules/core-js/internals/function-uncurry-this.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var NATIVE_BIND = require_function_bind_native();
      var FunctionPrototype = Function.prototype;
      var call = FunctionPrototype.call;
      var uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call, call);
      module.exports = NATIVE_BIND ? uncurryThisWithBind : function(fn) {
        return function() {
          return call.apply(fn, arguments);
        };
      };
    }
  });

  // node_modules/core-js/internals/classof-raw.js
  var require_classof_raw = __commonJS({
    "node_modules/core-js/internals/classof-raw.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var uncurryThis = require_function_uncurry_this();
      var toString = uncurryThis({}.toString);
      var stringSlice = uncurryThis("".slice);
      module.exports = function(it) {
        return stringSlice(toString(it), 8, -1);
      };
    }
  });

  // node_modules/core-js/internals/indexed-object.js
  var require_indexed_object = __commonJS({
    "node_modules/core-js/internals/indexed-object.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var uncurryThis = require_function_uncurry_this();
      var fails = require_fails();
      var classof = require_classof_raw();
      var $Object = Object;
      var split = uncurryThis("".split);
      module.exports = fails(function() {
        return !$Object("z").propertyIsEnumerable(0);
      }) ? function(it) {
        return classof(it) === "String" ? split(it, "") : $Object(it);
      } : $Object;
    }
  });

  // node_modules/core-js/internals/is-null-or-undefined.js
  var require_is_null_or_undefined = __commonJS({
    "node_modules/core-js/internals/is-null-or-undefined.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      module.exports = function(it) {
        return it === null || it === void 0;
      };
    }
  });

  // node_modules/core-js/internals/require-object-coercible.js
  var require_require_object_coercible = __commonJS({
    "node_modules/core-js/internals/require-object-coercible.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var isNullOrUndefined2 = require_is_null_or_undefined();
      var $TypeError = TypeError;
      module.exports = function(it) {
        if (isNullOrUndefined2(it)) throw new $TypeError("Can't call method on " + it);
        return it;
      };
    }
  });

  // node_modules/core-js/internals/to-indexed-object.js
  var require_to_indexed_object = __commonJS({
    "node_modules/core-js/internals/to-indexed-object.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var IndexedObject = require_indexed_object();
      var requireObjectCoercible = require_require_object_coercible();
      module.exports = function(it) {
        return IndexedObject(requireObjectCoercible(it));
      };
    }
  });

  // node_modules/core-js/internals/is-callable.js
  var require_is_callable = __commonJS({
    "node_modules/core-js/internals/is-callable.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var documentAll = typeof document == "object" && document.all;
      module.exports = typeof documentAll == "undefined" && documentAll !== void 0 ? function(argument) {
        return typeof argument == "function" || argument === documentAll;
      } : function(argument) {
        return typeof argument == "function";
      };
    }
  });

  // node_modules/core-js/internals/is-object.js
  var require_is_object = __commonJS({
    "node_modules/core-js/internals/is-object.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var isCallable = require_is_callable();
      module.exports = function(it) {
        return typeof it == "object" ? it !== null : isCallable(it);
      };
    }
  });

  // node_modules/core-js/internals/get-built-in.js
  var require_get_built_in = __commonJS({
    "node_modules/core-js/internals/get-built-in.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var global2 = require_global();
      var isCallable = require_is_callable();
      var aFunction = function(argument) {
        return isCallable(argument) ? argument : void 0;
      };
      module.exports = function(namespace, method) {
        return arguments.length < 2 ? aFunction(global2[namespace]) : global2[namespace] && global2[namespace][method];
      };
    }
  });

  // node_modules/core-js/internals/object-is-prototype-of.js
  var require_object_is_prototype_of = __commonJS({
    "node_modules/core-js/internals/object-is-prototype-of.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var uncurryThis = require_function_uncurry_this();
      module.exports = uncurryThis({}.isPrototypeOf);
    }
  });

  // node_modules/core-js/internals/engine-user-agent.js
  var require_engine_user_agent = __commonJS({
    "node_modules/core-js/internals/engine-user-agent.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      module.exports = typeof navigator != "undefined" && String(navigator.userAgent) || "";
    }
  });

  // node_modules/core-js/internals/engine-v8-version.js
  var require_engine_v8_version = __commonJS({
    "node_modules/core-js/internals/engine-v8-version.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var global2 = require_global();
      var userAgent = require_engine_user_agent();
      var process2 = global2.process;
      var Deno2 = global2.Deno;
      var versions = process2 && process2.versions || Deno2 && Deno2.version;
      var v8 = versions && versions.v8;
      var match;
      var version2;
      if (v8) {
        match = v8.split(".");
        version2 = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
      }
      if (!version2 && userAgent) {
        match = userAgent.match(/Edge\/(\d+)/);
        if (!match || match[1] >= 74) {
          match = userAgent.match(/Chrome\/(\d+)/);
          if (match) version2 = +match[1];
        }
      }
      module.exports = version2;
    }
  });

  // node_modules/core-js/internals/symbol-constructor-detection.js
  var require_symbol_constructor_detection = __commonJS({
    "node_modules/core-js/internals/symbol-constructor-detection.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var V8_VERSION = require_engine_v8_version();
      var fails = require_fails();
      var global2 = require_global();
      var $String = global2.String;
      module.exports = !!Object.getOwnPropertySymbols && !fails(function() {
        var symbol = Symbol("symbol detection");
        return !$String(symbol) || !(Object(symbol) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
        !Symbol.sham && V8_VERSION && V8_VERSION < 41;
      });
    }
  });

  // node_modules/core-js/internals/use-symbol-as-uid.js
  var require_use_symbol_as_uid = __commonJS({
    "node_modules/core-js/internals/use-symbol-as-uid.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var NATIVE_SYMBOL = require_symbol_constructor_detection();
      module.exports = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == "symbol";
    }
  });

  // node_modules/core-js/internals/is-symbol.js
  var require_is_symbol = __commonJS({
    "node_modules/core-js/internals/is-symbol.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var getBuiltIn = require_get_built_in();
      var isCallable = require_is_callable();
      var isPrototypeOf = require_object_is_prototype_of();
      var USE_SYMBOL_AS_UID = require_use_symbol_as_uid();
      var $Object = Object;
      module.exports = USE_SYMBOL_AS_UID ? function(it) {
        return typeof it == "symbol";
      } : function(it) {
        var $Symbol = getBuiltIn("Symbol");
        return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));
      };
    }
  });

  // node_modules/core-js/internals/try-to-string.js
  var require_try_to_string = __commonJS({
    "node_modules/core-js/internals/try-to-string.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $String = String;
      module.exports = function(argument) {
        try {
          return $String(argument);
        } catch (error) {
          return "Object";
        }
      };
    }
  });

  // node_modules/core-js/internals/a-callable.js
  var require_a_callable = __commonJS({
    "node_modules/core-js/internals/a-callable.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var isCallable = require_is_callable();
      var tryToString = require_try_to_string();
      var $TypeError = TypeError;
      module.exports = function(argument) {
        if (isCallable(argument)) return argument;
        throw new $TypeError(tryToString(argument) + " is not a function");
      };
    }
  });

  // node_modules/core-js/internals/get-method.js
  var require_get_method = __commonJS({
    "node_modules/core-js/internals/get-method.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var aCallable = require_a_callable();
      var isNullOrUndefined2 = require_is_null_or_undefined();
      module.exports = function(V, P) {
        var func = V[P];
        return isNullOrUndefined2(func) ? void 0 : aCallable(func);
      };
    }
  });

  // node_modules/core-js/internals/ordinary-to-primitive.js
  var require_ordinary_to_primitive = __commonJS({
    "node_modules/core-js/internals/ordinary-to-primitive.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var call = require_function_call();
      var isCallable = require_is_callable();
      var isObject2 = require_is_object();
      var $TypeError = TypeError;
      module.exports = function(input, pref) {
        var fn, val;
        if (pref === "string" && isCallable(fn = input.toString) && !isObject2(val = call(fn, input))) return val;
        if (isCallable(fn = input.valueOf) && !isObject2(val = call(fn, input))) return val;
        if (pref !== "string" && isCallable(fn = input.toString) && !isObject2(val = call(fn, input))) return val;
        throw new $TypeError("Can't convert object to primitive value");
      };
    }
  });

  // node_modules/core-js/internals/is-pure.js
  var require_is_pure = __commonJS({
    "node_modules/core-js/internals/is-pure.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      module.exports = false;
    }
  });

  // node_modules/core-js/internals/define-global-property.js
  var require_define_global_property = __commonJS({
    "node_modules/core-js/internals/define-global-property.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var global2 = require_global();
      var defineProperty = Object.defineProperty;
      module.exports = function(key, value) {
        try {
          defineProperty(global2, key, { value, configurable: true, writable: true });
        } catch (error) {
          global2[key] = value;
        }
        return value;
      };
    }
  });

  // node_modules/core-js/internals/shared-store.js
  var require_shared_store = __commonJS({
    "node_modules/core-js/internals/shared-store.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var IS_PURE = require_is_pure();
      var globalThis2 = require_global();
      var defineGlobalProperty = require_define_global_property();
      var SHARED = "__core-js_shared__";
      var store = module.exports = globalThis2[SHARED] || defineGlobalProperty(SHARED, {});
      (store.versions || (store.versions = [])).push({
        version: "3.37.1",
        mode: IS_PURE ? "pure" : "global",
        copyright: "\xA9 2014-2024 Denis Pushkarev (zloirock.ru)",
        license: "https://github.com/zloirock/core-js/blob/v3.37.1/LICENSE",
        source: "https://github.com/zloirock/core-js"
      });
    }
  });

  // node_modules/core-js/internals/shared.js
  var require_shared = __commonJS({
    "node_modules/core-js/internals/shared.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var store = require_shared_store();
      module.exports = function(key, value) {
        return store[key] || (store[key] = value || {});
      };
    }
  });

  // node_modules/core-js/internals/to-object.js
  var require_to_object = __commonJS({
    "node_modules/core-js/internals/to-object.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var requireObjectCoercible = require_require_object_coercible();
      var $Object = Object;
      module.exports = function(argument) {
        return $Object(requireObjectCoercible(argument));
      };
    }
  });

  // node_modules/core-js/internals/has-own-property.js
  var require_has_own_property = __commonJS({
    "node_modules/core-js/internals/has-own-property.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var uncurryThis = require_function_uncurry_this();
      var toObject = require_to_object();
      var hasOwnProperty2 = uncurryThis({}.hasOwnProperty);
      module.exports = Object.hasOwn || function hasOwn(it, key) {
        return hasOwnProperty2(toObject(it), key);
      };
    }
  });

  // node_modules/core-js/internals/uid.js
  var require_uid = __commonJS({
    "node_modules/core-js/internals/uid.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var uncurryThis = require_function_uncurry_this();
      var id = 0;
      var postfix = Math.random();
      var toString = uncurryThis(1 .toString);
      module.exports = function(key) {
        return "Symbol(" + (key === void 0 ? "" : key) + ")_" + toString(++id + postfix, 36);
      };
    }
  });

  // node_modules/core-js/internals/well-known-symbol.js
  var require_well_known_symbol = __commonJS({
    "node_modules/core-js/internals/well-known-symbol.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var global2 = require_global();
      var shared = require_shared();
      var hasOwn = require_has_own_property();
      var uid = require_uid();
      var NATIVE_SYMBOL = require_symbol_constructor_detection();
      var USE_SYMBOL_AS_UID = require_use_symbol_as_uid();
      var Symbol2 = global2.Symbol;
      var WellKnownSymbolsStore = shared("wks");
      var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol2["for"] || Symbol2 : Symbol2 && Symbol2.withoutSetter || uid;
      module.exports = function(name2) {
        if (!hasOwn(WellKnownSymbolsStore, name2)) {
          WellKnownSymbolsStore[name2] = NATIVE_SYMBOL && hasOwn(Symbol2, name2) ? Symbol2[name2] : createWellKnownSymbol("Symbol." + name2);
        }
        return WellKnownSymbolsStore[name2];
      };
    }
  });

  // node_modules/core-js/internals/to-primitive.js
  var require_to_primitive = __commonJS({
    "node_modules/core-js/internals/to-primitive.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var call = require_function_call();
      var isObject2 = require_is_object();
      var isSymbol = require_is_symbol();
      var getMethod = require_get_method();
      var ordinaryToPrimitive = require_ordinary_to_primitive();
      var wellKnownSymbol = require_well_known_symbol();
      var $TypeError = TypeError;
      var TO_PRIMITIVE = wellKnownSymbol("toPrimitive");
      module.exports = function(input, pref) {
        if (!isObject2(input) || isSymbol(input)) return input;
        var exoticToPrim = getMethod(input, TO_PRIMITIVE);
        var result;
        if (exoticToPrim) {
          if (pref === void 0) pref = "default";
          result = call(exoticToPrim, input, pref);
          if (!isObject2(result) || isSymbol(result)) return result;
          throw new $TypeError("Can't convert object to primitive value");
        }
        if (pref === void 0) pref = "number";
        return ordinaryToPrimitive(input, pref);
      };
    }
  });

  // node_modules/core-js/internals/to-property-key.js
  var require_to_property_key = __commonJS({
    "node_modules/core-js/internals/to-property-key.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var toPrimitive = require_to_primitive();
      var isSymbol = require_is_symbol();
      module.exports = function(argument) {
        var key = toPrimitive(argument, "string");
        return isSymbol(key) ? key : key + "";
      };
    }
  });

  // node_modules/core-js/internals/document-create-element.js
  var require_document_create_element = __commonJS({
    "node_modules/core-js/internals/document-create-element.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var global2 = require_global();
      var isObject2 = require_is_object();
      var document3 = global2.document;
      var EXISTS = isObject2(document3) && isObject2(document3.createElement);
      module.exports = function(it) {
        return EXISTS ? document3.createElement(it) : {};
      };
    }
  });

  // node_modules/core-js/internals/ie8-dom-define.js
  var require_ie8_dom_define = __commonJS({
    "node_modules/core-js/internals/ie8-dom-define.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var DESCRIPTORS = require_descriptors();
      var fails = require_fails();
      var createElement50 = require_document_create_element();
      module.exports = !DESCRIPTORS && !fails(function() {
        return Object.defineProperty(createElement50("div"), "a", {
          get: function() {
            return 7;
          }
        }).a !== 7;
      });
    }
  });

  // node_modules/core-js/internals/object-get-own-property-descriptor.js
  var require_object_get_own_property_descriptor = __commonJS({
    "node_modules/core-js/internals/object-get-own-property-descriptor.js"(exports) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var DESCRIPTORS = require_descriptors();
      var call = require_function_call();
      var propertyIsEnumerableModule = require_object_property_is_enumerable();
      var createPropertyDescriptor = require_create_property_descriptor();
      var toIndexedObject = require_to_indexed_object();
      var toPropertyKey = require_to_property_key();
      var hasOwn = require_has_own_property();
      var IE8_DOM_DEFINE = require_ie8_dom_define();
      var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
      exports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
        O = toIndexedObject(O);
        P = toPropertyKey(P);
        if (IE8_DOM_DEFINE) try {
          return $getOwnPropertyDescriptor(O, P);
        } catch (error) {
        }
        if (hasOwn(O, P)) return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);
      };
    }
  });

  // node_modules/core-js/internals/v8-prototype-define-bug.js
  var require_v8_prototype_define_bug = __commonJS({
    "node_modules/core-js/internals/v8-prototype-define-bug.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var DESCRIPTORS = require_descriptors();
      var fails = require_fails();
      module.exports = DESCRIPTORS && fails(function() {
        return Object.defineProperty(function() {
        }, "prototype", {
          value: 42,
          writable: false
        }).prototype !== 42;
      });
    }
  });

  // node_modules/core-js/internals/an-object.js
  var require_an_object = __commonJS({
    "node_modules/core-js/internals/an-object.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var isObject2 = require_is_object();
      var $String = String;
      var $TypeError = TypeError;
      module.exports = function(argument) {
        if (isObject2(argument)) return argument;
        throw new $TypeError($String(argument) + " is not an object");
      };
    }
  });

  // node_modules/core-js/internals/object-define-property.js
  var require_object_define_property = __commonJS({
    "node_modules/core-js/internals/object-define-property.js"(exports) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var DESCRIPTORS = require_descriptors();
      var IE8_DOM_DEFINE = require_ie8_dom_define();
      var V8_PROTOTYPE_DEFINE_BUG = require_v8_prototype_define_bug();
      var anObject = require_an_object();
      var toPropertyKey = require_to_property_key();
      var $TypeError = TypeError;
      var $defineProperty = Object.defineProperty;
      var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
      var ENUMERABLE = "enumerable";
      var CONFIGURABLE = "configurable";
      var WRITABLE = "writable";
      exports.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {
        anObject(O);
        P = toPropertyKey(P);
        anObject(Attributes);
        if (typeof O === "function" && P === "prototype" && "value" in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
          var current = $getOwnPropertyDescriptor(O, P);
          if (current && current[WRITABLE]) {
            O[P] = Attributes.value;
            Attributes = {
              configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
              enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
              writable: false
            };
          }
        }
        return $defineProperty(O, P, Attributes);
      } : $defineProperty : function defineProperty(O, P, Attributes) {
        anObject(O);
        P = toPropertyKey(P);
        anObject(Attributes);
        if (IE8_DOM_DEFINE) try {
          return $defineProperty(O, P, Attributes);
        } catch (error) {
        }
        if ("get" in Attributes || "set" in Attributes) throw new $TypeError("Accessors not supported");
        if ("value" in Attributes) O[P] = Attributes.value;
        return O;
      };
    }
  });

  // node_modules/core-js/internals/create-non-enumerable-property.js
  var require_create_non_enumerable_property = __commonJS({
    "node_modules/core-js/internals/create-non-enumerable-property.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var DESCRIPTORS = require_descriptors();
      var definePropertyModule = require_object_define_property();
      var createPropertyDescriptor = require_create_property_descriptor();
      module.exports = DESCRIPTORS ? function(object, key, value) {
        return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
      } : function(object, key, value) {
        object[key] = value;
        return object;
      };
    }
  });

  // node_modules/core-js/internals/function-name.js
  var require_function_name = __commonJS({
    "node_modules/core-js/internals/function-name.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var DESCRIPTORS = require_descriptors();
      var hasOwn = require_has_own_property();
      var FunctionPrototype = Function.prototype;
      var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;
      var EXISTS = hasOwn(FunctionPrototype, "name");
      var PROPER = EXISTS && function something() {
      }.name === "something";
      var CONFIGURABLE = EXISTS && (!DESCRIPTORS || DESCRIPTORS && getDescriptor(FunctionPrototype, "name").configurable);
      module.exports = {
        EXISTS,
        PROPER,
        CONFIGURABLE
      };
    }
  });

  // node_modules/core-js/internals/inspect-source.js
  var require_inspect_source = __commonJS({
    "node_modules/core-js/internals/inspect-source.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var uncurryThis = require_function_uncurry_this();
      var isCallable = require_is_callable();
      var store = require_shared_store();
      var functionToString = uncurryThis(Function.toString);
      if (!isCallable(store.inspectSource)) {
        store.inspectSource = function(it) {
          return functionToString(it);
        };
      }
      module.exports = store.inspectSource;
    }
  });

  // node_modules/core-js/internals/weak-map-basic-detection.js
  var require_weak_map_basic_detection = __commonJS({
    "node_modules/core-js/internals/weak-map-basic-detection.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var global2 = require_global();
      var isCallable = require_is_callable();
      var WeakMap2 = global2.WeakMap;
      module.exports = isCallable(WeakMap2) && /native code/.test(String(WeakMap2));
    }
  });

  // node_modules/core-js/internals/shared-key.js
  var require_shared_key = __commonJS({
    "node_modules/core-js/internals/shared-key.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var shared = require_shared();
      var uid = require_uid();
      var keys = shared("keys");
      module.exports = function(key) {
        return keys[key] || (keys[key] = uid(key));
      };
    }
  });

  // node_modules/core-js/internals/hidden-keys.js
  var require_hidden_keys = __commonJS({
    "node_modules/core-js/internals/hidden-keys.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      module.exports = {};
    }
  });

  // node_modules/core-js/internals/internal-state.js
  var require_internal_state = __commonJS({
    "node_modules/core-js/internals/internal-state.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var NATIVE_WEAK_MAP = require_weak_map_basic_detection();
      var global2 = require_global();
      var isObject2 = require_is_object();
      var createNonEnumerableProperty = require_create_non_enumerable_property();
      var hasOwn = require_has_own_property();
      var shared = require_shared_store();
      var sharedKey = require_shared_key();
      var hiddenKeys = require_hidden_keys();
      var OBJECT_ALREADY_INITIALIZED = "Object already initialized";
      var TypeError2 = global2.TypeError;
      var WeakMap2 = global2.WeakMap;
      var set2;
      var get2;
      var has;
      var enforce = function(it) {
        return has(it) ? get2(it) : set2(it, {});
      };
      var getterFor = function(TYPE) {
        return function(it) {
          var state;
          if (!isObject2(it) || (state = get2(it)).type !== TYPE) {
            throw new TypeError2("Incompatible receiver, " + TYPE + " required");
          }
          return state;
        };
      };
      if (NATIVE_WEAK_MAP || shared.state) {
        store = shared.state || (shared.state = new WeakMap2());
        store.get = store.get;
        store.has = store.has;
        store.set = store.set;
        set2 = function(it, metadata) {
          if (store.has(it)) throw new TypeError2(OBJECT_ALREADY_INITIALIZED);
          metadata.facade = it;
          store.set(it, metadata);
          return metadata;
        };
        get2 = function(it) {
          return store.get(it) || {};
        };
        has = function(it) {
          return store.has(it);
        };
      } else {
        STATE = sharedKey("state");
        hiddenKeys[STATE] = true;
        set2 = function(it, metadata) {
          if (hasOwn(it, STATE)) throw new TypeError2(OBJECT_ALREADY_INITIALIZED);
          metadata.facade = it;
          createNonEnumerableProperty(it, STATE, metadata);
          return metadata;
        };
        get2 = function(it) {
          return hasOwn(it, STATE) ? it[STATE] : {};
        };
        has = function(it) {
          return hasOwn(it, STATE);
        };
      }
      var store;
      var STATE;
      module.exports = {
        set: set2,
        get: get2,
        has,
        enforce,
        getterFor
      };
    }
  });

  // node_modules/core-js/internals/make-built-in.js
  var require_make_built_in = __commonJS({
    "node_modules/core-js/internals/make-built-in.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var uncurryThis = require_function_uncurry_this();
      var fails = require_fails();
      var isCallable = require_is_callable();
      var hasOwn = require_has_own_property();
      var DESCRIPTORS = require_descriptors();
      var CONFIGURABLE_FUNCTION_NAME = require_function_name().CONFIGURABLE;
      var inspectSource = require_inspect_source();
      var InternalStateModule = require_internal_state();
      var enforceInternalState = InternalStateModule.enforce;
      var getInternalState = InternalStateModule.get;
      var $String = String;
      var defineProperty = Object.defineProperty;
      var stringSlice = uncurryThis("".slice);
      var replace = uncurryThis("".replace);
      var join = uncurryThis([].join);
      var CONFIGURABLE_LENGTH = DESCRIPTORS && !fails(function() {
        return defineProperty(function() {
        }, "length", { value: 8 }).length !== 8;
      });
      var TEMPLATE = String(String).split("String");
      var makeBuiltIn = module.exports = function(value, name2, options) {
        if (stringSlice($String(name2), 0, 7) === "Symbol(") {
          name2 = "[" + replace($String(name2), /^Symbol\(([^)]*)\).*$/, "$1") + "]";
        }
        if (options && options.getter) name2 = "get " + name2;
        if (options && options.setter) name2 = "set " + name2;
        if (!hasOwn(value, "name") || CONFIGURABLE_FUNCTION_NAME && value.name !== name2) {
          if (DESCRIPTORS) defineProperty(value, "name", { value: name2, configurable: true });
          else value.name = name2;
        }
        if (CONFIGURABLE_LENGTH && options && hasOwn(options, "arity") && value.length !== options.arity) {
          defineProperty(value, "length", { value: options.arity });
        }
        try {
          if (options && hasOwn(options, "constructor") && options.constructor) {
            if (DESCRIPTORS) defineProperty(value, "prototype", { writable: false });
          } else if (value.prototype) value.prototype = void 0;
        } catch (error) {
        }
        var state = enforceInternalState(value);
        if (!hasOwn(state, "source")) {
          state.source = join(TEMPLATE, typeof name2 == "string" ? name2 : "");
        }
        return value;
      };
      Function.prototype.toString = makeBuiltIn(function toString() {
        return isCallable(this) && getInternalState(this).source || inspectSource(this);
      }, "toString");
    }
  });

  // node_modules/core-js/internals/define-built-in.js
  var require_define_built_in = __commonJS({
    "node_modules/core-js/internals/define-built-in.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var isCallable = require_is_callable();
      var definePropertyModule = require_object_define_property();
      var makeBuiltIn = require_make_built_in();
      var defineGlobalProperty = require_define_global_property();
      module.exports = function(O, key, value, options) {
        if (!options) options = {};
        var simple = options.enumerable;
        var name2 = options.name !== void 0 ? options.name : key;
        if (isCallable(value)) makeBuiltIn(value, name2, options);
        if (options.global) {
          if (simple) O[key] = value;
          else defineGlobalProperty(key, value);
        } else {
          try {
            if (!options.unsafe) delete O[key];
            else if (O[key]) simple = true;
          } catch (error) {
          }
          if (simple) O[key] = value;
          else definePropertyModule.f(O, key, {
            value,
            enumerable: false,
            configurable: !options.nonConfigurable,
            writable: !options.nonWritable
          });
        }
        return O;
      };
    }
  });

  // node_modules/core-js/internals/math-trunc.js
  var require_math_trunc = __commonJS({
    "node_modules/core-js/internals/math-trunc.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var ceil = Math.ceil;
      var floor = Math.floor;
      module.exports = Math.trunc || function trunc(x) {
        var n = +x;
        return (n > 0 ? floor : ceil)(n);
      };
    }
  });

  // node_modules/core-js/internals/to-integer-or-infinity.js
  var require_to_integer_or_infinity = __commonJS({
    "node_modules/core-js/internals/to-integer-or-infinity.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var trunc = require_math_trunc();
      module.exports = function(argument) {
        var number = +argument;
        return number !== number || number === 0 ? 0 : trunc(number);
      };
    }
  });

  // node_modules/core-js/internals/to-absolute-index.js
  var require_to_absolute_index = __commonJS({
    "node_modules/core-js/internals/to-absolute-index.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var max = Math.max;
      var min = Math.min;
      module.exports = function(index, length) {
        var integer = toIntegerOrInfinity(index);
        return integer < 0 ? max(integer + length, 0) : min(integer, length);
      };
    }
  });

  // node_modules/core-js/internals/to-length.js
  var require_to_length = __commonJS({
    "node_modules/core-js/internals/to-length.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var min = Math.min;
      module.exports = function(argument) {
        var len = toIntegerOrInfinity(argument);
        return len > 0 ? min(len, 9007199254740991) : 0;
      };
    }
  });

  // node_modules/core-js/internals/length-of-array-like.js
  var require_length_of_array_like = __commonJS({
    "node_modules/core-js/internals/length-of-array-like.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var toLength = require_to_length();
      module.exports = function(obj) {
        return toLength(obj.length);
      };
    }
  });

  // node_modules/core-js/internals/array-includes.js
  var require_array_includes = __commonJS({
    "node_modules/core-js/internals/array-includes.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var toIndexedObject = require_to_indexed_object();
      var toAbsoluteIndex = require_to_absolute_index();
      var lengthOfArrayLike = require_length_of_array_like();
      var createMethod = function(IS_INCLUDES) {
        return function($this, el, fromIndex) {
          var O = toIndexedObject($this);
          var length = lengthOfArrayLike(O);
          if (length === 0) return !IS_INCLUDES && -1;
          var index = toAbsoluteIndex(fromIndex, length);
          var value;
          if (IS_INCLUDES && el !== el) while (length > index) {
            value = O[index++];
            if (value !== value) return true;
          }
          else for (; length > index; index++) {
            if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
          }
          return !IS_INCLUDES && -1;
        };
      };
      module.exports = {
        // `Array.prototype.includes` method
        // https://tc39.es/ecma262/#sec-array.prototype.includes
        includes: createMethod(true),
        // `Array.prototype.indexOf` method
        // https://tc39.es/ecma262/#sec-array.prototype.indexof
        indexOf: createMethod(false)
      };
    }
  });

  // node_modules/core-js/internals/object-keys-internal.js
  var require_object_keys_internal = __commonJS({
    "node_modules/core-js/internals/object-keys-internal.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var uncurryThis = require_function_uncurry_this();
      var hasOwn = require_has_own_property();
      var toIndexedObject = require_to_indexed_object();
      var indexOf = require_array_includes().indexOf;
      var hiddenKeys = require_hidden_keys();
      var push = uncurryThis([].push);
      module.exports = function(object, names) {
        var O = toIndexedObject(object);
        var i = 0;
        var result = [];
        var key;
        for (key in O) !hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);
        while (names.length > i) if (hasOwn(O, key = names[i++])) {
          ~indexOf(result, key) || push(result, key);
        }
        return result;
      };
    }
  });

  // node_modules/core-js/internals/enum-bug-keys.js
  var require_enum_bug_keys = __commonJS({
    "node_modules/core-js/internals/enum-bug-keys.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      module.exports = [
        "constructor",
        "hasOwnProperty",
        "isPrototypeOf",
        "propertyIsEnumerable",
        "toLocaleString",
        "toString",
        "valueOf"
      ];
    }
  });

  // node_modules/core-js/internals/object-get-own-property-names.js
  var require_object_get_own_property_names = __commonJS({
    "node_modules/core-js/internals/object-get-own-property-names.js"(exports) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var internalObjectKeys = require_object_keys_internal();
      var enumBugKeys = require_enum_bug_keys();
      var hiddenKeys = enumBugKeys.concat("length", "prototype");
      exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
        return internalObjectKeys(O, hiddenKeys);
      };
    }
  });

  // node_modules/core-js/internals/object-get-own-property-symbols.js
  var require_object_get_own_property_symbols = __commonJS({
    "node_modules/core-js/internals/object-get-own-property-symbols.js"(exports) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      exports.f = Object.getOwnPropertySymbols;
    }
  });

  // node_modules/core-js/internals/own-keys.js
  var require_own_keys = __commonJS({
    "node_modules/core-js/internals/own-keys.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var getBuiltIn = require_get_built_in();
      var uncurryThis = require_function_uncurry_this();
      var getOwnPropertyNamesModule = require_object_get_own_property_names();
      var getOwnPropertySymbolsModule = require_object_get_own_property_symbols();
      var anObject = require_an_object();
      var concat2 = uncurryThis([].concat);
      module.exports = getBuiltIn("Reflect", "ownKeys") || function ownKeys(it) {
        var keys = getOwnPropertyNamesModule.f(anObject(it));
        var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
        return getOwnPropertySymbols ? concat2(keys, getOwnPropertySymbols(it)) : keys;
      };
    }
  });

  // node_modules/core-js/internals/copy-constructor-properties.js
  var require_copy_constructor_properties = __commonJS({
    "node_modules/core-js/internals/copy-constructor-properties.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var hasOwn = require_has_own_property();
      var ownKeys = require_own_keys();
      var getOwnPropertyDescriptorModule = require_object_get_own_property_descriptor();
      var definePropertyModule = require_object_define_property();
      module.exports = function(target, source, exceptions) {
        var keys = ownKeys(source);
        var defineProperty = definePropertyModule.f;
        var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {
            defineProperty(target, key, getOwnPropertyDescriptor(source, key));
          }
        }
      };
    }
  });

  // node_modules/core-js/internals/is-forced.js
  var require_is_forced = __commonJS({
    "node_modules/core-js/internals/is-forced.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var fails = require_fails();
      var isCallable = require_is_callable();
      var replacement = /#|\.prototype\./;
      var isForced = function(feature, detection) {
        var value = data2[normalize(feature)];
        return value === POLYFILL ? true : value === NATIVE ? false : isCallable(detection) ? fails(detection) : !!detection;
      };
      var normalize = isForced.normalize = function(string) {
        return String(string).replace(replacement, ".").toLowerCase();
      };
      var data2 = isForced.data = {};
      var NATIVE = isForced.NATIVE = "N";
      var POLYFILL = isForced.POLYFILL = "P";
      module.exports = isForced;
    }
  });

  // node_modules/core-js/internals/export.js
  var require_export = __commonJS({
    "node_modules/core-js/internals/export.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var global2 = require_global();
      var getOwnPropertyDescriptor = require_object_get_own_property_descriptor().f;
      var createNonEnumerableProperty = require_create_non_enumerable_property();
      var defineBuiltIn = require_define_built_in();
      var defineGlobalProperty = require_define_global_property();
      var copyConstructorProperties = require_copy_constructor_properties();
      var isForced = require_is_forced();
      module.exports = function(options, source) {
        var TARGET = options.target;
        var GLOBAL = options.global;
        var STATIC = options.stat;
        var FORCED, target, key, targetProperty, sourceProperty, descriptor;
        if (GLOBAL) {
          target = global2;
        } else if (STATIC) {
          target = global2[TARGET] || defineGlobalProperty(TARGET, {});
        } else {
          target = global2[TARGET] && global2[TARGET].prototype;
        }
        if (target) for (key in source) {
          sourceProperty = source[key];
          if (options.dontCallGetSet) {
            descriptor = getOwnPropertyDescriptor(target, key);
            targetProperty = descriptor && descriptor.value;
          } else targetProperty = target[key];
          FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
          if (!FORCED && targetProperty !== void 0) {
            if (typeof sourceProperty == typeof targetProperty) continue;
            copyConstructorProperties(sourceProperty, targetProperty);
          }
          if (options.sham || targetProperty && targetProperty.sham) {
            createNonEnumerableProperty(sourceProperty, "sham", true);
          }
          defineBuiltIn(target, key, sourceProperty, options);
        }
      };
    }
  });

  // node_modules/core-js/internals/to-string-tag-support.js
  var require_to_string_tag_support = __commonJS({
    "node_modules/core-js/internals/to-string-tag-support.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var wellKnownSymbol = require_well_known_symbol();
      var TO_STRING_TAG = wellKnownSymbol("toStringTag");
      var test = {};
      test[TO_STRING_TAG] = "z";
      module.exports = String(test) === "[object z]";
    }
  });

  // node_modules/core-js/internals/classof.js
  var require_classof = __commonJS({
    "node_modules/core-js/internals/classof.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var TO_STRING_TAG_SUPPORT = require_to_string_tag_support();
      var isCallable = require_is_callable();
      var classofRaw = require_classof_raw();
      var wellKnownSymbol = require_well_known_symbol();
      var TO_STRING_TAG = wellKnownSymbol("toStringTag");
      var $Object = Object;
      var CORRECT_ARGUMENTS = classofRaw(/* @__PURE__ */ function() {
        return arguments;
      }()) === "Arguments";
      var tryGet = function(it, key) {
        try {
          return it[key];
        } catch (error) {
        }
      };
      module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function(it) {
        var O, tag, result;
        return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) === "Object" && isCallable(O.callee) ? "Arguments" : result;
      };
    }
  });

  // node_modules/core-js/internals/to-string.js
  var require_to_string = __commonJS({
    "node_modules/core-js/internals/to-string.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var classof = require_classof();
      var $String = String;
      module.exports = function(argument) {
        if (classof(argument) === "Symbol") throw new TypeError("Cannot convert a Symbol value to a string");
        return $String(argument);
      };
    }
  });

  // node_modules/core-js/internals/object-keys.js
  var require_object_keys = __commonJS({
    "node_modules/core-js/internals/object-keys.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var internalObjectKeys = require_object_keys_internal();
      var enumBugKeys = require_enum_bug_keys();
      module.exports = Object.keys || function keys(O) {
        return internalObjectKeys(O, enumBugKeys);
      };
    }
  });

  // node_modules/core-js/internals/object-define-properties.js
  var require_object_define_properties = __commonJS({
    "node_modules/core-js/internals/object-define-properties.js"(exports) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var DESCRIPTORS = require_descriptors();
      var V8_PROTOTYPE_DEFINE_BUG = require_v8_prototype_define_bug();
      var definePropertyModule = require_object_define_property();
      var anObject = require_an_object();
      var toIndexedObject = require_to_indexed_object();
      var objectKeys = require_object_keys();
      exports.f = DESCRIPTORS && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {
        anObject(O);
        var props = toIndexedObject(Properties);
        var keys = objectKeys(Properties);
        var length = keys.length;
        var index = 0;
        var key;
        while (length > index) definePropertyModule.f(O, key = keys[index++], props[key]);
        return O;
      };
    }
  });

  // node_modules/core-js/internals/html.js
  var require_html = __commonJS({
    "node_modules/core-js/internals/html.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var getBuiltIn = require_get_built_in();
      module.exports = getBuiltIn("document", "documentElement");
    }
  });

  // node_modules/core-js/internals/object-create.js
  var require_object_create = __commonJS({
    "node_modules/core-js/internals/object-create.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var anObject = require_an_object();
      var definePropertiesModule = require_object_define_properties();
      var enumBugKeys = require_enum_bug_keys();
      var hiddenKeys = require_hidden_keys();
      var html = require_html();
      var documentCreateElement = require_document_create_element();
      var sharedKey = require_shared_key();
      var GT = ">";
      var LT = "<";
      var PROTOTYPE = "prototype";
      var SCRIPT = "script";
      var IE_PROTO = sharedKey("IE_PROTO");
      var EmptyConstructor = function() {
      };
      var scriptTag = function(content) {
        return LT + SCRIPT + GT + content + LT + "/" + SCRIPT + GT;
      };
      var NullProtoObjectViaActiveX = function(activeXDocument2) {
        activeXDocument2.write(scriptTag(""));
        activeXDocument2.close();
        var temp = activeXDocument2.parentWindow.Object;
        activeXDocument2 = null;
        return temp;
      };
      var NullProtoObjectViaIFrame = function() {
        var iframe = documentCreateElement("iframe");
        var JS = "java" + SCRIPT + ":";
        var iframeDocument;
        iframe.style.display = "none";
        html.appendChild(iframe);
        iframe.src = String(JS);
        iframeDocument = iframe.contentWindow.document;
        iframeDocument.open();
        iframeDocument.write(scriptTag("document.F=Object"));
        iframeDocument.close();
        return iframeDocument.F;
      };
      var activeXDocument;
      var NullProtoObject = function() {
        try {
          activeXDocument = new ActiveXObject("htmlfile");
        } catch (error) {
        }
        NullProtoObject = typeof document != "undefined" ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument);
        var length = enumBugKeys.length;
        while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
        return NullProtoObject();
      };
      hiddenKeys[IE_PROTO] = true;
      module.exports = Object.create || function create(O, Properties) {
        var result;
        if (O !== null) {
          EmptyConstructor[PROTOTYPE] = anObject(O);
          result = new EmptyConstructor();
          EmptyConstructor[PROTOTYPE] = null;
          result[IE_PROTO] = O;
        } else result = NullProtoObject();
        return Properties === void 0 ? result : definePropertiesModule.f(result, Properties);
      };
    }
  });

  // node_modules/core-js/internals/array-slice.js
  var require_array_slice = __commonJS({
    "node_modules/core-js/internals/array-slice.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var uncurryThis = require_function_uncurry_this();
      module.exports = uncurryThis([].slice);
    }
  });

  // node_modules/core-js/internals/object-get-own-property-names-external.js
  var require_object_get_own_property_names_external = __commonJS({
    "node_modules/core-js/internals/object-get-own-property-names-external.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var classof = require_classof_raw();
      var toIndexedObject = require_to_indexed_object();
      var $getOwnPropertyNames = require_object_get_own_property_names().f;
      var arraySlice2 = require_array_slice();
      var windowNames = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
      var getWindowNames = function(it) {
        try {
          return $getOwnPropertyNames(it);
        } catch (error) {
          return arraySlice2(windowNames);
        }
      };
      module.exports.f = function getOwnPropertyNames(it) {
        return windowNames && classof(it) === "Window" ? getWindowNames(it) : $getOwnPropertyNames(toIndexedObject(it));
      };
    }
  });

  // node_modules/core-js/internals/define-built-in-accessor.js
  var require_define_built_in_accessor = __commonJS({
    "node_modules/core-js/internals/define-built-in-accessor.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var makeBuiltIn = require_make_built_in();
      var defineProperty = require_object_define_property();
      module.exports = function(target, name2, descriptor) {
        if (descriptor.get) makeBuiltIn(descriptor.get, name2, { getter: true });
        if (descriptor.set) makeBuiltIn(descriptor.set, name2, { setter: true });
        return defineProperty.f(target, name2, descriptor);
      };
    }
  });

  // node_modules/core-js/internals/well-known-symbol-wrapped.js
  var require_well_known_symbol_wrapped = __commonJS({
    "node_modules/core-js/internals/well-known-symbol-wrapped.js"(exports) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var wellKnownSymbol = require_well_known_symbol();
      exports.f = wellKnownSymbol;
    }
  });

  // node_modules/core-js/internals/path.js
  var require_path = __commonJS({
    "node_modules/core-js/internals/path.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var global2 = require_global();
      module.exports = global2;
    }
  });

  // node_modules/core-js/internals/well-known-symbol-define.js
  var require_well_known_symbol_define = __commonJS({
    "node_modules/core-js/internals/well-known-symbol-define.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var path = require_path();
      var hasOwn = require_has_own_property();
      var wrappedWellKnownSymbolModule = require_well_known_symbol_wrapped();
      var defineProperty = require_object_define_property().f;
      module.exports = function(NAME) {
        var Symbol2 = path.Symbol || (path.Symbol = {});
        if (!hasOwn(Symbol2, NAME)) defineProperty(Symbol2, NAME, {
          value: wrappedWellKnownSymbolModule.f(NAME)
        });
      };
    }
  });

  // node_modules/core-js/internals/symbol-define-to-primitive.js
  var require_symbol_define_to_primitive = __commonJS({
    "node_modules/core-js/internals/symbol-define-to-primitive.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var call = require_function_call();
      var getBuiltIn = require_get_built_in();
      var wellKnownSymbol = require_well_known_symbol();
      var defineBuiltIn = require_define_built_in();
      module.exports = function() {
        var Symbol2 = getBuiltIn("Symbol");
        var SymbolPrototype = Symbol2 && Symbol2.prototype;
        var valueOf = SymbolPrototype && SymbolPrototype.valueOf;
        var TO_PRIMITIVE = wellKnownSymbol("toPrimitive");
        if (SymbolPrototype && !SymbolPrototype[TO_PRIMITIVE]) {
          defineBuiltIn(SymbolPrototype, TO_PRIMITIVE, function(hint) {
            return call(valueOf, this);
          }, { arity: 1 });
        }
      };
    }
  });

  // node_modules/core-js/internals/set-to-string-tag.js
  var require_set_to_string_tag = __commonJS({
    "node_modules/core-js/internals/set-to-string-tag.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var defineProperty = require_object_define_property().f;
      var hasOwn = require_has_own_property();
      var wellKnownSymbol = require_well_known_symbol();
      var TO_STRING_TAG = wellKnownSymbol("toStringTag");
      module.exports = function(target, TAG, STATIC) {
        if (target && !STATIC) target = target.prototype;
        if (target && !hasOwn(target, TO_STRING_TAG)) {
          defineProperty(target, TO_STRING_TAG, { configurable: true, value: TAG });
        }
      };
    }
  });

  // node_modules/core-js/internals/function-uncurry-this-clause.js
  var require_function_uncurry_this_clause = __commonJS({
    "node_modules/core-js/internals/function-uncurry-this-clause.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var classofRaw = require_classof_raw();
      var uncurryThis = require_function_uncurry_this();
      module.exports = function(fn) {
        if (classofRaw(fn) === "Function") return uncurryThis(fn);
      };
    }
  });

  // node_modules/core-js/internals/function-bind-context.js
  var require_function_bind_context = __commonJS({
    "node_modules/core-js/internals/function-bind-context.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var uncurryThis = require_function_uncurry_this_clause();
      var aCallable = require_a_callable();
      var NATIVE_BIND = require_function_bind_native();
      var bind = uncurryThis(uncurryThis.bind);
      module.exports = function(fn, that) {
        aCallable(fn);
        return that === void 0 ? fn : NATIVE_BIND ? bind(fn, that) : function() {
          return fn.apply(that, arguments);
        };
      };
    }
  });

  // node_modules/core-js/internals/is-array.js
  var require_is_array = __commonJS({
    "node_modules/core-js/internals/is-array.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var classof = require_classof_raw();
      module.exports = Array.isArray || function isArray(argument) {
        return classof(argument) === "Array";
      };
    }
  });

  // node_modules/core-js/internals/is-constructor.js
  var require_is_constructor = __commonJS({
    "node_modules/core-js/internals/is-constructor.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var uncurryThis = require_function_uncurry_this();
      var fails = require_fails();
      var isCallable = require_is_callable();
      var classof = require_classof();
      var getBuiltIn = require_get_built_in();
      var inspectSource = require_inspect_source();
      var noop = function() {
      };
      var construct = getBuiltIn("Reflect", "construct");
      var constructorRegExp = /^\s*(?:class|function)\b/;
      var exec = uncurryThis(constructorRegExp.exec);
      var INCORRECT_TO_STRING = !constructorRegExp.test(noop);
      var isConstructorModern = function isConstructor(argument) {
        if (!isCallable(argument)) return false;
        try {
          construct(noop, [], argument);
          return true;
        } catch (error) {
          return false;
        }
      };
      var isConstructorLegacy = function isConstructor(argument) {
        if (!isCallable(argument)) return false;
        switch (classof(argument)) {
          case "AsyncFunction":
          case "GeneratorFunction":
          case "AsyncGeneratorFunction":
            return false;
        }
        try {
          return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource(argument));
        } catch (error) {
          return true;
        }
      };
      isConstructorLegacy.sham = true;
      module.exports = !construct || fails(function() {
        var called;
        return isConstructorModern(isConstructorModern.call) || !isConstructorModern(Object) || !isConstructorModern(function() {
          called = true;
        }) || called;
      }) ? isConstructorLegacy : isConstructorModern;
    }
  });

  // node_modules/core-js/internals/array-species-constructor.js
  var require_array_species_constructor = __commonJS({
    "node_modules/core-js/internals/array-species-constructor.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var isArray = require_is_array();
      var isConstructor = require_is_constructor();
      var isObject2 = require_is_object();
      var wellKnownSymbol = require_well_known_symbol();
      var SPECIES = wellKnownSymbol("species");
      var $Array = Array;
      module.exports = function(originalArray) {
        var C;
        if (isArray(originalArray)) {
          C = originalArray.constructor;
          if (isConstructor(C) && (C === $Array || isArray(C.prototype))) C = void 0;
          else if (isObject2(C)) {
            C = C[SPECIES];
            if (C === null) C = void 0;
          }
        }
        return C === void 0 ? $Array : C;
      };
    }
  });

  // node_modules/core-js/internals/array-species-create.js
  var require_array_species_create = __commonJS({
    "node_modules/core-js/internals/array-species-create.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var arraySpeciesConstructor = require_array_species_constructor();
      module.exports = function(originalArray, length) {
        return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);
      };
    }
  });

  // node_modules/core-js/internals/array-iteration.js
  var require_array_iteration = __commonJS({
    "node_modules/core-js/internals/array-iteration.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var bind = require_function_bind_context();
      var uncurryThis = require_function_uncurry_this();
      var IndexedObject = require_indexed_object();
      var toObject = require_to_object();
      var lengthOfArrayLike = require_length_of_array_like();
      var arraySpeciesCreate = require_array_species_create();
      var push = uncurryThis([].push);
      var createMethod = function(TYPE) {
        var IS_MAP = TYPE === 1;
        var IS_FILTER = TYPE === 2;
        var IS_SOME = TYPE === 3;
        var IS_EVERY = TYPE === 4;
        var IS_FIND_INDEX = TYPE === 6;
        var IS_FILTER_REJECT = TYPE === 7;
        var NO_HOLES = TYPE === 5 || IS_FIND_INDEX;
        return function($this, callbackfn, that, specificCreate) {
          var O = toObject($this);
          var self2 = IndexedObject(O);
          var length = lengthOfArrayLike(self2);
          var boundFunction = bind(callbackfn, that);
          var index = 0;
          var create = specificCreate || arraySpeciesCreate;
          var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_REJECT ? create($this, 0) : void 0;
          var value, result;
          for (; length > index; index++) if (NO_HOLES || index in self2) {
            value = self2[index];
            result = boundFunction(value, index, O);
            if (TYPE) {
              if (IS_MAP) target[index] = result;
              else if (result) switch (TYPE) {
                case 3:
                  return true;
                case 5:
                  return value;
                case 6:
                  return index;
                case 2:
                  push(target, value);
              }
              else switch (TYPE) {
                case 4:
                  return false;
                case 7:
                  push(target, value);
              }
            }
          }
          return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
        };
      };
      module.exports = {
        // `Array.prototype.forEach` method
        // https://tc39.es/ecma262/#sec-array.prototype.foreach
        forEach: createMethod(0),
        // `Array.prototype.map` method
        // https://tc39.es/ecma262/#sec-array.prototype.map
        map: createMethod(1),
        // `Array.prototype.filter` method
        // https://tc39.es/ecma262/#sec-array.prototype.filter
        filter: createMethod(2),
        // `Array.prototype.some` method
        // https://tc39.es/ecma262/#sec-array.prototype.some
        some: createMethod(3),
        // `Array.prototype.every` method
        // https://tc39.es/ecma262/#sec-array.prototype.every
        every: createMethod(4),
        // `Array.prototype.find` method
        // https://tc39.es/ecma262/#sec-array.prototype.find
        find: createMethod(5),
        // `Array.prototype.findIndex` method
        // https://tc39.es/ecma262/#sec-array.prototype.findIndex
        findIndex: createMethod(6),
        // `Array.prototype.filterReject` method
        // https://github.com/tc39/proposal-array-filtering
        filterReject: createMethod(7)
      };
    }
  });

  // node_modules/core-js/modules/es.symbol.constructor.js
  var require_es_symbol_constructor = __commonJS({
    "node_modules/core-js/modules/es.symbol.constructor.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var global2 = require_global();
      var call = require_function_call();
      var uncurryThis = require_function_uncurry_this();
      var IS_PURE = require_is_pure();
      var DESCRIPTORS = require_descriptors();
      var NATIVE_SYMBOL = require_symbol_constructor_detection();
      var fails = require_fails();
      var hasOwn = require_has_own_property();
      var isPrototypeOf = require_object_is_prototype_of();
      var anObject = require_an_object();
      var toIndexedObject = require_to_indexed_object();
      var toPropertyKey = require_to_property_key();
      var $toString = require_to_string();
      var createPropertyDescriptor = require_create_property_descriptor();
      var nativeObjectCreate = require_object_create();
      var objectKeys = require_object_keys();
      var getOwnPropertyNamesModule = require_object_get_own_property_names();
      var getOwnPropertyNamesExternal = require_object_get_own_property_names_external();
      var getOwnPropertySymbolsModule = require_object_get_own_property_symbols();
      var getOwnPropertyDescriptorModule = require_object_get_own_property_descriptor();
      var definePropertyModule = require_object_define_property();
      var definePropertiesModule = require_object_define_properties();
      var propertyIsEnumerableModule = require_object_property_is_enumerable();
      var defineBuiltIn = require_define_built_in();
      var defineBuiltInAccessor = require_define_built_in_accessor();
      var shared = require_shared();
      var sharedKey = require_shared_key();
      var hiddenKeys = require_hidden_keys();
      var uid = require_uid();
      var wellKnownSymbol = require_well_known_symbol();
      var wrappedWellKnownSymbolModule = require_well_known_symbol_wrapped();
      var defineWellKnownSymbol = require_well_known_symbol_define();
      var defineSymbolToPrimitive = require_symbol_define_to_primitive();
      var setToStringTag = require_set_to_string_tag();
      var InternalStateModule = require_internal_state();
      var $forEach = require_array_iteration().forEach;
      var HIDDEN = sharedKey("hidden");
      var SYMBOL = "Symbol";
      var PROTOTYPE = "prototype";
      var setInternalState = InternalStateModule.set;
      var getInternalState = InternalStateModule.getterFor(SYMBOL);
      var ObjectPrototype = Object[PROTOTYPE];
      var $Symbol = global2.Symbol;
      var SymbolPrototype = $Symbol && $Symbol[PROTOTYPE];
      var RangeError2 = global2.RangeError;
      var TypeError2 = global2.TypeError;
      var QObject = global2.QObject;
      var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
      var nativeDefineProperty = definePropertyModule.f;
      var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;
      var nativePropertyIsEnumerable = propertyIsEnumerableModule.f;
      var push = uncurryThis([].push);
      var AllSymbols = shared("symbols");
      var ObjectPrototypeSymbols = shared("op-symbols");
      var WellKnownSymbolsStore = shared("wks");
      var USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
      var fallbackDefineProperty = function(O, P, Attributes) {
        var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor(ObjectPrototype, P);
        if (ObjectPrototypeDescriptor) delete ObjectPrototype[P];
        nativeDefineProperty(O, P, Attributes);
        if (ObjectPrototypeDescriptor && O !== ObjectPrototype) {
          nativeDefineProperty(ObjectPrototype, P, ObjectPrototypeDescriptor);
        }
      };
      var setSymbolDescriptor = DESCRIPTORS && fails(function() {
        return nativeObjectCreate(nativeDefineProperty({}, "a", {
          get: function() {
            return nativeDefineProperty(this, "a", { value: 7 }).a;
          }
        })).a !== 7;
      }) ? fallbackDefineProperty : nativeDefineProperty;
      var wrap = function(tag, description) {
        var symbol = AllSymbols[tag] = nativeObjectCreate(SymbolPrototype);
        setInternalState(symbol, {
          type: SYMBOL,
          tag,
          description
        });
        if (!DESCRIPTORS) symbol.description = description;
        return symbol;
      };
      var $defineProperty = function defineProperty(O, P, Attributes) {
        if (O === ObjectPrototype) $defineProperty(ObjectPrototypeSymbols, P, Attributes);
        anObject(O);
        var key = toPropertyKey(P);
        anObject(Attributes);
        if (hasOwn(AllSymbols, key)) {
          if (!Attributes.enumerable) {
            if (!hasOwn(O, HIDDEN)) nativeDefineProperty(O, HIDDEN, createPropertyDescriptor(1, nativeObjectCreate(null)));
            O[HIDDEN][key] = true;
          } else {
            if (hasOwn(O, HIDDEN) && O[HIDDEN][key]) O[HIDDEN][key] = false;
            Attributes = nativeObjectCreate(Attributes, { enumerable: createPropertyDescriptor(0, false) });
          }
          return setSymbolDescriptor(O, key, Attributes);
        }
        return nativeDefineProperty(O, key, Attributes);
      };
      var $defineProperties = function defineProperties(O, Properties) {
        anObject(O);
        var properties = toIndexedObject(Properties);
        var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));
        $forEach(keys, function(key) {
          if (!DESCRIPTORS || call($propertyIsEnumerable, properties, key)) $defineProperty(O, key, properties[key]);
        });
        return O;
      };
      var $create = function create(O, Properties) {
        return Properties === void 0 ? nativeObjectCreate(O) : $defineProperties(nativeObjectCreate(O), Properties);
      };
      var $propertyIsEnumerable = function propertyIsEnumerable(V) {
        var P = toPropertyKey(V);
        var enumerable = call(nativePropertyIsEnumerable, this, P);
        if (this === ObjectPrototype && hasOwn(AllSymbols, P) && !hasOwn(ObjectPrototypeSymbols, P)) return false;
        return enumerable || !hasOwn(this, P) || !hasOwn(AllSymbols, P) || hasOwn(this, HIDDEN) && this[HIDDEN][P] ? enumerable : true;
      };
      var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {
        var it = toIndexedObject(O);
        var key = toPropertyKey(P);
        if (it === ObjectPrototype && hasOwn(AllSymbols, key) && !hasOwn(ObjectPrototypeSymbols, key)) return;
        var descriptor = nativeGetOwnPropertyDescriptor(it, key);
        if (descriptor && hasOwn(AllSymbols, key) && !(hasOwn(it, HIDDEN) && it[HIDDEN][key])) {
          descriptor.enumerable = true;
        }
        return descriptor;
      };
      var $getOwnPropertyNames = function getOwnPropertyNames(O) {
        var names = nativeGetOwnPropertyNames(toIndexedObject(O));
        var result = [];
        $forEach(names, function(key) {
          if (!hasOwn(AllSymbols, key) && !hasOwn(hiddenKeys, key)) push(result, key);
        });
        return result;
      };
      var $getOwnPropertySymbols = function(O) {
        var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;
        var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));
        var result = [];
        $forEach(names, function(key) {
          if (hasOwn(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || hasOwn(ObjectPrototype, key))) {
            push(result, AllSymbols[key]);
          }
        });
        return result;
      };
      if (!NATIVE_SYMBOL) {
        $Symbol = function Symbol2() {
          if (isPrototypeOf(SymbolPrototype, this)) throw new TypeError2("Symbol is not a constructor");
          var description = !arguments.length || arguments[0] === void 0 ? void 0 : $toString(arguments[0]);
          var tag = uid(description);
          var setter = function(value) {
            var $this = this === void 0 ? global2 : this;
            if ($this === ObjectPrototype) call(setter, ObjectPrototypeSymbols, value);
            if (hasOwn($this, HIDDEN) && hasOwn($this[HIDDEN], tag)) $this[HIDDEN][tag] = false;
            var descriptor = createPropertyDescriptor(1, value);
            try {
              setSymbolDescriptor($this, tag, descriptor);
            } catch (error) {
              if (!(error instanceof RangeError2)) throw error;
              fallbackDefineProperty($this, tag, descriptor);
            }
          };
          if (DESCRIPTORS && USE_SETTER) setSymbolDescriptor(ObjectPrototype, tag, { configurable: true, set: setter });
          return wrap(tag, description);
        };
        SymbolPrototype = $Symbol[PROTOTYPE];
        defineBuiltIn(SymbolPrototype, "toString", function toString() {
          return getInternalState(this).tag;
        });
        defineBuiltIn($Symbol, "withoutSetter", function(description) {
          return wrap(uid(description), description);
        });
        propertyIsEnumerableModule.f = $propertyIsEnumerable;
        definePropertyModule.f = $defineProperty;
        definePropertiesModule.f = $defineProperties;
        getOwnPropertyDescriptorModule.f = $getOwnPropertyDescriptor;
        getOwnPropertyNamesModule.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;
        getOwnPropertySymbolsModule.f = $getOwnPropertySymbols;
        wrappedWellKnownSymbolModule.f = function(name2) {
          return wrap(wellKnownSymbol(name2), name2);
        };
        if (DESCRIPTORS) {
          defineBuiltInAccessor(SymbolPrototype, "description", {
            configurable: true,
            get: function description() {
              return getInternalState(this).description;
            }
          });
          if (!IS_PURE) {
            defineBuiltIn(ObjectPrototype, "propertyIsEnumerable", $propertyIsEnumerable, { unsafe: true });
          }
        }
      }
      $({ global: true, constructor: true, wrap: true, forced: !NATIVE_SYMBOL, sham: !NATIVE_SYMBOL }, {
        Symbol: $Symbol
      });
      $forEach(objectKeys(WellKnownSymbolsStore), function(name2) {
        defineWellKnownSymbol(name2);
      });
      $({ target: SYMBOL, stat: true, forced: !NATIVE_SYMBOL }, {
        useSetter: function() {
          USE_SETTER = true;
        },
        useSimple: function() {
          USE_SETTER = false;
        }
      });
      $({ target: "Object", stat: true, forced: !NATIVE_SYMBOL, sham: !DESCRIPTORS }, {
        // `Object.create` method
        // https://tc39.es/ecma262/#sec-object.create
        create: $create,
        // `Object.defineProperty` method
        // https://tc39.es/ecma262/#sec-object.defineproperty
        defineProperty: $defineProperty,
        // `Object.defineProperties` method
        // https://tc39.es/ecma262/#sec-object.defineproperties
        defineProperties: $defineProperties,
        // `Object.getOwnPropertyDescriptor` method
        // https://tc39.es/ecma262/#sec-object.getownpropertydescriptors
        getOwnPropertyDescriptor: $getOwnPropertyDescriptor
      });
      $({ target: "Object", stat: true, forced: !NATIVE_SYMBOL }, {
        // `Object.getOwnPropertyNames` method
        // https://tc39.es/ecma262/#sec-object.getownpropertynames
        getOwnPropertyNames: $getOwnPropertyNames
      });
      defineSymbolToPrimitive();
      setToStringTag($Symbol, SYMBOL);
      hiddenKeys[HIDDEN] = true;
    }
  });

  // node_modules/core-js/internals/symbol-registry-detection.js
  var require_symbol_registry_detection = __commonJS({
    "node_modules/core-js/internals/symbol-registry-detection.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var NATIVE_SYMBOL = require_symbol_constructor_detection();
      module.exports = NATIVE_SYMBOL && !!Symbol["for"] && !!Symbol.keyFor;
    }
  });

  // node_modules/core-js/modules/es.symbol.for.js
  var require_es_symbol_for = __commonJS({
    "node_modules/core-js/modules/es.symbol.for.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var getBuiltIn = require_get_built_in();
      var hasOwn = require_has_own_property();
      var toString = require_to_string();
      var shared = require_shared();
      var NATIVE_SYMBOL_REGISTRY = require_symbol_registry_detection();
      var StringToSymbolRegistry = shared("string-to-symbol-registry");
      var SymbolToStringRegistry = shared("symbol-to-string-registry");
      $({ target: "Symbol", stat: true, forced: !NATIVE_SYMBOL_REGISTRY }, {
        "for": function(key) {
          var string = toString(key);
          if (hasOwn(StringToSymbolRegistry, string)) return StringToSymbolRegistry[string];
          var symbol = getBuiltIn("Symbol")(string);
          StringToSymbolRegistry[string] = symbol;
          SymbolToStringRegistry[symbol] = string;
          return symbol;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.symbol.key-for.js
  var require_es_symbol_key_for = __commonJS({
    "node_modules/core-js/modules/es.symbol.key-for.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var hasOwn = require_has_own_property();
      var isSymbol = require_is_symbol();
      var tryToString = require_try_to_string();
      var shared = require_shared();
      var NATIVE_SYMBOL_REGISTRY = require_symbol_registry_detection();
      var SymbolToStringRegistry = shared("symbol-to-string-registry");
      $({ target: "Symbol", stat: true, forced: !NATIVE_SYMBOL_REGISTRY }, {
        keyFor: function keyFor(sym) {
          if (!isSymbol(sym)) throw new TypeError(tryToString(sym) + " is not a symbol");
          if (hasOwn(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym];
        }
      });
    }
  });

  // node_modules/core-js/internals/function-apply.js
  var require_function_apply = __commonJS({
    "node_modules/core-js/internals/function-apply.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var NATIVE_BIND = require_function_bind_native();
      var FunctionPrototype = Function.prototype;
      var apply = FunctionPrototype.apply;
      var call = FunctionPrototype.call;
      module.exports = typeof Reflect == "object" && Reflect.apply || (NATIVE_BIND ? call.bind(apply) : function() {
        return call.apply(apply, arguments);
      });
    }
  });

  // node_modules/core-js/internals/get-json-replacer-function.js
  var require_get_json_replacer_function = __commonJS({
    "node_modules/core-js/internals/get-json-replacer-function.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var uncurryThis = require_function_uncurry_this();
      var isArray = require_is_array();
      var isCallable = require_is_callable();
      var classof = require_classof_raw();
      var toString = require_to_string();
      var push = uncurryThis([].push);
      module.exports = function(replacer) {
        if (isCallable(replacer)) return replacer;
        if (!isArray(replacer)) return;
        var rawLength = replacer.length;
        var keys = [];
        for (var i = 0; i < rawLength; i++) {
          var element = replacer[i];
          if (typeof element == "string") push(keys, element);
          else if (typeof element == "number" || classof(element) === "Number" || classof(element) === "String") push(keys, toString(element));
        }
        var keysLength = keys.length;
        var root = true;
        return function(key, value) {
          if (root) {
            root = false;
            return value;
          }
          if (isArray(this)) return value;
          for (var j = 0; j < keysLength; j++) if (keys[j] === key) return value;
        };
      };
    }
  });

  // node_modules/core-js/modules/es.json.stringify.js
  var require_es_json_stringify = __commonJS({
    "node_modules/core-js/modules/es.json.stringify.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var getBuiltIn = require_get_built_in();
      var apply = require_function_apply();
      var call = require_function_call();
      var uncurryThis = require_function_uncurry_this();
      var fails = require_fails();
      var isCallable = require_is_callable();
      var isSymbol = require_is_symbol();
      var arraySlice2 = require_array_slice();
      var getReplacerFunction = require_get_json_replacer_function();
      var NATIVE_SYMBOL = require_symbol_constructor_detection();
      var $String = String;
      var $stringify = getBuiltIn("JSON", "stringify");
      var exec = uncurryThis(/./.exec);
      var charAt = uncurryThis("".charAt);
      var charCodeAt = uncurryThis("".charCodeAt);
      var replace = uncurryThis("".replace);
      var numberToString = uncurryThis(1 .toString);
      var tester = /[\uD800-\uDFFF]/g;
      var low = /^[\uD800-\uDBFF]$/;
      var hi = /^[\uDC00-\uDFFF]$/;
      var WRONG_SYMBOLS_CONVERSION = !NATIVE_SYMBOL || fails(function() {
        var symbol = getBuiltIn("Symbol")("stringify detection");
        return $stringify([symbol]) !== "[null]" || $stringify({ a: symbol }) !== "{}" || $stringify(Object(symbol)) !== "{}";
      });
      var ILL_FORMED_UNICODE = fails(function() {
        return $stringify("\uDF06\uD834") !== '"\\udf06\\ud834"' || $stringify("\uDEAD") !== '"\\udead"';
      });
      var stringifyWithSymbolsFix = function(it, replacer) {
        var args = arraySlice2(arguments);
        var $replacer = getReplacerFunction(replacer);
        if (!isCallable($replacer) && (it === void 0 || isSymbol(it))) return;
        args[1] = function(key, value) {
          if (isCallable($replacer)) value = call($replacer, this, $String(key), value);
          if (!isSymbol(value)) return value;
        };
        return apply($stringify, null, args);
      };
      var fixIllFormed = function(match, offset, string) {
        var prev = charAt(string, offset - 1);
        var next = charAt(string, offset + 1);
        if (exec(low, match) && !exec(hi, next) || exec(hi, match) && !exec(low, prev)) {
          return "\\u" + numberToString(charCodeAt(match, 0), 16);
        }
        return match;
      };
      if ($stringify) {
        $({ target: "JSON", stat: true, arity: 3, forced: WRONG_SYMBOLS_CONVERSION || ILL_FORMED_UNICODE }, {
          // eslint-disable-next-line no-unused-vars -- required for `.length`
          stringify: function stringify2(it, replacer, space) {
            var args = arraySlice2(arguments);
            var result = apply(WRONG_SYMBOLS_CONVERSION ? stringifyWithSymbolsFix : $stringify, null, args);
            return ILL_FORMED_UNICODE && typeof result == "string" ? replace(result, tester, fixIllFormed) : result;
          }
        });
      }
    }
  });

  // node_modules/core-js/modules/es.object.get-own-property-symbols.js
  var require_es_object_get_own_property_symbols = __commonJS({
    "node_modules/core-js/modules/es.object.get-own-property-symbols.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var NATIVE_SYMBOL = require_symbol_constructor_detection();
      var fails = require_fails();
      var getOwnPropertySymbolsModule = require_object_get_own_property_symbols();
      var toObject = require_to_object();
      var FORCED = !NATIVE_SYMBOL || fails(function() {
        getOwnPropertySymbolsModule.f(1);
      });
      $({ target: "Object", stat: true, forced: FORCED }, {
        getOwnPropertySymbols: function getOwnPropertySymbols(it) {
          var $getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
          return $getOwnPropertySymbols ? $getOwnPropertySymbols(toObject(it)) : [];
        }
      });
    }
  });

  // node_modules/core-js/modules/es.symbol.js
  var require_es_symbol = __commonJS({
    "node_modules/core-js/modules/es.symbol.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      require_es_symbol_constructor();
      require_es_symbol_for();
      require_es_symbol_key_for();
      require_es_json_stringify();
      require_es_object_get_own_property_symbols();
    }
  });

  // node_modules/core-js/modules/es.symbol.description.js
  var require_es_symbol_description = __commonJS({
    "node_modules/core-js/modules/es.symbol.description.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var DESCRIPTORS = require_descriptors();
      var global2 = require_global();
      var uncurryThis = require_function_uncurry_this();
      var hasOwn = require_has_own_property();
      var isCallable = require_is_callable();
      var isPrototypeOf = require_object_is_prototype_of();
      var toString = require_to_string();
      var defineBuiltInAccessor = require_define_built_in_accessor();
      var copyConstructorProperties = require_copy_constructor_properties();
      var NativeSymbol = global2.Symbol;
      var SymbolPrototype = NativeSymbol && NativeSymbol.prototype;
      if (DESCRIPTORS && isCallable(NativeSymbol) && (!("description" in SymbolPrototype) || // Safari 12 bug
      NativeSymbol().description !== void 0)) {
        EmptyStringDescriptionStore = {};
        SymbolWrapper = function Symbol2() {
          var description = arguments.length < 1 || arguments[0] === void 0 ? void 0 : toString(arguments[0]);
          var result = isPrototypeOf(SymbolPrototype, this) ? new NativeSymbol(description) : description === void 0 ? NativeSymbol() : NativeSymbol(description);
          if (description === "") EmptyStringDescriptionStore[result] = true;
          return result;
        };
        copyConstructorProperties(SymbolWrapper, NativeSymbol);
        SymbolWrapper.prototype = SymbolPrototype;
        SymbolPrototype.constructor = SymbolWrapper;
        NATIVE_SYMBOL = String(NativeSymbol("description detection")) === "Symbol(description detection)";
        thisSymbolValue = uncurryThis(SymbolPrototype.valueOf);
        symbolDescriptiveString = uncurryThis(SymbolPrototype.toString);
        regexp = /^Symbol\((.*)\)[^)]+$/;
        replace = uncurryThis("".replace);
        stringSlice = uncurryThis("".slice);
        defineBuiltInAccessor(SymbolPrototype, "description", {
          configurable: true,
          get: function description() {
            var symbol = thisSymbolValue(this);
            if (hasOwn(EmptyStringDescriptionStore, symbol)) return "";
            var string = symbolDescriptiveString(symbol);
            var desc = NATIVE_SYMBOL ? stringSlice(string, 7, -1) : replace(string, regexp, "$1");
            return desc === "" ? void 0 : desc;
          }
        });
        $({ global: true, constructor: true, forced: true }, {
          Symbol: SymbolWrapper
        });
      }
      var EmptyStringDescriptionStore;
      var SymbolWrapper;
      var NATIVE_SYMBOL;
      var thisSymbolValue;
      var symbolDescriptiveString;
      var regexp;
      var replace;
      var stringSlice;
    }
  });

  // node_modules/core-js/modules/es.symbol.async-iterator.js
  var require_es_symbol_async_iterator = __commonJS({
    "node_modules/core-js/modules/es.symbol.async-iterator.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var defineWellKnownSymbol = require_well_known_symbol_define();
      defineWellKnownSymbol("asyncIterator");
    }
  });

  // node_modules/core-js/modules/es.symbol.has-instance.js
  var require_es_symbol_has_instance = __commonJS({
    "node_modules/core-js/modules/es.symbol.has-instance.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var defineWellKnownSymbol = require_well_known_symbol_define();
      defineWellKnownSymbol("hasInstance");
    }
  });

  // node_modules/core-js/modules/es.symbol.is-concat-spreadable.js
  var require_es_symbol_is_concat_spreadable = __commonJS({
    "node_modules/core-js/modules/es.symbol.is-concat-spreadable.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var defineWellKnownSymbol = require_well_known_symbol_define();
      defineWellKnownSymbol("isConcatSpreadable");
    }
  });

  // node_modules/core-js/modules/es.symbol.iterator.js
  var require_es_symbol_iterator = __commonJS({
    "node_modules/core-js/modules/es.symbol.iterator.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var defineWellKnownSymbol = require_well_known_symbol_define();
      defineWellKnownSymbol("iterator");
    }
  });

  // node_modules/core-js/modules/es.symbol.match.js
  var require_es_symbol_match = __commonJS({
    "node_modules/core-js/modules/es.symbol.match.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var defineWellKnownSymbol = require_well_known_symbol_define();
      defineWellKnownSymbol("match");
    }
  });

  // node_modules/core-js/modules/es.symbol.match-all.js
  var require_es_symbol_match_all = __commonJS({
    "node_modules/core-js/modules/es.symbol.match-all.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var defineWellKnownSymbol = require_well_known_symbol_define();
      defineWellKnownSymbol("matchAll");
    }
  });

  // node_modules/core-js/modules/es.symbol.replace.js
  var require_es_symbol_replace = __commonJS({
    "node_modules/core-js/modules/es.symbol.replace.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var defineWellKnownSymbol = require_well_known_symbol_define();
      defineWellKnownSymbol("replace");
    }
  });

  // node_modules/core-js/modules/es.symbol.search.js
  var require_es_symbol_search = __commonJS({
    "node_modules/core-js/modules/es.symbol.search.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var defineWellKnownSymbol = require_well_known_symbol_define();
      defineWellKnownSymbol("search");
    }
  });

  // node_modules/core-js/modules/es.symbol.species.js
  var require_es_symbol_species = __commonJS({
    "node_modules/core-js/modules/es.symbol.species.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var defineWellKnownSymbol = require_well_known_symbol_define();
      defineWellKnownSymbol("species");
    }
  });

  // node_modules/core-js/modules/es.symbol.split.js
  var require_es_symbol_split = __commonJS({
    "node_modules/core-js/modules/es.symbol.split.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var defineWellKnownSymbol = require_well_known_symbol_define();
      defineWellKnownSymbol("split");
    }
  });

  // node_modules/core-js/modules/es.symbol.to-primitive.js
  var require_es_symbol_to_primitive = __commonJS({
    "node_modules/core-js/modules/es.symbol.to-primitive.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var defineWellKnownSymbol = require_well_known_symbol_define();
      var defineSymbolToPrimitive = require_symbol_define_to_primitive();
      defineWellKnownSymbol("toPrimitive");
      defineSymbolToPrimitive();
    }
  });

  // node_modules/core-js/modules/es.symbol.to-string-tag.js
  var require_es_symbol_to_string_tag = __commonJS({
    "node_modules/core-js/modules/es.symbol.to-string-tag.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var getBuiltIn = require_get_built_in();
      var defineWellKnownSymbol = require_well_known_symbol_define();
      var setToStringTag = require_set_to_string_tag();
      defineWellKnownSymbol("toStringTag");
      setToStringTag(getBuiltIn("Symbol"), "Symbol");
    }
  });

  // node_modules/core-js/modules/es.symbol.unscopables.js
  var require_es_symbol_unscopables = __commonJS({
    "node_modules/core-js/modules/es.symbol.unscopables.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var defineWellKnownSymbol = require_well_known_symbol_define();
      defineWellKnownSymbol("unscopables");
    }
  });

  // node_modules/core-js/internals/function-uncurry-this-accessor.js
  var require_function_uncurry_this_accessor = __commonJS({
    "node_modules/core-js/internals/function-uncurry-this-accessor.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var uncurryThis = require_function_uncurry_this();
      var aCallable = require_a_callable();
      module.exports = function(object, key, method) {
        try {
          return uncurryThis(aCallable(Object.getOwnPropertyDescriptor(object, key)[method]));
        } catch (error) {
        }
      };
    }
  });

  // node_modules/core-js/internals/is-possible-prototype.js
  var require_is_possible_prototype = __commonJS({
    "node_modules/core-js/internals/is-possible-prototype.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var isObject2 = require_is_object();
      module.exports = function(argument) {
        return isObject2(argument) || argument === null;
      };
    }
  });

  // node_modules/core-js/internals/a-possible-prototype.js
  var require_a_possible_prototype = __commonJS({
    "node_modules/core-js/internals/a-possible-prototype.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var isPossiblePrototype = require_is_possible_prototype();
      var $String = String;
      var $TypeError = TypeError;
      module.exports = function(argument) {
        if (isPossiblePrototype(argument)) return argument;
        throw new $TypeError("Can't set " + $String(argument) + " as a prototype");
      };
    }
  });

  // node_modules/core-js/internals/object-set-prototype-of.js
  var require_object_set_prototype_of = __commonJS({
    "node_modules/core-js/internals/object-set-prototype-of.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var uncurryThisAccessor = require_function_uncurry_this_accessor();
      var isObject2 = require_is_object();
      var requireObjectCoercible = require_require_object_coercible();
      var aPossiblePrototype = require_a_possible_prototype();
      module.exports = Object.setPrototypeOf || ("__proto__" in {} ? function() {
        var CORRECT_SETTER = false;
        var test = {};
        var setter;
        try {
          setter = uncurryThisAccessor(Object.prototype, "__proto__", "set");
          setter(test, []);
          CORRECT_SETTER = test instanceof Array;
        } catch (error) {
        }
        return function setPrototypeOf(O, proto) {
          requireObjectCoercible(O);
          aPossiblePrototype(proto);
          if (!isObject2(O)) return O;
          if (CORRECT_SETTER) setter(O, proto);
          else O.__proto__ = proto;
          return O;
        };
      }() : void 0);
    }
  });

  // node_modules/core-js/internals/proxy-accessor.js
  var require_proxy_accessor = __commonJS({
    "node_modules/core-js/internals/proxy-accessor.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var defineProperty = require_object_define_property().f;
      module.exports = function(Target, Source, key) {
        key in Target || defineProperty(Target, key, {
          configurable: true,
          get: function() {
            return Source[key];
          },
          set: function(it) {
            Source[key] = it;
          }
        });
      };
    }
  });

  // node_modules/core-js/internals/inherit-if-required.js
  var require_inherit_if_required = __commonJS({
    "node_modules/core-js/internals/inherit-if-required.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var isCallable = require_is_callable();
      var isObject2 = require_is_object();
      var setPrototypeOf = require_object_set_prototype_of();
      module.exports = function($this, dummy, Wrapper) {
        var NewTarget, NewTargetPrototype;
        if (
          // it can work only with native `setPrototypeOf`
          setPrototypeOf && // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
          isCallable(NewTarget = dummy.constructor) && NewTarget !== Wrapper && isObject2(NewTargetPrototype = NewTarget.prototype) && NewTargetPrototype !== Wrapper.prototype
        ) setPrototypeOf($this, NewTargetPrototype);
        return $this;
      };
    }
  });

  // node_modules/core-js/internals/normalize-string-argument.js
  var require_normalize_string_argument = __commonJS({
    "node_modules/core-js/internals/normalize-string-argument.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var toString = require_to_string();
      module.exports = function(argument, $default) {
        return argument === void 0 ? arguments.length < 2 ? "" : $default : toString(argument);
      };
    }
  });

  // node_modules/core-js/internals/install-error-cause.js
  var require_install_error_cause = __commonJS({
    "node_modules/core-js/internals/install-error-cause.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var isObject2 = require_is_object();
      var createNonEnumerableProperty = require_create_non_enumerable_property();
      module.exports = function(O, options) {
        if (isObject2(options) && "cause" in options) {
          createNonEnumerableProperty(O, "cause", options.cause);
        }
      };
    }
  });

  // node_modules/core-js/internals/error-stack-clear.js
  var require_error_stack_clear = __commonJS({
    "node_modules/core-js/internals/error-stack-clear.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var uncurryThis = require_function_uncurry_this();
      var $Error = Error;
      var replace = uncurryThis("".replace);
      var TEST = function(arg) {
        return String(new $Error(arg).stack);
      }("zxcasd");
      var V8_OR_CHAKRA_STACK_ENTRY = /\n\s*at [^:]*:[^\n]*/;
      var IS_V8_OR_CHAKRA_STACK = V8_OR_CHAKRA_STACK_ENTRY.test(TEST);
      module.exports = function(stack, dropEntries) {
        if (IS_V8_OR_CHAKRA_STACK && typeof stack == "string" && !$Error.prepareStackTrace) {
          while (dropEntries--) stack = replace(stack, V8_OR_CHAKRA_STACK_ENTRY, "");
        }
        return stack;
      };
    }
  });

  // node_modules/core-js/internals/error-stack-installable.js
  var require_error_stack_installable = __commonJS({
    "node_modules/core-js/internals/error-stack-installable.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var fails = require_fails();
      var createPropertyDescriptor = require_create_property_descriptor();
      module.exports = !fails(function() {
        var error = new Error("a");
        if (!("stack" in error)) return true;
        Object.defineProperty(error, "stack", createPropertyDescriptor(1, 7));
        return error.stack !== 7;
      });
    }
  });

  // node_modules/core-js/internals/error-stack-install.js
  var require_error_stack_install = __commonJS({
    "node_modules/core-js/internals/error-stack-install.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var createNonEnumerableProperty = require_create_non_enumerable_property();
      var clearErrorStack = require_error_stack_clear();
      var ERROR_STACK_INSTALLABLE = require_error_stack_installable();
      var captureStackTrace = Error.captureStackTrace;
      module.exports = function(error, C, stack, dropEntries) {
        if (ERROR_STACK_INSTALLABLE) {
          if (captureStackTrace) captureStackTrace(error, C);
          else createNonEnumerableProperty(error, "stack", clearErrorStack(stack, dropEntries));
        }
      };
    }
  });

  // node_modules/core-js/internals/wrap-error-constructor-with-cause.js
  var require_wrap_error_constructor_with_cause = __commonJS({
    "node_modules/core-js/internals/wrap-error-constructor-with-cause.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var getBuiltIn = require_get_built_in();
      var hasOwn = require_has_own_property();
      var createNonEnumerableProperty = require_create_non_enumerable_property();
      var isPrototypeOf = require_object_is_prototype_of();
      var setPrototypeOf = require_object_set_prototype_of();
      var copyConstructorProperties = require_copy_constructor_properties();
      var proxyAccessor = require_proxy_accessor();
      var inheritIfRequired = require_inherit_if_required();
      var normalizeStringArgument = require_normalize_string_argument();
      var installErrorCause = require_install_error_cause();
      var installErrorStack = require_error_stack_install();
      var DESCRIPTORS = require_descriptors();
      var IS_PURE = require_is_pure();
      module.exports = function(FULL_NAME, wrapper, FORCED, IS_AGGREGATE_ERROR) {
        var STACK_TRACE_LIMIT = "stackTraceLimit";
        var OPTIONS_POSITION = IS_AGGREGATE_ERROR ? 2 : 1;
        var path = FULL_NAME.split(".");
        var ERROR_NAME = path[path.length - 1];
        var OriginalError = getBuiltIn.apply(null, path);
        if (!OriginalError) return;
        var OriginalErrorPrototype = OriginalError.prototype;
        if (!IS_PURE && hasOwn(OriginalErrorPrototype, "cause")) delete OriginalErrorPrototype.cause;
        if (!FORCED) return OriginalError;
        var BaseError = getBuiltIn("Error");
        var WrappedError = wrapper(function(a, b) {
          var message = normalizeStringArgument(IS_AGGREGATE_ERROR ? b : a, void 0);
          var result = IS_AGGREGATE_ERROR ? new OriginalError(a) : new OriginalError();
          if (message !== void 0) createNonEnumerableProperty(result, "message", message);
          installErrorStack(result, WrappedError, result.stack, 2);
          if (this && isPrototypeOf(OriginalErrorPrototype, this)) inheritIfRequired(result, this, WrappedError);
          if (arguments.length > OPTIONS_POSITION) installErrorCause(result, arguments[OPTIONS_POSITION]);
          return result;
        });
        WrappedError.prototype = OriginalErrorPrototype;
        if (ERROR_NAME !== "Error") {
          if (setPrototypeOf) setPrototypeOf(WrappedError, BaseError);
          else copyConstructorProperties(WrappedError, BaseError, { name: true });
        } else if (DESCRIPTORS && STACK_TRACE_LIMIT in OriginalError) {
          proxyAccessor(WrappedError, OriginalError, STACK_TRACE_LIMIT);
          proxyAccessor(WrappedError, OriginalError, "prepareStackTrace");
        }
        copyConstructorProperties(WrappedError, OriginalError);
        if (!IS_PURE) try {
          if (OriginalErrorPrototype.name !== ERROR_NAME) {
            createNonEnumerableProperty(OriginalErrorPrototype, "name", ERROR_NAME);
          }
          OriginalErrorPrototype.constructor = WrappedError;
        } catch (error) {
        }
        return WrappedError;
      };
    }
  });

  // node_modules/core-js/modules/es.error.cause.js
  var require_es_error_cause = __commonJS({
    "node_modules/core-js/modules/es.error.cause.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var global2 = require_global();
      var apply = require_function_apply();
      var wrapErrorConstructorWithCause = require_wrap_error_constructor_with_cause();
      var WEB_ASSEMBLY = "WebAssembly";
      var WebAssembly = global2[WEB_ASSEMBLY];
      var FORCED = new Error("e", { cause: 7 }).cause !== 7;
      var exportGlobalErrorCauseWrapper = function(ERROR_NAME, wrapper) {
        var O = {};
        O[ERROR_NAME] = wrapErrorConstructorWithCause(ERROR_NAME, wrapper, FORCED);
        $({ global: true, constructor: true, arity: 1, forced: FORCED }, O);
      };
      var exportWebAssemblyErrorCauseWrapper = function(ERROR_NAME, wrapper) {
        if (WebAssembly && WebAssembly[ERROR_NAME]) {
          var O = {};
          O[ERROR_NAME] = wrapErrorConstructorWithCause(WEB_ASSEMBLY + "." + ERROR_NAME, wrapper, FORCED);
          $({ target: WEB_ASSEMBLY, stat: true, constructor: true, arity: 1, forced: FORCED }, O);
        }
      };
      exportGlobalErrorCauseWrapper("Error", function(init) {
        return function Error2(message) {
          return apply(init, this, arguments);
        };
      });
      exportGlobalErrorCauseWrapper("EvalError", function(init) {
        return function EvalError(message) {
          return apply(init, this, arguments);
        };
      });
      exportGlobalErrorCauseWrapper("RangeError", function(init) {
        return function RangeError2(message) {
          return apply(init, this, arguments);
        };
      });
      exportGlobalErrorCauseWrapper("ReferenceError", function(init) {
        return function ReferenceError2(message) {
          return apply(init, this, arguments);
        };
      });
      exportGlobalErrorCauseWrapper("SyntaxError", function(init) {
        return function SyntaxError(message) {
          return apply(init, this, arguments);
        };
      });
      exportGlobalErrorCauseWrapper("TypeError", function(init) {
        return function TypeError2(message) {
          return apply(init, this, arguments);
        };
      });
      exportGlobalErrorCauseWrapper("URIError", function(init) {
        return function URIError(message) {
          return apply(init, this, arguments);
        };
      });
      exportWebAssemblyErrorCauseWrapper("CompileError", function(init) {
        return function CompileError(message) {
          return apply(init, this, arguments);
        };
      });
      exportWebAssemblyErrorCauseWrapper("LinkError", function(init) {
        return function LinkError(message) {
          return apply(init, this, arguments);
        };
      });
      exportWebAssemblyErrorCauseWrapper("RuntimeError", function(init) {
        return function RuntimeError(message) {
          return apply(init, this, arguments);
        };
      });
    }
  });

  // node_modules/core-js/internals/error-to-string.js
  var require_error_to_string = __commonJS({
    "node_modules/core-js/internals/error-to-string.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var DESCRIPTORS = require_descriptors();
      var fails = require_fails();
      var anObject = require_an_object();
      var normalizeStringArgument = require_normalize_string_argument();
      var nativeErrorToString = Error.prototype.toString;
      var INCORRECT_TO_STRING = fails(function() {
        if (DESCRIPTORS) {
          var object = Object.create(Object.defineProperty({}, "name", { get: function() {
            return this === object;
          } }));
          if (nativeErrorToString.call(object) !== "true") return true;
        }
        return nativeErrorToString.call({ message: 1, name: 2 }) !== "2: 1" || nativeErrorToString.call({}) !== "Error";
      });
      module.exports = INCORRECT_TO_STRING ? function toString() {
        var O = anObject(this);
        var name2 = normalizeStringArgument(O.name, "Error");
        var message = normalizeStringArgument(O.message);
        return !name2 ? message : !message ? name2 : name2 + ": " + message;
      } : nativeErrorToString;
    }
  });

  // node_modules/core-js/modules/es.error.to-string.js
  var require_es_error_to_string = __commonJS({
    "node_modules/core-js/modules/es.error.to-string.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var defineBuiltIn = require_define_built_in();
      var errorToString = require_error_to_string();
      var ErrorPrototype = Error.prototype;
      if (ErrorPrototype.toString !== errorToString) {
        defineBuiltIn(ErrorPrototype, "toString", errorToString);
      }
    }
  });

  // node_modules/core-js/internals/correct-prototype-getter.js
  var require_correct_prototype_getter = __commonJS({
    "node_modules/core-js/internals/correct-prototype-getter.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var fails = require_fails();
      module.exports = !fails(function() {
        function F() {
        }
        F.prototype.constructor = null;
        return Object.getPrototypeOf(new F()) !== F.prototype;
      });
    }
  });

  // node_modules/core-js/internals/object-get-prototype-of.js
  var require_object_get_prototype_of = __commonJS({
    "node_modules/core-js/internals/object-get-prototype-of.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var hasOwn = require_has_own_property();
      var isCallable = require_is_callable();
      var toObject = require_to_object();
      var sharedKey = require_shared_key();
      var CORRECT_PROTOTYPE_GETTER = require_correct_prototype_getter();
      var IE_PROTO = sharedKey("IE_PROTO");
      var $Object = Object;
      var ObjectPrototype = $Object.prototype;
      module.exports = CORRECT_PROTOTYPE_GETTER ? $Object.getPrototypeOf : function(O) {
        var object = toObject(O);
        if (hasOwn(object, IE_PROTO)) return object[IE_PROTO];
        var constructor = object.constructor;
        if (isCallable(constructor) && object instanceof constructor) {
          return constructor.prototype;
        }
        return object instanceof $Object ? ObjectPrototype : null;
      };
    }
  });

  // node_modules/core-js/internals/iterators.js
  var require_iterators = __commonJS({
    "node_modules/core-js/internals/iterators.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      module.exports = {};
    }
  });

  // node_modules/core-js/internals/is-array-iterator-method.js
  var require_is_array_iterator_method = __commonJS({
    "node_modules/core-js/internals/is-array-iterator-method.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var wellKnownSymbol = require_well_known_symbol();
      var Iterators = require_iterators();
      var ITERATOR = wellKnownSymbol("iterator");
      var ArrayPrototype = Array.prototype;
      module.exports = function(it) {
        return it !== void 0 && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
      };
    }
  });

  // node_modules/core-js/internals/get-iterator-method.js
  var require_get_iterator_method = __commonJS({
    "node_modules/core-js/internals/get-iterator-method.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var classof = require_classof();
      var getMethod = require_get_method();
      var isNullOrUndefined2 = require_is_null_or_undefined();
      var Iterators = require_iterators();
      var wellKnownSymbol = require_well_known_symbol();
      var ITERATOR = wellKnownSymbol("iterator");
      module.exports = function(it) {
        if (!isNullOrUndefined2(it)) return getMethod(it, ITERATOR) || getMethod(it, "@@iterator") || Iterators[classof(it)];
      };
    }
  });

  // node_modules/core-js/internals/get-iterator.js
  var require_get_iterator = __commonJS({
    "node_modules/core-js/internals/get-iterator.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var call = require_function_call();
      var aCallable = require_a_callable();
      var anObject = require_an_object();
      var tryToString = require_try_to_string();
      var getIteratorMethod = require_get_iterator_method();
      var $TypeError = TypeError;
      module.exports = function(argument, usingIterator) {
        var iteratorMethod = arguments.length < 2 ? getIteratorMethod(argument) : usingIterator;
        if (aCallable(iteratorMethod)) return anObject(call(iteratorMethod, argument));
        throw new $TypeError(tryToString(argument) + " is not iterable");
      };
    }
  });

  // node_modules/core-js/internals/iterator-close.js
  var require_iterator_close = __commonJS({
    "node_modules/core-js/internals/iterator-close.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var call = require_function_call();
      var anObject = require_an_object();
      var getMethod = require_get_method();
      module.exports = function(iterator, kind, value) {
        var innerResult, innerError;
        anObject(iterator);
        try {
          innerResult = getMethod(iterator, "return");
          if (!innerResult) {
            if (kind === "throw") throw value;
            return value;
          }
          innerResult = call(innerResult, iterator);
        } catch (error) {
          innerError = true;
          innerResult = error;
        }
        if (kind === "throw") throw value;
        if (innerError) throw innerResult;
        anObject(innerResult);
        return value;
      };
    }
  });

  // node_modules/core-js/internals/iterate.js
  var require_iterate = __commonJS({
    "node_modules/core-js/internals/iterate.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var bind = require_function_bind_context();
      var call = require_function_call();
      var anObject = require_an_object();
      var tryToString = require_try_to_string();
      var isArrayIteratorMethod = require_is_array_iterator_method();
      var lengthOfArrayLike = require_length_of_array_like();
      var isPrototypeOf = require_object_is_prototype_of();
      var getIterator = require_get_iterator();
      var getIteratorMethod = require_get_iterator_method();
      var iteratorClose = require_iterator_close();
      var $TypeError = TypeError;
      var Result = function(stopped, result) {
        this.stopped = stopped;
        this.result = result;
      };
      var ResultPrototype = Result.prototype;
      module.exports = function(iterable, unboundFunction, options) {
        var that = options && options.that;
        var AS_ENTRIES = !!(options && options.AS_ENTRIES);
        var IS_RECORD = !!(options && options.IS_RECORD);
        var IS_ITERATOR = !!(options && options.IS_ITERATOR);
        var INTERRUPTED = !!(options && options.INTERRUPTED);
        var fn = bind(unboundFunction, that);
        var iterator, iterFn, index, length, result, next, step;
        var stop = function(condition) {
          if (iterator) iteratorClose(iterator, "normal", condition);
          return new Result(true, condition);
        };
        var callFn = function(value) {
          if (AS_ENTRIES) {
            anObject(value);
            return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
          }
          return INTERRUPTED ? fn(value, stop) : fn(value);
        };
        if (IS_RECORD) {
          iterator = iterable.iterator;
        } else if (IS_ITERATOR) {
          iterator = iterable;
        } else {
          iterFn = getIteratorMethod(iterable);
          if (!iterFn) throw new $TypeError(tryToString(iterable) + " is not iterable");
          if (isArrayIteratorMethod(iterFn)) {
            for (index = 0, length = lengthOfArrayLike(iterable); length > index; index++) {
              result = callFn(iterable[index]);
              if (result && isPrototypeOf(ResultPrototype, result)) return result;
            }
            return new Result(false);
          }
          iterator = getIterator(iterable, iterFn);
        }
        next = IS_RECORD ? iterable.next : iterator.next;
        while (!(step = call(next, iterator)).done) {
          try {
            result = callFn(step.value);
          } catch (error) {
            iteratorClose(iterator, "throw", error);
          }
          if (typeof result == "object" && result && isPrototypeOf(ResultPrototype, result)) return result;
        }
        return new Result(false);
      };
    }
  });

  // node_modules/core-js/modules/es.aggregate-error.constructor.js
  var require_es_aggregate_error_constructor = __commonJS({
    "node_modules/core-js/modules/es.aggregate-error.constructor.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var isPrototypeOf = require_object_is_prototype_of();
      var getPrototypeOf = require_object_get_prototype_of();
      var setPrototypeOf = require_object_set_prototype_of();
      var copyConstructorProperties = require_copy_constructor_properties();
      var create = require_object_create();
      var createNonEnumerableProperty = require_create_non_enumerable_property();
      var createPropertyDescriptor = require_create_property_descriptor();
      var installErrorCause = require_install_error_cause();
      var installErrorStack = require_error_stack_install();
      var iterate = require_iterate();
      var normalizeStringArgument = require_normalize_string_argument();
      var wellKnownSymbol = require_well_known_symbol();
      var TO_STRING_TAG = wellKnownSymbol("toStringTag");
      var $Error = Error;
      var push = [].push;
      var $AggregateError = function AggregateError(errors, message) {
        var isInstance = isPrototypeOf(AggregateErrorPrototype, this);
        var that;
        if (setPrototypeOf) {
          that = setPrototypeOf(new $Error(), isInstance ? getPrototypeOf(this) : AggregateErrorPrototype);
        } else {
          that = isInstance ? this : create(AggregateErrorPrototype);
          createNonEnumerableProperty(that, TO_STRING_TAG, "Error");
        }
        if (message !== void 0) createNonEnumerableProperty(that, "message", normalizeStringArgument(message));
        installErrorStack(that, $AggregateError, that.stack, 1);
        if (arguments.length > 2) installErrorCause(that, arguments[2]);
        var errorsArray = [];
        iterate(errors, push, { that: errorsArray });
        createNonEnumerableProperty(that, "errors", errorsArray);
        return that;
      };
      if (setPrototypeOf) setPrototypeOf($AggregateError, $Error);
      else copyConstructorProperties($AggregateError, $Error, { name: true });
      var AggregateErrorPrototype = $AggregateError.prototype = create($Error.prototype, {
        constructor: createPropertyDescriptor(1, $AggregateError),
        message: createPropertyDescriptor(1, ""),
        name: createPropertyDescriptor(1, "AggregateError")
      });
      $({ global: true, constructor: true, arity: 2 }, {
        AggregateError: $AggregateError
      });
    }
  });

  // node_modules/core-js/modules/es.aggregate-error.js
  var require_es_aggregate_error = __commonJS({
    "node_modules/core-js/modules/es.aggregate-error.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      require_es_aggregate_error_constructor();
    }
  });

  // node_modules/core-js/modules/es.aggregate-error.cause.js
  var require_es_aggregate_error_cause = __commonJS({
    "node_modules/core-js/modules/es.aggregate-error.cause.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var getBuiltIn = require_get_built_in();
      var apply = require_function_apply();
      var fails = require_fails();
      var wrapErrorConstructorWithCause = require_wrap_error_constructor_with_cause();
      var AGGREGATE_ERROR = "AggregateError";
      var $AggregateError = getBuiltIn(AGGREGATE_ERROR);
      var FORCED = !fails(function() {
        return $AggregateError([1]).errors[0] !== 1;
      }) && fails(function() {
        return $AggregateError([1], AGGREGATE_ERROR, { cause: 7 }).cause !== 7;
      });
      $({ global: true, constructor: true, arity: 2, forced: FORCED }, {
        AggregateError: wrapErrorConstructorWithCause(AGGREGATE_ERROR, function(init) {
          return function AggregateError(errors, message) {
            return apply(init, this, arguments);
          };
        }, FORCED, true)
      });
    }
  });

  // node_modules/core-js/internals/add-to-unscopables.js
  var require_add_to_unscopables = __commonJS({
    "node_modules/core-js/internals/add-to-unscopables.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var wellKnownSymbol = require_well_known_symbol();
      var create = require_object_create();
      var defineProperty = require_object_define_property().f;
      var UNSCOPABLES = wellKnownSymbol("unscopables");
      var ArrayPrototype = Array.prototype;
      if (ArrayPrototype[UNSCOPABLES] === void 0) {
        defineProperty(ArrayPrototype, UNSCOPABLES, {
          configurable: true,
          value: create(null)
        });
      }
      module.exports = function(key) {
        ArrayPrototype[UNSCOPABLES][key] = true;
      };
    }
  });

  // node_modules/core-js/modules/es.array.at.js
  var require_es_array_at = __commonJS({
    "node_modules/core-js/modules/es.array.at.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var toObject = require_to_object();
      var lengthOfArrayLike = require_length_of_array_like();
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var addToUnscopables = require_add_to_unscopables();
      $({ target: "Array", proto: true }, {
        at: function at(index) {
          var O = toObject(this);
          var len = lengthOfArrayLike(O);
          var relativeIndex = toIntegerOrInfinity(index);
          var k = relativeIndex >= 0 ? relativeIndex : len + relativeIndex;
          return k < 0 || k >= len ? void 0 : O[k];
        }
      });
      addToUnscopables("at");
    }
  });

  // node_modules/core-js/internals/does-not-exceed-safe-integer.js
  var require_does_not_exceed_safe_integer = __commonJS({
    "node_modules/core-js/internals/does-not-exceed-safe-integer.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $TypeError = TypeError;
      var MAX_SAFE_INTEGER = 9007199254740991;
      module.exports = function(it) {
        if (it > MAX_SAFE_INTEGER) throw $TypeError("Maximum allowed index exceeded");
        return it;
      };
    }
  });

  // node_modules/core-js/internals/create-property.js
  var require_create_property = __commonJS({
    "node_modules/core-js/internals/create-property.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var DESCRIPTORS = require_descriptors();
      var definePropertyModule = require_object_define_property();
      var createPropertyDescriptor = require_create_property_descriptor();
      module.exports = function(object, key, value) {
        if (DESCRIPTORS) definePropertyModule.f(object, key, createPropertyDescriptor(0, value));
        else object[key] = value;
      };
    }
  });

  // node_modules/core-js/internals/array-method-has-species-support.js
  var require_array_method_has_species_support = __commonJS({
    "node_modules/core-js/internals/array-method-has-species-support.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var fails = require_fails();
      var wellKnownSymbol = require_well_known_symbol();
      var V8_VERSION = require_engine_v8_version();
      var SPECIES = wellKnownSymbol("species");
      module.exports = function(METHOD_NAME) {
        return V8_VERSION >= 51 || !fails(function() {
          var array = [];
          var constructor = array.constructor = {};
          constructor[SPECIES] = function() {
            return { foo: 1 };
          };
          return array[METHOD_NAME](Boolean).foo !== 1;
        });
      };
    }
  });

  // node_modules/core-js/modules/es.array.concat.js
  var require_es_array_concat = __commonJS({
    "node_modules/core-js/modules/es.array.concat.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var fails = require_fails();
      var isArray = require_is_array();
      var isObject2 = require_is_object();
      var toObject = require_to_object();
      var lengthOfArrayLike = require_length_of_array_like();
      var doesNotExceedSafeInteger = require_does_not_exceed_safe_integer();
      var createProperty = require_create_property();
      var arraySpeciesCreate = require_array_species_create();
      var arrayMethodHasSpeciesSupport = require_array_method_has_species_support();
      var wellKnownSymbol = require_well_known_symbol();
      var V8_VERSION = require_engine_v8_version();
      var IS_CONCAT_SPREADABLE = wellKnownSymbol("isConcatSpreadable");
      var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 || !fails(function() {
        var array = [];
        array[IS_CONCAT_SPREADABLE] = false;
        return array.concat()[0] !== array;
      });
      var isConcatSpreadable = function(O) {
        if (!isObject2(O)) return false;
        var spreadable = O[IS_CONCAT_SPREADABLE];
        return spreadable !== void 0 ? !!spreadable : isArray(O);
      };
      var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !arrayMethodHasSpeciesSupport("concat");
      $({ target: "Array", proto: true, arity: 1, forced: FORCED }, {
        // eslint-disable-next-line no-unused-vars -- required for `.length`
        concat: function concat2(arg) {
          var O = toObject(this);
          var A = arraySpeciesCreate(O, 0);
          var n = 0;
          var i, k, length, len, E;
          for (i = -1, length = arguments.length; i < length; i++) {
            E = i === -1 ? O : arguments[i];
            if (isConcatSpreadable(E)) {
              len = lengthOfArrayLike(E);
              doesNotExceedSafeInteger(n + len);
              for (k = 0; k < len; k++, n++) if (k in E) createProperty(A, n, E[k]);
            } else {
              doesNotExceedSafeInteger(n + 1);
              createProperty(A, n++, E);
            }
          }
          A.length = n;
          return A;
        }
      });
    }
  });

  // node_modules/core-js/internals/delete-property-or-throw.js
  var require_delete_property_or_throw = __commonJS({
    "node_modules/core-js/internals/delete-property-or-throw.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var tryToString = require_try_to_string();
      var $TypeError = TypeError;
      module.exports = function(O, P) {
        if (!delete O[P]) throw new $TypeError("Cannot delete property " + tryToString(P) + " of " + tryToString(O));
      };
    }
  });

  // node_modules/core-js/internals/array-copy-within.js
  var require_array_copy_within = __commonJS({
    "node_modules/core-js/internals/array-copy-within.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var toObject = require_to_object();
      var toAbsoluteIndex = require_to_absolute_index();
      var lengthOfArrayLike = require_length_of_array_like();
      var deletePropertyOrThrow = require_delete_property_or_throw();
      var min = Math.min;
      module.exports = [].copyWithin || function copyWithin(target, start) {
        var O = toObject(this);
        var len = lengthOfArrayLike(O);
        var to = toAbsoluteIndex(target, len);
        var from = toAbsoluteIndex(start, len);
        var end = arguments.length > 2 ? arguments[2] : void 0;
        var count = min((end === void 0 ? len : toAbsoluteIndex(end, len)) - from, len - to);
        var inc = 1;
        if (from < to && to < from + count) {
          inc = -1;
          from += count - 1;
          to += count - 1;
        }
        while (count-- > 0) {
          if (from in O) O[to] = O[from];
          else deletePropertyOrThrow(O, to);
          to += inc;
          from += inc;
        }
        return O;
      };
    }
  });

  // node_modules/core-js/modules/es.array.copy-within.js
  var require_es_array_copy_within = __commonJS({
    "node_modules/core-js/modules/es.array.copy-within.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var copyWithin = require_array_copy_within();
      var addToUnscopables = require_add_to_unscopables();
      $({ target: "Array", proto: true }, {
        copyWithin
      });
      addToUnscopables("copyWithin");
    }
  });

  // node_modules/core-js/internals/array-method-is-strict.js
  var require_array_method_is_strict = __commonJS({
    "node_modules/core-js/internals/array-method-is-strict.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var fails = require_fails();
      module.exports = function(METHOD_NAME, argument) {
        var method = [][METHOD_NAME];
        return !!method && fails(function() {
          method.call(null, argument || function() {
            return 1;
          }, 1);
        });
      };
    }
  });

  // node_modules/core-js/modules/es.array.every.js
  var require_es_array_every = __commonJS({
    "node_modules/core-js/modules/es.array.every.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var $every = require_array_iteration().every;
      var arrayMethodIsStrict = require_array_method_is_strict();
      var STRICT_METHOD = arrayMethodIsStrict("every");
      $({ target: "Array", proto: true, forced: !STRICT_METHOD }, {
        every: function every(callbackfn) {
          return $every(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
        }
      });
    }
  });

  // node_modules/core-js/internals/array-fill.js
  var require_array_fill = __commonJS({
    "node_modules/core-js/internals/array-fill.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var toObject = require_to_object();
      var toAbsoluteIndex = require_to_absolute_index();
      var lengthOfArrayLike = require_length_of_array_like();
      module.exports = function fill(value) {
        var O = toObject(this);
        var length = lengthOfArrayLike(O);
        var argumentsLength = arguments.length;
        var index = toAbsoluteIndex(argumentsLength > 1 ? arguments[1] : void 0, length);
        var end = argumentsLength > 2 ? arguments[2] : void 0;
        var endPos = end === void 0 ? length : toAbsoluteIndex(end, length);
        while (endPos > index) O[index++] = value;
        return O;
      };
    }
  });

  // node_modules/core-js/modules/es.array.fill.js
  var require_es_array_fill = __commonJS({
    "node_modules/core-js/modules/es.array.fill.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var fill = require_array_fill();
      var addToUnscopables = require_add_to_unscopables();
      $({ target: "Array", proto: true }, {
        fill
      });
      addToUnscopables("fill");
    }
  });

  // node_modules/core-js/modules/es.array.filter.js
  var require_es_array_filter = __commonJS({
    "node_modules/core-js/modules/es.array.filter.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var $filter = require_array_iteration().filter;
      var arrayMethodHasSpeciesSupport = require_array_method_has_species_support();
      var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("filter");
      $({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT }, {
        filter: function filter(callbackfn) {
          return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.array.find.js
  var require_es_array_find = __commonJS({
    "node_modules/core-js/modules/es.array.find.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var $find = require_array_iteration().find;
      var addToUnscopables = require_add_to_unscopables();
      var FIND = "find";
      var SKIPS_HOLES = true;
      if (FIND in []) Array(1)[FIND](function() {
        SKIPS_HOLES = false;
      });
      $({ target: "Array", proto: true, forced: SKIPS_HOLES }, {
        find: function find(callbackfn) {
          return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
        }
      });
      addToUnscopables(FIND);
    }
  });

  // node_modules/core-js/modules/es.array.find-index.js
  var require_es_array_find_index = __commonJS({
    "node_modules/core-js/modules/es.array.find-index.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var $findIndex = require_array_iteration().findIndex;
      var addToUnscopables = require_add_to_unscopables();
      var FIND_INDEX = "findIndex";
      var SKIPS_HOLES = true;
      if (FIND_INDEX in []) Array(1)[FIND_INDEX](function() {
        SKIPS_HOLES = false;
      });
      $({ target: "Array", proto: true, forced: SKIPS_HOLES }, {
        findIndex: function findIndex(callbackfn) {
          return $findIndex(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
        }
      });
      addToUnscopables(FIND_INDEX);
    }
  });

  // node_modules/core-js/internals/array-iteration-from-last.js
  var require_array_iteration_from_last = __commonJS({
    "node_modules/core-js/internals/array-iteration-from-last.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var bind = require_function_bind_context();
      var IndexedObject = require_indexed_object();
      var toObject = require_to_object();
      var lengthOfArrayLike = require_length_of_array_like();
      var createMethod = function(TYPE) {
        var IS_FIND_LAST_INDEX = TYPE === 1;
        return function($this, callbackfn, that) {
          var O = toObject($this);
          var self2 = IndexedObject(O);
          var index = lengthOfArrayLike(self2);
          var boundFunction = bind(callbackfn, that);
          var value, result;
          while (index-- > 0) {
            value = self2[index];
            result = boundFunction(value, index, O);
            if (result) switch (TYPE) {
              case 0:
                return value;
              case 1:
                return index;
            }
          }
          return IS_FIND_LAST_INDEX ? -1 : void 0;
        };
      };
      module.exports = {
        // `Array.prototype.findLast` method
        // https://github.com/tc39/proposal-array-find-from-last
        findLast: createMethod(0),
        // `Array.prototype.findLastIndex` method
        // https://github.com/tc39/proposal-array-find-from-last
        findLastIndex: createMethod(1)
      };
    }
  });

  // node_modules/core-js/modules/es.array.find-last.js
  var require_es_array_find_last = __commonJS({
    "node_modules/core-js/modules/es.array.find-last.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var $findLast = require_array_iteration_from_last().findLast;
      var addToUnscopables = require_add_to_unscopables();
      $({ target: "Array", proto: true }, {
        findLast: function findLast(callbackfn) {
          return $findLast(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
        }
      });
      addToUnscopables("findLast");
    }
  });

  // node_modules/core-js/modules/es.array.find-last-index.js
  var require_es_array_find_last_index = __commonJS({
    "node_modules/core-js/modules/es.array.find-last-index.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var $findLastIndex = require_array_iteration_from_last().findLastIndex;
      var addToUnscopables = require_add_to_unscopables();
      $({ target: "Array", proto: true }, {
        findLastIndex: function findLastIndex(callbackfn) {
          return $findLastIndex(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
        }
      });
      addToUnscopables("findLastIndex");
    }
  });

  // node_modules/core-js/internals/flatten-into-array.js
  var require_flatten_into_array = __commonJS({
    "node_modules/core-js/internals/flatten-into-array.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var isArray = require_is_array();
      var lengthOfArrayLike = require_length_of_array_like();
      var doesNotExceedSafeInteger = require_does_not_exceed_safe_integer();
      var bind = require_function_bind_context();
      var flattenIntoArray = function(target, original, source, sourceLen, start, depth, mapper, thisArg) {
        var targetIndex = start;
        var sourceIndex = 0;
        var mapFn = mapper ? bind(mapper, thisArg) : false;
        var element, elementLen;
        while (sourceIndex < sourceLen) {
          if (sourceIndex in source) {
            element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];
            if (depth > 0 && isArray(element)) {
              elementLen = lengthOfArrayLike(element);
              targetIndex = flattenIntoArray(target, original, element, elementLen, targetIndex, depth - 1) - 1;
            } else {
              doesNotExceedSafeInteger(targetIndex + 1);
              target[targetIndex] = element;
            }
            targetIndex++;
          }
          sourceIndex++;
        }
        return targetIndex;
      };
      module.exports = flattenIntoArray;
    }
  });

  // node_modules/core-js/modules/es.array.flat.js
  var require_es_array_flat = __commonJS({
    "node_modules/core-js/modules/es.array.flat.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var flattenIntoArray = require_flatten_into_array();
      var toObject = require_to_object();
      var lengthOfArrayLike = require_length_of_array_like();
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var arraySpeciesCreate = require_array_species_create();
      $({ target: "Array", proto: true }, {
        flat: function flat() {
          var depthArg = arguments.length ? arguments[0] : void 0;
          var O = toObject(this);
          var sourceLen = lengthOfArrayLike(O);
          var A = arraySpeciesCreate(O, 0);
          A.length = flattenIntoArray(A, O, O, sourceLen, 0, depthArg === void 0 ? 1 : toIntegerOrInfinity(depthArg));
          return A;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.array.flat-map.js
  var require_es_array_flat_map = __commonJS({
    "node_modules/core-js/modules/es.array.flat-map.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var flattenIntoArray = require_flatten_into_array();
      var aCallable = require_a_callable();
      var toObject = require_to_object();
      var lengthOfArrayLike = require_length_of_array_like();
      var arraySpeciesCreate = require_array_species_create();
      $({ target: "Array", proto: true }, {
        flatMap: function flatMap2(callbackfn) {
          var O = toObject(this);
          var sourceLen = lengthOfArrayLike(O);
          var A;
          aCallable(callbackfn);
          A = arraySpeciesCreate(O, 0);
          A.length = flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
          return A;
        }
      });
    }
  });

  // node_modules/core-js/internals/array-for-each.js
  var require_array_for_each = __commonJS({
    "node_modules/core-js/internals/array-for-each.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $forEach = require_array_iteration().forEach;
      var arrayMethodIsStrict = require_array_method_is_strict();
      var STRICT_METHOD = arrayMethodIsStrict("forEach");
      module.exports = !STRICT_METHOD ? function forEach2(callbackfn) {
        return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
      } : [].forEach;
    }
  });

  // node_modules/core-js/modules/es.array.for-each.js
  var require_es_array_for_each = __commonJS({
    "node_modules/core-js/modules/es.array.for-each.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var forEach2 = require_array_for_each();
      $({ target: "Array", proto: true, forced: [].forEach !== forEach2 }, {
        forEach: forEach2
      });
    }
  });

  // node_modules/core-js/internals/call-with-safe-iteration-closing.js
  var require_call_with_safe_iteration_closing = __commonJS({
    "node_modules/core-js/internals/call-with-safe-iteration-closing.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var anObject = require_an_object();
      var iteratorClose = require_iterator_close();
      module.exports = function(iterator, fn, value, ENTRIES) {
        try {
          return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
        } catch (error) {
          iteratorClose(iterator, "throw", error);
        }
      };
    }
  });

  // node_modules/core-js/internals/array-from.js
  var require_array_from = __commonJS({
    "node_modules/core-js/internals/array-from.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var bind = require_function_bind_context();
      var call = require_function_call();
      var toObject = require_to_object();
      var callWithSafeIterationClosing = require_call_with_safe_iteration_closing();
      var isArrayIteratorMethod = require_is_array_iterator_method();
      var isConstructor = require_is_constructor();
      var lengthOfArrayLike = require_length_of_array_like();
      var createProperty = require_create_property();
      var getIterator = require_get_iterator();
      var getIteratorMethod = require_get_iterator_method();
      var $Array = Array;
      module.exports = function from(arrayLike) {
        var O = toObject(arrayLike);
        var IS_CONSTRUCTOR = isConstructor(this);
        var argumentsLength = arguments.length;
        var mapfn = argumentsLength > 1 ? arguments[1] : void 0;
        var mapping = mapfn !== void 0;
        if (mapping) mapfn = bind(mapfn, argumentsLength > 2 ? arguments[2] : void 0);
        var iteratorMethod = getIteratorMethod(O);
        var index = 0;
        var length, result, step, iterator, next, value;
        if (iteratorMethod && !(this === $Array && isArrayIteratorMethod(iteratorMethod))) {
          result = IS_CONSTRUCTOR ? new this() : [];
          iterator = getIterator(O, iteratorMethod);
          next = iterator.next;
          for (; !(step = call(next, iterator)).done; index++) {
            value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value;
            createProperty(result, index, value);
          }
        } else {
          length = lengthOfArrayLike(O);
          result = IS_CONSTRUCTOR ? new this(length) : $Array(length);
          for (; length > index; index++) {
            value = mapping ? mapfn(O[index], index) : O[index];
            createProperty(result, index, value);
          }
        }
        result.length = index;
        return result;
      };
    }
  });

  // node_modules/core-js/internals/check-correctness-of-iteration.js
  var require_check_correctness_of_iteration = __commonJS({
    "node_modules/core-js/internals/check-correctness-of-iteration.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var wellKnownSymbol = require_well_known_symbol();
      var ITERATOR = wellKnownSymbol("iterator");
      var SAFE_CLOSING = false;
      try {
        called = 0;
        iteratorWithReturn = {
          next: function() {
            return { done: !!called++ };
          },
          "return": function() {
            SAFE_CLOSING = true;
          }
        };
        iteratorWithReturn[ITERATOR] = function() {
          return this;
        };
        Array.from(iteratorWithReturn, function() {
          throw 2;
        });
      } catch (error) {
      }
      var called;
      var iteratorWithReturn;
      module.exports = function(exec, SKIP_CLOSING) {
        try {
          if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
        } catch (error) {
          return false;
        }
        var ITERATION_SUPPORT = false;
        try {
          var object = {};
          object[ITERATOR] = function() {
            return {
              next: function() {
                return { done: ITERATION_SUPPORT = true };
              }
            };
          };
          exec(object);
        } catch (error) {
        }
        return ITERATION_SUPPORT;
      };
    }
  });

  // node_modules/core-js/modules/es.array.from.js
  var require_es_array_from = __commonJS({
    "node_modules/core-js/modules/es.array.from.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var from = require_array_from();
      var checkCorrectnessOfIteration = require_check_correctness_of_iteration();
      var INCORRECT_ITERATION = !checkCorrectnessOfIteration(function(iterable) {
        Array.from(iterable);
      });
      $({ target: "Array", stat: true, forced: INCORRECT_ITERATION }, {
        from
      });
    }
  });

  // node_modules/core-js/modules/es.array.includes.js
  var require_es_array_includes = __commonJS({
    "node_modules/core-js/modules/es.array.includes.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var $includes = require_array_includes().includes;
      var fails = require_fails();
      var addToUnscopables = require_add_to_unscopables();
      var BROKEN_ON_SPARSE = fails(function() {
        return !Array(1).includes();
      });
      $({ target: "Array", proto: true, forced: BROKEN_ON_SPARSE }, {
        includes: function includes(el) {
          return $includes(this, el, arguments.length > 1 ? arguments[1] : void 0);
        }
      });
      addToUnscopables("includes");
    }
  });

  // node_modules/core-js/modules/es.array.index-of.js
  var require_es_array_index_of = __commonJS({
    "node_modules/core-js/modules/es.array.index-of.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var uncurryThis = require_function_uncurry_this_clause();
      var $indexOf = require_array_includes().indexOf;
      var arrayMethodIsStrict = require_array_method_is_strict();
      var nativeIndexOf = uncurryThis([].indexOf);
      var NEGATIVE_ZERO = !!nativeIndexOf && 1 / nativeIndexOf([1], 1, -0) < 0;
      var FORCED = NEGATIVE_ZERO || !arrayMethodIsStrict("indexOf");
      $({ target: "Array", proto: true, forced: FORCED }, {
        indexOf: function indexOf(searchElement) {
          var fromIndex = arguments.length > 1 ? arguments[1] : void 0;
          return NEGATIVE_ZERO ? nativeIndexOf(this, searchElement, fromIndex) || 0 : $indexOf(this, searchElement, fromIndex);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.array.is-array.js
  var require_es_array_is_array = __commonJS({
    "node_modules/core-js/modules/es.array.is-array.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var isArray = require_is_array();
      $({ target: "Array", stat: true }, {
        isArray
      });
    }
  });

  // node_modules/core-js/internals/iterators-core.js
  var require_iterators_core = __commonJS({
    "node_modules/core-js/internals/iterators-core.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var fails = require_fails();
      var isCallable = require_is_callable();
      var isObject2 = require_is_object();
      var create = require_object_create();
      var getPrototypeOf = require_object_get_prototype_of();
      var defineBuiltIn = require_define_built_in();
      var wellKnownSymbol = require_well_known_symbol();
      var IS_PURE = require_is_pure();
      var ITERATOR = wellKnownSymbol("iterator");
      var BUGGY_SAFARI_ITERATORS = false;
      var IteratorPrototype;
      var PrototypeOfArrayIteratorPrototype;
      var arrayIterator;
      if ([].keys) {
        arrayIterator = [].keys();
        if (!("next" in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
        else {
          PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
          if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
        }
      }
      var NEW_ITERATOR_PROTOTYPE = !isObject2(IteratorPrototype) || fails(function() {
        var test = {};
        return IteratorPrototype[ITERATOR].call(test) !== test;
      });
      if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype = {};
      else if (IS_PURE) IteratorPrototype = create(IteratorPrototype);
      if (!isCallable(IteratorPrototype[ITERATOR])) {
        defineBuiltIn(IteratorPrototype, ITERATOR, function() {
          return this;
        });
      }
      module.exports = {
        IteratorPrototype,
        BUGGY_SAFARI_ITERATORS
      };
    }
  });

  // node_modules/core-js/internals/iterator-create-constructor.js
  var require_iterator_create_constructor = __commonJS({
    "node_modules/core-js/internals/iterator-create-constructor.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var IteratorPrototype = require_iterators_core().IteratorPrototype;
      var create = require_object_create();
      var createPropertyDescriptor = require_create_property_descriptor();
      var setToStringTag = require_set_to_string_tag();
      var Iterators = require_iterators();
      var returnThis = function() {
        return this;
      };
      module.exports = function(IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {
        var TO_STRING_TAG = NAME + " Iterator";
        IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(+!ENUMERABLE_NEXT, next) });
        setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
        Iterators[TO_STRING_TAG] = returnThis;
        return IteratorConstructor;
      };
    }
  });

  // node_modules/core-js/internals/iterator-define.js
  var require_iterator_define = __commonJS({
    "node_modules/core-js/internals/iterator-define.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var call = require_function_call();
      var IS_PURE = require_is_pure();
      var FunctionName = require_function_name();
      var isCallable = require_is_callable();
      var createIteratorConstructor = require_iterator_create_constructor();
      var getPrototypeOf = require_object_get_prototype_of();
      var setPrototypeOf = require_object_set_prototype_of();
      var setToStringTag = require_set_to_string_tag();
      var createNonEnumerableProperty = require_create_non_enumerable_property();
      var defineBuiltIn = require_define_built_in();
      var wellKnownSymbol = require_well_known_symbol();
      var Iterators = require_iterators();
      var IteratorsCore = require_iterators_core();
      var PROPER_FUNCTION_NAME = FunctionName.PROPER;
      var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
      var IteratorPrototype = IteratorsCore.IteratorPrototype;
      var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
      var ITERATOR = wellKnownSymbol("iterator");
      var KEYS = "keys";
      var VALUES = "values";
      var ENTRIES = "entries";
      var returnThis = function() {
        return this;
      };
      module.exports = function(Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
        createIteratorConstructor(IteratorConstructor, NAME, next);
        var getIterationMethod = function(KIND) {
          if (KIND === DEFAULT && defaultIterator) return defaultIterator;
          if (!BUGGY_SAFARI_ITERATORS && KIND && KIND in IterablePrototype) return IterablePrototype[KIND];
          switch (KIND) {
            case KEYS:
              return function keys() {
                return new IteratorConstructor(this, KIND);
              };
            case VALUES:
              return function values() {
                return new IteratorConstructor(this, KIND);
              };
            case ENTRIES:
              return function entries() {
                return new IteratorConstructor(this, KIND);
              };
          }
          return function() {
            return new IteratorConstructor(this);
          };
        };
        var TO_STRING_TAG = NAME + " Iterator";
        var INCORRECT_VALUES_NAME = false;
        var IterablePrototype = Iterable.prototype;
        var nativeIterator = IterablePrototype[ITERATOR] || IterablePrototype["@@iterator"] || DEFAULT && IterablePrototype[DEFAULT];
        var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
        var anyNativeIterator = NAME === "Array" ? IterablePrototype.entries || nativeIterator : nativeIterator;
        var CurrentIteratorPrototype, methods, KEY;
        if (anyNativeIterator) {
          CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
          if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
            if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
              if (setPrototypeOf) {
                setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
              } else if (!isCallable(CurrentIteratorPrototype[ITERATOR])) {
                defineBuiltIn(CurrentIteratorPrototype, ITERATOR, returnThis);
              }
            }
            setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
            if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis;
          }
        }
        if (PROPER_FUNCTION_NAME && DEFAULT === VALUES && nativeIterator && nativeIterator.name !== VALUES) {
          if (!IS_PURE && CONFIGURABLE_FUNCTION_NAME) {
            createNonEnumerableProperty(IterablePrototype, "name", VALUES);
          } else {
            INCORRECT_VALUES_NAME = true;
            defaultIterator = function values() {
              return call(nativeIterator, this);
            };
          }
        }
        if (DEFAULT) {
          methods = {
            values: getIterationMethod(VALUES),
            keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
            entries: getIterationMethod(ENTRIES)
          };
          if (FORCED) for (KEY in methods) {
            if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
              defineBuiltIn(IterablePrototype, KEY, methods[KEY]);
            }
          }
          else $({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
        }
        if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
          defineBuiltIn(IterablePrototype, ITERATOR, defaultIterator, { name: DEFAULT });
        }
        Iterators[NAME] = defaultIterator;
        return methods;
      };
    }
  });

  // node_modules/core-js/internals/create-iter-result-object.js
  var require_create_iter_result_object = __commonJS({
    "node_modules/core-js/internals/create-iter-result-object.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      module.exports = function(value, done) {
        return { value, done };
      };
    }
  });

  // node_modules/core-js/modules/es.array.iterator.js
  var require_es_array_iterator = __commonJS({
    "node_modules/core-js/modules/es.array.iterator.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var toIndexedObject = require_to_indexed_object();
      var addToUnscopables = require_add_to_unscopables();
      var Iterators = require_iterators();
      var InternalStateModule = require_internal_state();
      var defineProperty = require_object_define_property().f;
      var defineIterator = require_iterator_define();
      var createIterResultObject = require_create_iter_result_object();
      var IS_PURE = require_is_pure();
      var DESCRIPTORS = require_descriptors();
      var ARRAY_ITERATOR = "Array Iterator";
      var setInternalState = InternalStateModule.set;
      var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);
      module.exports = defineIterator(Array, "Array", function(iterated, kind) {
        setInternalState(this, {
          type: ARRAY_ITERATOR,
          target: toIndexedObject(iterated),
          // target
          index: 0,
          // next index
          kind
          // kind
        });
      }, function() {
        var state = getInternalState(this);
        var target = state.target;
        var index = state.index++;
        if (!target || index >= target.length) {
          state.target = void 0;
          return createIterResultObject(void 0, true);
        }
        switch (state.kind) {
          case "keys":
            return createIterResultObject(index, false);
          case "values":
            return createIterResultObject(target[index], false);
        }
        return createIterResultObject([index, target[index]], false);
      }, "values");
      var values = Iterators.Arguments = Iterators.Array;
      addToUnscopables("keys");
      addToUnscopables("values");
      addToUnscopables("entries");
      if (!IS_PURE && DESCRIPTORS && values.name !== "values") try {
        defineProperty(values, "name", { value: "values" });
      } catch (error) {
      }
    }
  });

  // node_modules/core-js/modules/es.array.join.js
  var require_es_array_join = __commonJS({
    "node_modules/core-js/modules/es.array.join.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var uncurryThis = require_function_uncurry_this();
      var IndexedObject = require_indexed_object();
      var toIndexedObject = require_to_indexed_object();
      var arrayMethodIsStrict = require_array_method_is_strict();
      var nativeJoin = uncurryThis([].join);
      var ES3_STRINGS = IndexedObject !== Object;
      var FORCED = ES3_STRINGS || !arrayMethodIsStrict("join", ",");
      $({ target: "Array", proto: true, forced: FORCED }, {
        join: function join(separator) {
          return nativeJoin(toIndexedObject(this), separator === void 0 ? "," : separator);
        }
      });
    }
  });

  // node_modules/core-js/internals/array-last-index-of.js
  var require_array_last_index_of = __commonJS({
    "node_modules/core-js/internals/array-last-index-of.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var apply = require_function_apply();
      var toIndexedObject = require_to_indexed_object();
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var lengthOfArrayLike = require_length_of_array_like();
      var arrayMethodIsStrict = require_array_method_is_strict();
      var min = Math.min;
      var $lastIndexOf = [].lastIndexOf;
      var NEGATIVE_ZERO = !!$lastIndexOf && 1 / [1].lastIndexOf(1, -0) < 0;
      var STRICT_METHOD = arrayMethodIsStrict("lastIndexOf");
      var FORCED = NEGATIVE_ZERO || !STRICT_METHOD;
      module.exports = FORCED ? function lastIndexOf(searchElement) {
        if (NEGATIVE_ZERO) return apply($lastIndexOf, this, arguments) || 0;
        var O = toIndexedObject(this);
        var length = lengthOfArrayLike(O);
        if (length === 0) return -1;
        var index = length - 1;
        if (arguments.length > 1) index = min(index, toIntegerOrInfinity(arguments[1]));
        if (index < 0) index = length + index;
        for (; index >= 0; index--) if (index in O && O[index] === searchElement) return index || 0;
        return -1;
      } : $lastIndexOf;
    }
  });

  // node_modules/core-js/modules/es.array.last-index-of.js
  var require_es_array_last_index_of = __commonJS({
    "node_modules/core-js/modules/es.array.last-index-of.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var lastIndexOf = require_array_last_index_of();
      $({ target: "Array", proto: true, forced: lastIndexOf !== [].lastIndexOf }, {
        lastIndexOf
      });
    }
  });

  // node_modules/core-js/modules/es.array.map.js
  var require_es_array_map = __commonJS({
    "node_modules/core-js/modules/es.array.map.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var $map = require_array_iteration().map;
      var arrayMethodHasSpeciesSupport = require_array_method_has_species_support();
      var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("map");
      $({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT }, {
        map: function map(callbackfn) {
          return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.array.of.js
  var require_es_array_of = __commonJS({
    "node_modules/core-js/modules/es.array.of.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var fails = require_fails();
      var isConstructor = require_is_constructor();
      var createProperty = require_create_property();
      var $Array = Array;
      var ISNT_GENERIC = fails(function() {
        function F() {
        }
        return !($Array.of.call(F) instanceof F);
      });
      $({ target: "Array", stat: true, forced: ISNT_GENERIC }, {
        of: function of() {
          var index = 0;
          var argumentsLength = arguments.length;
          var result = new (isConstructor(this) ? this : $Array)(argumentsLength);
          while (argumentsLength > index) createProperty(result, index, arguments[index++]);
          result.length = argumentsLength;
          return result;
        }
      });
    }
  });

  // node_modules/core-js/internals/array-set-length.js
  var require_array_set_length = __commonJS({
    "node_modules/core-js/internals/array-set-length.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var DESCRIPTORS = require_descriptors();
      var isArray = require_is_array();
      var $TypeError = TypeError;
      var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
      var SILENT_ON_NON_WRITABLE_LENGTH_SET = DESCRIPTORS && !function() {
        if (this !== void 0) return true;
        try {
          Object.defineProperty([], "length", { writable: false }).length = 1;
        } catch (error) {
          return error instanceof TypeError;
        }
      }();
      module.exports = SILENT_ON_NON_WRITABLE_LENGTH_SET ? function(O, length) {
        if (isArray(O) && !getOwnPropertyDescriptor(O, "length").writable) {
          throw new $TypeError("Cannot set read only .length");
        }
        return O.length = length;
      } : function(O, length) {
        return O.length = length;
      };
    }
  });

  // node_modules/core-js/modules/es.array.push.js
  var require_es_array_push = __commonJS({
    "node_modules/core-js/modules/es.array.push.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var toObject = require_to_object();
      var lengthOfArrayLike = require_length_of_array_like();
      var setArrayLength = require_array_set_length();
      var doesNotExceedSafeInteger = require_does_not_exceed_safe_integer();
      var fails = require_fails();
      var INCORRECT_TO_LENGTH = fails(function() {
        return [].push.call({ length: 4294967296 }, 1) !== 4294967297;
      });
      var properErrorOnNonWritableLength = function() {
        try {
          Object.defineProperty([], "length", { writable: false }).push();
        } catch (error) {
          return error instanceof TypeError;
        }
      };
      var FORCED = INCORRECT_TO_LENGTH || !properErrorOnNonWritableLength();
      $({ target: "Array", proto: true, arity: 1, forced: FORCED }, {
        // eslint-disable-next-line no-unused-vars -- required for `.length`
        push: function push(item) {
          var O = toObject(this);
          var len = lengthOfArrayLike(O);
          var argCount = arguments.length;
          doesNotExceedSafeInteger(len + argCount);
          for (var i = 0; i < argCount; i++) {
            O[len] = arguments[i];
            len++;
          }
          setArrayLength(O, len);
          return len;
        }
      });
    }
  });

  // node_modules/core-js/internals/array-reduce.js
  var require_array_reduce = __commonJS({
    "node_modules/core-js/internals/array-reduce.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var aCallable = require_a_callable();
      var toObject = require_to_object();
      var IndexedObject = require_indexed_object();
      var lengthOfArrayLike = require_length_of_array_like();
      var $TypeError = TypeError;
      var REDUCE_EMPTY = "Reduce of empty array with no initial value";
      var createMethod = function(IS_RIGHT) {
        return function(that, callbackfn, argumentsLength, memo35) {
          var O = toObject(that);
          var self2 = IndexedObject(O);
          var length = lengthOfArrayLike(O);
          aCallable(callbackfn);
          if (length === 0 && argumentsLength < 2) throw new $TypeError(REDUCE_EMPTY);
          var index = IS_RIGHT ? length - 1 : 0;
          var i = IS_RIGHT ? -1 : 1;
          if (argumentsLength < 2) while (true) {
            if (index in self2) {
              memo35 = self2[index];
              index += i;
              break;
            }
            index += i;
            if (IS_RIGHT ? index < 0 : length <= index) {
              throw new $TypeError(REDUCE_EMPTY);
            }
          }
          for (; IS_RIGHT ? index >= 0 : length > index; index += i) if (index in self2) {
            memo35 = callbackfn(memo35, self2[index], index, O);
          }
          return memo35;
        };
      };
      module.exports = {
        // `Array.prototype.reduce` method
        // https://tc39.es/ecma262/#sec-array.prototype.reduce
        left: createMethod(false),
        // `Array.prototype.reduceRight` method
        // https://tc39.es/ecma262/#sec-array.prototype.reduceright
        right: createMethod(true)
      };
    }
  });

  // node_modules/core-js/internals/engine-is-node.js
  var require_engine_is_node = __commonJS({
    "node_modules/core-js/internals/engine-is-node.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var global2 = require_global();
      var classof = require_classof_raw();
      module.exports = classof(global2.process) === "process";
    }
  });

  // node_modules/core-js/modules/es.array.reduce.js
  var require_es_array_reduce = __commonJS({
    "node_modules/core-js/modules/es.array.reduce.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var $reduce = require_array_reduce().left;
      var arrayMethodIsStrict = require_array_method_is_strict();
      var CHROME_VERSION = require_engine_v8_version();
      var IS_NODE = require_engine_is_node();
      var CHROME_BUG = !IS_NODE && CHROME_VERSION > 79 && CHROME_VERSION < 83;
      var FORCED = CHROME_BUG || !arrayMethodIsStrict("reduce");
      $({ target: "Array", proto: true, forced: FORCED }, {
        reduce: function reduce(callbackfn) {
          var length = arguments.length;
          return $reduce(this, callbackfn, length, length > 1 ? arguments[1] : void 0);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.array.reduce-right.js
  var require_es_array_reduce_right = __commonJS({
    "node_modules/core-js/modules/es.array.reduce-right.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var $reduceRight = require_array_reduce().right;
      var arrayMethodIsStrict = require_array_method_is_strict();
      var CHROME_VERSION = require_engine_v8_version();
      var IS_NODE = require_engine_is_node();
      var CHROME_BUG = !IS_NODE && CHROME_VERSION > 79 && CHROME_VERSION < 83;
      var FORCED = CHROME_BUG || !arrayMethodIsStrict("reduceRight");
      $({ target: "Array", proto: true, forced: FORCED }, {
        reduceRight: function reduceRight(callbackfn) {
          return $reduceRight(this, callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : void 0);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.array.reverse.js
  var require_es_array_reverse = __commonJS({
    "node_modules/core-js/modules/es.array.reverse.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var uncurryThis = require_function_uncurry_this();
      var isArray = require_is_array();
      var nativeReverse = uncurryThis([].reverse);
      var test = [1, 2];
      $({ target: "Array", proto: true, forced: String(test) === String(test.reverse()) }, {
        reverse: function reverse() {
          if (isArray(this)) this.length = this.length;
          return nativeReverse(this);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.array.slice.js
  var require_es_array_slice = __commonJS({
    "node_modules/core-js/modules/es.array.slice.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var isArray = require_is_array();
      var isConstructor = require_is_constructor();
      var isObject2 = require_is_object();
      var toAbsoluteIndex = require_to_absolute_index();
      var lengthOfArrayLike = require_length_of_array_like();
      var toIndexedObject = require_to_indexed_object();
      var createProperty = require_create_property();
      var wellKnownSymbol = require_well_known_symbol();
      var arrayMethodHasSpeciesSupport = require_array_method_has_species_support();
      var nativeSlice = require_array_slice();
      var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("slice");
      var SPECIES = wellKnownSymbol("species");
      var $Array = Array;
      var max = Math.max;
      $({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT }, {
        slice: function slice(start, end) {
          var O = toIndexedObject(this);
          var length = lengthOfArrayLike(O);
          var k = toAbsoluteIndex(start, length);
          var fin = toAbsoluteIndex(end === void 0 ? length : end, length);
          var Constructor, result, n;
          if (isArray(O)) {
            Constructor = O.constructor;
            if (isConstructor(Constructor) && (Constructor === $Array || isArray(Constructor.prototype))) {
              Constructor = void 0;
            } else if (isObject2(Constructor)) {
              Constructor = Constructor[SPECIES];
              if (Constructor === null) Constructor = void 0;
            }
            if (Constructor === $Array || Constructor === void 0) {
              return nativeSlice(O, k, fin);
            }
          }
          result = new (Constructor === void 0 ? $Array : Constructor)(max(fin - k, 0));
          for (n = 0; k < fin; k++, n++) if (k in O) createProperty(result, n, O[k]);
          result.length = n;
          return result;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.array.some.js
  var require_es_array_some = __commonJS({
    "node_modules/core-js/modules/es.array.some.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var $some = require_array_iteration().some;
      var arrayMethodIsStrict = require_array_method_is_strict();
      var STRICT_METHOD = arrayMethodIsStrict("some");
      $({ target: "Array", proto: true, forced: !STRICT_METHOD }, {
        some: function some(callbackfn) {
          return $some(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
        }
      });
    }
  });

  // node_modules/core-js/internals/array-sort.js
  var require_array_sort = __commonJS({
    "node_modules/core-js/internals/array-sort.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var arraySlice2 = require_array_slice();
      var floor = Math.floor;
      var sort = function(array, comparefn) {
        var length = array.length;
        if (length < 8) {
          var i = 1;
          var element, j;
          while (i < length) {
            j = i;
            element = array[i];
            while (j && comparefn(array[j - 1], element) > 0) {
              array[j] = array[--j];
            }
            if (j !== i++) array[j] = element;
          }
        } else {
          var middle = floor(length / 2);
          var left = sort(arraySlice2(array, 0, middle), comparefn);
          var right = sort(arraySlice2(array, middle), comparefn);
          var llength = left.length;
          var rlength = right.length;
          var lindex = 0;
          var rindex = 0;
          while (lindex < llength || rindex < rlength) {
            array[lindex + rindex] = lindex < llength && rindex < rlength ? comparefn(left[lindex], right[rindex]) <= 0 ? left[lindex++] : right[rindex++] : lindex < llength ? left[lindex++] : right[rindex++];
          }
        }
        return array;
      };
      module.exports = sort;
    }
  });

  // node_modules/core-js/internals/engine-ff-version.js
  var require_engine_ff_version = __commonJS({
    "node_modules/core-js/internals/engine-ff-version.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var userAgent = require_engine_user_agent();
      var firefox = userAgent.match(/firefox\/(\d+)/i);
      module.exports = !!firefox && +firefox[1];
    }
  });

  // node_modules/core-js/internals/engine-is-ie-or-edge.js
  var require_engine_is_ie_or_edge = __commonJS({
    "node_modules/core-js/internals/engine-is-ie-or-edge.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var UA = require_engine_user_agent();
      module.exports = /MSIE|Trident/.test(UA);
    }
  });

  // node_modules/core-js/internals/engine-webkit-version.js
  var require_engine_webkit_version = __commonJS({
    "node_modules/core-js/internals/engine-webkit-version.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var userAgent = require_engine_user_agent();
      var webkit = userAgent.match(/AppleWebKit\/(\d+)\./);
      module.exports = !!webkit && +webkit[1];
    }
  });

  // node_modules/core-js/modules/es.array.sort.js
  var require_es_array_sort = __commonJS({
    "node_modules/core-js/modules/es.array.sort.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var uncurryThis = require_function_uncurry_this();
      var aCallable = require_a_callable();
      var toObject = require_to_object();
      var lengthOfArrayLike = require_length_of_array_like();
      var deletePropertyOrThrow = require_delete_property_or_throw();
      var toString = require_to_string();
      var fails = require_fails();
      var internalSort = require_array_sort();
      var arrayMethodIsStrict = require_array_method_is_strict();
      var FF = require_engine_ff_version();
      var IE_OR_EDGE = require_engine_is_ie_or_edge();
      var V8 = require_engine_v8_version();
      var WEBKIT = require_engine_webkit_version();
      var test = [];
      var nativeSort = uncurryThis(test.sort);
      var push = uncurryThis(test.push);
      var FAILS_ON_UNDEFINED = fails(function() {
        test.sort(void 0);
      });
      var FAILS_ON_NULL = fails(function() {
        test.sort(null);
      });
      var STRICT_METHOD = arrayMethodIsStrict("sort");
      var STABLE_SORT = !fails(function() {
        if (V8) return V8 < 70;
        if (FF && FF > 3) return;
        if (IE_OR_EDGE) return true;
        if (WEBKIT) return WEBKIT < 603;
        var result = "";
        var code, chr, value, index;
        for (code = 65; code < 76; code++) {
          chr = String.fromCharCode(code);
          switch (code) {
            case 66:
            case 69:
            case 70:
            case 72:
              value = 3;
              break;
            case 68:
            case 71:
              value = 4;
              break;
            default:
              value = 2;
          }
          for (index = 0; index < 47; index++) {
            test.push({ k: chr + index, v: value });
          }
        }
        test.sort(function(a, b) {
          return b.v - a.v;
        });
        for (index = 0; index < test.length; index++) {
          chr = test[index].k.charAt(0);
          if (result.charAt(result.length - 1) !== chr) result += chr;
        }
        return result !== "DGBEFHACIJK";
      });
      var FORCED = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD || !STABLE_SORT;
      var getSortCompare = function(comparefn) {
        return function(x, y) {
          if (y === void 0) return -1;
          if (x === void 0) return 1;
          if (comparefn !== void 0) return +comparefn(x, y) || 0;
          return toString(x) > toString(y) ? 1 : -1;
        };
      };
      $({ target: "Array", proto: true, forced: FORCED }, {
        sort: function sort(comparefn) {
          if (comparefn !== void 0) aCallable(comparefn);
          var array = toObject(this);
          if (STABLE_SORT) return comparefn === void 0 ? nativeSort(array) : nativeSort(array, comparefn);
          var items = [];
          var arrayLength = lengthOfArrayLike(array);
          var itemsLength, index;
          for (index = 0; index < arrayLength; index++) {
            if (index in array) push(items, array[index]);
          }
          internalSort(items, getSortCompare(comparefn));
          itemsLength = lengthOfArrayLike(items);
          index = 0;
          while (index < itemsLength) array[index] = items[index++];
          while (index < arrayLength) deletePropertyOrThrow(array, index++);
          return array;
        }
      });
    }
  });

  // node_modules/core-js/internals/set-species.js
  var require_set_species = __commonJS({
    "node_modules/core-js/internals/set-species.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var getBuiltIn = require_get_built_in();
      var defineBuiltInAccessor = require_define_built_in_accessor();
      var wellKnownSymbol = require_well_known_symbol();
      var DESCRIPTORS = require_descriptors();
      var SPECIES = wellKnownSymbol("species");
      module.exports = function(CONSTRUCTOR_NAME) {
        var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
        if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) {
          defineBuiltInAccessor(Constructor, SPECIES, {
            configurable: true,
            get: function() {
              return this;
            }
          });
        }
      };
    }
  });

  // node_modules/core-js/modules/es.array.species.js
  var require_es_array_species = __commonJS({
    "node_modules/core-js/modules/es.array.species.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var setSpecies = require_set_species();
      setSpecies("Array");
    }
  });

  // node_modules/core-js/modules/es.array.splice.js
  var require_es_array_splice = __commonJS({
    "node_modules/core-js/modules/es.array.splice.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var toObject = require_to_object();
      var toAbsoluteIndex = require_to_absolute_index();
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var lengthOfArrayLike = require_length_of_array_like();
      var setArrayLength = require_array_set_length();
      var doesNotExceedSafeInteger = require_does_not_exceed_safe_integer();
      var arraySpeciesCreate = require_array_species_create();
      var createProperty = require_create_property();
      var deletePropertyOrThrow = require_delete_property_or_throw();
      var arrayMethodHasSpeciesSupport = require_array_method_has_species_support();
      var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("splice");
      var max = Math.max;
      var min = Math.min;
      $({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT }, {
        splice: function splice(start, deleteCount) {
          var O = toObject(this);
          var len = lengthOfArrayLike(O);
          var actualStart = toAbsoluteIndex(start, len);
          var argumentsLength = arguments.length;
          var insertCount, actualDeleteCount, A, k, from, to;
          if (argumentsLength === 0) {
            insertCount = actualDeleteCount = 0;
          } else if (argumentsLength === 1) {
            insertCount = 0;
            actualDeleteCount = len - actualStart;
          } else {
            insertCount = argumentsLength - 2;
            actualDeleteCount = min(max(toIntegerOrInfinity(deleteCount), 0), len - actualStart);
          }
          doesNotExceedSafeInteger(len + insertCount - actualDeleteCount);
          A = arraySpeciesCreate(O, actualDeleteCount);
          for (k = 0; k < actualDeleteCount; k++) {
            from = actualStart + k;
            if (from in O) createProperty(A, k, O[from]);
          }
          A.length = actualDeleteCount;
          if (insertCount < actualDeleteCount) {
            for (k = actualStart; k < len - actualDeleteCount; k++) {
              from = k + actualDeleteCount;
              to = k + insertCount;
              if (from in O) O[to] = O[from];
              else deletePropertyOrThrow(O, to);
            }
            for (k = len; k > len - actualDeleteCount + insertCount; k--) deletePropertyOrThrow(O, k - 1);
          } else if (insertCount > actualDeleteCount) {
            for (k = len - actualDeleteCount; k > actualStart; k--) {
              from = k + actualDeleteCount - 1;
              to = k + insertCount - 1;
              if (from in O) O[to] = O[from];
              else deletePropertyOrThrow(O, to);
            }
          }
          for (k = 0; k < insertCount; k++) {
            O[k + actualStart] = arguments[k + 2];
          }
          setArrayLength(O, len - actualDeleteCount + insertCount);
          return A;
        }
      });
    }
  });

  // node_modules/core-js/internals/array-to-reversed.js
  var require_array_to_reversed = __commonJS({
    "node_modules/core-js/internals/array-to-reversed.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var lengthOfArrayLike = require_length_of_array_like();
      module.exports = function(O, C) {
        var len = lengthOfArrayLike(O);
        var A = new C(len);
        var k = 0;
        for (; k < len; k++) A[k] = O[len - k - 1];
        return A;
      };
    }
  });

  // node_modules/core-js/modules/es.array.to-reversed.js
  var require_es_array_to_reversed = __commonJS({
    "node_modules/core-js/modules/es.array.to-reversed.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var arrayToReversed = require_array_to_reversed();
      var toIndexedObject = require_to_indexed_object();
      var addToUnscopables = require_add_to_unscopables();
      var $Array = Array;
      $({ target: "Array", proto: true }, {
        toReversed: function toReversed() {
          return arrayToReversed(toIndexedObject(this), $Array);
        }
      });
      addToUnscopables("toReversed");
    }
  });

  // node_modules/core-js/internals/array-from-constructor-and-list.js
  var require_array_from_constructor_and_list = __commonJS({
    "node_modules/core-js/internals/array-from-constructor-and-list.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var lengthOfArrayLike = require_length_of_array_like();
      module.exports = function(Constructor, list, $length) {
        var index = 0;
        var length = arguments.length > 2 ? $length : lengthOfArrayLike(list);
        var result = new Constructor(length);
        while (length > index) result[index] = list[index++];
        return result;
      };
    }
  });

  // node_modules/core-js/internals/get-built-in-prototype-method.js
  var require_get_built_in_prototype_method = __commonJS({
    "node_modules/core-js/internals/get-built-in-prototype-method.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var global2 = require_global();
      module.exports = function(CONSTRUCTOR, METHOD) {
        var Constructor = global2[CONSTRUCTOR];
        var Prototype = Constructor && Constructor.prototype;
        return Prototype && Prototype[METHOD];
      };
    }
  });

  // node_modules/core-js/modules/es.array.to-sorted.js
  var require_es_array_to_sorted = __commonJS({
    "node_modules/core-js/modules/es.array.to-sorted.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var uncurryThis = require_function_uncurry_this();
      var aCallable = require_a_callable();
      var toIndexedObject = require_to_indexed_object();
      var arrayFromConstructorAndList = require_array_from_constructor_and_list();
      var getBuiltInPrototypeMethod = require_get_built_in_prototype_method();
      var addToUnscopables = require_add_to_unscopables();
      var $Array = Array;
      var sort = uncurryThis(getBuiltInPrototypeMethod("Array", "sort"));
      $({ target: "Array", proto: true }, {
        toSorted: function toSorted(compareFn) {
          if (compareFn !== void 0) aCallable(compareFn);
          var O = toIndexedObject(this);
          var A = arrayFromConstructorAndList($Array, O);
          return sort(A, compareFn);
        }
      });
      addToUnscopables("toSorted");
    }
  });

  // node_modules/core-js/modules/es.array.to-spliced.js
  var require_es_array_to_spliced = __commonJS({
    "node_modules/core-js/modules/es.array.to-spliced.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var addToUnscopables = require_add_to_unscopables();
      var doesNotExceedSafeInteger = require_does_not_exceed_safe_integer();
      var lengthOfArrayLike = require_length_of_array_like();
      var toAbsoluteIndex = require_to_absolute_index();
      var toIndexedObject = require_to_indexed_object();
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var $Array = Array;
      var max = Math.max;
      var min = Math.min;
      $({ target: "Array", proto: true }, {
        toSpliced: function toSpliced(start, deleteCount) {
          var O = toIndexedObject(this);
          var len = lengthOfArrayLike(O);
          var actualStart = toAbsoluteIndex(start, len);
          var argumentsLength = arguments.length;
          var k = 0;
          var insertCount, actualDeleteCount, newLen, A;
          if (argumentsLength === 0) {
            insertCount = actualDeleteCount = 0;
          } else if (argumentsLength === 1) {
            insertCount = 0;
            actualDeleteCount = len - actualStart;
          } else {
            insertCount = argumentsLength - 2;
            actualDeleteCount = min(max(toIntegerOrInfinity(deleteCount), 0), len - actualStart);
          }
          newLen = doesNotExceedSafeInteger(len + insertCount - actualDeleteCount);
          A = $Array(newLen);
          for (; k < actualStart; k++) A[k] = O[k];
          for (; k < actualStart + insertCount; k++) A[k] = arguments[k - actualStart + 2];
          for (; k < newLen; k++) A[k] = O[k + actualDeleteCount - insertCount];
          return A;
        }
      });
      addToUnscopables("toSpliced");
    }
  });

  // node_modules/core-js/modules/es.array.unscopables.flat.js
  var require_es_array_unscopables_flat = __commonJS({
    "node_modules/core-js/modules/es.array.unscopables.flat.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var addToUnscopables = require_add_to_unscopables();
      addToUnscopables("flat");
    }
  });

  // node_modules/core-js/modules/es.array.unscopables.flat-map.js
  var require_es_array_unscopables_flat_map = __commonJS({
    "node_modules/core-js/modules/es.array.unscopables.flat-map.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var addToUnscopables = require_add_to_unscopables();
      addToUnscopables("flatMap");
    }
  });

  // node_modules/core-js/modules/es.array.unshift.js
  var require_es_array_unshift = __commonJS({
    "node_modules/core-js/modules/es.array.unshift.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var toObject = require_to_object();
      var lengthOfArrayLike = require_length_of_array_like();
      var setArrayLength = require_array_set_length();
      var deletePropertyOrThrow = require_delete_property_or_throw();
      var doesNotExceedSafeInteger = require_does_not_exceed_safe_integer();
      var INCORRECT_RESULT = [].unshift(0) !== 1;
      var properErrorOnNonWritableLength = function() {
        try {
          Object.defineProperty([], "length", { writable: false }).unshift();
        } catch (error) {
          return error instanceof TypeError;
        }
      };
      var FORCED = INCORRECT_RESULT || !properErrorOnNonWritableLength();
      $({ target: "Array", proto: true, arity: 1, forced: FORCED }, {
        // eslint-disable-next-line no-unused-vars -- required for `.length`
        unshift: function unshift(item) {
          var O = toObject(this);
          var len = lengthOfArrayLike(O);
          var argCount = arguments.length;
          if (argCount) {
            doesNotExceedSafeInteger(len + argCount);
            var k = len;
            while (k--) {
              var to = k + argCount;
              if (k in O) O[to] = O[k];
              else deletePropertyOrThrow(O, to);
            }
            for (var j = 0; j < argCount; j++) {
              O[j] = arguments[j];
            }
          }
          return setArrayLength(O, len + argCount);
        }
      });
    }
  });

  // node_modules/core-js/internals/array-with.js
  var require_array_with = __commonJS({
    "node_modules/core-js/internals/array-with.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var lengthOfArrayLike = require_length_of_array_like();
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var $RangeError = RangeError;
      module.exports = function(O, C, index, value) {
        var len = lengthOfArrayLike(O);
        var relativeIndex = toIntegerOrInfinity(index);
        var actualIndex = relativeIndex < 0 ? len + relativeIndex : relativeIndex;
        if (actualIndex >= len || actualIndex < 0) throw new $RangeError("Incorrect index");
        var A = new C(len);
        var k = 0;
        for (; k < len; k++) A[k] = k === actualIndex ? value : O[k];
        return A;
      };
    }
  });

  // node_modules/core-js/modules/es.array.with.js
  var require_es_array_with = __commonJS({
    "node_modules/core-js/modules/es.array.with.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var arrayWith = require_array_with();
      var toIndexedObject = require_to_indexed_object();
      var $Array = Array;
      $({ target: "Array", proto: true }, {
        "with": function(index, value) {
          return arrayWith(toIndexedObject(this), $Array, index, value);
        }
      });
    }
  });

  // node_modules/core-js/internals/array-buffer-basic-detection.js
  var require_array_buffer_basic_detection = __commonJS({
    "node_modules/core-js/internals/array-buffer-basic-detection.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      module.exports = typeof ArrayBuffer != "undefined" && typeof DataView != "undefined";
    }
  });

  // node_modules/core-js/internals/define-built-ins.js
  var require_define_built_ins = __commonJS({
    "node_modules/core-js/internals/define-built-ins.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var defineBuiltIn = require_define_built_in();
      module.exports = function(target, src, options) {
        for (var key in src) defineBuiltIn(target, key, src[key], options);
        return target;
      };
    }
  });

  // node_modules/core-js/internals/an-instance.js
  var require_an_instance = __commonJS({
    "node_modules/core-js/internals/an-instance.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var isPrototypeOf = require_object_is_prototype_of();
      var $TypeError = TypeError;
      module.exports = function(it, Prototype) {
        if (isPrototypeOf(Prototype, it)) return it;
        throw new $TypeError("Incorrect invocation");
      };
    }
  });

  // node_modules/core-js/internals/to-index.js
  var require_to_index = __commonJS({
    "node_modules/core-js/internals/to-index.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var toLength = require_to_length();
      var $RangeError = RangeError;
      module.exports = function(it) {
        if (it === void 0) return 0;
        var number = toIntegerOrInfinity(it);
        var length = toLength(number);
        if (number !== length) throw new $RangeError("Wrong length or index");
        return length;
      };
    }
  });

  // node_modules/core-js/internals/math-sign.js
  var require_math_sign = __commonJS({
    "node_modules/core-js/internals/math-sign.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      module.exports = Math.sign || function sign(x) {
        var n = +x;
        return n === 0 || n !== n ? n : n < 0 ? -1 : 1;
      };
    }
  });

  // node_modules/core-js/internals/math-float-round.js
  var require_math_float_round = __commonJS({
    "node_modules/core-js/internals/math-float-round.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var sign = require_math_sign();
      var abs = Math.abs;
      var EPSILON4 = 2220446049250313e-31;
      var INVERSE_EPSILON = 1 / EPSILON4;
      var roundTiesToEven = function(n) {
        return n + INVERSE_EPSILON - INVERSE_EPSILON;
      };
      module.exports = function(x, FLOAT_EPSILON, FLOAT_MAX_VALUE, FLOAT_MIN_VALUE) {
        var n = +x;
        var absolute = abs(n);
        var s = sign(n);
        if (absolute < FLOAT_MIN_VALUE) return s * roundTiesToEven(absolute / FLOAT_MIN_VALUE / FLOAT_EPSILON) * FLOAT_MIN_VALUE * FLOAT_EPSILON;
        var a = (1 + FLOAT_EPSILON / EPSILON4) * absolute;
        var result = a - (a - absolute);
        if (result > FLOAT_MAX_VALUE || result !== result) return s * Infinity;
        return s * result;
      };
    }
  });

  // node_modules/core-js/internals/math-fround.js
  var require_math_fround = __commonJS({
    "node_modules/core-js/internals/math-fround.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var floatRound = require_math_float_round();
      var FLOAT32_EPSILON = 11920928955078125e-23;
      var FLOAT32_MAX_VALUE = 34028234663852886e22;
      var FLOAT32_MIN_VALUE = 11754943508222875e-54;
      module.exports = Math.fround || function fround(x) {
        return floatRound(x, FLOAT32_EPSILON, FLOAT32_MAX_VALUE, FLOAT32_MIN_VALUE);
      };
    }
  });

  // node_modules/core-js/internals/ieee754.js
  var require_ieee754 = __commonJS({
    "node_modules/core-js/internals/ieee754.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $Array = Array;
      var abs = Math.abs;
      var pow = Math.pow;
      var floor = Math.floor;
      var log = Math.log;
      var LN2 = Math.LN2;
      var pack = function(number, mantissaLength, bytes) {
        var buffer = $Array(bytes);
        var exponentLength = bytes * 8 - mantissaLength - 1;
        var eMax = (1 << exponentLength) - 1;
        var eBias = eMax >> 1;
        var rt = mantissaLength === 23 ? pow(2, -24) - pow(2, -77) : 0;
        var sign = number < 0 || number === 0 && 1 / number < 0 ? 1 : 0;
        var index = 0;
        var exponent, mantissa, c;
        number = abs(number);
        if (number !== number || number === Infinity) {
          mantissa = number !== number ? 1 : 0;
          exponent = eMax;
        } else {
          exponent = floor(log(number) / LN2);
          c = pow(2, -exponent);
          if (number * c < 1) {
            exponent--;
            c *= 2;
          }
          if (exponent + eBias >= 1) {
            number += rt / c;
          } else {
            number += rt * pow(2, 1 - eBias);
          }
          if (number * c >= 2) {
            exponent++;
            c /= 2;
          }
          if (exponent + eBias >= eMax) {
            mantissa = 0;
            exponent = eMax;
          } else if (exponent + eBias >= 1) {
            mantissa = (number * c - 1) * pow(2, mantissaLength);
            exponent += eBias;
          } else {
            mantissa = number * pow(2, eBias - 1) * pow(2, mantissaLength);
            exponent = 0;
          }
        }
        while (mantissaLength >= 8) {
          buffer[index++] = mantissa & 255;
          mantissa /= 256;
          mantissaLength -= 8;
        }
        exponent = exponent << mantissaLength | mantissa;
        exponentLength += mantissaLength;
        while (exponentLength > 0) {
          buffer[index++] = exponent & 255;
          exponent /= 256;
          exponentLength -= 8;
        }
        buffer[--index] |= sign * 128;
        return buffer;
      };
      var unpack = function(buffer, mantissaLength) {
        var bytes = buffer.length;
        var exponentLength = bytes * 8 - mantissaLength - 1;
        var eMax = (1 << exponentLength) - 1;
        var eBias = eMax >> 1;
        var nBits = exponentLength - 7;
        var index = bytes - 1;
        var sign = buffer[index--];
        var exponent = sign & 127;
        var mantissa;
        sign >>= 7;
        while (nBits > 0) {
          exponent = exponent * 256 + buffer[index--];
          nBits -= 8;
        }
        mantissa = exponent & (1 << -nBits) - 1;
        exponent >>= -nBits;
        nBits += mantissaLength;
        while (nBits > 0) {
          mantissa = mantissa * 256 + buffer[index--];
          nBits -= 8;
        }
        if (exponent === 0) {
          exponent = 1 - eBias;
        } else if (exponent === eMax) {
          return mantissa ? NaN : sign ? -Infinity : Infinity;
        } else {
          mantissa += pow(2, mantissaLength);
          exponent -= eBias;
        }
        return (sign ? -1 : 1) * mantissa * pow(2, exponent - mantissaLength);
      };
      module.exports = {
        pack,
        unpack
      };
    }
  });

  // node_modules/core-js/internals/array-buffer.js
  var require_array_buffer = __commonJS({
    "node_modules/core-js/internals/array-buffer.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var global2 = require_global();
      var uncurryThis = require_function_uncurry_this();
      var DESCRIPTORS = require_descriptors();
      var NATIVE_ARRAY_BUFFER = require_array_buffer_basic_detection();
      var FunctionName = require_function_name();
      var createNonEnumerableProperty = require_create_non_enumerable_property();
      var defineBuiltInAccessor = require_define_built_in_accessor();
      var defineBuiltIns = require_define_built_ins();
      var fails = require_fails();
      var anInstance = require_an_instance();
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var toLength = require_to_length();
      var toIndex = require_to_index();
      var fround = require_math_fround();
      var IEEE754 = require_ieee754();
      var getPrototypeOf = require_object_get_prototype_of();
      var setPrototypeOf = require_object_set_prototype_of();
      var arrayFill = require_array_fill();
      var arraySlice2 = require_array_slice();
      var inheritIfRequired = require_inherit_if_required();
      var copyConstructorProperties = require_copy_constructor_properties();
      var setToStringTag = require_set_to_string_tag();
      var InternalStateModule = require_internal_state();
      var PROPER_FUNCTION_NAME = FunctionName.PROPER;
      var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
      var ARRAY_BUFFER = "ArrayBuffer";
      var DATA_VIEW = "DataView";
      var PROTOTYPE = "prototype";
      var WRONG_LENGTH = "Wrong length";
      var WRONG_INDEX = "Wrong index";
      var getInternalArrayBufferState = InternalStateModule.getterFor(ARRAY_BUFFER);
      var getInternalDataViewState = InternalStateModule.getterFor(DATA_VIEW);
      var setInternalState = InternalStateModule.set;
      var NativeArrayBuffer = global2[ARRAY_BUFFER];
      var $ArrayBuffer = NativeArrayBuffer;
      var ArrayBufferPrototype = $ArrayBuffer && $ArrayBuffer[PROTOTYPE];
      var $DataView = global2[DATA_VIEW];
      var DataViewPrototype = $DataView && $DataView[PROTOTYPE];
      var ObjectPrototype = Object.prototype;
      var Array2 = global2.Array;
      var RangeError2 = global2.RangeError;
      var fill = uncurryThis(arrayFill);
      var reverse = uncurryThis([].reverse);
      var packIEEE754 = IEEE754.pack;
      var unpackIEEE754 = IEEE754.unpack;
      var packInt8 = function(number) {
        return [number & 255];
      };
      var packInt16 = function(number) {
        return [number & 255, number >> 8 & 255];
      };
      var packInt32 = function(number) {
        return [number & 255, number >> 8 & 255, number >> 16 & 255, number >> 24 & 255];
      };
      var unpackInt32 = function(buffer) {
        return buffer[3] << 24 | buffer[2] << 16 | buffer[1] << 8 | buffer[0];
      };
      var packFloat32 = function(number) {
        return packIEEE754(fround(number), 23, 4);
      };
      var packFloat64 = function(number) {
        return packIEEE754(number, 52, 8);
      };
      var addGetter = function(Constructor, key, getInternalState) {
        defineBuiltInAccessor(Constructor[PROTOTYPE], key, {
          configurable: true,
          get: function() {
            return getInternalState(this)[key];
          }
        });
      };
      var get2 = function(view, count, index, isLittleEndian) {
        var store = getInternalDataViewState(view);
        var intIndex = toIndex(index);
        var boolIsLittleEndian = !!isLittleEndian;
        if (intIndex + count > store.byteLength) throw new RangeError2(WRONG_INDEX);
        var bytes = store.bytes;
        var start = intIndex + store.byteOffset;
        var pack = arraySlice2(bytes, start, start + count);
        return boolIsLittleEndian ? pack : reverse(pack);
      };
      var set2 = function(view, count, index, conversion, value, isLittleEndian) {
        var store = getInternalDataViewState(view);
        var intIndex = toIndex(index);
        var pack = conversion(+value);
        var boolIsLittleEndian = !!isLittleEndian;
        if (intIndex + count > store.byteLength) throw new RangeError2(WRONG_INDEX);
        var bytes = store.bytes;
        var start = intIndex + store.byteOffset;
        for (var i = 0; i < count; i++) bytes[start + i] = pack[boolIsLittleEndian ? i : count - i - 1];
      };
      if (!NATIVE_ARRAY_BUFFER) {
        $ArrayBuffer = function ArrayBuffer2(length) {
          anInstance(this, ArrayBufferPrototype);
          var byteLength = toIndex(length);
          setInternalState(this, {
            type: ARRAY_BUFFER,
            bytes: fill(Array2(byteLength), 0),
            byteLength
          });
          if (!DESCRIPTORS) {
            this.byteLength = byteLength;
            this.detached = false;
          }
        };
        ArrayBufferPrototype = $ArrayBuffer[PROTOTYPE];
        $DataView = function DataView2(buffer, byteOffset, byteLength) {
          anInstance(this, DataViewPrototype);
          anInstance(buffer, ArrayBufferPrototype);
          var bufferState = getInternalArrayBufferState(buffer);
          var bufferLength = bufferState.byteLength;
          var offset = toIntegerOrInfinity(byteOffset);
          if (offset < 0 || offset > bufferLength) throw new RangeError2("Wrong offset");
          byteLength = byteLength === void 0 ? bufferLength - offset : toLength(byteLength);
          if (offset + byteLength > bufferLength) throw new RangeError2(WRONG_LENGTH);
          setInternalState(this, {
            type: DATA_VIEW,
            buffer,
            byteLength,
            byteOffset: offset,
            bytes: bufferState.bytes
          });
          if (!DESCRIPTORS) {
            this.buffer = buffer;
            this.byteLength = byteLength;
            this.byteOffset = offset;
          }
        };
        DataViewPrototype = $DataView[PROTOTYPE];
        if (DESCRIPTORS) {
          addGetter($ArrayBuffer, "byteLength", getInternalArrayBufferState);
          addGetter($DataView, "buffer", getInternalDataViewState);
          addGetter($DataView, "byteLength", getInternalDataViewState);
          addGetter($DataView, "byteOffset", getInternalDataViewState);
        }
        defineBuiltIns(DataViewPrototype, {
          getInt8: function getInt8(byteOffset) {
            return get2(this, 1, byteOffset)[0] << 24 >> 24;
          },
          getUint8: function getUint8(byteOffset) {
            return get2(this, 1, byteOffset)[0];
          },
          getInt16: function getInt16(byteOffset) {
            var bytes = get2(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : false);
            return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
          },
          getUint16: function getUint16(byteOffset) {
            var bytes = get2(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : false);
            return bytes[1] << 8 | bytes[0];
          },
          getInt32: function getInt32(byteOffset) {
            return unpackInt32(get2(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : false));
          },
          getUint32: function getUint32(byteOffset) {
            return unpackInt32(get2(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : false)) >>> 0;
          },
          getFloat32: function getFloat32(byteOffset) {
            return unpackIEEE754(get2(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : false), 23);
          },
          getFloat64: function getFloat64(byteOffset) {
            return unpackIEEE754(get2(this, 8, byteOffset, arguments.length > 1 ? arguments[1] : false), 52);
          },
          setInt8: function setInt8(byteOffset, value) {
            set2(this, 1, byteOffset, packInt8, value);
          },
          setUint8: function setUint8(byteOffset, value) {
            set2(this, 1, byteOffset, packInt8, value);
          },
          setInt16: function setInt16(byteOffset, value) {
            set2(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : false);
          },
          setUint16: function setUint16(byteOffset, value) {
            set2(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : false);
          },
          setInt32: function setInt32(byteOffset, value) {
            set2(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : false);
          },
          setUint32: function setUint32(byteOffset, value) {
            set2(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : false);
          },
          setFloat32: function setFloat32(byteOffset, value) {
            set2(this, 4, byteOffset, packFloat32, value, arguments.length > 2 ? arguments[2] : false);
          },
          setFloat64: function setFloat64(byteOffset, value) {
            set2(this, 8, byteOffset, packFloat64, value, arguments.length > 2 ? arguments[2] : false);
          }
        });
      } else {
        INCORRECT_ARRAY_BUFFER_NAME = PROPER_FUNCTION_NAME && NativeArrayBuffer.name !== ARRAY_BUFFER;
        if (!fails(function() {
          NativeArrayBuffer(1);
        }) || !fails(function() {
          new NativeArrayBuffer(-1);
        }) || fails(function() {
          new NativeArrayBuffer();
          new NativeArrayBuffer(1.5);
          new NativeArrayBuffer(NaN);
          return NativeArrayBuffer.length !== 1 || INCORRECT_ARRAY_BUFFER_NAME && !CONFIGURABLE_FUNCTION_NAME;
        })) {
          $ArrayBuffer = function ArrayBuffer2(length) {
            anInstance(this, ArrayBufferPrototype);
            return inheritIfRequired(new NativeArrayBuffer(toIndex(length)), this, $ArrayBuffer);
          };
          $ArrayBuffer[PROTOTYPE] = ArrayBufferPrototype;
          ArrayBufferPrototype.constructor = $ArrayBuffer;
          copyConstructorProperties($ArrayBuffer, NativeArrayBuffer);
        } else if (INCORRECT_ARRAY_BUFFER_NAME && CONFIGURABLE_FUNCTION_NAME) {
          createNonEnumerableProperty(NativeArrayBuffer, "name", ARRAY_BUFFER);
        }
        if (setPrototypeOf && getPrototypeOf(DataViewPrototype) !== ObjectPrototype) {
          setPrototypeOf(DataViewPrototype, ObjectPrototype);
        }
        testView = new $DataView(new $ArrayBuffer(2));
        $setInt8 = uncurryThis(DataViewPrototype.setInt8);
        testView.setInt8(0, 2147483648);
        testView.setInt8(1, 2147483649);
        if (testView.getInt8(0) || !testView.getInt8(1)) defineBuiltIns(DataViewPrototype, {
          setInt8: function setInt8(byteOffset, value) {
            $setInt8(this, byteOffset, value << 24 >> 24);
          },
          setUint8: function setUint8(byteOffset, value) {
            $setInt8(this, byteOffset, value << 24 >> 24);
          }
        }, { unsafe: true });
      }
      var INCORRECT_ARRAY_BUFFER_NAME;
      var testView;
      var $setInt8;
      setToStringTag($ArrayBuffer, ARRAY_BUFFER);
      setToStringTag($DataView, DATA_VIEW);
      module.exports = {
        ArrayBuffer: $ArrayBuffer,
        DataView: $DataView
      };
    }
  });

  // node_modules/core-js/modules/es.array-buffer.constructor.js
  var require_es_array_buffer_constructor = __commonJS({
    "node_modules/core-js/modules/es.array-buffer.constructor.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var global2 = require_global();
      var arrayBufferModule = require_array_buffer();
      var setSpecies = require_set_species();
      var ARRAY_BUFFER = "ArrayBuffer";
      var ArrayBuffer2 = arrayBufferModule[ARRAY_BUFFER];
      var NativeArrayBuffer = global2[ARRAY_BUFFER];
      $({ global: true, constructor: true, forced: NativeArrayBuffer !== ArrayBuffer2 }, {
        ArrayBuffer: ArrayBuffer2
      });
      setSpecies(ARRAY_BUFFER);
    }
  });

  // node_modules/core-js/internals/array-buffer-view-core.js
  var require_array_buffer_view_core = __commonJS({
    "node_modules/core-js/internals/array-buffer-view-core.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var NATIVE_ARRAY_BUFFER = require_array_buffer_basic_detection();
      var DESCRIPTORS = require_descriptors();
      var global2 = require_global();
      var isCallable = require_is_callable();
      var isObject2 = require_is_object();
      var hasOwn = require_has_own_property();
      var classof = require_classof();
      var tryToString = require_try_to_string();
      var createNonEnumerableProperty = require_create_non_enumerable_property();
      var defineBuiltIn = require_define_built_in();
      var defineBuiltInAccessor = require_define_built_in_accessor();
      var isPrototypeOf = require_object_is_prototype_of();
      var getPrototypeOf = require_object_get_prototype_of();
      var setPrototypeOf = require_object_set_prototype_of();
      var wellKnownSymbol = require_well_known_symbol();
      var uid = require_uid();
      var InternalStateModule = require_internal_state();
      var enforceInternalState = InternalStateModule.enforce;
      var getInternalState = InternalStateModule.get;
      var Int8Array2 = global2.Int8Array;
      var Int8ArrayPrototype = Int8Array2 && Int8Array2.prototype;
      var Uint8ClampedArray2 = global2.Uint8ClampedArray;
      var Uint8ClampedArrayPrototype = Uint8ClampedArray2 && Uint8ClampedArray2.prototype;
      var TypedArray = Int8Array2 && getPrototypeOf(Int8Array2);
      var TypedArrayPrototype = Int8ArrayPrototype && getPrototypeOf(Int8ArrayPrototype);
      var ObjectPrototype = Object.prototype;
      var TypeError2 = global2.TypeError;
      var TO_STRING_TAG = wellKnownSymbol("toStringTag");
      var TYPED_ARRAY_TAG = uid("TYPED_ARRAY_TAG");
      var TYPED_ARRAY_CONSTRUCTOR = "TypedArrayConstructor";
      var NATIVE_ARRAY_BUFFER_VIEWS = NATIVE_ARRAY_BUFFER && !!setPrototypeOf && classof(global2.opera) !== "Opera";
      var TYPED_ARRAY_TAG_REQUIRED = false;
      var NAME;
      var Constructor;
      var Prototype;
      var TypedArrayConstructorsList = {
        Int8Array: 1,
        Uint8Array: 1,
        Uint8ClampedArray: 1,
        Int16Array: 2,
        Uint16Array: 2,
        Int32Array: 4,
        Uint32Array: 4,
        Float32Array: 4,
        Float64Array: 8
      };
      var BigIntArrayConstructorsList = {
        BigInt64Array: 8,
        BigUint64Array: 8
      };
      var isView = function isView2(it) {
        if (!isObject2(it)) return false;
        var klass = classof(it);
        return klass === "DataView" || hasOwn(TypedArrayConstructorsList, klass) || hasOwn(BigIntArrayConstructorsList, klass);
      };
      var getTypedArrayConstructor = function(it) {
        var proto = getPrototypeOf(it);
        if (!isObject2(proto)) return;
        var state = getInternalState(proto);
        return state && hasOwn(state, TYPED_ARRAY_CONSTRUCTOR) ? state[TYPED_ARRAY_CONSTRUCTOR] : getTypedArrayConstructor(proto);
      };
      var isTypedArray = function(it) {
        if (!isObject2(it)) return false;
        var klass = classof(it);
        return hasOwn(TypedArrayConstructorsList, klass) || hasOwn(BigIntArrayConstructorsList, klass);
      };
      var aTypedArray = function(it) {
        if (isTypedArray(it)) return it;
        throw new TypeError2("Target is not a typed array");
      };
      var aTypedArrayConstructor = function(C) {
        if (isCallable(C) && (!setPrototypeOf || isPrototypeOf(TypedArray, C))) return C;
        throw new TypeError2(tryToString(C) + " is not a typed array constructor");
      };
      var exportTypedArrayMethod = function(KEY, property, forced, options) {
        if (!DESCRIPTORS) return;
        if (forced) for (var ARRAY in TypedArrayConstructorsList) {
          var TypedArrayConstructor = global2[ARRAY];
          if (TypedArrayConstructor && hasOwn(TypedArrayConstructor.prototype, KEY)) try {
            delete TypedArrayConstructor.prototype[KEY];
          } catch (error) {
            try {
              TypedArrayConstructor.prototype[KEY] = property;
            } catch (error2) {
            }
          }
        }
        if (!TypedArrayPrototype[KEY] || forced) {
          defineBuiltIn(TypedArrayPrototype, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && Int8ArrayPrototype[KEY] || property, options);
        }
      };
      var exportTypedArrayStaticMethod = function(KEY, property, forced) {
        var ARRAY, TypedArrayConstructor;
        if (!DESCRIPTORS) return;
        if (setPrototypeOf) {
          if (forced) for (ARRAY in TypedArrayConstructorsList) {
            TypedArrayConstructor = global2[ARRAY];
            if (TypedArrayConstructor && hasOwn(TypedArrayConstructor, KEY)) try {
              delete TypedArrayConstructor[KEY];
            } catch (error) {
            }
          }
          if (!TypedArray[KEY] || forced) {
            try {
              return defineBuiltIn(TypedArray, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && TypedArray[KEY] || property);
            } catch (error) {
            }
          } else return;
        }
        for (ARRAY in TypedArrayConstructorsList) {
          TypedArrayConstructor = global2[ARRAY];
          if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {
            defineBuiltIn(TypedArrayConstructor, KEY, property);
          }
        }
      };
      for (NAME in TypedArrayConstructorsList) {
        Constructor = global2[NAME];
        Prototype = Constructor && Constructor.prototype;
        if (Prototype) enforceInternalState(Prototype)[TYPED_ARRAY_CONSTRUCTOR] = Constructor;
        else NATIVE_ARRAY_BUFFER_VIEWS = false;
      }
      for (NAME in BigIntArrayConstructorsList) {
        Constructor = global2[NAME];
        Prototype = Constructor && Constructor.prototype;
        if (Prototype) enforceInternalState(Prototype)[TYPED_ARRAY_CONSTRUCTOR] = Constructor;
      }
      if (!NATIVE_ARRAY_BUFFER_VIEWS || !isCallable(TypedArray) || TypedArray === Function.prototype) {
        TypedArray = function TypedArray2() {
          throw new TypeError2("Incorrect invocation");
        };
        if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {
          if (global2[NAME]) setPrototypeOf(global2[NAME], TypedArray);
        }
      }
      if (!NATIVE_ARRAY_BUFFER_VIEWS || !TypedArrayPrototype || TypedArrayPrototype === ObjectPrototype) {
        TypedArrayPrototype = TypedArray.prototype;
        if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {
          if (global2[NAME]) setPrototypeOf(global2[NAME].prototype, TypedArrayPrototype);
        }
      }
      if (NATIVE_ARRAY_BUFFER_VIEWS && getPrototypeOf(Uint8ClampedArrayPrototype) !== TypedArrayPrototype) {
        setPrototypeOf(Uint8ClampedArrayPrototype, TypedArrayPrototype);
      }
      if (DESCRIPTORS && !hasOwn(TypedArrayPrototype, TO_STRING_TAG)) {
        TYPED_ARRAY_TAG_REQUIRED = true;
        defineBuiltInAccessor(TypedArrayPrototype, TO_STRING_TAG, {
          configurable: true,
          get: function() {
            return isObject2(this) ? this[TYPED_ARRAY_TAG] : void 0;
          }
        });
        for (NAME in TypedArrayConstructorsList) if (global2[NAME]) {
          createNonEnumerableProperty(global2[NAME], TYPED_ARRAY_TAG, NAME);
        }
      }
      module.exports = {
        NATIVE_ARRAY_BUFFER_VIEWS,
        TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQUIRED && TYPED_ARRAY_TAG,
        aTypedArray,
        aTypedArrayConstructor,
        exportTypedArrayMethod,
        exportTypedArrayStaticMethod,
        getTypedArrayConstructor,
        isView,
        isTypedArray,
        TypedArray,
        TypedArrayPrototype
      };
    }
  });

  // node_modules/core-js/modules/es.array-buffer.is-view.js
  var require_es_array_buffer_is_view = __commonJS({
    "node_modules/core-js/modules/es.array-buffer.is-view.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var NATIVE_ARRAY_BUFFER_VIEWS = ArrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;
      $({ target: "ArrayBuffer", stat: true, forced: !NATIVE_ARRAY_BUFFER_VIEWS }, {
        isView: ArrayBufferViewCore.isView
      });
    }
  });

  // node_modules/core-js/internals/a-constructor.js
  var require_a_constructor = __commonJS({
    "node_modules/core-js/internals/a-constructor.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var isConstructor = require_is_constructor();
      var tryToString = require_try_to_string();
      var $TypeError = TypeError;
      module.exports = function(argument) {
        if (isConstructor(argument)) return argument;
        throw new $TypeError(tryToString(argument) + " is not a constructor");
      };
    }
  });

  // node_modules/core-js/internals/species-constructor.js
  var require_species_constructor = __commonJS({
    "node_modules/core-js/internals/species-constructor.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var anObject = require_an_object();
      var aConstructor = require_a_constructor();
      var isNullOrUndefined2 = require_is_null_or_undefined();
      var wellKnownSymbol = require_well_known_symbol();
      var SPECIES = wellKnownSymbol("species");
      module.exports = function(O, defaultConstructor) {
        var C = anObject(O).constructor;
        var S;
        return C === void 0 || isNullOrUndefined2(S = anObject(C)[SPECIES]) ? defaultConstructor : aConstructor(S);
      };
    }
  });

  // node_modules/core-js/modules/es.array-buffer.slice.js
  var require_es_array_buffer_slice = __commonJS({
    "node_modules/core-js/modules/es.array-buffer.slice.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var uncurryThis = require_function_uncurry_this_clause();
      var fails = require_fails();
      var ArrayBufferModule = require_array_buffer();
      var anObject = require_an_object();
      var toAbsoluteIndex = require_to_absolute_index();
      var toLength = require_to_length();
      var speciesConstructor = require_species_constructor();
      var ArrayBuffer2 = ArrayBufferModule.ArrayBuffer;
      var DataView2 = ArrayBufferModule.DataView;
      var DataViewPrototype = DataView2.prototype;
      var nativeArrayBufferSlice = uncurryThis(ArrayBuffer2.prototype.slice);
      var getUint8 = uncurryThis(DataViewPrototype.getUint8);
      var setUint8 = uncurryThis(DataViewPrototype.setUint8);
      var INCORRECT_SLICE = fails(function() {
        return !new ArrayBuffer2(2).slice(1, void 0).byteLength;
      });
      $({ target: "ArrayBuffer", proto: true, unsafe: true, forced: INCORRECT_SLICE }, {
        slice: function slice(start, end) {
          if (nativeArrayBufferSlice && end === void 0) {
            return nativeArrayBufferSlice(anObject(this), start);
          }
          var length = anObject(this).byteLength;
          var first = toAbsoluteIndex(start, length);
          var fin = toAbsoluteIndex(end === void 0 ? length : end, length);
          var result = new (speciesConstructor(this, ArrayBuffer2))(toLength(fin - first));
          var viewSource = new DataView2(this);
          var viewTarget = new DataView2(result);
          var index = 0;
          while (first < fin) {
            setUint8(viewTarget, index++, getUint8(viewSource, first++));
          }
          return result;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.data-view.constructor.js
  var require_es_data_view_constructor = __commonJS({
    "node_modules/core-js/modules/es.data-view.constructor.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var ArrayBufferModule = require_array_buffer();
      var NATIVE_ARRAY_BUFFER = require_array_buffer_basic_detection();
      $({ global: true, constructor: true, forced: !NATIVE_ARRAY_BUFFER }, {
        DataView: ArrayBufferModule.DataView
      });
    }
  });

  // node_modules/core-js/modules/es.data-view.js
  var require_es_data_view = __commonJS({
    "node_modules/core-js/modules/es.data-view.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      require_es_data_view_constructor();
    }
  });

  // node_modules/core-js/internals/array-buffer-byte-length.js
  var require_array_buffer_byte_length = __commonJS({
    "node_modules/core-js/internals/array-buffer-byte-length.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var uncurryThisAccessor = require_function_uncurry_this_accessor();
      var classof = require_classof_raw();
      var $TypeError = TypeError;
      module.exports = uncurryThisAccessor(ArrayBuffer.prototype, "byteLength", "get") || function(O) {
        if (classof(O) !== "ArrayBuffer") throw new $TypeError("ArrayBuffer expected");
        return O.byteLength;
      };
    }
  });

  // node_modules/core-js/internals/array-buffer-is-detached.js
  var require_array_buffer_is_detached = __commonJS({
    "node_modules/core-js/internals/array-buffer-is-detached.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var uncurryThis = require_function_uncurry_this();
      var arrayBufferByteLength = require_array_buffer_byte_length();
      var slice = uncurryThis(ArrayBuffer.prototype.slice);
      module.exports = function(O) {
        if (arrayBufferByteLength(O) !== 0) return false;
        try {
          slice(O, 0, 0);
          return false;
        } catch (error) {
          return true;
        }
      };
    }
  });

  // node_modules/core-js/modules/es.array-buffer.detached.js
  var require_es_array_buffer_detached = __commonJS({
    "node_modules/core-js/modules/es.array-buffer.detached.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var DESCRIPTORS = require_descriptors();
      var defineBuiltInAccessor = require_define_built_in_accessor();
      var isDetached = require_array_buffer_is_detached();
      var ArrayBufferPrototype = ArrayBuffer.prototype;
      if (DESCRIPTORS && !("detached" in ArrayBufferPrototype)) {
        defineBuiltInAccessor(ArrayBufferPrototype, "detached", {
          configurable: true,
          get: function detached() {
            return isDetached(this);
          }
        });
      }
    }
  });

  // node_modules/core-js/internals/try-node-require.js
  var require_try_node_require = __commonJS({
    "node_modules/core-js/internals/try-node-require.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var IS_NODE = require_engine_is_node();
      module.exports = function(name2) {
        try {
          if (IS_NODE) return Function('return require("' + name2 + '")')();
        } catch (error) {
        }
      };
    }
  });

  // node_modules/core-js/internals/engine-is-deno.js
  var require_engine_is_deno = __commonJS({
    "node_modules/core-js/internals/engine-is-deno.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      module.exports = typeof Deno == "object" && Deno && typeof Deno.version == "object";
    }
  });

  // node_modules/core-js/internals/engine-is-browser.js
  var require_engine_is_browser = __commonJS({
    "node_modules/core-js/internals/engine-is-browser.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var IS_DENO = require_engine_is_deno();
      var IS_NODE = require_engine_is_node();
      module.exports = !IS_DENO && !IS_NODE && typeof window == "object" && typeof document == "object";
    }
  });

  // node_modules/core-js/internals/structured-clone-proper-transfer.js
  var require_structured_clone_proper_transfer = __commonJS({
    "node_modules/core-js/internals/structured-clone-proper-transfer.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var global2 = require_global();
      var fails = require_fails();
      var V8 = require_engine_v8_version();
      var IS_BROWSER = require_engine_is_browser();
      var IS_DENO = require_engine_is_deno();
      var IS_NODE = require_engine_is_node();
      var structuredClone = global2.structuredClone;
      module.exports = !!structuredClone && !fails(function() {
        if (IS_DENO && V8 > 92 || IS_NODE && V8 > 94 || IS_BROWSER && V8 > 97) return false;
        var buffer = new ArrayBuffer(8);
        var clone = structuredClone(buffer, { transfer: [buffer] });
        return buffer.byteLength !== 0 || clone.byteLength !== 8;
      });
    }
  });

  // node_modules/core-js/internals/detach-transferable.js
  var require_detach_transferable = __commonJS({
    "node_modules/core-js/internals/detach-transferable.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var global2 = require_global();
      var tryNodeRequire = require_try_node_require();
      var PROPER_STRUCTURED_CLONE_TRANSFER = require_structured_clone_proper_transfer();
      var structuredClone = global2.structuredClone;
      var $ArrayBuffer = global2.ArrayBuffer;
      var $MessageChannel = global2.MessageChannel;
      var detach = false;
      var WorkerThreads;
      var channel;
      var buffer;
      var $detach;
      if (PROPER_STRUCTURED_CLONE_TRANSFER) {
        detach = function(transferable) {
          structuredClone(transferable, { transfer: [transferable] });
        };
      } else if ($ArrayBuffer) try {
        if (!$MessageChannel) {
          WorkerThreads = tryNodeRequire("worker_threads");
          if (WorkerThreads) $MessageChannel = WorkerThreads.MessageChannel;
        }
        if ($MessageChannel) {
          channel = new $MessageChannel();
          buffer = new $ArrayBuffer(2);
          $detach = function(transferable) {
            channel.port1.postMessage(null, [transferable]);
          };
          if (buffer.byteLength === 2) {
            $detach(buffer);
            if (buffer.byteLength === 0) detach = $detach;
          }
        }
      } catch (error) {
      }
      module.exports = detach;
    }
  });

  // node_modules/core-js/internals/array-buffer-transfer.js
  var require_array_buffer_transfer = __commonJS({
    "node_modules/core-js/internals/array-buffer-transfer.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var global2 = require_global();
      var uncurryThis = require_function_uncurry_this();
      var uncurryThisAccessor = require_function_uncurry_this_accessor();
      var toIndex = require_to_index();
      var isDetached = require_array_buffer_is_detached();
      var arrayBufferByteLength = require_array_buffer_byte_length();
      var detachTransferable = require_detach_transferable();
      var PROPER_STRUCTURED_CLONE_TRANSFER = require_structured_clone_proper_transfer();
      var structuredClone = global2.structuredClone;
      var ArrayBuffer2 = global2.ArrayBuffer;
      var DataView2 = global2.DataView;
      var TypeError2 = global2.TypeError;
      var min = Math.min;
      var ArrayBufferPrototype = ArrayBuffer2.prototype;
      var DataViewPrototype = DataView2.prototype;
      var slice = uncurryThis(ArrayBufferPrototype.slice);
      var isResizable = uncurryThisAccessor(ArrayBufferPrototype, "resizable", "get");
      var maxByteLength = uncurryThisAccessor(ArrayBufferPrototype, "maxByteLength", "get");
      var getInt8 = uncurryThis(DataViewPrototype.getInt8);
      var setInt8 = uncurryThis(DataViewPrototype.setInt8);
      module.exports = (PROPER_STRUCTURED_CLONE_TRANSFER || detachTransferable) && function(arrayBuffer, newLength, preserveResizability) {
        var byteLength = arrayBufferByteLength(arrayBuffer);
        var newByteLength = newLength === void 0 ? byteLength : toIndex(newLength);
        var fixedLength = !isResizable || !isResizable(arrayBuffer);
        var newBuffer;
        if (isDetached(arrayBuffer)) throw new TypeError2("ArrayBuffer is detached");
        if (PROPER_STRUCTURED_CLONE_TRANSFER) {
          arrayBuffer = structuredClone(arrayBuffer, { transfer: [arrayBuffer] });
          if (byteLength === newByteLength && (preserveResizability || fixedLength)) return arrayBuffer;
        }
        if (byteLength >= newByteLength && (!preserveResizability || fixedLength)) {
          newBuffer = slice(arrayBuffer, 0, newByteLength);
        } else {
          var options = preserveResizability && !fixedLength && maxByteLength ? { maxByteLength: maxByteLength(arrayBuffer) } : void 0;
          newBuffer = new ArrayBuffer2(newByteLength, options);
          var a = new DataView2(arrayBuffer);
          var b = new DataView2(newBuffer);
          var copyLength = min(newByteLength, byteLength);
          for (var i = 0; i < copyLength; i++) setInt8(b, i, getInt8(a, i));
        }
        if (!PROPER_STRUCTURED_CLONE_TRANSFER) detachTransferable(arrayBuffer);
        return newBuffer;
      };
    }
  });

  // node_modules/core-js/modules/es.array-buffer.transfer.js
  var require_es_array_buffer_transfer = __commonJS({
    "node_modules/core-js/modules/es.array-buffer.transfer.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var $transfer = require_array_buffer_transfer();
      if ($transfer) $({ target: "ArrayBuffer", proto: true }, {
        transfer: function transfer() {
          return $transfer(this, arguments.length ? arguments[0] : void 0, true);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.array-buffer.transfer-to-fixed-length.js
  var require_es_array_buffer_transfer_to_fixed_length = __commonJS({
    "node_modules/core-js/modules/es.array-buffer.transfer-to-fixed-length.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var $transfer = require_array_buffer_transfer();
      if ($transfer) $({ target: "ArrayBuffer", proto: true }, {
        transferToFixedLength: function transferToFixedLength() {
          return $transfer(this, arguments.length ? arguments[0] : void 0, false);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.date.get-year.js
  var require_es_date_get_year = __commonJS({
    "node_modules/core-js/modules/es.date.get-year.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var uncurryThis = require_function_uncurry_this();
      var fails = require_fails();
      var FORCED = fails(function() {
        return (/* @__PURE__ */ new Date(16e11)).getYear() !== 120;
      });
      var getFullYear = uncurryThis(Date.prototype.getFullYear);
      $({ target: "Date", proto: true, forced: FORCED }, {
        getYear: function getYear() {
          return getFullYear(this) - 1900;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.date.now.js
  var require_es_date_now = __commonJS({
    "node_modules/core-js/modules/es.date.now.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var uncurryThis = require_function_uncurry_this();
      var $Date = Date;
      var thisTimeValue = uncurryThis($Date.prototype.getTime);
      $({ target: "Date", stat: true }, {
        now: function now() {
          return thisTimeValue(new $Date());
        }
      });
    }
  });

  // node_modules/core-js/modules/es.date.set-year.js
  var require_es_date_set_year = __commonJS({
    "node_modules/core-js/modules/es.date.set-year.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var uncurryThis = require_function_uncurry_this();
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var DatePrototype = Date.prototype;
      var thisTimeValue = uncurryThis(DatePrototype.getTime);
      var setFullYear = uncurryThis(DatePrototype.setFullYear);
      $({ target: "Date", proto: true }, {
        setYear: function setYear(year) {
          thisTimeValue(this);
          var yi = toIntegerOrInfinity(year);
          var yyyy = yi >= 0 && yi <= 99 ? yi + 1900 : yi;
          return setFullYear(this, yyyy);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.date.to-gmt-string.js
  var require_es_date_to_gmt_string = __commonJS({
    "node_modules/core-js/modules/es.date.to-gmt-string.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      $({ target: "Date", proto: true }, {
        toGMTString: Date.prototype.toUTCString
      });
    }
  });

  // node_modules/core-js/internals/string-repeat.js
  var require_string_repeat = __commonJS({
    "node_modules/core-js/internals/string-repeat.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var toString = require_to_string();
      var requireObjectCoercible = require_require_object_coercible();
      var $RangeError = RangeError;
      module.exports = function repeat(count) {
        var str = toString(requireObjectCoercible(this));
        var result = "";
        var n = toIntegerOrInfinity(count);
        if (n < 0 || n === Infinity) throw new $RangeError("Wrong number of repetitions");
        for (; n > 0; (n >>>= 1) && (str += str)) if (n & 1) result += str;
        return result;
      };
    }
  });

  // node_modules/core-js/internals/string-pad.js
  var require_string_pad = __commonJS({
    "node_modules/core-js/internals/string-pad.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var uncurryThis = require_function_uncurry_this();
      var toLength = require_to_length();
      var toString = require_to_string();
      var $repeat = require_string_repeat();
      var requireObjectCoercible = require_require_object_coercible();
      var repeat = uncurryThis($repeat);
      var stringSlice = uncurryThis("".slice);
      var ceil = Math.ceil;
      var createMethod = function(IS_END) {
        return function($this, maxLength, fillString) {
          var S = toString(requireObjectCoercible($this));
          var intMaxLength = toLength(maxLength);
          var stringLength = S.length;
          var fillStr = fillString === void 0 ? " " : toString(fillString);
          var fillLen, stringFiller;
          if (intMaxLength <= stringLength || fillStr === "") return S;
          fillLen = intMaxLength - stringLength;
          stringFiller = repeat(fillStr, ceil(fillLen / fillStr.length));
          if (stringFiller.length > fillLen) stringFiller = stringSlice(stringFiller, 0, fillLen);
          return IS_END ? S + stringFiller : stringFiller + S;
        };
      };
      module.exports = {
        // `String.prototype.padStart` method
        // https://tc39.es/ecma262/#sec-string.prototype.padstart
        start: createMethod(false),
        // `String.prototype.padEnd` method
        // https://tc39.es/ecma262/#sec-string.prototype.padend
        end: createMethod(true)
      };
    }
  });

  // node_modules/core-js/internals/date-to-iso-string.js
  var require_date_to_iso_string = __commonJS({
    "node_modules/core-js/internals/date-to-iso-string.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var uncurryThis = require_function_uncurry_this();
      var fails = require_fails();
      var padStart = require_string_pad().start;
      var $RangeError = RangeError;
      var $isFinite = isFinite;
      var abs = Math.abs;
      var DatePrototype = Date.prototype;
      var nativeDateToISOString = DatePrototype.toISOString;
      var thisTimeValue = uncurryThis(DatePrototype.getTime);
      var getUTCDate = uncurryThis(DatePrototype.getUTCDate);
      var getUTCFullYear = uncurryThis(DatePrototype.getUTCFullYear);
      var getUTCHours = uncurryThis(DatePrototype.getUTCHours);
      var getUTCMilliseconds = uncurryThis(DatePrototype.getUTCMilliseconds);
      var getUTCMinutes = uncurryThis(DatePrototype.getUTCMinutes);
      var getUTCMonth = uncurryThis(DatePrototype.getUTCMonth);
      var getUTCSeconds = uncurryThis(DatePrototype.getUTCSeconds);
      module.exports = fails(function() {
        return nativeDateToISOString.call(new Date(-5e13 - 1)) !== "0385-07-25T07:06:39.999Z";
      }) || !fails(function() {
        nativeDateToISOString.call(/* @__PURE__ */ new Date(NaN));
      }) ? function toISOString() {
        if (!$isFinite(thisTimeValue(this))) throw new $RangeError("Invalid time value");
        var date = this;
        var year = getUTCFullYear(date);
        var milliseconds = getUTCMilliseconds(date);
        var sign = year < 0 ? "-" : year > 9999 ? "+" : "";
        return sign + padStart(abs(year), sign ? 6 : 4, 0) + "-" + padStart(getUTCMonth(date) + 1, 2, 0) + "-" + padStart(getUTCDate(date), 2, 0) + "T" + padStart(getUTCHours(date), 2, 0) + ":" + padStart(getUTCMinutes(date), 2, 0) + ":" + padStart(getUTCSeconds(date), 2, 0) + "." + padStart(milliseconds, 3, 0) + "Z";
      } : nativeDateToISOString;
    }
  });

  // node_modules/core-js/modules/es.date.to-iso-string.js
  var require_es_date_to_iso_string = __commonJS({
    "node_modules/core-js/modules/es.date.to-iso-string.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var toISOString = require_date_to_iso_string();
      $({ target: "Date", proto: true, forced: Date.prototype.toISOString !== toISOString }, {
        toISOString
      });
    }
  });

  // node_modules/core-js/modules/es.date.to-json.js
  var require_es_date_to_json = __commonJS({
    "node_modules/core-js/modules/es.date.to-json.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var fails = require_fails();
      var toObject = require_to_object();
      var toPrimitive = require_to_primitive();
      var FORCED = fails(function() {
        return (/* @__PURE__ */ new Date(NaN)).toJSON() !== null || Date.prototype.toJSON.call({ toISOString: function() {
          return 1;
        } }) !== 1;
      });
      $({ target: "Date", proto: true, arity: 1, forced: FORCED }, {
        // eslint-disable-next-line no-unused-vars -- required for `.length`
        toJSON: function toJSON(key) {
          var O = toObject(this);
          var pv = toPrimitive(O, "number");
          return typeof pv == "number" && !isFinite(pv) ? null : O.toISOString();
        }
      });
    }
  });

  // node_modules/core-js/internals/date-to-primitive.js
  var require_date_to_primitive = __commonJS({
    "node_modules/core-js/internals/date-to-primitive.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var anObject = require_an_object();
      var ordinaryToPrimitive = require_ordinary_to_primitive();
      var $TypeError = TypeError;
      module.exports = function(hint) {
        anObject(this);
        if (hint === "string" || hint === "default") hint = "string";
        else if (hint !== "number") throw new $TypeError("Incorrect hint");
        return ordinaryToPrimitive(this, hint);
      };
    }
  });

  // node_modules/core-js/modules/es.date.to-primitive.js
  var require_es_date_to_primitive = __commonJS({
    "node_modules/core-js/modules/es.date.to-primitive.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var hasOwn = require_has_own_property();
      var defineBuiltIn = require_define_built_in();
      var dateToPrimitive = require_date_to_primitive();
      var wellKnownSymbol = require_well_known_symbol();
      var TO_PRIMITIVE = wellKnownSymbol("toPrimitive");
      var DatePrototype = Date.prototype;
      if (!hasOwn(DatePrototype, TO_PRIMITIVE)) {
        defineBuiltIn(DatePrototype, TO_PRIMITIVE, dateToPrimitive);
      }
    }
  });

  // node_modules/core-js/modules/es.date.to-string.js
  var require_es_date_to_string = __commonJS({
    "node_modules/core-js/modules/es.date.to-string.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var uncurryThis = require_function_uncurry_this();
      var defineBuiltIn = require_define_built_in();
      var DatePrototype = Date.prototype;
      var INVALID_DATE = "Invalid Date";
      var TO_STRING = "toString";
      var nativeDateToString = uncurryThis(DatePrototype[TO_STRING]);
      var thisTimeValue = uncurryThis(DatePrototype.getTime);
      if (String(/* @__PURE__ */ new Date(NaN)) !== INVALID_DATE) {
        defineBuiltIn(DatePrototype, TO_STRING, function toString() {
          var value = thisTimeValue(this);
          return value === value ? nativeDateToString(this) : INVALID_DATE;
        });
      }
    }
  });

  // node_modules/core-js/modules/es.escape.js
  var require_es_escape = __commonJS({
    "node_modules/core-js/modules/es.escape.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var uncurryThis = require_function_uncurry_this();
      var toString = require_to_string();
      var charAt = uncurryThis("".charAt);
      var charCodeAt = uncurryThis("".charCodeAt);
      var exec = uncurryThis(/./.exec);
      var numberToString = uncurryThis(1 .toString);
      var toUpperCase = uncurryThis("".toUpperCase);
      var raw = /[\w*+\-./@]/;
      var hex = function(code, length) {
        var result = numberToString(code, 16);
        while (result.length < length) result = "0" + result;
        return result;
      };
      $({ global: true }, {
        escape: function escape2(string) {
          var str = toString(string);
          var result = "";
          var length = str.length;
          var index = 0;
          var chr, code;
          while (index < length) {
            chr = charAt(str, index++);
            if (exec(raw, chr)) {
              result += chr;
            } else {
              code = charCodeAt(chr, 0);
              if (code < 256) {
                result += "%" + hex(code, 2);
              } else {
                result += "%u" + toUpperCase(hex(code, 4));
              }
            }
          }
          return result;
        }
      });
    }
  });

  // node_modules/core-js/internals/function-bind.js
  var require_function_bind = __commonJS({
    "node_modules/core-js/internals/function-bind.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var uncurryThis = require_function_uncurry_this();
      var aCallable = require_a_callable();
      var isObject2 = require_is_object();
      var hasOwn = require_has_own_property();
      var arraySlice2 = require_array_slice();
      var NATIVE_BIND = require_function_bind_native();
      var $Function = Function;
      var concat2 = uncurryThis([].concat);
      var join = uncurryThis([].join);
      var factories = {};
      var construct = function(C, argsLength, args) {
        if (!hasOwn(factories, argsLength)) {
          var list = [];
          var i = 0;
          for (; i < argsLength; i++) list[i] = "a[" + i + "]";
          factories[argsLength] = $Function("C,a", "return new C(" + join(list, ",") + ")");
        }
        return factories[argsLength](C, args);
      };
      module.exports = NATIVE_BIND ? $Function.bind : function bind(that) {
        var F = aCallable(this);
        var Prototype = F.prototype;
        var partArgs = arraySlice2(arguments, 1);
        var boundFunction = function bound() {
          var args = concat2(partArgs, arraySlice2(arguments));
          return this instanceof boundFunction ? construct(F, args.length, args) : F.apply(that, args);
        };
        if (isObject2(Prototype)) boundFunction.prototype = Prototype;
        return boundFunction;
      };
    }
  });

  // node_modules/core-js/modules/es.function.bind.js
  var require_es_function_bind = __commonJS({
    "node_modules/core-js/modules/es.function.bind.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var bind = require_function_bind();
      $({ target: "Function", proto: true, forced: Function.bind !== bind }, {
        bind
      });
    }
  });

  // node_modules/core-js/modules/es.function.has-instance.js
  var require_es_function_has_instance = __commonJS({
    "node_modules/core-js/modules/es.function.has-instance.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var isCallable = require_is_callable();
      var isObject2 = require_is_object();
      var definePropertyModule = require_object_define_property();
      var isPrototypeOf = require_object_is_prototype_of();
      var wellKnownSymbol = require_well_known_symbol();
      var makeBuiltIn = require_make_built_in();
      var HAS_INSTANCE = wellKnownSymbol("hasInstance");
      var FunctionPrototype = Function.prototype;
      if (!(HAS_INSTANCE in FunctionPrototype)) {
        definePropertyModule.f(FunctionPrototype, HAS_INSTANCE, { value: makeBuiltIn(function(O) {
          if (!isCallable(this) || !isObject2(O)) return false;
          var P = this.prototype;
          return isObject2(P) ? isPrototypeOf(P, O) : O instanceof this;
        }, HAS_INSTANCE) });
      }
    }
  });

  // node_modules/core-js/modules/es.function.name.js
  var require_es_function_name = __commonJS({
    "node_modules/core-js/modules/es.function.name.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var DESCRIPTORS = require_descriptors();
      var FUNCTION_NAME_EXISTS = require_function_name().EXISTS;
      var uncurryThis = require_function_uncurry_this();
      var defineBuiltInAccessor = require_define_built_in_accessor();
      var FunctionPrototype = Function.prototype;
      var functionToString = uncurryThis(FunctionPrototype.toString);
      var nameRE = /function\b(?:\s|\/\*[\S\s]*?\*\/|\/\/[^\n\r]*[\n\r]+)*([^\s(/]*)/;
      var regExpExec = uncurryThis(nameRE.exec);
      var NAME = "name";
      if (DESCRIPTORS && !FUNCTION_NAME_EXISTS) {
        defineBuiltInAccessor(FunctionPrototype, NAME, {
          configurable: true,
          get: function() {
            try {
              return regExpExec(nameRE, functionToString(this))[1];
            } catch (error) {
              return "";
            }
          }
        });
      }
    }
  });

  // node_modules/core-js/modules/es.global-this.js
  var require_es_global_this = __commonJS({
    "node_modules/core-js/modules/es.global-this.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var global2 = require_global();
      $({ global: true, forced: global2.globalThis !== global2 }, {
        globalThis: global2
      });
    }
  });

  // node_modules/core-js/modules/es.json.to-string-tag.js
  var require_es_json_to_string_tag = __commonJS({
    "node_modules/core-js/modules/es.json.to-string-tag.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var global2 = require_global();
      var setToStringTag = require_set_to_string_tag();
      setToStringTag(global2.JSON, "JSON", true);
    }
  });

  // node_modules/core-js/internals/array-buffer-non-extensible.js
  var require_array_buffer_non_extensible = __commonJS({
    "node_modules/core-js/internals/array-buffer-non-extensible.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var fails = require_fails();
      module.exports = fails(function() {
        if (typeof ArrayBuffer == "function") {
          var buffer = new ArrayBuffer(8);
          if (Object.isExtensible(buffer)) Object.defineProperty(buffer, "a", { value: 8 });
        }
      });
    }
  });

  // node_modules/core-js/internals/object-is-extensible.js
  var require_object_is_extensible = __commonJS({
    "node_modules/core-js/internals/object-is-extensible.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var fails = require_fails();
      var isObject2 = require_is_object();
      var classof = require_classof_raw();
      var ARRAY_BUFFER_NON_EXTENSIBLE = require_array_buffer_non_extensible();
      var $isExtensible = Object.isExtensible;
      var FAILS_ON_PRIMITIVES = fails(function() {
        $isExtensible(1);
      });
      module.exports = FAILS_ON_PRIMITIVES || ARRAY_BUFFER_NON_EXTENSIBLE ? function isExtensible(it) {
        if (!isObject2(it)) return false;
        if (ARRAY_BUFFER_NON_EXTENSIBLE && classof(it) === "ArrayBuffer") return false;
        return $isExtensible ? $isExtensible(it) : true;
      } : $isExtensible;
    }
  });

  // node_modules/core-js/internals/freezing.js
  var require_freezing = __commonJS({
    "node_modules/core-js/internals/freezing.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var fails = require_fails();
      module.exports = !fails(function() {
        return Object.isExtensible(Object.preventExtensions({}));
      });
    }
  });

  // node_modules/core-js/internals/internal-metadata.js
  var require_internal_metadata = __commonJS({
    "node_modules/core-js/internals/internal-metadata.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var uncurryThis = require_function_uncurry_this();
      var hiddenKeys = require_hidden_keys();
      var isObject2 = require_is_object();
      var hasOwn = require_has_own_property();
      var defineProperty = require_object_define_property().f;
      var getOwnPropertyNamesModule = require_object_get_own_property_names();
      var getOwnPropertyNamesExternalModule = require_object_get_own_property_names_external();
      var isExtensible = require_object_is_extensible();
      var uid = require_uid();
      var FREEZING = require_freezing();
      var REQUIRED = false;
      var METADATA = uid("meta");
      var id = 0;
      var setMetadata = function(it) {
        defineProperty(it, METADATA, { value: {
          objectID: "O" + id++,
          // object ID
          weakData: {}
          // weak collections IDs
        } });
      };
      var fastKey = function(it, create) {
        if (!isObject2(it)) return typeof it == "symbol" ? it : (typeof it == "string" ? "S" : "P") + it;
        if (!hasOwn(it, METADATA)) {
          if (!isExtensible(it)) return "F";
          if (!create) return "E";
          setMetadata(it);
        }
        return it[METADATA].objectID;
      };
      var getWeakData = function(it, create) {
        if (!hasOwn(it, METADATA)) {
          if (!isExtensible(it)) return true;
          if (!create) return false;
          setMetadata(it);
        }
        return it[METADATA].weakData;
      };
      var onFreeze = function(it) {
        if (FREEZING && REQUIRED && isExtensible(it) && !hasOwn(it, METADATA)) setMetadata(it);
        return it;
      };
      var enable = function() {
        meta.enable = function() {
        };
        REQUIRED = true;
        var getOwnPropertyNames = getOwnPropertyNamesModule.f;
        var splice = uncurryThis([].splice);
        var test = {};
        test[METADATA] = 1;
        if (getOwnPropertyNames(test).length) {
          getOwnPropertyNamesModule.f = function(it) {
            var result = getOwnPropertyNames(it);
            for (var i = 0, length = result.length; i < length; i++) {
              if (result[i] === METADATA) {
                splice(result, i, 1);
                break;
              }
            }
            return result;
          };
          $({ target: "Object", stat: true, forced: true }, {
            getOwnPropertyNames: getOwnPropertyNamesExternalModule.f
          });
        }
      };
      var meta = module.exports = {
        enable,
        fastKey,
        getWeakData,
        onFreeze
      };
      hiddenKeys[METADATA] = true;
    }
  });

  // node_modules/core-js/internals/collection.js
  var require_collection = __commonJS({
    "node_modules/core-js/internals/collection.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var global2 = require_global();
      var uncurryThis = require_function_uncurry_this();
      var isForced = require_is_forced();
      var defineBuiltIn = require_define_built_in();
      var InternalMetadataModule = require_internal_metadata();
      var iterate = require_iterate();
      var anInstance = require_an_instance();
      var isCallable = require_is_callable();
      var isNullOrUndefined2 = require_is_null_or_undefined();
      var isObject2 = require_is_object();
      var fails = require_fails();
      var checkCorrectnessOfIteration = require_check_correctness_of_iteration();
      var setToStringTag = require_set_to_string_tag();
      var inheritIfRequired = require_inherit_if_required();
      module.exports = function(CONSTRUCTOR_NAME, wrapper, common) {
        var IS_MAP = CONSTRUCTOR_NAME.indexOf("Map") !== -1;
        var IS_WEAK = CONSTRUCTOR_NAME.indexOf("Weak") !== -1;
        var ADDER = IS_MAP ? "set" : "add";
        var NativeConstructor = global2[CONSTRUCTOR_NAME];
        var NativePrototype = NativeConstructor && NativeConstructor.prototype;
        var Constructor = NativeConstructor;
        var exported = {};
        var fixMethod = function(KEY) {
          var uncurriedNativeMethod = uncurryThis(NativePrototype[KEY]);
          defineBuiltIn(
            NativePrototype,
            KEY,
            KEY === "add" ? function add(value) {
              uncurriedNativeMethod(this, value === 0 ? 0 : value);
              return this;
            } : KEY === "delete" ? function(key) {
              return IS_WEAK && !isObject2(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);
            } : KEY === "get" ? function get2(key) {
              return IS_WEAK && !isObject2(key) ? void 0 : uncurriedNativeMethod(this, key === 0 ? 0 : key);
            } : KEY === "has" ? function has(key) {
              return IS_WEAK && !isObject2(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);
            } : function set2(key, value) {
              uncurriedNativeMethod(this, key === 0 ? 0 : key, value);
              return this;
            }
          );
        };
        var REPLACE = isForced(
          CONSTRUCTOR_NAME,
          !isCallable(NativeConstructor) || !(IS_WEAK || NativePrototype.forEach && !fails(function() {
            new NativeConstructor().entries().next();
          }))
        );
        if (REPLACE) {
          Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);
          InternalMetadataModule.enable();
        } else if (isForced(CONSTRUCTOR_NAME, true)) {
          var instance = new Constructor();
          var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) !== instance;
          var THROWS_ON_PRIMITIVES = fails(function() {
            instance.has(1);
          });
          var ACCEPT_ITERABLES = checkCorrectnessOfIteration(function(iterable) {
            new NativeConstructor(iterable);
          });
          var BUGGY_ZERO = !IS_WEAK && fails(function() {
            var $instance = new NativeConstructor();
            var index = 5;
            while (index--) $instance[ADDER](index, index);
            return !$instance.has(-0);
          });
          if (!ACCEPT_ITERABLES) {
            Constructor = wrapper(function(dummy, iterable) {
              anInstance(dummy, NativePrototype);
              var that = inheritIfRequired(new NativeConstructor(), dummy, Constructor);
              if (!isNullOrUndefined2(iterable)) iterate(iterable, that[ADDER], { that, AS_ENTRIES: IS_MAP });
              return that;
            });
            Constructor.prototype = NativePrototype;
            NativePrototype.constructor = Constructor;
          }
          if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
            fixMethod("delete");
            fixMethod("has");
            IS_MAP && fixMethod("get");
          }
          if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);
          if (IS_WEAK && NativePrototype.clear) delete NativePrototype.clear;
        }
        exported[CONSTRUCTOR_NAME] = Constructor;
        $({ global: true, constructor: true, forced: Constructor !== NativeConstructor }, exported);
        setToStringTag(Constructor, CONSTRUCTOR_NAME);
        if (!IS_WEAK) common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);
        return Constructor;
      };
    }
  });

  // node_modules/core-js/internals/collection-strong.js
  var require_collection_strong = __commonJS({
    "node_modules/core-js/internals/collection-strong.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var create = require_object_create();
      var defineBuiltInAccessor = require_define_built_in_accessor();
      var defineBuiltIns = require_define_built_ins();
      var bind = require_function_bind_context();
      var anInstance = require_an_instance();
      var isNullOrUndefined2 = require_is_null_or_undefined();
      var iterate = require_iterate();
      var defineIterator = require_iterator_define();
      var createIterResultObject = require_create_iter_result_object();
      var setSpecies = require_set_species();
      var DESCRIPTORS = require_descriptors();
      var fastKey = require_internal_metadata().fastKey;
      var InternalStateModule = require_internal_state();
      var setInternalState = InternalStateModule.set;
      var internalStateGetterFor = InternalStateModule.getterFor;
      module.exports = {
        getConstructor: function(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
          var Constructor = wrapper(function(that, iterable) {
            anInstance(that, Prototype);
            setInternalState(that, {
              type: CONSTRUCTOR_NAME,
              index: create(null),
              first: void 0,
              last: void 0,
              size: 0
            });
            if (!DESCRIPTORS) that.size = 0;
            if (!isNullOrUndefined2(iterable)) iterate(iterable, that[ADDER], { that, AS_ENTRIES: IS_MAP });
          });
          var Prototype = Constructor.prototype;
          var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);
          var define = function(that, key, value) {
            var state = getInternalState(that);
            var entry = getEntry(that, key);
            var previous, index;
            if (entry) {
              entry.value = value;
            } else {
              state.last = entry = {
                index: index = fastKey(key, true),
                key,
                value,
                previous: previous = state.last,
                next: void 0,
                removed: false
              };
              if (!state.first) state.first = entry;
              if (previous) previous.next = entry;
              if (DESCRIPTORS) state.size++;
              else that.size++;
              if (index !== "F") state.index[index] = entry;
            }
            return that;
          };
          var getEntry = function(that, key) {
            var state = getInternalState(that);
            var index = fastKey(key);
            var entry;
            if (index !== "F") return state.index[index];
            for (entry = state.first; entry; entry = entry.next) {
              if (entry.key === key) return entry;
            }
          };
          defineBuiltIns(Prototype, {
            // `{ Map, Set }.prototype.clear()` methods
            // https://tc39.es/ecma262/#sec-map.prototype.clear
            // https://tc39.es/ecma262/#sec-set.prototype.clear
            clear: function clear() {
              var that = this;
              var state = getInternalState(that);
              var entry = state.first;
              while (entry) {
                entry.removed = true;
                if (entry.previous) entry.previous = entry.previous.next = void 0;
                entry = entry.next;
              }
              state.first = state.last = void 0;
              state.index = create(null);
              if (DESCRIPTORS) state.size = 0;
              else that.size = 0;
            },
            // `{ Map, Set }.prototype.delete(key)` methods
            // https://tc39.es/ecma262/#sec-map.prototype.delete
            // https://tc39.es/ecma262/#sec-set.prototype.delete
            "delete": function(key) {
              var that = this;
              var state = getInternalState(that);
              var entry = getEntry(that, key);
              if (entry) {
                var next = entry.next;
                var prev = entry.previous;
                delete state.index[entry.index];
                entry.removed = true;
                if (prev) prev.next = next;
                if (next) next.previous = prev;
                if (state.first === entry) state.first = next;
                if (state.last === entry) state.last = prev;
                if (DESCRIPTORS) state.size--;
                else that.size--;
              }
              return !!entry;
            },
            // `{ Map, Set }.prototype.forEach(callbackfn, thisArg = undefined)` methods
            // https://tc39.es/ecma262/#sec-map.prototype.foreach
            // https://tc39.es/ecma262/#sec-set.prototype.foreach
            forEach: function forEach2(callbackfn) {
              var state = getInternalState(this);
              var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : void 0);
              var entry;
              while (entry = entry ? entry.next : state.first) {
                boundFunction(entry.value, entry.key, this);
                while (entry && entry.removed) entry = entry.previous;
              }
            },
            // `{ Map, Set}.prototype.has(key)` methods
            // https://tc39.es/ecma262/#sec-map.prototype.has
            // https://tc39.es/ecma262/#sec-set.prototype.has
            has: function has(key) {
              return !!getEntry(this, key);
            }
          });
          defineBuiltIns(Prototype, IS_MAP ? {
            // `Map.prototype.get(key)` method
            // https://tc39.es/ecma262/#sec-map.prototype.get
            get: function get2(key) {
              var entry = getEntry(this, key);
              return entry && entry.value;
            },
            // `Map.prototype.set(key, value)` method
            // https://tc39.es/ecma262/#sec-map.prototype.set
            set: function set2(key, value) {
              return define(this, key === 0 ? 0 : key, value);
            }
          } : {
            // `Set.prototype.add(value)` method
            // https://tc39.es/ecma262/#sec-set.prototype.add
            add: function add(value) {
              return define(this, value = value === 0 ? 0 : value, value);
            }
          });
          if (DESCRIPTORS) defineBuiltInAccessor(Prototype, "size", {
            configurable: true,
            get: function() {
              return getInternalState(this).size;
            }
          });
          return Constructor;
        },
        setStrong: function(Constructor, CONSTRUCTOR_NAME, IS_MAP) {
          var ITERATOR_NAME = CONSTRUCTOR_NAME + " Iterator";
          var getInternalCollectionState = internalStateGetterFor(CONSTRUCTOR_NAME);
          var getInternalIteratorState = internalStateGetterFor(ITERATOR_NAME);
          defineIterator(Constructor, CONSTRUCTOR_NAME, function(iterated, kind) {
            setInternalState(this, {
              type: ITERATOR_NAME,
              target: iterated,
              state: getInternalCollectionState(iterated),
              kind,
              last: void 0
            });
          }, function() {
            var state = getInternalIteratorState(this);
            var kind = state.kind;
            var entry = state.last;
            while (entry && entry.removed) entry = entry.previous;
            if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {
              state.target = void 0;
              return createIterResultObject(void 0, true);
            }
            if (kind === "keys") return createIterResultObject(entry.key, false);
            if (kind === "values") return createIterResultObject(entry.value, false);
            return createIterResultObject([entry.key, entry.value], false);
          }, IS_MAP ? "entries" : "values", !IS_MAP, true);
          setSpecies(CONSTRUCTOR_NAME);
        }
      };
    }
  });

  // node_modules/core-js/modules/es.map.constructor.js
  var require_es_map_constructor = __commonJS({
    "node_modules/core-js/modules/es.map.constructor.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var collection = require_collection();
      var collectionStrong = require_collection_strong();
      collection("Map", function(init) {
        return function Map2() {
          return init(this, arguments.length ? arguments[0] : void 0);
        };
      }, collectionStrong);
    }
  });

  // node_modules/core-js/modules/es.map.js
  var require_es_map = __commonJS({
    "node_modules/core-js/modules/es.map.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      require_es_map_constructor();
    }
  });

  // node_modules/core-js/internals/map-helpers.js
  var require_map_helpers = __commonJS({
    "node_modules/core-js/internals/map-helpers.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var uncurryThis = require_function_uncurry_this();
      var MapPrototype = Map.prototype;
      module.exports = {
        // eslint-disable-next-line es/no-map -- safe
        Map,
        set: uncurryThis(MapPrototype.set),
        get: uncurryThis(MapPrototype.get),
        has: uncurryThis(MapPrototype.has),
        remove: uncurryThis(MapPrototype["delete"]),
        proto: MapPrototype
      };
    }
  });

  // node_modules/core-js/modules/es.map.group-by.js
  var require_es_map_group_by = __commonJS({
    "node_modules/core-js/modules/es.map.group-by.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var uncurryThis = require_function_uncurry_this();
      var aCallable = require_a_callable();
      var requireObjectCoercible = require_require_object_coercible();
      var iterate = require_iterate();
      var MapHelpers = require_map_helpers();
      var IS_PURE = require_is_pure();
      var fails = require_fails();
      var Map2 = MapHelpers.Map;
      var has = MapHelpers.has;
      var get2 = MapHelpers.get;
      var set2 = MapHelpers.set;
      var push = uncurryThis([].push);
      var DOES_NOT_WORK_WITH_PRIMITIVES = IS_PURE || fails(function() {
        return Map2.groupBy("ab", function(it) {
          return it;
        }).get("a").length !== 1;
      });
      $({ target: "Map", stat: true, forced: IS_PURE || DOES_NOT_WORK_WITH_PRIMITIVES }, {
        groupBy: function groupBy(items, callbackfn) {
          requireObjectCoercible(items);
          aCallable(callbackfn);
          var map = new Map2();
          var k = 0;
          iterate(items, function(value) {
            var key = callbackfn(value, k++);
            if (!has(map, key)) set2(map, key, [value]);
            else push(get2(map, key), value);
          });
          return map;
        }
      });
    }
  });

  // node_modules/core-js/internals/math-log1p.js
  var require_math_log1p = __commonJS({
    "node_modules/core-js/internals/math-log1p.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var log = Math.log;
      module.exports = Math.log1p || function log1p(x) {
        var n = +x;
        return n > -1e-8 && n < 1e-8 ? n - n * n / 2 : log(1 + n);
      };
    }
  });

  // node_modules/core-js/modules/es.math.acosh.js
  var require_es_math_acosh = __commonJS({
    "node_modules/core-js/modules/es.math.acosh.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var log1p = require_math_log1p();
      var $acosh = Math.acosh;
      var log = Math.log;
      var sqrt = Math.sqrt;
      var LN2 = Math.LN2;
      var FORCED = !$acosh || Math.floor($acosh(Number.MAX_VALUE)) !== 710 || $acosh(Infinity) !== Infinity;
      $({ target: "Math", stat: true, forced: FORCED }, {
        acosh: function acosh(x) {
          var n = +x;
          return n < 1 ? NaN : n > 9490626562425156e-8 ? log(n) + LN2 : log1p(n - 1 + sqrt(n - 1) * sqrt(n + 1));
        }
      });
    }
  });

  // node_modules/core-js/modules/es.math.asinh.js
  var require_es_math_asinh = __commonJS({
    "node_modules/core-js/modules/es.math.asinh.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var $asinh = Math.asinh;
      var log = Math.log;
      var sqrt = Math.sqrt;
      function asinh(x) {
        var n = +x;
        return !isFinite(n) || n === 0 ? n : n < 0 ? -asinh(-n) : log(n + sqrt(n * n + 1));
      }
      var FORCED = !($asinh && 1 / $asinh(0) > 0);
      $({ target: "Math", stat: true, forced: FORCED }, {
        asinh
      });
    }
  });

  // node_modules/core-js/modules/es.math.atanh.js
  var require_es_math_atanh = __commonJS({
    "node_modules/core-js/modules/es.math.atanh.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var $atanh = Math.atanh;
      var log = Math.log;
      var FORCED = !($atanh && 1 / $atanh(-0) < 0);
      $({ target: "Math", stat: true, forced: FORCED }, {
        atanh: function atanh(x) {
          var n = +x;
          return n === 0 ? n : log((1 + n) / (1 - n)) / 2;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.math.cbrt.js
  var require_es_math_cbrt = __commonJS({
    "node_modules/core-js/modules/es.math.cbrt.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var sign = require_math_sign();
      var abs = Math.abs;
      var pow = Math.pow;
      $({ target: "Math", stat: true }, {
        cbrt: function cbrt(x) {
          var n = +x;
          return sign(n) * pow(abs(n), 1 / 3);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.math.clz32.js
  var require_es_math_clz32 = __commonJS({
    "node_modules/core-js/modules/es.math.clz32.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var floor = Math.floor;
      var log = Math.log;
      var LOG2E = Math.LOG2E;
      $({ target: "Math", stat: true }, {
        clz32: function clz32(x) {
          var n = x >>> 0;
          return n ? 31 - floor(log(n + 0.5) * LOG2E) : 32;
        }
      });
    }
  });

  // node_modules/core-js/internals/math-expm1.js
  var require_math_expm1 = __commonJS({
    "node_modules/core-js/internals/math-expm1.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $expm1 = Math.expm1;
      var exp = Math.exp;
      module.exports = !$expm1 || $expm1(10) > 22025.465794806718 || $expm1(10) < 22025.465794806718 || $expm1(-2e-17) !== -2e-17 ? function expm1(x) {
        var n = +x;
        return n === 0 ? n : n > -1e-6 && n < 1e-6 ? n + n * n / 2 : exp(n) - 1;
      } : $expm1;
    }
  });

  // node_modules/core-js/modules/es.math.cosh.js
  var require_es_math_cosh = __commonJS({
    "node_modules/core-js/modules/es.math.cosh.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var expm1 = require_math_expm1();
      var $cosh = Math.cosh;
      var abs = Math.abs;
      var E = Math.E;
      var FORCED = !$cosh || $cosh(710) === Infinity;
      $({ target: "Math", stat: true, forced: FORCED }, {
        cosh: function cosh(x) {
          var t = expm1(abs(x) - 1) + 1;
          return (t + 1 / (t * E * E)) * (E / 2);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.math.expm1.js
  var require_es_math_expm1 = __commonJS({
    "node_modules/core-js/modules/es.math.expm1.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var expm1 = require_math_expm1();
      $({ target: "Math", stat: true, forced: expm1 !== Math.expm1 }, { expm1 });
    }
  });

  // node_modules/core-js/modules/es.math.fround.js
  var require_es_math_fround = __commonJS({
    "node_modules/core-js/modules/es.math.fround.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var fround = require_math_fround();
      $({ target: "Math", stat: true }, { fround });
    }
  });

  // node_modules/core-js/modules/es.math.hypot.js
  var require_es_math_hypot = __commonJS({
    "node_modules/core-js/modules/es.math.hypot.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var $hypot = Math.hypot;
      var abs = Math.abs;
      var sqrt = Math.sqrt;
      var FORCED = !!$hypot && $hypot(Infinity, NaN) !== Infinity;
      $({ target: "Math", stat: true, arity: 2, forced: FORCED }, {
        // eslint-disable-next-line no-unused-vars -- required for `.length`
        hypot: function hypot(value1, value2) {
          var sum = 0;
          var i = 0;
          var aLen = arguments.length;
          var larg = 0;
          var arg, div;
          while (i < aLen) {
            arg = abs(arguments[i++]);
            if (larg < arg) {
              div = larg / arg;
              sum = sum * div * div + 1;
              larg = arg;
            } else if (arg > 0) {
              div = arg / larg;
              sum += div * div;
            } else sum += arg;
          }
          return larg === Infinity ? Infinity : larg * sqrt(sum);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.math.imul.js
  var require_es_math_imul = __commonJS({
    "node_modules/core-js/modules/es.math.imul.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var fails = require_fails();
      var $imul = Math.imul;
      var FORCED = fails(function() {
        return $imul(4294967295, 5) !== -5 || $imul.length !== 2;
      });
      $({ target: "Math", stat: true, forced: FORCED }, {
        imul: function imul(x, y) {
          var UINT16 = 65535;
          var xn = +x;
          var yn = +y;
          var xl = UINT16 & xn;
          var yl = UINT16 & yn;
          return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
        }
      });
    }
  });

  // node_modules/core-js/internals/math-log10.js
  var require_math_log10 = __commonJS({
    "node_modules/core-js/internals/math-log10.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var log = Math.log;
      var LOG10E = Math.LOG10E;
      module.exports = Math.log10 || function log10(x) {
        return log(x) * LOG10E;
      };
    }
  });

  // node_modules/core-js/modules/es.math.log10.js
  var require_es_math_log10 = __commonJS({
    "node_modules/core-js/modules/es.math.log10.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var log10 = require_math_log10();
      $({ target: "Math", stat: true }, {
        log10
      });
    }
  });

  // node_modules/core-js/modules/es.math.log1p.js
  var require_es_math_log1p = __commonJS({
    "node_modules/core-js/modules/es.math.log1p.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var log1p = require_math_log1p();
      $({ target: "Math", stat: true }, { log1p });
    }
  });

  // node_modules/core-js/modules/es.math.log2.js
  var require_es_math_log2 = __commonJS({
    "node_modules/core-js/modules/es.math.log2.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var log = Math.log;
      var LN2 = Math.LN2;
      $({ target: "Math", stat: true }, {
        log2: function log2(x) {
          return log(x) / LN2;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.math.sign.js
  var require_es_math_sign = __commonJS({
    "node_modules/core-js/modules/es.math.sign.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var sign = require_math_sign();
      $({ target: "Math", stat: true }, {
        sign
      });
    }
  });

  // node_modules/core-js/modules/es.math.sinh.js
  var require_es_math_sinh = __commonJS({
    "node_modules/core-js/modules/es.math.sinh.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var fails = require_fails();
      var expm1 = require_math_expm1();
      var abs = Math.abs;
      var exp = Math.exp;
      var E = Math.E;
      var FORCED = fails(function() {
        return Math.sinh(-2e-17) !== -2e-17;
      });
      $({ target: "Math", stat: true, forced: FORCED }, {
        sinh: function sinh(x) {
          var n = +x;
          return abs(n) < 1 ? (expm1(n) - expm1(-n)) / 2 : (exp(n - 1) - exp(-n - 1)) * (E / 2);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.math.tanh.js
  var require_es_math_tanh = __commonJS({
    "node_modules/core-js/modules/es.math.tanh.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var expm1 = require_math_expm1();
      var exp = Math.exp;
      $({ target: "Math", stat: true }, {
        tanh: function tanh(x) {
          var n = +x;
          var a = expm1(n);
          var b = expm1(-n);
          return a === Infinity ? 1 : b === Infinity ? -1 : (a - b) / (exp(n) + exp(-n));
        }
      });
    }
  });

  // node_modules/core-js/modules/es.math.to-string-tag.js
  var require_es_math_to_string_tag = __commonJS({
    "node_modules/core-js/modules/es.math.to-string-tag.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var setToStringTag = require_set_to_string_tag();
      setToStringTag(Math, "Math", true);
    }
  });

  // node_modules/core-js/modules/es.math.trunc.js
  var require_es_math_trunc = __commonJS({
    "node_modules/core-js/modules/es.math.trunc.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var trunc = require_math_trunc();
      $({ target: "Math", stat: true }, {
        trunc
      });
    }
  });

  // node_modules/core-js/internals/this-number-value.js
  var require_this_number_value = __commonJS({
    "node_modules/core-js/internals/this-number-value.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var uncurryThis = require_function_uncurry_this();
      module.exports = uncurryThis(1 .valueOf);
    }
  });

  // node_modules/core-js/internals/whitespaces.js
  var require_whitespaces = __commonJS({
    "node_modules/core-js/internals/whitespaces.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      module.exports = "	\n\v\f\r \xA0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF";
    }
  });

  // node_modules/core-js/internals/string-trim.js
  var require_string_trim = __commonJS({
    "node_modules/core-js/internals/string-trim.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var uncurryThis = require_function_uncurry_this();
      var requireObjectCoercible = require_require_object_coercible();
      var toString = require_to_string();
      var whitespaces = require_whitespaces();
      var replace = uncurryThis("".replace);
      var ltrim = RegExp("^[" + whitespaces + "]+");
      var rtrim = RegExp("(^|[^" + whitespaces + "])[" + whitespaces + "]+$");
      var createMethod = function(TYPE) {
        return function($this) {
          var string = toString(requireObjectCoercible($this));
          if (TYPE & 1) string = replace(string, ltrim, "");
          if (TYPE & 2) string = replace(string, rtrim, "$1");
          return string;
        };
      };
      module.exports = {
        // `String.prototype.{ trimLeft, trimStart }` methods
        // https://tc39.es/ecma262/#sec-string.prototype.trimstart
        start: createMethod(1),
        // `String.prototype.{ trimRight, trimEnd }` methods
        // https://tc39.es/ecma262/#sec-string.prototype.trimend
        end: createMethod(2),
        // `String.prototype.trim` method
        // https://tc39.es/ecma262/#sec-string.prototype.trim
        trim: createMethod(3)
      };
    }
  });

  // node_modules/core-js/modules/es.number.constructor.js
  var require_es_number_constructor = __commonJS({
    "node_modules/core-js/modules/es.number.constructor.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var IS_PURE = require_is_pure();
      var DESCRIPTORS = require_descriptors();
      var global2 = require_global();
      var path = require_path();
      var uncurryThis = require_function_uncurry_this();
      var isForced = require_is_forced();
      var hasOwn = require_has_own_property();
      var inheritIfRequired = require_inherit_if_required();
      var isPrototypeOf = require_object_is_prototype_of();
      var isSymbol = require_is_symbol();
      var toPrimitive = require_to_primitive();
      var fails = require_fails();
      var getOwnPropertyNames = require_object_get_own_property_names().f;
      var getOwnPropertyDescriptor = require_object_get_own_property_descriptor().f;
      var defineProperty = require_object_define_property().f;
      var thisNumberValue = require_this_number_value();
      var trim = require_string_trim().trim;
      var NUMBER = "Number";
      var NativeNumber = global2[NUMBER];
      var PureNumberNamespace = path[NUMBER];
      var NumberPrototype = NativeNumber.prototype;
      var TypeError2 = global2.TypeError;
      var stringSlice = uncurryThis("".slice);
      var charCodeAt = uncurryThis("".charCodeAt);
      var toNumeric = function(value) {
        var primValue = toPrimitive(value, "number");
        return typeof primValue == "bigint" ? primValue : toNumber(primValue);
      };
      var toNumber = function(argument) {
        var it = toPrimitive(argument, "number");
        var first, third, radix, maxCode, digits, length, index, code;
        if (isSymbol(it)) throw new TypeError2("Cannot convert a Symbol value to a number");
        if (typeof it == "string" && it.length > 2) {
          it = trim(it);
          first = charCodeAt(it, 0);
          if (first === 43 || first === 45) {
            third = charCodeAt(it, 2);
            if (third === 88 || third === 120) return NaN;
          } else if (first === 48) {
            switch (charCodeAt(it, 1)) {
              case 66:
              case 98:
                radix = 2;
                maxCode = 49;
                break;
              case 79:
              case 111:
                radix = 8;
                maxCode = 55;
                break;
              default:
                return +it;
            }
            digits = stringSlice(it, 2);
            length = digits.length;
            for (index = 0; index < length; index++) {
              code = charCodeAt(digits, index);
              if (code < 48 || code > maxCode) return NaN;
            }
            return parseInt(digits, radix);
          }
        }
        return +it;
      };
      var FORCED = isForced(NUMBER, !NativeNumber(" 0o1") || !NativeNumber("0b1") || NativeNumber("+0x1"));
      var calledWithNew = function(dummy) {
        return isPrototypeOf(NumberPrototype, dummy) && fails(function() {
          thisNumberValue(dummy);
        });
      };
      var NumberWrapper = function Number2(value) {
        var n = arguments.length < 1 ? 0 : NativeNumber(toNumeric(value));
        return calledWithNew(this) ? inheritIfRequired(Object(n), this, NumberWrapper) : n;
      };
      NumberWrapper.prototype = NumberPrototype;
      if (FORCED && !IS_PURE) NumberPrototype.constructor = NumberWrapper;
      $({ global: true, constructor: true, wrap: true, forced: FORCED }, {
        Number: NumberWrapper
      });
      var copyConstructorProperties = function(target, source) {
        for (var keys = DESCRIPTORS ? getOwnPropertyNames(source) : (
          // ES3:
          "MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,isFinite,isInteger,isNaN,isSafeInteger,parseFloat,parseInt,fromString,range".split(",")
        ), j = 0, key; keys.length > j; j++) {
          if (hasOwn(source, key = keys[j]) && !hasOwn(target, key)) {
            defineProperty(target, key, getOwnPropertyDescriptor(source, key));
          }
        }
      };
      if (IS_PURE && PureNumberNamespace) copyConstructorProperties(path[NUMBER], PureNumberNamespace);
      if (FORCED || IS_PURE) copyConstructorProperties(path[NUMBER], NativeNumber);
    }
  });

  // node_modules/core-js/modules/es.number.epsilon.js
  var require_es_number_epsilon = __commonJS({
    "node_modules/core-js/modules/es.number.epsilon.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      $({ target: "Number", stat: true, nonConfigurable: true, nonWritable: true }, {
        EPSILON: Math.pow(2, -52)
      });
    }
  });

  // node_modules/core-js/internals/number-is-finite.js
  var require_number_is_finite = __commonJS({
    "node_modules/core-js/internals/number-is-finite.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var global2 = require_global();
      var globalIsFinite = global2.isFinite;
      module.exports = Number.isFinite || function isFinite2(it) {
        return typeof it == "number" && globalIsFinite(it);
      };
    }
  });

  // node_modules/core-js/modules/es.number.is-finite.js
  var require_es_number_is_finite = __commonJS({
    "node_modules/core-js/modules/es.number.is-finite.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var numberIsFinite = require_number_is_finite();
      $({ target: "Number", stat: true }, { isFinite: numberIsFinite });
    }
  });

  // node_modules/core-js/internals/is-integral-number.js
  var require_is_integral_number = __commonJS({
    "node_modules/core-js/internals/is-integral-number.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var isObject2 = require_is_object();
      var floor = Math.floor;
      module.exports = Number.isInteger || function isInteger(it) {
        return !isObject2(it) && isFinite(it) && floor(it) === it;
      };
    }
  });

  // node_modules/core-js/modules/es.number.is-integer.js
  var require_es_number_is_integer = __commonJS({
    "node_modules/core-js/modules/es.number.is-integer.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var isIntegralNumber = require_is_integral_number();
      $({ target: "Number", stat: true }, {
        isInteger: isIntegralNumber
      });
    }
  });

  // node_modules/core-js/modules/es.number.is-nan.js
  var require_es_number_is_nan = __commonJS({
    "node_modules/core-js/modules/es.number.is-nan.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      $({ target: "Number", stat: true }, {
        isNaN: function isNaN2(number) {
          return number !== number;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.number.is-safe-integer.js
  var require_es_number_is_safe_integer = __commonJS({
    "node_modules/core-js/modules/es.number.is-safe-integer.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var isIntegralNumber = require_is_integral_number();
      var abs = Math.abs;
      $({ target: "Number", stat: true }, {
        isSafeInteger: function isSafeInteger(number) {
          return isIntegralNumber(number) && abs(number) <= 9007199254740991;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.number.max-safe-integer.js
  var require_es_number_max_safe_integer = __commonJS({
    "node_modules/core-js/modules/es.number.max-safe-integer.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      $({ target: "Number", stat: true, nonConfigurable: true, nonWritable: true }, {
        MAX_SAFE_INTEGER: 9007199254740991
      });
    }
  });

  // node_modules/core-js/modules/es.number.min-safe-integer.js
  var require_es_number_min_safe_integer = __commonJS({
    "node_modules/core-js/modules/es.number.min-safe-integer.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      $({ target: "Number", stat: true, nonConfigurable: true, nonWritable: true }, {
        MIN_SAFE_INTEGER: -9007199254740991
      });
    }
  });

  // node_modules/core-js/internals/number-parse-float.js
  var require_number_parse_float = __commonJS({
    "node_modules/core-js/internals/number-parse-float.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var global2 = require_global();
      var fails = require_fails();
      var uncurryThis = require_function_uncurry_this();
      var toString = require_to_string();
      var trim = require_string_trim().trim;
      var whitespaces = require_whitespaces();
      var charAt = uncurryThis("".charAt);
      var $parseFloat = global2.parseFloat;
      var Symbol2 = global2.Symbol;
      var ITERATOR = Symbol2 && Symbol2.iterator;
      var FORCED = 1 / $parseFloat(whitespaces + "-0") !== -Infinity || ITERATOR && !fails(function() {
        $parseFloat(Object(ITERATOR));
      });
      module.exports = FORCED ? function parseFloat2(string) {
        var trimmedString = trim(toString(string));
        var result = $parseFloat(trimmedString);
        return result === 0 && charAt(trimmedString, 0) === "-" ? -0 : result;
      } : $parseFloat;
    }
  });

  // node_modules/core-js/modules/es.number.parse-float.js
  var require_es_number_parse_float = __commonJS({
    "node_modules/core-js/modules/es.number.parse-float.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var parseFloat2 = require_number_parse_float();
      $({ target: "Number", stat: true, forced: Number.parseFloat !== parseFloat2 }, {
        parseFloat: parseFloat2
      });
    }
  });

  // node_modules/core-js/internals/number-parse-int.js
  var require_number_parse_int = __commonJS({
    "node_modules/core-js/internals/number-parse-int.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var global2 = require_global();
      var fails = require_fails();
      var uncurryThis = require_function_uncurry_this();
      var toString = require_to_string();
      var trim = require_string_trim().trim;
      var whitespaces = require_whitespaces();
      var $parseInt = global2.parseInt;
      var Symbol2 = global2.Symbol;
      var ITERATOR = Symbol2 && Symbol2.iterator;
      var hex = /^[+-]?0x/i;
      var exec = uncurryThis(hex.exec);
      var FORCED = $parseInt(whitespaces + "08") !== 8 || $parseInt(whitespaces + "0x16") !== 22 || ITERATOR && !fails(function() {
        $parseInt(Object(ITERATOR));
      });
      module.exports = FORCED ? function parseInt2(string, radix) {
        var S = trim(toString(string));
        return $parseInt(S, radix >>> 0 || (exec(hex, S) ? 16 : 10));
      } : $parseInt;
    }
  });

  // node_modules/core-js/modules/es.number.parse-int.js
  var require_es_number_parse_int = __commonJS({
    "node_modules/core-js/modules/es.number.parse-int.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var parseInt2 = require_number_parse_int();
      $({ target: "Number", stat: true, forced: Number.parseInt !== parseInt2 }, {
        parseInt: parseInt2
      });
    }
  });

  // node_modules/core-js/modules/es.number.to-exponential.js
  var require_es_number_to_exponential = __commonJS({
    "node_modules/core-js/modules/es.number.to-exponential.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var uncurryThis = require_function_uncurry_this();
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var thisNumberValue = require_this_number_value();
      var $repeat = require_string_repeat();
      var log10 = require_math_log10();
      var fails = require_fails();
      var $RangeError = RangeError;
      var $String = String;
      var $isFinite = isFinite;
      var abs = Math.abs;
      var floor = Math.floor;
      var pow = Math.pow;
      var round = Math.round;
      var nativeToExponential = uncurryThis(1 .toExponential);
      var repeat = uncurryThis($repeat);
      var stringSlice = uncurryThis("".slice);
      var ROUNDS_PROPERLY = nativeToExponential(-69e-12, 4) === "-6.9000e-11" && nativeToExponential(1.255, 2) === "1.25e+0" && nativeToExponential(12345, 3) === "1.235e+4" && nativeToExponential(25, 0) === "3e+1";
      var throwsOnInfinityFraction = function() {
        return fails(function() {
          nativeToExponential(1, Infinity);
        }) && fails(function() {
          nativeToExponential(1, -Infinity);
        });
      };
      var properNonFiniteThisCheck = function() {
        return !fails(function() {
          nativeToExponential(Infinity, Infinity);
          nativeToExponential(NaN, Infinity);
        });
      };
      var FORCED = !ROUNDS_PROPERLY || !throwsOnInfinityFraction() || !properNonFiniteThisCheck();
      $({ target: "Number", proto: true, forced: FORCED }, {
        toExponential: function toExponential(fractionDigits) {
          var x = thisNumberValue(this);
          if (fractionDigits === void 0) return nativeToExponential(x);
          var f = toIntegerOrInfinity(fractionDigits);
          if (!$isFinite(x)) return String(x);
          if (f < 0 || f > 20) throw new $RangeError("Incorrect fraction digits");
          if (ROUNDS_PROPERLY) return nativeToExponential(x, f);
          var s = "";
          var m = "";
          var e = 0;
          var c = "";
          var d = "";
          if (x < 0) {
            s = "-";
            x = -x;
          }
          if (x === 0) {
            e = 0;
            m = repeat("0", f + 1);
          } else {
            var l = log10(x);
            e = floor(l);
            var n = 0;
            var w = pow(10, e - f);
            n = round(x / w);
            if (2 * x >= (2 * n + 1) * w) {
              n += 1;
            }
            if (n >= pow(10, f + 1)) {
              n /= 10;
              e += 1;
            }
            m = $String(n);
          }
          if (f !== 0) {
            m = stringSlice(m, 0, 1) + "." + stringSlice(m, 1);
          }
          if (e === 0) {
            c = "+";
            d = "0";
          } else {
            c = e > 0 ? "+" : "-";
            d = $String(abs(e));
          }
          m += "e" + c + d;
          return s + m;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.number.to-fixed.js
  var require_es_number_to_fixed = __commonJS({
    "node_modules/core-js/modules/es.number.to-fixed.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var uncurryThis = require_function_uncurry_this();
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var thisNumberValue = require_this_number_value();
      var $repeat = require_string_repeat();
      var fails = require_fails();
      var $RangeError = RangeError;
      var $String = String;
      var floor = Math.floor;
      var repeat = uncurryThis($repeat);
      var stringSlice = uncurryThis("".slice);
      var nativeToFixed = uncurryThis(1 .toFixed);
      var pow = function(x, n, acc) {
        return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
      };
      var log = function(x) {
        var n = 0;
        var x2 = x;
        while (x2 >= 4096) {
          n += 12;
          x2 /= 4096;
        }
        while (x2 >= 2) {
          n += 1;
          x2 /= 2;
        }
        return n;
      };
      var multiply = function(data2, n, c) {
        var index = -1;
        var c2 = c;
        while (++index < 6) {
          c2 += n * data2[index];
          data2[index] = c2 % 1e7;
          c2 = floor(c2 / 1e7);
        }
      };
      var divide = function(data2, n) {
        var index = 6;
        var c = 0;
        while (--index >= 0) {
          c += data2[index];
          data2[index] = floor(c / n);
          c = c % n * 1e7;
        }
      };
      var dataToString = function(data2) {
        var index = 6;
        var s = "";
        while (--index >= 0) {
          if (s !== "" || index === 0 || data2[index] !== 0) {
            var t = $String(data2[index]);
            s = s === "" ? t : s + repeat("0", 7 - t.length) + t;
          }
        }
        return s;
      };
      var FORCED = fails(function() {
        return nativeToFixed(8e-5, 3) !== "0.000" || nativeToFixed(0.9, 0) !== "1" || nativeToFixed(1.255, 2) !== "1.25" || nativeToFixed(1000000000000000100, 0) !== "1000000000000000128";
      }) || !fails(function() {
        nativeToFixed({});
      });
      $({ target: "Number", proto: true, forced: FORCED }, {
        toFixed: function toFixed(fractionDigits) {
          var number = thisNumberValue(this);
          var fractDigits = toIntegerOrInfinity(fractionDigits);
          var data2 = [0, 0, 0, 0, 0, 0];
          var sign = "";
          var result = "0";
          var e, z, j, k;
          if (fractDigits < 0 || fractDigits > 20) throw new $RangeError("Incorrect fraction digits");
          if (number !== number) return "NaN";
          if (number <= -1e21 || number >= 1e21) return $String(number);
          if (number < 0) {
            sign = "-";
            number = -number;
          }
          if (number > 1e-21) {
            e = log(number * pow(2, 69, 1)) - 69;
            z = e < 0 ? number * pow(2, -e, 1) : number / pow(2, e, 1);
            z *= 4503599627370496;
            e = 52 - e;
            if (e > 0) {
              multiply(data2, 0, z);
              j = fractDigits;
              while (j >= 7) {
                multiply(data2, 1e7, 0);
                j -= 7;
              }
              multiply(data2, pow(10, j, 1), 0);
              j = e - 1;
              while (j >= 23) {
                divide(data2, 1 << 23);
                j -= 23;
              }
              divide(data2, 1 << j);
              multiply(data2, 1, 1);
              divide(data2, 2);
              result = dataToString(data2);
            } else {
              multiply(data2, 0, z);
              multiply(data2, 1 << -e, 0);
              result = dataToString(data2) + repeat("0", fractDigits);
            }
          }
          if (fractDigits > 0) {
            k = result.length;
            result = sign + (k <= fractDigits ? "0." + repeat("0", fractDigits - k) + result : stringSlice(result, 0, k - fractDigits) + "." + stringSlice(result, k - fractDigits));
          } else {
            result = sign + result;
          }
          return result;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.number.to-precision.js
  var require_es_number_to_precision = __commonJS({
    "node_modules/core-js/modules/es.number.to-precision.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var uncurryThis = require_function_uncurry_this();
      var fails = require_fails();
      var thisNumberValue = require_this_number_value();
      var nativeToPrecision = uncurryThis(1 .toPrecision);
      var FORCED = fails(function() {
        return nativeToPrecision(1, void 0) !== "1";
      }) || !fails(function() {
        nativeToPrecision({});
      });
      $({ target: "Number", proto: true, forced: FORCED }, {
        toPrecision: function toPrecision(precision) {
          return precision === void 0 ? nativeToPrecision(thisNumberValue(this)) : nativeToPrecision(thisNumberValue(this), precision);
        }
      });
    }
  });

  // node_modules/core-js/internals/object-assign.js
  var require_object_assign = __commonJS({
    "node_modules/core-js/internals/object-assign.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var DESCRIPTORS = require_descriptors();
      var uncurryThis = require_function_uncurry_this();
      var call = require_function_call();
      var fails = require_fails();
      var objectKeys = require_object_keys();
      var getOwnPropertySymbolsModule = require_object_get_own_property_symbols();
      var propertyIsEnumerableModule = require_object_property_is_enumerable();
      var toObject = require_to_object();
      var IndexedObject = require_indexed_object();
      var $assign = Object.assign;
      var defineProperty = Object.defineProperty;
      var concat2 = uncurryThis([].concat);
      module.exports = !$assign || fails(function() {
        if (DESCRIPTORS && $assign({ b: 1 }, $assign(defineProperty({}, "a", {
          enumerable: true,
          get: function() {
            defineProperty(this, "b", {
              value: 3,
              enumerable: false
            });
          }
        }), { b: 2 })).b !== 1) return true;
        var A = {};
        var B = {};
        var symbol = Symbol("assign detection");
        var alphabet = "abcdefghijklmnopqrst";
        A[symbol] = 7;
        alphabet.split("").forEach(function(chr) {
          B[chr] = chr;
        });
        return $assign({}, A)[symbol] !== 7 || objectKeys($assign({}, B)).join("") !== alphabet;
      }) ? function assign(target, source) {
        var T = toObject(target);
        var argumentsLength = arguments.length;
        var index = 1;
        var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
        var propertyIsEnumerable = propertyIsEnumerableModule.f;
        while (argumentsLength > index) {
          var S = IndexedObject(arguments[index++]);
          var keys = getOwnPropertySymbols ? concat2(objectKeys(S), getOwnPropertySymbols(S)) : objectKeys(S);
          var length = keys.length;
          var j = 0;
          var key;
          while (length > j) {
            key = keys[j++];
            if (!DESCRIPTORS || call(propertyIsEnumerable, S, key)) T[key] = S[key];
          }
        }
        return T;
      } : $assign;
    }
  });

  // node_modules/core-js/modules/es.object.assign.js
  var require_es_object_assign = __commonJS({
    "node_modules/core-js/modules/es.object.assign.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var assign = require_object_assign();
      $({ target: "Object", stat: true, arity: 2, forced: Object.assign !== assign }, {
        assign
      });
    }
  });

  // node_modules/core-js/modules/es.object.create.js
  var require_es_object_create = __commonJS({
    "node_modules/core-js/modules/es.object.create.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var DESCRIPTORS = require_descriptors();
      var create = require_object_create();
      $({ target: "Object", stat: true, sham: !DESCRIPTORS }, {
        create
      });
    }
  });

  // node_modules/core-js/internals/object-prototype-accessors-forced.js
  var require_object_prototype_accessors_forced = __commonJS({
    "node_modules/core-js/internals/object-prototype-accessors-forced.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var IS_PURE = require_is_pure();
      var global2 = require_global();
      var fails = require_fails();
      var WEBKIT = require_engine_webkit_version();
      module.exports = IS_PURE || !fails(function() {
        if (WEBKIT && WEBKIT < 535) return;
        var key = Math.random();
        __defineSetter__.call(null, key, function() {
        });
        delete global2[key];
      });
    }
  });

  // node_modules/core-js/modules/es.object.define-getter.js
  var require_es_object_define_getter = __commonJS({
    "node_modules/core-js/modules/es.object.define-getter.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var DESCRIPTORS = require_descriptors();
      var FORCED = require_object_prototype_accessors_forced();
      var aCallable = require_a_callable();
      var toObject = require_to_object();
      var definePropertyModule = require_object_define_property();
      if (DESCRIPTORS) {
        $({ target: "Object", proto: true, forced: FORCED }, {
          __defineGetter__: function __defineGetter__(P, getter) {
            definePropertyModule.f(toObject(this), P, { get: aCallable(getter), enumerable: true, configurable: true });
          }
        });
      }
    }
  });

  // node_modules/core-js/modules/es.object.define-properties.js
  var require_es_object_define_properties = __commonJS({
    "node_modules/core-js/modules/es.object.define-properties.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var DESCRIPTORS = require_descriptors();
      var defineProperties = require_object_define_properties().f;
      $({ target: "Object", stat: true, forced: Object.defineProperties !== defineProperties, sham: !DESCRIPTORS }, {
        defineProperties
      });
    }
  });

  // node_modules/core-js/modules/es.object.define-property.js
  var require_es_object_define_property = __commonJS({
    "node_modules/core-js/modules/es.object.define-property.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var DESCRIPTORS = require_descriptors();
      var defineProperty = require_object_define_property().f;
      $({ target: "Object", stat: true, forced: Object.defineProperty !== defineProperty, sham: !DESCRIPTORS }, {
        defineProperty
      });
    }
  });

  // node_modules/core-js/modules/es.object.define-setter.js
  var require_es_object_define_setter = __commonJS({
    "node_modules/core-js/modules/es.object.define-setter.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var DESCRIPTORS = require_descriptors();
      var FORCED = require_object_prototype_accessors_forced();
      var aCallable = require_a_callable();
      var toObject = require_to_object();
      var definePropertyModule = require_object_define_property();
      if (DESCRIPTORS) {
        $({ target: "Object", proto: true, forced: FORCED }, {
          __defineSetter__: function __defineSetter__2(P, setter) {
            definePropertyModule.f(toObject(this), P, { set: aCallable(setter), enumerable: true, configurable: true });
          }
        });
      }
    }
  });

  // node_modules/core-js/internals/object-to-array.js
  var require_object_to_array = __commonJS({
    "node_modules/core-js/internals/object-to-array.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var DESCRIPTORS = require_descriptors();
      var fails = require_fails();
      var uncurryThis = require_function_uncurry_this();
      var objectGetPrototypeOf = require_object_get_prototype_of();
      var objectKeys = require_object_keys();
      var toIndexedObject = require_to_indexed_object();
      var $propertyIsEnumerable = require_object_property_is_enumerable().f;
      var propertyIsEnumerable = uncurryThis($propertyIsEnumerable);
      var push = uncurryThis([].push);
      var IE_BUG = DESCRIPTORS && fails(function() {
        var O = /* @__PURE__ */ Object.create(null);
        O[2] = 2;
        return !propertyIsEnumerable(O, 2);
      });
      var createMethod = function(TO_ENTRIES) {
        return function(it) {
          var O = toIndexedObject(it);
          var keys = objectKeys(O);
          var IE_WORKAROUND = IE_BUG && objectGetPrototypeOf(O) === null;
          var length = keys.length;
          var i = 0;
          var result = [];
          var key;
          while (length > i) {
            key = keys[i++];
            if (!DESCRIPTORS || (IE_WORKAROUND ? key in O : propertyIsEnumerable(O, key))) {
              push(result, TO_ENTRIES ? [key, O[key]] : O[key]);
            }
          }
          return result;
        };
      };
      module.exports = {
        // `Object.entries` method
        // https://tc39.es/ecma262/#sec-object.entries
        entries: createMethod(true),
        // `Object.values` method
        // https://tc39.es/ecma262/#sec-object.values
        values: createMethod(false)
      };
    }
  });

  // node_modules/core-js/modules/es.object.entries.js
  var require_es_object_entries = __commonJS({
    "node_modules/core-js/modules/es.object.entries.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var $entries = require_object_to_array().entries;
      $({ target: "Object", stat: true }, {
        entries: function entries(O) {
          return $entries(O);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.object.freeze.js
  var require_es_object_freeze = __commonJS({
    "node_modules/core-js/modules/es.object.freeze.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var FREEZING = require_freezing();
      var fails = require_fails();
      var isObject2 = require_is_object();
      var onFreeze = require_internal_metadata().onFreeze;
      var $freeze = Object.freeze;
      var FAILS_ON_PRIMITIVES = fails(function() {
        $freeze(1);
      });
      $({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES, sham: !FREEZING }, {
        freeze: function freeze(it) {
          return $freeze && isObject2(it) ? $freeze(onFreeze(it)) : it;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.object.from-entries.js
  var require_es_object_from_entries = __commonJS({
    "node_modules/core-js/modules/es.object.from-entries.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var iterate = require_iterate();
      var createProperty = require_create_property();
      $({ target: "Object", stat: true }, {
        fromEntries: function fromEntries(iterable) {
          var obj = {};
          iterate(iterable, function(k, v) {
            createProperty(obj, k, v);
          }, { AS_ENTRIES: true });
          return obj;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.object.get-own-property-descriptor.js
  var require_es_object_get_own_property_descriptor = __commonJS({
    "node_modules/core-js/modules/es.object.get-own-property-descriptor.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var fails = require_fails();
      var toIndexedObject = require_to_indexed_object();
      var nativeGetOwnPropertyDescriptor = require_object_get_own_property_descriptor().f;
      var DESCRIPTORS = require_descriptors();
      var FORCED = !DESCRIPTORS || fails(function() {
        nativeGetOwnPropertyDescriptor(1);
      });
      $({ target: "Object", stat: true, forced: FORCED, sham: !DESCRIPTORS }, {
        getOwnPropertyDescriptor: function getOwnPropertyDescriptor(it, key) {
          return nativeGetOwnPropertyDescriptor(toIndexedObject(it), key);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.object.get-own-property-descriptors.js
  var require_es_object_get_own_property_descriptors = __commonJS({
    "node_modules/core-js/modules/es.object.get-own-property-descriptors.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var DESCRIPTORS = require_descriptors();
      var ownKeys = require_own_keys();
      var toIndexedObject = require_to_indexed_object();
      var getOwnPropertyDescriptorModule = require_object_get_own_property_descriptor();
      var createProperty = require_create_property();
      $({ target: "Object", stat: true, sham: !DESCRIPTORS }, {
        getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
          var O = toIndexedObject(object);
          var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
          var keys = ownKeys(O);
          var result = {};
          var index = 0;
          var key, descriptor;
          while (keys.length > index) {
            descriptor = getOwnPropertyDescriptor(O, key = keys[index++]);
            if (descriptor !== void 0) createProperty(result, key, descriptor);
          }
          return result;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.object.get-own-property-names.js
  var require_es_object_get_own_property_names = __commonJS({
    "node_modules/core-js/modules/es.object.get-own-property-names.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var fails = require_fails();
      var getOwnPropertyNames = require_object_get_own_property_names_external().f;
      var FAILS_ON_PRIMITIVES = fails(function() {
        return !Object.getOwnPropertyNames(1);
      });
      $({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES }, {
        getOwnPropertyNames
      });
    }
  });

  // node_modules/core-js/modules/es.object.get-prototype-of.js
  var require_es_object_get_prototype_of = __commonJS({
    "node_modules/core-js/modules/es.object.get-prototype-of.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var fails = require_fails();
      var toObject = require_to_object();
      var nativeGetPrototypeOf = require_object_get_prototype_of();
      var CORRECT_PROTOTYPE_GETTER = require_correct_prototype_getter();
      var FAILS_ON_PRIMITIVES = fails(function() {
        nativeGetPrototypeOf(1);
      });
      $({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES, sham: !CORRECT_PROTOTYPE_GETTER }, {
        getPrototypeOf: function getPrototypeOf(it) {
          return nativeGetPrototypeOf(toObject(it));
        }
      });
    }
  });

  // node_modules/core-js/modules/es.object.group-by.js
  var require_es_object_group_by = __commonJS({
    "node_modules/core-js/modules/es.object.group-by.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var getBuiltIn = require_get_built_in();
      var uncurryThis = require_function_uncurry_this();
      var aCallable = require_a_callable();
      var requireObjectCoercible = require_require_object_coercible();
      var toPropertyKey = require_to_property_key();
      var iterate = require_iterate();
      var fails = require_fails();
      var nativeGroupBy = Object.groupBy;
      var create = getBuiltIn("Object", "create");
      var push = uncurryThis([].push);
      var DOES_NOT_WORK_WITH_PRIMITIVES = !nativeGroupBy || fails(function() {
        return nativeGroupBy("ab", function(it) {
          return it;
        }).a.length !== 1;
      });
      $({ target: "Object", stat: true, forced: DOES_NOT_WORK_WITH_PRIMITIVES }, {
        groupBy: function groupBy(items, callbackfn) {
          requireObjectCoercible(items);
          aCallable(callbackfn);
          var obj = create(null);
          var k = 0;
          iterate(items, function(value) {
            var key = toPropertyKey(callbackfn(value, k++));
            if (key in obj) push(obj[key], value);
            else obj[key] = [value];
          });
          return obj;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.object.has-own.js
  var require_es_object_has_own = __commonJS({
    "node_modules/core-js/modules/es.object.has-own.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var hasOwn = require_has_own_property();
      $({ target: "Object", stat: true }, {
        hasOwn
      });
    }
  });

  // node_modules/core-js/internals/same-value.js
  var require_same_value = __commonJS({
    "node_modules/core-js/internals/same-value.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      module.exports = Object.is || function is(x, y) {
        return x === y ? x !== 0 || 1 / x === 1 / y : x !== x && y !== y;
      };
    }
  });

  // node_modules/core-js/modules/es.object.is.js
  var require_es_object_is = __commonJS({
    "node_modules/core-js/modules/es.object.is.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var is = require_same_value();
      $({ target: "Object", stat: true }, {
        is
      });
    }
  });

  // node_modules/core-js/modules/es.object.is-extensible.js
  var require_es_object_is_extensible = __commonJS({
    "node_modules/core-js/modules/es.object.is-extensible.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var $isExtensible = require_object_is_extensible();
      $({ target: "Object", stat: true, forced: Object.isExtensible !== $isExtensible }, {
        isExtensible: $isExtensible
      });
    }
  });

  // node_modules/core-js/modules/es.object.is-frozen.js
  var require_es_object_is_frozen = __commonJS({
    "node_modules/core-js/modules/es.object.is-frozen.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var fails = require_fails();
      var isObject2 = require_is_object();
      var classof = require_classof_raw();
      var ARRAY_BUFFER_NON_EXTENSIBLE = require_array_buffer_non_extensible();
      var $isFrozen = Object.isFrozen;
      var FORCED = ARRAY_BUFFER_NON_EXTENSIBLE || fails(function() {
        $isFrozen(1);
      });
      $({ target: "Object", stat: true, forced: FORCED }, {
        isFrozen: function isFrozen(it) {
          if (!isObject2(it)) return true;
          if (ARRAY_BUFFER_NON_EXTENSIBLE && classof(it) === "ArrayBuffer") return true;
          return $isFrozen ? $isFrozen(it) : false;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.object.is-sealed.js
  var require_es_object_is_sealed = __commonJS({
    "node_modules/core-js/modules/es.object.is-sealed.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var fails = require_fails();
      var isObject2 = require_is_object();
      var classof = require_classof_raw();
      var ARRAY_BUFFER_NON_EXTENSIBLE = require_array_buffer_non_extensible();
      var $isSealed = Object.isSealed;
      var FORCED = ARRAY_BUFFER_NON_EXTENSIBLE || fails(function() {
        $isSealed(1);
      });
      $({ target: "Object", stat: true, forced: FORCED }, {
        isSealed: function isSealed(it) {
          if (!isObject2(it)) return true;
          if (ARRAY_BUFFER_NON_EXTENSIBLE && classof(it) === "ArrayBuffer") return true;
          return $isSealed ? $isSealed(it) : false;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.object.keys.js
  var require_es_object_keys = __commonJS({
    "node_modules/core-js/modules/es.object.keys.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var toObject = require_to_object();
      var nativeKeys = require_object_keys();
      var fails = require_fails();
      var FAILS_ON_PRIMITIVES = fails(function() {
        nativeKeys(1);
      });
      $({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES }, {
        keys: function keys(it) {
          return nativeKeys(toObject(it));
        }
      });
    }
  });

  // node_modules/core-js/modules/es.object.lookup-getter.js
  var require_es_object_lookup_getter = __commonJS({
    "node_modules/core-js/modules/es.object.lookup-getter.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var DESCRIPTORS = require_descriptors();
      var FORCED = require_object_prototype_accessors_forced();
      var toObject = require_to_object();
      var toPropertyKey = require_to_property_key();
      var getPrototypeOf = require_object_get_prototype_of();
      var getOwnPropertyDescriptor = require_object_get_own_property_descriptor().f;
      if (DESCRIPTORS) {
        $({ target: "Object", proto: true, forced: FORCED }, {
          __lookupGetter__: function __lookupGetter__(P) {
            var O = toObject(this);
            var key = toPropertyKey(P);
            var desc;
            do {
              if (desc = getOwnPropertyDescriptor(O, key)) return desc.get;
            } while (O = getPrototypeOf(O));
          }
        });
      }
    }
  });

  // node_modules/core-js/modules/es.object.lookup-setter.js
  var require_es_object_lookup_setter = __commonJS({
    "node_modules/core-js/modules/es.object.lookup-setter.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var DESCRIPTORS = require_descriptors();
      var FORCED = require_object_prototype_accessors_forced();
      var toObject = require_to_object();
      var toPropertyKey = require_to_property_key();
      var getPrototypeOf = require_object_get_prototype_of();
      var getOwnPropertyDescriptor = require_object_get_own_property_descriptor().f;
      if (DESCRIPTORS) {
        $({ target: "Object", proto: true, forced: FORCED }, {
          __lookupSetter__: function __lookupSetter__(P) {
            var O = toObject(this);
            var key = toPropertyKey(P);
            var desc;
            do {
              if (desc = getOwnPropertyDescriptor(O, key)) return desc.set;
            } while (O = getPrototypeOf(O));
          }
        });
      }
    }
  });

  // node_modules/core-js/modules/es.object.prevent-extensions.js
  var require_es_object_prevent_extensions = __commonJS({
    "node_modules/core-js/modules/es.object.prevent-extensions.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var isObject2 = require_is_object();
      var onFreeze = require_internal_metadata().onFreeze;
      var FREEZING = require_freezing();
      var fails = require_fails();
      var $preventExtensions = Object.preventExtensions;
      var FAILS_ON_PRIMITIVES = fails(function() {
        $preventExtensions(1);
      });
      $({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES, sham: !FREEZING }, {
        preventExtensions: function preventExtensions(it) {
          return $preventExtensions && isObject2(it) ? $preventExtensions(onFreeze(it)) : it;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.object.proto.js
  var require_es_object_proto = __commonJS({
    "node_modules/core-js/modules/es.object.proto.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var DESCRIPTORS = require_descriptors();
      var defineBuiltInAccessor = require_define_built_in_accessor();
      var isObject2 = require_is_object();
      var isPossiblePrototype = require_is_possible_prototype();
      var toObject = require_to_object();
      var requireObjectCoercible = require_require_object_coercible();
      var getPrototypeOf = Object.getPrototypeOf;
      var setPrototypeOf = Object.setPrototypeOf;
      var ObjectPrototype = Object.prototype;
      var PROTO = "__proto__";
      if (DESCRIPTORS && getPrototypeOf && setPrototypeOf && !(PROTO in ObjectPrototype)) try {
        defineBuiltInAccessor(ObjectPrototype, PROTO, {
          configurable: true,
          get: function __proto__() {
            return getPrototypeOf(toObject(this));
          },
          set: function __proto__(proto) {
            var O = requireObjectCoercible(this);
            if (isPossiblePrototype(proto) && isObject2(O)) {
              setPrototypeOf(O, proto);
            }
          }
        });
      } catch (error) {
      }
    }
  });

  // node_modules/core-js/modules/es.object.seal.js
  var require_es_object_seal = __commonJS({
    "node_modules/core-js/modules/es.object.seal.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var isObject2 = require_is_object();
      var onFreeze = require_internal_metadata().onFreeze;
      var FREEZING = require_freezing();
      var fails = require_fails();
      var $seal = Object.seal;
      var FAILS_ON_PRIMITIVES = fails(function() {
        $seal(1);
      });
      $({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES, sham: !FREEZING }, {
        seal: function seal(it) {
          return $seal && isObject2(it) ? $seal(onFreeze(it)) : it;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.object.set-prototype-of.js
  var require_es_object_set_prototype_of = __commonJS({
    "node_modules/core-js/modules/es.object.set-prototype-of.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var setPrototypeOf = require_object_set_prototype_of();
      $({ target: "Object", stat: true }, {
        setPrototypeOf
      });
    }
  });

  // node_modules/core-js/internals/object-to-string.js
  var require_object_to_string = __commonJS({
    "node_modules/core-js/internals/object-to-string.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var TO_STRING_TAG_SUPPORT = require_to_string_tag_support();
      var classof = require_classof();
      module.exports = TO_STRING_TAG_SUPPORT ? {}.toString : function toString() {
        return "[object " + classof(this) + "]";
      };
    }
  });

  // node_modules/core-js/modules/es.object.to-string.js
  var require_es_object_to_string = __commonJS({
    "node_modules/core-js/modules/es.object.to-string.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var TO_STRING_TAG_SUPPORT = require_to_string_tag_support();
      var defineBuiltIn = require_define_built_in();
      var toString = require_object_to_string();
      if (!TO_STRING_TAG_SUPPORT) {
        defineBuiltIn(Object.prototype, "toString", toString, { unsafe: true });
      }
    }
  });

  // node_modules/core-js/modules/es.object.values.js
  var require_es_object_values = __commonJS({
    "node_modules/core-js/modules/es.object.values.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var $values = require_object_to_array().values;
      $({ target: "Object", stat: true }, {
        values: function values(O) {
          return $values(O);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.parse-float.js
  var require_es_parse_float = __commonJS({
    "node_modules/core-js/modules/es.parse-float.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var $parseFloat = require_number_parse_float();
      $({ global: true, forced: parseFloat !== $parseFloat }, {
        parseFloat: $parseFloat
      });
    }
  });

  // node_modules/core-js/modules/es.parse-int.js
  var require_es_parse_int = __commonJS({
    "node_modules/core-js/modules/es.parse-int.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var $parseInt = require_number_parse_int();
      $({ global: true, forced: parseInt !== $parseInt }, {
        parseInt: $parseInt
      });
    }
  });

  // node_modules/core-js/internals/validate-arguments-length.js
  var require_validate_arguments_length = __commonJS({
    "node_modules/core-js/internals/validate-arguments-length.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $TypeError = TypeError;
      module.exports = function(passed, required) {
        if (passed < required) throw new $TypeError("Not enough arguments");
        return passed;
      };
    }
  });

  // node_modules/core-js/internals/engine-is-ios.js
  var require_engine_is_ios = __commonJS({
    "node_modules/core-js/internals/engine-is-ios.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var userAgent = require_engine_user_agent();
      module.exports = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent);
    }
  });

  // node_modules/core-js/internals/task.js
  var require_task = __commonJS({
    "node_modules/core-js/internals/task.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var global2 = require_global();
      var apply = require_function_apply();
      var bind = require_function_bind_context();
      var isCallable = require_is_callable();
      var hasOwn = require_has_own_property();
      var fails = require_fails();
      var html = require_html();
      var arraySlice2 = require_array_slice();
      var createElement50 = require_document_create_element();
      var validateArgumentsLength = require_validate_arguments_length();
      var IS_IOS = require_engine_is_ios();
      var IS_NODE = require_engine_is_node();
      var set2 = global2.setImmediate;
      var clear = global2.clearImmediate;
      var process2 = global2.process;
      var Dispatch = global2.Dispatch;
      var Function2 = global2.Function;
      var MessageChannel2 = global2.MessageChannel;
      var String2 = global2.String;
      var counter = 0;
      var queue = {};
      var ONREADYSTATECHANGE = "onreadystatechange";
      var $location;
      var defer;
      var channel;
      var port;
      fails(function() {
        $location = global2.location;
      });
      var run = function(id) {
        if (hasOwn(queue, id)) {
          var fn = queue[id];
          delete queue[id];
          fn();
        }
      };
      var runner = function(id) {
        return function() {
          run(id);
        };
      };
      var eventListener = function(event) {
        run(event.data);
      };
      var globalPostMessageDefer = function(id) {
        global2.postMessage(String2(id), $location.protocol + "//" + $location.host);
      };
      if (!set2 || !clear) {
        set2 = function setImmediate2(handler) {
          validateArgumentsLength(arguments.length, 1);
          var fn = isCallable(handler) ? handler : Function2(handler);
          var args = arraySlice2(arguments, 1);
          queue[++counter] = function() {
            apply(fn, void 0, args);
          };
          defer(counter);
          return counter;
        };
        clear = function clearImmediate(id) {
          delete queue[id];
        };
        if (IS_NODE) {
          defer = function(id) {
            process2.nextTick(runner(id));
          };
        } else if (Dispatch && Dispatch.now) {
          defer = function(id) {
            Dispatch.now(runner(id));
          };
        } else if (MessageChannel2 && !IS_IOS) {
          channel = new MessageChannel2();
          port = channel.port2;
          channel.port1.onmessage = eventListener;
          defer = bind(port.postMessage, port);
        } else if (global2.addEventListener && isCallable(global2.postMessage) && !global2.importScripts && $location && $location.protocol !== "file:" && !fails(globalPostMessageDefer)) {
          defer = globalPostMessageDefer;
          global2.addEventListener("message", eventListener, false);
        } else if (ONREADYSTATECHANGE in createElement50("script")) {
          defer = function(id) {
            html.appendChild(createElement50("script"))[ONREADYSTATECHANGE] = function() {
              html.removeChild(this);
              run(id);
            };
          };
        } else {
          defer = function(id) {
            setTimeout(runner(id), 0);
          };
        }
      }
      module.exports = {
        set: set2,
        clear
      };
    }
  });

  // node_modules/core-js/internals/safe-get-built-in.js
  var require_safe_get_built_in = __commonJS({
    "node_modules/core-js/internals/safe-get-built-in.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var global2 = require_global();
      var DESCRIPTORS = require_descriptors();
      var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
      module.exports = function(name2) {
        if (!DESCRIPTORS) return global2[name2];
        var descriptor = getOwnPropertyDescriptor(global2, name2);
        return descriptor && descriptor.value;
      };
    }
  });

  // node_modules/core-js/internals/queue.js
  var require_queue = __commonJS({
    "node_modules/core-js/internals/queue.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var Queue = function() {
        this.head = null;
        this.tail = null;
      };
      Queue.prototype = {
        add: function(item) {
          var entry = { item, next: null };
          var tail = this.tail;
          if (tail) tail.next = entry;
          else this.head = entry;
          this.tail = entry;
        },
        get: function() {
          var entry = this.head;
          if (entry) {
            var next = this.head = entry.next;
            if (next === null) this.tail = null;
            return entry.item;
          }
        }
      };
      module.exports = Queue;
    }
  });

  // node_modules/core-js/internals/engine-is-ios-pebble.js
  var require_engine_is_ios_pebble = __commonJS({
    "node_modules/core-js/internals/engine-is-ios-pebble.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var userAgent = require_engine_user_agent();
      module.exports = /ipad|iphone|ipod/i.test(userAgent) && typeof Pebble != "undefined";
    }
  });

  // node_modules/core-js/internals/engine-is-webos-webkit.js
  var require_engine_is_webos_webkit = __commonJS({
    "node_modules/core-js/internals/engine-is-webos-webkit.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var userAgent = require_engine_user_agent();
      module.exports = /web0s(?!.*chrome)/i.test(userAgent);
    }
  });

  // node_modules/core-js/internals/microtask.js
  var require_microtask = __commonJS({
    "node_modules/core-js/internals/microtask.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var global2 = require_global();
      var safeGetBuiltIn = require_safe_get_built_in();
      var bind = require_function_bind_context();
      var macrotask = require_task().set;
      var Queue = require_queue();
      var IS_IOS = require_engine_is_ios();
      var IS_IOS_PEBBLE = require_engine_is_ios_pebble();
      var IS_WEBOS_WEBKIT = require_engine_is_webos_webkit();
      var IS_NODE = require_engine_is_node();
      var MutationObserver = global2.MutationObserver || global2.WebKitMutationObserver;
      var document3 = global2.document;
      var process2 = global2.process;
      var Promise2 = global2.Promise;
      var microtask = safeGetBuiltIn("queueMicrotask");
      var notify;
      var toggle;
      var node;
      var promise;
      var then;
      if (!microtask) {
        queue = new Queue();
        flush = function() {
          var parent, fn;
          if (IS_NODE && (parent = process2.domain)) parent.exit();
          while (fn = queue.get()) try {
            fn();
          } catch (error) {
            if (queue.head) notify();
            throw error;
          }
          if (parent) parent.enter();
        };
        if (!IS_IOS && !IS_NODE && !IS_WEBOS_WEBKIT && MutationObserver && document3) {
          toggle = true;
          node = document3.createTextNode("");
          new MutationObserver(flush).observe(node, { characterData: true });
          notify = function() {
            node.data = toggle = !toggle;
          };
        } else if (!IS_IOS_PEBBLE && Promise2 && Promise2.resolve) {
          promise = Promise2.resolve(void 0);
          promise.constructor = Promise2;
          then = bind(promise.then, promise);
          notify = function() {
            then(flush);
          };
        } else if (IS_NODE) {
          notify = function() {
            process2.nextTick(flush);
          };
        } else {
          macrotask = bind(macrotask, global2);
          notify = function() {
            macrotask(flush);
          };
        }
        microtask = function(fn) {
          if (!queue.head) notify();
          queue.add(fn);
        };
      }
      var queue;
      var flush;
      module.exports = microtask;
    }
  });

  // node_modules/core-js/internals/host-report-errors.js
  var require_host_report_errors = __commonJS({
    "node_modules/core-js/internals/host-report-errors.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      module.exports = function(a, b) {
        try {
          arguments.length === 1 ? console.error(a) : console.error(a, b);
        } catch (error) {
        }
      };
    }
  });

  // node_modules/core-js/internals/perform.js
  var require_perform = __commonJS({
    "node_modules/core-js/internals/perform.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      module.exports = function(exec) {
        try {
          return { error: false, value: exec() };
        } catch (error) {
          return { error: true, value: error };
        }
      };
    }
  });

  // node_modules/core-js/internals/promise-native-constructor.js
  var require_promise_native_constructor = __commonJS({
    "node_modules/core-js/internals/promise-native-constructor.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var global2 = require_global();
      module.exports = global2.Promise;
    }
  });

  // node_modules/core-js/internals/promise-constructor-detection.js
  var require_promise_constructor_detection = __commonJS({
    "node_modules/core-js/internals/promise-constructor-detection.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var global2 = require_global();
      var NativePromiseConstructor = require_promise_native_constructor();
      var isCallable = require_is_callable();
      var isForced = require_is_forced();
      var inspectSource = require_inspect_source();
      var wellKnownSymbol = require_well_known_symbol();
      var IS_BROWSER = require_engine_is_browser();
      var IS_DENO = require_engine_is_deno();
      var IS_PURE = require_is_pure();
      var V8_VERSION = require_engine_v8_version();
      var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
      var SPECIES = wellKnownSymbol("species");
      var SUBCLASSING = false;
      var NATIVE_PROMISE_REJECTION_EVENT = isCallable(global2.PromiseRejectionEvent);
      var FORCED_PROMISE_CONSTRUCTOR = isForced("Promise", function() {
        var PROMISE_CONSTRUCTOR_SOURCE = inspectSource(NativePromiseConstructor);
        var GLOBAL_CORE_JS_PROMISE = PROMISE_CONSTRUCTOR_SOURCE !== String(NativePromiseConstructor);
        if (!GLOBAL_CORE_JS_PROMISE && V8_VERSION === 66) return true;
        if (IS_PURE && !(NativePromisePrototype["catch"] && NativePromisePrototype["finally"])) return true;
        if (!V8_VERSION || V8_VERSION < 51 || !/native code/.test(PROMISE_CONSTRUCTOR_SOURCE)) {
          var promise = new NativePromiseConstructor(function(resolve) {
            resolve(1);
          });
          var FakePromise = function(exec) {
            exec(function() {
            }, function() {
            });
          };
          var constructor = promise.constructor = {};
          constructor[SPECIES] = FakePromise;
          SUBCLASSING = promise.then(function() {
          }) instanceof FakePromise;
          if (!SUBCLASSING) return true;
        }
        return !GLOBAL_CORE_JS_PROMISE && (IS_BROWSER || IS_DENO) && !NATIVE_PROMISE_REJECTION_EVENT;
      });
      module.exports = {
        CONSTRUCTOR: FORCED_PROMISE_CONSTRUCTOR,
        REJECTION_EVENT: NATIVE_PROMISE_REJECTION_EVENT,
        SUBCLASSING
      };
    }
  });

  // node_modules/core-js/internals/new-promise-capability.js
  var require_new_promise_capability = __commonJS({
    "node_modules/core-js/internals/new-promise-capability.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var aCallable = require_a_callable();
      var $TypeError = TypeError;
      var PromiseCapability = function(C) {
        var resolve, reject;
        this.promise = new C(function($$resolve, $$reject) {
          if (resolve !== void 0 || reject !== void 0) throw new $TypeError("Bad Promise constructor");
          resolve = $$resolve;
          reject = $$reject;
        });
        this.resolve = aCallable(resolve);
        this.reject = aCallable(reject);
      };
      module.exports.f = function(C) {
        return new PromiseCapability(C);
      };
    }
  });

  // node_modules/core-js/modules/es.promise.constructor.js
  var require_es_promise_constructor = __commonJS({
    "node_modules/core-js/modules/es.promise.constructor.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var IS_PURE = require_is_pure();
      var IS_NODE = require_engine_is_node();
      var global2 = require_global();
      var call = require_function_call();
      var defineBuiltIn = require_define_built_in();
      var setPrototypeOf = require_object_set_prototype_of();
      var setToStringTag = require_set_to_string_tag();
      var setSpecies = require_set_species();
      var aCallable = require_a_callable();
      var isCallable = require_is_callable();
      var isObject2 = require_is_object();
      var anInstance = require_an_instance();
      var speciesConstructor = require_species_constructor();
      var task = require_task().set;
      var microtask = require_microtask();
      var hostReportErrors = require_host_report_errors();
      var perform = require_perform();
      var Queue = require_queue();
      var InternalStateModule = require_internal_state();
      var NativePromiseConstructor = require_promise_native_constructor();
      var PromiseConstructorDetection = require_promise_constructor_detection();
      var newPromiseCapabilityModule = require_new_promise_capability();
      var PROMISE = "Promise";
      var FORCED_PROMISE_CONSTRUCTOR = PromiseConstructorDetection.CONSTRUCTOR;
      var NATIVE_PROMISE_REJECTION_EVENT = PromiseConstructorDetection.REJECTION_EVENT;
      var NATIVE_PROMISE_SUBCLASSING = PromiseConstructorDetection.SUBCLASSING;
      var getInternalPromiseState = InternalStateModule.getterFor(PROMISE);
      var setInternalState = InternalStateModule.set;
      var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
      var PromiseConstructor = NativePromiseConstructor;
      var PromisePrototype = NativePromisePrototype;
      var TypeError2 = global2.TypeError;
      var document3 = global2.document;
      var process2 = global2.process;
      var newPromiseCapability = newPromiseCapabilityModule.f;
      var newGenericPromiseCapability = newPromiseCapability;
      var DISPATCH_EVENT = !!(document3 && document3.createEvent && global2.dispatchEvent);
      var UNHANDLED_REJECTION = "unhandledrejection";
      var REJECTION_HANDLED = "rejectionhandled";
      var PENDING = 0;
      var FULFILLED = 1;
      var REJECTED = 2;
      var HANDLED = 1;
      var UNHANDLED = 2;
      var Internal;
      var OwnPromiseCapability;
      var PromiseWrapper;
      var nativeThen;
      var isThenable = function(it) {
        var then;
        return isObject2(it) && isCallable(then = it.then) ? then : false;
      };
      var callReaction = function(reaction, state) {
        var value = state.value;
        var ok = state.state === FULFILLED;
        var handler = ok ? reaction.ok : reaction.fail;
        var resolve = reaction.resolve;
        var reject = reaction.reject;
        var domain2 = reaction.domain;
        var result, then, exited;
        try {
          if (handler) {
            if (!ok) {
              if (state.rejection === UNHANDLED) onHandleUnhandled(state);
              state.rejection = HANDLED;
            }
            if (handler === true) result = value;
            else {
              if (domain2) domain2.enter();
              result = handler(value);
              if (domain2) {
                domain2.exit();
                exited = true;
              }
            }
            if (result === reaction.promise) {
              reject(new TypeError2("Promise-chain cycle"));
            } else if (then = isThenable(result)) {
              call(then, result, resolve, reject);
            } else resolve(result);
          } else reject(value);
        } catch (error) {
          if (domain2 && !exited) domain2.exit();
          reject(error);
        }
      };
      var notify = function(state, isReject) {
        if (state.notified) return;
        state.notified = true;
        microtask(function() {
          var reactions = state.reactions;
          var reaction;
          while (reaction = reactions.get()) {
            callReaction(reaction, state);
          }
          state.notified = false;
          if (isReject && !state.rejection) onUnhandled(state);
        });
      };
      var dispatchEvent = function(name2, promise, reason) {
        var event, handler;
        if (DISPATCH_EVENT) {
          event = document3.createEvent("Event");
          event.promise = promise;
          event.reason = reason;
          event.initEvent(name2, false, true);
          global2.dispatchEvent(event);
        } else event = { promise, reason };
        if (!NATIVE_PROMISE_REJECTION_EVENT && (handler = global2["on" + name2])) handler(event);
        else if (name2 === UNHANDLED_REJECTION) hostReportErrors("Unhandled promise rejection", reason);
      };
      var onUnhandled = function(state) {
        call(task, global2, function() {
          var promise = state.facade;
          var value = state.value;
          var IS_UNHANDLED = isUnhandled(state);
          var result;
          if (IS_UNHANDLED) {
            result = perform(function() {
              if (IS_NODE) {
                process2.emit("unhandledRejection", value, promise);
              } else dispatchEvent(UNHANDLED_REJECTION, promise, value);
            });
            state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;
            if (result.error) throw result.value;
          }
        });
      };
      var isUnhandled = function(state) {
        return state.rejection !== HANDLED && !state.parent;
      };
      var onHandleUnhandled = function(state) {
        call(task, global2, function() {
          var promise = state.facade;
          if (IS_NODE) {
            process2.emit("rejectionHandled", promise);
          } else dispatchEvent(REJECTION_HANDLED, promise, state.value);
        });
      };
      var bind = function(fn, state, unwrap) {
        return function(value) {
          fn(state, value, unwrap);
        };
      };
      var internalReject = function(state, value, unwrap) {
        if (state.done) return;
        state.done = true;
        if (unwrap) state = unwrap;
        state.value = value;
        state.state = REJECTED;
        notify(state, true);
      };
      var internalResolve = function(state, value, unwrap) {
        if (state.done) return;
        state.done = true;
        if (unwrap) state = unwrap;
        try {
          if (state.facade === value) throw new TypeError2("Promise can't be resolved itself");
          var then = isThenable(value);
          if (then) {
            microtask(function() {
              var wrapper = { done: false };
              try {
                call(
                  then,
                  value,
                  bind(internalResolve, wrapper, state),
                  bind(internalReject, wrapper, state)
                );
              } catch (error) {
                internalReject(wrapper, error, state);
              }
            });
          } else {
            state.value = value;
            state.state = FULFILLED;
            notify(state, false);
          }
        } catch (error) {
          internalReject({ done: false }, error, state);
        }
      };
      if (FORCED_PROMISE_CONSTRUCTOR) {
        PromiseConstructor = function Promise2(executor) {
          anInstance(this, PromisePrototype);
          aCallable(executor);
          call(Internal, this);
          var state = getInternalPromiseState(this);
          try {
            executor(bind(internalResolve, state), bind(internalReject, state));
          } catch (error) {
            internalReject(state, error);
          }
        };
        PromisePrototype = PromiseConstructor.prototype;
        Internal = function Promise2(executor) {
          setInternalState(this, {
            type: PROMISE,
            done: false,
            notified: false,
            parent: false,
            reactions: new Queue(),
            rejection: false,
            state: PENDING,
            value: void 0
          });
        };
        Internal.prototype = defineBuiltIn(PromisePrototype, "then", function then(onFulfilled, onRejected) {
          var state = getInternalPromiseState(this);
          var reaction = newPromiseCapability(speciesConstructor(this, PromiseConstructor));
          state.parent = true;
          reaction.ok = isCallable(onFulfilled) ? onFulfilled : true;
          reaction.fail = isCallable(onRejected) && onRejected;
          reaction.domain = IS_NODE ? process2.domain : void 0;
          if (state.state === PENDING) state.reactions.add(reaction);
          else microtask(function() {
            callReaction(reaction, state);
          });
          return reaction.promise;
        });
        OwnPromiseCapability = function() {
          var promise = new Internal();
          var state = getInternalPromiseState(promise);
          this.promise = promise;
          this.resolve = bind(internalResolve, state);
          this.reject = bind(internalReject, state);
        };
        newPromiseCapabilityModule.f = newPromiseCapability = function(C) {
          return C === PromiseConstructor || C === PromiseWrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
        };
        if (!IS_PURE && isCallable(NativePromiseConstructor) && NativePromisePrototype !== Object.prototype) {
          nativeThen = NativePromisePrototype.then;
          if (!NATIVE_PROMISE_SUBCLASSING) {
            defineBuiltIn(NativePromisePrototype, "then", function then(onFulfilled, onRejected) {
              var that = this;
              return new PromiseConstructor(function(resolve, reject) {
                call(nativeThen, that, resolve, reject);
              }).then(onFulfilled, onRejected);
            }, { unsafe: true });
          }
          try {
            delete NativePromisePrototype.constructor;
          } catch (error) {
          }
          if (setPrototypeOf) {
            setPrototypeOf(NativePromisePrototype, PromisePrototype);
          }
        }
      }
      $({ global: true, constructor: true, wrap: true, forced: FORCED_PROMISE_CONSTRUCTOR }, {
        Promise: PromiseConstructor
      });
      setToStringTag(PromiseConstructor, PROMISE, false, true);
      setSpecies(PROMISE);
    }
  });

  // node_modules/core-js/internals/promise-statics-incorrect-iteration.js
  var require_promise_statics_incorrect_iteration = __commonJS({
    "node_modules/core-js/internals/promise-statics-incorrect-iteration.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var NativePromiseConstructor = require_promise_native_constructor();
      var checkCorrectnessOfIteration = require_check_correctness_of_iteration();
      var FORCED_PROMISE_CONSTRUCTOR = require_promise_constructor_detection().CONSTRUCTOR;
      module.exports = FORCED_PROMISE_CONSTRUCTOR || !checkCorrectnessOfIteration(function(iterable) {
        NativePromiseConstructor.all(iterable).then(void 0, function() {
        });
      });
    }
  });

  // node_modules/core-js/modules/es.promise.all.js
  var require_es_promise_all = __commonJS({
    "node_modules/core-js/modules/es.promise.all.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var call = require_function_call();
      var aCallable = require_a_callable();
      var newPromiseCapabilityModule = require_new_promise_capability();
      var perform = require_perform();
      var iterate = require_iterate();
      var PROMISE_STATICS_INCORRECT_ITERATION = require_promise_statics_incorrect_iteration();
      $({ target: "Promise", stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, {
        all: function all(iterable) {
          var C = this;
          var capability = newPromiseCapabilityModule.f(C);
          var resolve = capability.resolve;
          var reject = capability.reject;
          var result = perform(function() {
            var $promiseResolve = aCallable(C.resolve);
            var values = [];
            var counter = 0;
            var remaining = 1;
            iterate(iterable, function(promise) {
              var index = counter++;
              var alreadyCalled = false;
              remaining++;
              call($promiseResolve, C, promise).then(function(value) {
                if (alreadyCalled) return;
                alreadyCalled = true;
                values[index] = value;
                --remaining || resolve(values);
              }, reject);
            });
            --remaining || resolve(values);
          });
          if (result.error) reject(result.value);
          return capability.promise;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.promise.catch.js
  var require_es_promise_catch = __commonJS({
    "node_modules/core-js/modules/es.promise.catch.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var IS_PURE = require_is_pure();
      var FORCED_PROMISE_CONSTRUCTOR = require_promise_constructor_detection().CONSTRUCTOR;
      var NativePromiseConstructor = require_promise_native_constructor();
      var getBuiltIn = require_get_built_in();
      var isCallable = require_is_callable();
      var defineBuiltIn = require_define_built_in();
      var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
      $({ target: "Promise", proto: true, forced: FORCED_PROMISE_CONSTRUCTOR, real: true }, {
        "catch": function(onRejected) {
          return this.then(void 0, onRejected);
        }
      });
      if (!IS_PURE && isCallable(NativePromiseConstructor)) {
        method = getBuiltIn("Promise").prototype["catch"];
        if (NativePromisePrototype["catch"] !== method) {
          defineBuiltIn(NativePromisePrototype, "catch", method, { unsafe: true });
        }
      }
      var method;
    }
  });

  // node_modules/core-js/modules/es.promise.race.js
  var require_es_promise_race = __commonJS({
    "node_modules/core-js/modules/es.promise.race.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var call = require_function_call();
      var aCallable = require_a_callable();
      var newPromiseCapabilityModule = require_new_promise_capability();
      var perform = require_perform();
      var iterate = require_iterate();
      var PROMISE_STATICS_INCORRECT_ITERATION = require_promise_statics_incorrect_iteration();
      $({ target: "Promise", stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, {
        race: function race(iterable) {
          var C = this;
          var capability = newPromiseCapabilityModule.f(C);
          var reject = capability.reject;
          var result = perform(function() {
            var $promiseResolve = aCallable(C.resolve);
            iterate(iterable, function(promise) {
              call($promiseResolve, C, promise).then(capability.resolve, reject);
            });
          });
          if (result.error) reject(result.value);
          return capability.promise;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.promise.reject.js
  var require_es_promise_reject = __commonJS({
    "node_modules/core-js/modules/es.promise.reject.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var newPromiseCapabilityModule = require_new_promise_capability();
      var FORCED_PROMISE_CONSTRUCTOR = require_promise_constructor_detection().CONSTRUCTOR;
      $({ target: "Promise", stat: true, forced: FORCED_PROMISE_CONSTRUCTOR }, {
        reject: function reject(r) {
          var capability = newPromiseCapabilityModule.f(this);
          var capabilityReject = capability.reject;
          capabilityReject(r);
          return capability.promise;
        }
      });
    }
  });

  // node_modules/core-js/internals/promise-resolve.js
  var require_promise_resolve = __commonJS({
    "node_modules/core-js/internals/promise-resolve.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var anObject = require_an_object();
      var isObject2 = require_is_object();
      var newPromiseCapability = require_new_promise_capability();
      module.exports = function(C, x) {
        anObject(C);
        if (isObject2(x) && x.constructor === C) return x;
        var promiseCapability = newPromiseCapability.f(C);
        var resolve = promiseCapability.resolve;
        resolve(x);
        return promiseCapability.promise;
      };
    }
  });

  // node_modules/core-js/modules/es.promise.resolve.js
  var require_es_promise_resolve = __commonJS({
    "node_modules/core-js/modules/es.promise.resolve.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var getBuiltIn = require_get_built_in();
      var IS_PURE = require_is_pure();
      var NativePromiseConstructor = require_promise_native_constructor();
      var FORCED_PROMISE_CONSTRUCTOR = require_promise_constructor_detection().CONSTRUCTOR;
      var promiseResolve = require_promise_resolve();
      var PromiseConstructorWrapper = getBuiltIn("Promise");
      var CHECK_WRAPPER = IS_PURE && !FORCED_PROMISE_CONSTRUCTOR;
      $({ target: "Promise", stat: true, forced: IS_PURE || FORCED_PROMISE_CONSTRUCTOR }, {
        resolve: function resolve(x) {
          return promiseResolve(CHECK_WRAPPER && this === PromiseConstructorWrapper ? NativePromiseConstructor : this, x);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.promise.js
  var require_es_promise = __commonJS({
    "node_modules/core-js/modules/es.promise.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      require_es_promise_constructor();
      require_es_promise_all();
      require_es_promise_catch();
      require_es_promise_race();
      require_es_promise_reject();
      require_es_promise_resolve();
    }
  });

  // node_modules/core-js/modules/es.promise.all-settled.js
  var require_es_promise_all_settled = __commonJS({
    "node_modules/core-js/modules/es.promise.all-settled.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var call = require_function_call();
      var aCallable = require_a_callable();
      var newPromiseCapabilityModule = require_new_promise_capability();
      var perform = require_perform();
      var iterate = require_iterate();
      var PROMISE_STATICS_INCORRECT_ITERATION = require_promise_statics_incorrect_iteration();
      $({ target: "Promise", stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, {
        allSettled: function allSettled(iterable) {
          var C = this;
          var capability = newPromiseCapabilityModule.f(C);
          var resolve = capability.resolve;
          var reject = capability.reject;
          var result = perform(function() {
            var promiseResolve = aCallable(C.resolve);
            var values = [];
            var counter = 0;
            var remaining = 1;
            iterate(iterable, function(promise) {
              var index = counter++;
              var alreadyCalled = false;
              remaining++;
              call(promiseResolve, C, promise).then(function(value) {
                if (alreadyCalled) return;
                alreadyCalled = true;
                values[index] = { status: "fulfilled", value };
                --remaining || resolve(values);
              }, function(error) {
                if (alreadyCalled) return;
                alreadyCalled = true;
                values[index] = { status: "rejected", reason: error };
                --remaining || resolve(values);
              });
            });
            --remaining || resolve(values);
          });
          if (result.error) reject(result.value);
          return capability.promise;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.promise.any.js
  var require_es_promise_any = __commonJS({
    "node_modules/core-js/modules/es.promise.any.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var call = require_function_call();
      var aCallable = require_a_callable();
      var getBuiltIn = require_get_built_in();
      var newPromiseCapabilityModule = require_new_promise_capability();
      var perform = require_perform();
      var iterate = require_iterate();
      var PROMISE_STATICS_INCORRECT_ITERATION = require_promise_statics_incorrect_iteration();
      var PROMISE_ANY_ERROR = "No one promise resolved";
      $({ target: "Promise", stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, {
        any: function any(iterable) {
          var C = this;
          var AggregateError = getBuiltIn("AggregateError");
          var capability = newPromiseCapabilityModule.f(C);
          var resolve = capability.resolve;
          var reject = capability.reject;
          var result = perform(function() {
            var promiseResolve = aCallable(C.resolve);
            var errors = [];
            var counter = 0;
            var remaining = 1;
            var alreadyResolved = false;
            iterate(iterable, function(promise) {
              var index = counter++;
              var alreadyRejected = false;
              remaining++;
              call(promiseResolve, C, promise).then(function(value) {
                if (alreadyRejected || alreadyResolved) return;
                alreadyResolved = true;
                resolve(value);
              }, function(error) {
                if (alreadyRejected || alreadyResolved) return;
                alreadyRejected = true;
                errors[index] = error;
                --remaining || reject(new AggregateError(errors, PROMISE_ANY_ERROR));
              });
            });
            --remaining || reject(new AggregateError(errors, PROMISE_ANY_ERROR));
          });
          if (result.error) reject(result.value);
          return capability.promise;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.promise.finally.js
  var require_es_promise_finally = __commonJS({
    "node_modules/core-js/modules/es.promise.finally.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var IS_PURE = require_is_pure();
      var NativePromiseConstructor = require_promise_native_constructor();
      var fails = require_fails();
      var getBuiltIn = require_get_built_in();
      var isCallable = require_is_callable();
      var speciesConstructor = require_species_constructor();
      var promiseResolve = require_promise_resolve();
      var defineBuiltIn = require_define_built_in();
      var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
      var NON_GENERIC = !!NativePromiseConstructor && fails(function() {
        NativePromisePrototype["finally"].call({ then: function() {
        } }, function() {
        });
      });
      $({ target: "Promise", proto: true, real: true, forced: NON_GENERIC }, {
        "finally": function(onFinally) {
          var C = speciesConstructor(this, getBuiltIn("Promise"));
          var isFunction = isCallable(onFinally);
          return this.then(
            isFunction ? function(x) {
              return promiseResolve(C, onFinally()).then(function() {
                return x;
              });
            } : onFinally,
            isFunction ? function(e) {
              return promiseResolve(C, onFinally()).then(function() {
                throw e;
              });
            } : onFinally
          );
        }
      });
      if (!IS_PURE && isCallable(NativePromiseConstructor)) {
        method = getBuiltIn("Promise").prototype["finally"];
        if (NativePromisePrototype["finally"] !== method) {
          defineBuiltIn(NativePromisePrototype, "finally", method, { unsafe: true });
        }
      }
      var method;
    }
  });

  // node_modules/core-js/modules/es.promise.with-resolvers.js
  var require_es_promise_with_resolvers = __commonJS({
    "node_modules/core-js/modules/es.promise.with-resolvers.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var newPromiseCapabilityModule = require_new_promise_capability();
      $({ target: "Promise", stat: true }, {
        withResolvers: function withResolvers() {
          var promiseCapability = newPromiseCapabilityModule.f(this);
          return {
            promise: promiseCapability.promise,
            resolve: promiseCapability.resolve,
            reject: promiseCapability.reject
          };
        }
      });
    }
  });

  // node_modules/core-js/modules/es.reflect.apply.js
  var require_es_reflect_apply = __commonJS({
    "node_modules/core-js/modules/es.reflect.apply.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var functionApply = require_function_apply();
      var aCallable = require_a_callable();
      var anObject = require_an_object();
      var fails = require_fails();
      var OPTIONAL_ARGUMENTS_LIST = !fails(function() {
        Reflect.apply(function() {
        });
      });
      $({ target: "Reflect", stat: true, forced: OPTIONAL_ARGUMENTS_LIST }, {
        apply: function apply(target, thisArgument, argumentsList) {
          return functionApply(aCallable(target), thisArgument, anObject(argumentsList));
        }
      });
    }
  });

  // node_modules/core-js/modules/es.reflect.construct.js
  var require_es_reflect_construct = __commonJS({
    "node_modules/core-js/modules/es.reflect.construct.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var getBuiltIn = require_get_built_in();
      var apply = require_function_apply();
      var bind = require_function_bind();
      var aConstructor = require_a_constructor();
      var anObject = require_an_object();
      var isObject2 = require_is_object();
      var create = require_object_create();
      var fails = require_fails();
      var nativeConstruct = getBuiltIn("Reflect", "construct");
      var ObjectPrototype = Object.prototype;
      var push = [].push;
      var NEW_TARGET_BUG = fails(function() {
        function F() {
        }
        return !(nativeConstruct(function() {
        }, [], F) instanceof F);
      });
      var ARGS_BUG = !fails(function() {
        nativeConstruct(function() {
        });
      });
      var FORCED = NEW_TARGET_BUG || ARGS_BUG;
      $({ target: "Reflect", stat: true, forced: FORCED, sham: FORCED }, {
        construct: function construct(Target, args) {
          aConstructor(Target);
          anObject(args);
          var newTarget = arguments.length < 3 ? Target : aConstructor(arguments[2]);
          if (ARGS_BUG && !NEW_TARGET_BUG) return nativeConstruct(Target, args, newTarget);
          if (Target === newTarget) {
            switch (args.length) {
              case 0:
                return new Target();
              case 1:
                return new Target(args[0]);
              case 2:
                return new Target(args[0], args[1]);
              case 3:
                return new Target(args[0], args[1], args[2]);
              case 4:
                return new Target(args[0], args[1], args[2], args[3]);
            }
            var $args = [null];
            apply(push, $args, args);
            return new (apply(bind, Target, $args))();
          }
          var proto = newTarget.prototype;
          var instance = create(isObject2(proto) ? proto : ObjectPrototype);
          var result = apply(Target, instance, args);
          return isObject2(result) ? result : instance;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.reflect.define-property.js
  var require_es_reflect_define_property = __commonJS({
    "node_modules/core-js/modules/es.reflect.define-property.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var DESCRIPTORS = require_descriptors();
      var anObject = require_an_object();
      var toPropertyKey = require_to_property_key();
      var definePropertyModule = require_object_define_property();
      var fails = require_fails();
      var ERROR_INSTEAD_OF_FALSE = fails(function() {
        Reflect.defineProperty(definePropertyModule.f({}, 1, { value: 1 }), 1, { value: 2 });
      });
      $({ target: "Reflect", stat: true, forced: ERROR_INSTEAD_OF_FALSE, sham: !DESCRIPTORS }, {
        defineProperty: function defineProperty(target, propertyKey, attributes) {
          anObject(target);
          var key = toPropertyKey(propertyKey);
          anObject(attributes);
          try {
            definePropertyModule.f(target, key, attributes);
            return true;
          } catch (error) {
            return false;
          }
        }
      });
    }
  });

  // node_modules/core-js/modules/es.reflect.delete-property.js
  var require_es_reflect_delete_property = __commonJS({
    "node_modules/core-js/modules/es.reflect.delete-property.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var anObject = require_an_object();
      var getOwnPropertyDescriptor = require_object_get_own_property_descriptor().f;
      $({ target: "Reflect", stat: true }, {
        deleteProperty: function deleteProperty(target, propertyKey) {
          var descriptor = getOwnPropertyDescriptor(anObject(target), propertyKey);
          return descriptor && !descriptor.configurable ? false : delete target[propertyKey];
        }
      });
    }
  });

  // node_modules/core-js/internals/is-data-descriptor.js
  var require_is_data_descriptor = __commonJS({
    "node_modules/core-js/internals/is-data-descriptor.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var hasOwn = require_has_own_property();
      module.exports = function(descriptor) {
        return descriptor !== void 0 && (hasOwn(descriptor, "value") || hasOwn(descriptor, "writable"));
      };
    }
  });

  // node_modules/core-js/modules/es.reflect.get.js
  var require_es_reflect_get = __commonJS({
    "node_modules/core-js/modules/es.reflect.get.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var call = require_function_call();
      var isObject2 = require_is_object();
      var anObject = require_an_object();
      var isDataDescriptor = require_is_data_descriptor();
      var getOwnPropertyDescriptorModule = require_object_get_own_property_descriptor();
      var getPrototypeOf = require_object_get_prototype_of();
      function get2(target, propertyKey) {
        var receiver = arguments.length < 3 ? target : arguments[2];
        var descriptor, prototype;
        if (anObject(target) === receiver) return target[propertyKey];
        descriptor = getOwnPropertyDescriptorModule.f(target, propertyKey);
        if (descriptor) return isDataDescriptor(descriptor) ? descriptor.value : descriptor.get === void 0 ? void 0 : call(descriptor.get, receiver);
        if (isObject2(prototype = getPrototypeOf(target))) return get2(prototype, propertyKey, receiver);
      }
      $({ target: "Reflect", stat: true }, {
        get: get2
      });
    }
  });

  // node_modules/core-js/modules/es.reflect.get-own-property-descriptor.js
  var require_es_reflect_get_own_property_descriptor = __commonJS({
    "node_modules/core-js/modules/es.reflect.get-own-property-descriptor.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var DESCRIPTORS = require_descriptors();
      var anObject = require_an_object();
      var getOwnPropertyDescriptorModule = require_object_get_own_property_descriptor();
      $({ target: "Reflect", stat: true, sham: !DESCRIPTORS }, {
        getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
          return getOwnPropertyDescriptorModule.f(anObject(target), propertyKey);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.reflect.get-prototype-of.js
  var require_es_reflect_get_prototype_of = __commonJS({
    "node_modules/core-js/modules/es.reflect.get-prototype-of.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var anObject = require_an_object();
      var objectGetPrototypeOf = require_object_get_prototype_of();
      var CORRECT_PROTOTYPE_GETTER = require_correct_prototype_getter();
      $({ target: "Reflect", stat: true, sham: !CORRECT_PROTOTYPE_GETTER }, {
        getPrototypeOf: function getPrototypeOf(target) {
          return objectGetPrototypeOf(anObject(target));
        }
      });
    }
  });

  // node_modules/core-js/modules/es.reflect.has.js
  var require_es_reflect_has = __commonJS({
    "node_modules/core-js/modules/es.reflect.has.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      $({ target: "Reflect", stat: true }, {
        has: function has(target, propertyKey) {
          return propertyKey in target;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.reflect.is-extensible.js
  var require_es_reflect_is_extensible = __commonJS({
    "node_modules/core-js/modules/es.reflect.is-extensible.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var anObject = require_an_object();
      var $isExtensible = require_object_is_extensible();
      $({ target: "Reflect", stat: true }, {
        isExtensible: function isExtensible(target) {
          anObject(target);
          return $isExtensible(target);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.reflect.own-keys.js
  var require_es_reflect_own_keys = __commonJS({
    "node_modules/core-js/modules/es.reflect.own-keys.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var ownKeys = require_own_keys();
      $({ target: "Reflect", stat: true }, {
        ownKeys
      });
    }
  });

  // node_modules/core-js/modules/es.reflect.prevent-extensions.js
  var require_es_reflect_prevent_extensions = __commonJS({
    "node_modules/core-js/modules/es.reflect.prevent-extensions.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var getBuiltIn = require_get_built_in();
      var anObject = require_an_object();
      var FREEZING = require_freezing();
      $({ target: "Reflect", stat: true, sham: !FREEZING }, {
        preventExtensions: function preventExtensions(target) {
          anObject(target);
          try {
            var objectPreventExtensions = getBuiltIn("Object", "preventExtensions");
            if (objectPreventExtensions) objectPreventExtensions(target);
            return true;
          } catch (error) {
            return false;
          }
        }
      });
    }
  });

  // node_modules/core-js/modules/es.reflect.set.js
  var require_es_reflect_set = __commonJS({
    "node_modules/core-js/modules/es.reflect.set.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var call = require_function_call();
      var anObject = require_an_object();
      var isObject2 = require_is_object();
      var isDataDescriptor = require_is_data_descriptor();
      var fails = require_fails();
      var definePropertyModule = require_object_define_property();
      var getOwnPropertyDescriptorModule = require_object_get_own_property_descriptor();
      var getPrototypeOf = require_object_get_prototype_of();
      var createPropertyDescriptor = require_create_property_descriptor();
      function set2(target, propertyKey, V) {
        var receiver = arguments.length < 4 ? target : arguments[3];
        var ownDescriptor = getOwnPropertyDescriptorModule.f(anObject(target), propertyKey);
        var existingDescriptor, prototype, setter;
        if (!ownDescriptor) {
          if (isObject2(prototype = getPrototypeOf(target))) {
            return set2(prototype, propertyKey, V, receiver);
          }
          ownDescriptor = createPropertyDescriptor(0);
        }
        if (isDataDescriptor(ownDescriptor)) {
          if (ownDescriptor.writable === false || !isObject2(receiver)) return false;
          if (existingDescriptor = getOwnPropertyDescriptorModule.f(receiver, propertyKey)) {
            if (existingDescriptor.get || existingDescriptor.set || existingDescriptor.writable === false) return false;
            existingDescriptor.value = V;
            definePropertyModule.f(receiver, propertyKey, existingDescriptor);
          } else definePropertyModule.f(receiver, propertyKey, createPropertyDescriptor(0, V));
        } else {
          setter = ownDescriptor.set;
          if (setter === void 0) return false;
          call(setter, receiver, V);
        }
        return true;
      }
      var MS_EDGE_BUG = fails(function() {
        var Constructor = function() {
        };
        var object = definePropertyModule.f(new Constructor(), "a", { configurable: true });
        return Reflect.set(Constructor.prototype, "a", 1, object) !== false;
      });
      $({ target: "Reflect", stat: true, forced: MS_EDGE_BUG }, {
        set: set2
      });
    }
  });

  // node_modules/core-js/modules/es.reflect.set-prototype-of.js
  var require_es_reflect_set_prototype_of = __commonJS({
    "node_modules/core-js/modules/es.reflect.set-prototype-of.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var anObject = require_an_object();
      var aPossiblePrototype = require_a_possible_prototype();
      var objectSetPrototypeOf = require_object_set_prototype_of();
      if (objectSetPrototypeOf) $({ target: "Reflect", stat: true }, {
        setPrototypeOf: function setPrototypeOf(target, proto) {
          anObject(target);
          aPossiblePrototype(proto);
          try {
            objectSetPrototypeOf(target, proto);
            return true;
          } catch (error) {
            return false;
          }
        }
      });
    }
  });

  // node_modules/core-js/modules/es.reflect.to-string-tag.js
  var require_es_reflect_to_string_tag = __commonJS({
    "node_modules/core-js/modules/es.reflect.to-string-tag.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var global2 = require_global();
      var setToStringTag = require_set_to_string_tag();
      $({ global: true }, { Reflect: {} });
      setToStringTag(global2.Reflect, "Reflect", true);
    }
  });

  // node_modules/core-js/internals/is-regexp.js
  var require_is_regexp = __commonJS({
    "node_modules/core-js/internals/is-regexp.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var isObject2 = require_is_object();
      var classof = require_classof_raw();
      var wellKnownSymbol = require_well_known_symbol();
      var MATCH = wellKnownSymbol("match");
      module.exports = function(it) {
        var isRegExp;
        return isObject2(it) && ((isRegExp = it[MATCH]) !== void 0 ? !!isRegExp : classof(it) === "RegExp");
      };
    }
  });

  // node_modules/core-js/internals/regexp-flags.js
  var require_regexp_flags = __commonJS({
    "node_modules/core-js/internals/regexp-flags.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var anObject = require_an_object();
      module.exports = function() {
        var that = anObject(this);
        var result = "";
        if (that.hasIndices) result += "d";
        if (that.global) result += "g";
        if (that.ignoreCase) result += "i";
        if (that.multiline) result += "m";
        if (that.dotAll) result += "s";
        if (that.unicode) result += "u";
        if (that.unicodeSets) result += "v";
        if (that.sticky) result += "y";
        return result;
      };
    }
  });

  // node_modules/core-js/internals/regexp-get-flags.js
  var require_regexp_get_flags = __commonJS({
    "node_modules/core-js/internals/regexp-get-flags.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var call = require_function_call();
      var hasOwn = require_has_own_property();
      var isPrototypeOf = require_object_is_prototype_of();
      var regExpFlags = require_regexp_flags();
      var RegExpPrototype = RegExp.prototype;
      module.exports = function(R) {
        var flags = R.flags;
        return flags === void 0 && !("flags" in RegExpPrototype) && !hasOwn(R, "flags") && isPrototypeOf(RegExpPrototype, R) ? call(regExpFlags, R) : flags;
      };
    }
  });

  // node_modules/core-js/internals/regexp-sticky-helpers.js
  var require_regexp_sticky_helpers = __commonJS({
    "node_modules/core-js/internals/regexp-sticky-helpers.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var fails = require_fails();
      var global2 = require_global();
      var $RegExp = global2.RegExp;
      var UNSUPPORTED_Y = fails(function() {
        var re = $RegExp("a", "y");
        re.lastIndex = 2;
        return re.exec("abcd") !== null;
      });
      var MISSED_STICKY = UNSUPPORTED_Y || fails(function() {
        return !$RegExp("a", "y").sticky;
      });
      var BROKEN_CARET = UNSUPPORTED_Y || fails(function() {
        var re = $RegExp("^r", "gy");
        re.lastIndex = 2;
        return re.exec("str") !== null;
      });
      module.exports = {
        BROKEN_CARET,
        MISSED_STICKY,
        UNSUPPORTED_Y
      };
    }
  });

  // node_modules/core-js/internals/regexp-unsupported-dot-all.js
  var require_regexp_unsupported_dot_all = __commonJS({
    "node_modules/core-js/internals/regexp-unsupported-dot-all.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var fails = require_fails();
      var global2 = require_global();
      var $RegExp = global2.RegExp;
      module.exports = fails(function() {
        var re = $RegExp(".", "s");
        return !(re.dotAll && re.test("\n") && re.flags === "s");
      });
    }
  });

  // node_modules/core-js/internals/regexp-unsupported-ncg.js
  var require_regexp_unsupported_ncg = __commonJS({
    "node_modules/core-js/internals/regexp-unsupported-ncg.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var fails = require_fails();
      var global2 = require_global();
      var $RegExp = global2.RegExp;
      module.exports = fails(function() {
        var re = $RegExp("(?<a>b)", "g");
        return re.exec("b").groups.a !== "b" || "b".replace(re, "$<a>c") !== "bc";
      });
    }
  });

  // node_modules/core-js/modules/es.regexp.constructor.js
  var require_es_regexp_constructor = __commonJS({
    "node_modules/core-js/modules/es.regexp.constructor.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var DESCRIPTORS = require_descriptors();
      var global2 = require_global();
      var uncurryThis = require_function_uncurry_this();
      var isForced = require_is_forced();
      var inheritIfRequired = require_inherit_if_required();
      var createNonEnumerableProperty = require_create_non_enumerable_property();
      var create = require_object_create();
      var getOwnPropertyNames = require_object_get_own_property_names().f;
      var isPrototypeOf = require_object_is_prototype_of();
      var isRegExp = require_is_regexp();
      var toString = require_to_string();
      var getRegExpFlags = require_regexp_get_flags();
      var stickyHelpers = require_regexp_sticky_helpers();
      var proxyAccessor = require_proxy_accessor();
      var defineBuiltIn = require_define_built_in();
      var fails = require_fails();
      var hasOwn = require_has_own_property();
      var enforceInternalState = require_internal_state().enforce;
      var setSpecies = require_set_species();
      var wellKnownSymbol = require_well_known_symbol();
      var UNSUPPORTED_DOT_ALL = require_regexp_unsupported_dot_all();
      var UNSUPPORTED_NCG = require_regexp_unsupported_ncg();
      var MATCH = wellKnownSymbol("match");
      var NativeRegExp = global2.RegExp;
      var RegExpPrototype = NativeRegExp.prototype;
      var SyntaxError = global2.SyntaxError;
      var exec = uncurryThis(RegExpPrototype.exec);
      var charAt = uncurryThis("".charAt);
      var replace = uncurryThis("".replace);
      var stringIndexOf = uncurryThis("".indexOf);
      var stringSlice = uncurryThis("".slice);
      var IS_NCG = /^\?<[^\s\d!#%&*+<=>@^][^\s!#%&*+<=>@^]*>/;
      var re1 = /a/g;
      var re2 = /a/g;
      var CORRECT_NEW = new NativeRegExp(re1) !== re1;
      var MISSED_STICKY = stickyHelpers.MISSED_STICKY;
      var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y;
      var BASE_FORCED = DESCRIPTORS && (!CORRECT_NEW || MISSED_STICKY || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG || fails(function() {
        re2[MATCH] = false;
        return NativeRegExp(re1) !== re1 || NativeRegExp(re2) === re2 || String(NativeRegExp(re1, "i")) !== "/a/i";
      }));
      var handleDotAll = function(string) {
        var length = string.length;
        var index2 = 0;
        var result = "";
        var brackets = false;
        var chr;
        for (; index2 <= length; index2++) {
          chr = charAt(string, index2);
          if (chr === "\\") {
            result += chr + charAt(string, ++index2);
            continue;
          }
          if (!brackets && chr === ".") {
            result += "[\\s\\S]";
          } else {
            if (chr === "[") {
              brackets = true;
            } else if (chr === "]") {
              brackets = false;
            }
            result += chr;
          }
        }
        return result;
      };
      var handleNCG = function(string) {
        var length = string.length;
        var index2 = 0;
        var result = "";
        var named = [];
        var names = create(null);
        var brackets = false;
        var ncg = false;
        var groupid = 0;
        var groupname = "";
        var chr;
        for (; index2 <= length; index2++) {
          chr = charAt(string, index2);
          if (chr === "\\") {
            chr += charAt(string, ++index2);
          } else if (chr === "]") {
            brackets = false;
          } else if (!brackets) switch (true) {
            case chr === "[":
              brackets = true;
              break;
            case chr === "(":
              if (exec(IS_NCG, stringSlice(string, index2 + 1))) {
                index2 += 2;
                ncg = true;
              }
              result += chr;
              groupid++;
              continue;
            case (chr === ">" && ncg):
              if (groupname === "" || hasOwn(names, groupname)) {
                throw new SyntaxError("Invalid capture group name");
              }
              names[groupname] = true;
              named[named.length] = [groupname, groupid];
              ncg = false;
              groupname = "";
              continue;
          }
          if (ncg) groupname += chr;
          else result += chr;
        }
        return [result, named];
      };
      if (isForced("RegExp", BASE_FORCED)) {
        RegExpWrapper = function RegExp2(pattern, flags) {
          var thisIsRegExp = isPrototypeOf(RegExpPrototype, this);
          var patternIsRegExp = isRegExp(pattern);
          var flagsAreUndefined = flags === void 0;
          var groups = [];
          var rawPattern = pattern;
          var rawFlags, dotAll, sticky, handled, result, state;
          if (!thisIsRegExp && patternIsRegExp && flagsAreUndefined && pattern.constructor === RegExpWrapper) {
            return pattern;
          }
          if (patternIsRegExp || isPrototypeOf(RegExpPrototype, pattern)) {
            pattern = pattern.source;
            if (flagsAreUndefined) flags = getRegExpFlags(rawPattern);
          }
          pattern = pattern === void 0 ? "" : toString(pattern);
          flags = flags === void 0 ? "" : toString(flags);
          rawPattern = pattern;
          if (UNSUPPORTED_DOT_ALL && "dotAll" in re1) {
            dotAll = !!flags && stringIndexOf(flags, "s") > -1;
            if (dotAll) flags = replace(flags, /s/g, "");
          }
          rawFlags = flags;
          if (MISSED_STICKY && "sticky" in re1) {
            sticky = !!flags && stringIndexOf(flags, "y") > -1;
            if (sticky && UNSUPPORTED_Y) flags = replace(flags, /y/g, "");
          }
          if (UNSUPPORTED_NCG) {
            handled = handleNCG(pattern);
            pattern = handled[0];
            groups = handled[1];
          }
          result = inheritIfRequired(NativeRegExp(pattern, flags), thisIsRegExp ? this : RegExpPrototype, RegExpWrapper);
          if (dotAll || sticky || groups.length) {
            state = enforceInternalState(result);
            if (dotAll) {
              state.dotAll = true;
              state.raw = RegExpWrapper(handleDotAll(pattern), rawFlags);
            }
            if (sticky) state.sticky = true;
            if (groups.length) state.groups = groups;
          }
          if (pattern !== rawPattern) try {
            createNonEnumerableProperty(result, "source", rawPattern === "" ? "(?:)" : rawPattern);
          } catch (error) {
          }
          return result;
        };
        for (keys = getOwnPropertyNames(NativeRegExp), index = 0; keys.length > index; ) {
          proxyAccessor(RegExpWrapper, NativeRegExp, keys[index++]);
        }
        RegExpPrototype.constructor = RegExpWrapper;
        RegExpWrapper.prototype = RegExpPrototype;
        defineBuiltIn(global2, "RegExp", RegExpWrapper, { constructor: true });
      }
      var RegExpWrapper;
      var keys;
      var index;
      setSpecies("RegExp");
    }
  });

  // node_modules/core-js/modules/es.regexp.dot-all.js
  var require_es_regexp_dot_all = __commonJS({
    "node_modules/core-js/modules/es.regexp.dot-all.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var DESCRIPTORS = require_descriptors();
      var UNSUPPORTED_DOT_ALL = require_regexp_unsupported_dot_all();
      var classof = require_classof_raw();
      var defineBuiltInAccessor = require_define_built_in_accessor();
      var getInternalState = require_internal_state().get;
      var RegExpPrototype = RegExp.prototype;
      var $TypeError = TypeError;
      if (DESCRIPTORS && UNSUPPORTED_DOT_ALL) {
        defineBuiltInAccessor(RegExpPrototype, "dotAll", {
          configurable: true,
          get: function dotAll() {
            if (this === RegExpPrototype) return;
            if (classof(this) === "RegExp") {
              return !!getInternalState(this).dotAll;
            }
            throw new $TypeError("Incompatible receiver, RegExp required");
          }
        });
      }
    }
  });

  // node_modules/core-js/internals/regexp-exec.js
  var require_regexp_exec = __commonJS({
    "node_modules/core-js/internals/regexp-exec.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var call = require_function_call();
      var uncurryThis = require_function_uncurry_this();
      var toString = require_to_string();
      var regexpFlags = require_regexp_flags();
      var stickyHelpers = require_regexp_sticky_helpers();
      var shared = require_shared();
      var create = require_object_create();
      var getInternalState = require_internal_state().get;
      var UNSUPPORTED_DOT_ALL = require_regexp_unsupported_dot_all();
      var UNSUPPORTED_NCG = require_regexp_unsupported_ncg();
      var nativeReplace = shared("native-string-replace", String.prototype.replace);
      var nativeExec = RegExp.prototype.exec;
      var patchedExec = nativeExec;
      var charAt = uncurryThis("".charAt);
      var indexOf = uncurryThis("".indexOf);
      var replace = uncurryThis("".replace);
      var stringSlice = uncurryThis("".slice);
      var UPDATES_LAST_INDEX_WRONG = function() {
        var re1 = /a/;
        var re2 = /b*/g;
        call(nativeExec, re1, "a");
        call(nativeExec, re2, "a");
        return re1.lastIndex !== 0 || re2.lastIndex !== 0;
      }();
      var UNSUPPORTED_Y = stickyHelpers.BROKEN_CARET;
      var NPCG_INCLUDED = /()??/.exec("")[1] !== void 0;
      var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG;
      if (PATCH) {
        patchedExec = function exec(string) {
          var re = this;
          var state = getInternalState(re);
          var str = toString(string);
          var raw = state.raw;
          var result, reCopy, lastIndex, match, i, object, group;
          if (raw) {
            raw.lastIndex = re.lastIndex;
            result = call(patchedExec, raw, str);
            re.lastIndex = raw.lastIndex;
            return result;
          }
          var groups = state.groups;
          var sticky = UNSUPPORTED_Y && re.sticky;
          var flags = call(regexpFlags, re);
          var source = re.source;
          var charsAdded = 0;
          var strCopy = str;
          if (sticky) {
            flags = replace(flags, "y", "");
            if (indexOf(flags, "g") === -1) {
              flags += "g";
            }
            strCopy = stringSlice(str, re.lastIndex);
            if (re.lastIndex > 0 && (!re.multiline || re.multiline && charAt(str, re.lastIndex - 1) !== "\n")) {
              source = "(?: " + source + ")";
              strCopy = " " + strCopy;
              charsAdded++;
            }
            reCopy = new RegExp("^(?:" + source + ")", flags);
          }
          if (NPCG_INCLUDED) {
            reCopy = new RegExp("^" + source + "$(?!\\s)", flags);
          }
          if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;
          match = call(nativeExec, sticky ? reCopy : re, strCopy);
          if (sticky) {
            if (match) {
              match.input = stringSlice(match.input, charsAdded);
              match[0] = stringSlice(match[0], charsAdded);
              match.index = re.lastIndex;
              re.lastIndex += match[0].length;
            } else re.lastIndex = 0;
          } else if (UPDATES_LAST_INDEX_WRONG && match) {
            re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
          }
          if (NPCG_INCLUDED && match && match.length > 1) {
            call(nativeReplace, match[0], reCopy, function() {
              for (i = 1; i < arguments.length - 2; i++) {
                if (arguments[i] === void 0) match[i] = void 0;
              }
            });
          }
          if (match && groups) {
            match.groups = object = create(null);
            for (i = 0; i < groups.length; i++) {
              group = groups[i];
              object[group[0]] = match[group[1]];
            }
          }
          return match;
        };
      }
      module.exports = patchedExec;
    }
  });

  // node_modules/core-js/modules/es.regexp.exec.js
  var require_es_regexp_exec = __commonJS({
    "node_modules/core-js/modules/es.regexp.exec.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var exec = require_regexp_exec();
      $({ target: "RegExp", proto: true, forced: /./.exec !== exec }, {
        exec
      });
    }
  });

  // node_modules/core-js/modules/es.regexp.flags.js
  var require_es_regexp_flags = __commonJS({
    "node_modules/core-js/modules/es.regexp.flags.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var global2 = require_global();
      var DESCRIPTORS = require_descriptors();
      var defineBuiltInAccessor = require_define_built_in_accessor();
      var regExpFlags = require_regexp_flags();
      var fails = require_fails();
      var RegExp2 = global2.RegExp;
      var RegExpPrototype = RegExp2.prototype;
      var FORCED = DESCRIPTORS && fails(function() {
        var INDICES_SUPPORT = true;
        try {
          RegExp2(".", "d");
        } catch (error) {
          INDICES_SUPPORT = false;
        }
        var O = {};
        var calls = "";
        var expected = INDICES_SUPPORT ? "dgimsy" : "gimsy";
        var addGetter = function(key2, chr) {
          Object.defineProperty(O, key2, { get: function() {
            calls += chr;
            return true;
          } });
        };
        var pairs = {
          dotAll: "s",
          global: "g",
          ignoreCase: "i",
          multiline: "m",
          sticky: "y"
        };
        if (INDICES_SUPPORT) pairs.hasIndices = "d";
        for (var key in pairs) addGetter(key, pairs[key]);
        var result = Object.getOwnPropertyDescriptor(RegExpPrototype, "flags").get.call(O);
        return result !== expected || calls !== expected;
      });
      if (FORCED) defineBuiltInAccessor(RegExpPrototype, "flags", {
        configurable: true,
        get: regExpFlags
      });
    }
  });

  // node_modules/core-js/modules/es.regexp.sticky.js
  var require_es_regexp_sticky = __commonJS({
    "node_modules/core-js/modules/es.regexp.sticky.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var DESCRIPTORS = require_descriptors();
      var MISSED_STICKY = require_regexp_sticky_helpers().MISSED_STICKY;
      var classof = require_classof_raw();
      var defineBuiltInAccessor = require_define_built_in_accessor();
      var getInternalState = require_internal_state().get;
      var RegExpPrototype = RegExp.prototype;
      var $TypeError = TypeError;
      if (DESCRIPTORS && MISSED_STICKY) {
        defineBuiltInAccessor(RegExpPrototype, "sticky", {
          configurable: true,
          get: function sticky() {
            if (this === RegExpPrototype) return;
            if (classof(this) === "RegExp") {
              return !!getInternalState(this).sticky;
            }
            throw new $TypeError("Incompatible receiver, RegExp required");
          }
        });
      }
    }
  });

  // node_modules/core-js/modules/es.regexp.test.js
  var require_es_regexp_test = __commonJS({
    "node_modules/core-js/modules/es.regexp.test.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      require_es_regexp_exec();
      var $ = require_export();
      var call = require_function_call();
      var isCallable = require_is_callable();
      var anObject = require_an_object();
      var toString = require_to_string();
      var DELEGATES_TO_EXEC = function() {
        var execCalled = false;
        var re = /[ac]/;
        re.exec = function() {
          execCalled = true;
          return /./.exec.apply(this, arguments);
        };
        return re.test("abc") === true && execCalled;
      }();
      var nativeTest = /./.test;
      $({ target: "RegExp", proto: true, forced: !DELEGATES_TO_EXEC }, {
        test: function(S) {
          var R = anObject(this);
          var string = toString(S);
          var exec = R.exec;
          if (!isCallable(exec)) return call(nativeTest, R, string);
          var result = call(exec, R, string);
          if (result === null) return false;
          anObject(result);
          return true;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.regexp.to-string.js
  var require_es_regexp_to_string = __commonJS({
    "node_modules/core-js/modules/es.regexp.to-string.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var PROPER_FUNCTION_NAME = require_function_name().PROPER;
      var defineBuiltIn = require_define_built_in();
      var anObject = require_an_object();
      var $toString = require_to_string();
      var fails = require_fails();
      var getRegExpFlags = require_regexp_get_flags();
      var TO_STRING = "toString";
      var RegExpPrototype = RegExp.prototype;
      var nativeToString = RegExpPrototype[TO_STRING];
      var NOT_GENERIC = fails(function() {
        return nativeToString.call({ source: "a", flags: "b" }) !== "/a/b";
      });
      var INCORRECT_NAME = PROPER_FUNCTION_NAME && nativeToString.name !== TO_STRING;
      if (NOT_GENERIC || INCORRECT_NAME) {
        defineBuiltIn(RegExpPrototype, TO_STRING, function toString() {
          var R = anObject(this);
          var pattern = $toString(R.source);
          var flags = $toString(getRegExpFlags(R));
          return "/" + pattern + "/" + flags;
        }, { unsafe: true });
      }
    }
  });

  // node_modules/core-js/modules/es.set.constructor.js
  var require_es_set_constructor = __commonJS({
    "node_modules/core-js/modules/es.set.constructor.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var collection = require_collection();
      var collectionStrong = require_collection_strong();
      collection("Set", function(init) {
        return function Set2() {
          return init(this, arguments.length ? arguments[0] : void 0);
        };
      }, collectionStrong);
    }
  });

  // node_modules/core-js/modules/es.set.js
  var require_es_set = __commonJS({
    "node_modules/core-js/modules/es.set.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      require_es_set_constructor();
    }
  });

  // node_modules/core-js/internals/set-helpers.js
  var require_set_helpers = __commonJS({
    "node_modules/core-js/internals/set-helpers.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var uncurryThis = require_function_uncurry_this();
      var SetPrototype = Set.prototype;
      module.exports = {
        // eslint-disable-next-line es/no-set -- safe
        Set,
        add: uncurryThis(SetPrototype.add),
        has: uncurryThis(SetPrototype.has),
        remove: uncurryThis(SetPrototype["delete"]),
        proto: SetPrototype
      };
    }
  });

  // node_modules/core-js/internals/a-set.js
  var require_a_set = __commonJS({
    "node_modules/core-js/internals/a-set.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var has = require_set_helpers().has;
      module.exports = function(it) {
        has(it);
        return it;
      };
    }
  });

  // node_modules/core-js/internals/iterate-simple.js
  var require_iterate_simple = __commonJS({
    "node_modules/core-js/internals/iterate-simple.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var call = require_function_call();
      module.exports = function(record, fn, ITERATOR_INSTEAD_OF_RECORD) {
        var iterator = ITERATOR_INSTEAD_OF_RECORD ? record : record.iterator;
        var next = record.next;
        var step, result;
        while (!(step = call(next, iterator)).done) {
          result = fn(step.value);
          if (result !== void 0) return result;
        }
      };
    }
  });

  // node_modules/core-js/internals/set-iterate.js
  var require_set_iterate = __commonJS({
    "node_modules/core-js/internals/set-iterate.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var uncurryThis = require_function_uncurry_this();
      var iterateSimple = require_iterate_simple();
      var SetHelpers = require_set_helpers();
      var Set2 = SetHelpers.Set;
      var SetPrototype = SetHelpers.proto;
      var forEach2 = uncurryThis(SetPrototype.forEach);
      var keys = uncurryThis(SetPrototype.keys);
      var next = keys(new Set2()).next;
      module.exports = function(set2, fn, interruptible) {
        return interruptible ? iterateSimple({ iterator: keys(set2), next }, fn) : forEach2(set2, fn);
      };
    }
  });

  // node_modules/core-js/internals/set-clone.js
  var require_set_clone = __commonJS({
    "node_modules/core-js/internals/set-clone.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var SetHelpers = require_set_helpers();
      var iterate = require_set_iterate();
      var Set2 = SetHelpers.Set;
      var add = SetHelpers.add;
      module.exports = function(set2) {
        var result = new Set2();
        iterate(set2, function(it) {
          add(result, it);
        });
        return result;
      };
    }
  });

  // node_modules/core-js/internals/set-size.js
  var require_set_size = __commonJS({
    "node_modules/core-js/internals/set-size.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var uncurryThisAccessor = require_function_uncurry_this_accessor();
      var SetHelpers = require_set_helpers();
      module.exports = uncurryThisAccessor(SetHelpers.proto, "size", "get") || function(set2) {
        return set2.size;
      };
    }
  });

  // node_modules/core-js/internals/get-iterator-direct.js
  var require_get_iterator_direct = __commonJS({
    "node_modules/core-js/internals/get-iterator-direct.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      module.exports = function(obj) {
        return {
          iterator: obj,
          next: obj.next,
          done: false
        };
      };
    }
  });

  // node_modules/core-js/internals/get-set-record.js
  var require_get_set_record = __commonJS({
    "node_modules/core-js/internals/get-set-record.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var aCallable = require_a_callable();
      var anObject = require_an_object();
      var call = require_function_call();
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var getIteratorDirect = require_get_iterator_direct();
      var INVALID_SIZE = "Invalid size";
      var $RangeError = RangeError;
      var $TypeError = TypeError;
      var max = Math.max;
      var SetRecord = function(set2, intSize) {
        this.set = set2;
        this.size = max(intSize, 0);
        this.has = aCallable(set2.has);
        this.keys = aCallable(set2.keys);
      };
      SetRecord.prototype = {
        getIterator: function() {
          return getIteratorDirect(anObject(call(this.keys, this.set)));
        },
        includes: function(it) {
          return call(this.has, this.set, it);
        }
      };
      module.exports = function(obj) {
        anObject(obj);
        var numSize = +obj.size;
        if (numSize !== numSize) throw new $TypeError(INVALID_SIZE);
        var intSize = toIntegerOrInfinity(numSize);
        if (intSize < 0) throw new $RangeError(INVALID_SIZE);
        return new SetRecord(obj, intSize);
      };
    }
  });

  // node_modules/core-js/internals/set-difference.js
  var require_set_difference = __commonJS({
    "node_modules/core-js/internals/set-difference.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var aSet = require_a_set();
      var SetHelpers = require_set_helpers();
      var clone = require_set_clone();
      var size = require_set_size();
      var getSetRecord = require_get_set_record();
      var iterateSet = require_set_iterate();
      var iterateSimple = require_iterate_simple();
      var has = SetHelpers.has;
      var remove = SetHelpers.remove;
      module.exports = function difference(other) {
        var O = aSet(this);
        var otherRec = getSetRecord(other);
        var result = clone(O);
        if (size(O) <= otherRec.size) iterateSet(O, function(e) {
          if (otherRec.includes(e)) remove(result, e);
        });
        else iterateSimple(otherRec.getIterator(), function(e) {
          if (has(O, e)) remove(result, e);
        });
        return result;
      };
    }
  });

  // node_modules/core-js/internals/set-method-accept-set-like.js
  var require_set_method_accept_set_like = __commonJS({
    "node_modules/core-js/internals/set-method-accept-set-like.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var getBuiltIn = require_get_built_in();
      var createSetLike = function(size) {
        return {
          size,
          has: function() {
            return false;
          },
          keys: function() {
            return {
              next: function() {
                return { done: true };
              }
            };
          }
        };
      };
      module.exports = function(name2) {
        var Set2 = getBuiltIn("Set");
        try {
          new Set2()[name2](createSetLike(0));
          try {
            new Set2()[name2](createSetLike(-1));
            return false;
          } catch (error2) {
            return true;
          }
        } catch (error) {
          return false;
        }
      };
    }
  });

  // node_modules/core-js/modules/es.set.difference.v2.js
  var require_es_set_difference_v2 = __commonJS({
    "node_modules/core-js/modules/es.set.difference.v2.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var difference = require_set_difference();
      var setMethodAcceptSetLike = require_set_method_accept_set_like();
      $({ target: "Set", proto: true, real: true, forced: !setMethodAcceptSetLike("difference") }, {
        difference
      });
    }
  });

  // node_modules/core-js/internals/set-intersection.js
  var require_set_intersection = __commonJS({
    "node_modules/core-js/internals/set-intersection.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var aSet = require_a_set();
      var SetHelpers = require_set_helpers();
      var size = require_set_size();
      var getSetRecord = require_get_set_record();
      var iterateSet = require_set_iterate();
      var iterateSimple = require_iterate_simple();
      var Set2 = SetHelpers.Set;
      var add = SetHelpers.add;
      var has = SetHelpers.has;
      module.exports = function intersection(other) {
        var O = aSet(this);
        var otherRec = getSetRecord(other);
        var result = new Set2();
        if (size(O) > otherRec.size) {
          iterateSimple(otherRec.getIterator(), function(e) {
            if (has(O, e)) add(result, e);
          });
        } else {
          iterateSet(O, function(e) {
            if (otherRec.includes(e)) add(result, e);
          });
        }
        return result;
      };
    }
  });

  // node_modules/core-js/modules/es.set.intersection.v2.js
  var require_es_set_intersection_v2 = __commonJS({
    "node_modules/core-js/modules/es.set.intersection.v2.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var fails = require_fails();
      var intersection = require_set_intersection();
      var setMethodAcceptSetLike = require_set_method_accept_set_like();
      var INCORRECT = !setMethodAcceptSetLike("intersection") || fails(function() {
        return String(Array.from((/* @__PURE__ */ new Set([1, 2, 3])).intersection(/* @__PURE__ */ new Set([3, 2])))) !== "3,2";
      });
      $({ target: "Set", proto: true, real: true, forced: INCORRECT }, {
        intersection
      });
    }
  });

  // node_modules/core-js/internals/set-is-disjoint-from.js
  var require_set_is_disjoint_from = __commonJS({
    "node_modules/core-js/internals/set-is-disjoint-from.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var aSet = require_a_set();
      var has = require_set_helpers().has;
      var size = require_set_size();
      var getSetRecord = require_get_set_record();
      var iterateSet = require_set_iterate();
      var iterateSimple = require_iterate_simple();
      var iteratorClose = require_iterator_close();
      module.exports = function isDisjointFrom(other) {
        var O = aSet(this);
        var otherRec = getSetRecord(other);
        if (size(O) <= otherRec.size) return iterateSet(O, function(e) {
          if (otherRec.includes(e)) return false;
        }, true) !== false;
        var iterator = otherRec.getIterator();
        return iterateSimple(iterator, function(e) {
          if (has(O, e)) return iteratorClose(iterator, "normal", false);
        }) !== false;
      };
    }
  });

  // node_modules/core-js/modules/es.set.is-disjoint-from.v2.js
  var require_es_set_is_disjoint_from_v2 = __commonJS({
    "node_modules/core-js/modules/es.set.is-disjoint-from.v2.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var isDisjointFrom = require_set_is_disjoint_from();
      var setMethodAcceptSetLike = require_set_method_accept_set_like();
      $({ target: "Set", proto: true, real: true, forced: !setMethodAcceptSetLike("isDisjointFrom") }, {
        isDisjointFrom
      });
    }
  });

  // node_modules/core-js/internals/set-is-subset-of.js
  var require_set_is_subset_of = __commonJS({
    "node_modules/core-js/internals/set-is-subset-of.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var aSet = require_a_set();
      var size = require_set_size();
      var iterate = require_set_iterate();
      var getSetRecord = require_get_set_record();
      module.exports = function isSubsetOf(other) {
        var O = aSet(this);
        var otherRec = getSetRecord(other);
        if (size(O) > otherRec.size) return false;
        return iterate(O, function(e) {
          if (!otherRec.includes(e)) return false;
        }, true) !== false;
      };
    }
  });

  // node_modules/core-js/modules/es.set.is-subset-of.v2.js
  var require_es_set_is_subset_of_v2 = __commonJS({
    "node_modules/core-js/modules/es.set.is-subset-of.v2.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var isSubsetOf = require_set_is_subset_of();
      var setMethodAcceptSetLike = require_set_method_accept_set_like();
      $({ target: "Set", proto: true, real: true, forced: !setMethodAcceptSetLike("isSubsetOf") }, {
        isSubsetOf
      });
    }
  });

  // node_modules/core-js/internals/set-is-superset-of.js
  var require_set_is_superset_of = __commonJS({
    "node_modules/core-js/internals/set-is-superset-of.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var aSet = require_a_set();
      var has = require_set_helpers().has;
      var size = require_set_size();
      var getSetRecord = require_get_set_record();
      var iterateSimple = require_iterate_simple();
      var iteratorClose = require_iterator_close();
      module.exports = function isSupersetOf(other) {
        var O = aSet(this);
        var otherRec = getSetRecord(other);
        if (size(O) < otherRec.size) return false;
        var iterator = otherRec.getIterator();
        return iterateSimple(iterator, function(e) {
          if (!has(O, e)) return iteratorClose(iterator, "normal", false);
        }) !== false;
      };
    }
  });

  // node_modules/core-js/modules/es.set.is-superset-of.v2.js
  var require_es_set_is_superset_of_v2 = __commonJS({
    "node_modules/core-js/modules/es.set.is-superset-of.v2.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var isSupersetOf = require_set_is_superset_of();
      var setMethodAcceptSetLike = require_set_method_accept_set_like();
      $({ target: "Set", proto: true, real: true, forced: !setMethodAcceptSetLike("isSupersetOf") }, {
        isSupersetOf
      });
    }
  });

  // node_modules/core-js/internals/set-symmetric-difference.js
  var require_set_symmetric_difference = __commonJS({
    "node_modules/core-js/internals/set-symmetric-difference.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var aSet = require_a_set();
      var SetHelpers = require_set_helpers();
      var clone = require_set_clone();
      var getSetRecord = require_get_set_record();
      var iterateSimple = require_iterate_simple();
      var add = SetHelpers.add;
      var has = SetHelpers.has;
      var remove = SetHelpers.remove;
      module.exports = function symmetricDifference(other) {
        var O = aSet(this);
        var keysIter = getSetRecord(other).getIterator();
        var result = clone(O);
        iterateSimple(keysIter, function(e) {
          if (has(O, e)) remove(result, e);
          else add(result, e);
        });
        return result;
      };
    }
  });

  // node_modules/core-js/modules/es.set.symmetric-difference.v2.js
  var require_es_set_symmetric_difference_v2 = __commonJS({
    "node_modules/core-js/modules/es.set.symmetric-difference.v2.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var symmetricDifference = require_set_symmetric_difference();
      var setMethodAcceptSetLike = require_set_method_accept_set_like();
      $({ target: "Set", proto: true, real: true, forced: !setMethodAcceptSetLike("symmetricDifference") }, {
        symmetricDifference
      });
    }
  });

  // node_modules/core-js/internals/set-union.js
  var require_set_union = __commonJS({
    "node_modules/core-js/internals/set-union.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var aSet = require_a_set();
      var add = require_set_helpers().add;
      var clone = require_set_clone();
      var getSetRecord = require_get_set_record();
      var iterateSimple = require_iterate_simple();
      module.exports = function union(other) {
        var O = aSet(this);
        var keysIter = getSetRecord(other).getIterator();
        var result = clone(O);
        iterateSimple(keysIter, function(it) {
          add(result, it);
        });
        return result;
      };
    }
  });

  // node_modules/core-js/modules/es.set.union.v2.js
  var require_es_set_union_v2 = __commonJS({
    "node_modules/core-js/modules/es.set.union.v2.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var union = require_set_union();
      var setMethodAcceptSetLike = require_set_method_accept_set_like();
      $({ target: "Set", proto: true, real: true, forced: !setMethodAcceptSetLike("union") }, {
        union
      });
    }
  });

  // node_modules/core-js/modules/es.string.at-alternative.js
  var require_es_string_at_alternative = __commonJS({
    "node_modules/core-js/modules/es.string.at-alternative.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var uncurryThis = require_function_uncurry_this();
      var requireObjectCoercible = require_require_object_coercible();
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var toString = require_to_string();
      var fails = require_fails();
      var charAt = uncurryThis("".charAt);
      var FORCED = fails(function() {
        return "\u{20BB7}".at(-2) !== "\uD842";
      });
      $({ target: "String", proto: true, forced: FORCED }, {
        at: function at(index) {
          var S = toString(requireObjectCoercible(this));
          var len = S.length;
          var relativeIndex = toIntegerOrInfinity(index);
          var k = relativeIndex >= 0 ? relativeIndex : len + relativeIndex;
          return k < 0 || k >= len ? void 0 : charAt(S, k);
        }
      });
    }
  });

  // node_modules/core-js/internals/string-multibyte.js
  var require_string_multibyte = __commonJS({
    "node_modules/core-js/internals/string-multibyte.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var uncurryThis = require_function_uncurry_this();
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var toString = require_to_string();
      var requireObjectCoercible = require_require_object_coercible();
      var charAt = uncurryThis("".charAt);
      var charCodeAt = uncurryThis("".charCodeAt);
      var stringSlice = uncurryThis("".slice);
      var createMethod = function(CONVERT_TO_STRING) {
        return function($this, pos) {
          var S = toString(requireObjectCoercible($this));
          var position = toIntegerOrInfinity(pos);
          var size = S.length;
          var first, second;
          if (position < 0 || position >= size) return CONVERT_TO_STRING ? "" : void 0;
          first = charCodeAt(S, position);
          return first < 55296 || first > 56319 || position + 1 === size || (second = charCodeAt(S, position + 1)) < 56320 || second > 57343 ? CONVERT_TO_STRING ? charAt(S, position) : first : CONVERT_TO_STRING ? stringSlice(S, position, position + 2) : (first - 55296 << 10) + (second - 56320) + 65536;
        };
      };
      module.exports = {
        // `String.prototype.codePointAt` method
        // https://tc39.es/ecma262/#sec-string.prototype.codepointat
        codeAt: createMethod(false),
        // `String.prototype.at` method
        // https://github.com/mathiasbynens/String.prototype.at
        charAt: createMethod(true)
      };
    }
  });

  // node_modules/core-js/modules/es.string.code-point-at.js
  var require_es_string_code_point_at = __commonJS({
    "node_modules/core-js/modules/es.string.code-point-at.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var codeAt = require_string_multibyte().codeAt;
      $({ target: "String", proto: true }, {
        codePointAt: function codePointAt(pos) {
          return codeAt(this, pos);
        }
      });
    }
  });

  // node_modules/core-js/internals/not-a-regexp.js
  var require_not_a_regexp = __commonJS({
    "node_modules/core-js/internals/not-a-regexp.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var isRegExp = require_is_regexp();
      var $TypeError = TypeError;
      module.exports = function(it) {
        if (isRegExp(it)) {
          throw new $TypeError("The method doesn't accept regular expressions");
        }
        return it;
      };
    }
  });

  // node_modules/core-js/internals/correct-is-regexp-logic.js
  var require_correct_is_regexp_logic = __commonJS({
    "node_modules/core-js/internals/correct-is-regexp-logic.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var wellKnownSymbol = require_well_known_symbol();
      var MATCH = wellKnownSymbol("match");
      module.exports = function(METHOD_NAME) {
        var regexp = /./;
        try {
          "/./"[METHOD_NAME](regexp);
        } catch (error1) {
          try {
            regexp[MATCH] = false;
            return "/./"[METHOD_NAME](regexp);
          } catch (error2) {
          }
        }
        return false;
      };
    }
  });

  // node_modules/core-js/modules/es.string.ends-with.js
  var require_es_string_ends_with = __commonJS({
    "node_modules/core-js/modules/es.string.ends-with.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var uncurryThis = require_function_uncurry_this_clause();
      var getOwnPropertyDescriptor = require_object_get_own_property_descriptor().f;
      var toLength = require_to_length();
      var toString = require_to_string();
      var notARegExp = require_not_a_regexp();
      var requireObjectCoercible = require_require_object_coercible();
      var correctIsRegExpLogic = require_correct_is_regexp_logic();
      var IS_PURE = require_is_pure();
      var slice = uncurryThis("".slice);
      var min = Math.min;
      var CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic("endsWith");
      var MDN_POLYFILL_BUG = !IS_PURE && !CORRECT_IS_REGEXP_LOGIC && !!function() {
        var descriptor = getOwnPropertyDescriptor(String.prototype, "endsWith");
        return descriptor && !descriptor.writable;
      }();
      $({ target: "String", proto: true, forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC }, {
        endsWith: function endsWith(searchString) {
          var that = toString(requireObjectCoercible(this));
          notARegExp(searchString);
          var endPosition = arguments.length > 1 ? arguments[1] : void 0;
          var len = that.length;
          var end = endPosition === void 0 ? len : min(toLength(endPosition), len);
          var search = toString(searchString);
          return slice(that, end - search.length, end) === search;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.from-code-point.js
  var require_es_string_from_code_point = __commonJS({
    "node_modules/core-js/modules/es.string.from-code-point.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var uncurryThis = require_function_uncurry_this();
      var toAbsoluteIndex = require_to_absolute_index();
      var $RangeError = RangeError;
      var fromCharCode = String.fromCharCode;
      var $fromCodePoint = String.fromCodePoint;
      var join = uncurryThis([].join);
      var INCORRECT_LENGTH = !!$fromCodePoint && $fromCodePoint.length !== 1;
      $({ target: "String", stat: true, arity: 1, forced: INCORRECT_LENGTH }, {
        // eslint-disable-next-line no-unused-vars -- required for `.length`
        fromCodePoint: function fromCodePoint(x) {
          var elements = [];
          var length = arguments.length;
          var i = 0;
          var code;
          while (length > i) {
            code = +arguments[i++];
            if (toAbsoluteIndex(code, 1114111) !== code) throw new $RangeError(code + " is not a valid code point");
            elements[i] = code < 65536 ? fromCharCode(code) : fromCharCode(((code -= 65536) >> 10) + 55296, code % 1024 + 56320);
          }
          return join(elements, "");
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.includes.js
  var require_es_string_includes = __commonJS({
    "node_modules/core-js/modules/es.string.includes.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var uncurryThis = require_function_uncurry_this();
      var notARegExp = require_not_a_regexp();
      var requireObjectCoercible = require_require_object_coercible();
      var toString = require_to_string();
      var correctIsRegExpLogic = require_correct_is_regexp_logic();
      var stringIndexOf = uncurryThis("".indexOf);
      $({ target: "String", proto: true, forced: !correctIsRegExpLogic("includes") }, {
        includes: function includes(searchString) {
          return !!~stringIndexOf(
            toString(requireObjectCoercible(this)),
            toString(notARegExp(searchString)),
            arguments.length > 1 ? arguments[1] : void 0
          );
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.is-well-formed.js
  var require_es_string_is_well_formed = __commonJS({
    "node_modules/core-js/modules/es.string.is-well-formed.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var uncurryThis = require_function_uncurry_this();
      var requireObjectCoercible = require_require_object_coercible();
      var toString = require_to_string();
      var charCodeAt = uncurryThis("".charCodeAt);
      $({ target: "String", proto: true }, {
        isWellFormed: function isWellFormed() {
          var S = toString(requireObjectCoercible(this));
          var length = S.length;
          for (var i = 0; i < length; i++) {
            var charCode = charCodeAt(S, i);
            if ((charCode & 63488) !== 55296) continue;
            if (charCode >= 56320 || ++i >= length || (charCodeAt(S, i) & 64512) !== 56320) return false;
          }
          return true;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.iterator.js
  var require_es_string_iterator = __commonJS({
    "node_modules/core-js/modules/es.string.iterator.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var charAt = require_string_multibyte().charAt;
      var toString = require_to_string();
      var InternalStateModule = require_internal_state();
      var defineIterator = require_iterator_define();
      var createIterResultObject = require_create_iter_result_object();
      var STRING_ITERATOR = "String Iterator";
      var setInternalState = InternalStateModule.set;
      var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);
      defineIterator(String, "String", function(iterated) {
        setInternalState(this, {
          type: STRING_ITERATOR,
          string: toString(iterated),
          index: 0
        });
      }, function next() {
        var state = getInternalState(this);
        var string = state.string;
        var index = state.index;
        var point;
        if (index >= string.length) return createIterResultObject(void 0, true);
        point = charAt(string, index);
        state.index += point.length;
        return createIterResultObject(point, false);
      });
    }
  });

  // node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js
  var require_fix_regexp_well_known_symbol_logic = __commonJS({
    "node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      require_es_regexp_exec();
      var call = require_function_call();
      var defineBuiltIn = require_define_built_in();
      var regexpExec = require_regexp_exec();
      var fails = require_fails();
      var wellKnownSymbol = require_well_known_symbol();
      var createNonEnumerableProperty = require_create_non_enumerable_property();
      var SPECIES = wellKnownSymbol("species");
      var RegExpPrototype = RegExp.prototype;
      module.exports = function(KEY, exec, FORCED, SHAM) {
        var SYMBOL = wellKnownSymbol(KEY);
        var DELEGATES_TO_SYMBOL = !fails(function() {
          var O = {};
          O[SYMBOL] = function() {
            return 7;
          };
          return ""[KEY](O) !== 7;
        });
        var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function() {
          var execCalled = false;
          var re = /a/;
          if (KEY === "split") {
            re = {};
            re.constructor = {};
            re.constructor[SPECIES] = function() {
              return re;
            };
            re.flags = "";
            re[SYMBOL] = /./[SYMBOL];
          }
          re.exec = function() {
            execCalled = true;
            return null;
          };
          re[SYMBOL]("");
          return !execCalled;
        });
        if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || FORCED) {
          var nativeRegExpMethod = /./[SYMBOL];
          var methods = exec(SYMBOL, ""[KEY], function(nativeMethod, regexp, str, arg2, forceStringMethod) {
            var $exec = regexp.exec;
            if ($exec === regexpExec || $exec === RegExpPrototype.exec) {
              if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
                return { done: true, value: call(nativeRegExpMethod, regexp, str, arg2) };
              }
              return { done: true, value: call(nativeMethod, str, regexp, arg2) };
            }
            return { done: false };
          });
          defineBuiltIn(String.prototype, KEY, methods[0]);
          defineBuiltIn(RegExpPrototype, SYMBOL, methods[1]);
        }
        if (SHAM) createNonEnumerableProperty(RegExpPrototype[SYMBOL], "sham", true);
      };
    }
  });

  // node_modules/core-js/internals/advance-string-index.js
  var require_advance_string_index = __commonJS({
    "node_modules/core-js/internals/advance-string-index.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var charAt = require_string_multibyte().charAt;
      module.exports = function(S, index, unicode) {
        return index + (unicode ? charAt(S, index).length : 1);
      };
    }
  });

  // node_modules/core-js/internals/regexp-exec-abstract.js
  var require_regexp_exec_abstract = __commonJS({
    "node_modules/core-js/internals/regexp-exec-abstract.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var call = require_function_call();
      var anObject = require_an_object();
      var isCallable = require_is_callable();
      var classof = require_classof_raw();
      var regexpExec = require_regexp_exec();
      var $TypeError = TypeError;
      module.exports = function(R, S) {
        var exec = R.exec;
        if (isCallable(exec)) {
          var result = call(exec, R, S);
          if (result !== null) anObject(result);
          return result;
        }
        if (classof(R) === "RegExp") return call(regexpExec, R, S);
        throw new $TypeError("RegExp#exec called on incompatible receiver");
      };
    }
  });

  // node_modules/core-js/modules/es.string.match.js
  var require_es_string_match = __commonJS({
    "node_modules/core-js/modules/es.string.match.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var call = require_function_call();
      var fixRegExpWellKnownSymbolLogic = require_fix_regexp_well_known_symbol_logic();
      var anObject = require_an_object();
      var isNullOrUndefined2 = require_is_null_or_undefined();
      var toLength = require_to_length();
      var toString = require_to_string();
      var requireObjectCoercible = require_require_object_coercible();
      var getMethod = require_get_method();
      var advanceStringIndex = require_advance_string_index();
      var regExpExec = require_regexp_exec_abstract();
      fixRegExpWellKnownSymbolLogic("match", function(MATCH, nativeMatch, maybeCallNative) {
        return [
          // `String.prototype.match` method
          // https://tc39.es/ecma262/#sec-string.prototype.match
          function match(regexp) {
            var O = requireObjectCoercible(this);
            var matcher = isNullOrUndefined2(regexp) ? void 0 : getMethod(regexp, MATCH);
            return matcher ? call(matcher, regexp, O) : new RegExp(regexp)[MATCH](toString(O));
          },
          // `RegExp.prototype[@@match]` method
          // https://tc39.es/ecma262/#sec-regexp.prototype-@@match
          function(string) {
            var rx = anObject(this);
            var S = toString(string);
            var res = maybeCallNative(nativeMatch, rx, S);
            if (res.done) return res.value;
            if (!rx.global) return regExpExec(rx, S);
            var fullUnicode = rx.unicode;
            rx.lastIndex = 0;
            var A = [];
            var n = 0;
            var result;
            while ((result = regExpExec(rx, S)) !== null) {
              var matchStr = toString(result[0]);
              A[n] = matchStr;
              if (matchStr === "") rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
              n++;
            }
            return n === 0 ? null : A;
          }
        ];
      });
    }
  });

  // node_modules/core-js/modules/es.string.match-all.js
  var require_es_string_match_all = __commonJS({
    "node_modules/core-js/modules/es.string.match-all.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var call = require_function_call();
      var uncurryThis = require_function_uncurry_this_clause();
      var createIteratorConstructor = require_iterator_create_constructor();
      var createIterResultObject = require_create_iter_result_object();
      var requireObjectCoercible = require_require_object_coercible();
      var toLength = require_to_length();
      var toString = require_to_string();
      var anObject = require_an_object();
      var isNullOrUndefined2 = require_is_null_or_undefined();
      var classof = require_classof_raw();
      var isRegExp = require_is_regexp();
      var getRegExpFlags = require_regexp_get_flags();
      var getMethod = require_get_method();
      var defineBuiltIn = require_define_built_in();
      var fails = require_fails();
      var wellKnownSymbol = require_well_known_symbol();
      var speciesConstructor = require_species_constructor();
      var advanceStringIndex = require_advance_string_index();
      var regExpExec = require_regexp_exec_abstract();
      var InternalStateModule = require_internal_state();
      var IS_PURE = require_is_pure();
      var MATCH_ALL = wellKnownSymbol("matchAll");
      var REGEXP_STRING = "RegExp String";
      var REGEXP_STRING_ITERATOR = REGEXP_STRING + " Iterator";
      var setInternalState = InternalStateModule.set;
      var getInternalState = InternalStateModule.getterFor(REGEXP_STRING_ITERATOR);
      var RegExpPrototype = RegExp.prototype;
      var $TypeError = TypeError;
      var stringIndexOf = uncurryThis("".indexOf);
      var nativeMatchAll = uncurryThis("".matchAll);
      var WORKS_WITH_NON_GLOBAL_REGEX = !!nativeMatchAll && !fails(function() {
        nativeMatchAll("a", /./);
      });
      var $RegExpStringIterator = createIteratorConstructor(function RegExpStringIterator(regexp, string, $global, fullUnicode) {
        setInternalState(this, {
          type: REGEXP_STRING_ITERATOR,
          regexp,
          string,
          global: $global,
          unicode: fullUnicode,
          done: false
        });
      }, REGEXP_STRING, function next() {
        var state = getInternalState(this);
        if (state.done) return createIterResultObject(void 0, true);
        var R = state.regexp;
        var S = state.string;
        var match = regExpExec(R, S);
        if (match === null) {
          state.done = true;
          return createIterResultObject(void 0, true);
        }
        if (state.global) {
          if (toString(match[0]) === "") R.lastIndex = advanceStringIndex(S, toLength(R.lastIndex), state.unicode);
          return createIterResultObject(match, false);
        }
        state.done = true;
        return createIterResultObject(match, false);
      });
      var $matchAll = function(string) {
        var R = anObject(this);
        var S = toString(string);
        var C = speciesConstructor(R, RegExp);
        var flags = toString(getRegExpFlags(R));
        var matcher, $global, fullUnicode;
        matcher = new C(C === RegExp ? R.source : R, flags);
        $global = !!~stringIndexOf(flags, "g");
        fullUnicode = !!~stringIndexOf(flags, "u");
        matcher.lastIndex = toLength(R.lastIndex);
        return new $RegExpStringIterator(matcher, S, $global, fullUnicode);
      };
      $({ target: "String", proto: true, forced: WORKS_WITH_NON_GLOBAL_REGEX }, {
        matchAll: function matchAll(regexp) {
          var O = requireObjectCoercible(this);
          var flags, S, matcher, rx;
          if (!isNullOrUndefined2(regexp)) {
            if (isRegExp(regexp)) {
              flags = toString(requireObjectCoercible(getRegExpFlags(regexp)));
              if (!~stringIndexOf(flags, "g")) throw new $TypeError("`.matchAll` does not allow non-global regexes");
            }
            if (WORKS_WITH_NON_GLOBAL_REGEX) return nativeMatchAll(O, regexp);
            matcher = getMethod(regexp, MATCH_ALL);
            if (matcher === void 0 && IS_PURE && classof(regexp) === "RegExp") matcher = $matchAll;
            if (matcher) return call(matcher, regexp, O);
          } else if (WORKS_WITH_NON_GLOBAL_REGEX) return nativeMatchAll(O, regexp);
          S = toString(O);
          rx = new RegExp(regexp, "g");
          return IS_PURE ? call($matchAll, rx, S) : rx[MATCH_ALL](S);
        }
      });
      IS_PURE || MATCH_ALL in RegExpPrototype || defineBuiltIn(RegExpPrototype, MATCH_ALL, $matchAll);
    }
  });

  // node_modules/core-js/internals/string-pad-webkit-bug.js
  var require_string_pad_webkit_bug = __commonJS({
    "node_modules/core-js/internals/string-pad-webkit-bug.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var userAgent = require_engine_user_agent();
      module.exports = /Version\/10(?:\.\d+){1,2}(?: [\w./]+)?(?: Mobile\/\w+)? Safari\//.test(userAgent);
    }
  });

  // node_modules/core-js/modules/es.string.pad-end.js
  var require_es_string_pad_end = __commonJS({
    "node_modules/core-js/modules/es.string.pad-end.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var $padEnd = require_string_pad().end;
      var WEBKIT_BUG = require_string_pad_webkit_bug();
      $({ target: "String", proto: true, forced: WEBKIT_BUG }, {
        padEnd: function padEnd(maxLength) {
          return $padEnd(this, maxLength, arguments.length > 1 ? arguments[1] : void 0);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.pad-start.js
  var require_es_string_pad_start = __commonJS({
    "node_modules/core-js/modules/es.string.pad-start.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var $padStart = require_string_pad().start;
      var WEBKIT_BUG = require_string_pad_webkit_bug();
      $({ target: "String", proto: true, forced: WEBKIT_BUG }, {
        padStart: function padStart(maxLength) {
          return $padStart(this, maxLength, arguments.length > 1 ? arguments[1] : void 0);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.raw.js
  var require_es_string_raw = __commonJS({
    "node_modules/core-js/modules/es.string.raw.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var uncurryThis = require_function_uncurry_this();
      var toIndexedObject = require_to_indexed_object();
      var toObject = require_to_object();
      var toString = require_to_string();
      var lengthOfArrayLike = require_length_of_array_like();
      var push = uncurryThis([].push);
      var join = uncurryThis([].join);
      $({ target: "String", stat: true }, {
        raw: function raw(template) {
          var rawTemplate = toIndexedObject(toObject(template).raw);
          var literalSegments = lengthOfArrayLike(rawTemplate);
          if (!literalSegments) return "";
          var argumentsLength = arguments.length;
          var elements = [];
          var i = 0;
          while (true) {
            push(elements, toString(rawTemplate[i++]));
            if (i === literalSegments) return join(elements, "");
            if (i < argumentsLength) push(elements, toString(arguments[i]));
          }
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.repeat.js
  var require_es_string_repeat = __commonJS({
    "node_modules/core-js/modules/es.string.repeat.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var repeat = require_string_repeat();
      $({ target: "String", proto: true }, {
        repeat
      });
    }
  });

  // node_modules/core-js/internals/get-substitution.js
  var require_get_substitution = __commonJS({
    "node_modules/core-js/internals/get-substitution.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var uncurryThis = require_function_uncurry_this();
      var toObject = require_to_object();
      var floor = Math.floor;
      var charAt = uncurryThis("".charAt);
      var replace = uncurryThis("".replace);
      var stringSlice = uncurryThis("".slice);
      var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d{1,2}|<[^>]*>)/g;
      var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d{1,2})/g;
      module.exports = function(matched, str, position, captures, namedCaptures, replacement) {
        var tailPos = position + matched.length;
        var m = captures.length;
        var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
        if (namedCaptures !== void 0) {
          namedCaptures = toObject(namedCaptures);
          symbols = SUBSTITUTION_SYMBOLS;
        }
        return replace(replacement, symbols, function(match, ch) {
          var capture;
          switch (charAt(ch, 0)) {
            case "$":
              return "$";
            case "&":
              return matched;
            case "`":
              return stringSlice(str, 0, position);
            case "'":
              return stringSlice(str, tailPos);
            case "<":
              capture = namedCaptures[stringSlice(ch, 1, -1)];
              break;
            default:
              var n = +ch;
              if (n === 0) return match;
              if (n > m) {
                var f = floor(n / 10);
                if (f === 0) return match;
                if (f <= m) return captures[f - 1] === void 0 ? charAt(ch, 1) : captures[f - 1] + charAt(ch, 1);
                return match;
              }
              capture = captures[n - 1];
          }
          return capture === void 0 ? "" : capture;
        });
      };
    }
  });

  // node_modules/core-js/modules/es.string.replace.js
  var require_es_string_replace = __commonJS({
    "node_modules/core-js/modules/es.string.replace.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var apply = require_function_apply();
      var call = require_function_call();
      var uncurryThis = require_function_uncurry_this();
      var fixRegExpWellKnownSymbolLogic = require_fix_regexp_well_known_symbol_logic();
      var fails = require_fails();
      var anObject = require_an_object();
      var isCallable = require_is_callable();
      var isNullOrUndefined2 = require_is_null_or_undefined();
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var toLength = require_to_length();
      var toString = require_to_string();
      var requireObjectCoercible = require_require_object_coercible();
      var advanceStringIndex = require_advance_string_index();
      var getMethod = require_get_method();
      var getSubstitution = require_get_substitution();
      var regExpExec = require_regexp_exec_abstract();
      var wellKnownSymbol = require_well_known_symbol();
      var REPLACE = wellKnownSymbol("replace");
      var max = Math.max;
      var min = Math.min;
      var concat2 = uncurryThis([].concat);
      var push = uncurryThis([].push);
      var stringIndexOf = uncurryThis("".indexOf);
      var stringSlice = uncurryThis("".slice);
      var maybeToString = function(it) {
        return it === void 0 ? it : String(it);
      };
      var REPLACE_KEEPS_$0 = function() {
        return "a".replace(/./, "$0") === "$0";
      }();
      var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = function() {
        if (/./[REPLACE]) {
          return /./[REPLACE]("a", "$0") === "";
        }
        return false;
      }();
      var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function() {
        var re = /./;
        re.exec = function() {
          var result = [];
          result.groups = { a: "7" };
          return result;
        };
        return "".replace(re, "$<a>") !== "7";
      });
      fixRegExpWellKnownSymbolLogic("replace", function(_, nativeReplace, maybeCallNative) {
        var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? "$" : "$0";
        return [
          // `String.prototype.replace` method
          // https://tc39.es/ecma262/#sec-string.prototype.replace
          function replace(searchValue, replaceValue) {
            var O = requireObjectCoercible(this);
            var replacer = isNullOrUndefined2(searchValue) ? void 0 : getMethod(searchValue, REPLACE);
            return replacer ? call(replacer, searchValue, O, replaceValue) : call(nativeReplace, toString(O), searchValue, replaceValue);
          },
          // `RegExp.prototype[@@replace]` method
          // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
          function(string, replaceValue) {
            var rx = anObject(this);
            var S = toString(string);
            if (typeof replaceValue == "string" && stringIndexOf(replaceValue, UNSAFE_SUBSTITUTE) === -1 && stringIndexOf(replaceValue, "$<") === -1) {
              var res = maybeCallNative(nativeReplace, rx, S, replaceValue);
              if (res.done) return res.value;
            }
            var functionalReplace = isCallable(replaceValue);
            if (!functionalReplace) replaceValue = toString(replaceValue);
            var global2 = rx.global;
            var fullUnicode;
            if (global2) {
              fullUnicode = rx.unicode;
              rx.lastIndex = 0;
            }
            var results = [];
            var result;
            while (true) {
              result = regExpExec(rx, S);
              if (result === null) break;
              push(results, result);
              if (!global2) break;
              var matchStr = toString(result[0]);
              if (matchStr === "") rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
            }
            var accumulatedResult = "";
            var nextSourcePosition = 0;
            for (var i = 0; i < results.length; i++) {
              result = results[i];
              var matched = toString(result[0]);
              var position = max(min(toIntegerOrInfinity(result.index), S.length), 0);
              var captures = [];
              var replacement;
              for (var j = 1; j < result.length; j++) push(captures, maybeToString(result[j]));
              var namedCaptures = result.groups;
              if (functionalReplace) {
                var replacerArgs = concat2([matched], captures, position, S);
                if (namedCaptures !== void 0) push(replacerArgs, namedCaptures);
                replacement = toString(apply(replaceValue, void 0, replacerArgs));
              } else {
                replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
              }
              if (position >= nextSourcePosition) {
                accumulatedResult += stringSlice(S, nextSourcePosition, position) + replacement;
                nextSourcePosition = position + matched.length;
              }
            }
            return accumulatedResult + stringSlice(S, nextSourcePosition);
          }
        ];
      }, !REPLACE_SUPPORTS_NAMED_GROUPS || !REPLACE_KEEPS_$0 || REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE);
    }
  });

  // node_modules/core-js/modules/es.string.replace-all.js
  var require_es_string_replace_all = __commonJS({
    "node_modules/core-js/modules/es.string.replace-all.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var call = require_function_call();
      var uncurryThis = require_function_uncurry_this();
      var requireObjectCoercible = require_require_object_coercible();
      var isCallable = require_is_callable();
      var isNullOrUndefined2 = require_is_null_or_undefined();
      var isRegExp = require_is_regexp();
      var toString = require_to_string();
      var getMethod = require_get_method();
      var getRegExpFlags = require_regexp_get_flags();
      var getSubstitution = require_get_substitution();
      var wellKnownSymbol = require_well_known_symbol();
      var IS_PURE = require_is_pure();
      var REPLACE = wellKnownSymbol("replace");
      var $TypeError = TypeError;
      var indexOf = uncurryThis("".indexOf);
      var replace = uncurryThis("".replace);
      var stringSlice = uncurryThis("".slice);
      var max = Math.max;
      $({ target: "String", proto: true }, {
        replaceAll: function replaceAll(searchValue, replaceValue) {
          var O = requireObjectCoercible(this);
          var IS_REG_EXP, flags, replacer, string, searchString, functionalReplace, searchLength, advanceBy, replacement;
          var position = 0;
          var endOfLastMatch = 0;
          var result = "";
          if (!isNullOrUndefined2(searchValue)) {
            IS_REG_EXP = isRegExp(searchValue);
            if (IS_REG_EXP) {
              flags = toString(requireObjectCoercible(getRegExpFlags(searchValue)));
              if (!~indexOf(flags, "g")) throw new $TypeError("`.replaceAll` does not allow non-global regexes");
            }
            replacer = getMethod(searchValue, REPLACE);
            if (replacer) {
              return call(replacer, searchValue, O, replaceValue);
            } else if (IS_PURE && IS_REG_EXP) {
              return replace(toString(O), searchValue, replaceValue);
            }
          }
          string = toString(O);
          searchString = toString(searchValue);
          functionalReplace = isCallable(replaceValue);
          if (!functionalReplace) replaceValue = toString(replaceValue);
          searchLength = searchString.length;
          advanceBy = max(1, searchLength);
          position = indexOf(string, searchString);
          while (position !== -1) {
            replacement = functionalReplace ? toString(replaceValue(searchString, position, string)) : getSubstitution(searchString, string, position, [], void 0, replaceValue);
            result += stringSlice(string, endOfLastMatch, position) + replacement;
            endOfLastMatch = position + searchLength;
            position = position + advanceBy > string.length ? -1 : indexOf(string, searchString, position + advanceBy);
          }
          if (endOfLastMatch < string.length) {
            result += stringSlice(string, endOfLastMatch);
          }
          return result;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.search.js
  var require_es_string_search = __commonJS({
    "node_modules/core-js/modules/es.string.search.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var call = require_function_call();
      var fixRegExpWellKnownSymbolLogic = require_fix_regexp_well_known_symbol_logic();
      var anObject = require_an_object();
      var isNullOrUndefined2 = require_is_null_or_undefined();
      var requireObjectCoercible = require_require_object_coercible();
      var sameValue = require_same_value();
      var toString = require_to_string();
      var getMethod = require_get_method();
      var regExpExec = require_regexp_exec_abstract();
      fixRegExpWellKnownSymbolLogic("search", function(SEARCH, nativeSearch, maybeCallNative) {
        return [
          // `String.prototype.search` method
          // https://tc39.es/ecma262/#sec-string.prototype.search
          function search(regexp) {
            var O = requireObjectCoercible(this);
            var searcher = isNullOrUndefined2(regexp) ? void 0 : getMethod(regexp, SEARCH);
            return searcher ? call(searcher, regexp, O) : new RegExp(regexp)[SEARCH](toString(O));
          },
          // `RegExp.prototype[@@search]` method
          // https://tc39.es/ecma262/#sec-regexp.prototype-@@search
          function(string) {
            var rx = anObject(this);
            var S = toString(string);
            var res = maybeCallNative(nativeSearch, rx, S);
            if (res.done) return res.value;
            var previousLastIndex = rx.lastIndex;
            if (!sameValue(previousLastIndex, 0)) rx.lastIndex = 0;
            var result = regExpExec(rx, S);
            if (!sameValue(rx.lastIndex, previousLastIndex)) rx.lastIndex = previousLastIndex;
            return result === null ? -1 : result.index;
          }
        ];
      });
    }
  });

  // node_modules/core-js/modules/es.string.split.js
  var require_es_string_split = __commonJS({
    "node_modules/core-js/modules/es.string.split.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var call = require_function_call();
      var uncurryThis = require_function_uncurry_this();
      var fixRegExpWellKnownSymbolLogic = require_fix_regexp_well_known_symbol_logic();
      var anObject = require_an_object();
      var isNullOrUndefined2 = require_is_null_or_undefined();
      var requireObjectCoercible = require_require_object_coercible();
      var speciesConstructor = require_species_constructor();
      var advanceStringIndex = require_advance_string_index();
      var toLength = require_to_length();
      var toString = require_to_string();
      var getMethod = require_get_method();
      var regExpExec = require_regexp_exec_abstract();
      var stickyHelpers = require_regexp_sticky_helpers();
      var fails = require_fails();
      var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y;
      var MAX_UINT32 = 4294967295;
      var min = Math.min;
      var push = uncurryThis([].push);
      var stringSlice = uncurryThis("".slice);
      var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function() {
        var re = /(?:)/;
        var originalExec = re.exec;
        re.exec = function() {
          return originalExec.apply(this, arguments);
        };
        var result = "ab".split(re);
        return result.length !== 2 || result[0] !== "a" || result[1] !== "b";
      });
      var BUGGY = "abbc".split(/(b)*/)[1] === "c" || // eslint-disable-next-line regexp/no-empty-group -- required for testing
      "test".split(/(?:)/, -1).length !== 4 || "ab".split(/(?:ab)*/).length !== 2 || ".".split(/(.?)(.?)/).length !== 4 || // eslint-disable-next-line regexp/no-empty-capturing-group, regexp/no-empty-group -- required for testing
      ".".split(/()()/).length > 1 || "".split(/.?/).length;
      fixRegExpWellKnownSymbolLogic("split", function(SPLIT, nativeSplit, maybeCallNative) {
        var internalSplit = "0".split(void 0, 0).length ? function(separator, limit) {
          return separator === void 0 && limit === 0 ? [] : call(nativeSplit, this, separator, limit);
        } : nativeSplit;
        return [
          // `String.prototype.split` method
          // https://tc39.es/ecma262/#sec-string.prototype.split
          function split(separator, limit) {
            var O = requireObjectCoercible(this);
            var splitter = isNullOrUndefined2(separator) ? void 0 : getMethod(separator, SPLIT);
            return splitter ? call(splitter, separator, O, limit) : call(internalSplit, toString(O), separator, limit);
          },
          // `RegExp.prototype[@@split]` method
          // https://tc39.es/ecma262/#sec-regexp.prototype-@@split
          //
          // NOTE: This cannot be properly polyfilled in engines that don't support
          // the 'y' flag.
          function(string, limit) {
            var rx = anObject(this);
            var S = toString(string);
            if (!BUGGY) {
              var res = maybeCallNative(internalSplit, rx, S, limit, internalSplit !== nativeSplit);
              if (res.done) return res.value;
            }
            var C = speciesConstructor(rx, RegExp);
            var unicodeMatching = rx.unicode;
            var flags = (rx.ignoreCase ? "i" : "") + (rx.multiline ? "m" : "") + (rx.unicode ? "u" : "") + (UNSUPPORTED_Y ? "g" : "y");
            var splitter = new C(UNSUPPORTED_Y ? "^(?:" + rx.source + ")" : rx, flags);
            var lim = limit === void 0 ? MAX_UINT32 : limit >>> 0;
            if (lim === 0) return [];
            if (S.length === 0) return regExpExec(splitter, S) === null ? [S] : [];
            var p = 0;
            var q = 0;
            var A = [];
            while (q < S.length) {
              splitter.lastIndex = UNSUPPORTED_Y ? 0 : q;
              var z = regExpExec(splitter, UNSUPPORTED_Y ? stringSlice(S, q) : S);
              var e;
              if (z === null || (e = min(toLength(splitter.lastIndex + (UNSUPPORTED_Y ? q : 0)), S.length)) === p) {
                q = advanceStringIndex(S, q, unicodeMatching);
              } else {
                push(A, stringSlice(S, p, q));
                if (A.length === lim) return A;
                for (var i = 1; i <= z.length - 1; i++) {
                  push(A, z[i]);
                  if (A.length === lim) return A;
                }
                q = p = e;
              }
            }
            push(A, stringSlice(S, p));
            return A;
          }
        ];
      }, BUGGY || !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC, UNSUPPORTED_Y);
    }
  });

  // node_modules/core-js/modules/es.string.starts-with.js
  var require_es_string_starts_with = __commonJS({
    "node_modules/core-js/modules/es.string.starts-with.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var uncurryThis = require_function_uncurry_this_clause();
      var getOwnPropertyDescriptor = require_object_get_own_property_descriptor().f;
      var toLength = require_to_length();
      var toString = require_to_string();
      var notARegExp = require_not_a_regexp();
      var requireObjectCoercible = require_require_object_coercible();
      var correctIsRegExpLogic = require_correct_is_regexp_logic();
      var IS_PURE = require_is_pure();
      var stringSlice = uncurryThis("".slice);
      var min = Math.min;
      var CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic("startsWith");
      var MDN_POLYFILL_BUG = !IS_PURE && !CORRECT_IS_REGEXP_LOGIC && !!function() {
        var descriptor = getOwnPropertyDescriptor(String.prototype, "startsWith");
        return descriptor && !descriptor.writable;
      }();
      $({ target: "String", proto: true, forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC }, {
        startsWith: function startsWith2(searchString) {
          var that = toString(requireObjectCoercible(this));
          notARegExp(searchString);
          var index = toLength(min(arguments.length > 1 ? arguments[1] : void 0, that.length));
          var search = toString(searchString);
          return stringSlice(that, index, index + search.length) === search;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.substr.js
  var require_es_string_substr = __commonJS({
    "node_modules/core-js/modules/es.string.substr.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var uncurryThis = require_function_uncurry_this();
      var requireObjectCoercible = require_require_object_coercible();
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var toString = require_to_string();
      var stringSlice = uncurryThis("".slice);
      var max = Math.max;
      var min = Math.min;
      var FORCED = !"".substr || "ab".substr(-1) !== "b";
      $({ target: "String", proto: true, forced: FORCED }, {
        substr: function substr(start, length) {
          var that = toString(requireObjectCoercible(this));
          var size = that.length;
          var intStart = toIntegerOrInfinity(start);
          var intLength, intEnd;
          if (intStart === Infinity) intStart = 0;
          if (intStart < 0) intStart = max(size + intStart, 0);
          intLength = length === void 0 ? size : toIntegerOrInfinity(length);
          if (intLength <= 0 || intLength === Infinity) return "";
          intEnd = min(intStart + intLength, size);
          return intStart >= intEnd ? "" : stringSlice(that, intStart, intEnd);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.to-well-formed.js
  var require_es_string_to_well_formed = __commonJS({
    "node_modules/core-js/modules/es.string.to-well-formed.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var call = require_function_call();
      var uncurryThis = require_function_uncurry_this();
      var requireObjectCoercible = require_require_object_coercible();
      var toString = require_to_string();
      var fails = require_fails();
      var $Array = Array;
      var charAt = uncurryThis("".charAt);
      var charCodeAt = uncurryThis("".charCodeAt);
      var join = uncurryThis([].join);
      var $toWellFormed = "".toWellFormed;
      var REPLACEMENT_CHARACTER = "\uFFFD";
      var TO_STRING_CONVERSION_BUG = $toWellFormed && fails(function() {
        return call($toWellFormed, 1) !== "1";
      });
      $({ target: "String", proto: true, forced: TO_STRING_CONVERSION_BUG }, {
        toWellFormed: function toWellFormed() {
          var S = toString(requireObjectCoercible(this));
          if (TO_STRING_CONVERSION_BUG) return call($toWellFormed, S);
          var length = S.length;
          var result = $Array(length);
          for (var i = 0; i < length; i++) {
            var charCode = charCodeAt(S, i);
            if ((charCode & 63488) !== 55296) result[i] = charAt(S, i);
            else if (charCode >= 56320 || i + 1 >= length || (charCodeAt(S, i + 1) & 64512) !== 56320) result[i] = REPLACEMENT_CHARACTER;
            else {
              result[i] = charAt(S, i);
              result[++i] = charAt(S, i);
            }
          }
          return join(result, "");
        }
      });
    }
  });

  // node_modules/core-js/internals/string-trim-forced.js
  var require_string_trim_forced = __commonJS({
    "node_modules/core-js/internals/string-trim-forced.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var PROPER_FUNCTION_NAME = require_function_name().PROPER;
      var fails = require_fails();
      var whitespaces = require_whitespaces();
      var non = "\u200B\x85\u180E";
      module.exports = function(METHOD_NAME) {
        return fails(function() {
          return !!whitespaces[METHOD_NAME]() || non[METHOD_NAME]() !== non || PROPER_FUNCTION_NAME && whitespaces[METHOD_NAME].name !== METHOD_NAME;
        });
      };
    }
  });

  // node_modules/core-js/modules/es.string.trim.js
  var require_es_string_trim = __commonJS({
    "node_modules/core-js/modules/es.string.trim.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var $trim = require_string_trim().trim;
      var forcedStringTrimMethod = require_string_trim_forced();
      $({ target: "String", proto: true, forced: forcedStringTrimMethod("trim") }, {
        trim: function trim() {
          return $trim(this);
        }
      });
    }
  });

  // node_modules/core-js/internals/string-trim-end.js
  var require_string_trim_end = __commonJS({
    "node_modules/core-js/internals/string-trim-end.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $trimEnd = require_string_trim().end;
      var forcedStringTrimMethod = require_string_trim_forced();
      module.exports = forcedStringTrimMethod("trimEnd") ? function trimEnd() {
        return $trimEnd(this);
      } : "".trimEnd;
    }
  });

  // node_modules/core-js/modules/es.string.trim-right.js
  var require_es_string_trim_right = __commonJS({
    "node_modules/core-js/modules/es.string.trim-right.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var trimEnd = require_string_trim_end();
      $({ target: "String", proto: true, name: "trimEnd", forced: "".trimRight !== trimEnd }, {
        trimRight: trimEnd
      });
    }
  });

  // node_modules/core-js/modules/es.string.trim-end.js
  var require_es_string_trim_end = __commonJS({
    "node_modules/core-js/modules/es.string.trim-end.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      require_es_string_trim_right();
      var $ = require_export();
      var trimEnd = require_string_trim_end();
      $({ target: "String", proto: true, name: "trimEnd", forced: "".trimEnd !== trimEnd }, {
        trimEnd
      });
    }
  });

  // node_modules/core-js/internals/string-trim-start.js
  var require_string_trim_start = __commonJS({
    "node_modules/core-js/internals/string-trim-start.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $trimStart = require_string_trim().start;
      var forcedStringTrimMethod = require_string_trim_forced();
      module.exports = forcedStringTrimMethod("trimStart") ? function trimStart() {
        return $trimStart(this);
      } : "".trimStart;
    }
  });

  // node_modules/core-js/modules/es.string.trim-left.js
  var require_es_string_trim_left = __commonJS({
    "node_modules/core-js/modules/es.string.trim-left.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var trimStart = require_string_trim_start();
      $({ target: "String", proto: true, name: "trimStart", forced: "".trimLeft !== trimStart }, {
        trimLeft: trimStart
      });
    }
  });

  // node_modules/core-js/modules/es.string.trim-start.js
  var require_es_string_trim_start = __commonJS({
    "node_modules/core-js/modules/es.string.trim-start.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      require_es_string_trim_left();
      var $ = require_export();
      var trimStart = require_string_trim_start();
      $({ target: "String", proto: true, name: "trimStart", forced: "".trimStart !== trimStart }, {
        trimStart
      });
    }
  });

  // node_modules/core-js/internals/create-html.js
  var require_create_html = __commonJS({
    "node_modules/core-js/internals/create-html.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var uncurryThis = require_function_uncurry_this();
      var requireObjectCoercible = require_require_object_coercible();
      var toString = require_to_string();
      var quot = /"/g;
      var replace = uncurryThis("".replace);
      module.exports = function(string, tag, attribute, value) {
        var S = toString(requireObjectCoercible(string));
        var p1 = "<" + tag;
        if (attribute !== "") p1 += " " + attribute + '="' + replace(toString(value), quot, "&quot;") + '"';
        return p1 + ">" + S + "</" + tag + ">";
      };
    }
  });

  // node_modules/core-js/internals/string-html-forced.js
  var require_string_html_forced = __commonJS({
    "node_modules/core-js/internals/string-html-forced.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var fails = require_fails();
      module.exports = function(METHOD_NAME) {
        return fails(function() {
          var test = ""[METHOD_NAME]('"');
          return test !== test.toLowerCase() || test.split('"').length > 3;
        });
      };
    }
  });

  // node_modules/core-js/modules/es.string.anchor.js
  var require_es_string_anchor = __commonJS({
    "node_modules/core-js/modules/es.string.anchor.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var createHTML = require_create_html();
      var forcedStringHTMLMethod = require_string_html_forced();
      $({ target: "String", proto: true, forced: forcedStringHTMLMethod("anchor") }, {
        anchor: function anchor(name2) {
          return createHTML(this, "a", "name", name2);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.big.js
  var require_es_string_big = __commonJS({
    "node_modules/core-js/modules/es.string.big.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var createHTML = require_create_html();
      var forcedStringHTMLMethod = require_string_html_forced();
      $({ target: "String", proto: true, forced: forcedStringHTMLMethod("big") }, {
        big: function big() {
          return createHTML(this, "big", "", "");
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.blink.js
  var require_es_string_blink = __commonJS({
    "node_modules/core-js/modules/es.string.blink.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var createHTML = require_create_html();
      var forcedStringHTMLMethod = require_string_html_forced();
      $({ target: "String", proto: true, forced: forcedStringHTMLMethod("blink") }, {
        blink: function blink() {
          return createHTML(this, "blink", "", "");
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.bold.js
  var require_es_string_bold = __commonJS({
    "node_modules/core-js/modules/es.string.bold.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var createHTML = require_create_html();
      var forcedStringHTMLMethod = require_string_html_forced();
      $({ target: "String", proto: true, forced: forcedStringHTMLMethod("bold") }, {
        bold: function bold() {
          return createHTML(this, "b", "", "");
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.fixed.js
  var require_es_string_fixed = __commonJS({
    "node_modules/core-js/modules/es.string.fixed.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var createHTML = require_create_html();
      var forcedStringHTMLMethod = require_string_html_forced();
      $({ target: "String", proto: true, forced: forcedStringHTMLMethod("fixed") }, {
        fixed: function fixed() {
          return createHTML(this, "tt", "", "");
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.fontcolor.js
  var require_es_string_fontcolor = __commonJS({
    "node_modules/core-js/modules/es.string.fontcolor.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var createHTML = require_create_html();
      var forcedStringHTMLMethod = require_string_html_forced();
      $({ target: "String", proto: true, forced: forcedStringHTMLMethod("fontcolor") }, {
        fontcolor: function fontcolor(color) {
          return createHTML(this, "font", "color", color);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.fontsize.js
  var require_es_string_fontsize = __commonJS({
    "node_modules/core-js/modules/es.string.fontsize.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var createHTML = require_create_html();
      var forcedStringHTMLMethod = require_string_html_forced();
      $({ target: "String", proto: true, forced: forcedStringHTMLMethod("fontsize") }, {
        fontsize: function fontsize(size) {
          return createHTML(this, "font", "size", size);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.italics.js
  var require_es_string_italics = __commonJS({
    "node_modules/core-js/modules/es.string.italics.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var createHTML = require_create_html();
      var forcedStringHTMLMethod = require_string_html_forced();
      $({ target: "String", proto: true, forced: forcedStringHTMLMethod("italics") }, {
        italics: function italics() {
          return createHTML(this, "i", "", "");
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.link.js
  var require_es_string_link = __commonJS({
    "node_modules/core-js/modules/es.string.link.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var createHTML = require_create_html();
      var forcedStringHTMLMethod = require_string_html_forced();
      $({ target: "String", proto: true, forced: forcedStringHTMLMethod("link") }, {
        link: function link(url) {
          return createHTML(this, "a", "href", url);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.small.js
  var require_es_string_small = __commonJS({
    "node_modules/core-js/modules/es.string.small.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var createHTML = require_create_html();
      var forcedStringHTMLMethod = require_string_html_forced();
      $({ target: "String", proto: true, forced: forcedStringHTMLMethod("small") }, {
        small: function small() {
          return createHTML(this, "small", "", "");
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.strike.js
  var require_es_string_strike = __commonJS({
    "node_modules/core-js/modules/es.string.strike.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var createHTML = require_create_html();
      var forcedStringHTMLMethod = require_string_html_forced();
      $({ target: "String", proto: true, forced: forcedStringHTMLMethod("strike") }, {
        strike: function strike() {
          return createHTML(this, "strike", "", "");
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.sub.js
  var require_es_string_sub = __commonJS({
    "node_modules/core-js/modules/es.string.sub.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var createHTML = require_create_html();
      var forcedStringHTMLMethod = require_string_html_forced();
      $({ target: "String", proto: true, forced: forcedStringHTMLMethod("sub") }, {
        sub: function sub() {
          return createHTML(this, "sub", "", "");
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.sup.js
  var require_es_string_sup = __commonJS({
    "node_modules/core-js/modules/es.string.sup.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var createHTML = require_create_html();
      var forcedStringHTMLMethod = require_string_html_forced();
      $({ target: "String", proto: true, forced: forcedStringHTMLMethod("sup") }, {
        sup: function sup() {
          return createHTML(this, "sup", "", "");
        }
      });
    }
  });

  // node_modules/core-js/internals/typed-array-constructors-require-wrappers.js
  var require_typed_array_constructors_require_wrappers = __commonJS({
    "node_modules/core-js/internals/typed-array-constructors-require-wrappers.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var global2 = require_global();
      var fails = require_fails();
      var checkCorrectnessOfIteration = require_check_correctness_of_iteration();
      var NATIVE_ARRAY_BUFFER_VIEWS = require_array_buffer_view_core().NATIVE_ARRAY_BUFFER_VIEWS;
      var ArrayBuffer2 = global2.ArrayBuffer;
      var Int8Array2 = global2.Int8Array;
      module.exports = !NATIVE_ARRAY_BUFFER_VIEWS || !fails(function() {
        Int8Array2(1);
      }) || !fails(function() {
        new Int8Array2(-1);
      }) || !checkCorrectnessOfIteration(function(iterable) {
        new Int8Array2();
        new Int8Array2(null);
        new Int8Array2(1.5);
        new Int8Array2(iterable);
      }, true) || fails(function() {
        return new Int8Array2(new ArrayBuffer2(2), 1, void 0).length !== 1;
      });
    }
  });

  // node_modules/core-js/internals/to-positive-integer.js
  var require_to_positive_integer = __commonJS({
    "node_modules/core-js/internals/to-positive-integer.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var $RangeError = RangeError;
      module.exports = function(it) {
        var result = toIntegerOrInfinity(it);
        if (result < 0) throw new $RangeError("The argument can't be less than 0");
        return result;
      };
    }
  });

  // node_modules/core-js/internals/to-offset.js
  var require_to_offset = __commonJS({
    "node_modules/core-js/internals/to-offset.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var toPositiveInteger = require_to_positive_integer();
      var $RangeError = RangeError;
      module.exports = function(it, BYTES) {
        var offset = toPositiveInteger(it);
        if (offset % BYTES) throw new $RangeError("Wrong offset");
        return offset;
      };
    }
  });

  // node_modules/core-js/internals/to-uint8-clamped.js
  var require_to_uint8_clamped = __commonJS({
    "node_modules/core-js/internals/to-uint8-clamped.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var round = Math.round;
      module.exports = function(it) {
        var value = round(it);
        return value < 0 ? 0 : value > 255 ? 255 : value & 255;
      };
    }
  });

  // node_modules/core-js/internals/is-big-int-array.js
  var require_is_big_int_array = __commonJS({
    "node_modules/core-js/internals/is-big-int-array.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var classof = require_classof();
      module.exports = function(it) {
        var klass = classof(it);
        return klass === "BigInt64Array" || klass === "BigUint64Array";
      };
    }
  });

  // node_modules/core-js/internals/to-big-int.js
  var require_to_big_int = __commonJS({
    "node_modules/core-js/internals/to-big-int.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var toPrimitive = require_to_primitive();
      var $TypeError = TypeError;
      module.exports = function(argument) {
        var prim = toPrimitive(argument, "number");
        if (typeof prim == "number") throw new $TypeError("Can't convert number to bigint");
        return BigInt(prim);
      };
    }
  });

  // node_modules/core-js/internals/typed-array-from.js
  var require_typed_array_from = __commonJS({
    "node_modules/core-js/internals/typed-array-from.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var bind = require_function_bind_context();
      var call = require_function_call();
      var aConstructor = require_a_constructor();
      var toObject = require_to_object();
      var lengthOfArrayLike = require_length_of_array_like();
      var getIterator = require_get_iterator();
      var getIteratorMethod = require_get_iterator_method();
      var isArrayIteratorMethod = require_is_array_iterator_method();
      var isBigIntArray = require_is_big_int_array();
      var aTypedArrayConstructor = require_array_buffer_view_core().aTypedArrayConstructor;
      var toBigInt = require_to_big_int();
      module.exports = function from(source) {
        var C = aConstructor(this);
        var O = toObject(source);
        var argumentsLength = arguments.length;
        var mapfn = argumentsLength > 1 ? arguments[1] : void 0;
        var mapping = mapfn !== void 0;
        var iteratorMethod = getIteratorMethod(O);
        var i, length, result, thisIsBigIntArray, value, step, iterator, next;
        if (iteratorMethod && !isArrayIteratorMethod(iteratorMethod)) {
          iterator = getIterator(O, iteratorMethod);
          next = iterator.next;
          O = [];
          while (!(step = call(next, iterator)).done) {
            O.push(step.value);
          }
        }
        if (mapping && argumentsLength > 2) {
          mapfn = bind(mapfn, arguments[2]);
        }
        length = lengthOfArrayLike(O);
        result = new (aTypedArrayConstructor(C))(length);
        thisIsBigIntArray = isBigIntArray(result);
        for (i = 0; length > i; i++) {
          value = mapping ? mapfn(O[i], i) : O[i];
          result[i] = thisIsBigIntArray ? toBigInt(value) : +value;
        }
        return result;
      };
    }
  });

  // node_modules/core-js/internals/typed-array-constructor.js
  var require_typed_array_constructor = __commonJS({
    "node_modules/core-js/internals/typed-array-constructor.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var global2 = require_global();
      var call = require_function_call();
      var DESCRIPTORS = require_descriptors();
      var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS = require_typed_array_constructors_require_wrappers();
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var ArrayBufferModule = require_array_buffer();
      var anInstance = require_an_instance();
      var createPropertyDescriptor = require_create_property_descriptor();
      var createNonEnumerableProperty = require_create_non_enumerable_property();
      var isIntegralNumber = require_is_integral_number();
      var toLength = require_to_length();
      var toIndex = require_to_index();
      var toOffset = require_to_offset();
      var toUint8Clamped = require_to_uint8_clamped();
      var toPropertyKey = require_to_property_key();
      var hasOwn = require_has_own_property();
      var classof = require_classof();
      var isObject2 = require_is_object();
      var isSymbol = require_is_symbol();
      var create = require_object_create();
      var isPrototypeOf = require_object_is_prototype_of();
      var setPrototypeOf = require_object_set_prototype_of();
      var getOwnPropertyNames = require_object_get_own_property_names().f;
      var typedArrayFrom = require_typed_array_from();
      var forEach2 = require_array_iteration().forEach;
      var setSpecies = require_set_species();
      var defineBuiltInAccessor = require_define_built_in_accessor();
      var definePropertyModule = require_object_define_property();
      var getOwnPropertyDescriptorModule = require_object_get_own_property_descriptor();
      var arrayFromConstructorAndList = require_array_from_constructor_and_list();
      var InternalStateModule = require_internal_state();
      var inheritIfRequired = require_inherit_if_required();
      var getInternalState = InternalStateModule.get;
      var setInternalState = InternalStateModule.set;
      var enforceInternalState = InternalStateModule.enforce;
      var nativeDefineProperty = definePropertyModule.f;
      var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
      var RangeError2 = global2.RangeError;
      var ArrayBuffer2 = ArrayBufferModule.ArrayBuffer;
      var ArrayBufferPrototype = ArrayBuffer2.prototype;
      var DataView2 = ArrayBufferModule.DataView;
      var NATIVE_ARRAY_BUFFER_VIEWS = ArrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;
      var TYPED_ARRAY_TAG = ArrayBufferViewCore.TYPED_ARRAY_TAG;
      var TypedArray = ArrayBufferViewCore.TypedArray;
      var TypedArrayPrototype = ArrayBufferViewCore.TypedArrayPrototype;
      var isTypedArray = ArrayBufferViewCore.isTypedArray;
      var BYTES_PER_ELEMENT = "BYTES_PER_ELEMENT";
      var WRONG_LENGTH = "Wrong length";
      var addGetter = function(it, key) {
        defineBuiltInAccessor(it, key, {
          configurable: true,
          get: function() {
            return getInternalState(this)[key];
          }
        });
      };
      var isArrayBuffer = function(it) {
        var klass;
        return isPrototypeOf(ArrayBufferPrototype, it) || (klass = classof(it)) === "ArrayBuffer" || klass === "SharedArrayBuffer";
      };
      var isTypedArrayIndex = function(target, key) {
        return isTypedArray(target) && !isSymbol(key) && key in target && isIntegralNumber(+key) && key >= 0;
      };
      var wrappedGetOwnPropertyDescriptor = function getOwnPropertyDescriptor(target, key) {
        key = toPropertyKey(key);
        return isTypedArrayIndex(target, key) ? createPropertyDescriptor(2, target[key]) : nativeGetOwnPropertyDescriptor(target, key);
      };
      var wrappedDefineProperty = function defineProperty(target, key, descriptor) {
        key = toPropertyKey(key);
        if (isTypedArrayIndex(target, key) && isObject2(descriptor) && hasOwn(descriptor, "value") && !hasOwn(descriptor, "get") && !hasOwn(descriptor, "set") && !descriptor.configurable && (!hasOwn(descriptor, "writable") || descriptor.writable) && (!hasOwn(descriptor, "enumerable") || descriptor.enumerable)) {
          target[key] = descriptor.value;
          return target;
        }
        return nativeDefineProperty(target, key, descriptor);
      };
      if (DESCRIPTORS) {
        if (!NATIVE_ARRAY_BUFFER_VIEWS) {
          getOwnPropertyDescriptorModule.f = wrappedGetOwnPropertyDescriptor;
          definePropertyModule.f = wrappedDefineProperty;
          addGetter(TypedArrayPrototype, "buffer");
          addGetter(TypedArrayPrototype, "byteOffset");
          addGetter(TypedArrayPrototype, "byteLength");
          addGetter(TypedArrayPrototype, "length");
        }
        $({ target: "Object", stat: true, forced: !NATIVE_ARRAY_BUFFER_VIEWS }, {
          getOwnPropertyDescriptor: wrappedGetOwnPropertyDescriptor,
          defineProperty: wrappedDefineProperty
        });
        module.exports = function(TYPE, wrapper, CLAMPED) {
          var BYTES = TYPE.match(/\d+/)[0] / 8;
          var CONSTRUCTOR_NAME = TYPE + (CLAMPED ? "Clamped" : "") + "Array";
          var GETTER = "get" + TYPE;
          var SETTER = "set" + TYPE;
          var NativeTypedArrayConstructor = global2[CONSTRUCTOR_NAME];
          var TypedArrayConstructor = NativeTypedArrayConstructor;
          var TypedArrayConstructorPrototype = TypedArrayConstructor && TypedArrayConstructor.prototype;
          var exported = {};
          var getter = function(that, index) {
            var data2 = getInternalState(that);
            return data2.view[GETTER](index * BYTES + data2.byteOffset, true);
          };
          var setter = function(that, index, value) {
            var data2 = getInternalState(that);
            data2.view[SETTER](index * BYTES + data2.byteOffset, CLAMPED ? toUint8Clamped(value) : value, true);
          };
          var addElement = function(that, index) {
            nativeDefineProperty(that, index, {
              get: function() {
                return getter(this, index);
              },
              set: function(value) {
                return setter(this, index, value);
              },
              enumerable: true
            });
          };
          if (!NATIVE_ARRAY_BUFFER_VIEWS) {
            TypedArrayConstructor = wrapper(function(that, data2, offset, $length) {
              anInstance(that, TypedArrayConstructorPrototype);
              var index = 0;
              var byteOffset = 0;
              var buffer, byteLength, length;
              if (!isObject2(data2)) {
                length = toIndex(data2);
                byteLength = length * BYTES;
                buffer = new ArrayBuffer2(byteLength);
              } else if (isArrayBuffer(data2)) {
                buffer = data2;
                byteOffset = toOffset(offset, BYTES);
                var $len = data2.byteLength;
                if ($length === void 0) {
                  if ($len % BYTES) throw new RangeError2(WRONG_LENGTH);
                  byteLength = $len - byteOffset;
                  if (byteLength < 0) throw new RangeError2(WRONG_LENGTH);
                } else {
                  byteLength = toLength($length) * BYTES;
                  if (byteLength + byteOffset > $len) throw new RangeError2(WRONG_LENGTH);
                }
                length = byteLength / BYTES;
              } else if (isTypedArray(data2)) {
                return arrayFromConstructorAndList(TypedArrayConstructor, data2);
              } else {
                return call(typedArrayFrom, TypedArrayConstructor, data2);
              }
              setInternalState(that, {
                buffer,
                byteOffset,
                byteLength,
                length,
                view: new DataView2(buffer)
              });
              while (index < length) addElement(that, index++);
            });
            if (setPrototypeOf) setPrototypeOf(TypedArrayConstructor, TypedArray);
            TypedArrayConstructorPrototype = TypedArrayConstructor.prototype = create(TypedArrayPrototype);
          } else if (TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS) {
            TypedArrayConstructor = wrapper(function(dummy, data2, typedArrayOffset, $length) {
              anInstance(dummy, TypedArrayConstructorPrototype);
              return inheritIfRequired(function() {
                if (!isObject2(data2)) return new NativeTypedArrayConstructor(toIndex(data2));
                if (isArrayBuffer(data2)) return $length !== void 0 ? new NativeTypedArrayConstructor(data2, toOffset(typedArrayOffset, BYTES), $length) : typedArrayOffset !== void 0 ? new NativeTypedArrayConstructor(data2, toOffset(typedArrayOffset, BYTES)) : new NativeTypedArrayConstructor(data2);
                if (isTypedArray(data2)) return arrayFromConstructorAndList(TypedArrayConstructor, data2);
                return call(typedArrayFrom, TypedArrayConstructor, data2);
              }(), dummy, TypedArrayConstructor);
            });
            if (setPrototypeOf) setPrototypeOf(TypedArrayConstructor, TypedArray);
            forEach2(getOwnPropertyNames(NativeTypedArrayConstructor), function(key) {
              if (!(key in TypedArrayConstructor)) {
                createNonEnumerableProperty(TypedArrayConstructor, key, NativeTypedArrayConstructor[key]);
              }
            });
            TypedArrayConstructor.prototype = TypedArrayConstructorPrototype;
          }
          if (TypedArrayConstructorPrototype.constructor !== TypedArrayConstructor) {
            createNonEnumerableProperty(TypedArrayConstructorPrototype, "constructor", TypedArrayConstructor);
          }
          enforceInternalState(TypedArrayConstructorPrototype).TypedArrayConstructor = TypedArrayConstructor;
          if (TYPED_ARRAY_TAG) {
            createNonEnumerableProperty(TypedArrayConstructorPrototype, TYPED_ARRAY_TAG, CONSTRUCTOR_NAME);
          }
          var FORCED = TypedArrayConstructor !== NativeTypedArrayConstructor;
          exported[CONSTRUCTOR_NAME] = TypedArrayConstructor;
          $({ global: true, constructor: true, forced: FORCED, sham: !NATIVE_ARRAY_BUFFER_VIEWS }, exported);
          if (!(BYTES_PER_ELEMENT in TypedArrayConstructor)) {
            createNonEnumerableProperty(TypedArrayConstructor, BYTES_PER_ELEMENT, BYTES);
          }
          if (!(BYTES_PER_ELEMENT in TypedArrayConstructorPrototype)) {
            createNonEnumerableProperty(TypedArrayConstructorPrototype, BYTES_PER_ELEMENT, BYTES);
          }
          setSpecies(CONSTRUCTOR_NAME);
        };
      } else module.exports = function() {
      };
    }
  });

  // node_modules/core-js/modules/es.typed-array.float32-array.js
  var require_es_typed_array_float32_array = __commonJS({
    "node_modules/core-js/modules/es.typed-array.float32-array.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var createTypedArrayConstructor = require_typed_array_constructor();
      createTypedArrayConstructor("Float32", function(init) {
        return function Float32Array(data2, byteOffset, length) {
          return init(this, data2, byteOffset, length);
        };
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.float64-array.js
  var require_es_typed_array_float64_array = __commonJS({
    "node_modules/core-js/modules/es.typed-array.float64-array.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var createTypedArrayConstructor = require_typed_array_constructor();
      createTypedArrayConstructor("Float64", function(init) {
        return function Float64Array(data2, byteOffset, length) {
          return init(this, data2, byteOffset, length);
        };
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.int8-array.js
  var require_es_typed_array_int8_array = __commonJS({
    "node_modules/core-js/modules/es.typed-array.int8-array.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var createTypedArrayConstructor = require_typed_array_constructor();
      createTypedArrayConstructor("Int8", function(init) {
        return function Int8Array2(data2, byteOffset, length) {
          return init(this, data2, byteOffset, length);
        };
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.int16-array.js
  var require_es_typed_array_int16_array = __commonJS({
    "node_modules/core-js/modules/es.typed-array.int16-array.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var createTypedArrayConstructor = require_typed_array_constructor();
      createTypedArrayConstructor("Int16", function(init) {
        return function Int16Array(data2, byteOffset, length) {
          return init(this, data2, byteOffset, length);
        };
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.int32-array.js
  var require_es_typed_array_int32_array = __commonJS({
    "node_modules/core-js/modules/es.typed-array.int32-array.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var createTypedArrayConstructor = require_typed_array_constructor();
      createTypedArrayConstructor("Int32", function(init) {
        return function Int32Array(data2, byteOffset, length) {
          return init(this, data2, byteOffset, length);
        };
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.uint8-array.js
  var require_es_typed_array_uint8_array = __commonJS({
    "node_modules/core-js/modules/es.typed-array.uint8-array.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var createTypedArrayConstructor = require_typed_array_constructor();
      createTypedArrayConstructor("Uint8", function(init) {
        return function Uint8Array2(data2, byteOffset, length) {
          return init(this, data2, byteOffset, length);
        };
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.uint8-clamped-array.js
  var require_es_typed_array_uint8_clamped_array = __commonJS({
    "node_modules/core-js/modules/es.typed-array.uint8-clamped-array.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var createTypedArrayConstructor = require_typed_array_constructor();
      createTypedArrayConstructor("Uint8", function(init) {
        return function Uint8ClampedArray2(data2, byteOffset, length) {
          return init(this, data2, byteOffset, length);
        };
      }, true);
    }
  });

  // node_modules/core-js/modules/es.typed-array.uint16-array.js
  var require_es_typed_array_uint16_array = __commonJS({
    "node_modules/core-js/modules/es.typed-array.uint16-array.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var createTypedArrayConstructor = require_typed_array_constructor();
      createTypedArrayConstructor("Uint16", function(init) {
        return function Uint16Array(data2, byteOffset, length) {
          return init(this, data2, byteOffset, length);
        };
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.uint32-array.js
  var require_es_typed_array_uint32_array = __commonJS({
    "node_modules/core-js/modules/es.typed-array.uint32-array.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var createTypedArrayConstructor = require_typed_array_constructor();
      createTypedArrayConstructor("Uint32", function(init) {
        return function Uint32Array(data2, byteOffset, length) {
          return init(this, data2, byteOffset, length);
        };
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.at.js
  var require_es_typed_array_at = __commonJS({
    "node_modules/core-js/modules/es.typed-array.at.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var lengthOfArrayLike = require_length_of_array_like();
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      exportTypedArrayMethod("at", function at(index) {
        var O = aTypedArray(this);
        var len = lengthOfArrayLike(O);
        var relativeIndex = toIntegerOrInfinity(index);
        var k = relativeIndex >= 0 ? relativeIndex : len + relativeIndex;
        return k < 0 || k >= len ? void 0 : O[k];
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.copy-within.js
  var require_es_typed_array_copy_within = __commonJS({
    "node_modules/core-js/modules/es.typed-array.copy-within.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var uncurryThis = require_function_uncurry_this();
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var $ArrayCopyWithin = require_array_copy_within();
      var u$ArrayCopyWithin = uncurryThis($ArrayCopyWithin);
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      exportTypedArrayMethod("copyWithin", function copyWithin(target, start) {
        return u$ArrayCopyWithin(aTypedArray(this), target, start, arguments.length > 2 ? arguments[2] : void 0);
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.every.js
  var require_es_typed_array_every = __commonJS({
    "node_modules/core-js/modules/es.typed-array.every.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var $every = require_array_iteration().every;
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      exportTypedArrayMethod("every", function every(callbackfn) {
        return $every(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : void 0);
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.fill.js
  var require_es_typed_array_fill = __commonJS({
    "node_modules/core-js/modules/es.typed-array.fill.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var $fill = require_array_fill();
      var toBigInt = require_to_big_int();
      var classof = require_classof();
      var call = require_function_call();
      var uncurryThis = require_function_uncurry_this();
      var fails = require_fails();
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      var slice = uncurryThis("".slice);
      var CONVERSION_BUG = fails(function() {
        var count = 0;
        new Int8Array(2).fill({ valueOf: function() {
          return count++;
        } });
        return count !== 1;
      });
      exportTypedArrayMethod("fill", function fill(value) {
        var length = arguments.length;
        aTypedArray(this);
        var actualValue = slice(classof(this), 0, 3) === "Big" ? toBigInt(value) : +value;
        return call($fill, this, actualValue, length > 1 ? arguments[1] : void 0, length > 2 ? arguments[2] : void 0);
      }, CONVERSION_BUG);
    }
  });

  // node_modules/core-js/internals/typed-array-species-constructor.js
  var require_typed_array_species_constructor = __commonJS({
    "node_modules/core-js/internals/typed-array-species-constructor.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var speciesConstructor = require_species_constructor();
      var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;
      var getTypedArrayConstructor = ArrayBufferViewCore.getTypedArrayConstructor;
      module.exports = function(originalArray) {
        return aTypedArrayConstructor(speciesConstructor(originalArray, getTypedArrayConstructor(originalArray)));
      };
    }
  });

  // node_modules/core-js/internals/typed-array-from-species-and-list.js
  var require_typed_array_from_species_and_list = __commonJS({
    "node_modules/core-js/internals/typed-array-from-species-and-list.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var arrayFromConstructorAndList = require_array_from_constructor_and_list();
      var typedArraySpeciesConstructor = require_typed_array_species_constructor();
      module.exports = function(instance, list) {
        return arrayFromConstructorAndList(typedArraySpeciesConstructor(instance), list);
      };
    }
  });

  // node_modules/core-js/modules/es.typed-array.filter.js
  var require_es_typed_array_filter = __commonJS({
    "node_modules/core-js/modules/es.typed-array.filter.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var $filter = require_array_iteration().filter;
      var fromSpeciesAndList = require_typed_array_from_species_and_list();
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      exportTypedArrayMethod("filter", function filter(callbackfn) {
        var list = $filter(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : void 0);
        return fromSpeciesAndList(this, list);
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.find.js
  var require_es_typed_array_find = __commonJS({
    "node_modules/core-js/modules/es.typed-array.find.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var $find = require_array_iteration().find;
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      exportTypedArrayMethod("find", function find(predicate) {
        return $find(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : void 0);
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.find-index.js
  var require_es_typed_array_find_index = __commonJS({
    "node_modules/core-js/modules/es.typed-array.find-index.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var $findIndex = require_array_iteration().findIndex;
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      exportTypedArrayMethod("findIndex", function findIndex(predicate) {
        return $findIndex(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : void 0);
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.find-last.js
  var require_es_typed_array_find_last = __commonJS({
    "node_modules/core-js/modules/es.typed-array.find-last.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var $findLast = require_array_iteration_from_last().findLast;
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      exportTypedArrayMethod("findLast", function findLast(predicate) {
        return $findLast(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : void 0);
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.find-last-index.js
  var require_es_typed_array_find_last_index = __commonJS({
    "node_modules/core-js/modules/es.typed-array.find-last-index.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var $findLastIndex = require_array_iteration_from_last().findLastIndex;
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      exportTypedArrayMethod("findLastIndex", function findLastIndex(predicate) {
        return $findLastIndex(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : void 0);
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.for-each.js
  var require_es_typed_array_for_each = __commonJS({
    "node_modules/core-js/modules/es.typed-array.for-each.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var $forEach = require_array_iteration().forEach;
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      exportTypedArrayMethod("forEach", function forEach2(callbackfn) {
        $forEach(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : void 0);
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.from.js
  var require_es_typed_array_from = __commonJS({
    "node_modules/core-js/modules/es.typed-array.from.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS = require_typed_array_constructors_require_wrappers();
      var exportTypedArrayStaticMethod = require_array_buffer_view_core().exportTypedArrayStaticMethod;
      var typedArrayFrom = require_typed_array_from();
      exportTypedArrayStaticMethod("from", typedArrayFrom, TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS);
    }
  });

  // node_modules/core-js/modules/es.typed-array.includes.js
  var require_es_typed_array_includes = __commonJS({
    "node_modules/core-js/modules/es.typed-array.includes.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var $includes = require_array_includes().includes;
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      exportTypedArrayMethod("includes", function includes(searchElement) {
        return $includes(aTypedArray(this), searchElement, arguments.length > 1 ? arguments[1] : void 0);
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.index-of.js
  var require_es_typed_array_index_of = __commonJS({
    "node_modules/core-js/modules/es.typed-array.index-of.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var $indexOf = require_array_includes().indexOf;
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      exportTypedArrayMethod("indexOf", function indexOf(searchElement) {
        return $indexOf(aTypedArray(this), searchElement, arguments.length > 1 ? arguments[1] : void 0);
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.iterator.js
  var require_es_typed_array_iterator = __commonJS({
    "node_modules/core-js/modules/es.typed-array.iterator.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var global2 = require_global();
      var fails = require_fails();
      var uncurryThis = require_function_uncurry_this();
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var ArrayIterators = require_es_array_iterator();
      var wellKnownSymbol = require_well_known_symbol();
      var ITERATOR = wellKnownSymbol("iterator");
      var Uint8Array2 = global2.Uint8Array;
      var arrayValues = uncurryThis(ArrayIterators.values);
      var arrayKeys = uncurryThis(ArrayIterators.keys);
      var arrayEntries = uncurryThis(ArrayIterators.entries);
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      var TypedArrayPrototype = Uint8Array2 && Uint8Array2.prototype;
      var GENERIC = !fails(function() {
        TypedArrayPrototype[ITERATOR].call([1]);
      });
      var ITERATOR_IS_VALUES = !!TypedArrayPrototype && TypedArrayPrototype.values && TypedArrayPrototype[ITERATOR] === TypedArrayPrototype.values && TypedArrayPrototype.values.name === "values";
      var typedArrayValues = function values() {
        return arrayValues(aTypedArray(this));
      };
      exportTypedArrayMethod("entries", function entries() {
        return arrayEntries(aTypedArray(this));
      }, GENERIC);
      exportTypedArrayMethod("keys", function keys() {
        return arrayKeys(aTypedArray(this));
      }, GENERIC);
      exportTypedArrayMethod("values", typedArrayValues, GENERIC || !ITERATOR_IS_VALUES, { name: "values" });
      exportTypedArrayMethod(ITERATOR, typedArrayValues, GENERIC || !ITERATOR_IS_VALUES, { name: "values" });
    }
  });

  // node_modules/core-js/modules/es.typed-array.join.js
  var require_es_typed_array_join = __commonJS({
    "node_modules/core-js/modules/es.typed-array.join.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var uncurryThis = require_function_uncurry_this();
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      var $join = uncurryThis([].join);
      exportTypedArrayMethod("join", function join(separator) {
        return $join(aTypedArray(this), separator);
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.last-index-of.js
  var require_es_typed_array_last_index_of = __commonJS({
    "node_modules/core-js/modules/es.typed-array.last-index-of.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var apply = require_function_apply();
      var $lastIndexOf = require_array_last_index_of();
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      exportTypedArrayMethod("lastIndexOf", function lastIndexOf(searchElement) {
        var length = arguments.length;
        return apply($lastIndexOf, aTypedArray(this), length > 1 ? [searchElement, arguments[1]] : [searchElement]);
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.map.js
  var require_es_typed_array_map = __commonJS({
    "node_modules/core-js/modules/es.typed-array.map.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var $map = require_array_iteration().map;
      var typedArraySpeciesConstructor = require_typed_array_species_constructor();
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      exportTypedArrayMethod("map", function map(mapfn) {
        return $map(aTypedArray(this), mapfn, arguments.length > 1 ? arguments[1] : void 0, function(O, length) {
          return new (typedArraySpeciesConstructor(O))(length);
        });
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.of.js
  var require_es_typed_array_of = __commonJS({
    "node_modules/core-js/modules/es.typed-array.of.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS = require_typed_array_constructors_require_wrappers();
      var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;
      var exportTypedArrayStaticMethod = ArrayBufferViewCore.exportTypedArrayStaticMethod;
      exportTypedArrayStaticMethod("of", function of() {
        var index = 0;
        var length = arguments.length;
        var result = new (aTypedArrayConstructor(this))(length);
        while (length > index) result[index] = arguments[index++];
        return result;
      }, TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS);
    }
  });

  // node_modules/core-js/modules/es.typed-array.reduce.js
  var require_es_typed_array_reduce = __commonJS({
    "node_modules/core-js/modules/es.typed-array.reduce.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var $reduce = require_array_reduce().left;
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      exportTypedArrayMethod("reduce", function reduce(callbackfn) {
        var length = arguments.length;
        return $reduce(aTypedArray(this), callbackfn, length, length > 1 ? arguments[1] : void 0);
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.reduce-right.js
  var require_es_typed_array_reduce_right = __commonJS({
    "node_modules/core-js/modules/es.typed-array.reduce-right.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var $reduceRight = require_array_reduce().right;
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      exportTypedArrayMethod("reduceRight", function reduceRight(callbackfn) {
        var length = arguments.length;
        return $reduceRight(aTypedArray(this), callbackfn, length, length > 1 ? arguments[1] : void 0);
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.reverse.js
  var require_es_typed_array_reverse = __commonJS({
    "node_modules/core-js/modules/es.typed-array.reverse.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      var floor = Math.floor;
      exportTypedArrayMethod("reverse", function reverse() {
        var that = this;
        var length = aTypedArray(that).length;
        var middle = floor(length / 2);
        var index = 0;
        var value;
        while (index < middle) {
          value = that[index];
          that[index++] = that[--length];
          that[length] = value;
        }
        return that;
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.set.js
  var require_es_typed_array_set = __commonJS({
    "node_modules/core-js/modules/es.typed-array.set.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var global2 = require_global();
      var call = require_function_call();
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var lengthOfArrayLike = require_length_of_array_like();
      var toOffset = require_to_offset();
      var toIndexedObject = require_to_object();
      var fails = require_fails();
      var RangeError2 = global2.RangeError;
      var Int8Array2 = global2.Int8Array;
      var Int8ArrayPrototype = Int8Array2 && Int8Array2.prototype;
      var $set = Int8ArrayPrototype && Int8ArrayPrototype.set;
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      var WORKS_WITH_OBJECTS_AND_GENERIC_ON_TYPED_ARRAYS = !fails(function() {
        var array = new Uint8ClampedArray(2);
        call($set, array, { length: 1, 0: 3 }, 1);
        return array[1] !== 3;
      });
      var TO_OBJECT_BUG = WORKS_WITH_OBJECTS_AND_GENERIC_ON_TYPED_ARRAYS && ArrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS && fails(function() {
        var array = new Int8Array2(2);
        array.set(1);
        array.set("2", 1);
        return array[0] !== 0 || array[1] !== 2;
      });
      exportTypedArrayMethod("set", function set2(arrayLike) {
        aTypedArray(this);
        var offset = toOffset(arguments.length > 1 ? arguments[1] : void 0, 1);
        var src = toIndexedObject(arrayLike);
        if (WORKS_WITH_OBJECTS_AND_GENERIC_ON_TYPED_ARRAYS) return call($set, this, src, offset);
        var length = this.length;
        var len = lengthOfArrayLike(src);
        var index = 0;
        if (len + offset > length) throw new RangeError2("Wrong length");
        while (index < len) this[offset + index] = src[index++];
      }, !WORKS_WITH_OBJECTS_AND_GENERIC_ON_TYPED_ARRAYS || TO_OBJECT_BUG);
    }
  });

  // node_modules/core-js/modules/es.typed-array.slice.js
  var require_es_typed_array_slice = __commonJS({
    "node_modules/core-js/modules/es.typed-array.slice.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var typedArraySpeciesConstructor = require_typed_array_species_constructor();
      var fails = require_fails();
      var arraySlice2 = require_array_slice();
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      var FORCED = fails(function() {
        new Int8Array(1).slice();
      });
      exportTypedArrayMethod("slice", function slice(start, end) {
        var list = arraySlice2(aTypedArray(this), start, end);
        var C = typedArraySpeciesConstructor(this);
        var index = 0;
        var length = list.length;
        var result = new C(length);
        while (length > index) result[index] = list[index++];
        return result;
      }, FORCED);
    }
  });

  // node_modules/core-js/modules/es.typed-array.some.js
  var require_es_typed_array_some = __commonJS({
    "node_modules/core-js/modules/es.typed-array.some.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var $some = require_array_iteration().some;
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      exportTypedArrayMethod("some", function some(callbackfn) {
        return $some(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : void 0);
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.sort.js
  var require_es_typed_array_sort = __commonJS({
    "node_modules/core-js/modules/es.typed-array.sort.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var global2 = require_global();
      var uncurryThis = require_function_uncurry_this_clause();
      var fails = require_fails();
      var aCallable = require_a_callable();
      var internalSort = require_array_sort();
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var FF = require_engine_ff_version();
      var IE_OR_EDGE = require_engine_is_ie_or_edge();
      var V8 = require_engine_v8_version();
      var WEBKIT = require_engine_webkit_version();
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      var Uint16Array = global2.Uint16Array;
      var nativeSort = Uint16Array && uncurryThis(Uint16Array.prototype.sort);
      var ACCEPT_INCORRECT_ARGUMENTS = !!nativeSort && !(fails(function() {
        nativeSort(new Uint16Array(2), null);
      }) && fails(function() {
        nativeSort(new Uint16Array(2), {});
      }));
      var STABLE_SORT = !!nativeSort && !fails(function() {
        if (V8) return V8 < 74;
        if (FF) return FF < 67;
        if (IE_OR_EDGE) return true;
        if (WEBKIT) return WEBKIT < 602;
        var array = new Uint16Array(516);
        var expected = Array(516);
        var index, mod;
        for (index = 0; index < 516; index++) {
          mod = index % 4;
          array[index] = 515 - index;
          expected[index] = index - 2 * mod + 3;
        }
        nativeSort(array, function(a, b) {
          return (a / 4 | 0) - (b / 4 | 0);
        });
        for (index = 0; index < 516; index++) {
          if (array[index] !== expected[index]) return true;
        }
      });
      var getSortCompare = function(comparefn) {
        return function(x, y) {
          if (comparefn !== void 0) return +comparefn(x, y) || 0;
          if (y !== y) return -1;
          if (x !== x) return 1;
          if (x === 0 && y === 0) return 1 / x > 0 && 1 / y < 0 ? 1 : -1;
          return x > y;
        };
      };
      exportTypedArrayMethod("sort", function sort(comparefn) {
        if (comparefn !== void 0) aCallable(comparefn);
        if (STABLE_SORT) return nativeSort(this, comparefn);
        return internalSort(aTypedArray(this), getSortCompare(comparefn));
      }, !STABLE_SORT || ACCEPT_INCORRECT_ARGUMENTS);
    }
  });

  // node_modules/core-js/modules/es.typed-array.subarray.js
  var require_es_typed_array_subarray = __commonJS({
    "node_modules/core-js/modules/es.typed-array.subarray.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var toLength = require_to_length();
      var toAbsoluteIndex = require_to_absolute_index();
      var typedArraySpeciesConstructor = require_typed_array_species_constructor();
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      exportTypedArrayMethod("subarray", function subarray(begin, end) {
        var O = aTypedArray(this);
        var length = O.length;
        var beginIndex = toAbsoluteIndex(begin, length);
        var C = typedArraySpeciesConstructor(O);
        return new C(
          O.buffer,
          O.byteOffset + beginIndex * O.BYTES_PER_ELEMENT,
          toLength((end === void 0 ? length : toAbsoluteIndex(end, length)) - beginIndex)
        );
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.to-locale-string.js
  var require_es_typed_array_to_locale_string = __commonJS({
    "node_modules/core-js/modules/es.typed-array.to-locale-string.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var global2 = require_global();
      var apply = require_function_apply();
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var fails = require_fails();
      var arraySlice2 = require_array_slice();
      var Int8Array2 = global2.Int8Array;
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      var $toLocaleString = [].toLocaleString;
      var TO_LOCALE_STRING_BUG = !!Int8Array2 && fails(function() {
        $toLocaleString.call(new Int8Array2(1));
      });
      var FORCED = fails(function() {
        return [1, 2].toLocaleString() !== new Int8Array2([1, 2]).toLocaleString();
      }) || !fails(function() {
        Int8Array2.prototype.toLocaleString.call([1, 2]);
      });
      exportTypedArrayMethod("toLocaleString", function toLocaleString() {
        return apply(
          $toLocaleString,
          TO_LOCALE_STRING_BUG ? arraySlice2(aTypedArray(this)) : aTypedArray(this),
          arraySlice2(arguments)
        );
      }, FORCED);
    }
  });

  // node_modules/core-js/modules/es.typed-array.to-reversed.js
  var require_es_typed_array_to_reversed = __commonJS({
    "node_modules/core-js/modules/es.typed-array.to-reversed.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var arrayToReversed = require_array_to_reversed();
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      var getTypedArrayConstructor = ArrayBufferViewCore.getTypedArrayConstructor;
      exportTypedArrayMethod("toReversed", function toReversed() {
        return arrayToReversed(aTypedArray(this), getTypedArrayConstructor(this));
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.to-sorted.js
  var require_es_typed_array_to_sorted = __commonJS({
    "node_modules/core-js/modules/es.typed-array.to-sorted.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var uncurryThis = require_function_uncurry_this();
      var aCallable = require_a_callable();
      var arrayFromConstructorAndList = require_array_from_constructor_and_list();
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var getTypedArrayConstructor = ArrayBufferViewCore.getTypedArrayConstructor;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      var sort = uncurryThis(ArrayBufferViewCore.TypedArrayPrototype.sort);
      exportTypedArrayMethod("toSorted", function toSorted(compareFn) {
        if (compareFn !== void 0) aCallable(compareFn);
        var O = aTypedArray(this);
        var A = arrayFromConstructorAndList(getTypedArrayConstructor(O), O);
        return sort(A, compareFn);
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.to-string.js
  var require_es_typed_array_to_string = __commonJS({
    "node_modules/core-js/modules/es.typed-array.to-string.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var exportTypedArrayMethod = require_array_buffer_view_core().exportTypedArrayMethod;
      var fails = require_fails();
      var global2 = require_global();
      var uncurryThis = require_function_uncurry_this();
      var Uint8Array2 = global2.Uint8Array;
      var Uint8ArrayPrototype = Uint8Array2 && Uint8Array2.prototype || {};
      var arrayToString = [].toString;
      var join = uncurryThis([].join);
      if (fails(function() {
        arrayToString.call({});
      })) {
        arrayToString = function toString() {
          return join(this);
        };
      }
      var IS_NOT_ARRAY_METHOD = Uint8ArrayPrototype.toString !== arrayToString;
      exportTypedArrayMethod("toString", arrayToString, IS_NOT_ARRAY_METHOD);
    }
  });

  // node_modules/core-js/modules/es.typed-array.with.js
  var require_es_typed_array_with = __commonJS({
    "node_modules/core-js/modules/es.typed-array.with.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var arrayWith = require_array_with();
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var isBigIntArray = require_is_big_int_array();
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var toBigInt = require_to_big_int();
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var getTypedArrayConstructor = ArrayBufferViewCore.getTypedArrayConstructor;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      var PROPER_ORDER = !!function() {
        try {
          new Int8Array(1)["with"](2, { valueOf: function() {
            throw 8;
          } });
        } catch (error) {
          return error === 8;
        }
      }();
      exportTypedArrayMethod("with", { "with": function(index, value) {
        var O = aTypedArray(this);
        var relativeIndex = toIntegerOrInfinity(index);
        var actualValue = isBigIntArray(O) ? toBigInt(value) : +value;
        return arrayWith(O, getTypedArrayConstructor(O), relativeIndex, actualValue);
      } }["with"], !PROPER_ORDER);
    }
  });

  // node_modules/core-js/modules/es.unescape.js
  var require_es_unescape = __commonJS({
    "node_modules/core-js/modules/es.unescape.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var uncurryThis = require_function_uncurry_this();
      var toString = require_to_string();
      var fromCharCode = String.fromCharCode;
      var charAt = uncurryThis("".charAt);
      var exec = uncurryThis(/./.exec);
      var stringSlice = uncurryThis("".slice);
      var hex2 = /^[\da-f]{2}$/i;
      var hex4 = /^[\da-f]{4}$/i;
      $({ global: true }, {
        unescape: function unescape2(string) {
          var str = toString(string);
          var result = "";
          var length = str.length;
          var index = 0;
          var chr, part;
          while (index < length) {
            chr = charAt(str, index++);
            if (chr === "%") {
              if (charAt(str, index) === "u") {
                part = stringSlice(str, index + 1, index + 5);
                if (exec(hex4, part)) {
                  result += fromCharCode(parseInt(part, 16));
                  index += 5;
                  continue;
                }
              } else {
                part = stringSlice(str, index, index + 2);
                if (exec(hex2, part)) {
                  result += fromCharCode(parseInt(part, 16));
                  index += 2;
                  continue;
                }
              }
            }
            result += chr;
          }
          return result;
        }
      });
    }
  });

  // node_modules/core-js/internals/collection-weak.js
  var require_collection_weak = __commonJS({
    "node_modules/core-js/internals/collection-weak.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var uncurryThis = require_function_uncurry_this();
      var defineBuiltIns = require_define_built_ins();
      var getWeakData = require_internal_metadata().getWeakData;
      var anInstance = require_an_instance();
      var anObject = require_an_object();
      var isNullOrUndefined2 = require_is_null_or_undefined();
      var isObject2 = require_is_object();
      var iterate = require_iterate();
      var ArrayIterationModule = require_array_iteration();
      var hasOwn = require_has_own_property();
      var InternalStateModule = require_internal_state();
      var setInternalState = InternalStateModule.set;
      var internalStateGetterFor = InternalStateModule.getterFor;
      var find = ArrayIterationModule.find;
      var findIndex = ArrayIterationModule.findIndex;
      var splice = uncurryThis([].splice);
      var id = 0;
      var uncaughtFrozenStore = function(state) {
        return state.frozen || (state.frozen = new UncaughtFrozenStore());
      };
      var UncaughtFrozenStore = function() {
        this.entries = [];
      };
      var findUncaughtFrozen = function(store, key) {
        return find(store.entries, function(it) {
          return it[0] === key;
        });
      };
      UncaughtFrozenStore.prototype = {
        get: function(key) {
          var entry = findUncaughtFrozen(this, key);
          if (entry) return entry[1];
        },
        has: function(key) {
          return !!findUncaughtFrozen(this, key);
        },
        set: function(key, value) {
          var entry = findUncaughtFrozen(this, key);
          if (entry) entry[1] = value;
          else this.entries.push([key, value]);
        },
        "delete": function(key) {
          var index = findIndex(this.entries, function(it) {
            return it[0] === key;
          });
          if (~index) splice(this.entries, index, 1);
          return !!~index;
        }
      };
      module.exports = {
        getConstructor: function(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
          var Constructor = wrapper(function(that, iterable) {
            anInstance(that, Prototype);
            setInternalState(that, {
              type: CONSTRUCTOR_NAME,
              id: id++,
              frozen: void 0
            });
            if (!isNullOrUndefined2(iterable)) iterate(iterable, that[ADDER], { that, AS_ENTRIES: IS_MAP });
          });
          var Prototype = Constructor.prototype;
          var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);
          var define = function(that, key, value) {
            var state = getInternalState(that);
            var data2 = getWeakData(anObject(key), true);
            if (data2 === true) uncaughtFrozenStore(state).set(key, value);
            else data2[state.id] = value;
            return that;
          };
          defineBuiltIns(Prototype, {
            // `{ WeakMap, WeakSet }.prototype.delete(key)` methods
            // https://tc39.es/ecma262/#sec-weakmap.prototype.delete
            // https://tc39.es/ecma262/#sec-weakset.prototype.delete
            "delete": function(key) {
              var state = getInternalState(this);
              if (!isObject2(key)) return false;
              var data2 = getWeakData(key);
              if (data2 === true) return uncaughtFrozenStore(state)["delete"](key);
              return data2 && hasOwn(data2, state.id) && delete data2[state.id];
            },
            // `{ WeakMap, WeakSet }.prototype.has(key)` methods
            // https://tc39.es/ecma262/#sec-weakmap.prototype.has
            // https://tc39.es/ecma262/#sec-weakset.prototype.has
            has: function has(key) {
              var state = getInternalState(this);
              if (!isObject2(key)) return false;
              var data2 = getWeakData(key);
              if (data2 === true) return uncaughtFrozenStore(state).has(key);
              return data2 && hasOwn(data2, state.id);
            }
          });
          defineBuiltIns(Prototype, IS_MAP ? {
            // `WeakMap.prototype.get(key)` method
            // https://tc39.es/ecma262/#sec-weakmap.prototype.get
            get: function get2(key) {
              var state = getInternalState(this);
              if (isObject2(key)) {
                var data2 = getWeakData(key);
                if (data2 === true) return uncaughtFrozenStore(state).get(key);
                return data2 ? data2[state.id] : void 0;
              }
            },
            // `WeakMap.prototype.set(key, value)` method
            // https://tc39.es/ecma262/#sec-weakmap.prototype.set
            set: function set2(key, value) {
              return define(this, key, value);
            }
          } : {
            // `WeakSet.prototype.add(value)` method
            // https://tc39.es/ecma262/#sec-weakset.prototype.add
            add: function add(value) {
              return define(this, value, true);
            }
          });
          return Constructor;
        }
      };
    }
  });

  // node_modules/core-js/modules/es.weak-map.constructor.js
  var require_es_weak_map_constructor = __commonJS({
    "node_modules/core-js/modules/es.weak-map.constructor.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var FREEZING = require_freezing();
      var global2 = require_global();
      var uncurryThis = require_function_uncurry_this();
      var defineBuiltIns = require_define_built_ins();
      var InternalMetadataModule = require_internal_metadata();
      var collection = require_collection();
      var collectionWeak = require_collection_weak();
      var isObject2 = require_is_object();
      var enforceInternalState = require_internal_state().enforce;
      var fails = require_fails();
      var NATIVE_WEAK_MAP = require_weak_map_basic_detection();
      var $Object = Object;
      var isArray = Array.isArray;
      var isExtensible = $Object.isExtensible;
      var isFrozen = $Object.isFrozen;
      var isSealed = $Object.isSealed;
      var freeze = $Object.freeze;
      var seal = $Object.seal;
      var IS_IE11 = !global2.ActiveXObject && "ActiveXObject" in global2;
      var InternalWeakMap;
      var wrapper = function(init) {
        return function WeakMap2() {
          return init(this, arguments.length ? arguments[0] : void 0);
        };
      };
      var $WeakMap = collection("WeakMap", wrapper, collectionWeak);
      var WeakMapPrototype = $WeakMap.prototype;
      var nativeSet = uncurryThis(WeakMapPrototype.set);
      var hasMSEdgeFreezingBug = function() {
        return FREEZING && fails(function() {
          var frozenArray = freeze([]);
          nativeSet(new $WeakMap(), frozenArray, 1);
          return !isFrozen(frozenArray);
        });
      };
      if (NATIVE_WEAK_MAP) {
        if (IS_IE11) {
          InternalWeakMap = collectionWeak.getConstructor(wrapper, "WeakMap", true);
          InternalMetadataModule.enable();
          nativeDelete = uncurryThis(WeakMapPrototype["delete"]);
          nativeHas = uncurryThis(WeakMapPrototype.has);
          nativeGet = uncurryThis(WeakMapPrototype.get);
          defineBuiltIns(WeakMapPrototype, {
            "delete": function(key) {
              if (isObject2(key) && !isExtensible(key)) {
                var state = enforceInternalState(this);
                if (!state.frozen) state.frozen = new InternalWeakMap();
                return nativeDelete(this, key) || state.frozen["delete"](key);
              }
              return nativeDelete(this, key);
            },
            has: function has(key) {
              if (isObject2(key) && !isExtensible(key)) {
                var state = enforceInternalState(this);
                if (!state.frozen) state.frozen = new InternalWeakMap();
                return nativeHas(this, key) || state.frozen.has(key);
              }
              return nativeHas(this, key);
            },
            get: function get2(key) {
              if (isObject2(key) && !isExtensible(key)) {
                var state = enforceInternalState(this);
                if (!state.frozen) state.frozen = new InternalWeakMap();
                return nativeHas(this, key) ? nativeGet(this, key) : state.frozen.get(key);
              }
              return nativeGet(this, key);
            },
            set: function set2(key, value) {
              if (isObject2(key) && !isExtensible(key)) {
                var state = enforceInternalState(this);
                if (!state.frozen) state.frozen = new InternalWeakMap();
                nativeHas(this, key) ? nativeSet(this, key, value) : state.frozen.set(key, value);
              } else nativeSet(this, key, value);
              return this;
            }
          });
        } else if (hasMSEdgeFreezingBug()) {
          defineBuiltIns(WeakMapPrototype, {
            set: function set2(key, value) {
              var arrayIntegrityLevel;
              if (isArray(key)) {
                if (isFrozen(key)) arrayIntegrityLevel = freeze;
                else if (isSealed(key)) arrayIntegrityLevel = seal;
              }
              nativeSet(this, key, value);
              if (arrayIntegrityLevel) arrayIntegrityLevel(key);
              return this;
            }
          });
        }
      }
      var nativeDelete;
      var nativeHas;
      var nativeGet;
    }
  });

  // node_modules/core-js/modules/es.weak-map.js
  var require_es_weak_map = __commonJS({
    "node_modules/core-js/modules/es.weak-map.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      require_es_weak_map_constructor();
    }
  });

  // node_modules/core-js/modules/es.weak-set.constructor.js
  var require_es_weak_set_constructor = __commonJS({
    "node_modules/core-js/modules/es.weak-set.constructor.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var collection = require_collection();
      var collectionWeak = require_collection_weak();
      collection("WeakSet", function(init) {
        return function WeakSet2() {
          return init(this, arguments.length ? arguments[0] : void 0);
        };
      }, collectionWeak);
    }
  });

  // node_modules/core-js/modules/es.weak-set.js
  var require_es_weak_set = __commonJS({
    "node_modules/core-js/modules/es.weak-set.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      require_es_weak_set_constructor();
    }
  });

  // node_modules/core-js/internals/base64-map.js
  var require_base64_map = __commonJS({
    "node_modules/core-js/internals/base64-map.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var commonAlphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
      var base64Alphabet = commonAlphabet + "+/";
      var base64UrlAlphabet = commonAlphabet + "-_";
      var inverse = function(characters) {
        var result = {};
        var index = 0;
        for (; index < 64; index++) result[characters.charAt(index)] = index;
        return result;
      };
      module.exports = {
        i2c: base64Alphabet,
        c2i: inverse(base64Alphabet),
        i2cUrl: base64UrlAlphabet,
        c2iUrl: inverse(base64UrlAlphabet)
      };
    }
  });

  // node_modules/core-js/modules/web.atob.js
  var require_web_atob = __commonJS({
    "node_modules/core-js/modules/web.atob.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var global2 = require_global();
      var getBuiltIn = require_get_built_in();
      var uncurryThis = require_function_uncurry_this();
      var call = require_function_call();
      var fails = require_fails();
      var toString = require_to_string();
      var validateArgumentsLength = require_validate_arguments_length();
      var c2i = require_base64_map().c2i;
      var disallowed = /[^\d+/a-z]/i;
      var whitespaces = /[\t\n\f\r ]+/g;
      var finalEq = /[=]{1,2}$/;
      var $atob = getBuiltIn("atob");
      var fromCharCode = String.fromCharCode;
      var charAt = uncurryThis("".charAt);
      var replace = uncurryThis("".replace);
      var exec = uncurryThis(disallowed.exec);
      var BASIC = !!$atob && !fails(function() {
        return $atob("aGk=") !== "hi";
      });
      var NO_SPACES_IGNORE = BASIC && fails(function() {
        return $atob(" ") !== "";
      });
      var NO_ENCODING_CHECK = BASIC && !fails(function() {
        $atob("a");
      });
      var NO_ARG_RECEIVING_CHECK = BASIC && !fails(function() {
        $atob();
      });
      var WRONG_ARITY = BASIC && $atob.length !== 1;
      var FORCED = !BASIC || NO_SPACES_IGNORE || NO_ENCODING_CHECK || NO_ARG_RECEIVING_CHECK || WRONG_ARITY;
      $({ global: true, bind: true, enumerable: true, forced: FORCED }, {
        atob: function atob2(data2) {
          validateArgumentsLength(arguments.length, 1);
          if (BASIC && !NO_SPACES_IGNORE && !NO_ENCODING_CHECK) return call($atob, global2, data2);
          var string = replace(toString(data2), whitespaces, "");
          var output = "";
          var position = 0;
          var bc = 0;
          var length, chr, bs;
          if (string.length % 4 === 0) {
            string = replace(string, finalEq, "");
          }
          length = string.length;
          if (length % 4 === 1 || exec(disallowed, string)) {
            throw new (getBuiltIn("DOMException"))("The string is not correctly encoded", "InvalidCharacterError");
          }
          while (position < length) {
            chr = charAt(string, position++);
            bs = bc % 4 ? bs * 64 + c2i[chr] : c2i[chr];
            if (bc++ % 4) output += fromCharCode(255 & bs >> (-2 * bc & 6));
          }
          return output;
        }
      });
    }
  });

  // node_modules/core-js/modules/web.btoa.js
  var require_web_btoa = __commonJS({
    "node_modules/core-js/modules/web.btoa.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var global2 = require_global();
      var getBuiltIn = require_get_built_in();
      var uncurryThis = require_function_uncurry_this();
      var call = require_function_call();
      var fails = require_fails();
      var toString = require_to_string();
      var validateArgumentsLength = require_validate_arguments_length();
      var i2c = require_base64_map().i2c;
      var $btoa = getBuiltIn("btoa");
      var charAt = uncurryThis("".charAt);
      var charCodeAt = uncurryThis("".charCodeAt);
      var BASIC = !!$btoa && !fails(function() {
        return $btoa("hi") !== "aGk=";
      });
      var NO_ARG_RECEIVING_CHECK = BASIC && !fails(function() {
        $btoa();
      });
      var WRONG_ARG_CONVERSION = BASIC && fails(function() {
        return $btoa(null) !== "bnVsbA==";
      });
      var WRONG_ARITY = BASIC && $btoa.length !== 1;
      $({ global: true, bind: true, enumerable: true, forced: !BASIC || NO_ARG_RECEIVING_CHECK || WRONG_ARG_CONVERSION || WRONG_ARITY }, {
        btoa: function btoa(data2) {
          validateArgumentsLength(arguments.length, 1);
          if (BASIC) return call($btoa, global2, toString(data2));
          var string = toString(data2);
          var output = "";
          var position = 0;
          var map = i2c;
          var block, charCode;
          while (charAt(string, position) || (map = "=", position % 1)) {
            charCode = charCodeAt(string, position += 3 / 4);
            if (charCode > 255) {
              throw new (getBuiltIn("DOMException"))("The string contains characters outside of the Latin1 range", "InvalidCharacterError");
            }
            block = block << 8 | charCode;
            output += charAt(map, 63 & block >> 8 - position % 1 * 8);
          }
          return output;
        }
      });
    }
  });

  // node_modules/core-js/internals/dom-iterables.js
  var require_dom_iterables = __commonJS({
    "node_modules/core-js/internals/dom-iterables.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      module.exports = {
        CSSRuleList: 0,
        CSSStyleDeclaration: 0,
        CSSValueList: 0,
        ClientRectList: 0,
        DOMRectList: 0,
        DOMStringList: 0,
        DOMTokenList: 1,
        DataTransferItemList: 0,
        FileList: 0,
        HTMLAllCollection: 0,
        HTMLCollection: 0,
        HTMLFormElement: 0,
        HTMLSelectElement: 0,
        MediaList: 0,
        MimeTypeArray: 0,
        NamedNodeMap: 0,
        NodeList: 1,
        PaintRequestList: 0,
        Plugin: 0,
        PluginArray: 0,
        SVGLengthList: 0,
        SVGNumberList: 0,
        SVGPathSegList: 0,
        SVGPointList: 0,
        SVGStringList: 0,
        SVGTransformList: 0,
        SourceBufferList: 0,
        StyleSheetList: 0,
        TextTrackCueList: 0,
        TextTrackList: 0,
        TouchList: 0
      };
    }
  });

  // node_modules/core-js/internals/dom-token-list-prototype.js
  var require_dom_token_list_prototype = __commonJS({
    "node_modules/core-js/internals/dom-token-list-prototype.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var documentCreateElement = require_document_create_element();
      var classList = documentCreateElement("span").classList;
      var DOMTokenListPrototype = classList && classList.constructor && classList.constructor.prototype;
      module.exports = DOMTokenListPrototype === Object.prototype ? void 0 : DOMTokenListPrototype;
    }
  });

  // node_modules/core-js/modules/web.dom-collections.for-each.js
  var require_web_dom_collections_for_each = __commonJS({
    "node_modules/core-js/modules/web.dom-collections.for-each.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var global2 = require_global();
      var DOMIterables = require_dom_iterables();
      var DOMTokenListPrototype = require_dom_token_list_prototype();
      var forEach2 = require_array_for_each();
      var createNonEnumerableProperty = require_create_non_enumerable_property();
      var handlePrototype = function(CollectionPrototype) {
        if (CollectionPrototype && CollectionPrototype.forEach !== forEach2) try {
          createNonEnumerableProperty(CollectionPrototype, "forEach", forEach2);
        } catch (error) {
          CollectionPrototype.forEach = forEach2;
        }
      };
      for (COLLECTION_NAME in DOMIterables) {
        if (DOMIterables[COLLECTION_NAME]) {
          handlePrototype(global2[COLLECTION_NAME] && global2[COLLECTION_NAME].prototype);
        }
      }
      var COLLECTION_NAME;
      handlePrototype(DOMTokenListPrototype);
    }
  });

  // node_modules/core-js/modules/web.dom-collections.iterator.js
  var require_web_dom_collections_iterator = __commonJS({
    "node_modules/core-js/modules/web.dom-collections.iterator.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var global2 = require_global();
      var DOMIterables = require_dom_iterables();
      var DOMTokenListPrototype = require_dom_token_list_prototype();
      var ArrayIteratorMethods = require_es_array_iterator();
      var createNonEnumerableProperty = require_create_non_enumerable_property();
      var setToStringTag = require_set_to_string_tag();
      var wellKnownSymbol = require_well_known_symbol();
      var ITERATOR = wellKnownSymbol("iterator");
      var ArrayValues = ArrayIteratorMethods.values;
      var handlePrototype = function(CollectionPrototype, COLLECTION_NAME2) {
        if (CollectionPrototype) {
          if (CollectionPrototype[ITERATOR] !== ArrayValues) try {
            createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);
          } catch (error) {
            CollectionPrototype[ITERATOR] = ArrayValues;
          }
          setToStringTag(CollectionPrototype, COLLECTION_NAME2, true);
          if (DOMIterables[COLLECTION_NAME2]) for (var METHOD_NAME in ArrayIteratorMethods) {
            if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try {
              createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
            } catch (error) {
              CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
            }
          }
        }
      };
      for (COLLECTION_NAME in DOMIterables) {
        handlePrototype(global2[COLLECTION_NAME] && global2[COLLECTION_NAME].prototype, COLLECTION_NAME);
      }
      var COLLECTION_NAME;
      handlePrototype(DOMTokenListPrototype, "DOMTokenList");
    }
  });

  // node_modules/core-js/internals/dom-exception-constants.js
  var require_dom_exception_constants = __commonJS({
    "node_modules/core-js/internals/dom-exception-constants.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      module.exports = {
        IndexSizeError: { s: "INDEX_SIZE_ERR", c: 1, m: 1 },
        DOMStringSizeError: { s: "DOMSTRING_SIZE_ERR", c: 2, m: 0 },
        HierarchyRequestError: { s: "HIERARCHY_REQUEST_ERR", c: 3, m: 1 },
        WrongDocumentError: { s: "WRONG_DOCUMENT_ERR", c: 4, m: 1 },
        InvalidCharacterError: { s: "INVALID_CHARACTER_ERR", c: 5, m: 1 },
        NoDataAllowedError: { s: "NO_DATA_ALLOWED_ERR", c: 6, m: 0 },
        NoModificationAllowedError: { s: "NO_MODIFICATION_ALLOWED_ERR", c: 7, m: 1 },
        NotFoundError: { s: "NOT_FOUND_ERR", c: 8, m: 1 },
        NotSupportedError: { s: "NOT_SUPPORTED_ERR", c: 9, m: 1 },
        InUseAttributeError: { s: "INUSE_ATTRIBUTE_ERR", c: 10, m: 1 },
        InvalidStateError: { s: "INVALID_STATE_ERR", c: 11, m: 1 },
        SyntaxError: { s: "SYNTAX_ERR", c: 12, m: 1 },
        InvalidModificationError: { s: "INVALID_MODIFICATION_ERR", c: 13, m: 1 },
        NamespaceError: { s: "NAMESPACE_ERR", c: 14, m: 1 },
        InvalidAccessError: { s: "INVALID_ACCESS_ERR", c: 15, m: 1 },
        ValidationError: { s: "VALIDATION_ERR", c: 16, m: 0 },
        TypeMismatchError: { s: "TYPE_MISMATCH_ERR", c: 17, m: 1 },
        SecurityError: { s: "SECURITY_ERR", c: 18, m: 1 },
        NetworkError: { s: "NETWORK_ERR", c: 19, m: 1 },
        AbortError: { s: "ABORT_ERR", c: 20, m: 1 },
        URLMismatchError: { s: "URL_MISMATCH_ERR", c: 21, m: 1 },
        QuotaExceededError: { s: "QUOTA_EXCEEDED_ERR", c: 22, m: 1 },
        TimeoutError: { s: "TIMEOUT_ERR", c: 23, m: 1 },
        InvalidNodeTypeError: { s: "INVALID_NODE_TYPE_ERR", c: 24, m: 1 },
        DataCloneError: { s: "DATA_CLONE_ERR", c: 25, m: 1 }
      };
    }
  });

  // node_modules/core-js/modules/web.dom-exception.constructor.js
  var require_web_dom_exception_constructor = __commonJS({
    "node_modules/core-js/modules/web.dom-exception.constructor.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var tryNodeRequire = require_try_node_require();
      var getBuiltIn = require_get_built_in();
      var fails = require_fails();
      var create = require_object_create();
      var createPropertyDescriptor = require_create_property_descriptor();
      var defineProperty = require_object_define_property().f;
      var defineBuiltIn = require_define_built_in();
      var defineBuiltInAccessor = require_define_built_in_accessor();
      var hasOwn = require_has_own_property();
      var anInstance = require_an_instance();
      var anObject = require_an_object();
      var errorToString = require_error_to_string();
      var normalizeStringArgument = require_normalize_string_argument();
      var DOMExceptionConstants = require_dom_exception_constants();
      var clearErrorStack = require_error_stack_clear();
      var InternalStateModule = require_internal_state();
      var DESCRIPTORS = require_descriptors();
      var IS_PURE = require_is_pure();
      var DOM_EXCEPTION = "DOMException";
      var DATA_CLONE_ERR = "DATA_CLONE_ERR";
      var Error2 = getBuiltIn("Error");
      var NativeDOMException = getBuiltIn(DOM_EXCEPTION) || function() {
        try {
          var MessageChannel2 = getBuiltIn("MessageChannel") || tryNodeRequire("worker_threads").MessageChannel;
          new MessageChannel2().port1.postMessage(/* @__PURE__ */ new WeakMap());
        } catch (error) {
          if (error.name === DATA_CLONE_ERR && error.code === 25) return error.constructor;
        }
      }();
      var NativeDOMExceptionPrototype = NativeDOMException && NativeDOMException.prototype;
      var ErrorPrototype = Error2.prototype;
      var setInternalState = InternalStateModule.set;
      var getInternalState = InternalStateModule.getterFor(DOM_EXCEPTION);
      var HAS_STACK = "stack" in new Error2(DOM_EXCEPTION);
      var codeFor = function(name2) {
        return hasOwn(DOMExceptionConstants, name2) && DOMExceptionConstants[name2].m ? DOMExceptionConstants[name2].c : 0;
      };
      var $DOMException = function DOMException() {
        anInstance(this, DOMExceptionPrototype);
        var argumentsLength = arguments.length;
        var message = normalizeStringArgument(argumentsLength < 1 ? void 0 : arguments[0]);
        var name2 = normalizeStringArgument(argumentsLength < 2 ? void 0 : arguments[1], "Error");
        var code = codeFor(name2);
        setInternalState(this, {
          type: DOM_EXCEPTION,
          name: name2,
          message,
          code
        });
        if (!DESCRIPTORS) {
          this.name = name2;
          this.message = message;
          this.code = code;
        }
        if (HAS_STACK) {
          var error = new Error2(message);
          error.name = DOM_EXCEPTION;
          defineProperty(this, "stack", createPropertyDescriptor(1, clearErrorStack(error.stack, 1)));
        }
      };
      var DOMExceptionPrototype = $DOMException.prototype = create(ErrorPrototype);
      var createGetterDescriptor = function(get2) {
        return { enumerable: true, configurable: true, get: get2 };
      };
      var getterFor = function(key2) {
        return createGetterDescriptor(function() {
          return getInternalState(this)[key2];
        });
      };
      if (DESCRIPTORS) {
        defineBuiltInAccessor(DOMExceptionPrototype, "code", getterFor("code"));
        defineBuiltInAccessor(DOMExceptionPrototype, "message", getterFor("message"));
        defineBuiltInAccessor(DOMExceptionPrototype, "name", getterFor("name"));
      }
      defineProperty(DOMExceptionPrototype, "constructor", createPropertyDescriptor(1, $DOMException));
      var INCORRECT_CONSTRUCTOR = fails(function() {
        return !(new NativeDOMException() instanceof Error2);
      });
      var INCORRECT_TO_STRING = INCORRECT_CONSTRUCTOR || fails(function() {
        return ErrorPrototype.toString !== errorToString || String(new NativeDOMException(1, 2)) !== "2: 1";
      });
      var INCORRECT_CODE = INCORRECT_CONSTRUCTOR || fails(function() {
        return new NativeDOMException(1, "DataCloneError").code !== 25;
      });
      var MISSED_CONSTANTS = INCORRECT_CONSTRUCTOR || NativeDOMException[DATA_CLONE_ERR] !== 25 || NativeDOMExceptionPrototype[DATA_CLONE_ERR] !== 25;
      var FORCED_CONSTRUCTOR = IS_PURE ? INCORRECT_TO_STRING || INCORRECT_CODE || MISSED_CONSTANTS : INCORRECT_CONSTRUCTOR;
      $({ global: true, constructor: true, forced: FORCED_CONSTRUCTOR }, {
        DOMException: FORCED_CONSTRUCTOR ? $DOMException : NativeDOMException
      });
      var PolyfilledDOMException = getBuiltIn(DOM_EXCEPTION);
      var PolyfilledDOMExceptionPrototype = PolyfilledDOMException.prototype;
      if (INCORRECT_TO_STRING && (IS_PURE || NativeDOMException === PolyfilledDOMException)) {
        defineBuiltIn(PolyfilledDOMExceptionPrototype, "toString", errorToString);
      }
      if (INCORRECT_CODE && DESCRIPTORS && NativeDOMException === PolyfilledDOMException) {
        defineBuiltInAccessor(PolyfilledDOMExceptionPrototype, "code", createGetterDescriptor(function() {
          return codeFor(anObject(this).name);
        }));
      }
      for (key in DOMExceptionConstants) if (hasOwn(DOMExceptionConstants, key)) {
        constant = DOMExceptionConstants[key];
        constantName = constant.s;
        descriptor = createPropertyDescriptor(6, constant.c);
        if (!hasOwn(PolyfilledDOMException, constantName)) {
          defineProperty(PolyfilledDOMException, constantName, descriptor);
        }
        if (!hasOwn(PolyfilledDOMExceptionPrototype, constantName)) {
          defineProperty(PolyfilledDOMExceptionPrototype, constantName, descriptor);
        }
      }
      var constant;
      var constantName;
      var descriptor;
      var key;
    }
  });

  // node_modules/core-js/modules/web.dom-exception.stack.js
  var require_web_dom_exception_stack = __commonJS({
    "node_modules/core-js/modules/web.dom-exception.stack.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var global2 = require_global();
      var getBuiltIn = require_get_built_in();
      var createPropertyDescriptor = require_create_property_descriptor();
      var defineProperty = require_object_define_property().f;
      var hasOwn = require_has_own_property();
      var anInstance = require_an_instance();
      var inheritIfRequired = require_inherit_if_required();
      var normalizeStringArgument = require_normalize_string_argument();
      var DOMExceptionConstants = require_dom_exception_constants();
      var clearErrorStack = require_error_stack_clear();
      var DESCRIPTORS = require_descriptors();
      var IS_PURE = require_is_pure();
      var DOM_EXCEPTION = "DOMException";
      var Error2 = getBuiltIn("Error");
      var NativeDOMException = getBuiltIn(DOM_EXCEPTION);
      var $DOMException = function DOMException() {
        anInstance(this, DOMExceptionPrototype);
        var argumentsLength = arguments.length;
        var message = normalizeStringArgument(argumentsLength < 1 ? void 0 : arguments[0]);
        var name2 = normalizeStringArgument(argumentsLength < 2 ? void 0 : arguments[1], "Error");
        var that = new NativeDOMException(message, name2);
        var error = new Error2(message);
        error.name = DOM_EXCEPTION;
        defineProperty(that, "stack", createPropertyDescriptor(1, clearErrorStack(error.stack, 1)));
        inheritIfRequired(that, this, $DOMException);
        return that;
      };
      var DOMExceptionPrototype = $DOMException.prototype = NativeDOMException.prototype;
      var ERROR_HAS_STACK = "stack" in new Error2(DOM_EXCEPTION);
      var DOM_EXCEPTION_HAS_STACK = "stack" in new NativeDOMException(1, 2);
      var descriptor = NativeDOMException && DESCRIPTORS && Object.getOwnPropertyDescriptor(global2, DOM_EXCEPTION);
      var BUGGY_DESCRIPTOR = !!descriptor && !(descriptor.writable && descriptor.configurable);
      var FORCED_CONSTRUCTOR = ERROR_HAS_STACK && !BUGGY_DESCRIPTOR && !DOM_EXCEPTION_HAS_STACK;
      $({ global: true, constructor: true, forced: IS_PURE || FORCED_CONSTRUCTOR }, {
        // TODO: fix export logic
        DOMException: FORCED_CONSTRUCTOR ? $DOMException : NativeDOMException
      });
      var PolyfilledDOMException = getBuiltIn(DOM_EXCEPTION);
      var PolyfilledDOMExceptionPrototype = PolyfilledDOMException.prototype;
      if (PolyfilledDOMExceptionPrototype.constructor !== PolyfilledDOMException) {
        if (!IS_PURE) {
          defineProperty(PolyfilledDOMExceptionPrototype, "constructor", createPropertyDescriptor(1, PolyfilledDOMException));
        }
        for (key in DOMExceptionConstants) if (hasOwn(DOMExceptionConstants, key)) {
          constant = DOMExceptionConstants[key];
          constantName = constant.s;
          if (!hasOwn(PolyfilledDOMException, constantName)) {
            defineProperty(PolyfilledDOMException, constantName, createPropertyDescriptor(6, constant.c));
          }
        }
      }
      var constant;
      var constantName;
      var key;
    }
  });

  // node_modules/core-js/modules/web.dom-exception.to-string-tag.js
  var require_web_dom_exception_to_string_tag = __commonJS({
    "node_modules/core-js/modules/web.dom-exception.to-string-tag.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var getBuiltIn = require_get_built_in();
      var setToStringTag = require_set_to_string_tag();
      var DOM_EXCEPTION = "DOMException";
      setToStringTag(getBuiltIn(DOM_EXCEPTION), DOM_EXCEPTION);
    }
  });

  // node_modules/core-js/modules/web.clear-immediate.js
  var require_web_clear_immediate = __commonJS({
    "node_modules/core-js/modules/web.clear-immediate.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var global2 = require_global();
      var clearImmediate = require_task().clear;
      $({ global: true, bind: true, enumerable: true, forced: global2.clearImmediate !== clearImmediate }, {
        clearImmediate
      });
    }
  });

  // node_modules/core-js/internals/engine-is-bun.js
  var require_engine_is_bun = __commonJS({
    "node_modules/core-js/internals/engine-is-bun.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      module.exports = typeof Bun == "function" && Bun && typeof Bun.version == "string";
    }
  });

  // node_modules/core-js/internals/schedulers-fix.js
  var require_schedulers_fix = __commonJS({
    "node_modules/core-js/internals/schedulers-fix.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var global2 = require_global();
      var apply = require_function_apply();
      var isCallable = require_is_callable();
      var ENGINE_IS_BUN = require_engine_is_bun();
      var USER_AGENT = require_engine_user_agent();
      var arraySlice2 = require_array_slice();
      var validateArgumentsLength = require_validate_arguments_length();
      var Function2 = global2.Function;
      var WRAP = /MSIE .\./.test(USER_AGENT) || ENGINE_IS_BUN && function() {
        var version2 = global2.Bun.version.split(".");
        return version2.length < 3 || version2[0] === "0" && (version2[1] < 3 || version2[1] === "3" && version2[2] === "0");
      }();
      module.exports = function(scheduler, hasTimeArg) {
        var firstParamIndex = hasTimeArg ? 2 : 1;
        return WRAP ? function(handler, timeout) {
          var boundArgs = validateArgumentsLength(arguments.length, 1) > firstParamIndex;
          var fn = isCallable(handler) ? handler : Function2(handler);
          var params = boundArgs ? arraySlice2(arguments, firstParamIndex) : [];
          var callback = boundArgs ? function() {
            apply(fn, this, params);
          } : fn;
          return hasTimeArg ? scheduler(callback, timeout) : scheduler(callback);
        } : scheduler;
      };
    }
  });

  // node_modules/core-js/modules/web.set-immediate.js
  var require_web_set_immediate = __commonJS({
    "node_modules/core-js/modules/web.set-immediate.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var global2 = require_global();
      var setTask = require_task().set;
      var schedulersFix = require_schedulers_fix();
      var setImmediate2 = global2.setImmediate ? schedulersFix(setTask, false) : setTask;
      $({ global: true, bind: true, enumerable: true, forced: global2.setImmediate !== setImmediate2 }, {
        setImmediate: setImmediate2
      });
    }
  });

  // node_modules/core-js/modules/web.immediate.js
  var require_web_immediate = __commonJS({
    "node_modules/core-js/modules/web.immediate.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      require_web_clear_immediate();
      require_web_set_immediate();
    }
  });

  // node_modules/core-js/modules/web.queue-microtask.js
  var require_web_queue_microtask = __commonJS({
    "node_modules/core-js/modules/web.queue-microtask.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var globalThis2 = require_global();
      var microtask = require_microtask();
      var aCallable = require_a_callable();
      var validateArgumentsLength = require_validate_arguments_length();
      var fails = require_fails();
      var DESCRIPTORS = require_descriptors();
      var WRONG_ARITY = fails(function() {
        return DESCRIPTORS && Object.getOwnPropertyDescriptor(globalThis2, "queueMicrotask").value.length !== 1;
      });
      $({ global: true, enumerable: true, dontCallGetSet: true, forced: WRONG_ARITY }, {
        queueMicrotask: function queueMicrotask2(fn) {
          validateArgumentsLength(arguments.length, 1);
          microtask(aCallable(fn));
        }
      });
    }
  });

  // node_modules/core-js/modules/web.self.js
  var require_web_self = __commonJS({
    "node_modules/core-js/modules/web.self.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var global2 = require_global();
      var defineBuiltInAccessor = require_define_built_in_accessor();
      var DESCRIPTORS = require_descriptors();
      var $TypeError = TypeError;
      var defineProperty = Object.defineProperty;
      var INCORRECT_VALUE = global2.self !== global2;
      try {
        if (DESCRIPTORS) {
          descriptor = Object.getOwnPropertyDescriptor(global2, "self");
          if (INCORRECT_VALUE || !descriptor || !descriptor.get || !descriptor.enumerable) {
            defineBuiltInAccessor(global2, "self", {
              get: function self2() {
                return global2;
              },
              set: function self2(value) {
                if (this !== global2) throw new $TypeError("Illegal invocation");
                defineProperty(global2, "self", {
                  value,
                  writable: true,
                  configurable: true,
                  enumerable: true
                });
              },
              configurable: true,
              enumerable: true
            });
          }
        } else $({ global: true, simple: true, forced: INCORRECT_VALUE }, {
          self: global2
        });
      } catch (error) {
      }
      var descriptor;
    }
  });

  // node_modules/core-js/modules/web.structured-clone.js
  var require_web_structured_clone = __commonJS({
    "node_modules/core-js/modules/web.structured-clone.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var IS_PURE = require_is_pure();
      var $ = require_export();
      var global2 = require_global();
      var getBuiltIn = require_get_built_in();
      var uncurryThis = require_function_uncurry_this();
      var fails = require_fails();
      var uid = require_uid();
      var isCallable = require_is_callable();
      var isConstructor = require_is_constructor();
      var isNullOrUndefined2 = require_is_null_or_undefined();
      var isObject2 = require_is_object();
      var isSymbol = require_is_symbol();
      var iterate = require_iterate();
      var anObject = require_an_object();
      var classof = require_classof();
      var hasOwn = require_has_own_property();
      var createProperty = require_create_property();
      var createNonEnumerableProperty = require_create_non_enumerable_property();
      var lengthOfArrayLike = require_length_of_array_like();
      var validateArgumentsLength = require_validate_arguments_length();
      var getRegExpFlags = require_regexp_get_flags();
      var MapHelpers = require_map_helpers();
      var SetHelpers = require_set_helpers();
      var setIterate = require_set_iterate();
      var detachTransferable = require_detach_transferable();
      var ERROR_STACK_INSTALLABLE = require_error_stack_installable();
      var PROPER_STRUCTURED_CLONE_TRANSFER = require_structured_clone_proper_transfer();
      var Object2 = global2.Object;
      var Array2 = global2.Array;
      var Date2 = global2.Date;
      var Error2 = global2.Error;
      var TypeError2 = global2.TypeError;
      var PerformanceMark = global2.PerformanceMark;
      var DOMException = getBuiltIn("DOMException");
      var Map2 = MapHelpers.Map;
      var mapHas = MapHelpers.has;
      var mapGet = MapHelpers.get;
      var mapSet = MapHelpers.set;
      var Set2 = SetHelpers.Set;
      var setAdd = SetHelpers.add;
      var setHas = SetHelpers.has;
      var objectKeys = getBuiltIn("Object", "keys");
      var push = uncurryThis([].push);
      var thisBooleanValue = uncurryThis(true.valueOf);
      var thisNumberValue = uncurryThis(1 .valueOf);
      var thisStringValue = uncurryThis("".valueOf);
      var thisTimeValue = uncurryThis(Date2.prototype.getTime);
      var PERFORMANCE_MARK = uid("structuredClone");
      var DATA_CLONE_ERROR = "DataCloneError";
      var TRANSFERRING = "Transferring";
      var checkBasicSemantic = function(structuredCloneImplementation) {
        return !fails(function() {
          var set1 = new global2.Set([7]);
          var set2 = structuredCloneImplementation(set1);
          var number = structuredCloneImplementation(Object2(7));
          return set2 === set1 || !set2.has(7) || !isObject2(number) || +number !== 7;
        }) && structuredCloneImplementation;
      };
      var checkErrorsCloning = function(structuredCloneImplementation, $Error) {
        return !fails(function() {
          var error = new $Error();
          var test = structuredCloneImplementation({ a: error, b: error });
          return !(test && test.a === test.b && test.a instanceof $Error && test.a.stack === error.stack);
        });
      };
      var checkNewErrorsCloningSemantic = function(structuredCloneImplementation) {
        return !fails(function() {
          var test = structuredCloneImplementation(new global2.AggregateError([1], PERFORMANCE_MARK, { cause: 3 }));
          return test.name !== "AggregateError" || test.errors[0] !== 1 || test.message !== PERFORMANCE_MARK || test.cause !== 3;
        });
      };
      var nativeStructuredClone = global2.structuredClone;
      var FORCED_REPLACEMENT = IS_PURE || !checkErrorsCloning(nativeStructuredClone, Error2) || !checkErrorsCloning(nativeStructuredClone, DOMException) || !checkNewErrorsCloningSemantic(nativeStructuredClone);
      var structuredCloneFromMark = !nativeStructuredClone && checkBasicSemantic(function(value) {
        return new PerformanceMark(PERFORMANCE_MARK, { detail: value }).detail;
      });
      var nativeRestrictedStructuredClone = checkBasicSemantic(nativeStructuredClone) || structuredCloneFromMark;
      var throwUncloneable = function(type) {
        throw new DOMException("Uncloneable type: " + type, DATA_CLONE_ERROR);
      };
      var throwUnpolyfillable = function(type, action) {
        throw new DOMException((action || "Cloning") + " of " + type + " cannot be properly polyfilled in this engine", DATA_CLONE_ERROR);
      };
      var tryNativeRestrictedStructuredClone = function(value, type) {
        if (!nativeRestrictedStructuredClone) throwUnpolyfillable(type);
        return nativeRestrictedStructuredClone(value);
      };
      var createDataTransfer = function() {
        var dataTransfer;
        try {
          dataTransfer = new global2.DataTransfer();
        } catch (error) {
          try {
            dataTransfer = new global2.ClipboardEvent("").clipboardData;
          } catch (error2) {
          }
        }
        return dataTransfer && dataTransfer.items && dataTransfer.files ? dataTransfer : null;
      };
      var cloneBuffer = function(value, map, $type) {
        if (mapHas(map, value)) return mapGet(map, value);
        var type = $type || classof(value);
        var clone, length, options, source, target, i;
        if (type === "SharedArrayBuffer") {
          if (nativeRestrictedStructuredClone) clone = nativeRestrictedStructuredClone(value);
          else clone = value;
        } else {
          var DataView2 = global2.DataView;
          if (!DataView2 && !isCallable(value.slice)) throwUnpolyfillable("ArrayBuffer");
          try {
            if (isCallable(value.slice) && !value.resizable) {
              clone = value.slice(0);
            } else {
              length = value.byteLength;
              options = "maxByteLength" in value ? { maxByteLength: value.maxByteLength } : void 0;
              clone = new ArrayBuffer(length, options);
              source = new DataView2(value);
              target = new DataView2(clone);
              for (i = 0; i < length; i++) {
                target.setUint8(i, source.getUint8(i));
              }
            }
          } catch (error) {
            throw new DOMException("ArrayBuffer is detached", DATA_CLONE_ERROR);
          }
        }
        mapSet(map, value, clone);
        return clone;
      };
      var cloneView = function(value, type, offset, length, map) {
        var C = global2[type];
        if (!isObject2(C)) throwUnpolyfillable(type);
        return new C(cloneBuffer(value.buffer, map), offset, length);
      };
      var structuredCloneInternal = function(value, map) {
        if (isSymbol(value)) throwUncloneable("Symbol");
        if (!isObject2(value)) return value;
        if (map) {
          if (mapHas(map, value)) return mapGet(map, value);
        } else map = new Map2();
        var type = classof(value);
        var C, name2, cloned, dataTransfer, i, length, keys, key;
        switch (type) {
          case "Array":
            cloned = Array2(lengthOfArrayLike(value));
            break;
          case "Object":
            cloned = {};
            break;
          case "Map":
            cloned = new Map2();
            break;
          case "Set":
            cloned = new Set2();
            break;
          case "RegExp":
            cloned = new RegExp(value.source, getRegExpFlags(value));
            break;
          case "Error":
            name2 = value.name;
            switch (name2) {
              case "AggregateError":
                cloned = new (getBuiltIn(name2))([]);
                break;
              case "EvalError":
              case "RangeError":
              case "ReferenceError":
              case "SuppressedError":
              case "SyntaxError":
              case "TypeError":
              case "URIError":
                cloned = new (getBuiltIn(name2))();
                break;
              case "CompileError":
              case "LinkError":
              case "RuntimeError":
                cloned = new (getBuiltIn("WebAssembly", name2))();
                break;
              default:
                cloned = new Error2();
            }
            break;
          case "DOMException":
            cloned = new DOMException(value.message, value.name);
            break;
          case "ArrayBuffer":
          case "SharedArrayBuffer":
            cloned = cloneBuffer(value, map, type);
            break;
          case "DataView":
          case "Int8Array":
          case "Uint8Array":
          case "Uint8ClampedArray":
          case "Int16Array":
          case "Uint16Array":
          case "Int32Array":
          case "Uint32Array":
          case "Float16Array":
          case "Float32Array":
          case "Float64Array":
          case "BigInt64Array":
          case "BigUint64Array":
            length = type === "DataView" ? value.byteLength : value.length;
            cloned = cloneView(value, type, value.byteOffset, length, map);
            break;
          case "DOMQuad":
            try {
              cloned = new DOMQuad(
                structuredCloneInternal(value.p1, map),
                structuredCloneInternal(value.p2, map),
                structuredCloneInternal(value.p3, map),
                structuredCloneInternal(value.p4, map)
              );
            } catch (error) {
              cloned = tryNativeRestrictedStructuredClone(value, type);
            }
            break;
          case "File":
            if (nativeRestrictedStructuredClone) try {
              cloned = nativeRestrictedStructuredClone(value);
              if (classof(cloned) !== type) cloned = void 0;
            } catch (error) {
            }
            if (!cloned) try {
              cloned = new File([value], value.name, value);
            } catch (error) {
            }
            if (!cloned) throwUnpolyfillable(type);
            break;
          case "FileList":
            dataTransfer = createDataTransfer();
            if (dataTransfer) {
              for (i = 0, length = lengthOfArrayLike(value); i < length; i++) {
                dataTransfer.items.add(structuredCloneInternal(value[i], map));
              }
              cloned = dataTransfer.files;
            } else cloned = tryNativeRestrictedStructuredClone(value, type);
            break;
          case "ImageData":
            try {
              cloned = new ImageData(
                structuredCloneInternal(value.data, map),
                value.width,
                value.height,
                { colorSpace: value.colorSpace }
              );
            } catch (error) {
              cloned = tryNativeRestrictedStructuredClone(value, type);
            }
            break;
          default:
            if (nativeRestrictedStructuredClone) {
              cloned = nativeRestrictedStructuredClone(value);
            } else switch (type) {
              case "BigInt":
                cloned = Object2(value.valueOf());
                break;
              case "Boolean":
                cloned = Object2(thisBooleanValue(value));
                break;
              case "Number":
                cloned = Object2(thisNumberValue(value));
                break;
              case "String":
                cloned = Object2(thisStringValue(value));
                break;
              case "Date":
                cloned = new Date2(thisTimeValue(value));
                break;
              case "Blob":
                try {
                  cloned = value.slice(0, value.size, value.type);
                } catch (error) {
                  throwUnpolyfillable(type);
                }
                break;
              case "DOMPoint":
              case "DOMPointReadOnly":
                C = global2[type];
                try {
                  cloned = C.fromPoint ? C.fromPoint(value) : new C(value.x, value.y, value.z, value.w);
                } catch (error) {
                  throwUnpolyfillable(type);
                }
                break;
              case "DOMRect":
              case "DOMRectReadOnly":
                C = global2[type];
                try {
                  cloned = C.fromRect ? C.fromRect(value) : new C(value.x, value.y, value.width, value.height);
                } catch (error) {
                  throwUnpolyfillable(type);
                }
                break;
              case "DOMMatrix":
              case "DOMMatrixReadOnly":
                C = global2[type];
                try {
                  cloned = C.fromMatrix ? C.fromMatrix(value) : new C(value);
                } catch (error) {
                  throwUnpolyfillable(type);
                }
                break;
              case "AudioData":
              case "VideoFrame":
                if (!isCallable(value.clone)) throwUnpolyfillable(type);
                try {
                  cloned = value.clone();
                } catch (error) {
                  throwUncloneable(type);
                }
                break;
              case "CropTarget":
              case "CryptoKey":
              case "FileSystemDirectoryHandle":
              case "FileSystemFileHandle":
              case "FileSystemHandle":
              case "GPUCompilationInfo":
              case "GPUCompilationMessage":
              case "ImageBitmap":
              case "RTCCertificate":
              case "WebAssembly.Module":
                throwUnpolyfillable(type);
              default:
                throwUncloneable(type);
            }
        }
        mapSet(map, value, cloned);
        switch (type) {
          case "Array":
          case "Object":
            keys = objectKeys(value);
            for (i = 0, length = lengthOfArrayLike(keys); i < length; i++) {
              key = keys[i];
              createProperty(cloned, key, structuredCloneInternal(value[key], map));
            }
            break;
          case "Map":
            value.forEach(function(v, k) {
              mapSet(cloned, structuredCloneInternal(k, map), structuredCloneInternal(v, map));
            });
            break;
          case "Set":
            value.forEach(function(v) {
              setAdd(cloned, structuredCloneInternal(v, map));
            });
            break;
          case "Error":
            createNonEnumerableProperty(cloned, "message", structuredCloneInternal(value.message, map));
            if (hasOwn(value, "cause")) {
              createNonEnumerableProperty(cloned, "cause", structuredCloneInternal(value.cause, map));
            }
            if (name2 === "AggregateError") {
              cloned.errors = structuredCloneInternal(value.errors, map);
            } else if (name2 === "SuppressedError") {
              cloned.error = structuredCloneInternal(value.error, map);
              cloned.suppressed = structuredCloneInternal(value.suppressed, map);
            }
          case "DOMException":
            if (ERROR_STACK_INSTALLABLE) {
              createNonEnumerableProperty(cloned, "stack", structuredCloneInternal(value.stack, map));
            }
        }
        return cloned;
      };
      var tryToTransfer = function(rawTransfer, map) {
        if (!isObject2(rawTransfer)) throw new TypeError2("Transfer option cannot be converted to a sequence");
        var transfer = [];
        iterate(rawTransfer, function(value2) {
          push(transfer, anObject(value2));
        });
        var i = 0;
        var length = lengthOfArrayLike(transfer);
        var buffers = new Set2();
        var value, type, C, transferred, canvas, context;
        while (i < length) {
          value = transfer[i++];
          type = classof(value);
          if (type === "ArrayBuffer" ? setHas(buffers, value) : mapHas(map, value)) {
            throw new DOMException("Duplicate transferable", DATA_CLONE_ERROR);
          }
          if (type === "ArrayBuffer") {
            setAdd(buffers, value);
            continue;
          }
          if (PROPER_STRUCTURED_CLONE_TRANSFER) {
            transferred = nativeStructuredClone(value, { transfer: [value] });
          } else switch (type) {
            case "ImageBitmap":
              C = global2.OffscreenCanvas;
              if (!isConstructor(C)) throwUnpolyfillable(type, TRANSFERRING);
              try {
                canvas = new C(value.width, value.height);
                context = canvas.getContext("bitmaprenderer");
                context.transferFromImageBitmap(value);
                transferred = canvas.transferToImageBitmap();
              } catch (error) {
              }
              break;
            case "AudioData":
            case "VideoFrame":
              if (!isCallable(value.clone) || !isCallable(value.close)) throwUnpolyfillable(type, TRANSFERRING);
              try {
                transferred = value.clone();
                value.close();
              } catch (error) {
              }
              break;
            case "MediaSourceHandle":
            case "MessagePort":
            case "OffscreenCanvas":
            case "ReadableStream":
            case "TransformStream":
            case "WritableStream":
              throwUnpolyfillable(type, TRANSFERRING);
          }
          if (transferred === void 0) throw new DOMException("This object cannot be transferred: " + type, DATA_CLONE_ERROR);
          mapSet(map, value, transferred);
        }
        return buffers;
      };
      var detachBuffers = function(buffers) {
        setIterate(buffers, function(buffer) {
          if (PROPER_STRUCTURED_CLONE_TRANSFER) {
            nativeRestrictedStructuredClone(buffer, { transfer: [buffer] });
          } else if (isCallable(buffer.transfer)) {
            buffer.transfer();
          } else if (detachTransferable) {
            detachTransferable(buffer);
          } else {
            throwUnpolyfillable("ArrayBuffer", TRANSFERRING);
          }
        });
      };
      $({ global: true, enumerable: true, sham: !PROPER_STRUCTURED_CLONE_TRANSFER, forced: FORCED_REPLACEMENT }, {
        structuredClone: function structuredClone(value) {
          var options = validateArgumentsLength(arguments.length, 1) > 1 && !isNullOrUndefined2(arguments[1]) ? anObject(arguments[1]) : void 0;
          var transfer = options ? options.transfer : void 0;
          var map, buffers;
          if (transfer !== void 0) {
            map = new Map2();
            buffers = tryToTransfer(transfer, map);
          }
          var clone = structuredCloneInternal(value, map);
          if (buffers) detachBuffers(buffers);
          return clone;
        }
      });
    }
  });

  // node_modules/core-js/modules/web.set-interval.js
  var require_web_set_interval = __commonJS({
    "node_modules/core-js/modules/web.set-interval.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var global2 = require_global();
      var schedulersFix = require_schedulers_fix();
      var setInterval2 = schedulersFix(global2.setInterval, true);
      $({ global: true, bind: true, forced: global2.setInterval !== setInterval2 }, {
        setInterval: setInterval2
      });
    }
  });

  // node_modules/core-js/modules/web.set-timeout.js
  var require_web_set_timeout = __commonJS({
    "node_modules/core-js/modules/web.set-timeout.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var global2 = require_global();
      var schedulersFix = require_schedulers_fix();
      var setTimeout2 = schedulersFix(global2.setTimeout, true);
      $({ global: true, bind: true, forced: global2.setTimeout !== setTimeout2 }, {
        setTimeout: setTimeout2
      });
    }
  });

  // node_modules/core-js/modules/web.timers.js
  var require_web_timers = __commonJS({
    "node_modules/core-js/modules/web.timers.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      require_web_set_interval();
      require_web_set_timeout();
    }
  });

  // node_modules/core-js/internals/url-constructor-detection.js
  var require_url_constructor_detection = __commonJS({
    "node_modules/core-js/internals/url-constructor-detection.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var fails = require_fails();
      var wellKnownSymbol = require_well_known_symbol();
      var DESCRIPTORS = require_descriptors();
      var IS_PURE = require_is_pure();
      var ITERATOR = wellKnownSymbol("iterator");
      module.exports = !fails(function() {
        var url = new URL("b?a=1&b=2&c=3", "http://a");
        var params = url.searchParams;
        var params2 = new URLSearchParams("a=1&a=2&b=3");
        var result = "";
        url.pathname = "c%20d";
        params.forEach(function(value, key) {
          params["delete"]("b");
          result += key + value;
        });
        params2["delete"]("a", 2);
        params2["delete"]("b", void 0);
        return IS_PURE && (!url.toJSON || !params2.has("a", 1) || params2.has("a", 2) || !params2.has("a", void 0) || params2.has("b")) || !params.size && (IS_PURE || !DESCRIPTORS) || !params.sort || url.href !== "http://a/c%20d?a=1&c=3" || params.get("c") !== "3" || String(new URLSearchParams("?a=1")) !== "a=1" || !params[ITERATOR] || new URL("https://a@b").username !== "a" || new URLSearchParams(new URLSearchParams("a=b")).get("a") !== "b" || new URL("http://\u0442\u0435\u0441\u0442").host !== "xn--e1aybc" || new URL("http://a#\u0431").hash !== "#%D0%B1" || result !== "a1c3" || new URL("http://x", void 0).host !== "x";
      });
    }
  });

  // node_modules/core-js/internals/string-punycode-to-ascii.js
  var require_string_punycode_to_ascii = __commonJS({
    "node_modules/core-js/internals/string-punycode-to-ascii.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var uncurryThis = require_function_uncurry_this();
      var maxInt = 2147483647;
      var base = 36;
      var tMin = 1;
      var tMax = 26;
      var skew = 38;
      var damp = 700;
      var initialBias = 72;
      var initialN = 128;
      var delimiter = "-";
      var regexNonASCII = /[^\0-\u007E]/;
      var regexSeparators = /[.\u3002\uFF0E\uFF61]/g;
      var OVERFLOW_ERROR = "Overflow: input needs wider integers to process";
      var baseMinusTMin = base - tMin;
      var $RangeError = RangeError;
      var exec = uncurryThis(regexSeparators.exec);
      var floor = Math.floor;
      var fromCharCode = String.fromCharCode;
      var charCodeAt = uncurryThis("".charCodeAt);
      var join = uncurryThis([].join);
      var push = uncurryThis([].push);
      var replace = uncurryThis("".replace);
      var split = uncurryThis("".split);
      var toLowerCase2 = uncurryThis("".toLowerCase);
      var ucs2decode = function(string) {
        var output = [];
        var counter = 0;
        var length = string.length;
        while (counter < length) {
          var value = charCodeAt(string, counter++);
          if (value >= 55296 && value <= 56319 && counter < length) {
            var extra = charCodeAt(string, counter++);
            if ((extra & 64512) === 56320) {
              push(output, ((value & 1023) << 10) + (extra & 1023) + 65536);
            } else {
              push(output, value);
              counter--;
            }
          } else {
            push(output, value);
          }
        }
        return output;
      };
      var digitToBasic = function(digit) {
        return digit + 22 + 75 * (digit < 26);
      };
      var adapt = function(delta, numPoints, firstTime) {
        var k = 0;
        delta = firstTime ? floor(delta / damp) : delta >> 1;
        delta += floor(delta / numPoints);
        while (delta > baseMinusTMin * tMax >> 1) {
          delta = floor(delta / baseMinusTMin);
          k += base;
        }
        return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
      };
      var encode = function(input) {
        var output = [];
        input = ucs2decode(input);
        var inputLength = input.length;
        var n = initialN;
        var delta = 0;
        var bias = initialBias;
        var i, currentValue;
        for (i = 0; i < input.length; i++) {
          currentValue = input[i];
          if (currentValue < 128) {
            push(output, fromCharCode(currentValue));
          }
        }
        var basicLength = output.length;
        var handledCPCount = basicLength;
        if (basicLength) {
          push(output, delimiter);
        }
        while (handledCPCount < inputLength) {
          var m = maxInt;
          for (i = 0; i < input.length; i++) {
            currentValue = input[i];
            if (currentValue >= n && currentValue < m) {
              m = currentValue;
            }
          }
          var handledCPCountPlusOne = handledCPCount + 1;
          if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
            throw new $RangeError(OVERFLOW_ERROR);
          }
          delta += (m - n) * handledCPCountPlusOne;
          n = m;
          for (i = 0; i < input.length; i++) {
            currentValue = input[i];
            if (currentValue < n && ++delta > maxInt) {
              throw new $RangeError(OVERFLOW_ERROR);
            }
            if (currentValue === n) {
              var q = delta;
              var k = base;
              while (true) {
                var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                if (q < t) break;
                var qMinusT = q - t;
                var baseMinusT = base - t;
                push(output, fromCharCode(digitToBasic(t + qMinusT % baseMinusT)));
                q = floor(qMinusT / baseMinusT);
                k += base;
              }
              push(output, fromCharCode(digitToBasic(q)));
              bias = adapt(delta, handledCPCountPlusOne, handledCPCount === basicLength);
              delta = 0;
              handledCPCount++;
            }
          }
          delta++;
          n++;
        }
        return join(output, "");
      };
      module.exports = function(input) {
        var encoded = [];
        var labels = split(replace(toLowerCase2(input), regexSeparators, "."), ".");
        var i, label;
        for (i = 0; i < labels.length; i++) {
          label = labels[i];
          push(encoded, exec(regexNonASCII, label) ? "xn--" + encode(label) : label);
        }
        return join(encoded, ".");
      };
    }
  });

  // node_modules/core-js/modules/web.url-search-params.constructor.js
  var require_web_url_search_params_constructor = __commonJS({
    "node_modules/core-js/modules/web.url-search-params.constructor.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      require_es_array_iterator();
      var $ = require_export();
      var global2 = require_global();
      var safeGetBuiltIn = require_safe_get_built_in();
      var call = require_function_call();
      var uncurryThis = require_function_uncurry_this();
      var DESCRIPTORS = require_descriptors();
      var USE_NATIVE_URL = require_url_constructor_detection();
      var defineBuiltIn = require_define_built_in();
      var defineBuiltInAccessor = require_define_built_in_accessor();
      var defineBuiltIns = require_define_built_ins();
      var setToStringTag = require_set_to_string_tag();
      var createIteratorConstructor = require_iterator_create_constructor();
      var InternalStateModule = require_internal_state();
      var anInstance = require_an_instance();
      var isCallable = require_is_callable();
      var hasOwn = require_has_own_property();
      var bind = require_function_bind_context();
      var classof = require_classof();
      var anObject = require_an_object();
      var isObject2 = require_is_object();
      var $toString = require_to_string();
      var create = require_object_create();
      var createPropertyDescriptor = require_create_property_descriptor();
      var getIterator = require_get_iterator();
      var getIteratorMethod = require_get_iterator_method();
      var createIterResultObject = require_create_iter_result_object();
      var validateArgumentsLength = require_validate_arguments_length();
      var wellKnownSymbol = require_well_known_symbol();
      var arraySort = require_array_sort();
      var ITERATOR = wellKnownSymbol("iterator");
      var URL_SEARCH_PARAMS = "URLSearchParams";
      var URL_SEARCH_PARAMS_ITERATOR = URL_SEARCH_PARAMS + "Iterator";
      var setInternalState = InternalStateModule.set;
      var getInternalParamsState = InternalStateModule.getterFor(URL_SEARCH_PARAMS);
      var getInternalIteratorState = InternalStateModule.getterFor(URL_SEARCH_PARAMS_ITERATOR);
      var nativeFetch = safeGetBuiltIn("fetch");
      var NativeRequest = safeGetBuiltIn("Request");
      var Headers2 = safeGetBuiltIn("Headers");
      var RequestPrototype = NativeRequest && NativeRequest.prototype;
      var HeadersPrototype = Headers2 && Headers2.prototype;
      var RegExp2 = global2.RegExp;
      var TypeError2 = global2.TypeError;
      var decodeURIComponent2 = global2.decodeURIComponent;
      var encodeURIComponent2 = global2.encodeURIComponent;
      var charAt = uncurryThis("".charAt);
      var join = uncurryThis([].join);
      var push = uncurryThis([].push);
      var replace = uncurryThis("".replace);
      var shift = uncurryThis([].shift);
      var splice = uncurryThis([].splice);
      var split = uncurryThis("".split);
      var stringSlice = uncurryThis("".slice);
      var plus = /\+/g;
      var sequences = Array(4);
      var percentSequence = function(bytes) {
        return sequences[bytes - 1] || (sequences[bytes - 1] = RegExp2("((?:%[\\da-f]{2}){" + bytes + "})", "gi"));
      };
      var percentDecode = function(sequence) {
        try {
          return decodeURIComponent2(sequence);
        } catch (error) {
          return sequence;
        }
      };
      var deserialize = function(it) {
        var result = replace(it, plus, " ");
        var bytes = 4;
        try {
          return decodeURIComponent2(result);
        } catch (error) {
          while (bytes) {
            result = replace(result, percentSequence(bytes--), percentDecode);
          }
          return result;
        }
      };
      var find = /[!'()~]|%20/g;
      var replacements = {
        "!": "%21",
        "'": "%27",
        "(": "%28",
        ")": "%29",
        "~": "%7E",
        "%20": "+"
      };
      var replacer = function(match) {
        return replacements[match];
      };
      var serialize = function(it) {
        return replace(encodeURIComponent2(it), find, replacer);
      };
      var URLSearchParamsIterator = createIteratorConstructor(function Iterator(params, kind) {
        setInternalState(this, {
          type: URL_SEARCH_PARAMS_ITERATOR,
          target: getInternalParamsState(params).entries,
          index: 0,
          kind
        });
      }, URL_SEARCH_PARAMS, function next() {
        var state = getInternalIteratorState(this);
        var target = state.target;
        var index = state.index++;
        if (!target || index >= target.length) {
          state.target = void 0;
          return createIterResultObject(void 0, true);
        }
        var entry = target[index];
        switch (state.kind) {
          case "keys":
            return createIterResultObject(entry.key, false);
          case "values":
            return createIterResultObject(entry.value, false);
        }
        return createIterResultObject([entry.key, entry.value], false);
      }, true);
      var URLSearchParamsState = function(init) {
        this.entries = [];
        this.url = null;
        if (init !== void 0) {
          if (isObject2(init)) this.parseObject(init);
          else this.parseQuery(typeof init == "string" ? charAt(init, 0) === "?" ? stringSlice(init, 1) : init : $toString(init));
        }
      };
      URLSearchParamsState.prototype = {
        type: URL_SEARCH_PARAMS,
        bindURL: function(url) {
          this.url = url;
          this.update();
        },
        parseObject: function(object) {
          var entries = this.entries;
          var iteratorMethod = getIteratorMethod(object);
          var iterator, next, step, entryIterator, entryNext, first, second;
          if (iteratorMethod) {
            iterator = getIterator(object, iteratorMethod);
            next = iterator.next;
            while (!(step = call(next, iterator)).done) {
              entryIterator = getIterator(anObject(step.value));
              entryNext = entryIterator.next;
              if ((first = call(entryNext, entryIterator)).done || (second = call(entryNext, entryIterator)).done || !call(entryNext, entryIterator).done) throw new TypeError2("Expected sequence with length 2");
              push(entries, { key: $toString(first.value), value: $toString(second.value) });
            }
          } else for (var key in object) if (hasOwn(object, key)) {
            push(entries, { key, value: $toString(object[key]) });
          }
        },
        parseQuery: function(query) {
          if (query) {
            var entries = this.entries;
            var attributes = split(query, "&");
            var index = 0;
            var attribute, entry;
            while (index < attributes.length) {
              attribute = attributes[index++];
              if (attribute.length) {
                entry = split(attribute, "=");
                push(entries, {
                  key: deserialize(shift(entry)),
                  value: deserialize(join(entry, "="))
                });
              }
            }
          }
        },
        serialize: function() {
          var entries = this.entries;
          var result = [];
          var index = 0;
          var entry;
          while (index < entries.length) {
            entry = entries[index++];
            push(result, serialize(entry.key) + "=" + serialize(entry.value));
          }
          return join(result, "&");
        },
        update: function() {
          this.entries.length = 0;
          this.parseQuery(this.url.query);
        },
        updateURL: function() {
          if (this.url) this.url.update();
        }
      };
      var URLSearchParamsConstructor = function URLSearchParams2() {
        anInstance(this, URLSearchParamsPrototype);
        var init = arguments.length > 0 ? arguments[0] : void 0;
        var state = setInternalState(this, new URLSearchParamsState(init));
        if (!DESCRIPTORS) this.size = state.entries.length;
      };
      var URLSearchParamsPrototype = URLSearchParamsConstructor.prototype;
      defineBuiltIns(URLSearchParamsPrototype, {
        // `URLSearchParams.prototype.append` method
        // https://url.spec.whatwg.org/#dom-urlsearchparams-append
        append: function append(name2, value) {
          var state = getInternalParamsState(this);
          validateArgumentsLength(arguments.length, 2);
          push(state.entries, { key: $toString(name2), value: $toString(value) });
          if (!DESCRIPTORS) this.length++;
          state.updateURL();
        },
        // `URLSearchParams.prototype.delete` method
        // https://url.spec.whatwg.org/#dom-urlsearchparams-delete
        "delete": function(name2) {
          var state = getInternalParamsState(this);
          var length = validateArgumentsLength(arguments.length, 1);
          var entries = state.entries;
          var key = $toString(name2);
          var $value = length < 2 ? void 0 : arguments[1];
          var value = $value === void 0 ? $value : $toString($value);
          var index = 0;
          while (index < entries.length) {
            var entry = entries[index];
            if (entry.key === key && (value === void 0 || entry.value === value)) {
              splice(entries, index, 1);
              if (value !== void 0) break;
            } else index++;
          }
          if (!DESCRIPTORS) this.size = entries.length;
          state.updateURL();
        },
        // `URLSearchParams.prototype.get` method
        // https://url.spec.whatwg.org/#dom-urlsearchparams-get
        get: function get2(name2) {
          var entries = getInternalParamsState(this).entries;
          validateArgumentsLength(arguments.length, 1);
          var key = $toString(name2);
          var index = 0;
          for (; index < entries.length; index++) {
            if (entries[index].key === key) return entries[index].value;
          }
          return null;
        },
        // `URLSearchParams.prototype.getAll` method
        // https://url.spec.whatwg.org/#dom-urlsearchparams-getall
        getAll: function getAll(name2) {
          var entries = getInternalParamsState(this).entries;
          validateArgumentsLength(arguments.length, 1);
          var key = $toString(name2);
          var result = [];
          var index = 0;
          for (; index < entries.length; index++) {
            if (entries[index].key === key) push(result, entries[index].value);
          }
          return result;
        },
        // `URLSearchParams.prototype.has` method
        // https://url.spec.whatwg.org/#dom-urlsearchparams-has
        has: function has(name2) {
          var entries = getInternalParamsState(this).entries;
          var length = validateArgumentsLength(arguments.length, 1);
          var key = $toString(name2);
          var $value = length < 2 ? void 0 : arguments[1];
          var value = $value === void 0 ? $value : $toString($value);
          var index = 0;
          while (index < entries.length) {
            var entry = entries[index++];
            if (entry.key === key && (value === void 0 || entry.value === value)) return true;
          }
          return false;
        },
        // `URLSearchParams.prototype.set` method
        // https://url.spec.whatwg.org/#dom-urlsearchparams-set
        set: function set2(name2, value) {
          var state = getInternalParamsState(this);
          validateArgumentsLength(arguments.length, 1);
          var entries = state.entries;
          var found = false;
          var key = $toString(name2);
          var val = $toString(value);
          var index = 0;
          var entry;
          for (; index < entries.length; index++) {
            entry = entries[index];
            if (entry.key === key) {
              if (found) splice(entries, index--, 1);
              else {
                found = true;
                entry.value = val;
              }
            }
          }
          if (!found) push(entries, { key, value: val });
          if (!DESCRIPTORS) this.size = entries.length;
          state.updateURL();
        },
        // `URLSearchParams.prototype.sort` method
        // https://url.spec.whatwg.org/#dom-urlsearchparams-sort
        sort: function sort() {
          var state = getInternalParamsState(this);
          arraySort(state.entries, function(a, b) {
            return a.key > b.key ? 1 : -1;
          });
          state.updateURL();
        },
        // `URLSearchParams.prototype.forEach` method
        forEach: function forEach2(callback) {
          var entries = getInternalParamsState(this).entries;
          var boundFunction = bind(callback, arguments.length > 1 ? arguments[1] : void 0);
          var index = 0;
          var entry;
          while (index < entries.length) {
            entry = entries[index++];
            boundFunction(entry.value, entry.key, this);
          }
        },
        // `URLSearchParams.prototype.keys` method
        keys: function keys() {
          return new URLSearchParamsIterator(this, "keys");
        },
        // `URLSearchParams.prototype.values` method
        values: function values() {
          return new URLSearchParamsIterator(this, "values");
        },
        // `URLSearchParams.prototype.entries` method
        entries: function entries() {
          return new URLSearchParamsIterator(this, "entries");
        }
      }, { enumerable: true });
      defineBuiltIn(URLSearchParamsPrototype, ITERATOR, URLSearchParamsPrototype.entries, { name: "entries" });
      defineBuiltIn(URLSearchParamsPrototype, "toString", function toString() {
        return getInternalParamsState(this).serialize();
      }, { enumerable: true });
      if (DESCRIPTORS) defineBuiltInAccessor(URLSearchParamsPrototype, "size", {
        get: function size() {
          return getInternalParamsState(this).entries.length;
        },
        configurable: true,
        enumerable: true
      });
      setToStringTag(URLSearchParamsConstructor, URL_SEARCH_PARAMS);
      $({ global: true, constructor: true, forced: !USE_NATIVE_URL }, {
        URLSearchParams: URLSearchParamsConstructor
      });
      if (!USE_NATIVE_URL && isCallable(Headers2)) {
        headersHas = uncurryThis(HeadersPrototype.has);
        headersSet = uncurryThis(HeadersPrototype.set);
        wrapRequestOptions = function(init) {
          if (isObject2(init)) {
            var body = init.body;
            var headers;
            if (classof(body) === URL_SEARCH_PARAMS) {
              headers = init.headers ? new Headers2(init.headers) : new Headers2();
              if (!headersHas(headers, "content-type")) {
                headersSet(headers, "content-type", "application/x-www-form-urlencoded;charset=UTF-8");
              }
              return create(init, {
                body: createPropertyDescriptor(0, $toString(body)),
                headers: createPropertyDescriptor(0, headers)
              });
            }
          }
          return init;
        };
        if (isCallable(nativeFetch)) {
          $({ global: true, enumerable: true, dontCallGetSet: true, forced: true }, {
            fetch: function fetch3(input) {
              return nativeFetch(input, arguments.length > 1 ? wrapRequestOptions(arguments[1]) : {});
            }
          });
        }
        if (isCallable(NativeRequest)) {
          RequestConstructor = function Request(input) {
            anInstance(this, RequestPrototype);
            return new NativeRequest(input, arguments.length > 1 ? wrapRequestOptions(arguments[1]) : {});
          };
          RequestPrototype.constructor = RequestConstructor;
          RequestConstructor.prototype = RequestPrototype;
          $({ global: true, constructor: true, dontCallGetSet: true, forced: true }, {
            Request: RequestConstructor
          });
        }
      }
      var headersHas;
      var headersSet;
      var wrapRequestOptions;
      var RequestConstructor;
      module.exports = {
        URLSearchParams: URLSearchParamsConstructor,
        getState: getInternalParamsState
      };
    }
  });

  // node_modules/core-js/modules/web.url.constructor.js
  var require_web_url_constructor = __commonJS({
    "node_modules/core-js/modules/web.url.constructor.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      require_es_string_iterator();
      var $ = require_export();
      var DESCRIPTORS = require_descriptors();
      var USE_NATIVE_URL = require_url_constructor_detection();
      var global2 = require_global();
      var bind = require_function_bind_context();
      var uncurryThis = require_function_uncurry_this();
      var defineBuiltIn = require_define_built_in();
      var defineBuiltInAccessor = require_define_built_in_accessor();
      var anInstance = require_an_instance();
      var hasOwn = require_has_own_property();
      var assign = require_object_assign();
      var arrayFrom = require_array_from();
      var arraySlice2 = require_array_slice();
      var codeAt = require_string_multibyte().codeAt;
      var toASCII = require_string_punycode_to_ascii();
      var $toString = require_to_string();
      var setToStringTag = require_set_to_string_tag();
      var validateArgumentsLength = require_validate_arguments_length();
      var URLSearchParamsModule = require_web_url_search_params_constructor();
      var InternalStateModule = require_internal_state();
      var setInternalState = InternalStateModule.set;
      var getInternalURLState = InternalStateModule.getterFor("URL");
      var URLSearchParams2 = URLSearchParamsModule.URLSearchParams;
      var getInternalSearchParamsState = URLSearchParamsModule.getState;
      var NativeURL = global2.URL;
      var TypeError2 = global2.TypeError;
      var parseInt2 = global2.parseInt;
      var floor = Math.floor;
      var pow = Math.pow;
      var charAt = uncurryThis("".charAt);
      var exec = uncurryThis(/./.exec);
      var join = uncurryThis([].join);
      var numberToString = uncurryThis(1 .toString);
      var pop = uncurryThis([].pop);
      var push = uncurryThis([].push);
      var replace = uncurryThis("".replace);
      var shift = uncurryThis([].shift);
      var split = uncurryThis("".split);
      var stringSlice = uncurryThis("".slice);
      var toLowerCase2 = uncurryThis("".toLowerCase);
      var unshift = uncurryThis([].unshift);
      var INVALID_AUTHORITY = "Invalid authority";
      var INVALID_SCHEME = "Invalid scheme";
      var INVALID_HOST = "Invalid host";
      var INVALID_PORT = "Invalid port";
      var ALPHA = /[a-z]/i;
      var ALPHANUMERIC = /[\d+-.a-z]/i;
      var DIGIT = /\d/;
      var HEX_START = /^0x/i;
      var OCT = /^[0-7]+$/;
      var DEC = /^\d+$/;
      var HEX = /^[\da-f]+$/i;
      var FORBIDDEN_HOST_CODE_POINT = /[\0\t\n\r #%/:<>?@[\\\]^|]/;
      var FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT = /[\0\t\n\r #/:<>?@[\\\]^|]/;
      var LEADING_C0_CONTROL_OR_SPACE = /^[\u0000-\u0020]+/;
      var TRAILING_C0_CONTROL_OR_SPACE = /(^|[^\u0000-\u0020])[\u0000-\u0020]+$/;
      var TAB_AND_NEW_LINE = /[\t\n\r]/g;
      var EOF;
      var parseIPv4 = function(input) {
        var parts = split(input, ".");
        var partsLength, numbers, index, part, radix, number, ipv4;
        if (parts.length && parts[parts.length - 1] === "") {
          parts.length--;
        }
        partsLength = parts.length;
        if (partsLength > 4) return input;
        numbers = [];
        for (index = 0; index < partsLength; index++) {
          part = parts[index];
          if (part === "") return input;
          radix = 10;
          if (part.length > 1 && charAt(part, 0) === "0") {
            radix = exec(HEX_START, part) ? 16 : 8;
            part = stringSlice(part, radix === 8 ? 1 : 2);
          }
          if (part === "") {
            number = 0;
          } else {
            if (!exec(radix === 10 ? DEC : radix === 8 ? OCT : HEX, part)) return input;
            number = parseInt2(part, radix);
          }
          push(numbers, number);
        }
        for (index = 0; index < partsLength; index++) {
          number = numbers[index];
          if (index === partsLength - 1) {
            if (number >= pow(256, 5 - partsLength)) return null;
          } else if (number > 255) return null;
        }
        ipv4 = pop(numbers);
        for (index = 0; index < numbers.length; index++) {
          ipv4 += numbers[index] * pow(256, 3 - index);
        }
        return ipv4;
      };
      var parseIPv6 = function(input) {
        var address = [0, 0, 0, 0, 0, 0, 0, 0];
        var pieceIndex = 0;
        var compress = null;
        var pointer = 0;
        var value, length, numbersSeen, ipv4Piece, number, swaps, swap;
        var chr = function() {
          return charAt(input, pointer);
        };
        if (chr() === ":") {
          if (charAt(input, 1) !== ":") return;
          pointer += 2;
          pieceIndex++;
          compress = pieceIndex;
        }
        while (chr()) {
          if (pieceIndex === 8) return;
          if (chr() === ":") {
            if (compress !== null) return;
            pointer++;
            pieceIndex++;
            compress = pieceIndex;
            continue;
          }
          value = length = 0;
          while (length < 4 && exec(HEX, chr())) {
            value = value * 16 + parseInt2(chr(), 16);
            pointer++;
            length++;
          }
          if (chr() === ".") {
            if (length === 0) return;
            pointer -= length;
            if (pieceIndex > 6) return;
            numbersSeen = 0;
            while (chr()) {
              ipv4Piece = null;
              if (numbersSeen > 0) {
                if (chr() === "." && numbersSeen < 4) pointer++;
                else return;
              }
              if (!exec(DIGIT, chr())) return;
              while (exec(DIGIT, chr())) {
                number = parseInt2(chr(), 10);
                if (ipv4Piece === null) ipv4Piece = number;
                else if (ipv4Piece === 0) return;
                else ipv4Piece = ipv4Piece * 10 + number;
                if (ipv4Piece > 255) return;
                pointer++;
              }
              address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
              numbersSeen++;
              if (numbersSeen === 2 || numbersSeen === 4) pieceIndex++;
            }
            if (numbersSeen !== 4) return;
            break;
          } else if (chr() === ":") {
            pointer++;
            if (!chr()) return;
          } else if (chr()) return;
          address[pieceIndex++] = value;
        }
        if (compress !== null) {
          swaps = pieceIndex - compress;
          pieceIndex = 7;
          while (pieceIndex !== 0 && swaps > 0) {
            swap = address[pieceIndex];
            address[pieceIndex--] = address[compress + swaps - 1];
            address[compress + --swaps] = swap;
          }
        } else if (pieceIndex !== 8) return;
        return address;
      };
      var findLongestZeroSequence = function(ipv6) {
        var maxIndex = null;
        var maxLength = 1;
        var currStart = null;
        var currLength = 0;
        var index = 0;
        for (; index < 8; index++) {
          if (ipv6[index] !== 0) {
            if (currLength > maxLength) {
              maxIndex = currStart;
              maxLength = currLength;
            }
            currStart = null;
            currLength = 0;
          } else {
            if (currStart === null) currStart = index;
            ++currLength;
          }
        }
        if (currLength > maxLength) {
          maxIndex = currStart;
          maxLength = currLength;
        }
        return maxIndex;
      };
      var serializeHost = function(host) {
        var result, index, compress, ignore0;
        if (typeof host == "number") {
          result = [];
          for (index = 0; index < 4; index++) {
            unshift(result, host % 256);
            host = floor(host / 256);
          }
          return join(result, ".");
        } else if (typeof host == "object") {
          result = "";
          compress = findLongestZeroSequence(host);
          for (index = 0; index < 8; index++) {
            if (ignore0 && host[index] === 0) continue;
            if (ignore0) ignore0 = false;
            if (compress === index) {
              result += index ? ":" : "::";
              ignore0 = true;
            } else {
              result += numberToString(host[index], 16);
              if (index < 7) result += ":";
            }
          }
          return "[" + result + "]";
        }
        return host;
      };
      var C0ControlPercentEncodeSet = {};
      var fragmentPercentEncodeSet = assign({}, C0ControlPercentEncodeSet, {
        " ": 1,
        '"': 1,
        "<": 1,
        ">": 1,
        "`": 1
      });
      var pathPercentEncodeSet = assign({}, fragmentPercentEncodeSet, {
        "#": 1,
        "?": 1,
        "{": 1,
        "}": 1
      });
      var userinfoPercentEncodeSet = assign({}, pathPercentEncodeSet, {
        "/": 1,
        ":": 1,
        ";": 1,
        "=": 1,
        "@": 1,
        "[": 1,
        "\\": 1,
        "]": 1,
        "^": 1,
        "|": 1
      });
      var percentEncode = function(chr, set2) {
        var code = codeAt(chr, 0);
        return code > 32 && code < 127 && !hasOwn(set2, chr) ? chr : encodeURIComponent(chr);
      };
      var specialSchemes = {
        ftp: 21,
        file: null,
        http: 80,
        https: 443,
        ws: 80,
        wss: 443
      };
      var isWindowsDriveLetter = function(string, normalized) {
        var second;
        return string.length === 2 && exec(ALPHA, charAt(string, 0)) && ((second = charAt(string, 1)) === ":" || !normalized && second === "|");
      };
      var startsWithWindowsDriveLetter = function(string) {
        var third;
        return string.length > 1 && isWindowsDriveLetter(stringSlice(string, 0, 2)) && (string.length === 2 || ((third = charAt(string, 2)) === "/" || third === "\\" || third === "?" || third === "#"));
      };
      var isSingleDot = function(segment) {
        return segment === "." || toLowerCase2(segment) === "%2e";
      };
      var isDoubleDot = function(segment) {
        segment = toLowerCase2(segment);
        return segment === ".." || segment === "%2e." || segment === ".%2e" || segment === "%2e%2e";
      };
      var SCHEME_START = {};
      var SCHEME = {};
      var NO_SCHEME = {};
      var SPECIAL_RELATIVE_OR_AUTHORITY = {};
      var PATH_OR_AUTHORITY = {};
      var RELATIVE = {};
      var RELATIVE_SLASH = {};
      var SPECIAL_AUTHORITY_SLASHES = {};
      var SPECIAL_AUTHORITY_IGNORE_SLASHES = {};
      var AUTHORITY = {};
      var HOST = {};
      var HOSTNAME = {};
      var PORT = {};
      var FILE = {};
      var FILE_SLASH = {};
      var FILE_HOST = {};
      var PATH_START = {};
      var PATH = {};
      var CANNOT_BE_A_BASE_URL_PATH = {};
      var QUERY = {};
      var FRAGMENT = {};
      var URLState = function(url, isBase, base) {
        var urlString = $toString(url);
        var baseState, failure, searchParams;
        if (isBase) {
          failure = this.parse(urlString);
          if (failure) throw new TypeError2(failure);
          this.searchParams = null;
        } else {
          if (base !== void 0) baseState = new URLState(base, true);
          failure = this.parse(urlString, null, baseState);
          if (failure) throw new TypeError2(failure);
          searchParams = getInternalSearchParamsState(new URLSearchParams2());
          searchParams.bindURL(this);
          this.searchParams = searchParams;
        }
      };
      URLState.prototype = {
        type: "URL",
        // https://url.spec.whatwg.org/#url-parsing
        // eslint-disable-next-line max-statements -- TODO
        parse: function(input, stateOverride, base) {
          var url = this;
          var state = stateOverride || SCHEME_START;
          var pointer = 0;
          var buffer = "";
          var seenAt = false;
          var seenBracket = false;
          var seenPasswordToken = false;
          var codePoints, chr, bufferCodePoints, failure;
          input = $toString(input);
          if (!stateOverride) {
            url.scheme = "";
            url.username = "";
            url.password = "";
            url.host = null;
            url.port = null;
            url.path = [];
            url.query = null;
            url.fragment = null;
            url.cannotBeABaseURL = false;
            input = replace(input, LEADING_C0_CONTROL_OR_SPACE, "");
            input = replace(input, TRAILING_C0_CONTROL_OR_SPACE, "$1");
          }
          input = replace(input, TAB_AND_NEW_LINE, "");
          codePoints = arrayFrom(input);
          while (pointer <= codePoints.length) {
            chr = codePoints[pointer];
            switch (state) {
              case SCHEME_START:
                if (chr && exec(ALPHA, chr)) {
                  buffer += toLowerCase2(chr);
                  state = SCHEME;
                } else if (!stateOverride) {
                  state = NO_SCHEME;
                  continue;
                } else return INVALID_SCHEME;
                break;
              case SCHEME:
                if (chr && (exec(ALPHANUMERIC, chr) || chr === "+" || chr === "-" || chr === ".")) {
                  buffer += toLowerCase2(chr);
                } else if (chr === ":") {
                  if (stateOverride && (url.isSpecial() !== hasOwn(specialSchemes, buffer) || buffer === "file" && (url.includesCredentials() || url.port !== null) || url.scheme === "file" && !url.host)) return;
                  url.scheme = buffer;
                  if (stateOverride) {
                    if (url.isSpecial() && specialSchemes[url.scheme] === url.port) url.port = null;
                    return;
                  }
                  buffer = "";
                  if (url.scheme === "file") {
                    state = FILE;
                  } else if (url.isSpecial() && base && base.scheme === url.scheme) {
                    state = SPECIAL_RELATIVE_OR_AUTHORITY;
                  } else if (url.isSpecial()) {
                    state = SPECIAL_AUTHORITY_SLASHES;
                  } else if (codePoints[pointer + 1] === "/") {
                    state = PATH_OR_AUTHORITY;
                    pointer++;
                  } else {
                    url.cannotBeABaseURL = true;
                    push(url.path, "");
                    state = CANNOT_BE_A_BASE_URL_PATH;
                  }
                } else if (!stateOverride) {
                  buffer = "";
                  state = NO_SCHEME;
                  pointer = 0;
                  continue;
                } else return INVALID_SCHEME;
                break;
              case NO_SCHEME:
                if (!base || base.cannotBeABaseURL && chr !== "#") return INVALID_SCHEME;
                if (base.cannotBeABaseURL && chr === "#") {
                  url.scheme = base.scheme;
                  url.path = arraySlice2(base.path);
                  url.query = base.query;
                  url.fragment = "";
                  url.cannotBeABaseURL = true;
                  state = FRAGMENT;
                  break;
                }
                state = base.scheme === "file" ? FILE : RELATIVE;
                continue;
              case SPECIAL_RELATIVE_OR_AUTHORITY:
                if (chr === "/" && codePoints[pointer + 1] === "/") {
                  state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
                  pointer++;
                } else {
                  state = RELATIVE;
                  continue;
                }
                break;
              case PATH_OR_AUTHORITY:
                if (chr === "/") {
                  state = AUTHORITY;
                  break;
                } else {
                  state = PATH;
                  continue;
                }
              case RELATIVE:
                url.scheme = base.scheme;
                if (chr === EOF) {
                  url.username = base.username;
                  url.password = base.password;
                  url.host = base.host;
                  url.port = base.port;
                  url.path = arraySlice2(base.path);
                  url.query = base.query;
                } else if (chr === "/" || chr === "\\" && url.isSpecial()) {
                  state = RELATIVE_SLASH;
                } else if (chr === "?") {
                  url.username = base.username;
                  url.password = base.password;
                  url.host = base.host;
                  url.port = base.port;
                  url.path = arraySlice2(base.path);
                  url.query = "";
                  state = QUERY;
                } else if (chr === "#") {
                  url.username = base.username;
                  url.password = base.password;
                  url.host = base.host;
                  url.port = base.port;
                  url.path = arraySlice2(base.path);
                  url.query = base.query;
                  url.fragment = "";
                  state = FRAGMENT;
                } else {
                  url.username = base.username;
                  url.password = base.password;
                  url.host = base.host;
                  url.port = base.port;
                  url.path = arraySlice2(base.path);
                  url.path.length--;
                  state = PATH;
                  continue;
                }
                break;
              case RELATIVE_SLASH:
                if (url.isSpecial() && (chr === "/" || chr === "\\")) {
                  state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
                } else if (chr === "/") {
                  state = AUTHORITY;
                } else {
                  url.username = base.username;
                  url.password = base.password;
                  url.host = base.host;
                  url.port = base.port;
                  state = PATH;
                  continue;
                }
                break;
              case SPECIAL_AUTHORITY_SLASHES:
                state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
                if (chr !== "/" || charAt(buffer, pointer + 1) !== "/") continue;
                pointer++;
                break;
              case SPECIAL_AUTHORITY_IGNORE_SLASHES:
                if (chr !== "/" && chr !== "\\") {
                  state = AUTHORITY;
                  continue;
                }
                break;
              case AUTHORITY:
                if (chr === "@") {
                  if (seenAt) buffer = "%40" + buffer;
                  seenAt = true;
                  bufferCodePoints = arrayFrom(buffer);
                  for (var i = 0; i < bufferCodePoints.length; i++) {
                    var codePoint = bufferCodePoints[i];
                    if (codePoint === ":" && !seenPasswordToken) {
                      seenPasswordToken = true;
                      continue;
                    }
                    var encodedCodePoints = percentEncode(codePoint, userinfoPercentEncodeSet);
                    if (seenPasswordToken) url.password += encodedCodePoints;
                    else url.username += encodedCodePoints;
                  }
                  buffer = "";
                } else if (chr === EOF || chr === "/" || chr === "?" || chr === "#" || chr === "\\" && url.isSpecial()) {
                  if (seenAt && buffer === "") return INVALID_AUTHORITY;
                  pointer -= arrayFrom(buffer).length + 1;
                  buffer = "";
                  state = HOST;
                } else buffer += chr;
                break;
              case HOST:
              case HOSTNAME:
                if (stateOverride && url.scheme === "file") {
                  state = FILE_HOST;
                  continue;
                } else if (chr === ":" && !seenBracket) {
                  if (buffer === "") return INVALID_HOST;
                  failure = url.parseHost(buffer);
                  if (failure) return failure;
                  buffer = "";
                  state = PORT;
                  if (stateOverride === HOSTNAME) return;
                } else if (chr === EOF || chr === "/" || chr === "?" || chr === "#" || chr === "\\" && url.isSpecial()) {
                  if (url.isSpecial() && buffer === "") return INVALID_HOST;
                  if (stateOverride && buffer === "" && (url.includesCredentials() || url.port !== null)) return;
                  failure = url.parseHost(buffer);
                  if (failure) return failure;
                  buffer = "";
                  state = PATH_START;
                  if (stateOverride) return;
                  continue;
                } else {
                  if (chr === "[") seenBracket = true;
                  else if (chr === "]") seenBracket = false;
                  buffer += chr;
                }
                break;
              case PORT:
                if (exec(DIGIT, chr)) {
                  buffer += chr;
                } else if (chr === EOF || chr === "/" || chr === "?" || chr === "#" || chr === "\\" && url.isSpecial() || stateOverride) {
                  if (buffer !== "") {
                    var port = parseInt2(buffer, 10);
                    if (port > 65535) return INVALID_PORT;
                    url.port = url.isSpecial() && port === specialSchemes[url.scheme] ? null : port;
                    buffer = "";
                  }
                  if (stateOverride) return;
                  state = PATH_START;
                  continue;
                } else return INVALID_PORT;
                break;
              case FILE:
                url.scheme = "file";
                if (chr === "/" || chr === "\\") state = FILE_SLASH;
                else if (base && base.scheme === "file") {
                  switch (chr) {
                    case EOF:
                      url.host = base.host;
                      url.path = arraySlice2(base.path);
                      url.query = base.query;
                      break;
                    case "?":
                      url.host = base.host;
                      url.path = arraySlice2(base.path);
                      url.query = "";
                      state = QUERY;
                      break;
                    case "#":
                      url.host = base.host;
                      url.path = arraySlice2(base.path);
                      url.query = base.query;
                      url.fragment = "";
                      state = FRAGMENT;
                      break;
                    default:
                      if (!startsWithWindowsDriveLetter(join(arraySlice2(codePoints, pointer), ""))) {
                        url.host = base.host;
                        url.path = arraySlice2(base.path);
                        url.shortenPath();
                      }
                      state = PATH;
                      continue;
                  }
                } else {
                  state = PATH;
                  continue;
                }
                break;
              case FILE_SLASH:
                if (chr === "/" || chr === "\\") {
                  state = FILE_HOST;
                  break;
                }
                if (base && base.scheme === "file" && !startsWithWindowsDriveLetter(join(arraySlice2(codePoints, pointer), ""))) {
                  if (isWindowsDriveLetter(base.path[0], true)) push(url.path, base.path[0]);
                  else url.host = base.host;
                }
                state = PATH;
                continue;
              case FILE_HOST:
                if (chr === EOF || chr === "/" || chr === "\\" || chr === "?" || chr === "#") {
                  if (!stateOverride && isWindowsDriveLetter(buffer)) {
                    state = PATH;
                  } else if (buffer === "") {
                    url.host = "";
                    if (stateOverride) return;
                    state = PATH_START;
                  } else {
                    failure = url.parseHost(buffer);
                    if (failure) return failure;
                    if (url.host === "localhost") url.host = "";
                    if (stateOverride) return;
                    buffer = "";
                    state = PATH_START;
                  }
                  continue;
                } else buffer += chr;
                break;
              case PATH_START:
                if (url.isSpecial()) {
                  state = PATH;
                  if (chr !== "/" && chr !== "\\") continue;
                } else if (!stateOverride && chr === "?") {
                  url.query = "";
                  state = QUERY;
                } else if (!stateOverride && chr === "#") {
                  url.fragment = "";
                  state = FRAGMENT;
                } else if (chr !== EOF) {
                  state = PATH;
                  if (chr !== "/") continue;
                }
                break;
              case PATH:
                if (chr === EOF || chr === "/" || chr === "\\" && url.isSpecial() || !stateOverride && (chr === "?" || chr === "#")) {
                  if (isDoubleDot(buffer)) {
                    url.shortenPath();
                    if (chr !== "/" && !(chr === "\\" && url.isSpecial())) {
                      push(url.path, "");
                    }
                  } else if (isSingleDot(buffer)) {
                    if (chr !== "/" && !(chr === "\\" && url.isSpecial())) {
                      push(url.path, "");
                    }
                  } else {
                    if (url.scheme === "file" && !url.path.length && isWindowsDriveLetter(buffer)) {
                      if (url.host) url.host = "";
                      buffer = charAt(buffer, 0) + ":";
                    }
                    push(url.path, buffer);
                  }
                  buffer = "";
                  if (url.scheme === "file" && (chr === EOF || chr === "?" || chr === "#")) {
                    while (url.path.length > 1 && url.path[0] === "") {
                      shift(url.path);
                    }
                  }
                  if (chr === "?") {
                    url.query = "";
                    state = QUERY;
                  } else if (chr === "#") {
                    url.fragment = "";
                    state = FRAGMENT;
                  }
                } else {
                  buffer += percentEncode(chr, pathPercentEncodeSet);
                }
                break;
              case CANNOT_BE_A_BASE_URL_PATH:
                if (chr === "?") {
                  url.query = "";
                  state = QUERY;
                } else if (chr === "#") {
                  url.fragment = "";
                  state = FRAGMENT;
                } else if (chr !== EOF) {
                  url.path[0] += percentEncode(chr, C0ControlPercentEncodeSet);
                }
                break;
              case QUERY:
                if (!stateOverride && chr === "#") {
                  url.fragment = "";
                  state = FRAGMENT;
                } else if (chr !== EOF) {
                  if (chr === "'" && url.isSpecial()) url.query += "%27";
                  else if (chr === "#") url.query += "%23";
                  else url.query += percentEncode(chr, C0ControlPercentEncodeSet);
                }
                break;
              case FRAGMENT:
                if (chr !== EOF) url.fragment += percentEncode(chr, fragmentPercentEncodeSet);
                break;
            }
            pointer++;
          }
        },
        // https://url.spec.whatwg.org/#host-parsing
        parseHost: function(input) {
          var result, codePoints, index;
          if (charAt(input, 0) === "[") {
            if (charAt(input, input.length - 1) !== "]") return INVALID_HOST;
            result = parseIPv6(stringSlice(input, 1, -1));
            if (!result) return INVALID_HOST;
            this.host = result;
          } else if (!this.isSpecial()) {
            if (exec(FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT, input)) return INVALID_HOST;
            result = "";
            codePoints = arrayFrom(input);
            for (index = 0; index < codePoints.length; index++) {
              result += percentEncode(codePoints[index], C0ControlPercentEncodeSet);
            }
            this.host = result;
          } else {
            input = toASCII(input);
            if (exec(FORBIDDEN_HOST_CODE_POINT, input)) return INVALID_HOST;
            result = parseIPv4(input);
            if (result === null) return INVALID_HOST;
            this.host = result;
          }
        },
        // https://url.spec.whatwg.org/#cannot-have-a-username-password-port
        cannotHaveUsernamePasswordPort: function() {
          return !this.host || this.cannotBeABaseURL || this.scheme === "file";
        },
        // https://url.spec.whatwg.org/#include-credentials
        includesCredentials: function() {
          return this.username !== "" || this.password !== "";
        },
        // https://url.spec.whatwg.org/#is-special
        isSpecial: function() {
          return hasOwn(specialSchemes, this.scheme);
        },
        // https://url.spec.whatwg.org/#shorten-a-urls-path
        shortenPath: function() {
          var path = this.path;
          var pathSize = path.length;
          if (pathSize && (this.scheme !== "file" || pathSize !== 1 || !isWindowsDriveLetter(path[0], true))) {
            path.length--;
          }
        },
        // https://url.spec.whatwg.org/#concept-url-serializer
        serialize: function() {
          var url = this;
          var scheme = url.scheme;
          var username = url.username;
          var password = url.password;
          var host = url.host;
          var port = url.port;
          var path = url.path;
          var query = url.query;
          var fragment = url.fragment;
          var output = scheme + ":";
          if (host !== null) {
            output += "//";
            if (url.includesCredentials()) {
              output += username + (password ? ":" + password : "") + "@";
            }
            output += serializeHost(host);
            if (port !== null) output += ":" + port;
          } else if (scheme === "file") output += "//";
          output += url.cannotBeABaseURL ? path[0] : path.length ? "/" + join(path, "/") : "";
          if (query !== null) output += "?" + query;
          if (fragment !== null) output += "#" + fragment;
          return output;
        },
        // https://url.spec.whatwg.org/#dom-url-href
        setHref: function(href) {
          var failure = this.parse(href);
          if (failure) throw new TypeError2(failure);
          this.searchParams.update();
        },
        // https://url.spec.whatwg.org/#dom-url-origin
        getOrigin: function() {
          var scheme = this.scheme;
          var port = this.port;
          if (scheme === "blob") try {
            return new URLConstructor(scheme.path[0]).origin;
          } catch (error) {
            return "null";
          }
          if (scheme === "file" || !this.isSpecial()) return "null";
          return scheme + "://" + serializeHost(this.host) + (port !== null ? ":" + port : "");
        },
        // https://url.spec.whatwg.org/#dom-url-protocol
        getProtocol: function() {
          return this.scheme + ":";
        },
        setProtocol: function(protocol) {
          this.parse($toString(protocol) + ":", SCHEME_START);
        },
        // https://url.spec.whatwg.org/#dom-url-username
        getUsername: function() {
          return this.username;
        },
        setUsername: function(username) {
          var codePoints = arrayFrom($toString(username));
          if (this.cannotHaveUsernamePasswordPort()) return;
          this.username = "";
          for (var i = 0; i < codePoints.length; i++) {
            this.username += percentEncode(codePoints[i], userinfoPercentEncodeSet);
          }
        },
        // https://url.spec.whatwg.org/#dom-url-password
        getPassword: function() {
          return this.password;
        },
        setPassword: function(password) {
          var codePoints = arrayFrom($toString(password));
          if (this.cannotHaveUsernamePasswordPort()) return;
          this.password = "";
          for (var i = 0; i < codePoints.length; i++) {
            this.password += percentEncode(codePoints[i], userinfoPercentEncodeSet);
          }
        },
        // https://url.spec.whatwg.org/#dom-url-host
        getHost: function() {
          var host = this.host;
          var port = this.port;
          return host === null ? "" : port === null ? serializeHost(host) : serializeHost(host) + ":" + port;
        },
        setHost: function(host) {
          if (this.cannotBeABaseURL) return;
          this.parse(host, HOST);
        },
        // https://url.spec.whatwg.org/#dom-url-hostname
        getHostname: function() {
          var host = this.host;
          return host === null ? "" : serializeHost(host);
        },
        setHostname: function(hostname) {
          if (this.cannotBeABaseURL) return;
          this.parse(hostname, HOSTNAME);
        },
        // https://url.spec.whatwg.org/#dom-url-port
        getPort: function() {
          var port = this.port;
          return port === null ? "" : $toString(port);
        },
        setPort: function(port) {
          if (this.cannotHaveUsernamePasswordPort()) return;
          port = $toString(port);
          if (port === "") this.port = null;
          else this.parse(port, PORT);
        },
        // https://url.spec.whatwg.org/#dom-url-pathname
        getPathname: function() {
          var path = this.path;
          return this.cannotBeABaseURL ? path[0] : path.length ? "/" + join(path, "/") : "";
        },
        setPathname: function(pathname) {
          if (this.cannotBeABaseURL) return;
          this.path = [];
          this.parse(pathname, PATH_START);
        },
        // https://url.spec.whatwg.org/#dom-url-search
        getSearch: function() {
          var query = this.query;
          return query ? "?" + query : "";
        },
        setSearch: function(search) {
          search = $toString(search);
          if (search === "") {
            this.query = null;
          } else {
            if (charAt(search, 0) === "?") search = stringSlice(search, 1);
            this.query = "";
            this.parse(search, QUERY);
          }
          this.searchParams.update();
        },
        // https://url.spec.whatwg.org/#dom-url-searchparams
        getSearchParams: function() {
          return this.searchParams.facade;
        },
        // https://url.spec.whatwg.org/#dom-url-hash
        getHash: function() {
          var fragment = this.fragment;
          return fragment ? "#" + fragment : "";
        },
        setHash: function(hash) {
          hash = $toString(hash);
          if (hash === "") {
            this.fragment = null;
            return;
          }
          if (charAt(hash, 0) === "#") hash = stringSlice(hash, 1);
          this.fragment = "";
          this.parse(hash, FRAGMENT);
        },
        update: function() {
          this.query = this.searchParams.serialize() || null;
        }
      };
      var URLConstructor = function URL2(url) {
        var that = anInstance(this, URLPrototype);
        var base = validateArgumentsLength(arguments.length, 1) > 1 ? arguments[1] : void 0;
        var state = setInternalState(that, new URLState(url, false, base));
        if (!DESCRIPTORS) {
          that.href = state.serialize();
          that.origin = state.getOrigin();
          that.protocol = state.getProtocol();
          that.username = state.getUsername();
          that.password = state.getPassword();
          that.host = state.getHost();
          that.hostname = state.getHostname();
          that.port = state.getPort();
          that.pathname = state.getPathname();
          that.search = state.getSearch();
          that.searchParams = state.getSearchParams();
          that.hash = state.getHash();
        }
      };
      var URLPrototype = URLConstructor.prototype;
      var accessorDescriptor = function(getter, setter) {
        return {
          get: function() {
            return getInternalURLState(this)[getter]();
          },
          set: setter && function(value) {
            return getInternalURLState(this)[setter](value);
          },
          configurable: true,
          enumerable: true
        };
      };
      if (DESCRIPTORS) {
        defineBuiltInAccessor(URLPrototype, "href", accessorDescriptor("serialize", "setHref"));
        defineBuiltInAccessor(URLPrototype, "origin", accessorDescriptor("getOrigin"));
        defineBuiltInAccessor(URLPrototype, "protocol", accessorDescriptor("getProtocol", "setProtocol"));
        defineBuiltInAccessor(URLPrototype, "username", accessorDescriptor("getUsername", "setUsername"));
        defineBuiltInAccessor(URLPrototype, "password", accessorDescriptor("getPassword", "setPassword"));
        defineBuiltInAccessor(URLPrototype, "host", accessorDescriptor("getHost", "setHost"));
        defineBuiltInAccessor(URLPrototype, "hostname", accessorDescriptor("getHostname", "setHostname"));
        defineBuiltInAccessor(URLPrototype, "port", accessorDescriptor("getPort", "setPort"));
        defineBuiltInAccessor(URLPrototype, "pathname", accessorDescriptor("getPathname", "setPathname"));
        defineBuiltInAccessor(URLPrototype, "search", accessorDescriptor("getSearch", "setSearch"));
        defineBuiltInAccessor(URLPrototype, "searchParams", accessorDescriptor("getSearchParams"));
        defineBuiltInAccessor(URLPrototype, "hash", accessorDescriptor("getHash", "setHash"));
      }
      defineBuiltIn(URLPrototype, "toJSON", function toJSON() {
        return getInternalURLState(this).serialize();
      }, { enumerable: true });
      defineBuiltIn(URLPrototype, "toString", function toString() {
        return getInternalURLState(this).serialize();
      }, { enumerable: true });
      if (NativeURL) {
        nativeCreateObjectURL = NativeURL.createObjectURL;
        nativeRevokeObjectURL = NativeURL.revokeObjectURL;
        if (nativeCreateObjectURL) defineBuiltIn(URLConstructor, "createObjectURL", bind(nativeCreateObjectURL, NativeURL));
        if (nativeRevokeObjectURL) defineBuiltIn(URLConstructor, "revokeObjectURL", bind(nativeRevokeObjectURL, NativeURL));
      }
      var nativeCreateObjectURL;
      var nativeRevokeObjectURL;
      setToStringTag(URLConstructor, "URL");
      $({ global: true, constructor: true, forced: !USE_NATIVE_URL, sham: !DESCRIPTORS }, {
        URL: URLConstructor
      });
    }
  });

  // node_modules/core-js/modules/web.url.js
  var require_web_url = __commonJS({
    "node_modules/core-js/modules/web.url.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      require_web_url_constructor();
    }
  });

  // node_modules/core-js/modules/web.url.can-parse.js
  var require_web_url_can_parse = __commonJS({
    "node_modules/core-js/modules/web.url.can-parse.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var getBuiltIn = require_get_built_in();
      var fails = require_fails();
      var validateArgumentsLength = require_validate_arguments_length();
      var toString = require_to_string();
      var USE_NATIVE_URL = require_url_constructor_detection();
      var URL2 = getBuiltIn("URL");
      var THROWS_WITHOUT_ARGUMENTS = USE_NATIVE_URL && fails(function() {
        URL2.canParse();
      });
      var WRONG_ARITY = fails(function() {
        return URL2.canParse.length !== 1;
      });
      $({ target: "URL", stat: true, forced: !THROWS_WITHOUT_ARGUMENTS || WRONG_ARITY }, {
        canParse: function canParse(url) {
          var length = validateArgumentsLength(arguments.length, 1);
          var urlString = toString(url);
          var base = length < 2 || arguments[1] === void 0 ? void 0 : toString(arguments[1]);
          try {
            return !!new URL2(urlString, base);
          } catch (error) {
            return false;
          }
        }
      });
    }
  });

  // node_modules/core-js/modules/web.url.parse.js
  var require_web_url_parse = __commonJS({
    "node_modules/core-js/modules/web.url.parse.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var getBuiltIn = require_get_built_in();
      var validateArgumentsLength = require_validate_arguments_length();
      var toString = require_to_string();
      var USE_NATIVE_URL = require_url_constructor_detection();
      var URL2 = getBuiltIn("URL");
      $({ target: "URL", stat: true, forced: !USE_NATIVE_URL }, {
        parse: function parse2(url) {
          var length = validateArgumentsLength(arguments.length, 1);
          var urlString = toString(url);
          var base = length < 2 || arguments[1] === void 0 ? void 0 : toString(arguments[1]);
          try {
            return new URL2(urlString, base);
          } catch (error) {
            return null;
          }
        }
      });
    }
  });

  // node_modules/core-js/modules/web.url.to-json.js
  var require_web_url_to_json = __commonJS({
    "node_modules/core-js/modules/web.url.to-json.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var $ = require_export();
      var call = require_function_call();
      $({ target: "URL", proto: true, enumerable: true }, {
        toJSON: function toJSON() {
          return call(URL.prototype.toString, this);
        }
      });
    }
  });

  // node_modules/core-js/modules/web.url-search-params.js
  var require_web_url_search_params = __commonJS({
    "node_modules/core-js/modules/web.url-search-params.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      require_web_url_search_params_constructor();
    }
  });

  // node_modules/core-js/modules/web.url-search-params.delete.js
  var require_web_url_search_params_delete = __commonJS({
    "node_modules/core-js/modules/web.url-search-params.delete.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var defineBuiltIn = require_define_built_in();
      var uncurryThis = require_function_uncurry_this();
      var toString = require_to_string();
      var validateArgumentsLength = require_validate_arguments_length();
      var $URLSearchParams = URLSearchParams;
      var URLSearchParamsPrototype = $URLSearchParams.prototype;
      var append = uncurryThis(URLSearchParamsPrototype.append);
      var $delete = uncurryThis(URLSearchParamsPrototype["delete"]);
      var forEach2 = uncurryThis(URLSearchParamsPrototype.forEach);
      var push = uncurryThis([].push);
      var params = new $URLSearchParams("a=1&a=2&b=3");
      params["delete"]("a", 1);
      params["delete"]("b", void 0);
      if (params + "" !== "a=2") {
        defineBuiltIn(URLSearchParamsPrototype, "delete", function(name2) {
          var length = arguments.length;
          var $value = length < 2 ? void 0 : arguments[1];
          if (length && $value === void 0) return $delete(this, name2);
          var entries = [];
          forEach2(this, function(v, k) {
            push(entries, { key: k, value: v });
          });
          validateArgumentsLength(length, 1);
          var key = toString(name2);
          var value = toString($value);
          var index = 0;
          var dindex = 0;
          var found = false;
          var entriesLength = entries.length;
          var entry;
          while (index < entriesLength) {
            entry = entries[index++];
            if (found || entry.key === key) {
              found = true;
              $delete(this, entry.key);
            } else dindex++;
          }
          while (dindex < entriesLength) {
            entry = entries[dindex++];
            if (!(entry.key === key && entry.value === value)) append(this, entry.key, entry.value);
          }
        }, { enumerable: true, unsafe: true });
      }
    }
  });

  // node_modules/core-js/modules/web.url-search-params.has.js
  var require_web_url_search_params_has = __commonJS({
    "node_modules/core-js/modules/web.url-search-params.has.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var defineBuiltIn = require_define_built_in();
      var uncurryThis = require_function_uncurry_this();
      var toString = require_to_string();
      var validateArgumentsLength = require_validate_arguments_length();
      var $URLSearchParams = URLSearchParams;
      var URLSearchParamsPrototype = $URLSearchParams.prototype;
      var getAll = uncurryThis(URLSearchParamsPrototype.getAll);
      var $has = uncurryThis(URLSearchParamsPrototype.has);
      var params = new $URLSearchParams("a=1");
      if (params.has("a", 2) || !params.has("a", void 0)) {
        defineBuiltIn(URLSearchParamsPrototype, "has", function has(name2) {
          var length = arguments.length;
          var $value = length < 2 ? void 0 : arguments[1];
          if (length && $value === void 0) return $has(this, name2);
          var values = getAll(this, name2);
          validateArgumentsLength(length, 1);
          var value = toString($value);
          var index = 0;
          while (index < values.length) {
            if (values[index++] === value) return true;
          }
          return false;
        }, { enumerable: true, unsafe: true });
      }
    }
  });

  // node_modules/core-js/modules/web.url-search-params.size.js
  var require_web_url_search_params_size = __commonJS({
    "node_modules/core-js/modules/web.url-search-params.size.js"() {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var DESCRIPTORS = require_descriptors();
      var uncurryThis = require_function_uncurry_this();
      var defineBuiltInAccessor = require_define_built_in_accessor();
      var URLSearchParamsPrototype = URLSearchParams.prototype;
      var forEach2 = uncurryThis(URLSearchParamsPrototype.forEach);
      if (DESCRIPTORS && !("size" in URLSearchParamsPrototype)) {
        defineBuiltInAccessor(URLSearchParamsPrototype, "size", {
          get: function size() {
            var count = 0;
            forEach2(this, function() {
              count++;
            });
            return count;
          },
          configurable: true,
          enumerable: true
        });
      }
    }
  });

  // node_modules/core-js/stable/index.js
  var require_stable = __commonJS({
    "node_modules/core-js/stable/index.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      require_es_symbol();
      require_es_symbol_description();
      require_es_symbol_async_iterator();
      require_es_symbol_has_instance();
      require_es_symbol_is_concat_spreadable();
      require_es_symbol_iterator();
      require_es_symbol_match();
      require_es_symbol_match_all();
      require_es_symbol_replace();
      require_es_symbol_search();
      require_es_symbol_species();
      require_es_symbol_split();
      require_es_symbol_to_primitive();
      require_es_symbol_to_string_tag();
      require_es_symbol_unscopables();
      require_es_error_cause();
      require_es_error_to_string();
      require_es_aggregate_error();
      require_es_aggregate_error_cause();
      require_es_array_at();
      require_es_array_concat();
      require_es_array_copy_within();
      require_es_array_every();
      require_es_array_fill();
      require_es_array_filter();
      require_es_array_find();
      require_es_array_find_index();
      require_es_array_find_last();
      require_es_array_find_last_index();
      require_es_array_flat();
      require_es_array_flat_map();
      require_es_array_for_each();
      require_es_array_from();
      require_es_array_includes();
      require_es_array_index_of();
      require_es_array_is_array();
      require_es_array_iterator();
      require_es_array_join();
      require_es_array_last_index_of();
      require_es_array_map();
      require_es_array_of();
      require_es_array_push();
      require_es_array_reduce();
      require_es_array_reduce_right();
      require_es_array_reverse();
      require_es_array_slice();
      require_es_array_some();
      require_es_array_sort();
      require_es_array_species();
      require_es_array_splice();
      require_es_array_to_reversed();
      require_es_array_to_sorted();
      require_es_array_to_spliced();
      require_es_array_unscopables_flat();
      require_es_array_unscopables_flat_map();
      require_es_array_unshift();
      require_es_array_with();
      require_es_array_buffer_constructor();
      require_es_array_buffer_is_view();
      require_es_array_buffer_slice();
      require_es_data_view();
      require_es_array_buffer_detached();
      require_es_array_buffer_transfer();
      require_es_array_buffer_transfer_to_fixed_length();
      require_es_date_get_year();
      require_es_date_now();
      require_es_date_set_year();
      require_es_date_to_gmt_string();
      require_es_date_to_iso_string();
      require_es_date_to_json();
      require_es_date_to_primitive();
      require_es_date_to_string();
      require_es_escape();
      require_es_function_bind();
      require_es_function_has_instance();
      require_es_function_name();
      require_es_global_this();
      require_es_json_stringify();
      require_es_json_to_string_tag();
      require_es_map();
      require_es_map_group_by();
      require_es_math_acosh();
      require_es_math_asinh();
      require_es_math_atanh();
      require_es_math_cbrt();
      require_es_math_clz32();
      require_es_math_cosh();
      require_es_math_expm1();
      require_es_math_fround();
      require_es_math_hypot();
      require_es_math_imul();
      require_es_math_log10();
      require_es_math_log1p();
      require_es_math_log2();
      require_es_math_sign();
      require_es_math_sinh();
      require_es_math_tanh();
      require_es_math_to_string_tag();
      require_es_math_trunc();
      require_es_number_constructor();
      require_es_number_epsilon();
      require_es_number_is_finite();
      require_es_number_is_integer();
      require_es_number_is_nan();
      require_es_number_is_safe_integer();
      require_es_number_max_safe_integer();
      require_es_number_min_safe_integer();
      require_es_number_parse_float();
      require_es_number_parse_int();
      require_es_number_to_exponential();
      require_es_number_to_fixed();
      require_es_number_to_precision();
      require_es_object_assign();
      require_es_object_create();
      require_es_object_define_getter();
      require_es_object_define_properties();
      require_es_object_define_property();
      require_es_object_define_setter();
      require_es_object_entries();
      require_es_object_freeze();
      require_es_object_from_entries();
      require_es_object_get_own_property_descriptor();
      require_es_object_get_own_property_descriptors();
      require_es_object_get_own_property_names();
      require_es_object_get_prototype_of();
      require_es_object_group_by();
      require_es_object_has_own();
      require_es_object_is();
      require_es_object_is_extensible();
      require_es_object_is_frozen();
      require_es_object_is_sealed();
      require_es_object_keys();
      require_es_object_lookup_getter();
      require_es_object_lookup_setter();
      require_es_object_prevent_extensions();
      require_es_object_proto();
      require_es_object_seal();
      require_es_object_set_prototype_of();
      require_es_object_to_string();
      require_es_object_values();
      require_es_parse_float();
      require_es_parse_int();
      require_es_promise();
      require_es_promise_all_settled();
      require_es_promise_any();
      require_es_promise_finally();
      require_es_promise_with_resolvers();
      require_es_reflect_apply();
      require_es_reflect_construct();
      require_es_reflect_define_property();
      require_es_reflect_delete_property();
      require_es_reflect_get();
      require_es_reflect_get_own_property_descriptor();
      require_es_reflect_get_prototype_of();
      require_es_reflect_has();
      require_es_reflect_is_extensible();
      require_es_reflect_own_keys();
      require_es_reflect_prevent_extensions();
      require_es_reflect_set();
      require_es_reflect_set_prototype_of();
      require_es_reflect_to_string_tag();
      require_es_regexp_constructor();
      require_es_regexp_dot_all();
      require_es_regexp_exec();
      require_es_regexp_flags();
      require_es_regexp_sticky();
      require_es_regexp_test();
      require_es_regexp_to_string();
      require_es_set();
      require_es_set_difference_v2();
      require_es_set_intersection_v2();
      require_es_set_is_disjoint_from_v2();
      require_es_set_is_subset_of_v2();
      require_es_set_is_superset_of_v2();
      require_es_set_symmetric_difference_v2();
      require_es_set_union_v2();
      require_es_string_at_alternative();
      require_es_string_code_point_at();
      require_es_string_ends_with();
      require_es_string_from_code_point();
      require_es_string_includes();
      require_es_string_is_well_formed();
      require_es_string_iterator();
      require_es_string_match();
      require_es_string_match_all();
      require_es_string_pad_end();
      require_es_string_pad_start();
      require_es_string_raw();
      require_es_string_repeat();
      require_es_string_replace();
      require_es_string_replace_all();
      require_es_string_search();
      require_es_string_split();
      require_es_string_starts_with();
      require_es_string_substr();
      require_es_string_to_well_formed();
      require_es_string_trim();
      require_es_string_trim_end();
      require_es_string_trim_start();
      require_es_string_anchor();
      require_es_string_big();
      require_es_string_blink();
      require_es_string_bold();
      require_es_string_fixed();
      require_es_string_fontcolor();
      require_es_string_fontsize();
      require_es_string_italics();
      require_es_string_link();
      require_es_string_small();
      require_es_string_strike();
      require_es_string_sub();
      require_es_string_sup();
      require_es_typed_array_float32_array();
      require_es_typed_array_float64_array();
      require_es_typed_array_int8_array();
      require_es_typed_array_int16_array();
      require_es_typed_array_int32_array();
      require_es_typed_array_uint8_array();
      require_es_typed_array_uint8_clamped_array();
      require_es_typed_array_uint16_array();
      require_es_typed_array_uint32_array();
      require_es_typed_array_at();
      require_es_typed_array_copy_within();
      require_es_typed_array_every();
      require_es_typed_array_fill();
      require_es_typed_array_filter();
      require_es_typed_array_find();
      require_es_typed_array_find_index();
      require_es_typed_array_find_last();
      require_es_typed_array_find_last_index();
      require_es_typed_array_for_each();
      require_es_typed_array_from();
      require_es_typed_array_includes();
      require_es_typed_array_index_of();
      require_es_typed_array_iterator();
      require_es_typed_array_join();
      require_es_typed_array_last_index_of();
      require_es_typed_array_map();
      require_es_typed_array_of();
      require_es_typed_array_reduce();
      require_es_typed_array_reduce_right();
      require_es_typed_array_reverse();
      require_es_typed_array_set();
      require_es_typed_array_slice();
      require_es_typed_array_some();
      require_es_typed_array_sort();
      require_es_typed_array_subarray();
      require_es_typed_array_to_locale_string();
      require_es_typed_array_to_reversed();
      require_es_typed_array_to_sorted();
      require_es_typed_array_to_string();
      require_es_typed_array_with();
      require_es_unescape();
      require_es_weak_map();
      require_es_weak_set();
      require_web_atob();
      require_web_btoa();
      require_web_dom_collections_for_each();
      require_web_dom_collections_iterator();
      require_web_dom_exception_constructor();
      require_web_dom_exception_stack();
      require_web_dom_exception_to_string_tag();
      require_web_immediate();
      require_web_queue_microtask();
      require_web_self();
      require_web_structured_clone();
      require_web_timers();
      require_web_url();
      require_web_url_can_parse();
      require_web_url_parse();
      require_web_url_to_json();
      require_web_url_search_params();
      require_web_url_search_params_delete();
      require_web_url_search_params_has();
      require_web_url_search_params_size();
      module.exports = require_path();
    }
  });

  // node_modules/regenerator-runtime/runtime.js
  var require_runtime = __commonJS({
    "node_modules/regenerator-runtime/runtime.js"(exports, module) {
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var runtime = function(exports2) {
        "use strict";
        var Op = Object.prototype;
        var hasOwn = Op.hasOwnProperty;
        var defineProperty = Object.defineProperty || function(obj, key, desc) {
          obj[key] = desc.value;
        };
        var undefined2;
        var $Symbol = typeof Symbol === "function" ? Symbol : {};
        var iteratorSymbol = $Symbol.iterator || "@@iterator";
        var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
        var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
        function define(obj, key, value) {
          Object.defineProperty(obj, key, {
            value,
            enumerable: true,
            configurable: true,
            writable: true
          });
          return obj[key];
        }
        try {
          define({}, "");
        } catch (err) {
          define = function(obj, key, value) {
            return obj[key] = value;
          };
        }
        function wrap(innerFn, outerFn, self2, tryLocsList) {
          var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
          var generator = Object.create(protoGenerator.prototype);
          var context = new Context(tryLocsList || []);
          defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self2, context) });
          return generator;
        }
        exports2.wrap = wrap;
        function tryCatch(fn, obj, arg) {
          try {
            return { type: "normal", arg: fn.call(obj, arg) };
          } catch (err) {
            return { type: "throw", arg: err };
          }
        }
        var GenStateSuspendedStart = "suspendedStart";
        var GenStateSuspendedYield = "suspendedYield";
        var GenStateExecuting = "executing";
        var GenStateCompleted = "completed";
        var ContinueSentinel = {};
        function Generator() {
        }
        function GeneratorFunction() {
        }
        function GeneratorFunctionPrototype() {
        }
        var IteratorPrototype = {};
        define(IteratorPrototype, iteratorSymbol, function() {
          return this;
        });
        var getProto = Object.getPrototypeOf;
        var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
        if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
          IteratorPrototype = NativeIteratorPrototype;
        }
        var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
        GeneratorFunction.prototype = GeneratorFunctionPrototype;
        defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: true });
        defineProperty(
          GeneratorFunctionPrototype,
          "constructor",
          { value: GeneratorFunction, configurable: true }
        );
        GeneratorFunction.displayName = define(
          GeneratorFunctionPrototype,
          toStringTagSymbol,
          "GeneratorFunction"
        );
        function defineIteratorMethods(prototype) {
          ["next", "throw", "return"].forEach(function(method) {
            define(prototype, method, function(arg) {
              return this._invoke(method, arg);
            });
          });
        }
        exports2.isGeneratorFunction = function(genFun) {
          var ctor = typeof genFun === "function" && genFun.constructor;
          return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
          // do is to check its .name property.
          (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
        };
        exports2.mark = function(genFun) {
          if (Object.setPrototypeOf) {
            Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
          } else {
            genFun.__proto__ = GeneratorFunctionPrototype;
            define(genFun, toStringTagSymbol, "GeneratorFunction");
          }
          genFun.prototype = Object.create(Gp);
          return genFun;
        };
        exports2.awrap = function(arg) {
          return { __await: arg };
        };
        function AsyncIterator(generator, PromiseImpl) {
          function invoke(method, arg, resolve, reject) {
            var record = tryCatch(generator[method], generator, arg);
            if (record.type === "throw") {
              reject(record.arg);
            } else {
              var result = record.arg;
              var value = result.value;
              if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
                return PromiseImpl.resolve(value.__await).then(function(value2) {
                  invoke("next", value2, resolve, reject);
                }, function(err) {
                  invoke("throw", err, resolve, reject);
                });
              }
              return PromiseImpl.resolve(value).then(function(unwrapped) {
                result.value = unwrapped;
                resolve(result);
              }, function(error) {
                return invoke("throw", error, resolve, reject);
              });
            }
          }
          var previousPromise;
          function enqueue(method, arg) {
            function callInvokeWithMethodAndArg() {
              return new PromiseImpl(function(resolve, reject) {
                invoke(method, arg, resolve, reject);
              });
            }
            return previousPromise = // If enqueue has been called before, then we want to wait until
            // all previous Promises have been resolved before calling invoke,
            // so that results are always delivered in the correct order. If
            // enqueue has not been called before, then it is important to
            // call invoke immediately, without waiting on a callback to fire,
            // so that the async generator function has the opportunity to do
            // any necessary setup in a predictable way. This predictability
            // is why the Promise constructor synchronously invokes its
            // executor callback, and why async functions synchronously
            // execute code before the first await. Since we implement simple
            // async functions in terms of async generators, it is especially
            // important to get this right, even though it requires care.
            previousPromise ? previousPromise.then(
              callInvokeWithMethodAndArg,
              // Avoid propagating failures to Promises returned by later
              // invocations of the iterator.
              callInvokeWithMethodAndArg
            ) : callInvokeWithMethodAndArg();
          }
          defineProperty(this, "_invoke", { value: enqueue });
        }
        defineIteratorMethods(AsyncIterator.prototype);
        define(AsyncIterator.prototype, asyncIteratorSymbol, function() {
          return this;
        });
        exports2.AsyncIterator = AsyncIterator;
        exports2.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
          if (PromiseImpl === void 0) PromiseImpl = Promise;
          var iter = new AsyncIterator(
            wrap(innerFn, outerFn, self2, tryLocsList),
            PromiseImpl
          );
          return exports2.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
            return result.done ? result.value : iter.next();
          });
        };
        function makeInvokeMethod(innerFn, self2, context) {
          var state = GenStateSuspendedStart;
          return function invoke(method, arg) {
            if (state === GenStateExecuting) {
              throw new Error("Generator is already running");
            }
            if (state === GenStateCompleted) {
              if (method === "throw") {
                throw arg;
              }
              return doneResult();
            }
            context.method = method;
            context.arg = arg;
            while (true) {
              var delegate = context.delegate;
              if (delegate) {
                var delegateResult = maybeInvokeDelegate(delegate, context);
                if (delegateResult) {
                  if (delegateResult === ContinueSentinel) continue;
                  return delegateResult;
                }
              }
              if (context.method === "next") {
                context.sent = context._sent = context.arg;
              } else if (context.method === "throw") {
                if (state === GenStateSuspendedStart) {
                  state = GenStateCompleted;
                  throw context.arg;
                }
                context.dispatchException(context.arg);
              } else if (context.method === "return") {
                context.abrupt("return", context.arg);
              }
              state = GenStateExecuting;
              var record = tryCatch(innerFn, self2, context);
              if (record.type === "normal") {
                state = context.done ? GenStateCompleted : GenStateSuspendedYield;
                if (record.arg === ContinueSentinel) {
                  continue;
                }
                return {
                  value: record.arg,
                  done: context.done
                };
              } else if (record.type === "throw") {
                state = GenStateCompleted;
                context.method = "throw";
                context.arg = record.arg;
              }
            }
          };
        }
        function maybeInvokeDelegate(delegate, context) {
          var methodName = context.method;
          var method = delegate.iterator[methodName];
          if (method === undefined2) {
            context.delegate = null;
            if (methodName === "throw" && delegate.iterator["return"]) {
              context.method = "return";
              context.arg = undefined2;
              maybeInvokeDelegate(delegate, context);
              if (context.method === "throw") {
                return ContinueSentinel;
              }
            }
            if (methodName !== "return") {
              context.method = "throw";
              context.arg = new TypeError(
                "The iterator does not provide a '" + methodName + "' method"
              );
            }
            return ContinueSentinel;
          }
          var record = tryCatch(method, delegate.iterator, context.arg);
          if (record.type === "throw") {
            context.method = "throw";
            context.arg = record.arg;
            context.delegate = null;
            return ContinueSentinel;
          }
          var info = record.arg;
          if (!info) {
            context.method = "throw";
            context.arg = new TypeError("iterator result is not an object");
            context.delegate = null;
            return ContinueSentinel;
          }
          if (info.done) {
            context[delegate.resultName] = info.value;
            context.next = delegate.nextLoc;
            if (context.method !== "return") {
              context.method = "next";
              context.arg = undefined2;
            }
          } else {
            return info;
          }
          context.delegate = null;
          return ContinueSentinel;
        }
        defineIteratorMethods(Gp);
        define(Gp, toStringTagSymbol, "Generator");
        define(Gp, iteratorSymbol, function() {
          return this;
        });
        define(Gp, "toString", function() {
          return "[object Generator]";
        });
        function pushTryEntry(locs) {
          var entry = { tryLoc: locs[0] };
          if (1 in locs) {
            entry.catchLoc = locs[1];
          }
          if (2 in locs) {
            entry.finallyLoc = locs[2];
            entry.afterLoc = locs[3];
          }
          this.tryEntries.push(entry);
        }
        function resetTryEntry(entry) {
          var record = entry.completion || {};
          record.type = "normal";
          delete record.arg;
          entry.completion = record;
        }
        function Context(tryLocsList) {
          this.tryEntries = [{ tryLoc: "root" }];
          tryLocsList.forEach(pushTryEntry, this);
          this.reset(true);
        }
        exports2.keys = function(val) {
          var object = Object(val);
          var keys = [];
          for (var key in object) {
            keys.push(key);
          }
          keys.reverse();
          return function next() {
            while (keys.length) {
              var key2 = keys.pop();
              if (key2 in object) {
                next.value = key2;
                next.done = false;
                return next;
              }
            }
            next.done = true;
            return next;
          };
        };
        function values(iterable) {
          if (iterable != null) {
            var iteratorMethod = iterable[iteratorSymbol];
            if (iteratorMethod) {
              return iteratorMethod.call(iterable);
            }
            if (typeof iterable.next === "function") {
              return iterable;
            }
            if (!isNaN(iterable.length)) {
              var i = -1, next = function next2() {
                while (++i < iterable.length) {
                  if (hasOwn.call(iterable, i)) {
                    next2.value = iterable[i];
                    next2.done = false;
                    return next2;
                  }
                }
                next2.value = undefined2;
                next2.done = true;
                return next2;
              };
              return next.next = next;
            }
          }
          throw new TypeError(typeof iterable + " is not iterable");
        }
        exports2.values = values;
        function doneResult() {
          return { value: undefined2, done: true };
        }
        Context.prototype = {
          constructor: Context,
          reset: function(skipTempReset) {
            this.prev = 0;
            this.next = 0;
            this.sent = this._sent = undefined2;
            this.done = false;
            this.delegate = null;
            this.method = "next";
            this.arg = undefined2;
            this.tryEntries.forEach(resetTryEntry);
            if (!skipTempReset) {
              for (var name2 in this) {
                if (name2.charAt(0) === "t" && hasOwn.call(this, name2) && !isNaN(+name2.slice(1))) {
                  this[name2] = undefined2;
                }
              }
            }
          },
          stop: function() {
            this.done = true;
            var rootEntry = this.tryEntries[0];
            var rootRecord = rootEntry.completion;
            if (rootRecord.type === "throw") {
              throw rootRecord.arg;
            }
            return this.rval;
          },
          dispatchException: function(exception) {
            if (this.done) {
              throw exception;
            }
            var context = this;
            function handle(loc, caught) {
              record.type = "throw";
              record.arg = exception;
              context.next = loc;
              if (caught) {
                context.method = "next";
                context.arg = undefined2;
              }
              return !!caught;
            }
            for (var i = this.tryEntries.length - 1; i >= 0; --i) {
              var entry = this.tryEntries[i];
              var record = entry.completion;
              if (entry.tryLoc === "root") {
                return handle("end");
              }
              if (entry.tryLoc <= this.prev) {
                var hasCatch = hasOwn.call(entry, "catchLoc");
                var hasFinally = hasOwn.call(entry, "finallyLoc");
                if (hasCatch && hasFinally) {
                  if (this.prev < entry.catchLoc) {
                    return handle(entry.catchLoc, true);
                  } else if (this.prev < entry.finallyLoc) {
                    return handle(entry.finallyLoc);
                  }
                } else if (hasCatch) {
                  if (this.prev < entry.catchLoc) {
                    return handle(entry.catchLoc, true);
                  }
                } else if (hasFinally) {
                  if (this.prev < entry.finallyLoc) {
                    return handle(entry.finallyLoc);
                  }
                } else {
                  throw new Error("try statement without catch or finally");
                }
              }
            }
          },
          abrupt: function(type, arg) {
            for (var i = this.tryEntries.length - 1; i >= 0; --i) {
              var entry = this.tryEntries[i];
              if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
                var finallyEntry = entry;
                break;
              }
            }
            if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
              finallyEntry = null;
            }
            var record = finallyEntry ? finallyEntry.completion : {};
            record.type = type;
            record.arg = arg;
            if (finallyEntry) {
              this.method = "next";
              this.next = finallyEntry.finallyLoc;
              return ContinueSentinel;
            }
            return this.complete(record);
          },
          complete: function(record, afterLoc) {
            if (record.type === "throw") {
              throw record.arg;
            }
            if (record.type === "break" || record.type === "continue") {
              this.next = record.arg;
            } else if (record.type === "return") {
              this.rval = this.arg = record.arg;
              this.method = "return";
              this.next = "end";
            } else if (record.type === "normal" && afterLoc) {
              this.next = afterLoc;
            }
            return ContinueSentinel;
          },
          finish: function(finallyLoc) {
            for (var i = this.tryEntries.length - 1; i >= 0; --i) {
              var entry = this.tryEntries[i];
              if (entry.finallyLoc === finallyLoc) {
                this.complete(entry.completion, entry.afterLoc);
                resetTryEntry(entry);
                return ContinueSentinel;
              }
            }
          },
          "catch": function(tryLoc) {
            for (var i = this.tryEntries.length - 1; i >= 0; --i) {
              var entry = this.tryEntries[i];
              if (entry.tryLoc === tryLoc) {
                var record = entry.completion;
                if (record.type === "throw") {
                  var thrown = record.arg;
                  resetTryEntry(entry);
                }
                return thrown;
              }
            }
            throw new Error("illegal catch attempt");
          },
          delegateYield: function(iterable, resultName, nextLoc) {
            this.delegate = {
              iterator: values(iterable),
              resultName,
              nextLoc
            };
            if (this.method === "next") {
              this.arg = undefined2;
            }
            return ContinueSentinel;
          }
        };
        return exports2;
      }(
        // If this script is executing as a CommonJS module, use module.exports
        // as the regeneratorRuntime namespace. Otherwise create a new empty
        // object. Either way, the resulting object will be used to initialize
        // the regeneratorRuntime variable at the top of this file.
        typeof module === "object" ? module.exports : {}
      );
      try {
        regeneratorRuntime = runtime;
      } catch (accidentalStrictMode) {
        if (typeof globalThis === "object") {
          globalThis.regeneratorRuntime = runtime;
        } else {
          Function("r", "regeneratorRuntime = r")(runtime);
        }
      }
    }
  });

  // node_modules/react/cjs/react.production.min.js
  var require_react_production_min = __commonJS({
    "node_modules/react/cjs/react.production.min.js"(exports) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var l = Symbol.for("react.element");
      var n = Symbol.for("react.portal");
      var p = Symbol.for("react.fragment");
      var q = Symbol.for("react.strict_mode");
      var r = Symbol.for("react.profiler");
      var t = Symbol.for("react.provider");
      var u = Symbol.for("react.context");
      var v = Symbol.for("react.forward_ref");
      var w = Symbol.for("react.suspense");
      var x = Symbol.for("react.memo");
      var y = Symbol.for("react.lazy");
      var z = Symbol.iterator;
      function A(a) {
        if (null === a || "object" !== typeof a) return null;
        a = z && a[z] || a["@@iterator"];
        return "function" === typeof a ? a : null;
      }
      var B = { isMounted: function() {
        return false;
      }, enqueueForceUpdate: function() {
      }, enqueueReplaceState: function() {
      }, enqueueSetState: function() {
      } };
      var C = Object.assign;
      var D = {};
      function E(a, b, e) {
        this.props = a;
        this.context = b;
        this.refs = D;
        this.updater = e || B;
      }
      E.prototype.isReactComponent = {};
      E.prototype.setState = function(a, b) {
        if ("object" !== typeof a && "function" !== typeof a && null != a) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
        this.updater.enqueueSetState(this, a, b, "setState");
      };
      E.prototype.forceUpdate = function(a) {
        this.updater.enqueueForceUpdate(this, a, "forceUpdate");
      };
      function F() {
      }
      F.prototype = E.prototype;
      function G(a, b, e) {
        this.props = a;
        this.context = b;
        this.refs = D;
        this.updater = e || B;
      }
      var H = G.prototype = new F();
      H.constructor = G;
      C(H, E.prototype);
      H.isPureReactComponent = true;
      var I = Array.isArray;
      var J = Object.prototype.hasOwnProperty;
      var K = { current: null };
      var L = { key: true, ref: true, __self: true, __source: true };
      function M(a, b, e) {
        var d, c = {}, k = null, h = null;
        if (null != b) for (d in void 0 !== b.ref && (h = b.ref), void 0 !== b.key && (k = "" + b.key), b) J.call(b, d) && !L.hasOwnProperty(d) && (c[d] = b[d]);
        var g = arguments.length - 2;
        if (1 === g) c.children = e;
        else if (1 < g) {
          for (var f = Array(g), m = 0; m < g; m++) f[m] = arguments[m + 2];
          c.children = f;
        }
        if (a && a.defaultProps) for (d in g = a.defaultProps, g) void 0 === c[d] && (c[d] = g[d]);
        return { $$typeof: l, type: a, key: k, ref: h, props: c, _owner: K.current };
      }
      function N(a, b) {
        return { $$typeof: l, type: a.type, key: b, ref: a.ref, props: a.props, _owner: a._owner };
      }
      function O(a) {
        return "object" === typeof a && null !== a && a.$$typeof === l;
      }
      function escape2(a) {
        var b = { "=": "=0", ":": "=2" };
        return "$" + a.replace(/[=:]/g, function(a2) {
          return b[a2];
        });
      }
      var P = /\/+/g;
      function Q(a, b) {
        return "object" === typeof a && null !== a && null != a.key ? escape2("" + a.key) : b.toString(36);
      }
      function R(a, b, e, d, c) {
        var k = typeof a;
        if ("undefined" === k || "boolean" === k) a = null;
        var h = false;
        if (null === a) h = true;
        else switch (k) {
          case "string":
          case "number":
            h = true;
            break;
          case "object":
            switch (a.$$typeof) {
              case l:
              case n:
                h = true;
            }
        }
        if (h) return h = a, c = c(h), a = "" === d ? "." + Q(h, 0) : d, I(c) ? (e = "", null != a && (e = a.replace(P, "$&/") + "/"), R(c, b, e, "", function(a2) {
          return a2;
        })) : null != c && (O(c) && (c = N(c, e + (!c.key || h && h.key === c.key ? "" : ("" + c.key).replace(P, "$&/") + "/") + a)), b.push(c)), 1;
        h = 0;
        d = "" === d ? "." : d + ":";
        if (I(a)) for (var g = 0; g < a.length; g++) {
          k = a[g];
          var f = d + Q(k, g);
          h += R(k, b, e, f, c);
        }
        else if (f = A(a), "function" === typeof f) for (a = f.call(a), g = 0; !(k = a.next()).done; ) k = k.value, f = d + Q(k, g++), h += R(k, b, e, f, c);
        else if ("object" === k) throw b = String(a), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b ? "object with keys {" + Object.keys(a).join(", ") + "}" : b) + "). If you meant to render a collection of children, use an array instead.");
        return h;
      }
      function S(a, b, e) {
        if (null == a) return a;
        var d = [], c = 0;
        R(a, d, "", "", function(a2) {
          return b.call(e, a2, c++);
        });
        return d;
      }
      function T(a) {
        if (-1 === a._status) {
          var b = a._result;
          b = b();
          b.then(function(b2) {
            if (0 === a._status || -1 === a._status) a._status = 1, a._result = b2;
          }, function(b2) {
            if (0 === a._status || -1 === a._status) a._status = 2, a._result = b2;
          });
          -1 === a._status && (a._status = 0, a._result = b);
        }
        if (1 === a._status) return a._result.default;
        throw a._result;
      }
      var U = { current: null };
      var V = { transition: null };
      var W = { ReactCurrentDispatcher: U, ReactCurrentBatchConfig: V, ReactCurrentOwner: K };
      function X() {
        throw Error("act(...) is not supported in production builds of React.");
      }
      exports.Children = { map: S, forEach: function(a, b, e) {
        S(a, function() {
          b.apply(this, arguments);
        }, e);
      }, count: function(a) {
        var b = 0;
        S(a, function() {
          b++;
        });
        return b;
      }, toArray: function(a) {
        return S(a, function(a2) {
          return a2;
        }) || [];
      }, only: function(a) {
        if (!O(a)) throw Error("React.Children.only expected to receive a single React element child.");
        return a;
      } };
      exports.Component = E;
      exports.Fragment = p;
      exports.Profiler = r;
      exports.PureComponent = G;
      exports.StrictMode = q;
      exports.Suspense = w;
      exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W;
      exports.act = X;
      exports.cloneElement = function(a, b, e) {
        if (null === a || void 0 === a) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a + ".");
        var d = C({}, a.props), c = a.key, k = a.ref, h = a._owner;
        if (null != b) {
          void 0 !== b.ref && (k = b.ref, h = K.current);
          void 0 !== b.key && (c = "" + b.key);
          if (a.type && a.type.defaultProps) var g = a.type.defaultProps;
          for (f in b) J.call(b, f) && !L.hasOwnProperty(f) && (d[f] = void 0 === b[f] && void 0 !== g ? g[f] : b[f]);
        }
        var f = arguments.length - 2;
        if (1 === f) d.children = e;
        else if (1 < f) {
          g = Array(f);
          for (var m = 0; m < f; m++) g[m] = arguments[m + 2];
          d.children = g;
        }
        return { $$typeof: l, type: a.type, key: c, ref: k, props: d, _owner: h };
      };
      exports.createContext = function(a) {
        a = { $$typeof: u, _currentValue: a, _currentValue2: a, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
        a.Provider = { $$typeof: t, _context: a };
        return a.Consumer = a;
      };
      exports.createElement = M;
      exports.createFactory = function(a) {
        var b = M.bind(null, a);
        b.type = a;
        return b;
      };
      exports.createRef = function() {
        return { current: null };
      };
      exports.forwardRef = function(a) {
        return { $$typeof: v, render: a };
      };
      exports.isValidElement = O;
      exports.lazy = function(a) {
        return { $$typeof: y, _payload: { _status: -1, _result: a }, _init: T };
      };
      exports.memo = function(a, b) {
        return { $$typeof: x, type: a, compare: void 0 === b ? null : b };
      };
      exports.startTransition = function(a) {
        var b = V.transition;
        V.transition = {};
        try {
          a();
        } finally {
          V.transition = b;
        }
      };
      exports.unstable_act = X;
      exports.useCallback = function(a, b) {
        return U.current.useCallback(a, b);
      };
      exports.useContext = function(a) {
        return U.current.useContext(a);
      };
      exports.useDebugValue = function() {
      };
      exports.useDeferredValue = function(a) {
        return U.current.useDeferredValue(a);
      };
      exports.useEffect = function(a, b) {
        return U.current.useEffect(a, b);
      };
      exports.useId = function() {
        return U.current.useId();
      };
      exports.useImperativeHandle = function(a, b, e) {
        return U.current.useImperativeHandle(a, b, e);
      };
      exports.useInsertionEffect = function(a, b) {
        return U.current.useInsertionEffect(a, b);
      };
      exports.useLayoutEffect = function(a, b) {
        return U.current.useLayoutEffect(a, b);
      };
      exports.useMemo = function(a, b) {
        return U.current.useMemo(a, b);
      };
      exports.useReducer = function(a, b, e) {
        return U.current.useReducer(a, b, e);
      };
      exports.useRef = function(a) {
        return U.current.useRef(a);
      };
      exports.useState = function(a) {
        return U.current.useState(a);
      };
      exports.useSyncExternalStore = function(a, b, e) {
        return U.current.useSyncExternalStore(a, b, e);
      };
      exports.useTransition = function() {
        return U.current.useTransition();
      };
      exports.version = "18.3.1";
    }
  });

  // node_modules/react/index.js
  var require_react = __commonJS({
    "node_modules/react/index.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      if (true) {
        module.exports = require_react_production_min();
      } else {
        module.exports = null;
      }
    }
  });

  // node_modules/scheduler/cjs/scheduler.production.min.js
  var require_scheduler_production_min = __commonJS({
    "node_modules/scheduler/cjs/scheduler.production.min.js"(exports) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      function f(a, b) {
        var c = a.length;
        a.push(b);
        a: for (; 0 < c; ) {
          var d = c - 1 >>> 1, e = a[d];
          if (0 < g(e, b)) a[d] = b, a[c] = e, c = d;
          else break a;
        }
      }
      function h(a) {
        return 0 === a.length ? null : a[0];
      }
      function k(a) {
        if (0 === a.length) return null;
        var b = a[0], c = a.pop();
        if (c !== b) {
          a[0] = c;
          a: for (var d = 0, e = a.length, w = e >>> 1; d < w; ) {
            var m = 2 * (d + 1) - 1, C = a[m], n = m + 1, x = a[n];
            if (0 > g(C, c)) n < e && 0 > g(x, C) ? (a[d] = x, a[n] = c, d = n) : (a[d] = C, a[m] = c, d = m);
            else if (n < e && 0 > g(x, c)) a[d] = x, a[n] = c, d = n;
            else break a;
          }
        }
        return b;
      }
      function g(a, b) {
        var c = a.sortIndex - b.sortIndex;
        return 0 !== c ? c : a.id - b.id;
      }
      if ("object" === typeof performance && "function" === typeof performance.now) {
        l = performance;
        exports.unstable_now = function() {
          return l.now();
        };
      } else {
        p = Date, q = p.now();
        exports.unstable_now = function() {
          return p.now() - q;
        };
      }
      var l;
      var p;
      var q;
      var r = [];
      var t = [];
      var u = 1;
      var v = null;
      var y = 3;
      var z = false;
      var A = false;
      var B = false;
      var D = "function" === typeof setTimeout ? setTimeout : null;
      var E = "function" === typeof clearTimeout ? clearTimeout : null;
      var F = "undefined" !== typeof setImmediate ? setImmediate : null;
      "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
      function G(a) {
        for (var b = h(t); null !== b; ) {
          if (null === b.callback) k(t);
          else if (b.startTime <= a) k(t), b.sortIndex = b.expirationTime, f(r, b);
          else break;
          b = h(t);
        }
      }
      function H(a) {
        B = false;
        G(a);
        if (!A) if (null !== h(r)) A = true, I(J);
        else {
          var b = h(t);
          null !== b && K(H, b.startTime - a);
        }
      }
      function J(a, b) {
        A = false;
        B && (B = false, E(L), L = -1);
        z = true;
        var c = y;
        try {
          G(b);
          for (v = h(r); null !== v && (!(v.expirationTime > b) || a && !M()); ) {
            var d = v.callback;
            if ("function" === typeof d) {
              v.callback = null;
              y = v.priorityLevel;
              var e = d(v.expirationTime <= b);
              b = exports.unstable_now();
              "function" === typeof e ? v.callback = e : v === h(r) && k(r);
              G(b);
            } else k(r);
            v = h(r);
          }
          if (null !== v) var w = true;
          else {
            var m = h(t);
            null !== m && K(H, m.startTime - b);
            w = false;
          }
          return w;
        } finally {
          v = null, y = c, z = false;
        }
      }
      var N = false;
      var O = null;
      var L = -1;
      var P = 5;
      var Q = -1;
      function M() {
        return exports.unstable_now() - Q < P ? false : true;
      }
      function R() {
        if (null !== O) {
          var a = exports.unstable_now();
          Q = a;
          var b = true;
          try {
            b = O(true, a);
          } finally {
            b ? S() : (N = false, O = null);
          }
        } else N = false;
      }
      var S;
      if ("function" === typeof F) S = function() {
        F(R);
      };
      else if ("undefined" !== typeof MessageChannel) {
        T = new MessageChannel(), U = T.port2;
        T.port1.onmessage = R;
        S = function() {
          U.postMessage(null);
        };
      } else S = function() {
        D(R, 0);
      };
      var T;
      var U;
      function I(a) {
        O = a;
        N || (N = true, S());
      }
      function K(a, b) {
        L = D(function() {
          a(exports.unstable_now());
        }, b);
      }
      exports.unstable_IdlePriority = 5;
      exports.unstable_ImmediatePriority = 1;
      exports.unstable_LowPriority = 4;
      exports.unstable_NormalPriority = 3;
      exports.unstable_Profiling = null;
      exports.unstable_UserBlockingPriority = 2;
      exports.unstable_cancelCallback = function(a) {
        a.callback = null;
      };
      exports.unstable_continueExecution = function() {
        A || z || (A = true, I(J));
      };
      exports.unstable_forceFrameRate = function(a) {
        0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P = 0 < a ? Math.floor(1e3 / a) : 5;
      };
      exports.unstable_getCurrentPriorityLevel = function() {
        return y;
      };
      exports.unstable_getFirstCallbackNode = function() {
        return h(r);
      };
      exports.unstable_next = function(a) {
        switch (y) {
          case 1:
          case 2:
          case 3:
            var b = 3;
            break;
          default:
            b = y;
        }
        var c = y;
        y = b;
        try {
          return a();
        } finally {
          y = c;
        }
      };
      exports.unstable_pauseExecution = function() {
      };
      exports.unstable_requestPaint = function() {
      };
      exports.unstable_runWithPriority = function(a, b) {
        switch (a) {
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
            break;
          default:
            a = 3;
        }
        var c = y;
        y = a;
        try {
          return b();
        } finally {
          y = c;
        }
      };
      exports.unstable_scheduleCallback = function(a, b, c) {
        var d = exports.unstable_now();
        "object" === typeof c && null !== c ? (c = c.delay, c = "number" === typeof c && 0 < c ? d + c : d) : c = d;
        switch (a) {
          case 1:
            var e = -1;
            break;
          case 2:
            e = 250;
            break;
          case 5:
            e = 1073741823;
            break;
          case 4:
            e = 1e4;
            break;
          default:
            e = 5e3;
        }
        e = c + e;
        a = { id: u++, callback: b, priorityLevel: a, startTime: c, expirationTime: e, sortIndex: -1 };
        c > d ? (a.sortIndex = c, f(t, a), null === h(r) && a === h(t) && (B ? (E(L), L = -1) : B = true, K(H, c - d))) : (a.sortIndex = e, f(r, a), A || z || (A = true, I(J)));
        return a;
      };
      exports.unstable_shouldYield = M;
      exports.unstable_wrapCallback = function(a) {
        var b = y;
        return function() {
          var c = y;
          y = b;
          try {
            return a.apply(this, arguments);
          } finally {
            y = c;
          }
        };
      };
    }
  });

  // node_modules/scheduler/index.js
  var require_scheduler = __commonJS({
    "node_modules/scheduler/index.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      if (true) {
        module.exports = require_scheduler_production_min();
      } else {
        module.exports = null;
      }
    }
  });

  // node_modules/react-dom/cjs/react-dom.production.min.js
  var require_react_dom_production_min = __commonJS({
    "node_modules/react-dom/cjs/react-dom.production.min.js"(exports) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var aa = require_react();
      var ca = require_scheduler();
      function p(a) {
        for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++) b += "&args[]=" + encodeURIComponent(arguments[c]);
        return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
      }
      var da = /* @__PURE__ */ new Set();
      var ea = {};
      function fa(a, b) {
        ha(a, b);
        ha(a + "Capture", b);
      }
      function ha(a, b) {
        ea[a] = b;
        for (a = 0; a < b.length; a++) da.add(b[a]);
      }
      var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement);
      var ja = Object.prototype.hasOwnProperty;
      var ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/;
      var la = {};
      var ma = {};
      function oa(a) {
        if (ja.call(ma, a)) return true;
        if (ja.call(la, a)) return false;
        if (ka.test(a)) return ma[a] = true;
        la[a] = true;
        return false;
      }
      function pa(a, b, c, d) {
        if (null !== c && 0 === c.type) return false;
        switch (typeof b) {
          case "function":
          case "symbol":
            return true;
          case "boolean":
            if (d) return false;
            if (null !== c) return !c.acceptsBooleans;
            a = a.toLowerCase().slice(0, 5);
            return "data-" !== a && "aria-" !== a;
          default:
            return false;
        }
      }
      function qa(a, b, c, d) {
        if (null === b || "undefined" === typeof b || pa(a, b, c, d)) return true;
        if (d) return false;
        if (null !== c) switch (c.type) {
          case 3:
            return !b;
          case 4:
            return false === b;
          case 5:
            return isNaN(b);
          case 6:
            return isNaN(b) || 1 > b;
        }
        return false;
      }
      function v(a, b, c, d, e, f, g) {
        this.acceptsBooleans = 2 === b || 3 === b || 4 === b;
        this.attributeName = d;
        this.attributeNamespace = e;
        this.mustUseProperty = c;
        this.propertyName = a;
        this.type = b;
        this.sanitizeURL = f;
        this.removeEmptyString = g;
      }
      var z = {};
      "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a) {
        z[a] = new v(a, 0, false, a, null, false, false);
      });
      [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a) {
        var b = a[0];
        z[b] = new v(b, 1, false, a[1], null, false, false);
      });
      ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a) {
        z[a] = new v(a, 2, false, a.toLowerCase(), null, false, false);
      });
      ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a) {
        z[a] = new v(a, 2, false, a, null, false, false);
      });
      "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a) {
        z[a] = new v(a, 3, false, a.toLowerCase(), null, false, false);
      });
      ["checked", "multiple", "muted", "selected"].forEach(function(a) {
        z[a] = new v(a, 3, true, a, null, false, false);
      });
      ["capture", "download"].forEach(function(a) {
        z[a] = new v(a, 4, false, a, null, false, false);
      });
      ["cols", "rows", "size", "span"].forEach(function(a) {
        z[a] = new v(a, 6, false, a, null, false, false);
      });
      ["rowSpan", "start"].forEach(function(a) {
        z[a] = new v(a, 5, false, a.toLowerCase(), null, false, false);
      });
      var ra = /[\-:]([a-z])/g;
      function sa(a) {
        return a[1].toUpperCase();
      }
      "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a) {
        var b = a.replace(
          ra,
          sa
        );
        z[b] = new v(b, 1, false, a, null, false, false);
      });
      "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a) {
        var b = a.replace(ra, sa);
        z[b] = new v(b, 1, false, a, "http://www.w3.org/1999/xlink", false, false);
      });
      ["xml:base", "xml:lang", "xml:space"].forEach(function(a) {
        var b = a.replace(ra, sa);
        z[b] = new v(b, 1, false, a, "http://www.w3.org/XML/1998/namespace", false, false);
      });
      ["tabIndex", "crossOrigin"].forEach(function(a) {
        z[a] = new v(a, 1, false, a.toLowerCase(), null, false, false);
      });
      z.xlinkHref = new v("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
      ["src", "href", "action", "formAction"].forEach(function(a) {
        z[a] = new v(a, 1, false, a.toLowerCase(), null, true, true);
      });
      function ta(a, b, c, d) {
        var e = z.hasOwnProperty(b) ? z[b] : null;
        if (null !== e ? 0 !== e.type : d || !(2 < b.length) || "o" !== b[0] && "O" !== b[0] || "n" !== b[1] && "N" !== b[1]) qa(b, c, e, d) && (c = null), d || null === e ? oa(b) && (null === c ? a.removeAttribute(b) : a.setAttribute(b, "" + c)) : e.mustUseProperty ? a[e.propertyName] = null === c ? 3 === e.type ? false : "" : c : (b = e.attributeName, d = e.attributeNamespace, null === c ? a.removeAttribute(b) : (e = e.type, c = 3 === e || 4 === e && true === c ? "" : "" + c, d ? a.setAttributeNS(d, b, c) : a.setAttribute(b, c)));
      }
      var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      var va = Symbol.for("react.element");
      var wa = Symbol.for("react.portal");
      var ya = Symbol.for("react.fragment");
      var za = Symbol.for("react.strict_mode");
      var Aa = Symbol.for("react.profiler");
      var Ba = Symbol.for("react.provider");
      var Ca = Symbol.for("react.context");
      var Da = Symbol.for("react.forward_ref");
      var Ea = Symbol.for("react.suspense");
      var Fa = Symbol.for("react.suspense_list");
      var Ga = Symbol.for("react.memo");
      var Ha = Symbol.for("react.lazy");
      Symbol.for("react.scope");
      Symbol.for("react.debug_trace_mode");
      var Ia = Symbol.for("react.offscreen");
      Symbol.for("react.legacy_hidden");
      Symbol.for("react.cache");
      Symbol.for("react.tracing_marker");
      var Ja = Symbol.iterator;
      function Ka(a) {
        if (null === a || "object" !== typeof a) return null;
        a = Ja && a[Ja] || a["@@iterator"];
        return "function" === typeof a ? a : null;
      }
      var A = Object.assign;
      var La;
      function Ma(a) {
        if (void 0 === La) try {
          throw Error();
        } catch (c) {
          var b = c.stack.trim().match(/\n( *(at )?)/);
          La = b && b[1] || "";
        }
        return "\n" + La + a;
      }
      var Na = false;
      function Oa(a, b) {
        if (!a || Na) return "";
        Na = true;
        var c = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        try {
          if (b) if (b = function() {
            throw Error();
          }, Object.defineProperty(b.prototype, "props", { set: function() {
            throw Error();
          } }), "object" === typeof Reflect && Reflect.construct) {
            try {
              Reflect.construct(b, []);
            } catch (l) {
              var d = l;
            }
            Reflect.construct(a, [], b);
          } else {
            try {
              b.call();
            } catch (l) {
              d = l;
            }
            a.call(b.prototype);
          }
          else {
            try {
              throw Error();
            } catch (l) {
              d = l;
            }
            a();
          }
        } catch (l) {
          if (l && d && "string" === typeof l.stack) {
            for (var e = l.stack.split("\n"), f = d.stack.split("\n"), g = e.length - 1, h = f.length - 1; 1 <= g && 0 <= h && e[g] !== f[h]; ) h--;
            for (; 1 <= g && 0 <= h; g--, h--) if (e[g] !== f[h]) {
              if (1 !== g || 1 !== h) {
                do
                  if (g--, h--, 0 > h || e[g] !== f[h]) {
                    var k = "\n" + e[g].replace(" at new ", " at ");
                    a.displayName && k.includes("<anonymous>") && (k = k.replace("<anonymous>", a.displayName));
                    return k;
                  }
                while (1 <= g && 0 <= h);
              }
              break;
            }
          }
        } finally {
          Na = false, Error.prepareStackTrace = c;
        }
        return (a = a ? a.displayName || a.name : "") ? Ma(a) : "";
      }
      function Pa(a) {
        switch (a.tag) {
          case 5:
            return Ma(a.type);
          case 16:
            return Ma("Lazy");
          case 13:
            return Ma("Suspense");
          case 19:
            return Ma("SuspenseList");
          case 0:
          case 2:
          case 15:
            return a = Oa(a.type, false), a;
          case 11:
            return a = Oa(a.type.render, false), a;
          case 1:
            return a = Oa(a.type, true), a;
          default:
            return "";
        }
      }
      function Qa(a) {
        if (null == a) return null;
        if ("function" === typeof a) return a.displayName || a.name || null;
        if ("string" === typeof a) return a;
        switch (a) {
          case ya:
            return "Fragment";
          case wa:
            return "Portal";
          case Aa:
            return "Profiler";
          case za:
            return "StrictMode";
          case Ea:
            return "Suspense";
          case Fa:
            return "SuspenseList";
        }
        if ("object" === typeof a) switch (a.$$typeof) {
          case Ca:
            return (a.displayName || "Context") + ".Consumer";
          case Ba:
            return (a._context.displayName || "Context") + ".Provider";
          case Da:
            var b = a.render;
            a = a.displayName;
            a || (a = b.displayName || b.name || "", a = "" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
            return a;
          case Ga:
            return b = a.displayName || null, null !== b ? b : Qa(a.type) || "Memo";
          case Ha:
            b = a._payload;
            a = a._init;
            try {
              return Qa(a(b));
            } catch (c) {
            }
        }
        return null;
      }
      function Ra(a) {
        var b = a.type;
        switch (a.tag) {
          case 24:
            return "Cache";
          case 9:
            return (b.displayName || "Context") + ".Consumer";
          case 10:
            return (b._context.displayName || "Context") + ".Provider";
          case 18:
            return "DehydratedFragment";
          case 11:
            return a = b.render, a = a.displayName || a.name || "", b.displayName || ("" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
          case 7:
            return "Fragment";
          case 5:
            return b;
          case 4:
            return "Portal";
          case 3:
            return "Root";
          case 6:
            return "Text";
          case 16:
            return Qa(b);
          case 8:
            return b === za ? "StrictMode" : "Mode";
          case 22:
            return "Offscreen";
          case 12:
            return "Profiler";
          case 21:
            return "Scope";
          case 13:
            return "Suspense";
          case 19:
            return "SuspenseList";
          case 25:
            return "TracingMarker";
          case 1:
          case 0:
          case 17:
          case 2:
          case 14:
          case 15:
            if ("function" === typeof b) return b.displayName || b.name || null;
            if ("string" === typeof b) return b;
        }
        return null;
      }
      function Sa(a) {
        switch (typeof a) {
          case "boolean":
          case "number":
          case "string":
          case "undefined":
            return a;
          case "object":
            return a;
          default:
            return "";
        }
      }
      function Ta(a) {
        var b = a.type;
        return (a = a.nodeName) && "input" === a.toLowerCase() && ("checkbox" === b || "radio" === b);
      }
      function Ua(a) {
        var b = Ta(a) ? "checked" : "value", c = Object.getOwnPropertyDescriptor(a.constructor.prototype, b), d = "" + a[b];
        if (!a.hasOwnProperty(b) && "undefined" !== typeof c && "function" === typeof c.get && "function" === typeof c.set) {
          var e = c.get, f = c.set;
          Object.defineProperty(a, b, { configurable: true, get: function() {
            return e.call(this);
          }, set: function(a2) {
            d = "" + a2;
            f.call(this, a2);
          } });
          Object.defineProperty(a, b, { enumerable: c.enumerable });
          return { getValue: function() {
            return d;
          }, setValue: function(a2) {
            d = "" + a2;
          }, stopTracking: function() {
            a._valueTracker = null;
            delete a[b];
          } };
        }
      }
      function Va(a) {
        a._valueTracker || (a._valueTracker = Ua(a));
      }
      function Wa(a) {
        if (!a) return false;
        var b = a._valueTracker;
        if (!b) return true;
        var c = b.getValue();
        var d = "";
        a && (d = Ta(a) ? a.checked ? "true" : "false" : a.value);
        a = d;
        return a !== c ? (b.setValue(a), true) : false;
      }
      function Xa(a) {
        a = a || ("undefined" !== typeof document ? document : void 0);
        if ("undefined" === typeof a) return null;
        try {
          return a.activeElement || a.body;
        } catch (b) {
          return a.body;
        }
      }
      function Ya(a, b) {
        var c = b.checked;
        return A({}, b, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c ? c : a._wrapperState.initialChecked });
      }
      function Za(a, b) {
        var c = null == b.defaultValue ? "" : b.defaultValue, d = null != b.checked ? b.checked : b.defaultChecked;
        c = Sa(null != b.value ? b.value : c);
        a._wrapperState = { initialChecked: d, initialValue: c, controlled: "checkbox" === b.type || "radio" === b.type ? null != b.checked : null != b.value };
      }
      function ab(a, b) {
        b = b.checked;
        null != b && ta(a, "checked", b, false);
      }
      function bb(a, b) {
        ab(a, b);
        var c = Sa(b.value), d = b.type;
        if (null != c) if ("number" === d) {
          if (0 === c && "" === a.value || a.value != c) a.value = "" + c;
        } else a.value !== "" + c && (a.value = "" + c);
        else if ("submit" === d || "reset" === d) {
          a.removeAttribute("value");
          return;
        }
        b.hasOwnProperty("value") ? cb(a, b.type, c) : b.hasOwnProperty("defaultValue") && cb(a, b.type, Sa(b.defaultValue));
        null == b.checked && null != b.defaultChecked && (a.defaultChecked = !!b.defaultChecked);
      }
      function db(a, b, c) {
        if (b.hasOwnProperty("value") || b.hasOwnProperty("defaultValue")) {
          var d = b.type;
          if (!("submit" !== d && "reset" !== d || void 0 !== b.value && null !== b.value)) return;
          b = "" + a._wrapperState.initialValue;
          c || b === a.value || (a.value = b);
          a.defaultValue = b;
        }
        c = a.name;
        "" !== c && (a.name = "");
        a.defaultChecked = !!a._wrapperState.initialChecked;
        "" !== c && (a.name = c);
      }
      function cb(a, b, c) {
        if ("number" !== b || Xa(a.ownerDocument) !== a) null == c ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + c && (a.defaultValue = "" + c);
      }
      var eb = Array.isArray;
      function fb(a, b, c, d) {
        a = a.options;
        if (b) {
          b = {};
          for (var e = 0; e < c.length; e++) b["$" + c[e]] = true;
          for (c = 0; c < a.length; c++) e = b.hasOwnProperty("$" + a[c].value), a[c].selected !== e && (a[c].selected = e), e && d && (a[c].defaultSelected = true);
        } else {
          c = "" + Sa(c);
          b = null;
          for (e = 0; e < a.length; e++) {
            if (a[e].value === c) {
              a[e].selected = true;
              d && (a[e].defaultSelected = true);
              return;
            }
            null !== b || a[e].disabled || (b = a[e]);
          }
          null !== b && (b.selected = true);
        }
      }
      function gb(a, b) {
        if (null != b.dangerouslySetInnerHTML) throw Error(p(91));
        return A({}, b, { value: void 0, defaultValue: void 0, children: "" + a._wrapperState.initialValue });
      }
      function hb(a, b) {
        var c = b.value;
        if (null == c) {
          c = b.children;
          b = b.defaultValue;
          if (null != c) {
            if (null != b) throw Error(p(92));
            if (eb(c)) {
              if (1 < c.length) throw Error(p(93));
              c = c[0];
            }
            b = c;
          }
          null == b && (b = "");
          c = b;
        }
        a._wrapperState = { initialValue: Sa(c) };
      }
      function ib(a, b) {
        var c = Sa(b.value), d = Sa(b.defaultValue);
        null != c && (c = "" + c, c !== a.value && (a.value = c), null == b.defaultValue && a.defaultValue !== c && (a.defaultValue = c));
        null != d && (a.defaultValue = "" + d);
      }
      function jb(a) {
        var b = a.textContent;
        b === a._wrapperState.initialValue && "" !== b && null !== b && (a.value = b);
      }
      function kb(a) {
        switch (a) {
          case "svg":
            return "http://www.w3.org/2000/svg";
          case "math":
            return "http://www.w3.org/1998/Math/MathML";
          default:
            return "http://www.w3.org/1999/xhtml";
        }
      }
      function lb(a, b) {
        return null == a || "http://www.w3.org/1999/xhtml" === a ? kb(b) : "http://www.w3.org/2000/svg" === a && "foreignObject" === b ? "http://www.w3.org/1999/xhtml" : a;
      }
      var mb;
      var nb = function(a) {
        return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b, c, d, e) {
          MSApp.execUnsafeLocalFunction(function() {
            return a(b, c, d, e);
          });
        } : a;
      }(function(a, b) {
        if ("http://www.w3.org/2000/svg" !== a.namespaceURI || "innerHTML" in a) a.innerHTML = b;
        else {
          mb = mb || document.createElement("div");
          mb.innerHTML = "<svg>" + b.valueOf().toString() + "</svg>";
          for (b = mb.firstChild; a.firstChild; ) a.removeChild(a.firstChild);
          for (; b.firstChild; ) a.appendChild(b.firstChild);
        }
      });
      function ob(a, b) {
        if (b) {
          var c = a.firstChild;
          if (c && c === a.lastChild && 3 === c.nodeType) {
            c.nodeValue = b;
            return;
          }
        }
        a.textContent = b;
      }
      var pb = {
        animationIterationCount: true,
        aspectRatio: true,
        borderImageOutset: true,
        borderImageSlice: true,
        borderImageWidth: true,
        boxFlex: true,
        boxFlexGroup: true,
        boxOrdinalGroup: true,
        columnCount: true,
        columns: true,
        flex: true,
        flexGrow: true,
        flexPositive: true,
        flexShrink: true,
        flexNegative: true,
        flexOrder: true,
        gridArea: true,
        gridRow: true,
        gridRowEnd: true,
        gridRowSpan: true,
        gridRowStart: true,
        gridColumn: true,
        gridColumnEnd: true,
        gridColumnSpan: true,
        gridColumnStart: true,
        fontWeight: true,
        lineClamp: true,
        lineHeight: true,
        opacity: true,
        order: true,
        orphans: true,
        tabSize: true,
        widows: true,
        zIndex: true,
        zoom: true,
        fillOpacity: true,
        floodOpacity: true,
        stopOpacity: true,
        strokeDasharray: true,
        strokeDashoffset: true,
        strokeMiterlimit: true,
        strokeOpacity: true,
        strokeWidth: true
      };
      var qb = ["Webkit", "ms", "Moz", "O"];
      Object.keys(pb).forEach(function(a) {
        qb.forEach(function(b) {
          b = b + a.charAt(0).toUpperCase() + a.substring(1);
          pb[b] = pb[a];
        });
      });
      function rb(a, b, c) {
        return null == b || "boolean" === typeof b || "" === b ? "" : c || "number" !== typeof b || 0 === b || pb.hasOwnProperty(a) && pb[a] ? ("" + b).trim() : b + "px";
      }
      function sb(a, b) {
        a = a.style;
        for (var c in b) if (b.hasOwnProperty(c)) {
          var d = 0 === c.indexOf("--"), e = rb(c, b[c], d);
          "float" === c && (c = "cssFloat");
          d ? a.setProperty(c, e) : a[c] = e;
        }
      }
      var tb = A({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
      function ub(a, b) {
        if (b) {
          if (tb[a] && (null != b.children || null != b.dangerouslySetInnerHTML)) throw Error(p(137, a));
          if (null != b.dangerouslySetInnerHTML) {
            if (null != b.children) throw Error(p(60));
            if ("object" !== typeof b.dangerouslySetInnerHTML || !("__html" in b.dangerouslySetInnerHTML)) throw Error(p(61));
          }
          if (null != b.style && "object" !== typeof b.style) throw Error(p(62));
        }
      }
      function vb(a, b) {
        if (-1 === a.indexOf("-")) return "string" === typeof b.is;
        switch (a) {
          case "annotation-xml":
          case "color-profile":
          case "font-face":
          case "font-face-src":
          case "font-face-uri":
          case "font-face-format":
          case "font-face-name":
          case "missing-glyph":
            return false;
          default:
            return true;
        }
      }
      var wb = null;
      function xb(a) {
        a = a.target || a.srcElement || window;
        a.correspondingUseElement && (a = a.correspondingUseElement);
        return 3 === a.nodeType ? a.parentNode : a;
      }
      var yb = null;
      var zb = null;
      var Ab = null;
      function Bb(a) {
        if (a = Cb(a)) {
          if ("function" !== typeof yb) throw Error(p(280));
          var b = a.stateNode;
          b && (b = Db(b), yb(a.stateNode, a.type, b));
        }
      }
      function Eb(a) {
        zb ? Ab ? Ab.push(a) : Ab = [a] : zb = a;
      }
      function Fb() {
        if (zb) {
          var a = zb, b = Ab;
          Ab = zb = null;
          Bb(a);
          if (b) for (a = 0; a < b.length; a++) Bb(b[a]);
        }
      }
      function Gb(a, b) {
        return a(b);
      }
      function Hb() {
      }
      var Ib = false;
      function Jb(a, b, c) {
        if (Ib) return a(b, c);
        Ib = true;
        try {
          return Gb(a, b, c);
        } finally {
          if (Ib = false, null !== zb || null !== Ab) Hb(), Fb();
        }
      }
      function Kb(a, b) {
        var c = a.stateNode;
        if (null === c) return null;
        var d = Db(c);
        if (null === d) return null;
        c = d[b];
        a: switch (b) {
          case "onClick":
          case "onClickCapture":
          case "onDoubleClick":
          case "onDoubleClickCapture":
          case "onMouseDown":
          case "onMouseDownCapture":
          case "onMouseMove":
          case "onMouseMoveCapture":
          case "onMouseUp":
          case "onMouseUpCapture":
          case "onMouseEnter":
            (d = !d.disabled) || (a = a.type, d = !("button" === a || "input" === a || "select" === a || "textarea" === a));
            a = !d;
            break a;
          default:
            a = false;
        }
        if (a) return null;
        if (c && "function" !== typeof c) throw Error(p(231, b, typeof c));
        return c;
      }
      var Lb = false;
      if (ia) try {
        Mb = {};
        Object.defineProperty(Mb, "passive", { get: function() {
          Lb = true;
        } });
        window.addEventListener("test", Mb, Mb);
        window.removeEventListener("test", Mb, Mb);
      } catch (a) {
        Lb = false;
      }
      var Mb;
      function Nb(a, b, c, d, e, f, g, h, k) {
        var l = Array.prototype.slice.call(arguments, 3);
        try {
          b.apply(c, l);
        } catch (m) {
          this.onError(m);
        }
      }
      var Ob = false;
      var Pb = null;
      var Qb = false;
      var Rb = null;
      var Sb = { onError: function(a) {
        Ob = true;
        Pb = a;
      } };
      function Tb(a, b, c, d, e, f, g, h, k) {
        Ob = false;
        Pb = null;
        Nb.apply(Sb, arguments);
      }
      function Ub(a, b, c, d, e, f, g, h, k) {
        Tb.apply(this, arguments);
        if (Ob) {
          if (Ob) {
            var l = Pb;
            Ob = false;
            Pb = null;
          } else throw Error(p(198));
          Qb || (Qb = true, Rb = l);
        }
      }
      function Vb(a) {
        var b = a, c = a;
        if (a.alternate) for (; b.return; ) b = b.return;
        else {
          a = b;
          do
            b = a, 0 !== (b.flags & 4098) && (c = b.return), a = b.return;
          while (a);
        }
        return 3 === b.tag ? c : null;
      }
      function Wb(a) {
        if (13 === a.tag) {
          var b = a.memoizedState;
          null === b && (a = a.alternate, null !== a && (b = a.memoizedState));
          if (null !== b) return b.dehydrated;
        }
        return null;
      }
      function Xb(a) {
        if (Vb(a) !== a) throw Error(p(188));
      }
      function Yb(a) {
        var b = a.alternate;
        if (!b) {
          b = Vb(a);
          if (null === b) throw Error(p(188));
          return b !== a ? null : a;
        }
        for (var c = a, d = b; ; ) {
          var e = c.return;
          if (null === e) break;
          var f = e.alternate;
          if (null === f) {
            d = e.return;
            if (null !== d) {
              c = d;
              continue;
            }
            break;
          }
          if (e.child === f.child) {
            for (f = e.child; f; ) {
              if (f === c) return Xb(e), a;
              if (f === d) return Xb(e), b;
              f = f.sibling;
            }
            throw Error(p(188));
          }
          if (c.return !== d.return) c = e, d = f;
          else {
            for (var g = false, h = e.child; h; ) {
              if (h === c) {
                g = true;
                c = e;
                d = f;
                break;
              }
              if (h === d) {
                g = true;
                d = e;
                c = f;
                break;
              }
              h = h.sibling;
            }
            if (!g) {
              for (h = f.child; h; ) {
                if (h === c) {
                  g = true;
                  c = f;
                  d = e;
                  break;
                }
                if (h === d) {
                  g = true;
                  d = f;
                  c = e;
                  break;
                }
                h = h.sibling;
              }
              if (!g) throw Error(p(189));
            }
          }
          if (c.alternate !== d) throw Error(p(190));
        }
        if (3 !== c.tag) throw Error(p(188));
        return c.stateNode.current === c ? a : b;
      }
      function Zb(a) {
        a = Yb(a);
        return null !== a ? $b(a) : null;
      }
      function $b(a) {
        if (5 === a.tag || 6 === a.tag) return a;
        for (a = a.child; null !== a; ) {
          var b = $b(a);
          if (null !== b) return b;
          a = a.sibling;
        }
        return null;
      }
      var ac = ca.unstable_scheduleCallback;
      var bc = ca.unstable_cancelCallback;
      var cc = ca.unstable_shouldYield;
      var dc = ca.unstable_requestPaint;
      var B = ca.unstable_now;
      var ec = ca.unstable_getCurrentPriorityLevel;
      var fc = ca.unstable_ImmediatePriority;
      var gc = ca.unstable_UserBlockingPriority;
      var hc = ca.unstable_NormalPriority;
      var ic = ca.unstable_LowPriority;
      var jc = ca.unstable_IdlePriority;
      var kc = null;
      var lc = null;
      function mc(a) {
        if (lc && "function" === typeof lc.onCommitFiberRoot) try {
          lc.onCommitFiberRoot(kc, a, void 0, 128 === (a.current.flags & 128));
        } catch (b) {
        }
      }
      var oc = Math.clz32 ? Math.clz32 : nc;
      var pc = Math.log;
      var qc = Math.LN2;
      function nc(a) {
        a >>>= 0;
        return 0 === a ? 32 : 31 - (pc(a) / qc | 0) | 0;
      }
      var rc = 64;
      var sc = 4194304;
      function tc(a) {
        switch (a & -a) {
          case 1:
            return 1;
          case 2:
            return 2;
          case 4:
            return 4;
          case 8:
            return 8;
          case 16:
            return 16;
          case 32:
            return 32;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
            return a & 4194240;
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            return a & 130023424;
          case 134217728:
            return 134217728;
          case 268435456:
            return 268435456;
          case 536870912:
            return 536870912;
          case 1073741824:
            return 1073741824;
          default:
            return a;
        }
      }
      function uc(a, b) {
        var c = a.pendingLanes;
        if (0 === c) return 0;
        var d = 0, e = a.suspendedLanes, f = a.pingedLanes, g = c & 268435455;
        if (0 !== g) {
          var h = g & ~e;
          0 !== h ? d = tc(h) : (f &= g, 0 !== f && (d = tc(f)));
        } else g = c & ~e, 0 !== g ? d = tc(g) : 0 !== f && (d = tc(f));
        if (0 === d) return 0;
        if (0 !== b && b !== d && 0 === (b & e) && (e = d & -d, f = b & -b, e >= f || 16 === e && 0 !== (f & 4194240))) return b;
        0 !== (d & 4) && (d |= c & 16);
        b = a.entangledLanes;
        if (0 !== b) for (a = a.entanglements, b &= d; 0 < b; ) c = 31 - oc(b), e = 1 << c, d |= a[c], b &= ~e;
        return d;
      }
      function vc(a, b) {
        switch (a) {
          case 1:
          case 2:
          case 4:
            return b + 250;
          case 8:
          case 16:
          case 32:
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
            return b + 5e3;
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            return -1;
          case 134217728:
          case 268435456:
          case 536870912:
          case 1073741824:
            return -1;
          default:
            return -1;
        }
      }
      function wc(a, b) {
        for (var c = a.suspendedLanes, d = a.pingedLanes, e = a.expirationTimes, f = a.pendingLanes; 0 < f; ) {
          var g = 31 - oc(f), h = 1 << g, k = e[g];
          if (-1 === k) {
            if (0 === (h & c) || 0 !== (h & d)) e[g] = vc(h, b);
          } else k <= b && (a.expiredLanes |= h);
          f &= ~h;
        }
      }
      function xc(a) {
        a = a.pendingLanes & -1073741825;
        return 0 !== a ? a : a & 1073741824 ? 1073741824 : 0;
      }
      function yc() {
        var a = rc;
        rc <<= 1;
        0 === (rc & 4194240) && (rc = 64);
        return a;
      }
      function zc(a) {
        for (var b = [], c = 0; 31 > c; c++) b.push(a);
        return b;
      }
      function Ac(a, b, c) {
        a.pendingLanes |= b;
        536870912 !== b && (a.suspendedLanes = 0, a.pingedLanes = 0);
        a = a.eventTimes;
        b = 31 - oc(b);
        a[b] = c;
      }
      function Bc(a, b) {
        var c = a.pendingLanes & ~b;
        a.pendingLanes = b;
        a.suspendedLanes = 0;
        a.pingedLanes = 0;
        a.expiredLanes &= b;
        a.mutableReadLanes &= b;
        a.entangledLanes &= b;
        b = a.entanglements;
        var d = a.eventTimes;
        for (a = a.expirationTimes; 0 < c; ) {
          var e = 31 - oc(c), f = 1 << e;
          b[e] = 0;
          d[e] = -1;
          a[e] = -1;
          c &= ~f;
        }
      }
      function Cc(a, b) {
        var c = a.entangledLanes |= b;
        for (a = a.entanglements; c; ) {
          var d = 31 - oc(c), e = 1 << d;
          e & b | a[d] & b && (a[d] |= b);
          c &= ~e;
        }
      }
      var C = 0;
      function Dc(a) {
        a &= -a;
        return 1 < a ? 4 < a ? 0 !== (a & 268435455) ? 16 : 536870912 : 4 : 1;
      }
      var Ec;
      var Fc;
      var Gc;
      var Hc;
      var Ic;
      var Jc = false;
      var Kc = [];
      var Lc = null;
      var Mc = null;
      var Nc = null;
      var Oc = /* @__PURE__ */ new Map();
      var Pc = /* @__PURE__ */ new Map();
      var Qc = [];
      var Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
      function Sc(a, b) {
        switch (a) {
          case "focusin":
          case "focusout":
            Lc = null;
            break;
          case "dragenter":
          case "dragleave":
            Mc = null;
            break;
          case "mouseover":
          case "mouseout":
            Nc = null;
            break;
          case "pointerover":
          case "pointerout":
            Oc.delete(b.pointerId);
            break;
          case "gotpointercapture":
          case "lostpointercapture":
            Pc.delete(b.pointerId);
        }
      }
      function Tc(a, b, c, d, e, f) {
        if (null === a || a.nativeEvent !== f) return a = { blockedOn: b, domEventName: c, eventSystemFlags: d, nativeEvent: f, targetContainers: [e] }, null !== b && (b = Cb(b), null !== b && Fc(b)), a;
        a.eventSystemFlags |= d;
        b = a.targetContainers;
        null !== e && -1 === b.indexOf(e) && b.push(e);
        return a;
      }
      function Uc(a, b, c, d, e) {
        switch (b) {
          case "focusin":
            return Lc = Tc(Lc, a, b, c, d, e), true;
          case "dragenter":
            return Mc = Tc(Mc, a, b, c, d, e), true;
          case "mouseover":
            return Nc = Tc(Nc, a, b, c, d, e), true;
          case "pointerover":
            var f = e.pointerId;
            Oc.set(f, Tc(Oc.get(f) || null, a, b, c, d, e));
            return true;
          case "gotpointercapture":
            return f = e.pointerId, Pc.set(f, Tc(Pc.get(f) || null, a, b, c, d, e)), true;
        }
        return false;
      }
      function Vc(a) {
        var b = Wc(a.target);
        if (null !== b) {
          var c = Vb(b);
          if (null !== c) {
            if (b = c.tag, 13 === b) {
              if (b = Wb(c), null !== b) {
                a.blockedOn = b;
                Ic(a.priority, function() {
                  Gc(c);
                });
                return;
              }
            } else if (3 === b && c.stateNode.current.memoizedState.isDehydrated) {
              a.blockedOn = 3 === c.tag ? c.stateNode.containerInfo : null;
              return;
            }
          }
        }
        a.blockedOn = null;
      }
      function Xc(a) {
        if (null !== a.blockedOn) return false;
        for (var b = a.targetContainers; 0 < b.length; ) {
          var c = Yc(a.domEventName, a.eventSystemFlags, b[0], a.nativeEvent);
          if (null === c) {
            c = a.nativeEvent;
            var d = new c.constructor(c.type, c);
            wb = d;
            c.target.dispatchEvent(d);
            wb = null;
          } else return b = Cb(c), null !== b && Fc(b), a.blockedOn = c, false;
          b.shift();
        }
        return true;
      }
      function Zc(a, b, c) {
        Xc(a) && c.delete(b);
      }
      function $c() {
        Jc = false;
        null !== Lc && Xc(Lc) && (Lc = null);
        null !== Mc && Xc(Mc) && (Mc = null);
        null !== Nc && Xc(Nc) && (Nc = null);
        Oc.forEach(Zc);
        Pc.forEach(Zc);
      }
      function ad(a, b) {
        a.blockedOn === b && (a.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
      }
      function bd(a) {
        function b(b2) {
          return ad(b2, a);
        }
        if (0 < Kc.length) {
          ad(Kc[0], a);
          for (var c = 1; c < Kc.length; c++) {
            var d = Kc[c];
            d.blockedOn === a && (d.blockedOn = null);
          }
        }
        null !== Lc && ad(Lc, a);
        null !== Mc && ad(Mc, a);
        null !== Nc && ad(Nc, a);
        Oc.forEach(b);
        Pc.forEach(b);
        for (c = 0; c < Qc.length; c++) d = Qc[c], d.blockedOn === a && (d.blockedOn = null);
        for (; 0 < Qc.length && (c = Qc[0], null === c.blockedOn); ) Vc(c), null === c.blockedOn && Qc.shift();
      }
      var cd = ua.ReactCurrentBatchConfig;
      var dd = true;
      function ed(a, b, c, d) {
        var e = C, f = cd.transition;
        cd.transition = null;
        try {
          C = 1, fd(a, b, c, d);
        } finally {
          C = e, cd.transition = f;
        }
      }
      function gd(a, b, c, d) {
        var e = C, f = cd.transition;
        cd.transition = null;
        try {
          C = 4, fd(a, b, c, d);
        } finally {
          C = e, cd.transition = f;
        }
      }
      function fd(a, b, c, d) {
        if (dd) {
          var e = Yc(a, b, c, d);
          if (null === e) hd(a, b, d, id, c), Sc(a, d);
          else if (Uc(e, a, b, c, d)) d.stopPropagation();
          else if (Sc(a, d), b & 4 && -1 < Rc.indexOf(a)) {
            for (; null !== e; ) {
              var f = Cb(e);
              null !== f && Ec(f);
              f = Yc(a, b, c, d);
              null === f && hd(a, b, d, id, c);
              if (f === e) break;
              e = f;
            }
            null !== e && d.stopPropagation();
          } else hd(a, b, d, null, c);
        }
      }
      var id = null;
      function Yc(a, b, c, d) {
        id = null;
        a = xb(d);
        a = Wc(a);
        if (null !== a) if (b = Vb(a), null === b) a = null;
        else if (c = b.tag, 13 === c) {
          a = Wb(b);
          if (null !== a) return a;
          a = null;
        } else if (3 === c) {
          if (b.stateNode.current.memoizedState.isDehydrated) return 3 === b.tag ? b.stateNode.containerInfo : null;
          a = null;
        } else b !== a && (a = null);
        id = a;
        return null;
      }
      function jd(a) {
        switch (a) {
          case "cancel":
          case "click":
          case "close":
          case "contextmenu":
          case "copy":
          case "cut":
          case "auxclick":
          case "dblclick":
          case "dragend":
          case "dragstart":
          case "drop":
          case "focusin":
          case "focusout":
          case "input":
          case "invalid":
          case "keydown":
          case "keypress":
          case "keyup":
          case "mousedown":
          case "mouseup":
          case "paste":
          case "pause":
          case "play":
          case "pointercancel":
          case "pointerdown":
          case "pointerup":
          case "ratechange":
          case "reset":
          case "resize":
          case "seeked":
          case "submit":
          case "touchcancel":
          case "touchend":
          case "touchstart":
          case "volumechange":
          case "change":
          case "selectionchange":
          case "textInput":
          case "compositionstart":
          case "compositionend":
          case "compositionupdate":
          case "beforeblur":
          case "afterblur":
          case "beforeinput":
          case "blur":
          case "fullscreenchange":
          case "focus":
          case "hashchange":
          case "popstate":
          case "select":
          case "selectstart":
            return 1;
          case "drag":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "mousemove":
          case "mouseout":
          case "mouseover":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "scroll":
          case "toggle":
          case "touchmove":
          case "wheel":
          case "mouseenter":
          case "mouseleave":
          case "pointerenter":
          case "pointerleave":
            return 4;
          case "message":
            switch (ec()) {
              case fc:
                return 1;
              case gc:
                return 4;
              case hc:
              case ic:
                return 16;
              case jc:
                return 536870912;
              default:
                return 16;
            }
          default:
            return 16;
        }
      }
      var kd = null;
      var ld = null;
      var md = null;
      function nd() {
        if (md) return md;
        var a, b = ld, c = b.length, d, e = "value" in kd ? kd.value : kd.textContent, f = e.length;
        for (a = 0; a < c && b[a] === e[a]; a++) ;
        var g = c - a;
        for (d = 1; d <= g && b[c - d] === e[f - d]; d++) ;
        return md = e.slice(a, 1 < d ? 1 - d : void 0);
      }
      function od(a) {
        var b = a.keyCode;
        "charCode" in a ? (a = a.charCode, 0 === a && 13 === b && (a = 13)) : a = b;
        10 === a && (a = 13);
        return 32 <= a || 13 === a ? a : 0;
      }
      function pd() {
        return true;
      }
      function qd() {
        return false;
      }
      function rd(a) {
        function b(b2, d, e, f, g) {
          this._reactName = b2;
          this._targetInst = e;
          this.type = d;
          this.nativeEvent = f;
          this.target = g;
          this.currentTarget = null;
          for (var c in a) a.hasOwnProperty(c) && (b2 = a[c], this[c] = b2 ? b2(f) : f[c]);
          this.isDefaultPrevented = (null != f.defaultPrevented ? f.defaultPrevented : false === f.returnValue) ? pd : qd;
          this.isPropagationStopped = qd;
          return this;
        }
        A(b.prototype, { preventDefault: function() {
          this.defaultPrevented = true;
          var a2 = this.nativeEvent;
          a2 && (a2.preventDefault ? a2.preventDefault() : "unknown" !== typeof a2.returnValue && (a2.returnValue = false), this.isDefaultPrevented = pd);
        }, stopPropagation: function() {
          var a2 = this.nativeEvent;
          a2 && (a2.stopPropagation ? a2.stopPropagation() : "unknown" !== typeof a2.cancelBubble && (a2.cancelBubble = true), this.isPropagationStopped = pd);
        }, persist: function() {
        }, isPersistent: pd });
        return b;
      }
      var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a) {
        return a.timeStamp || Date.now();
      }, defaultPrevented: 0, isTrusted: 0 };
      var td = rd(sd);
      var ud = A({}, sd, { view: 0, detail: 0 });
      var vd = rd(ud);
      var wd;
      var xd;
      var yd;
      var Ad = A({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a) {
        return void 0 === a.relatedTarget ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
      }, movementX: function(a) {
        if ("movementX" in a) return a.movementX;
        a !== yd && (yd && "mousemove" === a.type ? (wd = a.screenX - yd.screenX, xd = a.screenY - yd.screenY) : xd = wd = 0, yd = a);
        return wd;
      }, movementY: function(a) {
        return "movementY" in a ? a.movementY : xd;
      } });
      var Bd = rd(Ad);
      var Cd = A({}, Ad, { dataTransfer: 0 });
      var Dd = rd(Cd);
      var Ed = A({}, ud, { relatedTarget: 0 });
      var Fd = rd(Ed);
      var Gd = A({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 });
      var Hd = rd(Gd);
      var Id = A({}, sd, { clipboardData: function(a) {
        return "clipboardData" in a ? a.clipboardData : window.clipboardData;
      } });
      var Jd = rd(Id);
      var Kd = A({}, sd, { data: 0 });
      var Ld = rd(Kd);
      var Md = {
        Esc: "Escape",
        Spacebar: " ",
        Left: "ArrowLeft",
        Up: "ArrowUp",
        Right: "ArrowRight",
        Down: "ArrowDown",
        Del: "Delete",
        Win: "OS",
        Menu: "ContextMenu",
        Apps: "ContextMenu",
        Scroll: "ScrollLock",
        MozPrintableKey: "Unidentified"
      };
      var Nd = {
        8: "Backspace",
        9: "Tab",
        12: "Clear",
        13: "Enter",
        16: "Shift",
        17: "Control",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Escape",
        32: " ",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "ArrowLeft",
        38: "ArrowUp",
        39: "ArrowRight",
        40: "ArrowDown",
        45: "Insert",
        46: "Delete",
        112: "F1",
        113: "F2",
        114: "F3",
        115: "F4",
        116: "F5",
        117: "F6",
        118: "F7",
        119: "F8",
        120: "F9",
        121: "F10",
        122: "F11",
        123: "F12",
        144: "NumLock",
        145: "ScrollLock",
        224: "Meta"
      };
      var Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
      function Pd(a) {
        var b = this.nativeEvent;
        return b.getModifierState ? b.getModifierState(a) : (a = Od[a]) ? !!b[a] : false;
      }
      function zd() {
        return Pd;
      }
      var Qd = A({}, ud, { key: function(a) {
        if (a.key) {
          var b = Md[a.key] || a.key;
          if ("Unidentified" !== b) return b;
        }
        return "keypress" === a.type ? (a = od(a), 13 === a ? "Enter" : String.fromCharCode(a)) : "keydown" === a.type || "keyup" === a.type ? Nd[a.keyCode] || "Unidentified" : "";
      }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a) {
        return "keypress" === a.type ? od(a) : 0;
      }, keyCode: function(a) {
        return "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
      }, which: function(a) {
        return "keypress" === a.type ? od(a) : "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
      } });
      var Rd = rd(Qd);
      var Sd = A({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 });
      var Td = rd(Sd);
      var Ud = A({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd });
      var Vd = rd(Ud);
      var Wd = A({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 });
      var Xd = rd(Wd);
      var Yd = A({}, Ad, {
        deltaX: function(a) {
          return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
        },
        deltaY: function(a) {
          return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
        },
        deltaZ: 0,
        deltaMode: 0
      });
      var Zd = rd(Yd);
      var $d = [9, 13, 27, 32];
      var ae = ia && "CompositionEvent" in window;
      var be = null;
      ia && "documentMode" in document && (be = document.documentMode);
      var ce = ia && "TextEvent" in window && !be;
      var de = ia && (!ae || be && 8 < be && 11 >= be);
      var ee = String.fromCharCode(32);
      var fe = false;
      function ge(a, b) {
        switch (a) {
          case "keyup":
            return -1 !== $d.indexOf(b.keyCode);
          case "keydown":
            return 229 !== b.keyCode;
          case "keypress":
          case "mousedown":
          case "focusout":
            return true;
          default:
            return false;
        }
      }
      function he(a) {
        a = a.detail;
        return "object" === typeof a && "data" in a ? a.data : null;
      }
      var ie = false;
      function je(a, b) {
        switch (a) {
          case "compositionend":
            return he(b);
          case "keypress":
            if (32 !== b.which) return null;
            fe = true;
            return ee;
          case "textInput":
            return a = b.data, a === ee && fe ? null : a;
          default:
            return null;
        }
      }
      function ke(a, b) {
        if (ie) return "compositionend" === a || !ae && ge(a, b) ? (a = nd(), md = ld = kd = null, ie = false, a) : null;
        switch (a) {
          case "paste":
            return null;
          case "keypress":
            if (!(b.ctrlKey || b.altKey || b.metaKey) || b.ctrlKey && b.altKey) {
              if (b.char && 1 < b.char.length) return b.char;
              if (b.which) return String.fromCharCode(b.which);
            }
            return null;
          case "compositionend":
            return de && "ko" !== b.locale ? null : b.data;
          default:
            return null;
        }
      }
      var le = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
      function me(a) {
        var b = a && a.nodeName && a.nodeName.toLowerCase();
        return "input" === b ? !!le[a.type] : "textarea" === b ? true : false;
      }
      function ne(a, b, c, d) {
        Eb(d);
        b = oe(b, "onChange");
        0 < b.length && (c = new td("onChange", "change", null, c, d), a.push({ event: c, listeners: b }));
      }
      var pe = null;
      var qe = null;
      function re(a) {
        se(a, 0);
      }
      function te(a) {
        var b = ue(a);
        if (Wa(b)) return a;
      }
      function ve(a, b) {
        if ("change" === a) return b;
      }
      var we = false;
      if (ia) {
        if (ia) {
          ye = "oninput" in document;
          if (!ye) {
            ze = document.createElement("div");
            ze.setAttribute("oninput", "return;");
            ye = "function" === typeof ze.oninput;
          }
          xe = ye;
        } else xe = false;
        we = xe && (!document.documentMode || 9 < document.documentMode);
      }
      var xe;
      var ye;
      var ze;
      function Ae() {
        pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
      }
      function Be(a) {
        if ("value" === a.propertyName && te(qe)) {
          var b = [];
          ne(b, qe, a, xb(a));
          Jb(re, b);
        }
      }
      function Ce(a, b, c) {
        "focusin" === a ? (Ae(), pe = b, qe = c, pe.attachEvent("onpropertychange", Be)) : "focusout" === a && Ae();
      }
      function De(a) {
        if ("selectionchange" === a || "keyup" === a || "keydown" === a) return te(qe);
      }
      function Ee(a, b) {
        if ("click" === a) return te(b);
      }
      function Fe(a, b) {
        if ("input" === a || "change" === a) return te(b);
      }
      function Ge(a, b) {
        return a === b && (0 !== a || 1 / a === 1 / b) || a !== a && b !== b;
      }
      var He = "function" === typeof Object.is ? Object.is : Ge;
      function Ie(a, b) {
        if (He(a, b)) return true;
        if ("object" !== typeof a || null === a || "object" !== typeof b || null === b) return false;
        var c = Object.keys(a), d = Object.keys(b);
        if (c.length !== d.length) return false;
        for (d = 0; d < c.length; d++) {
          var e = c[d];
          if (!ja.call(b, e) || !He(a[e], b[e])) return false;
        }
        return true;
      }
      function Je(a) {
        for (; a && a.firstChild; ) a = a.firstChild;
        return a;
      }
      function Ke(a, b) {
        var c = Je(a);
        a = 0;
        for (var d; c; ) {
          if (3 === c.nodeType) {
            d = a + c.textContent.length;
            if (a <= b && d >= b) return { node: c, offset: b - a };
            a = d;
          }
          a: {
            for (; c; ) {
              if (c.nextSibling) {
                c = c.nextSibling;
                break a;
              }
              c = c.parentNode;
            }
            c = void 0;
          }
          c = Je(c);
        }
      }
      function Le(a, b) {
        return a && b ? a === b ? true : a && 3 === a.nodeType ? false : b && 3 === b.nodeType ? Le(a, b.parentNode) : "contains" in a ? a.contains(b) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(b) & 16) : false : false;
      }
      function Me() {
        for (var a = window, b = Xa(); b instanceof a.HTMLIFrameElement; ) {
          try {
            var c = "string" === typeof b.contentWindow.location.href;
          } catch (d) {
            c = false;
          }
          if (c) a = b.contentWindow;
          else break;
          b = Xa(a.document);
        }
        return b;
      }
      function Ne(a) {
        var b = a && a.nodeName && a.nodeName.toLowerCase();
        return b && ("input" === b && ("text" === a.type || "search" === a.type || "tel" === a.type || "url" === a.type || "password" === a.type) || "textarea" === b || "true" === a.contentEditable);
      }
      function Oe(a) {
        var b = Me(), c = a.focusedElem, d = a.selectionRange;
        if (b !== c && c && c.ownerDocument && Le(c.ownerDocument.documentElement, c)) {
          if (null !== d && Ne(c)) {
            if (b = d.start, a = d.end, void 0 === a && (a = b), "selectionStart" in c) c.selectionStart = b, c.selectionEnd = Math.min(a, c.value.length);
            else if (a = (b = c.ownerDocument || document) && b.defaultView || window, a.getSelection) {
              a = a.getSelection();
              var e = c.textContent.length, f = Math.min(d.start, e);
              d = void 0 === d.end ? f : Math.min(d.end, e);
              !a.extend && f > d && (e = d, d = f, f = e);
              e = Ke(c, f);
              var g = Ke(
                c,
                d
              );
              e && g && (1 !== a.rangeCount || a.anchorNode !== e.node || a.anchorOffset !== e.offset || a.focusNode !== g.node || a.focusOffset !== g.offset) && (b = b.createRange(), b.setStart(e.node, e.offset), a.removeAllRanges(), f > d ? (a.addRange(b), a.extend(g.node, g.offset)) : (b.setEnd(g.node, g.offset), a.addRange(b)));
            }
          }
          b = [];
          for (a = c; a = a.parentNode; ) 1 === a.nodeType && b.push({ element: a, left: a.scrollLeft, top: a.scrollTop });
          "function" === typeof c.focus && c.focus();
          for (c = 0; c < b.length; c++) a = b[c], a.element.scrollLeft = a.left, a.element.scrollTop = a.top;
        }
      }
      var Pe = ia && "documentMode" in document && 11 >= document.documentMode;
      var Qe = null;
      var Re = null;
      var Se = null;
      var Te = false;
      function Ue(a, b, c) {
        var d = c.window === c ? c.document : 9 === c.nodeType ? c : c.ownerDocument;
        Te || null == Qe || Qe !== Xa(d) || (d = Qe, "selectionStart" in d && Ne(d) ? d = { start: d.selectionStart, end: d.selectionEnd } : (d = (d.ownerDocument && d.ownerDocument.defaultView || window).getSelection(), d = { anchorNode: d.anchorNode, anchorOffset: d.anchorOffset, focusNode: d.focusNode, focusOffset: d.focusOffset }), Se && Ie(Se, d) || (Se = d, d = oe(Re, "onSelect"), 0 < d.length && (b = new td("onSelect", "select", null, b, c), a.push({ event: b, listeners: d }), b.target = Qe)));
      }
      function Ve(a, b) {
        var c = {};
        c[a.toLowerCase()] = b.toLowerCase();
        c["Webkit" + a] = "webkit" + b;
        c["Moz" + a] = "moz" + b;
        return c;
      }
      var We = { animationend: Ve("Animation", "AnimationEnd"), animationiteration: Ve("Animation", "AnimationIteration"), animationstart: Ve("Animation", "AnimationStart"), transitionend: Ve("Transition", "TransitionEnd") };
      var Xe = {};
      var Ye = {};
      ia && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition);
      function Ze(a) {
        if (Xe[a]) return Xe[a];
        if (!We[a]) return a;
        var b = We[a], c;
        for (c in b) if (b.hasOwnProperty(c) && c in Ye) return Xe[a] = b[c];
        return a;
      }
      var $e = Ze("animationend");
      var af = Ze("animationiteration");
      var bf = Ze("animationstart");
      var cf = Ze("transitionend");
      var df = /* @__PURE__ */ new Map();
      var ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
      function ff(a, b) {
        df.set(a, b);
        fa(b, [a]);
      }
      for (gf = 0; gf < ef.length; gf++) {
        hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
        ff(jf, "on" + kf);
      }
      var hf;
      var jf;
      var kf;
      var gf;
      ff($e, "onAnimationEnd");
      ff(af, "onAnimationIteration");
      ff(bf, "onAnimationStart");
      ff("dblclick", "onDoubleClick");
      ff("focusin", "onFocus");
      ff("focusout", "onBlur");
      ff(cf, "onTransitionEnd");
      ha("onMouseEnter", ["mouseout", "mouseover"]);
      ha("onMouseLeave", ["mouseout", "mouseover"]);
      ha("onPointerEnter", ["pointerout", "pointerover"]);
      ha("onPointerLeave", ["pointerout", "pointerover"]);
      fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
      fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
      fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
      fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
      fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
      fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
      var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" ");
      var mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
      function nf(a, b, c) {
        var d = a.type || "unknown-event";
        a.currentTarget = c;
        Ub(d, b, void 0, a);
        a.currentTarget = null;
      }
      function se(a, b) {
        b = 0 !== (b & 4);
        for (var c = 0; c < a.length; c++) {
          var d = a[c], e = d.event;
          d = d.listeners;
          a: {
            var f = void 0;
            if (b) for (var g = d.length - 1; 0 <= g; g--) {
              var h = d[g], k = h.instance, l = h.currentTarget;
              h = h.listener;
              if (k !== f && e.isPropagationStopped()) break a;
              nf(e, h, l);
              f = k;
            }
            else for (g = 0; g < d.length; g++) {
              h = d[g];
              k = h.instance;
              l = h.currentTarget;
              h = h.listener;
              if (k !== f && e.isPropagationStopped()) break a;
              nf(e, h, l);
              f = k;
            }
          }
        }
        if (Qb) throw a = Rb, Qb = false, Rb = null, a;
      }
      function D(a, b) {
        var c = b[of];
        void 0 === c && (c = b[of] = /* @__PURE__ */ new Set());
        var d = a + "__bubble";
        c.has(d) || (pf(b, a, 2, false), c.add(d));
      }
      function qf(a, b, c) {
        var d = 0;
        b && (d |= 4);
        pf(c, a, d, b);
      }
      var rf = "_reactListening" + Math.random().toString(36).slice(2);
      function sf(a) {
        if (!a[rf]) {
          a[rf] = true;
          da.forEach(function(b2) {
            "selectionchange" !== b2 && (mf.has(b2) || qf(b2, false, a), qf(b2, true, a));
          });
          var b = 9 === a.nodeType ? a : a.ownerDocument;
          null === b || b[rf] || (b[rf] = true, qf("selectionchange", false, b));
        }
      }
      function pf(a, b, c, d) {
        switch (jd(b)) {
          case 1:
            var e = ed;
            break;
          case 4:
            e = gd;
            break;
          default:
            e = fd;
        }
        c = e.bind(null, b, c, a);
        e = void 0;
        !Lb || "touchstart" !== b && "touchmove" !== b && "wheel" !== b || (e = true);
        d ? void 0 !== e ? a.addEventListener(b, c, { capture: true, passive: e }) : a.addEventListener(b, c, true) : void 0 !== e ? a.addEventListener(b, c, { passive: e }) : a.addEventListener(b, c, false);
      }
      function hd(a, b, c, d, e) {
        var f = d;
        if (0 === (b & 1) && 0 === (b & 2) && null !== d) a: for (; ; ) {
          if (null === d) return;
          var g = d.tag;
          if (3 === g || 4 === g) {
            var h = d.stateNode.containerInfo;
            if (h === e || 8 === h.nodeType && h.parentNode === e) break;
            if (4 === g) for (g = d.return; null !== g; ) {
              var k = g.tag;
              if (3 === k || 4 === k) {
                if (k = g.stateNode.containerInfo, k === e || 8 === k.nodeType && k.parentNode === e) return;
              }
              g = g.return;
            }
            for (; null !== h; ) {
              g = Wc(h);
              if (null === g) return;
              k = g.tag;
              if (5 === k || 6 === k) {
                d = f = g;
                continue a;
              }
              h = h.parentNode;
            }
          }
          d = d.return;
        }
        Jb(function() {
          var d2 = f, e2 = xb(c), g2 = [];
          a: {
            var h2 = df.get(a);
            if (void 0 !== h2) {
              var k2 = td, n = a;
              switch (a) {
                case "keypress":
                  if (0 === od(c)) break a;
                case "keydown":
                case "keyup":
                  k2 = Rd;
                  break;
                case "focusin":
                  n = "focus";
                  k2 = Fd;
                  break;
                case "focusout":
                  n = "blur";
                  k2 = Fd;
                  break;
                case "beforeblur":
                case "afterblur":
                  k2 = Fd;
                  break;
                case "click":
                  if (2 === c.button) break a;
                case "auxclick":
                case "dblclick":
                case "mousedown":
                case "mousemove":
                case "mouseup":
                case "mouseout":
                case "mouseover":
                case "contextmenu":
                  k2 = Bd;
                  break;
                case "drag":
                case "dragend":
                case "dragenter":
                case "dragexit":
                case "dragleave":
                case "dragover":
                case "dragstart":
                case "drop":
                  k2 = Dd;
                  break;
                case "touchcancel":
                case "touchend":
                case "touchmove":
                case "touchstart":
                  k2 = Vd;
                  break;
                case $e:
                case af:
                case bf:
                  k2 = Hd;
                  break;
                case cf:
                  k2 = Xd;
                  break;
                case "scroll":
                  k2 = vd;
                  break;
                case "wheel":
                  k2 = Zd;
                  break;
                case "copy":
                case "cut":
                case "paste":
                  k2 = Jd;
                  break;
                case "gotpointercapture":
                case "lostpointercapture":
                case "pointercancel":
                case "pointerdown":
                case "pointermove":
                case "pointerout":
                case "pointerover":
                case "pointerup":
                  k2 = Td;
              }
              var t = 0 !== (b & 4), J = !t && "scroll" === a, x = t ? null !== h2 ? h2 + "Capture" : null : h2;
              t = [];
              for (var w = d2, u; null !== w; ) {
                u = w;
                var F = u.stateNode;
                5 === u.tag && null !== F && (u = F, null !== x && (F = Kb(w, x), null != F && t.push(tf(w, F, u))));
                if (J) break;
                w = w.return;
              }
              0 < t.length && (h2 = new k2(h2, n, null, c, e2), g2.push({ event: h2, listeners: t }));
            }
          }
          if (0 === (b & 7)) {
            a: {
              h2 = "mouseover" === a || "pointerover" === a;
              k2 = "mouseout" === a || "pointerout" === a;
              if (h2 && c !== wb && (n = c.relatedTarget || c.fromElement) && (Wc(n) || n[uf])) break a;
              if (k2 || h2) {
                h2 = e2.window === e2 ? e2 : (h2 = e2.ownerDocument) ? h2.defaultView || h2.parentWindow : window;
                if (k2) {
                  if (n = c.relatedTarget || c.toElement, k2 = d2, n = n ? Wc(n) : null, null !== n && (J = Vb(n), n !== J || 5 !== n.tag && 6 !== n.tag)) n = null;
                } else k2 = null, n = d2;
                if (k2 !== n) {
                  t = Bd;
                  F = "onMouseLeave";
                  x = "onMouseEnter";
                  w = "mouse";
                  if ("pointerout" === a || "pointerover" === a) t = Td, F = "onPointerLeave", x = "onPointerEnter", w = "pointer";
                  J = null == k2 ? h2 : ue(k2);
                  u = null == n ? h2 : ue(n);
                  h2 = new t(F, w + "leave", k2, c, e2);
                  h2.target = J;
                  h2.relatedTarget = u;
                  F = null;
                  Wc(e2) === d2 && (t = new t(x, w + "enter", n, c, e2), t.target = u, t.relatedTarget = J, F = t);
                  J = F;
                  if (k2 && n) b: {
                    t = k2;
                    x = n;
                    w = 0;
                    for (u = t; u; u = vf(u)) w++;
                    u = 0;
                    for (F = x; F; F = vf(F)) u++;
                    for (; 0 < w - u; ) t = vf(t), w--;
                    for (; 0 < u - w; ) x = vf(x), u--;
                    for (; w--; ) {
                      if (t === x || null !== x && t === x.alternate) break b;
                      t = vf(t);
                      x = vf(x);
                    }
                    t = null;
                  }
                  else t = null;
                  null !== k2 && wf(g2, h2, k2, t, false);
                  null !== n && null !== J && wf(g2, J, n, t, true);
                }
              }
            }
            a: {
              h2 = d2 ? ue(d2) : window;
              k2 = h2.nodeName && h2.nodeName.toLowerCase();
              if ("select" === k2 || "input" === k2 && "file" === h2.type) var na = ve;
              else if (me(h2)) if (we) na = Fe;
              else {
                na = De;
                var xa = Ce;
              }
              else (k2 = h2.nodeName) && "input" === k2.toLowerCase() && ("checkbox" === h2.type || "radio" === h2.type) && (na = Ee);
              if (na && (na = na(a, d2))) {
                ne(g2, na, c, e2);
                break a;
              }
              xa && xa(a, h2, d2);
              "focusout" === a && (xa = h2._wrapperState) && xa.controlled && "number" === h2.type && cb(h2, "number", h2.value);
            }
            xa = d2 ? ue(d2) : window;
            switch (a) {
              case "focusin":
                if (me(xa) || "true" === xa.contentEditable) Qe = xa, Re = d2, Se = null;
                break;
              case "focusout":
                Se = Re = Qe = null;
                break;
              case "mousedown":
                Te = true;
                break;
              case "contextmenu":
              case "mouseup":
              case "dragend":
                Te = false;
                Ue(g2, c, e2);
                break;
              case "selectionchange":
                if (Pe) break;
              case "keydown":
              case "keyup":
                Ue(g2, c, e2);
            }
            var $a;
            if (ae) b: {
              switch (a) {
                case "compositionstart":
                  var ba = "onCompositionStart";
                  break b;
                case "compositionend":
                  ba = "onCompositionEnd";
                  break b;
                case "compositionupdate":
                  ba = "onCompositionUpdate";
                  break b;
              }
              ba = void 0;
            }
            else ie ? ge(a, c) && (ba = "onCompositionEnd") : "keydown" === a && 229 === c.keyCode && (ba = "onCompositionStart");
            ba && (de && "ko" !== c.locale && (ie || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie && ($a = nd()) : (kd = e2, ld = "value" in kd ? kd.value : kd.textContent, ie = true)), xa = oe(d2, ba), 0 < xa.length && (ba = new Ld(ba, a, null, c, e2), g2.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he(c), null !== $a && (ba.data = $a))));
            if ($a = ce ? je(a, c) : ke(a, c)) d2 = oe(d2, "onBeforeInput"), 0 < d2.length && (e2 = new Ld("onBeforeInput", "beforeinput", null, c, e2), g2.push({ event: e2, listeners: d2 }), e2.data = $a);
          }
          se(g2, b);
        });
      }
      function tf(a, b, c) {
        return { instance: a, listener: b, currentTarget: c };
      }
      function oe(a, b) {
        for (var c = b + "Capture", d = []; null !== a; ) {
          var e = a, f = e.stateNode;
          5 === e.tag && null !== f && (e = f, f = Kb(a, c), null != f && d.unshift(tf(a, f, e)), f = Kb(a, b), null != f && d.push(tf(a, f, e)));
          a = a.return;
        }
        return d;
      }
      function vf(a) {
        if (null === a) return null;
        do
          a = a.return;
        while (a && 5 !== a.tag);
        return a ? a : null;
      }
      function wf(a, b, c, d, e) {
        for (var f = b._reactName, g = []; null !== c && c !== d; ) {
          var h = c, k = h.alternate, l = h.stateNode;
          if (null !== k && k === d) break;
          5 === h.tag && null !== l && (h = l, e ? (k = Kb(c, f), null != k && g.unshift(tf(c, k, h))) : e || (k = Kb(c, f), null != k && g.push(tf(c, k, h))));
          c = c.return;
        }
        0 !== g.length && a.push({ event: b, listeners: g });
      }
      var xf = /\r\n?/g;
      var yf = /\u0000|\uFFFD/g;
      function zf(a) {
        return ("string" === typeof a ? a : "" + a).replace(xf, "\n").replace(yf, "");
      }
      function Af(a, b, c) {
        b = zf(b);
        if (zf(a) !== b && c) throw Error(p(425));
      }
      function Bf() {
      }
      var Cf = null;
      var Df = null;
      function Ef(a, b) {
        return "textarea" === a || "noscript" === a || "string" === typeof b.children || "number" === typeof b.children || "object" === typeof b.dangerouslySetInnerHTML && null !== b.dangerouslySetInnerHTML && null != b.dangerouslySetInnerHTML.__html;
      }
      var Ff = "function" === typeof setTimeout ? setTimeout : void 0;
      var Gf = "function" === typeof clearTimeout ? clearTimeout : void 0;
      var Hf = "function" === typeof Promise ? Promise : void 0;
      var Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a) {
        return Hf.resolve(null).then(a).catch(If);
      } : Ff;
      function If(a) {
        setTimeout(function() {
          throw a;
        });
      }
      function Kf(a, b) {
        var c = b, d = 0;
        do {
          var e = c.nextSibling;
          a.removeChild(c);
          if (e && 8 === e.nodeType) if (c = e.data, "/$" === c) {
            if (0 === d) {
              a.removeChild(e);
              bd(b);
              return;
            }
            d--;
          } else "$" !== c && "$?" !== c && "$!" !== c || d++;
          c = e;
        } while (c);
        bd(b);
      }
      function Lf(a) {
        for (; null != a; a = a.nextSibling) {
          var b = a.nodeType;
          if (1 === b || 3 === b) break;
          if (8 === b) {
            b = a.data;
            if ("$" === b || "$!" === b || "$?" === b) break;
            if ("/$" === b) return null;
          }
        }
        return a;
      }
      function Mf(a) {
        a = a.previousSibling;
        for (var b = 0; a; ) {
          if (8 === a.nodeType) {
            var c = a.data;
            if ("$" === c || "$!" === c || "$?" === c) {
              if (0 === b) return a;
              b--;
            } else "/$" === c && b++;
          }
          a = a.previousSibling;
        }
        return null;
      }
      var Nf = Math.random().toString(36).slice(2);
      var Of = "__reactFiber$" + Nf;
      var Pf = "__reactProps$" + Nf;
      var uf = "__reactContainer$" + Nf;
      var of = "__reactEvents$" + Nf;
      var Qf = "__reactListeners$" + Nf;
      var Rf = "__reactHandles$" + Nf;
      function Wc(a) {
        var b = a[Of];
        if (b) return b;
        for (var c = a.parentNode; c; ) {
          if (b = c[uf] || c[Of]) {
            c = b.alternate;
            if (null !== b.child || null !== c && null !== c.child) for (a = Mf(a); null !== a; ) {
              if (c = a[Of]) return c;
              a = Mf(a);
            }
            return b;
          }
          a = c;
          c = a.parentNode;
        }
        return null;
      }
      function Cb(a) {
        a = a[Of] || a[uf];
        return !a || 5 !== a.tag && 6 !== a.tag && 13 !== a.tag && 3 !== a.tag ? null : a;
      }
      function ue(a) {
        if (5 === a.tag || 6 === a.tag) return a.stateNode;
        throw Error(p(33));
      }
      function Db(a) {
        return a[Pf] || null;
      }
      var Sf = [];
      var Tf = -1;
      function Uf(a) {
        return { current: a };
      }
      function E(a) {
        0 > Tf || (a.current = Sf[Tf], Sf[Tf] = null, Tf--);
      }
      function G(a, b) {
        Tf++;
        Sf[Tf] = a.current;
        a.current = b;
      }
      var Vf = {};
      var H = Uf(Vf);
      var Wf = Uf(false);
      var Xf = Vf;
      function Yf(a, b) {
        var c = a.type.contextTypes;
        if (!c) return Vf;
        var d = a.stateNode;
        if (d && d.__reactInternalMemoizedUnmaskedChildContext === b) return d.__reactInternalMemoizedMaskedChildContext;
        var e = {}, f;
        for (f in c) e[f] = b[f];
        d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b, a.__reactInternalMemoizedMaskedChildContext = e);
        return e;
      }
      function Zf(a) {
        a = a.childContextTypes;
        return null !== a && void 0 !== a;
      }
      function $f() {
        E(Wf);
        E(H);
      }
      function ag(a, b, c) {
        if (H.current !== Vf) throw Error(p(168));
        G(H, b);
        G(Wf, c);
      }
      function bg(a, b, c) {
        var d = a.stateNode;
        b = b.childContextTypes;
        if ("function" !== typeof d.getChildContext) return c;
        d = d.getChildContext();
        for (var e in d) if (!(e in b)) throw Error(p(108, Ra(a) || "Unknown", e));
        return A({}, c, d);
      }
      function cg(a) {
        a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || Vf;
        Xf = H.current;
        G(H, a);
        G(Wf, Wf.current);
        return true;
      }
      function dg(a, b, c) {
        var d = a.stateNode;
        if (!d) throw Error(p(169));
        c ? (a = bg(a, b, Xf), d.__reactInternalMemoizedMergedChildContext = a, E(Wf), E(H), G(H, a)) : E(Wf);
        G(Wf, c);
      }
      var eg = null;
      var fg = false;
      var gg = false;
      function hg(a) {
        null === eg ? eg = [a] : eg.push(a);
      }
      function ig(a) {
        fg = true;
        hg(a);
      }
      function jg() {
        if (!gg && null !== eg) {
          gg = true;
          var a = 0, b = C;
          try {
            var c = eg;
            for (C = 1; a < c.length; a++) {
              var d = c[a];
              do
                d = d(true);
              while (null !== d);
            }
            eg = null;
            fg = false;
          } catch (e) {
            throw null !== eg && (eg = eg.slice(a + 1)), ac(fc, jg), e;
          } finally {
            C = b, gg = false;
          }
        }
        return null;
      }
      var kg = [];
      var lg = 0;
      var mg = null;
      var ng = 0;
      var og = [];
      var pg = 0;
      var qg = null;
      var rg = 1;
      var sg = "";
      function tg(a, b) {
        kg[lg++] = ng;
        kg[lg++] = mg;
        mg = a;
        ng = b;
      }
      function ug(a, b, c) {
        og[pg++] = rg;
        og[pg++] = sg;
        og[pg++] = qg;
        qg = a;
        var d = rg;
        a = sg;
        var e = 32 - oc(d) - 1;
        d &= ~(1 << e);
        c += 1;
        var f = 32 - oc(b) + e;
        if (30 < f) {
          var g = e - e % 5;
          f = (d & (1 << g) - 1).toString(32);
          d >>= g;
          e -= g;
          rg = 1 << 32 - oc(b) + e | c << e | d;
          sg = f + a;
        } else rg = 1 << f | c << e | d, sg = a;
      }
      function vg(a) {
        null !== a.return && (tg(a, 1), ug(a, 1, 0));
      }
      function wg(a) {
        for (; a === mg; ) mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
        for (; a === qg; ) qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
      }
      var xg = null;
      var yg = null;
      var I = false;
      var zg = null;
      function Ag(a, b) {
        var c = Bg(5, null, null, 0);
        c.elementType = "DELETED";
        c.stateNode = b;
        c.return = a;
        b = a.deletions;
        null === b ? (a.deletions = [c], a.flags |= 16) : b.push(c);
      }
      function Cg(a, b) {
        switch (a.tag) {
          case 5:
            var c = a.type;
            b = 1 !== b.nodeType || c.toLowerCase() !== b.nodeName.toLowerCase() ? null : b;
            return null !== b ? (a.stateNode = b, xg = a, yg = Lf(b.firstChild), true) : false;
          case 6:
            return b = "" === a.pendingProps || 3 !== b.nodeType ? null : b, null !== b ? (a.stateNode = b, xg = a, yg = null, true) : false;
          case 13:
            return b = 8 !== b.nodeType ? null : b, null !== b ? (c = null !== qg ? { id: rg, overflow: sg } : null, a.memoizedState = { dehydrated: b, treeContext: c, retryLane: 1073741824 }, c = Bg(18, null, null, 0), c.stateNode = b, c.return = a, a.child = c, xg = a, yg = null, true) : false;
          default:
            return false;
        }
      }
      function Dg(a) {
        return 0 !== (a.mode & 1) && 0 === (a.flags & 128);
      }
      function Eg(a) {
        if (I) {
          var b = yg;
          if (b) {
            var c = b;
            if (!Cg(a, b)) {
              if (Dg(a)) throw Error(p(418));
              b = Lf(c.nextSibling);
              var d = xg;
              b && Cg(a, b) ? Ag(d, c) : (a.flags = a.flags & -4097 | 2, I = false, xg = a);
            }
          } else {
            if (Dg(a)) throw Error(p(418));
            a.flags = a.flags & -4097 | 2;
            I = false;
            xg = a;
          }
        }
      }
      function Fg(a) {
        for (a = a.return; null !== a && 5 !== a.tag && 3 !== a.tag && 13 !== a.tag; ) a = a.return;
        xg = a;
      }
      function Gg(a) {
        if (a !== xg) return false;
        if (!I) return Fg(a), I = true, false;
        var b;
        (b = 3 !== a.tag) && !(b = 5 !== a.tag) && (b = a.type, b = "head" !== b && "body" !== b && !Ef(a.type, a.memoizedProps));
        if (b && (b = yg)) {
          if (Dg(a)) throw Hg(), Error(p(418));
          for (; b; ) Ag(a, b), b = Lf(b.nextSibling);
        }
        Fg(a);
        if (13 === a.tag) {
          a = a.memoizedState;
          a = null !== a ? a.dehydrated : null;
          if (!a) throw Error(p(317));
          a: {
            a = a.nextSibling;
            for (b = 0; a; ) {
              if (8 === a.nodeType) {
                var c = a.data;
                if ("/$" === c) {
                  if (0 === b) {
                    yg = Lf(a.nextSibling);
                    break a;
                  }
                  b--;
                } else "$" !== c && "$!" !== c && "$?" !== c || b++;
              }
              a = a.nextSibling;
            }
            yg = null;
          }
        } else yg = xg ? Lf(a.stateNode.nextSibling) : null;
        return true;
      }
      function Hg() {
        for (var a = yg; a; ) a = Lf(a.nextSibling);
      }
      function Ig() {
        yg = xg = null;
        I = false;
      }
      function Jg(a) {
        null === zg ? zg = [a] : zg.push(a);
      }
      var Kg = ua.ReactCurrentBatchConfig;
      function Lg(a, b, c) {
        a = c.ref;
        if (null !== a && "function" !== typeof a && "object" !== typeof a) {
          if (c._owner) {
            c = c._owner;
            if (c) {
              if (1 !== c.tag) throw Error(p(309));
              var d = c.stateNode;
            }
            if (!d) throw Error(p(147, a));
            var e = d, f = "" + a;
            if (null !== b && null !== b.ref && "function" === typeof b.ref && b.ref._stringRef === f) return b.ref;
            b = function(a2) {
              var b2 = e.refs;
              null === a2 ? delete b2[f] : b2[f] = a2;
            };
            b._stringRef = f;
            return b;
          }
          if ("string" !== typeof a) throw Error(p(284));
          if (!c._owner) throw Error(p(290, a));
        }
        return a;
      }
      function Mg(a, b) {
        a = Object.prototype.toString.call(b);
        throw Error(p(31, "[object Object]" === a ? "object with keys {" + Object.keys(b).join(", ") + "}" : a));
      }
      function Ng(a) {
        var b = a._init;
        return b(a._payload);
      }
      function Og(a) {
        function b(b2, c2) {
          if (a) {
            var d2 = b2.deletions;
            null === d2 ? (b2.deletions = [c2], b2.flags |= 16) : d2.push(c2);
          }
        }
        function c(c2, d2) {
          if (!a) return null;
          for (; null !== d2; ) b(c2, d2), d2 = d2.sibling;
          return null;
        }
        function d(a2, b2) {
          for (a2 = /* @__PURE__ */ new Map(); null !== b2; ) null !== b2.key ? a2.set(b2.key, b2) : a2.set(b2.index, b2), b2 = b2.sibling;
          return a2;
        }
        function e(a2, b2) {
          a2 = Pg(a2, b2);
          a2.index = 0;
          a2.sibling = null;
          return a2;
        }
        function f(b2, c2, d2) {
          b2.index = d2;
          if (!a) return b2.flags |= 1048576, c2;
          d2 = b2.alternate;
          if (null !== d2) return d2 = d2.index, d2 < c2 ? (b2.flags |= 2, c2) : d2;
          b2.flags |= 2;
          return c2;
        }
        function g(b2) {
          a && null === b2.alternate && (b2.flags |= 2);
          return b2;
        }
        function h(a2, b2, c2, d2) {
          if (null === b2 || 6 !== b2.tag) return b2 = Qg(c2, a2.mode, d2), b2.return = a2, b2;
          b2 = e(b2, c2);
          b2.return = a2;
          return b2;
        }
        function k(a2, b2, c2, d2) {
          var f2 = c2.type;
          if (f2 === ya) return m(a2, b2, c2.props.children, d2, c2.key);
          if (null !== b2 && (b2.elementType === f2 || "object" === typeof f2 && null !== f2 && f2.$$typeof === Ha && Ng(f2) === b2.type)) return d2 = e(b2, c2.props), d2.ref = Lg(a2, b2, c2), d2.return = a2, d2;
          d2 = Rg(c2.type, c2.key, c2.props, null, a2.mode, d2);
          d2.ref = Lg(a2, b2, c2);
          d2.return = a2;
          return d2;
        }
        function l(a2, b2, c2, d2) {
          if (null === b2 || 4 !== b2.tag || b2.stateNode.containerInfo !== c2.containerInfo || b2.stateNode.implementation !== c2.implementation) return b2 = Sg(c2, a2.mode, d2), b2.return = a2, b2;
          b2 = e(b2, c2.children || []);
          b2.return = a2;
          return b2;
        }
        function m(a2, b2, c2, d2, f2) {
          if (null === b2 || 7 !== b2.tag) return b2 = Tg(c2, a2.mode, d2, f2), b2.return = a2, b2;
          b2 = e(b2, c2);
          b2.return = a2;
          return b2;
        }
        function q(a2, b2, c2) {
          if ("string" === typeof b2 && "" !== b2 || "number" === typeof b2) return b2 = Qg("" + b2, a2.mode, c2), b2.return = a2, b2;
          if ("object" === typeof b2 && null !== b2) {
            switch (b2.$$typeof) {
              case va:
                return c2 = Rg(b2.type, b2.key, b2.props, null, a2.mode, c2), c2.ref = Lg(a2, null, b2), c2.return = a2, c2;
              case wa:
                return b2 = Sg(b2, a2.mode, c2), b2.return = a2, b2;
              case Ha:
                var d2 = b2._init;
                return q(a2, d2(b2._payload), c2);
            }
            if (eb(b2) || Ka(b2)) return b2 = Tg(b2, a2.mode, c2, null), b2.return = a2, b2;
            Mg(a2, b2);
          }
          return null;
        }
        function r(a2, b2, c2, d2) {
          var e2 = null !== b2 ? b2.key : null;
          if ("string" === typeof c2 && "" !== c2 || "number" === typeof c2) return null !== e2 ? null : h(a2, b2, "" + c2, d2);
          if ("object" === typeof c2 && null !== c2) {
            switch (c2.$$typeof) {
              case va:
                return c2.key === e2 ? k(a2, b2, c2, d2) : null;
              case wa:
                return c2.key === e2 ? l(a2, b2, c2, d2) : null;
              case Ha:
                return e2 = c2._init, r(
                  a2,
                  b2,
                  e2(c2._payload),
                  d2
                );
            }
            if (eb(c2) || Ka(c2)) return null !== e2 ? null : m(a2, b2, c2, d2, null);
            Mg(a2, c2);
          }
          return null;
        }
        function y(a2, b2, c2, d2, e2) {
          if ("string" === typeof d2 && "" !== d2 || "number" === typeof d2) return a2 = a2.get(c2) || null, h(b2, a2, "" + d2, e2);
          if ("object" === typeof d2 && null !== d2) {
            switch (d2.$$typeof) {
              case va:
                return a2 = a2.get(null === d2.key ? c2 : d2.key) || null, k(b2, a2, d2, e2);
              case wa:
                return a2 = a2.get(null === d2.key ? c2 : d2.key) || null, l(b2, a2, d2, e2);
              case Ha:
                var f2 = d2._init;
                return y(a2, b2, c2, f2(d2._payload), e2);
            }
            if (eb(d2) || Ka(d2)) return a2 = a2.get(c2) || null, m(b2, a2, d2, e2, null);
            Mg(b2, d2);
          }
          return null;
        }
        function n(e2, g2, h2, k2) {
          for (var l2 = null, m2 = null, u = g2, w = g2 = 0, x = null; null !== u && w < h2.length; w++) {
            u.index > w ? (x = u, u = null) : x = u.sibling;
            var n2 = r(e2, u, h2[w], k2);
            if (null === n2) {
              null === u && (u = x);
              break;
            }
            a && u && null === n2.alternate && b(e2, u);
            g2 = f(n2, g2, w);
            null === m2 ? l2 = n2 : m2.sibling = n2;
            m2 = n2;
            u = x;
          }
          if (w === h2.length) return c(e2, u), I && tg(e2, w), l2;
          if (null === u) {
            for (; w < h2.length; w++) u = q(e2, h2[w], k2), null !== u && (g2 = f(u, g2, w), null === m2 ? l2 = u : m2.sibling = u, m2 = u);
            I && tg(e2, w);
            return l2;
          }
          for (u = d(e2, u); w < h2.length; w++) x = y(u, e2, w, h2[w], k2), null !== x && (a && null !== x.alternate && u.delete(null === x.key ? w : x.key), g2 = f(x, g2, w), null === m2 ? l2 = x : m2.sibling = x, m2 = x);
          a && u.forEach(function(a2) {
            return b(e2, a2);
          });
          I && tg(e2, w);
          return l2;
        }
        function t(e2, g2, h2, k2) {
          var l2 = Ka(h2);
          if ("function" !== typeof l2) throw Error(p(150));
          h2 = l2.call(h2);
          if (null == h2) throw Error(p(151));
          for (var u = l2 = null, m2 = g2, w = g2 = 0, x = null, n2 = h2.next(); null !== m2 && !n2.done; w++, n2 = h2.next()) {
            m2.index > w ? (x = m2, m2 = null) : x = m2.sibling;
            var t2 = r(e2, m2, n2.value, k2);
            if (null === t2) {
              null === m2 && (m2 = x);
              break;
            }
            a && m2 && null === t2.alternate && b(e2, m2);
            g2 = f(t2, g2, w);
            null === u ? l2 = t2 : u.sibling = t2;
            u = t2;
            m2 = x;
          }
          if (n2.done) return c(
            e2,
            m2
          ), I && tg(e2, w), l2;
          if (null === m2) {
            for (; !n2.done; w++, n2 = h2.next()) n2 = q(e2, n2.value, k2), null !== n2 && (g2 = f(n2, g2, w), null === u ? l2 = n2 : u.sibling = n2, u = n2);
            I && tg(e2, w);
            return l2;
          }
          for (m2 = d(e2, m2); !n2.done; w++, n2 = h2.next()) n2 = y(m2, e2, w, n2.value, k2), null !== n2 && (a && null !== n2.alternate && m2.delete(null === n2.key ? w : n2.key), g2 = f(n2, g2, w), null === u ? l2 = n2 : u.sibling = n2, u = n2);
          a && m2.forEach(function(a2) {
            return b(e2, a2);
          });
          I && tg(e2, w);
          return l2;
        }
        function J(a2, d2, f2, h2) {
          "object" === typeof f2 && null !== f2 && f2.type === ya && null === f2.key && (f2 = f2.props.children);
          if ("object" === typeof f2 && null !== f2) {
            switch (f2.$$typeof) {
              case va:
                a: {
                  for (var k2 = f2.key, l2 = d2; null !== l2; ) {
                    if (l2.key === k2) {
                      k2 = f2.type;
                      if (k2 === ya) {
                        if (7 === l2.tag) {
                          c(a2, l2.sibling);
                          d2 = e(l2, f2.props.children);
                          d2.return = a2;
                          a2 = d2;
                          break a;
                        }
                      } else if (l2.elementType === k2 || "object" === typeof k2 && null !== k2 && k2.$$typeof === Ha && Ng(k2) === l2.type) {
                        c(a2, l2.sibling);
                        d2 = e(l2, f2.props);
                        d2.ref = Lg(a2, l2, f2);
                        d2.return = a2;
                        a2 = d2;
                        break a;
                      }
                      c(a2, l2);
                      break;
                    } else b(a2, l2);
                    l2 = l2.sibling;
                  }
                  f2.type === ya ? (d2 = Tg(f2.props.children, a2.mode, h2, f2.key), d2.return = a2, a2 = d2) : (h2 = Rg(f2.type, f2.key, f2.props, null, a2.mode, h2), h2.ref = Lg(a2, d2, f2), h2.return = a2, a2 = h2);
                }
                return g(a2);
              case wa:
                a: {
                  for (l2 = f2.key; null !== d2; ) {
                    if (d2.key === l2) if (4 === d2.tag && d2.stateNode.containerInfo === f2.containerInfo && d2.stateNode.implementation === f2.implementation) {
                      c(a2, d2.sibling);
                      d2 = e(d2, f2.children || []);
                      d2.return = a2;
                      a2 = d2;
                      break a;
                    } else {
                      c(a2, d2);
                      break;
                    }
                    else b(a2, d2);
                    d2 = d2.sibling;
                  }
                  d2 = Sg(f2, a2.mode, h2);
                  d2.return = a2;
                  a2 = d2;
                }
                return g(a2);
              case Ha:
                return l2 = f2._init, J(a2, d2, l2(f2._payload), h2);
            }
            if (eb(f2)) return n(a2, d2, f2, h2);
            if (Ka(f2)) return t(a2, d2, f2, h2);
            Mg(a2, f2);
          }
          return "string" === typeof f2 && "" !== f2 || "number" === typeof f2 ? (f2 = "" + f2, null !== d2 && 6 === d2.tag ? (c(a2, d2.sibling), d2 = e(d2, f2), d2.return = a2, a2 = d2) : (c(a2, d2), d2 = Qg(f2, a2.mode, h2), d2.return = a2, a2 = d2), g(a2)) : c(a2, d2);
        }
        return J;
      }
      var Ug = Og(true);
      var Vg = Og(false);
      var Wg = Uf(null);
      var Xg = null;
      var Yg = null;
      var Zg = null;
      function $g() {
        Zg = Yg = Xg = null;
      }
      function ah(a) {
        var b = Wg.current;
        E(Wg);
        a._currentValue = b;
      }
      function bh(a, b, c) {
        for (; null !== a; ) {
          var d = a.alternate;
          (a.childLanes & b) !== b ? (a.childLanes |= b, null !== d && (d.childLanes |= b)) : null !== d && (d.childLanes & b) !== b && (d.childLanes |= b);
          if (a === c) break;
          a = a.return;
        }
      }
      function ch(a, b) {
        Xg = a;
        Zg = Yg = null;
        a = a.dependencies;
        null !== a && null !== a.firstContext && (0 !== (a.lanes & b) && (dh = true), a.firstContext = null);
      }
      function eh(a) {
        var b = a._currentValue;
        if (Zg !== a) if (a = { context: a, memoizedValue: b, next: null }, null === Yg) {
          if (null === Xg) throw Error(p(308));
          Yg = a;
          Xg.dependencies = { lanes: 0, firstContext: a };
        } else Yg = Yg.next = a;
        return b;
      }
      var fh = null;
      function gh(a) {
        null === fh ? fh = [a] : fh.push(a);
      }
      function hh(a, b, c, d) {
        var e = b.interleaved;
        null === e ? (c.next = c, gh(b)) : (c.next = e.next, e.next = c);
        b.interleaved = c;
        return ih(a, d);
      }
      function ih(a, b) {
        a.lanes |= b;
        var c = a.alternate;
        null !== c && (c.lanes |= b);
        c = a;
        for (a = a.return; null !== a; ) a.childLanes |= b, c = a.alternate, null !== c && (c.childLanes |= b), c = a, a = a.return;
        return 3 === c.tag ? c.stateNode : null;
      }
      var jh = false;
      function kh(a) {
        a.updateQueue = { baseState: a.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
      }
      function lh(a, b) {
        a = a.updateQueue;
        b.updateQueue === a && (b.updateQueue = { baseState: a.baseState, firstBaseUpdate: a.firstBaseUpdate, lastBaseUpdate: a.lastBaseUpdate, shared: a.shared, effects: a.effects });
      }
      function mh(a, b) {
        return { eventTime: a, lane: b, tag: 0, payload: null, callback: null, next: null };
      }
      function nh(a, b, c) {
        var d = a.updateQueue;
        if (null === d) return null;
        d = d.shared;
        if (0 !== (K & 2)) {
          var e = d.pending;
          null === e ? b.next = b : (b.next = e.next, e.next = b);
          d.pending = b;
          return ih(a, c);
        }
        e = d.interleaved;
        null === e ? (b.next = b, gh(d)) : (b.next = e.next, e.next = b);
        d.interleaved = b;
        return ih(a, c);
      }
      function oh(a, b, c) {
        b = b.updateQueue;
        if (null !== b && (b = b.shared, 0 !== (c & 4194240))) {
          var d = b.lanes;
          d &= a.pendingLanes;
          c |= d;
          b.lanes = c;
          Cc(a, c);
        }
      }
      function ph(a, b) {
        var c = a.updateQueue, d = a.alternate;
        if (null !== d && (d = d.updateQueue, c === d)) {
          var e = null, f = null;
          c = c.firstBaseUpdate;
          if (null !== c) {
            do {
              var g = { eventTime: c.eventTime, lane: c.lane, tag: c.tag, payload: c.payload, callback: c.callback, next: null };
              null === f ? e = f = g : f = f.next = g;
              c = c.next;
            } while (null !== c);
            null === f ? e = f = b : f = f.next = b;
          } else e = f = b;
          c = { baseState: d.baseState, firstBaseUpdate: e, lastBaseUpdate: f, shared: d.shared, effects: d.effects };
          a.updateQueue = c;
          return;
        }
        a = c.lastBaseUpdate;
        null === a ? c.firstBaseUpdate = b : a.next = b;
        c.lastBaseUpdate = b;
      }
      function qh(a, b, c, d) {
        var e = a.updateQueue;
        jh = false;
        var f = e.firstBaseUpdate, g = e.lastBaseUpdate, h = e.shared.pending;
        if (null !== h) {
          e.shared.pending = null;
          var k = h, l = k.next;
          k.next = null;
          null === g ? f = l : g.next = l;
          g = k;
          var m = a.alternate;
          null !== m && (m = m.updateQueue, h = m.lastBaseUpdate, h !== g && (null === h ? m.firstBaseUpdate = l : h.next = l, m.lastBaseUpdate = k));
        }
        if (null !== f) {
          var q = e.baseState;
          g = 0;
          m = l = k = null;
          h = f;
          do {
            var r = h.lane, y = h.eventTime;
            if ((d & r) === r) {
              null !== m && (m = m.next = {
                eventTime: y,
                lane: 0,
                tag: h.tag,
                payload: h.payload,
                callback: h.callback,
                next: null
              });
              a: {
                var n = a, t = h;
                r = b;
                y = c;
                switch (t.tag) {
                  case 1:
                    n = t.payload;
                    if ("function" === typeof n) {
                      q = n.call(y, q, r);
                      break a;
                    }
                    q = n;
                    break a;
                  case 3:
                    n.flags = n.flags & -65537 | 128;
                  case 0:
                    n = t.payload;
                    r = "function" === typeof n ? n.call(y, q, r) : n;
                    if (null === r || void 0 === r) break a;
                    q = A({}, q, r);
                    break a;
                  case 2:
                    jh = true;
                }
              }
              null !== h.callback && 0 !== h.lane && (a.flags |= 64, r = e.effects, null === r ? e.effects = [h] : r.push(h));
            } else y = { eventTime: y, lane: r, tag: h.tag, payload: h.payload, callback: h.callback, next: null }, null === m ? (l = m = y, k = q) : m = m.next = y, g |= r;
            h = h.next;
            if (null === h) if (h = e.shared.pending, null === h) break;
            else r = h, h = r.next, r.next = null, e.lastBaseUpdate = r, e.shared.pending = null;
          } while (1);
          null === m && (k = q);
          e.baseState = k;
          e.firstBaseUpdate = l;
          e.lastBaseUpdate = m;
          b = e.shared.interleaved;
          if (null !== b) {
            e = b;
            do
              g |= e.lane, e = e.next;
            while (e !== b);
          } else null === f && (e.shared.lanes = 0);
          rh |= g;
          a.lanes = g;
          a.memoizedState = q;
        }
      }
      function sh(a, b, c) {
        a = b.effects;
        b.effects = null;
        if (null !== a) for (b = 0; b < a.length; b++) {
          var d = a[b], e = d.callback;
          if (null !== e) {
            d.callback = null;
            d = c;
            if ("function" !== typeof e) throw Error(p(191, e));
            e.call(d);
          }
        }
      }
      var th = {};
      var uh = Uf(th);
      var vh = Uf(th);
      var wh = Uf(th);
      function xh(a) {
        if (a === th) throw Error(p(174));
        return a;
      }
      function yh(a, b) {
        G(wh, b);
        G(vh, a);
        G(uh, th);
        a = b.nodeType;
        switch (a) {
          case 9:
          case 11:
            b = (b = b.documentElement) ? b.namespaceURI : lb(null, "");
            break;
          default:
            a = 8 === a ? b.parentNode : b, b = a.namespaceURI || null, a = a.tagName, b = lb(b, a);
        }
        E(uh);
        G(uh, b);
      }
      function zh() {
        E(uh);
        E(vh);
        E(wh);
      }
      function Ah(a) {
        xh(wh.current);
        var b = xh(uh.current);
        var c = lb(b, a.type);
        b !== c && (G(vh, a), G(uh, c));
      }
      function Bh(a) {
        vh.current === a && (E(uh), E(vh));
      }
      var L = Uf(0);
      function Ch(a) {
        for (var b = a; null !== b; ) {
          if (13 === b.tag) {
            var c = b.memoizedState;
            if (null !== c && (c = c.dehydrated, null === c || "$?" === c.data || "$!" === c.data)) return b;
          } else if (19 === b.tag && void 0 !== b.memoizedProps.revealOrder) {
            if (0 !== (b.flags & 128)) return b;
          } else if (null !== b.child) {
            b.child.return = b;
            b = b.child;
            continue;
          }
          if (b === a) break;
          for (; null === b.sibling; ) {
            if (null === b.return || b.return === a) return null;
            b = b.return;
          }
          b.sibling.return = b.return;
          b = b.sibling;
        }
        return null;
      }
      var Dh = [];
      function Eh() {
        for (var a = 0; a < Dh.length; a++) Dh[a]._workInProgressVersionPrimary = null;
        Dh.length = 0;
      }
      var Fh = ua.ReactCurrentDispatcher;
      var Gh = ua.ReactCurrentBatchConfig;
      var Hh = 0;
      var M = null;
      var N = null;
      var O = null;
      var Ih = false;
      var Jh = false;
      var Kh = 0;
      var Lh = 0;
      function P() {
        throw Error(p(321));
      }
      function Mh(a, b) {
        if (null === b) return false;
        for (var c = 0; c < b.length && c < a.length; c++) if (!He(a[c], b[c])) return false;
        return true;
      }
      function Nh(a, b, c, d, e, f) {
        Hh = f;
        M = b;
        b.memoizedState = null;
        b.updateQueue = null;
        b.lanes = 0;
        Fh.current = null === a || null === a.memoizedState ? Oh : Ph;
        a = c(d, e);
        if (Jh) {
          f = 0;
          do {
            Jh = false;
            Kh = 0;
            if (25 <= f) throw Error(p(301));
            f += 1;
            O = N = null;
            b.updateQueue = null;
            Fh.current = Qh;
            a = c(d, e);
          } while (Jh);
        }
        Fh.current = Rh;
        b = null !== N && null !== N.next;
        Hh = 0;
        O = N = M = null;
        Ih = false;
        if (b) throw Error(p(300));
        return a;
      }
      function Sh() {
        var a = 0 !== Kh;
        Kh = 0;
        return a;
      }
      function Th() {
        var a = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
        null === O ? M.memoizedState = O = a : O = O.next = a;
        return O;
      }
      function Uh() {
        if (null === N) {
          var a = M.alternate;
          a = null !== a ? a.memoizedState : null;
        } else a = N.next;
        var b = null === O ? M.memoizedState : O.next;
        if (null !== b) O = b, N = a;
        else {
          if (null === a) throw Error(p(310));
          N = a;
          a = { memoizedState: N.memoizedState, baseState: N.baseState, baseQueue: N.baseQueue, queue: N.queue, next: null };
          null === O ? M.memoizedState = O = a : O = O.next = a;
        }
        return O;
      }
      function Vh(a, b) {
        return "function" === typeof b ? b(a) : b;
      }
      function Wh(a) {
        var b = Uh(), c = b.queue;
        if (null === c) throw Error(p(311));
        c.lastRenderedReducer = a;
        var d = N, e = d.baseQueue, f = c.pending;
        if (null !== f) {
          if (null !== e) {
            var g = e.next;
            e.next = f.next;
            f.next = g;
          }
          d.baseQueue = e = f;
          c.pending = null;
        }
        if (null !== e) {
          f = e.next;
          d = d.baseState;
          var h = g = null, k = null, l = f;
          do {
            var m = l.lane;
            if ((Hh & m) === m) null !== k && (k = k.next = { lane: 0, action: l.action, hasEagerState: l.hasEagerState, eagerState: l.eagerState, next: null }), d = l.hasEagerState ? l.eagerState : a(d, l.action);
            else {
              var q = {
                lane: m,
                action: l.action,
                hasEagerState: l.hasEagerState,
                eagerState: l.eagerState,
                next: null
              };
              null === k ? (h = k = q, g = d) : k = k.next = q;
              M.lanes |= m;
              rh |= m;
            }
            l = l.next;
          } while (null !== l && l !== f);
          null === k ? g = d : k.next = h;
          He(d, b.memoizedState) || (dh = true);
          b.memoizedState = d;
          b.baseState = g;
          b.baseQueue = k;
          c.lastRenderedState = d;
        }
        a = c.interleaved;
        if (null !== a) {
          e = a;
          do
            f = e.lane, M.lanes |= f, rh |= f, e = e.next;
          while (e !== a);
        } else null === e && (c.lanes = 0);
        return [b.memoizedState, c.dispatch];
      }
      function Xh(a) {
        var b = Uh(), c = b.queue;
        if (null === c) throw Error(p(311));
        c.lastRenderedReducer = a;
        var d = c.dispatch, e = c.pending, f = b.memoizedState;
        if (null !== e) {
          c.pending = null;
          var g = e = e.next;
          do
            f = a(f, g.action), g = g.next;
          while (g !== e);
          He(f, b.memoizedState) || (dh = true);
          b.memoizedState = f;
          null === b.baseQueue && (b.baseState = f);
          c.lastRenderedState = f;
        }
        return [f, d];
      }
      function Yh() {
      }
      function Zh(a, b) {
        var c = M, d = Uh(), e = b(), f = !He(d.memoizedState, e);
        f && (d.memoizedState = e, dh = true);
        d = d.queue;
        $h(ai.bind(null, c, d, a), [a]);
        if (d.getSnapshot !== b || f || null !== O && O.memoizedState.tag & 1) {
          c.flags |= 2048;
          bi(9, ci.bind(null, c, d, e, b), void 0, null);
          if (null === Q) throw Error(p(349));
          0 !== (Hh & 30) || di(c, b, e);
        }
        return e;
      }
      function di(a, b, c) {
        a.flags |= 16384;
        a = { getSnapshot: b, value: c };
        b = M.updateQueue;
        null === b ? (b = { lastEffect: null, stores: null }, M.updateQueue = b, b.stores = [a]) : (c = b.stores, null === c ? b.stores = [a] : c.push(a));
      }
      function ci(a, b, c, d) {
        b.value = c;
        b.getSnapshot = d;
        ei(b) && fi(a);
      }
      function ai(a, b, c) {
        return c(function() {
          ei(b) && fi(a);
        });
      }
      function ei(a) {
        var b = a.getSnapshot;
        a = a.value;
        try {
          var c = b();
          return !He(a, c);
        } catch (d) {
          return true;
        }
      }
      function fi(a) {
        var b = ih(a, 1);
        null !== b && gi(b, a, 1, -1);
      }
      function hi(a) {
        var b = Th();
        "function" === typeof a && (a = a());
        b.memoizedState = b.baseState = a;
        a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Vh, lastRenderedState: a };
        b.queue = a;
        a = a.dispatch = ii.bind(null, M, a);
        return [b.memoizedState, a];
      }
      function bi(a, b, c, d) {
        a = { tag: a, create: b, destroy: c, deps: d, next: null };
        b = M.updateQueue;
        null === b ? (b = { lastEffect: null, stores: null }, M.updateQueue = b, b.lastEffect = a.next = a) : (c = b.lastEffect, null === c ? b.lastEffect = a.next = a : (d = c.next, c.next = a, a.next = d, b.lastEffect = a));
        return a;
      }
      function ji() {
        return Uh().memoizedState;
      }
      function ki(a, b, c, d) {
        var e = Th();
        M.flags |= a;
        e.memoizedState = bi(1 | b, c, void 0, void 0 === d ? null : d);
      }
      function li(a, b, c, d) {
        var e = Uh();
        d = void 0 === d ? null : d;
        var f = void 0;
        if (null !== N) {
          var g = N.memoizedState;
          f = g.destroy;
          if (null !== d && Mh(d, g.deps)) {
            e.memoizedState = bi(b, c, f, d);
            return;
          }
        }
        M.flags |= a;
        e.memoizedState = bi(1 | b, c, f, d);
      }
      function mi(a, b) {
        return ki(8390656, 8, a, b);
      }
      function $h(a, b) {
        return li(2048, 8, a, b);
      }
      function ni(a, b) {
        return li(4, 2, a, b);
      }
      function oi(a, b) {
        return li(4, 4, a, b);
      }
      function pi(a, b) {
        if ("function" === typeof b) return a = a(), b(a), function() {
          b(null);
        };
        if (null !== b && void 0 !== b) return a = a(), b.current = a, function() {
          b.current = null;
        };
      }
      function qi(a, b, c) {
        c = null !== c && void 0 !== c ? c.concat([a]) : null;
        return li(4, 4, pi.bind(null, b, a), c);
      }
      function ri() {
      }
      function si(a, b) {
        var c = Uh();
        b = void 0 === b ? null : b;
        var d = c.memoizedState;
        if (null !== d && null !== b && Mh(b, d[1])) return d[0];
        c.memoizedState = [a, b];
        return a;
      }
      function ti(a, b) {
        var c = Uh();
        b = void 0 === b ? null : b;
        var d = c.memoizedState;
        if (null !== d && null !== b && Mh(b, d[1])) return d[0];
        a = a();
        c.memoizedState = [a, b];
        return a;
      }
      function ui(a, b, c) {
        if (0 === (Hh & 21)) return a.baseState && (a.baseState = false, dh = true), a.memoizedState = c;
        He(c, b) || (c = yc(), M.lanes |= c, rh |= c, a.baseState = true);
        return b;
      }
      function vi(a, b) {
        var c = C;
        C = 0 !== c && 4 > c ? c : 4;
        a(true);
        var d = Gh.transition;
        Gh.transition = {};
        try {
          a(false), b();
        } finally {
          C = c, Gh.transition = d;
        }
      }
      function wi() {
        return Uh().memoizedState;
      }
      function xi(a, b, c) {
        var d = yi(a);
        c = { lane: d, action: c, hasEagerState: false, eagerState: null, next: null };
        if (zi(a)) Ai(b, c);
        else if (c = hh(a, b, c, d), null !== c) {
          var e = R();
          gi(c, a, d, e);
          Bi(c, b, d);
        }
      }
      function ii(a, b, c) {
        var d = yi(a), e = { lane: d, action: c, hasEagerState: false, eagerState: null, next: null };
        if (zi(a)) Ai(b, e);
        else {
          var f = a.alternate;
          if (0 === a.lanes && (null === f || 0 === f.lanes) && (f = b.lastRenderedReducer, null !== f)) try {
            var g = b.lastRenderedState, h = f(g, c);
            e.hasEagerState = true;
            e.eagerState = h;
            if (He(h, g)) {
              var k = b.interleaved;
              null === k ? (e.next = e, gh(b)) : (e.next = k.next, k.next = e);
              b.interleaved = e;
              return;
            }
          } catch (l) {
          } finally {
          }
          c = hh(a, b, e, d);
          null !== c && (e = R(), gi(c, a, d, e), Bi(c, b, d));
        }
      }
      function zi(a) {
        var b = a.alternate;
        return a === M || null !== b && b === M;
      }
      function Ai(a, b) {
        Jh = Ih = true;
        var c = a.pending;
        null === c ? b.next = b : (b.next = c.next, c.next = b);
        a.pending = b;
      }
      function Bi(a, b, c) {
        if (0 !== (c & 4194240)) {
          var d = b.lanes;
          d &= a.pendingLanes;
          c |= d;
          b.lanes = c;
          Cc(a, c);
        }
      }
      var Rh = { readContext: eh, useCallback: P, useContext: P, useEffect: P, useImperativeHandle: P, useInsertionEffect: P, useLayoutEffect: P, useMemo: P, useReducer: P, useRef: P, useState: P, useDebugValue: P, useDeferredValue: P, useTransition: P, useMutableSource: P, useSyncExternalStore: P, useId: P, unstable_isNewReconciler: false };
      var Oh = { readContext: eh, useCallback: function(a, b) {
        Th().memoizedState = [a, void 0 === b ? null : b];
        return a;
      }, useContext: eh, useEffect: mi, useImperativeHandle: function(a, b, c) {
        c = null !== c && void 0 !== c ? c.concat([a]) : null;
        return ki(
          4194308,
          4,
          pi.bind(null, b, a),
          c
        );
      }, useLayoutEffect: function(a, b) {
        return ki(4194308, 4, a, b);
      }, useInsertionEffect: function(a, b) {
        return ki(4, 2, a, b);
      }, useMemo: function(a, b) {
        var c = Th();
        b = void 0 === b ? null : b;
        a = a();
        c.memoizedState = [a, b];
        return a;
      }, useReducer: function(a, b, c) {
        var d = Th();
        b = void 0 !== c ? c(b) : b;
        d.memoizedState = d.baseState = b;
        a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a, lastRenderedState: b };
        d.queue = a;
        a = a.dispatch = xi.bind(null, M, a);
        return [d.memoizedState, a];
      }, useRef: function(a) {
        var b = Th();
        a = { current: a };
        return b.memoizedState = a;
      }, useState: hi, useDebugValue: ri, useDeferredValue: function(a) {
        return Th().memoizedState = a;
      }, useTransition: function() {
        var a = hi(false), b = a[0];
        a = vi.bind(null, a[1]);
        Th().memoizedState = a;
        return [b, a];
      }, useMutableSource: function() {
      }, useSyncExternalStore: function(a, b, c) {
        var d = M, e = Th();
        if (I) {
          if (void 0 === c) throw Error(p(407));
          c = c();
        } else {
          c = b();
          if (null === Q) throw Error(p(349));
          0 !== (Hh & 30) || di(d, b, c);
        }
        e.memoizedState = c;
        var f = { value: c, getSnapshot: b };
        e.queue = f;
        mi(ai.bind(
          null,
          d,
          f,
          a
        ), [a]);
        d.flags |= 2048;
        bi(9, ci.bind(null, d, f, c, b), void 0, null);
        return c;
      }, useId: function() {
        var a = Th(), b = Q.identifierPrefix;
        if (I) {
          var c = sg;
          var d = rg;
          c = (d & ~(1 << 32 - oc(d) - 1)).toString(32) + c;
          b = ":" + b + "R" + c;
          c = Kh++;
          0 < c && (b += "H" + c.toString(32));
          b += ":";
        } else c = Lh++, b = ":" + b + "r" + c.toString(32) + ":";
        return a.memoizedState = b;
      }, unstable_isNewReconciler: false };
      var Ph = {
        readContext: eh,
        useCallback: si,
        useContext: eh,
        useEffect: $h,
        useImperativeHandle: qi,
        useInsertionEffect: ni,
        useLayoutEffect: oi,
        useMemo: ti,
        useReducer: Wh,
        useRef: ji,
        useState: function() {
          return Wh(Vh);
        },
        useDebugValue: ri,
        useDeferredValue: function(a) {
          var b = Uh();
          return ui(b, N.memoizedState, a);
        },
        useTransition: function() {
          var a = Wh(Vh)[0], b = Uh().memoizedState;
          return [a, b];
        },
        useMutableSource: Yh,
        useSyncExternalStore: Zh,
        useId: wi,
        unstable_isNewReconciler: false
      };
      var Qh = { readContext: eh, useCallback: si, useContext: eh, useEffect: $h, useImperativeHandle: qi, useInsertionEffect: ni, useLayoutEffect: oi, useMemo: ti, useReducer: Xh, useRef: ji, useState: function() {
        return Xh(Vh);
      }, useDebugValue: ri, useDeferredValue: function(a) {
        var b = Uh();
        return null === N ? b.memoizedState = a : ui(b, N.memoizedState, a);
      }, useTransition: function() {
        var a = Xh(Vh)[0], b = Uh().memoizedState;
        return [a, b];
      }, useMutableSource: Yh, useSyncExternalStore: Zh, useId: wi, unstable_isNewReconciler: false };
      function Ci(a, b) {
        if (a && a.defaultProps) {
          b = A({}, b);
          a = a.defaultProps;
          for (var c in a) void 0 === b[c] && (b[c] = a[c]);
          return b;
        }
        return b;
      }
      function Di(a, b, c, d) {
        b = a.memoizedState;
        c = c(d, b);
        c = null === c || void 0 === c ? b : A({}, b, c);
        a.memoizedState = c;
        0 === a.lanes && (a.updateQueue.baseState = c);
      }
      var Ei = { isMounted: function(a) {
        return (a = a._reactInternals) ? Vb(a) === a : false;
      }, enqueueSetState: function(a, b, c) {
        a = a._reactInternals;
        var d = R(), e = yi(a), f = mh(d, e);
        f.payload = b;
        void 0 !== c && null !== c && (f.callback = c);
        b = nh(a, f, e);
        null !== b && (gi(b, a, e, d), oh(b, a, e));
      }, enqueueReplaceState: function(a, b, c) {
        a = a._reactInternals;
        var d = R(), e = yi(a), f = mh(d, e);
        f.tag = 1;
        f.payload = b;
        void 0 !== c && null !== c && (f.callback = c);
        b = nh(a, f, e);
        null !== b && (gi(b, a, e, d), oh(b, a, e));
      }, enqueueForceUpdate: function(a, b) {
        a = a._reactInternals;
        var c = R(), d = yi(a), e = mh(c, d);
        e.tag = 2;
        void 0 !== b && null !== b && (e.callback = b);
        b = nh(a, e, d);
        null !== b && (gi(b, a, d, c), oh(b, a, d));
      } };
      function Fi(a, b, c, d, e, f, g) {
        a = a.stateNode;
        return "function" === typeof a.shouldComponentUpdate ? a.shouldComponentUpdate(d, f, g) : b.prototype && b.prototype.isPureReactComponent ? !Ie(c, d) || !Ie(e, f) : true;
      }
      function Gi(a, b, c) {
        var d = false, e = Vf;
        var f = b.contextType;
        "object" === typeof f && null !== f ? f = eh(f) : (e = Zf(b) ? Xf : H.current, d = b.contextTypes, f = (d = null !== d && void 0 !== d) ? Yf(a, e) : Vf);
        b = new b(c, f);
        a.memoizedState = null !== b.state && void 0 !== b.state ? b.state : null;
        b.updater = Ei;
        a.stateNode = b;
        b._reactInternals = a;
        d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = e, a.__reactInternalMemoizedMaskedChildContext = f);
        return b;
      }
      function Hi(a, b, c, d) {
        a = b.state;
        "function" === typeof b.componentWillReceiveProps && b.componentWillReceiveProps(c, d);
        "function" === typeof b.UNSAFE_componentWillReceiveProps && b.UNSAFE_componentWillReceiveProps(c, d);
        b.state !== a && Ei.enqueueReplaceState(b, b.state, null);
      }
      function Ii(a, b, c, d) {
        var e = a.stateNode;
        e.props = c;
        e.state = a.memoizedState;
        e.refs = {};
        kh(a);
        var f = b.contextType;
        "object" === typeof f && null !== f ? e.context = eh(f) : (f = Zf(b) ? Xf : H.current, e.context = Yf(a, f));
        e.state = a.memoizedState;
        f = b.getDerivedStateFromProps;
        "function" === typeof f && (Di(a, b, f, c), e.state = a.memoizedState);
        "function" === typeof b.getDerivedStateFromProps || "function" === typeof e.getSnapshotBeforeUpdate || "function" !== typeof e.UNSAFE_componentWillMount && "function" !== typeof e.componentWillMount || (b = e.state, "function" === typeof e.componentWillMount && e.componentWillMount(), "function" === typeof e.UNSAFE_componentWillMount && e.UNSAFE_componentWillMount(), b !== e.state && Ei.enqueueReplaceState(e, e.state, null), qh(a, c, e, d), e.state = a.memoizedState);
        "function" === typeof e.componentDidMount && (a.flags |= 4194308);
      }
      function Ji(a, b) {
        try {
          var c = "", d = b;
          do
            c += Pa(d), d = d.return;
          while (d);
          var e = c;
        } catch (f) {
          e = "\nError generating stack: " + f.message + "\n" + f.stack;
        }
        return { value: a, source: b, stack: e, digest: null };
      }
      function Ki(a, b, c) {
        return { value: a, source: null, stack: null != c ? c : null, digest: null != b ? b : null };
      }
      function Li(a, b) {
        try {
          console.error(b.value);
        } catch (c) {
          setTimeout(function() {
            throw c;
          });
        }
      }
      var Mi = "function" === typeof WeakMap ? WeakMap : Map;
      function Ni(a, b, c) {
        c = mh(-1, c);
        c.tag = 3;
        c.payload = { element: null };
        var d = b.value;
        c.callback = function() {
          Oi || (Oi = true, Pi = d);
          Li(a, b);
        };
        return c;
      }
      function Qi(a, b, c) {
        c = mh(-1, c);
        c.tag = 3;
        var d = a.type.getDerivedStateFromError;
        if ("function" === typeof d) {
          var e = b.value;
          c.payload = function() {
            return d(e);
          };
          c.callback = function() {
            Li(a, b);
          };
        }
        var f = a.stateNode;
        null !== f && "function" === typeof f.componentDidCatch && (c.callback = function() {
          Li(a, b);
          "function" !== typeof d && (null === Ri ? Ri = /* @__PURE__ */ new Set([this]) : Ri.add(this));
          var c2 = b.stack;
          this.componentDidCatch(b.value, { componentStack: null !== c2 ? c2 : "" });
        });
        return c;
      }
      function Si(a, b, c) {
        var d = a.pingCache;
        if (null === d) {
          d = a.pingCache = new Mi();
          var e = /* @__PURE__ */ new Set();
          d.set(b, e);
        } else e = d.get(b), void 0 === e && (e = /* @__PURE__ */ new Set(), d.set(b, e));
        e.has(c) || (e.add(c), a = Ti.bind(null, a, b, c), b.then(a, a));
      }
      function Ui(a) {
        do {
          var b;
          if (b = 13 === a.tag) b = a.memoizedState, b = null !== b ? null !== b.dehydrated ? true : false : true;
          if (b) return a;
          a = a.return;
        } while (null !== a);
        return null;
      }
      function Vi(a, b, c, d, e) {
        if (0 === (a.mode & 1)) return a === b ? a.flags |= 65536 : (a.flags |= 128, c.flags |= 131072, c.flags &= -52805, 1 === c.tag && (null === c.alternate ? c.tag = 17 : (b = mh(-1, 1), b.tag = 2, nh(c, b, 1))), c.lanes |= 1), a;
        a.flags |= 65536;
        a.lanes = e;
        return a;
      }
      var Wi = ua.ReactCurrentOwner;
      var dh = false;
      function Xi(a, b, c, d) {
        b.child = null === a ? Vg(b, null, c, d) : Ug(b, a.child, c, d);
      }
      function Yi(a, b, c, d, e) {
        c = c.render;
        var f = b.ref;
        ch(b, e);
        d = Nh(a, b, c, d, f, e);
        c = Sh();
        if (null !== a && !dh) return b.updateQueue = a.updateQueue, b.flags &= -2053, a.lanes &= ~e, Zi(a, b, e);
        I && c && vg(b);
        b.flags |= 1;
        Xi(a, b, d, e);
        return b.child;
      }
      function $i(a, b, c, d, e) {
        if (null === a) {
          var f = c.type;
          if ("function" === typeof f && !aj(f) && void 0 === f.defaultProps && null === c.compare && void 0 === c.defaultProps) return b.tag = 15, b.type = f, bj(a, b, f, d, e);
          a = Rg(c.type, null, d, b, b.mode, e);
          a.ref = b.ref;
          a.return = b;
          return b.child = a;
        }
        f = a.child;
        if (0 === (a.lanes & e)) {
          var g = f.memoizedProps;
          c = c.compare;
          c = null !== c ? c : Ie;
          if (c(g, d) && a.ref === b.ref) return Zi(a, b, e);
        }
        b.flags |= 1;
        a = Pg(f, d);
        a.ref = b.ref;
        a.return = b;
        return b.child = a;
      }
      function bj(a, b, c, d, e) {
        if (null !== a) {
          var f = a.memoizedProps;
          if (Ie(f, d) && a.ref === b.ref) if (dh = false, b.pendingProps = d = f, 0 !== (a.lanes & e)) 0 !== (a.flags & 131072) && (dh = true);
          else return b.lanes = a.lanes, Zi(a, b, e);
        }
        return cj(a, b, c, d, e);
      }
      function dj(a, b, c) {
        var d = b.pendingProps, e = d.children, f = null !== a ? a.memoizedState : null;
        if ("hidden" === d.mode) if (0 === (b.mode & 1)) b.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G(ej, fj), fj |= c;
        else {
          if (0 === (c & 1073741824)) return a = null !== f ? f.baseLanes | c : c, b.lanes = b.childLanes = 1073741824, b.memoizedState = { baseLanes: a, cachePool: null, transitions: null }, b.updateQueue = null, G(ej, fj), fj |= a, null;
          b.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
          d = null !== f ? f.baseLanes : c;
          G(ej, fj);
          fj |= d;
        }
        else null !== f ? (d = f.baseLanes | c, b.memoizedState = null) : d = c, G(ej, fj), fj |= d;
        Xi(a, b, e, c);
        return b.child;
      }
      function gj(a, b) {
        var c = b.ref;
        if (null === a && null !== c || null !== a && a.ref !== c) b.flags |= 512, b.flags |= 2097152;
      }
      function cj(a, b, c, d, e) {
        var f = Zf(c) ? Xf : H.current;
        f = Yf(b, f);
        ch(b, e);
        c = Nh(a, b, c, d, f, e);
        d = Sh();
        if (null !== a && !dh) return b.updateQueue = a.updateQueue, b.flags &= -2053, a.lanes &= ~e, Zi(a, b, e);
        I && d && vg(b);
        b.flags |= 1;
        Xi(a, b, c, e);
        return b.child;
      }
      function hj(a, b, c, d, e) {
        if (Zf(c)) {
          var f = true;
          cg(b);
        } else f = false;
        ch(b, e);
        if (null === b.stateNode) ij(a, b), Gi(b, c, d), Ii(b, c, d, e), d = true;
        else if (null === a) {
          var g = b.stateNode, h = b.memoizedProps;
          g.props = h;
          var k = g.context, l = c.contextType;
          "object" === typeof l && null !== l ? l = eh(l) : (l = Zf(c) ? Xf : H.current, l = Yf(b, l));
          var m = c.getDerivedStateFromProps, q = "function" === typeof m || "function" === typeof g.getSnapshotBeforeUpdate;
          q || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== d || k !== l) && Hi(b, g, d, l);
          jh = false;
          var r = b.memoizedState;
          g.state = r;
          qh(b, d, g, e);
          k = b.memoizedState;
          h !== d || r !== k || Wf.current || jh ? ("function" === typeof m && (Di(b, c, m, d), k = b.memoizedState), (h = jh || Fi(b, c, h, d, r, k, l)) ? (q || "function" !== typeof g.UNSAFE_componentWillMount && "function" !== typeof g.componentWillMount || ("function" === typeof g.componentWillMount && g.componentWillMount(), "function" === typeof g.UNSAFE_componentWillMount && g.UNSAFE_componentWillMount()), "function" === typeof g.componentDidMount && (b.flags |= 4194308)) : ("function" === typeof g.componentDidMount && (b.flags |= 4194308), b.memoizedProps = d, b.memoizedState = k), g.props = d, g.state = k, g.context = l, d = h) : ("function" === typeof g.componentDidMount && (b.flags |= 4194308), d = false);
        } else {
          g = b.stateNode;
          lh(a, b);
          h = b.memoizedProps;
          l = b.type === b.elementType ? h : Ci(b.type, h);
          g.props = l;
          q = b.pendingProps;
          r = g.context;
          k = c.contextType;
          "object" === typeof k && null !== k ? k = eh(k) : (k = Zf(c) ? Xf : H.current, k = Yf(b, k));
          var y = c.getDerivedStateFromProps;
          (m = "function" === typeof y || "function" === typeof g.getSnapshotBeforeUpdate) || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== q || r !== k) && Hi(b, g, d, k);
          jh = false;
          r = b.memoizedState;
          g.state = r;
          qh(b, d, g, e);
          var n = b.memoizedState;
          h !== q || r !== n || Wf.current || jh ? ("function" === typeof y && (Di(b, c, y, d), n = b.memoizedState), (l = jh || Fi(b, c, l, d, r, n, k) || false) ? (m || "function" !== typeof g.UNSAFE_componentWillUpdate && "function" !== typeof g.componentWillUpdate || ("function" === typeof g.componentWillUpdate && g.componentWillUpdate(d, n, k), "function" === typeof g.UNSAFE_componentWillUpdate && g.UNSAFE_componentWillUpdate(d, n, k)), "function" === typeof g.componentDidUpdate && (b.flags |= 4), "function" === typeof g.getSnapshotBeforeUpdate && (b.flags |= 1024)) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 1024), b.memoizedProps = d, b.memoizedState = n), g.props = d, g.state = n, g.context = k, d = l) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 1024), d = false);
        }
        return jj(a, b, c, d, f, e);
      }
      function jj(a, b, c, d, e, f) {
        gj(a, b);
        var g = 0 !== (b.flags & 128);
        if (!d && !g) return e && dg(b, c, false), Zi(a, b, f);
        d = b.stateNode;
        Wi.current = b;
        var h = g && "function" !== typeof c.getDerivedStateFromError ? null : d.render();
        b.flags |= 1;
        null !== a && g ? (b.child = Ug(b, a.child, null, f), b.child = Ug(b, null, h, f)) : Xi(a, b, h, f);
        b.memoizedState = d.state;
        e && dg(b, c, true);
        return b.child;
      }
      function kj(a) {
        var b = a.stateNode;
        b.pendingContext ? ag(a, b.pendingContext, b.pendingContext !== b.context) : b.context && ag(a, b.context, false);
        yh(a, b.containerInfo);
      }
      function lj(a, b, c, d, e) {
        Ig();
        Jg(e);
        b.flags |= 256;
        Xi(a, b, c, d);
        return b.child;
      }
      var mj = { dehydrated: null, treeContext: null, retryLane: 0 };
      function nj(a) {
        return { baseLanes: a, cachePool: null, transitions: null };
      }
      function oj(a, b, c) {
        var d = b.pendingProps, e = L.current, f = false, g = 0 !== (b.flags & 128), h;
        (h = g) || (h = null !== a && null === a.memoizedState ? false : 0 !== (e & 2));
        if (h) f = true, b.flags &= -129;
        else if (null === a || null !== a.memoizedState) e |= 1;
        G(L, e & 1);
        if (null === a) {
          Eg(b);
          a = b.memoizedState;
          if (null !== a && (a = a.dehydrated, null !== a)) return 0 === (b.mode & 1) ? b.lanes = 1 : "$!" === a.data ? b.lanes = 8 : b.lanes = 1073741824, null;
          g = d.children;
          a = d.fallback;
          return f ? (d = b.mode, f = b.child, g = { mode: "hidden", children: g }, 0 === (d & 1) && null !== f ? (f.childLanes = 0, f.pendingProps = g) : f = pj(g, d, 0, null), a = Tg(a, d, c, null), f.return = b, a.return = b, f.sibling = a, b.child = f, b.child.memoizedState = nj(c), b.memoizedState = mj, a) : qj(b, g);
        }
        e = a.memoizedState;
        if (null !== e && (h = e.dehydrated, null !== h)) return rj(a, b, g, d, h, e, c);
        if (f) {
          f = d.fallback;
          g = b.mode;
          e = a.child;
          h = e.sibling;
          var k = { mode: "hidden", children: d.children };
          0 === (g & 1) && b.child !== e ? (d = b.child, d.childLanes = 0, d.pendingProps = k, b.deletions = null) : (d = Pg(e, k), d.subtreeFlags = e.subtreeFlags & 14680064);
          null !== h ? f = Pg(h, f) : (f = Tg(f, g, c, null), f.flags |= 2);
          f.return = b;
          d.return = b;
          d.sibling = f;
          b.child = d;
          d = f;
          f = b.child;
          g = a.child.memoizedState;
          g = null === g ? nj(c) : { baseLanes: g.baseLanes | c, cachePool: null, transitions: g.transitions };
          f.memoizedState = g;
          f.childLanes = a.childLanes & ~c;
          b.memoizedState = mj;
          return d;
        }
        f = a.child;
        a = f.sibling;
        d = Pg(f, { mode: "visible", children: d.children });
        0 === (b.mode & 1) && (d.lanes = c);
        d.return = b;
        d.sibling = null;
        null !== a && (c = b.deletions, null === c ? (b.deletions = [a], b.flags |= 16) : c.push(a));
        b.child = d;
        b.memoizedState = null;
        return d;
      }
      function qj(a, b) {
        b = pj({ mode: "visible", children: b }, a.mode, 0, null);
        b.return = a;
        return a.child = b;
      }
      function sj(a, b, c, d) {
        null !== d && Jg(d);
        Ug(b, a.child, null, c);
        a = qj(b, b.pendingProps.children);
        a.flags |= 2;
        b.memoizedState = null;
        return a;
      }
      function rj(a, b, c, d, e, f, g) {
        if (c) {
          if (b.flags & 256) return b.flags &= -257, d = Ki(Error(p(422))), sj(a, b, g, d);
          if (null !== b.memoizedState) return b.child = a.child, b.flags |= 128, null;
          f = d.fallback;
          e = b.mode;
          d = pj({ mode: "visible", children: d.children }, e, 0, null);
          f = Tg(f, e, g, null);
          f.flags |= 2;
          d.return = b;
          f.return = b;
          d.sibling = f;
          b.child = d;
          0 !== (b.mode & 1) && Ug(b, a.child, null, g);
          b.child.memoizedState = nj(g);
          b.memoizedState = mj;
          return f;
        }
        if (0 === (b.mode & 1)) return sj(a, b, g, null);
        if ("$!" === e.data) {
          d = e.nextSibling && e.nextSibling.dataset;
          if (d) var h = d.dgst;
          d = h;
          f = Error(p(419));
          d = Ki(f, d, void 0);
          return sj(a, b, g, d);
        }
        h = 0 !== (g & a.childLanes);
        if (dh || h) {
          d = Q;
          if (null !== d) {
            switch (g & -g) {
              case 4:
                e = 2;
                break;
              case 16:
                e = 8;
                break;
              case 64:
              case 128:
              case 256:
              case 512:
              case 1024:
              case 2048:
              case 4096:
              case 8192:
              case 16384:
              case 32768:
              case 65536:
              case 131072:
              case 262144:
              case 524288:
              case 1048576:
              case 2097152:
              case 4194304:
              case 8388608:
              case 16777216:
              case 33554432:
              case 67108864:
                e = 32;
                break;
              case 536870912:
                e = 268435456;
                break;
              default:
                e = 0;
            }
            e = 0 !== (e & (d.suspendedLanes | g)) ? 0 : e;
            0 !== e && e !== f.retryLane && (f.retryLane = e, ih(a, e), gi(d, a, e, -1));
          }
          tj();
          d = Ki(Error(p(421)));
          return sj(a, b, g, d);
        }
        if ("$?" === e.data) return b.flags |= 128, b.child = a.child, b = uj.bind(null, a), e._reactRetry = b, null;
        a = f.treeContext;
        yg = Lf(e.nextSibling);
        xg = b;
        I = true;
        zg = null;
        null !== a && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a.id, sg = a.overflow, qg = b);
        b = qj(b, d.children);
        b.flags |= 4096;
        return b;
      }
      function vj(a, b, c) {
        a.lanes |= b;
        var d = a.alternate;
        null !== d && (d.lanes |= b);
        bh(a.return, b, c);
      }
      function wj(a, b, c, d, e) {
        var f = a.memoizedState;
        null === f ? a.memoizedState = { isBackwards: b, rendering: null, renderingStartTime: 0, last: d, tail: c, tailMode: e } : (f.isBackwards = b, f.rendering = null, f.renderingStartTime = 0, f.last = d, f.tail = c, f.tailMode = e);
      }
      function xj(a, b, c) {
        var d = b.pendingProps, e = d.revealOrder, f = d.tail;
        Xi(a, b, d.children, c);
        d = L.current;
        if (0 !== (d & 2)) d = d & 1 | 2, b.flags |= 128;
        else {
          if (null !== a && 0 !== (a.flags & 128)) a: for (a = b.child; null !== a; ) {
            if (13 === a.tag) null !== a.memoizedState && vj(a, c, b);
            else if (19 === a.tag) vj(a, c, b);
            else if (null !== a.child) {
              a.child.return = a;
              a = a.child;
              continue;
            }
            if (a === b) break a;
            for (; null === a.sibling; ) {
              if (null === a.return || a.return === b) break a;
              a = a.return;
            }
            a.sibling.return = a.return;
            a = a.sibling;
          }
          d &= 1;
        }
        G(L, d);
        if (0 === (b.mode & 1)) b.memoizedState = null;
        else switch (e) {
          case "forwards":
            c = b.child;
            for (e = null; null !== c; ) a = c.alternate, null !== a && null === Ch(a) && (e = c), c = c.sibling;
            c = e;
            null === c ? (e = b.child, b.child = null) : (e = c.sibling, c.sibling = null);
            wj(b, false, e, c, f);
            break;
          case "backwards":
            c = null;
            e = b.child;
            for (b.child = null; null !== e; ) {
              a = e.alternate;
              if (null !== a && null === Ch(a)) {
                b.child = e;
                break;
              }
              a = e.sibling;
              e.sibling = c;
              c = e;
              e = a;
            }
            wj(b, true, c, null, f);
            break;
          case "together":
            wj(b, false, null, null, void 0);
            break;
          default:
            b.memoizedState = null;
        }
        return b.child;
      }
      function ij(a, b) {
        0 === (b.mode & 1) && null !== a && (a.alternate = null, b.alternate = null, b.flags |= 2);
      }
      function Zi(a, b, c) {
        null !== a && (b.dependencies = a.dependencies);
        rh |= b.lanes;
        if (0 === (c & b.childLanes)) return null;
        if (null !== a && b.child !== a.child) throw Error(p(153));
        if (null !== b.child) {
          a = b.child;
          c = Pg(a, a.pendingProps);
          b.child = c;
          for (c.return = b; null !== a.sibling; ) a = a.sibling, c = c.sibling = Pg(a, a.pendingProps), c.return = b;
          c.sibling = null;
        }
        return b.child;
      }
      function yj(a, b, c) {
        switch (b.tag) {
          case 3:
            kj(b);
            Ig();
            break;
          case 5:
            Ah(b);
            break;
          case 1:
            Zf(b.type) && cg(b);
            break;
          case 4:
            yh(b, b.stateNode.containerInfo);
            break;
          case 10:
            var d = b.type._context, e = b.memoizedProps.value;
            G(Wg, d._currentValue);
            d._currentValue = e;
            break;
          case 13:
            d = b.memoizedState;
            if (null !== d) {
              if (null !== d.dehydrated) return G(L, L.current & 1), b.flags |= 128, null;
              if (0 !== (c & b.child.childLanes)) return oj(a, b, c);
              G(L, L.current & 1);
              a = Zi(a, b, c);
              return null !== a ? a.sibling : null;
            }
            G(L, L.current & 1);
            break;
          case 19:
            d = 0 !== (c & b.childLanes);
            if (0 !== (a.flags & 128)) {
              if (d) return xj(a, b, c);
              b.flags |= 128;
            }
            e = b.memoizedState;
            null !== e && (e.rendering = null, e.tail = null, e.lastEffect = null);
            G(L, L.current);
            if (d) break;
            else return null;
          case 22:
          case 23:
            return b.lanes = 0, dj(a, b, c);
        }
        return Zi(a, b, c);
      }
      var zj;
      var Aj;
      var Bj;
      var Cj;
      zj = function(a, b) {
        for (var c = b.child; null !== c; ) {
          if (5 === c.tag || 6 === c.tag) a.appendChild(c.stateNode);
          else if (4 !== c.tag && null !== c.child) {
            c.child.return = c;
            c = c.child;
            continue;
          }
          if (c === b) break;
          for (; null === c.sibling; ) {
            if (null === c.return || c.return === b) return;
            c = c.return;
          }
          c.sibling.return = c.return;
          c = c.sibling;
        }
      };
      Aj = function() {
      };
      Bj = function(a, b, c, d) {
        var e = a.memoizedProps;
        if (e !== d) {
          a = b.stateNode;
          xh(uh.current);
          var f = null;
          switch (c) {
            case "input":
              e = Ya(a, e);
              d = Ya(a, d);
              f = [];
              break;
            case "select":
              e = A({}, e, { value: void 0 });
              d = A({}, d, { value: void 0 });
              f = [];
              break;
            case "textarea":
              e = gb(a, e);
              d = gb(a, d);
              f = [];
              break;
            default:
              "function" !== typeof e.onClick && "function" === typeof d.onClick && (a.onclick = Bf);
          }
          ub(c, d);
          var g;
          c = null;
          for (l in e) if (!d.hasOwnProperty(l) && e.hasOwnProperty(l) && null != e[l]) if ("style" === l) {
            var h = e[l];
            for (g in h) h.hasOwnProperty(g) && (c || (c = {}), c[g] = "");
          } else "dangerouslySetInnerHTML" !== l && "children" !== l && "suppressContentEditableWarning" !== l && "suppressHydrationWarning" !== l && "autoFocus" !== l && (ea.hasOwnProperty(l) ? f || (f = []) : (f = f || []).push(l, null));
          for (l in d) {
            var k = d[l];
            h = null != e ? e[l] : void 0;
            if (d.hasOwnProperty(l) && k !== h && (null != k || null != h)) if ("style" === l) if (h) {
              for (g in h) !h.hasOwnProperty(g) || k && k.hasOwnProperty(g) || (c || (c = {}), c[g] = "");
              for (g in k) k.hasOwnProperty(g) && h[g] !== k[g] && (c || (c = {}), c[g] = k[g]);
            } else c || (f || (f = []), f.push(
              l,
              c
            )), c = k;
            else "dangerouslySetInnerHTML" === l ? (k = k ? k.__html : void 0, h = h ? h.__html : void 0, null != k && h !== k && (f = f || []).push(l, k)) : "children" === l ? "string" !== typeof k && "number" !== typeof k || (f = f || []).push(l, "" + k) : "suppressContentEditableWarning" !== l && "suppressHydrationWarning" !== l && (ea.hasOwnProperty(l) ? (null != k && "onScroll" === l && D("scroll", a), f || h === k || (f = [])) : (f = f || []).push(l, k));
          }
          c && (f = f || []).push("style", c);
          var l = f;
          if (b.updateQueue = l) b.flags |= 4;
        }
      };
      Cj = function(a, b, c, d) {
        c !== d && (b.flags |= 4);
      };
      function Dj(a, b) {
        if (!I) switch (a.tailMode) {
          case "hidden":
            b = a.tail;
            for (var c = null; null !== b; ) null !== b.alternate && (c = b), b = b.sibling;
            null === c ? a.tail = null : c.sibling = null;
            break;
          case "collapsed":
            c = a.tail;
            for (var d = null; null !== c; ) null !== c.alternate && (d = c), c = c.sibling;
            null === d ? b || null === a.tail ? a.tail = null : a.tail.sibling = null : d.sibling = null;
        }
      }
      function S(a) {
        var b = null !== a.alternate && a.alternate.child === a.child, c = 0, d = 0;
        if (b) for (var e = a.child; null !== e; ) c |= e.lanes | e.childLanes, d |= e.subtreeFlags & 14680064, d |= e.flags & 14680064, e.return = a, e = e.sibling;
        else for (e = a.child; null !== e; ) c |= e.lanes | e.childLanes, d |= e.subtreeFlags, d |= e.flags, e.return = a, e = e.sibling;
        a.subtreeFlags |= d;
        a.childLanes = c;
        return b;
      }
      function Ej(a, b, c) {
        var d = b.pendingProps;
        wg(b);
        switch (b.tag) {
          case 2:
          case 16:
          case 15:
          case 0:
          case 11:
          case 7:
          case 8:
          case 12:
          case 9:
          case 14:
            return S(b), null;
          case 1:
            return Zf(b.type) && $f(), S(b), null;
          case 3:
            d = b.stateNode;
            zh();
            E(Wf);
            E(H);
            Eh();
            d.pendingContext && (d.context = d.pendingContext, d.pendingContext = null);
            if (null === a || null === a.child) Gg(b) ? b.flags |= 4 : null === a || a.memoizedState.isDehydrated && 0 === (b.flags & 256) || (b.flags |= 1024, null !== zg && (Fj(zg), zg = null));
            Aj(a, b);
            S(b);
            return null;
          case 5:
            Bh(b);
            var e = xh(wh.current);
            c = b.type;
            if (null !== a && null != b.stateNode) Bj(a, b, c, d, e), a.ref !== b.ref && (b.flags |= 512, b.flags |= 2097152);
            else {
              if (!d) {
                if (null === b.stateNode) throw Error(p(166));
                S(b);
                return null;
              }
              a = xh(uh.current);
              if (Gg(b)) {
                d = b.stateNode;
                c = b.type;
                var f = b.memoizedProps;
                d[Of] = b;
                d[Pf] = f;
                a = 0 !== (b.mode & 1);
                switch (c) {
                  case "dialog":
                    D("cancel", d);
                    D("close", d);
                    break;
                  case "iframe":
                  case "object":
                  case "embed":
                    D("load", d);
                    break;
                  case "video":
                  case "audio":
                    for (e = 0; e < lf.length; e++) D(lf[e], d);
                    break;
                  case "source":
                    D("error", d);
                    break;
                  case "img":
                  case "image":
                  case "link":
                    D(
                      "error",
                      d
                    );
                    D("load", d);
                    break;
                  case "details":
                    D("toggle", d);
                    break;
                  case "input":
                    Za(d, f);
                    D("invalid", d);
                    break;
                  case "select":
                    d._wrapperState = { wasMultiple: !!f.multiple };
                    D("invalid", d);
                    break;
                  case "textarea":
                    hb(d, f), D("invalid", d);
                }
                ub(c, f);
                e = null;
                for (var g in f) if (f.hasOwnProperty(g)) {
                  var h = f[g];
                  "children" === g ? "string" === typeof h ? d.textContent !== h && (true !== f.suppressHydrationWarning && Af(d.textContent, h, a), e = ["children", h]) : "number" === typeof h && d.textContent !== "" + h && (true !== f.suppressHydrationWarning && Af(
                    d.textContent,
                    h,
                    a
                  ), e = ["children", "" + h]) : ea.hasOwnProperty(g) && null != h && "onScroll" === g && D("scroll", d);
                }
                switch (c) {
                  case "input":
                    Va(d);
                    db(d, f, true);
                    break;
                  case "textarea":
                    Va(d);
                    jb(d);
                    break;
                  case "select":
                  case "option":
                    break;
                  default:
                    "function" === typeof f.onClick && (d.onclick = Bf);
                }
                d = e;
                b.updateQueue = d;
                null !== d && (b.flags |= 4);
              } else {
                g = 9 === e.nodeType ? e : e.ownerDocument;
                "http://www.w3.org/1999/xhtml" === a && (a = kb(c));
                "http://www.w3.org/1999/xhtml" === a ? "script" === c ? (a = g.createElement("div"), a.innerHTML = "<script><\/script>", a = a.removeChild(a.firstChild)) : "string" === typeof d.is ? a = g.createElement(c, { is: d.is }) : (a = g.createElement(c), "select" === c && (g = a, d.multiple ? g.multiple = true : d.size && (g.size = d.size))) : a = g.createElementNS(a, c);
                a[Of] = b;
                a[Pf] = d;
                zj(a, b, false, false);
                b.stateNode = a;
                a: {
                  g = vb(c, d);
                  switch (c) {
                    case "dialog":
                      D("cancel", a);
                      D("close", a);
                      e = d;
                      break;
                    case "iframe":
                    case "object":
                    case "embed":
                      D("load", a);
                      e = d;
                      break;
                    case "video":
                    case "audio":
                      for (e = 0; e < lf.length; e++) D(lf[e], a);
                      e = d;
                      break;
                    case "source":
                      D("error", a);
                      e = d;
                      break;
                    case "img":
                    case "image":
                    case "link":
                      D(
                        "error",
                        a
                      );
                      D("load", a);
                      e = d;
                      break;
                    case "details":
                      D("toggle", a);
                      e = d;
                      break;
                    case "input":
                      Za(a, d);
                      e = Ya(a, d);
                      D("invalid", a);
                      break;
                    case "option":
                      e = d;
                      break;
                    case "select":
                      a._wrapperState = { wasMultiple: !!d.multiple };
                      e = A({}, d, { value: void 0 });
                      D("invalid", a);
                      break;
                    case "textarea":
                      hb(a, d);
                      e = gb(a, d);
                      D("invalid", a);
                      break;
                    default:
                      e = d;
                  }
                  ub(c, e);
                  h = e;
                  for (f in h) if (h.hasOwnProperty(f)) {
                    var k = h[f];
                    "style" === f ? sb(a, k) : "dangerouslySetInnerHTML" === f ? (k = k ? k.__html : void 0, null != k && nb(a, k)) : "children" === f ? "string" === typeof k ? ("textarea" !== c || "" !== k) && ob(a, k) : "number" === typeof k && ob(a, "" + k) : "suppressContentEditableWarning" !== f && "suppressHydrationWarning" !== f && "autoFocus" !== f && (ea.hasOwnProperty(f) ? null != k && "onScroll" === f && D("scroll", a) : null != k && ta(a, f, k, g));
                  }
                  switch (c) {
                    case "input":
                      Va(a);
                      db(a, d, false);
                      break;
                    case "textarea":
                      Va(a);
                      jb(a);
                      break;
                    case "option":
                      null != d.value && a.setAttribute("value", "" + Sa(d.value));
                      break;
                    case "select":
                      a.multiple = !!d.multiple;
                      f = d.value;
                      null != f ? fb(a, !!d.multiple, f, false) : null != d.defaultValue && fb(
                        a,
                        !!d.multiple,
                        d.defaultValue,
                        true
                      );
                      break;
                    default:
                      "function" === typeof e.onClick && (a.onclick = Bf);
                  }
                  switch (c) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                      d = !!d.autoFocus;
                      break a;
                    case "img":
                      d = true;
                      break a;
                    default:
                      d = false;
                  }
                }
                d && (b.flags |= 4);
              }
              null !== b.ref && (b.flags |= 512, b.flags |= 2097152);
            }
            S(b);
            return null;
          case 6:
            if (a && null != b.stateNode) Cj(a, b, a.memoizedProps, d);
            else {
              if ("string" !== typeof d && null === b.stateNode) throw Error(p(166));
              c = xh(wh.current);
              xh(uh.current);
              if (Gg(b)) {
                d = b.stateNode;
                c = b.memoizedProps;
                d[Of] = b;
                if (f = d.nodeValue !== c) {
                  if (a = xg, null !== a) switch (a.tag) {
                    case 3:
                      Af(d.nodeValue, c, 0 !== (a.mode & 1));
                      break;
                    case 5:
                      true !== a.memoizedProps.suppressHydrationWarning && Af(d.nodeValue, c, 0 !== (a.mode & 1));
                  }
                }
                f && (b.flags |= 4);
              } else d = (9 === c.nodeType ? c : c.ownerDocument).createTextNode(d), d[Of] = b, b.stateNode = d;
            }
            S(b);
            return null;
          case 13:
            E(L);
            d = b.memoizedState;
            if (null === a || null !== a.memoizedState && null !== a.memoizedState.dehydrated) {
              if (I && null !== yg && 0 !== (b.mode & 1) && 0 === (b.flags & 128)) Hg(), Ig(), b.flags |= 98560, f = false;
              else if (f = Gg(b), null !== d && null !== d.dehydrated) {
                if (null === a) {
                  if (!f) throw Error(p(318));
                  f = b.memoizedState;
                  f = null !== f ? f.dehydrated : null;
                  if (!f) throw Error(p(317));
                  f[Of] = b;
                } else Ig(), 0 === (b.flags & 128) && (b.memoizedState = null), b.flags |= 4;
                S(b);
                f = false;
              } else null !== zg && (Fj(zg), zg = null), f = true;
              if (!f) return b.flags & 65536 ? b : null;
            }
            if (0 !== (b.flags & 128)) return b.lanes = c, b;
            d = null !== d;
            d !== (null !== a && null !== a.memoizedState) && d && (b.child.flags |= 8192, 0 !== (b.mode & 1) && (null === a || 0 !== (L.current & 1) ? 0 === T && (T = 3) : tj()));
            null !== b.updateQueue && (b.flags |= 4);
            S(b);
            return null;
          case 4:
            return zh(), Aj(a, b), null === a && sf(b.stateNode.containerInfo), S(b), null;
          case 10:
            return ah(b.type._context), S(b), null;
          case 17:
            return Zf(b.type) && $f(), S(b), null;
          case 19:
            E(L);
            f = b.memoizedState;
            if (null === f) return S(b), null;
            d = 0 !== (b.flags & 128);
            g = f.rendering;
            if (null === g) if (d) Dj(f, false);
            else {
              if (0 !== T || null !== a && 0 !== (a.flags & 128)) for (a = b.child; null !== a; ) {
                g = Ch(a);
                if (null !== g) {
                  b.flags |= 128;
                  Dj(f, false);
                  d = g.updateQueue;
                  null !== d && (b.updateQueue = d, b.flags |= 4);
                  b.subtreeFlags = 0;
                  d = c;
                  for (c = b.child; null !== c; ) f = c, a = d, f.flags &= 14680066, g = f.alternate, null === g ? (f.childLanes = 0, f.lanes = a, f.child = null, f.subtreeFlags = 0, f.memoizedProps = null, f.memoizedState = null, f.updateQueue = null, f.dependencies = null, f.stateNode = null) : (f.childLanes = g.childLanes, f.lanes = g.lanes, f.child = g.child, f.subtreeFlags = 0, f.deletions = null, f.memoizedProps = g.memoizedProps, f.memoizedState = g.memoizedState, f.updateQueue = g.updateQueue, f.type = g.type, a = g.dependencies, f.dependencies = null === a ? null : { lanes: a.lanes, firstContext: a.firstContext }), c = c.sibling;
                  G(L, L.current & 1 | 2);
                  return b.child;
                }
                a = a.sibling;
              }
              null !== f.tail && B() > Gj && (b.flags |= 128, d = true, Dj(f, false), b.lanes = 4194304);
            }
            else {
              if (!d) if (a = Ch(g), null !== a) {
                if (b.flags |= 128, d = true, c = a.updateQueue, null !== c && (b.updateQueue = c, b.flags |= 4), Dj(f, true), null === f.tail && "hidden" === f.tailMode && !g.alternate && !I) return S(b), null;
              } else 2 * B() - f.renderingStartTime > Gj && 1073741824 !== c && (b.flags |= 128, d = true, Dj(f, false), b.lanes = 4194304);
              f.isBackwards ? (g.sibling = b.child, b.child = g) : (c = f.last, null !== c ? c.sibling = g : b.child = g, f.last = g);
            }
            if (null !== f.tail) return b = f.tail, f.rendering = b, f.tail = b.sibling, f.renderingStartTime = B(), b.sibling = null, c = L.current, G(L, d ? c & 1 | 2 : c & 1), b;
            S(b);
            return null;
          case 22:
          case 23:
            return Hj(), d = null !== b.memoizedState, null !== a && null !== a.memoizedState !== d && (b.flags |= 8192), d && 0 !== (b.mode & 1) ? 0 !== (fj & 1073741824) && (S(b), b.subtreeFlags & 6 && (b.flags |= 8192)) : S(b), null;
          case 24:
            return null;
          case 25:
            return null;
        }
        throw Error(p(156, b.tag));
      }
      function Ij(a, b) {
        wg(b);
        switch (b.tag) {
          case 1:
            return Zf(b.type) && $f(), a = b.flags, a & 65536 ? (b.flags = a & -65537 | 128, b) : null;
          case 3:
            return zh(), E(Wf), E(H), Eh(), a = b.flags, 0 !== (a & 65536) && 0 === (a & 128) ? (b.flags = a & -65537 | 128, b) : null;
          case 5:
            return Bh(b), null;
          case 13:
            E(L);
            a = b.memoizedState;
            if (null !== a && null !== a.dehydrated) {
              if (null === b.alternate) throw Error(p(340));
              Ig();
            }
            a = b.flags;
            return a & 65536 ? (b.flags = a & -65537 | 128, b) : null;
          case 19:
            return E(L), null;
          case 4:
            return zh(), null;
          case 10:
            return ah(b.type._context), null;
          case 22:
          case 23:
            return Hj(), null;
          case 24:
            return null;
          default:
            return null;
        }
      }
      var Jj = false;
      var U = false;
      var Kj = "function" === typeof WeakSet ? WeakSet : Set;
      var V = null;
      function Lj(a, b) {
        var c = a.ref;
        if (null !== c) if ("function" === typeof c) try {
          c(null);
        } catch (d) {
          W(a, b, d);
        }
        else c.current = null;
      }
      function Mj(a, b, c) {
        try {
          c();
        } catch (d) {
          W(a, b, d);
        }
      }
      var Nj = false;
      function Oj(a, b) {
        Cf = dd;
        a = Me();
        if (Ne(a)) {
          if ("selectionStart" in a) var c = { start: a.selectionStart, end: a.selectionEnd };
          else a: {
            c = (c = a.ownerDocument) && c.defaultView || window;
            var d = c.getSelection && c.getSelection();
            if (d && 0 !== d.rangeCount) {
              c = d.anchorNode;
              var e = d.anchorOffset, f = d.focusNode;
              d = d.focusOffset;
              try {
                c.nodeType, f.nodeType;
              } catch (F) {
                c = null;
                break a;
              }
              var g = 0, h = -1, k = -1, l = 0, m = 0, q = a, r = null;
              b: for (; ; ) {
                for (var y; ; ) {
                  q !== c || 0 !== e && 3 !== q.nodeType || (h = g + e);
                  q !== f || 0 !== d && 3 !== q.nodeType || (k = g + d);
                  3 === q.nodeType && (g += q.nodeValue.length);
                  if (null === (y = q.firstChild)) break;
                  r = q;
                  q = y;
                }
                for (; ; ) {
                  if (q === a) break b;
                  r === c && ++l === e && (h = g);
                  r === f && ++m === d && (k = g);
                  if (null !== (y = q.nextSibling)) break;
                  q = r;
                  r = q.parentNode;
                }
                q = y;
              }
              c = -1 === h || -1 === k ? null : { start: h, end: k };
            } else c = null;
          }
          c = c || { start: 0, end: 0 };
        } else c = null;
        Df = { focusedElem: a, selectionRange: c };
        dd = false;
        for (V = b; null !== V; ) if (b = V, a = b.child, 0 !== (b.subtreeFlags & 1028) && null !== a) a.return = b, V = a;
        else for (; null !== V; ) {
          b = V;
          try {
            var n = b.alternate;
            if (0 !== (b.flags & 1024)) switch (b.tag) {
              case 0:
              case 11:
              case 15:
                break;
              case 1:
                if (null !== n) {
                  var t = n.memoizedProps, J = n.memoizedState, x = b.stateNode, w = x.getSnapshotBeforeUpdate(b.elementType === b.type ? t : Ci(b.type, t), J);
                  x.__reactInternalSnapshotBeforeUpdate = w;
                }
                break;
              case 3:
                var u = b.stateNode.containerInfo;
                1 === u.nodeType ? u.textContent = "" : 9 === u.nodeType && u.documentElement && u.removeChild(u.documentElement);
                break;
              case 5:
              case 6:
              case 4:
              case 17:
                break;
              default:
                throw Error(p(163));
            }
          } catch (F) {
            W(b, b.return, F);
          }
          a = b.sibling;
          if (null !== a) {
            a.return = b.return;
            V = a;
            break;
          }
          V = b.return;
        }
        n = Nj;
        Nj = false;
        return n;
      }
      function Pj(a, b, c) {
        var d = b.updateQueue;
        d = null !== d ? d.lastEffect : null;
        if (null !== d) {
          var e = d = d.next;
          do {
            if ((e.tag & a) === a) {
              var f = e.destroy;
              e.destroy = void 0;
              void 0 !== f && Mj(b, c, f);
            }
            e = e.next;
          } while (e !== d);
        }
      }
      function Qj(a, b) {
        b = b.updateQueue;
        b = null !== b ? b.lastEffect : null;
        if (null !== b) {
          var c = b = b.next;
          do {
            if ((c.tag & a) === a) {
              var d = c.create;
              c.destroy = d();
            }
            c = c.next;
          } while (c !== b);
        }
      }
      function Rj(a) {
        var b = a.ref;
        if (null !== b) {
          var c = a.stateNode;
          switch (a.tag) {
            case 5:
              a = c;
              break;
            default:
              a = c;
          }
          "function" === typeof b ? b(a) : b.current = a;
        }
      }
      function Sj(a) {
        var b = a.alternate;
        null !== b && (a.alternate = null, Sj(b));
        a.child = null;
        a.deletions = null;
        a.sibling = null;
        5 === a.tag && (b = a.stateNode, null !== b && (delete b[Of], delete b[Pf], delete b[of], delete b[Qf], delete b[Rf]));
        a.stateNode = null;
        a.return = null;
        a.dependencies = null;
        a.memoizedProps = null;
        a.memoizedState = null;
        a.pendingProps = null;
        a.stateNode = null;
        a.updateQueue = null;
      }
      function Tj(a) {
        return 5 === a.tag || 3 === a.tag || 4 === a.tag;
      }
      function Uj(a) {
        a: for (; ; ) {
          for (; null === a.sibling; ) {
            if (null === a.return || Tj(a.return)) return null;
            a = a.return;
          }
          a.sibling.return = a.return;
          for (a = a.sibling; 5 !== a.tag && 6 !== a.tag && 18 !== a.tag; ) {
            if (a.flags & 2) continue a;
            if (null === a.child || 4 === a.tag) continue a;
            else a.child.return = a, a = a.child;
          }
          if (!(a.flags & 2)) return a.stateNode;
        }
      }
      function Vj(a, b, c) {
        var d = a.tag;
        if (5 === d || 6 === d) a = a.stateNode, b ? 8 === c.nodeType ? c.parentNode.insertBefore(a, b) : c.insertBefore(a, b) : (8 === c.nodeType ? (b = c.parentNode, b.insertBefore(a, c)) : (b = c, b.appendChild(a)), c = c._reactRootContainer, null !== c && void 0 !== c || null !== b.onclick || (b.onclick = Bf));
        else if (4 !== d && (a = a.child, null !== a)) for (Vj(a, b, c), a = a.sibling; null !== a; ) Vj(a, b, c), a = a.sibling;
      }
      function Wj(a, b, c) {
        var d = a.tag;
        if (5 === d || 6 === d) a = a.stateNode, b ? c.insertBefore(a, b) : c.appendChild(a);
        else if (4 !== d && (a = a.child, null !== a)) for (Wj(a, b, c), a = a.sibling; null !== a; ) Wj(a, b, c), a = a.sibling;
      }
      var X = null;
      var Xj = false;
      function Yj(a, b, c) {
        for (c = c.child; null !== c; ) Zj(a, b, c), c = c.sibling;
      }
      function Zj(a, b, c) {
        if (lc && "function" === typeof lc.onCommitFiberUnmount) try {
          lc.onCommitFiberUnmount(kc, c);
        } catch (h) {
        }
        switch (c.tag) {
          case 5:
            U || Lj(c, b);
          case 6:
            var d = X, e = Xj;
            X = null;
            Yj(a, b, c);
            X = d;
            Xj = e;
            null !== X && (Xj ? (a = X, c = c.stateNode, 8 === a.nodeType ? a.parentNode.removeChild(c) : a.removeChild(c)) : X.removeChild(c.stateNode));
            break;
          case 18:
            null !== X && (Xj ? (a = X, c = c.stateNode, 8 === a.nodeType ? Kf(a.parentNode, c) : 1 === a.nodeType && Kf(a, c), bd(a)) : Kf(X, c.stateNode));
            break;
          case 4:
            d = X;
            e = Xj;
            X = c.stateNode.containerInfo;
            Xj = true;
            Yj(a, b, c);
            X = d;
            Xj = e;
            break;
          case 0:
          case 11:
          case 14:
          case 15:
            if (!U && (d = c.updateQueue, null !== d && (d = d.lastEffect, null !== d))) {
              e = d = d.next;
              do {
                var f = e, g = f.destroy;
                f = f.tag;
                void 0 !== g && (0 !== (f & 2) ? Mj(c, b, g) : 0 !== (f & 4) && Mj(c, b, g));
                e = e.next;
              } while (e !== d);
            }
            Yj(a, b, c);
            break;
          case 1:
            if (!U && (Lj(c, b), d = c.stateNode, "function" === typeof d.componentWillUnmount)) try {
              d.props = c.memoizedProps, d.state = c.memoizedState, d.componentWillUnmount();
            } catch (h) {
              W(c, b, h);
            }
            Yj(a, b, c);
            break;
          case 21:
            Yj(a, b, c);
            break;
          case 22:
            c.mode & 1 ? (U = (d = U) || null !== c.memoizedState, Yj(a, b, c), U = d) : Yj(a, b, c);
            break;
          default:
            Yj(a, b, c);
        }
      }
      function ak(a) {
        var b = a.updateQueue;
        if (null !== b) {
          a.updateQueue = null;
          var c = a.stateNode;
          null === c && (c = a.stateNode = new Kj());
          b.forEach(function(b2) {
            var d = bk.bind(null, a, b2);
            c.has(b2) || (c.add(b2), b2.then(d, d));
          });
        }
      }
      function ck(a, b) {
        var c = b.deletions;
        if (null !== c) for (var d = 0; d < c.length; d++) {
          var e = c[d];
          try {
            var f = a, g = b, h = g;
            a: for (; null !== h; ) {
              switch (h.tag) {
                case 5:
                  X = h.stateNode;
                  Xj = false;
                  break a;
                case 3:
                  X = h.stateNode.containerInfo;
                  Xj = true;
                  break a;
                case 4:
                  X = h.stateNode.containerInfo;
                  Xj = true;
                  break a;
              }
              h = h.return;
            }
            if (null === X) throw Error(p(160));
            Zj(f, g, e);
            X = null;
            Xj = false;
            var k = e.alternate;
            null !== k && (k.return = null);
            e.return = null;
          } catch (l) {
            W(e, b, l);
          }
        }
        if (b.subtreeFlags & 12854) for (b = b.child; null !== b; ) dk(b, a), b = b.sibling;
      }
      function dk(a, b) {
        var c = a.alternate, d = a.flags;
        switch (a.tag) {
          case 0:
          case 11:
          case 14:
          case 15:
            ck(b, a);
            ek(a);
            if (d & 4) {
              try {
                Pj(3, a, a.return), Qj(3, a);
              } catch (t) {
                W(a, a.return, t);
              }
              try {
                Pj(5, a, a.return);
              } catch (t) {
                W(a, a.return, t);
              }
            }
            break;
          case 1:
            ck(b, a);
            ek(a);
            d & 512 && null !== c && Lj(c, c.return);
            break;
          case 5:
            ck(b, a);
            ek(a);
            d & 512 && null !== c && Lj(c, c.return);
            if (a.flags & 32) {
              var e = a.stateNode;
              try {
                ob(e, "");
              } catch (t) {
                W(a, a.return, t);
              }
            }
            if (d & 4 && (e = a.stateNode, null != e)) {
              var f = a.memoizedProps, g = null !== c ? c.memoizedProps : f, h = a.type, k = a.updateQueue;
              a.updateQueue = null;
              if (null !== k) try {
                "input" === h && "radio" === f.type && null != f.name && ab(e, f);
                vb(h, g);
                var l = vb(h, f);
                for (g = 0; g < k.length; g += 2) {
                  var m = k[g], q = k[g + 1];
                  "style" === m ? sb(e, q) : "dangerouslySetInnerHTML" === m ? nb(e, q) : "children" === m ? ob(e, q) : ta(e, m, q, l);
                }
                switch (h) {
                  case "input":
                    bb(e, f);
                    break;
                  case "textarea":
                    ib(e, f);
                    break;
                  case "select":
                    var r = e._wrapperState.wasMultiple;
                    e._wrapperState.wasMultiple = !!f.multiple;
                    var y = f.value;
                    null != y ? fb(e, !!f.multiple, y, false) : r !== !!f.multiple && (null != f.defaultValue ? fb(
                      e,
                      !!f.multiple,
                      f.defaultValue,
                      true
                    ) : fb(e, !!f.multiple, f.multiple ? [] : "", false));
                }
                e[Pf] = f;
              } catch (t) {
                W(a, a.return, t);
              }
            }
            break;
          case 6:
            ck(b, a);
            ek(a);
            if (d & 4) {
              if (null === a.stateNode) throw Error(p(162));
              e = a.stateNode;
              f = a.memoizedProps;
              try {
                e.nodeValue = f;
              } catch (t) {
                W(a, a.return, t);
              }
            }
            break;
          case 3:
            ck(b, a);
            ek(a);
            if (d & 4 && null !== c && c.memoizedState.isDehydrated) try {
              bd(b.containerInfo);
            } catch (t) {
              W(a, a.return, t);
            }
            break;
          case 4:
            ck(b, a);
            ek(a);
            break;
          case 13:
            ck(b, a);
            ek(a);
            e = a.child;
            e.flags & 8192 && (f = null !== e.memoizedState, e.stateNode.isHidden = f, !f || null !== e.alternate && null !== e.alternate.memoizedState || (fk = B()));
            d & 4 && ak(a);
            break;
          case 22:
            m = null !== c && null !== c.memoizedState;
            a.mode & 1 ? (U = (l = U) || m, ck(b, a), U = l) : ck(b, a);
            ek(a);
            if (d & 8192) {
              l = null !== a.memoizedState;
              if ((a.stateNode.isHidden = l) && !m && 0 !== (a.mode & 1)) for (V = a, m = a.child; null !== m; ) {
                for (q = V = m; null !== V; ) {
                  r = V;
                  y = r.child;
                  switch (r.tag) {
                    case 0:
                    case 11:
                    case 14:
                    case 15:
                      Pj(4, r, r.return);
                      break;
                    case 1:
                      Lj(r, r.return);
                      var n = r.stateNode;
                      if ("function" === typeof n.componentWillUnmount) {
                        d = r;
                        c = r.return;
                        try {
                          b = d, n.props = b.memoizedProps, n.state = b.memoizedState, n.componentWillUnmount();
                        } catch (t) {
                          W(d, c, t);
                        }
                      }
                      break;
                    case 5:
                      Lj(r, r.return);
                      break;
                    case 22:
                      if (null !== r.memoizedState) {
                        gk(q);
                        continue;
                      }
                  }
                  null !== y ? (y.return = r, V = y) : gk(q);
                }
                m = m.sibling;
              }
              a: for (m = null, q = a; ; ) {
                if (5 === q.tag) {
                  if (null === m) {
                    m = q;
                    try {
                      e = q.stateNode, l ? (f = e.style, "function" === typeof f.setProperty ? f.setProperty("display", "none", "important") : f.display = "none") : (h = q.stateNode, k = q.memoizedProps.style, g = void 0 !== k && null !== k && k.hasOwnProperty("display") ? k.display : null, h.style.display = rb("display", g));
                    } catch (t) {
                      W(a, a.return, t);
                    }
                  }
                } else if (6 === q.tag) {
                  if (null === m) try {
                    q.stateNode.nodeValue = l ? "" : q.memoizedProps;
                  } catch (t) {
                    W(a, a.return, t);
                  }
                } else if ((22 !== q.tag && 23 !== q.tag || null === q.memoizedState || q === a) && null !== q.child) {
                  q.child.return = q;
                  q = q.child;
                  continue;
                }
                if (q === a) break a;
                for (; null === q.sibling; ) {
                  if (null === q.return || q.return === a) break a;
                  m === q && (m = null);
                  q = q.return;
                }
                m === q && (m = null);
                q.sibling.return = q.return;
                q = q.sibling;
              }
            }
            break;
          case 19:
            ck(b, a);
            ek(a);
            d & 4 && ak(a);
            break;
          case 21:
            break;
          default:
            ck(
              b,
              a
            ), ek(a);
        }
      }
      function ek(a) {
        var b = a.flags;
        if (b & 2) {
          try {
            a: {
              for (var c = a.return; null !== c; ) {
                if (Tj(c)) {
                  var d = c;
                  break a;
                }
                c = c.return;
              }
              throw Error(p(160));
            }
            switch (d.tag) {
              case 5:
                var e = d.stateNode;
                d.flags & 32 && (ob(e, ""), d.flags &= -33);
                var f = Uj(a);
                Wj(a, f, e);
                break;
              case 3:
              case 4:
                var g = d.stateNode.containerInfo, h = Uj(a);
                Vj(a, h, g);
                break;
              default:
                throw Error(p(161));
            }
          } catch (k) {
            W(a, a.return, k);
          }
          a.flags &= -3;
        }
        b & 4096 && (a.flags &= -4097);
      }
      function hk(a, b, c) {
        V = a;
        ik(a, b, c);
      }
      function ik(a, b, c) {
        for (var d = 0 !== (a.mode & 1); null !== V; ) {
          var e = V, f = e.child;
          if (22 === e.tag && d) {
            var g = null !== e.memoizedState || Jj;
            if (!g) {
              var h = e.alternate, k = null !== h && null !== h.memoizedState || U;
              h = Jj;
              var l = U;
              Jj = g;
              if ((U = k) && !l) for (V = e; null !== V; ) g = V, k = g.child, 22 === g.tag && null !== g.memoizedState ? jk(e) : null !== k ? (k.return = g, V = k) : jk(e);
              for (; null !== f; ) V = f, ik(f, b, c), f = f.sibling;
              V = e;
              Jj = h;
              U = l;
            }
            kk(a, b, c);
          } else 0 !== (e.subtreeFlags & 8772) && null !== f ? (f.return = e, V = f) : kk(a, b, c);
        }
      }
      function kk(a) {
        for (; null !== V; ) {
          var b = V;
          if (0 !== (b.flags & 8772)) {
            var c = b.alternate;
            try {
              if (0 !== (b.flags & 8772)) switch (b.tag) {
                case 0:
                case 11:
                case 15:
                  U || Qj(5, b);
                  break;
                case 1:
                  var d = b.stateNode;
                  if (b.flags & 4 && !U) if (null === c) d.componentDidMount();
                  else {
                    var e = b.elementType === b.type ? c.memoizedProps : Ci(b.type, c.memoizedProps);
                    d.componentDidUpdate(e, c.memoizedState, d.__reactInternalSnapshotBeforeUpdate);
                  }
                  var f = b.updateQueue;
                  null !== f && sh(b, f, d);
                  break;
                case 3:
                  var g = b.updateQueue;
                  if (null !== g) {
                    c = null;
                    if (null !== b.child) switch (b.child.tag) {
                      case 5:
                        c = b.child.stateNode;
                        break;
                      case 1:
                        c = b.child.stateNode;
                    }
                    sh(b, g, c);
                  }
                  break;
                case 5:
                  var h = b.stateNode;
                  if (null === c && b.flags & 4) {
                    c = h;
                    var k = b.memoizedProps;
                    switch (b.type) {
                      case "button":
                      case "input":
                      case "select":
                      case "textarea":
                        k.autoFocus && c.focus();
                        break;
                      case "img":
                        k.src && (c.src = k.src);
                    }
                  }
                  break;
                case 6:
                  break;
                case 4:
                  break;
                case 12:
                  break;
                case 13:
                  if (null === b.memoizedState) {
                    var l = b.alternate;
                    if (null !== l) {
                      var m = l.memoizedState;
                      if (null !== m) {
                        var q = m.dehydrated;
                        null !== q && bd(q);
                      }
                    }
                  }
                  break;
                case 19:
                case 17:
                case 21:
                case 22:
                case 23:
                case 25:
                  break;
                default:
                  throw Error(p(163));
              }
              U || b.flags & 512 && Rj(b);
            } catch (r) {
              W(b, b.return, r);
            }
          }
          if (b === a) {
            V = null;
            break;
          }
          c = b.sibling;
          if (null !== c) {
            c.return = b.return;
            V = c;
            break;
          }
          V = b.return;
        }
      }
      function gk(a) {
        for (; null !== V; ) {
          var b = V;
          if (b === a) {
            V = null;
            break;
          }
          var c = b.sibling;
          if (null !== c) {
            c.return = b.return;
            V = c;
            break;
          }
          V = b.return;
        }
      }
      function jk(a) {
        for (; null !== V; ) {
          var b = V;
          try {
            switch (b.tag) {
              case 0:
              case 11:
              case 15:
                var c = b.return;
                try {
                  Qj(4, b);
                } catch (k) {
                  W(b, c, k);
                }
                break;
              case 1:
                var d = b.stateNode;
                if ("function" === typeof d.componentDidMount) {
                  var e = b.return;
                  try {
                    d.componentDidMount();
                  } catch (k) {
                    W(b, e, k);
                  }
                }
                var f = b.return;
                try {
                  Rj(b);
                } catch (k) {
                  W(b, f, k);
                }
                break;
              case 5:
                var g = b.return;
                try {
                  Rj(b);
                } catch (k) {
                  W(b, g, k);
                }
            }
          } catch (k) {
            W(b, b.return, k);
          }
          if (b === a) {
            V = null;
            break;
          }
          var h = b.sibling;
          if (null !== h) {
            h.return = b.return;
            V = h;
            break;
          }
          V = b.return;
        }
      }
      var lk = Math.ceil;
      var mk = ua.ReactCurrentDispatcher;
      var nk = ua.ReactCurrentOwner;
      var ok = ua.ReactCurrentBatchConfig;
      var K = 0;
      var Q = null;
      var Y = null;
      var Z = 0;
      var fj = 0;
      var ej = Uf(0);
      var T = 0;
      var pk = null;
      var rh = 0;
      var qk = 0;
      var rk = 0;
      var sk = null;
      var tk = null;
      var fk = 0;
      var Gj = Infinity;
      var uk = null;
      var Oi = false;
      var Pi = null;
      var Ri = null;
      var vk = false;
      var wk = null;
      var xk = 0;
      var yk = 0;
      var zk = null;
      var Ak = -1;
      var Bk = 0;
      function R() {
        return 0 !== (K & 6) ? B() : -1 !== Ak ? Ak : Ak = B();
      }
      function yi(a) {
        if (0 === (a.mode & 1)) return 1;
        if (0 !== (K & 2) && 0 !== Z) return Z & -Z;
        if (null !== Kg.transition) return 0 === Bk && (Bk = yc()), Bk;
        a = C;
        if (0 !== a) return a;
        a = window.event;
        a = void 0 === a ? 16 : jd(a.type);
        return a;
      }
      function gi(a, b, c, d) {
        if (50 < yk) throw yk = 0, zk = null, Error(p(185));
        Ac(a, c, d);
        if (0 === (K & 2) || a !== Q) a === Q && (0 === (K & 2) && (qk |= c), 4 === T && Ck(a, Z)), Dk(a, d), 1 === c && 0 === K && 0 === (b.mode & 1) && (Gj = B() + 500, fg && jg());
      }
      function Dk(a, b) {
        var c = a.callbackNode;
        wc(a, b);
        var d = uc(a, a === Q ? Z : 0);
        if (0 === d) null !== c && bc(c), a.callbackNode = null, a.callbackPriority = 0;
        else if (b = d & -d, a.callbackPriority !== b) {
          null != c && bc(c);
          if (1 === b) 0 === a.tag ? ig(Ek.bind(null, a)) : hg(Ek.bind(null, a)), Jf(function() {
            0 === (K & 6) && jg();
          }), c = null;
          else {
            switch (Dc(d)) {
              case 1:
                c = fc;
                break;
              case 4:
                c = gc;
                break;
              case 16:
                c = hc;
                break;
              case 536870912:
                c = jc;
                break;
              default:
                c = hc;
            }
            c = Fk(c, Gk.bind(null, a));
          }
          a.callbackPriority = b;
          a.callbackNode = c;
        }
      }
      function Gk(a, b) {
        Ak = -1;
        Bk = 0;
        if (0 !== (K & 6)) throw Error(p(327));
        var c = a.callbackNode;
        if (Hk() && a.callbackNode !== c) return null;
        var d = uc(a, a === Q ? Z : 0);
        if (0 === d) return null;
        if (0 !== (d & 30) || 0 !== (d & a.expiredLanes) || b) b = Ik(a, d);
        else {
          b = d;
          var e = K;
          K |= 2;
          var f = Jk();
          if (Q !== a || Z !== b) uk = null, Gj = B() + 500, Kk(a, b);
          do
            try {
              Lk();
              break;
            } catch (h) {
              Mk(a, h);
            }
          while (1);
          $g();
          mk.current = f;
          K = e;
          null !== Y ? b = 0 : (Q = null, Z = 0, b = T);
        }
        if (0 !== b) {
          2 === b && (e = xc(a), 0 !== e && (d = e, b = Nk(a, e)));
          if (1 === b) throw c = pk, Kk(a, 0), Ck(a, d), Dk(a, B()), c;
          if (6 === b) Ck(a, d);
          else {
            e = a.current.alternate;
            if (0 === (d & 30) && !Ok(e) && (b = Ik(a, d), 2 === b && (f = xc(a), 0 !== f && (d = f, b = Nk(a, f))), 1 === b)) throw c = pk, Kk(a, 0), Ck(a, d), Dk(a, B()), c;
            a.finishedWork = e;
            a.finishedLanes = d;
            switch (b) {
              case 0:
              case 1:
                throw Error(p(345));
              case 2:
                Pk(a, tk, uk);
                break;
              case 3:
                Ck(a, d);
                if ((d & 130023424) === d && (b = fk + 500 - B(), 10 < b)) {
                  if (0 !== uc(a, 0)) break;
                  e = a.suspendedLanes;
                  if ((e & d) !== d) {
                    R();
                    a.pingedLanes |= a.suspendedLanes & e;
                    break;
                  }
                  a.timeoutHandle = Ff(Pk.bind(null, a, tk, uk), b);
                  break;
                }
                Pk(a, tk, uk);
                break;
              case 4:
                Ck(a, d);
                if ((d & 4194240) === d) break;
                b = a.eventTimes;
                for (e = -1; 0 < d; ) {
                  var g = 31 - oc(d);
                  f = 1 << g;
                  g = b[g];
                  g > e && (e = g);
                  d &= ~f;
                }
                d = e;
                d = B() - d;
                d = (120 > d ? 120 : 480 > d ? 480 : 1080 > d ? 1080 : 1920 > d ? 1920 : 3e3 > d ? 3e3 : 4320 > d ? 4320 : 1960 * lk(d / 1960)) - d;
                if (10 < d) {
                  a.timeoutHandle = Ff(Pk.bind(null, a, tk, uk), d);
                  break;
                }
                Pk(a, tk, uk);
                break;
              case 5:
                Pk(a, tk, uk);
                break;
              default:
                throw Error(p(329));
            }
          }
        }
        Dk(a, B());
        return a.callbackNode === c ? Gk.bind(null, a) : null;
      }
      function Nk(a, b) {
        var c = sk;
        a.current.memoizedState.isDehydrated && (Kk(a, b).flags |= 256);
        a = Ik(a, b);
        2 !== a && (b = tk, tk = c, null !== b && Fj(b));
        return a;
      }
      function Fj(a) {
        null === tk ? tk = a : tk.push.apply(tk, a);
      }
      function Ok(a) {
        for (var b = a; ; ) {
          if (b.flags & 16384) {
            var c = b.updateQueue;
            if (null !== c && (c = c.stores, null !== c)) for (var d = 0; d < c.length; d++) {
              var e = c[d], f = e.getSnapshot;
              e = e.value;
              try {
                if (!He(f(), e)) return false;
              } catch (g) {
                return false;
              }
            }
          }
          c = b.child;
          if (b.subtreeFlags & 16384 && null !== c) c.return = b, b = c;
          else {
            if (b === a) break;
            for (; null === b.sibling; ) {
              if (null === b.return || b.return === a) return true;
              b = b.return;
            }
            b.sibling.return = b.return;
            b = b.sibling;
          }
        }
        return true;
      }
      function Ck(a, b) {
        b &= ~rk;
        b &= ~qk;
        a.suspendedLanes |= b;
        a.pingedLanes &= ~b;
        for (a = a.expirationTimes; 0 < b; ) {
          var c = 31 - oc(b), d = 1 << c;
          a[c] = -1;
          b &= ~d;
        }
      }
      function Ek(a) {
        if (0 !== (K & 6)) throw Error(p(327));
        Hk();
        var b = uc(a, 0);
        if (0 === (b & 1)) return Dk(a, B()), null;
        var c = Ik(a, b);
        if (0 !== a.tag && 2 === c) {
          var d = xc(a);
          0 !== d && (b = d, c = Nk(a, d));
        }
        if (1 === c) throw c = pk, Kk(a, 0), Ck(a, b), Dk(a, B()), c;
        if (6 === c) throw Error(p(345));
        a.finishedWork = a.current.alternate;
        a.finishedLanes = b;
        Pk(a, tk, uk);
        Dk(a, B());
        return null;
      }
      function Qk(a, b) {
        var c = K;
        K |= 1;
        try {
          return a(b);
        } finally {
          K = c, 0 === K && (Gj = B() + 500, fg && jg());
        }
      }
      function Rk(a) {
        null !== wk && 0 === wk.tag && 0 === (K & 6) && Hk();
        var b = K;
        K |= 1;
        var c = ok.transition, d = C;
        try {
          if (ok.transition = null, C = 1, a) return a();
        } finally {
          C = d, ok.transition = c, K = b, 0 === (K & 6) && jg();
        }
      }
      function Hj() {
        fj = ej.current;
        E(ej);
      }
      function Kk(a, b) {
        a.finishedWork = null;
        a.finishedLanes = 0;
        var c = a.timeoutHandle;
        -1 !== c && (a.timeoutHandle = -1, Gf(c));
        if (null !== Y) for (c = Y.return; null !== c; ) {
          var d = c;
          wg(d);
          switch (d.tag) {
            case 1:
              d = d.type.childContextTypes;
              null !== d && void 0 !== d && $f();
              break;
            case 3:
              zh();
              E(Wf);
              E(H);
              Eh();
              break;
            case 5:
              Bh(d);
              break;
            case 4:
              zh();
              break;
            case 13:
              E(L);
              break;
            case 19:
              E(L);
              break;
            case 10:
              ah(d.type._context);
              break;
            case 22:
            case 23:
              Hj();
          }
          c = c.return;
        }
        Q = a;
        Y = a = Pg(a.current, null);
        Z = fj = b;
        T = 0;
        pk = null;
        rk = qk = rh = 0;
        tk = sk = null;
        if (null !== fh) {
          for (b = 0; b < fh.length; b++) if (c = fh[b], d = c.interleaved, null !== d) {
            c.interleaved = null;
            var e = d.next, f = c.pending;
            if (null !== f) {
              var g = f.next;
              f.next = e;
              d.next = g;
            }
            c.pending = d;
          }
          fh = null;
        }
        return a;
      }
      function Mk(a, b) {
        do {
          var c = Y;
          try {
            $g();
            Fh.current = Rh;
            if (Ih) {
              for (var d = M.memoizedState; null !== d; ) {
                var e = d.queue;
                null !== e && (e.pending = null);
                d = d.next;
              }
              Ih = false;
            }
            Hh = 0;
            O = N = M = null;
            Jh = false;
            Kh = 0;
            nk.current = null;
            if (null === c || null === c.return) {
              T = 1;
              pk = b;
              Y = null;
              break;
            }
            a: {
              var f = a, g = c.return, h = c, k = b;
              b = Z;
              h.flags |= 32768;
              if (null !== k && "object" === typeof k && "function" === typeof k.then) {
                var l = k, m = h, q = m.tag;
                if (0 === (m.mode & 1) && (0 === q || 11 === q || 15 === q)) {
                  var r = m.alternate;
                  r ? (m.updateQueue = r.updateQueue, m.memoizedState = r.memoizedState, m.lanes = r.lanes) : (m.updateQueue = null, m.memoizedState = null);
                }
                var y = Ui(g);
                if (null !== y) {
                  y.flags &= -257;
                  Vi(y, g, h, f, b);
                  y.mode & 1 && Si(f, l, b);
                  b = y;
                  k = l;
                  var n = b.updateQueue;
                  if (null === n) {
                    var t = /* @__PURE__ */ new Set();
                    t.add(k);
                    b.updateQueue = t;
                  } else n.add(k);
                  break a;
                } else {
                  if (0 === (b & 1)) {
                    Si(f, l, b);
                    tj();
                    break a;
                  }
                  k = Error(p(426));
                }
              } else if (I && h.mode & 1) {
                var J = Ui(g);
                if (null !== J) {
                  0 === (J.flags & 65536) && (J.flags |= 256);
                  Vi(J, g, h, f, b);
                  Jg(Ji(k, h));
                  break a;
                }
              }
              f = k = Ji(k, h);
              4 !== T && (T = 2);
              null === sk ? sk = [f] : sk.push(f);
              f = g;
              do {
                switch (f.tag) {
                  case 3:
                    f.flags |= 65536;
                    b &= -b;
                    f.lanes |= b;
                    var x = Ni(f, k, b);
                    ph(f, x);
                    break a;
                  case 1:
                    h = k;
                    var w = f.type, u = f.stateNode;
                    if (0 === (f.flags & 128) && ("function" === typeof w.getDerivedStateFromError || null !== u && "function" === typeof u.componentDidCatch && (null === Ri || !Ri.has(u)))) {
                      f.flags |= 65536;
                      b &= -b;
                      f.lanes |= b;
                      var F = Qi(f, h, b);
                      ph(f, F);
                      break a;
                    }
                }
                f = f.return;
              } while (null !== f);
            }
            Sk(c);
          } catch (na) {
            b = na;
            Y === c && null !== c && (Y = c = c.return);
            continue;
          }
          break;
        } while (1);
      }
      function Jk() {
        var a = mk.current;
        mk.current = Rh;
        return null === a ? Rh : a;
      }
      function tj() {
        if (0 === T || 3 === T || 2 === T) T = 4;
        null === Q || 0 === (rh & 268435455) && 0 === (qk & 268435455) || Ck(Q, Z);
      }
      function Ik(a, b) {
        var c = K;
        K |= 2;
        var d = Jk();
        if (Q !== a || Z !== b) uk = null, Kk(a, b);
        do
          try {
            Tk();
            break;
          } catch (e) {
            Mk(a, e);
          }
        while (1);
        $g();
        K = c;
        mk.current = d;
        if (null !== Y) throw Error(p(261));
        Q = null;
        Z = 0;
        return T;
      }
      function Tk() {
        for (; null !== Y; ) Uk(Y);
      }
      function Lk() {
        for (; null !== Y && !cc(); ) Uk(Y);
      }
      function Uk(a) {
        var b = Vk(a.alternate, a, fj);
        a.memoizedProps = a.pendingProps;
        null === b ? Sk(a) : Y = b;
        nk.current = null;
      }
      function Sk(a) {
        var b = a;
        do {
          var c = b.alternate;
          a = b.return;
          if (0 === (b.flags & 32768)) {
            if (c = Ej(c, b, fj), null !== c) {
              Y = c;
              return;
            }
          } else {
            c = Ij(c, b);
            if (null !== c) {
              c.flags &= 32767;
              Y = c;
              return;
            }
            if (null !== a) a.flags |= 32768, a.subtreeFlags = 0, a.deletions = null;
            else {
              T = 6;
              Y = null;
              return;
            }
          }
          b = b.sibling;
          if (null !== b) {
            Y = b;
            return;
          }
          Y = b = a;
        } while (null !== b);
        0 === T && (T = 5);
      }
      function Pk(a, b, c) {
        var d = C, e = ok.transition;
        try {
          ok.transition = null, C = 1, Wk(a, b, c, d);
        } finally {
          ok.transition = e, C = d;
        }
        return null;
      }
      function Wk(a, b, c, d) {
        do
          Hk();
        while (null !== wk);
        if (0 !== (K & 6)) throw Error(p(327));
        c = a.finishedWork;
        var e = a.finishedLanes;
        if (null === c) return null;
        a.finishedWork = null;
        a.finishedLanes = 0;
        if (c === a.current) throw Error(p(177));
        a.callbackNode = null;
        a.callbackPriority = 0;
        var f = c.lanes | c.childLanes;
        Bc(a, f);
        a === Q && (Y = Q = null, Z = 0);
        0 === (c.subtreeFlags & 2064) && 0 === (c.flags & 2064) || vk || (vk = true, Fk(hc, function() {
          Hk();
          return null;
        }));
        f = 0 !== (c.flags & 15990);
        if (0 !== (c.subtreeFlags & 15990) || f) {
          f = ok.transition;
          ok.transition = null;
          var g = C;
          C = 1;
          var h = K;
          K |= 4;
          nk.current = null;
          Oj(a, c);
          dk(c, a);
          Oe(Df);
          dd = !!Cf;
          Df = Cf = null;
          a.current = c;
          hk(c, a, e);
          dc();
          K = h;
          C = g;
          ok.transition = f;
        } else a.current = c;
        vk && (vk = false, wk = a, xk = e);
        f = a.pendingLanes;
        0 === f && (Ri = null);
        mc(c.stateNode, d);
        Dk(a, B());
        if (null !== b) for (d = a.onRecoverableError, c = 0; c < b.length; c++) e = b[c], d(e.value, { componentStack: e.stack, digest: e.digest });
        if (Oi) throw Oi = false, a = Pi, Pi = null, a;
        0 !== (xk & 1) && 0 !== a.tag && Hk();
        f = a.pendingLanes;
        0 !== (f & 1) ? a === zk ? yk++ : (yk = 0, zk = a) : yk = 0;
        jg();
        return null;
      }
      function Hk() {
        if (null !== wk) {
          var a = Dc(xk), b = ok.transition, c = C;
          try {
            ok.transition = null;
            C = 16 > a ? 16 : a;
            if (null === wk) var d = false;
            else {
              a = wk;
              wk = null;
              xk = 0;
              if (0 !== (K & 6)) throw Error(p(331));
              var e = K;
              K |= 4;
              for (V = a.current; null !== V; ) {
                var f = V, g = f.child;
                if (0 !== (V.flags & 16)) {
                  var h = f.deletions;
                  if (null !== h) {
                    for (var k = 0; k < h.length; k++) {
                      var l = h[k];
                      for (V = l; null !== V; ) {
                        var m = V;
                        switch (m.tag) {
                          case 0:
                          case 11:
                          case 15:
                            Pj(8, m, f);
                        }
                        var q = m.child;
                        if (null !== q) q.return = m, V = q;
                        else for (; null !== V; ) {
                          m = V;
                          var r = m.sibling, y = m.return;
                          Sj(m);
                          if (m === l) {
                            V = null;
                            break;
                          }
                          if (null !== r) {
                            r.return = y;
                            V = r;
                            break;
                          }
                          V = y;
                        }
                      }
                    }
                    var n = f.alternate;
                    if (null !== n) {
                      var t = n.child;
                      if (null !== t) {
                        n.child = null;
                        do {
                          var J = t.sibling;
                          t.sibling = null;
                          t = J;
                        } while (null !== t);
                      }
                    }
                    V = f;
                  }
                }
                if (0 !== (f.subtreeFlags & 2064) && null !== g) g.return = f, V = g;
                else b: for (; null !== V; ) {
                  f = V;
                  if (0 !== (f.flags & 2048)) switch (f.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Pj(9, f, f.return);
                  }
                  var x = f.sibling;
                  if (null !== x) {
                    x.return = f.return;
                    V = x;
                    break b;
                  }
                  V = f.return;
                }
              }
              var w = a.current;
              for (V = w; null !== V; ) {
                g = V;
                var u = g.child;
                if (0 !== (g.subtreeFlags & 2064) && null !== u) u.return = g, V = u;
                else b: for (g = w; null !== V; ) {
                  h = V;
                  if (0 !== (h.flags & 2048)) try {
                    switch (h.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Qj(9, h);
                    }
                  } catch (na) {
                    W(h, h.return, na);
                  }
                  if (h === g) {
                    V = null;
                    break b;
                  }
                  var F = h.sibling;
                  if (null !== F) {
                    F.return = h.return;
                    V = F;
                    break b;
                  }
                  V = h.return;
                }
              }
              K = e;
              jg();
              if (lc && "function" === typeof lc.onPostCommitFiberRoot) try {
                lc.onPostCommitFiberRoot(kc, a);
              } catch (na) {
              }
              d = true;
            }
            return d;
          } finally {
            C = c, ok.transition = b;
          }
        }
        return false;
      }
      function Xk(a, b, c) {
        b = Ji(c, b);
        b = Ni(a, b, 1);
        a = nh(a, b, 1);
        b = R();
        null !== a && (Ac(a, 1, b), Dk(a, b));
      }
      function W(a, b, c) {
        if (3 === a.tag) Xk(a, a, c);
        else for (; null !== b; ) {
          if (3 === b.tag) {
            Xk(b, a, c);
            break;
          } else if (1 === b.tag) {
            var d = b.stateNode;
            if ("function" === typeof b.type.getDerivedStateFromError || "function" === typeof d.componentDidCatch && (null === Ri || !Ri.has(d))) {
              a = Ji(c, a);
              a = Qi(b, a, 1);
              b = nh(b, a, 1);
              a = R();
              null !== b && (Ac(b, 1, a), Dk(b, a));
              break;
            }
          }
          b = b.return;
        }
      }
      function Ti(a, b, c) {
        var d = a.pingCache;
        null !== d && d.delete(b);
        b = R();
        a.pingedLanes |= a.suspendedLanes & c;
        Q === a && (Z & c) === c && (4 === T || 3 === T && (Z & 130023424) === Z && 500 > B() - fk ? Kk(a, 0) : rk |= c);
        Dk(a, b);
      }
      function Yk(a, b) {
        0 === b && (0 === (a.mode & 1) ? b = 1 : (b = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
        var c = R();
        a = ih(a, b);
        null !== a && (Ac(a, b, c), Dk(a, c));
      }
      function uj(a) {
        var b = a.memoizedState, c = 0;
        null !== b && (c = b.retryLane);
        Yk(a, c);
      }
      function bk(a, b) {
        var c = 0;
        switch (a.tag) {
          case 13:
            var d = a.stateNode;
            var e = a.memoizedState;
            null !== e && (c = e.retryLane);
            break;
          case 19:
            d = a.stateNode;
            break;
          default:
            throw Error(p(314));
        }
        null !== d && d.delete(b);
        Yk(a, c);
      }
      var Vk;
      Vk = function(a, b, c) {
        if (null !== a) if (a.memoizedProps !== b.pendingProps || Wf.current) dh = true;
        else {
          if (0 === (a.lanes & c) && 0 === (b.flags & 128)) return dh = false, yj(a, b, c);
          dh = 0 !== (a.flags & 131072) ? true : false;
        }
        else dh = false, I && 0 !== (b.flags & 1048576) && ug(b, ng, b.index);
        b.lanes = 0;
        switch (b.tag) {
          case 2:
            var d = b.type;
            ij(a, b);
            a = b.pendingProps;
            var e = Yf(b, H.current);
            ch(b, c);
            e = Nh(null, b, d, a, e, c);
            var f = Sh();
            b.flags |= 1;
            "object" === typeof e && null !== e && "function" === typeof e.render && void 0 === e.$$typeof ? (b.tag = 1, b.memoizedState = null, b.updateQueue = null, Zf(d) ? (f = true, cg(b)) : f = false, b.memoizedState = null !== e.state && void 0 !== e.state ? e.state : null, kh(b), e.updater = Ei, b.stateNode = e, e._reactInternals = b, Ii(b, d, a, c), b = jj(null, b, d, true, f, c)) : (b.tag = 0, I && f && vg(b), Xi(null, b, e, c), b = b.child);
            return b;
          case 16:
            d = b.elementType;
            a: {
              ij(a, b);
              a = b.pendingProps;
              e = d._init;
              d = e(d._payload);
              b.type = d;
              e = b.tag = Zk(d);
              a = Ci(d, a);
              switch (e) {
                case 0:
                  b = cj(null, b, d, a, c);
                  break a;
                case 1:
                  b = hj(null, b, d, a, c);
                  break a;
                case 11:
                  b = Yi(null, b, d, a, c);
                  break a;
                case 14:
                  b = $i(null, b, d, Ci(d.type, a), c);
                  break a;
              }
              throw Error(p(
                306,
                d,
                ""
              ));
            }
            return b;
          case 0:
            return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), cj(a, b, d, e, c);
          case 1:
            return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), hj(a, b, d, e, c);
          case 3:
            a: {
              kj(b);
              if (null === a) throw Error(p(387));
              d = b.pendingProps;
              f = b.memoizedState;
              e = f.element;
              lh(a, b);
              qh(b, d, null, c);
              var g = b.memoizedState;
              d = g.element;
              if (f.isDehydrated) if (f = { element: d, isDehydrated: false, cache: g.cache, pendingSuspenseBoundaries: g.pendingSuspenseBoundaries, transitions: g.transitions }, b.updateQueue.baseState = f, b.memoizedState = f, b.flags & 256) {
                e = Ji(Error(p(423)), b);
                b = lj(a, b, d, c, e);
                break a;
              } else if (d !== e) {
                e = Ji(Error(p(424)), b);
                b = lj(a, b, d, c, e);
                break a;
              } else for (yg = Lf(b.stateNode.containerInfo.firstChild), xg = b, I = true, zg = null, c = Vg(b, null, d, c), b.child = c; c; ) c.flags = c.flags & -3 | 4096, c = c.sibling;
              else {
                Ig();
                if (d === e) {
                  b = Zi(a, b, c);
                  break a;
                }
                Xi(a, b, d, c);
              }
              b = b.child;
            }
            return b;
          case 5:
            return Ah(b), null === a && Eg(b), d = b.type, e = b.pendingProps, f = null !== a ? a.memoizedProps : null, g = e.children, Ef(d, e) ? g = null : null !== f && Ef(d, f) && (b.flags |= 32), gj(a, b), Xi(a, b, g, c), b.child;
          case 6:
            return null === a && Eg(b), null;
          case 13:
            return oj(a, b, c);
          case 4:
            return yh(b, b.stateNode.containerInfo), d = b.pendingProps, null === a ? b.child = Ug(b, null, d, c) : Xi(a, b, d, c), b.child;
          case 11:
            return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), Yi(a, b, d, e, c);
          case 7:
            return Xi(a, b, b.pendingProps, c), b.child;
          case 8:
            return Xi(a, b, b.pendingProps.children, c), b.child;
          case 12:
            return Xi(a, b, b.pendingProps.children, c), b.child;
          case 10:
            a: {
              d = b.type._context;
              e = b.pendingProps;
              f = b.memoizedProps;
              g = e.value;
              G(Wg, d._currentValue);
              d._currentValue = g;
              if (null !== f) if (He(f.value, g)) {
                if (f.children === e.children && !Wf.current) {
                  b = Zi(a, b, c);
                  break a;
                }
              } else for (f = b.child, null !== f && (f.return = b); null !== f; ) {
                var h = f.dependencies;
                if (null !== h) {
                  g = f.child;
                  for (var k = h.firstContext; null !== k; ) {
                    if (k.context === d) {
                      if (1 === f.tag) {
                        k = mh(-1, c & -c);
                        k.tag = 2;
                        var l = f.updateQueue;
                        if (null !== l) {
                          l = l.shared;
                          var m = l.pending;
                          null === m ? k.next = k : (k.next = m.next, m.next = k);
                          l.pending = k;
                        }
                      }
                      f.lanes |= c;
                      k = f.alternate;
                      null !== k && (k.lanes |= c);
                      bh(
                        f.return,
                        c,
                        b
                      );
                      h.lanes |= c;
                      break;
                    }
                    k = k.next;
                  }
                } else if (10 === f.tag) g = f.type === b.type ? null : f.child;
                else if (18 === f.tag) {
                  g = f.return;
                  if (null === g) throw Error(p(341));
                  g.lanes |= c;
                  h = g.alternate;
                  null !== h && (h.lanes |= c);
                  bh(g, c, b);
                  g = f.sibling;
                } else g = f.child;
                if (null !== g) g.return = f;
                else for (g = f; null !== g; ) {
                  if (g === b) {
                    g = null;
                    break;
                  }
                  f = g.sibling;
                  if (null !== f) {
                    f.return = g.return;
                    g = f;
                    break;
                  }
                  g = g.return;
                }
                f = g;
              }
              Xi(a, b, e.children, c);
              b = b.child;
            }
            return b;
          case 9:
            return e = b.type, d = b.pendingProps.children, ch(b, c), e = eh(e), d = d(e), b.flags |= 1, Xi(a, b, d, c), b.child;
          case 14:
            return d = b.type, e = Ci(d, b.pendingProps), e = Ci(d.type, e), $i(a, b, d, e, c);
          case 15:
            return bj(a, b, b.type, b.pendingProps, c);
          case 17:
            return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), ij(a, b), b.tag = 1, Zf(d) ? (a = true, cg(b)) : a = false, ch(b, c), Gi(b, d, e), Ii(b, d, e, c), jj(null, b, d, true, a, c);
          case 19:
            return xj(a, b, c);
          case 22:
            return dj(a, b, c);
        }
        throw Error(p(156, b.tag));
      };
      function Fk(a, b) {
        return ac(a, b);
      }
      function $k(a, b, c, d) {
        this.tag = a;
        this.key = c;
        this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
        this.index = 0;
        this.ref = null;
        this.pendingProps = b;
        this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
        this.mode = d;
        this.subtreeFlags = this.flags = 0;
        this.deletions = null;
        this.childLanes = this.lanes = 0;
        this.alternate = null;
      }
      function Bg(a, b, c, d) {
        return new $k(a, b, c, d);
      }
      function aj(a) {
        a = a.prototype;
        return !(!a || !a.isReactComponent);
      }
      function Zk(a) {
        if ("function" === typeof a) return aj(a) ? 1 : 0;
        if (void 0 !== a && null !== a) {
          a = a.$$typeof;
          if (a === Da) return 11;
          if (a === Ga) return 14;
        }
        return 2;
      }
      function Pg(a, b) {
        var c = a.alternate;
        null === c ? (c = Bg(a.tag, b, a.key, a.mode), c.elementType = a.elementType, c.type = a.type, c.stateNode = a.stateNode, c.alternate = a, a.alternate = c) : (c.pendingProps = b, c.type = a.type, c.flags = 0, c.subtreeFlags = 0, c.deletions = null);
        c.flags = a.flags & 14680064;
        c.childLanes = a.childLanes;
        c.lanes = a.lanes;
        c.child = a.child;
        c.memoizedProps = a.memoizedProps;
        c.memoizedState = a.memoizedState;
        c.updateQueue = a.updateQueue;
        b = a.dependencies;
        c.dependencies = null === b ? null : { lanes: b.lanes, firstContext: b.firstContext };
        c.sibling = a.sibling;
        c.index = a.index;
        c.ref = a.ref;
        return c;
      }
      function Rg(a, b, c, d, e, f) {
        var g = 2;
        d = a;
        if ("function" === typeof a) aj(a) && (g = 1);
        else if ("string" === typeof a) g = 5;
        else a: switch (a) {
          case ya:
            return Tg(c.children, e, f, b);
          case za:
            g = 8;
            e |= 8;
            break;
          case Aa:
            return a = Bg(12, c, b, e | 2), a.elementType = Aa, a.lanes = f, a;
          case Ea:
            return a = Bg(13, c, b, e), a.elementType = Ea, a.lanes = f, a;
          case Fa:
            return a = Bg(19, c, b, e), a.elementType = Fa, a.lanes = f, a;
          case Ia:
            return pj(c, e, f, b);
          default:
            if ("object" === typeof a && null !== a) switch (a.$$typeof) {
              case Ba:
                g = 10;
                break a;
              case Ca:
                g = 9;
                break a;
              case Da:
                g = 11;
                break a;
              case Ga:
                g = 14;
                break a;
              case Ha:
                g = 16;
                d = null;
                break a;
            }
            throw Error(p(130, null == a ? a : typeof a, ""));
        }
        b = Bg(g, c, b, e);
        b.elementType = a;
        b.type = d;
        b.lanes = f;
        return b;
      }
      function Tg(a, b, c, d) {
        a = Bg(7, a, d, b);
        a.lanes = c;
        return a;
      }
      function pj(a, b, c, d) {
        a = Bg(22, a, d, b);
        a.elementType = Ia;
        a.lanes = c;
        a.stateNode = { isHidden: false };
        return a;
      }
      function Qg(a, b, c) {
        a = Bg(6, a, null, b);
        a.lanes = c;
        return a;
      }
      function Sg(a, b, c) {
        b = Bg(4, null !== a.children ? a.children : [], a.key, b);
        b.lanes = c;
        b.stateNode = { containerInfo: a.containerInfo, pendingChildren: null, implementation: a.implementation };
        return b;
      }
      function al(a, b, c, d, e) {
        this.tag = b;
        this.containerInfo = a;
        this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
        this.timeoutHandle = -1;
        this.callbackNode = this.pendingContext = this.context = null;
        this.callbackPriority = 0;
        this.eventTimes = zc(0);
        this.expirationTimes = zc(-1);
        this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
        this.entanglements = zc(0);
        this.identifierPrefix = d;
        this.onRecoverableError = e;
        this.mutableSourceEagerHydrationData = null;
      }
      function bl(a, b, c, d, e, f, g, h, k) {
        a = new al(a, b, c, h, k);
        1 === b ? (b = 1, true === f && (b |= 8)) : b = 0;
        f = Bg(3, null, null, b);
        a.current = f;
        f.stateNode = a;
        f.memoizedState = { element: d, isDehydrated: c, cache: null, transitions: null, pendingSuspenseBoundaries: null };
        kh(f);
        return a;
      }
      function cl(a, b, c) {
        var d = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
        return { $$typeof: wa, key: null == d ? null : "" + d, children: a, containerInfo: b, implementation: c };
      }
      function dl(a) {
        if (!a) return Vf;
        a = a._reactInternals;
        a: {
          if (Vb(a) !== a || 1 !== a.tag) throw Error(p(170));
          var b = a;
          do {
            switch (b.tag) {
              case 3:
                b = b.stateNode.context;
                break a;
              case 1:
                if (Zf(b.type)) {
                  b = b.stateNode.__reactInternalMemoizedMergedChildContext;
                  break a;
                }
            }
            b = b.return;
          } while (null !== b);
          throw Error(p(171));
        }
        if (1 === a.tag) {
          var c = a.type;
          if (Zf(c)) return bg(a, c, b);
        }
        return b;
      }
      function el(a, b, c, d, e, f, g, h, k) {
        a = bl(c, d, true, a, e, f, g, h, k);
        a.context = dl(null);
        c = a.current;
        d = R();
        e = yi(c);
        f = mh(d, e);
        f.callback = void 0 !== b && null !== b ? b : null;
        nh(c, f, e);
        a.current.lanes = e;
        Ac(a, e, d);
        Dk(a, d);
        return a;
      }
      function fl(a, b, c, d) {
        var e = b.current, f = R(), g = yi(e);
        c = dl(c);
        null === b.context ? b.context = c : b.pendingContext = c;
        b = mh(f, g);
        b.payload = { element: a };
        d = void 0 === d ? null : d;
        null !== d && (b.callback = d);
        a = nh(e, b, g);
        null !== a && (gi(a, e, g, f), oh(a, e, g));
        return g;
      }
      function gl(a) {
        a = a.current;
        if (!a.child) return null;
        switch (a.child.tag) {
          case 5:
            return a.child.stateNode;
          default:
            return a.child.stateNode;
        }
      }
      function hl(a, b) {
        a = a.memoizedState;
        if (null !== a && null !== a.dehydrated) {
          var c = a.retryLane;
          a.retryLane = 0 !== c && c < b ? c : b;
        }
      }
      function il(a, b) {
        hl(a, b);
        (a = a.alternate) && hl(a, b);
      }
      function jl() {
        return null;
      }
      var kl = "function" === typeof reportError ? reportError : function(a) {
        console.error(a);
      };
      function ll(a) {
        this._internalRoot = a;
      }
      ml.prototype.render = ll.prototype.render = function(a) {
        var b = this._internalRoot;
        if (null === b) throw Error(p(409));
        fl(a, b, null, null);
      };
      ml.prototype.unmount = ll.prototype.unmount = function() {
        var a = this._internalRoot;
        if (null !== a) {
          this._internalRoot = null;
          var b = a.containerInfo;
          Rk(function() {
            fl(null, a, null, null);
          });
          b[uf] = null;
        }
      };
      function ml(a) {
        this._internalRoot = a;
      }
      ml.prototype.unstable_scheduleHydration = function(a) {
        if (a) {
          var b = Hc();
          a = { blockedOn: null, target: a, priority: b };
          for (var c = 0; c < Qc.length && 0 !== b && b < Qc[c].priority; c++) ;
          Qc.splice(c, 0, a);
          0 === c && Vc(a);
        }
      };
      function nl(a) {
        return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType);
      }
      function ol(a) {
        return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType && (8 !== a.nodeType || " react-mount-point-unstable " !== a.nodeValue));
      }
      function pl() {
      }
      function ql(a, b, c, d, e) {
        if (e) {
          if ("function" === typeof d) {
            var f = d;
            d = function() {
              var a2 = gl(g);
              f.call(a2);
            };
          }
          var g = el(b, d, a, 0, null, false, false, "", pl);
          a._reactRootContainer = g;
          a[uf] = g.current;
          sf(8 === a.nodeType ? a.parentNode : a);
          Rk();
          return g;
        }
        for (; e = a.lastChild; ) a.removeChild(e);
        if ("function" === typeof d) {
          var h = d;
          d = function() {
            var a2 = gl(k);
            h.call(a2);
          };
        }
        var k = bl(a, 0, false, null, null, false, false, "", pl);
        a._reactRootContainer = k;
        a[uf] = k.current;
        sf(8 === a.nodeType ? a.parentNode : a);
        Rk(function() {
          fl(b, k, c, d);
        });
        return k;
      }
      function rl(a, b, c, d, e) {
        var f = c._reactRootContainer;
        if (f) {
          var g = f;
          if ("function" === typeof e) {
            var h = e;
            e = function() {
              var a2 = gl(g);
              h.call(a2);
            };
          }
          fl(b, g, a, e);
        } else g = ql(c, b, a, e, d);
        return gl(g);
      }
      Ec = function(a) {
        switch (a.tag) {
          case 3:
            var b = a.stateNode;
            if (b.current.memoizedState.isDehydrated) {
              var c = tc(b.pendingLanes);
              0 !== c && (Cc(b, c | 1), Dk(b, B()), 0 === (K & 6) && (Gj = B() + 500, jg()));
            }
            break;
          case 13:
            Rk(function() {
              var b2 = ih(a, 1);
              if (null !== b2) {
                var c2 = R();
                gi(b2, a, 1, c2);
              }
            }), il(a, 1);
        }
      };
      Fc = function(a) {
        if (13 === a.tag) {
          var b = ih(a, 134217728);
          if (null !== b) {
            var c = R();
            gi(b, a, 134217728, c);
          }
          il(a, 134217728);
        }
      };
      Gc = function(a) {
        if (13 === a.tag) {
          var b = yi(a), c = ih(a, b);
          if (null !== c) {
            var d = R();
            gi(c, a, b, d);
          }
          il(a, b);
        }
      };
      Hc = function() {
        return C;
      };
      Ic = function(a, b) {
        var c = C;
        try {
          return C = a, b();
        } finally {
          C = c;
        }
      };
      yb = function(a, b, c) {
        switch (b) {
          case "input":
            bb(a, c);
            b = c.name;
            if ("radio" === c.type && null != b) {
              for (c = a; c.parentNode; ) c = c.parentNode;
              c = c.querySelectorAll("input[name=" + JSON.stringify("" + b) + '][type="radio"]');
              for (b = 0; b < c.length; b++) {
                var d = c[b];
                if (d !== a && d.form === a.form) {
                  var e = Db(d);
                  if (!e) throw Error(p(90));
                  Wa(d);
                  bb(d, e);
                }
              }
            }
            break;
          case "textarea":
            ib(a, c);
            break;
          case "select":
            b = c.value, null != b && fb(a, !!c.multiple, b, false);
        }
      };
      Gb = Qk;
      Hb = Rk;
      var sl = { usingClientEntryPoint: false, Events: [Cb, ue, Db, Eb, Fb, Qk] };
      var tl = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" };
      var ul = { bundleType: tl.bundleType, version: tl.version, rendererPackageName: tl.rendererPackageName, rendererConfig: tl.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a) {
        a = Zb(a);
        return null === a ? null : a.stateNode;
      }, findFiberByHostInstance: tl.findFiberByHostInstance || jl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" };
      if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
        vl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (!vl.isDisabled && vl.supportsFiber) try {
          kc = vl.inject(ul), lc = vl;
        } catch (a) {
        }
      }
      var vl;
      exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = sl;
      exports.createPortal = function(a, b) {
        var c = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
        if (!nl(b)) throw Error(p(200));
        return cl(a, b, null, c);
      };
      exports.createRoot = function(a, b) {
        if (!nl(a)) throw Error(p(299));
        var c = false, d = "", e = kl;
        null !== b && void 0 !== b && (true === b.unstable_strictMode && (c = true), void 0 !== b.identifierPrefix && (d = b.identifierPrefix), void 0 !== b.onRecoverableError && (e = b.onRecoverableError));
        b = bl(a, 1, false, null, null, c, false, d, e);
        a[uf] = b.current;
        sf(8 === a.nodeType ? a.parentNode : a);
        return new ll(b);
      };
      exports.findDOMNode = function(a) {
        if (null == a) return null;
        if (1 === a.nodeType) return a;
        var b = a._reactInternals;
        if (void 0 === b) {
          if ("function" === typeof a.render) throw Error(p(188));
          a = Object.keys(a).join(",");
          throw Error(p(268, a));
        }
        a = Zb(b);
        a = null === a ? null : a.stateNode;
        return a;
      };
      exports.flushSync = function(a) {
        return Rk(a);
      };
      exports.hydrate = function(a, b, c) {
        if (!ol(b)) throw Error(p(200));
        return rl(null, a, b, true, c);
      };
      exports.hydrateRoot = function(a, b, c) {
        if (!nl(a)) throw Error(p(405));
        var d = null != c && c.hydratedSources || null, e = false, f = "", g = kl;
        null !== c && void 0 !== c && (true === c.unstable_strictMode && (e = true), void 0 !== c.identifierPrefix && (f = c.identifierPrefix), void 0 !== c.onRecoverableError && (g = c.onRecoverableError));
        b = el(b, null, a, 1, null != c ? c : null, e, false, f, g);
        a[uf] = b.current;
        sf(a);
        if (d) for (a = 0; a < d.length; a++) c = d[a], e = c._getVersion, e = e(c._source), null == b.mutableSourceEagerHydrationData ? b.mutableSourceEagerHydrationData = [c, e] : b.mutableSourceEagerHydrationData.push(
          c,
          e
        );
        return new ml(b);
      };
      exports.render = function(a, b, c) {
        if (!ol(b)) throw Error(p(200));
        return rl(null, a, b, false, c);
      };
      exports.unmountComponentAtNode = function(a) {
        if (!ol(a)) throw Error(p(40));
        return a._reactRootContainer ? (Rk(function() {
          rl(null, null, a, false, function() {
            a._reactRootContainer = null;
            a[uf] = null;
          });
        }), true) : false;
      };
      exports.unstable_batchedUpdates = Qk;
      exports.unstable_renderSubtreeIntoContainer = function(a, b, c, d) {
        if (!ol(c)) throw Error(p(200));
        if (null == a || void 0 === a._reactInternals) throw Error(p(38));
        return rl(a, b, c, false, d);
      };
      exports.version = "18.3.1-next-f1338f8080-20240426";
    }
  });

  // node_modules/react-dom/index.js
  var require_react_dom = __commonJS({
    "node_modules/react-dom/index.js"(exports, module) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      function checkDCE() {
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
          return;
        }
        if (false) {
          throw new Error("^_^");
        }
        try {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
        } catch (err) {
          console.error(err);
        }
      }
      if (true) {
        checkDCE();
        module.exports = require_react_dom_production_min();
      } else {
        module.exports = null;
      }
    }
  });

  // node_modules/react-dom/client.js
  var require_client = __commonJS({
    "node_modules/react-dom/client.js"(exports) {
      "use strict";
      init_define_ENVIRONMENT();
      init_define_LOGGER_LEVEL();
      var m = require_react_dom();
      if (true) {
        exports.createRoot = m.createRoot;
        exports.hydrateRoot = m.hydrateRoot;
      } else {
        i = m.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        exports.createRoot = function(c, o) {
          i.usingClientEntryPoint = true;
          try {
            return m.createRoot(c, o);
          } finally {
            i.usingClientEntryPoint = false;
          }
        };
        exports.hydrateRoot = function(c, h, o) {
          i.usingClientEntryPoint = true;
          try {
            return m.hydrateRoot(c, h, o);
          } finally {
            i.usingClientEntryPoint = false;
          }
        };
      }
      var i;
    }
  });

  // demo/scripts/index.tsx
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var import_stable = __toESM(require_stable());
  var import_runtime22 = __toESM(require_runtime());
  var React46 = __toESM(require_react());
  var ReactDOM = __toESM(require_client());

  // demo/scripts/controllers/Main.tsx
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/minimal.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/compat/is_debug_mode_enabled.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function isDebugModeEnabled() {
    return typeof __RX_PLAYER_DEBUG_MODE__ === "boolean" && __RX_PLAYER_DEBUG_MODE__;
  }

  // src/compat/patch_webkit_source_buffer.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/utils/event_emitter.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/utils/is_null_or_undefined.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function isNullOrUndefined(x) {
    return x === null || x === void 0;
  }

  // src/utils/event_emitter.ts
  var EventEmitter = class {
    constructor() {
      this._listeners = {};
    }
    /**
     * Register a new callback for an event.
     *
     * @param {string} evt - The event to register a callback to
     * @param {Function} fn - The callback to call as that event is triggered.
     * The callback will take as argument the eventual payload of the event
     * (single argument).
     * @param {Object | undefined} cancellationSignal - When that signal emits,
     * the event listener is automatically removed.
     */
    addEventListener(evt, fn, cancellationSignal) {
      const listeners = this._listeners[evt];
      if (!Array.isArray(listeners)) {
        this._listeners[evt] = [fn];
      } else {
        listeners.push(fn);
      }
      if (cancellationSignal !== void 0) {
        cancellationSignal.register(() => {
          this.removeEventListener(evt, fn);
        });
      }
    }
    /**
     * Unregister callbacks linked to events.
     * @param {string} [evt] - The event for which the callback[s] should be
     * unregistered. Set it to null or undefined to remove all callbacks
     * currently registered (for any event).
     * @param {Function} [fn] - The callback to unregister. If set to null
     * or undefined while the evt argument is set, all callbacks linked to that
     * event will be unregistered.
     */
    removeEventListener(evt, fn) {
      if (isNullOrUndefined(evt)) {
        this._listeners = {};
        return;
      }
      const listeners = this._listeners[evt];
      if (!Array.isArray(listeners)) {
        return;
      }
      if (isNullOrUndefined(fn)) {
        delete this._listeners[evt];
        return;
      }
      const index = listeners.indexOf(fn);
      if (index !== -1) {
        listeners.splice(index, 1);
      }
      if (listeners.length === 0) {
        delete this._listeners[evt];
      }
    }
    /**
     * Trigger every registered callbacks for a given event
     * @param {string} evt - The event to trigger
     * @param {*} arg - The eventual payload for that event. All triggered
     * callbacks will recieve this payload as argument.
     */
    trigger(evt, arg) {
      const listeners = this._listeners[evt];
      if (!Array.isArray(listeners)) {
        return;
      }
      listeners.slice().forEach((listener) => {
        try {
          listener(arg);
        } catch (e) {
          if (define_ENVIRONMENT_default.CURRENT_ENV === define_ENVIRONMENT_default.DEV) {
            throw e instanceof Error ? e : new Error("EventEmitter: listener error");
          }
          console.error("RxPlayer: EventEmitter error", e instanceof Error ? e : null);
        }
      });
    }
  };

  // src/utils/global_scope.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/utils/is_node.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/utils/is_worker.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var is_worker_default = typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope;

  // src/utils/is_node.ts
  var isNode = typeof window === "undefined" && !is_worker_default;
  var is_node_default = isNode;

  // src/utils/global_scope.ts
  var globalScope;
  if (is_worker_default) {
    globalScope = self;
  } else if (is_node_default) {
    globalScope = global;
  } else {
    globalScope = window;
  }
  var global_scope_default = globalScope;

  // src/utils/queue_microtask.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var queue_microtask_default = typeof queueMicrotask === "function" ? queueMicrotask : function queueMicrotaskPonyfill(cb) {
    Promise.resolve().then(cb, () => cb());
  };

  // src/compat/patch_webkit_source_buffer.ts
  function patchWebkitSourceBuffer() {
    if (!is_node_default && !isNullOrUndefined(
      global_scope_default.WebKitSourceBuffer
    ) && global_scope_default.WebKitSourceBuffer.prototype.addEventListener === void 0) {
      const sourceBufferWebkitRef = global_scope_default.WebKitSourceBuffer;
      const sourceBufferWebkitProto = sourceBufferWebkitRef.prototype;
      for (const fnName in EventEmitter.prototype) {
        if (EventEmitter.prototype.hasOwnProperty(fnName)) {
          sourceBufferWebkitProto[fnName] = EventEmitter.prototype[fnName];
        }
      }
      sourceBufferWebkitProto._listeners = [];
      sourceBufferWebkitProto._emitUpdate = function(eventName, val) {
        queue_microtask_default(() => {
          this.trigger(eventName, val);
          this.updating = false;
          this.trigger("updateend", new Event("updateend"));
        });
      };
      sourceBufferWebkitProto.appendBuffer = function(data2) {
        var _a, _b;
        if (this.updating) {
          throw new Error("updating");
        }
        this.trigger("updatestart", new Event("updatestart"));
        this.updating = true;
        try {
          this.append(data2);
        } catch (error) {
          (_a = this._emitUpdate) == null ? void 0 : _a.call(this, "error", error);
          return;
        }
        (_b = this._emitUpdate) == null ? void 0 : _b.call(this, "update", new Event("update"));
      };
    }
  }

  // src/log.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/utils/logger.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/utils/monotonic_timestamp.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/utils/reference.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/utils/array_find_index.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function arrayFindIndex(arr, predicate, thisArg) {
    if (typeof Array.prototype.findIndex === "function") {
      return arr.findIndex(predicate, thisArg);
    }
    const len = arr.length >>> 0;
    for (let i = 0; i < len; i++) {
      if (predicate.call(thisArg, arr[i], i, arr)) {
        return i;
      }
    }
    return -1;
  }

  // src/utils/noop.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function noop_default() {
  }

  // src/utils/reference.ts
  var SharedReference = class {
    /**
     * Create a `SharedReference` object encapsulating the mutable `initialValue`
     * value of type T.
     * @param {*} initialValue
     * @param {Object|undefined} [cancelSignal] - If set, the created shared
     * reference will be automatically "finished" once that signal emits.
     * Finished references won't be able to update their value anymore, and will
     * also automatically have their listeners (callbacks linked to value change)
     * removed - as they cannot be triggered anymore, thus providing a security
     * against memory leaks.
     */
    constructor(initialValue, cancelSignal) {
      this._value = initialValue;
      this._listeners = [];
      this._isFinished = false;
      this._onFinishCbs = [];
      if (cancelSignal !== void 0) {
        this._deregisterCancellation = cancelSignal.register(() => this.finish());
      }
    }
    /**
     * Returns the current value of this shared reference.
     * @returns {*}
     */
    getValue() {
      return this._value;
    }
    /**
     * Update the value of this shared reference.
     * @param {*} newVal
     */
    setValue(newVal) {
      if (this._isFinished) {
        if (define_ENVIRONMENT_default.CURRENT_ENV === define_ENVIRONMENT_default.DEV) {
          console.error("Finished shared references cannot be updated");
        }
        return;
      }
      this._value = newVal;
      if (this._listeners.length === 0) {
        return;
      }
      const clonedCbs = this._listeners.slice();
      for (const cbObj of clonedCbs) {
        try {
          if (!cbObj.hasBeenCleared) {
            cbObj.trigger(newVal, cbObj.complete);
          }
        } catch (_) {
        }
      }
    }
    /**
     * Update the value of this shared reference only if the value changed.
     *
     * Note that this function only performs a strict equality reference through
     * the "===" operator. Different objects that are structurally the same will
     * thus be considered different.
     * @param {*} newVal
     */
    setValueIfChanged(newVal) {
      if (newVal !== this._value) {
        this.setValue(newVal);
      }
    }
    /**
     * Allows to register a callback to be called each time the value inside the
     * reference is updated.
     * @param {Function} cb - Callback to be called each time the reference is
     * updated. Takes as first argument its new value and in second argument a
     * callback allowing to unregister the callback.
     * @param {Object|undefined} [options]
     * @param {Object|undefined} [options.clearSignal] - Allows to provide a
     * CancellationSignal which will unregister the callback when it emits.
     * @param {boolean|undefined} [options.emitCurrentValue] - If `true`, the
     * callback will also be immediately called with the current value.
     */
    onUpdate(cb, options) {
      const unlisten = () => {
        if ((options == null ? void 0 : options.clearSignal) !== void 0) {
          options.clearSignal.deregister(unlisten);
        }
        if (cbObj.hasBeenCleared) {
          return;
        }
        cbObj.hasBeenCleared = true;
        const indexOf = this._listeners.indexOf(cbObj);
        if (indexOf >= 0) {
          this._listeners.splice(indexOf, 1);
        }
      };
      const cbObj = { trigger: cb, complete: unlisten, hasBeenCleared: false };
      this._listeners.push(cbObj);
      if ((options == null ? void 0 : options.emitCurrentValue) === true) {
        cb(this._value, unlisten);
      }
      if (this._isFinished || cbObj.hasBeenCleared) {
        unlisten();
        return;
      }
      if ((options == null ? void 0 : options.clearSignal) === void 0) {
        return;
      }
      options.clearSignal.register(unlisten);
    }
    /**
     * Variant of `onUpdate` which will only call the callback once, once the
     * value inside the reference is different from `undefined`.
     * The callback is called synchronously if the value already isn't set to
     * `undefined`.
     *
     * This method can be used as a lighter weight alternative to `onUpdate` when
     * just waiting that the stored value becomes defined.
     * As such, it is an explicit equivalent to something like:
     * ```js
     * myReference.onUpdate((newVal, stopListening) => {
     *  if (newVal !== undefined) {
     *    stopListening();
     *
     *    // ... do the logic
     *  }
     * }, { emitCurrentValue: true });
     * ```
     * @param {Function} cb - Callback to be called each time the reference is
     * updated. Takes the new value in argument.
     * @param {Object | undefined} [options]
     * @param {Object | undefined} [options.clearSignal] - Allows to provide a
     * CancellationSignal which will unregister the callback when it emits.
     */
    waitUntilDefined(cb, options) {
      this.onUpdate(
        (val, stopListening) => {
          if (val !== void 0) {
            stopListening();
            cb(this._value);
          }
        },
        { clearSignal: options == null ? void 0 : options.clearSignal, emitCurrentValue: true }
      );
    }
    /**
     * Allows to register a callback for when the Shared Reference is "finished".
     *
     * This function is mostly there for implementing operators on the shared
     * reference and isn't meant to be used by regular code, hence it being
     * prefixed by `_`.
     * @param {Function} cb - Callback to be called once the reference is
     * finished.
     * @param {Object} onFinishCancelSignal - Allows to provide a
     * CancellationSignal which will unregister the callback when it emits.
     */
    _onFinished(cb, onFinishCancelSignal) {
      if (onFinishCancelSignal.isCancelled()) {
        return noop_default;
      }
      const cleanUp = () => {
        const indexOf = arrayFindIndex(this._onFinishCbs, (x) => x.trigger === trigger);
        if (indexOf >= 0) {
          this._onFinishCbs[indexOf].hasBeenCleared = true;
          this._onFinishCbs.splice(indexOf, 1);
        }
      };
      const trigger = () => {
        cleanUp();
        cb();
      };
      const deregisterCancellation = onFinishCancelSignal.register(cleanUp);
      this._onFinishCbs.push({ trigger, hasBeenCleared: false });
      return deregisterCancellation;
    }
    /**
     * Indicate that no new values will be emitted.
     * Allows to automatically free all listeners linked to this reference.
     */
    finish() {
      if (this._deregisterCancellation !== void 0) {
        this._deregisterCancellation();
      }
      this._isFinished = true;
      const clonedCbs = this._listeners.slice();
      for (const cbObj of clonedCbs) {
        try {
          if (!cbObj.hasBeenCleared) {
            cbObj.complete();
            cbObj.hasBeenCleared = true;
          }
        } catch (_) {
        }
      }
      this._listeners.length = 0;
      if (this._onFinishCbs.length > 0) {
        const clonedFinishedCbs = this._onFinishCbs.slice();
        for (const cbObj of clonedFinishedCbs) {
          try {
            if (!cbObj.hasBeenCleared) {
              cbObj.trigger();
              cbObj.hasBeenCleared = true;
            }
          } catch (_) {
          }
        }
        this._onFinishCbs.length = 0;
      }
    }
  };
  function createMappedReference(originalRef, mappingFn, cancellationSignal) {
    const newRef = new SharedReference(
      mappingFn(originalRef.getValue()),
      cancellationSignal
    );
    originalRef.onUpdate(
      function mapOriginalReference(x) {
        newRef.setValue(mappingFn(x));
      },
      { clearSignal: cancellationSignal }
    );
    originalRef._onFinished(() => {
      newRef.finish();
    }, cancellationSignal);
    return newRef;
  }
  var reference_default = SharedReference;

  // src/utils/monotonic_timestamp.ts
  var mainThreadTimestampDiff = new reference_default(0);
  var getMonotonicTimeStamp = typeof performance !== "undefined" ? (
    // eslint-disable-next-line no-restricted-properties
    () => performance.now() + mainThreadTimestampDiff.getValue()
  ) : () => Date.now() + mainThreadTimestampDiff.getValue();
  var monotonic_timestamp_default = getMonotonicTimeStamp;

  // src/utils/logger.ts
  var DEFAULT_LOG_LEVEL = "NONE";
  var Logger = class extends EventEmitter {
    constructor() {
      super();
      this.error = noop_default;
      this.warn = noop_default;
      this.info = noop_default;
      this.debug = noop_default;
      this._levels = { NONE: 0, ERROR: 1, WARNING: 2, INFO: 3, DEBUG: 4 };
      this._currentFormat = "standard";
      this._currentLevel = DEFAULT_LOG_LEVEL;
    }
    /**
     * Update the logger's level to increase or decrease its verbosity, to change
     * its format with a newly set one, or to update its logging function.
     * @param {string} levelStr - One of the [upper-case] logger level. If the
     * given level is not valid, it will default to `"NONE"`.
     * @param {function|undefined} [logFn] - Optional logger function which will
     * be called with logs (with the corresponding upper-case logger level as
     * first argument).
     * Can be omited to just rely on regular logging functions.
     */
    setLevel(levelStr, format, logFn) {
      let level;
      const foundLevel = this._levels[levelStr];
      if (typeof foundLevel === "number") {
        level = foundLevel;
        this._currentLevel = levelStr;
      } else {
        level = 0;
        this._currentLevel = "NONE";
      }
      let actualFormat;
      if (format === "standard" || format === "full") {
        actualFormat = format;
      } else {
        actualFormat = "standard";
      }
      if (actualFormat === "full" && actualFormat !== this._currentFormat) {
        const now = monotonic_timestamp_default();
        console.log(String(now.toFixed(2)), "[Init]", `Local-Date: ${Date.now()}`);
      }
      this._currentFormat = actualFormat;
      const generateLogFn = this._currentFormat === "full" ? (namespace, consoleFn) => {
        return (...args) => {
          const now = monotonic_timestamp_default();
          return consoleFn(String(now.toFixed(2)), `[${namespace}]`, ...args);
        };
      } : (_namespace, consoleFn) => consoleFn;
      if (logFn === void 0) {
        this.error = level >= this._levels.ERROR ? generateLogFn("error", console.error.bind(console)) : noop_default;
        this.warn = level >= this._levels.WARNING ? generateLogFn("warn", console.warn.bind(console)) : noop_default;
        this.info = level >= this._levels.INFO ? generateLogFn("info", console.info.bind(console)) : noop_default;
        this.debug = level >= this._levels.DEBUG ? generateLogFn("log", console.log.bind(console)) : noop_default;
      } else {
        const produceLogFn = (logLevel) => {
          return level >= this._levels[logLevel] ? (...args) => {
            return logFn(logLevel, args);
          } : noop_default;
        };
        this.error = produceLogFn("ERROR");
        this.warn = produceLogFn("WARNING");
        this.info = produceLogFn("INFO");
        this.debug = produceLogFn("DEBUG");
      }
      this.trigger("onLogLevelChange", {
        level: this._currentLevel,
        format: this._currentFormat
      });
    }
    /**
     * Get the last set logger level, as an upper-case string value.
     * @returns {string}
     */
    getLevel() {
      return this._currentLevel;
    }
    /**
     * Get the last set logger's log format.
     * @returns {string}
     */
    getFormat() {
      return this._currentFormat;
    }
    /**
     * Returns `true` if the currently set level includes logs of the level given
     * in argument.
     * @param {string} logLevel
     * @returns {boolean}
     */
    hasLevel(logLevel) {
      return this._levels[logLevel] >= this._levels[this._currentLevel];
    }
  };

  // src/log.ts
  var logger = new Logger();
  var log_default = logger;

  // src/main_thread/api/index.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/main_thread/api/public_api.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/compat/can_rely_on_video_visibility_and_size.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/compat/browser_detection.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var isEdgeChromium = false;
  var isIE11 = false;
  var isIEOrEdge = false;
  var isFirefox = false;
  var isSafariDesktop = false;
  var isSafariMobile = false;
  var isSamsungBrowser = false;
  var isTizen = false;
  var isWebOs = false;
  var isWebOs2021 = false;
  var isWebOs2022 = false;
  var isPanasonic = false;
  var isPhilipsNetTv = false;
  var isPlayStation4 = false;
  var isPlayStation5 = false;
  var isXbox = false;
  var isA1KStb40xx = false;
  (function findCurrentBrowser() {
    var _a, _b, _c;
    if (is_node_default) {
      return;
    }
    if (typeof global_scope_default.MSInputMethodContext !== "undefined" && typeof document.documentMode !== "undefined") {
      isIE11 = true;
      isIEOrEdge = true;
    } else if (navigator.appName === "Microsoft Internet Explorer" || navigator.appName === "Netscape" && /(Trident|Edge)\//.test(navigator.userAgent)) {
      isIEOrEdge = true;
    } else if (navigator.userAgent.toLowerCase().indexOf("edg/") !== -1) {
      isEdgeChromium = true;
    } else if (navigator.userAgent.toLowerCase().indexOf("firefox") !== -1) {
      isFirefox = true;
    } else if (typeof navigator.platform === "string" && /iPad|iPhone|iPod/.test(navigator.platform)) {
      isSafariMobile = true;
    } else if (
      // the following statement check if the window.safari contains the method
      // "pushNotification", this condition is not met when using web app from the dock
      // on macOS, this is why we also check userAgent.
      Object.prototype.toString.call(global_scope_default.HTMLElement).indexOf("Constructor") >= 0 || ((_b = (_a = global_scope_default.safari) == null ? void 0 : _a.pushNotification) == null ? void 0 : _b.toString()) === "[object SafariRemoteNotification]" || // browsers are lying: Chrome reports both as Chrome and Safari in user
      // agent string, So to detect Safari we have to check for the Safari string
      // and the absence of the Chrome string
      // @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Browser_detection_using_the_user_agent#which_part_of_the_user_agent_contains_the_information_you_are_looking_for
      /Safari\/(\d+)/.test(navigator.userAgent) && // Safari should contain Version/ in userAgent
      /Version\/(\d+)/.test(navigator.userAgent) && ((_c = navigator.vendor) == null ? void 0 : _c.indexOf("Apple")) !== -1 && !/Chrome\/(\d+)/.test(navigator.userAgent) && !/Chromium\/(\d+)/.test(navigator.userAgent)
    ) {
      isSafariDesktop = true;
    }
    if (/SamsungBrowser/.test(navigator.userAgent)) {
      isSamsungBrowser = true;
    }
    if (navigator.userAgent.indexOf("PlayStation 4") !== -1) {
      isPlayStation4 = true;
    } else if (navigator.userAgent.indexOf("PlayStation 5") !== -1) {
      isPlayStation5 = true;
    } else if (/Tizen/.test(navigator.userAgent)) {
      isTizen = true;
    } else if (/[Ww]eb[O0]S/.test(navigator.userAgent)) {
      isWebOs = true;
      if (/[Ww]eb[O0]S.TV-2022/.test(navigator.userAgent) || /[Cc]hr[o0]me\/87/.test(navigator.userAgent)) {
        isWebOs2022 = true;
      } else if (/[Ww]eb[O0]S.TV-2021/.test(navigator.userAgent) || /[Cc]hr[o0]me\/79/.test(navigator.userAgent)) {
        isWebOs2021 = true;
      }
    } else if (navigator.userAgent.indexOf("NETTV") !== -1 && navigator.userAgent.indexOf("Philips") !== -1) {
      isPhilipsNetTv = true;
    } else if (/[Pp]anasonic/.test(navigator.userAgent)) {
      isPanasonic = true;
    } else if (navigator.userAgent.indexOf("Xbox") !== -1) {
      isXbox = true;
    } else if (navigator.userAgent.indexOf("Model/a1-kstb40xx")) {
      isA1KStb40xx = true;
    }
  })();

  // src/compat/browser_version.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function getFirefoxVersion() {
    if (!isFirefox) {
      log_default.warn("Compat: Can't access Firefox version on no firefox browser.");
      return null;
    }
    const userAgent = navigator.userAgent;
    const match = /Firefox\/([0-9]+)\./.exec(userAgent);
    if (match === null) {
      return -1;
    }
    const result = parseInt(match[1], 10);
    if (isNaN(result)) {
      return -1;
    }
    return result;
  }

  // src/compat/can_rely_on_video_visibility_and_size.ts
  function canRelyOnVideoVisibilityAndSize() {
    if (!isFirefox) {
      return true;
    }
    const firefoxVersion = getFirefoxVersion();
    if (firefoxVersion === null || firefoxVersion < 67) {
      return true;
    }
    const proto = HTMLVideoElement == null ? void 0 : HTMLVideoElement.prototype;
    return (proto == null ? void 0 : proto.requirePictureInPicture) !== void 0;
  }

  // src/compat/event_listeners.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/config.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/default_config.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var DEFAULT_CONFIG = {
    /**
     * Default time interval after which a request will timeout, in ms.
     * @type {Number}
     */
    DEFAULT_REQUEST_TIMEOUT: 30 * 1e3,
    /**
     * Default connection time after which a request will timeout, in ms.
     * @type {Number}
     */
    DEFAULT_CONNECTION_TIMEOUT: 15 * 1e3,
    /**
     * Can be either:
     *   - "native": Subtitles are all displayed in a <track> element
     *   - "html": Subtitles are all displayed in a <div> separated from the video
     *     element. Can be useful to display richer TTML subtitles, for example.
     * @type {Object|null}
     */
    DEFAULT_TEXT_TRACK_MODE: "native",
    /**
     * Default behavior for the `enableFastSwitching` loadVideo options.
     *
     * Fast-switching allows to provide quicker transitions from lower quality
     * segments to higher quality segments but might be badly supported on some
     * devices.
     * When enabled, the RxPlayer might replace segments of a lower-quality
     * (with a lower bitrate) with segments of a higher quality (with a higher
     * bitrate). This allows to have a fast transition when network conditions
     * improve.
     * When disabled, segments of a lower-quality will not be replaced.
     */
    DEFAULT_ENABLE_FAST_SWITCHING: true,
    /**
     * In some cases after switching the current track or bitrate, the RxPlayer
     * could be led to go into the `"RELOADING"` state, which corresponds to
     * visually a black screen (with nothing audible) before restarting playback.
     *
     * We could want to seek back some milliseconds when doing that.
     * For example, when switching the current audio track, it might make sense
     * to restart some time before, so the beginning of the sentence can be heard
     * again in the new language.
     *
     * This config property allows to set the relative position the RxPlayer will
     * seek to after reloading, in seconds.
     *
     * For example: a value of `-0.7` means that will seek back 700 milliseconds
     * when reloading due to a track or bitrate switch with necessitated a
     * reloading.
     */
    DELTA_POSITION_AFTER_RELOAD: {
      /** Relative position when switching the bitrate */
      bitrateSwitch: -0.1,
      /**
       * Relative position when switching the track.
       *
       * From tests, I noticed that seeking back was only really "pleasant" when
       * switching the audio track.
       *
       * E.g. switching the video track often means changing the camera angle or
       * even totally changing what is being seen and rely much less on temporal
       * context than when an audio track is switched.
       * As such, I decided to only set a sensible seek-back behavior when
       * switching the audio track, and only a minimal one (to still ensure
       * nothing was missed) for video.
       *
       * "Other" mainly concern text track, where seeking back could even be
       * annoying, so that behavior has been disabled in that case.
       */
      trackSwitch: { audio: 0, video: 0, other: 0 }
    },
    /**
     * Behavior of the RxPlayer when encountering a whole other codec on a already
     * existing audio or video SourceBuffer.
     *
     * Can be either:
     *
     *    - "continue": Segments linked to the new codec will continue to be
     *      pushed to that same SourceBuffer. The RxPlayer will still try to call
     *      the `changeType` API on the SourceBuffer before pushing those
     *      segments but continue even if this call failed.
     *
     *    - "reload": Every time a new incompatible codec is encountered on a
     *      given SourceBuffer, we will reload the MediaSource.
     */
    DEFAULT_CODEC_SWITCHING_BEHAVIOR: "continue",
    /**
     * If set to true, video through loadVideo will auto play by default
     * @type {Boolean}
     */
    DEFAULT_AUTO_PLAY: false,
    /**
     * Default buffer goal in seconds.
     * Once enough content has been downloaded to fill the buffer up to
     * ``current position + DEFAULT_WANTED_BUFFER_AHEAD", we will stop downloading
     * content.
     * @type {Number}
     */
    DEFAULT_WANTED_BUFFER_AHEAD: 30,
    /**
     * Default max buffer size ahead of the current position in seconds.
     * The buffer _after_ this limit will be garbage collected.
     * Set to Infinity for no limit.
     * @type {Number}
     */
    DEFAULT_MAX_BUFFER_AHEAD: Infinity,
    /**
     * Default max buffer size ahead of the current position in seconds.
     * The buffer _before_ this limit will be garbage collected.
     * Set to Infinity for no limit.
     * @type {Number}
     */
    DEFAULT_MAX_BUFFER_BEHIND: Infinity,
    /**
     * Default video buffer memory limit in kilobytes.
     * Once enough video content has been downloaded to fill the buffer up to
     * DEFAULT_MAX_VIDEO_BUFFER_SIZE , we will stop downloading
     * content.
     * @type {Number}
     */
    DEFAULT_MAX_VIDEO_BUFFER_SIZE: Infinity,
    /**
     * Maximum possible buffer ahead for each type of buffer, to avoid too much
     * memory usage when playing for a long time.
     * Equal to Infinity if not defined here.
     * @type {Object}
     */
    MAXIMUM_MAX_BUFFER_AHEAD: {
      text: 5 * 60 * 60
    },
    /**
     * Minimum possible buffer ahead for each type of buffer, to avoid Garbage
     * Collecting too much data when it would have adverse effects.
     * Equal to `0` if not defined here.
     * @type {Object}
     */
    MINIMUM_MAX_BUFFER_AHEAD: {
      // Text segments are both much lighter on resources and might
      // actually be much larger than other types of segments in terms
      // of duration. Let's make an exception here by authorizing a
      // larger text buffer ahead, to avoid unnecesarily reloading the
      // same text track.
      text: 2 * 60
    },
    /**
     * Maximum possible buffer behind for each type of buffer, to avoid too much
     * memory usage when playing for a long time.
     * Equal to Infinity if not defined here.
     * @type {Object}
     */
    MAXIMUM_MAX_BUFFER_BEHIND: {
      text: 5 * 60 * 60
    },
    /**
     * Default bitrate ceils initially set as the first content begins.
     *
     * If no track is found with a bitrate inferior or equal to the
     * bitrate there, the one with the lowest bitrate will be taken instead.
     *
     * Set to 0 for the lowest bitrate, Infinity for the highest.
     *
     * These values are only useful for the first content played, as consecutive
     * play will always take the last set one.
     * @type {Object}
     */
    DEFAULT_BASE_BANDWIDTH: 0,
    /**
     * Delay after which, if the page is hidden, the user is considered inactive
     * on the current video.
     *
     * Allow to enforce specific optimizations when the page is not shown.
     * @see DEFAULT_THROTTLE_WHEN_HIDDEN
     * @type {Number}
     */
    INACTIVITY_DELAY: 60 * 1e3,
    /**
     * If true, if the video is considered in a "hidden" state for a delay specified by
     * the INACTIVITY DELAY config property, we throttle automatically to the video
     * representation with the lowest bitrate.
     * @type {Boolean}
     */
    DEFAULT_THROTTLE_VIDEO_BITRATE_WHEN_HIDDEN: false,
    /**
     * Default video resolution limit behavior.
     *
     * This option allows for example to throttle the video resolution so it
     * does not exceed the screen resolution.
     *
     * Here set to "none" by default to disable throttling.
     * @type {Boolean}
     */
    DEFAULT_VIDEO_RESOLUTION_LIMIT: "none",
    /**
     * Default initial live gap considered if no presentation delay has been
     * suggested, in seconds.
     * @type {Number}
     */
    DEFAULT_LIVE_GAP: {
      DEFAULT: 10,
      LOW_LATENCY: 3.5
    },
    /**
     * Maximum time, in seconds, the player should automatically skip when stalled
     * because of a current hole in the buffer.
     * Bear in mind that this might seek over not-yet-downloaded/pushed segments.
     * @type {Number}
     */
    BUFFER_DISCONTINUITY_THRESHOLD: 0.2,
    /**
     * Ratio used to know if an already loaded segment should be re-buffered.
     * We re-load the given segment if the current one times that ratio is
     * inferior to the new one.
     * @type {Number}
     */
    BITRATE_REBUFFERING_RATIO: 1.5,
    /**
     * The default number of times a manifest request will be re-performed
     * when loaded/refreshed if the request finishes on an error which
     * justify an retry.
     *
     * Note that some errors do not use this counter:
     *   - if the error is not due to the xhr, no retry will be peformed
     *   - if the error is an HTTP error code, but not a 500-smthg or a 404, no
     *     retry will be performed.
     * @type Number
     */
    DEFAULT_MAX_MANIFEST_REQUEST_RETRY: 4,
    /**
     * Default delay, in seconds, during which a CDN will be "downgraded".
     *
     * For example in case of media content being available on multiple CDNs, the
     * RxPlayer may decide that a CDN is less reliable (for example, it returned a
     * server error) and should thus be avoided, at least for some time
     *
     * This value is the amount of time this CDN will be "less considered" than the
     * alternatives.
     */
    DEFAULT_CDN_DOWNGRADE_TIME: 60,
    /**
     * The default number of times a segment request will be re-performed when
     * on error which justify a retry.
     *
     * Note that some errors do not use this counter:
     *   - if the error is not due to the xhr, no retry will be peformed
     *   - if the error is an HTTP error code, but not a 500-smthg or a 404, no
     *     retry will be performed.
     * @type Number
     */
    DEFAULT_MAX_REQUESTS_RETRY_ON_ERROR: 4,
    /**
     * Initial backoff delay when a segment / manifest download fails, in
     * milliseconds.
     *
     * This delay will then grow exponentally by power of twos (200, 400, 800
     * etc.)
     *
     * Please note that this delay is not exact, as it will be fuzzed.
     * @type {Number}
     */
    INITIAL_BACKOFF_DELAY_BASE: {
      REGULAR: 200,
      LOW_LATENCY: 50
    },
    /**
     * Maximum backoff delay when a segment / manifest download fails, in
     * milliseconds.
     *
     * Please note that this delay is not exact, as it will be fuzzed.
     * @type {Number}
     */
    MAX_BACKOFF_DELAY_BASE: {
      REGULAR: 3e3,
      LOW_LATENCY: 1e3
    },
    /**
     * Minimum interval at which playback information samples will be taken. This
     * variable is for the "regular" mediasource strategy (that is, not for the
     * directfile API.
     *
     * At each of these interval, various different modules in the RxPlayer will
     * run based on the information communicated.
     *
     * Keep in mind this is the minimum interval. This logic will also be
     * triggered when various events of the media element are received.
     * @type {Number}
     */
    SAMPLING_INTERVAL_MEDIASOURCE: 1e3,
    /**
     * Same than SAMPLING_INTERVAL_MEDIASOURCE but for lowLatency mode.
     * @type {Number}
     */
    SAMPLING_INTERVAL_LOW_LATENCY: 500,
    /**
     * Same than SAMPLING_INTERVAL_MEDIASOURCE but for the directfile API.
     * @type {Number}
     */
    SAMPLING_INTERVAL_NO_MEDIASOURCE: 500,
    /**
     * Amount of buffer to have ahead of the current position before we may
     * consider buffer-based adaptive estimates, in seconds.
     *
     * For example setting it to `10` means that we need to have ten seconds of
     * buffer ahead of the current position before relying on buffer-based
     * adaptive estimates.
     *
     * To avoid getting in-and-out of the buffer-based logic all the time, it
     * should be set higher than `ABR_EXIT_BUFFER_BASED_ALGO`.
     */
    ABR_ENTER_BUFFER_BASED_ALGO: 10,
    /**
     * Below this amount of buffer ahead of the current position, in seconds, we
     * will stop using buffer-based estimate in our adaptive logic to select a
     * quality.
     *
     * For example setting it to `5` means that if we have less than 5 seconds of
     * buffer ahead of the current position, we should stop relying on
     * buffer-based estimates to choose a quality.
     *
     * To avoid getting in-and-out of the buffer-based logic all the time, it
     * should be set lower than `ABR_ENTER_BUFFER_BASED_ALGO`.
     */
    ABR_EXIT_BUFFER_BASED_ALGO: 5,
    /**
     * Minimum number of bytes sampled before we trust the estimate.
     * If we have not sampled much data, our estimate may not be accurate
     * enough to trust.
     * If the total of bytes sampled is less than this value, we use a
     * default estimate.
     * This specific value is based on experimentations.
     * @type {Number}
     */
    ABR_MINIMUM_TOTAL_BYTES: 15e4,
    /**
     * Minimum number of bytes, under which samples are discarded.
     * Our models do not include latency information, so connection startup time
     * (time to first byte) is considered part of the download time.
     * Because of this, we should ignore very small downloads which would cause
     * our estimate to be too low.
     * This specific value is based on experimentation.
     * @type {Number}
     */
    ABR_MINIMUM_CHUNK_SIZE: 16e3,
    /**
     * Factor with which is multiplied the bandwidth estimate when the ABR is in
     * starvation mode.
     * @type {Object}
     */
    ABR_STARVATION_FACTOR: {
      DEFAULT: 0.72,
      LOW_LATENCY: 0.72
    },
    /**
     * Factor with which is multiplied the bandwidth estimate when the ABR is not
     * in starvation mode.
     * @type {Object}
     */
    ABR_REGULAR_FACTOR: {
      DEFAULT: 0.72,
      LOW_LATENCY: 0.72
    },
    /**
     * If a media buffer has less than ABR_STARVATION_GAP in seconds ahead of the
     * current position in its buffer, the adaptive logic will go into starvation
     * mode.
     *
     * It gets out of starvation mode when the OUT_OF_STARVATION_GAP value is
     * reached.
     *
     * Under this starvation mode:
     *
     *   - the bandwidth considered will be a little lower than the one estimated
     *
     *   - the time the next important request take will be checked
     *     multiple times to detect when/if it takes too much time.
     *     If the request is considered too long, the bitrate will be hastily
     *     re-calculated from this single request.
     *
     * @type {Object}
     */
    ABR_STARVATION_GAP: {
      DEFAULT: 5,
      LOW_LATENCY: 5
    },
    OUT_OF_STARVATION_GAP: {
      DEFAULT: 7,
      LOW_LATENCY: 7
    },
    /**
     * This is a security to avoid going into starvation mode when the content is
     * ending (@see ABR_STARVATION_GAP).
     * Basically, we subtract that value from the global duration of the content
     * and we never enter "starvation mode" if the currently available buffer
     * (which equals to the current position + the available buffer ahead of it)
     * is equal or higher than this value.
     * @type {Number}
     */
    ABR_STARVATION_DURATION_DELTA: 0.1,
    /**
     * Half-life, in seconds for a fastly-evolving exponential weighted moving
     * average.
     * The lower it is, the faster the ABR logic will react to the bandwidth
     * falling quickly.
     * Should be kept to a lower number than ABR_SLOW_EMA for coherency reasons.
     * @type {Number}
     */
    ABR_FAST_EMA: 2,
    /**
     * Half-life, in seconds for a slowly-evolving exponential weighted moving
     * average.
     * The lower it is, the faster the ABR logic is going to react to recent
     * bandwidth variation, on the higher and on the lower side.
     * Should be kept to a higher number than ABR_FAST_EMA for coherency reasons.
     * @type {Number}
     */
    ABR_SLOW_EMA: 10,
    /**
     * Number of seconds ahead in the buffer after which playback will resume when
     * seeking on an unbuffered part of the content.
     * @type {Number}
     */
    RESUME_GAP_AFTER_SEEKING: {
      DEFAULT: 1.5,
      LOW_LATENCY: 0.5
    },
    /**
     * Number of seconds ahead in the buffer after which playback will resume when
     * the player was rebuffering due to a low readyState.
     * @type {Number}
     */
    RESUME_GAP_AFTER_NOT_ENOUGH_DATA: {
      DEFAULT: 0.5,
      LOW_LATENCY: 0.5
    },
    /**
     * Number of seconds ahead in the buffer after which playback will resume
     * after the player went through a buffering step.
     * @type {Number}
     */
    RESUME_GAP_AFTER_BUFFERING: {
      DEFAULT: 5,
      LOW_LATENCY: 0.5
    },
    /**
     * Maximum number of seconds in the buffer based on which a "rebuffering"
     * strategy will be considered:
     * The player will pause playback to get enough time building a sufficient
     * buffer. This mostly happen when seeking in an unbuffered part or when not
     * enough buffer is ahead of the current position.
     * @type {Number}
     */
    REBUFFERING_GAP: {
      DEFAULT: 0.5,
      LOW_LATENCY: 0.2
    },
    /**
     * Amount of time (in seconds) with data ahead of the current position, at
     * which we always consider the browser to be able to play.
     *
     * If the media element has this amount of data in advance or more but
     * playback cannot begin, the player will consider it "freezing".
     */
    MINIMUM_BUFFER_AMOUNT_BEFORE_FREEZING: 2,
    /**
     * A media whose position inexplicably does not increment despite playing is
     * called as "freezing" in the RxPlayer.
     *
     * If the media is still "freezing" after waiting for `UNFREEZING_SEEK_DELAY`
     * milliseconds, the RxPlayer will try to un-freeze the situation by interacting
     * with the media element.
     *
     * Those interactions can be costly in time before playback continue, so it
     * should be set at a sufficiently high value to avoid false positives.
     */
    UNFREEZING_SEEK_DELAY: 6e3,
    /**
     * A media whose position inexplicably does not increment despite playing is
     * called as "freezing" in the RxPlayer.
     *
     * A small freezing interval may be normal as the browser may take time before
     * playing, e.g. after a seek.
     *
     * If the media is still "freezing" after waiting for `FREEZING_STALLED_DELAY`
     * milliseconds, the RxPlayer will emit a BUFFERING state through its API to
     * notify that the player cannot currently advance.
     */
    FREEZING_STALLED_DELAY: 600,
    /**
     * A media whose position inexplicably does not increment despite playing is
     * called as "freezing" in the RxPlayer.
     *
     * If the media is frozen for a sufficiently large time
     * (@see UNFREEZING_SEEK_DELAY), the RxPlayer will perform a seek corresponding
     * to its current position plus `UNFREEZING_DELTA_POSITION` seconds.
     *
     * This should be kept short enough as the goal is just to un-freeze lower-level
     * buffers.
     */
    UNFREEZING_DELTA_POSITION: 1e-3,
    /**
     * The RxPlayer has a recurring logic which will synchronize the browser's
     * buffers' buffered time ranges with its internal representation in the
     * RxPlayer to then rely on that internal representation to determine where
     * segments are technically present in the browser's buffer.
     *
     * We found out that when inserting a new segment to the buffer, the browser
     * may actually take time before actually considering the full segment in its
     * advertised buffered time ranges.
     *
     * This value thus set an amount of milliseconds we might want to wait before
     * being sure that the buffered time ranges should have considered a segment
     * that has been pushed.
     */
    SEGMENT_SYNCHRONIZATION_DELAY: 1500,
    /**
     * The `SEGMENT_SYNCHRONIZATION_DELAY` defined in this same configuration
     * object only needs to be used if it appears that the current buffered
     * time ranges do not reflect the full data of a pushed segment yet.
     *
     * The `MISSING_DATA_TRIGGER_SYNC_DELAY` value thus allows to define a
     * minimum time difference in seconds between what's buffered and what the
     * segment's ranges should have been, from which we might consider that we may
     * want to wait the `SEGMENT_SYNCHRONIZATION_DELAY` before trusting the buffered
     * time ranges for that segment.
     * If what's missing from that segment is however less than that value in
     * seconds, we can begin to trust the reported buffered time ranges.
     *
     * Should generally be inferior to `MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT`.
     */
    MISSING_DATA_TRIGGER_SYNC_DELAY: 0.1,
    /**
     * Maximum authorized difference between what we calculated to be the
     * beginning or end of the segment in a media buffer and what we
     * actually are noticing now.
     *
     * If the segment seems to have removed more than this size in seconds, we
     * will infer that the segment has been garbage collected and we might try to
     * re-download it.
     * @type {Number}
     */
    MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT: 0.15,
    /**
     * The maximum authorized difference, in seconds, between the real buffered
     * time of a given chunk and what the segment information of the Manifest
     * tells us.
     *
     * Setting a value too high can lead to parts of the media buffer being
     * linked to the wrong segments and to segments wrongly believed to be still
     * complete (instead of garbage collected).
     *
     * Setting a value too low can lead to parts of the media buffer not being
     * linked to the concerned segment and to segments wrongly believed to be
     * partly garbage collected (instead of complete segments).
     * @type {Number}
     */
    MAX_MANIFEST_BUFFERED_START_END_DIFFERENCE: 0.4,
    /**
     * The maximum authorized difference, in seconds, between the duration a
     * segment should have according to the Manifest and the actual duration it
     * seems to have once pushed to the media buffer.
     *
     * Setting a value too high can lead to parts of the media buffer being
     * linked to the wrong segments and to segments wrongly believed to be still
     * complete (instead of garbage collected).
     *
     * Setting a value too low can lead to parts of the media buffer not being
     * linked to the concerned segment and to segments wrongly believed to be
     * partly garbage collected (instead of complete segments). This last point
     * could lead to unnecessary segment re-downloading.
     * @type {Number}
     */
    MAX_MANIFEST_BUFFERED_DURATION_DIFFERENCE: 0.3,
    /**
     * Minimum duration in seconds a segment should be into a buffered range to be
     * considered as part of that range.
     * Segments which have less than this amount of time "linked" to a buffered
     * range will be deleted.
     *
     * Setting a value too low can lead in worst-case scenarios to segments being
     * wrongly linked to the next or previous range it is truly linked too (if
     * those ranges are too close).
     *
     * Setting a value too high can lead to part of the buffer not being assigned
     * any segment. It also limits the minimum duration a segment can be.
     *
     * TODO As of now, this limits the minimum size a complete segment can be. A
     * better logic would be to also consider the duration of a segment. Though
     * this logic could lead to bugs with the current code.
     * @type {Number}
     */
    MINIMUM_SEGMENT_SIZE: 1e-3,
    /**
     * Append windows allow to filter media data from segments if they are outside
     * a given limit.
     * Coded frames with presentation timestamp within this range are allowed to
     * be appended to the media buffer while coded frames outside this range are
     * filtered out.
     *
     * Those are often set to be the start and end of the "Period" the segment is
     * in.
     * However, we noticed that some browsers were too aggressive when the exact
     * limits were set: more data than needed was removed, often leading to
     * discontinuities.
     *
     * Those securities are added to the set windows (substracted from the window
     * start and added to the window end) to avoid those problems.
     * @type {Object}
     */
    APPEND_WINDOW_SECURITIES: {
      START: 0.2,
      END: 0.1
    },
    /**
     * Maximum interval at which text tracks are refreshed in an "html"
     * textTrackMode.
     *
     * The text tracks are also refreshed on various video events, this interval
     * will only trigger a refresh if none of those events was received during
     * that timespan.
     *
     * Note that if the TextTrack cue did not change between two intervals or
     * events, the DOM won't be refreshed.
     * The TextTrack cues structure is also optimized for fast retrieval.
     * We should thus not have much of a performance impact here if we set a low
     * interval.
     *
     * @type {Number}
     */
    MAXIMUM_HTML_TEXT_TRACK_UPDATE_INTERVAL: 50,
    /**
     * On browsers with no ResizeObserver API, this will be the interval in
     * milliseconds at which we should check if the text track element has
     * changed its size, and updates proportional text-track data accordingly
     * (like a proportional font-size).
     *
     * This is only used:
     *   - in an "html" textTrackMode
     *   - when some styling is proportional in the text track data
     *
     * Putting a value too low will render faster but might use to much proc time.
     * Putting a value too high might provoke a re-render too late after the user
     * changed the element's size (e.g. when going to fullscreen mode).
     *
     * @type {Number}
     */
    TEXT_TRACK_SIZE_CHECKS_INTERVAL: 250,
    /**
     * The Buffer padding is a time offset from the current time that affects
     * the buffer.
     *
     * Basically, from a given time, if the current buffer gap number (time
     * between the current time and the end of the downloaded buffer) is above
     * the padding described here (of the corresponding type), we won't
     * reschedule segments for that range.
     *
     * This is to avoid excessive re-buffering.
     *
     * Keeping the padding too low would increase the risk of re-bufferings.
     *
     * Keeping the padding too high would delay visible quality increase.
     *
     * @type {Object}
     */
    BUFFER_PADDING: {
      audio: 1,
      // only "audio" segments
      video: 3,
      // only "video" segments
      other: 1
      // tracks which are not audio/video (like text).
    },
    /**
     * Segments of different types are downloaded by steps:
     *
     *   - first the audio/video/text Segments which are immediately needed
     *
     *   - then once every of those Segments have been downloaded, less-needed
     *     Segments
     *
     *   - then once every of those less-needed Segments have been downloaded,
     *     even less-needed Segments
     *
     *   - etc.
     *
     * This stepped download strategy allows to make a better use of network
     * ressources.
     *
     * For example, if more than sufficient audio buffer has been downloaded but
     * the immediately-needed video Segment is still pending its request, we might
     * be in a situation of rebuffering.
     * In that case, a better strategy would be to make sure every network
     * ressource is allocated for this video Segment before rebuffering happens.
     *
     * This is where those steps become useful.
     *
     * --
     *
     * The numbers defined in this Array describe what the steps are.
     *
     * Each number is linked to a distance from the current playing position, in
     * seconds.
     * Distances which will be used as limit points, from which a new step is
     * reached (see example).
     *
     * In the RxPlayer's code, each step is then translated in to a priority
     * number.
     * The lower is that number, the lower is the step and the lower is the step,
     * the higher is the priority.
     *
     * Note: You can set an empty array to deactivate the steps feature (every
     * Segments have the same priority).
     *
     * @example
     *
     * let's imagine the following SEGMENT_PRIORITIES_STEPS array:
     * [5, 11, 17, 25]
     *
     * To link each Segments to a corresponding priority number (and thus to a
     * specific step), we have to consider the distance between the current
     * position and the start time of the Segment.
     *
     * We have in our example 5 groups, which correspond to the following possible
     * distances:
     *   1. inferior to 5 => first step (priority number = 0)
     *   2. between 5 and 11 => second step (priority number = 1)
     *   3. between 11 and 17 => third step (priority number = 2)
     *   4. between 17 and 25 => fourth step (priority number = 3)
     *   5. superior to 25 => fifth step (priority number = 4)
     *
     * Segments corresponding to a lower-step will need to all be downloaded
     * before Segments of a newer step begin.
     *
     * @type {Array.<Number>}
     */
    SEGMENT_PRIORITIES_STEPS: [
      2,
      // 1st Step (priority number = 0):  < 2
      4,
      // 2nd Step (priority number = 1):  2-4
      8,
      // 3rd Step (priority number = 2):  4-8
      12,
      // 4th Step (priority number = 3):  8-12
      18,
      // 5th Step (priority number = 4):  12-18
      25
    ],
    // 6th Step (priority number = 5):  18-25
    // 7th Step (priority number = 6):  >= 25
    /**
     * Some segment requests are said to be "high priority".
     *
     * Requests in that category once done will cancel any segment request that
     * has a low priority number (see `SEGMENT_PRIORITIES_STEPS`) - meaning a
     * priority number equal to `MIN_CANCELABLE_PRIORITY` or more.
     *
     * Enter here the last priority number that is considered high priority
     * (beginning by the first step, which has the priority number `0`).
     * @type {number}
     */
    MAX_HIGH_PRIORITY_LEVEL: 1,
    // priority number 1 and lower is high priority
    /**
     * Enter here the first priority step (see `SEGMENT_PRIORITIES_STEPS`) that
     * will be considered as low priority.
     *
     * Segment requests with a low priority will be cancelled if a high priority
     * segment request (see MAX_HIGH_PRIORITY_LEVEL) is scheduled while they are
     * pending.
     *
     * This number should be strictly superior to the value indicated in
     * `MAX_HIGH_PRIORITY_LEVEL`.
     * @type {number}
     */
    MIN_CANCELABLE_PRIORITY: 3,
    // priority number 3 onward can be cancelled
    /**
     * Codecs used in the videoCapabilities of the MediaKeySystemConfiguration
     * (DRM).
     *
     * Defined in order of importance (first will be tested first etc.)
     * @type {Array.<string>}
     */
    EME_DEFAULT_VIDEO_CODECS: [
      'video/mp4;codecs="avc1.4d401e"',
      'video/mp4;codecs="avc1.42e01e"',
      'video/mp4;codecs="hvc1.1.6.L93.B0"',
      'video/webm;codecs="vp8"'
    ],
    /**
     * Codecs used in the audioCapabilities of the MediaKeySystemConfiguration
     * (DRM).
     *
     * Defined in order of importance (first will be tested first etc.)
     * @type {Array.<string>}
     */
    EME_DEFAULT_AUDIO_CODECS: ['audio/mp4;codecs="mp4a.40.2"', "audio/webm;codecs=opus"],
    /**
     * Robustnesses used in the {audio,video}Capabilities of the
     * MediaKeySystemConfiguration (DRM).
     *
     * Only used for widevine keysystems.
     *
     * Defined in order of importance (first will be tested first etc.)
     * @type {Array.<string>}
     */
    EME_DEFAULT_WIDEVINE_ROBUSTNESSES: [
      "HW_SECURE_ALL",
      "HW_SECURE_DECODE",
      "HW_SECURE_CRYPTO",
      "SW_SECURE_DECODE",
      "SW_SECURE_CRYPTO"
    ],
    /**
     * Robustnesses used in the {audio,video}Capabilities of the
     * MediaKeySystemConfiguration (DRM).
     *
     * Only used for "com.microsoft.playready.recommendation" keysystems.
     *
     * Defined in order of importance (first will be tested first etc.)
     * @type {Array.<string>}
     */
    EME_DEFAULT_PLAYREADY_RECOMMENDATION_ROBUSTNESSES: ["3000", "2000"],
    /**
     * Link canonical key systems names to their respective reverse domain name,
     * used in the EME APIs.
     * This allows to have a simpler API, where users just need to set "widevine"
     * or "playready" as a keySystem.
     * @type {Object}
     */
    EME_KEY_SYSTEMS: {
      clearkey: ["webkit-org.w3.clearkey", "org.w3.clearkey"],
      widevine: ["com.widevine.alpha"],
      playready: [
        "com.microsoft.playready.recommendation",
        "com.microsoft.playready",
        "com.chromecast.playready",
        "com.youtube.playready"
      ],
      fairplay: ["com.apple.fps.1_0"]
    },
    /**
     * The Manifest parsing logic has a notion of "unsafeMode" which allows to
     * speed-up this process a lot with a small risk of de-synchronization with
     * what actually is on the server.
     * Because using that mode is risky, and can lead to all sort of problems, we
     * regularly should fall back to a regular "safe" parsing every once in a
     * while.
     * This value defines how many consecutive time maximum the "unsafeMode"
     * parsing can be done.
     */
    MAX_CONSECUTIVE_MANIFEST_PARSING_IN_UNSAFE_MODE: 10,
    /**
     * Minimum time spent parsing the Manifest before we can authorize parsing
     * it in an "unsafeMode", to speed-up the process with a little risk.
     * Please note that this parsing time also sometimes includes idle time such
     * as when the parser is waiting for a request to finish.
     */
    MIN_MANIFEST_PARSING_TIME_TO_ENTER_UNSAFE_MODE: 200,
    /**
     * Minimum amount of <S> elements in a DASH MPD's <SegmentTimeline> element
     * necessary to begin parsing the current SegmentTimeline element in an
     * unsafe manner (meaning: with risks of de-synchronization).
     * This is only done when the "unsafeMode" parsing mode is enabled.
     */
    MIN_DASH_S_ELEMENTS_TO_PARSE_UNSAFELY: 300,
    /**
     * When we detect that the local Manifest might be out-of-sync with the
     * server's one, we schedule a Manifest refresh.
     * However, as this "unsynchronization" is only a theory and as we do not want
     * to send too many Manifest requests, we keep a delay between the last
     * Manifest refresh done and that one.
     * This value indicates which delay we want. Note that the Manifest could
     * still be refreshed before this delay for other reasons.
     * @type {Number}
     */
    OUT_OF_SYNC_MANIFEST_REFRESH_DELAY: 3e3,
    /**
     * When a partial Manifest update (that is an update with a partial sub-set
     * of the Manifest) fails, we will perform an update with the whole Manifest
     * instead.
     * To not overload the client - as parsing a Manifest can be resource heavy -
     * we set a minimum delay to wait before doing the corresponding request.
     * @type {Number}
     */
    FAILED_PARTIAL_UPDATE_MANIFEST_REFRESH_DELAY: 3e3,
    /**
     * DASH Manifest based on a SegmentTimeline should normally have an
     * MPD@minimumUpdatePeriod attribute which should be sufficient to
     * know when to refresh it.
     * However, there is a specific case, for when it is equal to 0.
     * As of DASH-IF IOP (valid in v4.3), when a DASH's MPD set a
     * MPD@minimumUpdatePeriod to `0`, a client should not refresh the MPD
     * unless told to do so through inband events, in the stream.
     * In reality however, we found it to not always be the case (even with
     * DASH-IF own streams) and moreover to not always be the best thing to do.
     * We prefer to refresh in average at a regular interval when we do not have
     * this information.
     * /!\ This value is expressed in seconds.
     */
    DASH_FALLBACK_LIFETIME_WHEN_MINIMUM_UPDATE_PERIOD_EQUAL_0: 3,
    /**
     * Default value for the maximum number of simultaneous MediaKeySessions that
     * will be kept in a cache (linked to the MediaKeys instance) to avoid doing
     * superfluous license requests.
     *
     * If this number is reached, any new session creation will close the oldest
     * one.
     * Another value can be configured through the API, in which case this default
     * will be overwritten.
     * @type {Number}
     */
    EME_DEFAULT_MAX_SIMULTANEOUS_MEDIA_KEY_SESSIONS: 15,
    /**
     * When playing contents with a persistent license, we will usually store some
     * information related to that MediaKeySession, to be able to play it at a
     * later time.
     *
     * Those information are removed once a MediaKeySession is not considered
     * as "usable" anymore. But to know that, the RxPlayer has to load it.
     *
     * But the RxPlayer does not re-load every persisted MediaKeySession every
     * time to check each one of them one by one, as this would not be a
     * performant thing to do.
     *
     * So this is only done when and if the corresponding content is encountered
     * again and only if it contains the same initialization data.
     *
     * We have to consider that those "information" contain binary data which can
     * be of arbitrary length. Size taken by an array of them can relatively
     * rapidly take a lot of space in JS memory.
     *
     * So to avoid this storage to take too much space (would it be in the chosen
     * browser's storage or in JS memory), we now set a higher bound for the
     * amount of MediaKeySession information that can be stored at the same time.
     *
     * I set the value of 1000 here, as it seems big enough to not be considered a
     * problem (though it can become one, when contents have a lot of keys per
     * content), and still low enough so it should not cause much problem (my
     * method to choose that number was to work with power of 10s and choosing the
     * amount which seemed the most sensible one).
     *
     * This wasn't battle-tested however.
     */
    EME_MAX_STORED_PERSISTENT_SESSION_INFORMATION: 1e3,
    /**
     * After loading a persistent MediaKeySession, the RxPlayer needs to ensure
     * that its keys still allow to decrypt a content.
     *
     * However on some browsers, the `keyStatuses` property that we used to check
     * the keys' satuses linked to that session can be empty for some time after
     * the loading operation is done.
     *
     * This value allows to configure a delay in milliseconds that will be the
     * maximum time we will wait after a persistent session is loaded.
     * If after that time, the `keyStatuses` property is still empty, we will
     * consider that session as not usable.
     */
    EME_WAITING_DELAY_LOADED_SESSION_EMPTY_KEYSTATUSES: 100,
    /**
     * The player relies on browser events and properties to update its status to
     * "ENDED".
     *
     * Sadly in some cases, like in Chrome 54, this event is never triggered on
     * some contents probably due to a browser bug.
     *
     * This threshold resolves this issue by forcing the status to "ENDED" when:
     *   1. the player is stalling
     *   2. the absolute difference between current playback time and duration is
     *      under this value
     *
     * If set to null, this workaround is disabled and the player only relies on
     * browser events.
     *
     * @type {Number|null}
     */
    FORCED_ENDED_THRESHOLD: 8e-4,
    /**
     * Maximum duration from the current position we will let in the buffer when
     * switching an Adaptation/Representations of a given type.
     *
     * For example, if we have ``text: { before: 1, after: 4 }``, it means that
     * when switching subtitles, we will let 1 second before and 4 second after
     * the current position in the previous language (until the new segments
     * overwrite it).
     * This is to allow smooth transitions and avoid de-synchronization that
     * can happen when removing the content being decoded.
     * @type {Object}
     */
    ADAP_REP_SWITCH_BUFFER_PADDINGS: {
      video: { before: 5, after: 5 },
      audio: { before: 2, after: 2.5 },
      text: { before: 0, after: 0 }
      // not managed natively, so no problem here
    },
    /**
     * Interval, in milliseconds, at which we should manually flush
     * SourceBuffers.
     * Some browsers (happened with firefox 66) sometimes "forget" to send us
     * `update` or `updateend` events.
     * In that case, we're completely unable to continue the queue here and
     * stay locked in a waiting state.
     * This interval is here to check at regular intervals if the underlying
     * SourceBuffer is currently updating.
     * @type {Number}
     */
    SOURCE_BUFFER_FLUSHING_INTERVAL: 500,
    /**
     * Any already-pushed segment starting before or at the current position +
     * CONTENT_REPLACEMENT_PADDING won't be replaced by new segments.
     *
     * This allows to avoid overwriting segments that are currently being decoded
     * as we encountered many decoding issues when doing so.
     * @type {Number} - in seconds
     */
    CONTENT_REPLACEMENT_PADDING: 1.2,
    /**
     * For video and audio segments, determines two thresholds below which :
     * - The segment is considered as loaded from cache
     * - The segment may be loaded from cache depending on the previous request
     */
    CACHE_LOAD_DURATION_THRESHOLDS: {
      video: 50,
      audio: 10
    },
    /** Interval we will use to poll for checking if an event shall be emitted */
    STREAM_EVENT_EMITTER_POLL_INTERVAL: 250,
    /**
     * In Javascript, numbers are encoded in a way that a floating number may be
     * represented internally with a rounding error. When multiplying times in
     * seconds by the timescale, we've encoutered cases were the rounding error
     * was amplified by a factor which is about the timescale.
     * Example :
     * (192797480.641122).toFixed(20) = 192797480.64112201333045959473
     * (error is 0.0000000133...)
     * 192797480.641122 * 10000000 = 1927974806411220.2 (error is 0.2)
     * 192797480.641122 * 10000000 * 4 = 7711899225644881 (error is 1)
     * The error is much more significant here, once the timescale has been
     * applied.
     * Thus, we consider that our max tolerable rounding error is 1ms.
     * It is much more than max rounding errors when seen into practice,
     * and not significant from the media loss perspective.
     */
    DEFAULT_MAXIMUM_TIME_ROUNDING_ERROR: 1 / 1e3,
    /**
     * RxPlayer's media buffers have a linked history registering recent events
     * that happened on those.
     * The reason is to implement various heuristics in case of weird browser
     * behavior.
     *
     * The `BUFFERED_HISTORY_RETENTION_TIME` is the minimum age an entry of
     * that history can have before being removed from the history.
     */
    BUFFERED_HISTORY_RETENTION_TIME: 6e4,
    /**
     * RxPlayer's media buffers have a linked history registering recent events
     * that happened on those.
     * The reason is to implement various heuristics in case of weird browser
     * behavior.
     *
     * The `BUFFERED_HISTORY_RETENTION_TIME` is the maximum number of entries
     * there can be in that history.
     */
    BUFFERED_HISTORY_MAXIMUM_ENTRIES: 200,
    /**
     * Minimum buffer in seconds ahead relative to current time
     * we should be able to download, even in cases of saturated memory.
     */
    MIN_BUFFER_AHEAD: 5,
    /**
     * Distance in seconds behind the current position
     * the player will free up to in the case we agressively free up memory
     * It is set to avoid playback issues
     */
    UPTO_CURRENT_POSITION_CLEANUP: 5,
    /**
     * Default "switching mode" used when locking video Representations.
     * That is, which behavior the RxPlayer should have by default when
     * explicitely and manually switching from a previous set of video
     * Representations to a new one.
     */
    DEFAULT_VIDEO_REPRESENTATIONS_SWITCHING_MODE: "seamless",
    /**
     * Default "switching mode" used when locking audio Representations.
     * That is, which behavior the RxPlayer should have by default when
     * explicitely and manually switching from a previous set of audio
     * Representations to a new one.
     */
    DEFAULT_AUDIO_REPRESENTATIONS_SWITCHING_MODE: "seamless",
    /**
     * Default "switching mode" used when switching between video tracks.
     * That is, which behavior the RxPlayer should have by default when
     * explicitely and manually switching from a previous video track to a new
     * one.
     */
    DEFAULT_VIDEO_TRACK_SWITCHING_MODE: "reload",
    /**
     * Default "switching mode" used when switching between audio tracks.
     * That is, which behavior the RxPlayer should have by default when
     * explicitely and manually switching from a previous audio track to a new
     * one.
     */
    DEFAULT_AUDIO_TRACK_SWITCHING_MODE: "seamless",
    /**
     * The default number of times a thumbnail request will be re-performed when
     * on error which justify a retry.
     *
     * Note that some errors do not use this counter:
     *   - if the error is not due to the xhr, no retry will be peformed
     *   - if the error is an HTTP error code, but not a 500-smthg or a 404, no
     *     retry will be performed.
     * @type Number
     */
    DEFAULT_MAX_THUMBNAIL_REQUESTS_RETRY_ON_ERROR: 1,
    /**
     * Default time interval after which a thumbnail request will timeout, in ms.
     * @type {Number}
     */
    DEFAULT_THUMBNAIL_REQUEST_TIMEOUT: 10 * 1e3,
    /**
     * Default connection time after which a thumbnail request conncection will
     * timeout, in ms.
     * @type {Number}
     */
    DEFAULT_THUMBNAIL_CONNECTION_TIMEOUT: 7 * 1e3
  };
  var default_config_default = DEFAULT_CONFIG;

  // src/utils/deep_merge.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/utils/object_assign.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function objectAssign(target, ...sources) {
    if (target === null || target === void 0) {
      throw new TypeError("Cannot convert undefined or null to object");
    }
    const to = Object(target);
    for (const source of sources) {
      for (const key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          to[key] = source[key];
        }
      }
    }
    return to;
  }
  var object_assign_default = typeof Object.assign === "function" ? (
    // eslint-disable-next-line no-restricted-properties
    Object.assign
  ) : (
    // eslint-disable-next-line  @typescript-eslint/unbound-method
    objectAssign
  );

  // src/utils/deep_merge.ts
  function isObject(item) {
    return item !== null && item !== void 0 && !Array.isArray(item) && typeof item === "object";
  }
  function deepMerge(target, ...sources) {
    if (sources.length === 0) {
      return target;
    }
    const source = sources.shift();
    if (isObject(target) && isObject(source)) {
      for (const key in source) {
        if (isObject(source[key])) {
          let newTarget = target[key];
          if (newTarget === void 0) {
            newTarget = {};
            target[key] = newTarget;
          }
          deepMerge(newTarget, source[key]);
        } else {
          object_assign_default(target, { [key]: source[key] });
        }
      }
    }
    return deepMerge(target, ...sources);
  }

  // src/config.ts
  var ConfigHandler = class {
    constructor() {
      this._config = default_config_default;
    }
    update(config) {
      const newConfig = deepMerge(this._config, config);
      this._config = newConfig;
    }
    getCurrent() {
      return this._config;
    }
  };
  var configHandler = new ConfigHandler();
  var config_default = configHandler;

  // src/utils/is_non_empty_string.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function isNonEmptyString(x) {
    return typeof x === "string" && x.length > 0;
  }

  // src/compat/event_listeners.ts
  var BROWSER_PREFIXES = ["", "webkit", "moz", "ms"];
  function isEventSupported(element, eventNameSuffix) {
    const clone = document.createElement(element.tagName);
    const eventName = "on" + eventNameSuffix;
    if (eventName in clone) {
      return true;
    } else {
      clone.setAttribute(eventName, "return;");
      return typeof clone[eventName] === "function";
    }
  }
  function findSupportedEvent(element, eventNames) {
    return eventNames.filter((name2) => isEventSupported(element, name2))[0];
  }
  function eventPrefixed(eventNames, prefixes) {
    return eventNames.reduce(
      (parent, name2) => parent.concat(
        (prefixes === void 0 ? BROWSER_PREFIXES : prefixes).map((p) => p + name2)
      ),
      []
    );
  }
  function createCompatibleEventListener(eventNames, prefixes) {
    let mem;
    const prefixedEvents = eventPrefixed(eventNames, prefixes);
    return (element, listener, cancelSignal) => {
      if (cancelSignal.isCancelled()) {
        return;
      }
      if (typeof HTMLElement !== "undefined" && element instanceof HTMLElement) {
        if (typeof mem === "undefined") {
          mem = findSupportedEvent(element, prefixedEvents);
        }
        if (isNonEmptyString(mem)) {
          element.addEventListener(mem, listener);
          cancelSignal.register(() => {
            if (mem !== void 0) {
              element.removeEventListener(mem, listener);
            }
          });
        } else {
          if (define_ENVIRONMENT_default.CURRENT_ENV === define_ENVIRONMENT_default.DEV) {
            log_default.warn(
              `compat: element ${element.tagName} does not support any of these events: ` + prefixedEvents.join(", ")
            );
          }
          return;
        }
      }
      prefixedEvents.forEach((eventName) => {
        let hasSetOnFn = false;
        if (typeof element.addEventListener === "function") {
          element.addEventListener(eventName, listener);
        } else {
          hasSetOnFn = true;
          element["on" + eventName] = listener;
        }
        cancelSignal.register(() => {
          if (typeof element.removeEventListener === "function") {
            element.removeEventListener(eventName, listener);
          }
          if (hasSetOnFn) {
            delete element["on" + eventName];
          }
        });
      });
    };
  }
  function getDocumentVisibilityRef(stopListening) {
    let prefix;
    const doc = document;
    if (!isNullOrUndefined(doc.hidden)) {
      prefix = "";
    } else if (!isNullOrUndefined(doc.mozHidden)) {
      prefix = "moz";
    } else if (!isNullOrUndefined(doc.msHidden)) {
      prefix = "ms";
    } else if (!isNullOrUndefined(doc.webkitHidden)) {
      prefix = "webkit";
    }
    const hidden = isNonEmptyString(prefix) ? prefix + "Hidden" : "hidden";
    const visibilityChangeEvent = isNonEmptyString(prefix) ? prefix + "visibilitychange" : "visibilitychange";
    const isHidden = document[hidden];
    const ref = new reference_default(!isHidden, stopListening);
    addEventListener(
      document,
      visibilityChangeEvent,
      () => {
        const isVisible = !document[hidden];
        ref.setValueIfChanged(isVisible);
      },
      stopListening
    );
    return ref;
  }
  function getPictureOnPictureStateRef(mediaElement, stopListening) {
    if (mediaElement.webkitSupportsPresentationMode === true && typeof mediaElement.webkitSetPresentationMode === "function") {
      const isWebKitPIPEnabled = mediaElement.webkitPresentationMode === "picture-in-picture";
      const ref2 = new reference_default(
        {
          isEnabled: isWebKitPIPEnabled,
          pipWindow: null
        },
        stopListening
      );
      addEventListener(
        mediaElement,
        "webkitpresentationmodechanged",
        () => {
          const isEnabled = mediaElement.webkitPresentationMode === "picture-in-picture";
          ref2.setValue({ isEnabled, pipWindow: null });
        },
        stopListening
      );
      return ref2;
    }
    const isPIPEnabled = document.pictureInPictureElement === mediaElement;
    const ref = new reference_default(
      { isEnabled: isPIPEnabled, pipWindow: null },
      stopListening
    );
    addEventListener(
      mediaElement,
      "enterpictureinpicture",
      (evt) => {
        var _a;
        ref.setValue({
          isEnabled: true,
          pipWindow: (_a = evt.pictureInPictureWindow) != null ? _a : null
        });
      },
      stopListening
    );
    addEventListener(
      mediaElement,
      "leavepictureinpicture",
      () => {
        ref.setValue({ isEnabled: false, pipWindow: null });
      },
      stopListening
    );
    return ref;
  }
  function getVideoVisibilityRef(pipStatus, stopListening) {
    const isDocVisibleRef = getDocumentVisibilityRef(stopListening);
    let currentTimeout;
    const ref = new reference_default(true, stopListening);
    stopListening.register(() => {
      clearTimeout(currentTimeout);
      currentTimeout = void 0;
    });
    isDocVisibleRef.onUpdate(checkCurrentVisibility, {
      clearSignal: stopListening
    });
    pipStatus.onUpdate(checkCurrentVisibility, { clearSignal: stopListening });
    checkCurrentVisibility();
    return ref;
    function checkCurrentVisibility() {
      clearTimeout(currentTimeout);
      currentTimeout = void 0;
      if (pipStatus.getValue().isEnabled || isDocVisibleRef.getValue()) {
        ref.setValueIfChanged(true);
      } else {
        const { INACTIVITY_DELAY } = config_default.getCurrent();
        currentTimeout = setTimeout(() => {
          ref.setValueIfChanged(false);
        }, INACTIVITY_DELAY);
      }
    }
  }
  function getScreenResolutionRef(stopListening) {
    var _a, _b;
    const pixelRatio = isNullOrUndefined(global_scope_default.devicePixelRatio) || global_scope_default.devicePixelRatio === 0 ? 1 : global_scope_default.devicePixelRatio;
    const ref = new reference_default(
      {
        width: (_a = global_scope_default.screen) == null ? void 0 : _a.width,
        height: (_b = global_scope_default.screen) == null ? void 0 : _b.height,
        pixelRatio
      },
      stopListening
    );
    const interval = setInterval(checkScreenResolution, 2e4);
    stopListening.register(function stopUpdating() {
      clearInterval(interval);
    });
    return ref;
    function checkScreenResolution() {
      const oldVal = ref.getValue();
      if (oldVal.width !== screen.width || oldVal.height !== screen.height || oldVal.pixelRatio !== pixelRatio) {
        ref.setValue({ width: screen.width, height: screen.height, pixelRatio });
      }
    }
  }
  function getElementResolutionRef(mediaElement, pipStatusRef, stopListening) {
    const pixelRatio = isNullOrUndefined(global_scope_default.devicePixelRatio) || global_scope_default.devicePixelRatio === 0 ? 1 : global_scope_default.devicePixelRatio;
    const ref = new reference_default(
      {
        width: mediaElement.clientWidth,
        height: mediaElement.clientHeight,
        pixelRatio
      },
      stopListening
    );
    let clearPreviousEventListener = noop_default;
    pipStatusRef.onUpdate(checkElementResolution, { clearSignal: stopListening });
    addEventListener(global_scope_default, "resize", checkElementResolution, stopListening);
    addEventListener(
      mediaElement,
      "enterpictureinpicture",
      checkElementResolution,
      stopListening
    );
    addEventListener(
      mediaElement,
      "leavepictureinpicture",
      checkElementResolution,
      stopListening
    );
    const interval = setInterval(checkElementResolution, 2e4);
    checkElementResolution();
    stopListening.register(function stopUpdating() {
      clearPreviousEventListener();
      clearInterval(interval);
    });
    return ref;
    function checkElementResolution() {
      clearPreviousEventListener();
      const pipStatus = pipStatusRef.getValue();
      const { pipWindow } = pipStatus;
      if (!pipStatus.isEnabled) {
        const oldVal = ref.getValue();
        if (oldVal.width !== mediaElement.clientWidth || oldVal.height !== mediaElement.clientHeight || oldVal.pixelRatio !== pixelRatio) {
          ref.setValue({
            width: mediaElement.clientWidth,
            height: mediaElement.clientHeight,
            pixelRatio
          });
        }
      } else if (!isNullOrUndefined(pipWindow)) {
        const onPipResize = () => {
          updateToPipWindowResolution();
        };
        pipWindow.addEventListener("resize", onPipResize);
        clearPreviousEventListener = () => {
          pipWindow.removeEventListener("resize", onPipResize);
          clearPreviousEventListener = noop_default;
        };
        updateToPipWindowResolution();
      } else {
        const oldVal = ref.getValue();
        if (oldVal.width !== void 0 || oldVal.height !== void 0 || oldVal.pixelRatio !== pixelRatio) {
          ref.setValue({ width: void 0, height: void 0, pixelRatio });
        }
      }
      function updateToPipWindowResolution() {
        const oldVal = ref.getValue();
        if (oldVal.width !== (pipWindow == null ? void 0 : pipWindow.width) || oldVal.height !== (pipWindow == null ? void 0 : pipWindow.height) || oldVal.pixelRatio !== pixelRatio) {
          ref.setValue({
            width: pipWindow == null ? void 0 : pipWindow.width,
            height: pipWindow == null ? void 0 : pipWindow.height,
            pixelRatio
          });
        }
      }
    }
  }
  var onLoadedMetadata = createCompatibleEventListener(["loadedmetadata"]);
  var onTimeUpdate = createCompatibleEventListener(["timeupdate"]);
  var onTextTrackAdded = createCompatibleEventListener(["addtrack"]);
  var onTextTrackRemoved = createCompatibleEventListener(["removetrack"]);
  var onSourceOpen = createCompatibleEventListener(["sourceopen", "webkitsourceopen"]);
  var onSourceClose = createCompatibleEventListener(["sourceclose", "webkitsourceclose"]);
  var onSourceEnded = createCompatibleEventListener(["sourceended", "webkitsourceended"]);
  var onSourceBufferUpdate = createCompatibleEventListener(["update"]);
  var onRemoveSourceBuffers = createCompatibleEventListener(["removesourcebuffer"]);
  var onKeyMessage = createCompatibleEventListener(["keymessage", "message"]);
  var onKeyAdded = createCompatibleEventListener(["keyadded", "ready"]);
  var onKeyError = createCompatibleEventListener(["keyerror", "error"]);
  var onKeyStatusesChange = createCompatibleEventListener(["keystatuseschange"]);
  var onSeeking = createCompatibleEventListener(["seeking"]);
  var onSeeked = createCompatibleEventListener(["seeked"]);
  var onEnded = createCompatibleEventListener(["ended"]);
  function addEventListener(elt, evt, listener, stopListening) {
    elt.addEventListener(evt, listener);
    stopListening.register(() => {
      elt.removeEventListener(evt, listener);
    });
  }

  // src/compat/get_start_date.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function getStartDate(mediaElement) {
    const _mediaElement = mediaElement;
    if (typeof _mediaElement.getStartDate === "function") {
      const startDate = _mediaElement.getStartDate();
      if (typeof startDate === "object" && startDate !== null) {
        const startDateNum = +startDate;
        if (!isNaN(startDateNum)) {
          return startDateNum / 1e3;
        }
      } else if (typeof startDate === "number" && !isNaN(startDate)) {
        return startDate;
      }
    }
  }

  // src/compat/has_mse_in_worker.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var hasMseInWorker = typeof MediaSource === "function" && // eslint-disable-next-line
  MediaSource.canConstructInDedicatedWorker === true;
  var has_mse_in_worker_default = hasMseInWorker;

  // src/compat/has_worker_api.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function hasWorkerApi() {
    return isPlayStation4 ? typeof Worker === "object" || typeof Worker === "function" : typeof Worker === "function";
  }

  // src/errors/index.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/errors/custom_loader_error.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var CustomLoaderError = class _CustomLoaderError extends Error {
    /**
     * @param {string} message
     * @param {boolean} canRetry
     * @param {XMLHttpRequest} xhr
     */
    constructor(message, canRetry, xhr) {
      super(message);
      Object.setPrototypeOf(this, _CustomLoaderError.prototype);
      this.name = "CustomLoaderError";
      this.canRetry = canRetry;
      this.xhr = xhr;
    }
  };

  // src/errors/encrypted_media_error.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/errors/error_codes.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/utils/request/index.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/utils/request/fetch.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/utils/request/request_error.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var RequestError = class _RequestError extends Error {
    /**
     * @param {string} url
     * @param {number} status
     * @param {string} type
     */
    constructor(url, status, type) {
      let message;
      switch (type) {
        case "TIMEOUT":
          message = "The request timed out";
          break;
        case "ERROR_EVENT":
          message = "An error prevented the request to be performed successfully";
          break;
        case "PARSE_ERROR":
          message = "An error happened while formatting the response data";
          break;
        case "ERROR_HTTP_CODE":
          message = "An HTTP status code indicating failure was received: " + String(status);
          break;
      }
      super(message);
      Object.setPrototypeOf(this, _RequestError.prototype);
      this.name = "RequestError";
      this.url = url;
      this.status = status;
      this.type = type;
    }
    serialize() {
      return { url: this.url, status: this.status, type: this.type };
    }
  };
  var RequestErrorTypes = {
    TIMEOUT: "TIMEOUT",
    ERROR_EVENT: "ERROR_EVENT",
    ERROR_HTTP_CODE: "ERROR_HTTP_CODE",
    PARSE_ERROR: "PARSE_ERROR"
  };

  // src/utils/request/fetch.ts
  var _Headers = typeof Headers === "function" ? Headers : null;
  var _AbortController = typeof AbortController === "function" ? AbortController : null;
  function fetchRequest(options) {
    var _a, _b;
    let headers;
    if (!isNullOrUndefined(options.headers)) {
      if (isNullOrUndefined(_Headers)) {
        headers = options.headers;
      } else {
        headers = new _Headers();
        const headerNames = Object.keys(options.headers);
        for (let i = 0; i < headerNames.length; i++) {
          const headerName = headerNames[i];
          headers.append(headerName, options.headers[headerName]);
        }
      }
    }
    log_default.debug("Fetch: Called with URL", options.url);
    let cancellation = null;
    let isTimedOut = false;
    let isConnectionTimedOut = false;
    const sendingTime = monotonic_timestamp_default();
    const abortController = !isNullOrUndefined(_AbortController) ? new _AbortController() : null;
    function abortFetch() {
      if (isNullOrUndefined(abortController)) {
        log_default.warn("Fetch: AbortController API not available.");
        return;
      }
      abortController.abort();
    }
    let timeoutId;
    if (options.timeout !== void 0) {
      timeoutId = setTimeout(() => {
        isTimedOut = true;
        if (connectionTimeoutId !== void 0) {
          clearTimeout(connectionTimeoutId);
        }
        abortFetch();
      }, options.timeout);
    }
    let connectionTimeoutId;
    if (options.connectionTimeout !== void 0) {
      connectionTimeoutId = setTimeout(() => {
        isConnectionTimedOut = true;
        if (timeoutId !== void 0) {
          clearTimeout(timeoutId);
        }
        abortFetch();
      }, options.connectionTimeout);
    }
    const deregisterCancelLstnr = options.cancelSignal.register(function abortRequest(err) {
      cancellation = err;
      abortFetch();
    });
    const fetchOpts = { method: "GET" };
    if (headers !== void 0) {
      fetchOpts.headers = headers;
    }
    fetchOpts.signal = !isNullOrUndefined(abortController) ? abortController.signal : null;
    if (log_default.hasLevel("DEBUG")) {
      let logLine = "FETCH: Sending GET " + options.url;
      if (options.timeout !== void 0) {
        logLine += " to=" + String(options.timeout / 1e3);
      }
      if (options.connectionTimeout !== void 0) {
        logLine += " cto=" + String(options.connectionTimeout / 1e3);
      }
      if (((_a = options.headers) == null ? void 0 : _a.Range) !== void 0) {
        logLine += " Range=" + ((_b = options.headers) == null ? void 0 : _b.Range);
      }
      log_default.debug(logLine);
    }
    return fetch(options.url, fetchOpts).then((response) => {
      if (connectionTimeoutId !== void 0) {
        clearTimeout(connectionTimeoutId);
      }
      if (response.status >= 300) {
        log_default.warn("Fetch: Request HTTP Error", response.status, response.url);
        throw new RequestError(
          response.url,
          response.status,
          RequestErrorTypes.ERROR_HTTP_CODE
        );
      }
      if (isNullOrUndefined(response.body)) {
        throw new RequestError(
          response.url,
          response.status,
          RequestErrorTypes.PARSE_ERROR
        );
      }
      const contentLengthHeader = response.headers.get("Content-Length");
      const contentLength = !isNullOrUndefined(contentLengthHeader) && !isNaN(+contentLengthHeader) ? +contentLengthHeader : void 0;
      const reader = response.body.getReader();
      let size = 0;
      return readBufferAndSendEvents();
      async function readBufferAndSendEvents() {
        const data2 = await reader.read();
        if (!data2.done && !isNullOrUndefined(data2.value)) {
          size += data2.value.byteLength;
          const currentTime = monotonic_timestamp_default();
          const dataInfo = {
            url: response.url,
            currentTime,
            duration: currentTime - sendingTime,
            sendingTime,
            chunkSize: data2.value.byteLength,
            chunk: data2.value.buffer,
            size,
            totalSize: contentLength
          };
          options.onData(dataInfo);
          return readBufferAndSendEvents();
        } else if (data2.done) {
          if (timeoutId !== void 0) {
            clearTimeout(timeoutId);
          }
          deregisterCancelLstnr();
          const receivedTime = monotonic_timestamp_default();
          const requestDuration = receivedTime - sendingTime;
          return {
            requestDuration,
            receivedTime,
            sendingTime,
            size,
            status: response.status,
            url: response.url
          };
        }
        return readBufferAndSendEvents();
      }
    }).catch((err) => {
      if (cancellation !== null) {
        throw cancellation;
      }
      deregisterCancelLstnr();
      if (isTimedOut) {
        log_default.warn("Fetch: Request timed out.");
        throw new RequestError(options.url, 0, RequestErrorTypes.TIMEOUT);
      } else if (isConnectionTimedOut) {
        log_default.warn("Fetch: Request connection timed out.");
        throw new RequestError(options.url, 0, RequestErrorTypes.TIMEOUT);
      } else if (err instanceof RequestError) {
        throw err;
      }
      log_default.warn("Fetch: Request Error", err instanceof Error ? err.toString() : "");
      throw new RequestError(options.url, 0, RequestErrorTypes.ERROR_EVENT);
    });
  }
  function fetchIsSupported() {
    return typeof global_scope_default.fetch === "function" && !isNullOrUndefined(_AbortController) && !isNullOrUndefined(_Headers);
  }

  // src/utils/request/xhr.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var DEFAULT_RESPONSE_TYPE = "json";
  function request(options) {
    const requestOptions = {
      url: options.url,
      headers: options.headers,
      responseType: isNullOrUndefined(options.responseType) ? DEFAULT_RESPONSE_TYPE : options.responseType,
      timeout: options.timeout,
      connectionTimeout: options.connectionTimeout
    };
    return new Promise((resolve, reject) => {
      const { onProgress, cancelSignal } = options;
      const { url, headers, responseType, timeout, connectionTimeout } = requestOptions;
      const xhr = new XMLHttpRequest();
      xhr.open("GET", url, true);
      let timeoutId;
      if (timeout !== void 0) {
        xhr.timeout = timeout;
        timeoutId = setTimeout(() => {
          clearCancellingProcess();
          reject(new RequestError(url, xhr.status, RequestErrorTypes.TIMEOUT));
        }, timeout + 3e3);
      }
      let connectionTimeoutId;
      if (connectionTimeout !== void 0) {
        connectionTimeoutId = setTimeout(() => {
          clearCancellingProcess();
          if (xhr.readyState !== XMLHttpRequest.DONE) {
            xhr.abort();
          }
          reject(new RequestError(url, xhr.status, RequestErrorTypes.TIMEOUT));
        }, connectionTimeout);
      }
      xhr.responseType = responseType;
      if (xhr.responseType === "document") {
        xhr.overrideMimeType("text/xml");
      }
      if (!isNullOrUndefined(headers)) {
        const _headers = headers;
        for (const key in _headers) {
          if (_headers.hasOwnProperty(key)) {
            xhr.setRequestHeader(key, _headers[key]);
          }
        }
      }
      const sendingTime = monotonic_timestamp_default();
      let deregisterCancellationListener = null;
      if (cancelSignal !== void 0) {
        deregisterCancellationListener = cancelSignal.register(function abortRequest(err) {
          clearCancellingProcess();
          if (xhr.readyState !== XMLHttpRequest.DONE) {
            xhr.abort();
          }
          reject(err);
        });
        if (cancelSignal.isCancelled()) {
          return;
        }
      }
      xhr.onerror = function onXHRError() {
        clearCancellingProcess();
        reject(new RequestError(url, xhr.status, RequestErrorTypes.ERROR_EVENT));
      };
      xhr.ontimeout = function onXHRTimeout() {
        clearCancellingProcess();
        reject(new RequestError(url, xhr.status, RequestErrorTypes.TIMEOUT));
      };
      if (connectionTimeout !== void 0) {
        xhr.onreadystatechange = function clearConnectionTimeout() {
          if (xhr.readyState >= XMLHttpRequest.HEADERS_RECEIVED) {
            clearTimeout(connectionTimeoutId);
          }
        };
      }
      if (onProgress !== void 0) {
        xhr.onprogress = function onXHRProgress(event) {
          const currentTime = monotonic_timestamp_default();
          onProgress({
            url,
            duration: currentTime - sendingTime,
            sendingTime,
            currentTime,
            size: event.loaded,
            totalSize: event.total
          });
        };
      }
      xhr.onload = function onXHRLoad(event) {
        if (xhr.readyState === XMLHttpRequest.DONE) {
          clearCancellingProcess();
          if (xhr.status >= 200 && xhr.status < 300) {
            const receivedTime = monotonic_timestamp_default();
            const totalSize = xhr.response instanceof ArrayBuffer ? xhr.response.byteLength : event.total;
            const status = xhr.status;
            const loadedResponseType = xhr.responseType;
            const _url = isNonEmptyString(xhr.responseURL) ? xhr.responseURL : url;
            let responseData;
            if (loadedResponseType === "json") {
              responseData = typeof xhr.response === "object" ? xhr.response : toJSONForIE(xhr.responseText);
            } else {
              responseData = xhr.response;
            }
            if (isNullOrUndefined(responseData)) {
              reject(new RequestError(url, xhr.status, RequestErrorTypes.PARSE_ERROR));
              return;
            }
            resolve({
              status,
              url: _url,
              responseType: loadedResponseType,
              sendingTime,
              receivedTime,
              requestDuration: receivedTime - sendingTime,
              size: totalSize,
              responseData
            });
          } else {
            reject(new RequestError(url, xhr.status, RequestErrorTypes.ERROR_HTTP_CODE));
          }
        }
      };
      if (log_default.hasLevel("DEBUG")) {
        let logLine = "XHR: Sending GET " + url;
        if (options.responseType !== void 0) {
          logLine += " type=" + options.responseType;
        }
        if (timeout !== void 0) {
          logLine += " to=" + String(timeout / 1e3);
        }
        if (connectionTimeout !== void 0) {
          logLine += " cto=" + String(connectionTimeout / 1e3);
        }
        if ((headers == null ? void 0 : headers.Range) !== void 0) {
          logLine += " Range=" + (headers == null ? void 0 : headers.Range);
        }
        log_default.debug(logLine);
      }
      xhr.send();
      function clearCancellingProcess() {
        if (timeoutId !== void 0) {
          clearTimeout(timeoutId);
        }
        if (connectionTimeoutId !== void 0) {
          clearTimeout(connectionTimeoutId);
        }
        if (deregisterCancellationListener !== null) {
          deregisterCancellationListener();
        }
      }
    });
  }
  function toJSONForIE(data2) {
    try {
      return JSON.parse(data2);
    } catch (_e) {
      return null;
    }
  }

  // src/utils/request/index.ts
  var request_default = request;

  // src/errors/error_codes.ts
  var NetworkErrorTypes = RequestErrorTypes;
  var ErrorTypes = {
    NETWORK_ERROR: "NETWORK_ERROR",
    MEDIA_ERROR: "MEDIA_ERROR",
    ENCRYPTED_MEDIA_ERROR: "ENCRYPTED_MEDIA_ERROR",
    OTHER_ERROR: "OTHER_ERROR"
  };
  var ErrorCodes = {
    PIPELINE_LOAD_ERROR: "PIPELINE_LOAD_ERROR",
    PIPELINE_PARSE_ERROR: "PIPELINE_PARSE_ERROR",
    INTEGRITY_ERROR: "INTEGRITY_ERROR",
    MANIFEST_PARSE_ERROR: "MANIFEST_PARSE_ERROR",
    MANIFEST_INCOMPATIBLE_CODECS_ERROR: "MANIFEST_INCOMPATIBLE_CODECS_ERROR",
    MANIFEST_UPDATE_ERROR: "MANIFEST_UPDATE_ERROR",
    MANIFEST_UNSUPPORTED_ADAPTATION_TYPE: "MANIFEST_UNSUPPORTED_ADAPTATION_TYPE",
    MEDIA_STARTING_TIME_NOT_FOUND: "MEDIA_STARTING_TIME_NOT_FOUND",
    MEDIA_TIME_BEFORE_MANIFEST: "MEDIA_TIME_BEFORE_MANIFEST",
    MEDIA_TIME_AFTER_MANIFEST: "MEDIA_TIME_AFTER_MANIFEST",
    MEDIA_TIME_NOT_FOUND: "MEDIA_TIME_NOT_FOUND",
    NO_PLAYABLE_REPRESENTATION: "NO_PLAYABLE_REPRESENTATION",
    MEDIA_IS_ENCRYPTED_ERROR: "MEDIA_IS_ENCRYPTED_ERROR",
    CREATE_MEDIA_KEYS_ERROR: "CREATE_MEDIA_KEYS_ERROR",
    MEDIA_KEYS_ATTACHMENT_ERROR: "MEDIA_KEYS_ATTACHMENT_ERROR",
    KEY_ERROR: "KEY_ERROR",
    KEY_STATUS_CHANGE_ERROR: "KEY_STATUS_CHANGE_ERROR",
    KEY_UPDATE_ERROR: "KEY_UPDATE_ERROR",
    KEY_LOAD_ERROR: "KEY_LOAD_ERROR",
    KEY_LOAD_TIMEOUT: "KEY_LOAD_TIMEOUT",
    KEY_GENERATE_REQUEST_ERROR: "KEY_GENERATE_REQUEST_ERROR",
    INCOMPATIBLE_KEYSYSTEMS: "INCOMPATIBLE_KEYSYSTEMS",
    INVALID_ENCRYPTED_EVENT: "INVALID_ENCRYPTED_EVENT",
    INVALID_KEY_SYSTEM: "INVALID_KEY_SYSTEM",
    LICENSE_SERVER_CERTIFICATE_ERROR: "LICENSE_SERVER_CERTIFICATE_ERROR",
    MULTIPLE_SESSIONS_SAME_INIT_DATA: "MULTIPLE_SESSIONS_SAME_INIT_DATA",
    BUFFER_APPEND_ERROR: "BUFFER_APPEND_ERROR",
    BUFFER_FULL_ERROR: "BUFFER_FULL_ERROR",
    BUFFER_TYPE_UNKNOWN: "BUFFER_TYPE_UNKNOWN",
    MEDIA_ERR_BLOCKED_AUTOPLAY: "MEDIA_ERR_BLOCKED_AUTOPLAY",
    MEDIA_ERR_PLAY_NOT_ALLOWED: "MEDIA_ERR_PLAY_NOT_ALLOWED",
    MEDIA_ERR_NOT_LOADED_METADATA: "MEDIA_ERR_NOT_LOADED_METADATA",
    MEDIA_ERR_ABORTED: "MEDIA_ERR_ABORTED",
    MEDIA_ERR_NETWORK: "MEDIA_ERR_NETWORK",
    MEDIA_ERR_DECODE: "MEDIA_ERR_DECODE",
    MEDIA_ERR_SRC_NOT_SUPPORTED: "MEDIA_ERR_SRC_NOT_SUPPORTED",
    MEDIA_ERR_UNKNOWN: "MEDIA_ERR_UNKNOWN",
    MEDIA_SOURCE_NOT_SUPPORTED: "MEDIA_SOURCE_NOT_SUPPORTED",
    MEDIA_KEYS_NOT_SUPPORTED: "MEDIA_KEYS_NOT_SUPPORTED",
    DISCONTINUITY_ENCOUNTERED: "DISCONTINUITY_ENCOUNTERED",
    NONE: "NONE"
  };

  // src/errors/error_message.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function errorMessage(code, reason) {
    return `${code}: ${reason}`;
  }

  // src/errors/encrypted_media_error.ts
  var EncryptedMediaError = class _EncryptedMediaError extends Error {
    constructor(code, reason, supplementaryInfos) {
      super(errorMessage(code, reason));
      Object.setPrototypeOf(this, _EncryptedMediaError.prototype);
      this.name = "EncryptedMediaError";
      this.type = ErrorTypes.ENCRYPTED_MEDIA_ERROR;
      this.code = code;
      this._originalMessage = reason;
      this.fatal = false;
      if (typeof (supplementaryInfos == null ? void 0 : supplementaryInfos.keyStatuses) === "string") {
        this.keyStatuses = supplementaryInfos.keyStatuses;
      }
    }
    /**
     * If that error has to be communicated through another thread, this method
     * allows to obtain its main defining properties in an Object so the Error can
     * be reconstructed in the other thread.
     * @returns {Object}
     */
    serialize() {
      return {
        name: this.name,
        code: this.code,
        reason: this._originalMessage,
        keyStatuses: this.keyStatuses
      };
    }
  };

  // src/errors/format_error.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/errors/is_known_error.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/errors/media_error.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var MediaError = class _MediaError extends Error {
    constructor(code, reason, context) {
      super(errorMessage(code, reason));
      Object.setPrototypeOf(this, _MediaError.prototype);
      this.name = "MediaError";
      this.type = ErrorTypes.MEDIA_ERROR;
      this._originalMessage = reason;
      this.code = code;
      this.fatal = false;
      if ((context == null ? void 0 : context.tracks) !== void 0 && (context == null ? void 0 : context.tracks.length) > 0) {
        this.tracksInfo = context.tracks;
      }
    }
    /**
     * If that error has to be communicated through another thread, this method
     * allows to obtain its main defining properties in an Object so the Error can
     * be reconstructed in the other thread.
     * @returns {Object}
     */
    serialize() {
      return {
        name: this.name,
        code: this.code,
        reason: this._originalMessage,
        tracks: this.tracksInfo
      };
    }
  };

  // src/errors/network_error.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var NetworkError = class _NetworkError extends Error {
    /**
     * @param {string} code
     * @param {Error} baseError
     */
    constructor(code, baseError) {
      super(errorMessage(code, baseError.message));
      Object.setPrototypeOf(this, _NetworkError.prototype);
      this.name = "NetworkError";
      this.type = ErrorTypes.NETWORK_ERROR;
      this.url = baseError.url;
      this.status = baseError.status;
      this.errorType = baseError.type;
      this._baseError = baseError;
      this.code = code;
      this.fatal = false;
    }
    /**
     * Returns true if the NetworkError is due to the given http error code
     * @param {number} httpErrorCode
     * @returns {Boolean}
     */
    isHttpError(httpErrorCode) {
      return this.errorType === NetworkErrorTypes.ERROR_HTTP_CODE && this.status === httpErrorCode;
    }
    /**
     * If that error has to be communicated through another thread, this method
     * allows to obtain its main defining properties in an Object so the Error can
     * be reconstructed in the other thread.
     * @returns {Object}
     */
    serialize() {
      return {
        name: this.name,
        code: this.code,
        baseError: this._baseError.serialize()
      };
    }
  };

  // src/errors/other_error.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var OtherError = class _OtherError extends Error {
    /**
     * @param {string} code
     * @param {string} reason
     */
    constructor(code, reason) {
      super(errorMessage(code, reason));
      Object.setPrototypeOf(this, _OtherError.prototype);
      this.name = "OtherError";
      this.type = ErrorTypes.OTHER_ERROR;
      this.code = code;
      this.fatal = false;
      this._originalMessage = reason;
    }
    /**
     * If that error has to be communicated through another thread, this method
     * allows to obtain its main defining properties in an Object so the Error can
     * be reconstructed in the other thread.
     * @returns {Object}
     */
    serialize() {
      return { name: this.name, code: this.code, reason: this._originalMessage };
    }
  };

  // src/errors/is_known_error.ts
  function isKnownError(error) {
    return (error instanceof EncryptedMediaError || error instanceof MediaError || error instanceof OtherError || error instanceof NetworkError) && Object.keys(ErrorTypes).indexOf(error.type) >= 0;
  }

  // src/errors/format_error.ts
  function formatError(error, {
    defaultCode,
    defaultReason
  }) {
    if (isKnownError(error)) {
      return error;
    }
    const reason = error instanceof Error ? error.toString() : defaultReason;
    return new OtherError(defaultCode, reason);
  }

  // src/errors/source_buffer_error.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var SourceBufferError = class _SourceBufferError extends Error {
    /**
     * @param {string} errorName - The original Error's name.
     * @param {string} message - The original Error's message.
     * @param {boolean} isBufferFull - If `true`, the Error is due to the fact
     * that the `SourceBuffer` was full.
     */
    constructor(errorName, message, isBufferFull) {
      super(message);
      Object.setPrototypeOf(this, _SourceBufferError.prototype);
      this.name = "SourceBufferError";
      this.errorName = errorName;
      this.isBufferFull = isBufferFull;
    }
    /**
     * If that error has to be communicated through another thread, this method
     * allows to obtain its main defining properties in an Object so the Error can
     * be reconstructed in the other thread.
     * @returns {Object}
     */
    serialize() {
      return {
        errorName: this.name,
        message: this.message,
        isBufferFull: this.isBufferFull
      };
    }
    /**
     * When stringified, just try to replicate the original error as it may be
     * more informative.
     * @returns {string}
     */
    toString() {
      return `${this.errorName}: ${this.message}`;
    }
  };

  // src/errors/worker_initialization_error.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var WorkerInitializationError = class _WorkerInitializationError extends Error {
    /**
     * @param {string} code
     * @param {string} message
     */
    constructor(code, message) {
      super(errorMessage(code, message));
      Object.setPrototypeOf(this, _WorkerInitializationError.prototype);
      this.name = "WorkerInitializationError";
      this.type = "WORKER_INITIALIZATION_ERROR";
      this.code = code;
    }
  };

  // src/features/index.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/features/add_features.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/features/features_object.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var features = {
    dashParsers: { wasm: null, native: null, fastJs: null },
    createDebugElement: null,
    directfile: null,
    decrypt: null,
    htmlTextDisplayer: null,
    htmlTextTracksParsers: {},
    mainThreadMediaSourceInit: null,
    multithread: null,
    nativeTextDisplayer: null,
    nativeTextTracksParsers: {},
    transports: {}
  };
  var features_object_default = features;

  // src/features/add_features.ts
  function addFeatures(featureFuncList) {
    for (const addFeature of featureFuncList) {
      if (typeof addFeature === "function") {
        addFeature(features_object_default);
      } else if (!isNullOrUndefined(addFeature) && typeof addFeature._addFeature === "function") {
        addFeature._addFeature(features_object_default);
      } else {
        throw new Error("Unrecognized feature");
      }
    }
  }

  // src/features/index.ts
  var features_default = features_object_default;

  // src/manifest/index.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/manifest/classes/index.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/manifest/classes/adaptation.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/utils/array_find.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function arrayFind(arr, predicate, thisArg) {
    if (typeof Array.prototype.find === "function") {
      return arr.find(predicate, thisArg);
    }
    const len = arr.length >>> 0;
    for (let i = 0; i < len; i++) {
      const val = arr[i];
      if (predicate.call(thisArg, val, i, arr)) {
        return val;
      }
    }
    return void 0;
  }

  // src/utils/languages/index.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/utils/languages/normalize.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/utils/languages/ISO_639-1_to_ISO_639-3.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var ISO_MAP_1_TO_3 = {
    aa: "aar",
    // Afar
    ab: "abk",
    // Abkhazian
    ae: "ave",
    // Avestan
    af: "afr",
    // Afrikaans
    ak: "aka",
    // Akan
    am: "amh",
    // Amharic
    an: "arg",
    // Aragonese
    ar: "ara",
    // Arabic
    as: "asm",
    // Assamese
    av: "ava",
    // Avaric
    ay: "aym",
    // Aymara
    az: "aze",
    // Azerbaijani
    ba: "bak",
    // Bashkir
    be: "bel",
    // Belarusian
    bg: "bul",
    // Bulgarian
    bi: "bis",
    // Bislama
    bm: "bam",
    // Bambara
    bn: "ben",
    // Bengali
    bo: "bod",
    // Tibetan
    br: "bre",
    // Breton
    bs: "bos",
    // Bosnian
    ca: "cat",
    // Catalan, Valencian
    ce: "che",
    // Chechen
    ch: "cha",
    // Chamorro
    co: "cos",
    // Corsican
    cr: "cre",
    // Cree
    cs: "ces",
    // Czech
    cu: "chu",
    // Church Slavic, Church Slavonic, Old Church Slavonic,
    // Old Slavonic, Old Bulgarian
    cv: "chv",
    // Chuvash
    cy: "cym",
    // Welsh
    da: "dan",
    // Danish
    de: "deu",
    // German
    dv: "div",
    // Divehi, Dhivehi, Maldivian
    dz: "dzo",
    // Dzongkha
    ee: "ewe",
    // Ewe
    el: "ell",
    // Greek (modern)
    en: "eng",
    // English
    eo: "epo",
    // Esperanto
    es: "spa",
    // Spanish, Castilian
    et: "est",
    // Estonian
    eu: "eus",
    // Basque
    fa: "fas",
    // Persian
    ff: "ful",
    // Fulah
    fi: "fin",
    // Finnish
    fj: "fij",
    // Fijian
    fo: "fao",
    // Faroese
    fr: "fra",
    // French
    fy: "fry",
    // Western Frisian
    ga: "gle",
    // Irish
    gd: "gla",
    // Gaelic, Scottish Gaelic
    gl: "glg",
    // Galician
    gn: "grn",
    // Guaran
    gu: "guj",
    // Gujarati
    gv: "glv",
    // Manx
    ha: "hau",
    // Hausa
    he: "heb",
    // Hebrew (modern)
    hi: "hin",
    // Hindi
    ho: "hmo",
    // Hiri Motu
    hr: "hrv",
    // Croatian
    ht: "hat",
    // Haitian, Haitian Creole
    hu: "hun",
    // Hungarian
    hy: "hye",
    // Armenian
    hz: "her",
    // Herero
    ia: "ina",
    // Interlingua
    id: "ind",
    // Indonesian
    ie: "ile",
    // Interlingue
    ig: "ibo",
    // Igbo
    ii: "iii",
    // Sichuan Yi, Nuosu
    ik: "ipk",
    // Inupiaq
    io: "ido",
    // Ido
    is: "isl",
    // Icelandic
    it: "ita",
    // Italian
    iu: "iku",
    // Inuktitut
    ja: "jpn",
    // Japanese
    jv: "jav",
    // Javanese
    ka: "kat",
    // Georgian
    kg: "kon",
    // Kongo
    ki: "kik",
    // Kikuyu, Gikuyu
    kj: "kua",
    // Kuanyama, Kwanyama
    kk: "kaz",
    // Kazakh
    kl: "kal",
    // Kalaallisut, Greenlandic
    km: "khm",
    // Central Khmer
    kn: "kan",
    // Kannada
    ko: "kor",
    // Korean
    kr: "kau",
    // Kanuri
    ks: "kas",
    // Kashmiri
    ku: "kur",
    // Kurdish
    kv: "kom",
    // Komi
    kw: "cor",
    // Cornish
    ky: "kir",
    // Kirghiz, Kyrgyz
    la: "lat",
    // Latin
    lb: "ltz",
    // Luxembourgish, Letzeburgesch
    lg: "lug",
    // Ganda
    li: "lim",
    // Limburgan, Limburger, Limburgish
    ln: "lin",
    // Lingala
    lo: "lao",
    // Lao
    lt: "lit",
    // Lithuanian
    lu: "lub",
    // Luba-Katanga
    lv: "lav",
    // Latvian
    mg: "mlg",
    // Malagasy
    mh: "mah",
    // Marshallese
    mi: "mri",
    // Maori
    mk: "mkd",
    // Macedonian
    ml: "mal",
    // Malayalam
    mn: "mon",
    // Mongolian
    mr: "mar",
    // Marathi
    ms: "msa",
    // Malay
    mt: "mlt",
    // Maltese
    my: "mya",
    // Burmese
    na: "nau",
    // Nauru
    nb: "nob",
    // Norwegian Bokml
    nd: "nde",
    // North Ndebele
    ne: "nep",
    // Nepali
    ng: "ndo",
    // Ndonga
    nl: "nld",
    // Dutch, Flemish
    nn: "nno",
    // Norwegian Nynorsk
    no: "nor",
    // Norwegian
    nr: "nbl",
    // South Ndebele
    nv: "nav",
    // Navajo, Navaho
    ny: "nya",
    // Chichewa, Chewa, Nyanja
    oc: "oci",
    // Occitan
    oj: "oji",
    // Ojibwa
    om: "orm",
    // Oromo
    or: "ori",
    // Oriya
    os: "oss",
    // Ossetian, Ossetic
    pa: "pan",
    // Panjabi, Punjabi
    pi: "pli",
    // Pali
    pl: "pol",
    // Polish
    ps: "pus",
    // Pashto, Pushto
    pt: "por",
    // Portuguese
    qu: "que",
    // Quechua
    rm: "roh",
    // Romansh
    rn: "run",
    // Rundi
    ro: "ron",
    // Romanian, Moldavian, Moldovan
    ru: "rus",
    // Russian
    rw: "kin",
    // Kinyarwanda
    sa: "san",
    // Sanskrit
    sc: "srd",
    // Sardinian
    sd: "snd",
    // Sindhi
    se: "sme",
    // Northern Sami
    sg: "sag",
    // Sango
    si: "sin",
    // Sinhala, Sinhalese
    sk: "slk",
    // Slovak
    sl: "slv",
    // Slovenian
    sm: "smo",
    // Samoan
    sn: "sna",
    // Shona
    so: "som",
    // Somali
    sq: "sqi",
    // Albanian
    sr: "srp",
    // Serbian
    ss: "ssw",
    // Swati
    st: "sot",
    // Southern Sotho
    su: "sun",
    // Sundanese
    sv: "swe",
    // Swedish
    sw: "swa",
    // Swahili
    ta: "tam",
    // Tamil
    te: "tel",
    // Telugu
    tg: "tgk",
    // Tajik
    th: "tha",
    // Thai
    ti: "tir",
    // Tigrinya
    tk: "tuk",
    // Turkmen
    tl: "tgl",
    // Tagalog
    tn: "tsn",
    // Tswana
    to: "ton",
    // Tonga (Tonga Islands)
    tr: "tur",
    // Turkish
    ts: "tso",
    // Tsonga
    tt: "tat",
    // Tatar
    tw: "twi",
    // Twi
    ty: "tah",
    // Tahitian
    ug: "uig",
    // Uighur, Uyghur
    uk: "ukr",
    // Ukrainian
    ur: "urd",
    // Urdu
    uz: "uzb",
    // Uzbek
    ve: "ven",
    // Venda
    vi: "vie",
    // Vietnamese
    vo: "vol",
    // Volapk
    wa: "wln",
    // Walloon
    wo: "wol",
    // Wolof
    xh: "xho",
    // Xhosa
    yi: "yid",
    // Yiddish
    yo: "yor",
    // Yoruba
    za: "zha",
    // Zhuang, Chuang
    zh: "zho",
    // Chinese
    zu: "zul"
    // Zulu
  };
  var ISO_639_1_to_ISO_639_3_default = ISO_MAP_1_TO_3;

  // src/utils/languages/ISO_639-2_to_ISO_639-3.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var ISO_MAP_2_TO_3 = {
    alb: "sqi",
    // Albanian
    arm: "hye",
    // Armenian
    baq: "eus",
    // Basque
    bur: "mya",
    // Burmese
    chi: "zho",
    // Chinese
    cze: "ces",
    // Czech
    dut: "nld",
    // Dutch; Flemish
    fre: "fra",
    // French
    geo: "kat",
    // Georgian
    ger: "deu",
    // German
    gre: "ell",
    // Modern Greek (1453)
    ice: "isl",
    // Icelandic
    mac: "mkd",
    // Macedonian
    mao: "mri",
    // Maori
    may: "msa",
    // Malay
    per: "fas",
    // Persian
    slo: "slk",
    // Slovak
    rum: "ron",
    // Moldovan
    tib: "bod",
    // Tibetan
    wel: "cym"
    // Welsh
  };
  var ISO_639_2_to_ISO_639_3_default = ISO_MAP_2_TO_3;

  // src/utils/languages/normalize.ts
  function normalizeLanguage(_language) {
    if (isNullOrUndefined(_language) || _language === "") {
      return "und";
    }
    const fields = ("" + _language).toLowerCase().split("-");
    const base = fields[0];
    const normalizedBase = normalizeBase(base);
    if (isNonEmptyString(normalizedBase)) {
      return normalizedBase;
    }
    return _language;
  }
  function normalizeBase(base) {
    let result;
    switch (base.length) {
      case 2:
        result = ISO_639_1_to_ISO_639_3_default[base];
        break;
      case 3:
        result = ISO_639_2_to_ISO_639_3_default[base];
        break;
    }
    return result;
  }
  var normalize_default = normalizeLanguage;

  // src/utils/languages/index.ts
  var languages_default = normalize_default;

  // src/manifest/classes/representation.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/utils/are_arrays_of_numbers_equal.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function areArraysOfNumbersEqual(arr1, arr2) {
    if (arr1.length !== arr2.length) {
      return false;
    }
    if (arr1 === arr2) {
      return true;
    }
    for (let i = arr1.length - 1; i >= 0; i--) {
      if (arr1[i] !== arr2[i]) {
        return false;
      }
    }
    return true;
  }

  // src/utils/id_generator.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function idGenerator() {
    let prefix = "";
    let currId = -1;
    return function generateNewId() {
      currId++;
      if (currId >= Number.MAX_SAFE_INTEGER) {
        prefix += "0";
        currId = 0;
      }
      return prefix + String(currId);
    };
  }

  // src/manifest/classes/representation.ts
  var generateRepresentationUniqueId = idGenerator();
  var Representation = class {
    /**
     * @param {Object} args
     * @param {string} trackType
     */
    constructor(args, trackType, cachedCodecSupport) {
      var _a, _b, _c, _d, _e;
      this.id = args.id;
      this.uniqueId = generateRepresentationUniqueId();
      this.bitrate = args.bitrate;
      this.codecs = [];
      this.trackType = trackType;
      if (args.isSpatialAudio !== void 0) {
        this.isSpatialAudio = args.isSpatialAudio;
      }
      if (args.height !== void 0) {
        this.height = args.height;
      }
      if (args.width !== void 0) {
        this.width = args.width;
      }
      if (args.mimeType !== void 0) {
        this.mimeType = args.mimeType;
      }
      if (args.contentProtections !== void 0) {
        this.contentProtections = args.contentProtections;
      }
      if (args.frameRate !== void 0) {
        this.frameRate = args.frameRate;
      }
      if (args.hdrInfo !== void 0) {
        this.hdrInfo = args.hdrInfo;
      }
      this.cdnMetadata = args.cdnMetadata;
      this.index = args.index;
      const isEncrypted = this.contentProtections !== void 0;
      if (trackType === "audio" || trackType === "video") {
        if (args.supplementalCodecs !== void 0) {
          const isSupplementaryCodecSupported = cachedCodecSupport.isSupported(
            (_a = this.mimeType) != null ? _a : "",
            (_b = args.supplementalCodecs) != null ? _b : "",
            isEncrypted
          );
          if (isSupplementaryCodecSupported !== false) {
            this.codecs = [args.supplementalCodecs];
            this.isSupported = isSupplementaryCodecSupported;
          }
        }
        if (this.isSupported !== true) {
          if (this.codecs.length > 0) {
            this.codecs.push((_c = args.codecs) != null ? _c : "");
          } else {
            this.codecs = args.codecs === void 0 ? [] : [args.codecs];
            this.isSupported = cachedCodecSupport.isSupported(
              (_d = this.mimeType) != null ? _d : "",
              (_e = args.codecs) != null ? _e : "",
              isEncrypted
            );
          }
        }
      } else {
        if (args.codecs !== void 0) {
          this.codecs.push(args.codecs);
        }
        this.isSupported = true;
      }
    }
    /**
     * Some environments (e.g. in a WebWorker) may not have the capability to know
     * if a mimetype+codec combination is supported on the current platform.
     *
     * Calling `refreshCodecSupport` manually once the codecs supported are known
     * by the current environnement allows to work-around this issue.
     *
     * If the right mimetype+codec combination is found in the provided object,
     * this `Representation`'s `isSupported` property will be updated accordingly.
     *
     * @param {Array.<Object>} cachedCodecSupport;
     */
    refreshCodecSupport(cachedCodecSupport) {
      var _a, _b;
      if (this.isSupported !== void 0) {
        return;
      }
      const isEncrypted = this.contentProtections !== void 0;
      let isSupported = false;
      const mimeType = (_a = this.mimeType) != null ? _a : "";
      let codecs = (_b = this.codecs) != null ? _b : [];
      if (codecs.length === 0) {
        codecs = [""];
      }
      let representationHasUnknownCodecs = false;
      for (const codec of codecs) {
        isSupported = cachedCodecSupport.isSupported(mimeType, codec, isEncrypted);
        if (isSupported === true) {
          this.codecs = [codec];
          break;
        }
        if (isSupported === void 0) {
          representationHasUnknownCodecs = true;
        }
      }
      if (isSupported === true) {
        this.isSupported = true;
      } else {
        if (representationHasUnknownCodecs) {
          this.isSupported = void 0;
        } else {
          this.isSupported = false;
        }
      }
    }
    /**
     * Returns "mime-type string" which includes both the mime-type and the codec,
     * which is often needed when interacting with the browser's APIs.
     * @returns {string}
     */
    getMimeTypeString() {
      var _a, _b, _c;
      return `${(_a = this.mimeType) != null ? _a : ""};codecs="${(_c = (_b = this.codecs) == null ? void 0 : _b[0]) != null ? _c : ""}"`;
    }
    /**
     * Returns encryption initialization data linked to the given DRM's system ID.
     * This data may be useful to decrypt encrypted media segments.
     *
     * Returns an empty array if there is no data found for that system ID at the
     * moment.
     *
     * When you know that all encryption data has been added to this
     * Representation, you can also call the `getAllEncryptionData` method.
     * This second function will return all encryption initialization data
     * regardless of the DRM system, and might thus be used in all cases.
     *
     * /!\ Note that encryption initialization data may be progressively added to
     * this Representation after `_addProtectionData` calls or Manifest updates.
     * Because of this, the return value of this function might change after those
     * events.
     *
     * @param {string} drmSystemId - The hexa-encoded DRM system ID
     * @returns {Array.<Object>}
     */
    getEncryptionData(drmSystemId) {
      var _a;
      const allInitData = this.getAllEncryptionData();
      const filtered = [];
      for (let i = 0; i < allInitData.length; i++) {
        let createdObjForType = false;
        const initData = allInitData[i];
        for (let j = 0; j < initData.values.length; j++) {
          if (initData.values[j].systemId.toLowerCase() === drmSystemId.toLowerCase()) {
            if (!createdObjForType) {
              const keyIds = (_a = this.contentProtections) == null ? void 0 : _a.keyIds;
              filtered.push({
                type: initData.type,
                keyIds,
                values: [initData.values[j]]
              });
              createdObjForType = true;
            } else {
              filtered[filtered.length - 1].values.push(initData.values[j]);
            }
          }
        }
      }
      return filtered;
    }
    /**
     * Returns all currently-known encryption initialization data linked to this
     * Representation.
     * Encryption initialization data is generally required to be able to decrypt
     * those Representation's media segments.
     *
     * Unlike `getEncryptionData`, this method will return all available
     * encryption data.
     * It might as such might be used when either the current drm's system id is
     * not known or when no encryption data specific to it was found. In that
     * case, providing every encryption data linked to this Representation might
     * still allow decryption.
     *
     * Returns an empty array in two cases:
     *   - the content is not encrypted.
     *   - We don't have any decryption data yet.
     *
     * /!\ Note that new encryption initialization data can be added progressively
     * through the `_addProtectionData` method or through Manifest updates.
     * It is thus highly advised to only rely on this method once every protection
     * data related to this Representation has been known to be added.
     *
     * The main situation where new encryption initialization data is added is
     * after parsing this Representation's initialization segment, if one exists.
     * @returns {Array.<Object>}
     */
    getAllEncryptionData() {
      var _a;
      if (this.contentProtections === void 0 || this.contentProtections.initData.length === 0) {
        return [];
      }
      const keyIds = (_a = this.contentProtections) == null ? void 0 : _a.keyIds;
      return this.contentProtections.initData.map((x) => {
        return { type: x.type, keyIds, values: x.values };
      });
    }
    /**
     * Add new encryption initialization data to this Representation if it was not
     * already included.
     *
     * Returns `true` if new encryption initialization data has been added.
     * Returns `false` if none has been added (e.g. because it was already known).
     *
     * /!\ Mutates the current Representation
     *
     * TODO better handle use cases like key rotation by not always grouping
     * every protection data together? To check.
     * @param {string} initDataType
     * @param {Uint8Array|undefined} keyId
     * @param {Uint8Array} data
     * @returns {boolean}
     */
    addProtectionData(initDataType, keyId, data2) {
      let hasUpdatedProtectionData = false;
      if (this.contentProtections === void 0) {
        this.contentProtections = {
          keyIds: keyId !== void 0 ? [keyId] : [],
          initData: [{ type: initDataType, values: data2 }]
        };
        return true;
      }
      if (keyId !== void 0) {
        const keyIds = this.contentProtections.keyIds;
        if (keyIds === void 0) {
          this.contentProtections.keyIds = [keyId];
        } else {
          let foundKeyId = false;
          for (const knownKeyId of keyIds) {
            if (areArraysOfNumbersEqual(knownKeyId, keyId)) {
              foundKeyId = true;
            }
          }
          if (!foundKeyId) {
            log_default.warn("Manifest: found unanounced key id.");
            keyIds.push(keyId);
          }
        }
      }
      const cInitData = this.contentProtections.initData;
      for (let i = 0; i < cInitData.length; i++) {
        if (cInitData[i].type === initDataType) {
          const cValues = cInitData[i].values;
          for (let dataI = 0; dataI < data2.length; dataI++) {
            const dataToAdd = data2[dataI];
            let cValuesIdx;
            for (cValuesIdx = 0; cValuesIdx < cValues.length; cValuesIdx++) {
              if (dataToAdd.systemId === cValues[cValuesIdx].systemId) {
                if (areArraysOfNumbersEqual(dataToAdd.data, cValues[cValuesIdx].data)) {
                  break;
                } else {
                  log_default.warn("Manifest: different init data for the same system ID");
                }
              }
            }
            if (cValuesIdx === cValues.length) {
              cValues.push(dataToAdd);
              hasUpdatedProtectionData = true;
            }
          }
          return hasUpdatedProtectionData;
        }
      }
      this.contentProtections.initData.push({ type: initDataType, values: data2 });
      return true;
    }
    /**
     * Format the current `Representation`'s properties into a
     * `IRepresentationMetadata` format which can better be communicated through
     * another thread.
     *
     * Please bear in mind however that the returned object will not be updated
     * when the current `Representation` instance is updated, it is only a
     * snapshot at the current time.
     *
     * If you want to keep that data up-to-date with the current `Representation`
     * instance, you will have to do it yourself.
     *
     * @returns {Object}
     */
    getMetadataSnapshot() {
      return {
        id: this.id,
        uniqueId: this.uniqueId,
        bitrate: this.bitrate,
        codecs: this.codecs,
        mimeType: this.mimeType,
        width: this.width,
        height: this.height,
        frameRate: this.frameRate,
        isSupported: this.isSupported,
        hdrInfo: this.hdrInfo,
        contentProtections: this.contentProtections,
        decipherable: this.decipherable
      };
    }
  };
  var representation_default = Representation;

  // src/manifest/classes/adaptation.ts
  var Adaptation = class _Adaptation {
    /**
     * @constructor
     * @param {Object} parsedAdaptation
     * @param {Object|undefined} [options]
     */
    constructor(parsedAdaptation, cachedCodecSupport, options = {}) {
      const { trickModeTracks } = parsedAdaptation;
      const { representationFilter, isManuallyAdded } = options;
      this.id = parsedAdaptation.id;
      this.type = parsedAdaptation.type;
      if (parsedAdaptation.isTrickModeTrack !== void 0) {
        this.isTrickModeTrack = parsedAdaptation.isTrickModeTrack;
      }
      if (parsedAdaptation.language !== void 0) {
        this.language = parsedAdaptation.language;
        this.normalizedLanguage = languages_default(parsedAdaptation.language);
      }
      if (parsedAdaptation.closedCaption !== void 0) {
        this.isClosedCaption = parsedAdaptation.closedCaption;
      }
      if (parsedAdaptation.audioDescription !== void 0) {
        this.isAudioDescription = parsedAdaptation.audioDescription;
      }
      if (parsedAdaptation.isDub !== void 0) {
        this.isDub = parsedAdaptation.isDub;
      }
      if (parsedAdaptation.forcedSubtitles !== void 0) {
        this.isForcedSubtitles = parsedAdaptation.forcedSubtitles;
      }
      if (parsedAdaptation.isSignInterpreted !== void 0) {
        this.isSignInterpreted = parsedAdaptation.isSignInterpreted;
      }
      if (parsedAdaptation.label !== void 0) {
        this.label = parsedAdaptation.label;
      }
      if (trickModeTracks !== void 0 && trickModeTracks.length > 0) {
        this.trickModeTracks = trickModeTracks.map(
          (track) => new _Adaptation(track, cachedCodecSupport)
        );
      }
      const argsRepresentations = parsedAdaptation.representations;
      const representations = [];
      this.supportStatus = {
        hasSupportedCodec: false,
        hasCodecWithUndefinedSupport: false,
        isDecipherable: false
      };
      for (let i = 0; i < argsRepresentations.length; i++) {
        const representation = new representation_default(
          argsRepresentations[i],
          this.type,
          cachedCodecSupport
        );
        let shouldAdd = true;
        if (!isNullOrUndefined(representationFilter)) {
          const reprObject = {
            id: representation.id,
            bitrate: representation.bitrate,
            codecs: representation.codecs,
            height: representation.height,
            width: representation.width,
            frameRate: representation.frameRate,
            hdrInfo: representation.hdrInfo
          };
          if (representation.contentProtections !== void 0) {
            reprObject.contentProtections = {};
            if (representation.contentProtections.keyIds !== void 0) {
              const keyIds = representation.contentProtections.keyIds;
              reprObject.contentProtections.keyIds = keyIds;
            }
          }
          shouldAdd = representationFilter(reprObject, {
            trackType: this.type,
            language: this.language,
            normalizedLanguage: this.normalizedLanguage,
            isClosedCaption: this.isClosedCaption,
            isDub: this.isDub,
            isAudioDescription: this.isAudioDescription,
            isSignInterpreted: this.isSignInterpreted
          });
        }
        if (shouldAdd) {
          representations.push(representation);
          if (representation.isSupported === void 0) {
            this.supportStatus.hasCodecWithUndefinedSupport = true;
            if (this.supportStatus.hasSupportedCodec === false) {
              this.supportStatus.hasSupportedCodec = void 0;
            }
          } else if (representation.isSupported) {
            this.supportStatus.hasSupportedCodec = true;
          }
          if (representation.decipherable === void 0) {
            if (this.supportStatus.isDecipherable === false) {
              this.supportStatus.isDecipherable = void 0;
            }
          } else if (representation.decipherable) {
            this.supportStatus.isDecipherable = true;
          }
        } else {
          log_default.debug(
            "Filtering Representation due to representationFilter",
            this.type,
            `Adaptation: ${this.id}`,
            `Representation: ${representation.id}`,
            `(${representation.bitrate})`
          );
        }
      }
      representations.sort((a, b) => a.bitrate - b.bitrate);
      this.representations = representations;
      this.manuallyAdded = isManuallyAdded === true;
    }
    /**
     * Some environments (e.g. in a WebWorker) may not have the capability to know
     * if a mimetype+codec combination is supported on the current platform.
     *
     * Calling `refreshCodecSupport` manually once the codecs supported are known
     * by the current environnement allows to work-around this issue.
     *
     *
     * If the right mimetype+codec combination is found in the provided object,
     * this `Adaptation`'s `isSupported` property will be updated accordingly as
     * well as all of its inner `Representation`'s `isSupported` attributes.
     *
     * @param {Array.<Object>} cachedCodecSupport
     */
    refreshCodecSupport(cachedCodecSupport) {
      let hasCodecWithUndefinedSupport = false;
      let hasSupportedRepresentation = false;
      for (const representation of this.representations) {
        representation.refreshCodecSupport(cachedCodecSupport);
        if (representation.isSupported === void 0) {
          hasCodecWithUndefinedSupport = true;
        } else if (representation.isSupported) {
          hasSupportedRepresentation = true;
        }
      }
      if (hasSupportedRepresentation) {
        this.supportStatus.hasSupportedCodec = true;
      } else if (hasCodecWithUndefinedSupport) {
        this.supportStatus.hasSupportedCodec = void 0;
      } else {
        this.supportStatus.hasSupportedCodec = false;
      }
      this.supportStatus.hasCodecWithUndefinedSupport = hasCodecWithUndefinedSupport;
    }
    /**
     * Returns the Representation linked to the given ID.
     * @param {number|string} wantedId
     * @returns {Object|undefined}
     */
    getRepresentation(wantedId) {
      return arrayFind(this.representations, ({ id }) => wantedId === id);
    }
    /**
     * Format the current `Adaptation`'s properties into a
     * `IAdaptationMetadata` format which can better be communicated through
     * another thread.
     *
     * Please bear in mind however that the returned object will not be updated
     * when the current `Adaptation` instance is updated, it is only a
     * snapshot at the current time.
     *
     * If you want to keep that data up-to-date with the current `Adaptation`
     * instance, you will have to do it yourself.
     *
     * @returns {Object}
     */
    getMetadataSnapshot() {
      const representations = [];
      const baseRepresentations = this.representations;
      for (const representation of baseRepresentations) {
        representations.push(representation.getMetadataSnapshot());
      }
      return {
        id: this.id,
        type: this.type,
        supportStatus: this.supportStatus,
        language: this.language,
        isForcedSubtitles: this.isForcedSubtitles,
        isClosedCaption: this.isClosedCaption,
        isAudioDescription: this.isAudioDescription,
        isSignInterpreted: this.isSignInterpreted,
        normalizedLanguage: this.normalizedLanguage,
        representations,
        label: this.label,
        isDub: this.isDub
      };
    }
  };

  // src/manifest/classes/manifest.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/main_thread/init/utils/update_manifest_codec_support.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/compat/is_codec_supported.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/compat/browser_compatibility_types.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var gs = global_scope_default;
  var MediaSource_ = gs === void 0 ? void 0 : !isNullOrUndefined(gs.MediaSource) ? gs.MediaSource : !isNullOrUndefined(gs.MozMediaSource) ? gs.MozMediaSource : !isNullOrUndefined(gs.WebKitMediaSource) ? gs.WebKitMediaSource : gs.MSMediaSource;

  // src/compat/is_codec_supported.ts
  var MAX_SUPPORT_MAP_ENTRIES = 200;
  var supportMap = /* @__PURE__ */ new Map();
  function isCodecSupported(mimeType) {
    if (isNullOrUndefined(MediaSource_)) {
      if (is_worker_default) {
        log_default.error("Compat: Cannot request codec support in a worker without MSE.");
      }
      return false;
    }
    if (typeof MediaSource_.isTypeSupported === "function") {
      const cachedSupport = supportMap.get(mimeType);
      if (cachedSupport !== void 0) {
        return cachedSupport;
      } else {
        const isSupported = MediaSource_.isTypeSupported(mimeType);
        if (supportMap.size >= MAX_SUPPORT_MAP_ENTRIES) {
          supportMap.clear();
        }
        supportMap.set(mimeType, isSupported);
        return isSupported;
      }
    }
    return true;
  }

  // src/main_thread/decrypt/index.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/main_thread/decrypt/clear_on_stop.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/compat/should_unset_media_keys.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function shouldUnsetMediaKeys() {
    return isIE11;
  }

  // src/main_thread/decrypt/dispose_decryption_resources.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/compat/eme/set_media_keys.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/utils/sleep.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function sleep(timeInMs) {
    return new Promise((res) => {
      setTimeout(res, timeInMs);
    });
  }

  // src/compat/should_await_set_media_keys.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function shouldAwaitSetMediaKeys() {
    return isWebOs;
  }

  // src/compat/eme/set_media_keys.ts
  function setMediaKeys(emeImplementation, mediaElement, mediaKeys) {
    const prom = emeImplementation.setMediaKeys(mediaElement, mediaKeys).then(() => {
      log_default.info("Compat: MediaKeys updated with success");
    }).catch((err) => {
      if (mediaKeys === null) {
        log_default.error(
          "Compat: Could not reset MediaKeys",
          err instanceof Error ? err : "Unknown Error"
        );
        return;
      }
      log_default.error(
        "Compat: Could not update MediaKeys",
        err instanceof Error ? err : "Unknown Error"
      );
      throw err;
    });
    if (shouldAwaitSetMediaKeys()) {
      return prom;
    }
    return Promise.race([
      prom,
      // Because we know how much EME has implementation issues, let's not block
      // everything because that API hangs
      sleep(1e3)
    ]);
  }

  // src/main_thread/decrypt/utils/media_keys_infos_store.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var currentMediaState = /* @__PURE__ */ new WeakMap();
  var media_keys_infos_store_default = {
    /**
     * Update MediaKeys infos set on a HMTLMediaElement
     * @param {HTMLMediaElement} mediaElement
     * @param {Object} state
     */
    setState(mediaElement, state) {
      currentMediaState.set(mediaElement, state);
    },
    /**
     * Get MediaKeys infos currently set on a HMTLMediaElement
     * @param {HTMLMediaElement} mediaElement
     * @returns {Object}
     */
    getState(mediaElement) {
      const currentState = currentMediaState.get(mediaElement);
      return currentState === void 0 ? null : currentState;
    },
    /**
     * Remove MediaKeys infos currently set on a HMTLMediaElement
     * @param {HTMLMediaElement} mediaElement
     */
    clearState(mediaElement) {
      currentMediaState.set(mediaElement, null);
    }
  };

  // src/main_thread/decrypt/dispose_decryption_resources.ts
  async function disposeDecryptionResources(mediaElement) {
    const currentState = media_keys_infos_store_default.getState(mediaElement);
    if (currentState === null) {
      return void 0;
    }
    log_default.info("DRM: Disposing of the current MediaKeys");
    const { loadedSessionsStore } = currentState;
    media_keys_infos_store_default.clearState(mediaElement);
    await loadedSessionsStore.closeAllSessions();
    return setMediaKeys(currentState.emeImplementation, mediaElement, null);
  }

  // src/main_thread/decrypt/clear_on_stop.ts
  function clearOnStop(mediaElement) {
    log_default.info("DRM: Clearing-up DRM session.");
    if (shouldUnsetMediaKeys()) {
      log_default.info("DRM: disposing current MediaKeys.");
      return disposeDecryptionResources(mediaElement);
    }
    const currentState = media_keys_infos_store_default.getState(mediaElement);
    if (currentState !== null && currentState.keySystemOptions.closeSessionsOnStop === true) {
      log_default.info("DRM: closing all current sessions.");
      return currentState.loadedSessionsStore.closeAllSessions();
    }
    log_default.info(
      "DRM: Nothing to clear. Returning right away. No state =",
      currentState === null
    );
    return Promise.resolve();
  }

  // src/main_thread/decrypt/content_decryptor.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/compat/eme/index.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/compat/eme/close_session.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/utils/cancellable_sleep.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/utils/create_cancellable_promise.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function createCancellablePromise(cancellationSignal, cb) {
    let abortingLogic;
    return new Promise((res, rej) => {
      if (cancellationSignal.cancellationError !== null) {
        return rej(cancellationSignal.cancellationError);
      }
      let hasUnregistered = false;
      abortingLogic = cb(
        function onCancellablePromiseSuccess(val) {
          cancellationSignal.deregister(onCancellablePromiseCancellation);
          hasUnregistered = true;
          res(val);
        },
        function onCancellablePromiseFailure(err) {
          cancellationSignal.deregister(onCancellablePromiseCancellation);
          hasUnregistered = true;
          rej(err);
        }
      );
      if (!hasUnregistered) {
        cancellationSignal.register(onCancellablePromiseCancellation);
      }
      function onCancellablePromiseCancellation(error) {
        if (abortingLogic !== void 0) {
          abortingLogic();
        }
        rej(error);
      }
    });
  }

  // src/utils/cancellable_sleep.ts
  function cancellableSleep(delay, cancellationSignal) {
    return createCancellablePromise(cancellationSignal, (res) => {
      const timeout = setTimeout(() => res(), delay);
      return () => clearTimeout(timeout);
    });
  }

  // src/utils/task_canceller.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/utils/assert.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var AssertionError = class _AssertionError extends Error {
    /**
     * @param {string} message
     */
    constructor(message) {
      super(message);
      Object.setPrototypeOf(this, _AssertionError.prototype);
      this.name = "AssertionError";
    }
  };
  function assert(assertion, message) {
    if (define_ENVIRONMENT_default.DEV === define_ENVIRONMENT_default.CURRENT_ENV && !assertion) {
      throw new AssertionError(message === void 0 ? "invalid assertion" : message);
    }
  }
  function assertInterface(o, iface, name2 = "object") {
    assert(!isNullOrUndefined(o), `${name2} should be an object`);
    for (const k in iface) {
      if (iface.hasOwnProperty(k)) {
        assert(
          typeof o[k] === iface[k],
          `${name2} should have property ${k} as a ${iface[k]}`
        );
      }
    }
  }
  function assertUnreachable(_) {
    throw new AssertionError("Unreachable path taken");
  }

  // src/utils/task_canceller.ts
  var TaskCanceller = class {
    /**
     * Creates a new `TaskCanceller`, with its own `CancellationSignal` created
     * as its `signal` provide.
     * You can then pass this property to async task you wish to be cancellable.
     */
    constructor() {
      const [trigger, register] = createCancellationFunctions();
      this._isUsed = false;
      this._trigger = trigger;
      this.signal = new CancellationSignal(register);
    }
    /**
     * Returns `true` if this `TaskCanceller` has already been triggered.
     * `false` otherwise.
     */
    isUsed() {
      return this._isUsed;
    }
    /**
     * Bind this `TaskCanceller` to a `CancellationSignal`, so the former
     * is automatically cancelled when the latter is triggered.
     *
     * Note that this call registers a callback on the given signal, until either
     * the current `TaskCanceller` is cancelled or until this given
     * `CancellationSignal` is triggered.
     * To avoid leaking memory, the returned callback allow to undo this link.
     * It should be called if/when that link is not needed anymore, such as when
     * there is no need for this `TaskCanceller` anymore.
     *
     * @param {Object} signal
     * @returns {Function}
     */
    linkToSignal(signal) {
      const unregister = signal.register(() => {
        this.cancel();
      });
      this.signal.register(unregister);
      return unregister;
    }
    /**
     * "Trigger" the `TaskCanceller`, notify through its associated
     * `CancellationSignal` (its `signal` property) that a task should be aborted.
     *
     * Once called the `TaskCanceller` is permanently triggered.
     *
     * An optional CancellationError can be given in argument for when this
     * cancellation is actually triggered as a chain reaction from a previous
     * cancellation.
     * @param {Error} [srcError]
     */
    cancel(srcError) {
      if (this._isUsed) {
        return;
      }
      this._isUsed = true;
      const cancellationError = srcError != null ? srcError : new CancellationError();
      this._trigger(cancellationError);
    }
    /**
     * Check that the `error` in argument is a `CancellationError`, most likely
     * meaning that the linked error is due to a task aborted via a
     * `CancellationSignal`.
     * @param {*} error
     * @returns {boolean}
     */
    static isCancellationError(error) {
      return error instanceof CancellationError;
    }
  };
  var CancellationSignal = class {
    /**
     * Creates a new CancellationSignal.
     * /!\ Note: Only a `TaskCanceller` is supposed to be able to create one.
     * @param {Function} registerToSource - Function called when the task is
     * cancelled.
     */
    constructor(registerToSource) {
      this._isCancelled = false;
      this.cancellationError = null;
      this._listeners = [];
      registerToSource((cancellationError) => {
        this.cancellationError = cancellationError;
        this._isCancelled = true;
        while (this._listeners.length > 0) {
          try {
            const listener = this._listeners.pop();
            listener == null ? void 0 : listener(cancellationError);
          } catch (err) {
            log_default.error(
              "Error while calling clean up listener",
              err instanceof Error ? err.toString() : "Unknown error"
            );
          }
        }
      });
    }
    /**
     * Returns `true` when the cancellation order was already triggered, meaning
     * that the linked task needs to be aborted.
     * @returns boolean
     */
    isCancelled() {
      return this._isCancelled;
    }
    /**
     * Registers a function that will be called when/if the current task is
     * cancelled.
     *
     * Multiple calls to `register` can be performed to register multiple
     * callbacks on cancellation associated to the same `CancellationSignal`.
     *
     * @param {Function} fn - This function should perform all logic allowing to
     * abort everything the task is doing.
     *
     * It takes in argument the `CancellationError` which was created when the
     * task was aborted.
     * You can use this error to notify callers that the task has been aborted,
     * for example through a rejected Promise.
     *
     * @return {Function} - Removes that cancellation listener. You can call this
     * once you don't want the callback to be triggered anymore (e.g. after the
     * task succeeded or failed).
     * You don't need to call that function when cancellation has already been
     * performed.
     */
    register(fn) {
      if (this._isCancelled) {
        assert(this.cancellationError !== null);
        fn(this.cancellationError);
        return noop_default;
      }
      this._listeners.push(fn);
      return () => this.deregister(fn);
    }
    /**
     * De-register a function registered through the `register` function.
     * Do nothing if that function wasn't registered.
     *
     * You can call this method when using the return value of `register` is not
     * practical.
     * @param {Function} fn
     */
    deregister(fn) {
      for (let i = this._listeners.length - 1; i >= 0; i--) {
        if (this._listeners[i] === fn) {
          this._listeners.splice(i, 1);
        }
      }
    }
  };
  var CancellationError = class _CancellationError extends Error {
    constructor() {
      const message = "This task was cancelled.";
      super(message);
      Object.setPrototypeOf(this, _CancellationError.prototype);
      this.name = "CancellationError";
    }
  };
  function createCancellationFunctions() {
    let listener = noop_default;
    return [
      function trigger(error) {
        listener(error);
      },
      function register(newListener) {
        listener = newListener;
      }
    ];
  }

  // src/compat/eme/close_session.ts
  function closeSession(session) {
    const timeoutCanceller = new TaskCanceller();
    return Promise.race([
      session.close().then(() => {
        timeoutCanceller.cancel();
      }),
      // The `closed` promise may resolve, even if `close()` result has not
      // (seen at some point on Firefox).
      session.closed.then(() => {
        timeoutCanceller.cancel();
      }),
      waitTimeoutAndCheck()
    ]);
    async function waitTimeoutAndCheck() {
      try {
        await cancellableSleep(1e3, timeoutCanceller.signal);
        await tryUpdatingSession();
      } catch (err) {
        if (err instanceof CancellationError) {
          return;
        }
        const message = err instanceof Error ? err.message : "Unknown error made it impossible to close the session";
        log_default.error(`DRM: ${message}`);
      }
    }
    async function tryUpdatingSession() {
      try {
        await session.update(new Uint8Array(1));
      } catch (err) {
        if (timeoutCanceller.isUsed()) {
          return;
        }
        if (err instanceof Error && err.message === "The session is already closed.") {
          return;
        }
        await cancellableSleep(1e3, timeoutCanceller.signal);
      }
      if (timeoutCanceller.isUsed()) {
        return;
      }
      throw new Error("Compat: Couldn't know if session is closed");
    }
  }

  // src/compat/eme/eme-api-implementation.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/compat/should_favour_custom_safari_EME.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/compat/eme/custom_media_keys/webkit_media_keys_constructor.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var WebKitMediaKeysConstructor;
  var { WebKitMediaKeys } = global_scope_default;
  if (WebKitMediaKeys !== void 0 && typeof WebKitMediaKeys.isTypeSupported === "function" && // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
  typeof WebKitMediaKeys.prototype.createSession === "function" && typeof HTMLMediaElement.prototype.webkitSetMediaKeys === "function") {
    WebKitMediaKeysConstructor = WebKitMediaKeys;
  }

  // src/compat/should_favour_custom_safari_EME.ts
  function shouldFavourCustomSafariEME() {
    return (isSafariDesktop || isSafariMobile) && WebKitMediaKeysConstructor !== void 0;
  }

  // src/compat/eme/custom_key_system_access.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var CustomMediaKeySystemAccess = class {
    /**
     * @param {string} _keyType - type of key system (e.g. "widevine" or
     * "com.widevine.alpha").
     * @param {Object} _mediaKeys - MediaKeys implementation
     * @param {Object} _configuration - Configuration accepted for this
     * MediaKeySystemAccess.
     */
    constructor(_keyType, _mediaKeys, _configuration) {
      this._keyType = _keyType;
      this._mediaKeys = _mediaKeys;
      this._configuration = _configuration;
    }
    /**
     * @returns {string} - current key system type (e.g. "widevine" or
     * "com.widevine.alpha").
     */
    get keySystem() {
      return this._keyType;
    }
    /**
     * @returns {Promise.<Object>} - Promise wrapping the MediaKeys for this
     * MediaKeySystemAccess. Never rejects.
     */
    createMediaKeys() {
      return new Promise((res) => res(this._mediaKeys));
    }
    /**
     * @returns {Object} - Configuration accepted for this MediaKeySystemAccess.
     */
    getConfiguration() {
      return this._configuration;
    }
  };

  // src/compat/eme/custom_media_keys/ie11_media_keys.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/utils/wrapInPromise.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function wrapInPromise(val) {
    try {
      const ret = val();
      if (typeof ret === "object" && ret !== null && typeof ret.then === "function") {
        return ret;
      } else {
        return Promise.resolve(ret);
      }
    } catch (err) {
      return Promise.reject(err);
    }
  }

  // src/compat/eme/custom_media_keys/ms_media_keys_constructor.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var MSMediaKeysConstructor;
  var { MSMediaKeys } = global_scope_default;
  if (MSMediaKeys !== void 0 && MSMediaKeys.prototype !== void 0 && typeof MSMediaKeys.isTypeSupported === "function" && // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
  typeof MSMediaKeys.prototype.createSession === "function") {
    MSMediaKeysConstructor = MSMediaKeys;
  }

  // src/compat/eme/custom_media_keys/ie11_media_keys.ts
  var IE11MediaKeySession = class extends EventEmitter {
    constructor(mk) {
      super();
      this.expiration = NaN;
      this.keyStatuses = /* @__PURE__ */ new Map();
      this._mk = mk;
      this._sessionClosingCanceller = new TaskCanceller();
      this.closed = new Promise((resolve) => {
        this._sessionClosingCanceller.signal.register(() => resolve());
      });
      this.update = (license) => {
        return new Promise((resolve, reject) => {
          if (this._ss === void 0) {
            return reject("MediaKeySession not set.");
          }
          try {
            resolve(
              this._ss.update(
                license,
                ""
              )
            );
          } catch (err) {
            reject(err);
          }
        });
      };
    }
    generateRequest(_initDataType, initData) {
      return new Promise((resolve) => {
        let initDataU8;
        if (initData instanceof Uint8Array) {
          initDataU8 = initData;
        } else if (initData instanceof ArrayBuffer) {
          initDataU8 = new Uint8Array(initData);
        } else {
          initDataU8 = new Uint8Array(initData.buffer);
        }
        this._ss = this._mk.createSession("video/mp4", initDataU8);
        onKeyMessage(
          this._ss,
          (evt) => {
            var _a;
            this.trigger((_a = evt.type) != null ? _a : "message", evt);
          },
          this._sessionClosingCanceller.signal
        );
        onKeyAdded(
          this._ss,
          (evt) => {
            var _a;
            this.trigger((_a = evt.type) != null ? _a : "keyadded", evt);
          },
          this._sessionClosingCanceller.signal
        );
        onKeyError(
          this._ss,
          (evt) => {
            var _a;
            this.trigger((_a = evt.type) != null ? _a : "keyerror", evt);
          },
          this._sessionClosingCanceller.signal
        );
        resolve();
      });
    }
    close() {
      return new Promise((resolve) => {
        if (!isNullOrUndefined(this._ss)) {
          this._ss.close();
          this._ss = void 0;
        }
        this._sessionClosingCanceller.cancel();
        resolve();
      });
    }
    load() {
      return Promise.resolve(false);
    }
    remove() {
      return Promise.resolve();
    }
    get sessionId() {
      var _a, _b;
      return (_b = (_a = this._ss) == null ? void 0 : _a.sessionId) != null ? _b : "";
    }
  };
  var IE11CustomMediaKeys = class {
    constructor(keyType) {
      if (MSMediaKeysConstructor === void 0) {
        throw new Error("No MSMediaKeys API.");
      }
      this._mediaKeys = new MSMediaKeysConstructor(keyType);
    }
    _setVideo(videoElement) {
      return wrapInPromise(() => {
        this._videoElement = videoElement;
        if (this._videoElement.msSetMediaKeys !== void 0) {
          this._videoElement.msSetMediaKeys(this._mediaKeys);
        }
      });
    }
    createSession() {
      if (this._videoElement === void 0 || this._mediaKeys === void 0) {
        throw new Error("Video not attached to the MediaKeys");
      }
      return new IE11MediaKeySession(this._mediaKeys);
    }
    setServerCertificate() {
      throw new Error("Server certificate is not implemented in your browser");
    }
  };
  function getIE11MediaKeysCallbacks() {
    const isTypeSupported = (keySystem, type) => {
      if (MSMediaKeysConstructor === void 0) {
        throw new Error("No MSMediaKeys API.");
      }
      if (type !== void 0) {
        return MSMediaKeysConstructor.isTypeSupported(keySystem, type);
      }
      return MSMediaKeysConstructor.isTypeSupported(keySystem);
    };
    const createCustomMediaKeys = (keyType) => new IE11CustomMediaKeys(keyType);
    const setMediaKeys2 = (elt, mediaKeys) => {
      if (mediaKeys === null) {
        return Promise.resolve(void 0);
      }
      if (!(mediaKeys instanceof IE11CustomMediaKeys)) {
        throw new Error(
          "Custom setMediaKeys is supposed to be called with IE11 custom MediaKeys."
        );
      }
      return mediaKeys._setVideo(elt);
    };
    return {
      isTypeSupported,
      createCustomMediaKeys,
      setMediaKeys: setMediaKeys2
    };
  }

  // src/compat/eme/custom_media_keys/moz_media_keys_constructor.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var MozMediaKeysConstructor;
  var { MozMediaKeys } = global_scope_default;
  if (MozMediaKeys !== void 0 && MozMediaKeys.prototype !== void 0 && typeof MozMediaKeys.isTypeSupported === "function" && // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
  typeof MozMediaKeys.prototype.createSession === "function") {
    MozMediaKeysConstructor = MozMediaKeys;
  }
  function getMozMediaKeysCallbacks() {
    const isTypeSupported = (keySystem, type) => {
      if (MozMediaKeysConstructor === void 0) {
        throw new Error("No MozMediaKeys API.");
      }
      if (type !== void 0) {
        return MozMediaKeysConstructor.isTypeSupported(keySystem, type);
      }
      return MozMediaKeysConstructor.isTypeSupported(keySystem);
    };
    const createCustomMediaKeys = (keyType) => {
      if (MozMediaKeysConstructor === void 0) {
        throw new Error("No MozMediaKeys API.");
      }
      return new MozMediaKeysConstructor(keyType);
    };
    const setMediaKeys2 = (elt, mediaKeys) => {
      return wrapInPromise(() => {
        if (elt.mozSetMediaKeys === void 0 || typeof elt.mozSetMediaKeys !== "function") {
          throw new Error("Can't set video on MozMediaKeys.");
        }
        return elt.mozSetMediaKeys(mediaKeys);
      });
    };
    return {
      isTypeSupported,
      createCustomMediaKeys,
      setMediaKeys: setMediaKeys2
    };
  }

  // src/compat/eme/custom_media_keys/old_webkit_media_keys.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/utils/base64.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var base64abc = [
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g",
    "h",
    "i",
    "j",
    "k",
    "l",
    "m",
    "n",
    "o",
    "p",
    "q",
    "r",
    "s",
    "t",
    "u",
    "v",
    "w",
    "x",
    "y",
    "z",
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "+",
    "/"
  ];
  var base64codes = [
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    62,
    255,
    255,
    255,
    63,
    52,
    53,
    54,
    55,
    56,
    57,
    58,
    59,
    60,
    61,
    255,
    255,
    255,
    0,
    255,
    255,
    255,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    17,
    18,
    19,
    20,
    21,
    22,
    23,
    24,
    25,
    255,
    255,
    255,
    255,
    255,
    255,
    26,
    27,
    28,
    29,
    30,
    31,
    32,
    33,
    34,
    35,
    36,
    37,
    38,
    39,
    40,
    41,
    42,
    43,
    44,
    45,
    46,
    47,
    48,
    49,
    50,
    51
  ];
  function getBase64Code(charCode) {
    if (charCode >= base64codes.length) {
      throw new Error("Unable to parse base64 string.");
    }
    const code = base64codes[charCode];
    if (code === 255) {
      throw new Error("Unable to parse base64 string.");
    }
    return code;
  }
  function bytesToBase64(bytes) {
    let result = "";
    let i;
    const length = bytes.length;
    for (i = 2; i < length; i += 3) {
      result += base64abc[bytes[i - 2] >> 2];
      result += base64abc[(bytes[i - 2] & 3) << 4 | bytes[i - 1] >> 4];
      result += base64abc[(bytes[i - 1] & 15) << 2 | bytes[i] >> 6];
      result += base64abc[bytes[i] & 63];
    }
    if (i === length + 1) {
      result += base64abc[bytes[i - 2] >> 2];
      result += base64abc[(bytes[i - 2] & 3) << 4];
      result += "==";
    }
    if (i === length) {
      result += base64abc[bytes[i - 2] >> 2];
      result += base64abc[(bytes[i - 2] & 3) << 4 | bytes[i - 1] >> 4];
      result += base64abc[(bytes[i - 1] & 15) << 2];
      result += "=";
    }
    return result;
  }
  function base64ToBytes(str) {
    const paddingNeeded = str.length % 4;
    let paddedStr = str;
    if (paddingNeeded !== 0) {
      log_default.warn("base64ToBytes: base64 given miss padding");
      paddedStr += paddingNeeded === 3 ? "=" : paddingNeeded === 2 ? "==" : "===";
    }
    const index = paddedStr.indexOf("=");
    if (index !== -1 && index < paddedStr.length - 2) {
      throw new Error("Unable to parse base64 string.");
    }
    const missingOctets = paddedStr.endsWith("==") ? 2 : paddedStr.endsWith("=") ? 1 : 0;
    const n = paddedStr.length;
    const result = new Uint8Array(n / 4 * 3);
    let buffer;
    for (let i = 0, j = 0; i < n; i += 4, j += 3) {
      buffer = getBase64Code(paddedStr.charCodeAt(i)) << 18 | getBase64Code(paddedStr.charCodeAt(i + 1)) << 12 | getBase64Code(paddedStr.charCodeAt(i + 2)) << 6 | getBase64Code(paddedStr.charCodeAt(i + 3));
      result[j] = buffer >> 16;
      result[j + 1] = buffer >> 8 & 255;
      result[j + 2] = buffer & 255;
    }
    return result.subarray(0, result.length - missingOctets);
  }

  // src/utils/string_parsing.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var hasTextDecoder = typeof global_scope_default === "object" && typeof global_scope_default.TextDecoder === "function";
  var hasTextEncoder = typeof global_scope_default === "object" && typeof global_scope_default.TextEncoder === "function";
  function strToUtf16LE(str) {
    const buffer = new ArrayBuffer(str.length * 2);
    const res = new Uint8Array(buffer);
    for (let i = 0; i < res.length; i += 2) {
      const value = str.charCodeAt(i / 2);
      res[i] = value & 255;
      res[i + 1] = value >> 8 & 255;
    }
    return res;
  }
  function utf16LEToStr(bytes) {
    if (hasTextDecoder) {
      try {
        const decoder = new TextDecoder("utf-16le");
        return decoder.decode(bytes);
      } catch (e) {
        const err = e instanceof Error ? e : "";
        log_default.warn(
          "Utils: could not use TextDecoder to parse UTF-16LE, fallbacking to another implementation",
          err
        );
      }
    }
    let str = "";
    for (let i = 0; i < bytes.length; i += 2) {
      str += String.fromCharCode((bytes[i + 1] << 8) + bytes[i]);
    }
    return str;
  }
  function strToUtf8(str) {
    if (hasTextEncoder) {
      try {
        const encoder = new TextEncoder();
        return encoder.encode(str);
      } catch (e) {
        const err = e instanceof Error ? e : "";
        log_default.warn(
          "Utils: could not use TextEncoder to encode string into UTF-8, fallbacking to another implementation",
          err
        );
      }
    }
    let utf8Str;
    const pcStr = encodeURIComponent(str);
    if (typeof unescape === "function") {
      utf8Str = unescape(pcStr);
    } else {
      const isHexChar = /[0-9a-fA-F]/;
      const pcStrLen = pcStr.length;
      utf8Str = "";
      for (let i = 0; i < pcStr.length; i++) {
        let wasPercentEncoded = false;
        if (pcStr[i] === "%") {
          if (i <= pcStrLen - 6 && pcStr[i + 1] === "u" && isHexChar.test(pcStr[i + 2]) && isHexChar.test(pcStr[i + 3]) && isHexChar.test(pcStr[i + 4]) && isHexChar.test(pcStr[i + 5])) {
            const charCode = parseInt(pcStr.substring(i + 1, i + 6), 16);
            utf8Str += String.fromCharCode(charCode);
            wasPercentEncoded = true;
            i += 5;
          } else if (i <= pcStrLen - 3 && isHexChar.test(pcStr[i + 1]) && isHexChar.test(pcStr[i + 2])) {
            const charCode = parseInt(pcStr.substring(i + 1, i + 3), 16);
            utf8Str += String.fromCharCode(charCode);
            wasPercentEncoded = true;
            i += 2;
          }
        }
        if (!wasPercentEncoded) {
          utf8Str += pcStr[i];
        }
      }
    }
    const res = new Uint8Array(utf8Str.length);
    for (let i = 0; i < utf8Str.length; i++) {
      res[i] = utf8Str.charCodeAt(i) & 255;
    }
    return res;
  }
  function stringFromCharCodes(args) {
    const max = 16e3;
    let ret = "";
    for (let i = 0; i < args.length; i += max) {
      const subArray = args.subarray(i, i + max);
      ret += String.fromCharCode.apply(null, subArray);
    }
    return ret;
  }
  function intToHex(num, size) {
    const toStr = num.toString(16);
    return toStr.length >= size ? toStr : new Array(size - toStr.length + 1).join("0") + toStr;
  }
  function utf8ToStr(data2) {
    if (hasTextDecoder) {
      try {
        const decoder = new TextDecoder();
        return decoder.decode(data2);
      } catch (e) {
        const err = e instanceof Error ? e : "";
        log_default.warn(
          "Utils: could not use TextDecoder to parse UTF-8, fallbacking to another implementation",
          err
        );
      }
    }
    let uint8 = data2;
    if (uint8[0] === 239 && uint8[1] === 187 && uint8[2] === 191) {
      uint8 = uint8.subarray(3);
    }
    const utf8Str = stringFromCharCodes(uint8);
    let escaped;
    if (typeof escape === "function") {
      escaped = escape(utf8Str);
    } else {
      const nonEscapedChar = /[A-Za-z0-9*_\+-\.\/]/;
      escaped = "";
      for (let i = 0; i < utf8Str.length; i++) {
        if (nonEscapedChar.test(utf8Str[i])) {
          escaped += utf8Str[i];
        } else {
          const charCode = utf8Str.charCodeAt(i);
          escaped += charCode >= 256 ? "%u" + intToHex(charCode, 4) : "%" + intToHex(charCode, 2);
        }
      }
    }
    return decodeURIComponent(escaped);
  }
  function hexToBytes(str) {
    const len = str.length;
    const arr = new Uint8Array(len / 2);
    for (let i = 0, j = 0; i < len; i += 2, j++) {
      arr[j] = parseInt(str.substring(i, i + 2), 16) & 255;
    }
    return arr;
  }
  function bytesToHex(bytes, sep = "") {
    let hex = "";
    for (let i = 0; i < bytes.byteLength; i++) {
      hex += (bytes[i] >>> 4).toString(16);
      hex += (bytes[i] & 15).toString(16);
      if (sep.length > 0 && i < bytes.byteLength - 1) {
        hex += sep;
      }
    }
    return hex;
  }
  function guidToUuid(guid) {
    assert(guid.length === 16, "GUID length should be 16");
    const p1A = guid[0];
    const p1B = guid[1];
    const p1C = guid[2];
    const p1D = guid[3];
    const p2A = guid[4];
    const p2B = guid[5];
    const p3A = guid[6];
    const p3B = guid[7];
    const uuid = new Uint8Array(16);
    uuid[0] = p1D;
    uuid[1] = p1C;
    uuid[2] = p1B;
    uuid[3] = p1A;
    uuid[4] = p2B;
    uuid[5] = p2A;
    uuid[6] = p3B;
    uuid[7] = p3A;
    uuid.set(guid.subarray(8, 16), 8);
    return uuid;
  }
  function readNullTerminatedString(buffer, offset) {
    let position = offset;
    while (position < buffer.length) {
      const value = buffer[position];
      if (value === 0) {
        break;
      }
      position += 1;
    }
    const bytes = buffer.subarray(offset, position);
    return { end: position + 1, string: utf8ToStr(bytes) };
  }

  // src/compat/eme/custom_media_keys/old_webkit_media_keys.ts
  function isOldWebkitMediaElement(element) {
    return typeof (element == null ? void 0 : element.webkitGenerateKeyRequest) === "function";
  }
  var OldWebkitMediaKeySession = class extends EventEmitter {
    constructor(mediaElement, keySystem) {
      super();
      this._vid = mediaElement;
      this._key = keySystem;
      this.sessionId = "";
      this._closeSession = noop_default;
      this.keyStatuses = /* @__PURE__ */ new Map();
      this.expiration = NaN;
      const onSessionRelatedEvent = (evt) => {
        this.trigger(evt.type, evt);
      };
      this.closed = new Promise((resolve) => {
        this._closeSession = () => {
          ["keymessage", "message", "keyadded", "ready", "keyerror", "error"].forEach(
            (evt) => {
              mediaElement.removeEventListener(evt, onSessionRelatedEvent);
              mediaElement.removeEventListener(`webkit${evt}`, onSessionRelatedEvent);
            }
          );
          resolve();
        };
      });
      ["keymessage", "message", "keyadded", "ready", "keyerror", "error"].forEach((evt) => {
        mediaElement.addEventListener(evt, onSessionRelatedEvent);
        mediaElement.addEventListener(`webkit${evt}`, onSessionRelatedEvent);
      });
    }
    update(license) {
      return new Promise((resolve, reject) => {
        try {
          if (this._key.indexOf("clearkey") >= 0) {
            const licenseTypedArray = license instanceof ArrayBuffer ? new Uint8Array(license) : license;
            const json = JSON.parse(utf8ToStr(licenseTypedArray));
            const key = base64ToBytes(json.keys[0].k);
            const kid = base64ToBytes(json.keys[0].kid);
            resolve(this._vid.webkitAddKey(
              this._key,
              key,
              kid,
              /* sessionId */
              ""
            ));
          } else {
            resolve(this._vid.webkitAddKey(
              this._key,
              license,
              null,
              /* sessionId */
              ""
            ));
          }
        } catch (err) {
          reject(err);
        }
      });
    }
    generateRequest(_initDataType, initData) {
      return new Promise((resolve) => {
        this._vid.webkitGenerateKeyRequest(this._key, initData);
        resolve();
      });
    }
    close() {
      return new Promise((resolve) => {
        this._closeSession();
        resolve();
      });
    }
    /**
     * Load a Persistent MediaKeySession.
     * Do nothing here because this implementation doesn't handle them.
     * @returns {Promise.<boolean>}
     */
    load() {
      return Promise.resolve(false);
    }
    remove() {
      return Promise.resolve();
    }
  };
  var OldWebKitCustomMediaKeys = class {
    constructor(keySystem) {
      this._keySystem = keySystem;
    }
    _setVideo(videoElement) {
      return wrapInPromise(() => {
        if (!isOldWebkitMediaElement(videoElement)) {
          throw new Error("Video not attached to the MediaKeys");
        }
        this._videoElement = videoElement;
      });
    }
    createSession() {
      if (isNullOrUndefined(this._videoElement)) {
        throw new Error("Video not attached to the MediaKeys");
      }
      return new OldWebkitMediaKeySession(this._videoElement, this._keySystem);
    }
    setServerCertificate() {
      throw new Error("Server certificate is not implemented in your browser");
    }
  };
  function getOldWebKitMediaKeysCallbacks() {
    const isTypeSupported = function(keyType) {
      let videoElement = document.querySelector("video");
      if (isNullOrUndefined(videoElement)) {
        videoElement = document.createElement("video");
      }
      if (!isNullOrUndefined(videoElement) && typeof videoElement.canPlayType === "function") {
        return !!videoElement.canPlayType("video/mp4", keyType);
      } else {
        return false;
      }
    };
    const createCustomMediaKeys = (keyType) => new OldWebKitCustomMediaKeys(keyType);
    const setMediaKeys2 = (elt, mediaKeys) => {
      if (mediaKeys === null) {
        return Promise.resolve(void 0);
      }
      if (!(mediaKeys instanceof OldWebKitCustomMediaKeys)) {
        throw new Error(
          "Custom setMediaKeys is supposed to be called with old webkit custom MediaKeys."
        );
      }
      return mediaKeys._setVideo(elt);
    };
    return {
      isTypeSupported,
      createCustomMediaKeys,
      setMediaKeys: setMediaKeys2
    };
  }

  // src/compat/eme/custom_media_keys/webkit_media_keys.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/utils/starts_with.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function startsWith(completeString, searchString, position) {
    if (typeof String.prototype.startsWith === "function") {
      return completeString.startsWith(searchString, position);
    }
    const initialPosition = typeof position === "number" ? Math.max(position, 0) : 0;
    return completeString.substring(initialPosition, initialPosition + searchString.length) === searchString;
  }

  // src/compat/eme/get_webkit_fairplay_initdata.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/utils/byte_parsing.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function concat(...args) {
    const l = args.length;
    let i = -1;
    let len = 0;
    let arg;
    while (++i < l) {
      arg = args[i];
      len += typeof arg === "number" ? arg : arg.length;
    }
    const arr = new Uint8Array(len);
    let offset = 0;
    i = -1;
    while (++i < l) {
      arg = args[i];
      if (typeof arg === "number") {
        offset += arg;
      } else if (arg.length > 0) {
        arr.set(arg, offset);
        offset += arg.length;
      }
    }
    return arr;
  }
  function be2toi(bytes, offset) {
    return (bytes[offset + 0] << 8) + (bytes[offset + 1] << 0);
  }
  function be3toi(bytes, offset) {
    return bytes[offset + 0] * 65536 + bytes[offset + 1] * 256 + bytes[offset + 2];
  }
  function be4toi(bytes, offset) {
    return bytes[offset + 0] * 16777216 + bytes[offset + 1] * 65536 + bytes[offset + 2] * 256 + bytes[offset + 3];
  }
  function be8toi(bytes, offset) {
    return (bytes[offset + 0] * 16777216 + bytes[offset + 1] * 65536 + bytes[offset + 2] * 256 + bytes[offset + 3]) * 4294967296 + bytes[offset + 4] * 16777216 + bytes[offset + 5] * 65536 + bytes[offset + 6] * 256 + bytes[offset + 7];
  }
  function itobe2(num) {
    return new Uint8Array([num >>> 8 & 255, num & 255]);
  }
  function itobe4(num) {
    return new Uint8Array([
      num >>> 24 & 255,
      num >>> 16 & 255,
      num >>> 8 & 255,
      num & 255
    ]);
  }
  function itobe8(num) {
    const l = num % 4294967296;
    const h = (num - l) / 4294967296;
    return new Uint8Array([
      h >>> 24 & 255,
      h >>> 16 & 255,
      h >>> 8 & 255,
      h & 255,
      l >>> 24 & 255,
      l >>> 16 & 255,
      l >>> 8 & 255,
      l & 255
    ]);
  }
  function le2toi(bytes, offset) {
    return (bytes[offset + 0] << 0) + (bytes[offset + 1] << 8);
  }
  function le4toi(bytes, offset) {
    return bytes[offset + 0] + bytes[offset + 1] * 256 + bytes[offset + 2] * 65536 + bytes[offset + 3] * 16777216;
  }
  function itole2(num) {
    return new Uint8Array([num & 255, num >>> 8 & 255]);
  }
  function itole4(num) {
    return new Uint8Array([
      num & 255,
      num >>> 8 & 255,
      num >>> 16 & 255,
      num >>> 24 & 255
    ]);
  }

  // src/compat/eme/get_webkit_fairplay_initdata.ts
  function getWebKitFairPlayInitData(initDataBytes, serverCertificateBytes) {
    const initData = initDataBytes instanceof Uint8Array ? initDataBytes : new Uint8Array(initDataBytes);
    const serverCertificate = serverCertificateBytes instanceof Uint8Array ? serverCertificateBytes : new Uint8Array(serverCertificateBytes);
    const length = le4toi(initData, 0);
    if (length + 4 !== initData.length) {
      throw new Error("Unsupported WebKit initData.");
    }
    const initDataUri = utf16LEToStr(initData);
    const skdIndexInInitData = initDataUri.indexOf("skd://");
    const contentIdStr = skdIndexInInitData > -1 ? initDataUri.substring(skdIndexInInitData + 6) : initDataUri;
    const id = strToUtf16LE(contentIdStr);
    let offset = 0;
    const res = new Uint8Array(
      initData.byteLength + /* id length */
      4 + id.byteLength + /* certificate length */
      4 + serverCertificate.byteLength
    );
    res.set(initData);
    offset += initData.length;
    res.set(itole4(id.byteLength), offset);
    offset += 4;
    res.set(id, offset);
    offset += id.byteLength;
    res.set(itole4(serverCertificate.byteLength), offset);
    offset += 4;
    res.set(serverCertificate, offset);
    return res;
  }

  // src/compat/eme/custom_media_keys/webkit_media_keys.ts
  function isFairplayKeyType(keyType) {
    return startsWith(keyType, "com.apple.fps");
  }
  function setWebKitMediaKeys(elt, mediaKeys) {
    return wrapInPromise(() => {
      if (elt.webkitSetMediaKeys === void 0) {
        throw new Error("No webKitMediaKeys API.");
      }
      elt.webkitSetMediaKeys(mediaKeys);
    });
  }
  var WebkitMediaKeySession = class extends EventEmitter {
    /**
     * @param {HTMLMediaElement} mediaElement
     * @param {string} keyType
     * @param {Uint8Array | undefined} serverCertificate
     */
    constructor(mediaElement, keyType, serverCertificate) {
      super();
      this._serverCertificate = serverCertificate;
      this._videoElement = mediaElement;
      this._keyType = keyType;
      this._unbindSession = noop_default;
      this._closeSession = noop_default;
      this.closed = new Promise((resolve) => {
        this._closeSession = resolve;
      });
      this.keyStatuses = /* @__PURE__ */ new Map();
      this.expiration = NaN;
    }
    update(license) {
      return new Promise((resolve, reject) => {
        if (this._nativeSession === void 0 || this._nativeSession.update === void 0 || typeof this._nativeSession.update !== "function") {
          return reject("Unavailable WebKit key session.");
        }
        try {
          let uInt8Arraylicense;
          if (license instanceof ArrayBuffer) {
            uInt8Arraylicense = new Uint8Array(license);
          } else if (license instanceof Uint8Array) {
            uInt8Arraylicense = license;
          } else {
            uInt8Arraylicense = new Uint8Array(license.buffer);
          }
          resolve(this._nativeSession.update(uInt8Arraylicense));
        } catch (err) {
          reject(err);
        }
      });
    }
    generateRequest(_initDataType, initData) {
      return new Promise((resolve) => {
        var _a;
        const elt = this._videoElement;
        if (((_a = elt.webkitKeys) == null ? void 0 : _a.createSession) === void 0) {
          throw new Error("No WebKitMediaKeys API.");
        }
        let formattedInitData;
        if (isFairplayKeyType(this._keyType)) {
          if (this._serverCertificate === void 0) {
            throw new Error(
              "A server certificate is needed for creating fairplay session."
            );
          }
          formattedInitData = getWebKitFairPlayInitData(initData, this._serverCertificate);
        } else {
          formattedInitData = initData;
        }
        const keySession = elt.webkitKeys.createSession("video/mp4", formattedInitData);
        if (keySession === void 0 || keySession === null) {
          throw new Error("Impossible to get the key sessions");
        }
        this._listenEvent(keySession);
        this._nativeSession = keySession;
        resolve();
      });
    }
    close() {
      return new Promise((resolve, reject) => {
        this._unbindSession();
        this._closeSession();
        if (this._nativeSession === void 0) {
          reject("No session to close.");
          return;
        }
        this._nativeSession.close();
        resolve();
      });
    }
    load() {
      return Promise.resolve(false);
    }
    remove() {
      return Promise.resolve();
    }
    get sessionId() {
      var _a, _b;
      return (_b = (_a = this._nativeSession) == null ? void 0 : _a.sessionId) != null ? _b : "";
    }
    _listenEvent(session) {
      this._unbindSession();
      const onEvent2 = (evt) => {
        this.trigger(evt.type, evt);
      };
      ["keymessage", "message", "keyadded", "ready", "keyerror", "error"].forEach((evt) => {
        session.addEventListener(evt, onEvent2);
        session.addEventListener(`webkit${evt}`, onEvent2);
      });
      this._unbindSession = () => {
        ["keymessage", "message", "keyadded", "ready", "keyerror", "error"].forEach(
          (evt) => {
            session.removeEventListener(evt, onEvent2);
            session.removeEventListener(`webkit${evt}`, onEvent2);
          }
        );
      };
    }
  };
  var WebKitCustomMediaKeys = class {
    constructor(keyType) {
      if (WebKitMediaKeysConstructor === void 0) {
        throw new Error("No WebKitMediaKeys API.");
      }
      this._keyType = keyType;
      this._mediaKeys = new WebKitMediaKeysConstructor(keyType);
    }
    _setVideo(videoElement) {
      this._videoElement = videoElement;
      if (this._videoElement === void 0) {
        throw new Error("Video not attached to the MediaKeys");
      }
      return setWebKitMediaKeys(this._videoElement, this._mediaKeys);
    }
    createSession() {
      if (this._videoElement === void 0 || this._mediaKeys === void 0) {
        throw new Error("Video not attached to the MediaKeys");
      }
      return new WebkitMediaKeySession(
        this._videoElement,
        this._keyType,
        this._serverCertificate
      );
    }
    setServerCertificate(serverCertificate) {
      this._serverCertificate = serverCertificate;
      return Promise.resolve();
    }
  };
  function getWebKitMediaKeysCallbacks() {
    if (WebKitMediaKeysConstructor === void 0) {
      throw new Error("No WebKitMediaKeys API.");
    }
    const isTypeSupported = WebKitMediaKeysConstructor.isTypeSupported;
    const createCustomMediaKeys = (keyType) => new WebKitCustomMediaKeys(keyType);
    const setMediaKeys2 = (elt, mediaKeys) => {
      if (mediaKeys === null) {
        return setWebKitMediaKeys(elt, mediaKeys);
      }
      if (!(mediaKeys instanceof WebKitCustomMediaKeys)) {
        throw new Error(
          "Custom setMediaKeys is supposed to be called with webkit custom MediaKeys."
        );
      }
      return mediaKeys._setVideo(elt);
    };
    return {
      isTypeSupported,
      createCustomMediaKeys,
      setMediaKeys: setMediaKeys2
    };
  }

  // src/compat/eme/eme-api-implementation.ts
  var defaultEmeImplementation = getEmeApiImplementation("auto");
  var eme_api_implementation_default = defaultEmeImplementation;
  function getEmeApiImplementation(preferredApiType) {
    var _a;
    let requestMediaKeySystemAccess;
    let onEncrypted;
    let setMediaKeys2 = defaultSetMediaKeys;
    let implementation;
    if ((preferredApiType === "standard" || preferredApiType === "auto" && !shouldFavourCustomSafariEME()) && // eslint-disable-next-line @typescript-eslint/unbound-method
    (is_node_default || !isNullOrUndefined(navigator.requestMediaKeySystemAccess))) {
      requestMediaKeySystemAccess = (...args) => navigator.requestMediaKeySystemAccess(...args);
      onEncrypted = createCompatibleEventListener(["encrypted"]);
      implementation = "standard";
    } else {
      let isTypeSupported;
      let createCustomMediaKeys;
      if (preferredApiType === "webkit" && WebKitMediaKeysConstructor !== void 0) {
        const callbacks = getWebKitMediaKeysCallbacks();
        onEncrypted = createOnEncryptedForWebkit();
        isTypeSupported = callbacks.isTypeSupported;
        createCustomMediaKeys = callbacks.createCustomMediaKeys;
        setMediaKeys2 = callbacks.setMediaKeys;
        implementation = "webkit";
      } else {
        if (isOldWebkitMediaElement((_a = global_scope_default.HTMLVideoElement) == null ? void 0 : _a.prototype)) {
          onEncrypted = createCompatibleEventListener(["needkey"]);
          const callbacks = getOldWebKitMediaKeysCallbacks();
          isTypeSupported = callbacks.isTypeSupported;
          createCustomMediaKeys = callbacks.createCustomMediaKeys;
          setMediaKeys2 = callbacks.setMediaKeys;
          implementation = "older-webkit";
        } else if (WebKitMediaKeysConstructor !== void 0) {
          onEncrypted = createOnEncryptedForWebkit();
          const callbacks = getWebKitMediaKeysCallbacks();
          isTypeSupported = callbacks.isTypeSupported;
          createCustomMediaKeys = callbacks.createCustomMediaKeys;
          setMediaKeys2 = callbacks.setMediaKeys;
          implementation = "webkit";
        } else if (isIE11 && MSMediaKeysConstructor !== void 0) {
          onEncrypted = createCompatibleEventListener(["encrypted", "needkey"]);
          const callbacks = getIE11MediaKeysCallbacks();
          isTypeSupported = callbacks.isTypeSupported;
          createCustomMediaKeys = callbacks.createCustomMediaKeys;
          setMediaKeys2 = callbacks.setMediaKeys;
          implementation = "ms";
        } else if (MozMediaKeysConstructor !== void 0) {
          onEncrypted = createCompatibleEventListener(["encrypted", "needkey"]);
          const callbacks = getMozMediaKeysCallbacks();
          isTypeSupported = callbacks.isTypeSupported;
          createCustomMediaKeys = callbacks.createCustomMediaKeys;
          setMediaKeys2 = callbacks.setMediaKeys;
          implementation = "moz";
        } else {
          onEncrypted = createCompatibleEventListener(["encrypted", "needkey"]);
          const MK = global_scope_default.MediaKeys;
          const checkForStandardMediaKeys = () => {
            if (MK === void 0) {
              throw new MediaError(
                "MEDIA_KEYS_NOT_SUPPORTED",
                "No `MediaKeys` implementation found in the current browser."
              );
            }
            if (typeof MK.isTypeSupported === "undefined") {
              const message = "This browser seems to be unable to play encrypted contents currently.Note: Some browsers do not allow decryption in some situations, like when not using HTTPS.";
              throw new Error(message);
            }
          };
          isTypeSupported = (keyType) => {
            checkForStandardMediaKeys();
            assert(typeof MK.isTypeSupported === "function");
            return MK.isTypeSupported(keyType);
          };
          createCustomMediaKeys = (keyType) => {
            checkForStandardMediaKeys();
            return new MK(keyType);
          };
          implementation = "unknown";
        }
      }
      requestMediaKeySystemAccess = function(keyType, keySystemConfigurations) {
        if (!isTypeSupported(keyType)) {
          return Promise.reject(new Error("Unsupported key type"));
        }
        for (let i = 0; i < keySystemConfigurations.length; i++) {
          const keySystemConfiguration = keySystemConfigurations[i];
          const {
            videoCapabilities,
            audioCapabilities,
            initDataTypes,
            distinctiveIdentifier
          } = keySystemConfiguration;
          let supported = true;
          supported = supported && (isNullOrUndefined(initDataTypes) || initDataTypes.some((idt) => idt === "cenc"));
          supported = supported && distinctiveIdentifier !== "required";
          if (supported) {
            const keySystemConfigurationResponse = {
              initDataTypes: ["cenc"],
              distinctiveIdentifier: "not-allowed",
              persistentState: "required",
              sessionTypes: ["temporary", "persistent-license"]
            };
            if (videoCapabilities !== void 0) {
              keySystemConfigurationResponse.videoCapabilities = videoCapabilities;
            }
            if (audioCapabilities !== void 0) {
              keySystemConfigurationResponse.audioCapabilities = audioCapabilities;
            }
            const customMediaKeys = createCustomMediaKeys(keyType);
            return Promise.resolve(
              new CustomMediaKeySystemAccess(
                keyType,
                customMediaKeys,
                keySystemConfigurationResponse
              )
            );
          }
        }
        return Promise.reject(new Error("Unsupported configuration"));
      };
    }
    return {
      requestMediaKeySystemAccess,
      onEncrypted,
      setMediaKeys: setMediaKeys2,
      implementation
    };
  }
  function createOnEncryptedForWebkit() {
    const compatibleEventListener = createCompatibleEventListener(
      ["needkey"],
      void 0
    );
    const onEncrypted = (target, listener, cancelSignal) => {
      compatibleEventListener(
        target,
        (event) => {
          const patchedEvent = object_assign_default(event, {
            forceSessionRecreation: true
          });
          listener(patchedEvent);
        },
        cancelSignal
      );
    };
    return onEncrypted;
  }
  function defaultSetMediaKeys(elt, mediaKeys) {
    try {
      let ret;
      if (typeof elt.setMediaKeys === "function") {
        ret = elt.setMediaKeys(mediaKeys);
      } else if (typeof elt.webkitSetMediaKeys === "function") {
        ret = elt.webkitSetMediaKeys(mediaKeys);
      } else if (typeof elt.mozSetMediaKeys === "function") {
        ret = elt.mozSetMediaKeys(mediaKeys);
      } else if (typeof elt.msSetMediaKeys === "function" && mediaKeys !== null) {
        ret = elt.msSetMediaKeys(mediaKeys);
      }
      if (typeof ret === "object" && ret !== null && typeof ret.then === "function") {
        return ret;
      } else {
        return Promise.resolve(ret);
      }
    } catch (err) {
      return Promise.reject(err);
    }
  }

  // src/compat/eme/generate_key_request.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/parsers/containers/isobmff/index.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/parsers/containers/isobmff/extract_complete_chunks.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/parsers/containers/isobmff/find_complete_box.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function findCompleteBox(buf, wantedName) {
    const len = buf.length;
    let i = 0;
    while (i + 8 <= len) {
      let size = be4toi(buf, i);
      if (size === 0) {
        size = len - i;
      } else if (size === 1) {
        if (i + 16 > len) {
          return -1;
        }
        size = be8toi(buf, i + 8);
      }
      if (isNaN(size) || size <= 0) {
        return -1;
      }
      const name2 = be4toi(buf, i + 4);
      if (name2 === wantedName) {
        if (i + size <= len) {
          return i;
        }
        return -1;
      }
      i += size;
    }
    return -1;
  }

  // src/parsers/containers/isobmff/extract_complete_chunks.ts
  function extractCompleteChunks(buffer) {
    let _position = 0;
    const chunks = [];
    let currentBuffer = null;
    while (_position <= buffer.length) {
      if (_position === buffer.length) {
        currentBuffer = null;
        break;
      }
      currentBuffer = buffer.subarray(_position, Infinity);
      const moofIndex = findCompleteBox(
        currentBuffer,
        1836019558
        /* moof */
      );
      if (moofIndex < 0) {
        break;
      }
      const moofLen = be4toi(buffer, moofIndex + _position);
      const moofEnd = _position + moofIndex + moofLen;
      if (moofEnd > buffer.length) {
        break;
      }
      const mdatIndex = findCompleteBox(
        currentBuffer,
        1835295092
        /* mdat */
      );
      if (mdatIndex < 0) {
        break;
      }
      const mdatLen = be4toi(buffer, mdatIndex + _position);
      const mdatEnd = _position + mdatIndex + mdatLen;
      if (mdatEnd > buffer.length) {
        break;
      }
      const maxEnd = Math.max(moofEnd, mdatEnd);
      const chunk = buffer.subarray(_position, maxEnd);
      chunks.push(chunk);
      _position = maxEnd;
    }
    if (chunks.length === 0) {
      return [null, currentBuffer];
    }
    return [chunks, currentBuffer];
  }

  // src/parsers/containers/isobmff/take_pssh_out.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/utils/slice_uint8array.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function arraySlice(arr, start, end) {
    return new Uint8Array(Array.prototype.slice.call(arr, start, end));
  }
  function uint8ArraySlice(arr, start, end) {
    return arr.slice(start, end);
  }
  var slice_uint8array_default = typeof Uint8Array.prototype.slice === "function" ? uint8ArraySlice : arraySlice;

  // src/parsers/containers/isobmff/get_box.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function getChildBox(buf, childNames) {
    let currBox = buf;
    for (const childName of childNames) {
      const box = getBoxContent(currBox, childName);
      if (box === null) {
        return null;
      }
      currBox = box;
    }
    return currBox;
  }
  function getBoxContent(buf, boxName2) {
    const offsets = getBoxOffsets(buf, boxName2);
    return offsets !== null ? buf.subarray(offsets[1], offsets[2]) : null;
  }
  function getBoxesContent(buf, boxName2) {
    const ret = [];
    let currentBuf = buf;
    while (true) {
      const offsets = getBoxOffsets(currentBuf, boxName2);
      if (offsets === null) {
        return ret;
      }
      assert(offsets[2] !== 0 && currentBuf.length !== 0);
      ret.push(currentBuf.subarray(offsets[1], offsets[2]));
      currentBuf = currentBuf.subarray(offsets[2]);
    }
  }
  function getBox(buf, boxName2) {
    const offsets = getBoxOffsets(buf, boxName2);
    return offsets !== null ? buf.subarray(offsets[0], offsets[2]) : null;
  }
  function getBoxOffsets(buf, boxName2) {
    const len = buf.length;
    let boxBaseOffset = 0;
    let name2;
    let lastBoxSize = 0;
    let lastOffset;
    while (boxBaseOffset + 8 <= len) {
      lastOffset = boxBaseOffset;
      lastBoxSize = be4toi(buf, lastOffset);
      lastOffset += 4;
      name2 = be4toi(buf, lastOffset);
      lastOffset += 4;
      if (lastBoxSize === 0) {
        lastBoxSize = len - boxBaseOffset;
      } else if (lastBoxSize === 1) {
        if (lastOffset + 8 > len) {
          return null;
        }
        lastBoxSize = be8toi(buf, lastOffset);
        lastOffset += 8;
      }
      if (lastBoxSize < 0) {
        throw new Error("ISOBMFF: Size out of range");
      }
      if (name2 === boxName2) {
        if (boxName2 === 1970628964) {
          lastOffset += 16;
        }
        return [boxBaseOffset, lastOffset, boxBaseOffset + lastBoxSize];
      } else {
        boxBaseOffset += lastBoxSize;
      }
    }
    return null;
  }
  function getUuidContent(buf, id1, id2, id3, id4) {
    const len = buf.length;
    let boxSize;
    for (let boxBaseOffset = 0; boxBaseOffset < len; boxBaseOffset += boxSize) {
      let currentOffset = boxBaseOffset;
      boxSize = be4toi(buf, currentOffset);
      currentOffset += 4;
      const boxName2 = be4toi(buf, currentOffset);
      currentOffset += 4;
      if (boxSize === 0) {
        boxSize = len - boxBaseOffset;
      } else if (boxSize === 1) {
        if (currentOffset + 8 > len) {
          return void 0;
        }
        boxSize = be8toi(buf, currentOffset);
        currentOffset += 8;
      }
      if (boxName2 === 1970628964 && currentOffset + 16 <= len && be4toi(buf, currentOffset) === id1 && be4toi(buf, currentOffset + 4) === id2 && be4toi(buf, currentOffset + 8) === id3 && be4toi(buf, currentOffset + 12) === id4) {
        currentOffset += 16;
        return buf.subarray(currentOffset, boxBaseOffset + boxSize);
      }
    }
  }
  function getNextBoxOffsets(buf) {
    const len = buf.length;
    if (len < 8) {
      log_default.warn("ISOBMFF: box inferior to 8 bytes, cannot find offsets");
      return null;
    }
    let lastOffset = 0;
    let boxSize = be4toi(buf, lastOffset);
    lastOffset += 4;
    const name2 = be4toi(buf, lastOffset);
    lastOffset += 4;
    if (boxSize === 0) {
      boxSize = len;
    } else if (boxSize === 1) {
      if (lastOffset + 8 > len) {
        log_default.warn("ISOBMFF: box too short, cannot find offsets");
        return null;
      }
      boxSize = be8toi(buf, lastOffset);
      lastOffset += 8;
    }
    if (boxSize < 0) {
      throw new Error("ISOBMFF: Size out of range");
    }
    if (name2 === 1970628964) {
      lastOffset += 16;
    }
    return [0, lastOffset, boxSize];
  }

  // src/parsers/containers/isobmff/take_pssh_out.ts
  function takePSSHOut(data2) {
    let i = 0;
    const moov = getBoxContent(
      data2,
      1836019574
      /* moov */
    );
    if (moov === null) {
      return [];
    }
    const psshBoxes = [];
    while (i < moov.length) {
      let psshOffsets;
      try {
        psshOffsets = getBoxOffsets(
          moov,
          1886614376
          /* pssh */
        );
      } catch (e) {
        const err = e instanceof Error ? e : "";
        log_default.warn("Error while removing PSSH from ISOBMFF", err);
        return psshBoxes;
      }
      if (psshOffsets === null) {
        return psshBoxes;
      }
      const pssh = slice_uint8array_default(moov, psshOffsets[0], psshOffsets[2]);
      const systemId = getPsshSystemID(pssh, psshOffsets[1] - psshOffsets[0]);
      if (systemId !== void 0) {
        psshBoxes.push({ systemId, data: pssh });
      }
      moov[psshOffsets[0] + 4] = 102;
      moov[psshOffsets[0] + 5] = 114;
      moov[psshOffsets[0] + 6] = 101;
      moov[psshOffsets[0] + 7] = 101;
      i = psshOffsets[2];
    }
    return psshBoxes;
  }
  function getPsshSystemID(buff, initialDataOffset) {
    if (buff[initialDataOffset] > 1) {
      log_default.warn("ISOBMFF: un-handled PSSH version");
      return void 0;
    }
    const offset = initialDataOffset + 4;
    if (offset + 16 > buff.length) {
      return void 0;
    }
    const systemIDBytes = slice_uint8array_default(buff, offset, offset + 16);
    return bytesToHex(systemIDBytes);
  }

  // src/parsers/containers/isobmff/create_box.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/parsers/containers/isobmff/constants.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var MAX_32_BIT_INT = Math.pow(2, 32) - 1;

  // src/parsers/containers/isobmff/create_box.ts
  var boxNamesMem = {};
  function boxName(str) {
    if (boxNamesMem[str] !== void 0) {
      return boxNamesMem[str];
    }
    const nameInBytes = strToUtf8(str);
    boxNamesMem[str] = nameInBytes;
    return nameInBytes;
  }
  function createBox(name2, buff) {
    const len = buff.length + 8;
    return len <= MAX_32_BIT_INT ? concat(itobe4(len), boxName(name2), buff) : concat(itobe4(1), boxName(name2), itobe8(len + 8), buff);
  }
  function createBoxWithChildren(name2, children) {
    return createBox(name2, concat(...children));
  }

  // src/parsers/containers/isobmff/read.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function getTRAF(buffer) {
    const moof = getBoxContent(
      buffer,
      1836019558
      /* moof */
    );
    if (moof === null) {
      return null;
    }
    return getBoxContent(
      moof,
      1953653094
      /* traf */
    );
  }
  function getTRAFs(buffer) {
    const moofs = getBoxesContent(
      buffer,
      1836019558
      /* moof */
    );
    return moofs.reduce((acc, moof) => {
      const traf = getBoxContent(
        moof,
        1953653094
        /* traf */
      );
      if (traf !== null) {
        acc.push(traf);
      }
      return acc;
    }, []);
  }
  function getMDAT(buf) {
    return getBoxContent(
      buf,
      1835295092
      /* "mdat" */
    );
  }
  function getMDIA(buf) {
    const moov = getBoxContent(
      buf,
      1836019574
      /* moov */
    );
    if (moov === null) {
      return null;
    }
    const trak = getBoxContent(
      moov,
      1953653099
      /* "trak" */
    );
    if (trak === null) {
      return null;
    }
    return getBoxContent(
      trak,
      1835297121
      /* "mdia" */
    );
  }
  function getEMSG(buffer, offset = 0) {
    return getBoxContent(
      buffer.subarray(offset),
      1701671783
      /* emsg */
    );
  }

  // src/parsers/containers/isobmff/utils.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/parsers/containers/isobmff/drm/index.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/parsers/containers/isobmff/drm/playready.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function getPlayReadyKIDFromPrivateData(data2) {
    const xmlLength = le2toi(data2, 8);
    const xml = utf16LEToStr(data2.subarray(10, xmlLength + 10));
    const doc = new DOMParser().parseFromString(xml, "application/xml");
    const kidElement = doc.querySelector("KID");
    if (kidElement === null) {
      throw new Error("Cannot parse PlayReady private data: invalid XML");
    }
    const b64guidKid = kidElement.textContent === null ? "" : kidElement.textContent;
    const uuidKid = guidToUuid(base64ToBytes(b64guidKid));
    return bytesToHex(uuidKid).toLowerCase();
  }

  // src/parsers/containers/isobmff/utils.ts
  function getSegmentsFromSidx(buf, sidxOffsetInWholeSegment) {
    const sidxOffsets = getBoxOffsets(
      buf,
      1936286840
      /* "sidx" */
    );
    if (sidxOffsets === null) {
      return null;
    }
    let offset = sidxOffsetInWholeSegment;
    const boxSize = sidxOffsets[2] - sidxOffsets[0];
    let cursor = sidxOffsets[1];
    const version2 = buf[cursor];
    cursor += 4 + 4;
    const timescale = be4toi(buf, cursor);
    cursor += 4;
    let time;
    if (version2 === 0) {
      time = be4toi(buf, cursor);
      cursor += 4;
      offset += be4toi(buf, cursor) + boxSize;
      cursor += 4;
    } else if (version2 === 1) {
      time = be8toi(buf, cursor);
      cursor += 8;
      offset += be8toi(buf, cursor) + boxSize;
      cursor += 8;
    } else {
      return null;
    }
    const segments = [];
    cursor += 2;
    let count = be2toi(buf, cursor);
    cursor += 2;
    while (--count >= 0) {
      const refChunk = be4toi(buf, cursor);
      cursor += 4;
      const refType = (refChunk & 2147483648) >>> 31;
      const refSize = refChunk & 2147483647;
      if (refType === 1) {
        throw new Error("sidx with reference_type `1` not yet implemented");
      }
      const duration = be4toi(buf, cursor);
      cursor += 4;
      cursor += 4;
      segments.push({
        time,
        duration,
        timescale,
        range: [offset, offset + refSize - 1]
      });
      time += duration;
      offset += refSize;
    }
    return segments;
  }
  function getTrackFragmentDecodeTime(buffer) {
    const traf = getTRAF(buffer);
    if (traf === null) {
      return void 0;
    }
    const tfdt = getBoxContent(
      traf,
      1952867444
      /* tfdt */
    );
    if (tfdt === null) {
      return void 0;
    }
    const version2 = tfdt[0];
    if (version2 === 1) {
      return be8toi(tfdt, 4);
    }
    if (version2 === 0) {
      return be4toi(tfdt, 4);
    }
    return void 0;
  }
  function getDefaultDurationFromTFHDInTRAF(traf) {
    const tfhd = getBoxContent(
      traf,
      1952868452
      /* tfhd */
    );
    if (tfhd === null) {
      return void 0;
    }
    let cursor = (
      /* version */
      1
    );
    const flags = be3toi(tfhd, cursor);
    cursor += 3;
    const hasBaseDataOffset = (flags & 1) > 0;
    const hasSampleDescriptionIndex = (flags & 2) > 0;
    const hasDefaultSampleDuration = (flags & 8) > 0;
    if (!hasDefaultSampleDuration) {
      return void 0;
    }
    cursor += 4;
    if (hasBaseDataOffset) {
      cursor += 8;
    }
    if (hasSampleDescriptionIndex) {
      cursor += 4;
    }
    const defaultDuration = be4toi(tfhd, cursor);
    return defaultDuration;
  }
  function getDurationFromTrun(buffer) {
    const trafs = getTRAFs(buffer);
    if (trafs.length === 0) {
      return void 0;
    }
    let completeDuration = 0;
    for (const traf of trafs) {
      const trun = getBoxContent(
        traf,
        1953658222
        /* trun */
      );
      if (trun === null) {
        return void 0;
      }
      let cursor = 0;
      const version2 = trun[cursor];
      cursor += 1;
      if (version2 > 1) {
        return void 0;
      }
      const flags = be3toi(trun, cursor);
      cursor += 3;
      const hasSampleDuration = (flags & 256) > 0;
      let defaultDuration = 0;
      if (!hasSampleDuration) {
        defaultDuration = getDefaultDurationFromTFHDInTRAF(traf);
        if (defaultDuration === void 0) {
          return void 0;
        }
      }
      const hasDataOffset = (flags & 1) > 0;
      const hasFirstSampleFlags = (flags & 4) > 0;
      const hasSampleSize = (flags & 512) > 0;
      const hasSampleFlags = (flags & 1024) > 0;
      const hasSampleCompositionOffset = (flags & 2048) > 0;
      const sampleCounts = be4toi(trun, cursor);
      cursor += 4;
      if (hasDataOffset) {
        cursor += 4;
      }
      if (hasFirstSampleFlags) {
        cursor += 4;
      }
      let i = sampleCounts;
      let duration = 0;
      while (i-- > 0) {
        if (hasSampleDuration) {
          duration += be4toi(trun, cursor);
          cursor += 4;
        } else {
          duration += defaultDuration;
        }
        if (hasSampleSize) {
          cursor += 4;
        }
        if (hasSampleFlags) {
          cursor += 4;
        }
        if (hasSampleCompositionOffset) {
          cursor += 4;
        }
      }
      completeDuration += duration;
    }
    return completeDuration;
  }
  function getMDHDTimescale(buffer) {
    const mdia = getMDIA(buffer);
    if (mdia === null) {
      return void 0;
    }
    const mdhd = getBoxContent(
      mdia,
      1835296868
      /* "mdhd" */
    );
    if (mdhd === null) {
      return void 0;
    }
    let cursor = 0;
    const version2 = mdhd[cursor];
    cursor += 4;
    if (version2 === 1) {
      return be4toi(mdhd, cursor + 16);
    } else if (version2 === 0) {
      return be4toi(mdhd, cursor + 8);
    }
    return void 0;
  }
  function updateBoxLength(buf) {
    const newLen = buf.length;
    if (newLen < 4) {
      throw new Error("Cannot update box length: box too short");
    }
    const oldSize = be4toi(buf, 0);
    if (oldSize === 0) {
      if (newLen > MAX_32_BIT_INT) {
        const newBox = new Uint8Array(newLen + 8);
        newBox.set(itobe4(1), 0);
        newBox.set(buf.subarray(4, 8), 4);
        newBox.set(itobe8(newLen + 8), 8);
        newBox.set(buf.subarray(8, newLen), 16);
        return newBox;
      } else {
        buf.set(itobe4(newLen), 0);
        return buf;
      }
    } else if (oldSize === 1) {
      if (newLen < 16) {
        throw new Error("Cannot update box length: box too short");
      }
      buf.set(itobe8(newLen), 8);
      return buf;
    } else if (newLen <= MAX_32_BIT_INT) {
      buf.set(itobe4(newLen), 0);
      return buf;
    } else {
      const newBox = new Uint8Array(newLen + 8);
      newBox.set(itobe4(1), 0);
      newBox.set(buf.subarray(4, 8), 4);
      newBox.set(itobe8(newLen + 8), 8);
      newBox.set(buf.subarray(8, newLen), 16);
      return newBox;
    }
  }
  function parseEmsgBoxes(buffer) {
    const emsgs = [];
    let offset = 0;
    while (offset < buffer.length) {
      const emsg = getEMSG(buffer, offset);
      if (emsg === null) {
        break;
      }
      const length = emsg.length;
      offset += length;
      const version2 = emsg[0];
      if (version2 !== 0) {
        log_default.warn("ISOBMFF: EMSG version " + version2.toString() + " not supported.");
      } else {
        let position = 4;
        const { end: schemeIdEnd, string: schemeIdUri } = readNullTerminatedString(
          emsg,
          position
        );
        position = schemeIdEnd;
        const { end: valueEnd, string: value } = readNullTerminatedString(emsg, position);
        position = valueEnd;
        const timescale = be4toi(emsg, position);
        position += 4;
        const presentationTimeDelta = be4toi(emsg, position);
        position += 4;
        const eventDuration = be4toi(emsg, position);
        position += 4;
        const id = be4toi(emsg, position);
        position += 4;
        const messageData = emsg.subarray(position, length);
        const emsgData = {
          schemeIdUri,
          value,
          timescale,
          presentationTimeDelta,
          eventDuration,
          id,
          messageData
        };
        emsgs.push(emsgData);
      }
    }
    if (emsgs.length === 0) {
      return void 0;
    }
    return emsgs;
  }
  function getKeyIdFromInitSegment(segment) {
    const stsd = getChildBox(
      segment,
      [
        1836019574,
        1953653099,
        1835297121,
        1835626086,
        1937007212,
        1937011556
      ]
    );
    if (stsd === null) {
      return null;
    }
    const stsdSubBoxes = stsd.subarray(8);
    let encBox = getBoxContent(
      stsdSubBoxes,
      1701733238
      /* encv */
    );
    let encContentOffset = 0;
    if (encBox === null) {
      encContentOffset = 8 + // sample entry header
      8 + // reserved
      2 + // channelcount
      2 + // samplesize
      2 + // predefined
      2 + // reserved
      4;
      encBox = getBoxContent(
        stsdSubBoxes,
        1701733217
        /* enca */
      );
    } else {
      encContentOffset = 8 + // sample entry header
      2 + 2 + 12 + // predefined + reserved + predefined
      2 + 2 + // width + height
      4 + 4 + // horizresolution + vertresolution
      4 + // reserved
      2 + // frame_count
      32 + 2 + // depth
      2;
    }
    if (encBox === null) {
      return null;
    }
    const tenc = getChildBox(
      encBox.subarray(encContentOffset),
      [
        1936289382,
        1935894633,
        1952804451
        /* tenc */
      ]
    );
    if (tenc === null || tenc.byteLength < 24) {
      return null;
    }
    const keyId = tenc.subarray(8, 24);
    return keyId.every((b) => b === 0) ? null : keyId;
  }

  // src/compat/eme/constants.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var PSSH_TO_INTEGER = be4toi(strToUtf8("pssh"), 0);

  // src/compat/eme/generate_key_request.ts
  function patchInitData(initData) {
    log_default.info("Compat: Trying to move CENC PSSH from init data at the end of it.");
    let foundCencV1 = false;
    let concatenatedCencs = new Uint8Array();
    let resInitData = new Uint8Array();
    let offset = 0;
    while (offset < initData.length) {
      if (initData.length < offset + 8 || be4toi(initData, offset + 4) !== PSSH_TO_INTEGER) {
        log_default.warn("Compat: unrecognized initialization data. Cannot patch it.");
        throw new Error("Compat: unrecognized initialization data. Cannot patch it.");
      }
      const len = be4toi(new Uint8Array(initData), offset);
      if (offset + len > initData.length) {
        log_default.warn("Compat: unrecognized initialization data. Cannot patch it.");
        throw new Error("Compat: unrecognized initialization data. Cannot patch it.");
      }
      const currentPSSH = initData.subarray(offset, offset + len);
      if (initData[offset + 12] === 16 && initData[offset + 13] === 119 && initData[offset + 14] === 239 && initData[offset + 15] === 236 && initData[offset + 16] === 192 && initData[offset + 17] === 178 && initData[offset + 18] === 77 && initData[offset + 19] === 2 && initData[offset + 20] === 172 && initData[offset + 21] === 227 && initData[offset + 22] === 60 && initData[offset + 23] === 30 && initData[offset + 24] === 82 && initData[offset + 25] === 226 && initData[offset + 26] === 251 && initData[offset + 27] === 75) {
        const cencOffsets = getNextBoxOffsets(currentPSSH);
        const version2 = cencOffsets === null ? void 0 : currentPSSH[cencOffsets[1]];
        log_default.info("Compat: CENC PSSH found with version", version2);
        if (version2 === void 0) {
          log_default.warn("Compat: could not read version of CENC PSSH");
        } else if (foundCencV1 === (version2 === 1)) {
          concatenatedCencs = concat(concatenatedCencs, currentPSSH);
        } else if (version2 === 1) {
          log_default.warn(
            "Compat: cenc version 1 encountered, removing every other cenc pssh box."
          );
          concatenatedCencs = currentPSSH;
          foundCencV1 = true;
        } else {
          log_default.warn("Compat: filtering out cenc pssh box with wrong version", version2);
        }
      } else {
        resInitData = concat(resInitData, currentPSSH);
      }
      offset += len;
    }
    if (offset !== initData.length) {
      log_default.warn("Compat: unrecognized initialization data. Cannot patch it.");
      throw new Error("Compat: unrecognized initialization data. Cannot patch it.");
    }
    return concat(resInitData, concatenatedCencs);
  }
  function generateKeyRequest(session, initializationDataType, initializationData) {
    log_default.debug("Compat: Calling generateRequest on the MediaKeySession");
    let patchedInit;
    try {
      patchedInit = patchInitData(initializationData);
    } catch (_e) {
      patchedInit = initializationData;
    }
    const initDataType = initializationDataType != null ? initializationDataType : "";
    return session.generateRequest(initDataType, patchedInit).catch((error) => {
      if (initDataType !== "" || !(error instanceof TypeError)) {
        throw error;
      }
      log_default.warn(
        'Compat: error while calling `generateRequest` with an empty initialization data type. Retrying with a default "cenc" value.',
        error
      );
      return session.generateRequest("cenc", patchedInit);
    });
  }

  // src/compat/eme/get_init_data.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function getInitializationDataValues(initData) {
    const result = [];
    let offset = 0;
    while (offset < initData.length) {
      if (initData.length < offset + 8 || be4toi(initData, offset + 4) !== PSSH_TO_INTEGER) {
        log_default.warn("Compat: Unrecognized initialization data. Use as is.");
        return [{ systemId: void 0, data: initData }];
      }
      const len = be4toi(new Uint8Array(initData), offset);
      if (offset + len > initData.length) {
        log_default.warn("Compat: Unrecognized initialization data. Use as is.");
        return [{ systemId: void 0, data: initData }];
      }
      const currentPSSH = initData.subarray(offset, offset + len);
      const systemId = getPsshSystemID(currentPSSH, 8);
      const currentItem = { systemId, data: currentPSSH };
      if (isPSSHAlreadyEncountered(result, currentItem)) {
        log_default.warn("Compat: Duplicated PSSH found in initialization data, removing it.");
      } else {
        result.push(currentItem);
      }
      offset += len;
    }
    if (offset !== initData.length) {
      log_default.warn("Compat: Unrecognized initialization data. Use as is.");
      return [{ systemId: void 0, data: initData }];
    }
    return result;
  }
  function isPSSHAlreadyEncountered(encounteredPSSHs, pssh) {
    for (let i = 0; i < encounteredPSSHs.length; i++) {
      const item = encounteredPSSHs[i];
      if (pssh.systemId === void 0 || item.systemId === void 0 || pssh.systemId === item.systemId) {
        if (areArraysOfNumbersEqual(pssh.data, item.data)) {
          return true;
        }
      }
    }
    return false;
  }
  function getInitData(encryptedEvent) {
    const { initData, initDataType, forceSessionRecreation } = encryptedEvent;
    if (isNullOrUndefined(initData)) {
      log_default.warn("Compat: No init data found on media encrypted event.");
      return null;
    }
    const initDataBytes = new Uint8Array(initData);
    const values = getInitializationDataValues(initDataBytes);
    return { type: initDataType, values, forceSessionRecreation };
  }

  // src/compat/eme/load_session.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var EME_WAITING_DELAY_LOADED_SESSION_EMPTY_KEYSTATUSES = 100;
  async function loadSession(session, sessionId) {
    log_default.info("DRM: Load persisted session", sessionId);
    const isLoaded = await session.load(sessionId);
    if (!isLoaded || session.keyStatuses.size > 0) {
      return isLoaded;
    }
    return new Promise((resolve) => {
      session.addEventListener(
        "keystatuseschange",
        resolveWithLoadedStatus
      );
      const timeout = setTimeout(
        resolveWithLoadedStatus,
        EME_WAITING_DELAY_LOADED_SESSION_EMPTY_KEYSTATUSES
      );
      function resolveWithLoadedStatus() {
        cleanUp();
        resolve(isLoaded);
      }
      function cleanUp() {
        clearTimeout(timeout);
        session.removeEventListener(
          "keystatuseschange",
          resolveWithLoadedStatus
        );
      }
    });
  }

  // src/compat/eme/index.ts
  var eme_default = eme_api_implementation_default;

  // src/utils/array_includes.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function arrayIncludes(arr, searchElement, fromIndex) {
    if (typeof Array.prototype.includes === "function") {
      return arr.includes(searchElement, fromIndex);
    }
    const len = arr.length >>> 0;
    if (len === 0) {
      return false;
    }
    const n = fromIndex | 0;
    let k = n >= 0 ? Math.min(n, len - 1) : Math.max(len + n, 0);
    const areTheSame = (x, y) => x === y || // Viva las JavaScriptas!
    typeof x === "number" && typeof y === "number" && isNaN(x) && isNaN(y);
    while (k < len) {
      if (areTheSame(arr[k], searchElement)) {
        return true;
      }
      k++;
    }
    return false;
  }

  // src/utils/object_values.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function objectValues(o) {
    return Object.keys(o).map((k) => o[k]);
  }
  var object_values_default = typeof Object.values === "function" ? Object.values : objectValues;

  // src/main_thread/decrypt/attach_media_keys.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function disableMediaKeys(mediaElement) {
    var _a;
    const previousState = media_keys_infos_store_default.getState(mediaElement);
    media_keys_infos_store_default.setState(mediaElement, null);
    return setMediaKeys((_a = previousState == null ? void 0 : previousState.emeImplementation) != null ? _a : eme_default, mediaElement, null);
  }
  async function attachMediaKeys(mediaElement, {
    emeImplementation,
    keySystemOptions,
    askedConfiguration,
    loadedSessionsStore,
    mediaKeySystemAccess,
    mediaKeys
  }, cancelSignal) {
    const previousState = media_keys_infos_store_default.getState(mediaElement);
    const closeAllSessions = previousState !== null && previousState.loadedSessionsStore !== loadedSessionsStore ? previousState.loadedSessionsStore.closeAllSessions() : Promise.resolve();
    await closeAllSessions;
    if (cancelSignal.isCancelled()) {
      throw cancelSignal.cancellationError;
    }
    media_keys_infos_store_default.setState(mediaElement, {
      emeImplementation,
      keySystemOptions,
      mediaKeySystemAccess,
      mediaKeys,
      loadedSessionsStore,
      askedConfiguration
    });
    if (mediaElement.mediaKeys === mediaKeys) {
      return;
    }
    log_default.info("DRM: Attaching MediaKeys to the media element");
    return setMediaKeys(emeImplementation, mediaElement, mediaKeys).then(() => {
      log_default.info("DRM: MediaKeys attached with success");
    }).catch((err) => {
      const errMessage = err instanceof Error ? err.toString() : "Unknown Error";
      throw new EncryptedMediaError(
        "MEDIA_KEYS_ATTACHMENT_ERROR",
        "Could not attach the MediaKeys to the media element: " + errMessage
      );
    });
  }

  // src/main_thread/decrypt/create_or_load_session.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/main_thread/decrypt/create_session.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/main_thread/decrypt/utils/is_session_usable.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function isSessionUsable(loadedSession) {
    if (loadedSession.sessionId === "") {
      return false;
    }
    const keyStatusesMap = loadedSession.keyStatuses;
    const keyStatuses = [];
    keyStatusesMap.forEach((keyStatus) => {
      keyStatuses.push(keyStatus);
    });
    if (keyStatuses.length <= 0) {
      log_default.debug(
        "DRM: isSessionUsable: MediaKeySession given has an empty keyStatuses",
        loadedSession.sessionId
      );
      return false;
    }
    if (arrayIncludes(keyStatuses, "expired")) {
      log_default.debug(
        "DRM: isSessionUsable: MediaKeySession given has an expired key",
        loadedSession.sessionId
      );
      return false;
    }
    if (arrayIncludes(keyStatuses, "internal-error")) {
      log_default.debug(
        "DRM: isSessionUsable: MediaKeySession given has a key with an internal-error",
        loadedSession.sessionId
      );
      return false;
    }
    log_default.debug("DRM: isSessionUsable: MediaKeySession is usable", loadedSession.sessionId);
    return true;
  }

  // src/main_thread/decrypt/create_session.ts
  function createSession(stores, initData, wantedSessionType, cancelSignal) {
    const { loadedSessionsStore, persistentSessionsStore } = stores;
    if (wantedSessionType === "temporary") {
      return createTemporarySession(loadedSessionsStore, initData);
    } else if (persistentSessionsStore === null) {
      log_default.warn(
        "DRM: Cannot create persistent MediaKeySession, PersistentSessionsStore not created."
      );
      return createTemporarySession(loadedSessionsStore, initData);
    }
    return createAndTryToRetrievePersistentSession(
      loadedSessionsStore,
      persistentSessionsStore,
      initData,
      cancelSignal
    );
  }
  function createTemporarySession(loadedSessionsStore, initData) {
    log_default.info("DRM: Creating a new temporary session");
    const entry = loadedSessionsStore.createSession(initData, "temporary");
    return Promise.resolve({
      type: "created-session" /* Created */,
      value: entry
    });
  }
  async function createAndTryToRetrievePersistentSession(loadedSessionsStore, persistentSessionsStore, initData, cancelSignal) {
    if (cancelSignal.cancellationError !== null) {
      throw cancelSignal.cancellationError;
    }
    log_default.info("DRM: Creating persistent MediaKeySession");
    const entry = loadedSessionsStore.createSession(initData, "persistent-license");
    const storedEntry = persistentSessionsStore.getAndReuse(initData);
    if (storedEntry === null) {
      return { type: "created-session" /* Created */, value: entry };
    }
    try {
      const hasLoadedSession = await loadedSessionsStore.loadPersistentSession(
        entry.mediaKeySession,
        storedEntry.sessionId
      );
      if (!hasLoadedSession) {
        log_default.warn("DRM: No data stored for the loaded session");
        persistentSessionsStore.delete(storedEntry.sessionId);
        loadedSessionsStore.removeSessionWithoutClosingIt(entry.mediaKeySession);
        const newEntry = loadedSessionsStore.createSession(initData, "persistent-license");
        return { type: "created-session" /* Created */, value: newEntry };
      }
      if (hasLoadedSession && isSessionUsable(entry.mediaKeySession)) {
        persistentSessionsStore.add(initData, initData.keyIds, entry.mediaKeySession);
        log_default.info("DRM: Succeeded to load persistent session.");
        return {
          type: "loaded-persistent-session" /* LoadedPersistentSession */,
          value: entry
        };
      }
      log_default.warn("DRM: Previous persistent session not usable anymore.");
      return recreatePersistentSession();
    } catch (err) {
      log_default.warn(
        "DRM: Unable to load persistent session: " + (err instanceof Error ? err.toString() : "Unknown Error")
      );
      return recreatePersistentSession();
    }
    async function recreatePersistentSession() {
      if (cancelSignal.cancellationError !== null) {
        throw cancelSignal.cancellationError;
      }
      log_default.info("DRM: Removing previous persistent session.");
      const persistentEntry = persistentSessionsStore.get(initData);
      if (persistentEntry !== null) {
        persistentSessionsStore.delete(persistentEntry.sessionId);
      }
      try {
        await loadedSessionsStore.closeSession(entry.mediaKeySession);
      } catch (err) {
        if (entry.mediaKeySession.sessionId !== "") {
          throw err;
        }
        loadedSessionsStore.removeSessionWithoutClosingIt(entry.mediaKeySession);
      }
      if (cancelSignal.cancellationError !== null) {
        throw cancelSignal.cancellationError;
      }
      const newEntry = loadedSessionsStore.createSession(initData, "persistent-license");
      return { type: "created-session" /* Created */, value: newEntry };
    }
  }

  // src/main_thread/decrypt/utils/clean_old_loaded_sessions.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  async function cleanOldLoadedSessions(loadedSessionsStore, limit) {
    if (limit < 0 || limit >= loadedSessionsStore.getLength()) {
      return;
    }
    log_default.info("DRM: LSS cache limit exceeded", limit, loadedSessionsStore.getLength());
    const proms = [];
    const entries = loadedSessionsStore.getAll().slice();
    const toDelete = entries.length - limit;
    for (let i = 0; i < toDelete; i++) {
      const entry = entries[i];
      proms.push(loadedSessionsStore.closeSession(entry.mediaKeySession));
    }
    await Promise.all(proms);
  }

  // src/main_thread/decrypt/create_or_load_session.ts
  async function createOrLoadSession(initializationData, stores, wantedSessionType, maxSessionCacheSize, cancelSignal) {
    let previousLoadedSession = null;
    const { loadedSessionsStore, persistentSessionsStore } = stores;
    const entry = loadedSessionsStore.reuse(initializationData);
    if (entry !== null) {
      previousLoadedSession = entry.mediaKeySession;
      if (isSessionUsable(previousLoadedSession)) {
        log_default.info("DRM: Reuse loaded session", previousLoadedSession.sessionId);
        return {
          type: "loaded-open-session" /* LoadedOpenSession */,
          value: {
            mediaKeySession: previousLoadedSession,
            sessionType: entry.sessionType,
            keySessionRecord: entry.keySessionRecord
          }
        };
      } else if (persistentSessionsStore !== null) {
        if (entry.mediaKeySession.sessionId !== "") {
          persistentSessionsStore.delete(entry.mediaKeySession.sessionId);
        }
      }
    }
    if (previousLoadedSession !== null) {
      await loadedSessionsStore.closeSession(previousLoadedSession);
      if (cancelSignal.cancellationError !== null) {
        throw cancelSignal.cancellationError;
      }
    }
    await cleanOldLoadedSessions(loadedSessionsStore, maxSessionCacheSize);
    if (cancelSignal.cancellationError !== null) {
      throw cancelSignal.cancellationError;
    }
    const evt = await createSession(
      stores,
      initializationData,
      wantedSessionType,
      cancelSignal
    );
    return {
      type: evt.type,
      value: {
        mediaKeySession: evt.value.mediaKeySession,
        sessionType: evt.value.sessionType,
        keySessionRecord: evt.value.keySessionRecord
      }
    };
  }

  // src/main_thread/decrypt/init_media_keys.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/main_thread/decrypt/get_media_keys.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/compat/can_reuse_media_keys.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function canReuseMediaKeys() {
    return !isWebOs && !isPhilipsNetTv && !isPanasonic && !isA1KStb40xx;
  }

  // src/main_thread/decrypt/find_key_system.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/compat/can_rely_on_request_media_key_system_access.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function canRelyOnRequestMediaKeySystemAccess(keySystem) {
    if (isEdgeChromium && keySystem.indexOf("playready") !== -1) {
      return false;
    }
    return true;
  }

  // src/compat/generate_init_data.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var DUMMY_PLAY_READY_HEADER = '<WRMHEADER xmlns="http://schemas.microsoft.com/DRM/2007/03/PlayReadyHeader" version="4.0.0.0"><DATA><PROTECTINFO><KEYLEN>16</KEYLEN><ALGID>AESCTR</ALGID></PROTECTINFO><KID>ckB07BNLskeUq0qd83fTbA==</KID><DS_ID>yYIPDBca1kmMfL60IsfgAQ==</DS_ID><CUSTOMATTRIBUTES xmlns=""><encryptionref>312_4024_2018127108</encryptionref></CUSTOMATTRIBUTES><CHECKSUM>U/tsUYRgMzw=</CHECKSUM></DATA></WRMHEADER>';
  function generatePlayReadyInitData(playreadyHeader) {
    const recordValueEncoded = strToUtf16LE(playreadyHeader);
    const recordLength = itole2(recordValueEncoded.length);
    const recordType = new Uint8Array([1, 0]);
    const numberOfObjects = new Uint8Array([1, 0]);
    const playReadyObjectLength = itole4(recordValueEncoded.length + 6);
    const playReadyObject = concat(
      playReadyObjectLength,
      // 4 bytes for the Playready object length
      numberOfObjects,
      // 2 bytes for the number of PlayReady objects
      recordType,
      // 2 bytes for record type
      recordLength,
      // 2 bytes for record length
      recordValueEncoded
      // X bytes for record value
    );
    const playreadySystemId = hexToBytes("9a04f07998404286ab92e65be0885f95");
    return generateInitData(playReadyObject, playreadySystemId);
  }
  function generateInitData(data2, systemId) {
    const psshBoxName = strToUtf8("pssh");
    const versionAndFlags = new Uint8Array([0, 0, 0, 0]);
    const sizeOfData = itobe4(data2.length);
    const psshSize = itobe4(
      4 + 4 + 4 + 16 + 4 + data2.length
    );
    return concat(
      psshSize,
      // 4 bytes for the pssh size
      psshBoxName,
      // 4 bytes for the pssh box
      versionAndFlags,
      // 4 bytes for version and flags
      systemId,
      // 16 bytes for the systemId
      sizeOfData,
      // 4 bytes for the data size
      data2
      // X bytes for data
    );
  }

  // src/compat/should_renew_media_key_system_access.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function shouldRenewMediaKeySystemAccess() {
    return isIE11;
  }

  // src/utils/are_codecs_compatible.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function areCodecsCompatible(a, b) {
    const { mimeType: mimeTypeA, codecs: codecsA } = parseCodec(a);
    const { mimeType: mimeTypeB, codecs: codecsB } = parseCodec(b);
    if (mimeTypeA !== mimeTypeB) {
      return false;
    }
    if (codecsA === "" || codecsB === "") {
      return false;
    }
    let initialPartA = codecsA.split(".")[0];
    initialPartA = initialPartA === "hev1" ? "hvc1" : initialPartA;
    let initialPartB = codecsB.split(".")[0];
    initialPartB = initialPartB === "hev1" ? "hvc1" : initialPartB;
    if (initialPartA !== initialPartB) {
      return false;
    }
    return true;
  }
  var LENGTH_OF_CODEC_PREFIX = "codecs=".length;
  function parseCodec(unparsedCodec) {
    var _a;
    const [mimeType, ...props] = unparsedCodec.split(";");
    let codecs = (_a = arrayFind(props, (prop) => startsWith(prop, "codecs="))) != null ? _a : "";
    codecs = codecs.substring(LENGTH_OF_CODEC_PREFIX);
    if (codecs[0] === '"') {
      codecs = codecs.substring(1, codecs.length - 2);
    }
    return { mimeType, codecs };
  }
  var are_codecs_compatible_default = areCodecsCompatible;

  // src/utils/flat_map.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function flatMap(originalArray, fn) {
    if (typeof Array.prototype.flatMap === "function") {
      return originalArray.flatMap(fn);
    }
    return originalArray.reduce((acc, arg) => {
      const r = fn(arg);
      if (Array.isArray(r)) {
        acc.push(...r);
        return acc;
      }
      acc.push(r);
      return acc;
    }, []);
  }

  // src/main_thread/decrypt/find_key_system.ts
  function checkCachedMediaKeySystemAccess(keySystems, askedConfiguration, currentKeySystemAccess, currentKeySystemOptions) {
    const mksConfiguration = currentKeySystemAccess.getConfiguration();
    if (shouldRenewMediaKeySystemAccess() || isNullOrUndefined(mksConfiguration)) {
      return null;
    }
    const firstCompatibleOption = keySystems.filter((ks) => {
      if (ks.type !== currentKeySystemOptions.type) {
        return false;
      }
      if ((!isNullOrUndefined(ks.persistentLicenseConfig) || ks.persistentState === "required") && mksConfiguration.persistentState !== "required") {
        return false;
      }
      if (ks.distinctiveIdentifier === "required" && mksConfiguration.distinctiveIdentifier !== "required") {
        return false;
      }
      return true;
    })[0];
    if (firstCompatibleOption !== void 0) {
      return {
        keySystemOptions: firstCompatibleOption,
        keySystemAccess: currentKeySystemAccess,
        askedConfiguration
      };
    }
    return null;
  }
  function findKeySystemCanonicalName(ksType) {
    const { EME_KEY_SYSTEMS } = config_default.getCurrent();
    for (const ksName of Object.keys(EME_KEY_SYSTEMS)) {
      if (arrayIncludes(EME_KEY_SYSTEMS[ksName], ksType)) {
        return ksName;
      }
    }
    return void 0;
  }
  function buildKeySystemConfigurations(keySystemTypeInfo) {
    const { keyName, keyType, keySystemOptions: keySystem } = keySystemTypeInfo;
    const sessionTypes = ["temporary"];
    let persistentState = "optional";
    let distinctiveIdentifier = "optional";
    if (!isNullOrUndefined(keySystem.persistentLicenseConfig)) {
      persistentState = "required";
      sessionTypes.push("persistent-license");
    }
    if (!isNullOrUndefined(keySystem.persistentState)) {
      persistentState = keySystem.persistentState;
    }
    if (!isNullOrUndefined(keySystem.distinctiveIdentifier)) {
      distinctiveIdentifier = keySystem.distinctiveIdentifier;
    }
    const {
      EME_DEFAULT_AUDIO_CODECS,
      EME_DEFAULT_VIDEO_CODECS,
      EME_DEFAULT_WIDEVINE_ROBUSTNESSES,
      EME_DEFAULT_PLAYREADY_RECOMMENDATION_ROBUSTNESSES
    } = config_default.getCurrent();
    let audioCapabilities;
    let videoCapabilities;
    const { audioCapabilitiesConfig, videoCapabilitiesConfig } = keySystem;
    if ((audioCapabilitiesConfig == null ? void 0 : audioCapabilitiesConfig.type) === "full") {
      audioCapabilities = audioCapabilitiesConfig.value;
    } else {
      let audioRobustnesses;
      if ((audioCapabilitiesConfig == null ? void 0 : audioCapabilitiesConfig.type) === "robustness") {
        audioRobustnesses = audioCapabilitiesConfig.value;
      } else if (keyName === "widevine") {
        audioRobustnesses = EME_DEFAULT_WIDEVINE_ROBUSTNESSES;
      } else if (keyType === "com.microsoft.playready.recommendation") {
        audioRobustnesses = EME_DEFAULT_PLAYREADY_RECOMMENDATION_ROBUSTNESSES;
      } else {
        audioRobustnesses = [];
      }
      if (audioRobustnesses.length === 0) {
        audioRobustnesses.push(void 0);
      }
      const audioCodecs = (audioCapabilitiesConfig == null ? void 0 : audioCapabilitiesConfig.type) === "contentType" ? audioCapabilitiesConfig.value : EME_DEFAULT_AUDIO_CODECS;
      audioCapabilities = flatMap(
        audioRobustnesses,
        (robustness) => audioCodecs.map((contentType) => {
          return robustness !== void 0 ? { contentType, robustness } : { contentType };
        })
      );
    }
    if ((videoCapabilitiesConfig == null ? void 0 : videoCapabilitiesConfig.type) === "full") {
      videoCapabilities = videoCapabilitiesConfig.value;
    } else {
      let videoRobustnesses;
      if ((videoCapabilitiesConfig == null ? void 0 : videoCapabilitiesConfig.type) === "robustness") {
        videoRobustnesses = videoCapabilitiesConfig.value;
      } else if (keyName === "widevine") {
        videoRobustnesses = EME_DEFAULT_WIDEVINE_ROBUSTNESSES;
      } else if (keyType === "com.microsoft.playready.recommendation") {
        videoRobustnesses = EME_DEFAULT_PLAYREADY_RECOMMENDATION_ROBUSTNESSES;
      } else {
        videoRobustnesses = [];
      }
      if (videoRobustnesses.length === 0) {
        videoRobustnesses.push(void 0);
      }
      const videoCodecs = (videoCapabilitiesConfig == null ? void 0 : videoCapabilitiesConfig.type) === "contentType" ? videoCapabilitiesConfig.value : EME_DEFAULT_VIDEO_CODECS;
      videoCapabilities = flatMap(
        videoRobustnesses,
        (robustness) => videoCodecs.map((contentType) => {
          return robustness !== void 0 ? { contentType, robustness } : { contentType };
        })
      );
    }
    const wantedMediaKeySystemConfiguration = {
      initDataTypes: ["cenc"],
      videoCapabilities,
      audioCapabilities,
      distinctiveIdentifier,
      persistentState,
      sessionTypes
    };
    if (audioCapabilitiesConfig !== void 0) {
      if (videoCapabilitiesConfig !== void 0) {
        return [wantedMediaKeySystemConfiguration];
      }
      return [
        wantedMediaKeySystemConfiguration,
        __spreadProps(__spreadValues({}, wantedMediaKeySystemConfiguration), {
          // Re-try without `videoCapabilities` in case the EME implementation is
          // buggy
          videoCapabilities: void 0
        })
      ];
    } else if (videoCapabilitiesConfig !== void 0) {
      return [
        wantedMediaKeySystemConfiguration,
        __spreadProps(__spreadValues({}, wantedMediaKeySystemConfiguration), {
          // Re-try without `audioCapabilities` in case the EME implementation is
          // buggy
          audioCapabilities: void 0
        })
      ];
    }
    return [
      wantedMediaKeySystemConfiguration,
      // Some legacy implementations have issues with `audioCapabilities` and
      // `videoCapabilities`, so we're including a supplementary
      // `MediaKeySystemConfiguration` without those properties.
      __spreadProps(__spreadValues({}, wantedMediaKeySystemConfiguration), {
        audioCapabilities: void 0,
        videoCapabilities: void 0
      })
    ];
  }
  function extractCodecSupportListFromConfiguration(initialConfiguration, mksConfiguration) {
    var _a, _b, _c, _d, _e, _f;
    const testedAudioCodecs = (_b = (_a = initialConfiguration.audioCapabilities) == null ? void 0 : _a.map((v) => v.contentType)) != null ? _b : [];
    const testedVideoCodecs = (_d = (_c = initialConfiguration.videoCapabilities) == null ? void 0 : _c.map((v) => v.contentType)) != null ? _d : [];
    const testedCodecs = testedAudioCodecs.concat(testedVideoCodecs).filter((c) => c !== void 0);
    const supportedVideoCodecs = (_e = mksConfiguration.videoCapabilities) == null ? void 0 : _e.map(
      (entry) => entry.contentType
    );
    const supportedAudioCodecs = (_f = mksConfiguration.audioCapabilities) == null ? void 0 : _f.map(
      (entry) => entry.contentType
    );
    const supportedCodecs = [
      ...supportedVideoCodecs != null ? supportedVideoCodecs : [],
      ...supportedAudioCodecs != null ? supportedAudioCodecs : []
    ].filter((contentType) => contentType !== void 0);
    if (supportedCodecs.length === 0) {
      return [];
    }
    const codecSupportList = testedCodecs.map((codec) => {
      const { codecs, mimeType } = parseCodec(codec);
      const isSupported = arrayIncludes(supportedCodecs, codec);
      return {
        codec: codecs,
        mimeType,
        result: isSupported
      };
    });
    return codecSupportList;
  }
  function getMediaKeySystemAccess(mediaElement, keySystemsConfigs, cancelSignal) {
    log_default.info("DRM: Searching for compatible MediaKeySystemAccess");
    const currentState = media_keys_infos_store_default.getState(mediaElement);
    if (currentState !== null) {
      if (eme_default.implementation === currentState.emeImplementation.implementation) {
        const cachedKeySystemAccess = checkCachedMediaKeySystemAccess(
          keySystemsConfigs,
          currentState.askedConfiguration,
          currentState.mediaKeySystemAccess,
          currentState.keySystemOptions
        );
        if (cachedKeySystemAccess !== null) {
          log_default.info("DRM: Found cached compatible keySystem");
          return Promise.resolve({
            type: "reuse-media-key-system-access",
            value: {
              mediaKeySystemAccess: cachedKeySystemAccess.keySystemAccess,
              askedConfiguration: cachedKeySystemAccess.askedConfiguration,
              options: cachedKeySystemAccess.keySystemOptions,
              codecSupport: extractCodecSupportListFromConfiguration(
                cachedKeySystemAccess.askedConfiguration,
                cachedKeySystemAccess.keySystemAccess.getConfiguration()
              )
            }
          });
        }
      }
    }
    const keySystemsType = keySystemsConfigs.reduce(
      (arr, keySystemOptions) => {
        const { EME_KEY_SYSTEMS } = config_default.getCurrent();
        const managedRDNs = EME_KEY_SYSTEMS[keySystemOptions.type];
        let ksType;
        if (!isNullOrUndefined(managedRDNs)) {
          ksType = managedRDNs.map((keyType) => {
            const keyName = keySystemOptions.type;
            return { keyName, keyType, keySystemOptions };
          });
        } else {
          const keyName = findKeySystemCanonicalName(keySystemOptions.type);
          const keyType = keySystemOptions.type;
          ksType = [{ keyName, keyType, keySystemOptions }];
        }
        return arr.concat(ksType);
      },
      []
    );
    return recursivelyTestKeySystems(0);
    async function recursivelyTestKeySystems(index) {
      if (index >= keySystemsType.length) {
        throw new EncryptedMediaError(
          "INCOMPATIBLE_KEYSYSTEMS",
          "No key system compatible with your wanted configuration has been found in the current browser."
        );
      }
      if (isNullOrUndefined(eme_default.requestMediaKeySystemAccess)) {
        throw new Error("requestMediaKeySystemAccess is not implemented in your browser.");
      }
      const chosenType = keySystemsType[index];
      const { keyType, keySystemOptions } = chosenType;
      const keySystemConfigurations = buildKeySystemConfigurations(chosenType);
      log_default.debug(
        `DRM: Request keysystem access ${keyType},${index + 1} of ${keySystemsType.length}`
      );
      let keySystemAccess;
      for (let configIdx = 0; configIdx < keySystemConfigurations.length; configIdx++) {
        const keySystemConfiguration = keySystemConfigurations[configIdx];
        try {
          keySystemAccess = await testKeySystem(keyType, [keySystemConfiguration]);
          log_default.info("DRM: Found compatible keysystem", keyType, index + 1);
          return {
            type: "create-media-key-system-access",
            value: {
              options: keySystemOptions,
              mediaKeySystemAccess: keySystemAccess,
              askedConfiguration: keySystemConfiguration,
              codecSupport: extractCodecSupportListFromConfiguration(
                keySystemConfiguration,
                keySystemAccess.getConfiguration()
              )
            }
          };
        } catch (_) {
          log_default.debug("DRM: Rejected access to keysystem", keyType, index + 1, configIdx);
          if (cancelSignal.cancellationError !== null) {
            throw cancelSignal.cancellationError;
          }
        }
      }
      return recursivelyTestKeySystems(index + 1);
    }
  }
  async function testKeySystem(keyType, keySystemConfigurations) {
    const keySystemAccess = await eme_default.requestMediaKeySystemAccess(
      keyType,
      keySystemConfigurations
    );
    if (!canRelyOnRequestMediaKeySystemAccess(keyType)) {
      try {
        const mediaKeys = await keySystemAccess.createMediaKeys();
        const session = mediaKeys.createSession();
        const initData = generatePlayReadyInitData(DUMMY_PLAY_READY_HEADER);
        await session.generateRequest("cenc", initData);
      } catch (err) {
        log_default.debug("DRM: KeySystemAccess was granted but it is not usable");
        throw err;
      }
    }
    return keySystemAccess;
  }

  // src/main_thread/decrypt/utils/loaded_sessions_store.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/main_thread/decrypt/utils/key_session_record.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/main_thread/decrypt/utils/key_id_comparison.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function areAllKeyIdsContainedIn(wantedKeyIds, keyIdsArr) {
    for (const keyId of wantedKeyIds) {
      const found = keyIdsArr.some((k) => areArraysOfNumbersEqual(k, keyId));
      if (!found) {
        return false;
      }
    }
    return true;
  }
  function areSomeKeyIdsContainedIn(wantedKeyIds, keyIdsArr) {
    for (const keyId of wantedKeyIds) {
      const found = keyIdsArr.some((k) => areArraysOfNumbersEqual(k, keyId));
      if (found) {
        return true;
      }
    }
    return false;
  }

  // src/main_thread/decrypt/utils/key_session_record.ts
  var KeySessionRecord = class {
    /**
     * Create a new `KeySessionRecord`, linked to its corresponding initialization
     * data,
     * @param {Object} initializationData
     */
    constructor(initializationData) {
      this._initializationData = initializationData;
      this._keyIds = null;
    }
    /**
     * Associate supplementary key ids to this `KeySessionRecord` so it becomes
     * "compatible" to them.
     *
     * After this call, new initialization data linked to subsets of those key
     * ids will be considered compatible  to this `KeySessionRecord` (calls to
     * `isCompatibleWith` with the corresponding initialization data will return
     * `true`).
     * @param {Array.<Uint8Array>} keyIds
     */
    associateKeyIds(keyIds) {
      if (this._keyIds === null) {
        this._keyIds = [];
      }
      const keyIdsArr = Array.from(keyIds);
      for (const keyId of keyIdsArr) {
        if (!this.isAssociatedWithKeyId(keyId)) {
          this._keyIds.push(keyId);
        }
      }
    }
    /**
     * @param {Uint8Array} keyId
     * @returns {boolean}
     */
    isAssociatedWithKeyId(keyId) {
      if (this._keyIds === null) {
        return false;
      }
      for (const storedKeyId of this._keyIds) {
        if (areArraysOfNumbersEqual(storedKeyId, keyId)) {
          return true;
        }
      }
      return false;
    }
    /**
     * @returns {Array.<Uint8Array>}
     */
    getAssociatedKeyIds() {
      if (this._keyIds === null) {
        return [];
      }
      return this._keyIds;
    }
    /**
     * Check if that `KeySessionRecord` is compatible to the initialization data
     * given.
     *
     * If it returns `true`, it means that this `KeySessionRecord` is already
     * linked to that initialization data's key. As such, if that
     * `KeySessionRecord` is already associated to an active MediaKeySession for
     * example, the content linked to that initialization data should already be
     * handled.
     *
     * If it returns `false`, it means that this `KeySessionRecord` has no
     * relation with the given initialization data.
     *
     * @param {Object} initializationData
     * @returns {boolean}
     */
    isCompatibleWith(initializationData) {
      const { keyIds } = initializationData;
      if (keyIds !== void 0 && keyIds.length > 0) {
        if (this._keyIds !== null && areAllKeyIdsContainedIn(keyIds, this._keyIds)) {
          return true;
        }
        if (this._initializationData.keyIds !== void 0) {
          return areAllKeyIdsContainedIn(keyIds, this._initializationData.keyIds);
        }
      }
      return this._checkInitializationDataCompatibility(initializationData);
    }
    _checkInitializationDataCompatibility(initializationData) {
      if (initializationData.keyIds !== void 0 && initializationData.keyIds.length > 0 && this._initializationData.keyIds !== void 0) {
        return areAllKeyIdsContainedIn(
          initializationData.keyIds,
          this._initializationData.keyIds
        );
      }
      if (this._initializationData.type !== initializationData.type) {
        return false;
      }
      return this._initializationData.values.isCompatibleWith(initializationData.values);
    }
  };

  // src/main_thread/decrypt/utils/loaded_sessions_store.ts
  var LoadedSessionsStore = class {
    /**
     * Create a new LoadedSessionsStore, which will store information about
     * loaded MediaKeySessions on the given MediaKeys instance.
     * @param {MediaKeys} mediaKeys
     */
    constructor(mediaKeys) {
      this._mediaKeys = mediaKeys;
      this._storage = [];
    }
    /**
     * Create a new MediaKeySession and store it in this store.
     * @param {Object} initData
     * @param {string} sessionType
     * @returns {Object}
     */
    createSession(initData, sessionType) {
      const keySessionRecord = new KeySessionRecord(initData);
      log_default.debug("DRM-LSS: calling `createSession`", sessionType);
      const mediaKeySession = this._mediaKeys.createSession(sessionType);
      const entry = {
        mediaKeySession,
        sessionType,
        keySessionRecord,
        isGeneratingRequest: false,
        isLoadingPersistentSession: false,
        closingStatus: { type: "none" }
      };
      if (!isNullOrUndefined(mediaKeySession.closed)) {
        mediaKeySession.closed.then(() => {
          log_default.info(
            "DRM-LSS: session was closed, removing it.",
            mediaKeySession.sessionId
          );
          const index = this.getIndex(keySessionRecord);
          if (index >= 0 && this._storage[index].mediaKeySession === mediaKeySession) {
            this._storage.splice(index, 1);
          }
        }).catch((e) => {
          log_default.warn(`DRM-LSS: MediaKeySession.closed rejected: ${e}`);
        });
      }
      this._storage.push(__spreadValues({}, entry));
      log_default.debug("DRM-LSS: MediaKeySession added", entry.sessionType, this._storage.length);
      return entry;
    }
    /**
     * Find a stored entry compatible with the initialization data given and moves
     * this entry at the end of the `LoadedSessionsStore`''s storage, returned by
     * its `getAll` method.
     *
     * This can be used for example to tell when a previously-stored
     * entry is re-used to then be able to implement a caching replacement
     * algorithm based on the least-recently-used values by just evicting the first
     * values returned by `getAll`.
     * @param {Object} initializationData
     * @returns {Object|null}
     */
    reuse(initializationData) {
      for (let i = this._storage.length - 1; i >= 0; i--) {
        const stored = this._storage[i];
        if (stored.keySessionRecord.isCompatibleWith(initializationData)) {
          this._storage.splice(i, 1);
          this._storage.push(stored);
          log_default.debug(
            "DRM-LSS: Reusing session:",
            stored.mediaKeySession.sessionId,
            stored.sessionType
          );
          return __spreadValues({}, stored);
        }
      }
      return null;
    }
    /**
     * Get `LoadedSessionsStore`'s entry for a given MediaKeySession.
     * Returns `null` if the given MediaKeySession is not stored in the
     * `LoadedSessionsStore`.
     * @param {MediaKeySession} mediaKeySession
     * @returns {Object|null}
     */
    getEntryForSession(mediaKeySession) {
      for (let i = this._storage.length - 1; i >= 0; i--) {
        const stored = this._storage[i];
        if (stored.mediaKeySession === mediaKeySession) {
          return __spreadValues({}, stored);
        }
      }
      return null;
    }
    /**
     * Generate a license request on the given MediaKeySession, while indicating
     * to the LoadedSessionsStore that a license-request is pending so
     * session-closing orders are properly scheduled after it is done.
     * @param {Object} mediaKeySession
     * @param {string} initializationDataType - Initialization data type given
     * e.g. by the "encrypted" event for the corresponding request.
     * @param {Uint8Array}initializationData - Initialization data given e.g. by
     * the "encrypted" event for the corresponding request.
     * @returns {Promise}
     */
    async generateLicenseRequest(mediaKeySession, initializationDataType, initializationData) {
      let entry;
      for (const stored of this._storage) {
        if (stored.mediaKeySession === mediaKeySession) {
          entry = stored;
          break;
        }
      }
      if (entry === void 0) {
        log_default.error(
          "DRM-LSS: generateRequest error. No MediaKeySession found with the given initData and initDataType"
        );
        return generateKeyRequest(
          mediaKeySession,
          initializationDataType,
          initializationData
        );
      }
      entry.isGeneratingRequest = true;
      if (entry.closingStatus.type !== "none") {
        throw new Error("The `MediaKeySession` is being closed.");
      }
      try {
        await generateKeyRequest(
          mediaKeySession,
          initializationDataType,
          initializationData
        );
      } catch (err) {
        if (entry === void 0) {
          throw err;
        }
        entry.isGeneratingRequest = false;
        if (entry.closingStatus.type === "awaiting") {
          entry.closingStatus.start();
        }
        throw err;
      }
      if (entry === void 0) {
        return void 0;
      }
      entry.isGeneratingRequest = false;
      if (entry.closingStatus.type === "awaiting") {
        entry.closingStatus.start();
      }
    }
    /**
     * @param {Object} mediaKeySession
     * @param {string} sessionId
     * @returns {Promise}
     */
    async loadPersistentSession(mediaKeySession, sessionId) {
      let entry;
      for (const stored of this._storage) {
        if (stored.mediaKeySession === mediaKeySession) {
          entry = stored;
          break;
        }
      }
      if (entry === void 0) {
        log_default.error(
          "DRM-LSS: loadPersistentSession error. No MediaKeySession found with the given initData and initDataType"
        );
        return loadSession(mediaKeySession, sessionId);
      }
      entry.isLoadingPersistentSession = true;
      if (entry.closingStatus.type !== "none") {
        throw new Error("The `MediaKeySession` is being closed.");
      }
      let ret;
      try {
        ret = await loadSession(mediaKeySession, sessionId);
      } catch (err) {
        if (entry === void 0) {
          throw err;
        }
        entry.isLoadingPersistentSession = false;
        if (entry.closingStatus.type === "awaiting") {
          entry.closingStatus.start();
        }
        throw err;
      }
      if (entry === void 0) {
        return ret;
      }
      entry.isLoadingPersistentSession = false;
      if (entry.closingStatus.type === "awaiting") {
        entry.closingStatus.start();
      }
      return ret;
    }
    /**
     * Close a MediaKeySession and remove its related stored information from the
     * `LoadedSessionsStore`.
     * Emit when done.
     * @param {Object} mediaKeySession
     * @returns {Promise}
     */
    async closeSession(mediaKeySession) {
      let entry;
      for (const stored of this._storage) {
        if (stored.mediaKeySession === mediaKeySession) {
          entry = stored;
          break;
        }
      }
      if (entry === void 0) {
        log_default.warn(
          "DRM-LSS: No MediaKeySession found with the given initData and initDataType"
        );
        return Promise.resolve(false);
      }
      return this._closeEntry(entry);
    }
    /**
     * Returns the number of stored MediaKeySessions in this LoadedSessionsStore.
     * @returns {number}
     */
    getLength() {
      return this._storage.length;
    }
    /**
     * Returns information about all stored MediaKeySession, in the order in which
     * the MediaKeySession have been created.
     * @returns {Array.<Object>}
     */
    getAll() {
      return this._storage;
    }
    /**
     * Close all sessions in this store.
     * Emit `null` when done.
     * @returns {Promise}
     */
    async closeAllSessions() {
      const allEntries = this._storage;
      log_default.debug("DRM-LSS: Closing all current MediaKeySessions", allEntries.length);
      this._storage = [];
      const closingProms = allEntries.map((entry) => this._closeEntry(entry));
      await Promise.all(closingProms);
    }
    /**
     * Find the given `MediaKeySession` in the `LoadedSessionsStore` and removes
     * any reference to it without actually closing it.
     *
     * Returns `true` if the given `mediaKeySession` has been found and removed,
     * `false` otherwise.
     *
     * Note that this may create a `MediaKeySession` leakage in the wrong
     * conditions, cases where this method should be called should be very
     * carefully evaluated.
     * @param {MediaKeySession} mediaKeySession
     * @returns {boolean}
     */
    removeSessionWithoutClosingIt(mediaKeySession) {
      assert(
        mediaKeySession.sessionId === "",
        "Initialized `MediaKeySession`s should always be properly closed"
      );
      for (let i = this._storage.length - 1; i >= 0; i--) {
        const stored = this._storage[i];
        if (stored.mediaKeySession === mediaKeySession) {
          log_default.debug(
            "DRM-LSS: Removing session without closing it",
            mediaKeySession.sessionId
          );
          this._storage.splice(i, 1);
          return true;
        }
      }
      return false;
    }
    /**
     * Get the index of a stored MediaKeySession entry based on its
     * `KeySessionRecord`.
     * Returns -1 if not found.
     * @param {Object} record
     * @returns {number}
     */
    getIndex(record) {
      for (let i = 0; i < this._storage.length; i++) {
        const stored = this._storage[i];
        if (stored.keySessionRecord === record) {
          return i;
        }
      }
      return -1;
    }
    /**
     * Prepare the closure of a `MediaKeySession` stored as an entry of the
     * `LoadedSessionsStore`.
     * Allows to postpone the closure action if another MediaKeySession action
     * is already pending.
     * @param {Object} entry
     * @returns {Promise.<boolean>}
     */
    async _closeEntry(entry) {
      const { mediaKeySession } = entry;
      return new Promise((resolve, reject) => {
        if (entry !== void 0 && (entry.isLoadingPersistentSession || entry.isGeneratingRequest)) {
          entry.closingStatus = {
            type: "awaiting",
            start: tryClosingEntryAndResolve
          };
        } else {
          tryClosingEntryAndResolve();
        }
        function tryClosingEntryAndResolve() {
          if (entry !== void 0) {
            entry.closingStatus = { type: "pending" };
          }
          safelyCloseMediaKeySession(mediaKeySession).then(() => {
            if (entry !== void 0) {
              entry.closingStatus = { type: "done" };
            }
            resolve(true);
          }).catch((err) => {
            if (entry !== void 0) {
              entry.closingStatus = { type: "failed" };
            }
            reject(err);
          });
        }
      });
    }
  };
  async function safelyCloseMediaKeySession(mediaKeySession) {
    log_default.debug("DRM: Trying to close a MediaKeySession", mediaKeySession.sessionId);
    try {
      await closeSession(mediaKeySession);
      log_default.debug("DRM: Succeeded to close MediaKeySession");
      return;
    } catch (err) {
      log_default.error(
        "DRM: Could not close MediaKeySession: " + (err instanceof Error ? err.toString() : "Unknown error")
      );
      return;
    }
  }

  // src/main_thread/decrypt/utils/persistent_sessions_store.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/utils/hash_buffer.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function hashBuffer(buffer) {
    let hash = 0;
    let char;
    for (let i = 0; i < buffer.length; i++) {
      char = buffer[i];
      hash = (hash << 5) - hash + char;
      hash = hash & hash;
    }
    return hash;
  }

  // src/main_thread/decrypt/utils/are_init_values_compatible.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/main_thread/decrypt/utils/serializable_bytes.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var SerializableBytes = class {
    /**
     * Create a new `SerializableBytes`, wrapping the initialization data
     * given and allowing serialization into base64.
     * @param {Uint8Array} initData
     */
    constructor(initData) {
      this.initData = initData;
    }
    /**
     * Convert it to base64.
     * `toJSON` is specially interpreted by JavaScript engines to be able to rely
     * on it when calling `JSON.stringify` on it or any of its parent objects:
     * https://tc39.es/ecma262/#sec-serializejsonproperty
     * @returns {string}
     */
    toJSON() {
      return bytesToBase64(this.initData);
    }
    /**
     * Decode a base64 sequence representing an initialization data back to an
     * Uint8Array.
     * @param {string}
     * @returns {Uint8Array}
     */
    static decode(base64) {
      return base64ToBytes(base64);
    }
  };

  // src/main_thread/decrypt/utils/are_init_values_compatible.ts
  function areInitializationValuesCompatible(stored, newElts) {
    var _a, _b;
    return (_b = (_a = _isAInB(stored, newElts)) != null ? _a : _isAInB(newElts, stored)) != null ? _b : false;
  }
  function _isAInB(a, b) {
    if (a.length === 0) {
      return false;
    }
    if (b.length < a.length) {
      return null;
    }
    const firstAElt = a[0];
    let aIdx = 0;
    let bIdx = 0;
    for (; bIdx < b.length; bIdx++) {
      const bElt = b[bIdx];
      if (bElt.systemId !== firstAElt.systemId) {
        continue;
      }
      if (bElt.hash !== firstAElt.hash) {
        return false;
      }
      let aData;
      if (firstAElt.data instanceof Uint8Array) {
        aData = firstAElt.data;
      } else if (typeof firstAElt.data === "string") {
        aData = SerializableBytes.decode(firstAElt.data);
      } else {
        aData = firstAElt.data.initData;
      }
      let bData;
      if (bElt.data instanceof Uint8Array) {
        bData = bElt.data;
      } else if (typeof bElt.data === "string") {
        bData = SerializableBytes.decode(bElt.data);
      } else {
        bData = bElt.data.initData;
      }
      if (!areArraysOfNumbersEqual(aData, bData)) {
        return false;
      }
      if (b.length - bIdx < a.length) {
        return null;
      }
      for (aIdx = 1; aIdx < a.length; aIdx++) {
        const aElt = a[aIdx];
        for (bIdx += 1; bIdx < b.length; bIdx++) {
          const bNewElt = b[bIdx];
          if (aElt.systemId !== bNewElt.systemId) {
            continue;
          }
          if (aElt.hash !== bNewElt.hash) {
            return false;
          }
          let aNewData;
          if (aElt.data instanceof Uint8Array) {
            aNewData = aElt.data;
          } else if (typeof aElt.data === "string") {
            aNewData = SerializableBytes.decode(aElt.data);
          } else {
            aNewData = aElt.data.initData;
          }
          let bNewData;
          if (bNewElt.data instanceof Uint8Array) {
            bNewData = bNewElt.data;
          } else if (typeof bNewElt.data === "string") {
            bNewData = SerializableBytes.decode(bNewElt.data);
          } else {
            bNewData = bNewElt.data.initData;
          }
          if (!areArraysOfNumbersEqual(aNewData, bNewData)) {
            return false;
          }
          break;
        }
        if (aIdx === b.length) {
          return null;
        }
      }
      return true;
    }
    return null;
  }

  // src/main_thread/decrypt/utils/persistent_sessions_store.ts
  function checkStorage(storage) {
    assertInterface(
      storage,
      { save: "function", load: "function" },
      "persistentLicenseConfig"
    );
  }
  var PersistentSessionsStore = class {
    /**
     * Create a new PersistentSessionsStore.
     * @param {Object} storage
     */
    constructor(storage) {
      checkStorage(storage);
      this._entries = [];
      this._storage = storage;
      try {
        let entries = this._storage.load();
        if (!Array.isArray(entries)) {
          entries = [];
        }
        this._entries = entries;
      } catch (e) {
        log_default.warn(
          "DRM-PSS: Could not get entries from license storage",
          e instanceof Error ? e : ""
        );
        this.dispose();
      }
    }
    /**
     * Returns the number of stored values.
     * @returns {number}
     */
    getLength() {
      return this._entries.length;
    }
    /**
     * Returns information about all stored MediaKeySession, in the order in which
     * the MediaKeySession have been created.
     * @returns {Array.<Object>}
     */
    getAll() {
      return this._entries;
    }
    /**
     * Retrieve an entry based on its initialization data.
     * @param {Object}  initData
     * @param {string|undefined} initDataType
     * @returns {Object|null}
     */
    get(initData) {
      const index = this._getIndex(initData);
      return index === -1 ? null : this._entries[index];
    }
    /**
     * Like `get`, but also move the corresponding value at the end of the store
     * (as returned by `getAll`) if found.
     * This can be used for example to tell when a previously-stored value is
     * re-used to then be able to implement a caching replacement algorithm based
     * on the least-recently-used values by just evicting the first values
     * returned by `getAll`.
     * @param {Uint8Array} initData
     * @param {string|undefined} initDataType
     * @returns {*}
     */
    getAndReuse(initData) {
      const index = this._getIndex(initData);
      if (index === -1) {
        return null;
      }
      const item = this._entries.splice(index, 1)[0];
      this._entries.push(item);
      return item;
    }
    /**
     * Add a new entry in the PersistentSessionsStore.
     * @param {Uint8Array}  initData
     * @param {string|undefined} initDataType
     * @param {MediaKeySession} session
     */
    add(initData, keyIds, session) {
      var _a;
      if (isNullOrUndefined(session) || !isNonEmptyString(session.sessionId)) {
        log_default.warn("DRM-PSS: Invalid Persisten Session given.");
        return;
      }
      const { sessionId } = session;
      const currentIndex = this._getIndex(initData);
      if (currentIndex >= 0) {
        const currVersion = keyIds === void 0 ? 3 : 4;
        const currentEntry = this._entries[currentIndex];
        const entryVersion = (_a = currentEntry.version) != null ? _a : -1;
        if (entryVersion >= currVersion && sessionId === currentEntry.sessionId) {
          return;
        }
        log_default.info("DRM-PSS: Updating session info.", sessionId);
        this._entries.splice(currentIndex, 1);
      } else {
        log_default.info("DRM-PSS: Add new session", sessionId);
      }
      const storedValues = prepareValuesForStore(initData.values.getFormattedValues());
      if (keyIds === void 0) {
        this._entries.push({
          version: 3,
          sessionId,
          values: storedValues,
          initDataType: initData.type
        });
      } else {
        this._entries.push({
          version: 4,
          sessionId,
          keyIds: keyIds.map((k) => new SerializableBytes(k)),
          values: storedValues,
          initDataType: initData.type
        });
      }
      this._save();
    }
    /**
     * Delete stored MediaKeySession information based on its session id.
     * @param {string} sessionId
     */
    delete(sessionId) {
      let index = -1;
      for (let i = 0; i < this._entries.length; i++) {
        const entry2 = this._entries[i];
        if (entry2.sessionId === sessionId) {
          index = i;
          break;
        }
      }
      if (index === -1) {
        log_default.warn("DRM-PSS: initData to delete not found.");
        return;
      }
      const entry = this._entries[index];
      log_default.warn("DRM-PSS: Delete session from store", entry.sessionId);
      this._entries.splice(index, 1);
      this._save();
    }
    deleteOldSessions(sessionsToDelete) {
      log_default.info(`DRM-PSS: Deleting last ${sessionsToDelete} sessions.`);
      if (sessionsToDelete <= 0) {
        return;
      }
      if (sessionsToDelete <= this._entries.length) {
        this._entries.splice(0, sessionsToDelete);
      } else {
        log_default.warn(
          "DRM-PSS: Asked to remove more information that it contains",
          sessionsToDelete,
          this._entries.length
        );
        this._entries = [];
      }
      this._save();
    }
    /**
     * Delete all saved entries.
     */
    dispose() {
      this._entries = [];
      this._save();
    }
    /**
     * Retrieve index of an entry.
     * Returns `-1` if not found.
     * @param {Object} initData
     * @returns {number}
     */
    _getIndex(initData) {
      let lazyConcatenatedData = null;
      function getConcatenatedInitDataInfo() {
        if (lazyConcatenatedData === null) {
          const concatInitData = initData.values.constructRequestData();
          lazyConcatenatedData = {
            initData: concatInitData,
            initDataHash: hashBuffer(concatInitData)
          };
        }
        return lazyConcatenatedData;
      }
      for (let i = 0; i < this._entries.length; i++) {
        const entry = this._entries[i];
        if (entry.initDataType === initData.type) {
          switch (entry.version) {
            case 4:
              if (initData.keyIds !== void 0) {
                const foundCompatible = initData.keyIds.every((keyId) => {
                  const keyIdB64 = bytesToBase64(keyId);
                  for (const entryKid of entry.keyIds) {
                    if (typeof entryKid === "string") {
                      if (keyIdB64 === entryKid) {
                        return true;
                      }
                    } else if (areArraysOfNumbersEqual(entryKid.initData, keyId)) {
                      return true;
                    }
                  }
                  return false;
                });
                if (foundCompatible) {
                  return i;
                }
              } else {
                const formatted = initData.values.getFormattedValues();
                if (areInitializationValuesCompatible(formatted, entry.values)) {
                  return i;
                }
              }
              break;
            case 3: {
              const formatted = initData.values.getFormattedValues();
              if (areInitializationValuesCompatible(formatted, entry.values)) {
                return i;
              }
              break;
            }
            case 2: {
              const { initData: concatInitData, initDataHash: concatHash } = getConcatenatedInitDataInfo();
              if (entry.initDataHash === concatHash) {
                try {
                  const decodedInitData = typeof entry.initData === "string" ? SerializableBytes.decode(entry.initData) : entry.initData.initData;
                  if (areArraysOfNumbersEqual(decodedInitData, concatInitData)) {
                    return i;
                  }
                } catch (e) {
                  log_default.warn(
                    "DRM-PSS: Could not decode initialization data.",
                    e instanceof Error ? e : ""
                  );
                }
              }
              break;
            }
            case 1: {
              const { initData: concatInitData, initDataHash: concatHash } = getConcatenatedInitDataInfo();
              if (entry.initDataHash === concatHash) {
                if (typeof entry.initData.length === "undefined") {
                  return i;
                } else if (areArraysOfNumbersEqual(entry.initData, concatInitData)) {
                  return i;
                }
              }
              break;
            }
            default: {
              const { initDataHash: concatHash } = getConcatenatedInitDataInfo();
              if (entry.initData === concatHash) {
                return i;
              }
            }
          }
        }
      }
      return -1;
    }
    /**
     * Use the given storage to store the current entries.
     */
    _save() {
      try {
        this._storage.save(this._entries);
      } catch (e) {
        const err = e instanceof Error ? e : void 0;
        log_default.warn("DRM-PSS: Could not save MediaKeySession information", err);
      }
    }
  };
  function prepareValuesForStore(initialValues) {
    return initialValues.map(({ systemId, data: data2, hash }) => ({
      systemId,
      hash,
      data: new SerializableBytes(data2)
    }));
  }

  // src/main_thread/decrypt/utils/server_certificate_store.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var serverCertificateHashesMap = /* @__PURE__ */ new WeakMap();
  var server_certificate_store_default = {
    /**
     * Tells the ServerCertificateStore that you begin to call the APIs to set a
     * ServerCertificate on `mediaKeys`.
     *
     * Calling this function is necessary due to how server certificate work
     * currently in EME APIs:
     * Because right now, it is impossible to tell if a MediaKeys instance has an
     * attached ServerCertificate or not when the corresponding API fails or if it
     * never answers, we prefer to announce through this function that the current
     * server certificate attached to this MediaKeys is for now invalid.
     * @param {MediaKeys | Object} mediaKeys
     */
    prepare(mediaKeys) {
      serverCertificateHashesMap.set(mediaKeys, null);
    },
    /**
     * Attach a new server certificate to a MediaKeys in the
     * ServerCertificateStore.
     *
     * Only one server certificate should ever be attached to a MediaKeys
     * instance and the `prepare` function should have been called before any
     * action to update the server certificate took place (this function does not
     * enforce either of those behaviors).
     * @param {MediaKeys | Object} mediaKeys
     * @param {ArrayBufferView | BufferSource} serverCertificate
     */
    set(mediaKeys, serverCertificate) {
      const formattedServerCertificate = serverCertificate instanceof Uint8Array ? serverCertificate : new Uint8Array(
        serverCertificate instanceof ArrayBuffer ? serverCertificate : serverCertificate.buffer
      );
      const hash = hashBuffer(formattedServerCertificate);
      serverCertificateHashesMap.set(mediaKeys, {
        hash,
        serverCertificate: formattedServerCertificate
      });
    },
    /**
     * Returns `true` if the MediaKeys instance has an attached ServerCertificate.
     * Returns `false` if it doesn't.
     *
     * Returns `undefined` if we cannot know, most likely because related EME APIs
     * failed or had an unexpected behavior.
     * @param {MediaKeys} mediaKeys
     * @returns {Boolean|undefined}
     */
    hasOne(mediaKeys) {
      const currentServerCertificate = serverCertificateHashesMap.get(mediaKeys);
      if (currentServerCertificate === void 0) {
        return false;
      }
      if (currentServerCertificate === null) {
        return void 0;
      }
      return true;
    },
    /**
     * Returns `true` if the given `mediaKeys` has `serverCertificate` attached to
     * it.
     * Returns `false` either if it doesn't of if we doesn't know if it does.
     * @param {MediaKeys | Object} mediaKeys
     * @param {ArrayBufferView | BufferSource} serverCertificate
     * @returns {boolean}
     */
    has(mediaKeys, serverCertificate) {
      const serverCertificateHash = serverCertificateHashesMap.get(mediaKeys);
      if (serverCertificateHash === void 0 || serverCertificateHash === null) {
        return false;
      }
      const { hash: oldHash, serverCertificate: oldServerCertificate } = serverCertificateHash;
      const newServerCertificate = serverCertificate instanceof Uint8Array ? serverCertificate : new Uint8Array(
        serverCertificate instanceof ArrayBuffer ? serverCertificate : serverCertificate.buffer
      );
      const newHash = hashBuffer(newServerCertificate);
      if (newHash !== oldHash || oldServerCertificate.length !== newServerCertificate.length) {
        return false;
      }
      for (let i = 0; i < oldServerCertificate.length; i++) {
        if (oldServerCertificate[i] !== newServerCertificate[i]) {
          return false;
        }
      }
      return true;
    }
  };

  // src/main_thread/decrypt/get_media_keys.ts
  function createPersistentSessionsStorage(keySystemOptions) {
    const { persistentLicenseConfig } = keySystemOptions;
    if (isNullOrUndefined(persistentLicenseConfig)) {
      return null;
    }
    log_default.debug("DRM: Set the given license storage");
    return new PersistentSessionsStore(persistentLicenseConfig);
  }
  async function getMediaKeysInfos(mediaElement, keySystemsConfigs, cancelSignal) {
    const evt = await getMediaKeySystemAccess(
      mediaElement,
      keySystemsConfigs,
      cancelSignal
    );
    if (cancelSignal.cancellationError !== null) {
      throw cancelSignal.cancellationError;
    }
    const { options, mediaKeySystemAccess, askedConfiguration, codecSupport } = evt.value;
    const currentState = media_keys_infos_store_default.getState(mediaElement);
    const persistentSessionsStore = createPersistentSessionsStorage(options);
    if (canReuseMediaKeys() && currentState !== null && evt.type === "reuse-media-key-system-access") {
      const { mediaKeys: mediaKeys2, loadedSessionsStore: loadedSessionsStore2 } = currentState;
      if (server_certificate_store_default.hasOne(mediaKeys2) === false || !isNullOrUndefined(options.serverCertificate) && server_certificate_store_default.has(mediaKeys2, options.serverCertificate)) {
        return {
          mediaKeys: mediaKeys2,
          mediaKeySystemAccess,
          askedConfiguration,
          stores: { loadedSessionsStore: loadedSessionsStore2, persistentSessionsStore },
          options,
          codecSupport
        };
      }
    }
    const mediaKeys = await createMediaKeys(mediaKeySystemAccess);
    log_default.info("DRM: MediaKeys created with success");
    const loadedSessionsStore = new LoadedSessionsStore(mediaKeys);
    return {
      mediaKeys,
      mediaKeySystemAccess,
      askedConfiguration,
      stores: { loadedSessionsStore, persistentSessionsStore },
      options,
      codecSupport
    };
  }
  async function createMediaKeys(mediaKeySystemAccess) {
    log_default.info("DRM: Calling createMediaKeys on the MediaKeySystemAccess");
    try {
      const mediaKeys = await mediaKeySystemAccess.createMediaKeys();
      return mediaKeys;
    } catch (error) {
      const message = error instanceof Error ? error.message : "Unknown error when creating MediaKeys.";
      throw new EncryptedMediaError("CREATE_MEDIA_KEYS_ERROR", message);
    }
  }

  // src/main_thread/decrypt/init_media_keys.ts
  async function initMediaKeys(mediaElement, keySystemsConfigs, cancelSignal) {
    const mediaKeysInfo = await getMediaKeysInfos(
      mediaElement,
      keySystemsConfigs,
      cancelSignal
    );
    const { mediaKeys } = mediaKeysInfo;
    const shouldDisableOldMediaKeys = mediaElement.mediaKeys !== null && mediaElement.mediaKeys !== void 0 && mediaKeys !== mediaElement.mediaKeys;
    if (shouldDisableOldMediaKeys) {
      log_default.debug("DRM: Disabling old MediaKeys");
      await disableMediaKeys(mediaElement);
    }
    return mediaKeysInfo;
  }

  // src/main_thread/decrypt/session_events_listener.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/utils/retry_promise_with_backoff.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/utils/get_fuzzed_delay.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var FUZZ_FACTOR = 0.3;
  function getFuzzedDelay(retryDelay) {
    const fuzzingFactor = (Math.random() * 2 - 1) * FUZZ_FACTOR;
    return retryDelay * (fuzzingFactor + 1);
  }

  // src/utils/retry_promise_with_backoff.ts
  function retryPromiseWithBackoff(runProm, options, cancelSignal) {
    const { baseDelay, maxDelay, totalRetry, shouldRetry: shouldRetry2, onRetry } = options;
    let retryCount = 0;
    return iterate();
    async function iterate() {
      if (cancelSignal.cancellationError !== null) {
        throw cancelSignal.cancellationError;
      }
      try {
        const res = await runProm();
        return res;
      } catch (error) {
        if (cancelSignal.cancellationError !== null) {
          throw cancelSignal.cancellationError;
        }
        if (!isNullOrUndefined(shouldRetry2) && !shouldRetry2(error) || retryCount++ >= totalRetry) {
          throw error;
        }
        if (typeof onRetry === "function") {
          onRetry(error, retryCount);
        }
        const delay = getRetryDelay(baseDelay, retryCount, maxDelay);
        await sleep(delay);
        const res = iterate();
        return res;
      }
    }
  }
  function getRetryDelay(baseDelay, retryCount, maxDelay) {
    const delay = baseDelay * Math.pow(2, retryCount - 1);
    const fuzzedDelay = getFuzzedDelay(delay);
    return Math.min(fuzzedDelay, maxDelay);
  }

  // src/main_thread/decrypt/utils/check_key_statuses.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/compat/eme/get_uuid_kid_from_keystatus_kid.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function getUUIDKIDFromKeyStatusKID(keySystem, baseKeyId) {
    if (keySystem.indexOf("playready") !== -1 && (isIEOrEdge || isEdgeChromium)) {
      return guidToUuid(baseKeyId);
    }
    return baseKeyId;
  }

  // src/main_thread/decrypt/utils/check_key_statuses.ts
  var DecommissionedSessionError = class _DecommissionedSessionError extends Error {
    /**
     * Creates a new `DecommissionedSessionError`.
     * @param {Error} reason - Error that led to the decision to close the
     * current MediaKeySession. Should be used for reporting purposes.
     */
    constructor(reason) {
      super(reason.message);
      Object.setPrototypeOf(this, _DecommissionedSessionError.prototype);
      this.reason = reason;
    }
  };
  var KEY_STATUSES = {
    EXPIRED: "expired",
    INTERNAL_ERROR: "internal-error",
    OUTPUT_RESTRICTED: "output-restricted"
  };
  function checkKeyStatuses(session, options, keySystem) {
    const { onKeyInternalError, onKeyOutputRestricted, onKeyExpiration } = options;
    const blacklistedKeyIds = [];
    const whitelistedKeyIds = [];
    const badKeyStatuses = [];
    session.keyStatuses.forEach(
      (_arg1, _arg2) => {
        const [keyStatus, keyStatusKeyId] = /* @__PURE__ */ (() => {
          return typeof _arg1 === "string" ? [_arg1, _arg2] : [_arg2, _arg1];
        })();
        const keyId = getUUIDKIDFromKeyStatusKID(keySystem, new Uint8Array(keyStatusKeyId));
        const keyStatusObj = { keyId: keyId.buffer, keyStatus };
        if (log_default.hasLevel("DEBUG")) {
          log_default.debug(`DRM: key status update (${bytesToHex(keyId)}): ${keyStatus}`);
        }
        switch (keyStatus) {
          case KEY_STATUSES.EXPIRED: {
            const error = new EncryptedMediaError(
              "KEY_STATUS_CHANGE_ERROR",
              `A decryption key expired (${bytesToHex(keyId)})`,
              { keyStatuses: [keyStatusObj, ...badKeyStatuses] }
            );
            if (onKeyExpiration === "error" || onKeyExpiration === void 0) {
              throw error;
            }
            switch (onKeyExpiration) {
              case "close-session":
                throw new DecommissionedSessionError(error);
              case "fallback":
                blacklistedKeyIds.push(keyId);
                break;
              default:
                if (onKeyExpiration === "continue" || onKeyExpiration === void 0) {
                  whitelistedKeyIds.push(keyId);
                } else {
                  assertUnreachable(onKeyExpiration);
                }
                break;
            }
            badKeyStatuses.push(keyStatusObj);
            break;
          }
          case KEY_STATUSES.INTERNAL_ERROR: {
            const error = new EncryptedMediaError(
              "KEY_STATUS_CHANGE_ERROR",
              `A "${keyStatus}" status has been encountered (${bytesToHex(keyId)})`,
              { keyStatuses: [keyStatusObj, ...badKeyStatuses] }
            );
            switch (onKeyInternalError) {
              case void 0:
              case "error":
                throw error;
              case "close-session":
                throw new DecommissionedSessionError(error);
              case "fallback":
                blacklistedKeyIds.push(keyId);
                break;
              case "continue":
                whitelistedKeyIds.push(keyId);
                break;
              default:
                if (onKeyInternalError !== void 0) {
                  assertUnreachable(onKeyInternalError);
                } else {
                  throw error;
                }
            }
            badKeyStatuses.push(keyStatusObj);
            break;
          }
          case KEY_STATUSES.OUTPUT_RESTRICTED: {
            const error = new EncryptedMediaError(
              "KEY_STATUS_CHANGE_ERROR",
              `A "${keyStatus}" status has been encountered (${bytesToHex(keyId)})`,
              { keyStatuses: [keyStatusObj, ...badKeyStatuses] }
            );
            switch (onKeyOutputRestricted) {
              case void 0:
              case "error":
                throw error;
              case "fallback":
                blacklistedKeyIds.push(keyId);
                break;
              case "continue":
                whitelistedKeyIds.push(keyId);
                break;
              default:
                if (onKeyOutputRestricted !== void 0) {
                  assertUnreachable(onKeyOutputRestricted);
                } else {
                  throw error;
                }
            }
            badKeyStatuses.push(keyStatusObj);
            break;
          }
          default:
            whitelistedKeyIds.push(keyId);
            break;
        }
      }
    );
    let warning;
    if (badKeyStatuses.length > 0) {
      warning = new EncryptedMediaError(
        "KEY_STATUS_CHANGE_ERROR",
        "One or several problematic key statuses have been encountered",
        { keyStatuses: badKeyStatuses }
      );
    }
    return { warning, blacklistedKeyIds, whitelistedKeyIds };
  }

  // src/main_thread/decrypt/session_events_listener.ts
  function SessionEventsListener(session, keySystemOptions, keySystem, callbacks, cancelSignal) {
    log_default.info("DRM: Binding session events", session.sessionId);
    const { getLicenseConfig = {} } = keySystemOptions;
    const manualCanceller = new TaskCanceller();
    manualCanceller.linkToSignal(cancelSignal);
    if (!isNullOrUndefined(session.closed)) {
      session.closed.then(() => manualCanceller.cancel()).catch((err) => {
        if (cancelSignal.isCancelled()) {
          return;
        }
        manualCanceller.cancel();
        callbacks.onError(err);
      });
    }
    onKeyError(
      session,
      (evt) => {
        manualCanceller.cancel();
        callbacks.onError(new EncryptedMediaError("KEY_ERROR", evt.type));
      },
      manualCanceller.signal
    );
    onKeyStatusesChange(
      session,
      () => {
        log_default.info("DRM: keystatuseschange event received", session.sessionId);
        try {
          checkAndHandleCurrentKeyStatuses();
        } catch (error) {
          if (cancelSignal.isCancelled() || manualCanceller.isUsed() && error instanceof CancellationSignal) {
            return;
          }
          manualCanceller.cancel();
          callbacks.onError(error);
        }
      },
      manualCanceller.signal
    );
    onKeyMessage(
      session,
      (evt) => {
        const messageEvent = evt;
        const message = new Uint8Array(messageEvent.message);
        const messageType = isNonEmptyString(messageEvent.messageType) ? messageEvent.messageType : "license-request";
        log_default.info(`DRM: Received message event, type ${messageType}`, session.sessionId);
        const backoffOptions = getLicenseBackoffOptions(getLicenseConfig.retry);
        retryPromiseWithBackoff(
          () => runGetLicense(message, messageType),
          backoffOptions,
          manualCanceller.signal
        ).then((licenseObject) => {
          if (manualCanceller.isUsed()) {
            return Promise.resolve();
          }
          if (isNullOrUndefined(licenseObject)) {
            log_default.info("DRM: No license given, skipping session.update");
          } else {
            try {
              return updateSessionWithMessage(session, licenseObject);
            } catch (err) {
              manualCanceller.cancel();
              callbacks.onError(err);
            }
          }
        }).catch((err) => {
          if (manualCanceller.isUsed()) {
            return;
          }
          manualCanceller.cancel();
          const formattedError = formatGetLicenseError(err);
          if (!isNullOrUndefined(err)) {
            const { fallbackOnLastTry } = err;
            if (fallbackOnLastTry === true) {
              log_default.warn(
                "DRM: Last `getLicense` attempt failed. Blacklisting the current session."
              );
              callbacks.onError(new BlacklistedSessionError(formattedError));
              return;
            }
          }
          callbacks.onError(formattedError);
        });
      },
      manualCanceller.signal
    );
    log_default.info("DRM: transmitting current keystatuses", session.sessionId);
    checkAndHandleCurrentKeyStatuses();
    return;
    function checkAndHandleCurrentKeyStatuses() {
      if (manualCanceller.isUsed() || session.keyStatuses.size === 0) {
        return;
      }
      const { warning, blacklistedKeyIds, whitelistedKeyIds } = checkKeyStatuses(
        session,
        keySystemOptions,
        keySystem
      );
      if (warning !== void 0) {
        callbacks.onWarning(warning);
        if (manualCanceller.isUsed()) {
          return;
        }
      }
      callbacks.onKeyUpdate({ whitelistedKeyIds, blacklistedKeyIds });
    }
    function runGetLicense(message, messageType) {
      let timeoutId;
      return new Promise((res, rej) => {
        try {
          log_default.debug("DRM: Calling `getLicense`", messageType);
          const getLicense = keySystemOptions.getLicense(message, messageType);
          const getLicenseTimeout = isNullOrUndefined(getLicenseConfig.timeout) ? 10 * 1e3 : getLicenseConfig.timeout;
          if (getLicenseTimeout >= 0) {
            timeoutId = setTimeout(() => {
              rej(
                new GetLicenseTimeoutError(
                  `"getLicense" timeout exceeded (${getLicenseTimeout} ms)`
                )
              );
            }, getLicenseTimeout);
          }
          Promise.resolve(getLicense).then(clearTimeoutAndResolve, clearTimeoutAndReject);
        } catch (err) {
          clearTimeoutAndReject(err);
        }
        function clearTimeoutAndResolve(data2) {
          if (timeoutId !== void 0) {
            clearTimeout(timeoutId);
          }
          res(data2);
        }
        function clearTimeoutAndReject(err) {
          if (timeoutId !== void 0) {
            clearTimeout(timeoutId);
          }
          rej(err);
        }
      });
    }
    function getLicenseBackoffOptions(numberOfRetry) {
      return {
        totalRetry: numberOfRetry != null ? numberOfRetry : 2,
        baseDelay: 200,
        maxDelay: 3e3,
        shouldRetry: (error) => error instanceof GetLicenseTimeoutError || isNullOrUndefined(error) || error.noRetry !== true,
        onRetry: (error) => callbacks.onWarning(formatGetLicenseError(error))
      };
    }
  }
  function formatGetLicenseError(error) {
    if (error instanceof GetLicenseTimeoutError) {
      return new EncryptedMediaError(
        "KEY_LOAD_TIMEOUT",
        "The license server took too much time to respond."
      );
    }
    const err = new EncryptedMediaError(
      "KEY_LOAD_ERROR",
      "An error occured when calling `getLicense`."
    );
    if (!isNullOrUndefined(error) && isNonEmptyString(error.message)) {
      err.message = error.message;
    }
    return err;
  }
  async function updateSessionWithMessage(session, message) {
    log_default.info("DRM: Updating MediaKeySession with message");
    try {
      await session.update(message);
    } catch (error) {
      const reason = error instanceof Error ? error.toString() : "`session.update` failed";
      throw new EncryptedMediaError("KEY_UPDATE_ERROR", reason);
    }
    log_default.info("DRM: MediaKeySession update succeeded.");
  }
  var BlacklistedSessionError = class _BlacklistedSessionError extends Error {
    constructor(sessionError) {
      super(sessionError.message);
      Object.setPrototypeOf(this, _BlacklistedSessionError.prototype);
      this.sessionError = sessionError;
    }
  };
  var GetLicenseTimeoutError = class extends Error {
    constructor(message) {
      super(message);
      Object.setPrototypeOf(this, BlacklistedSessionError.prototype);
      this.message = message;
    }
  };

  // src/main_thread/decrypt/set_server_certificate.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  async function setServerCertificate(mediaKeys, serverCertificate) {
    try {
      const res = await mediaKeys.setServerCertificate(serverCertificate);
      return res;
    } catch (error) {
      log_default.warn(
        "DRM: mediaKeys.setServerCertificate returned an error",
        error instanceof Error ? error : ""
      );
      const reason = error instanceof Error ? error.toString() : "`setServerCertificate` error";
      throw new EncryptedMediaError("LICENSE_SERVER_CERTIFICATE_ERROR", reason);
    }
  }
  async function trySettingServerCertificate(mediaKeys, serverCertificate) {
    if (server_certificate_store_default.hasOne(mediaKeys) === true) {
      log_default.info("DRM: The MediaKeys already has a server certificate, skipping...");
      return { type: "already-has-one" };
    }
    if (typeof mediaKeys.setServerCertificate !== "function") {
      log_default.warn(
        "DRM: Could not set the server certificate. mediaKeys.setServerCertificate is not a function"
      );
      return { type: "method-not-implemented" };
    }
    log_default.info("DRM: Setting server certificate on the MediaKeys");
    server_certificate_store_default.prepare(mediaKeys);
    try {
      const result = await setServerCertificate(mediaKeys, serverCertificate);
      server_certificate_store_default.set(mediaKeys, serverCertificate);
      return { type: "success", value: result };
    } catch (error) {
      const formattedErr = isKnownError(error) ? error : new EncryptedMediaError(
        "LICENSE_SERVER_CERTIFICATE_ERROR",
        "Unknown error when setting the server certificate."
      );
      return { type: "error", value: formattedErr };
    }
  }

  // src/main_thread/decrypt/utils/clean_old_stored_persistent_info.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function cleanOldStoredPersistentInfo(persistentSessionsStore, limit) {
    if (isNaN(limit) || limit < 0 || limit >= persistentSessionsStore.getLength()) {
      return;
    }
    const numberOfPersistentSessions = persistentSessionsStore.getLength();
    const toDelete = numberOfPersistentSessions - limit;
    log_default.info(
      "DRM: Too many stored persistent sessions, removing some.",
      numberOfPersistentSessions,
      toDelete
    );
    persistentSessionsStore.deleteOldSessions(toDelete);
  }

  // src/main_thread/decrypt/utils/get_drm_system_id.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function getDrmSystemId(keySystem) {
    if (startsWith(keySystem, "com.microsoft.playready") || keySystem === "com.chromecast.playready" || keySystem === "com.youtube.playready") {
      return "9a04f07998404286ab92e65be0885f95";
    }
    if (keySystem === "com.widevine.alpha") {
      return "edef8ba979d64acea3c827dcd51d21ed";
    }
    if (startsWith(keySystem, "com.apple.fps")) {
      return "94ce86fb07ff4f43adb893d2fa968ca2";
    }
    if (startsWith(keySystem, "com.nagra.")) {
      return "adb41c242dbf4a6d958b4457c0d27b95";
    }
    return void 0;
  }

  // src/main_thread/decrypt/utils/init_data_values_container.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var InitDataValuesContainer = class _InitDataValuesContainer {
    /**
     * Construct a new `InitDataValuesContainer`.
     * Note that the data is not formatted right away.
     * It is only really formatted lazily the first time we need it.
     *
     * @param {Array.<Object>} initDataValues
     */
    constructor(initDataValues) {
      this._innerValues = initDataValues;
      this._lazyFormattedValues = null;
    }
    /**
     * Construct data that should be given to the `generateRequest` EME API.
     * @returns {Uint8Array}
     */
    constructRequestData() {
      return concat(...this._innerValues.map((i) => i.data));
    }
    /**
     * Returns `true` if the given `InitDataValuesContainer` seems to be
     * "compatible" with the one stored in this instance.
     * Returns `false` if not.
     *
     * By "compatible" we mean that it will generate the same key request.
     * @param {InitDataValuesContainer | Object} initDataValues
     * @returns {boolean}
     */
    isCompatibleWith(initDataValues) {
      const formatted = initDataValues instanceof _InitDataValuesContainer ? initDataValues.getFormattedValues() : initDataValues;
      return areInitializationValuesCompatible(this.getFormattedValues(), formatted);
    }
    /**
     * Return the stored initialization data values, with added niceties:
     *   - they are sorted always the same way for similar
     *     `InitDataValuesContainer`
     *   - each value is associated to its hash, which is always done with  the
     *     same hashing function than for all other InitDataValuesContainer).
     *
     * The main point being to be able to compare much faster multiple
     * `InitDataValuesContainer`, though that data can also be used in any
     * other way.
     * @returns {Array.<Object>}
     */
    getFormattedValues() {
      if (this._lazyFormattedValues === null) {
        this._lazyFormattedValues = formatInitDataValues(this._innerValues);
      }
      return this._lazyFormattedValues;
    }
  };
  function formatInitDataValues(initialValues) {
    return initialValues.slice().sort((a, b) => {
      if (a.systemId === b.systemId) {
        return 0;
      }
      if (a.systemId === void 0) {
        return 1;
      }
      if (b.systemId === void 0) {
        return -1;
      }
      if (a.systemId < b.systemId) {
        return -1;
      }
      return 1;
    }).map(({ systemId, data: data2 }) => ({ systemId, data: data2, hash: hashBuffer(data2) }));
  }

  // src/main_thread/decrypt/utils/is_compatible_codec_supported.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function isCompatibleCodecSupported(mimeType, codec, codecList) {
    const inputCodec = `${mimeType};codecs="${codec}"`;
    const sameMimeTypeCodec = codecList.filter((c) => c.mimeType === mimeType);
    if (sameMimeTypeCodec.length === 0) {
      return void 0;
    }
    for (const {
      codec: currentCodec,
      mimeType: currentMimeType,
      result
    } of sameMimeTypeCodec) {
      const existingCodec = `${currentMimeType};codecs="${currentCodec}"`;
      if (are_codecs_compatible_default(inputCodec, existingCodec)) {
        return result;
      }
    }
    return void 0;
  }

  // src/main_thread/decrypt/content_decryptor.ts
  var ContentDecryptor = class extends EventEmitter {
    /**
     * `true` if the EME API are available on the current platform according to
     * the default EME implementation used.
     * `false` otherwise.
     * @returns {boolean}
     */
    static hasEmeApis() {
      return !isNullOrUndefined(eme_default.requestMediaKeySystemAccess);
    }
    /**
     * Create a new `ContentDecryptor`, and initialize its decryption capabilities
     * right away.
     * Goes into the `WaitingForAttachment` state once that initialization is
     * done, after which you should call the `attach` method when you're ready for
     * those decryption capabilities to be attached to the HTMLMediaElement.
     *
     * @param {HTMLMediaElement} mediaElement - The MediaElement which will be
     * associated to a MediaKeys object
     * @param {Array.<Object>} ksOptions - key system configuration.
     * The `ContentDecryptor` can be given one or multiple key system
     * configurations. It will choose the appropriate one depending on user
     * settings and browser support.
     */
    constructor(mediaElement, ksOptions) {
      super();
      log_default.debug("DRM: Starting ContentDecryptor logic.");
      const canceller = new TaskCanceller();
      this._currentSessions = [];
      this._canceller = canceller;
      this._initDataQueue = [];
      this._stateData = {
        state: 0 /* Initializing */,
        isMediaKeysAttached: 0 /* NotAttached */,
        isInitDataQueueLocked: true,
        data: null
      };
      this._supportedCodecWhenEncrypted = [];
      this.error = null;
      eme_default.onEncrypted(
        mediaElement,
        (evt) => {
          log_default.debug("DRM: Encrypted event received from media element.");
          const initData = getInitData(evt);
          if (initData !== null) {
            this.onInitializationData(initData);
          }
        },
        canceller.signal
      );
      initMediaKeys(mediaElement, ksOptions, canceller.signal).then((mediaKeysInfo) => {
        const { options, mediaKeySystemAccess } = mediaKeysInfo;
        this._supportedCodecWhenEncrypted = mediaKeysInfo.codecSupport;
        let systemId;
        if (isNullOrUndefined(options.persistentLicenseConfig) || options.persistentLicenseConfig.disableRetroCompatibility === true) {
          systemId = getDrmSystemId(mediaKeySystemAccess.keySystem);
        }
        this.systemId = systemId;
        if (this._stateData.state === 0 /* Initializing */) {
          this._stateData = {
            state: 1 /* WaitingForAttachment */,
            isInitDataQueueLocked: true,
            isMediaKeysAttached: 0 /* NotAttached */,
            data: { mediaKeysInfo, mediaElement }
          };
          this.trigger("stateChange", this._stateData.state);
        }
      }).catch((err) => {
        this._onFatalError(err);
      });
    }
    /**
     * Returns the current state of the ContentDecryptor.
     * @see ContentDecryptorState
     * @returns {Object}
     */
    getState() {
      return this._stateData.state;
    }
    /**
     * Attach the current decryption capabilities to the HTMLMediaElement.
     * This method should only be called once the `ContentDecryptor` is in the
     * `WaitingForAttachment` state.
     *
     * You might want to first set the HTMLMediaElement's `src` attribute before
     * calling this method, and only push data to it once the `ReadyForContent`
     * state is reached, for compatibility reasons.
     */
    attach() {
      if (this._stateData.state !== 1 /* WaitingForAttachment */) {
        throw new Error(
          "`attach` should only be called when in the WaitingForAttachment state"
        );
      } else if (this._stateData.isMediaKeysAttached !== 0 /* NotAttached */) {
        log_default.warn("DRM: ContentDecryptor's `attach` method called more than once.");
        return;
      }
      const { mediaElement, mediaKeysInfo } = this._stateData.data;
      const { options, mediaKeys, mediaKeySystemAccess, stores, askedConfiguration } = mediaKeysInfo;
      const shouldDisableLock = options.disableMediaKeysAttachmentLock === true;
      if (shouldDisableLock) {
        this._stateData = {
          state: 2 /* ReadyForContent */,
          isInitDataQueueLocked: true,
          isMediaKeysAttached: 1 /* Pending */,
          data: { mediaKeysInfo, mediaElement }
        };
        this.trigger("stateChange", this._stateData.state);
        if (this._isStopped()) {
          return;
        }
      }
      this._stateData.isMediaKeysAttached = 1 /* Pending */;
      const stateToAttach = {
        emeImplementation: eme_default,
        loadedSessionsStore: stores.loadedSessionsStore,
        mediaKeySystemAccess,
        mediaKeys,
        askedConfiguration,
        keySystemOptions: options
      };
      log_default.debug("DRM: Attaching current MediaKeys");
      attachMediaKeys(mediaElement, stateToAttach, this._canceller.signal).then(async () => {
        this._stateData.isMediaKeysAttached = 2 /* Attached */;
        const { serverCertificate } = options;
        if (!isNullOrUndefined(serverCertificate)) {
          const resSsc = await trySettingServerCertificate(mediaKeys, serverCertificate);
          if (resSsc.type === "error") {
            this.trigger("warning", resSsc.value);
          }
        }
        if (this._isStopped()) {
          return;
        }
        const prevState = this._stateData.state;
        this._stateData = {
          state: 2 /* ReadyForContent */,
          isMediaKeysAttached: 2 /* Attached */,
          isInitDataQueueLocked: false,
          data: { mediaKeysData: mediaKeysInfo }
        };
        if (prevState !== 2 /* ReadyForContent */) {
          this.trigger("stateChange", 2 /* ReadyForContent */);
        }
        if (!this._isStopped()) {
          this._processCurrentInitDataQueue();
        }
      }).catch((err) => {
        this._onFatalError(err);
      });
    }
    /**
     * Stop this `ContentDecryptor` instance:
     *   - stop listening and reacting to the various event listeners
     *   - abort all operations.
     *
     * Once disposed, a `ContentDecryptor` cannot be used anymore.
     */
    dispose() {
      this.removeEventListener();
      this._stateData = {
        state: 4 /* Disposed */,
        isMediaKeysAttached: void 0,
        isInitDataQueueLocked: void 0,
        data: null
      };
      this._canceller.cancel();
      this.trigger("stateChange", this._stateData.state);
    }
    /**
     * Returns `true` if the given mimeType and codec couple should be supported
     * by the current key system.
     * Returns `false` if it isn't.
     *
     * Returns `undefined` if we cannot determine if it is supported.
     *
     * @param {string} mimeType
     * @param {string} codec
     * @returns {boolean}
     */
    isCodecSupported(mimeType, codec) {
      if (this._stateData.state === 0 /* Initializing */) {
        log_default.error(
          "DRM: Asking for codec support while the ContentDecryptor is still initializing"
        );
        return void 0;
      }
      if (this._stateData.state === 3 /* Error */ || this._stateData.state === 4 /* Disposed */) {
        log_default.error("DRM: Asking for codec support while the ContentDecryptor is disposed");
      }
      return isCompatibleCodecSupported(mimeType, codec, this._supportedCodecWhenEncrypted);
    }
    /**
     * Method to call when new protection initialization data is encounted on the
     * content.
     *
     * When called, the `ContentDecryptor` will try to obtain the decryption key
     * if not already obtained.
     *
     * @param {Object} initializationData
     */
    onInitializationData(initializationData) {
      if (this._stateData.isInitDataQueueLocked !== false) {
        if (this._isStopped()) {
          throw new Error("ContentDecryptor either disposed or stopped.");
        }
        this._initDataQueue.push(initializationData);
        return;
      }
      const { mediaKeysData } = this._stateData.data;
      const processedInitializationData = __spreadProps(__spreadValues({}, initializationData), {
        values: new InitDataValuesContainer(initializationData.values)
      });
      this._processInitializationData(processedInitializationData, mediaKeysData).catch(
        (err) => {
          this._onFatalError(err);
        }
      );
    }
    /**
     * Async logic run each time new initialization data has to be processed.
     * The promise return may reject, in which case a fatal error should be linked
     * the current `ContentDecryptor`.
     *
     * The Promise's resolution however provides no semantic value.
     * @param {Object} initializationData
     * @returns {Promise.<void>}
     */
    async _processInitializationData(initializationData, mediaKeysData) {
      var _a, _b, _c;
      if (log_default.hasLevel("DEBUG")) {
        log_default.debug(
          "DRM: processing init data",
          (_a = initializationData.content) == null ? void 0 : _a.adaptation.type,
          (_b = initializationData.content) == null ? void 0 : _b.representation.bitrate,
          ((_c = initializationData.keyIds) != null ? _c : []).map((k) => bytesToHex(k)).join(", ")
        );
      }
      const { mediaKeySystemAccess, stores, options } = mediaKeysData;
      if (this._tryToUseAlreadyCreatedSession(initializationData, mediaKeysData) || this._isStopped()) {
        return;
      }
      if (options.singleLicensePer === "content") {
        const firstCreatedSession = arrayFind(
          this._currentSessions,
          (x) => x.source === "created-session" /* Created */
        );
        if (firstCreatedSession !== void 0) {
          const keyIds = initializationData.keyIds;
          if (keyIds === void 0) {
            if (initializationData.content === void 0) {
              log_default.warn("DRM: Unable to fallback from a non-decipherable quality.");
            } else {
              log_default.debug(
                "DRM: Blacklisting new init data (due to singleLicensePer content policy)"
              );
              this.trigger("blackListProtectionData", initializationData);
            }
            return;
          }
          firstCreatedSession.record.associateKeyIds(keyIds);
          if (initializationData.content === void 0) {
            log_default.warn("DRM: Unable to fallback from a non-decipherable quality.");
          } else {
            if (log_default.hasLevel("DEBUG")) {
              const hexKids = keyIds.reduce((acc, kid) => `${acc}, ${bytesToHex(kid)}`, "");
              log_default.debug("DRM: Blacklisting new key ids", hexKids);
            }
            this.trigger("keyIdsCompatibilityUpdate", {
              whitelistedKeyIds: [],
              blacklistedKeyIds: keyIds,
              delistedKeyIds: []
            });
          }
          return;
        }
      } else if (options.singleLicensePer === "periods" && initializationData.content !== void 0) {
        const { period } = initializationData.content;
        const createdSessions = this._currentSessions.filter(
          (x) => x.source === "created-session" /* Created */
        );
        const periodKeys = /* @__PURE__ */ new Set();
        addKeyIdsFromPeriod(periodKeys, period);
        for (const createdSess of createdSessions) {
          const periodKeysArr = Array.from(periodKeys);
          for (const kid of periodKeysArr) {
            if (createdSess.record.isAssociatedWithKeyId(kid)) {
              createdSess.record.associateKeyIds(periodKeys.values());
              for (const innerKid of periodKeysArr) {
                if (!createdSess.keyStatuses.whitelisted.some(
                  (k) => areArraysOfNumbersEqual(k, innerKid)
                ) && !createdSess.keyStatuses.blacklisted.some(
                  (k) => areArraysOfNumbersEqual(k, innerKid)
                )) {
                  createdSess.keyStatuses.blacklisted.push(innerKid);
                }
              }
              if (log_default.hasLevel("DEBUG")) {
                log_default.debug(
                  "DRM: Session already created for",
                  bytesToHex(kid),
                  'under singleLicensePer "periods" policy'
                );
              }
              this.trigger("keyIdsCompatibilityUpdate", {
                whitelistedKeyIds: createdSess.keyStatuses.whitelisted,
                blacklistedKeyIds: createdSess.keyStatuses.blacklisted,
                delistedKeyIds: []
              });
              return;
            }
          }
        }
      }
      this._lockInitDataQueue();
      let wantedSessionType;
      if (isNullOrUndefined(options.persistentLicenseConfig)) {
        wantedSessionType = "temporary";
      } else if (!canCreatePersistentSession(mediaKeySystemAccess)) {
        log_default.warn('DRM: Cannot create "persistent-license" session: not supported');
        wantedSessionType = "temporary";
      } else {
        wantedSessionType = "persistent-license";
      }
      const {
        EME_DEFAULT_MAX_SIMULTANEOUS_MEDIA_KEY_SESSIONS,
        EME_MAX_STORED_PERSISTENT_SESSION_INFORMATION
      } = config_default.getCurrent();
      const maxSessionCacheSize = typeof options.maxSessionCacheSize === "number" ? options.maxSessionCacheSize : EME_DEFAULT_MAX_SIMULTANEOUS_MEDIA_KEY_SESSIONS;
      const sessionRes = await createOrLoadSession(
        initializationData,
        stores,
        wantedSessionType,
        maxSessionCacheSize,
        this._canceller.signal
      );
      if (this._isStopped()) {
        return;
      }
      const sessionInfo = {
        record: sessionRes.value.keySessionRecord,
        source: sessionRes.type,
        keyStatuses: { whitelisted: [], blacklisted: [] },
        blacklistedSessionError: null
      };
      this._currentSessions.push(sessionInfo);
      const { mediaKeySession, sessionType } = sessionRes.value;
      let isSessionPersisted = false;
      SessionEventsListener(
        mediaKeySession,
        options,
        mediaKeySystemAccess.keySystem,
        {
          onKeyUpdate: (value) => {
            const linkedKeys = getKeyIdsLinkedToSession(
              initializationData,
              sessionInfo.record,
              options.singleLicensePer,
              sessionInfo.source === "created-session" /* Created */,
              value.whitelistedKeyIds,
              value.blacklistedKeyIds
            );
            sessionInfo.record.associateKeyIds(linkedKeys.whitelisted);
            sessionInfo.record.associateKeyIds(linkedKeys.blacklisted);
            sessionInfo.keyStatuses = {
              whitelisted: linkedKeys.whitelisted,
              blacklisted: linkedKeys.blacklisted
            };
            if (sessionInfo.record.getAssociatedKeyIds().length !== 0 && sessionType === "persistent-license" && stores.persistentSessionsStore !== null && !isSessionPersisted) {
              const { persistentSessionsStore } = stores;
              cleanOldStoredPersistentInfo(
                persistentSessionsStore,
                EME_MAX_STORED_PERSISTENT_SESSION_INFORMATION - 1
              );
              persistentSessionsStore.add(
                initializationData,
                sessionInfo.record.getAssociatedKeyIds(),
                mediaKeySession
              );
              isSessionPersisted = true;
            }
            if (initializationData.content !== void 0) {
              this.trigger("keyIdsCompatibilityUpdate", {
                whitelistedKeyIds: linkedKeys.whitelisted,
                blacklistedKeyIds: linkedKeys.blacklisted,
                delistedKeyIds: []
              });
            }
            this._unlockInitDataQueue();
          },
          onWarning: (value) => {
            this.trigger("warning", value);
          },
          onError: (err) => {
            var _a2;
            if (err instanceof DecommissionedSessionError) {
              log_default.warn("DRM: A session's closing condition has been triggered");
              this._lockInitDataQueue();
              const indexOf = this._currentSessions.indexOf(sessionInfo);
              if (indexOf >= 0) {
                this._currentSessions.splice(indexOf);
              }
              if (initializationData.content !== void 0) {
                this.trigger("keyIdsCompatibilityUpdate", {
                  whitelistedKeyIds: [],
                  blacklistedKeyIds: [],
                  delistedKeyIds: sessionInfo.record.getAssociatedKeyIds()
                });
              }
              (_a2 = stores.persistentSessionsStore) == null ? void 0 : _a2.delete(mediaKeySession.sessionId);
              stores.loadedSessionsStore.closeSession(mediaKeySession).catch((e) => {
                const closeError = e instanceof Error ? e : "unknown error";
                log_default.warn("DRM: failed to close expired session", closeError);
              }).then(() => this._unlockInitDataQueue()).catch((retryError) => this._onFatalError(retryError));
              if (!this._isStopped()) {
                this.trigger("warning", err.reason);
              }
              return;
            }
            if (!(err instanceof BlacklistedSessionError)) {
              this._onFatalError(err);
              return;
            }
            sessionInfo.blacklistedSessionError = err;
            if (initializationData.content !== void 0) {
              log_default.info("DRM: blacklisting Representations based on protection data.");
              this.trigger("blackListProtectionData", initializationData);
            }
            this._unlockInitDataQueue();
          }
        },
        this._canceller.signal
      );
      if (options.singleLicensePer === void 0 || options.singleLicensePer === "init-data") {
        this._unlockInitDataQueue();
      }
      if (sessionRes.type === "created-session" /* Created */) {
        const requestData = initializationData.values.constructRequestData();
        try {
          await stores.loadedSessionsStore.generateLicenseRequest(
            mediaKeySession,
            initializationData.type,
            requestData
          );
        } catch (error) {
          const entry = stores.loadedSessionsStore.getEntryForSession(mediaKeySession);
          if (entry === null || entry.closingStatus.type !== "none") {
            const indexInCurrent = this._currentSessions.indexOf(sessionInfo);
            if (indexInCurrent >= 0) {
              this._currentSessions.splice(indexInCurrent, 1);
            }
            return Promise.resolve();
          }
          throw new EncryptedMediaError(
            "KEY_GENERATE_REQUEST_ERROR",
            error instanceof Error ? error.toString() : "Unknown error"
          );
        }
      }
      return Promise.resolve();
    }
    _tryToUseAlreadyCreatedSession(initializationData, mediaKeysData) {
      const { stores, options } = mediaKeysData;
      const compatibleSessionInfo = arrayFind(
        this._currentSessions,
        (x) => x.record.isCompatibleWith(initializationData)
      );
      if (compatibleSessionInfo === void 0) {
        return false;
      }
      const forceSessionRecreation = initializationData.forceSessionRecreation;
      if (forceSessionRecreation === true) {
        this.removeSessionForInitData(initializationData, mediaKeysData);
        return false;
      }
      const blacklistedSessionError = compatibleSessionInfo.blacklistedSessionError;
      if (!isNullOrUndefined(blacklistedSessionError)) {
        if (initializationData.type === void 0 || initializationData.content === void 0) {
          log_default.error(
            "DRM: This initialization data has already been blacklisted but the current content is not known."
          );
          return true;
        } else {
          log_default.info(
            "DRM: This initialization data has already been blacklisted. Blacklisting the related content."
          );
          this.trigger("blackListProtectionData", initializationData);
          return true;
        }
      }
      if (initializationData.keyIds !== void 0) {
        let isUndecipherable;
        if (options.singleLicensePer === void 0 || options.singleLicensePer === "init-data") {
          const { blacklisted } = compatibleSessionInfo.keyStatuses;
          isUndecipherable = areSomeKeyIdsContainedIn(
            initializationData.keyIds,
            blacklisted
          );
        } else {
          const { whitelisted } = compatibleSessionInfo.keyStatuses;
          isUndecipherable = !areAllKeyIdsContainedIn(
            initializationData.keyIds,
            whitelisted
          );
        }
        if (isUndecipherable) {
          if (initializationData.content === void 0) {
            log_default.error("DRM: Cannot forbid key id, the content is unknown.");
            return true;
          }
          log_default.info(
            "DRM: Current initialization data is linked to blacklisted keys. Marking Representations as not decipherable"
          );
          this.trigger("keyIdsCompatibilityUpdate", {
            whitelistedKeyIds: [],
            blacklistedKeyIds: initializationData.keyIds,
            delistedKeyIds: []
          });
          return true;
        }
      }
      const entry = stores.loadedSessionsStore.reuse(initializationData);
      if (entry !== null) {
        log_default.debug("DRM: Init data already processed. Skipping it.");
        return true;
      }
      const indexOf = this._currentSessions.indexOf(compatibleSessionInfo);
      if (indexOf === -1) {
        log_default.error("DRM: Unable to remove processed init data: not found.");
      } else {
        log_default.debug(
          "DRM: A session from a processed init data is not available anymore. Re-processing it."
        );
        this._currentSessions.splice(indexOf, 1);
      }
      return false;
    }
    /**
     * Remove the session corresponding to the initData provided, and close it.
     * It does nothing if no session was found for this initData.
     * @param {Object} initData : The initialization data corresponding to the session
     * that need to be removed
     * @param {Object} mediaKeysData : The media keys data
     */
    removeSessionForInitData(initData, mediaKeysData) {
      const { stores } = mediaKeysData;
      const entry = stores.loadedSessionsStore.reuse(initData);
      if (entry !== null) {
        stores.loadedSessionsStore.closeSession(entry.mediaKeySession).catch(
          () => log_default.error("DRM: Cannot close the session from the loaded session store")
        );
      }
      const compatibleSessionInfo = arrayFind(
        this._currentSessions,
        (x) => x.record.isCompatibleWith(initData)
      );
      if (compatibleSessionInfo === void 0) {
        return;
      }
      const indexOf = this._currentSessions.indexOf(compatibleSessionInfo);
      if (indexOf !== -1) {
        log_default.debug(
          "DRM: A session from a processed init is removed due to forceSessionRecreation policy."
        );
        this._currentSessions.splice(indexOf, 1);
      }
    }
    /**
     * Callback that should be called if an error that made the current
     * `ContentDecryptor` instance unusable arised.
     * This callbacks takes care of resetting state and sending the right events.
     *
     * Once called, no further actions should be taken.
     *
     * @param {*} err - The error object which describes the issue. Will be
     * formatted and sent in an "error" event.
     */
    _onFatalError(err) {
      if (this._canceller.isUsed()) {
        return;
      }
      const formattedErr = err instanceof Error ? err : new OtherError("NONE", "Unknown decryption error");
      this.error = formattedErr;
      this._initDataQueue.length = 0;
      this._stateData = {
        state: 3 /* Error */,
        isMediaKeysAttached: void 0,
        isInitDataQueueLocked: void 0,
        data: null
      };
      this._canceller.cancel();
      this.trigger("error", formattedErr);
      if (this._stateData.state === 3 /* Error */) {
        this.trigger("stateChange", this._stateData.state);
      }
    }
    /**
     * Return `true` if the `ContentDecryptor` has either been disposed or
     * encountered a fatal error which made it stop.
     * @returns {boolean}
     */
    _isStopped() {
      return this._stateData.state === 4 /* Disposed */ || this._stateData.state === 3 /* Error */;
    }
    /**
     * Start processing the next initialization data of the `_initDataQueue` if it
     * isn't lock.
     */
    _processCurrentInitDataQueue() {
      while (this._stateData.isInitDataQueueLocked === false) {
        const initData = this._initDataQueue.shift();
        if (initData === void 0) {
          return;
        }
        this.onInitializationData(initData);
      }
    }
    /**
     * Lock new initialization data (from the `_initDataQueue`) from being
     * processed until `_unlockInitDataQueue` is called.
     *
     * You may want to call this method when performing operations which may have
     * an impact on the handling of other initialization data.
     */
    _lockInitDataQueue() {
      if (this._stateData.isInitDataQueueLocked === false) {
        this._stateData.isInitDataQueueLocked = true;
      }
    }
    /**
     * Unlock `_initDataQueue` and start processing the first element.
     *
     * Should have no effect if the `_initDataQueue` was not locked.
     */
    _unlockInitDataQueue() {
      if (this._stateData.isMediaKeysAttached !== 2 /* Attached */) {
        log_default.error("DRM: Trying to unlock in the wrong state");
        return;
      }
      this._stateData.isInitDataQueueLocked = false;
      this._processCurrentInitDataQueue();
    }
  };
  function canCreatePersistentSession(mediaKeySystemAccess) {
    const { sessionTypes } = mediaKeySystemAccess.getConfiguration();
    return sessionTypes !== void 0 && arrayIncludes(sessionTypes, "persistent-license");
  }
  function getMissingKeyIds(expectedKeyIds, actualKeyIds) {
    return expectedKeyIds.filter((expected) => {
      return !actualKeyIds.some((actual) => areArraysOfNumbersEqual(actual, expected));
    });
  }
  function getMissingKnownKeyIds(keySessionRecord, newKeyIds) {
    const allKnownKeyIds = keySessionRecord.getAssociatedKeyIds();
    const missingKeyIds = getMissingKeyIds(allKnownKeyIds, newKeyIds);
    if (missingKeyIds.length > 0 && log_default.hasLevel("DEBUG")) {
      log_default.debug(
        "DRM: KeySessionRecord's keys missing in the license, blacklisting them",
        missingKeyIds.map((m) => bytesToHex(m)).join(", ")
      );
    }
    return missingKeyIds;
  }
  function getMissingInitDataKeyIds(initializationData, newKeyIds) {
    let missingKeyIds = [];
    const { keyIds: expectedKeyIds } = initializationData;
    if (expectedKeyIds !== void 0) {
      missingKeyIds = getMissingKeyIds(expectedKeyIds, newKeyIds);
    }
    if (missingKeyIds.length > 0 && log_default.hasLevel("DEBUG")) {
      log_default.debug(
        "DRM: init data keys missing in the license, blacklisting them",
        missingKeyIds.map((m) => bytesToHex(m)).join(", ")
      );
    }
    return missingKeyIds;
  }
  function getKeyIdsLinkedToSession(initializationData, keySessionRecord, singleLicensePer, isCurrentLicense, usableKeyIds, unusableKeyIds) {
    var _a;
    const keyIdsInLicense = [...usableKeyIds, ...unusableKeyIds];
    const missingKnownKeyIds = getMissingKnownKeyIds(keySessionRecord, keyIdsInLicense);
    const associatedKeyIds = keyIdsInLicense.concat(missingKnownKeyIds);
    if (singleLicensePer !== void 0 && singleLicensePer !== "init-data") {
      const missingInitDataKeyIds = getMissingInitDataKeyIds(
        initializationData,
        associatedKeyIds
      );
      associatedKeyIds.push(...missingInitDataKeyIds);
      const { content } = initializationData;
      if (isCurrentLicense && content !== void 0) {
        if (singleLicensePer === "content") {
          const contentKeys = /* @__PURE__ */ new Set();
          const { manifest } = content;
          for (const period of manifest.periods) {
            addKeyIdsFromPeriod(contentKeys, period);
          }
          mergeKeyIdSetIntoArray(contentKeys, associatedKeyIds);
        } else if (singleLicensePer === "periods") {
          const { manifest } = content;
          for (const period of manifest.periods) {
            const periodKeys = /* @__PURE__ */ new Set();
            addKeyIdsFromPeriod(periodKeys, period);
            if (((_a = initializationData.content) == null ? void 0 : _a.period.id) === period.id) {
              mergeKeyIdSetIntoArray(periodKeys, associatedKeyIds);
            } else {
              const periodKeysArr = Array.from(periodKeys);
              for (const kid of periodKeysArr) {
                const isFound = associatedKeyIds.some(
                  (k) => areArraysOfNumbersEqual(k, kid)
                );
                if (isFound) {
                  mergeKeyIdSetIntoArray(periodKeys, associatedKeyIds);
                  break;
                }
              }
            }
          }
        }
      }
    }
    return {
      whitelisted: usableKeyIds,
      /** associatedKeyIds starts with the whitelisted one. */
      blacklisted: associatedKeyIds.slice(usableKeyIds.length)
    };
  }
  function mergeKeyIdSetIntoArray(set2, arr) {
    const setArr = Array.from(set2.values());
    for (const kid of setArr) {
      const isFound = arr.some((k) => areArraysOfNumbersEqual(k, kid));
      if (!isFound) {
        arr.push(kid);
      }
    }
  }
  function addKeyIdsFromPeriod(set2, period) {
    const adaptationsByType = period.adaptations;
    const adaptations = objectValues(adaptationsByType).reduce(
      // Note: the second case cannot happen. TS is just being dumb here
      (acc, adaps) => !isNullOrUndefined(adaps) ? acc.concat(adaps) : acc,
      []
    );
    for (const adaptation of adaptations) {
      for (const representation of adaptation.representations) {
        if (representation.contentProtections !== void 0 && representation.contentProtections.keyIds !== void 0) {
          for (const kid of representation.contentProtections.keyIds) {
            set2.add(kid);
          }
        }
      }
    }
  }

  // src/main_thread/decrypt/get_key_system_configuration.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function getKeySystemConfiguration(mediaElement) {
    const currentState = media_keys_infos_store_default.getState(mediaElement);
    if (currentState === null) {
      return null;
    }
    return [
      currentState.mediaKeySystemAccess.keySystem,
      currentState.mediaKeySystemAccess.getConfiguration()
    ];
  }

  // src/main_thread/decrypt/index.ts
  var decrypt_default = ContentDecryptor;

  // src/main_thread/init/utils/update_manifest_codec_support.ts
  function getCodecsWithUnknownSupport(manifest) {
    var _a, _b, _c, _d, _e;
    const codecsWithUnknownSupport = [];
    for (const period of manifest.periods) {
      const checkedAdaptations = [
        ...(_a = period.adaptations.video) != null ? _a : [],
        ...(_b = period.adaptations.audio) != null ? _b : []
      ];
      for (const adaptation of checkedAdaptations) {
        if (!adaptation.supportStatus.hasCodecWithUndefinedSupport) {
          continue;
        }
        for (const representation of adaptation.representations) {
          if (representation.isSupported === void 0) {
            codecsWithUnknownSupport.push({
              mimeType: (_c = representation.mimeType) != null ? _c : "",
              codec: (_e = (_d = representation.codecs) == null ? void 0 : _d[0]) != null ? _e : ""
            });
          }
        }
      }
    }
    return codecsWithUnknownSupport;
  }
  function updateManifestCodecSupport(manifest, contentDecryptor) {
    const codecSupportMap = /* @__PURE__ */ new Map();
    const updatedCodecs = [];
    const efficientlyGetCodecSupport = (mimeType, codec) => {
      var _a;
      const inputCodec = `${mimeType != null ? mimeType : ""};codecs="${codec != null ? codec : ""}"`;
      const baseData = codecSupportMap.get(inputCodec);
      if (baseData !== void 0) {
        return baseData;
      }
      let newData;
      const isSupported = isCodecSupported(inputCodec);
      if (!isSupported) {
        newData = {
          isSupportedClear: false,
          isSupportedEncrypted: false
        };
      } else if (isNullOrUndefined(contentDecryptor)) {
        newData = {
          isSupportedClear: true,
          // This is ambiguous. Less assume that with no ContentDecryptor, an
          // encrypted codec is supported
          isSupportedEncrypted: true
        };
      } else if (contentDecryptor.getState() === 0 /* Initializing */) {
        newData = {
          isSupportedClear: true,
          isSupportedEncrypted: void 0
        };
      } else {
        newData = {
          isSupportedClear: true,
          isSupportedEncrypted: (_a = contentDecryptor.isCodecSupported(mimeType != null ? mimeType : "", codec != null ? codec : "")) != null ? _a : true
        };
      }
      codecSupportMap.set(inputCodec, newData);
      updatedCodecs.push({
        codec: codec != null ? codec : "",
        mimeType: mimeType != null ? mimeType : "",
        supported: newData.isSupportedClear,
        supportedIfEncrypted: newData.isSupportedEncrypted
      });
      return newData;
    };
    manifest.periods.forEach((p) => {
      var _a, _b, _c;
      [
        ...(_a = p.adaptations.audio) != null ? _a : [],
        ...(_b = p.adaptations.video) != null ? _b : [],
        ...(_c = p.adaptations.text) != null ? _c : []
      ].forEach((adaptation) => {
        let hasSupportedCodec = false;
        let hasCodecWithUndefinedSupport = false;
        adaptation.representations.forEach((representation) => {
          var _a2, _b2;
          if (representation.isSupported !== void 0) {
            if (representation.isSupported) {
              hasSupportedCodec = true;
            }
            return;
          }
          const isEncrypted = representation.contentProtections !== void 0;
          const mimeType = (_a2 = representation.mimeType) != null ? _a2 : "";
          let codecs = (_b2 = representation.codecs) != null ? _b2 : [];
          if (codecs.length === 0) {
            codecs = [""];
          }
          for (const codec of codecs) {
            const codecSupportInfo = efficientlyGetCodecSupport(mimeType, codec);
            if (!isEncrypted) {
              representation.isSupported = codecSupportInfo.isSupportedClear;
            } else if (representation.isSupported !== codecSupportInfo.isSupportedEncrypted) {
              representation.isSupported = codecSupportInfo.isSupportedEncrypted;
            }
            if (representation.isSupported === void 0) {
              hasCodecWithUndefinedSupport = true;
            } else if (representation.isSupported) {
              hasSupportedCodec = true;
              representation.codecs = [codec];
              break;
            }
          }
        });
        adaptation.supportStatus.hasCodecWithUndefinedSupport = hasCodecWithUndefinedSupport;
        if (hasCodecWithUndefinedSupport && !hasSupportedCodec) {
          adaptation.supportStatus.hasSupportedCodec = void 0;
        } else {
          adaptation.supportStatus.hasSupportedCodec = hasSupportedCodec;
        }
      });
      ["audio", "video"].forEach((ttype) => {
        const forType = p.adaptations[ttype];
        if (forType !== void 0 && forType.every((a) => a.supportStatus.hasSupportedCodec === false)) {
          throw new MediaError(
            "MANIFEST_INCOMPATIBLE_CODECS_ERROR",
            "No supported " + ttype + " adaptations",
            { tracks: void 0 }
          );
        }
      });
    });
    return updatedCodecs;
  }

  // src/utils/warn_once.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var WARNED_MESSAGES = [];
  function warnOnce(message) {
    if (!arrayIncludes(WARNED_MESSAGES, message)) {
      console.warn(message);
      WARNED_MESSAGES.push(message);
    }
  }

  // src/manifest/utils.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var SUPPORTED_ADAPTATIONS_TYPE = ["audio", "video", "text"];
  function getMinimumSafePosition(manifest) {
    var _a, _b;
    const windowData = manifest.timeBounds;
    if (windowData.timeshiftDepth === null) {
      return (_a = windowData.minimumSafePosition) != null ? _a : 0;
    }
    const { maximumTimeData } = windowData;
    let maximumTime;
    if (!windowData.maximumTimeData.isLinear) {
      maximumTime = maximumTimeData.maximumSafePosition;
    } else {
      const timeDiff = monotonic_timestamp_default() - maximumTimeData.time;
      maximumTime = maximumTimeData.maximumSafePosition + timeDiff / 1e3;
    }
    const theoricalMinimum = maximumTime - windowData.timeshiftDepth;
    return Math.max((_b = windowData.minimumSafePosition) != null ? _b : 0, theoricalMinimum);
  }
  function getLivePosition(manifest) {
    const { maximumTimeData } = manifest.timeBounds;
    if (!manifest.isLive || maximumTimeData.livePosition === void 0) {
      return void 0;
    }
    if (!maximumTimeData.isLinear) {
      return maximumTimeData.livePosition;
    }
    const timeDiff = monotonic_timestamp_default() - maximumTimeData.time;
    return maximumTimeData.livePosition + timeDiff / 1e3;
  }
  function getMaximumSafePosition(manifest) {
    const { maximumTimeData } = manifest.timeBounds;
    if (!maximumTimeData.isLinear) {
      return maximumTimeData.maximumSafePosition;
    }
    const timeDiff = monotonic_timestamp_default() - maximumTimeData.time;
    return maximumTimeData.maximumSafePosition + timeDiff / 1e3;
  }
  function getSupportedAdaptations(period, type) {
    if (type === void 0) {
      return getAdaptations(period).filter((ada) => {
        return ada.supportStatus.hasSupportedCodec !== false && ada.supportStatus.isDecipherable !== false;
      });
    }
    const adaptationsForType = period.adaptations[type];
    if (adaptationsForType === void 0) {
      return [];
    }
    return adaptationsForType.filter((ada) => {
      return ada.supportStatus.hasSupportedCodec !== false && ada.supportStatus.isDecipherable !== false;
    });
  }
  function getPeriodForTime(manifest, time) {
    let nextPeriod = null;
    for (const period of manifest.periods) {
      if (periodContainsTime(period, time, nextPeriod)) {
        return period;
      }
      nextPeriod = period;
    }
  }
  function getPeriodAfter(manifest, period) {
    const endOfPeriod = period.end;
    if (endOfPeriod === void 0) {
      return null;
    }
    const nextPeriod = arrayFind(manifest.periods, (_period) => {
      return _period.end === void 0 || endOfPeriod < _period.end;
    });
    return nextPeriod === void 0 ? null : nextPeriod;
  }
  function periodContainsTime(period, time, nextPeriod) {
    if (time >= period.start && (period.end === void 0 || time < period.end)) {
      return true;
    } else if (time === period.end && (nextPeriod === null || nextPeriod.start > period.end)) {
      return true;
    }
    return false;
  }
  function getAdaptations(period) {
    const adaptationsByType = period.adaptations;
    return objectValues(adaptationsByType).reduce(
      // Note: the second case cannot happen. TS is just being dumb here
      (acc, adaptations) => !isNullOrUndefined(adaptations) ? acc.concat(adaptations) : acc,
      []
    );
  }
  function toAudioTrack(adaptation, filterPlayable) {
    var _a, _b;
    const formatted = {
      language: (_a = adaptation.language) != null ? _a : "",
      normalized: (_b = adaptation.normalizedLanguage) != null ? _b : "",
      audioDescription: adaptation.isAudioDescription === true,
      id: adaptation.id,
      representations: (filterPlayable ? adaptation.representations.filter(
        (r) => r.isSupported === true && r.decipherable !== false
      ) : adaptation.representations).map(toAudioRepresentation),
      label: adaptation.label
    };
    if (adaptation.isDub === true) {
      formatted.dub = true;
    }
    return formatted;
  }
  function toTextTrack(adaptation) {
    var _a, _b;
    return {
      language: (_a = adaptation.language) != null ? _a : "",
      normalized: (_b = adaptation.normalizedLanguage) != null ? _b : "",
      closedCaption: adaptation.isClosedCaption === true,
      id: adaptation.id,
      label: adaptation.label,
      forced: adaptation.isForcedSubtitles
    };
  }
  function toVideoTrack(adaptation, filterPlayable) {
    const trickModeTracks = adaptation.trickModeTracks !== void 0 ? adaptation.trickModeTracks.map((trickModeAdaptation) => {
      const representations = (filterPlayable ? trickModeAdaptation.representations.filter(
        (r) => r.isSupported === true && r.decipherable !== false
      ) : trickModeAdaptation.representations).map(toVideoRepresentation);
      const trickMode = {
        id: trickModeAdaptation.id,
        representations,
        isTrickModeTrack: true
      };
      if (trickModeAdaptation.isSignInterpreted === true) {
        trickMode.signInterpreted = true;
      }
      return trickMode;
    }) : void 0;
    const videoTrack = {
      id: adaptation.id,
      representations: (filterPlayable ? adaptation.representations.filter(
        (r) => r.isSupported === true && r.decipherable !== false
      ) : adaptation.representations).map(toVideoRepresentation),
      label: adaptation.label
    };
    if (adaptation.isSignInterpreted === true) {
      videoTrack.signInterpreted = true;
    }
    if (adaptation.isTrickModeTrack === true) {
      videoTrack.isTrickModeTrack = true;
    }
    if (trickModeTracks !== void 0) {
      videoTrack.trickModeTracks = trickModeTracks;
    }
    return videoTrack;
  }
  function toAudioRepresentation(representation) {
    const { id, bitrate, codecs, isSpatialAudio, isSupported, decipherable } = representation;
    return {
      id,
      bitrate,
      codec: codecs == null ? void 0 : codecs[0],
      isSpatialAudio,
      isCodecSupported: isSupported,
      decipherable
    };
  }
  function toVideoRepresentation(representation) {
    const {
      id,
      bitrate,
      frameRate,
      width,
      height,
      codecs,
      hdrInfo,
      isSupported,
      decipherable,
      contentProtections
    } = representation;
    return {
      id,
      bitrate,
      frameRate,
      width,
      height,
      codec: codecs == null ? void 0 : codecs[0],
      hdrInfo,
      isCodecSupported: isSupported,
      decipherable,
      contentProtections: contentProtections !== void 0 ? {
        keyIds: contentProtections.keyIds
      } : void 0
    };
  }
  function toTaggedTrack(adaptation) {
    switch (adaptation.type) {
      case "audio":
        return { type: "audio", track: toAudioTrack(adaptation, false) };
      case "video":
        return { type: "video", track: toVideoTrack(adaptation, false) };
      case "text":
        return { type: "text", track: toTextTrack(adaptation) };
    }
  }
  function updateDecipherabilityFromKeyIds(manifest, updates) {
    const { whitelistedKeyIds, blacklistedKeyIds, delistedKeyIds } = updates;
    return updateRepresentationsDeciperability(manifest, (representation) => {
      if (representation.contentProtections === void 0) {
        return representation.decipherable;
      }
      const contentKIDs = representation.contentProtections.keyIds;
      if (contentKIDs !== void 0) {
        for (const elt of contentKIDs) {
          for (const blacklistedKeyId of blacklistedKeyIds) {
            if (areArraysOfNumbersEqual(blacklistedKeyId, elt)) {
              return false;
            }
          }
          for (const whitelistedKeyId of whitelistedKeyIds) {
            if (areArraysOfNumbersEqual(whitelistedKeyId, elt)) {
              return true;
            }
          }
          for (const delistedKeyId of delistedKeyIds) {
            if (areArraysOfNumbersEqual(delistedKeyId, elt)) {
              return void 0;
            }
          }
        }
      }
      return representation.decipherable;
    });
  }
  function updateDecipherabilityFromProtectionData(manifest, initData) {
    return updateRepresentationsDeciperability(manifest, (representation) => {
      var _a, _b;
      if (representation.decipherable === false) {
        return false;
      }
      const segmentProtections = (_b = (_a = representation.contentProtections) == null ? void 0 : _a.initData) != null ? _b : [];
      for (const protection of segmentProtections) {
        if (initData.type === void 0 || protection.type === initData.type) {
          const containedInitData = initData.values.getFormattedValues().every((undecipherableVal) => {
            return protection.values.some((currVal) => {
              return (undecipherableVal.systemId === void 0 || currVal.systemId === undecipherableVal.systemId) && areArraysOfNumbersEqual(currVal.data, undecipherableVal.data);
            });
          });
          if (containedInitData) {
            return false;
          }
        }
      }
      return representation.decipherable;
    });
  }
  function updateRepresentationsDeciperability(manifest, isDecipherable) {
    const updates = [];
    for (const period of manifest.periods) {
      const adaptationsByType = period.adaptations;
      const adaptations = objectValues(adaptationsByType).reduce(
        // Note: the second case cannot happen. TS is just being dumb here
        (acc, adaps) => !isNullOrUndefined(adaps) ? acc.concat(adaps) : acc,
        []
      );
      for (const adaptation of adaptations) {
        let hasOnlyUndecipherableRepresentations = true;
        for (const representation of adaptation.representations) {
          const result = isDecipherable(representation);
          if (result !== false) {
            hasOnlyUndecipherableRepresentations = false;
          }
          if (result !== representation.decipherable) {
            if (result === true) {
              adaptation.supportStatus.isDecipherable = true;
            } else if (result === void 0 && adaptation.supportStatus.isDecipherable === false) {
              adaptation.supportStatus.isDecipherable = void 0;
            }
            updates.push({ manifest, period, adaptation, representation });
            representation.decipherable = result;
          }
        }
        if (hasOnlyUndecipherableRepresentations) {
          adaptation.supportStatus.isDecipherable = false;
        }
      }
    }
    return updates;
  }
  function replicateUpdatesOnManifestMetadata(baseManifest, newManifest, updates) {
    var _a, _b;
    for (const prop of Object.keys(newManifest)) {
      if (prop !== "periods") {
        baseManifest[prop] = newManifest[prop];
      }
    }
    for (const removedPeriod of updates.removedPeriods) {
      for (let periodIdx = 0; periodIdx < baseManifest.periods.length; periodIdx++) {
        if (baseManifest.periods[periodIdx].id === removedPeriod.id) {
          baseManifest.periods.splice(periodIdx, 1);
          break;
        }
      }
    }
    for (const updatedPeriod of updates.updatedPeriods) {
      for (let periodIdx = 0; periodIdx < baseManifest.periods.length; periodIdx++) {
        const newPeriod = updatedPeriod.period;
        if (baseManifest.periods[periodIdx].id === updatedPeriod.period.id) {
          const basePeriod = baseManifest.periods[periodIdx];
          for (const prop of Object.keys(newPeriod)) {
            if (prop !== "adaptations") {
              basePeriod[prop] = newPeriod[prop];
            }
          }
          for (const removedThumbnailTrack of updatedPeriod.result.removedThumbnailTracks) {
            for (let thumbIdx = 0; thumbIdx < basePeriod.thumbnailTracks.length; thumbIdx++) {
              if (basePeriod.thumbnailTracks[thumbIdx].id === removedThumbnailTrack.id) {
                basePeriod.thumbnailTracks.splice(thumbIdx, 1);
                break;
              }
            }
          }
          for (const updatedThumbnailTrack of updatedPeriod.result.updatedThumbnailTracks) {
            const newThumbnailTrack = updatedThumbnailTrack;
            for (let thumbIdx = 0; thumbIdx < basePeriod.thumbnailTracks.length; thumbIdx++) {
              if (basePeriod.thumbnailTracks[thumbIdx].id === newThumbnailTrack.id) {
                const baseThumbnailTrack = basePeriod.thumbnailTracks[thumbIdx];
                for (const prop of Object.keys(newThumbnailTrack)) {
                  baseThumbnailTrack[prop] = newThumbnailTrack[prop];
                }
                break;
              }
            }
          }
          for (const addedThumbnailTrack of updatedPeriod.result.addedThumbnailTracks) {
            basePeriod.thumbnailTracks.push(addedThumbnailTrack);
          }
          for (const removedAdaptation of updatedPeriod.result.removedAdaptations) {
            const ttype = removedAdaptation.trackType;
            const adaptationsForType = (_a = basePeriod.adaptations[ttype]) != null ? _a : [];
            for (let adapIdx = 0; adapIdx < adaptationsForType.length; adapIdx++) {
              if (adaptationsForType[adapIdx].id === removedAdaptation.id) {
                adaptationsForType.splice(adapIdx, 1);
                break;
              }
            }
          }
          for (const updatedAdaptation of updatedPeriod.result.updatedAdaptations) {
            const newAdaptation = updatedAdaptation.adaptation;
            const ttype = updatedAdaptation.trackType;
            const adaptationsForType = (_b = basePeriod.adaptations[ttype]) != null ? _b : [];
            for (let adapIdx = 0; adapIdx < adaptationsForType.length; adapIdx++) {
              if (adaptationsForType[adapIdx].id === newAdaptation) {
                const baseAdaptation = adaptationsForType[adapIdx];
                for (const removedRepresentation of updatedAdaptation.removedRepresentations) {
                  for (let repIdx = 0; repIdx < baseAdaptation.representations.length; repIdx++) {
                    if (baseAdaptation.representations[repIdx].id === removedRepresentation) {
                      baseAdaptation.representations.splice(repIdx, 1);
                      break;
                    }
                  }
                }
                for (const newRepresentation of updatedAdaptation.updatedRepresentations) {
                  for (let repIdx = 0; repIdx < baseAdaptation.representations.length; repIdx++) {
                    if (baseAdaptation.representations[repIdx].id === newRepresentation.id) {
                      const baseRepresentation = baseAdaptation.representations[repIdx];
                      for (const prop of Object.keys(newRepresentation)) {
                        if (prop !== "decipherable") {
                          baseRepresentation[prop] = newRepresentation[prop];
                        }
                      }
                      break;
                    }
                  }
                }
                for (const addedRepresentation of updatedAdaptation.addedRepresentations) {
                  baseAdaptation.representations.push(addedRepresentation);
                }
                break;
              }
            }
          }
          for (const addedAdaptation of updatedPeriod.result.addedAdaptations) {
            const ttype = addedAdaptation.type;
            const adaptationsForType = basePeriod.adaptations[ttype];
            if (adaptationsForType === void 0) {
              basePeriod.adaptations[ttype] = [addedAdaptation];
            } else {
              adaptationsForType.push(addedAdaptation);
            }
          }
          break;
        }
      }
    }
    for (const addedPeriod of updates.addedPeriods) {
      for (let periodIdx = 0; periodIdx < baseManifest.periods.length; periodIdx++) {
        if (baseManifest.periods[periodIdx].start > addedPeriod.start) {
          baseManifest.periods.splice(periodIdx, 0, addedPeriod);
          break;
        }
      }
      baseManifest.periods.push(addedPeriod);
    }
  }
  function createRepresentationFilterFromFnString(fnString) {
    return new Function(
      `return (${fnString}(arguments[0], arguments[1]))`
    );
  }

  // src/manifest/classes/codec_support_cache.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var CodecSupportCache = class {
    /**
     * Constructs an CodecSupportCache instance.
     * @param {Array} codecList - List of codec support information.
     */
    constructor(codecList) {
      this.supportMap = /* @__PURE__ */ new Map();
      this.addCodecs(codecList);
    }
    /**
     * Adds codec support information to this `CodecSupportCache`.
     * @param {Array} codecList - List of codec support information.
     */
    addCodecs(codecList) {
      for (const codec of codecList) {
        let mimeTypeMap = this.supportMap.get(codec.mimeType);
        if (mimeTypeMap === void 0) {
          mimeTypeMap = /* @__PURE__ */ new Map();
          this.supportMap.set(codec.mimeType, mimeTypeMap);
        }
        mimeTypeMap.set(codec.codec, {
          supported: codec.supported,
          supportedIfEncrypted: codec.supportedIfEncrypted
        });
      }
    }
    /**
     * Checks if a codec is supported for a given MIME type.
     * @param {string} mimeType - The MIME type to check.
     * @param {string} codec - The codec to check.
     * @param {boolean} isEncrypted - Whether the content is encrypted.
     * @returns {boolean | undefined} - `true` if the codec is supported, `false`
     * if not, or `undefined` if no support information is found.
     */
    isSupported(mimeType, codec, isEncrypted) {
      const mimeTypeMap = this.supportMap.get(mimeType);
      if (mimeTypeMap === void 0) {
        return void 0;
      }
      const result = mimeTypeMap.get(codec);
      if (result === void 0) {
        return void 0;
      }
      if (isEncrypted) {
        return result.supportedIfEncrypted;
      } else {
        return result.supported;
      }
    }
  };

  // src/manifest/classes/period.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var Period = class {
    /**
     * @constructor
     * @param {Object} args
     * @param {Array.<Object>} unsupportedAdaptations - Array on which
     * `Adaptation`s objects which have no supported `Representation` will be
     * pushed.
     * This array might be useful for minor error reporting.
     * @param {function|undefined} [representationFilter]
     */
    constructor(args, unsupportedAdaptations, cachedCodecSupport, representationFilter) {
      this.id = args.id;
      this.adaptations = Object.keys(args.adaptations).reduce((acc, type) => {
        const adaptationsForType = args.adaptations[type];
        if (isNullOrUndefined(adaptationsForType)) {
          return acc;
        }
        const filteredAdaptations = adaptationsForType.map((adaptation) => {
          const newAdaptation = new Adaptation(adaptation, cachedCodecSupport, {
            representationFilter
          });
          if (newAdaptation.representations.length > 0 && newAdaptation.supportStatus.hasSupportedCodec === false) {
            unsupportedAdaptations.push(newAdaptation);
          }
          return newAdaptation;
        }).filter(
          (adaptation) => adaptation.representations.length > 0
        );
        if (filteredAdaptations.every(
          (adaptation) => adaptation.supportStatus.hasSupportedCodec === false
        ) && adaptationsForType.length > 0 && (type === "video" || type === "audio")) {
          throw new MediaError(
            "MANIFEST_INCOMPATIBLE_CODECS_ERROR",
            "No supported " + type + " adaptations",
            { tracks: void 0 }
          );
        }
        if (filteredAdaptations.length > 0) {
          acc[type] = filteredAdaptations;
        }
        return acc;
      }, {});
      if (!Array.isArray(this.adaptations.video) && !Array.isArray(this.adaptations.audio)) {
        throw new MediaError(
          "MANIFEST_PARSE_ERROR",
          "No supported audio and video tracks."
        );
      }
      this.thumbnailTracks = args.thumbnailTracks.map((thumbnailTrack) => ({
        id: thumbnailTrack.id,
        mimeType: thumbnailTrack.mimeType,
        index: thumbnailTrack.index,
        cdnMetadata: thumbnailTrack.cdnMetadata,
        height: thumbnailTrack.height,
        width: thumbnailTrack.width,
        horizontalTiles: thumbnailTrack.horizontalTiles,
        verticalTiles: thumbnailTrack.verticalTiles
      }));
      this.duration = args.duration;
      this.start = args.start;
      if (!isNullOrUndefined(this.duration) && !isNullOrUndefined(this.start)) {
        this.end = this.start + this.duration;
      }
      this.streamEvents = args.streamEvents === void 0 ? [] : args.streamEvents;
    }
    /**
     * Some environments (e.g. in a WebWorker) may not have the capability to know
     * if a mimetype+codec combination is supported on the current platform.
     *
     * Calling `refreshCodecSupport` manually once the codecs supported are known
     * by the current environnement allows to work-around this issue.
     *
     * @param {Array.<Object>} unsupportedAdaptations - Array on which
     * `Adaptation`s objects which are now known to have no supported
     * `Representation` will be pushed.
     * This array might be useful for minor error reporting.
     * @param {Array.<Object>} cachedCodecSupport
     */
    refreshCodecSupport(unsupportedAdaptations, cachedCodecSupport) {
      Object.keys(this.adaptations).forEach((ttype) => {
        const adaptationsForType = this.adaptations[ttype];
        if (adaptationsForType === void 0) {
          return;
        }
        let hasSupportedAdaptations = false;
        for (const adaptation of adaptationsForType) {
          if (!adaptation.supportStatus.hasCodecWithUndefinedSupport) {
            if (adaptation.supportStatus.hasSupportedCodec === true) {
              hasSupportedAdaptations = true;
            }
            continue;
          }
          const wasSupported = adaptation.supportStatus.hasSupportedCodec;
          adaptation.refreshCodecSupport(cachedCodecSupport);
          if (wasSupported !== false && adaptation.supportStatus.hasSupportedCodec === false) {
            unsupportedAdaptations.push(adaptation);
          }
          if (hasSupportedAdaptations === false) {
            hasSupportedAdaptations = adaptation.supportStatus.hasSupportedCodec;
          } else if (hasSupportedAdaptations === void 0 && adaptation.supportStatus.hasSupportedCodec === true) {
            hasSupportedAdaptations = true;
          }
        }
        if ((ttype === "video" || ttype === "audio") && hasSupportedAdaptations === false) {
          throw new MediaError(
            "MANIFEST_INCOMPATIBLE_CODECS_ERROR",
            "No supported " + ttype + " adaptations",
            { tracks: void 0 }
          );
        }
      }, {});
    }
    /**
     * Returns every `Adaptations` (or `tracks`) linked to that Period, in an
     * Array.
     * @returns {Array.<Object>}
     */
    getAdaptations() {
      return getAdaptations(this);
    }
    /**
     * Returns every `Adaptations` (or `tracks`) linked to that Period for a
     * given type.
     * @param {string} adaptationType
     * @returns {Array.<Object>}
     */
    getAdaptationsForType(adaptationType) {
      const adaptationsForType = this.adaptations[adaptationType];
      return adaptationsForType != null ? adaptationsForType : [];
    }
    /**
     * Returns the Adaptation linked to the given ID.
     * @param {number|string} wantedId
     * @returns {Object|undefined}
     */
    getAdaptation(wantedId) {
      return arrayFind(this.getAdaptations(), ({ id }) => wantedId === id);
    }
    /**
     * Returns Adaptations that contain Representations in supported codecs.
     * @param {string|undefined} type - If set filter on a specific Adaptation's
     * type. Will return for all types if `undefined`.
     * @returns {Array.<Adaptation>}
     */
    getSupportedAdaptations(type) {
      return getSupportedAdaptations(this, type);
    }
    /**
     * Returns true if the give time is in the time boundaries of this `Period`.
     * @param {number} time
     * @param {object|null} nextPeriod - Period coming chronologically just
     * after in the same Manifest. `null` if this instance is the last `Period`.
     * @returns {boolean}
     */
    containsTime(time, nextPeriod) {
      return periodContainsTime(this, time, nextPeriod);
    }
    /**
     * Format the current `Period`'s properties into a
     * `IPeriodMetadata` format which can better be communicated through
     * another thread.
     *
     * Please bear in mind however that the returned object will not be updated
     * when the current `Period` instance is updated, it is only a
     * snapshot at the current time.
     *
     * If you want to keep that data up-to-date with the current `Period`
     * instance, you will have to do it yourself.
     *
     * @returns {Object}
     */
    getMetadataSnapshot() {
      const adaptations = {};
      const baseAdaptations = this.getAdaptations();
      for (const adaptation of baseAdaptations) {
        let currentAdaps = adaptations[adaptation.type];
        if (currentAdaps === void 0) {
          currentAdaps = [];
          adaptations[adaptation.type] = currentAdaps;
        }
        currentAdaps.push(adaptation.getMetadataSnapshot());
      }
      return {
        start: this.start,
        end: this.end,
        id: this.id,
        streamEvents: this.streamEvents,
        adaptations,
        thumbnailTracks: this.thumbnailTracks.map((thumbnailTrack) => ({
          id: thumbnailTrack.id,
          mimeType: thumbnailTrack.mimeType,
          height: thumbnailTrack.height,
          width: thumbnailTrack.width,
          horizontalTiles: thumbnailTrack.horizontalTiles,
          verticalTiles: thumbnailTrack.verticalTiles
        }))
      };
    }
  };

  // src/manifest/classes/update_periods.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/manifest/classes/update_period_in_place.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function updatePeriodInPlace(oldPeriod, newPeriod, updateType) {
    const res = {
      updatedAdaptations: [],
      removedAdaptations: [],
      addedAdaptations: [],
      updatedThumbnailTracks: [],
      removedThumbnailTracks: [],
      addedThumbnailTracks: []
    };
    oldPeriod.start = newPeriod.start;
    oldPeriod.end = newPeriod.end;
    oldPeriod.duration = newPeriod.duration;
    oldPeriod.streamEvents = newPeriod.streamEvents;
    const oldThumbnailTracks = oldPeriod.thumbnailTracks;
    const newThumbnailTracks = newPeriod.thumbnailTracks;
    for (let j = 0; j < oldThumbnailTracks.length; j++) {
      const oldThumbnailTrack = oldThumbnailTracks[j];
      const newThumbnailTrackIdx = arrayFindIndex(
        newThumbnailTracks,
        (a) => a.id === oldThumbnailTrack.id
      );
      if (newThumbnailTrackIdx === -1) {
        log_default.warn(
          'Manifest: ThumbnailTrack "' + oldThumbnailTracks[j].id + '" not found when merging.'
        );
        const [removed] = oldThumbnailTracks.splice(j, 1);
        j--;
        res.removedThumbnailTracks.push({
          id: removed.id
        });
      } else {
        const [newThumbnailTrack] = newThumbnailTracks.splice(newThumbnailTrackIdx, 1);
        oldThumbnailTrack.mimeType = newThumbnailTrack.mimeType;
        oldThumbnailTrack.height = newThumbnailTrack.height;
        oldThumbnailTrack.width = newThumbnailTrack.width;
        oldThumbnailTrack.horizontalTiles = newThumbnailTrack.horizontalTiles;
        oldThumbnailTrack.verticalTiles = newThumbnailTrack.verticalTiles;
        oldThumbnailTrack.cdnMetadata = newThumbnailTrack.cdnMetadata;
        if (updateType === 0 /* Full */) {
          oldThumbnailTrack.index._replace(newThumbnailTrack.index);
        } else {
          oldThumbnailTrack.index._update(newThumbnailTrack.index);
        }
        res.updatedThumbnailTracks.push({
          id: oldThumbnailTrack.id,
          mimeType: oldThumbnailTrack.mimeType,
          height: oldThumbnailTrack.height,
          width: oldThumbnailTrack.width,
          horizontalTiles: oldThumbnailTrack.horizontalTiles,
          verticalTiles: oldThumbnailTrack.verticalTiles
        });
      }
    }
    if (newThumbnailTracks.length > 0) {
      log_default.warn(
        `Manifest: ${newThumbnailTracks.length} new Thumbnail tracks found when merging.`
      );
      res.addedThumbnailTracks.push(...newThumbnailTracks);
      oldPeriod.thumbnailTracks.push(...newThumbnailTracks);
    }
    const oldAdaptations = oldPeriod.getAdaptations();
    const newAdaptations = newPeriod.getAdaptations();
    for (let j = 0; j < oldAdaptations.length; j++) {
      const oldAdaptation = oldAdaptations[j];
      const newAdaptationIdx = arrayFindIndex(
        newAdaptations,
        (a) => a.id === oldAdaptation.id
      );
      if (newAdaptationIdx === -1) {
        log_default.warn(
          'Manifest: Adaptation "' + oldAdaptations[j].id + '" not found when merging.'
        );
        const [removed] = oldAdaptations.splice(j, 1);
        j--;
        res.removedAdaptations.push({
          id: removed.id,
          trackType: removed.type
        });
      } else {
        const [newAdaptation] = newAdaptations.splice(newAdaptationIdx, 1);
        const updatedRepresentations = [];
        const addedRepresentations = [];
        const removedRepresentations = [];
        res.updatedAdaptations.push({
          adaptation: oldAdaptation.id,
          trackType: oldAdaptation.type,
          updatedRepresentations,
          addedRepresentations,
          removedRepresentations
        });
        const oldRepresentations = oldAdaptation.representations;
        const newRepresentations = newAdaptation.representations.slice();
        for (let k = 0; k < oldRepresentations.length; k++) {
          const oldRepresentation = oldRepresentations[k];
          const newRepresentationIdx = arrayFindIndex(
            newRepresentations,
            (representation) => representation.id === oldRepresentation.id
          );
          if (newRepresentationIdx === -1) {
            log_default.warn(
              `Manifest: Representation "${oldRepresentations[k].id}" not found when merging.`
            );
            const [removed] = oldRepresentations.splice(k, 1);
            k--;
            removedRepresentations.push(removed.id);
          } else {
            const [newRepresentation] = newRepresentations.splice(newRepresentationIdx, 1);
            updatedRepresentations.push(oldRepresentation.getMetadataSnapshot());
            oldRepresentation.cdnMetadata = newRepresentation.cdnMetadata;
            if (updateType === 0 /* Full */) {
              oldRepresentation.index._replace(newRepresentation.index);
            } else {
              oldRepresentation.index._update(newRepresentation.index);
            }
          }
        }
        if (newRepresentations.length > 0) {
          log_default.warn(
            `Manifest: ${newRepresentations.length} new Representations found when merging.`
          );
          oldAdaptation.representations.push(...newRepresentations);
          addedRepresentations.push(
            ...newRepresentations.map((r) => r.getMetadataSnapshot())
          );
        }
      }
    }
    if (newAdaptations.length > 0) {
      log_default.warn(
        `Manifest: ${newAdaptations.length} new Adaptations found when merging.`
      );
      for (const adap of newAdaptations) {
        const prevAdaps = oldPeriod.adaptations[adap.type];
        if (prevAdaps === void 0) {
          oldPeriod.adaptations[adap.type] = [adap];
        } else {
          prevAdaps.push(adap);
        }
        res.addedAdaptations.push(adap.getMetadataSnapshot());
      }
    }
    return res;
  }

  // src/manifest/classes/update_periods.ts
  function replacePeriods(oldPeriods, newPeriods) {
    const res = {
      updatedPeriods: [],
      addedPeriods: [],
      removedPeriods: []
    };
    let firstUnhandledPeriodIdx = 0;
    for (let i = 0; i < newPeriods.length; i++) {
      const newPeriod = newPeriods[i];
      let j = firstUnhandledPeriodIdx;
      let oldPeriod = oldPeriods[j];
      while (oldPeriod !== void 0 && oldPeriod.id !== newPeriod.id) {
        j++;
        oldPeriod = oldPeriods[j];
      }
      if (oldPeriod !== void 0) {
        const result = updatePeriodInPlace(oldPeriod, newPeriod, 0 /* Full */);
        res.updatedPeriods.push({
          period: {
            id: oldPeriod.id,
            start: oldPeriod.start,
            end: oldPeriod.end,
            duration: oldPeriod.duration,
            streamEvents: oldPeriod.streamEvents
          },
          result
        });
        const periodsToInclude = newPeriods.slice(firstUnhandledPeriodIdx, i);
        const nbrOfPeriodsToRemove = j - firstUnhandledPeriodIdx;
        const removed = oldPeriods.splice(
          firstUnhandledPeriodIdx,
          nbrOfPeriodsToRemove,
          ...periodsToInclude
        );
        res.removedPeriods.push(
          ...removed.map((p) => ({
            id: p.id,
            start: p.start,
            end: p.end
          }))
        );
        res.addedPeriods.push(...periodsToInclude.map((p) => p.getMetadataSnapshot()));
        firstUnhandledPeriodIdx = i + 1;
      }
    }
    if (firstUnhandledPeriodIdx > oldPeriods.length) {
      log_default.error("Manifest: error when updating Periods");
      return res;
    }
    if (firstUnhandledPeriodIdx < oldPeriods.length) {
      const removed = oldPeriods.splice(
        firstUnhandledPeriodIdx,
        oldPeriods.length - firstUnhandledPeriodIdx
      );
      res.removedPeriods.push(
        ...removed.map((p) => ({
          id: p.id,
          start: p.start,
          end: p.end
        }))
      );
    }
    const remainingNewPeriods = newPeriods.slice(
      firstUnhandledPeriodIdx,
      newPeriods.length
    );
    if (remainingNewPeriods.length > 0) {
      oldPeriods.push(...remainingNewPeriods);
      res.addedPeriods.push(...remainingNewPeriods.map((p) => p.getMetadataSnapshot()));
    }
    return res;
  }
  function updatePeriods(oldPeriods, newPeriods) {
    const res = {
      updatedPeriods: [],
      addedPeriods: [],
      removedPeriods: []
    };
    if (oldPeriods.length === 0) {
      oldPeriods.splice(0, 0, ...newPeriods);
      res.addedPeriods.push(...newPeriods.map((p) => p.getMetadataSnapshot()));
      return res;
    }
    if (newPeriods.length === 0) {
      return res;
    }
    const oldLastPeriod = oldPeriods[oldPeriods.length - 1];
    if (oldLastPeriod.start < newPeriods[0].start) {
      if (oldLastPeriod.end !== newPeriods[0].start) {
        throw new MediaError(
          "MANIFEST_UPDATE_ERROR",
          "Cannot perform partial update: not enough data"
        );
      }
      oldPeriods.push(...newPeriods);
      res.addedPeriods.push(...newPeriods.map((p) => p.getMetadataSnapshot()));
      return res;
    }
    const indexOfNewFirstPeriod = arrayFindIndex(
      oldPeriods,
      ({ id }) => id === newPeriods[0].id
    );
    if (indexOfNewFirstPeriod < 0) {
      throw new MediaError(
        "MANIFEST_UPDATE_ERROR",
        "Cannot perform partial update: incoherent data"
      );
    }
    const updateRes = updatePeriodInPlace(
      oldPeriods[indexOfNewFirstPeriod],
      newPeriods[0],
      1 /* Partial */
    );
    res.updatedPeriods.push({
      period: object_assign_default(oldPeriods[indexOfNewFirstPeriod].getMetadataSnapshot(), {
        adaptations: void 0
      }),
      result: updateRes
    });
    let prevIndexOfNewPeriod = indexOfNewFirstPeriod + 1;
    for (let i = 1; i < newPeriods.length; i++) {
      const newPeriod = newPeriods[i];
      let indexOfNewPeriod = -1;
      for (let j = prevIndexOfNewPeriod; j < oldPeriods.length; j++) {
        if (newPeriod.id === oldPeriods[j].id) {
          indexOfNewPeriod = j;
          break;
        }
      }
      if (indexOfNewPeriod < 0) {
        let toRemoveUntil = -1;
        for (let j = prevIndexOfNewPeriod; j < oldPeriods.length; j++) {
          if (newPeriod.start < oldPeriods[j].start) {
            toRemoveUntil = j;
            break;
          }
        }
        const nbElementsToRemove = toRemoveUntil - prevIndexOfNewPeriod;
        const removed = oldPeriods.splice(
          prevIndexOfNewPeriod,
          nbElementsToRemove,
          newPeriod
        );
        res.addedPeriods.push(newPeriod.getMetadataSnapshot());
        res.removedPeriods.push(
          ...removed.map((p) => ({
            id: p.id,
            start: p.start,
            end: p.end
          }))
        );
      } else {
        if (indexOfNewPeriod > prevIndexOfNewPeriod) {
          log_default.warn("Manifest: old Periods not found in new when updating, removing");
          const removed = oldPeriods.splice(
            prevIndexOfNewPeriod,
            indexOfNewPeriod - prevIndexOfNewPeriod
          );
          res.removedPeriods.push(
            ...removed.map((p) => ({
              id: p.id,
              start: p.start,
              end: p.end
            }))
          );
          indexOfNewPeriod = prevIndexOfNewPeriod;
        }
        const result = updatePeriodInPlace(
          oldPeriods[indexOfNewPeriod],
          newPeriod,
          0 /* Full */
        );
        res.updatedPeriods.push({
          period: object_assign_default(oldPeriods[indexOfNewPeriod].getMetadataSnapshot(), {
            adaptations: void 0
          }),
          result
        });
      }
      prevIndexOfNewPeriod++;
    }
    if (prevIndexOfNewPeriod < oldPeriods.length) {
      log_default.warn("Manifest: Ending Periods not found in new when updating, removing");
      const removed = oldPeriods.splice(
        prevIndexOfNewPeriod,
        oldPeriods.length - prevIndexOfNewPeriod
      );
      res.removedPeriods.push(
        ...removed.map((p) => ({
          id: p.id,
          start: p.start,
          end: p.end
        }))
      );
    }
    return res;
  }

  // src/manifest/classes/manifest.ts
  var generateNewManifestId = idGenerator();
  var Manifest = class extends EventEmitter {
    /**
     * Construct a Manifest instance from a parsed Manifest object (as returned by
     * Manifest parsers) and options.
     *
     * Some minor errors can arise during that construction. `warnings`
     * will contain all such errors, in the order they have been encountered.
     * @param {Object} parsedManifest
     * @param {Object} options
     * @param {Array.<Object>} warnings - After construction, will be optionally
     * filled by errors expressing minor issues seen while parsing the Manifest.
     */
    constructor(parsedManifest, options, warnings) {
      var _a;
      super();
      const { representationFilter, manifestUpdateUrl } = options;
      this.manifestFormat = 0 /* Class */;
      this.id = generateNewManifestId();
      this.expired = (_a = parsedManifest.expired) != null ? _a : null;
      this.transport = parsedManifest.transportType;
      this.clockOffset = parsedManifest.clockOffset;
      this._cachedCodecSupport = new CodecSupportCache([]);
      const unsupportedAdaptations = [];
      this.periods = parsedManifest.periods.map((parsedPeriod) => {
        const period = new Period(
          parsedPeriod,
          unsupportedAdaptations,
          this._cachedCodecSupport,
          representationFilter
        );
        return period;
      }).sort((a, b) => a.start - b.start);
      if (unsupportedAdaptations.length > 0) {
        const error = new MediaError(
          "MANIFEST_INCOMPATIBLE_CODECS_ERROR",
          "An Adaptation contains only incompatible codecs.",
          { tracks: unsupportedAdaptations.map(toTaggedTrack) }
        );
        warnings.push(error);
      }
      this.adaptations = this.periods[0] === void 0 ? {} : this.periods[0].adaptations;
      this.timeBounds = parsedManifest.timeBounds;
      this.isDynamic = parsedManifest.isDynamic;
      this.isLive = parsedManifest.isLive;
      this.isLastPeriodKnown = parsedManifest.isLastPeriodKnown;
      this.uris = parsedManifest.uris === void 0 ? [] : parsedManifest.uris;
      this.updateUrl = manifestUpdateUrl;
      this.lifetime = parsedManifest.lifetime;
      this.clockOffset = parsedManifest.clockOffset;
      this.suggestedPresentationDelay = parsedManifest.suggestedPresentationDelay;
      this.availabilityStartTime = parsedManifest.availabilityStartTime;
      this.publishTime = parsedManifest.publishTime;
    }
    /**
     * Some environments (e.g. in a WebWorker) may not have the capability to know
     * if a mimetype+codec combination is supported on the current platform.
     *
     * Calling `updateCodecSupport` manually once the codecs supported are known
     * by the current environnement allows to work-around this issue.
     *
     * @param {Array<Object>} [updatedCodecSupportInfo]
     * @returns {Error|null} - Refreshing codec support might reveal that some
     * `Adaptation` don't have any of their `Representation`s supported.
     * In that case, an error object will be created and returned, so you can
     * e.g. later emit it as a warning through the RxPlayer API.
     */
    updateCodecSupport(updatedCodecSupportInfo = []) {
      if (updatedCodecSupportInfo.length === 0) {
        return null;
      }
      this._cachedCodecSupport.addCodecs(updatedCodecSupportInfo);
      const unsupportedAdaptations = [];
      for (const period of this.periods) {
        period.refreshCodecSupport(unsupportedAdaptations, this._cachedCodecSupport);
      }
      this.trigger("supportUpdate", null);
      if (unsupportedAdaptations.length > 0) {
        return new MediaError(
          "MANIFEST_INCOMPATIBLE_CODECS_ERROR",
          "An Adaptation contains only incompatible codecs.",
          { tracks: unsupportedAdaptations.map(toTaggedTrack) }
        );
      }
      return null;
    }
    /**
     * Returns the Period corresponding to the given `id`.
     * Returns `undefined` if there is none.
     * @param {string} id
     * @returns {Object|undefined}
     */
    getPeriod(id) {
      return arrayFind(this.periods, (period) => {
        return id === period.id;
      });
    }
    /**
     * Returns the Period encountered at the given time.
     * Returns `undefined` if there is no Period exactly at the given time.
     * @param {number} time
     * @returns {Object|undefined}
     */
    getPeriodForTime(time) {
      return getPeriodForTime(this, time);
    }
    /**
     * Returns the first Period starting strictly after the given time.
     * Returns `undefined` if there is no Period starting after that time.
     * @param {number} time
     * @returns {Object|undefined}
     */
    getNextPeriod(time) {
      return arrayFind(this.periods, (period) => {
        return period.start > time;
      });
    }
    /**
     * Returns the Period coming chronologically just after another given Period.
     * Returns `undefined` if not found.
     * @param {Object} period
     * @returns {Object|null}
     */
    getPeriodAfter(period) {
      return getPeriodAfter(this, period);
    }
    /**
     * Returns the most important URL from which the Manifest can be refreshed.
     * `undefined` if no URL is found.
     * @returns {Array.<string>}
     */
    getUrls() {
      return this.uris;
    }
    /**
     * Update the current Manifest properties by giving a new updated version.
     * This instance will be updated with the new information coming from it.
     * @param {Object} newManifest
     */
    replace(newManifest) {
      this._performUpdate(newManifest, 0 /* Full */);
    }
    /**
     * Update the current Manifest properties by giving a new but shorter version
     * of it.
     * This instance will add the new information coming from it and will
     * automatically clean old Periods that shouldn't be available anymore.
     *
     * /!\ Throws if the given Manifest cannot be used or is not sufficient to
     * update the Manifest.
     * @param {Object} newManifest
     */
    update(newManifest) {
      this._performUpdate(newManifest, 1 /* Partial */);
    }
    /**
     * Returns the theoretical minimum playable position on the content
     * regardless of the current Adaptation chosen, as estimated at parsing
     * time.
     * @returns {number}
     */
    getMinimumSafePosition() {
      return getMinimumSafePosition(this);
    }
    /**
     * Get the position of the live edge - that is, the position of what is
     * currently being broadcasted, in seconds.
     * @returns {number|undefined}
     */
    getLivePosition() {
      return getLivePosition(this);
    }
    /**
     * Returns the theoretical maximum playable position on the content
     * regardless of the current Adaptation chosen, as estimated at parsing
     * time.
     */
    getMaximumSafePosition() {
      return getMaximumSafePosition(this);
    }
    updateCodecSupportList(cachedCodecSupport) {
      this._cachedCodecSupport = cachedCodecSupport;
    }
    /**
     * Look in the Manifest for Representations linked to the given key ID,
     * and mark them as being impossible to decrypt.
     * Then trigger a "decipherabilityUpdate" event to notify everyone of the
     * changes performed.
     * @param {Function} isDecipherableCb
     */
    updateRepresentationsDeciperability(isDecipherableCb) {
      const updates = updateDeciperability(this, isDecipherableCb);
      if (updates.length > 0) {
        this.trigger("decipherabilityUpdate", updates);
      }
    }
    /**
     * @deprecated only returns adaptations for the first period
     * @returns {Array.<Object>}
     */
    getAdaptations() {
      warnOnce(
        "manifest.getAdaptations() is deprecated. Please use manifest.period[].getAdaptations() instead"
      );
      const firstPeriod = this.periods[0];
      if (firstPeriod === void 0) {
        return [];
      }
      const adaptationsByType = firstPeriod.adaptations;
      const adaptationsList = [];
      for (const adaptationType in adaptationsByType) {
        if (adaptationsByType.hasOwnProperty(adaptationType)) {
          const adaptations = adaptationsByType[adaptationType];
          adaptationsList.push(...adaptations);
        }
      }
      return adaptationsList;
    }
    /**
     * @deprecated only returns adaptations for the first period
     * @returns {Array.<Object>}
     */
    getAdaptationsForType(adaptationType) {
      warnOnce(
        "manifest.getAdaptationsForType(type) is deprecated. Please use manifest.period[].getAdaptationsForType(type) instead"
      );
      const firstPeriod = this.periods[0];
      if (firstPeriod === void 0) {
        return [];
      }
      const adaptationsForType = firstPeriod.adaptations[adaptationType];
      return adaptationsForType === void 0 ? [] : adaptationsForType;
    }
    /**
     * @deprecated only returns adaptations for the first period
     * @returns {Array.<Object>}
     */
    getAdaptation(wantedId) {
      warnOnce(
        "manifest.getAdaptation(id) is deprecated. Please use manifest.period[].getAdaptation(id) instead"
      );
      return arrayFind(this.getAdaptations(), ({ id }) => wantedId === id);
    }
    /**
     * Format the current `Manifest`'s properties into a
     * `IManifestMetadata` format which can better be communicated through
     * another thread.
     *
     * Please bear in mind however that the returned object will not be updated
     * when the current `Manifest` instance is updated, it is only a
     * snapshot at the current time.
     *
     * If you want to keep that data up-to-date with the current `Manifest`
     * instance, you will have to do it yourself.
     *
     * @returns {Object}
     */
    getMetadataSnapshot() {
      const periods = [];
      for (const period of this.periods) {
        periods.push(period.getMetadataSnapshot());
      }
      return {
        manifestFormat: 1 /* MetadataObject */,
        id: this.id,
        periods,
        isDynamic: this.isDynamic,
        isLive: this.isLive,
        isLastPeriodKnown: this.isLastPeriodKnown,
        suggestedPresentationDelay: this.suggestedPresentationDelay,
        clockOffset: this.clockOffset,
        uris: this.uris,
        availabilityStartTime: this.availabilityStartTime,
        timeBounds: this.timeBounds
      };
    }
    /**
     * Returns a list of all codecs that the support is not known yet.
     * If a representation with (`isSupported`) is undefined, we consider the
     * codec support as unknown.
     *
     * This function iterates through all periods, adaptations, and representations,
     * and collects unknown codecs.
     *
     * @returns {Array} The list of codecs with unknown support status.
     */
    getCodecsWithUnknownSupport() {
      return getCodecsWithUnknownSupport(this);
    }
    /**
     * @param {Object} newManifest
     * @param {number} updateType
     */
    _performUpdate(newManifest, updateType) {
      this.availabilityStartTime = newManifest.availabilityStartTime;
      this.expired = newManifest.expired;
      this.isDynamic = newManifest.isDynamic;
      this.isLive = newManifest.isLive;
      this.isLastPeriodKnown = newManifest.isLastPeriodKnown;
      this.lifetime = newManifest.lifetime;
      this.clockOffset = newManifest.clockOffset;
      this.suggestedPresentationDelay = newManifest.suggestedPresentationDelay;
      this.transport = newManifest.transport;
      this.publishTime = newManifest.publishTime;
      let updatedPeriodsResult;
      if (updateType === 0 /* Full */) {
        this.timeBounds = newManifest.timeBounds;
        this.uris = newManifest.uris;
        updatedPeriodsResult = replacePeriods(this.periods, newManifest.periods);
      } else {
        this.timeBounds.maximumTimeData = newManifest.timeBounds.maximumTimeData;
        this.updateUrl = newManifest.uris[0];
        updatedPeriodsResult = updatePeriods(this.periods, newManifest.periods);
        const min = this.getMinimumSafePosition();
        while (this.periods.length > 0) {
          const period = this.periods[0];
          if (period.end === void 0 || period.end > min) {
            break;
          }
          this.periods.shift();
        }
      }
      this.updateCodecSupport();
      this.adaptations = this.periods[0] === void 0 ? {} : this.periods[0].adaptations;
      this.trigger("manifestUpdate", updatedPeriodsResult);
    }
  };
  function updateDeciperability(manifest, isDecipherable) {
    const updates = [];
    for (const period of manifest.periods) {
      for (const adaptation of period.getAdaptations()) {
        let hasOnlyUndecipherableRepresentations = true;
        for (const representation of adaptation.representations) {
          const content = { manifest, period, adaptation, representation };
          const result = isDecipherable(content);
          if (result !== false) {
            hasOnlyUndecipherableRepresentations = false;
          }
          if (result !== representation.decipherable) {
            updates.push(content);
            representation.decipherable = result;
            if (result === true) {
              adaptation.supportStatus.isDecipherable = true;
            } else if (result === void 0 && adaptation.supportStatus.isDecipherable === false) {
              adaptation.supportStatus.isDecipherable = void 0;
            }
            log_default.debug(
              `Decipherability changed for "${representation.id}"`,
              `(${representation.bitrate})`,
              String(representation.decipherable)
            );
          }
        }
        if (hasOnlyUndecipherableRepresentations) {
          adaptation.supportStatus.isDecipherable = false;
        }
      }
    }
    return updates;
  }

  // src/manifest/classes/representation_index/index.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/manifest/classes/representation_index/static.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var StaticRepresentationIndex = class {
    /**
     * @param {Object} infos
     */
    constructor(infos) {
      this._url = infos.media;
    }
    /**
     * Static contents do not have any initialization segments.
     * Just return null.
     * @returns {null}
     */
    getInitSegment() {
      return null;
    }
    /**
     * Returns the only Segment available here.
     * @returns {Array.<Object>}
     */
    getSegments() {
      return [
        {
          id: "0",
          isInit: false,
          number: 0,
          url: this._url,
          time: 0,
          end: Number.MAX_VALUE,
          duration: Number.MAX_VALUE,
          complete: true,
          privateInfos: {},
          timescale: 1
        }
      ];
    }
    /**
     * Returns first position in index.
     * @returns {undefined}
     */
    getFirstAvailablePosition() {
      return;
    }
    /**
     * Returns last position in index.
     * @returns {undefined}
     */
    getLastAvailablePosition() {
      return;
    }
    /**
     * Returns the absolute end in seconds this RepresentationIndex can reach once
     * all segments are available.
     * @returns {number|null|undefined}
     */
    getEnd() {
      return;
    }
    /**
     * Returns:
     *   - `true` if in the given time interval, at least one new segment is
     *     expected to be available in the future.
     *   - `false` either if all segments in that time interval are already
     *     available for download or if none will ever be available for it.
     *   - `undefined` when it is not possible to tell.
     *
     * Always `false` in a `StaticRepresentationIndex` because all segments should
     * be directly available.
     * @returns {boolean}
     */
    awaitSegmentBetween() {
      return false;
    }
    /**
     * Returns false as a static file never need to be refreshed.
     * @returns {Boolean}
     */
    shouldRefresh() {
      return false;
    }
    /**
     * @returns {null}
     */
    checkDiscontinuity() {
      return null;
    }
    /**
     * Returns true as a static file should never need lose availability.
     * @returns {Boolean}
     */
    isSegmentStillAvailable() {
      return true;
    }
    /**
     * @returns {Boolean}
     */
    canBeOutOfSyncError() {
      return false;
    }
    /**
     * @returns {Boolean}
     */
    isStillAwaitingFutureSegments() {
      return false;
    }
    /**
     * @returns {Boolean}
     */
    isInitialized() {
      return true;
    }
    initialize() {
      log_default.error("A `StaticRepresentationIndex` does not need to be initialized");
    }
    addPredictedSegments() {
      log_default.warn("Cannot add predicted segments to a `StaticRepresentationIndex`");
    }
    _replace() {
      log_default.warn("Tried to replace a static RepresentationIndex");
    }
    _update() {
      log_default.warn("Tried to update a static RepresentationIndex");
    }
  };

  // src/manifest/classes/utils.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function areSameContent(content1, content2) {
    return content1.segment.id === content2.segment.id && content1.representation.uniqueId === content2.representation.uniqueId;
  }
  function getLoggableSegmentId(content) {
    if (isNullOrUndefined(content)) {
      return "";
    }
    const { period, adaptation, representation, segment } = content;
    let segmentString;
    if (segment.isInit) {
      segmentString = "init";
    } else if (segment.complete) {
      segmentString = `${segment.time}-${segment.duration}`;
    } else {
      segmentString = `${segment.time}`;
    }
    return `${adaptation.type} P: ${period.id} A: ${adaptation.id} R: ${representation.id} S: ${segmentString}`;
  }

  // src/manifest/classes/index.ts
  var classes_default = Manifest;

  // src/playback_observer/media_element_playback_observer.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/compat/is_seeking_approximate.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var isSeekingApproximate = isTizen;
  var is_seeking_approximate_default = isSeekingApproximate;

  // src/utils/ranges.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var EPSILON = 1 / 60;
  function nearlyEqual(a, b) {
    return Math.abs(a - b) < EPSILON;
  }
  function createRangeUnion(range1, range2) {
    const start = Math.min(range1.start, range2.start);
    const end = Math.max(range1.end, range2.end);
    return { start, end };
  }
  function removeEmptyRanges(ranges) {
    for (let index = 0; index < ranges.length; index++) {
      const range = ranges[index];
      if (range.start === range.end) {
        ranges.splice(index--, 1);
      }
    }
    return ranges;
  }
  function mergeContiguousRanges(ranges) {
    for (let index = 1; index < ranges.length; index++) {
      const prevRange = ranges[index - 1];
      const currRange = ranges[index];
      if (areRangesNearlyContiguous(prevRange, currRange)) {
        const unionRange = createRangeUnion(prevRange, currRange);
        ranges.splice(--index, 2, unionRange);
      }
    }
    return ranges;
  }
  function isBefore(range1, range2) {
    return range1.end <= range2.start;
  }
  function isTimeInRange({ start, end }, time) {
    return start <= time && time < end;
  }
  function areRangesOverlapping(range1, range2) {
    return isTimeInRange(range1, range2.start) || range1.start < range2.end && range2.end < range1.end || isTimeInRange(range2, range1.start);
  }
  function areRangesNearlyContiguous(range1, range2) {
    return nearlyEqual(range2.start, range1.end) || nearlyEqual(range2.end, range1.start);
  }
  function convertToRanges(timeRanges) {
    const ranges = [];
    for (let i = 0; i < timeRanges.length; i++) {
      ranges.push({ start: timeRanges.start(i), end: timeRanges.end(i) });
    }
    return ranges;
  }
  function getBufferedTimeRange(timeRanges, time) {
    for (let i = timeRanges.length - 1; i >= 0; i--) {
      const start = timeRanges.start(i);
      if (time >= start) {
        const end = timeRanges.end(i);
        if (time < end) {
          return { start, end };
        }
      }
    }
    return null;
  }
  function getRange(ranges, time) {
    for (let i = ranges.length - 1; i >= 0; i--) {
      const start = ranges[i].start;
      if (time >= start) {
        const end = ranges[i].end;
        if (time < end) {
          return ranges[i];
        }
      }
    }
    return null;
  }
  function getNextBufferedTimeRangeGap(timeRanges, time) {
    const len = timeRanges.length;
    for (let i = 0; i < len; i++) {
      const start = timeRanges.start(i);
      if (time < start) {
        return start - time;
      }
    }
    return Infinity;
  }
  function getInnerAndOuterRanges(ranges, time) {
    let innerRange = null;
    const outerRanges = [];
    for (let i = 0; i < ranges.length; i++) {
      const start = ranges[i].start;
      const end = ranges[i].end;
      if (time < start || time >= end) {
        outerRanges.push({ start, end });
      } else {
        innerRange = { start, end };
      }
    }
    return { outerRanges, innerRange };
  }
  function getLeftSizeOfBufferedTimeRange(timeRanges, currentTime) {
    const range = getBufferedTimeRange(timeRanges, currentTime);
    return range !== null ? range.end - currentTime : Infinity;
  }
  function getLeftSizeOfRange(ranges, currentTime) {
    const range = getRange(ranges, currentTime);
    return range !== null ? range.end - currentTime : Infinity;
  }
  function insertInto(ranges, rangeToAddArg) {
    if (rangeToAddArg.start === rangeToAddArg.end) {
      return ranges;
    }
    let rangeToAdd = rangeToAddArg;
    let index = 0;
    for (; index < ranges.length; index++) {
      const range = ranges[index];
      const overlapping = areRangesOverlapping(rangeToAdd, range);
      const contiguous = areRangesNearlyContiguous(rangeToAdd, range);
      if (overlapping || contiguous) {
        rangeToAdd = createRangeUnion(rangeToAdd, range);
        ranges.splice(index--, 1);
      } else {
        if (index === 0) {
          if (isBefore(rangeToAdd, ranges[0])) {
            break;
          }
        } else {
          if (isBefore(ranges[index - 1], rangeToAdd) && isBefore(rangeToAdd, range)) {
            break;
          }
        }
      }
    }
    ranges.splice(index, 0, rangeToAdd);
    return mergeContiguousRanges(removeEmptyRanges(ranges));
  }
  function findOverlappingRanges(range, ranges) {
    const resultingRanges = [];
    for (let i = 0; i < ranges.length; i++) {
      if (areRangesOverlapping(range, ranges[i])) {
        resultingRanges.push(ranges[i]);
      }
    }
    return resultingRanges;
  }
  function keepRangeIntersection(ranges1, ranges2) {
    const result = [];
    for (let i = 0; i < ranges1.length; i++) {
      const range = ranges1[i];
      const overlappingRanges = findOverlappingRanges(range, ranges2);
      if (overlappingRanges.length > 0) {
        for (let j = 0; j < overlappingRanges.length; j++) {
          const overlappingRange = overlappingRanges[j];
          result.push({
            start: Math.max(range.start, overlappingRange.start),
            end: Math.min(range.end, overlappingRange.end)
          });
        }
      }
    }
    return result;
  }
  function excludeFromRanges(baseRanges, rangesToExclude) {
    const result = [];
    for (let i = 0; i < baseRanges.length; i++) {
      const range = baseRanges[i];
      const intersections = [];
      const overlappingRanges = findOverlappingRanges(range, rangesToExclude);
      if (overlappingRanges.length > 0) {
        for (let j = 0; j < overlappingRanges.length; j++) {
          const overlappingRange = overlappingRanges[j];
          intersections.push({
            start: Math.max(range.start, overlappingRange.start),
            end: Math.min(range.end, overlappingRange.end)
          });
        }
      }
      if (intersections.length === 0) {
        result.push(range);
      } else {
        let lastStart = range.start;
        for (let j = 0; j < intersections.length; j++) {
          if (intersections[j].start > lastStart) {
            result.push({ start: lastStart, end: intersections[j].start });
          }
          lastStart = intersections[j].end;
        }
        if (lastStart < range.end) {
          result.push({ start: lastStart, end: range.end });
        }
      }
    }
    return result;
  }

  // src/playback_observer/utils/generate_read_only_observer.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function generateReadOnlyObserver(src, transform, cancellationSignal) {
    const mappedRef = transform(src.getReference(), cancellationSignal);
    return {
      getCurrentTime() {
        return src.getCurrentTime();
      },
      getReadyState() {
        return src.getReadyState();
      },
      getPlaybackRate() {
        return src.getPlaybackRate();
      },
      getIsPaused() {
        return src.getIsPaused();
      },
      getReference() {
        return mappedRef;
      },
      listen(cb, options) {
        var _a;
        if (cancellationSignal.isCancelled() || ((_a = options == null ? void 0 : options.clearSignal) == null ? void 0 : _a.isCancelled()) === true) {
          return;
        }
        mappedRef.onUpdate(cb, {
          clearSignal: options == null ? void 0 : options.clearSignal,
          emitCurrentValue: options == null ? void 0 : options.includeLastObservation
        });
      },
      deriveReadOnlyObserver(newTransformFn) {
        return generateReadOnlyObserver(this, newTransformFn, cancellationSignal);
      }
    };
  }

  // src/playback_observer/utils/observation_position.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var ObservationPosition = class {
    constructor(last, wanted) {
      this._last = last;
      this._wanted = wanted;
    }
    /**
     * Obtain arguments allowing to instanciate the same ObservationPosition.
     *
     * This can be used to create a new `ObservationPosition` across JS realms,
     * generally to communicate its data between the main thread and a WebWorker.
     * @returns {Array.<number>}
     */
    serialize() {
      return [this._last, this._wanted];
    }
    /**
     * Returns the playback position actually observed on the media element at
     * the time the playback observation was made.
     *
     * Note that it may be different than the position for which media data is
     * wanted in rare scenarios where the goal position is not yet set on the
     * media element.
     *
     * You should use this value when you want to obtain the actual position set
     * on the media element for browser compatibility purposes. Note that this
     * position was calculated at observation time, it might thus not be
     * up-to-date if what you want is milliseconds-accuracy.
     *
     * If what you want is the actual position which the player is intended to
     * play, you should rely on `getWanted` instead`.
     * @returns {number}
     */
    getPolled() {
      return this._last;
    }
    /**
     * Returns the position which the player should consider to load media data
     * at the time the observation was made.
     *
     * It can be different than the value returned by `getPolled` in rare
     * scenarios:
     *
     *   - When the initial position has not been set yet.
     *
     *   - When the current device do not let the RxPlayer peform precize seeks,
     *     usually for perfomance reasons by seeking to a previous IDR frame
     *     instead (for now only Tizen may be like this), in which case we
     *     prefer to generally rely on the position wanted by the player (this
     *     e.g. prevents issues where the RxPlayer logic and the device are
     *     seeking back and forth in a loop).
     *
     *   - When a wanted position has been "forced" (@see forceWantedPosition).
     * @returns {number}
     */
    getWanted() {
      var _a;
      return (_a = this._wanted) != null ? _a : this._last;
    }
    /**
     * Method to call if you want to overwrite the currently wanted position.
     * @param {number} pos
     */
    forceWantedPosition(pos) {
      this._wanted = pos;
    }
    /**
     * Returns `true` when the position wanted returned by `getWanted` and the
     * actual position returned by `getPolled` may be different, meaning that
     * we're currently not at the position we want to reach.
     *
     * This is a relatively rare situation which only happens when either the
     * initial seek has not yet been performed. on specific targets where the
     * seeking behavior is a little broken (@see getWanted) or when the wanted
     * position has been forced (@see forceWantedPosition).
     *
     * In those situations, you might temporarily refrain from acting upon the
     * actual current media position, as it may change soon.
     *
     * @returns {boolean}
     */
    isAwaitingFuturePosition() {
      return this._wanted !== null;
    }
  };

  // src/playback_observer/media_element_playback_observer.ts
  var SCANNED_MEDIA_ELEMENTS_EVENTS = [
    "canplay",
    "ended",
    "play",
    "pause",
    "seeking",
    "seeked",
    "loadedmetadata",
    "ratechange"
  ];
  var PlaybackObserver = class {
    /**
     * Create a new `PlaybackObserver`, which allows to produce new "playback
     * observations" on various media events and intervals.
     *
     * Note that creating a `PlaybackObserver` lead to the usage of resources,
     * such as event listeners which will only be freed once the `stop` method is
     * called.
     * @param {HTMLMediaElement} mediaElement
     * @param {Object} options
     */
    constructor(mediaElement, options) {
      this._internalSeeksIncoming = [];
      this._mediaElement = mediaElement;
      this._withMediaSource = options.withMediaSource;
      this._lowLatencyMode = options.lowLatencyMode;
      this._canceller = new TaskCanceller();
      this._observationRef = this._createSharedReference();
      this._expectedSeekingPosition = null;
      this._pendingSeek = null;
      const onLoadedMetadata2 = () => {
        if (this._pendingSeek !== null) {
          const positionToSeekTo = this._pendingSeek;
          this._pendingSeek = null;
          this._actuallySetCurrentTime(positionToSeekTo);
        }
      };
      mediaElement.addEventListener("loadedmetadata", onLoadedMetadata2);
      this._canceller.signal.register(() => {
        mediaElement.removeEventListener("loadedmetadata", onLoadedMetadata2);
      });
    }
    /**
     * Stop the `PlaybackObserver` from emitting playback observations and free all
     * resources reserved to emitting them such as event listeners and intervals.
     *
     * Once `stop` is called, no new playback observation will ever be emitted.
     *
     * Note that it is important to call stop once the `PlaybackObserver` is no
     * more needed to avoid unnecessarily leaking resources.
     */
    stop() {
      this._canceller.cancel();
    }
    /**
     * Returns the current position advertised by the `HTMLMediaElement`, in
     * seconds.
     * @returns {number}
     */
    getCurrentTime() {
      return this._mediaElement.currentTime;
    }
    /**
     * Returns the current playback rate advertised by the `HTMLMediaElement`.
     * @returns {number}
     */
    getPlaybackRate() {
      return this._mediaElement.playbackRate;
    }
    /**
     * Returns the current `paused` status advertised by the `HTMLMediaElement`.
     *
     * Use this instead of the same status emitted on an observation when you want
     * to be sure you're using the current value.
     * @returns {boolean}
     */
    getIsPaused() {
      return this._mediaElement.paused;
    }
    /**
     * Update the current position (seek) on the `HTMLMediaElement`, by giving a
     * new position in seconds.
     *
     * Note that seeks performed through this method are caracherized as
     * "internal" seeks. They don't result into the exact same playback
     * observation than regular seeks (which most likely comes from the outside,
     * e.g. the user).
     * @param {number} time
     */
    setCurrentTime(time) {
      if (this._mediaElement.readyState >= 1) {
        this._actuallySetCurrentTime(time);
      } else {
        this._internalSeeksIncoming = [];
        this._pendingSeek = time;
        this._generateObservationForEvent("manual");
      }
    }
    /**
     * Update the playback rate of the `HTMLMediaElement`.
     * @param {number} playbackRate
     */
    setPlaybackRate(playbackRate) {
      this._mediaElement.playbackRate = playbackRate;
    }
    /**
     * Returns the current `readyState` advertised by the `HTMLMediaElement`.
     * @returns {number}
     */
    getReadyState() {
      return this._mediaElement.readyState;
    }
    /**
     * Returns an `IReadOnlySharedReference` storing the last playback observation
     * produced by the `PlaybackObserver` and updated each time a new one is
     * produced.
     *
     * This value can then be for example listened to to be notified of future
     * playback observations.
     *
     * @returns {Object}
     */
    getReference() {
      return this._observationRef;
    }
    /**
     * Register a callback so it regularly receives playback observations.
     * @param {Function} cb
     * @param {Object} options - Configuration options:
     *   - `includeLastObservation`: If set to `true` the last observation will
     *     be first emitted synchronously.
     *   - `clearSignal`: If set, the callback will be unregistered when this
     *     CancellationSignal emits.
     */
    listen(cb, options) {
      var _a;
      if (this._canceller.isUsed() || ((_a = options == null ? void 0 : options.clearSignal) == null ? void 0 : _a.isCancelled()) === true) {
        return noop_default;
      }
      this._observationRef.onUpdate(cb, {
        clearSignal: options == null ? void 0 : options.clearSignal,
        emitCurrentValue: options == null ? void 0 : options.includeLastObservation
      });
    }
    /**
     * Generate a new playback observer which can listen to other
     * properties and which can only be accessed to read observations (e.g.
     * it cannot ask to perform a seek).
     *
     * The object returned will respect the `IReadOnlyPlaybackObserver` interface
     * and will inherit this `PlaybackObserver`'s lifecycle: it will emit when
     * the latter emits.
     *
     * As argument, this method takes a function which will allow to produce
     * the new set of properties to be present on each observation.
     * @param {Function} transform
     * @returns {Object}
     */
    deriveReadOnlyObserver(transform) {
      return generateReadOnlyObserver(this, transform, this._canceller.signal);
    }
    _actuallySetCurrentTime(time) {
      log_default.info("API: Seeking internally", time);
      this._internalSeeksIncoming.push(time);
      this._mediaElement.currentTime = time;
    }
    /**
     * Creates the `IReadOnlySharedReference` that will generate playback
     * observations.
     * @returns {Object}
     */
    _createSharedReference() {
      if (this._observationRef !== void 0) {
        return this._observationRef;
      }
      const {
        SAMPLING_INTERVAL_MEDIASOURCE,
        SAMPLING_INTERVAL_LOW_LATENCY,
        SAMPLING_INTERVAL_NO_MEDIASOURCE
      } = config_default.getCurrent();
      const returnedSharedReference = new reference_default(
        this._getCurrentObservation("init"),
        this._canceller.signal
      );
      let interval;
      if (this._lowLatencyMode) {
        interval = SAMPLING_INTERVAL_LOW_LATENCY;
      } else if (this._withMediaSource) {
        interval = SAMPLING_INTERVAL_MEDIASOURCE;
      } else {
        interval = SAMPLING_INTERVAL_NO_MEDIASOURCE;
      }
      const onInterval = () => {
        this._generateObservationForEvent("timeupdate");
      };
      let intervalId = setInterval(onInterval, interval);
      SCANNED_MEDIA_ELEMENTS_EVENTS.map((eventName) => {
        const onMediaEvent = () => {
          restartInterval();
          this._generateObservationForEvent(eventName);
        };
        this._mediaElement.addEventListener(eventName, onMediaEvent);
        this._canceller.signal.register(() => {
          this._mediaElement.removeEventListener(eventName, onMediaEvent);
        });
      });
      this._canceller.signal.register(() => {
        clearInterval(intervalId);
        returnedSharedReference.finish();
      });
      return returnedSharedReference;
      function restartInterval() {
        clearInterval(intervalId);
        intervalId = setInterval(onInterval, interval);
      }
    }
    _getCurrentObservation(event) {
      var _a, _b;
      let tmpEvt = event;
      const previousObservation = this._observationRef === void 0 ? getInitialObservation(this._mediaElement) : this._observationRef.getValue();
      let isInternalSeeking = false;
      let pendingPosition = this._pendingSeek;
      const mediaTimings = getMediaInfos(this._mediaElement);
      const { buffered, readyState, position, seeking } = mediaTimings;
      if (tmpEvt === "seeking") {
        if (this._internalSeeksIncoming.length > 0) {
          isInternalSeeking = true;
          tmpEvt = "internal-seeking";
          const startedInternalSeekTime = this._internalSeeksIncoming.shift();
          this._expectedSeekingPosition = is_seeking_approximate_default ? Math.max(position, startedInternalSeekTime != null ? startedInternalSeekTime : 0) : position;
        } else {
          this._expectedSeekingPosition = position;
        }
      } else if (seeking) {
        this._expectedSeekingPosition = Math.max(
          position,
          (_a = this._expectedSeekingPosition) != null ? _a : 0
        );
      } else if (is_seeking_approximate_default && this._expectedSeekingPosition !== null && position < this._expectedSeekingPosition) {
        pendingPosition = this._expectedSeekingPosition;
      } else {
        this._expectedSeekingPosition = null;
      }
      if (seeking && previousObservation.seeking === 1 /* Internal */ && event !== "seeking") {
        isInternalSeeking = true;
      }
      const basePosition = (_b = this._expectedSeekingPosition) != null ? _b : position;
      let currentRange;
      let bufferGap;
      if (!this._withMediaSource && buffered.length === 0 && readyState >= 3) {
        currentRange = void 0;
        bufferGap = void 0;
      } else {
        currentRange = getBufferedTimeRange(buffered, basePosition);
        bufferGap = currentRange !== null ? currentRange.end - basePosition : (
          // TODO null/0 would probably be
          // more appropriate
          Infinity
        );
      }
      const rebufferingStatus = getRebufferingStatus({
        previousObservation,
        currentObservation: mediaTimings,
        basePosition,
        observationEvent: tmpEvt,
        lowLatencyMode: this._lowLatencyMode,
        withMediaSource: this._withMediaSource,
        bufferGap,
        currentRange
      });
      const freezingStatus = getFreezingStatus(
        previousObservation,
        mediaTimings,
        tmpEvt,
        bufferGap
      );
      let seekingState;
      if (isInternalSeeking) {
        seekingState = 1 /* Internal */;
      } else if (seeking) {
        seekingState = 2 /* External */;
      } else {
        seekingState = 0 /* None */;
      }
      const timings = object_assign_default({}, mediaTimings, {
        position: new ObservationPosition(mediaTimings.position, pendingPosition),
        event: tmpEvt,
        seeking: seekingState,
        rebuffering: rebufferingStatus,
        freezing: freezingStatus,
        bufferGap,
        currentRange
      });
      if (log_default.hasLevel("DEBUG")) {
        log_default.debug(
          "API: current media element state tick",
          "event",
          timings.event,
          "position",
          timings.position.getPolled(),
          "seeking",
          timings.seeking,
          "internalSeek",
          isInternalSeeking,
          "rebuffering",
          timings.rebuffering !== null,
          "freezing",
          timings.freezing !== null,
          "ended",
          timings.ended,
          "paused",
          timings.paused,
          "playbackRate",
          timings.playbackRate,
          "readyState",
          timings.readyState,
          "pendingPosition",
          pendingPosition
        );
      }
      return timings;
    }
    _generateObservationForEvent(event) {
      const newObservation = this._getCurrentObservation(event);
      if (log_default.hasLevel("DEBUG")) {
        log_default.debug(
          "API: current playback timeline:\n" + prettyPrintBuffered(
            newObservation.buffered,
            newObservation.position.getPolled()
          ),
          `
${event}`
        );
      }
      this._observationRef.setValue(newObservation);
    }
  };
  function getRebufferingEndGap(rebufferingStatus, lowLatencyMode) {
    if (rebufferingStatus === null) {
      return 0;
    }
    const suffix = lowLatencyMode ? "LOW_LATENCY" : "DEFAULT";
    const {
      RESUME_GAP_AFTER_SEEKING,
      RESUME_GAP_AFTER_NOT_ENOUGH_DATA,
      RESUME_GAP_AFTER_BUFFERING
    } = config_default.getCurrent();
    switch (rebufferingStatus.reason) {
      case "seeking":
        return RESUME_GAP_AFTER_SEEKING[suffix];
      case "not-ready":
        return RESUME_GAP_AFTER_NOT_ENOUGH_DATA[suffix];
      case "buffering":
        return RESUME_GAP_AFTER_BUFFERING[suffix];
    }
  }
  function hasLoadedUntilTheEnd(currentTime, currentRange, ended, duration, lowLatencyMode) {
    const { REBUFFERING_GAP } = config_default.getCurrent();
    const suffix = lowLatencyMode ? "LOW_LATENCY" : "DEFAULT";
    if (currentRange === void 0) {
      return ended && Math.abs(duration - currentTime) <= REBUFFERING_GAP[suffix];
    }
    return currentRange !== null && duration - currentRange.end <= REBUFFERING_GAP[suffix];
  }
  function getMediaInfos(mediaElement) {
    const {
      buffered,
      currentTime,
      duration,
      ended,
      paused,
      playbackRate,
      readyState,
      seeking
    } = mediaElement;
    return {
      buffered,
      position: currentTime,
      duration,
      ended,
      paused,
      playbackRate,
      readyState,
      seeking
    };
  }
  function getRebufferingStatus({
    previousObservation,
    currentObservation,
    basePosition,
    observationEvent,
    withMediaSource,
    lowLatencyMode,
    bufferGap,
    currentRange
  }) {
    const { REBUFFERING_GAP } = config_default.getCurrent();
    const {
      position: currentTime,
      duration,
      paused,
      readyState,
      ended
    } = currentObservation;
    const {
      rebuffering: prevRebuffering,
      event: prevEvt,
      position: prevTime
    } = previousObservation;
    const fullyLoaded = hasLoadedUntilTheEnd(
      basePosition,
      currentRange,
      ended,
      duration,
      lowLatencyMode
    );
    const canSwitchToRebuffering = readyState >= 1 && observationEvent !== "loadedmetadata" && prevRebuffering === null && !(fullyLoaded || ended);
    let rebufferEndPosition = null;
    let shouldRebuffer;
    let shouldStopRebuffer;
    const rebufferGap = lowLatencyMode ? REBUFFERING_GAP.LOW_LATENCY : REBUFFERING_GAP.DEFAULT;
    if (withMediaSource) {
      if (canSwitchToRebuffering) {
        if (bufferGap === Infinity) {
          shouldRebuffer = true;
          rebufferEndPosition = basePosition;
        } else if (bufferGap === void 0) {
          if (readyState < 3) {
            shouldRebuffer = true;
            rebufferEndPosition = void 0;
          }
        } else if (bufferGap <= rebufferGap) {
          shouldRebuffer = true;
          rebufferEndPosition = basePosition + bufferGap;
        }
      } else if (prevRebuffering !== null) {
        const resumeGap = getRebufferingEndGap(prevRebuffering, lowLatencyMode);
        if (shouldRebuffer !== true && prevRebuffering !== null && readyState > 1 && (fullyLoaded || ended || bufferGap !== void 0 && isFinite(bufferGap) && bufferGap > resumeGap) || bufferGap === void 0 && readyState >= 3) {
          shouldStopRebuffer = true;
        } else if (bufferGap === void 0) {
          rebufferEndPosition = void 0;
        } else if (bufferGap === Infinity) {
          rebufferEndPosition = basePosition;
        } else if (bufferGap <= resumeGap) {
          rebufferEndPosition = basePosition + bufferGap;
        }
      }
    } else {
      if (canSwitchToRebuffering && // TODO what about when paused: e.g. when loading initially the content
      (!paused && observationEvent === "timeupdate" && prevEvt === "timeupdate" && currentTime === prevTime.getPolled() || observationEvent === "seeking" && (bufferGap === Infinity || bufferGap === void 0 && readyState < 3))) {
        shouldRebuffer = true;
      } else if (prevRebuffering !== null && (observationEvent !== "seeking" && currentTime !== prevTime.getPolled() || observationEvent === "canplay" || bufferGap === void 0 && readyState >= 3 || bufferGap !== void 0 && bufferGap < Infinity && (bufferGap > getRebufferingEndGap(prevRebuffering, lowLatencyMode) || fullyLoaded || ended))) {
        shouldStopRebuffer = true;
      }
    }
    if (shouldStopRebuffer === true) {
      return null;
    } else if (shouldRebuffer === true || prevRebuffering !== null) {
      let reason;
      if (observationEvent === "seeking" || prevRebuffering !== null && prevRebuffering.reason === "seeking") {
        reason = "seeking";
      } else if (currentObservation.seeking) {
        reason = "seeking";
      } else if (readyState === 1) {
        reason = "not-ready";
      } else {
        reason = "buffering";
      }
      if (prevRebuffering !== null && prevRebuffering.reason === reason) {
        return {
          reason: prevRebuffering.reason,
          timestamp: prevRebuffering.timestamp,
          position: rebufferEndPosition
        };
      }
      return {
        reason,
        timestamp: monotonic_timestamp_default(),
        position: rebufferEndPosition
      };
    }
    return null;
  }
  function getFreezingStatus(prevObservation, currentInfo, currentEvt, bufferGap) {
    const { MINIMUM_BUFFER_AMOUNT_BEFORE_FREEZING } = config_default.getCurrent();
    if (prevObservation.freezing) {
      if (currentInfo.ended || currentInfo.paused || currentInfo.readyState === 0 || currentInfo.playbackRate === 0 || prevObservation.position.getPolled() !== currentInfo.position) {
        return null;
      }
      return prevObservation.freezing;
    }
    return currentEvt === "timeupdate" && bufferGap !== void 0 && bufferGap > MINIMUM_BUFFER_AMOUNT_BEFORE_FREEZING && !currentInfo.ended && !currentInfo.paused && currentInfo.readyState >= 1 && currentInfo.playbackRate !== 0 && currentInfo.position === prevObservation.position.getPolled() ? { timestamp: monotonic_timestamp_default() } : null;
  }
  function prettyPrintBuffered(buffered, currentTime) {
    let str = "";
    let currentTimeStr = "";
    for (let i = 0; i < buffered.length; i++) {
      const start = buffered.start(i);
      const end = buffered.end(i);
      const fixedStart = start.toFixed(2);
      const fixedEnd = end.toFixed(2);
      const fixedDuration = (end - start).toFixed(2);
      const newIntervalStr = `${fixedStart}|==${fixedDuration}==|${fixedEnd}`;
      str += newIntervalStr;
      if (currentTimeStr.length === 0 && end > currentTime) {
        const padBefore = str.length - Math.floor(newIntervalStr.length / 2);
        currentTimeStr = " ".repeat(padBefore) + `^${currentTime}`;
      }
      if (i < buffered.length - 1) {
        const nextStart = buffered.start(i + 1);
        const fixedDiff = (nextStart - end).toFixed(2);
        const holeStr = ` ~${fixedDiff}~ `;
        str += holeStr;
        if (currentTimeStr.length === 0 && currentTime < nextStart) {
          const padBefore = str.length - Math.floor(holeStr.length / 2);
          currentTimeStr = " ".repeat(padBefore) + `^${currentTime}`;
        }
      }
    }
    if (currentTimeStr.length === 0) {
      currentTimeStr = " ".repeat(str.length) + `^${currentTime}`;
    }
    return str + "\n" + currentTimeStr;
  }
  function getInitialObservation(mediaElement) {
    const mediaTimings = getMediaInfos(mediaElement);
    return object_assign_default(mediaTimings, {
      rebuffering: null,
      event: "init",
      seeking: 0 /* None */,
      position: new ObservationPosition(mediaTimings.position, null),
      freezing: null,
      bufferGap: 0,
      currentRange: null
    });
  }

  // src/main_thread/render_thumbnail.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  async function renderThumbnail(contentInfos, options) {
    const { time, container } = options;
    if (contentInfos === null || contentInfos.fetchThumbnailDataCallback === null || contentInfos.manifest === null) {
      return Promise.reject(
        new ThumbnailRenderingError(
          "NO_CONTENT",
          "Cannot get thumbnail: no content loaded"
        )
      );
    }
    const { thumbnailRequestsInfo, currentContentCanceller } = contentInfos;
    const canceller = new TaskCanceller();
    canceller.linkToSignal(currentContentCanceller.signal);
    let imageUrl;
    const olderTaskSameContainer = thumbnailRequestsInfo.pendingRequests.get(container);
    olderTaskSameContainer == null ? void 0 : olderTaskSameContainer.cancel();
    thumbnailRequestsInfo.pendingRequests.set(container, canceller);
    const onFinished = () => {
      canceller.cancel();
      thumbnailRequestsInfo.pendingRequests.delete(container);
      setTimeout(() => {
        if (imageUrl !== void 0) {
          URL.revokeObjectURL(imageUrl);
        }
      }, 0);
    };
    try {
      const period = getPeriodForTime(contentInfos.manifest, time);
      if (period === void 0) {
        throw new ThumbnailRenderingError("NO_THUMBNAIL", "Wanted Period not found.");
      }
      const thumbnailTracks = period.thumbnailTracks;
      const thumbnailTrack = options.thumbnailTrackId !== void 0 ? arrayFind(thumbnailTracks, (t) => t.id === options.thumbnailTrackId) : thumbnailTracks[0];
      if (thumbnailTrack === void 0) {
        if (options.thumbnailTrackId !== void 0) {
          throw new ThumbnailRenderingError(
            "NO_THUMBNAIL",
            "Given `thumbnailTrackId` not found"
          );
        } else {
          throw new ThumbnailRenderingError(
            "NO_THUMBNAIL",
            "Wanted Period has no thumbnail track."
          );
        }
      }
      const { lastResponse } = thumbnailRequestsInfo;
      let res;
      if (lastResponse !== null && lastResponse.thumbnailTrackId === thumbnailTrack.id && lastResponse.periodId === period.id) {
        const previousThumbs = lastResponse.response.thumbnails;
        if (previousThumbs.length > 0 && time >= previousThumbs[0].start && time < previousThumbs[previousThumbs.length - 1].end) {
          res = lastResponse.response;
        }
      }
      if (res === void 0) {
        res = await contentInfos.fetchThumbnailDataCallback(
          period.id,
          thumbnailTrack.id,
          time
        );
        thumbnailRequestsInfo.lastResponse = {
          response: res,
          periodId: period.id,
          thumbnailTrackId: thumbnailTrack.id
        };
      }
      const canvas = document.createElement("canvas");
      const context = canvas.getContext("2d");
      if (context === null) {
        throw new ThumbnailRenderingError(
          "RENDERING",
          "Cannot display thumbnail: cannot create canvas context"
        );
      }
      let foundIdx;
      for (let i = 0; i < res.thumbnails.length; i++) {
        if (res.thumbnails[i].start <= time && res.thumbnails[i].end > time) {
          foundIdx = i;
          break;
        }
      }
      if (foundIdx === void 0) {
        throw new Error("Cannot display thumbnail: time not found in fetched data");
      }
      const image = new Image();
      const blob = new Blob([res.data], { type: res.mimeType });
      imageUrl = URL.createObjectURL(blob);
      image.src = imageUrl;
      canvas.height = res.thumbnails[foundIdx].height;
      canvas.width = res.thumbnails[foundIdx].width;
      return new Promise((resolve, reject) => {
        image.onload = () => {
          try {
            context.drawImage(
              image,
              res.thumbnails[foundIdx].offsetX,
              res.thumbnails[foundIdx].offsetY,
              res.thumbnails[foundIdx].width,
              res.thumbnails[foundIdx].height,
              0,
              0,
              res.thumbnails[foundIdx].width,
              res.thumbnails[foundIdx].height
            );
            canvas.style.width = "100%";
            canvas.style.height = "100%";
            canvas.className = "__rx-thumbnail__";
            clearPreviousThumbnails();
            container.appendChild(canvas);
            resolve();
          } catch (srcError) {
            reject(
              new ThumbnailRenderingError(
                "RENDERING",
                "Could not draw the image in a canvas"
              )
            );
          }
          onFinished();
        };
        image.onerror = () => {
          if (options.keepPreviousThumbnailOnError !== true) {
            clearPreviousThumbnails();
          }
          reject(
            new ThumbnailRenderingError(
              "RENDERING",
              "Could not load the corresponding image in the DOM"
            )
          );
          onFinished();
        };
      });
    } catch (srcError) {
      if (options.keepPreviousThumbnailOnError !== true) {
        clearPreviousThumbnails();
      }
      if (srcError !== null && srcError === canceller.signal.cancellationError) {
        const error = new ThumbnailRenderingError(
          "ABORTED",
          "Thumbnail rendering has been aborted"
        );
        throw error;
      }
      const formattedErr = formatError(srcError, {
        defaultCode: "NONE",
        defaultReason: "Unknown error"
      });
      let returnedError;
      if (formattedErr.type === "NETWORK_ERROR") {
        returnedError = new ThumbnailRenderingError("LOADING", formattedErr.message);
      } else {
        returnedError = new ThumbnailRenderingError("NOT_FOUND", formattedErr.message);
      }
      onFinished();
      throw returnedError;
    }
    function clearPreviousThumbnails() {
      for (let i = container.children.length - 1; i >= 0; i--) {
        const child = container.children[i];
        if (child.className === "__rx-thumbnail__") {
          container.removeChild(child);
        }
      }
    }
  }
  var ThumbnailRenderingError = class _ThumbnailRenderingError extends Error {
    /**
     * @param {string} code
     * @param {string} message
     */
    constructor(code, message) {
      super(errorMessage(code, message));
      Object.setPrototypeOf(this, _ThumbnailRenderingError.prototype);
      this.name = "ThumbnailRenderingError";
      this.code = code;
    }
  };

  // src/main_thread/tracks_store/index.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/main_thread/tracks_store/tracks_store.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/main_thread/tracks_store/track_dispatcher.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var TrackDispatcher = class extends EventEmitter {
    /**
     * Create a new `TrackDispatcher` by giving its Reference and an initial track
     * setting.
     * This constructor will update the Reference with the right preferences
     * synchronously.
     * @param {Object} adaptationRef
     */
    constructor(adaptationRef) {
      super();
      this._canceller = new TaskCanceller();
      this._adaptationRef = adaptationRef;
      this._updateToken = false;
      this._lastEmitted = void 0;
      this.refresh = noop_default;
    }
    /**
     * Returns `true` if the initial track choice has been sent by this
     * `TrackDispatcher`.
     * Returns `false` if that's not the case yet.
     * @returns {boolean}
     */
    hasSetTrack() {
      return this._adaptationRef.getValue() !== void 0;
    }
    /**
     * Update the wanted track on the Reference linked to this `TrackDispatcher`.
     * @param {Object|null} newTrackInfo
     */
    updateTrack(newTrackInfo) {
      this._updateToken = true;
      if (newTrackInfo === null) {
        if (this._lastEmitted === null) {
          return;
        }
        this._updateToken = false;
        this._canceller.cancel();
        this._canceller = new TaskCanceller();
        this._lastEmitted = null;
        this._adaptationRef.setValue(null);
        return;
      }
      const { adaptation, switchingMode, relativeResumingPosition } = newTrackInfo;
      this._canceller.cancel();
      this._canceller = new TaskCanceller();
      const reference = this._constructLockedRepresentationsReference(newTrackInfo);
      if (!this._updateToken) {
        return;
      }
      this._lastEmitted = {
        adaptation,
        switchingMode,
        lockedRepresentations: null
      };
      this._updateToken = false;
      this._adaptationRef.setValue({
        adaptationId: adaptation.id,
        switchingMode,
        representations: reference,
        relativeResumingPosition
      });
    }
    /**
     * Create a shared reference which will emit the wanted locked Representations
     * based on the current capabilities and the last user settings.
     *
     * @param {Object} trackInfo
     * @returns {Object}
     */
    _constructLockedRepresentationsReference(trackInfo) {
      const reference = new reference_default({
        representationIds: [],
        switchingMode: "lazy"
      });
      const self2 = this;
      this.refresh = updateReferenceIfNeeded;
      this._canceller.signal.register(removeListeners);
      trackInfo.lockedRepresentations.onUpdate(updateReferenceIfNeeded, {
        clearSignal: this._canceller.signal,
        emitCurrentValue: false
      });
      updateReferenceIfNeeded();
      return reference;
      function updateReferenceIfNeeded() {
        const repSettings = trackInfo.lockedRepresentations.getValue();
        let switchingMode;
        let playableRepresentations;
        if (repSettings === null) {
          playableRepresentations = trackInfo.adaptation.representations.filter(
            (representation) => {
              return representation.isSupported === true && representation.decipherable !== false;
            }
          );
          switchingMode = "lazy";
        } else {
          const { representationIds } = repSettings;
          switchingMode = repSettings.switchingMode;
          const representations = trackInfo.adaptation.representations.filter(
            (r) => arrayIncludes(representationIds, r.id)
          );
          playableRepresentations = representations.filter(
            (r) => r.isSupported === true && r.decipherable !== false
          );
          if (playableRepresentations.length === 0) {
            self2.trigger("noPlayableLockedRepresentation", null);
            return;
          }
        }
        if (playableRepresentations.length <= 0) {
          self2.trigger("noPlayableRepresentation", null);
          return;
        }
        const oldRef = reference.getValue();
        const sortedReps = playableRepresentations.map((r) => r.id).slice().sort();
        if (sortedReps.length !== oldRef.representationIds.length) {
          reference.setValue({ representationIds: sortedReps, switchingMode });
          return;
        }
        for (let i = 0; i < sortedReps.length; i++) {
          if (oldRef.representationIds[i] !== sortedReps[i]) {
            reference.setValue({ representationIds: sortedReps, switchingMode });
            return;
          }
        }
      }
      function removeListeners() {
        self2.refresh = noop_default;
      }
    }
    /**
     * Free the resources (e.g. `Manifest` event listeners) linked to this
     * `TrackDispatcher`.
     */
    dispose() {
      this.removeEventListener();
      this._canceller.cancel();
      this._adaptationRef.finish();
    }
  };

  // src/main_thread/tracks_store/tracks_store.ts
  var TracksStore = class extends EventEmitter {
    constructor(args) {
      var _a;
      super();
      this._storedPeriodInfo = [];
      this._isDisposed = false;
      this._cachedPeriodInfo = /* @__PURE__ */ new WeakMap();
      this._isTrickModeTrackEnabled = args.preferTrickModeTracks;
      this._defaultAudioTrackSwitchingMode = (_a = args.defaultAudioTrackSwitchingMode) != null ? _a : config_default.getCurrent().DEFAULT_AUDIO_TRACK_SWITCHING_MODE;
    }
    /**
     * Return Array of Period information, to allow an outside application to
     * modify the track of any Period.
     * @returns {Array.<Object>}
     */
    getAvailablePeriods() {
      return this._storedPeriodInfo.reduce((acc, p) => {
        if (p.isPeriodAdvertised) {
          acc.push(toExposedPeriod(p.period));
        }
        return acc;
      }, []);
    }
    /**
     * Callack that needs to be called as codec support is either first known or
     * updated on the Manifest.
     */
    onManifestCodecSupportUpdate() {
      this._selectInitialTrackIfNeeded();
    }
    /**
     * Update the list of Periods handled by the TracksStore and make a
     * track choice decision for each of them.
     * @param {Object} manifest - The new Manifest object
     */
    onManifestUpdate(manifest) {
      var _a, _b, _c, _d, _e, _f;
      const { DEFAULT_VIDEO_TRACK_SWITCHING_MODE } = config_default.getCurrent();
      const { periods } = manifest;
      if (define_ENVIRONMENT_default.CURRENT_ENV === define_ENVIRONMENT_default.DEV) {
        for (let i = 1; i < periods.length; i++) {
          assert(periods[i - 1].start <= periods[i].start);
        }
      }
      const addedPeriods = [];
      let newPListIdx = 0;
      for (let i = 0; i < this._storedPeriodInfo.length; i++) {
        const oldPeriod = this._storedPeriodInfo[i].period;
        const newPeriod = periods[newPListIdx];
        if (newPeriod === void 0) {
          for (let j = this._storedPeriodInfo.length - 1; j >= i; j--) {
            this._storedPeriodInfo[j].inManifest = false;
            if (isPeriodItemRemovable(this._storedPeriodInfo[j])) {
              this._removePeriodObject(j);
            }
          }
        } else if (oldPeriod === newPeriod) {
          newPListIdx++;
          const curWantedTextTrack = this._storedPeriodInfo[i].text.storedSettings;
          if (!isNullOrUndefined(curWantedTextTrack)) {
            const textAdaptations = getSupportedAdaptations(newPeriod, "text");
            const stillHere = textAdaptations.some(
              (a) => a.id === curWantedTextTrack.adaptation.id
            );
            if (!stillHere) {
              log_default.warn("TS: Chosen text Adaptation not available anymore");
              const periodInfo = this._storedPeriodInfo[i];
              periodInfo.text.storedSettings = null;
              this.trigger("trackUpdate", {
                period: toExposedPeriod(newPeriod),
                trackType: "text",
                reason: "missing"
              });
              if (this._isDisposed) {
                return;
              }
              const periodItem = getPeriodItem(
                this._storedPeriodInfo,
                periodInfo.period.id
              );
              if (periodItem !== void 0 && periodItem.isPeriodAdvertised && periodItem.text.storedSettings === null) {
                (_a = periodItem.text.dispatcher) == null ? void 0 : _a.updateTrack(null);
              }
            }
          }
          const curWantedVideoTrack = this._storedPeriodInfo[i].video.storedSettings;
          if (!isNullOrUndefined(curWantedVideoTrack)) {
            const videoAdaptations = getSupportedAdaptations(newPeriod, "video");
            const stillHere = videoAdaptations.some(
              (a) => a.id === curWantedVideoTrack.adaptation.id
            );
            if (!stillHere) {
              log_default.warn("TS: Chosen video Adaptation not available anymore");
              const periodItem = this._storedPeriodInfo[i];
              let storedSettings;
              if (videoAdaptations.length === 0) {
                storedSettings = null;
              } else {
                const adaptationBase = videoAdaptations[0];
                const adaptation = getRightVideoTrack(
                  adaptationBase,
                  this._isTrickModeTrackEnabled
                );
                const lockedRepresentations = new reference_default(null);
                storedSettings = {
                  adaptationBase,
                  adaptation,
                  switchingMode: DEFAULT_VIDEO_TRACK_SWITCHING_MODE,
                  lockedRepresentations
                };
              }
              periodItem.video.storedSettings = storedSettings;
              this.trigger("trackUpdate", {
                period: toExposedPeriod(newPeriod),
                trackType: "video",
                reason: "missing"
              });
              if (this._isDisposed) {
                return;
              }
              const newPeriodItem = getPeriodItem(
                this._storedPeriodInfo,
                periodItem.period.id
              );
              if (newPeriodItem !== void 0 && newPeriodItem.isPeriodAdvertised && newPeriodItem.video.storedSettings === storedSettings) {
                (_b = newPeriodItem.video.dispatcher) == null ? void 0 : _b.updateTrack(storedSettings);
              }
            }
          }
          const curWantedAudioTrack = this._storedPeriodInfo[i].audio.storedSettings;
          if (!isNullOrUndefined(curWantedAudioTrack)) {
            const audioAdaptations = getSupportedAdaptations(newPeriod, "audio");
            const stillHere = audioAdaptations.some(
              (a) => a.id === curWantedAudioTrack.adaptation.id
            );
            if (!stillHere) {
              log_default.warn("TS: Chosen audio Adaptation not available anymore");
              const periodItem = this._storedPeriodInfo[i];
              const storedSettings = audioAdaptations.length === 0 ? null : {
                adaptation: audioAdaptations[0],
                switchingMode: this._defaultAudioTrackSwitchingMode,
                lockedRepresentations: new reference_default(null)
              };
              periodItem.audio.storedSettings = storedSettings;
              this.trigger("trackUpdate", {
                period: toExposedPeriod(newPeriod),
                trackType: "audio",
                reason: "missing"
              });
              if (this._isDisposed) {
                return;
              }
              const newPeriodItem = getPeriodItem(
                this._storedPeriodInfo,
                periodItem.period.id
              );
              if (newPeriodItem !== void 0 && newPeriodItem.isPeriodAdvertised && newPeriodItem.audio.storedSettings === storedSettings) {
                (_c = newPeriodItem.audio.dispatcher) == null ? void 0 : _c.updateTrack(storedSettings);
              }
            }
          }
        } else if (oldPeriod.start <= newPeriod.start) {
          this._storedPeriodInfo[i].inManifest = false;
          if (isPeriodItemRemovable(this._storedPeriodInfo[i])) {
            this._removePeriodObject(i);
            i--;
          }
        } else {
          const newPeriodInfo = generatePeriodInfo(newPeriod, true);
          this._storedPeriodInfo.splice(i, 0, newPeriodInfo);
          addedPeriods.push(newPeriodInfo);
          newPListIdx++;
        }
      }
      if (newPListIdx < periods.length) {
        const periodsToAdd = periods.slice(newPListIdx).map((p) => generatePeriodInfo(p, true));
        this._storedPeriodInfo.push(...periodsToAdd);
        addedPeriods.push(...periodsToAdd);
      }
      for (const storedPeriodInfo of this._storedPeriodInfo) {
        (_d = storedPeriodInfo.audio.dispatcher) == null ? void 0 : _d.refresh();
        (_e = storedPeriodInfo.video.dispatcher) == null ? void 0 : _e.refresh();
        (_f = storedPeriodInfo.text.dispatcher) == null ? void 0 : _f.refresh();
      }
    }
    onDecipherabilityUpdates() {
      var _a, _b, _c;
      for (const storedPeriodInfo of this._storedPeriodInfo) {
        (_a = storedPeriodInfo.audio.dispatcher) == null ? void 0 : _a.refresh();
        (_b = storedPeriodInfo.video.dispatcher) == null ? void 0 : _b.refresh();
        (_c = storedPeriodInfo.text.dispatcher) == null ? void 0 : _c.refresh();
      }
    }
    /**
     * Add shared reference to choose Adaptation for new "audio", "video" or
     * "text" Period.
     *
     * Note that such reference has to be removed through `removeTrackReference`
     * so ressources can be freed.
     * @param {string} bufferType - The concerned buffer type
     * @param {Period} period - The concerned Period.
     * @param {Object} adaptationRef - A reference through which
     * the choice will be given.
     */
    addTrackReference(bufferType, period, adaptationRef) {
      let periodObj = getPeriodItem(this._storedPeriodInfo, period.id);
      if (periodObj === void 0) {
        periodObj = generatePeriodInfo(period, false);
        let found = false;
        for (let i = 0; i < this._storedPeriodInfo.length; i++) {
          if (this._storedPeriodInfo[i].period.start > period.start) {
            this._storedPeriodInfo.splice(i, 0, periodObj);
            found = true;
          }
        }
        if (!found) {
          this._storedPeriodInfo.push(periodObj);
        }
      }
      if (periodObj[bufferType].dispatcher !== null) {
        log_default.error(
          `TS: Subject already added for ${bufferType} and Period ${period.start}`
        );
        return;
      }
      const dispatcher = new TrackDispatcher(adaptationRef);
      periodObj[bufferType].dispatcher = dispatcher;
      dispatcher.addEventListener("noPlayableRepresentation", () => {
        var _a, _b, _c, _d;
        const nextAdaptation = arrayFind(
          (_a = period.adaptations[bufferType]) != null ? _a : [],
          (adaptation) => {
            if (adaptation.supportStatus.hasSupportedCodec === false || adaptation.supportStatus.isDecipherable === false) {
              return false;
            }
            const playableRepresentations = adaptation.representations.filter(
              (r) => r.isSupported === true && r.decipherable !== false
            );
            return playableRepresentations.length > 0;
          }
        );
        if (nextAdaptation === void 0) {
          const noRepErr = new MediaError(
            "NO_PLAYABLE_REPRESENTATION",
            `No ${bufferType} Representation can be played`,
            { tracks: void 0 }
          );
          this.trigger("error", noRepErr);
          this.dispose();
          return;
        }
        let typeInfo = (_b = getPeriodItem(this._storedPeriodInfo, period.id)) == null ? void 0 : _b[bufferType];
        if (isNullOrUndefined(typeInfo)) {
          return;
        }
        const switchingMode = bufferType === "audio" ? this._defaultAudioTrackSwitchingMode : "reload";
        const storedSettings = {
          adaptation: nextAdaptation,
          switchingMode,
          lockedRepresentations: new reference_default(null)
        };
        typeInfo.storedSettings = storedSettings;
        this.trigger("trackUpdate", {
          period: toExposedPeriod(period),
          trackType: bufferType,
          reason: "no-playable-representation"
        });
        if (this._isDisposed) {
          return;
        }
        typeInfo = (_c = getPeriodItem(this._storedPeriodInfo, period.id)) == null ? void 0 : _c[bufferType];
        if (isNullOrUndefined(typeInfo) || typeInfo.storedSettings !== storedSettings) {
          return;
        }
        (_d = typeInfo.dispatcher) == null ? void 0 : _d.updateTrack(storedSettings);
      });
      dispatcher.addEventListener("noPlayableLockedRepresentation", () => {
        if (periodObj === void 0) {
          return;
        }
        this.unlockVideoRepresentations(periodObj);
        this.trigger("brokenRepresentationsLock", {
          period: { id: period.id, start: period.start, end: period.end },
          trackType: bufferType
        });
      });
      this._selectInitialTrackIfNeeded();
      if (this._shouldAdvertisePeriod(periodObj)) {
        periodObj.isPeriodAdvertised = true;
        this.trigger("newAvailablePeriods", [
          {
            id: period.id,
            start: period.start,
            end: period.end
          }
        ]);
        if (this._isDisposed) {
          return;
        }
      }
      const trackTypes = ["audio", "video", "text"];
      for (const ttype of trackTypes) {
        const trackObj = periodObj[ttype];
        if (periodObj.isPeriodAdvertised && trackObj.dispatcher !== null && !trackObj.dispatcher.hasSetTrack() && trackObj.storedSettings !== void 0) {
          trackObj.dispatcher.updateTrack(trackObj.storedSettings);
        }
        if (this._isDisposed) {
          return;
        }
      }
    }
    /**
     * Remove shared reference to choose an "audio", "video" or "text" Adaptation
     * for a Period.
     * @param {string} bufferType - The concerned buffer type
     * @param {Period} period - The concerned Period.
     */
    removeTrackReference(bufferType, period) {
      const periodIndex = findPeriodIndex(this._storedPeriodInfo, period);
      if (periodIndex === void 0) {
        log_default.warn(`TS: ${bufferType} not found for period`, period.start);
        return;
      }
      const periodObj = this._storedPeriodInfo[periodIndex];
      const choiceItem = periodObj[bufferType];
      if ((choiceItem == null ? void 0 : choiceItem.dispatcher) === null) {
        log_default.warn(
          `TS: TrackDispatcher already removed for ${bufferType} and Period ${period.start}`
        );
        return;
      }
      choiceItem.dispatcher.dispose();
      choiceItem.dispatcher = null;
      if (isPeriodItemRemovable(periodObj)) {
        this._removePeriodObject(periodIndex);
      }
    }
    /**
     * Allows to recuperate a "Period Object" - used in get/set methods of the
     * `TracksStore` - by giving the Period itself.
     *
     * This method should be preferred when possible over `getPeriodObjectFromId`
     * because it is able to fallback on an internal cache in case the
     * corresponding Period is not stored anymore.
     * This for example could happen when a Period has been removed from the
     * Manifest yet may still be needed (e.g. because its linked segments might
     * still live in the buffers).
     *
     * Note however that this cache-retrieval logic is based on a Map whose key
     * is the Period's JavaScript reference. As such, the cache won't be used if
     * `Period` corresponds to a copy of the original `Period` object.
     *
     * @param {Object} period
     * @returns {Object}
     */
    getPeriodObjectFromPeriod(period) {
      const periodObj = getPeriodItem(this._storedPeriodInfo, period.id);
      if (periodObj === void 0 && period !== void 0) {
        return this._cachedPeriodInfo.get(period);
      }
      return periodObj;
    }
    /**
     * Allows to recuperate a "Period Object" - used in get/set methods of the
     * `TracksStore` - by giving the Period's id.
     *
     * Note that unlike `getPeriodObjectFromPeriod` this method is only going to look
     * into currently stored Period and as such old Periods not in the Manifest
     * anymore might not be retrievable.
     * If you want to retrieve Period objects linked to such Period, you might
     * prefer to use `getPeriodObjectFromPeriod` (which necessitates the original
     * Period object).
     *
     * @param {string} periodId - The concerned Period's id
     * @returns {Object}
     */
    getPeriodObjectFromId(periodId) {
      return getPeriodItem(this._storedPeriodInfo, periodId);
    }
    disableVideoTrickModeTracks() {
      if (!this._isTrickModeTrackEnabled) {
        return;
      }
      this._isTrickModeTrackEnabled = false;
      this._resetVideoTrackChoices("trickmode-disabled");
    }
    enableVideoTrickModeTracks() {
      if (this._isTrickModeTrackEnabled) {
        return;
      }
      this._isTrickModeTrackEnabled = true;
      this._resetVideoTrackChoices("trickmode-enabled");
    }
    /**
     * Reset the TracksStore's Period objects:
     *   - All Period which are not in the manifest currently will be removed.
     *   - All References used to communicate the wanted track will be removed.
     *
     * You might want to call this API when restarting playback.
     */
    resetPeriodObjects() {
      var _a, _b, _c;
      for (let i = this._storedPeriodInfo.length - 1; i >= 0; i--) {
        const storedObj = this._storedPeriodInfo[i];
        (_a = storedObj.audio.dispatcher) == null ? void 0 : _a.dispose();
        storedObj.audio.dispatcher = null;
        (_b = storedObj.video.dispatcher) == null ? void 0 : _b.dispose();
        storedObj.video.dispatcher = null;
        (_c = storedObj.text.dispatcher) == null ? void 0 : _c.dispose();
        storedObj.text.dispatcher = null;
        if (!storedObj.inManifest) {
          this._removePeriodObject(i);
        }
      }
    }
    /**
     * @returns {boolean}
     */
    isTrickModeEnabled() {
      return this._isTrickModeTrackEnabled;
    }
    /**
     * Set audio track based on the ID of its Adaptation for a given added Period.
     * @param {Object} params
     * @param {Object} params.periodRef - The concerned Period's object.
     * @param {string} params.trackId - adaptation id of the wanted track.
     * @param {string} params.switchingMode - Behavior when replacing the track by
     * another.
     * @param {Object|null} params.lockedRepresentations - Audio Representations
     * that should be locked after switching to that track.
     * `null` if no Audio Representation should be locked.
     * @param {number} params.relativeResumingPosition
     */
    setAudioTrack(payload) {
      const {
        periodRef,
        trackId,
        switchingMode,
        lockedRepresentations,
        relativeResumingPosition
      } = payload;
      return this._setAudioOrTextTrack({
        bufferType: "audio",
        periodRef,
        trackId,
        switchingMode: switchingMode != null ? switchingMode : this._defaultAudioTrackSwitchingMode,
        lockedRepresentations,
        relativeResumingPosition
      });
    }
    /**
     * Set text track based on the ID of its Adaptation for a given added Period.
     * @param {Object} periodObj - The concerned Period's object.
     * @param {string} wantedId - adaptation id of the wanted track.
     */
    setTextTrack(periodObj, wantedId) {
      return this._setAudioOrTextTrack({
        bufferType: "text",
        periodRef: periodObj,
        trackId: wantedId,
        switchingMode: "direct",
        lockedRepresentations: null,
        relativeResumingPosition: void 0
      });
    }
    /**
     * Set audio track based on the ID of its Adaptation for a given added Period.
     * @param {Object} params
     * @param {string} params.bufferType
     * @param {Object} params.periodRef - The concerned Period's object.
     * @param {string} params.trackId - adaptation id of the wanted track.
     * @param {string} params.switchingMode - Behavior when replacing the track by
     * another.
     * @param {Array.<string>|null} params.lockedRepresentations - Audio
     * Representations that should be locked after switchingMode to that track.
     * `null` if no Audio Representation should be locked.
     * @param {number|undefined} params.relativeResumingPosition
     */
    _setAudioOrTextTrack({
      bufferType,
      periodRef,
      trackId,
      switchingMode,
      lockedRepresentations,
      relativeResumingPosition
    }) {
      var _a, _b;
      if (!periodRef.isPeriodAdvertised) {
        throw new Error("Wanted Period not yet advertised.");
      }
      const period = periodRef.period;
      const wantedAdaptation = arrayFind(
        (_a = period.adaptations[bufferType]) != null ? _a : [],
        ({ id, supportStatus }) => supportStatus.hasSupportedCodec !== false && supportStatus.isDecipherable !== false && id === trackId
      );
      if (wantedAdaptation === void 0) {
        throw new Error(`Wanted ${bufferType} track not found.`);
      }
      const typeInfo = periodRef[bufferType];
      let lockedRepresentationsRef;
      if (lockedRepresentations === null) {
        lockedRepresentationsRef = new reference_default(null);
      } else {
        const representationsToLock = this._getRepresentationsToLock(
          wantedAdaptation,
          lockedRepresentations
        );
        const repSwitchingMode = bufferType === "audio" ? this._defaultAudioTrackSwitchingMode : "direct";
        lockedRepresentationsRef = new reference_default({
          representationIds: representationsToLock,
          switchingMode: repSwitchingMode
        });
      }
      const storedSettings = {
        adaptation: wantedAdaptation,
        switchingMode,
        lockedRepresentations: lockedRepresentationsRef,
        relativeResumingPosition
      };
      typeInfo.storedSettings = storedSettings;
      this.trigger("trackUpdate", {
        period: toExposedPeriod(period),
        trackType: bufferType,
        reason: "manual"
      });
      if (this._isDisposed) {
        return;
      }
      const newPeriodItem = getPeriodItem(this._storedPeriodInfo, period.id);
      if (newPeriodItem !== void 0 && newPeriodItem[bufferType].storedSettings === storedSettings) {
        (_b = newPeriodItem[bufferType].dispatcher) == null ? void 0 : _b.updateTrack(storedSettings);
      }
    }
    /**
     * Set video track based on the ID of its Adaptation for a given added Period.
     * @param {Object} params
     * @param {Object} params.periodRef - The concerned Period's object.
     * @param {string} params.trackId - adaptation id of the wanted track.
     * @param {string} params.switchingMode - Behavior when replacing the track by
     * another.
     * @param {Array.<string>|null} params.lockedRepresentations - Video
     * Representations that should be locked after switching to that track.
     * `null` if no Video Representation should be locked.
     * @param {number|undefined} params.relativeResumingPosition
     */
    setVideoTrack(payload) {
      var _a, _b;
      const {
        periodRef,
        trackId,
        switchingMode,
        lockedRepresentations,
        relativeResumingPosition
      } = payload;
      if (!periodRef.isPeriodAdvertised) {
        throw new Error("Wanted Period not yet advertised.");
      }
      const period = periodRef.period;
      const wantedAdaptation = arrayFind(
        (_a = period.adaptations.video) != null ? _a : [],
        ({ id, supportStatus }) => supportStatus.isDecipherable !== false && supportStatus.hasSupportedCodec !== false && id === trackId
      );
      if (wantedAdaptation === void 0) {
        throw new Error("Wanted video track not found.");
      }
      const { DEFAULT_VIDEO_TRACK_SWITCHING_MODE } = config_default.getCurrent();
      const typeInfo = periodRef.video;
      const newAdaptation = getRightVideoTrack(
        wantedAdaptation,
        this._isTrickModeTrackEnabled
      );
      let lockedRepresentationsRef;
      if (lockedRepresentations === null) {
        lockedRepresentationsRef = new reference_default(null);
      } else {
        const representationsToLock = this._getRepresentationsToLock(
          wantedAdaptation,
          lockedRepresentations
        );
        const repSwitchingMode = DEFAULT_VIDEO_TRACK_SWITCHING_MODE;
        lockedRepresentationsRef = new reference_default({
          representationIds: representationsToLock,
          switchingMode: repSwitchingMode
        });
      }
      const storedSettings = {
        adaptationBase: wantedAdaptation,
        switchingMode: switchingMode != null ? switchingMode : DEFAULT_VIDEO_TRACK_SWITCHING_MODE,
        adaptation: newAdaptation,
        relativeResumingPosition,
        lockedRepresentations: lockedRepresentationsRef
      };
      typeInfo.storedSettings = storedSettings;
      this.trigger("trackUpdate", {
        period: toExposedPeriod(period),
        trackType: "video",
        reason: "manual"
      });
      if (this._isDisposed) {
        return;
      }
      const newPeriodItem = getPeriodItem(this._storedPeriodInfo, period.id);
      if (newPeriodItem !== void 0 && newPeriodItem.video.storedSettings === storedSettings) {
        (_b = newPeriodItem.video.dispatcher) == null ? void 0 : _b.updateTrack(storedSettings);
      }
    }
    /**
     * Disable the current text track for a given period.
     *
     * @param {Object} periodObj - The concerned Period's object
     * @param {string} bufferType - The type of track to disable.
     * @throws Error - Throws if the period given has not been added
     */
    disableTrack(periodObj, bufferType) {
      var _a, _b;
      if (!periodObj.isPeriodAdvertised) {
        throw new Error("Wanted Period not yet advertised.");
      }
      const trackInfo = periodObj[bufferType];
      if (trackInfo.storedSettings === null) {
        return;
      }
      if (bufferType !== "text") {
        (_a = periodObj[bufferType].storedSettings) == null ? void 0 : _a.lockedRepresentations.finish();
      }
      trackInfo.storedSettings = null;
      this.trigger("trackUpdate", {
        period: toExposedPeriod(periodObj.period),
        trackType: bufferType,
        reason: "manual"
      });
      if (this._isDisposed) {
        return;
      }
      const newPeriodItem = getPeriodItem(this._storedPeriodInfo, periodObj.period.id);
      if (newPeriodItem !== void 0 && newPeriodItem[bufferType].storedSettings === null) {
        (_b = newPeriodItem[bufferType].dispatcher) == null ? void 0 : _b.updateTrack(null);
      }
    }
    /**
     * Returns an object describing the chosen audio track for the given audio
     * Period.
     *
     * Returns `null` is the the current audio track is disabled or not
     * set yet.a pas bcp de marge de manoeuvre j'ai l'impression
     *
     * Returns `undefined` if the given Period's id is not currently found in the
     * `TracksStore`. The cause being most probably that the corresponding
     * Period is not available anymore.
     * If you're in that case and if still have the corresponding JavaScript
     * reference to the wanted Period, you can call `getOldAudioTrack` with it. It
     * will try retrieving the choice it made from its cache.
     * @param {Object} periodObj - The concerned Period's object
     * @returns {Object|null|undefined} - The audio track chosen for this Period.
     * `null` if audio tracks were disabled and `undefined` if the Period is not
     * known.
     */
    getChosenAudioTrack(periodObj, filterPlayableRepresentations) {
      return isNullOrUndefined(periodObj.audio.storedSettings) ? null : toAudioTrack(
        periodObj.audio.storedSettings.adaptation,
        filterPlayableRepresentations
      );
    }
    /**
     * Returns an object describing the chosen text track for the given text
     * Period.
     *
     * Returns null is the the current text track is disabled or not
     * set yet.
     *
     * @param {Object} periodObj - The concerned Period's object
     * @returns {Object|null} - The text track chosen for this Period
     */
    getChosenTextTrack(periodObj) {
      return isNullOrUndefined(periodObj.text.storedSettings) ? null : toTextTrack(periodObj.text.storedSettings.adaptation);
    }
    /**
     * Returns an object describing the chosen video track for the given video
     * Period.
     *
     * Returns null is the the current video track is disabled or not
     * set yet.
     *
     * @param {Object} periodObj - The concerned Period's object
     * @returns {Object|null} - The video track chosen for this Period
     */
    getChosenVideoTrack(periodObj, filterPlayableRepresentations) {
      if (isNullOrUndefined(periodObj.video.storedSettings)) {
        return null;
      }
      return toVideoTrack(
        periodObj.video.storedSettings.adaptation,
        filterPlayableRepresentations
      );
    }
    /**
     * Returns all available audio tracks for a given Period, as an array of
     * objects.
     *
     * Returns `undefined` if the given Period's id is not known.
     *
     * @param {Object} periodObj - The concerned Period's object
     * @param {boolean} filterPlayableRepresentations - If `true`, only
     * representations considered to be "playable" will be included in the
     * returned response.
     * If `false`, the response should contain all linked representations.
     * @returns {Array.<Object>}
     */
    getAvailableAudioTracks(periodObj, filterPlayableRepresentations) {
      const storedSettings = periodObj.audio.storedSettings;
      const currentId = !isNullOrUndefined(storedSettings) ? storedSettings.adaptation.id : null;
      const adaptations = getSupportedAdaptations(periodObj.period, "audio");
      return adaptations.map((adaptation) => {
        const active = currentId === null ? false : currentId === adaptation.id;
        return object_assign_default(toAudioTrack(adaptation, filterPlayableRepresentations), {
          active
        });
      });
    }
    /**
     * Returns all available text tracks for a given Period, as an array of
     * objects.
     *
     * Returns `undefined` if the given Period's id is not known.
     *
     * @param {Object} periodObj - The concerned Period's object
     * @returns {Array.<Object>}
     */
    getAvailableTextTracks(periodObj) {
      const storedSettings = periodObj.text.storedSettings;
      const currentId = !isNullOrUndefined(storedSettings) ? storedSettings.adaptation.id : null;
      const adaptations = getSupportedAdaptations(periodObj.period, "text");
      return adaptations.map((adaptation) => {
        const active = currentId === null ? false : currentId === adaptation.id;
        return object_assign_default(toTextTrack(adaptation), { active });
      });
    }
    /**
     * Returns all available video tracks for a given Period, as an array of
     * objects.
     *
     * Returns `undefined` if the given Period's id is not known.
     *
     * @param {Object} periodObj - The concerned Period's object
     * @param {boolean} filterPlayableRepresentations - If `true`, only
     * representations considered to be "playable" will be included in the
     * returned response.
     * If `false`, the response should contain all linked representations.
     * @returns {Array.<Object>}
     */
    getAvailableVideoTracks(periodObj, filterPlayableRepresentations) {
      const storedSettings = periodObj.video.storedSettings;
      const currentId = isNullOrUndefined(storedSettings) ? void 0 : storedSettings.adaptation.id;
      const adaptations = getSupportedAdaptations(periodObj.period, "video");
      return adaptations.map((adaptation) => {
        const active = currentId === null ? false : currentId === adaptation.id;
        const track = toVideoTrack(adaptation, filterPlayableRepresentations);
        const trickModeTracks = track.trickModeTracks !== void 0 ? track.trickModeTracks.map((trickModeAdaptation) => {
          const isActive = currentId === null ? false : currentId === trickModeAdaptation.id;
          return object_assign_default(trickModeAdaptation, { active: isActive });
        }) : [];
        const availableTrack = object_assign_default(track, { active });
        if (trickModeTracks !== void 0) {
          availableTrack.trickModeTracks = trickModeTracks;
        }
        return availableTrack;
      });
    }
    getLockedAudioRepresentations(periodObj) {
      const { storedSettings } = periodObj.audio;
      if (isNullOrUndefined(storedSettings)) {
        return null;
      }
      const lastLockedSettings = storedSettings.lockedRepresentations.getValue();
      return lastLockedSettings === null ? null : lastLockedSettings.representationIds;
    }
    getLockedVideoRepresentations(periodObj) {
      const { storedSettings } = periodObj.video;
      if (isNullOrUndefined(storedSettings)) {
        return null;
      }
      const lastLockedSettings = storedSettings.lockedRepresentations.getValue();
      return lastLockedSettings === null ? null : lastLockedSettings.representationIds;
    }
    lockAudioRepresentations(periodObj, lockSettings) {
      var _a;
      const { storedSettings } = periodObj.audio;
      if (isNullOrUndefined(storedSettings)) {
        return;
      }
      const { DEFAULT_AUDIO_REPRESENTATIONS_SWITCHING_MODE } = config_default.getCurrent();
      const filtered = this._getRepresentationsToLock(
        storedSettings.adaptation,
        lockSettings.representations
      );
      const switchingMode = (_a = lockSettings.switchingMode) != null ? _a : DEFAULT_AUDIO_REPRESENTATIONS_SWITCHING_MODE;
      storedSettings.lockedRepresentations.setValue({
        representationIds: filtered,
        switchingMode
      });
    }
    lockVideoRepresentations(periodObj, lockSettings) {
      var _a;
      const { storedSettings } = periodObj.video;
      if (isNullOrUndefined(storedSettings)) {
        return;
      }
      const { DEFAULT_VIDEO_REPRESENTATIONS_SWITCHING_MODE } = config_default.getCurrent();
      const filtered = this._getRepresentationsToLock(
        storedSettings.adaptation,
        lockSettings.representations
      );
      const switchingMode = (_a = lockSettings.switchingMode) != null ? _a : DEFAULT_VIDEO_REPRESENTATIONS_SWITCHING_MODE;
      storedSettings.lockedRepresentations.setValue({
        representationIds: filtered,
        switchingMode
      });
    }
    unlockAudioRepresentations(periodObj) {
      const { storedSettings } = periodObj.audio;
      if (isNullOrUndefined(storedSettings) || storedSettings.lockedRepresentations.getValue() === null) {
        return;
      }
      storedSettings.lockedRepresentations.setValue(null);
    }
    unlockVideoRepresentations(periodObj) {
      const { storedSettings } = periodObj.video;
      if (isNullOrUndefined(storedSettings) || storedSettings.lockedRepresentations.getValue() === null) {
        return;
      }
      storedSettings.lockedRepresentations.setValue(null);
    }
    dispose() {
      this._isDisposed = true;
      while (true) {
        const lastPeriod = this._storedPeriodInfo.pop();
        if (lastPeriod === void 0) {
          return;
        }
        lastPeriod.isRemoved = true;
      }
    }
    _resetVideoTrackChoices(reason) {
      var _a;
      for (let i = 0; i < this._storedPeriodInfo.length; i++) {
        const periodObj = this._storedPeriodInfo[i];
        if (!isNullOrUndefined(periodObj.video.storedSettings)) {
          const chosenBaseTrack = periodObj.video.storedSettings.adaptationBase;
          if (chosenBaseTrack !== null) {
            const chosenTrack = getRightVideoTrack(
              chosenBaseTrack,
              this._isTrickModeTrackEnabled
            );
            periodObj.video.storedSettings.adaptationBase = chosenBaseTrack;
            periodObj.video.storedSettings.adaptation = chosenTrack;
          }
        }
      }
      const sliced = this._storedPeriodInfo.slice();
      for (let i = 0; i < sliced.length; i++) {
        const period = sliced[i].period;
        const videoItem = sliced[i].video;
        const storedSettings = videoItem.storedSettings;
        if (storedSettings !== void 0) {
          this.trigger("trackUpdate", {
            period: toExposedPeriod(period),
            trackType: "video",
            reason
          });
          if (this._isDisposed) {
            return;
          }
          const newPeriodItem = getPeriodItem(this._storedPeriodInfo, period.id);
          if (newPeriodItem !== void 0 && newPeriodItem.isPeriodAdvertised && newPeriodItem.video.storedSettings === storedSettings) {
            (_a = newPeriodItem.video.dispatcher) == null ? void 0 : _a.updateTrack(storedSettings);
          }
        }
      }
    }
    _removePeriodObject(index) {
      if (define_ENVIRONMENT_default.CURRENT_ENV === define_ENVIRONMENT_default.DEV) {
        assert(index < this._storedPeriodInfo.length, "Invalid index for Period removal");
      }
      const oldPeriodItem = this._storedPeriodInfo[index];
      this._storedPeriodInfo[index].isRemoved = true;
      this._storedPeriodInfo.splice(index, 1);
      this._cachedPeriodInfo.set(oldPeriodItem.period, oldPeriodItem);
    }
    _getRepresentationsToLock(adaptation, representationIds) {
      const filtered = representationIds.reduce((acc, repId) => {
        const foundRep = arrayFind(adaptation.representations, (r) => {
          return r.id === repId;
        });
        if (foundRep === void 0) {
          log_default.warn("API: Wanted locked Representation not found.");
        } else {
          acc.push(foundRep.id);
        }
        return acc;
      }, []);
      if (filtered.length === 0) {
        throw new Error(
          "Cannot lock Representations: None of the given Representation id are found"
        );
      }
      return filtered;
    }
    /**
     * Check or re-check all Periods for which both an initial track can be chosen
     * and for which the `newAvailablePeriods` event can be triggered.
     */
    _selectInitialTrackIfNeeded() {
      var _a, _b, _c, _d;
      const { DEFAULT_VIDEO_TRACK_SWITCHING_MODE } = config_default.getCurrent();
      const periodsToAdvertise = [];
      const toDispatchTrack = [];
      for (const trackStorePeriod of this._storedPeriodInfo) {
        const { period } = trackStorePeriod;
        if (trackStorePeriod.audio.storedSettings !== void 0 && trackStorePeriod.video.storedSettings !== void 0 && trackStorePeriod.text.storedSettings !== void 0) {
          continue;
        }
        const adaptations = [
          ...(_a = period.adaptations.audio) != null ? _a : [],
          ...(_b = period.adaptations.video) != null ? _b : []
        ];
        const hasCodecWithUndefinedSupport = adaptations.every(
          (a) => a.supportStatus.hasCodecWithUndefinedSupport
        );
        if (adaptations.length > 0 && hasCodecWithUndefinedSupport) {
          continue;
        }
        const audioAdaptation = getSupportedAdaptations(period, "audio")[0];
        trackStorePeriod.audio.storedSettings = audioAdaptation === void 0 ? null : {
          adaptation: audioAdaptation,
          switchingMode: this._defaultAudioTrackSwitchingMode,
          lockedRepresentations: new reference_default(
            null
          )
        };
        const baseVideoAdaptation = getSupportedAdaptations(period, "video")[0];
        const videoAdaptation = getRightVideoTrack(
          baseVideoAdaptation,
          this._isTrickModeTrackEnabled
        );
        trackStorePeriod.video.storedSettings = videoAdaptation === void 0 ? null : {
          adaptation: videoAdaptation,
          adaptationBase: baseVideoAdaptation,
          switchingMode: DEFAULT_VIDEO_TRACK_SWITCHING_MODE,
          lockedRepresentations: new reference_default(
            null
          )
        };
        let textAdaptation = null;
        const forcedSubtitles = ((_c = period.adaptations.text) != null ? _c : []).filter(
          (ad) => ad.isForcedSubtitles === true
        );
        if (forcedSubtitles.length > 0) {
          if (audioAdaptation !== null && audioAdaptation !== void 0) {
            const sameLanguage = arrayFind(
              forcedSubtitles,
              (f) => f.normalizedLanguage === audioAdaptation.normalizedLanguage
            );
            if (sameLanguage !== void 0) {
              textAdaptation = sameLanguage;
            }
          }
          if (textAdaptation === null) {
            textAdaptation = (_d = arrayFind(forcedSubtitles, (f) => f.normalizedLanguage === void 0)) != null ? _d : null;
          }
        }
        trackStorePeriod.text.storedSettings = textAdaptation === null ? null : {
          adaptation: textAdaptation,
          switchingMode: "direct",
          lockedRepresentations: new reference_default(
            null
          )
        };
        toDispatchTrack.push(trackStorePeriod);
        if (this._shouldAdvertisePeriod(trackStorePeriod)) {
          trackStorePeriod.isPeriodAdvertised = true;
          periodsToAdvertise.push({ id: period.id, start: period.start, end: period.end });
        }
      }
      if (periodsToAdvertise.length > 0) {
        this.trigger("newAvailablePeriods", periodsToAdvertise);
        if (this._isDisposed) {
          return;
        }
      }
      for (const trackStorePeriod of toDispatchTrack) {
        if (!trackStorePeriod.isPeriodAdvertised) {
          continue;
        }
        const bufferTypes = ["audio", "video", "text"];
        for (const bufferType of bufferTypes) {
          const trackInfo = trackStorePeriod[bufferType];
          if (trackInfo.dispatcher !== null && trackInfo.storedSettings !== void 0 && !trackInfo.dispatcher.hasSetTrack()) {
            trackInfo.dispatcher.updateTrack(trackInfo.storedSettings);
            if (this._isDisposed) {
              return;
            }
          }
        }
      }
    }
    /**
     * Returns `true` once a Period can be advertised through a `newAvailablePeriods`
     * event, after which track can begin to be set and updated.
     * @param {Object} periodObj
     * @returns {boolean}
     */
    _shouldAdvertisePeriod(periodObj) {
      return !periodObj.isPeriodAdvertised && periodObj.text.dispatcher !== null && periodObj.video.dispatcher !== null && periodObj.audio.dispatcher !== null;
    }
  };
  function findPeriodIndex(periods, period) {
    for (let i = 0; i < periods.length; i++) {
      const periodI = periods[i];
      if (periodI.period.id === period.id) {
        return i;
      }
    }
  }
  function getPeriodItem(periods, periodId) {
    for (let i = 0; i < periods.length; i++) {
      const periodI = periods[i];
      if (periodI.period.id === periodId) {
        return periodI;
      }
    }
  }
  function isPeriodItemRemovable(periodObj) {
    var _a, _b, _c;
    return !periodObj.inManifest && ((_a = periodObj.text) == null ? void 0 : _a.dispatcher) === null && ((_b = periodObj.audio) == null ? void 0 : _b.dispatcher) === null && ((_c = periodObj.video) == null ? void 0 : _c.dispatcher) === null;
  }
  function getRightVideoTrack(adaptation, isTrickModeEnabled) {
    var _a;
    if (isTrickModeEnabled && ((_a = adaptation.trickModeTracks) == null ? void 0 : _a[0]) !== void 0) {
      return adaptation.trickModeTracks[0];
    }
    return adaptation;
  }
  function generatePeriodInfo(period, inManifest) {
    return {
      period,
      inManifest,
      isPeriodAdvertised: false,
      isRemoved: false,
      audio: { storedSettings: void 0, dispatcher: null },
      video: { storedSettings: void 0, dispatcher: null },
      text: { storedSettings: void 0, dispatcher: null }
    };
  }
  function toExposedPeriod(p) {
    return { start: p.start, end: p.end, id: p.id };
  }

  // src/main_thread/tracks_store/index.ts
  var tracks_store_default = TracksStore;

  // src/main_thread/api/option_utils.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function parseConstructorOptions(options) {
    let maxBufferAhead;
    let maxBufferBehind;
    let wantedBufferAhead;
    let maxVideoBufferSize;
    let videoElement;
    let baseBandwidth;
    const {
      DEFAULT_BASE_BANDWIDTH,
      DEFAULT_VIDEO_RESOLUTION_LIMIT,
      DEFAULT_MAX_BUFFER_AHEAD: DEFAULT_MAX_BUFFER_AHEAD2,
      DEFAULT_MAX_BUFFER_BEHIND: DEFAULT_MAX_BUFFER_BEHIND2,
      DEFAULT_MAX_VIDEO_BUFFER_SIZE: DEFAULT_MAX_VIDEO_BUFFER_SIZE2,
      DEFAULT_THROTTLE_VIDEO_BITRATE_WHEN_HIDDEN,
      DEFAULT_WANTED_BUFFER_AHEAD: DEFAULT_WANTED_BUFFER_AHEAD2
    } = config_default.getCurrent();
    if (isNullOrUndefined(options.maxBufferAhead)) {
      maxBufferAhead = DEFAULT_MAX_BUFFER_AHEAD2;
    } else {
      maxBufferAhead = Number(options.maxBufferAhead);
      if (isNaN(maxBufferAhead)) {
        throw new Error("Invalid maxBufferAhead parameter. Should be a number.");
      }
    }
    if (isNullOrUndefined(options.maxBufferBehind)) {
      maxBufferBehind = DEFAULT_MAX_BUFFER_BEHIND2;
    } else {
      maxBufferBehind = Number(options.maxBufferBehind);
      if (isNaN(maxBufferBehind)) {
        throw new Error("Invalid maxBufferBehind parameter. Should be a number.");
      }
    }
    if (isNullOrUndefined(options.wantedBufferAhead)) {
      wantedBufferAhead = DEFAULT_WANTED_BUFFER_AHEAD2;
    } else {
      wantedBufferAhead = Number(options.wantedBufferAhead);
      if (isNaN(wantedBufferAhead)) {
        throw new Error("Invalid wantedBufferAhead parameter. Should be a number.");
      }
    }
    if (isNullOrUndefined(options.maxVideoBufferSize)) {
      maxVideoBufferSize = DEFAULT_MAX_VIDEO_BUFFER_SIZE2;
    } else {
      maxVideoBufferSize = Number(options.maxVideoBufferSize);
      if (isNaN(maxVideoBufferSize)) {
        throw new Error("Invalid maxVideoBufferSize parameter. Should be a number.");
      }
    }
    const videoResolutionLimit = isNullOrUndefined(options.videoResolutionLimit) ? DEFAULT_VIDEO_RESOLUTION_LIMIT : options.videoResolutionLimit;
    const throttleVideoBitrateWhenHidden = isNullOrUndefined(
      options.throttleVideoBitrateWhenHidden
    ) ? DEFAULT_THROTTLE_VIDEO_BITRATE_WHEN_HIDDEN : !!options.throttleVideoBitrateWhenHidden;
    if (isNullOrUndefined(options.videoElement)) {
      videoElement = document.createElement("video");
    } else if (options.videoElement.nodeName.toLowerCase() === "video" || options.videoElement.nodeName.toLowerCase() === "audio") {
      videoElement = options.videoElement;
    } else {
      throw new Error("Invalid videoElement parameter. Should be a HTMLMediaElement.");
    }
    if (isNullOrUndefined(options.baseBandwidth)) {
      baseBandwidth = DEFAULT_BASE_BANDWIDTH;
    } else {
      baseBandwidth = Number(options.baseBandwidth);
      if (isNaN(baseBandwidth)) {
        throw new Error("Invalid baseBandwidth parameter. Should be a number.");
      }
    }
    return {
      maxBufferAhead,
      maxBufferBehind,
      videoResolutionLimit,
      videoElement,
      wantedBufferAhead,
      maxVideoBufferSize,
      throttleVideoBitrateWhenHidden,
      baseBandwidth
    };
  }
  function checkReloadOptions(options) {
    var _a, _b, _c, _d;
    if (options === null || typeof options !== "object" && options !== void 0) {
      throw new Error("API: reload - Invalid options format.");
    }
    if ((options == null ? void 0 : options.reloadAt) === null || typeof (options == null ? void 0 : options.reloadAt) !== "object" && (options == null ? void 0 : options.reloadAt) !== void 0) {
      throw new Error("API: reload - Invalid 'reloadAt' option format.");
    }
    if (typeof ((_a = options == null ? void 0 : options.reloadAt) == null ? void 0 : _a.position) !== "number" && ((_b = options == null ? void 0 : options.reloadAt) == null ? void 0 : _b.position) !== void 0) {
      throw new Error("API: reload - Invalid 'reloadAt.position' option format.");
    }
    if (typeof ((_c = options == null ? void 0 : options.reloadAt) == null ? void 0 : _c.relative) !== "number" && ((_d = options == null ? void 0 : options.reloadAt) == null ? void 0 : _d.relative) !== void 0) {
      throw new Error("API: reload - Invalid 'reloadAt.relative' option format.");
    }
    if (!Array.isArray(options == null ? void 0 : options.keySystems) && (options == null ? void 0 : options.keySystems) !== void 0) {
      throw new Error("API: reload - Invalid 'keySystems' option format.");
    }
    if ((options == null ? void 0 : options.autoPlay) !== void 0 && typeof options.autoPlay !== "boolean") {
      throw new Error("API: reload - Invalid 'autoPlay' option format.");
    }
  }
  function parseLoadVideoOptions(options) {
    var _a, _b, _c;
    let url;
    let transport;
    let keySystems;
    let textTrackMode;
    let mode;
    let textTrackElement;
    let startAt;
    const {
      DEFAULT_AUTO_PLAY,
      DEFAULT_CODEC_SWITCHING_BEHAVIOR,
      DEFAULT_ENABLE_FAST_SWITCHING,
      DEFAULT_TEXT_TRACK_MODE
    } = config_default.getCurrent();
    if (isNullOrUndefined(options)) {
      throw new Error("No option set on loadVideo");
    }
    if (!isNullOrUndefined(options.url)) {
      url = String(options.url);
    } else if (isNullOrUndefined(options.initialManifest) && isNullOrUndefined(options.manifestLoader)) {
      throw new Error(
        "Unable to load a content: no url set on loadVideo.\nPlease provide at least either an `url` argument, a `initialManifest` option or a `manifestLoader` option so the RxPlayer can load the content."
      );
    }
    if (isNullOrUndefined(options.transport)) {
      throw new Error("No transport set on loadVideo");
    } else {
      transport = String(options.transport);
    }
    const autoPlay = isNullOrUndefined(options.autoPlay) ? DEFAULT_AUTO_PLAY : !!options.autoPlay;
    if (isNullOrUndefined(options.keySystems)) {
      keySystems = [];
    } else {
      keySystems = Array.isArray(options.keySystems) ? options.keySystems : [options.keySystems];
      for (const keySystem of keySystems) {
        if (typeof keySystem.type !== "string" || typeof keySystem.getLicense !== "function") {
          throw new Error(
            "Invalid key system given: Missing type string or getLicense callback"
          );
        }
      }
    }
    const lowLatencyMode = options.lowLatencyMode === void 0 ? false : !!options.lowLatencyMode;
    const initialManifest = options.initialManifest;
    const minimumManifestUpdateInterval = (_a = options.minimumManifestUpdateInterval) != null ? _a : 0;
    let defaultAudioTrackSwitchingMode = (_b = options.defaultAudioTrackSwitchingMode) != null ? _b : void 0;
    if (defaultAudioTrackSwitchingMode !== void 0 && !arrayIncludes(["seamless", "direct", "reload"], defaultAudioTrackSwitchingMode)) {
      log_default.warn(
        "The `defaultAudioTrackSwitchingMode` loadVideo option must match one of the following strategy name:\n- `seamless`\n- `direct`\n- `reload`"
      );
      defaultAudioTrackSwitchingMode = void 0;
    }
    let onCodecSwitch = isNullOrUndefined(options.onCodecSwitch) ? DEFAULT_CODEC_SWITCHING_BEHAVIOR : options.onCodecSwitch;
    if (!arrayIncludes(["continue", "reload"], onCodecSwitch)) {
      log_default.warn(
        "The `onCodecSwitch` loadVideo option must match one of the following string:\n- `continue`\n- `reload`\nIf badly set, " + DEFAULT_CODEC_SWITCHING_BEHAVIOR + " will be used as default"
      );
      onCodecSwitch = DEFAULT_CODEC_SWITCHING_BEHAVIOR;
    }
    if (isNullOrUndefined(options.textTrackMode)) {
      textTrackMode = DEFAULT_TEXT_TRACK_MODE;
    } else {
      if (options.textTrackMode !== "native" && options.textTrackMode !== "html") {
        throw new Error("Invalid textTrackMode.");
      }
      textTrackMode = options.textTrackMode;
    }
    if (textTrackMode === "html") {
      if (isNullOrUndefined(options.textTrackElement)) {
        throw new Error(
          'You have to provide a textTrackElement in "html" textTrackMode.'
        );
      } else if (!(options.textTrackElement instanceof HTMLElement)) {
        throw new Error("textTrackElement should be an HTMLElement.");
      } else {
        textTrackElement = options.textTrackElement;
      }
    } else if (!isNullOrUndefined(options.textTrackElement)) {
      log_default.warn(
        'API: You have set a textTrackElement without being in an "html" textTrackMode. It will be ignored.'
      );
    }
    if (isNullOrUndefined(options.mode)) {
      mode = "auto";
    } else {
      if (!arrayIncludes(["auto", "multithread", "main"], options.mode)) {
        throw new Error("Invalid `mode` option.");
      }
      mode = options.mode;
    }
    const enableFastSwitching = isNullOrUndefined(options.enableFastSwitching) ? DEFAULT_ENABLE_FAST_SWITCHING : options.enableFastSwitching;
    if (!isNullOrUndefined(options.startAt)) {
      if ("wallClockTime" in options.startAt && options.startAt.wallClockTime instanceof Date) {
        const wallClockTime = options.startAt.wallClockTime.getTime() / 1e3;
        startAt = object_assign_default({}, options.startAt, { wallClockTime });
      } else {
        startAt = options.startAt;
      }
    }
    const requestConfig = (_c = options.requestConfig) != null ? _c : {};
    return {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access
      __priv_patchLastSegmentInSidx: options.__priv_patchLastSegmentInSidx,
      // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access
      __priv_manifestUpdateUrl: options.__priv_manifestUpdateUrl,
      checkMediaSegmentIntegrity: options.checkMediaSegmentIntegrity,
      checkManifestIntegrity: options.checkManifestIntegrity,
      autoPlay,
      defaultAudioTrackSwitchingMode,
      enableFastSwitching,
      initialManifest,
      keySystems,
      lowLatencyMode,
      manifestLoader: options.manifestLoader,
      minimumManifestUpdateInterval,
      requestConfig,
      onCodecSwitch,
      referenceDateTime: options.referenceDateTime,
      representationFilter: options.representationFilter,
      segmentLoader: options.segmentLoader,
      serverSyncInfos: options.serverSyncInfos,
      startAt,
      textTrackElement,
      textTrackMode,
      transport,
      mode,
      url,
      cmcd: options.cmcd
    };
  }

  // src/main_thread/api/utils.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function emitSeekEvents(mediaElement, playbackObserver, onSeeking2, onSeeked2, cancelSignal) {
    if (cancelSignal.isCancelled() || mediaElement === null) {
      return;
    }
    let wasSeeking = playbackObserver.getReference().getValue().seeking === 2 /* External */;
    if (wasSeeking) {
      onSeeking2();
      if (cancelSignal.isCancelled()) {
        return;
      }
    }
    playbackObserver.listen(
      (obs) => {
        if (obs.event === "seeking") {
          wasSeeking = true;
          onSeeking2();
        } else if (wasSeeking && obs.event === "seeked") {
          wasSeeking = false;
          onSeeked2();
        }
      },
      { includeLastObservation: true, clearSignal: cancelSignal }
    );
  }
  function emitPlayPauseEvents(mediaElement, onPlay, onPause, cancelSignal) {
    if (cancelSignal.isCancelled() || mediaElement === null) {
      return;
    }
    mediaElement.addEventListener("play", onPlay);
    mediaElement.addEventListener("pause", onPause);
    cancelSignal.register(() => {
      mediaElement.removeEventListener("play", onPlay);
      mediaElement.removeEventListener("pause", onPause);
    });
  }
  function constructPlayerStateReference(initializer, mediaElement, playbackObserver, cancelSignal) {
    const playerStateRef = new reference_default(
      "LOADING" /* LOADING */,
      cancelSignal
    );
    initializer.addEventListener(
      "loaded",
      () => {
        if (playerStateRef.getValue() === "LOADING" /* LOADING */) {
          playerStateRef.setValue("LOADED" /* LOADED */);
          if (!cancelSignal.isCancelled()) {
            const newState = getLoadedContentState(mediaElement, null);
            if (newState !== "PAUSED" /* PAUSED */) {
              playerStateRef.setValue(newState);
            }
          }
        } else if (playerStateRef.getValue() === "RELOADING" /* RELOADING */) {
          playerStateRef.setValue(getLoadedContentState(mediaElement, null));
        } else {
          updateStateIfLoaded(null);
        }
      },
      cancelSignal
    );
    initializer.addEventListener(
      "reloadingMediaSource",
      () => {
        if (isLoadedState(playerStateRef.getValue())) {
          playerStateRef.setValueIfChanged("RELOADING" /* RELOADING */);
        }
      },
      cancelSignal
    );
    let prevStallReason = null;
    initializer.addEventListener(
      "stalled",
      (s) => {
        if (s !== prevStallReason) {
          updateStateIfLoaded(s);
          prevStallReason = s;
        }
      },
      cancelSignal
    );
    initializer.addEventListener(
      "unstalled",
      () => {
        if (prevStallReason !== null) {
          updateStateIfLoaded(null);
          prevStallReason = null;
        }
      },
      cancelSignal
    );
    playbackObserver.listen(
      (observation) => {
        if (arrayIncludes(["seeking", "ended", "play", "pause"], observation.event)) {
          updateStateIfLoaded(prevStallReason);
        }
      },
      { clearSignal: cancelSignal }
    );
    return playerStateRef;
    function updateStateIfLoaded(stallRes) {
      if (!isLoadedState(playerStateRef.getValue())) {
        return;
      }
      const newState = getLoadedContentState(mediaElement, stallRes);
      const prevState = playerStateRef.getValue();
      if (prevState === "LOADED" /* LOADED */ && newState === "PAUSED" /* PAUSED */) {
        return;
      }
      playerStateRef.setValueIfChanged(newState);
    }
  }
  function getLoadedContentState(mediaElement, stalledStatus) {
    const { FORCED_ENDED_THRESHOLD } = config_default.getCurrent();
    if (mediaElement.ended) {
      return "ENDED" /* ENDED */;
    }
    if (stalledStatus !== null) {
      const gapBetweenDurationAndCurrentTime = Math.abs(
        mediaElement.duration - mediaElement.currentTime
      );
      if (!isNullOrUndefined(FORCED_ENDED_THRESHOLD) && gapBetweenDurationAndCurrentTime < FORCED_ENDED_THRESHOLD) {
        return "ENDED" /* ENDED */;
      }
      if (stalledStatus === "seeking") {
        return "SEEKING" /* SEEKING */;
      }
      if (stalledStatus === "freezing") {
        return "FREEZING" /* FREEZING */;
      }
      return "BUFFERING" /* BUFFERING */;
    }
    return mediaElement.paused ? "PAUSED" /* PAUSED */ : "PLAYING" /* PLAYING */;
  }
  function isLoadedState(state) {
    return state !== "LOADING" /* LOADING */ && state !== "RELOADING" /* RELOADING */ && state !== "STOPPED" /* STOPPED */;
  }

  // src/main_thread/api/public_api.ts
  var generateContentId = idGenerator();
  var MULTI_THREAD_UNSUPPORTED_LOAD_VIDEO_OPTIONS = [
    "manifestLoader",
    "segmentLoader"
  ];
  var _Player = class _Player extends EventEmitter {
    /** All possible Error types emitted by the RxPlayer. */
    static get ErrorTypes() {
      return ErrorTypes;
    }
    /** All possible Error codes emitted by the RxPlayer. */
    static get ErrorCodes() {
      return ErrorCodes;
    }
    /**
     * Current log level.
     * Update current log level.
     * Should be either (by verbosity ascending):
     *   - "NONE"
     *   - "ERROR"
     *   - "WARNING"
     *   - "INFO"
     *   - "DEBUG"
     * Any other value will be translated to "NONE".
     */
    static get LogLevel() {
      return log_default.getLevel();
    }
    static set LogLevel(logLevel) {
      log_default.setLevel(logLevel, log_default.getFormat());
    }
    /**
     * Current log format.
     * Should be either (by verbosity ascending):
     *   - "standard": Regular log messages.
     *   - "full": More verbose format, including a timestamp and a namespace.
     * Any other value will be translated to "standard".
     */
    static get LogFormat() {
      return log_default.getFormat();
    }
    static set LogFormat(format) {
      log_default.setLevel(log_default.getLevel(), format);
    }
    /**
     * Add feature(s) to the RxPlayer.
     * @param {Array.<Object>} featureList - Features wanted.
     */
    static addFeatures(featureList) {
      addFeatures(featureList);
    }
    /**
     * Register the video element to the set of elements currently in use.
     * @param videoElement the video element to register.
     * @throws Error - Throws if the element is already used by another player instance.
     */
    static _priv_registerVideoElement(videoElement) {
      if (_Player._priv_currentlyUsedVideoElements.has(videoElement)) {
        const errorMessage2 = "The video element is already attached to another RxPlayer instance.\nMake sure to dispose the previous instance with player.dispose() before creating a new player instance attaching that video element.";
        console.warn(errorMessage2);
      }
      _Player._priv_currentlyUsedVideoElements.add(videoElement);
    }
    /**
     * Deregister the video element of the set of elements currently in use.
     * @param videoElement the video element to deregister.
     */
    static _priv_deregisterVideoElement(videoElement) {
      if (_Player._priv_currentlyUsedVideoElements.has(videoElement)) {
        _Player._priv_currentlyUsedVideoElements.delete(videoElement);
      }
    }
    /**
     * @constructor
     * @param {Object} options
     */
    constructor(options = {}) {
      super();
      const {
        baseBandwidth,
        videoResolutionLimit,
        maxBufferAhead,
        maxBufferBehind,
        throttleVideoBitrateWhenHidden,
        videoElement,
        wantedBufferAhead,
        maxVideoBufferSize
      } = parseConstructorOptions(options);
      videoElement.preload = "auto";
      this.version = /* PLAYER_VERSION */
      "4.1.0";
      this.log = log_default;
      this.state = "STOPPED";
      this.videoElement = videoElement;
      _Player._priv_registerVideoElement(this.videoElement);
      const destroyCanceller = new TaskCanceller();
      this._destroyCanceller = destroyCanceller;
      this._priv_pictureInPictureRef = getPictureOnPictureStateRef(
        videoElement,
        destroyCanceller.signal
      );
      this._priv_speed = new reference_default(
        videoElement.playbackRate,
        this._destroyCanceller.signal
      );
      this._priv_preferTrickModeTracks = false;
      this._priv_contentLock = new reference_default(
        false,
        this._destroyCanceller.signal
      );
      this._priv_bufferOptions = {
        wantedBufferAhead: new reference_default(
          wantedBufferAhead,
          this._destroyCanceller.signal
        ),
        maxBufferAhead: new reference_default(maxBufferAhead, this._destroyCanceller.signal),
        maxBufferBehind: new reference_default(
          maxBufferBehind,
          this._destroyCanceller.signal
        ),
        maxVideoBufferSize: new reference_default(
          maxVideoBufferSize,
          this._destroyCanceller.signal
        )
      };
      this._priv_bitrateInfos = {
        lastBitrates: { audio: baseBandwidth, video: baseBandwidth }
      };
      this._priv_throttleVideoBitrateWhenHidden = throttleVideoBitrateWhenHidden;
      this._priv_videoResolutionLimit = videoResolutionLimit;
      this._priv_currentError = null;
      this._priv_contentInfos = null;
      this._priv_contentEventsMemory = {};
      this._priv_reloadingMetadata = {};
      this._priv_lastAutoPlay = false;
      this._priv_worker = null;
      const onVolumeChange = () => {
        this.trigger("volumeChange", {
          volume: videoElement.volume,
          muted: videoElement.muted
        });
      };
      videoElement.addEventListener("volumechange", onVolumeChange);
      destroyCanceller.signal.register(() => {
        videoElement.removeEventListener("volumechange", onVolumeChange);
      });
    }
    /**
     * TODO returns promise?
     * @param {Object} workerSettings
     */
    attachWorker(workerSettings) {
      return new Promise((res, rej) => {
        var _a;
        if (!hasWorkerApi()) {
          log_default.warn("API: Cannot rely on a WebWorker: Worker API unavailable");
          return rej(
            new WorkerInitializationError("INCOMPATIBLE_ERROR", "Worker unavailable")
          );
        }
        if (typeof workerSettings.workerUrl === "string") {
          this._priv_worker = new Worker(workerSettings.workerUrl);
        } else {
          const blobUrl = URL.createObjectURL(workerSettings.workerUrl);
          this._priv_worker = new Worker(blobUrl);
          URL.revokeObjectURL(blobUrl);
        }
        this._priv_worker.onerror = (evt) => {
          if (this._priv_worker !== null) {
            this._priv_worker.terminate();
            this._priv_worker = null;
          }
          log_default.error(
            "API: Unexpected worker error",
            evt.error instanceof Error ? evt.error : void 0
          );
          rej(
            new WorkerInitializationError(
              "UNKNOWN_ERROR",
              'Unexpected Worker "error" event'
            )
          );
        };
        const handleInitMessages = (msg) => {
          const msgData = msg.data;
          if (msgData.type === "init-error" /* InitError */) {
            log_default.warn("API: Processing InitError worker message: detaching worker");
            if (this._priv_worker !== null) {
              this._priv_worker.removeEventListener("message", handleInitMessages);
              this._priv_worker.terminate();
              this._priv_worker = null;
            }
            rej(
              new WorkerInitializationError(
                "SETUP_ERROR",
                "Worker parser initialization failed: " + msgData.value.errorMessage
              )
            );
          } else if (msgData.type === "init-success" /* InitSuccess */) {
            log_default.info("API: InitSuccess received from worker.");
            if (this._priv_worker !== null) {
              this._priv_worker.removeEventListener("message", handleInitMessages);
            }
            res();
          }
        };
        this._priv_worker.addEventListener("message", handleInitMessages);
        log_default.debug("---> Sending To Worker:", "init" /* Init */);
        this._priv_worker.postMessage({
          type: "init" /* Init */,
          value: {
            dashWasmUrl: workerSettings.dashWasmUrl,
            logLevel: log_default.getLevel(),
            logFormat: log_default.getFormat(),
            sendBackLogs: isDebugModeEnabled(),
            date: Date.now(),
            timestamp: monotonic_timestamp_default(),
            hasVideo: ((_a = this.videoElement) == null ? void 0 : _a.nodeName.toLowerCase()) === "video",
            hasMseInWorker: has_mse_in_worker_default
          }
        });
        log_default.addEventListener(
          "onLogLevelChange",
          (logInfo) => {
            if (this._priv_worker === null) {
              return;
            }
            log_default.debug("---> Sending To Worker:", "log-level-update" /* LogLevelUpdate */);
            this._priv_worker.postMessage({
              type: "log-level-update" /* LogLevelUpdate */,
              value: {
                logLevel: logInfo.level,
                logFormat: logInfo.format,
                sendBackLogs: isDebugModeEnabled()
              }
            });
          },
          this._destroyCanceller.signal
        );
      });
    }
    /**
     * Returns information on which "mode" the RxPlayer is running for the current
     * content (e.g. main logic running in a WebWorker or not, are we in
     * directfile mode...).
     *
     * Returns `null` if no content is loaded.
     * @returns {Object|null}
     */
    getCurrentModeInformation() {
      if (this._priv_contentInfos === null) {
        return null;
      }
      return {
        isDirectFile: this._priv_contentInfos.isDirectFile,
        useWorker: this._priv_contentInfos.useWorker
      };
    }
    /**
     * Register a new callback for a player event event.
     *
     * @param {string} evt - The event to register a callback to
     * @param {Function} fn - The callback to call as that event is triggered.
     * The callback will take as argument the eventual payload of the event
     * (single argument).
     */
    addEventListener(evt, fn) {
      return super.addEventListener(evt, fn);
    }
    /**
     * Stop the playback for the current content.
     */
    stop() {
      if (this._priv_contentInfos !== null) {
        this._priv_contentInfos.currentContentCanceller.cancel();
      }
      this._priv_cleanUpCurrentContentState();
      if (this.state !== "STOPPED" /* STOPPED */) {
        this._priv_setPlayerState("STOPPED" /* STOPPED */);
      }
    }
    /**
     * Free the resources used by the player.
     * /!\ The player cannot be "used" anymore after this method has been called.
     */
    dispose() {
      this.stop();
      if (this.videoElement !== null) {
        _Player._priv_deregisterVideoElement(this.videoElement);
        disposeDecryptionResources(this.videoElement).catch((err) => {
          const message = err instanceof Error ? err.message : "Unknown error";
          log_default.error("API: Could not dispose decryption resources: " + message);
        });
      }
      this._destroyCanceller.cancel();
      this._priv_reloadingMetadata = {};
      this.videoElement = null;
      if (this._priv_worker !== null) {
        this._priv_worker.terminate();
        this._priv_worker = null;
      }
    }
    /**
     * Load a new video.
     * @param {Object} opts
     */
    loadVideo(opts) {
      const options = parseLoadVideoOptions(opts);
      log_default.info("API: Calling loadvideo", options.url, options.transport);
      this._priv_reloadingMetadata = { options };
      this._priv_initializeContentPlayback(options);
      this._priv_lastAutoPlay = options.autoPlay;
    }
    /**
     * Reload the last loaded content.
     * @param {Object} reloadOpts
     */
    reload(reloadOpts) {
      var _a, _b, _c;
      const { options, manifest, reloadPosition, reloadInPause } = this._priv_reloadingMetadata;
      if (options === void 0) {
        throw new Error("API: Can't reload without having previously loaded a content.");
      }
      checkReloadOptions(reloadOpts);
      let startAt;
      if (((_a = reloadOpts == null ? void 0 : reloadOpts.reloadAt) == null ? void 0 : _a.position) !== void 0) {
        startAt = { position: reloadOpts.reloadAt.position };
      } else if (((_b = reloadOpts == null ? void 0 : reloadOpts.reloadAt) == null ? void 0 : _b.relative) !== void 0) {
        if (reloadPosition === void 0) {
          throw new Error(
            "Can't reload to a relative position when previous content was not loaded."
          );
        } else {
          startAt = { position: reloadOpts.reloadAt.relative + reloadPosition };
        }
      } else if (reloadPosition !== void 0) {
        startAt = { position: reloadPosition };
      }
      let autoPlay;
      if ((reloadOpts == null ? void 0 : reloadOpts.autoPlay) !== void 0) {
        autoPlay = reloadOpts.autoPlay;
      } else if (reloadInPause !== void 0) {
        autoPlay = !reloadInPause;
      }
      let keySystems;
      if ((reloadOpts == null ? void 0 : reloadOpts.keySystems) !== void 0) {
        keySystems = reloadOpts.keySystems;
      } else if (((_c = this._priv_reloadingMetadata.options) == null ? void 0 : _c.keySystems) !== void 0) {
        keySystems = this._priv_reloadingMetadata.options.keySystems;
      }
      const newOptions = __spreadProps(__spreadValues({}, options), { initialManifest: manifest });
      if (startAt !== void 0) {
        newOptions.startAt = startAt;
      }
      if (autoPlay !== void 0) {
        newOptions.autoPlay = autoPlay;
      }
      if (keySystems !== void 0) {
        newOptions.keySystems = keySystems;
      }
      this._priv_initializeContentPlayback(newOptions);
    }
    createDebugElement(element) {
      if (features_default.createDebugElement === null) {
        throw new Error("Feature `DEBUG_ELEMENT` not added to the RxPlayer");
      }
      const canceller = new TaskCanceller();
      features_default.createDebugElement(element, this, canceller.signal);
      return {
        dispose() {
          canceller.cancel();
        }
      };
    }
    /**
     * Returns either an array decribing the various thumbnail tracks that can be
     * encountered at the given time, or `null` if no thumbnail track is available
     * at that time.
     * @param {number} time - The position to check for thumbnail tracks, in
     * seconds.
     * @returns {Array.<Object>|null}
     */
    getThumbnailMetadata({ time }) {
      if (this._priv_contentInfos === null || this._priv_contentInfos.manifest === null) {
        return null;
      }
      const period = getPeriodForTime(this._priv_contentInfos.manifest, time);
      if (period === void 0 || period.thumbnailTracks.length === 0) {
        return null;
      }
      return period.thumbnailTracks.map((t) => {
        return {
          id: t.id,
          width: Math.floor(t.width / t.horizontalTiles),
          height: Math.floor(t.height / t.verticalTiles),
          mimeType: t.mimeType
        };
      });
    }
    /**
     * Render inside the given `container` the thumbnail corresponding to the
     * given time.
     *
     * If no thumbnail is available at that time or if the RxPlayer does not succeed
     * to load or render it, reject the corresponding Promise and remove the
     * potential previous thumbnail from the container.
     *
     * If a new `renderThumbnail` call is made with the same `container` before it
     * had time to finish, the Promise is also rejected but the previous thumbnail
     * potentially found in the container is untouched.
     *
     * @param {Object|undefined} options
     * @returns {Promise}
     */
    async renderThumbnail(options) {
      return renderThumbnail(this._priv_contentInfos, options);
    }
    /**
     * From given options, initialize content playback.
     * @param {Object} options
     */
    _priv_initializeContentPlayback(options) {
      var _a, _b, _c, _d, _e, _f;
      const {
        autoPlay,
        cmcd,
        defaultAudioTrackSwitchingMode,
        enableFastSwitching,
        initialManifest,
        keySystems,
        lowLatencyMode,
        minimumManifestUpdateInterval,
        requestConfig,
        onCodecSwitch,
        startAt,
        transport,
        checkMediaSegmentIntegrity,
        checkManifestIntegrity,
        manifestLoader,
        referenceDateTime,
        segmentLoader,
        serverSyncInfos,
        mode,
        __priv_manifestUpdateUrl,
        __priv_patchLastSegmentInSidx,
        url
      } = options;
      if (this.videoElement === null) {
        throw new Error("the attached video element is disposed");
      }
      const isDirectFile = transport === "directfile";
      const currentContentCanceller = new TaskCanceller();
      const videoElement = this.videoElement;
      let initializer;
      let useWorker = false;
      let mediaElementTracksStore = null;
      if (!isDirectFile) {
        const manifestRequestSettings = {
          lowLatencyMode,
          maxRetry: (_a = requestConfig.manifest) == null ? void 0 : _a.maxRetry,
          requestTimeout: (_b = requestConfig.manifest) == null ? void 0 : _b.timeout,
          connectionTimeout: (_c = requestConfig.manifest) == null ? void 0 : _c.connectionTimeout,
          minimumManifestUpdateInterval,
          initialManifest
        };
        const relyOnVideoVisibilityAndSize = canRelyOnVideoVisibilityAndSize();
        const throttlers = {
          throttleBitrate: {},
          limitResolution: {}
        };
        if (this._priv_throttleVideoBitrateWhenHidden) {
          if (!relyOnVideoVisibilityAndSize) {
            log_default.warn(
              "API: Can't apply throttleVideoBitrateWhenHidden because browser can't be trusted for visibility."
            );
          } else {
            throttlers.throttleBitrate = {
              video: createMappedReference(
                getVideoVisibilityRef(
                  this._priv_pictureInPictureRef,
                  currentContentCanceller.signal
                ),
                (isActive) => isActive ? Infinity : 0,
                currentContentCanceller.signal
              )
            };
          }
        }
        if (this._priv_videoResolutionLimit === "videoElement") {
          if (!relyOnVideoVisibilityAndSize) {
            log_default.warn(
              "API: Can't apply videoResolutionLimit because browser can't be trusted for video size."
            );
          } else {
            throttlers.limitResolution = {
              video: getElementResolutionRef(
                videoElement,
                this._priv_pictureInPictureRef,
                currentContentCanceller.signal
              )
            };
          }
        } else if (this._priv_videoResolutionLimit === "screen") {
          throttlers.limitResolution = {
            video: getScreenResolutionRef(currentContentCanceller.signal)
          };
        }
        const adaptiveOptions = {
          initialBitrates: this._priv_bitrateInfos.lastBitrates,
          lowLatencyMode,
          throttlers
        };
        const textTrackOptions = options.textTrackMode === "native" ? { textTrackMode: "native" } : {
          textTrackMode: "html",
          textTrackElement: options.textTrackElement
        };
        const bufferOptions = object_assign_default(
          { enableFastSwitching, onCodecSwitch },
          this._priv_bufferOptions
        );
        const segmentRequestOptions = {
          lowLatencyMode,
          maxRetry: (_d = requestConfig.segment) == null ? void 0 : _d.maxRetry,
          requestTimeout: (_e = requestConfig.segment) == null ? void 0 : _e.timeout,
          connectionTimeout: (_f = requestConfig.segment) == null ? void 0 : _f.connectionTimeout
        };
        const canRunInMultiThread = features_default.multithread !== null && this._priv_worker !== null && transport === "dash" && MULTI_THREAD_UNSUPPORTED_LOAD_VIDEO_OPTIONS.every(
          (option) => isNullOrUndefined(options[option])
        ) && typeof options.representationFilter !== "function";
        if (mode === "main" || mode === "auto" && !canRunInMultiThread) {
          if (features_default.mainThreadMediaSourceInit === null) {
            throw new Error(
              "Cannot load video, neither in a WebWorker nor with the `MEDIA_SOURCE_MAIN` feature"
            );
          }
          const transportFn = features_default.transports[transport];
          if (typeof transportFn !== "function") {
            this.stop();
            this._priv_currentError = null;
            throw new Error(`transport "${transport}" not supported`);
          }
          const representationFilter = typeof options.representationFilter === "string" ? createRepresentationFilterFromFnString(options.representationFilter) : options.representationFilter;
          log_default.info("API: Initializing MediaSource mode in the main thread");
          const transportPipelines = transportFn({
            lowLatencyMode,
            checkMediaSegmentIntegrity,
            checkManifestIntegrity,
            manifestLoader,
            referenceDateTime,
            representationFilter,
            segmentLoader,
            serverSyncInfos,
            __priv_manifestUpdateUrl,
            __priv_patchLastSegmentInSidx
          });
          initializer = new features_default.mainThreadMediaSourceInit({
            adaptiveOptions,
            autoPlay,
            bufferOptions,
            cmcd,
            keySystems,
            lowLatencyMode,
            transport: transportPipelines,
            manifestRequestSettings,
            segmentRequestOptions,
            speed: this._priv_speed,
            startAt,
            textTrackOptions,
            url
          });
        } else {
          if (features_default.multithread === null) {
            throw new Error(
              "Cannot load video in multithread mode: `MULTI_THREAD` feature not imported."
            );
          } else if (this._priv_worker === null) {
            throw new Error(
              "Cannot load video in multithread mode: `attachWorker` method not called."
            );
          }
          assert(typeof options.representationFilter !== "function");
          useWorker = true;
          log_default.info("API: Initializing MediaSource mode in a WebWorker");
          const transportOptions = {
            lowLatencyMode,
            checkMediaSegmentIntegrity,
            checkManifestIntegrity,
            referenceDateTime,
            serverSyncInfos,
            manifestLoader: void 0,
            segmentLoader: void 0,
            representationFilter: options.representationFilter,
            __priv_manifestUpdateUrl,
            __priv_patchLastSegmentInSidx
          };
          initializer = new features_default.multithread.init({
            adaptiveOptions,
            autoPlay,
            bufferOptions,
            cmcd,
            keySystems,
            lowLatencyMode,
            transportOptions,
            manifestRequestSettings,
            segmentRequestOptions,
            speed: this._priv_speed,
            startAt,
            textTrackOptions,
            worker: this._priv_worker,
            url
          });
        }
      } else {
        if (features_default.directfile === null) {
          this.stop();
          this._priv_currentError = null;
          throw new Error("DirectFile feature not activated in your build.");
        } else if (isNullOrUndefined(url)) {
          throw new Error("No URL for a DirectFile content");
        }
        log_default.info("API: Initializing DirectFile mode in the main thread");
        mediaElementTracksStore = this._priv_initializeMediaElementTracksStore(
          currentContentCanceller.signal
        );
        if (currentContentCanceller.isUsed()) {
          return;
        }
        initializer = new features_default.directfile.initDirectFile({
          autoPlay,
          keySystems,
          speed: this._priv_speed,
          startAt,
          url
        });
      }
      const contentInfos = {
        contentId: generateContentId(),
        originalUrl: url,
        currentContentCanceller,
        defaultAudioTrackSwitchingMode,
        initializer,
        isDirectFile,
        manifest: null,
        currentPeriod: null,
        activeAdaptations: null,
        activeRepresentations: null,
        tracksStore: null,
        mediaElementTracksStore,
        useWorker,
        segmentSinkMetricsCallback: null,
        fetchThumbnailDataCallback: null,
        thumbnailRequestsInfo: {
          pendingRequests: /* @__PURE__ */ new Map(),
          lastResponse: null
        }
      };
      initializer.addEventListener("error", (error) => {
        this._priv_onFatalError(error, contentInfos);
      });
      initializer.addEventListener("warning", (error) => {
        const formattedError = formatError(error, {
          defaultCode: "NONE",
          defaultReason: "An unknown error happened."
        });
        log_default.warn("API: Sending warning:", formattedError);
        this.trigger("warning", formattedError);
      });
      initializer.addEventListener("reloadingMediaSource", (payload) => {
        if (contentInfos.tracksStore !== null) {
          contentInfos.tracksStore.resetPeriodObjects();
        }
        if (this._priv_contentInfos !== null) {
          this._priv_contentInfos.segmentSinkMetricsCallback = null;
        }
        this._priv_lastAutoPlay = payload.autoPlay;
      });
      initializer.addEventListener(
        "inbandEvents",
        (inbandEvents) => this.trigger("inbandEvents", inbandEvents)
      );
      initializer.addEventListener(
        "streamEvent",
        (streamEvent) => this.trigger("streamEvent", streamEvent)
      );
      initializer.addEventListener(
        "streamEventSkip",
        (streamEventSkip) => this.trigger("streamEventSkip", streamEventSkip)
      );
      initializer.addEventListener(
        "activePeriodChanged",
        (periodInfo) => this._priv_onActivePeriodChanged(contentInfos, periodInfo)
      );
      initializer.addEventListener(
        "periodStreamReady",
        (periodReadyInfo) => this._priv_onPeriodStreamReady(contentInfos, periodReadyInfo)
      );
      initializer.addEventListener(
        "periodStreamCleared",
        (periodClearedInfo) => this._priv_onPeriodStreamCleared(contentInfos, periodClearedInfo)
      );
      initializer.addEventListener(
        "representationChange",
        (representationInfo) => this._priv_onRepresentationChange(contentInfos, representationInfo)
      );
      initializer.addEventListener(
        "adaptationChange",
        (adaptationInfo) => this._priv_onAdaptationChange(contentInfos, adaptationInfo)
      );
      initializer.addEventListener(
        "bitrateEstimateChange",
        (bitrateEstimateInfo) => this._priv_onBitrateEstimateChange(bitrateEstimateInfo)
      );
      initializer.addEventListener(
        "manifestReady",
        (manifest) => this._priv_onManifestReady(contentInfos, manifest)
      );
      initializer.addEventListener(
        "manifestUpdate",
        (updates) => this._priv_onManifestUpdate(contentInfos, updates)
      );
      initializer.addEventListener(
        "codecSupportUpdate",
        () => this._priv_onCodecSupportUpdate(contentInfos)
      );
      initializer.addEventListener(
        "decipherabilityUpdate",
        (updates) => this._priv_onDecipherabilityUpdate(contentInfos, updates)
      );
      initializer.addEventListener("loaded", (evt) => {
        if (this._priv_contentInfos !== null) {
          this._priv_contentInfos.segmentSinkMetricsCallback = evt.getSegmentSinkMetrics;
          this._priv_contentInfos.fetchThumbnailDataCallback = evt.getThumbnailData;
        }
      });
      initializer.prepare();
      this.stop();
      const playbackObserver = new PlaybackObserver(videoElement, {
        withMediaSource: !isDirectFile,
        lowLatencyMode
      });
      currentContentCanceller.signal.register(() => {
        playbackObserver.stop();
      });
      const playerStateRef = constructPlayerStateReference(
        initializer,
        videoElement,
        playbackObserver,
        currentContentCanceller.signal
      );
      currentContentCanceller.signal.register(() => {
        initializer.dispose();
      });
      const updateReloadingMetadata = (state) => {
        switch (state) {
          case "STOPPED":
          case "RELOADING":
          case "LOADING":
            break;
          case "ENDED":
            this._priv_reloadingMetadata.reloadInPause = true;
            this._priv_reloadingMetadata.reloadPosition = playbackObserver.getReference().getValue().position.getPolled();
            break;
          default: {
            const o = playbackObserver.getReference().getValue();
            this._priv_reloadingMetadata.reloadInPause = o.paused;
            this._priv_reloadingMetadata.reloadPosition = o.position.getWanted();
            break;
          }
        }
      };
      let playPauseEventsCanceller = null;
      const triggerPlayPauseEventsWhenReady = (willAutoPlay) => {
        if (playPauseEventsCanceller !== null) {
          playPauseEventsCanceller.cancel();
          playPauseEventsCanceller = null;
        }
        playerStateRef.onUpdate(
          (val, stopListeningToStateUpdates) => {
            if (!isLoadedState(val)) {
              return;
            }
            stopListeningToStateUpdates();
            if (playPauseEventsCanceller !== null) {
              playPauseEventsCanceller.cancel();
            }
            playPauseEventsCanceller = new TaskCanceller();
            playPauseEventsCanceller.linkToSignal(currentContentCanceller.signal);
            if (willAutoPlay !== !videoElement.paused) {
              if (videoElement.paused) {
                this.trigger("pause", null);
              } else {
                this.trigger("play", null);
              }
            }
            emitPlayPauseEvents(
              videoElement,
              () => this.trigger("play", null),
              () => this.trigger("pause", null),
              currentContentCanceller.signal
            );
          },
          {
            emitCurrentValue: false,
            clearSignal: currentContentCanceller.signal
          }
        );
      };
      triggerPlayPauseEventsWhenReady(autoPlay);
      initializer.addEventListener("reloadingMediaSource", (payload) => {
        triggerPlayPauseEventsWhenReady(payload.autoPlay);
      });
      this._priv_currentError = null;
      this._priv_contentInfos = contentInfos;
      let seekEventsCanceller = null;
      playerStateRef.onUpdate(
        (newState) => {
          updateReloadingMetadata(newState);
          this._priv_setPlayerState(newState);
          if (currentContentCanceller.isUsed()) {
            return;
          }
          if (seekEventsCanceller !== null) {
            if (!isLoadedState(this.state)) {
              seekEventsCanceller.cancel();
              seekEventsCanceller = null;
            }
          } else if (isLoadedState(this.state)) {
            seekEventsCanceller = new TaskCanceller();
            seekEventsCanceller.linkToSignal(currentContentCanceller.signal);
            emitSeekEvents(
              videoElement,
              playbackObserver,
              () => this.trigger("seeking", null),
              () => this.trigger("seeked", null),
              seekEventsCanceller.signal
            );
          }
        },
        { emitCurrentValue: true, clearSignal: currentContentCanceller.signal }
      );
      playbackObserver.listen(
        (observation) => {
          updateReloadingMetadata(this.state);
          this._priv_triggerPositionUpdate(contentInfos, observation);
        },
        { clearSignal: currentContentCanceller.signal }
      );
      currentContentCanceller.signal.register(() => {
        initializer.removeEventListener();
      });
      this._priv_contentLock.onUpdate(
        (isLocked, stopListeningToLock) => {
          if (!isLocked) {
            stopListeningToLock();
            initializer.start(videoElement, playbackObserver);
          }
        },
        { emitCurrentValue: true, clearSignal: currentContentCanceller.signal }
      );
    }
    /**
     * Returns fatal error if one for the current content.
     * null otherwise.
     * @returns {Object|null} - The current Error (`null` when no error).
     */
    getError() {
      return this._priv_currentError;
    }
    /**
     * Returns the media DOM element used by the player.
     * You should not its HTML5 API directly and use the player's method instead,
     * to ensure a well-behaved player.
     * @returns {HTMLMediaElement|null} - The HTMLMediaElement used (`null` when
     * disposed)
     */
    // eslint-disable-next-line @typescript-eslint/no-restricted-types
    getVideoElement() {
      return this.videoElement;
    }
    /**
     * Returns the player's current state.
     * @returns {string} - The current Player's state
     */
    getPlayerState() {
      return this.state;
    }
    /**
     * Returns true if a content is loaded.
     * @returns {Boolean} - `true` if a content is loaded, `false` otherwise.
     */
    isContentLoaded() {
      return !arrayIncludes(["LOADING", "RELOADING", "STOPPED"], this.state);
    }
    /**
     * Returns true if the player is buffering.
     * @returns {Boolean} - `true` if the player is buffering, `false` otherwise.
     */
    isBuffering() {
      return arrayIncludes(["BUFFERING", "SEEKING", "LOADING", "RELOADING"], this.state);
    }
    /**
     * Returns the play/pause status of the player :
     *   - when `LOADING` or `RELOADING`, returns the scheduled play/pause condition
     *     for when loading is over,
     *   - in other states, returns the `<video>` element .paused value,
     *   - if the player is disposed, returns `true`.
     * @returns {Boolean} - `true` if the player is paused or will be after loading,
     * `false` otherwise.
     */
    isPaused() {
      if (this.videoElement) {
        if (arrayIncludes(["LOADING", "RELOADING"], this.state)) {
          return !this._priv_lastAutoPlay;
        } else {
          return this.videoElement.paused;
        }
      }
      return true;
    }
    /**
     * Returns true if both:
     *   - a content is loaded
     *   - the content loaded is a live content
     * @returns {Boolean} - `true` if we're playing a live content, `false` otherwise.
     */
    isLive() {
      if (this._priv_contentInfos === null) {
        return false;
      }
      const { isDirectFile, manifest } = this._priv_contentInfos;
      if (isDirectFile || manifest === null) {
        return false;
      }
      return manifest.isLive;
    }
    /**
     * Returns `true` if trickmode playback is active (usually through the usage
     * of the `setPlaybackRate` method), which means that the RxPlayer selects
     * "trickmode" video tracks in priority.
     * @returns {Boolean}
     */
    areTrickModeTracksEnabled() {
      return this._priv_preferTrickModeTracks;
    }
    /**
     * Returns the URL(s) of the currently considered Manifest, or of the content for
     * directfile content.
     * @returns {Array.<string>|undefined} - Current URL. `undefined` if not known
     * or no URL yet.
     */
    getContentUrls() {
      if (this._priv_contentInfos === null) {
        return void 0;
      }
      const { isDirectFile, manifest, originalUrl } = this._priv_contentInfos;
      if (isDirectFile) {
        return originalUrl === void 0 ? void 0 : [originalUrl];
      }
      if (manifest !== null) {
        return manifest.uris;
      }
      return void 0;
    }
    /**
     * Update URL of the content currently being played (e.g. DASH's MPD).
     * @param {Array.<string>|undefined} urls - URLs to reach that content /
     * Manifest from the most prioritized URL to the least prioritized URL.
     * @param {Object|undefined} [params]
     * @param {boolean} params.refresh - If `true` the resource in question
     * (e.g. DASH's MPD) will be refreshed immediately.
     */
    updateContentUrls(urls, params) {
      if (this._priv_contentInfos === null) {
        throw new Error("No content loaded");
      }
      const refreshNow = (params == null ? void 0 : params.refresh) === true;
      this._priv_contentInfos.initializer.updateContentUrls(urls, refreshNow);
    }
    /**
     * Returns the video duration, in seconds.
     * NaN if no video is playing.
     * @returns {Number}
     */
    getMediaDuration() {
      if (this.videoElement === null) {
        throw new Error("Disposed player");
      }
      return this.videoElement.duration;
    }
    /**
     * Returns in seconds the difference between:
     *   - the end of the current contiguous loaded range.
     *   - the current time
     * @returns {Number}
     */
    getCurrentBufferGap() {
      if (this.videoElement === null) {
        throw new Error("Disposed player");
      }
      const videoElement = this.videoElement;
      const bufferGap = getLeftSizeOfBufferedTimeRange(
        videoElement.buffered,
        videoElement.currentTime
      );
      if (bufferGap === Infinity) {
        return 0;
      }
      return bufferGap;
    }
    /**
     * Get the current position, in s, in wall-clock time.
     * That is:
     *   - for live content, get a timestamp, in s, of the current played content.
     *   - for static content, returns the position from beginning in s.
     *
     * If you do not know if you want to use this method or getPosition:
     *   - If what you want is to display the current time to the user, use this
     *     one.
     *   - If what you want is to interact with the player's API or perform other
     *     actions (like statistics) with the real player data, use getPosition.
     *
     * @returns {Number}
     */
    getWallClockTime() {
      var _a;
      if (this.videoElement === null) {
        throw new Error("Disposed player");
      }
      if (this._priv_contentInfos === null) {
        return this.videoElement.currentTime;
      }
      const { isDirectFile, manifest } = this._priv_contentInfos;
      if (isDirectFile) {
        const startDate = getStartDate(this.videoElement);
        return (startDate != null ? startDate : 0) + this.videoElement.currentTime;
      }
      if (manifest !== null) {
        const currentTime = this.videoElement.currentTime;
        const ast = (_a = manifest.availabilityStartTime) != null ? _a : 0;
        return currentTime + ast;
      }
      return 0;
    }
    /**
     * Get the current position, in seconds, of the video element.
     *
     * If you do not know if you want to use this method or getWallClockTime:
     *   - If what you want is to display the current time to the user, use
     *     getWallClockTime.
     *   - If what you want is to interact with the player's API or perform other
     *     actions (like statistics) with the real player data, use this one.
     *
     * @returns {Number}
     */
    getPosition() {
      if (this.videoElement === null) {
        throw new Error("Disposed player");
      }
      return this.videoElement.currentTime;
    }
    /**
     * Returns the last stored content position, in seconds.
     *
     * @returns {number|undefined}
     */
    getLastStoredContentPosition() {
      return this._priv_reloadingMetadata.reloadPosition;
    }
    /**
     * Returns the current playback rate at which the video plays.
     * @returns {Number}
     */
    getPlaybackRate() {
      return this._priv_speed.getValue();
    }
    /**
     * Update the playback rate of the video.
     *
     * This method's effect is persisted from content to content, and can be
     * called even when no content is playing (it will still have an effect for
     * the next contents).
     *
     * If you want to reverse effects provoked by `setPlaybackRate` before playing
     * another content, you will have to call `setPlaybackRate` first with the
     * default settings you want to set.
     *
     * As an example, to reset the speed to "normal" (x1) speed and to disable
     * trickMode video tracks (which may have been enabled by a previous
     * `setPlaybackRate` call), you can call:
     * ```js
     * player.setPlaybackRate(1, { preferTrickModeTracks: false });
     * ```
     *
     * --
     *
     * This method can be used to switch to or exit from "trickMode" video tracks,
     * which are tracks specifically defined to mimic the visual aspect of a VCR's
     * fast forward/rewind feature, by only displaying a few video frames during
     * playback.
     *
     * This behavior is configurable through the second argument, by adding a
     * property named `preferTrickModeTracks` to that object.
     *
     * You can set that value to `true` to switch to trickMode video tracks when
     * available, and set it to `false` when you want to disable that logic.
     * Note that like any configuration given to `setPlaybackRate`, this setting
     * is persisted through all future contents played by the player.
     *
     * If you want to stop enabling trickMode tracks, you will have to call
     * `setPlaybackRate` again with `preferTrickModeTracks` set to `false`.
     *
     * You can know at any moment whether this behavior is enabled by calling
     * the `areTrickModeTracksEnabled` method. This will only means that the
     * RxPlayer will select in priority trickmode video tracks, not that the
     * currently chosen video tracks is a trickmode track (for example, some
     * contents may have no trickmode tracks available).
     *
     * If you want to know about the latter instead, you can call `getVideoTrack`
     * and/or listen to `videoTrackChange` events. The track returned may have an
     * `isTrickModeTrack` property set to `true`, indicating that it is a
     * trickmode track.
     *
     * Note that switching to or getting out of a trickmode video track may
     * lead to the player being a brief instant in a `"RELOADING"` state (notified
     * through `playerStateChange` events and the `getLoadedContentState` method).
     * When in that state, a black screen may be displayed and multiple RxPlayer
     * APIs will not be usable.
     *
     * @param {Number} rate
     * @param {Object} opts
     */
    setPlaybackRate(rate, opts) {
      var _a;
      if (rate !== this._priv_speed.getValue()) {
        this._priv_speed.setValue(rate);
      }
      const preferTrickModeTracks = opts == null ? void 0 : opts.preferTrickModeTracks;
      if (typeof preferTrickModeTracks !== "boolean") {
        return;
      }
      this._priv_preferTrickModeTracks = preferTrickModeTracks;
      const tracksStore = (_a = this._priv_contentInfos) == null ? void 0 : _a.tracksStore;
      if (!isNullOrUndefined(tracksStore)) {
        if (preferTrickModeTracks && !tracksStore.isTrickModeEnabled()) {
          tracksStore.enableVideoTrickModeTracks();
        } else if (!preferTrickModeTracks && tracksStore.isTrickModeEnabled()) {
          tracksStore.disableVideoTrickModeTracks();
        }
      }
    }
    /**
     * Returns video Representation currently considered for the current Period.
     *
     * Returns `null` if no video track is playing for the current Period.
     *
     * Returns `undefined` either when are not currently playing any Period or
     * when we don't know which Representation is playing.
     * @returns {Object|null|undefined}
     */
    getVideoRepresentation() {
      const representations = this.__priv_getCurrentRepresentations();
      if (representations === null) {
        return void 0;
      }
      return representations.video;
    }
    /**
     * Returns audio Representation currently considered for the current Period.
     *
     * Returns `null` if no audio track is playing for the current Period.
     *
     * Returns `undefined` either when are not currently playing any Period or
     * when we don't know which Representation is playing.
     * @returns {Object|null|undefined}
     */
    getAudioRepresentation() {
      const representations = this.__priv_getCurrentRepresentations();
      if (representations === null) {
        return void 0;
      }
      return representations.audio;
    }
    /**
     * Play/Resume the current video.
     * @returns {Promise}
     */
    play() {
      if (this.videoElement === null) {
        throw new Error("Disposed player");
      }
      const playPromise = this.videoElement.play();
      if (isNullOrUndefined(playPromise) || typeof playPromise.catch !== "function") {
        return Promise.resolve();
      }
      return playPromise.catch((error) => {
        if (error.name === "NotAllowedError") {
          const warning = new MediaError("MEDIA_ERR_PLAY_NOT_ALLOWED", error.toString());
          this.trigger("warning", warning);
        }
        throw error;
      });
    }
    /**
     * Pause the current video.
     */
    pause() {
      if (this.videoElement === null) {
        throw new Error("Disposed player");
      }
      this.videoElement.pause();
    }
    /**
     * Seek to a given absolute position.
     * @param {Number|Object} time
     * @returns {Number} - The time the player has seek to
     */
    seekTo(time) {
      var _a;
      if (this.videoElement === null) {
        throw new Error("Disposed player");
      }
      if (this._priv_contentInfos === null) {
        throw new Error("player: no content loaded");
      }
      const { isDirectFile, manifest } = this._priv_contentInfos;
      if (!isDirectFile && manifest === null) {
        throw new Error("player: the content did not load yet");
      }
      let positionWanted;
      if (typeof time === "number") {
        positionWanted = time;
      } else if (typeof time === "object") {
        const timeObj = time;
        const currentTs = this.videoElement.currentTime;
        if (!isNullOrUndefined(timeObj.relative)) {
          positionWanted = currentTs + timeObj.relative;
        } else if (!isNullOrUndefined(timeObj.position)) {
          positionWanted = timeObj.position;
        } else if (!isNullOrUndefined(timeObj.wallClockTime)) {
          if (manifest !== null) {
            positionWanted = timeObj.wallClockTime - ((_a = manifest.availabilityStartTime) != null ? _a : 0);
          } else if (isDirectFile && this.videoElement !== null) {
            const startDate = getStartDate(this.videoElement);
            if (startDate !== void 0) {
              positionWanted = timeObj.wallClockTime - startDate;
            }
          }
          if (positionWanted === void 0) {
            positionWanted = timeObj.wallClockTime;
          }
        } else {
          throw new Error(
            'invalid time object. You must set one of the following properties: "relative", "position" or "wallClockTime"'
          );
        }
      }
      if (positionWanted === void 0) {
        throw new Error("invalid time given");
      }
      log_default.info("API: API Seek to", positionWanted);
      this.videoElement.currentTime = positionWanted;
      return positionWanted;
    }
    /**
     * Returns the current player's audio volume on the media element.
     * From 0 (no audio) to 1 (maximum volume).
     * @returns {Number}
     */
    getVolume() {
      if (this.videoElement === null) {
        throw new Error("Disposed player");
      }
      return this.videoElement.volume;
    }
    /**
     * Set the player's audio volume. From 0 (no volume) to 1 (maximum volume).
     * @param {Number} volume
     */
    setVolume(volume) {
      if (this.videoElement === null) {
        throw new Error("Disposed player");
      }
      const videoElement = this.videoElement;
      if (volume !== videoElement.volume) {
        videoElement.volume = volume;
      }
    }
    /**
     * Returns `true` if audio is currently muted.
     * @returns {Boolean}
     */
    isMute() {
      var _a;
      return ((_a = this.videoElement) == null ? void 0 : _a.muted) === true;
    }
    /**
     * Mute audio.
     */
    mute() {
      if (this.videoElement === null) {
        throw new Error("Disposed player");
      }
      if (!this.videoElement.muted) {
        this.videoElement.muted = true;
      }
    }
    /**
     * Unmute audio.
     */
    unMute() {
      if (this.videoElement === null) {
        throw new Error("Disposed player");
      }
      if (this.videoElement.muted) {
        this.videoElement.muted = false;
      }
    }
    /**
     * Set the max buffer size for the buffer behind the current position.
     * Every buffer data before will be removed.
     * @param {Number} depthInSeconds
     */
    setMaxBufferBehind(depthInSeconds) {
      this._priv_bufferOptions.maxBufferBehind.setValue(depthInSeconds);
    }
    /**
     * Set the max buffer size for the buffer behind the current position.
     * Every buffer data before will be removed.
     * @param {Number} depthInSeconds
     */
    setMaxBufferAhead(depthInSeconds) {
      this._priv_bufferOptions.maxBufferAhead.setValue(depthInSeconds);
    }
    /**
     * Set the max buffer size for the buffer ahead of the current position.
     * The player will stop downloading chunks when this size is reached.
     * @param {Number} sizeInSeconds
     */
    setWantedBufferAhead(sizeInSeconds) {
      this._priv_bufferOptions.wantedBufferAhead.setValue(sizeInSeconds);
    }
    /**
     * Set the max buffer size the buffer should take in memory
     * The player . will stop downloading chunks when this size is reached.
     * @param {Number} sizeInKBytes
     */
    setMaxVideoBufferSize(sizeInKBytes) {
      this._priv_bufferOptions.maxVideoBufferSize.setValue(sizeInKBytes);
    }
    /**
     * Returns the max buffer size for the buffer behind the current position.
     * @returns {Number}
     */
    getMaxBufferBehind() {
      return this._priv_bufferOptions.maxBufferBehind.getValue();
    }
    /**
     * Returns the max buffer size for the buffer behind the current position.
     * @returns {Number}
     */
    getMaxBufferAhead() {
      return this._priv_bufferOptions.maxBufferAhead.getValue();
    }
    /**
     * Returns the max buffer size for the buffer ahead of the current position.
     * @returns {Number}
     */
    getWantedBufferAhead() {
      return this._priv_bufferOptions.wantedBufferAhead.getValue();
    }
    /**
     * Returns the max buffer memory size for the buffer in kilobytes
     * @returns {Number}
     */
    getMaxVideoBufferSize() {
      return this._priv_bufferOptions.maxVideoBufferSize.getValue();
    }
    getCurrentPeriod() {
      var _a;
      const currentPeriod = (_a = this._priv_contentInfos) == null ? void 0 : _a.currentPeriod;
      if (isNullOrUndefined(currentPeriod)) {
        return null;
      }
      return {
        id: currentPeriod.id,
        start: currentPeriod.start,
        end: currentPeriod.end
      };
    }
    /**
     * Returns both the name of the key system (e.g. `"com.widevine.alpha"`) and
     * the `MediaKeySystemConfiguration` currently associated to the
     * HTMLMediaElement linked to the RxPlayer.
     *
     * Returns `null` if no such capabilities is associated or if unknown.
     * @returns {Object|null}
     */
    getKeySystemConfiguration() {
      if (this.videoElement === null) {
        throw new Error("Disposed player");
      }
      const values = getKeySystemConfiguration(this.videoElement);
      if (values === null) {
        return null;
      }
      return { keySystem: values[0], configuration: values[1] };
    }
    /**
     * Returns the list of available Periods for which the current audio, video or
     * text track can now be changed.
     * @returns {Array.<Object>}
     */
    getAvailablePeriods() {
      if (this._priv_contentInfos === null) {
        return [];
      }
      const { isDirectFile, tracksStore } = this._priv_contentInfos;
      if (isDirectFile) {
        return [];
      }
      if (tracksStore === null) {
        return [];
      }
      return tracksStore.getAvailablePeriods().slice();
    }
    /**
     * Returns every available audio tracks for a given Period - or the current
     * one if no `periodId` is given.
     * @param {string|Object|undefined} [arg]
     * @returns {Array.<Object>}
     */
    getAvailableAudioTracks(arg) {
      var _a, _b;
      if (this._priv_contentInfos === null) {
        return [];
      }
      const { isDirectFile, mediaElementTracksStore } = this._priv_contentInfos;
      if (isDirectFile) {
        return (_a = mediaElementTracksStore == null ? void 0 : mediaElementTracksStore.getAvailableAudioTracks()) != null ? _a : [];
      }
      let periodId;
      let filterPlayableRepresentations;
      if (typeof arg === "string") {
        periodId = arg;
      } else {
        periodId = arg == null ? void 0 : arg.periodId;
        filterPlayableRepresentations = (_b = arg == null ? void 0 : arg.filterPlayableRepresentations) != null ? _b : true;
      }
      return this._priv_callTracksStoreGetterSetter(
        periodId,
        [],
        (tcm, periodRef) => {
          var _a2;
          return (_a2 = tcm.getAvailableAudioTracks(periodRef, filterPlayableRepresentations)) != null ? _a2 : [];
        }
      );
    }
    /**
     * Returns every available text tracks for a given Period - or the current
     * one if no `periodId` is given.
     * @param {string|undefined} [periodId]
     * @returns {Array.<Object>}
     */
    getAvailableTextTracks(periodId) {
      var _a;
      if (this._priv_contentInfos === null) {
        return [];
      }
      const { isDirectFile, mediaElementTracksStore } = this._priv_contentInfos;
      if (isDirectFile) {
        return (_a = mediaElementTracksStore == null ? void 0 : mediaElementTracksStore.getAvailableTextTracks()) != null ? _a : [];
      }
      return this._priv_callTracksStoreGetterSetter(
        periodId,
        [],
        (tcm, periodRef) => {
          var _a2;
          return (_a2 = tcm.getAvailableTextTracks(periodRef)) != null ? _a2 : [];
        }
      );
    }
    /**
     * Returns every available video tracks for the current Period.
     * @param {string|Object|undefined} [arg]
     * @returns {Array.<Object>}
     */
    getAvailableVideoTracks(arg) {
      var _a, _b;
      if (this._priv_contentInfos === null) {
        return [];
      }
      const { isDirectFile, mediaElementTracksStore } = this._priv_contentInfos;
      if (isDirectFile) {
        return (_a = mediaElementTracksStore == null ? void 0 : mediaElementTracksStore.getAvailableVideoTracks()) != null ? _a : [];
      }
      let periodId;
      let filterPlayableRepresentations;
      if (typeof arg === "string") {
        periodId = arg;
      } else {
        periodId = arg == null ? void 0 : arg.periodId;
        filterPlayableRepresentations = (_b = arg == null ? void 0 : arg.filterPlayableRepresentations) != null ? _b : true;
      }
      return this._priv_callTracksStoreGetterSetter(
        periodId,
        [],
        (tcm, periodRef) => {
          var _a2;
          return (_a2 = tcm.getAvailableVideoTracks(periodRef, filterPlayableRepresentations)) != null ? _a2 : [];
        }
      );
    }
    /**
     * Returns currently chosen audio language for the current Period.
     * @param {string|Object|undefined} [arg]
     * @returns {Object|null|undefined}
     */
    getAudioTrack(arg) {
      var _a;
      if (this._priv_contentInfos === null) {
        return void 0;
      }
      const { isDirectFile, mediaElementTracksStore } = this._priv_contentInfos;
      if (isDirectFile) {
        if (mediaElementTracksStore === null) {
          return void 0;
        }
        return mediaElementTracksStore.getChosenAudioTrack();
      }
      let periodId;
      let filterPlayableRepresentations;
      if (typeof arg === "string") {
        periodId = arg;
      } else {
        periodId = arg == null ? void 0 : arg.periodId;
        filterPlayableRepresentations = (_a = arg == null ? void 0 : arg.filterPlayableRepresentations) != null ? _a : true;
      }
      return this._priv_callTracksStoreGetterSetter(
        periodId,
        void 0,
        (tcm, periodRef) => tcm.getChosenAudioTrack(periodRef, filterPlayableRepresentations)
      );
    }
    /**
     * Returns currently chosen subtitle for the current Period.
     * @param {string|undefined} [periodId]
     * @returns {Object|null|undefined}
     */
    getTextTrack(periodId) {
      if (this._priv_contentInfos === null) {
        return void 0;
      }
      const { isDirectFile, mediaElementTracksStore } = this._priv_contentInfos;
      if (isDirectFile) {
        if (mediaElementTracksStore === null) {
          return void 0;
        }
        return mediaElementTracksStore.getChosenTextTrack();
      }
      return this._priv_callTracksStoreGetterSetter(
        periodId,
        void 0,
        (tcm, periodRef) => tcm.getChosenTextTrack(periodRef)
      );
    }
    /**
     * Returns currently chosen video track for the current Period.
     * @param {string|Object|undefined} [arg]
     * @returns {Object|null|undefined}
     */
    getVideoTrack(arg) {
      var _a;
      if (this._priv_contentInfos === null) {
        return void 0;
      }
      const { isDirectFile, mediaElementTracksStore } = this._priv_contentInfos;
      if (isDirectFile) {
        if (mediaElementTracksStore === null) {
          return void 0;
        }
        return mediaElementTracksStore.getChosenVideoTrack();
      }
      let periodId;
      let filterPlayableRepresentations;
      if (typeof arg === "string") {
        periodId = arg;
      } else {
        periodId = arg == null ? void 0 : arg.periodId;
        filterPlayableRepresentations = (_a = arg == null ? void 0 : arg.filterPlayableRepresentations) != null ? _a : true;
      }
      return this._priv_callTracksStoreGetterSetter(
        periodId,
        void 0,
        (tcm, periodRef) => tcm.getChosenVideoTrack(periodRef, filterPlayableRepresentations)
      );
    }
    /**
     * Update the audio language for the current Period.
     * @param {string | object} arg
     * @throws Error - the current content has no TracksStore.
     * @throws Error - the given id is linked to no audio track.
     */
    setAudioTrack(arg) {
      var _a;
      if (this._priv_contentInfos === null) {
        throw new Error("No content loaded");
      }
      const { isDirectFile, mediaElementTracksStore } = this._priv_contentInfos;
      if (isDirectFile) {
        try {
          const audioId = typeof arg === "string" ? arg : arg.trackId;
          mediaElementTracksStore == null ? void 0 : mediaElementTracksStore.setAudioTrackById(audioId);
          return;
        } catch (_e) {
          throw new Error("player: unknown audio track");
        }
      }
      let periodId;
      let trackId;
      let switchingMode;
      let lockedRepresentations = null;
      let relativeResumingPosition;
      if (typeof arg === "string") {
        trackId = arg;
      } else {
        trackId = arg.trackId;
        periodId = arg.periodId;
        switchingMode = arg.switchingMode;
        lockedRepresentations = (_a = arg.lockedRepresentations) != null ? _a : null;
        relativeResumingPosition = arg.relativeResumingPosition;
      }
      return this._priv_callTracksStoreGetterSetter(
        periodId,
        void 0,
        (tcm, periodRef) => tcm.setAudioTrack({
          periodRef,
          trackId,
          switchingMode,
          lockedRepresentations,
          relativeResumingPosition
        })
      );
    }
    /**
     * Update the text language for the current Period.
     * @param {string | Object} arg
     * @throws Error - the current content has no TracksStore.
     * @throws Error - the given id is linked to no text track.
     */
    setTextTrack(arg) {
      if (this._priv_contentInfos === null) {
        throw new Error("No content loaded");
      }
      const { isDirectFile, mediaElementTracksStore } = this._priv_contentInfos;
      if (isDirectFile) {
        try {
          const textId = typeof arg === "string" ? arg : arg.trackId;
          mediaElementTracksStore == null ? void 0 : mediaElementTracksStore.setTextTrackById(textId);
          return;
        } catch (_e) {
          throw new Error("player: unknown text track");
        }
      }
      let periodId;
      let trackId;
      if (typeof arg === "string") {
        trackId = arg;
      } else {
        trackId = arg.trackId;
        periodId = arg.periodId;
      }
      return this._priv_callTracksStoreGetterSetter(
        periodId,
        void 0,
        (tcm, periodRef) => tcm.setTextTrack(periodRef, trackId)
      );
    }
    /**
     * Disable subtitles for the current content.
     * @param {string|undefined} [periodId]
     */
    disableTextTrack(periodId) {
      if (this._priv_contentInfos === null) {
        return;
      }
      const { isDirectFile, mediaElementTracksStore } = this._priv_contentInfos;
      if (isDirectFile) {
        mediaElementTracksStore == null ? void 0 : mediaElementTracksStore.disableTextTrack();
        return;
      }
      return this._priv_callTracksStoreGetterSetter(
        periodId,
        void 0,
        (tcm, periodRef) => tcm.disableTrack(periodRef, "text")
      );
    }
    /**
     * Update the video track for the current Period.
     * @param {string | Object} arg
     * @throws Error - the current content has no TracksStore.
     * @throws Error - the given id is linked to no video track.
     */
    setVideoTrack(arg) {
      var _a;
      if (this._priv_contentInfos === null) {
        throw new Error("No content loaded");
      }
      const { isDirectFile, mediaElementTracksStore } = this._priv_contentInfos;
      if (isDirectFile) {
        try {
          const videoId = typeof arg === "string" ? arg : arg.trackId;
          mediaElementTracksStore == null ? void 0 : mediaElementTracksStore.setVideoTrackById(videoId);
          return;
        } catch (_e) {
          throw new Error("player: unknown video track");
        }
      }
      let periodId;
      let trackId;
      let switchingMode;
      let lockedRepresentations = null;
      let relativeResumingPosition;
      if (typeof arg === "string") {
        trackId = arg;
      } else {
        trackId = arg.trackId;
        periodId = arg.periodId;
        switchingMode = arg.switchingMode;
        lockedRepresentations = (_a = arg.lockedRepresentations) != null ? _a : null;
        relativeResumingPosition = arg.relativeResumingPosition;
      }
      return this._priv_callTracksStoreGetterSetter(
        periodId,
        void 0,
        (tcm, periodRef) => tcm.setVideoTrack({
          periodRef,
          trackId,
          switchingMode,
          lockedRepresentations,
          relativeResumingPosition
        })
      );
    }
    /**
     * Disable video track for the current content.
     * @param {string|undefined} [periodId]
     */
    disableVideoTrack(periodId) {
      if (this._priv_contentInfos === null) {
        return;
      }
      const { isDirectFile, mediaElementTracksStore } = this._priv_contentInfos;
      if (isDirectFile && mediaElementTracksStore !== null) {
        return mediaElementTracksStore.disableVideoTrack();
      }
      return this._priv_callTracksStoreGetterSetter(
        periodId,
        void 0,
        (tcm, periodRef) => tcm.disableTrack(periodRef, "video")
      );
    }
    lockVideoRepresentations(arg) {
      if (this._priv_contentInfos === null) {
        throw new Error("No content loaded");
      }
      const { isDirectFile } = this._priv_contentInfos;
      if (isDirectFile) {
        throw new Error("Cannot lock video Representations in directfile mode.");
      }
      let repsId;
      let periodId;
      let switchingMode;
      if (Array.isArray(arg)) {
        repsId = arg;
        periodId = void 0;
      } else {
        repsId = arg.representations;
        periodId = arg.periodId;
        switchingMode = arg.switchingMode;
      }
      return this._priv_callTracksStoreGetterSetter(
        periodId,
        void 0,
        (tcm, periodRef) => tcm.lockVideoRepresentations(periodRef, {
          representations: repsId,
          switchingMode
        })
      );
    }
    lockAudioRepresentations(arg) {
      if (this._priv_contentInfos === null) {
        throw new Error("No content loaded");
      }
      const { isDirectFile } = this._priv_contentInfos;
      if (isDirectFile) {
        throw new Error("Cannot lock audio Representations in directfile mode.");
      }
      let repsId;
      let periodId;
      let switchingMode;
      if (Array.isArray(arg)) {
        repsId = arg;
        periodId = void 0;
      } else {
        repsId = arg.representations;
        periodId = arg.periodId;
        switchingMode = arg.switchingMode;
      }
      return this._priv_callTracksStoreGetterSetter(
        periodId,
        void 0,
        (tcm, periodRef) => tcm.lockAudioRepresentations(periodRef, {
          representations: repsId,
          switchingMode
        })
      );
    }
    getLockedVideoRepresentations(periodId) {
      if (this._priv_contentInfos === null) {
        return null;
      }
      const { isDirectFile } = this._priv_contentInfos;
      if (isDirectFile) {
        return null;
      }
      return this._priv_callTracksStoreGetterSetter(
        periodId,
        null,
        (tcm, periodRef) => tcm.getLockedVideoRepresentations(periodRef)
      );
    }
    getLockedAudioRepresentations(periodId) {
      if (this._priv_contentInfos === null) {
        return null;
      }
      const { isDirectFile } = this._priv_contentInfos;
      if (isDirectFile) {
        return null;
      }
      return this._priv_callTracksStoreGetterSetter(
        periodId,
        null,
        (tcm, periodRef) => tcm.getLockedAudioRepresentations(periodRef)
      );
    }
    unlockVideoRepresentations(periodId) {
      if (this._priv_contentInfos === null) {
        return;
      }
      const { isDirectFile } = this._priv_contentInfos;
      if (isDirectFile) {
        return;
      }
      return this._priv_callTracksStoreGetterSetter(
        periodId,
        void 0,
        (tcm, periodRef) => tcm.unlockVideoRepresentations(periodRef)
      );
    }
    unlockAudioRepresentations(periodId) {
      if (this._priv_contentInfos === null) {
        return;
      }
      const { isDirectFile } = this._priv_contentInfos;
      if (isDirectFile) {
        return;
      }
      return this._priv_callTracksStoreGetterSetter(
        periodId,
        void 0,
        (tcm, periodRef) => tcm.unlockAudioRepresentations(periodRef)
      );
    }
    /**
     * Get minimum seek-able position.
     * @returns {number}
     */
    getMinimumPosition() {
      if (this._priv_contentInfos === null) {
        return null;
      }
      if (this._priv_contentInfos.isDirectFile) {
        return 0;
      }
      const { manifest } = this._priv_contentInfos;
      if (manifest !== null) {
        return getMinimumSafePosition(manifest);
      }
      return null;
    }
    /**
     * Returns the current position for live contents.
     *
     * Returns `null` if no content is loaded or if the current loaded content is
     * not considered as a live content.
     * Returns `undefined` if that live position is currently unknown.
     * @returns {number}
     */
    getLivePosition() {
      if (this._priv_contentInfos === null) {
        return null;
      }
      const { isDirectFile, manifest } = this._priv_contentInfos;
      if (isDirectFile) {
        return void 0;
      }
      if ((manifest == null ? void 0 : manifest.isLive) !== true) {
        return null;
      }
      return getLivePosition(manifest);
    }
    /**
     * Get maximum seek-able position.
     * @returns {number}
     */
    getMaximumPosition() {
      if (this._priv_contentInfos === null) {
        return null;
      }
      const { isDirectFile, manifest } = this._priv_contentInfos;
      if (isDirectFile) {
        if (this.videoElement === null) {
          throw new Error("Disposed player");
        }
        return this.videoElement.duration;
      }
      if (manifest !== null) {
        if (!manifest.isDynamic && this.videoElement !== null) {
          return this.videoElement.duration;
        }
        return getMaximumSafePosition(manifest);
      }
      return null;
    }
    // ---- Undocumented Private methods. ----
    //
    // Those methods are just here either to allow some tools relying on the
    // RxPlayer instance to work or to improve the RxPlayer's demo.
    //
    // They should not be used by any external code.
    /**
     * Used for the display of segmentSink metrics for the debug element
     * @param fn
     * @param cancellationSignal
     * @returns
     */
    async __priv_getSegmentSinkMetrics() {
      var _a, _b;
      return (_b = (_a = this._priv_contentInfos) == null ? void 0 : _a.segmentSinkMetricsCallback) == null ? void 0 : _b.call(_a);
    }
    /**
     * /!\ For tools use only! Do not touch!
     *
     * Returns manifest/playlist object.
     * null if the player is STOPPED.
     * @returns {Manifest|null} - The current Manifest (`null` when not known).
     */
    // TODO remove the need for that public method
    __priv_getManifest() {
      if (this._priv_contentInfos === null) {
        return null;
      }
      return this._priv_contentInfos.manifest;
    }
    // TODO remove the need for that public method
    __priv_getCurrentAdaptation() {
      if (this._priv_contentInfos === null) {
        return null;
      }
      const { currentPeriod, activeAdaptations } = this._priv_contentInfos;
      if (currentPeriod === null || activeAdaptations === null || isNullOrUndefined(activeAdaptations[currentPeriod.id])) {
        return null;
      }
      return activeAdaptations[currentPeriod.id];
    }
    // TODO remove the need for that public method
    __priv_getCurrentRepresentations() {
      if (this._priv_contentInfos === null) {
        return null;
      }
      const { currentPeriod, activeRepresentations } = this._priv_contentInfos;
      if (currentPeriod === null || activeRepresentations === null || isNullOrUndefined(activeRepresentations[currentPeriod.id])) {
        return null;
      }
      return activeRepresentations[currentPeriod.id];
    }
    // ---- Private methods ----
    /**
     * Reset all state properties relative to a playing content.
     */
    _priv_cleanUpCurrentContentState() {
      var _a, _b, _c, _d;
      log_default.debug("Locking `contentLock` to clean-up the current content.");
      this._priv_contentLock.setValue(true);
      (_b = (_a = this._priv_contentInfos) == null ? void 0 : _a.tracksStore) == null ? void 0 : _b.dispose();
      (_d = (_c = this._priv_contentInfos) == null ? void 0 : _c.mediaElementTracksStore) == null ? void 0 : _d.dispose();
      this._priv_contentInfos = null;
      this._priv_contentEventsMemory = {};
      const freeUpContentLock = () => {
        if (this.videoElement !== null) {
          log_default.debug("Unlocking `contentLock`. Next content can begin.");
          this._priv_contentLock.setValue(false);
        }
      };
      if (!isNullOrUndefined(this.videoElement)) {
        clearOnStop(this.videoElement).then(
          () => {
            log_default.debug("API: DRM session cleaned-up with success!");
            freeUpContentLock();
          },
          (err) => {
            log_default.error(
              "API: An error arised when trying to clean-up the DRM session:" + (err instanceof Error ? err.toString() : "Unknown Error")
            );
            freeUpContentLock();
          }
        );
      } else {
        freeUpContentLock();
      }
    }
    /**
     * Triggered when the Manifest has been loaded for the current content.
     * Initialize various private properties and emit initial event.
     * @param {Object} contentInfos
     * @param {Object} manifest
     */
    _priv_onManifestReady(contentInfos, manifest) {
      var _a;
      if (contentInfos.contentId !== ((_a = this._priv_contentInfos) == null ? void 0 : _a.contentId)) {
        return;
      }
      contentInfos.manifest = manifest;
      if (manifest.manifestFormat === 0 /* Class */) {
        this._priv_reloadingMetadata.manifest = manifest;
      }
      const tracksStore = new tracks_store_default({
        preferTrickModeTracks: this._priv_preferTrickModeTracks,
        defaultAudioTrackSwitchingMode: contentInfos.defaultAudioTrackSwitchingMode
      });
      contentInfos.tracksStore = tracksStore;
      tracksStore.addEventListener("newAvailablePeriods", (p) => {
        this.trigger("newAvailablePeriods", p);
      });
      tracksStore.addEventListener("brokenRepresentationsLock", (e) => {
        this.trigger("brokenRepresentationsLock", e);
      });
      tracksStore.addEventListener("trackUpdate", (e) => {
        var _a2, _b;
        this.trigger("trackUpdate", e);
        const currentPeriod = (_b = (_a2 = this._priv_contentInfos) == null ? void 0 : _a2.currentPeriod) != null ? _b : void 0;
        if (e.reason === "no-playable-representation" && e.period.id === (currentPeriod == null ? void 0 : currentPeriod.id)) {
          this._priv_onAvailableTracksMayHaveChanged(e.trackType);
        }
      });
      contentInfos.tracksStore.addEventListener("warning", (err) => {
        this.trigger("warning", err);
      });
      contentInfos.tracksStore.addEventListener("error", (err) => {
        this._priv_onFatalError(err, contentInfos);
      });
      contentInfos.tracksStore.onManifestUpdate(manifest);
    }
    /**
     * Triggered when the Manifest has been updated for the current content.
     * Initialize various private properties and emit initial event.
     * @param {Object} contentInfos
     * @param {Object} updates
     */
    _priv_onManifestUpdate(contentInfos, updates) {
      var _a, _b, _c;
      if (this._priv_contentInfos === null || this._priv_contentInfos.manifest === null) {
        return;
      }
      if (!isNullOrUndefined(contentInfos == null ? void 0 : contentInfos.tracksStore)) {
        contentInfos.tracksStore.onManifestUpdate(this._priv_contentInfos.manifest);
      }
      const currentPeriod = (_b = (_a = this._priv_contentInfos) == null ? void 0 : _a.currentPeriod) != null ? _b : void 0;
      const currTracksStore = (_c = this._priv_contentInfos) == null ? void 0 : _c.tracksStore;
      if (currentPeriod === void 0 || isNullOrUndefined(currTracksStore)) {
        return;
      }
      for (const update of updates.updatedPeriods) {
        if (update.period.id === currentPeriod.id) {
          if (update.result.addedAdaptations.length > 0 || update.result.removedAdaptations.length > 0) {
            const periodRef = currTracksStore.getPeriodObjectFromPeriod(currentPeriod);
            if (periodRef === void 0) {
              return;
            }
            this._priv_onAvailableTracksMayHaveChanged("audio");
            this._priv_onAvailableTracksMayHaveChanged("text");
            this._priv_onAvailableTracksMayHaveChanged("video");
          }
        }
      }
    }
    /**
     * Triggered each times the support for a codec has changed in the manifest.
     * When triggered, the track store may need to consider selecting a new track.
     *
     * @param {Object} contentInfos
     */
    _priv_onCodecSupportUpdate(contentInfos) {
      const tStore = contentInfos == null ? void 0 : contentInfos.tracksStore;
      if (isNullOrUndefined(tStore)) {
        return;
      }
      tStore.onManifestCodecSupportUpdate();
    }
    _priv_onDecipherabilityUpdate(contentInfos, elts) {
      if (contentInfos === null || contentInfos.manifest === null) {
        return;
      }
      if (!isNullOrUndefined(contentInfos == null ? void 0 : contentInfos.tracksStore)) {
        contentInfos.tracksStore.onDecipherabilityUpdates();
      }
      const periodsAndTrackTypes = elts.reduce(
        (acc, elt) => {
          var _a, _b, _c;
          const isFound = arrayFind(
            acc,
            (x) => x[0].id === elt.period.id && x[1] === elt.adaptation.type
          ) !== void 0;
          if (!isFound) {
            const tStore = contentInfos.tracksStore;
            if (tStore === null) {
              return acc;
            }
            let isCurrent = false;
            const periodRef = tStore.getPeriodObjectFromPeriod(elt.period);
            if (periodRef === void 0) {
              return acc;
            }
            switch (elt.adaptation.type) {
              case "audio":
                isCurrent = ((_a = tStore.getChosenAudioTrack(periodRef, false)) == null ? void 0 : _a.id) === elt.adaptation.id;
                break;
              case "video":
                isCurrent = ((_b = tStore.getChosenVideoTrack(periodRef, false)) == null ? void 0 : _b.id) === elt.adaptation.id;
                break;
              case "text":
                isCurrent = ((_c = tStore.getChosenTextTrack(periodRef)) == null ? void 0 : _c.id) === elt.adaptation.id;
                break;
            }
            if (isCurrent) {
              acc.push([elt.period, elt.adaptation.type]);
            }
          }
          return acc;
        },
        []
      );
      for (const [period, trackType] of periodsAndTrackTypes) {
        this._priv_triggerEventIfNotStopped(
          "representationListUpdate",
          {
            period: { start: period.start, end: period.end, id: period.id },
            trackType,
            reason: "decipherability-update"
          },
          contentInfos.currentContentCanceller.signal
        );
      }
    }
    /**
     * Triggered each times the current Period Changed.
     * Store and emit initial state for the Period.
     *
     * @param {Object} contentInfos
     * @param {Object} periodInfo
     */
    _priv_onActivePeriodChanged(contentInfos, { period }) {
      var _a, _b, _c, _d, _e, _f;
      if (contentInfos.contentId !== ((_a = this._priv_contentInfos) == null ? void 0 : _a.contentId)) {
        return;
      }
      contentInfos.currentPeriod = period;
      const cancelSignal = contentInfos.currentContentCanceller.signal;
      if (this._priv_contentEventsMemory.periodChange !== period) {
        this._priv_contentEventsMemory.periodChange = period;
        this._priv_triggerEventIfNotStopped(
          "periodChange",
          { start: period.start, end: period.end, id: period.id },
          cancelSignal
        );
      }
      this._priv_triggerEventIfNotStopped(
        "availableAudioTracksChange",
        this.getAvailableAudioTracks(),
        cancelSignal
      );
      this._priv_triggerEventIfNotStopped(
        "availableTextTracksChange",
        this.getAvailableTextTracks(),
        cancelSignal
      );
      this._priv_triggerEventIfNotStopped(
        "availableVideoTracksChange",
        this.getAvailableVideoTracks(),
        cancelSignal
      );
      const tracksStore = (_b = this._priv_contentInfos) == null ? void 0 : _b.tracksStore;
      if (!isNullOrUndefined(tracksStore)) {
        const periodRef = tracksStore.getPeriodObjectFromPeriod(period);
        if (periodRef) {
          const audioTrack = tracksStore.getChosenAudioTrack(periodRef, true);
          this._priv_triggerEventIfNotStopped("audioTrackChange", audioTrack, cancelSignal);
          const textTrack = tracksStore.getChosenTextTrack(periodRef);
          this._priv_triggerEventIfNotStopped("textTrackChange", textTrack, cancelSignal);
          const videoTrack = tracksStore.getChosenVideoTrack(periodRef, true);
          this._priv_triggerEventIfNotStopped("videoTrackChange", videoTrack, cancelSignal);
        }
      } else {
        this._priv_triggerEventIfNotStopped("audioTrackChange", null, cancelSignal);
        this._priv_triggerEventIfNotStopped("textTrackChange", null, cancelSignal);
        this._priv_triggerEventIfNotStopped("videoTrackChange", null, cancelSignal);
      }
      const audioRepresentation = (_d = (_c = this.__priv_getCurrentRepresentations()) == null ? void 0 : _c.audio) != null ? _d : null;
      this._priv_triggerEventIfNotStopped(
        "audioRepresentationChange",
        audioRepresentation,
        cancelSignal
      );
      const videoRepresentation = (_f = (_e = this.__priv_getCurrentRepresentations()) == null ? void 0 : _e.video) != null ? _f : null;
      this._priv_triggerEventIfNotStopped(
        "videoRepresentationChange",
        videoRepresentation,
        cancelSignal
      );
    }
    /**
     * Triggered each times a new "PeriodStream" is ready.
     * Choose the right Adaptation for the Period and emit it.
     * @param {Object} contentInfos
     * @param {Object} value
     */
    _priv_onPeriodStreamReady(contentInfos, value) {
      var _a;
      if (contentInfos.contentId !== ((_a = this._priv_contentInfos) == null ? void 0 : _a.contentId)) {
        return;
      }
      const { type, period, adaptationRef } = value;
      const tracksStore = contentInfos.tracksStore;
      switch (type) {
        case "video":
        case "audio":
        case "text":
          if (isNullOrUndefined(tracksStore)) {
            log_default.error(`API: TracksStore not instanciated for a new ${type} period`);
            adaptationRef.setValue(null);
          } else {
            tracksStore.addTrackReference(type, period, adaptationRef);
          }
          break;
        default:
          assertUnreachable(type);
      }
    }
    /**
     * Triggered each times we "remove" a PeriodStream.
     * @param {Object} contentInfos
     * @param {Object} value
     */
    _priv_onPeriodStreamCleared(contentInfos, value) {
      var _a;
      if (contentInfos.contentId !== ((_a = this._priv_contentInfos) == null ? void 0 : _a.contentId)) {
        return;
      }
      const { type, period } = value;
      const tracksStore = contentInfos.tracksStore;
      switch (type) {
        case "audio":
        case "text":
        case "video":
          if (!isNullOrUndefined(tracksStore)) {
            tracksStore.removeTrackReference(type, period);
          }
          break;
      }
      const { activeAdaptations, activeRepresentations } = contentInfos;
      if (!isNullOrUndefined(activeAdaptations) && !isNullOrUndefined(activeAdaptations[period.id])) {
        const activePeriodAdaptations = activeAdaptations[period.id];
        delete activePeriodAdaptations[type];
        if (Object.keys(activePeriodAdaptations).length === 0) {
          delete activeAdaptations[period.id];
        }
      }
      if (!isNullOrUndefined(activeRepresentations) && !isNullOrUndefined(activeRepresentations[period.id])) {
        const activePeriodRepresentations = activeRepresentations[period.id];
        delete activePeriodRepresentations[type];
        if (Object.keys(activePeriodRepresentations).length === 0) {
          delete activeRepresentations[period.id];
        }
      }
    }
    /**
     * Triggered each times a new Adaptation is considered for the current
     * content.
     * Store given Adaptation and emit it if from the current Period.
     * @param {Object} contentInfos
     * @param {Object} value
     */
    _priv_onAdaptationChange(contentInfos, {
      type,
      adaptation,
      period
    }) {
      var _a;
      if (contentInfos.contentId !== ((_a = this._priv_contentInfos) == null ? void 0 : _a.contentId)) {
        return;
      }
      if (contentInfos.activeAdaptations === null) {
        contentInfos.activeAdaptations = {};
      }
      const { activeAdaptations, currentPeriod } = contentInfos;
      const activePeriodAdaptations = activeAdaptations[period.id];
      if (isNullOrUndefined(activePeriodAdaptations)) {
        activeAdaptations[period.id] = { [type]: adaptation };
      } else {
        activePeriodAdaptations[type] = adaptation;
      }
      const { tracksStore } = contentInfos;
      const cancelSignal = contentInfos.currentContentCanceller.signal;
      if (tracksStore !== null && currentPeriod !== null && !isNullOrUndefined(period) && period.id === currentPeriod.id) {
        const periodRef = tracksStore.getPeriodObjectFromPeriod(period);
        if (periodRef === void 0) {
          return;
        }
        switch (type) {
          case "audio": {
            const audioTrack = tracksStore.getChosenAudioTrack(periodRef, true);
            this._priv_triggerEventIfNotStopped(
              "audioTrackChange",
              audioTrack,
              cancelSignal
            );
            break;
          }
          case "text": {
            const textTrack = tracksStore.getChosenTextTrack(periodRef);
            this._priv_triggerEventIfNotStopped("textTrackChange", textTrack, cancelSignal);
            break;
          }
          case "video": {
            const videoTrack = tracksStore.getChosenVideoTrack(periodRef, true);
            this._priv_triggerEventIfNotStopped(
              "videoTrackChange",
              videoTrack,
              cancelSignal
            );
            break;
          }
        }
      }
    }
    /**
     * Triggered each times a new Representation is considered during playback.
     *
     * Store given Representation and emit it if from the current Period.
     *
     * @param {Object} contentInfos
     * @param {Object} obj
     */
    _priv_onRepresentationChange(contentInfos, {
      type,
      period,
      representation
    }) {
      var _a;
      if (contentInfos.contentId !== ((_a = this._priv_contentInfos) == null ? void 0 : _a.contentId)) {
        return;
      }
      if (contentInfos.activeRepresentations === null) {
        contentInfos.activeRepresentations = {};
      }
      const { activeRepresentations, currentPeriod } = contentInfos;
      const activePeriodRepresentations = activeRepresentations[period.id];
      if (isNullOrUndefined(activePeriodRepresentations)) {
        activeRepresentations[period.id] = { [type]: representation };
      } else {
        activePeriodRepresentations[type] = representation;
      }
      if (!isNullOrUndefined(period) && currentPeriod !== null && currentPeriod.id === period.id) {
        const cancelSignal = this._priv_contentInfos.currentContentCanceller.signal;
        if (type === "video") {
          this._priv_triggerEventIfNotStopped(
            "videoRepresentationChange",
            representation,
            cancelSignal
          );
        } else if (type === "audio") {
          this._priv_triggerEventIfNotStopped(
            "audioRepresentationChange",
            representation,
            cancelSignal
          );
        }
      }
    }
    /**
     * Triggered each time a bitrate estimate is calculated.
     *
     * Emit it.
     *
     * @param {Object} value
     */
    _priv_onBitrateEstimateChange({
      type,
      bitrate
    }) {
      if (bitrate !== void 0) {
        this._priv_bitrateInfos.lastBitrates[type] = bitrate;
      }
      this.trigger(
        // !!! undocumented API :O !!!
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        "__priv_bitrateEstimateChange",
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        { type, bitrate }
      );
    }
    /**
     * Triggered each time the player state updates.
     *
     * Trigger the right Player Event.
     *
     * @param {string} newState
     */
    _priv_setPlayerState(newState) {
      if (this.state !== newState) {
        this.state = newState;
        log_default.info("API: playerStateChange event", newState);
        this.trigger("playerStateChange", newState);
      }
    }
    /**
     * Triggered each time a playback observation.
     *
     * Trigger the right Player Event
     *
     * @param {Object} contentInfos
     * @param {Object} observation
     */
    _priv_triggerPositionUpdate(contentInfos, observation) {
      var _a, _b;
      if (contentInfos.contentId !== ((_a = this._priv_contentInfos) == null ? void 0 : _a.contentId)) {
        return;
      }
      const { isDirectFile, manifest } = contentInfos;
      if (!isDirectFile && manifest === null || isNullOrUndefined(observation)) {
        return;
      }
      const maximumPosition = manifest !== null ? getMaximumSafePosition(manifest) : void 0;
      const positionData = {
        position: observation.position.getPolled(),
        duration: observation.duration,
        playbackRate: observation.playbackRate,
        maximumPosition,
        // TODO bufferGap may be undefined
        bufferGap: observation.bufferGap === void 0 || !isFinite(observation.bufferGap) ? 0 : observation.bufferGap
      };
      if (manifest !== null && manifest.isLive && observation.position.getPolled() > 0) {
        const ast = (_b = manifest.availabilityStartTime) != null ? _b : 0;
        positionData.wallClockTime = observation.position.getPolled() + ast;
        const livePosition = getLivePosition(manifest);
        if (livePosition !== void 0) {
          positionData.liveGap = livePosition - observation.position.getPolled();
        }
      } else if (isDirectFile && this.videoElement !== null) {
        const startDate = getStartDate(this.videoElement);
        if (startDate !== void 0) {
          positionData.wallClockTime = startDate + observation.position.getPolled();
        }
      }
      this.trigger("positionUpdate", positionData);
    }
    /**
     * @param {string} evt
     * @param {*} arg
     * @param {Object} currentContentCancelSignal
     */
    _priv_triggerEventIfNotStopped(evt, arg, currentContentCancelSignal) {
      if (!currentContentCancelSignal.isCancelled()) {
        this.trigger(evt, arg);
      }
    }
    /**
     * @param {Object} cancelSignal
     * @returns {Object}
     */
    _priv_initializeMediaElementTracksStore(cancelSignal) {
      var _a, _b, _c;
      assert(
        features_default.directfile !== null,
        "Initializing `MediaElementTracksStore` without Directfile feature"
      );
      assert(
        this.videoElement !== null,
        "Initializing `MediaElementTracksStore` on a disposed RxPlayer"
      );
      const mediaElementTracksStore = new features_default.directfile.mediaElementTracksStore(
        this.videoElement
      );
      this._priv_triggerEventIfNotStopped(
        "availableAudioTracksChange",
        mediaElementTracksStore.getAvailableAudioTracks(),
        cancelSignal
      );
      this._priv_triggerEventIfNotStopped(
        "availableVideoTracksChange",
        mediaElementTracksStore.getAvailableVideoTracks(),
        cancelSignal
      );
      this._priv_triggerEventIfNotStopped(
        "availableTextTracksChange",
        mediaElementTracksStore.getAvailableTextTracks(),
        cancelSignal
      );
      this._priv_triggerEventIfNotStopped(
        "audioTrackChange",
        (_a = mediaElementTracksStore.getChosenAudioTrack()) != null ? _a : null,
        cancelSignal
      );
      this._priv_triggerEventIfNotStopped(
        "textTrackChange",
        (_b = mediaElementTracksStore.getChosenTextTrack()) != null ? _b : null,
        cancelSignal
      );
      this._priv_triggerEventIfNotStopped(
        "videoTrackChange",
        (_c = mediaElementTracksStore.getChosenVideoTrack()) != null ? _c : null,
        cancelSignal
      );
      mediaElementTracksStore.addEventListener(
        "availableVideoTracksChange",
        (val) => this.trigger("availableVideoTracksChange", val)
      );
      mediaElementTracksStore.addEventListener(
        "availableAudioTracksChange",
        (val) => this.trigger("availableAudioTracksChange", val)
      );
      mediaElementTracksStore.addEventListener(
        "availableTextTracksChange",
        (val) => this.trigger("availableTextTracksChange", val)
      );
      mediaElementTracksStore.addEventListener(
        "audioTrackChange",
        (val) => this.trigger("audioTrackChange", val)
      );
      mediaElementTracksStore.addEventListener(
        "videoTrackChange",
        (val) => this.trigger("videoTrackChange", val)
      );
      mediaElementTracksStore.addEventListener(
        "textTrackChange",
        (val) => this.trigger("textTrackChange", val)
      );
      return mediaElementTracksStore;
    }
    _priv_callTracksStoreGetterSetter(periodId, defaultValue, cb) {
      var _a, _b;
      if (this._priv_contentInfos === null || this._priv_contentInfos.tracksStore === null) {
        log_default.warn("API: Trying to call track API too soon");
        return defaultValue;
      }
      const { tracksStore } = this._priv_contentInfos;
      const currentPeriod = (_b = (_a = this._priv_contentInfos) == null ? void 0 : _a.currentPeriod) != null ? _b : void 0;
      const wantedPeriodId = periodId != null ? periodId : currentPeriod == null ? void 0 : currentPeriod.id;
      if (wantedPeriodId === void 0) {
        return defaultValue;
      }
      const periodRef = wantedPeriodId === (currentPeriod == null ? void 0 : currentPeriod.id) ? tracksStore.getPeriodObjectFromPeriod(currentPeriod) : tracksStore.getPeriodObjectFromId(wantedPeriodId);
      if (periodRef === void 0) {
        return defaultValue;
      }
      return cb(tracksStore, periodRef);
    }
    /**
     * Method to call when some event lead to a high for possibility that the
     * available tracks for the given type have changed.
     * Send the corresponding `available*Tracks` change event with the last
     * available tracks.
     *
     * @param {string} trackType
     * @param {Object|undefined} [oPeriodRef] - optional period object used by the
     * `tracksStore` API, allows to optimize the method by bypassing this step.
     */
    _priv_onAvailableTracksMayHaveChanged(trackType, oPeriodRef) {
      const contentInfos = this._priv_contentInfos;
      if (contentInfos === null) {
        return;
      }
      const { currentPeriod, tracksStore, currentContentCanceller } = contentInfos;
      const cancelSignal = currentContentCanceller.signal;
      if (isNullOrUndefined(currentPeriod) || tracksStore === null) {
        return;
      }
      const periodRef = oPeriodRef != null ? oPeriodRef : tracksStore.getPeriodObjectFromPeriod(currentPeriod);
      if (periodRef === void 0) {
        return;
      }
      switch (trackType) {
        case "video": {
          const videoTracks = tracksStore.getAvailableVideoTracks(periodRef, true);
          this._priv_triggerEventIfNotStopped(
            "availableVideoTracksChange",
            videoTracks != null ? videoTracks : [],
            cancelSignal
          );
          break;
        }
        case "audio": {
          const audioTracks = tracksStore.getAvailableAudioTracks(periodRef, true);
          this._priv_triggerEventIfNotStopped(
            "availableAudioTracksChange",
            audioTracks != null ? audioTracks : [],
            cancelSignal
          );
          break;
        }
        case "text": {
          const textTracks = tracksStore.getAvailableTextTracks(periodRef);
          this._priv_triggerEventIfNotStopped(
            "availableTextTracksChange",
            textTracks != null ? textTracks : [],
            cancelSignal
          );
          break;
        }
        default:
          assertUnreachable(trackType);
      }
    }
    /**
     * Method to call when a fatal error lead to the stopping of the current
     * content.
     *
     * @param {*} err - The error encountered.
     * @param {Object} contentInfos - The `IPublicApiContentInfos` object linked
     * to the content for which the error was received.
     */
    _priv_onFatalError(err, contentInfos) {
      const formattedError = formatError(err, {
        defaultCode: "NONE",
        defaultReason: "An unknown error stopped content playback."
      });
      formattedError.fatal = true;
      contentInfos.currentContentCanceller.cancel();
      this._priv_cleanUpCurrentContentState();
      this._priv_currentError = formattedError;
      log_default.error("API: The player stopped because of an error", formattedError);
      this._priv_setPlayerState("STOPPED" /* STOPPED */);
      if (this._priv_currentError === formattedError) {
        this.trigger("error", formattedError);
      }
    }
  };
  /**
   * Store all video elements currently in use by an RxPlayer instance.
   * This is used to check that a video element is not shared between multiple instances.
   * Use of a WeakSet ensure the object is garbage collected if it's not used anymore.
   */
  _Player._priv_currentlyUsedVideoElements = /* @__PURE__ */ new WeakSet();
  var Player = _Player;
  Player.version = /* PLAYER_VERSION */
  "4.1.0";
  var public_api_default = Player;

  // src/main_thread/api/index.ts
  var api_default = public_api_default;

  // src/minimal.ts
  patchWebkitSourceBuffer();
  if (isDebugModeEnabled()) {
    log_default.setLevel("DEBUG", "standard");
  } else if (define_ENVIRONMENT_default.CURRENT_ENV === define_ENVIRONMENT_default.DEV) {
    log_default.setLevel(define_LOGGER_LEVEL_default.CURRENT_LEVEL, "standard");
  }
  var minimal_default = api_default;

  // demo/scripts/controllers/Main.tsx
  var React45 = __toESM(require_react());

  // demo/scripts/components/GitHubButton.tsx
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var React = __toESM(require_react());

  // node_modules/github-buttons/dist/buttons.esm.js
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var document2 = window.document;
  var Math2 = window.Math;
  var HTMLElement2 = window.HTMLElement;
  var XMLHttpRequest2 = window.XMLHttpRequest;
  var forEach = function(obj, func) {
    for (var i = 0, len = obj.length; i < len; i++) {
      func(obj[i]);
    }
  };
  var createElementInDocument = function(document3) {
    return function(tag, props, children) {
      var el = document3.createElement(tag);
      if (props != null) {
        for (var prop in props) {
          var val = props[prop];
          if (val != null) {
            if (el[prop] != null) {
              el[prop] = val;
            } else {
              el.setAttribute(prop, val);
            }
          }
        }
      }
      if (children != null) {
        forEach(children, function(child) {
          el.appendChild(typeof child === "string" ? document3.createTextNode(child) : child);
        });
      }
      return el;
    };
  };
  var createElement = createElementInDocument(document2);
  var dispatchOnce = function(func) {
    var onceToken;
    return function() {
      if (!onceToken) {
        onceToken = 1;
        func.apply(this, arguments);
      }
    };
  };
  var hasOwnProperty = function(obj, prop) {
    return {}.hasOwnProperty.call(obj, prop);
  };
  var toLowerCase = function(obj) {
    return ("" + obj).toLowerCase();
  };
  var name = "github-buttons";
  var version = "2.28.1";
  var iframeURL = "https://" + /* istanbul ignore next */
  ("unpkg.com/" + name + "@" + version + "/dist") + "/buttons.html";
  var domain = "github.com";
  var apiBaseURL = "https://api." + domain;
  var useXHR = XMLHttpRequest2 && "prototype" in XMLHttpRequest2 && "withCredentials" in XMLHttpRequest2.prototype;
  var useShadowDOM = useXHR && HTMLElement2 && "attachShadow" in HTMLElement2.prototype && !("prototype" in HTMLElement2.prototype.attachShadow);
  var onEvent = function(target, eventName, func) {
    if (target.addEventListener) {
      target.addEventListener(eventName, func, false);
    } else {
      target.attachEvent("on" + eventName, func);
    }
  };
  var offEvent = function(target, eventName, func) {
    if (target.removeEventListener) {
      target.removeEventListener(eventName, func, false);
    } else {
      target.detachEvent("on" + eventName, func);
    }
  };
  var onceEvent = function(target, eventName, func) {
    var callback = function() {
      offEvent(target, eventName, callback);
      return func.apply(this, arguments);
    };
    onEvent(target, eventName, callback);
  };
  var onceReadyStateChange = (
    /* istanbul ignore next: IE lt 9 */
    function(target, regex, func) {
      if (target.readyState != null) {
        var eventName = "readystatechange";
        var callback = function() {
          if (regex.test(target.readyState)) {
            offEvent(target, eventName, callback);
            return func.apply(this, arguments);
          }
        };
        onEvent(target, eventName, callback);
      }
    }
  );
  var parseOptions = function(anchor) {
    var options = {
      href: anchor.href,
      title: anchor.title,
      "aria-label": anchor.getAttribute("aria-label")
    };
    forEach(["icon", "color-scheme", "text", "size", "show-count"], function(option) {
      var attribute = "data-" + option;
      options[attribute] = anchor.getAttribute(attribute);
    });
    if (options["data-text"] == null) {
      options["data-text"] = anchor.textContent || anchor.innerText;
    }
    return options;
  };
  var buttonsCssText = "body{margin:0}a{text-decoration:none;outline:0}.widget{display:inline-block;overflow:hidden;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Helvetica,Arial,sans-serif;font-size:0;line-height:0;white-space:nowrap}.btn,.social-count{position:relative;display:inline-block;display:inline-flex;height:14px;padding:2px 5px;font-size:11px;font-weight:600;line-height:14px;vertical-align:bottom;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;background-repeat:repeat-x;background-position:-1px -1px;background-size:110% 110%;border:1px solid}.btn{border-radius:.25em}.btn:not(:last-child){border-radius:.25em 0 0 .25em}.social-count{border-left:0;border-radius:0 .25em .25em 0}.widget-lg .btn,.widget-lg .social-count{height:16px;padding:5px 10px;font-size:12px;line-height:16px}.octicon{display:inline-block;vertical-align:text-top;fill:currentColor;overflow:visible}";
  var light = `.btn:focus-visible,.social-count:focus-visible{outline:2px solid #0969da;outline-offset:-2px}.btn{color:#24292f;background-color:#ebf0f4;border-color:#d0d7de;background-image:url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg'%3e%3clinearGradient id='o' x2='0' y2='1'%3e%3cstop stop-color='%23f6f8fa'/%3e%3cstop offset='90%25' stop-color='%23ebf0f4'/%3e%3c/linearGradient%3e%3crect width='100%25' height='100%25' fill='url(%23o)'/%3e%3c/svg%3e");background-image:-moz-linear-gradient(top, #f6f8fa, #ebf0f4 90%);background-image:linear-gradient(180deg, #f6f8fa, #ebf0f4 90%);filter:progid:DXImageTransform.Microsoft.Gradient(startColorstr='#FFF6F8FA', endColorstr='#FFEAEFF3')}:root .btn{filter:none}.btn:hover,.btn:focus{background-color:#e4e9ed;background-position:0 -0.5em;border-color:#d0d7de;background-image:url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg'%3e%3clinearGradient id='o' x2='0' y2='1'%3e%3cstop stop-color='%23eef1f4'/%3e%3cstop offset='90%25' stop-color='%23e4e9ed'/%3e%3c/linearGradient%3e%3crect width='100%25' height='100%25' fill='url(%23o)'/%3e%3c/svg%3e");background-image:-moz-linear-gradient(top, #eef1f4, #e4e9ed 90%);background-image:linear-gradient(180deg, #eef1f4, #e4e9ed 90%);filter:progid:DXImageTransform.Microsoft.Gradient(startColorstr='#FFEEF1F4', endColorstr='#FFE3E8EC')}:root .btn:hover,:root .btn:focus{filter:none}.btn:active{background-color:#e7ebef;border-color:#d0d7de;background-image:none;filter:none}.social-count{color:#24292f;background-color:#fff;border-color:#d0d7de}.social-count:hover,.social-count:focus{color:#0969da}.octicon-heart{color:#bf3989}`;
  var lightHighContrast = ".btn:focus-visible,.social-count:focus-visible{outline:2px solid #0349b4;outline-offset:-2px}.btn{color:#0e1116;background-color:#e7ecf0;border-color:#20252c;background-image:none;filter:none}.btn:hover,.btn:focus{background-color:#d1d9df;background-position:0 -0.5em;border-color:#20252c;background-image:none;filter:none}.btn:active{background-color:#cfd6dd;border-color:#20252c}.social-count{color:#0e1116;background-color:#fff;border-color:#20252c}.social-count:hover,.social-count:focus{color:#023b95}.octicon-heart{color:#7d0c57}";
  var dark = `.btn:focus-visible,.social-count:focus-visible{outline:2px solid #1f6feb;outline-offset:-2px}.btn{color:#c9d1d9;background-color:#1a1e23;border-color:#30363d;background-image:url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg'%3e%3clinearGradient id='o' x2='0' y2='1'%3e%3cstop stop-color='%2321262d'/%3e%3cstop offset='90%25' stop-color='%231a1e23'/%3e%3c/linearGradient%3e%3crect width='100%25' height='100%25' fill='url(%23o)'/%3e%3c/svg%3e");background-image:-moz-linear-gradient(top, #21262d, #1a1e23 90%);background-image:linear-gradient(180deg, #21262d, #1a1e23 90%);filter:progid:DXImageTransform.Microsoft.Gradient(startColorstr='#FF21262D', endColorstr='#FF191D22')}:root .btn{filter:none}.btn:hover,.btn:focus{background-color:#22262c;background-position:0 -0.5em;border-color:#30363d;background-image:url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg'%3e%3clinearGradient id='o' x2='0' y2='1'%3e%3cstop stop-color='%23292e36'/%3e%3cstop offset='90%25' stop-color='%2322262c'/%3e%3c/linearGradient%3e%3crect width='100%25' height='100%25' fill='url(%23o)'/%3e%3c/svg%3e");background-image:-moz-linear-gradient(top, #292e36, #22262c 90%);background-image:linear-gradient(180deg, #292e36, #22262c 90%);filter:progid:DXImageTransform.Microsoft.Gradient(startColorstr='#FF292E36', endColorstr='#FF21252B')}:root .btn:hover,:root .btn:focus{filter:none}.btn:active{background-color:#31363e;border-color:#30363d;background-image:none;filter:none}.social-count{color:#c9d1d9;background-color:#0d1117;border-color:#30363d}.social-count:hover,.social-count:focus{color:#388bfd}.octicon-heart{color:#db61a2}`;
  var darkDimmed = `.btn:focus-visible,.social-count:focus-visible{outline:2px solid #316dca;outline-offset:-2px}.btn{color:#adbac7;background-color:#30363d;border-color:#444c56;background-image:url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg'%3e%3clinearGradient id='o' x2='0' y2='1'%3e%3cstop stop-color='%23373e47'/%3e%3cstop offset='90%25' stop-color='%2330363d'/%3e%3c/linearGradient%3e%3crect width='100%25' height='100%25' fill='url(%23o)'/%3e%3c/svg%3e");background-image:-moz-linear-gradient(top, #373e47, #30363d 90%);background-image:linear-gradient(180deg, #373e47, #30363d 90%);filter:progid:DXImageTransform.Microsoft.Gradient(startColorstr='#FF373E47', endColorstr='#FF2F353C')}:root .btn{filter:none}.btn:hover,.btn:focus{background-color:#363c44;background-position:0 -0.5em;border-color:#444c56;background-image:url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg'%3e%3clinearGradient id='o' x2='0' y2='1'%3e%3cstop stop-color='%233d444e'/%3e%3cstop offset='90%25' stop-color='%23363c44'/%3e%3c/linearGradient%3e%3crect width='100%25' height='100%25' fill='url(%23o)'/%3e%3c/svg%3e");background-image:-moz-linear-gradient(top, #3d444e, #363c44 90%);background-image:linear-gradient(180deg, #3d444e, #363c44 90%);filter:progid:DXImageTransform.Microsoft.Gradient(startColorstr='#FF3D444E', endColorstr='#FF353B43')}:root .btn:hover,:root .btn:focus{filter:none}.btn:active{background-color:#434a54;border-color:#444c56;background-image:none;filter:none}.social-count{color:#adbac7;background-color:#22272e;border-color:#444c56}.social-count:hover,.social-count:focus{color:#4184e4}.octicon-heart{color:#c96198}`;
  var darkHighContrast = ".btn:focus-visible,.social-count:focus-visible{outline:2px solid #409eff;outline-offset:-2px}.btn{color:#f0f3f6;background-color:#3d424d;border-color:#7a828e;background-image:none;filter:none}.btn:hover,.btn:focus{background-color:#414751;background-position:0 -0.5em;border-color:#7a828e;background-image:none;filter:none}.btn:active{background-color:#393d48;border-color:#7a828e}.social-count{color:#f0f3f6;background-color:#0a0c10;border-color:#7a828e}.social-count:hover,.social-count:focus{color:#5cacff}.octicon-heart{color:#ff8dc7}";
  var stringify = function(obj, sep, eq, encodeURIComponent2) {
    if (sep == null) {
      sep = "&";
    }
    if (eq == null) {
      eq = "=";
    }
    if (encodeURIComponent2 == null) {
      encodeURIComponent2 = window.encodeURIComponent;
    }
    var params = [];
    for (var name2 in obj) {
      var value = obj[name2];
      if (value != null) {
        params.push(encodeURIComponent2(name2) + eq + encodeURIComponent2(value));
      }
    }
    return params.join(sep);
  };
  var parse = function(str, sep, eq, decodeURIComponent2) {
    if (decodeURIComponent2 == null) {
      decodeURIComponent2 = window.decodeURIComponent;
    }
    var obj = {};
    forEach(str.split(sep), function(entry) {
      if (entry !== "") {
        var ref = entry.split(eq);
        obj[decodeURIComponent2(ref[0])] = ref[1] != null ? decodeURIComponent2(ref.slice(1).join(eq)) : void 0;
      }
    });
    return obj;
  };
  var widgetColorSchemes = {
    light,
    light_high_contrast: lightHighContrast,
    dark,
    dark_dimmed: darkDimmed,
    dark_high_contrast: darkHighContrast
  };
  var getColorSchemeMediaQuery = function(systemColorScheme, widgetColorScheme) {
    return "@media(prefers-color-scheme:" + systemColorScheme + "){" + widgetColorSchemes[hasOwnProperty(widgetColorSchemes, widgetColorScheme) ? widgetColorScheme : systemColorScheme] + "}";
  };
  var getColorScheme = function(declarations) {
    if (declarations == null) {
      return widgetColorSchemes.light;
    }
    if (hasOwnProperty(widgetColorSchemes, declarations)) {
      return widgetColorSchemes[declarations];
    }
    var colorSchemes = parse(declarations, ";", ":", function(str) {
      return str.replace(/^[ \t\n\f\r]+|[ \t\n\f\r]+$/g, "");
    });
    return widgetColorSchemes[hasOwnProperty(widgetColorSchemes, colorSchemes["no-preference"]) ? colorSchemes["no-preference"] : "light"] + getColorSchemeMediaQuery("light", colorSchemes.light) + getColorSchemeMediaQuery("dark", colorSchemes.dark);
  };
  var data = {
    "comment-discussion": {
      heights: {
        "16": {
          width: 16,
          path: '<path d="M1.75 1h8.5c.966 0 1.75.784 1.75 1.75v5.5A1.75 1.75 0 0 1 10.25 10H7.061l-2.574 2.573A1.458 1.458 0 0 1 2 11.543V10h-.25A1.75 1.75 0 0 1 0 8.25v-5.5C0 1.784.784 1 1.75 1ZM1.5 2.75v5.5c0 .138.112.25.25.25h1a.75.75 0 0 1 .75.75v2.19l2.72-2.72a.749.749 0 0 1 .53-.22h3.5a.25.25 0 0 0 .25-.25v-5.5a.25.25 0 0 0-.25-.25h-8.5a.25.25 0 0 0-.25.25Zm13 2a.25.25 0 0 0-.25-.25h-.5a.75.75 0 0 1 0-1.5h.5c.966 0 1.75.784 1.75 1.75v5.5A1.75 1.75 0 0 1 14.25 12H14v1.543a1.458 1.458 0 0 1-2.487 1.03L9.22 12.28a.749.749 0 0 1 .326-1.275.749.749 0 0 1 .734.215l2.22 2.22v-2.19a.75.75 0 0 1 .75-.75h1a.25.25 0 0 0 .25-.25Z"></path>'
        }
      }
    },
    download: {
      heights: {
        "16": {
          width: 16,
          path: '<path d="M2.75 14A1.75 1.75 0 0 1 1 12.25v-2.5a.75.75 0 0 1 1.5 0v2.5c0 .138.112.25.25.25h10.5a.25.25 0 0 0 .25-.25v-2.5a.75.75 0 0 1 1.5 0v2.5A1.75 1.75 0 0 1 13.25 14Z"></path><path d="M7.25 7.689V2a.75.75 0 0 1 1.5 0v5.689l1.97-1.969a.749.749 0 1 1 1.06 1.06l-3.25 3.25a.749.749 0 0 1-1.06 0L4.22 6.78a.749.749 0 1 1 1.06-1.06l1.97 1.969Z"></path>'
        }
      }
    },
    eye: {
      heights: {
        "16": {
          width: 16,
          path: '<path d="M8 2c1.981 0 3.671.992 4.933 2.078 1.27 1.091 2.187 2.345 2.637 3.023a1.62 1.62 0 0 1 0 1.798c-.45.678-1.367 1.932-2.637 3.023C11.67 13.008 9.981 14 8 14c-1.981 0-3.671-.992-4.933-2.078C1.797 10.83.88 9.576.43 8.898a1.62 1.62 0 0 1 0-1.798c.45-.677 1.367-1.931 2.637-3.022C4.33 2.992 6.019 2 8 2ZM1.679 7.932a.12.12 0 0 0 0 .136c.411.622 1.241 1.75 2.366 2.717C5.176 11.758 6.527 12.5 8 12.5c1.473 0 2.825-.742 3.955-1.715 1.124-.967 1.954-2.096 2.366-2.717a.12.12 0 0 0 0-.136c-.412-.621-1.242-1.75-2.366-2.717C10.824 4.242 9.473 3.5 8 3.5c-1.473 0-2.825.742-3.955 1.715-1.124.967-1.954 2.096-2.366 2.717ZM8 10a2 2 0 1 1-.001-3.999A2 2 0 0 1 8 10Z"></path>'
        }
      }
    },
    heart: {
      heights: {
        "16": {
          width: 16,
          path: '<path d="m8 14.25.345.666a.75.75 0 0 1-.69 0l-.008-.004-.018-.01a7.152 7.152 0 0 1-.31-.17 22.055 22.055 0 0 1-3.434-2.414C2.045 10.731 0 8.35 0 5.5 0 2.836 2.086 1 4.25 1 5.797 1 7.153 1.802 8 3.02 8.847 1.802 10.203 1 11.75 1 13.914 1 16 2.836 16 5.5c0 2.85-2.045 5.231-3.885 6.818a22.066 22.066 0 0 1-3.744 2.584l-.018.01-.006.003h-.002ZM4.25 2.5c-1.336 0-2.75 1.164-2.75 3 0 2.15 1.58 4.144 3.365 5.682A20.58 20.58 0 0 0 8 13.393a20.58 20.58 0 0 0 3.135-2.211C12.92 9.644 14.5 7.65 14.5 5.5c0-1.836-1.414-3-2.75-3-1.373 0-2.609.986-3.029 2.456a.749.749 0 0 1-1.442 0C6.859 3.486 5.623 2.5 4.25 2.5Z"></path>'
        }
      }
    },
    "issue-opened": {
      heights: {
        "16": {
          width: 16,
          path: '<path d="M8 9.5a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3Z"></path><path d="M8 0a8 8 0 1 1 0 16A8 8 0 0 1 8 0ZM1.5 8a6.5 6.5 0 1 0 13 0 6.5 6.5 0 0 0-13 0Z"></path>'
        }
      }
    },
    "mark-github": {
      heights: {
        "16": {
          width: 16,
          path: '<path d="M8 0c4.42 0 8 3.58 8 8a8.013 8.013 0 0 1-5.45 7.59c-.4.08-.55-.17-.55-.38 0-.27.01-1.13.01-2.2 0-.75-.25-1.23-.54-1.48 1.78-.2 3.65-.88 3.65-3.95 0-.88-.31-1.59-.82-2.15.08-.2.36-1.02-.08-2.12 0 0-.67-.22-2.2.82-.64-.18-1.32-.27-2-.27-.68 0-1.36.09-2 .27-1.53-1.03-2.2-.82-2.2-.82-.44 1.1-.16 1.92-.08 2.12-.51.56-.82 1.28-.82 2.15 0 3.06 1.86 3.75 3.64 3.95-.23.2-.44.55-.51 1.07-.46.21-1.61.55-2.33-.66-.15-.24-.6-.83-1.23-.82-.67.01-.27.38.01.53.34.19.73.9.82 1.13.16.45.68 1.31 2.69.94 0 .67.01 1.3.01 1.49 0 .21-.15.45-.55.38A7.995 7.995 0 0 1 0 8c0-4.42 3.58-8 8-8Z"></path>'
        }
      }
    },
    "package": {
      heights: {
        "16": {
          width: 16,
          path: '<path d="m8.878.392 5.25 3.045c.54.314.872.89.872 1.514v6.098a1.75 1.75 0 0 1-.872 1.514l-5.25 3.045a1.75 1.75 0 0 1-1.756 0l-5.25-3.045A1.75 1.75 0 0 1 1 11.049V4.951c0-.624.332-1.201.872-1.514L7.122.392a1.75 1.75 0 0 1 1.756 0ZM7.875 1.69l-4.63 2.685L8 7.133l4.755-2.758-4.63-2.685a.248.248 0 0 0-.25 0ZM2.5 5.677v5.372c0 .09.047.171.125.216l4.625 2.683V8.432Zm6.25 8.271 4.625-2.683a.25.25 0 0 0 .125-.216V5.677L8.75 8.432Z"></path>'
        }
      }
    },
    play: {
      heights: {
        "16": {
          width: 16,
          path: '<path d="M8 0a8 8 0 1 1 0 16A8 8 0 0 1 8 0ZM1.5 8a6.5 6.5 0 1 0 13 0 6.5 6.5 0 0 0-13 0Zm4.879-2.773 4.264 2.559a.25.25 0 0 1 0 .428l-4.264 2.559A.25.25 0 0 1 6 10.559V5.442a.25.25 0 0 1 .379-.215Z"></path>'
        }
      }
    },
    "repo-forked": {
      heights: {
        "16": {
          width: 16,
          path: '<path d="M5 5.372v.878c0 .414.336.75.75.75h4.5a.75.75 0 0 0 .75-.75v-.878a2.25 2.25 0 1 1 1.5 0v.878a2.25 2.25 0 0 1-2.25 2.25h-1.5v2.128a2.251 2.251 0 1 1-1.5 0V8.5h-1.5A2.25 2.25 0 0 1 3.5 6.25v-.878a2.25 2.25 0 1 1 1.5 0ZM5 3.25a.75.75 0 1 0-1.5 0 .75.75 0 0 0 1.5 0Zm6.75.75a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5Zm-3 8.75a.75.75 0 1 0-1.5 0 .75.75 0 0 0 1.5 0Z"></path>'
        }
      }
    },
    "repo-template": {
      heights: {
        "16": {
          width: 16,
          path: '<path d="M13.25 8a.75.75 0 0 1 .75.75v4.5a.75.75 0 0 1-.75.75h-2.5a.75.75 0 0 1 0-1.5h1.75v-2h-.75a.75.75 0 0 1 0-1.5h.75v-.25a.75.75 0 0 1 .75-.75ZM5 12.25a.25.25 0 0 1 .25-.25h3.5a.25.25 0 0 1 .25.25v3.25a.25.25 0 0 1-.4.2l-1.45-1.087a.249.249 0 0 0-.3 0L5.4 15.7a.25.25 0 0 1-.4-.2ZM2.75 8a.75.75 0 0 1 .75.75v.268c.083-.012.166-.018.25-.018h.5a.75.75 0 0 1 0 1.5h-.5a.25.25 0 0 0-.25.25v.75c0 .28.114.532.3.714a.75.75 0 1 1-1.05 1.072A2.495 2.495 0 0 1 2 11.5V8.75A.75.75 0 0 1 2.75 8ZM11 .75a.75.75 0 0 1 .75-.75h1.5a.75.75 0 0 1 .75.75v1.5a.75.75 0 0 1-1.5 0V1.5h-.75A.75.75 0 0 1 11 .75Zm-5 0A.75.75 0 0 1 6.75 0h2.5a.75.75 0 0 1 0 1.5h-2.5A.75.75 0 0 1 6 .75Zm0 9A.75.75 0 0 1 6.75 9h2.5a.75.75 0 0 1 0 1.5h-2.5A.75.75 0 0 1 6 9.75ZM4.992.662a.75.75 0 0 1-.636.848c-.436.063-.783.41-.846.846a.751.751 0 0 1-1.485-.212A2.501 2.501 0 0 1 4.144.025a.75.75 0 0 1 .848.637ZM2.75 4a.75.75 0 0 1 .75.75v1.5a.75.75 0 0 1-1.5 0v-1.5A.75.75 0 0 1 2.75 4Zm10.5 0a.75.75 0 0 1 .75.75v1.5a.75.75 0 0 1-1.5 0v-1.5a.75.75 0 0 1 .75-.75Z"></path>'
        }
      }
    },
    star: {
      heights: {
        "16": {
          width: 16,
          path: '<path d="M8 .25a.75.75 0 0 1 .673.418l1.882 3.815 4.21.612a.75.75 0 0 1 .416 1.279l-3.046 2.97.719 4.192a.751.751 0 0 1-1.088.791L8 12.347l-3.766 1.98a.75.75 0 0 1-1.088-.79l.72-4.194L.818 6.374a.75.75 0 0 1 .416-1.28l4.21-.611L7.327.668A.75.75 0 0 1 8 .25Zm0 2.445L6.615 5.5a.75.75 0 0 1-.564.41l-3.097.45 2.24 2.184a.75.75 0 0 1 .216.664l-.528 3.084 2.769-1.456a.75.75 0 0 1 .698 0l2.77 1.456-.53-3.084a.75.75 0 0 1 .216-.664l2.24-2.183-3.096-.45a.75.75 0 0 1-.564-.41L8 2.694Z"></path>'
        }
      }
    }
  };
  var octicon = function(icon, height) {
    icon = toLowerCase(icon).replace(/^octicon-/, "");
    if (!hasOwnProperty(data, icon)) {
      icon = "mark-github";
    }
    var defaultHeight = height >= 24 && /* istanbul ignore next */
    24 in data[icon].heights ? (
      /* istanbul ignore next */
      24
    ) : 16;
    var svg = data[icon].heights[defaultHeight];
    return '<svg viewBox="0 0 ' + svg.width + " " + defaultHeight + '" width="' + height * svg.width / defaultHeight + '" height="' + height + '" class="octicon octicon-' + icon + '" aria-hidden="true">' + svg.path + "</svg>";
  };
  var queues = {};
  var fetch2 = function(url, func) {
    var queue = queues[url] || (queues[url] = []);
    if (queue.push(func) > 1) {
      return;
    }
    var callback = dispatchOnce(function() {
      delete queues[url];
      while (func = queue.shift()) {
        func.apply(null, arguments);
      }
    });
    if (useXHR) {
      var xhr = new XMLHttpRequest2();
      onEvent(xhr, "abort", callback);
      onEvent(xhr, "error", callback);
      onEvent(xhr, "load", function() {
        var data2;
        try {
          data2 = JSON.parse(this.responseText);
        } catch (error) {
          callback(error);
          return;
        }
        callback(this.status !== 200, data2);
      });
      xhr.open("GET", url);
      xhr.send();
    } else {
      var contentWindow = this || window;
      contentWindow._ = function(json) {
        contentWindow._ = null;
        callback(json.meta.status !== 200, json.data);
      };
      var script = createElementInDocument(contentWindow.document)("script", {
        async: true,
        src: url + (url.indexOf("?") !== -1 ? "&" : "?") + "callback=_"
      });
      var onloadend = (
        /* istanbul ignore next: IE lt 9 */
        function() {
          if (contentWindow._) {
            contentWindow._({
              meta: {}
            });
          }
        }
      );
      onEvent(script, "load", onloadend);
      onEvent(script, "error", onloadend);
      onceReadyStateChange(script, /de|m/, onloadend);
      contentWindow.document.getElementsByTagName("head")[0].appendChild(script);
    }
  };
  var render$1 = function(root, options, func) {
    var createElement50 = createElementInDocument(root.ownerDocument);
    var style = root.appendChild(createElement50("style", {
      type: "text/css"
    }));
    var cssText = buttonsCssText + getColorScheme(options["data-color-scheme"]);
    if (style.styleSheet) {
      style.styleSheet.cssText = cssText;
    } else {
      style.appendChild(root.ownerDocument.createTextNode(cssText));
    }
    var isLarge = toLowerCase(options["data-size"]) === "large";
    var btn = createElement50("a", {
      className: "btn",
      href: options.href,
      rel: "noopener",
      target: "_blank",
      title: options.title || void 0,
      "aria-label": options["aria-label"] || void 0,
      innerHTML: octicon(options["data-icon"], isLarge ? 16 : 14) + "&nbsp;"
    }, [
      createElement50("span", {}, [options["data-text"] || ""])
    ]);
    var widget = root.appendChild(createElement50("div", {
      className: "widget" + (isLarge ? " widget-lg" : "")
    }, [
      btn
    ]));
    var hostname = btn.hostname.replace(/\.$/, "");
    if (("." + hostname).substring(hostname.length - domain.length) !== "." + domain) {
      btn.removeAttribute("href");
      func(widget);
      return;
    }
    var path = (" /" + btn.pathname).split(/\/+/);
    if ((hostname === domain || hostname === "gist." + domain) && path[3] === "archive" || hostname === domain && path[3] === "releases" && (path[4] === "download" || path[4] === "latest" && path[5] === "download") || hostname === "codeload." + domain) {
      btn.target = "_top";
    }
    if (toLowerCase(options["data-show-count"]) !== "true" || hostname !== domain || path[1] === "marketplace" || path[1] === "sponsors" || path[1] === "orgs" || path[1] === "users" || path[1] === "-") {
      func(widget);
      return;
    }
    var href, property;
    if (!path[2] && path[1]) {
      property = "followers";
      href = "?tab=followers";
    } else if (!path[3] && path[2]) {
      property = "stargazers_count";
      href = "/stargazers";
    } else if (!path[4] && path[3] === "subscription") {
      property = "subscribers_count";
      href = "/watchers";
    } else if (!path[4] && path[3] === "fork") {
      property = "forks_count";
      href = "/forks";
    } else if (path[3] === "issues") {
      property = "open_issues_count";
      href = "/issues";
    } else {
      func(widget);
      return;
    }
    var api = path[2] ? "/repos/" + path[1] + "/" + path[2] : "/users/" + path[1];
    fetch2.call(this, apiBaseURL + api, function(error, json) {
      if (!error) {
        var data2 = json[property];
        widget.appendChild(createElement50("a", {
          className: "social-count",
          href: json.html_url + href,
          rel: "noopener",
          target: "_blank",
          "aria-label": data2 + " " + property.replace(/_count$/, "").replace("_", " ").slice(0, data2 < 2 ? -1 : void 0) + " on GitHub"
        }, [
          ("" + data2).replace(/\B(?=(\d{3})+(?!\d))/g, ",")
        ]));
      }
      func(widget);
    });
  };
  var devicePixelRatio = window.devicePixelRatio || /* istanbul ignore next */
  1;
  var ceilPixel = function(px) {
    return (devicePixelRatio > 1 ? Math2.ceil(Math2.round(px * devicePixelRatio) / devicePixelRatio * 2) / 2 : Math2.ceil(px)) || 0;
  };
  var get = function(el) {
    var width = el.offsetWidth;
    var height = el.offsetHeight;
    if (el.getBoundingClientRect) {
      var boundingClientRect = el.getBoundingClientRect();
      width = Math2.max(width, ceilPixel(boundingClientRect.width));
      height = Math2.max(height, ceilPixel(boundingClientRect.height));
    }
    return [width, height];
  };
  var set = function(el, size) {
    el.style.width = size[0] + "px";
    el.style.height = size[1] + "px";
  };
  var render = function(options, func) {
    if (options == null || func == null) {
      return;
    }
    if (options.getAttribute) {
      options = parseOptions(options);
    }
    if (useShadowDOM) {
      var host = createElement("span");
      render$1(host.attachShadow({ mode: "closed" }), options, function() {
        func(host);
      });
    } else {
      var iframe = createElement("iframe", {
        src: "javascript:0",
        title: options.title || void 0,
        allowtransparency: true,
        scrolling: "no",
        frameBorder: 0
      });
      set(iframe, [0, 0]);
      iframe.style.border = "none";
      var callback = function() {
        var contentWindow = iframe.contentWindow;
        var body;
        try {
          body = contentWindow.document.body;
        } catch (_) {
          document2.body.appendChild(iframe.parentNode.removeChild(iframe));
          return;
        }
        offEvent(iframe, "load", callback);
        render$1.call(contentWindow, body, options, function(widget) {
          var size = get(widget);
          iframe.parentNode.removeChild(iframe);
          onceEvent(iframe, "load", function() {
            set(iframe, size);
          });
          iframe.src = iframeURL + "#" + (iframe.name = stringify(options));
          func(iframe);
        });
      };
      onEvent(iframe, "load", callback);
      document2.body.appendChild(iframe);
    }
  };

  // demo/scripts/components/GitHubButton.tsx
  var { useEffect, useRef } = React;
  var GitHubButton = ({
    href,
    ariaLabel,
    dataColorScheme = "dark_high_contrast",
    dataIcon,
    dataShowCount,
    dataSize = "large",
    dataText,
    title,
    children
  }) => {
    const aRef = useRef(null);
    useEffect(() => {
      const aElement = aRef.current;
      if (aElement !== null) {
        render(aElement, (newA) => {
          var _a;
          return (_a = aElement == null ? void 0 : aElement.parentNode) == null ? void 0 : _a.replaceChild(newA, aElement);
        });
      }
    });
    return /* @__PURE__ */ React.createElement("span", { className: "button-gh" }, /* @__PURE__ */ React.createElement(
      "a",
      {
        ref: aRef,
        href,
        "aria-label": ariaLabel,
        "data-icon": dataIcon,
        "data-color-scheme": dataColorScheme,
        "data-show-count": dataShowCount,
        "data-size": dataSize,
        "data-text": dataText,
        title
      },
      children
    ));
  };
  var GitHubButton_default = GitHubButton;

  // demo/scripts/controllers/Player.tsx
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var React44 = __toESM(require_react());

  // demo/scripts/modules/player/index.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/features/list/index.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/features/list/dash.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/main_thread/init/media_source_content_initializer.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/compat/may_media_element_fail_on_undecipherable_data.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var mayMediaElementFailOnUndecipherableData = isPlayStation5;
  var may_media_element_fail_on_undecipherable_data_default = mayMediaElementFailOnUndecipherableData;

  // src/compat/should_reload_media_source_on_decipherability_update.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function shouldReloadMediaSourceOnDecipherabilityUpdate(currentKeySystem) {
    return currentKeySystem === void 0 || currentKeySystem.indexOf("widevine") < 0;
  }

  // src/core/adaptive/index.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/core/adaptive/adaptive_representation_selector.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/core/adaptive/buffer_based_chooser.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/core/adaptive/utils/get_buffer_levels.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function getBufferLevels(bitrates) {
    const logs = bitrates.map((b) => Math.log(b / bitrates[0]));
    const utilities = logs.map((l) => l - logs[0] + 1);
    const gp = (utilities[utilities.length - 1] - 1) / (bitrates.length * 2 + 10);
    const Vp = 1 / gp;
    return bitrates.map((_, i) => minBufferLevelForBitrate(i));
    function minBufferLevelForBitrate(index) {
      if (index === 0) {
        return 0;
      }
      const boundedIndex = Math.min(Math.max(1, index), bitrates.length - 1);
      if (bitrates[boundedIndex] === bitrates[boundedIndex - 1]) {
        return minBufferLevelForBitrate(index - 1);
      }
      return Vp * (gp + (bitrates[boundedIndex] * utilities[boundedIndex - 1] - bitrates[boundedIndex - 1] * utilities[boundedIndex]) / (bitrates[boundedIndex] - bitrates[boundedIndex - 1])) + 4;
    }
  }

  // src/core/adaptive/utils/representation_score_calculator.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/core/adaptive/utils/ewma.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var EWMA = class {
    /**
     * @param {number} halfLife
     */
    constructor(halfLife) {
      this._alpha = Math.exp(Math.log(0.5) / halfLife);
      this._lastEstimate = 0;
      this._totalWeight = 0;
    }
    /**
     * @param {number} weight
     * @param {number} value
     */
    addSample(weight, value) {
      const adjAlpha = Math.pow(this._alpha, weight);
      const newEstimate = value * (1 - adjAlpha) + adjAlpha * this._lastEstimate;
      if (!isNaN(newEstimate)) {
        this._lastEstimate = newEstimate;
        this._totalWeight += weight;
      }
    }
    /**
     * @returns {number} value
     */
    getEstimate() {
      const zeroFactor = 1 - Math.pow(this._alpha, this._totalWeight);
      return this._lastEstimate / zeroFactor;
    }
  };

  // src/core/adaptive/utils/representation_score_calculator.ts
  var RepresentationScoreCalculator = class {
    constructor() {
      this._currentRepresentationData = null;
      this._lastRepresentationWithGoodScore = null;
    }
    /**
     * Add new sample data.
     * @param {Object} representation
     * @param {number} requestDuration - duration taken for doing the request for
     * the whole segment.
     * @param {number} segmentDuration - media duration of the whole segment, in
     * seconds.
     */
    addSample(representation, requestDuration, segmentDuration) {
      const ratio = segmentDuration / requestDuration;
      const currentRep = this._currentRepresentationData;
      let currentEWMA;
      if (currentRep !== null && currentRep.representation.id === representation.id) {
        currentEWMA = currentRep.ewma;
        currentRep.ewma.addSample(requestDuration, ratio);
        currentRep.loadedDuration += segmentDuration;
        currentRep.loadedSegments++;
      } else {
        currentEWMA = new EWMA(5);
        currentEWMA.addSample(requestDuration, ratio);
        this._currentRepresentationData = {
          representation,
          ewma: currentEWMA,
          loadedDuration: segmentDuration,
          loadedSegments: 0
        };
      }
      if (currentEWMA.getEstimate() > 1 && this._lastRepresentationWithGoodScore !== representation) {
        log_default.debug("ABR: New last stable representation", representation.bitrate);
        this._lastRepresentationWithGoodScore = representation;
      }
    }
    /**
     * Get score estimate for the given Representation.
     * undefined if no estimate is available.
     * @param {Object} representation
     * @returns {number|undefined}
     */
    getEstimate(representation) {
      if (this._currentRepresentationData === null || this._currentRepresentationData.representation.id !== representation.id) {
        return void 0;
      }
      const { ewma, loadedSegments, loadedDuration } = this._currentRepresentationData;
      const estimate = ewma.getEstimate();
      const confidenceLevel = loadedSegments >= 5 && loadedDuration >= 10 ? 1 /* HIGH */ : 0 /* LOW */;
      return { score: estimate, confidenceLevel };
    }
    /**
     * Returns last Representation which had reached a score superior to 1.
     * This Representation is the last known one which could be maintained.
     * Useful to know if a current guess is higher than what you should
     * normally be able to play.
     * `null` if no Representation ever reach that score.
     * @returns {Object|null}
     */
    getLastStableRepresentation() {
      return this._lastRepresentationWithGoodScore;
    }
  };

  // src/core/adaptive/buffer_based_chooser.ts
  var MINIMUM_BLOCK_RAISE_DELAY = 6e3;
  var MAXIMUM_BLOCK_RAISE_DELAY = 15e3;
  var RAISE_BLOCKING_DELAY_INCREMENT = 3e3;
  var RAISE_BLOCKING_DELAY_DECREMENT = 1e3;
  var STABILITY_CHECK_DELAY = 9e3;
  var BufferBasedChooser = class {
    /**
     * @param {Array.<number>} bitrates
     */
    constructor(bitrates) {
      this._levelsMap = getBufferLevels(bitrates).map((bl) => {
        return bl + 4;
      });
      this._bitrates = bitrates;
      this._lastUnsuitableQualityTimestamp = void 0;
      this._blockRaiseDelay = MINIMUM_BLOCK_RAISE_DELAY;
      log_default.debug(
        "ABR: Steps for buffer based chooser.",
        this._levelsMap.map((l, i) => `bufferLevel: ${l}, bitrate: ${bitrates[i]}`).join(" ,")
      );
    }
    /**
     * @param {Object} playbackObservation
     * @returns {number|undefined}
     */
    onAddedSegment(playbackObservation) {
      const bufferLevels = this._levelsMap;
      const bitrates = this._bitrates;
      const { bufferGap, currentBitrate, currentScore, speed } = playbackObservation;
      if (isNullOrUndefined(currentBitrate)) {
        this._currentEstimate = bitrates[0];
        return;
      }
      let currentBitrateIndex = -1;
      for (let i = 0; i < bitrates.length; i++) {
        const bitrate = bitrates[i];
        if (bitrate === currentBitrate) {
          currentBitrateIndex = i;
        } else if (bitrate > currentBitrate) {
          break;
        }
      }
      if (currentBitrateIndex < 0 || bitrates.length !== bufferLevels.length) {
        log_default.info("ABR: Current Bitrate not found in the calculated levels");
        this._currentEstimate = bitrates[0];
        return;
      }
      let scaledScore;
      if (currentScore !== void 0) {
        scaledScore = speed === 0 ? currentScore.score : currentScore.score / speed;
      }
      const actualBufferGap = isFinite(bufferGap) ? bufferGap : 0;
      const now = monotonic_timestamp_default();
      if (actualBufferGap < bufferLevels[currentBitrateIndex] || scaledScore !== void 0 && scaledScore < 1 && (currentScore == null ? void 0 : currentScore.confidenceLevel) === 1 /* HIGH */) {
        const timeSincePrev = this._lastUnsuitableQualityTimestamp === void 0 ? -1 : now - this._lastUnsuitableQualityTimestamp;
        if (timeSincePrev < this._blockRaiseDelay + STABILITY_CHECK_DELAY) {
          const newDelay = this._blockRaiseDelay + RAISE_BLOCKING_DELAY_INCREMENT;
          this._blockRaiseDelay = Math.min(newDelay, MAXIMUM_BLOCK_RAISE_DELAY);
          log_default.debug(
            "ABR: Incrementing blocking raise in BufferBasedChooser due to unstable quality",
            this._blockRaiseDelay
          );
        } else {
          const newDelay = this._blockRaiseDelay - RAISE_BLOCKING_DELAY_DECREMENT;
          this._blockRaiseDelay = Math.max(MINIMUM_BLOCK_RAISE_DELAY, newDelay);
          log_default.debug("ABR: Lowering quality in BufferBasedChooser", this._blockRaiseDelay);
        }
        this._lastUnsuitableQualityTimestamp = now;
        const baseIndex = arrayFindIndex(bitrates, (b) => b === currentBitrate);
        for (let i = baseIndex - 1; i >= 0; i--) {
          if (actualBufferGap >= bufferLevels[i]) {
            this._currentEstimate = bitrates[i];
            return;
          }
        }
        this._currentEstimate = bitrates[0];
        return;
      }
      if (this._lastUnsuitableQualityTimestamp !== void 0 && now - this._lastUnsuitableQualityTimestamp < this._blockRaiseDelay || scaledScore === void 0 || scaledScore < 1.15 || (currentScore == null ? void 0 : currentScore.confidenceLevel) !== 1 /* HIGH */) {
        this._currentEstimate = currentBitrate;
        return;
      }
      const currentBufferLevel = bufferLevels[currentBitrateIndex];
      const nextIndex = (() => {
        for (let i = currentBitrateIndex + 1; i < bufferLevels.length; i++) {
          if (bufferLevels[i] > currentBufferLevel) {
            return i;
          }
        }
      })();
      if (nextIndex !== void 0) {
        const nextBufferLevel = bufferLevels[nextIndex];
        if (bufferGap >= nextBufferLevel) {
          log_default.debug("ABR: Raising quality in BufferBasedChooser", bitrates[nextIndex]);
          this._currentEstimate = bitrates[nextIndex];
          return;
        }
      }
      this._currentEstimate = currentBitrate;
      return;
    }
    /**
     * Returns the last best Representation's bitrate estimate made by the
     * `BufferBasedChooser` or `undefined` if it has no such guess for now.
     *
     * Might be updated after `onAddedSegment` is called.
     *
     * @returns {number|undefined}
     */
    getLastEstimate() {
      return this._currentEstimate;
    }
  };

  // src/core/adaptive/guess_based_chooser.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/core/adaptive/network_analyzer.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function getConcernedRequests(requests, neededPosition) {
    let nextSegmentIndex = -1;
    for (let i = 0; i < requests.length; i++) {
      const { segment } = requests[i].content;
      if (segment.duration <= 0) {
        continue;
      }
      const segmentEnd = segment.time + segment.duration;
      if (!segment.complete) {
        if (i === requests.length - 1 && neededPosition - segment.time > -1.2) {
          nextSegmentIndex = i;
          break;
        }
      }
      if (segmentEnd > neededPosition && neededPosition - segment.time > -1.2) {
        nextSegmentIndex = i;
        break;
      }
    }
    if (nextSegmentIndex < 0) {
      return [];
    }
    const nextRequest = requests[nextSegmentIndex];
    const segmentTime = nextRequest.content.segment.time;
    const filteredRequests = [nextRequest];
    for (let i = nextSegmentIndex + 1; i < requests.length; i++) {
      if (requests[i].content.segment.time === segmentTime) {
        filteredRequests.push(requests[i]);
      } else {
        break;
      }
    }
    return filteredRequests;
  }
  function estimateRequestBandwidth(request2) {
    if (request2.progress.length < 5) {
      return void 0;
    }
    const ewma1 = new EWMA(2);
    const { progress } = request2;
    for (let i = 1; i < progress.length; i++) {
      const bytesDownloaded = progress[i].size - progress[i - 1].size;
      const timeElapsed = progress[i].timestamp - progress[i - 1].timestamp;
      const reqBitrate = bytesDownloaded * 8 / (timeElapsed / 1e3);
      ewma1.addSample(timeElapsed / 1e3, reqBitrate);
    }
    return ewma1.getEstimate();
  }
  function estimateRemainingTime(lastProgressEvent, bandwidthEstimate) {
    const remainingData = (lastProgressEvent.totalSize - lastProgressEvent.size) * 8;
    return Math.max(remainingData / bandwidthEstimate, 0);
  }
  function estimateStarvationModeBitrate(pendingRequests, playbackInfo, currentRepresentation, lowLatencyMode, lastEstimatedBitrate) {
    if (lowLatencyMode) {
      return void 0;
    }
    const { bufferGap, speed, position } = playbackInfo;
    const realBufferGap = isFinite(bufferGap) ? bufferGap : 0;
    const nextNeededPosition = position.getWanted() + realBufferGap;
    const concernedRequests = getConcernedRequests(pendingRequests, nextNeededPosition);
    if (concernedRequests.length !== 1) {
      return void 0;
    }
    const concernedRequest = concernedRequests[0];
    const now = monotonic_timestamp_default();
    let minimumRequestTime = concernedRequest.content.segment.duration * 1.5;
    minimumRequestTime = Math.min(minimumRequestTime, 3e3);
    minimumRequestTime = Math.max(minimumRequestTime, 12e3);
    if (now - concernedRequest.requestTimestamp < minimumRequestTime) {
      return void 0;
    }
    const lastProgressEvent = concernedRequest.progress.length > 0 ? concernedRequest.progress[concernedRequest.progress.length - 1] : void 0;
    const bandwidthEstimate = estimateRequestBandwidth(concernedRequest);
    if (lastProgressEvent !== void 0 && bandwidthEstimate !== void 0) {
      const remainingTime = estimateRemainingTime(lastProgressEvent, bandwidthEstimate);
      if ((now - lastProgressEvent.timestamp) / 1e3 <= remainingTime) {
        const expectedRebufferingTime = remainingTime - realBufferGap / speed;
        if (expectedRebufferingTime > 2500) {
          return bandwidthEstimate;
        }
      }
    }
    if (!concernedRequest.content.segment.complete) {
      return void 0;
    }
    const chunkDuration = concernedRequest.content.segment.duration;
    const requestElapsedTime = (now - concernedRequest.requestTimestamp) / 1e3;
    const reasonableElapsedTime = requestElapsedTime <= (chunkDuration * 1.5 + 2) / speed;
    if (isNullOrUndefined(currentRepresentation) || reasonableElapsedTime) {
      return void 0;
    }
    const factor = chunkDuration / requestElapsedTime;
    const reducedBitrate = currentRepresentation.bitrate * Math.min(0.7, factor);
    if (lastEstimatedBitrate === void 0 || reducedBitrate < lastEstimatedBitrate) {
      return reducedBitrate;
    }
  }
  function shouldDirectlySwitchToLowBitrate(playbackInfo, requests, lowLatencyMode) {
    if (lowLatencyMode) {
      return true;
    }
    const realBufferGap = isFinite(playbackInfo.bufferGap) ? playbackInfo.bufferGap : 0;
    const nextNeededPosition = playbackInfo.position.getWanted() + realBufferGap;
    const nextRequest = arrayFind(
      requests,
      ({ content }) => content.segment.duration > 0 && content.segment.time + content.segment.duration > nextNeededPosition
    );
    if (nextRequest === void 0) {
      return true;
    }
    const now = monotonic_timestamp_default();
    const lastProgressEvent = nextRequest.progress.length > 0 ? nextRequest.progress[nextRequest.progress.length - 1] : void 0;
    const bandwidthEstimate = estimateRequestBandwidth(nextRequest);
    if (lastProgressEvent === void 0 || bandwidthEstimate === void 0) {
      return true;
    }
    const remainingTime = estimateRemainingTime(lastProgressEvent, bandwidthEstimate);
    if ((now - lastProgressEvent.timestamp) / 1e3 > remainingTime * 1.2) {
      return true;
    }
    const expectedRebufferingTime = remainingTime - realBufferGap / playbackInfo.speed;
    return expectedRebufferingTime > -1.5;
  }
  var NetworkAnalyzer = class {
    constructor(initialBitrate, lowLatencyMode) {
      const {
        ABR_STARVATION_GAP,
        OUT_OF_STARVATION_GAP,
        ABR_STARVATION_FACTOR,
        ABR_REGULAR_FACTOR
      } = config_default.getCurrent();
      this._initialBitrate = initialBitrate;
      this._inStarvationMode = false;
      this._lowLatencyMode = lowLatencyMode;
      if (lowLatencyMode) {
        this._config = {
          starvationGap: ABR_STARVATION_GAP.LOW_LATENCY,
          outOfStarvationGap: OUT_OF_STARVATION_GAP.LOW_LATENCY,
          starvationBitrateFactor: ABR_STARVATION_FACTOR.LOW_LATENCY,
          regularBitrateFactor: ABR_REGULAR_FACTOR.LOW_LATENCY
        };
      } else {
        this._config = {
          starvationGap: ABR_STARVATION_GAP.DEFAULT,
          outOfStarvationGap: OUT_OF_STARVATION_GAP.DEFAULT,
          starvationBitrateFactor: ABR_STARVATION_FACTOR.DEFAULT,
          regularBitrateFactor: ABR_REGULAR_FACTOR.DEFAULT
        };
      }
    }
    /**
     * Gives an estimate of the current bandwidth and of the bitrate that should
     * be considered for chosing a `representation`.
     * This estimate is only based on network metrics.
     * @param {Object} playbackInfo - Gives current information about playback.
     * @param {Object} bandwidthEstimator - `BandwidthEstimator` allowing to
     * produce network bandwidth estimates.
     * @param {Object|null} currentRepresentation - The Representation currently
     * chosen.
     * `null` if no Representation has been chosen yet.
     * @param {Array.<Object>} currentRequests - All segment requests by segment's
     * start chronological order
     * @param {number|undefined} lastEstimatedBitrate - Bitrate emitted during the
     * last estimate.
     * @returns {Object}
     */
    getBandwidthEstimate(playbackInfo, bandwidthEstimator, currentRepresentation, currentRequests, lastEstimatedBitrate) {
      let newBitrateCeil;
      let bandwidthEstimate;
      const localConf = this._config;
      const { bufferGap, position, duration } = playbackInfo;
      const realBufferGap = isFinite(bufferGap) ? bufferGap : 0;
      const { ABR_STARVATION_DURATION_DELTA } = config_default.getCurrent();
      if (isNaN(duration) || realBufferGap + position.getWanted() < duration - ABR_STARVATION_DURATION_DELTA) {
        if (!this._inStarvationMode && realBufferGap <= localConf.starvationGap) {
          log_default.info("ABR: enter starvation mode.");
          this._inStarvationMode = true;
        } else if (this._inStarvationMode && realBufferGap >= localConf.outOfStarvationGap) {
          log_default.info("ABR: exit starvation mode.");
          this._inStarvationMode = false;
        }
      } else if (this._inStarvationMode) {
        log_default.info("ABR: exit starvation mode.");
        this._inStarvationMode = false;
      }
      if (this._inStarvationMode) {
        bandwidthEstimate = estimateStarvationModeBitrate(
          currentRequests,
          playbackInfo,
          currentRepresentation,
          this._lowLatencyMode,
          lastEstimatedBitrate
        );
        if (bandwidthEstimate !== void 0) {
          log_default.info("ABR: starvation mode emergency estimate:", bandwidthEstimate);
          bandwidthEstimator.reset();
          newBitrateCeil = isNullOrUndefined(currentRepresentation) ? bandwidthEstimate : Math.min(bandwidthEstimate, currentRepresentation.bitrate);
        }
      }
      if (isNullOrUndefined(newBitrateCeil)) {
        bandwidthEstimate = bandwidthEstimator.getEstimate();
        if (bandwidthEstimate !== void 0) {
          newBitrateCeil = bandwidthEstimate * (this._inStarvationMode ? localConf.starvationBitrateFactor : localConf.regularBitrateFactor);
        } else if (lastEstimatedBitrate !== void 0) {
          newBitrateCeil = lastEstimatedBitrate * (this._inStarvationMode ? localConf.starvationBitrateFactor : localConf.regularBitrateFactor);
        } else {
          newBitrateCeil = this._initialBitrate;
        }
      }
      if (playbackInfo.speed > 1) {
        newBitrateCeil /= playbackInfo.speed;
      }
      return { bandwidthEstimate, bitrateChosen: newBitrateCeil };
    }
    /**
     * For a given wanted bitrate, tells if should switch urgently.
     * @param {number} bitrate - The new estimated bitrate.
     * @param {Object|null} currentRepresentation - The Representation being
     * presently being loaded.
     * @param {Array.<Object>} currentRequests - All segment requests by segment's
     * start chronological order
     * @param {Object} playbackInfo - Information on the current playback.
     * @returns {boolean}
     */
    isUrgent(bitrate, currentRepresentation, currentRequests, playbackInfo) {
      if (currentRepresentation === null) {
        return true;
      } else if (bitrate >= currentRepresentation.bitrate) {
        return false;
      }
      return shouldDirectlySwitchToLowBitrate(
        playbackInfo,
        currentRequests,
        this._lowLatencyMode
      );
    }
  };

  // src/core/adaptive/utils/last_estimate_storage.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var LastEstimateStorage = class {
    constructor() {
      this.bandwidth = void 0;
      this.representation = null;
      this.algorithmType = 3 /* None */;
    }
    /**
     * Update this `LastEstimateStorage` with new values.
     * @param {Object} representation - Estimated Representation.
     * @param {number|undefined} bandwidth - Estimated bandwidth.
     * @param {number} algorithmType - The type of algorithm used to produce that
     * estimate.
     */
    update(representation, bandwidth, algorithmType) {
      this.representation = representation;
      this.bandwidth = bandwidth;
      this.algorithmType = algorithmType;
    }
  };

  // src/core/adaptive/guess_based_chooser.ts
  var GuessBasedChooser = class {
    /**
     * Create a new `GuessBasedChooser`.
     * @param {Object} scoreCalculator
     * @param {Object} prevEstimate
     */
    constructor(scoreCalculator, prevEstimate) {
      this._scoreCalculator = scoreCalculator;
      this._lastAbrEstimate = prevEstimate;
      this._consecutiveWrongGuesses = 0;
      this._blockGuessesUntil = 0;
      this._lastMaintanableBitrate = null;
    }
    /**
     * Perform a "guess", which basically indicates which Representation should be
     * chosen according to the `GuessBasedChooser`.
     *
     * @param {Array.<Object>} representations - Array of all Representation the
     * GuessBasedChooser can choose from, sorted by bitrate ascending.
     * /!\ It is very important that Representation in that Array are sorted by
     * bitrate ascending for this method to work as intented.
     * @param {Object} observation - Last playback observation performed.
     * @param {Object} currentRepresentation - The Representation currently
     * loading.
     * @param {number} incomingBestBitrate - The bitrate of the Representation
     * chosen by the more optimistic of the other ABR algorithms currently.
     * @param {Array.<Object>} requests - Information on all pending requests.
     * @returns {Object|null} - If a guess is made, return that guess, else
     * returns `null` (in which case you should fallback to another ABR
     * algorithm).
     */
    getGuess(representations, observation, currentRepresentation, incomingBestBitrate, requests) {
      const { bufferGap, speed } = observation;
      const lastChosenRep = this._lastAbrEstimate.representation;
      if (lastChosenRep === null) {
        return null;
      }
      if (incomingBestBitrate > lastChosenRep.bitrate) {
        if (this._lastAbrEstimate.algorithmType === 2 /* GuessBased */) {
          if (this._lastAbrEstimate.representation !== null) {
            this._lastMaintanableBitrate = this._lastAbrEstimate.representation.bitrate;
          }
          this._consecutiveWrongGuesses = 0;
        }
        return null;
      }
      const scoreData = this._scoreCalculator.getEstimate(currentRepresentation);
      if (this._lastAbrEstimate.algorithmType !== 2 /* GuessBased */) {
        if (scoreData === void 0) {
          return null;
        }
        if (this._canGuessHigher(bufferGap, speed, scoreData)) {
          const nextRepresentation = getNextRepresentation(
            representations,
            currentRepresentation
          );
          if (nextRepresentation !== null) {
            return nextRepresentation;
          }
        }
        return null;
      }
      if (this._isLastGuessValidated(lastChosenRep, incomingBestBitrate, scoreData)) {
        log_default.debug("ABR: Guessed Representation validated", lastChosenRep.bitrate);
        this._lastMaintanableBitrate = lastChosenRep.bitrate;
        this._consecutiveWrongGuesses = 0;
      }
      if (currentRepresentation.id !== lastChosenRep.id) {
        return lastChosenRep;
      }
      const shouldStopGuess = this._shouldStopGuess(
        currentRepresentation,
        scoreData,
        bufferGap,
        requests
      );
      if (shouldStopGuess) {
        this._consecutiveWrongGuesses++;
        this._blockGuessesUntil = monotonic_timestamp_default() + Math.min(this._consecutiveWrongGuesses * 15e3, 12e4);
        return getPreviousRepresentation(representations, currentRepresentation);
      } else if (scoreData === void 0) {
        return currentRepresentation;
      }
      if (this._canGuessHigher(bufferGap, speed, scoreData)) {
        const nextRepresentation = getNextRepresentation(
          representations,
          currentRepresentation
        );
        if (nextRepresentation !== null) {
          return nextRepresentation;
        }
      }
      return currentRepresentation;
    }
    /**
     * Returns `true` if we've enough confidence on the current situation to make
     * a higher guess.
     * @param {number} bufferGap
     * @param {number} speed
     * @param {Array} scoreData
     * @returns {boolean}
     */
    _canGuessHigher(bufferGap, speed, { score, confidenceLevel }) {
      return isFinite(bufferGap) && bufferGap >= 2.5 && monotonic_timestamp_default() > this._blockGuessesUntil && confidenceLevel === 1 /* HIGH */ && score / speed > 1.01;
    }
    /**
     * Returns `true` if the pending guess of `lastGuess` seems to not
     * be maintainable and as such should be stopped.
     * @param {Object} lastGuess
     * @param {Array} scoreData
     * @param {number} bufferGap
     * @param {Array.<Object>} requests
     * @returns {boolean}
     */
    _shouldStopGuess(lastGuess, scoreData, bufferGap, requests) {
      if (scoreData !== void 0 && scoreData.score < 1.01) {
        return true;
      } else if ((scoreData === void 0 || scoreData.score < 1.2) && bufferGap < 0.6) {
        return true;
      }
      const guessedRepresentationRequests = requests.filter((req) => {
        return req.content.representation.id === lastGuess.id;
      });
      const now = monotonic_timestamp_default();
      for (const req of guessedRepresentationRequests) {
        const requestElapsedTime = now - req.requestTimestamp;
        if (req.content.segment.isInit) {
          if (requestElapsedTime > 1e3) {
            return true;
          }
        } else if (requestElapsedTime > req.content.segment.duration * 1e3 + 200) {
          return true;
        } else {
          const fastBw = estimateRequestBandwidth(req);
          if (fastBw !== void 0 && fastBw < lastGuess.bitrate * 0.8) {
            return true;
          }
        }
      }
      return false;
    }
    _isLastGuessValidated(lastGuess, incomingBestBitrate, scoreData) {
      if (scoreData !== void 0 && scoreData.confidenceLevel === 1 /* HIGH */ && scoreData.score > 1.5) {
        return true;
      }
      return incomingBestBitrate >= lastGuess.bitrate && (this._lastMaintanableBitrate === null || this._lastMaintanableBitrate < lastGuess.bitrate);
    }
  };
  function getNextRepresentation(representations, currentRepresentation) {
    const len = representations.length;
    let index = arrayFindIndex(
      representations,
      ({ id }) => id === currentRepresentation.id
    );
    if (index < 0) {
      log_default.error("ABR: Current Representation not found.");
      return null;
    }
    while (++index < len) {
      if (representations[index].bitrate > currentRepresentation.bitrate) {
        return representations[index];
      }
    }
    return null;
  }
  function getPreviousRepresentation(representations, currentRepresentation) {
    let index = arrayFindIndex(
      representations,
      ({ id }) => id === currentRepresentation.id
    );
    if (index < 0) {
      log_default.error("ABR: Current Representation not found.");
      return null;
    }
    while (--index >= 0) {
      if (representations[index].bitrate < currentRepresentation.bitrate) {
        return representations[index];
      }
    }
    return null;
  }

  // src/core/adaptive/utils/bandwidth_estimator.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var BandwidthEstimator = class {
    constructor() {
      const { ABR_FAST_EMA, ABR_SLOW_EMA } = config_default.getCurrent();
      this._fastEWMA = new EWMA(ABR_FAST_EMA);
      this._slowEWMA = new EWMA(ABR_SLOW_EMA);
      this._bytesSampled = 0;
    }
    /**
     * Takes a bandwidth sample.
     * @param {number} durationInMs - The amount of time, in milliseconds, for a
     * particular request.
     * @param {number} numberOfBytes - The total number of bytes transferred in
     * that request.
     */
    addSample(durationInMs, numberOfBytes) {
      const { ABR_MINIMUM_CHUNK_SIZE } = config_default.getCurrent();
      if (numberOfBytes < ABR_MINIMUM_CHUNK_SIZE) {
        return;
      }
      const bandwidth = numberOfBytes * 8e3 / durationInMs;
      const weight = durationInMs / 1e3;
      this._bytesSampled += numberOfBytes;
      this._fastEWMA.addSample(weight, bandwidth);
      this._slowEWMA.addSample(weight, bandwidth);
    }
    /**
     * Get estimate of the bandwidth, in bits per seconds.
     * @returns {Number|undefined}
     */
    getEstimate() {
      const { ABR_MINIMUM_TOTAL_BYTES } = config_default.getCurrent();
      if (this._bytesSampled < ABR_MINIMUM_TOTAL_BYTES) {
        return void 0;
      }
      return Math.min(this._fastEWMA.getEstimate(), this._slowEWMA.getEstimate());
    }
    /** Reset the bandwidth estimation. */
    reset() {
      const { ABR_FAST_EMA, ABR_SLOW_EMA } = config_default.getCurrent();
      this._fastEWMA = new EWMA(ABR_FAST_EMA);
      this._slowEWMA = new EWMA(ABR_SLOW_EMA);
      this._bytesSampled = 0;
    }
  };

  // src/core/adaptive/utils/filter_by_bitrate.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function filterByBitrate(representations, bitrate) {
    if (representations.length === 0) {
      return [];
    }
    representations.sort((ra, rb) => ra.bitrate - rb.bitrate);
    const minimumBitrate = representations[0].bitrate;
    const bitrateCeil = Math.max(bitrate, minimumBitrate);
    const firstSuperiorBitrateIndex = arrayFindIndex(
      representations,
      (representation) => representation.bitrate > bitrateCeil
    );
    if (firstSuperiorBitrateIndex === -1) {
      return representations;
    }
    return representations.slice(0, firstSuperiorBitrateIndex);
  }

  // src/core/adaptive/utils/filter_by_resolution.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function filterByResolution(representations, resolution) {
    if (resolution.width === void 0 || resolution.height === void 0) {
      return representations;
    }
    const width = resolution.width * resolution.pixelRatio;
    const height = resolution.height * resolution.pixelRatio;
    const sortedRepsByWidth = representations.slice().sort((a, b) => {
      var _a, _b;
      return ((_a = a.width) != null ? _a : 0) - ((_b = b.width) != null ? _b : 0);
    });
    const repWithMaxWidth = arrayFind(
      sortedRepsByWidth,
      (representation) => typeof representation.width === "number" && representation.width >= width && typeof representation.height === "number" && representation.height >= height
    );
    if (repWithMaxWidth === void 0) {
      return representations;
    }
    const maxWidth = typeof repWithMaxWidth.width === "number" ? repWithMaxWidth.width : 0;
    return representations.filter(
      (representation) => typeof representation.width === "number" ? representation.width <= maxWidth : true
    );
  }

  // src/core/adaptive/utils/pending_requests_store.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var PendingRequestsStore = class {
    constructor() {
      this._currentRequests = {};
    }
    /**
     * Add information about a new pending request.
     * @param {Object} payload
     */
    add(payload) {
      const { id, requestTimestamp, content } = payload;
      this._currentRequests[id] = { requestTimestamp, progress: [], content };
    }
    /**
     * Notify of the progress of a currently pending request.
     * @param {Object} progress
     */
    addProgress(progress) {
      const request2 = this._currentRequests[progress.id];
      if (isNullOrUndefined(request2)) {
        if (define_ENVIRONMENT_default.CURRENT_ENV === define_ENVIRONMENT_default.DEV) {
          throw new Error("ABR: progress for a request not added");
        }
        log_default.warn("ABR: progress for a request not added");
        return;
      }
      request2.progress.push(progress);
    }
    /**
     * Remove a request previously set as pending.
     * @param {string} id
     */
    remove(id) {
      if (isNullOrUndefined(this._currentRequests[id])) {
        if (define_ENVIRONMENT_default.CURRENT_ENV === define_ENVIRONMENT_default.DEV) {
          throw new Error("ABR: can't remove unknown request");
        }
        log_default.warn("ABR: can't remove unknown request");
      }
      delete this._currentRequests[id];
    }
    /**
     * Returns information about all pending requests, in segment's chronological
     * order.
     * @returns {Array.<Object>}
     */
    getRequests() {
      return object_values_default(this._currentRequests).filter((x) => !isNullOrUndefined(x)).sort((reqA, reqB) => reqA.content.segment.time - reqB.content.segment.time);
    }
  };

  // src/core/adaptive/utils/select_optimal_representation.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function selectOptimalRepresentation(representations, wantedBitrate) {
    const firstIndexTooHigh = arrayFindIndex(
      representations,
      (representation) => representation.bitrate > wantedBitrate
    );
    if (firstIndexTooHigh === -1) {
      return representations[representations.length - 1];
    } else if (firstIndexTooHigh === 0) {
      return representations[0];
    }
    return representations[firstIndexTooHigh - 1];
  }

  // src/core/adaptive/adaptive_representation_selector.ts
  var limitResolutionDefaultRef = new reference_default(
    void 0
  );
  limitResolutionDefaultRef.finish();
  var throttleBitrateDefaultRef = new reference_default(Infinity);
  throttleBitrateDefaultRef.finish();
  function createAdaptiveRepresentationSelector(options) {
    const bandwidthEstimators = {};
    const { initialBitrates, throttlers, lowLatencyMode } = options;
    return function getEstimates(context, currentRepresentation, representations, playbackObserver, stopAllEstimates) {
      var _a, _b, _c;
      const { type } = context.adaptation;
      const bandwidthEstimator = _getBandwidthEstimator(type);
      const initialBitrate = (_a = initialBitrates[type]) != null ? _a : 0;
      const filters = {
        limitResolution: (_b = throttlers.limitResolution[type]) != null ? _b : limitResolutionDefaultRef,
        throttleBitrate: (_c = throttlers.throttleBitrate[type]) != null ? _c : throttleBitrateDefaultRef
      };
      return getEstimateReference(
        {
          bandwidthEstimator,
          context,
          currentRepresentation,
          filters,
          initialBitrate,
          playbackObserver,
          representations,
          lowLatencyMode
        },
        stopAllEstimates
      );
    };
    function _getBandwidthEstimator(bufferType) {
      const originalBandwidthEstimator = bandwidthEstimators[bufferType];
      if (isNullOrUndefined(originalBandwidthEstimator)) {
        log_default.debug("ABR: Creating new BandwidthEstimator for ", bufferType);
        const bandwidthEstimator = new BandwidthEstimator();
        bandwidthEstimators[bufferType] = bandwidthEstimator;
        return bandwidthEstimator;
      }
      return originalBandwidthEstimator;
    }
  }
  function getEstimateReference({
    bandwidthEstimator,
    context,
    currentRepresentation,
    filters,
    initialBitrate,
    lowLatencyMode,
    playbackObserver,
    representations: representationsRef
  }, stopAllEstimates) {
    const scoreCalculator = new RepresentationScoreCalculator();
    const networkAnalyzer = new NetworkAnalyzer(initialBitrate != null ? initialBitrate : 0, lowLatencyMode);
    const requestsStore = new PendingRequestsStore();
    let onAddedSegment = noop_default;
    const callbacks = {
      metrics: onMetric,
      requestBegin: onRequestBegin,
      requestProgress: onRequestProgress,
      requestEnd: onRequestEnd,
      addedSegment(val) {
        onAddedSegment(val);
      }
    };
    let currentEstimatesCanceller = new TaskCanceller();
    currentEstimatesCanceller.linkToSignal(stopAllEstimates);
    const estimateRef = createEstimateReference(
      representationsRef.getValue(),
      currentEstimatesCanceller.signal
    );
    representationsRef.onUpdate(restartEstimatesProductionFromCurrentConditions, {
      clearSignal: stopAllEstimates
    });
    return { estimates: estimateRef, callbacks };
    function createEstimateReference(unsortedRepresentations, innerCancellationSignal) {
      if (unsortedRepresentations.length <= 1) {
        return new reference_default({
          bitrate: void 0,
          representation: unsortedRepresentations[0],
          urgent: true,
          knownStableBitrate: void 0
        });
      }
      let allowBufferBasedEstimates = false;
      const sortedRepresentations = unsortedRepresentations.sort(
        (ra, rb) => ra.bitrate - rb.bitrate
      );
      const bufferBasedChooser = new BufferBasedChooser(
        sortedRepresentations.map((r) => r.bitrate)
      );
      const prevEstimate = new LastEstimateStorage();
      const guessBasedChooser = new GuessBasedChooser(scoreCalculator, prevEstimate);
      let lastPlaybackObservation = playbackObserver.getReference().getValue();
      const innerEstimateRef = new reference_default(getCurrentEstimate());
      playbackObserver.listen(
        (obs) => {
          lastPlaybackObservation = obs;
          updateEstimate();
        },
        { includeLastObservation: false, clearSignal: innerCancellationSignal }
      );
      onAddedSegment = function(val) {
        if (lastPlaybackObservation === null) {
          return;
        }
        const { position, speed } = lastPlaybackObservation;
        const timeRanges = val.buffered;
        const bufferGap = getLeftSizeOfRange(timeRanges, position.getWanted());
        const { representation } = val.content;
        const currentScore = scoreCalculator.getEstimate(representation);
        const currentBitrate = representation.bitrate;
        const observation = { bufferGap, currentBitrate, currentScore, speed };
        bufferBasedChooser.onAddedSegment(observation);
        updateEstimate();
      };
      innerCancellationSignal.register(() => {
        onAddedSegment = noop_default;
      });
      filters.throttleBitrate.onUpdate(updateEstimate, {
        clearSignal: innerCancellationSignal
      });
      filters.limitResolution.onUpdate(updateEstimate, {
        clearSignal: innerCancellationSignal
      });
      return innerEstimateRef;
      function updateEstimate() {
        innerEstimateRef.setValue(getCurrentEstimate());
      }
      function getCurrentEstimate() {
        const { bufferGap, position, maximumPosition } = lastPlaybackObservation;
        const resolutionLimit = filters.limitResolution.getValue();
        const bitrateThrottle = filters.throttleBitrate.getValue();
        const currentRepresentationVal = currentRepresentation.getValue();
        const filteredReps = getFilteredRepresentations(
          sortedRepresentations,
          resolutionLimit,
          bitrateThrottle
        );
        const requests = requestsStore.getRequests();
        const { bandwidthEstimate, bitrateChosen } = networkAnalyzer.getBandwidthEstimate(
          lastPlaybackObservation,
          bandwidthEstimator,
          currentRepresentationVal,
          requests,
          prevEstimate.bandwidth
        );
        const stableRepresentation = scoreCalculator.getLastStableRepresentation();
        const knownStableBitrate = stableRepresentation === null ? void 0 : stableRepresentation.bitrate / (lastPlaybackObservation.speed > 0 ? lastPlaybackObservation.speed : 1);
        const { ABR_ENTER_BUFFER_BASED_ALGO, ABR_EXIT_BUFFER_BASED_ALGO } = config_default.getCurrent();
        if (allowBufferBasedEstimates && bufferGap <= ABR_EXIT_BUFFER_BASED_ALGO) {
          allowBufferBasedEstimates = false;
        } else if (!allowBufferBasedEstimates && isFinite(bufferGap) && bufferGap >= ABR_ENTER_BUFFER_BASED_ALGO) {
          allowBufferBasedEstimates = true;
        }
        const chosenRepFromBandwidth = selectOptimalRepresentation(
          filteredReps,
          bitrateChosen
        );
        const currentBufferBasedEstimate = bufferBasedChooser.getLastEstimate();
        let currentBestBitrate = chosenRepFromBandwidth.bitrate;
        let chosenRepFromBufferSize = null;
        if (allowBufferBasedEstimates && currentBufferBasedEstimate !== void 0 && currentBufferBasedEstimate > currentBestBitrate) {
          chosenRepFromBufferSize = selectOptimalRepresentation(
            filteredReps,
            currentBufferBasedEstimate
          );
          currentBestBitrate = chosenRepFromBufferSize.bitrate;
        }
        let chosenRepFromGuessMode = null;
        if (lowLatencyMode && currentRepresentationVal !== null && context.manifest.isDynamic && maximumPosition - position.getWanted() < 40) {
          chosenRepFromGuessMode = guessBasedChooser.getGuess(
            sortedRepresentations,
            lastPlaybackObservation,
            currentRepresentationVal,
            currentBestBitrate,
            requests
          );
        }
        if (chosenRepFromGuessMode !== null && chosenRepFromGuessMode.bitrate > currentBestBitrate) {
          log_default.debug(
            "ABR: Choosing representation with guess-based estimation.",
            chosenRepFromGuessMode.bitrate,
            chosenRepFromGuessMode.id
          );
          prevEstimate.update(
            chosenRepFromGuessMode,
            bandwidthEstimate,
            2 /* GuessBased */
          );
          return {
            bitrate: bandwidthEstimate,
            representation: chosenRepFromGuessMode,
            urgent: currentRepresentationVal === null || chosenRepFromGuessMode.bitrate < currentRepresentationVal.bitrate,
            knownStableBitrate
          };
        } else if (chosenRepFromBufferSize !== null) {
          log_default.debug(
            "ABR: Choosing representation with buffer-based estimation.",
            chosenRepFromBufferSize.bitrate,
            chosenRepFromBufferSize.id
          );
          prevEstimate.update(
            chosenRepFromBufferSize,
            bandwidthEstimate,
            0 /* BufferBased */
          );
          return {
            bitrate: bandwidthEstimate,
            representation: chosenRepFromBufferSize,
            urgent: networkAnalyzer.isUrgent(
              chosenRepFromBufferSize.bitrate,
              currentRepresentationVal,
              requests,
              lastPlaybackObservation
            ),
            knownStableBitrate
          };
        } else {
          log_default.debug(
            "ABR: Choosing representation with bandwidth estimation.",
            chosenRepFromBandwidth.bitrate,
            chosenRepFromBandwidth.id
          );
          prevEstimate.update(
            chosenRepFromBandwidth,
            bandwidthEstimate,
            1 /* BandwidthBased */
          );
          return {
            bitrate: bandwidthEstimate,
            representation: chosenRepFromBandwidth,
            urgent: networkAnalyzer.isUrgent(
              chosenRepFromBandwidth.bitrate,
              currentRepresentationVal,
              requests,
              lastPlaybackObservation
            ),
            knownStableBitrate
          };
        }
      }
    }
    function restartEstimatesProductionFromCurrentConditions() {
      const representations = representationsRef.getValue();
      currentEstimatesCanceller.cancel();
      currentEstimatesCanceller = new TaskCanceller();
      currentEstimatesCanceller.linkToSignal(stopAllEstimates);
      const newRef = createEstimateReference(
        representations,
        currentEstimatesCanceller.signal
      );
      newRef.onUpdate(
        function onNewEstimate(newEstimate) {
          estimateRef.setValue(newEstimate);
        },
        { clearSignal: currentEstimatesCanceller.signal, emitCurrentValue: true }
      );
    }
    function onMetric(value) {
      const { requestDuration, segmentDuration, size, content } = value;
      bandwidthEstimator.addSample(requestDuration, size);
      if (!content.segment.isInit) {
        const { segment, representation } = content;
        if (segmentDuration === void 0 && !segment.complete) {
          return;
        }
        const segDur = segmentDuration != null ? segmentDuration : segment.duration;
        scoreCalculator.addSample(representation, requestDuration / 1e3, segDur);
      }
    }
    function onRequestBegin(val) {
      requestsStore.add(val);
    }
    function onRequestProgress(val) {
      requestsStore.addProgress(val);
    }
    function onRequestEnd(val) {
      requestsStore.remove(val.id);
    }
  }
  function getFilteredRepresentations(representations, resolutionLimit, bitrateThrottle) {
    let filteredReps = representations;
    if (bitrateThrottle !== void 0 && bitrateThrottle < Infinity) {
      filteredReps = filterByBitrate(filteredReps, bitrateThrottle);
    }
    if (resolutionLimit !== void 0) {
      filteredReps = filterByResolution(filteredReps, resolutionLimit);
    }
    return filteredReps;
  }

  // src/core/adaptive/index.ts
  var adaptive_default = createAdaptiveRepresentationSelector;

  // src/core/cmcd/index.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/core/cmcd/cmcd_data_builder.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/utils/create_uuid.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function createUuid() {
    var _a;
    if (typeof ((_a = global_scope_default.crypto) == null ? void 0 : _a.randomUUID) === "function") {
      return global_scope_default.crypto.randomUUID();
    }
    let ts1 = (/* @__PURE__ */ new Date()).getTime();
    let ts2 = monotonic_timestamp_default();
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
      let r = Math.random() * 16;
      if (ts1 > 0) {
        r = (ts1 + r) % 16 | 0;
        ts1 = Math.floor(ts1 / 16);
      } else {
        r = (ts2 + r) % 16 | 0;
        ts2 = Math.floor(ts2 / 16);
      }
      return (c === "x" ? r : r & 3 | 8).toString(16);
    });
  }

  // src/core/cmcd/cmcd_data_builder.ts
  var RTP_FACTOR = 4;
  var CmcdDataBuilder = class {
    /**
     * Create a new `CmcdDataBuilder`, linked to the given options (see type
     * definition).
     * @param {Object} options
     */
    constructor(options) {
      var _a, _b;
      this._sessionId = (_a = options.sessionId) != null ? _a : createUuid();
      this._contentId = (_b = options.contentId) != null ? _b : createUuid();
      this._typePreference = options.communicationType === "headers" ? 0 /* Headers */ : 1 /* QueryString */;
      this._bufferStarvationToggle = false;
      this._playbackObserver = null;
      this._lastThroughput = {};
      this._canceller = null;
    }
    /**
     * Start listening to the given `playbackObserver` so the `CmcdDataBuilder`
     * can extract some playback-linked metadata that it needs.
     *
     * It will keep listening for media data until `stopMonitoringPlayback` is called.
     *
     * If `startMonitoringPlayback` is called again, the previous monitoring is
     * also cancelled.
     * @param {Object} playbackObserver
     */
    startMonitoringPlayback(playbackObserver) {
      var _a;
      (_a = this._canceller) == null ? void 0 : _a.cancel();
      this._canceller = new TaskCanceller();
      this._playbackObserver = playbackObserver;
      playbackObserver.listen(
        (obs) => {
          if (obs.rebuffering !== null) {
            this._bufferStarvationToggle = true;
          }
        },
        { includeLastObservation: true, clearSignal: this._canceller.signal }
      );
    }
    /**
     * Stop the monitoring of playback conditions started from the last
     * `stopMonitoringPlayback` call.
     */
    stopMonitoringPlayback() {
      var _a;
      (_a = this._canceller) == null ? void 0 : _a.cancel();
      this._canceller = null;
      this._playbackObserver = null;
    }
    /**
     * Update the last measured throughput for a specific media type.
     * Needed for some of CMCD's properties.
     * @param {string} trackType
     * @param {number|undefined} throughput - Last throughput measured for that
     * media type. `undefined` if unknown.
     */
    updateThroughput(trackType, throughput) {
      this._lastThroughput[trackType] = throughput;
    }
    /**
     * Returns the base of data that is common to all resources' requests.
     * @param {number|undefined} lastThroughput - The last measured throughput to
     * provide. `undefined` to provide no throughput.
     * @returns {Object}
     */
    _getCommonCmcdData(lastThroughput) {
      var _a;
      const props = {};
      props.bs = this._bufferStarvationToggle;
      this._bufferStarvationToggle = false;
      props.cid = this._contentId;
      props.mtp = lastThroughput !== void 0 ? Math.floor(Math.round(lastThroughput / 1e3 / 100) * 100) : void 0;
      props.sid = this._sessionId;
      const lastObservation = (_a = this._playbackObserver) == null ? void 0 : _a.getReference().getValue();
      props.pr = lastObservation === void 0 || lastObservation.speed === 1 ? void 0 : lastObservation.speed;
      if (lastObservation !== void 0) {
        props.su = lastObservation.rebuffering !== null;
      }
      return props;
    }
    /**
     * For the given type of Manifest, returns the corresponding CMCD payload
     * that should be provided alongside its request.
     * @param {string} transportType
     * @returns {Object}
     */
    getCmcdDataForManifest(transportType) {
      var _a;
      const props = this._getCommonCmcdData(
        (_a = this._lastThroughput.video) != null ? _a : this._lastThroughput.audio
      );
      props.ot = "m";
      switch (transportType) {
        case "dash":
          props.sf = "d";
          break;
        case "smooth":
          props.sf = "s";
          break;
        default:
          props.sf = "o";
          break;
      }
      return this._producePayload(props);
    }
    /**
     * For the given segment information, returns the corresponding CMCD payload
     * that should be provided alongside its request.
     * @param {Object} content
     * @returns {Object}
     */
    getCmcdDataForSegmentRequest(content) {
      var _a, _b, _c, _d;
      const lastObservation = (_a = this._playbackObserver) == null ? void 0 : _a.getReference().getValue();
      const props = this._getCommonCmcdData(this._lastThroughput[content.adaptation.type]);
      props.br = Math.round(content.representation.bitrate / 1e3);
      props.d = Math.round(content.segment.duration * 1e3);
      switch (content.adaptation.type) {
        case "video":
          props.ot = "v";
          break;
        case "audio":
          props.ot = "a";
          break;
        case "text":
          props.ot = "c";
          break;
      }
      if (content.segment.isInit) {
        props.ot = "i";
      }
      let precizeBufferLengthMs;
      if (lastObservation !== void 0 && (props.ot === "v" || props.ot === "a" || props.ot === "av")) {
        const bufferedForType = lastObservation.buffered[content.adaptation.type];
        if (!isNullOrUndefined(bufferedForType)) {
          const position = (_d = (_c = (_b = this._playbackObserver) == null ? void 0 : _b.getCurrentTime()) != null ? _c : lastObservation.position.getWanted()) != null ? _d : lastObservation.position.getPolled();
          for (const range of bufferedForType) {
            if (position >= range.start && position < range.end) {
              precizeBufferLengthMs = (range.end - position) * 1e3;
              props.bl = Math.floor(Math.round(precizeBufferLengthMs / 100) * 100);
              break;
            }
          }
        }
      }
      const precizeDeadlineMs = precizeBufferLengthMs === void 0 || lastObservation === void 0 ? void 0 : precizeBufferLengthMs / lastObservation.speed;
      props.dl = precizeDeadlineMs === void 0 ? void 0 : Math.floor(Math.round(precizeDeadlineMs / 100) * 100);
      if (precizeDeadlineMs !== void 0) {
        const estimatedFileSizeKb = content.representation.bitrate * content.segment.duration / 1e3;
        const wantedCeilBandwidthKbps = estimatedFileSizeKb / (precizeDeadlineMs / 1e3);
        props.rtp = Math.floor(
          Math.round(wantedCeilBandwidthKbps * RTP_FACTOR / 100) * 100
        );
      }
      switch (content.manifest.transport) {
        case "dash":
          props.sf = "d";
          break;
        case "smooth":
          props.sf = "s";
          break;
        default:
          props.sf = "o";
          break;
      }
      props.st = content.manifest.isDynamic ? "l" : "v";
      props.tb = content.adaptation.representations.reduce(
        (acc, representation) => {
          if (representation.isSupported !== true || representation.decipherable === false) {
            return acc;
          }
          if (acc === void 0) {
            return Math.round(representation.bitrate / 1e3);
          }
          return Math.max(acc, Math.round(representation.bitrate / 1e3));
        },
        void 0
      );
      return this._producePayload(props);
    }
    /**
     * From the given CMCD properties, produce the corresponding payload according
     * to current settings.
     * @param {Object} props
     * @returns {Object}
     */
    _producePayload(props) {
      const headers = {
        object: "",
        request: "",
        session: "",
        status: ""
      };
      let queryStringPayload = "";
      const addPayload = (payload, headerName) => {
        if (this._typePreference === 0 /* Headers */) {
          headers[headerName] += payload;
        } else {
          queryStringPayload += payload;
        }
      };
      const addNumberProperty = (prop, headerName) => {
        const val = props[prop];
        if (val !== void 0) {
          const toAdd = `${prop}=${String(val)},`;
          addPayload(toAdd, headerName);
        }
      };
      const addBooleanProperty = (prop, headerName) => {
        if (props[prop] === true) {
          const toAdd = `${prop},`;
          addPayload(toAdd, headerName);
        }
      };
      const addStringProperty = (prop, headerName) => {
        const val = props[prop];
        if (val !== void 0) {
          const formatted = `"${val.replace("\\", "\\\\").replace('"', '\\"')}"`;
          const toAdd = `prop=${formatted},`;
          addPayload(toAdd, headerName);
        }
      };
      const addTokenProperty = (prop, headerName) => {
        const val = props[prop];
        if (val !== void 0) {
          const toAdd = `prop=${val},`;
          addPayload(toAdd, headerName);
        }
      };
      addNumberProperty("bl", "request");
      addNumberProperty("br", "object");
      addBooleanProperty("bs", "status");
      addStringProperty("cid", "session");
      addNumberProperty("d", "object");
      addNumberProperty("dl", "request");
      addNumberProperty("mtp", "request");
      addTokenProperty("ot", "object");
      addNumberProperty("pr", "session");
      addNumberProperty("rtp", "status");
      addTokenProperty("sf", "session");
      addStringProperty("sid", "session");
      addTokenProperty("st", "session");
      addBooleanProperty("su", "request");
      addNumberProperty("tb", "object");
      if (this._typePreference === 0 /* Headers */) {
        if (headers.object[headers.object.length - 1] === ",") {
          headers.object = headers.object.substring(0, headers.object.length - 1);
        }
        if (headers.request[headers.request.length - 1] === ",") {
          headers.request = headers.request.substring(0, headers.request.length - 1);
        }
        if (headers.session[headers.session.length - 1] === ",") {
          headers.session = headers.session.substring(0, headers.session.length - 1);
        }
        if (headers.status[headers.status.length - 1] === ",") {
          headers.status = headers.status.substring(0, headers.status.length - 1);
        }
        log_default.debug("CMCD: proposing headers payload");
        return {
          type: "headers",
          value: {
            /* eslint-disable @typescript-eslint/naming-convention */
            "CMCD-Object": headers.object,
            "CMCD-Request": headers.request,
            "CMCD-Session": headers.session,
            "CMCD-Status": headers.status
            /* eslint-enable @typescript-eslint/naming-convention */
          }
        };
      }
      if (queryStringPayload[queryStringPayload.length - 1] === ",") {
        queryStringPayload = queryStringPayload.substring(0, queryStringPayload.length - 1);
      }
      queryStringPayload = encodeURIComponent(queryStringPayload);
      log_default.debug("CMCD: proposing query string payload", queryStringPayload);
      return {
        type: "query",
        value: [["CMCD", queryStringPayload]]
      };
    }
  };

  // src/core/cmcd/index.ts
  var cmcd_default = CmcdDataBuilder;

  // src/core/fetchers/index.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/core/fetchers/cdn_prioritizer.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var CdnPrioritizer = class extends EventEmitter {
    /**
     * @param {Object} destroySignal
     */
    constructor(destroySignal) {
      super();
      this._downgradedCdnList = { metadata: [], timeouts: [] };
      destroySignal.register(() => {
        for (const timeout of this._downgradedCdnList.timeouts) {
          clearTimeout(timeout);
        }
        this._downgradedCdnList = { metadata: [], timeouts: [] };
      });
    }
    /**
     * From the list of __ALL__ CDNs available to a resource, return them in the
     * order in which requests should be performed.
     *
     * Note: It is VERY important to include all CDN that are able to reach the
     * wanted resource, even those which will in the end not be used anyway.
     * If some CDN are not communicated, the `CdnPrioritizer` might wrongly
     * consider that the current resource don't have any of the CDN prioritized
     * internally and return other CDN which should have been forbidden if it knew
     * about the other, non-used, ones.
     *
     * @param {Array.<string>} everyCdnForResource - Array of ALL available CDN
     * able to reach the wanted resource - even those which might not be used in
     * the end.
     * @returns {Array.<Object>} - Array of CDN that can be tried to reach the
     * resource, sorted by order of CDN preference, according to the
     * `CdnPrioritizer`'s own list of priorities.
     */
    getCdnPreferenceForResource(everyCdnForResource) {
      if (everyCdnForResource.length <= 1) {
        return everyCdnForResource;
      }
      return this._innerGetCdnPreferenceForResource(everyCdnForResource);
    }
    /**
     * Limit usage of the CDN for a configured amount of time.
     * Call this method if you encountered an issue with that CDN which leads you
     * to want to prevent its usage currently.
     *
     * Note that the CDN can still be the preferred one if no other CDN exist for
     * a wanted resource.
     * @param {string} metadata
     */
    downgradeCdn(metadata) {
      const indexOf = indexOfMetadata(this._downgradedCdnList.metadata, metadata);
      if (indexOf >= 0) {
        this._removeIndexFromDowngradeList(indexOf);
      }
      const { DEFAULT_CDN_DOWNGRADE_TIME } = config_default.getCurrent();
      const downgradeTime = DEFAULT_CDN_DOWNGRADE_TIME;
      this._downgradedCdnList.metadata.push(metadata);
      const timeout = setTimeout(() => {
        const newIndex = indexOfMetadata(this._downgradedCdnList.metadata, metadata);
        if (newIndex >= 0) {
          this._removeIndexFromDowngradeList(newIndex);
        }
        this.trigger("priorityChange", null);
      }, downgradeTime);
      this._downgradedCdnList.timeouts.push(timeout);
      this.trigger("priorityChange", null);
    }
    /**
     * From the list of __ALL__ CDNs available to a resource, return them in the
     * order in which requests should be performed.
     *
     * Note: It is VERY important to include all CDN that are able to reach the
     * wanted resource, even those which will in the end not be used anyway.
     * If some CDN are not communicated, the `CdnPrioritizer` might wrongly
     * consider that the current resource don't have any of the CDN prioritized
     * internally and return other CDN which should have been forbidden if it knew
     * about the other, non-used, ones.
     *
     * @param {Array.<string>} everyCdnForResource - Array of ALL available CDN
     * able to reach the wanted resource - even those which might not be used in
     * the end.
     * @returns {Array.<string>} - Array of CDN that can be tried to reach the
     * resource, sorted by order of CDN preference, according to the
     * `CdnPrioritizer`'s own list of priorities.
     */
    _innerGetCdnPreferenceForResource(everyCdnForResource) {
      const [allowedInOrder, downgradedInOrder] = everyCdnForResource.reduce(
        (acc, elt) => {
          if (this._downgradedCdnList.metadata.some(
            (c) => c.id === elt.id && c.baseUrl === elt.baseUrl
          )) {
            acc[1].push(elt);
          } else {
            acc[0].push(elt);
          }
          return acc;
        },
        [[], []]
      );
      return allowedInOrder.concat(downgradedInOrder);
    }
    /**
     * @param {number} index
     */
    _removeIndexFromDowngradeList(index) {
      this._downgradedCdnList.metadata.splice(index, 1);
      const oldTimeout = this._downgradedCdnList.timeouts.splice(index, 1);
      clearTimeout(oldTimeout[0]);
    }
  };
  function indexOfMetadata(arr, elt) {
    if (arr.length === 0) {
      return -1;
    }
    return elt.id !== void 0 ? arrayFindIndex(arr, (m) => m.id === elt.id) : arrayFindIndex(arr, (m) => m.baseUrl === elt.baseUrl);
  }

  // src/core/fetchers/manifest/index.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/core/fetchers/manifest/manifest_fetcher.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/core/fetchers/utils/error_selector.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function errorSelector(error) {
    if (error instanceof RequestError) {
      return new NetworkError("PIPELINE_LOAD_ERROR", error);
    }
    return formatError(error, {
      defaultCode: "PIPELINE_LOAD_ERROR",
      defaultReason: "Unknown error when fetching the Manifest"
    });
  }

  // src/core/fetchers/utils/schedule_request.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function shouldRetry(error) {
    if (error instanceof RequestError) {
      if (error.type === NetworkErrorTypes.ERROR_HTTP_CODE) {
        return error.status >= 500 || error.status === 404 || error.status === 415 || // some CDN seems to use that code when
        // requesting low-latency segments too much
        // in advance
        error.status === 412;
      }
      return error.type === NetworkErrorTypes.TIMEOUT || error.type === NetworkErrorTypes.ERROR_EVENT;
    } else if (error instanceof CustomLoaderError) {
      if (typeof error.canRetry === "boolean") {
        return error.canRetry;
      }
      if (error.xhr !== void 0) {
        return error.xhr.status >= 500 || error.xhr.status === 404 || error.xhr.status === 415 || // some CDN seems to use that code when
        // requesting low-latency segments too much
        // in advance
        error.xhr.status === 412;
      }
      return false;
    }
    return isKnownError(error) && error.code === "INTEGRITY_ERROR";
  }
  async function scheduleRequestWithCdns(cdns, cdnPrioritizer, performRequest, options, cancellationSignal) {
    if (cancellationSignal.cancellationError !== null) {
      return Promise.reject(cancellationSignal.cancellationError);
    }
    const { baseDelay, maxDelay, maxRetry, onRetry } = options;
    if (cdns !== null && cdns.length === 0) {
      log_default.warn("Fetchers: no CDN given to `scheduleRequestWithCdns`.");
    }
    const missedAttempts = /* @__PURE__ */ new Map();
    const initialCdnToRequest = getCdnToRequest();
    if (initialCdnToRequest === void 0) {
      throw new Error("No CDN to request");
    }
    return requestCdn(initialCdnToRequest);
    function getCdnToRequest() {
      if (cdns === null) {
        const nullAttemptObject = missedAttempts.get(null);
        if (nullAttemptObject !== void 0 && nullAttemptObject.isBlacklisted) {
          return void 0;
        }
        return null;
      } else if (cdnPrioritizer === null) {
        return getPrioritaryRequestableCdnFromSortedList(cdns);
      } else {
        const prioritized = cdnPrioritizer.getCdnPreferenceForResource(cdns);
        return getPrioritaryRequestableCdnFromSortedList(prioritized);
      }
    }
    async function requestCdn(cdn) {
      try {
        const res = await performRequest(cdn, cancellationSignal);
        return res;
      } catch (error) {
        if (TaskCanceller.isCancellationError(error)) {
          throw error;
        }
        if (cdn !== null && cdnPrioritizer !== null) {
          cdnPrioritizer.downgradeCdn(cdn);
        }
        let missedAttemptsObj = missedAttempts.get(cdn);
        if (missedAttemptsObj === void 0) {
          missedAttemptsObj = {
            errorCounter: 1,
            blockedUntil: void 0,
            isBlacklisted: false
          };
          missedAttempts.set(cdn, missedAttemptsObj);
        } else {
          missedAttemptsObj.errorCounter++;
        }
        if (!shouldRetry(error)) {
          missedAttemptsObj.blockedUntil = void 0;
          missedAttemptsObj.isBlacklisted = true;
          return retryWithNextCdn(error);
        }
        if (missedAttemptsObj.errorCounter > maxRetry) {
          missedAttemptsObj.blockedUntil = void 0;
          missedAttemptsObj.isBlacklisted = true;
        } else {
          const errorCounter = missedAttemptsObj.errorCounter;
          const delay = Math.min(baseDelay * Math.pow(2, errorCounter - 1), maxDelay);
          const fuzzedDelay = getFuzzedDelay(delay);
          missedAttemptsObj.blockedUntil = monotonic_timestamp_default() + fuzzedDelay;
        }
        return retryWithNextCdn(error);
      }
    }
    async function retryWithNextCdn(prevRequestError) {
      const nextCdn = getCdnToRequest();
      if (cancellationSignal.isCancelled()) {
        throw cancellationSignal.cancellationError;
      }
      if (nextCdn === void 0) {
        throw prevRequestError;
      }
      onRetry(prevRequestError);
      if (cancellationSignal.isCancelled()) {
        throw cancellationSignal.cancellationError;
      }
      return waitPotentialBackoffAndRequest(nextCdn, prevRequestError);
    }
    function waitPotentialBackoffAndRequest(nextWantedCdn, prevRequestError) {
      const nextCdnAttemptObj = missedAttempts.get(nextWantedCdn);
      if (nextCdnAttemptObj === void 0 || nextCdnAttemptObj.blockedUntil === void 0) {
        return requestCdn(nextWantedCdn);
      }
      const now = monotonic_timestamp_default();
      const blockedFor = nextCdnAttemptObj.blockedUntil - now;
      if (blockedFor <= 0) {
        return requestCdn(nextWantedCdn);
      }
      const canceller = new TaskCanceller();
      const unlinkCanceller = canceller.linkToSignal(cancellationSignal);
      return new Promise((res, rej) => {
        cdnPrioritizer == null ? void 0 : cdnPrioritizer.addEventListener(
          "priorityChange",
          () => {
            const updatedPrioritaryCdn = getCdnToRequest();
            if (cancellationSignal.isCancelled()) {
              throw cancellationSignal.cancellationError;
            }
            if (updatedPrioritaryCdn === void 0) {
              return cleanAndReject(prevRequestError);
            }
            if (updatedPrioritaryCdn !== nextWantedCdn) {
              canceller.cancel();
              waitPotentialBackoffAndRequest(updatedPrioritaryCdn, prevRequestError).then(
                cleanAndResolve,
                cleanAndReject
              );
            }
          },
          canceller.signal
        );
        cancellableSleep(blockedFor, canceller.signal).then(
          () => requestCdn(nextWantedCdn).then(cleanAndResolve, cleanAndReject),
          noop_default
        );
        function cleanAndResolve(response) {
          unlinkCanceller();
          res(response);
        }
        function cleanAndReject(err) {
          unlinkCanceller();
          rej(err);
        }
      });
    }
    function getPrioritaryRequestableCdnFromSortedList(sortedCdns) {
      var _a;
      if (missedAttempts.size === 0) {
        return sortedCdns[0];
      }
      const now = monotonic_timestamp_default();
      return (_a = sortedCdns.filter((c) => {
        var _a2;
        return ((_a2 = missedAttempts.get(c)) == null ? void 0 : _a2.isBlacklisted) !== true;
      }).reduce(
        (acc, x) => {
          var _a2;
          let blockedUntil = (_a2 = missedAttempts.get(x)) == null ? void 0 : _a2.blockedUntil;
          if (blockedUntil !== void 0 && blockedUntil <= now) {
            blockedUntil = void 0;
          }
          if (acc === void 0) {
            return [x, blockedUntil];
          }
          if (acc[1] === void 0) {
            return acc;
          }
          if (blockedUntil === void 0) {
            return [x, void 0];
          }
          if (blockedUntil < acc[1]) {
            return [x, blockedUntil];
          }
          return acc;
        },
        void 0
      )) == null ? void 0 : _a[0];
    }
  }
  function scheduleRequestPromise(performRequest, options, cancellationSignal) {
    return scheduleRequestWithCdns(null, null, performRequest, options, cancellationSignal);
  }

  // src/core/fetchers/manifest/manifest_fetcher.ts
  var ManifestFetcher = class extends EventEmitter {
    /**
     * Construct a new ManifestFetcher.
     * @param {Array.<string> | undefined} urls - Manifest URLs, will be used when
     * no URL is provided to the `fetch` function.
     * `undefined` if unknown or if a Manifest should be retrieved through other
     * means than an HTTP request.
     * @param {Object} pipelines - Transport pipelines used to perform the
     * Manifest loading and parsing operations.
     * @param {Object} settings - Configure the `ManifestFetcher`.
     */
    constructor(urls, pipelines, settings) {
      super();
      this.scheduleManualRefresh = noop_default;
      this._manifestUrls = urls;
      this._pipelines = pipelines.manifest;
      this._transportName = pipelines.transportName;
      this._settings = settings;
      this._canceller = new TaskCanceller();
      this._isStarted = false;
      this._isRefreshPending = false;
      this._consecutiveUnsafeMode = 0;
      this._prioritizedContentUrl = null;
    }
    /**
     * Free resources and stop refresh mechanism from happening.
     *
     * Once `dispose` has been called. This `ManifestFetcher` cannot be relied on
     * anymore.
     */
    dispose() {
      this._canceller.cancel();
      this.removeEventListener();
    }
    /**
     * Start requesting the Manifest as well as the Manifest refreshing logic, if
     * needed.
     *
     * Once `start` has been called, this mechanism can only be stopped by calling
     * `dispose`.
     */
    start() {
      if (this._isStarted) {
        return;
      }
      this._isStarted = true;
      let manifestProm;
      const initialManifest = this._settings.initialManifest;
      if (initialManifest instanceof classes_default) {
        manifestProm = Promise.resolve({ manifest: initialManifest });
      } else if (initialManifest !== void 0) {
        manifestProm = this.parse(
          initialManifest,
          { previousManifest: null, unsafeMode: false },
          void 0
        );
      } else {
        manifestProm = this._fetchManifest(void 0).then((val) => {
          return val.parse({ previousManifest: null, unsafeMode: false });
        });
      }
      manifestProm.then((val) => {
        this.trigger("manifestReady", val.manifest);
        if (!this._canceller.isUsed()) {
          this._recursivelyRefreshManifest(val.manifest, val);
        }
      }).catch((err) => this._onFatalError(err));
    }
    /**
     * Update URL of the fetched Manifest.
     * @param {Array.<string> | undefined} urls - New Manifest URLs by order of
     * priority or `undefined` if there's now no URL.
     * @param {boolean} refreshNow - If set to `true`, the next Manifest refresh
     * will be triggered immediately.
     */
    updateContentUrls(urls, refreshNow) {
      var _a;
      this._prioritizedContentUrl = (_a = urls == null ? void 0 : urls[0]) != null ? _a : void 0;
      if (refreshNow) {
        this.scheduleManualRefresh({
          enablePartialRefresh: false,
          delay: 0,
          canUseUnsafeMode: false
        });
      }
    }
    /**
     * (re-)Load the Manifest.
     * This method does not yet parse it, parsing will then be available through
     * a callback available on the response.
     *
     * You can set an `url` on which that Manifest will be requested.
     * If not set, the regular Manifest url - defined on the `ManifestFetcher`
     * instanciation - will be used instead.
     *
     * @param {string | undefined} url
     * @returns {Promise}
     */
    async _fetchManifest(url) {
      var _a;
      const cancelSignal = this._canceller.signal;
      const settings = this._settings;
      const transportName = this._transportName;
      const pipelines = this._pipelines;
      const requestUrl = url != null ? url : (_a = this._manifestUrls) == null ? void 0 : _a[0];
      const backoffSettings = this._getBackoffSetting((err) => {
        this.trigger("warning", errorSelector(err));
      });
      try {
        const response = await callLoaderWithRetries(requestUrl);
        return {
          parse: (parserOptions) => {
            return this._parseLoadedManifest(response, parserOptions, requestUrl);
          }
        };
      } catch (err) {
        throw errorSelector(err);
      }
      function callLoaderWithRetries(manifestUrl) {
        var _a2;
        const { loadManifest } = pipelines;
        let requestTimeout = settings.requestTimeout === void 0 ? config_default.getCurrent().DEFAULT_REQUEST_TIMEOUT : settings.requestTimeout;
        let connectionTimeout = settings.connectionTimeout === void 0 ? config_default.getCurrent().DEFAULT_CONNECTION_TIMEOUT : settings.connectionTimeout;
        if (requestTimeout < 0) {
          requestTimeout = void 0;
        }
        if (connectionTimeout < 0) {
          connectionTimeout = void 0;
        }
        const requestOptions = {
          timeout: requestTimeout,
          connectionTimeout,
          cmcdPayload: (_a2 = settings.cmcdDataBuilder) == null ? void 0 : _a2.getCmcdDataForManifest(transportName)
        };
        const callLoader = () => loadManifest(manifestUrl, requestOptions, cancelSignal);
        return scheduleRequestPromise(callLoader, backoffSettings, cancelSignal);
      }
    }
    /**
     * Parse an already loaded Manifest.
     *
     * This method should be reserved for Manifests for which no request has been
     * done.
     * In other cases, it's preferable to go through the `fetch` method, so
     * information on the request can be used by the parsing process.
     * @param {*} manifest
     * @param {Object} parserOptions
     * @param {string | undefined} originalUrl
     * @returns {Promise}
     */
    parse(manifest, parserOptions, originalUrl) {
      return this._parseLoadedManifest(
        { responseData: manifest, size: void 0, requestDuration: void 0 },
        parserOptions,
        originalUrl
      );
    }
    /**
     * Parse a Manifest.
     *
     * @param {Object} loaded - Information about the loaded Manifest as well as
     * about the corresponding request.
     * @param {Object} parserOptions - Options used when parsing the Manifest.
     * @param {string | undefined} requestUrl
     * @returns {Promise}
     */
    async _parseLoadedManifest(loaded, parserOptions, requestUrl) {
      var _a;
      const parsingTimeStart = monotonic_timestamp_default();
      const cancelSignal = this._canceller.signal;
      const trigger = this.trigger.bind(this);
      const { sendingTime, receivedTime } = loaded;
      const backoffSettings = this._getBackoffSetting((err) => {
        this.trigger("warning", errorSelector(err));
      });
      const originalUrl = requestUrl != null ? requestUrl : (_a = this._manifestUrls) == null ? void 0 : _a[0];
      const opts = {
        externalClockOffset: parserOptions.externalClockOffset,
        unsafeMode: parserOptions.unsafeMode,
        previousManifest: parserOptions.previousManifest,
        originalUrl
      };
      try {
        const res = this._pipelines.parseManifest(
          loaded,
          opts,
          onWarnings,
          cancelSignal,
          scheduleRequest
        );
        if (!isPromise(res)) {
          return finish(res.manifest, res.warnings);
        } else {
          const { manifest, warnings } = await res;
          return finish(manifest, warnings);
        }
      } catch (err) {
        const formattedError = formatError(err, {
          defaultCode: "PIPELINE_PARSE_ERROR",
          defaultReason: "Unknown error when parsing the Manifest"
        });
        throw formattedError;
      }
      async function scheduleRequest(performRequest) {
        try {
          const data2 = await scheduleRequestPromise(
            performRequest,
            backoffSettings,
            cancelSignal
          );
          return data2;
        } catch (err) {
          throw errorSelector(err);
        }
      }
      function onWarnings(warnings) {
        for (const warning of warnings) {
          if (cancelSignal.isCancelled()) {
            return;
          }
          const formattedError = formatError(warning, {
            defaultCode: "PIPELINE_PARSE_ERROR",
            defaultReason: "Unknown error when parsing the Manifest"
          });
          trigger("warning", formattedError);
        }
      }
      function finish(manifest, warnings) {
        onWarnings(warnings);
        const parsingTime = monotonic_timestamp_default() - parsingTimeStart;
        log_default.info(`MF: Manifest parsed in ${parsingTime}ms`);
        return { manifest, sendingTime, receivedTime, parsingTime };
      }
    }
    /**
     * Construct "backoff settings" that can be used with a range of functions
     * allowing to perform multiple request attempts
     * @param {Function} onRetry
     * @returns {Object}
     */
    _getBackoffSetting(onRetry) {
      const {
        DEFAULT_MAX_MANIFEST_REQUEST_RETRY,
        INITIAL_BACKOFF_DELAY_BASE,
        MAX_BACKOFF_DELAY_BASE
      } = config_default.getCurrent();
      const { lowLatencyMode, maxRetry: ogRegular } = this._settings;
      const baseDelay = lowLatencyMode ? INITIAL_BACKOFF_DELAY_BASE.LOW_LATENCY : INITIAL_BACKOFF_DELAY_BASE.REGULAR;
      const maxDelay = lowLatencyMode ? MAX_BACKOFF_DELAY_BASE.LOW_LATENCY : MAX_BACKOFF_DELAY_BASE.REGULAR;
      const maxRetry = ogRegular != null ? ogRegular : DEFAULT_MAX_MANIFEST_REQUEST_RETRY;
      return { onRetry, baseDelay, maxDelay, maxRetry };
    }
    /**
     * Performs Manifest refresh (recursively) when it judges it is time to do so.
     * @param {Object} manifest
     * @param {Object} manifestRequestInfos - Various information linked to the
     * last Manifest loading and parsing operations.
     */
    _recursivelyRefreshManifest(manifest, {
      sendingTime,
      parsingTime,
      updatingTime
    }) {
      const {
        MAX_CONSECUTIVE_MANIFEST_PARSING_IN_UNSAFE_MODE,
        MIN_MANIFEST_PARSING_TIME_TO_ENTER_UNSAFE_MODE
      } = config_default.getCurrent();
      const totalUpdateTime = parsingTime !== void 0 ? parsingTime + (updatingTime != null ? updatingTime : 0) : void 0;
      let unsafeModeEnabled = false;
      if (this._consecutiveUnsafeMode > 0) {
        unsafeModeEnabled = this._consecutiveUnsafeMode < MAX_CONSECUTIVE_MANIFEST_PARSING_IN_UNSAFE_MODE;
      } else if (totalUpdateTime !== void 0) {
        unsafeModeEnabled = totalUpdateTime >= MIN_MANIFEST_PARSING_TIME_TO_ENTER_UNSAFE_MODE;
      }
      const timeSinceRequest = sendingTime === void 0 ? 0 : monotonic_timestamp_default() - sendingTime;
      const minInterval = Math.max(
        this._settings.minimumManifestUpdateInterval - timeSinceRequest,
        0
      );
      const nextRefreshCanceller = new TaskCanceller();
      nextRefreshCanceller.linkToSignal(this._canceller.signal);
      this.scheduleManualRefresh = (settings) => {
        const { enablePartialRefresh, delay, canUseUnsafeMode } = settings;
        const unsafeMode = canUseUnsafeMode && unsafeModeEnabled;
        const timeSinceLastRefresh = sendingTime === void 0 ? 0 : monotonic_timestamp_default() - sendingTime;
        const _minInterval = Math.max(
          this._settings.minimumManifestUpdateInterval - timeSinceLastRefresh,
          0
        );
        const timeoutId = setTimeout(
          () => {
            nextRefreshCanceller.cancel();
            this._triggerNextManifestRefresh(manifest, {
              enablePartialRefresh,
              unsafeMode
            });
          },
          Math.max((delay != null ? delay : 0) - timeSinceLastRefresh, _minInterval)
        );
        nextRefreshCanceller.signal.register(() => {
          clearTimeout(timeoutId);
        });
      };
      if (manifest.expired !== null) {
        const timeoutId = setTimeout(() => {
          var _a;
          (_a = manifest.expired) == null ? void 0 : _a.then(() => {
            nextRefreshCanceller.cancel();
            this._triggerNextManifestRefresh(manifest, {
              enablePartialRefresh: false,
              unsafeMode: unsafeModeEnabled
            });
          }, noop_default);
        }, minInterval);
        nextRefreshCanceller.signal.register(() => {
          clearTimeout(timeoutId);
        });
      }
      if (manifest.lifetime !== void 0 && manifest.lifetime >= 0) {
        const regularRefreshDelay = manifest.lifetime * 1e3 - timeSinceRequest;
        let actualRefreshInterval;
        if (totalUpdateTime === void 0) {
          actualRefreshInterval = regularRefreshDelay;
        } else if (manifest.lifetime < 3 && totalUpdateTime >= 100) {
          actualRefreshInterval = Math.min(
            Math.max(
              // Take 3 seconds as a default safe value for a base interval.
              3e3 - timeSinceRequest,
              // Add update time to the original interval.
              Math.max(regularRefreshDelay, 0) + totalUpdateTime
            ),
            // Limit the postponment's higher bound to a very high value relative
            // to `regularRefreshDelay`.
            // This avoid perpetually postponing a Manifest update when
            // performance seems to have been abysmal one time.
            regularRefreshDelay * 6
          );
          log_default.info(
            "MUS: Manifest update rythm is too frequent. Postponing next request.",
            regularRefreshDelay,
            actualRefreshInterval
          );
        } else if (totalUpdateTime >= manifest.lifetime * 1e3 / 10) {
          actualRefreshInterval = Math.min(
            // Just add the update time to the original waiting time
            Math.max(regularRefreshDelay, 0) + totalUpdateTime,
            // Limit the postponment's higher bound to a very high value relative
            // to `regularRefreshDelay`.
            // This avoid perpetually postponing a Manifest update when
            // performance seems to have been abysmal one time.
            regularRefreshDelay * 6
          );
          log_default.info(
            "MUS: Manifest took too long to parse. Postponing next request",
            actualRefreshInterval,
            actualRefreshInterval
          );
        } else {
          actualRefreshInterval = regularRefreshDelay;
        }
        const timeoutId = setTimeout(
          () => {
            nextRefreshCanceller.cancel();
            this._triggerNextManifestRefresh(manifest, {
              enablePartialRefresh: false,
              unsafeMode: unsafeModeEnabled
            });
          },
          Math.max(actualRefreshInterval, minInterval)
        );
        nextRefreshCanceller.signal.register(() => {
          clearTimeout(timeoutId);
        });
      }
    }
    /**
     * Refresh the Manifest, performing a full update if a partial update failed.
     * Also re-call `recursivelyRefreshManifest` to schedule the next refresh
     * trigger.
     * @param {Object} manifest
     * @param {Object} refreshInformation
     */
    _triggerNextManifestRefresh(manifest, {
      enablePartialRefresh,
      unsafeMode
    }) {
      const manifestUpdateUrl = manifest.updateUrl;
      let fullRefresh;
      let refreshURL;
      if (this._prioritizedContentUrl !== null) {
        fullRefresh = true;
        refreshURL = this._prioritizedContentUrl;
        this._prioritizedContentUrl = null;
      } else {
        fullRefresh = !enablePartialRefresh || manifestUpdateUrl === void 0;
        refreshURL = fullRefresh ? manifest.getUrls()[0] : manifestUpdateUrl;
      }
      const externalClockOffset = manifest.clockOffset;
      if (unsafeMode) {
        this._consecutiveUnsafeMode += 1;
        log_default.info(
          'Init: Refreshing the Manifest in "unsafeMode" for the ' + String(this._consecutiveUnsafeMode) + " consecutive time."
        );
      } else if (this._consecutiveUnsafeMode > 0) {
        log_default.info(
          'Init: Not parsing the Manifest in "unsafeMode" anymore after ' + String(this._consecutiveUnsafeMode) + " consecutive times."
        );
        this._consecutiveUnsafeMode = 0;
      }
      if (this._isRefreshPending) {
        return;
      }
      this._isRefreshPending = true;
      this._fetchManifest(refreshURL).then(
        (res) => res.parse({
          externalClockOffset,
          previousManifest: manifest,
          unsafeMode
        })
      ).then((res) => {
        this._isRefreshPending = false;
        const { manifest: newManifest, sendingTime: newSendingTime, parsingTime } = res;
        const updateTimeStart = monotonic_timestamp_default();
        if (fullRefresh) {
          manifest.replace(newManifest);
        } else {
          try {
            manifest.update(newManifest);
          } catch (e) {
            const message = e instanceof Error ? e.message : "unknown error";
            log_default.warn(
              `MUS: Attempt to update Manifest failed: ${message}`,
              "Re-downloading the Manifest fully"
            );
            const { FAILED_PARTIAL_UPDATE_MANIFEST_REFRESH_DELAY } = config_default.getCurrent();
            const timeSinceLastRefresh = newSendingTime === void 0 ? 0 : monotonic_timestamp_default() - newSendingTime;
            const _minInterval = Math.max(
              this._settings.minimumManifestUpdateInterval - timeSinceLastRefresh,
              0
            );
            let unregisterCanceller = noop_default;
            const timeoutId = setTimeout(
              () => {
                unregisterCanceller();
                this._triggerNextManifestRefresh(manifest, {
                  enablePartialRefresh: false,
                  unsafeMode: false
                });
              },
              Math.max(
                FAILED_PARTIAL_UPDATE_MANIFEST_REFRESH_DELAY - timeSinceLastRefresh,
                _minInterval
              )
            );
            unregisterCanceller = this._canceller.signal.register(() => {
              clearTimeout(timeoutId);
            });
            return;
          }
        }
        const updatingTime = monotonic_timestamp_default() - updateTimeStart;
        this._recursivelyRefreshManifest(manifest, {
          sendingTime: newSendingTime,
          parsingTime,
          updatingTime
        });
      }).catch((err) => {
        this._isRefreshPending = false;
        this._onFatalError(err);
      });
    }
    _onFatalError(err) {
      if (this._canceller.isUsed()) {
        return;
      }
      this.trigger("error", err);
      this.dispose();
    }
  };
  function isPromise(val) {
    return val instanceof Promise;
  }

  // src/core/fetchers/manifest/index.ts
  var manifest_default = ManifestFetcher;

  // src/core/fetchers/segment/index.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/core/fetchers/segment/segment_queue_creator.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/core/fetchers/segment/prioritized_segment_fetcher.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function applyPrioritizerToSegmentFetcher(prioritizer, fetcher) {
    const taskHandlers = /* @__PURE__ */ new WeakMap();
    return {
      /**
       * Create a Segment request with a given priority.
       * @param {Object} content - content to request
       * @param {Number} priority - priority at which the content should be requested.
       * Lower number == higher priority.
       * @param {Object} callbacks
       * @param {Object} cancelSignal
       * @returns {Promise}
       */
      createRequest(content, priority, callbacks, cancelSignal) {
        const givenTask = (innerCancelSignal) => {
          return fetcher(content, callbacks, innerCancelSignal);
        };
        const ret = prioritizer.create(givenTask, priority, callbacks, cancelSignal);
        taskHandlers.set(ret, givenTask);
        return ret;
      },
      /**
       * Update the priority of a pending request, created through
       * `createRequest`.
       * @param {Promise} task - The Promise returned by `createRequest`.
       * @param {Number} priority - The new priority value.
       */
      updatePriority(task, priority) {
        const correspondingTask = taskHandlers.get(task);
        if (correspondingTask === void 0) {
          log_default.warn("Fetchers: Cannot update the priority of a request: task not found.");
          return;
        }
        prioritizer.updatePriority(correspondingTask, priority);
      }
    };
  }

  // src/core/fetchers/segment/segment_fetcher.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/core/fetchers/segment/initialization_segment_cache.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var InitializationSegmentCache = class {
    constructor() {
      this._cache = /* @__PURE__ */ new WeakMap();
    }
    /**
     * @param {Object} obj
     * @param {*} response
     */
    add({ representation, segment }, response) {
      if (segment.isInit) {
        this._cache.set(representation, response);
      }
    }
    /**
     * @param {Object} obj
     * @returns {*} response
     */
    get({
      representation,
      segment
    }) {
      if (segment.isInit) {
        const value = this._cache.get(representation);
        if (value !== void 0) {
          return value;
        }
      }
      return null;
    }
  };
  var initialization_segment_cache_default = InitializationSegmentCache;

  // src/core/fetchers/segment/segment_fetcher.ts
  var generateRequestID = idGenerator();
  function createSegmentFetcher({
    bufferType,
    pipeline,
    cdnPrioritizer,
    cmcdDataBuilder,
    eventListeners,
    requestOptions
  }) {
    let connectionTimeout;
    if (requestOptions.connectionTimeout === void 0 || requestOptions.connectionTimeout < 0) {
      connectionTimeout = void 0;
    } else {
      connectionTimeout = requestOptions.connectionTimeout;
    }
    const pipelineRequestOptions = {
      timeout: requestOptions.requestTimeout < 0 ? void 0 : requestOptions.requestTimeout,
      connectionTimeout,
      cmcdPayload: void 0
    };
    const cache = arrayIncludes(["audio", "video"], bufferType) ? new initialization_segment_cache_default() : void 0;
    const { loadSegment, parseSegment } = pipeline;
    return async function fetchSegment(content, fetcherCallbacks, cancellationSignal) {
      var _a, _b, _c;
      const { segment, adaptation, representation, manifest, period } = content;
      const segmentIdString = getLoggableSegmentId(content);
      const requestId = generateRequestID();
      let requestInfo;
      const parsedChunks = [];
      let segmentDurationAcc = 0;
      let metricsSent = false;
      const context = {
        segment,
        type: adaptation.type,
        language: adaptation.language,
        isLive: manifest.isLive,
        periodStart: period.start,
        periodEnd: period.end,
        mimeType: representation.mimeType,
        codecs: representation.codecs[0],
        manifestPublishTime: manifest.publishTime
      };
      const loaderCallbacks = {
        /**
         * Callback called when the segment loader has progress information on
         * the request.
         * @param {Object} info
         */
        onProgress(info) {
          var _a2;
          if (requestInfo !== void 0) {
            return;
          }
          if (info.totalSize !== void 0 && info.size < info.totalSize) {
            (_a2 = eventListeners.onProgress) == null ? void 0 : _a2.call(eventListeners, {
              duration: info.duration,
              size: info.size,
              totalSize: info.totalSize,
              timestamp: monotonic_timestamp_default(),
              id: requestId
            });
          }
        },
        /**
         * Callback called when the segment is communicated by the loader
         * through decodable sub-segment(s) called chunk(s), with a chunk in
         * argument.
         * @param {*} chunkData
         */
        onNewChunk(chunkData) {
          fetcherCallbacks.onChunk(generateParserFunction(chunkData, true));
        }
      };
      const cached = cache !== void 0 ? cache.get(content) : null;
      if (cached !== null) {
        log_default.debug("SF: Found wanted segment in cache", segmentIdString);
        fetcherCallbacks.onChunk(generateParserFunction(cached, false));
        return Promise.resolve();
      }
      log_default.debug("SF: Beginning request", segmentIdString);
      (_a = eventListeners.onRequestBegin) == null ? void 0 : _a.call(eventListeners, {
        requestTimestamp: monotonic_timestamp_default(),
        id: requestId,
        content
      });
      cancellationSignal.register(onCancellation);
      try {
        const res = await scheduleRequestWithCdns(
          content.representation.cdnMetadata,
          cdnPrioritizer,
          callLoaderWithUrl,
          object_assign_default({ onRetry }, requestOptions),
          cancellationSignal
        );
        if (res.resultType === "segment-loaded") {
          const loadedData = res.resultData.responseData;
          if (cache !== void 0) {
            cache.add(content, res.resultData.responseData);
          }
          fetcherCallbacks.onChunk(generateParserFunction(loadedData, false));
        } else if (res.resultType === "segment-created") {
          fetcherCallbacks.onChunk(generateParserFunction(res.resultData, false));
        }
        log_default.debug("SF: Segment request ended with success", segmentIdString);
        fetcherCallbacks.onAllChunksReceived();
        if (res.resultType !== "segment-created") {
          requestInfo = res.resultData;
          sendNetworkMetricsIfAvailable();
        } else {
          requestInfo = null;
        }
        if (!cancellationSignal.isCancelled()) {
          (_b = eventListeners.onRequestEnd) == null ? void 0 : _b.call(eventListeners, { id: requestId });
        }
        cancellationSignal.deregister(onCancellation);
      } catch (err) {
        cancellationSignal.deregister(onCancellation);
        requestInfo = null;
        if (err instanceof CancellationError) {
          log_default.debug("SF: Segment request aborted", segmentIdString);
          throw err;
        }
        log_default.debug("SF: Segment request failed", segmentIdString);
        (_c = eventListeners.onRequestEnd) == null ? void 0 : _c.call(eventListeners, { id: requestId });
        throw errorSelector(err);
      }
      function onCancellation() {
        var _a2;
        if (requestInfo !== void 0) {
          return;
        }
        log_default.debug("SF: Segment request cancelled", segmentIdString);
        requestInfo = null;
        (_a2 = eventListeners.onRequestEnd) == null ? void 0 : _a2.call(eventListeners, { id: requestId });
      }
      function callLoaderWithUrl(cdnMetadata) {
        pipelineRequestOptions.cmcdPayload = cmcdDataBuilder == null ? void 0 : cmcdDataBuilder.getCmcdDataForSegmentRequest(content);
        return loadSegment(
          cdnMetadata,
          context,
          pipelineRequestOptions,
          cancellationSignal,
          loaderCallbacks
        );
      }
      function generateParserFunction(data2, isChunked) {
        parsedChunks.push(false);
        const parsedChunkId = parsedChunks.length - 1;
        return function parse2(initTimescale) {
          const loaded = { data: data2, isChunked };
          try {
            const parsed = parseSegment(loaded, context, initTimescale);
            if (!parsedChunks[parsedChunkId]) {
              segmentDurationAcc = segmentDurationAcc !== void 0 && parsed.segmentType === "media" && parsed.chunkInfos !== null && parsed.chunkInfos.duration !== void 0 ? segmentDurationAcc + parsed.chunkInfos.duration : void 0;
              parsedChunks[parsedChunkId] = true;
              sendNetworkMetricsIfAvailable();
            }
            return parsed;
          } catch (error) {
            throw formatError(error, {
              defaultCode: "PIPELINE_PARSE_ERROR",
              defaultReason: "Unknown parsing error"
            });
          }
        };
      }
      function onRetry(err) {
        fetcherCallbacks.onRetry(errorSelector(err));
      }
      function sendNetworkMetricsIfAvailable() {
        var _a2;
        if (metricsSent) {
          return;
        }
        if (!isNullOrUndefined(requestInfo) && requestInfo.size !== void 0 && requestInfo.requestDuration !== void 0 && parsedChunks.length > 0 && parsedChunks.every((isParsed) => isParsed)) {
          metricsSent = true;
          (_a2 = eventListeners.onMetrics) == null ? void 0 : _a2.call(eventListeners, {
            size: requestInfo.size,
            requestDuration: requestInfo.requestDuration,
            content,
            segmentDuration: segmentDurationAcc
          });
        }
      }
    };
  }
  function getSegmentFetcherRequestOptions({
    maxRetry,
    lowLatencyMode,
    requestTimeout,
    connectionTimeout
  }) {
    const {
      DEFAULT_MAX_REQUESTS_RETRY_ON_ERROR,
      DEFAULT_REQUEST_TIMEOUT,
      DEFAULT_CONNECTION_TIMEOUT,
      INITIAL_BACKOFF_DELAY_BASE,
      MAX_BACKOFF_DELAY_BASE
    } = config_default.getCurrent();
    return {
      maxRetry: maxRetry != null ? maxRetry : DEFAULT_MAX_REQUESTS_RETRY_ON_ERROR,
      baseDelay: lowLatencyMode ? INITIAL_BACKOFF_DELAY_BASE.LOW_LATENCY : INITIAL_BACKOFF_DELAY_BASE.REGULAR,
      maxDelay: lowLatencyMode ? MAX_BACKOFF_DELAY_BASE.LOW_LATENCY : MAX_BACKOFF_DELAY_BASE.REGULAR,
      requestTimeout: requestTimeout === void 0 ? DEFAULT_REQUEST_TIMEOUT : requestTimeout,
      connectionTimeout: connectionTimeout === void 0 ? DEFAULT_CONNECTION_TIMEOUT : connectionTimeout
    };
  }

  // src/core/fetchers/segment/segment_queue.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var SegmentQueue = class extends EventEmitter {
    /**
     * Create a new `SegmentQueue`.
     *
     * @param {Object} segmentFetcher - Interface to facilitate the download of
     * segments.
     */
    constructor(segmentFetcher) {
      super();
      this._segmentFetcher = segmentFetcher;
      this._currentContentInfo = null;
    }
    /**
     * Returns the initialization segment currently being requested.
     * Returns `null` if no initialization segment request is pending.
     * @returns {Object | null}
     */
    getRequestedInitSegment() {
      var _a, _b, _c;
      return (_c = (_b = (_a = this._currentContentInfo) == null ? void 0 : _a.initSegmentRequest) == null ? void 0 : _b.segment) != null ? _c : null;
    }
    /**
     * Returns the media segment currently being requested.
     * Returns `null` if no media segment request is pending.
     * @returns {Object | null}
     */
    getRequestedMediaSegment() {
      var _a, _b, _c;
      return (_c = (_b = (_a = this._currentContentInfo) == null ? void 0 : _a.mediaSegmentRequest) == null ? void 0 : _b.segment) != null ? _c : null;
    }
    /**
     * Return an object allowing to schedule segment requests linked to the given
     * content.
     * The `SegmentQueue` will emit events as it loads and parses initialization
     * and media segments.
     *
     * Calling this method resets all previous queues that were previously started
     * on the same instance.
     *
     * @param {Object} content - The context of the Representation you want to
     * load segments for.
     * @param {boolean} hasInitSegment - Declare that an initialization segment
     * will need to be downloaded.
     *
     * A `SegmentQueue` ALWAYS wait for the initialization segment to be
     * loaded and parsed before parsing a media segment.
     *
     * In cases where no initialization segment exist, this would lead to the
     * `SegmentQueue` waiting indefinitely for it.
     *
     * By setting that value to `false`, you anounce to the `SegmentQueue`
     * that it should not wait for an initialization segment before parsing a
     * media segment.
     * @returns {Object} - `SharedReference` on which the queue of segment for
     * that content can be communicated and updated. See type for more
     * information.
     */
    resetForContent(content, hasInitSegment) {
      var _a;
      (_a = this._currentContentInfo) == null ? void 0 : _a.currentCanceller.cancel();
      const downloadQueue = new reference_default({
        initSegment: null,
        segmentQueue: []
      });
      const currentCanceller = new TaskCanceller();
      currentCanceller.signal.register(() => {
        downloadQueue.finish();
      });
      const currentContentInfo = {
        content,
        downloadQueue,
        initSegmentInfoRef: hasInitSegment ? new reference_default(void 0) : new reference_default(null),
        currentCanceller,
        initSegmentRequest: null,
        mediaSegmentRequest: null,
        mediaSegmentAwaitingInitMetadata: null
      };
      this._currentContentInfo = currentContentInfo;
      downloadQueue.onUpdate(
        (queue) => {
          const { segmentQueue } = queue;
          if (segmentQueue.length > 0 && segmentQueue[0].segment.id === currentContentInfo.mediaSegmentAwaitingInitMetadata) {
            return;
          }
          const currentSegmentRequest = currentContentInfo.mediaSegmentRequest;
          if (segmentQueue.length === 0) {
            if (currentSegmentRequest === null) {
              return;
            }
            log_default.debug(
              "SQ: no more media segment to request. Cancelling queue.",
              content.adaptation.type
            );
            this._restartMediaSegmentDownloadingQueue(currentContentInfo);
            return;
          } else if (currentSegmentRequest === null) {
            log_default.debug(
              "SQ: Media segments now need to be requested. Starting queue.",
              content.adaptation.type,
              segmentQueue.length
            );
            this._restartMediaSegmentDownloadingQueue(currentContentInfo);
            return;
          } else {
            const nextItem = segmentQueue[0];
            if (currentSegmentRequest.segment.id !== nextItem.segment.id) {
              log_default.debug(
                "SQ: Next media segment changed, cancelling previous",
                content.adaptation.type
              );
              this._restartMediaSegmentDownloadingQueue(currentContentInfo);
              return;
            }
            if (currentSegmentRequest.priority !== nextItem.priority) {
              log_default.debug(
                "SQ: Priority of next media segment changed, updating",
                content.adaptation.type,
                currentSegmentRequest.priority,
                nextItem.priority
              );
              this._segmentFetcher.updatePriority(
                currentSegmentRequest.request,
                nextItem.priority
              );
            }
            return;
          }
        },
        { emitCurrentValue: true, clearSignal: currentCanceller.signal }
      );
      downloadQueue.onUpdate(
        (next) => {
          var _a2;
          const initSegmentRequest = currentContentInfo.initSegmentRequest;
          if (next.initSegment !== null && initSegmentRequest !== null) {
            if (next.initSegment.priority !== initSegmentRequest.priority) {
              this._segmentFetcher.updatePriority(
                initSegmentRequest.request,
                next.initSegment.priority
              );
            }
            return;
          } else if (((_a2 = next.initSegment) == null ? void 0 : _a2.segment.id) === (initSegmentRequest == null ? void 0 : initSegmentRequest.segment.id)) {
            return;
          }
          if (next.initSegment === null) {
            log_default.debug(
              "SQ: no more init segment to request. Cancelling queue.",
              content.adaptation.type
            );
          }
          this._restartInitSegmentDownloadingQueue(currentContentInfo, next.initSegment);
        },
        { emitCurrentValue: true, clearSignal: currentCanceller.signal }
      );
      return downloadQueue;
    }
    /**
     * Stop the currently-active `SegmentQueue`.
     *
     * Do nothing if no queue is active.
     */
    stop() {
      var _a;
      (_a = this._currentContentInfo) == null ? void 0 : _a.currentCanceller.cancel();
      this._currentContentInfo = null;
    }
    /**
     * Internal logic performing media segment requests.
     */
    _restartMediaSegmentDownloadingQueue(contentInfo) {
      if (contentInfo.mediaSegmentRequest !== null) {
        contentInfo.mediaSegmentRequest.canceller.cancel();
      }
      const { downloadQueue, content, initSegmentInfoRef, currentCanceller } = contentInfo;
      const { segmentQueue } = downloadQueue.getValue();
      const currentNeededSegment = segmentQueue[0];
      const recursivelyRequestSegments = (startingSegment) => {
        if (currentCanceller !== null && currentCanceller.isUsed()) {
          contentInfo.mediaSegmentRequest = null;
          return;
        }
        if (startingSegment === void 0) {
          contentInfo.mediaSegmentRequest = null;
          this.trigger("emptyQueue", null);
          return;
        }
        const canceller = new TaskCanceller();
        const unlinkCanceller = currentCanceller === null ? noop_default : canceller.linkToSignal(currentCanceller.signal);
        const { segment, priority } = startingSegment;
        const context = object_assign_default({ segment }, content);
        let isComplete = false;
        let isWaitingOnInitSegment = false;
        canceller.signal.register(() => {
          contentInfo.mediaSegmentRequest = null;
          if (isComplete) {
            return;
          }
          if (contentInfo.mediaSegmentAwaitingInitMetadata === segment.id) {
            contentInfo.mediaSegmentAwaitingInitMetadata = null;
          }
          isComplete = true;
          isWaitingOnInitSegment = false;
        });
        const emitChunk = (parsed) => {
          assert(parsed.segmentType === "media", "Should have loaded a media segment.");
          this.trigger("parsedMediaSegment", object_assign_default({}, parsed, { segment }));
        };
        const continueToNextSegment = () => {
          const lastQueue = downloadQueue.getValue().segmentQueue;
          if (lastQueue.length === 0) {
            isComplete = true;
            this.trigger("emptyQueue", null);
            return;
          } else if (lastQueue[0].segment.id === segment.id) {
            lastQueue.shift();
          }
          isComplete = true;
          recursivelyRequestSegments(lastQueue[0]);
        };
        const request2 = this._segmentFetcher.createRequest(
          context,
          priority,
          {
            /**
             * Callback called when the request has to be retried.
             * @param {Error} error
             */
            onRetry: (error) => {
              this.trigger("requestRetry", { segment, error });
            },
            /**
             * Callback called when the request has to be interrupted and
             * restarted later.
             */
            beforeInterrupted() {
              log_default.info(
                "SQ: segment request interrupted temporarly.",
                segment.id,
                segment.time
              );
            },
            /**
             * Callback called when a decodable chunk of the segment is available.
             * @param {Function} parse - Function allowing to parse the segment.
             */
            onChunk: (parse2) => {
              const initTimescale = initSegmentInfoRef.getValue();
              if (initTimescale !== void 0) {
                emitChunk(parse2(initTimescale != null ? initTimescale : void 0));
              } else {
                isWaitingOnInitSegment = true;
                initSegmentInfoRef.waitUntilDefined(
                  (actualTimescale) => {
                    emitChunk(parse2(actualTimescale != null ? actualTimescale : void 0));
                  },
                  { clearSignal: canceller.signal }
                );
              }
            },
            /** Callback called after all chunks have been sent. */
            onAllChunksReceived: () => {
              if (!isWaitingOnInitSegment) {
                this.trigger("fullyLoadedSegment", segment);
              } else {
                contentInfo.mediaSegmentAwaitingInitMetadata = segment.id;
                initSegmentInfoRef.waitUntilDefined(
                  () => {
                    contentInfo.mediaSegmentAwaitingInitMetadata = null;
                    isWaitingOnInitSegment = false;
                    this.trigger("fullyLoadedSegment", segment);
                  },
                  { clearSignal: canceller.signal }
                );
              }
            },
            /**
             * Callback called right after the request ended but before the next
             * requests are scheduled. It is used to schedule the next segment.
             */
            beforeEnded: () => {
              unlinkCanceller();
              contentInfo.mediaSegmentRequest = null;
              if (isWaitingOnInitSegment) {
                initSegmentInfoRef.waitUntilDefined(continueToNextSegment, {
                  clearSignal: canceller.signal
                });
              } else {
                continueToNextSegment();
              }
            }
          },
          canceller.signal
        );
        request2.catch((error) => {
          unlinkCanceller();
          if (!isComplete) {
            isComplete = true;
            this.stop();
            this.trigger("error", error);
          }
        });
        contentInfo.mediaSegmentRequest = { segment, priority, request: request2, canceller };
      };
      recursivelyRequestSegments(currentNeededSegment);
    }
    /**
     * Internal logic performing initialization segment requests.
     * @param {Object} contentInfo
     * @param {Object} queuedInitSegment
     */
    _restartInitSegmentDownloadingQueue(contentInfo, queuedInitSegment) {
      const { content, initSegmentInfoRef } = contentInfo;
      if (contentInfo.initSegmentRequest !== null) {
        contentInfo.initSegmentRequest.canceller.cancel();
      }
      if (queuedInitSegment === null) {
        return;
      }
      const canceller = new TaskCanceller();
      const unlinkCanceller = contentInfo.currentCanceller === null ? noop_default : canceller.linkToSignal(contentInfo.currentCanceller.signal);
      const { segment, priority } = queuedInitSegment;
      const context = object_assign_default({ segment }, content);
      let isComplete = false;
      const request2 = this._segmentFetcher.createRequest(
        context,
        priority,
        {
          onRetry: (err) => {
            this.trigger("requestRetry", { segment, error: err });
          },
          beforeInterrupted: () => {
            log_default.info("SQ: init segment request interrupted temporarly.", segment.id);
          },
          beforeEnded: () => {
            unlinkCanceller();
            contentInfo.initSegmentRequest = null;
            isComplete = true;
          },
          onChunk: (parse2) => {
            var _a;
            const parsed = parse2(void 0);
            assert(parsed.segmentType === "init", "Should have loaded an init segment.");
            this.trigger("parsedInitSegment", object_assign_default({}, parsed, { segment }));
            if (parsed.segmentType === "init") {
              initSegmentInfoRef.setValue((_a = parsed.initTimescale) != null ? _a : null);
            }
          },
          onAllChunksReceived: () => {
            this.trigger("fullyLoadedSegment", segment);
          }
        },
        canceller.signal
      );
      request2.catch((error) => {
        unlinkCanceller();
        if (!isComplete) {
          isComplete = true;
          this.stop();
          this.trigger("error", error);
        }
      });
      canceller.signal.register(() => {
        contentInfo.initSegmentRequest = null;
        if (isComplete) {
          return;
        }
        isComplete = true;
      });
      contentInfo.initSegmentRequest = { segment, priority, request: request2, canceller };
    }
  };

  // src/core/fetchers/segment/task_prioritizer.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var TaskPrioritizer = class {
    /**
     * @param {Options} prioritizerOptions
     */
    constructor({ prioritySteps }) {
      this._minPendingPriority = null;
      this._waitingQueue = [];
      this._pendingTasks = [];
      this._prioritySteps = prioritySteps;
      if (this._prioritySteps.high >= this._prioritySteps.low) {
        throw new Error(
          "TP: the max high level priority should be given a lowerpriority number than the min low priority."
        );
      }
    }
    /**
     * Create a priorized Promise from a base task.
     *
     * This task will immediately have its priority compared to all the
     * already-running ones created from this class.
     *
     * Only if this number is inferior or equal to the priority of the
     * minimum priority number of all currently-running tasks  will it be
     * immediately started.
     * In the opposite case, we will wait for higher-priority tasks to
     * finish before starting it.
     *
     * Note that while this task is waiting for its turn, it is possible
     * to update its property through the updatePriority method, by providing
     * the task again and its new priority number.
     *
     * @param {Function} taskFn
     * @param {number} priority
     * @param {Object} callbacks
     * @param {Object} cancelSignal
     * @returns {Promise}
     */
    create(taskFn, priority, callbacks, cancelSignal) {
      let newTask;
      return createCancellablePromise(cancelSignal, (resolve, reject) => {
        const trigger = () => {
          if (newTask.hasEnded) {
            return;
          }
          const finishTask = () => {
            unlinkInterrupter();
            this._endTask(newTask);
          };
          const onResolve = (value) => {
            callbacks.beforeEnded();
            finishTask();
            resolve(value);
          };
          const onReject = (err) => {
            finishTask();
            reject(err);
          };
          const interrupter = new TaskCanceller();
          const unlinkInterrupter = interrupter.linkToSignal(cancelSignal);
          newTask.interrupter = interrupter;
          interrupter.signal.register(() => {
            newTask.interrupter = null;
            if (!cancelSignal.isCancelled()) {
              callbacks.beforeInterrupted();
            }
          });
          this._minPendingPriority = this._minPendingPriority === null ? newTask.priority : Math.min(this._minPendingPriority, newTask.priority);
          this._pendingTasks.push(newTask);
          newTask.taskFn(interrupter.signal).then(onResolve).catch((err) => {
            if (!cancelSignal.isCancelled() && interrupter.isUsed() && err instanceof CancellationError) {
              return;
            }
            onReject(err);
          });
        };
        newTask = {
          hasEnded: false,
          priority,
          trigger,
          taskFn,
          interrupter: null
        };
        if (!this._canBeStartedNow(newTask)) {
          this._waitingQueue.push(newTask);
        } else {
          newTask.trigger();
          if (this._isRunningHighPriorityTasks()) {
            this._interruptCancellableTasks();
          }
        }
        return () => this._endTask(newTask);
      });
    }
    _endTask(task) {
      task.hasEnded = true;
      const waitingQueueIndex = _findTaskIndex(task.taskFn, this._waitingQueue);
      if (waitingQueueIndex >= 0) {
        this._waitingQueue.splice(waitingQueueIndex, 1);
      } else {
        const pendingTasksIndex = _findTaskIndex(task.taskFn, this._pendingTasks);
        if (pendingTasksIndex < 0) {
          return;
        }
        this._pendingTasks.splice(pendingTasksIndex, 1);
        if (this._pendingTasks.length > 0) {
          if (this._minPendingPriority === task.priority) {
            this._minPendingPriority = Math.min(
              ...this._pendingTasks.map((t) => t.priority)
            );
          }
        } else {
          this._minPendingPriority = null;
        }
        this._loopThroughWaitingQueue();
      }
    }
    /**
     * Update the priority of a promise given to the TaskPrioritizer.
     * @param {Object} promise
     * @param {number} priority
     */
    updatePriority(promise, priority) {
      const waitingQueueIndex = _findTaskIndex(promise, this._waitingQueue);
      if (waitingQueueIndex >= 0) {
        const waitingQueueElt = this._waitingQueue[waitingQueueIndex];
        if (waitingQueueElt.priority === priority) {
          return;
        }
        waitingQueueElt.priority = priority;
        if (!this._canBeStartedNow(waitingQueueElt)) {
          return;
        }
        this._findAndRunWaitingQueueTask(waitingQueueIndex);
        if (this._isRunningHighPriorityTasks()) {
          this._interruptCancellableTasks();
        }
        return;
      }
      const pendingTasksIndex = _findTaskIndex(promise, this._pendingTasks);
      if (pendingTasksIndex < 0) {
        log_default.warn("TP: request to update the priority of a non-existent task");
        return;
      }
      const task = this._pendingTasks[pendingTasksIndex];
      if (task.priority === priority) {
        return;
      }
      const prevPriority = task.priority;
      task.priority = priority;
      if (this._minPendingPriority === null || priority < this._minPendingPriority) {
        this._minPendingPriority = priority;
      } else if (this._minPendingPriority === prevPriority) {
        if (this._pendingTasks.length === 1) {
          this._minPendingPriority = priority;
        } else {
          this._minPendingPriority = Math.min(...this._pendingTasks.map((t) => t.priority));
        }
        this._loopThroughWaitingQueue();
      }
      if (this._isRunningHighPriorityTasks()) {
        this._interruptCancellableTasks();
      }
    }
    /**
     * Browse the current waiting queue and start all task in it that needs to be
     * started: start the ones with the lowest priority value below
     * `_minPendingPriority`.
     *
     * Private properties, such as `_minPendingPriority` are updated accordingly
     * while this method is called.
     */
    _loopThroughWaitingQueue() {
      const minWaitingPriority = this._waitingQueue.reduce((acc, elt) => {
        return acc === null || acc > elt.priority ? elt.priority : acc;
      }, null);
      if (minWaitingPriority === null || this._minPendingPriority !== null && this._minPendingPriority < minWaitingPriority) {
        return;
      }
      for (let i = 0; i < this._waitingQueue.length; i++) {
        const priorityToCheck = this._minPendingPriority === null ? minWaitingPriority : Math.min(this._minPendingPriority, minWaitingPriority);
        const elt = this._waitingQueue[i];
        if (elt.priority <= priorityToCheck) {
          this._findAndRunWaitingQueueTask(i);
          i--;
        }
      }
    }
    /**
     * Interrupt and move back to the waiting queue all pending tasks that are
     * low priority (having a higher priority number than
     * `this._prioritySteps.low`).
     */
    _interruptCancellableTasks() {
      for (const pendingObj of this._pendingTasks) {
        if (pendingObj.priority >= this._prioritySteps.low) {
          this._interruptPendingTask(pendingObj);
          return this._interruptCancellableTasks();
        }
      }
    }
    /**
     * Start task which is at the given index in the waiting queue.
     * The task will be removed from the waiting queue in the process.
     * @param {number} index
     */
    _findAndRunWaitingQueueTask(index) {
      if (index >= this._waitingQueue.length || index < 0) {
        log_default.warn("TP : Tried to start a non existing task");
        return false;
      }
      const task = this._waitingQueue.splice(index, 1)[0];
      task.trigger();
      return true;
    }
    /**
     * Move back pending task to the waiting queue and interrupt it.
     * @param {object} task
     */
    _interruptPendingTask(task) {
      var _a;
      const pendingTasksIndex = _findTaskIndex(task.taskFn, this._pendingTasks);
      if (pendingTasksIndex < 0) {
        log_default.warn("TP: Interrupting a non-existent pending task. Aborting...");
        return;
      }
      this._pendingTasks.splice(pendingTasksIndex, 1);
      this._waitingQueue.push(task);
      if (this._pendingTasks.length === 0) {
        this._minPendingPriority = null;
      } else if (this._minPendingPriority === task.priority) {
        this._minPendingPriority = Math.min(...this._pendingTasks.map((t) => t.priority));
      }
      (_a = task.interrupter) == null ? void 0 : _a.cancel();
    }
    /**
     * Return `true` if the given task can be started immediately based on its
     * priority.
     * @param {Object} task
     * @returns {boolean}
     */
    _canBeStartedNow(task) {
      return this._minPendingPriority === null || task.priority <= this._minPendingPriority;
    }
    /**
     * Returns `true` if any running task is considered "high priority".
     * returns `false` otherwise.
     * @returns {boolean}
     */
    _isRunningHighPriorityTasks() {
      return this._minPendingPriority !== null && this._minPendingPriority <= this._prioritySteps.high;
    }
  };
  function _findTaskIndex(taskFn, queue) {
    return arrayFindIndex(queue, (elt) => elt.taskFn === taskFn);
  }

  // src/core/fetchers/segment/segment_queue_creator.ts
  var SegmentQueueCreator = class {
    /**
     * @param {Object} transport
     * @param {Object} cdnPrioritizer
     * @param {Object|null} cmcdDataBuilder
     * @param {Object} options
     */
    constructor(transport, cdnPrioritizer, cmcdDataBuilder, options) {
      const { MIN_CANCELABLE_PRIORITY, MAX_HIGH_PRIORITY_LEVEL } = config_default.getCurrent();
      this._transport = transport;
      this._prioritizer = new TaskPrioritizer({
        prioritySteps: {
          high: MAX_HIGH_PRIORITY_LEVEL,
          low: MIN_CANCELABLE_PRIORITY
        }
      });
      this._cdnPrioritizer = cdnPrioritizer;
      this._backoffOptions = options;
      this._cmcdDataBuilder = cmcdDataBuilder;
    }
    /**
     * Create a `SegmentQueue`, allowing to easily perform segment requests.
     * @param {string} bufferType - The type of buffer concerned (e.g. "audio",
     * "video", etc.)
     * @param {Object} eventListeners
     * @returns {Object} - `SegmentQueue`, which is an abstraction allowing to
     * perform a queue of segment requests for a given media type (here defined by
     * `bufferType`) with associated priorities.
     */
    createSegmentQueue(bufferType, eventListeners) {
      const requestOptions = getSegmentFetcherRequestOptions(this._backoffOptions);
      const pipelines = this._transport[bufferType];
      const segmentFetcher = createSegmentFetcher({
        bufferType,
        pipeline: pipelines,
        cdnPrioritizer: this._cdnPrioritizer,
        cmcdDataBuilder: this._cmcdDataBuilder,
        eventListeners,
        requestOptions
      });
      const prioritizedSegmentFetcher = applyPrioritizerToSegmentFetcher(
        this._prioritizer,
        segmentFetcher
      );
      return new SegmentQueue(prioritizedSegmentFetcher);
    }
  };

  // src/core/fetchers/segment/index.ts
  var segment_default = SegmentQueueCreator;

  // src/core/fetchers/thumbnails/index.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/core/fetchers/thumbnails/thumbnail_fetcher.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function createThumbnailFetcher(pipeline, cdnPrioritizer) {
    const { loadThumbnail: loadThumbnail2 } = pipeline;
    return async function fetchThumbnail(thumbnail, thumbnailTrack, requestOptions, cancellationSignal) {
      let connectionTimeout;
      if (requestOptions.connectionTimeout === void 0 || requestOptions.connectionTimeout < 0) {
        connectionTimeout = void 0;
      } else {
        connectionTimeout = requestOptions.connectionTimeout;
      }
      const pipelineRequestOptions = {
        timeout: requestOptions.requestTimeout < 0 ? void 0 : requestOptions.requestTimeout,
        connectionTimeout,
        cmcdPayload: void 0
      };
      log_default.debug("TF: Beginning thumbnail request", thumbnail.time);
      cancellationSignal.register(onCancellation);
      let res;
      try {
        res = await scheduleRequestWithCdns(
          thumbnailTrack.cdnMetadata,
          cdnPrioritizer,
          callLoaderWithUrl,
          object_assign_default({ onRetry }, requestOptions),
          cancellationSignal
        );
        if (cancellationSignal.isCancelled()) {
          return Promise.reject(cancellationSignal.cancellationError);
        }
        log_default.debug("TF: Thumbnail request ended with success", thumbnail.time);
        cancellationSignal.deregister(onCancellation);
      } catch (err) {
        cancellationSignal.deregister(onCancellation);
        if (err instanceof CancellationError) {
          log_default.debug("TF: Thumbnail request aborted", thumbnail.time);
          throw err;
        }
        log_default.debug("TF: Thumbnail request failed", thumbnail.time);
        throw errorSelector(err);
      }
      try {
        const parsed = pipeline.parseThumbnail(res.responseData, {
          thumbnail,
          thumbnailTrack
        });
        return parsed;
      } catch (error) {
        throw formatError(error, {
          defaultCode: "PIPELINE_PARSE_ERROR",
          defaultReason: "Unknown parsing error"
        });
      }
      function onCancellation() {
        log_default.debug("TF: Thumbnail request cancelled", thumbnail.time);
      }
      function callLoaderWithUrl(cdnMetadata) {
        return loadThumbnail2(
          cdnMetadata,
          thumbnail,
          pipelineRequestOptions,
          cancellationSignal
        );
      }
      function onRetry(err) {
        const formattedErr = errorSelector(err);
        log_default.warn("TF: Thumbnail request retry ", thumbnail.time, formattedErr);
      }
    };
  }
  function getThumbnailFetcherRequestOptions({
    maxRetry,
    requestTimeout,
    connectionTimeout
  }) {
    const {
      DEFAULT_MAX_THUMBNAIL_REQUESTS_RETRY_ON_ERROR,
      DEFAULT_THUMBNAIL_REQUEST_TIMEOUT,
      DEFAULT_THUMBNAIL_CONNECTION_TIMEOUT,
      INITIAL_BACKOFF_DELAY_BASE,
      MAX_BACKOFF_DELAY_BASE
    } = config_default.getCurrent();
    return {
      maxRetry: maxRetry != null ? maxRetry : DEFAULT_MAX_THUMBNAIL_REQUESTS_RETRY_ON_ERROR,
      baseDelay: INITIAL_BACKOFF_DELAY_BASE.REGULAR,
      maxDelay: MAX_BACKOFF_DELAY_BASE.REGULAR,
      requestTimeout: requestTimeout === void 0 ? DEFAULT_THUMBNAIL_REQUEST_TIMEOUT : requestTimeout,
      connectionTimeout: connectionTimeout === void 0 ? DEFAULT_THUMBNAIL_CONNECTION_TIMEOUT : connectionTimeout
    };
  }

  // src/core/fetchers/thumbnails/index.ts
  var thumbnails_default = createThumbnailFetcher;

  // src/core/main/common/create_content_time_boundaries_observer.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/core/main/common/content_time_boundaries_observer.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/utils/sorted_list.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var SortedList = class {
    /**
     * @param {Function} sortingFunction
     */
    constructor(sortingFunction) {
      this._array = [];
      this._sortingFn = sortingFunction;
    }
    /**
     * Add a new element to the List at the right place for the List to stay
     * sorted.
     *
     * /!\ The added Element will share the same reference than the given
     * argument, any mutation on your part can lead to an un-sorted SortedList.
     * You can still re-force the sorting to happen by calling forceSort.
     * @param {...*} elements
     */
    add(...elements) {
      elements.sort(this._sortingFn);
      let j = 0;
      for (let i = 0; i < elements.length; i++) {
        const element = elements[i];
        let inserted = false;
        while (!inserted && j < this._array.length) {
          if (this._sortingFn(element, this._array[j]) < 0) {
            this._array.splice(j, 0, element);
            inserted = true;
          } else {
            j++;
          }
        }
        if (!inserted) {
          this._array.push(element);
        }
      }
    }
    /**
     * Returns the current length of the list.
     * @returns {number}
     */
    length() {
      return this._array.length;
    }
    /**
     * Returns the nth element. Throws if the index does not exist.
     *
     * /!\ The returned Element shares the same reference with what is used
     * internally, any mutation on your part can lead to an un-sorted SortedList.
     * You can still re-force the sorting to happen by calling forceSort.
     * @throws Error - Throws if the given index is negative or superior to the
     * array's length.
     * @param {number} index
     * @returns {*}
     */
    get(index) {
      if (index < 0 || index >= this._array.length) {
        throw new Error("Invalid index.");
      }
      return this._array[index];
    }
    toArray() {
      return this._array.slice();
    }
    /**
     * Find the first element corresponding to the given predicate.
     *
     * /!\ The returned element shares the same reference with what is used
     * internally, any mutation on your part can lead to an un-sorted SortedList.
     * You can still re-force the sorting to happen by calling forceSort.
     * @param {Function} fn
     * @returns {*}
     */
    findFirst(fn) {
      return arrayFind(this._array, fn);
    }
    /**
     * Returns true if the List contains the given element.
     * @param {*} element
     * @returns {Boolean}
     */
    has(element) {
      return arrayIncludes(this._array, element);
    }
    /**
     * Remove the first occurence of the given element.
     * Returns the index of the removed element. Undefined if not found.
     * @returns {number|undefined}
     */
    removeElement(element) {
      const indexOf = this._array.indexOf(element);
      if (indexOf >= 0) {
        this._array.splice(indexOf, 1);
        return indexOf;
      }
      return void 0;
    }
    /**
     * Returns the first element.
     *
     * /!\ The returned Element shares the same reference with what is used
     * internally, any mutation on your part can lead to an un-sorted SortedList.
     * You can still re-force the sorting to happen by calling forceSort.
     * @returns {*}
     */
    head() {
      return this._array[0];
    }
    /**
     * Returns the last element.
     *
     * /!\ The returned Element shares the same reference with what is used
     * internally, any mutation on your part can lead to an un-sorted SortedList.
     * You can still re-force the sorting to happen by calling forceSort.
     * @returns {*}
     */
    last() {
      return this._array[this._array.length - 1];
    }
    /**
     * Remove the first element.
     * Returns the element removed or undefined if no element were removed.
     * @returns {*}
     */
    shift() {
      return this._array.shift();
    }
    /**
     * Remove the last element.
     * Returns the element removed or undefined if no element were removed.
     * @returns {*}
     */
    pop() {
      return this._array.pop();
    }
    /**
     * Returns true if the wrapped Array is well-sorted.
     *
     * You might want to call this function to know if a mutation you've done
     * yourself impacted the order of elements.
     * You can then call the forceSort function to sort the list manually.
     *
     * @example
     * ```js
     * const sortedList = new SortedList((a, b) => a.start - b.start);
     * const element1 = { start: 20 };
     * const element2 = { start: 10 };
     *
     * sortedList.add(element1, element2);
     * console.log(sortedList.unwrap()); // -> [{ start: 10 }, { start : 20 }]
     * console.log(sortedList.checkSort()); // -> true
     *
     * element2.start = 5; // Mutation impacting the order of elements
     * console.log(sortedList.unwrap()); // -> [{ start: 10 }, { start : 5 }]
     * console.log(sortedList.checkSort()); // -> false
     *
     * sortedList.forceSort();
     * console.log(sortedList.unwrap()); // -> [{ start: 5 }, { start : 10 }]
     * console.log(sortedList.checkSort()); // -> true
     * ```
     * @returns {Boolean}
     */
    // checkSort() : boolean {
    //   for (let i = 0; i < this._array.length - 1; i++) {
    //     if (this._sortingFn(this._array[i], this._array[i + 1]) > 0) {
    //       return false;
    //     }
    //   }
    //   return true;
    // }
    /**
     * Force the array to be sorted.
     *
     * You might want to call this function when you're unsure that a mutation
     * you've done yourself impacted the order of the elements in the list.
     */
    // forceSort() {
    //   this._array.sort(this._sortingFn);
    // }
  };

  // src/core/main/common/content_time_boundaries_observer.ts
  var ContentTimeBoundariesObserver = class extends EventEmitter {
    /**
     * @param {Object} manifest
     * @param {Object} playbackObserver
     */
    constructor(manifest, playbackObserver, bufferTypes) {
      super();
      this._canceller = new TaskCanceller();
      this._manifest = manifest;
      this._activeStreams = /* @__PURE__ */ new Map();
      this._allBufferTypes = bufferTypes;
      this._lastCurrentPeriodId = null;
      const maximumPositionCalculator = new MaximumPositionCalculator(manifest);
      this._maximumPositionCalculator = maximumPositionCalculator;
      const cancelSignal = this._canceller.signal;
      playbackObserver.listen(
        ({ position }) => {
          const wantedPosition = position.getWanted();
          if (wantedPosition < manifest.getMinimumSafePosition()) {
            const warning = new MediaError(
              "MEDIA_TIME_BEFORE_MANIFEST",
              "The current position is behind the earliest time announced in the Manifest."
            );
            this.trigger("warning", warning);
          } else if (wantedPosition > maximumPositionCalculator.getMaximumAvailablePosition()) {
            const warning = new MediaError(
              "MEDIA_TIME_AFTER_MANIFEST",
              "The current position is after the latest time announced in the Manifest."
            );
            this.trigger("warning", warning);
          }
        },
        { includeLastObservation: true, clearSignal: cancelSignal }
      );
      manifest.addEventListener(
        "manifestUpdate",
        () => {
          this.trigger("endingPositionChange", this._getManifestEndTime());
          if (cancelSignal.isCancelled()) {
            return;
          }
          this._checkEndOfStream();
        },
        cancelSignal
      );
    }
    /**
     * Returns an estimate of the current last position which may be played in
     * the content at the moment.
     * @returns {Object}
     */
    getCurrentEndingTime() {
      return this._getManifestEndTime();
    }
    /**
     * Method to call any time an Adaptation has been selected.
     *
     * That Adaptation switch will be considered as active until the
     * `onPeriodCleared` method has been called for the same `bufferType` and
     * `Period`, or until `dispose` is called.
     * @param {string} bufferType - The type of buffer concerned by the Adaptation
     * switch
     * @param {Object} period - The Period concerned by the Adaptation switch
     * @param {Object|null} adaptation - The Adaptation selected. `null` if the
     * absence of `Adaptation` has been explicitely selected for this Period and
     * buffer type (e.g. no video).
     */
    onAdaptationChange(bufferType, period, adaptation) {
      if (this._manifest.isLastPeriodKnown) {
        const lastPeriod = this._manifest.periods[this._manifest.periods.length - 1];
        if (period.id === (lastPeriod == null ? void 0 : lastPeriod.id)) {
          if (bufferType === "audio" || bufferType === "video") {
            if (bufferType === "audio") {
              this._maximumPositionCalculator.updateLastAudioAdaptation(adaptation);
            } else {
              this._maximumPositionCalculator.updateLastVideoAdaptation(adaptation);
            }
            const endingPosition = this._maximumPositionCalculator.getEndingPosition();
            const newEndingPosition = endingPosition !== void 0 ? { isEnd: true, endingPosition } : {
              isEnd: false,
              endingPosition: this._maximumPositionCalculator.getMaximumAvailablePosition()
            };
            this.trigger("endingPositionChange", newEndingPosition);
          }
        }
      }
      if (this._canceller.isUsed()) {
        return;
      }
      if (adaptation === null) {
        this._addActivelyLoadedPeriod(period, bufferType);
      }
    }
    /**
     * Method to call any time a Representation has been selected.
     *
     * That Representation switch will be considered as active until the
     * `onPeriodCleared` method has been called for the same `bufferType` and
     * `Period`, or until `dispose` is called.
     * @param {string} bufferType - The type of buffer concerned by the
     * Representation switch
     * @param {Object} period - The Period concerned by the Representation switch
     */
    onRepresentationChange(bufferType, period) {
      this._addActivelyLoadedPeriod(period, bufferType);
    }
    /**
     * Method to call any time a Period and type combination is not considered
     * anymore.
     *
     * Calling this method allows to signal that a previous Adaptation and/or
     * Representation change respectively indicated by an `onAdaptationChange` and
     * an `onRepresentationChange` call, are not active anymore.
     * @param {string} bufferType - The type of buffer concerned
     * @param {Object} period - The Period concerned
     */
    onPeriodCleared(bufferType, period) {
      this._removeActivelyLoadedPeriod(period, bufferType);
    }
    /**
     * Method to call when the last chronological segment for a given buffer type
     * is known to have been loaded and is either pushed or in the process of
     * being pushed to the corresponding MSE `SourceBuffer` or equivalent.
     *
     * This method can even be called multiple times in a row as long as the
     * aforementioned condition is true, if it simplify your code's management.
     * @param {string} bufferType
     */
    onLastSegmentFinishedLoading(bufferType) {
      const streamInfo = this._lazilyCreateActiveStreamInfo(bufferType);
      if (!streamInfo.hasFinishedLoadingLastPeriod) {
        streamInfo.hasFinishedLoadingLastPeriod = true;
        this._checkEndOfStream();
      }
    }
    /**
     * Method to call to "cancel" a previous call to
     * `onLastSegmentFinishedLoading`.
     *
     * That is, calling this method indicates that the last chronological segment
     * of a given buffer type is now either not loaded or it is not known.
     *
     * This method can even be called multiple times in a row as long as the
     * aforementioned condition is true, if it simplify your code's management.
     * @param {string} bufferType
     */
    onLastSegmentLoadingResume(bufferType) {
      const streamInfo = this._lazilyCreateActiveStreamInfo(bufferType);
      if (streamInfo.hasFinishedLoadingLastPeriod) {
        streamInfo.hasFinishedLoadingLastPeriod = false;
        this._checkEndOfStream();
      }
    }
    /**
     * Free all resources used by the `ContentTimeBoundariesObserver` and cancels
     * all recurring processes it performs.
     */
    dispose() {
      this.removeEventListener();
      this._canceller.cancel();
    }
    _addActivelyLoadedPeriod(period, bufferType) {
      const streamInfo = this._lazilyCreateActiveStreamInfo(bufferType);
      if (!streamInfo.activePeriods.has(period)) {
        streamInfo.activePeriods.add(period);
        this._checkCurrentPeriod();
      }
    }
    _removeActivelyLoadedPeriod(period, bufferType) {
      const streamInfo = this._activeStreams.get(bufferType);
      if (streamInfo === void 0) {
        return;
      }
      if (streamInfo.activePeriods.has(period)) {
        streamInfo.activePeriods.removeElement(period);
        this._checkCurrentPeriod();
      }
    }
    _checkCurrentPeriod() {
      if (this._allBufferTypes.length === 0) {
        return;
      }
      const streamInfo = this._activeStreams.get(this._allBufferTypes[0]);
      if (streamInfo === void 0) {
        return;
      }
      for (const period of streamInfo.activePeriods.toArray()) {
        let wasFoundInAllTypes = true;
        for (const bufferType of this._allBufferTypes) {
          const streamInfo2 = this._activeStreams.get(bufferType);
          if (streamInfo2 === void 0) {
            return;
          }
          const activePeriods = streamInfo2.activePeriods.toArray();
          const hasPeriod = activePeriods.some((p) => p.id === period.id);
          if (!hasPeriod) {
            wasFoundInAllTypes = false;
            break;
          }
        }
        if (wasFoundInAllTypes) {
          if (this._lastCurrentPeriodId !== period.id) {
            this._lastCurrentPeriodId = period.id;
            this.trigger("periodChange", period);
          }
          return;
        }
      }
    }
    _getManifestEndTime() {
      const endingPosition = this._maximumPositionCalculator.getEndingPosition();
      return endingPosition !== void 0 ? { isEnd: true, endingPosition } : {
        isEnd: false,
        endingPosition: this._maximumPositionCalculator.getMaximumAvailablePosition()
      };
    }
    _lazilyCreateActiveStreamInfo(bufferType) {
      let streamInfo = this._activeStreams.get(bufferType);
      if (streamInfo === void 0) {
        streamInfo = {
          activePeriods: new SortedList((a, b) => a.start - b.start),
          hasFinishedLoadingLastPeriod: false
        };
        this._activeStreams.set(bufferType, streamInfo);
      }
      return streamInfo;
    }
    _checkEndOfStream() {
      if (!this._manifest.isLastPeriodKnown) {
        return;
      }
      const everyBufferTypeLoaded = this._allBufferTypes.every((bt) => {
        const streamInfo = this._activeStreams.get(bt);
        return streamInfo !== void 0 && streamInfo.hasFinishedLoadingLastPeriod;
      });
      if (everyBufferTypeLoaded) {
        this.trigger("endOfStream", null);
      } else {
        this.trigger("resumeStream", null);
      }
    }
  };
  var MaximumPositionCalculator = class {
    /**
     * @param {Object} manifest
     */
    constructor(manifest) {
      this._manifest = manifest;
      this._lastAudioAdaptation = void 0;
      this._lastVideoAdaptation = void 0;
    }
    /**
     * Update the last known audio Adaptation for the last Period.
     * If no Adaptation has been set, it should be set to `null`.
     *
     * Allows to calculate the maximum position more precizely in
     * `getMaximumAvailablePosition` and `getEndingPosition`.
     * @param {Object|null} adaptation
     */
    updateLastAudioAdaptation(adaptation) {
      this._lastAudioAdaptation = adaptation;
    }
    /**
     * Update the last known video Adaptation for the last Period.
     * If no Adaptation has been set, it should be set to `null`.
     *
     * Allows to calculate the maximum position more precizely in
     * `getMaximumAvailablePosition` and `getEndingPosition`.
     * @param {Object|null} adaptation
     */
    updateLastVideoAdaptation(adaptation) {
      this._lastVideoAdaptation = adaptation;
    }
    /**
     * Returns an estimate of the maximum position currently reachable (i.e.
     * segments are available) under the current circumstances.
     * @returns {number}
     */
    getMaximumAvailablePosition() {
      if (this._manifest.isDynamic) {
        return this._manifest.getMaximumSafePosition();
      }
      if (this._lastVideoAdaptation === void 0 || this._lastAudioAdaptation === void 0) {
        return this._manifest.getMaximumSafePosition();
      } else if (this._lastAudioAdaptation === null) {
        if (this._lastVideoAdaptation === null) {
          return this._manifest.getMaximumSafePosition();
        } else {
          const lastVideoPosition = getLastAvailablePositionFromAdaptation(
            this._lastVideoAdaptation
          );
          if (typeof lastVideoPosition !== "number") {
            return this._manifest.getMaximumSafePosition();
          }
          return lastVideoPosition;
        }
      } else if (this._lastVideoAdaptation === null) {
        const lastAudioPosition = getLastAvailablePositionFromAdaptation(
          this._lastAudioAdaptation
        );
        if (typeof lastAudioPosition !== "number") {
          return this._manifest.getMaximumSafePosition();
        }
        return lastAudioPosition;
      } else {
        const lastAudioPosition = getLastAvailablePositionFromAdaptation(
          this._lastAudioAdaptation
        );
        const lastVideoPosition = getLastAvailablePositionFromAdaptation(
          this._lastVideoAdaptation
        );
        if (typeof lastAudioPosition !== "number" || typeof lastVideoPosition !== "number") {
          return this._manifest.getMaximumSafePosition();
        } else {
          return Math.min(lastAudioPosition, lastVideoPosition);
        }
      }
    }
    /**
     * Returns an estimate of the actual ending position once
     * the full content is available.
     * Returns `undefined` if that could not be determined, for various reasons.
     * @returns {number|undefined}
     */
    getEndingPosition() {
      var _a, _b;
      if (!this._manifest.isDynamic) {
        return this.getMaximumAvailablePosition();
      }
      if (this._lastVideoAdaptation === void 0 || this._lastAudioAdaptation === void 0) {
        return void 0;
      } else if (this._lastAudioAdaptation === null) {
        if (this._lastVideoAdaptation === null) {
          return void 0;
        } else {
          return (_a = getEndingPositionFromAdaptation(this._lastVideoAdaptation)) != null ? _a : void 0;
        }
      } else if (this._lastVideoAdaptation === null) {
        return (_b = getEndingPositionFromAdaptation(this._lastAudioAdaptation)) != null ? _b : void 0;
      } else {
        const lastAudioPosition = getEndingPositionFromAdaptation(
          this._lastAudioAdaptation
        );
        const lastVideoPosition = getEndingPositionFromAdaptation(
          this._lastVideoAdaptation
        );
        if (typeof lastAudioPosition !== "number" || typeof lastVideoPosition !== "number") {
          return void 0;
        } else {
          return Math.min(lastAudioPosition, lastVideoPosition);
        }
      }
    }
  };
  function getLastAvailablePositionFromAdaptation(adaptation) {
    const { representations } = adaptation;
    let min = null;
    let lastIndex;
    for (const representation of representations) {
      if (representation.index !== lastIndex) {
        lastIndex = representation.index;
        const lastPosition = representation.index.getLastAvailablePosition();
        if (lastPosition === void 0) {
          return void 0;
        }
        if (lastPosition !== null) {
          min = isNullOrUndefined(min) ? lastPosition : Math.min(min, lastPosition);
        }
      }
    }
    return min;
  }
  function getEndingPositionFromAdaptation(adaptation) {
    const { representations } = adaptation;
    let min = null;
    let lastIndex;
    for (const representation of representations) {
      if (representation.index !== lastIndex) {
        lastIndex = representation.index;
        const lastPosition = representation.index.getEnd();
        if (lastPosition === void 0) {
          return void 0;
        }
        if (lastPosition !== null) {
          min = isNullOrUndefined(min) ? lastPosition : Math.min(min, lastPosition);
        }
      }
    }
    return min;
  }

  // src/core/main/common/create_content_time_boundaries_observer.ts
  function createContentTimeBoundariesObserver(manifest, mediaSource, streamObserver, segmentSinksStore, callbacks, cancelSignal) {
    cancelSignal.register(() => {
      mediaSource.interruptDurationSetting();
    });
    const contentTimeBoundariesObserver = new ContentTimeBoundariesObserver(
      manifest,
      streamObserver,
      segmentSinksStore.getBufferTypes()
    );
    cancelSignal.register(() => {
      contentTimeBoundariesObserver.dispose();
    });
    contentTimeBoundariesObserver.addEventListener(
      "warning",
      (err) => callbacks.onWarning(err)
    );
    contentTimeBoundariesObserver.addEventListener(
      "periodChange",
      (period) => callbacks.onPeriodChanged(period)
    );
    contentTimeBoundariesObserver.addEventListener("endingPositionChange", (evt) => {
      mediaSource.setDuration(evt.endingPosition, evt.isEnd);
    });
    contentTimeBoundariesObserver.addEventListener("endOfStream", () => {
      log_default.debug("Init: end-of-stream order received.");
      mediaSource.maintainEndOfStream();
    });
    contentTimeBoundariesObserver.addEventListener("resumeStream", () => {
      mediaSource.stopEndOfStream();
    });
    const obj = contentTimeBoundariesObserver.getCurrentEndingTime();
    mediaSource.setDuration(obj.endingPosition, obj.isEnd);
    return contentTimeBoundariesObserver;
  }

  // src/core/main/common/DecipherabilityFreezeDetector.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var DecipherabilityFreezeDetector = class {
    constructor(segmentSinksStore) {
      this._segmentSinksStore = segmentSinksStore;
      this._currentFreezeTimestamp = null;
    }
    /**
     * Support of contents with DRM on all the platforms out there is a pain in
     * the *ss considering all the DRM-related bugs there are.
     *
     * We found out a frequent issue which is to be unable to play despite having
     * all the decryption keys to play what is currently buffered.
     * When this happens, re-creating the buffers from scratch, with a reload, is
     * usually sufficient to unlock the situation.
     *
     * Although we prefer providing more targeted fixes or telling to platform
     * developpers to fix their implementation, it's not always possible.
     * We thus resorted to developping an heuristic which detects such situation
     * and reload in that case.
     *
     * @param {Object} observation - The last playback observation produced, it
     * has to be recent (just triggered for example).
     * @returns {boolean} - Returns `true` if it seems to be such kind of
     * decipherability freeze, in which case you should probably reload the
     * content.
     */
    needToReload(observation) {
      const { readyState, rebuffering, freezing } = observation;
      const bufferGap = observation.bufferGap !== void 0 && isFinite(observation.bufferGap) ? observation.bufferGap : 0;
      if (bufferGap < 6 || rebuffering === null && freezing === null || readyState > 1) {
        this._currentFreezeTimestamp = null;
        return false;
      }
      const now = monotonic_timestamp_default();
      if (this._currentFreezeTimestamp === null) {
        this._currentFreezeTimestamp = now;
      }
      const rebufferingForTooLong = rebuffering !== null && now - rebuffering.timestamp > 4e3;
      const frozenForTooLong = freezing !== null && now - freezing.timestamp > 4e3;
      if ((rebufferingForTooLong || frozenForTooLong) && monotonic_timestamp_default() - this._currentFreezeTimestamp > 4e3) {
        const statusAudio = this._segmentSinksStore.getStatus("audio");
        const statusVideo = this._segmentSinksStore.getStatus("video");
        let hasOnlyDecipherableSegments = true;
        let isClear = true;
        for (const status of [statusAudio, statusVideo]) {
          if (status.type === "initialized") {
            for (const segment of status.value.getLastKnownInventory()) {
              const { representation } = segment.infos;
              if (representation.decipherable === false) {
                log_default.warn(
                  "Init: we have undecipherable segments left in the buffer, reloading"
                );
                this._currentFreezeTimestamp = null;
                return true;
              } else if (representation.contentProtections !== void 0) {
                isClear = false;
                if (representation.decipherable !== true) {
                  hasOnlyDecipherableSegments = false;
                }
              }
            }
          }
        }
        if (!isClear && hasOnlyDecipherableSegments) {
          log_default.warn(
            "Init: we are frozen despite only having decipherable segments left in the buffer, reloading"
          );
          this._currentFreezeTimestamp = null;
          return true;
        }
      }
      return false;
    }
  };

  // src/core/main/common/get_thumbnail_data.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  async function getThumbnailData(fetchThumbnails, manifest, periodId, thumbnailTrackId, time) {
    const period = manifest.getPeriod(periodId);
    if (period === void 0) {
      throw new Error("Wanted Period not found.");
    }
    const thumbnailTrack = arrayFind(period.thumbnailTracks, (t) => {
      return t.id === thumbnailTrackId;
    });
    if (thumbnailTrack === void 0) {
      throw new Error("Wanted Period has no thumbnail track.");
    }
    const wantedThumbnail = thumbnailTrack.index.getSegments(time, 1)[0];
    if (wantedThumbnail === void 0) {
      throw new Error("No thumbnail for the given timestamp");
    }
    return fetchThumbnails(
      wantedThumbnail,
      thumbnailTrack,
      getThumbnailFetcherRequestOptions({}),
      new TaskCanceller().signal
    );
  }

  // src/core/segment_sinks/index.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/core/segment_sinks/garbage_collector.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function BufferGarbageCollector({
    segmentSink,
    playbackObserver,
    maxBufferBehind,
    maxBufferAhead
  }, cancellationSignal) {
    let lastPosition;
    let lastBuffered = [];
    playbackObserver.listen(
      (o) => {
        lastPosition = o.position.getWanted();
        lastBuffered = o.buffered[segmentSink.bufferType];
        clean();
      },
      { includeLastObservation: true, clearSignal: cancellationSignal }
    );
    function clean() {
      if (lastBuffered === null) {
        return;
      }
      clearBuffer(
        segmentSink,
        lastPosition,
        lastBuffered,
        maxBufferBehind.getValue(),
        maxBufferAhead.getValue(),
        cancellationSignal
      ).catch((e) => {
        const errMsg = e instanceof Error ? e.message : "Unknown error";
        log_default.error("Could not run BufferGarbageCollector:", errMsg);
      });
    }
    maxBufferBehind.onUpdate(clean, { clearSignal: cancellationSignal });
    maxBufferAhead.onUpdate(clean, { clearSignal: cancellationSignal });
    clean();
  }
  async function clearBuffer(segmentSink, position, buffered, maxBufferBehind, maxBufferAhead, cancellationSignal) {
    if (!isFinite(maxBufferBehind) && !isFinite(maxBufferAhead)) {
      return Promise.resolve();
    }
    const cleanedupRanges = [];
    const { innerRange, outerRanges } = getInnerAndOuterRanges(buffered, position);
    const collectBufferBehind = () => {
      if (!isFinite(maxBufferBehind)) {
        return;
      }
      for (const outerRange of outerRanges) {
        if (position - maxBufferBehind >= outerRange.end) {
          cleanedupRanges.push(outerRange);
        } else if (position >= outerRange.end && position - maxBufferBehind > outerRange.start && position - maxBufferBehind < outerRange.end) {
          cleanedupRanges.push({
            start: outerRange.start,
            end: position - maxBufferBehind
          });
        }
      }
      if (!isNullOrUndefined(innerRange)) {
        if (position - maxBufferBehind > innerRange.start) {
          cleanedupRanges.push({
            start: innerRange.start,
            end: position - maxBufferBehind
          });
        }
      }
    };
    const collectBufferAhead = () => {
      if (!isFinite(maxBufferAhead)) {
        return;
      }
      for (const outerRange of outerRanges) {
        if (position + maxBufferAhead <= outerRange.start) {
          cleanedupRanges.push(outerRange);
        } else if (position <= outerRange.start && position + maxBufferAhead < outerRange.end && position + maxBufferAhead > outerRange.start) {
          cleanedupRanges.push({
            start: position + maxBufferAhead,
            end: outerRange.end
          });
        }
      }
      if (!isNullOrUndefined(innerRange)) {
        if (position + maxBufferAhead < innerRange.end) {
          cleanedupRanges.push({
            start: position + maxBufferAhead,
            end: innerRange.end
          });
        }
      }
    };
    collectBufferBehind();
    collectBufferAhead();
    for (const range of cleanedupRanges) {
      if (range.start < range.end) {
        log_default.debug("GC: cleaning range from SegmentSink", range.start, range.end);
        if (cancellationSignal.cancellationError !== null) {
          throw cancellationSignal.cancellationError;
        }
        await segmentSink.removeBuffer(range.start, range.end);
      }
    }
  }

  // src/core/segment_sinks/implementations/index.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/core/segment_sinks/implementations/audio_video/index.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/core/segment_sinks/implementations/audio_video/audio_video_segment_buffer.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/core/segment_sinks/implementations/types.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/core/segment_sinks/inventory/index.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/core/segment_sinks/inventory/segment_inventory.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/core/segment_sinks/inventory/buffered_history.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var BufferedHistory = class {
    /**
     * @param {number} lifetime - Maximum time a history entry should be retained.
     * @param {number} maxHistoryLength - Maximum number of entries the history
     * should have.
     */
    constructor(lifetime, maxHistoryLength) {
      this._history = [];
      this._lifetime = lifetime;
      this._maxHistoryLength = maxHistoryLength;
    }
    /**
     * Add an entry to the `BufferedHistory`'s history indicating the buffered
     * range of a pushed segment.
     *
     * To call when the full range of a given segment becomes known.
     *
     * @param {Object} context
     * @param {Array.<number>|null} buffered
     */
    addBufferedSegment(context, buffered) {
      const now = monotonic_timestamp_default();
      this._history.push({ date: now, buffered, context });
      this._cleanHistory(now);
    }
    /**
     * Returns all entries linked to the given segment.
     * @param {Object} context
     * @returns {Array.<Object>}
     */
    getHistoryFor(context) {
      return this._history.filter((el) => areSameContent(el.context, context));
    }
    /**
     * If the current history does not satisfy `_lifetime` or `_maxHistoryLength`,
     * clear older entries until it does.
     * @param {number} now - Current monotonically-raising timestamp.
     */
    _cleanHistory(now) {
      const historyEarliestLimit = now - this._lifetime;
      let firstKeptIndex = 0;
      for (const event of this._history) {
        if (event.date < historyEarliestLimit) {
          firstKeptIndex++;
        } else {
          break;
        }
      }
      if (firstKeptIndex > 0) {
        this._history = this._history.splice(firstKeptIndex);
      }
      if (this._history.length > this._maxHistoryLength) {
        const toRemove = this._history.length - this._maxHistoryLength;
        this._history = this._history.splice(toRemove);
      }
    }
  };

  // src/core/segment_sinks/inventory/segment_inventory.ts
  var SegmentInventory = class {
    constructor() {
      const { BUFFERED_HISTORY_RETENTION_TIME, BUFFERED_HISTORY_MAXIMUM_ENTRIES } = config_default.getCurrent();
      this._inventory = [];
      this._bufferedHistory = new BufferedHistory(
        BUFFERED_HISTORY_RETENTION_TIME,
        BUFFERED_HISTORY_MAXIMUM_ENTRIES
      );
    }
    /**
     * Reset the whole inventory.
     */
    reset() {
      this._inventory.length = 0;
    }
    /**
     * Infer each segment's `bufferedStart` and `bufferedEnd` properties from the
     * ranges given.
     *
     * The ranges object given should come from the media buffer linked to that
     * SegmentInventory.
     *
     * /!\ A SegmentInventory should not be associated to multiple media buffers
     * at a time, so each `synchronizeBuffered` call should be given ranges coming
     * from the same buffer.
     * @param {Array.<Object>} ranges
     */
    synchronizeBuffered(ranges) {
      var _a, _b, _c, _d, _e, _f, _g;
      const inventory = this._inventory;
      let inventoryIndex = 0;
      let thisSegment = inventory[0];
      const { MINIMUM_SEGMENT_SIZE } = config_default.getCurrent();
      const bufferType = thisSegment == null ? void 0 : thisSegment.infos.adaptation.type;
      if (log_default.hasLevel("DEBUG")) {
        const prettyPrintedRanges = ranges.map((r) => `${r.start}-${r.end}`).join(",");
        log_default.debug(
          `SI: synchronizing ${bufferType != null ? bufferType : "unknown"} buffered ranges:`,
          prettyPrintedRanges
        );
      }
      const rangesLength = ranges.length;
      for (let i = 0; i < rangesLength; i++) {
        if (thisSegment === void 0) {
          return;
        }
        const rangeStart = ranges[i].start;
        const rangeEnd = ranges[i].end;
        if (rangeEnd - rangeStart < MINIMUM_SEGMENT_SIZE) {
          log_default.warn(
            "SI: skipped range when synchronizing because it was too small",
            bufferType,
            rangeStart,
            rangeEnd
          );
          continue;
        }
        const indexBefore = inventoryIndex;
        while (thisSegment !== void 0 && ((_a = thisSegment.bufferedEnd) != null ? _a : thisSegment.end) - rangeStart < MINIMUM_SEGMENT_SIZE) {
          thisSegment = inventory[++inventoryIndex];
        }
        let lastDeletedSegmentInfos = null;
        const numberOfSegmentToDelete = inventoryIndex - indexBefore;
        if (numberOfSegmentToDelete > 0) {
          const lastDeletedSegment = inventory[indexBefore + numberOfSegmentToDelete - 1];
          lastDeletedSegmentInfos = {
            end: (_b = lastDeletedSegment.bufferedEnd) != null ? _b : lastDeletedSegment.end,
            precizeEnd: lastDeletedSegment.precizeEnd
          };
          log_default.debug(`SI: ${numberOfSegmentToDelete} segments GCed.`, bufferType);
          const removed = inventory.splice(indexBefore, numberOfSegmentToDelete);
          for (const seg of removed) {
            if (seg.bufferedStart === void 0 && seg.bufferedEnd === void 0 && seg.status !== 2 /* Failed */) {
              this._bufferedHistory.addBufferedSegment(seg.infos, null);
            }
          }
          inventoryIndex = indexBefore;
        }
        if (thisSegment === void 0) {
          return;
        }
        if (rangeEnd - ((_c = thisSegment.bufferedStart) != null ? _c : thisSegment.start) >= MINIMUM_SEGMENT_SIZE) {
          guessBufferedStartFromRangeStart(
            thisSegment,
            rangeStart,
            lastDeletedSegmentInfos,
            bufferType
          );
          if (inventoryIndex === inventory.length - 1) {
            guessBufferedEndFromRangeEnd(thisSegment, rangeEnd, bufferType);
            return;
          }
          thisSegment = inventory[++inventoryIndex];
          let thisSegmentStart = (_d = thisSegment.bufferedStart) != null ? _d : thisSegment.start;
          let thisSegmentEnd = (_e = thisSegment.bufferedEnd) != null ? _e : thisSegment.end;
          const nextRangeStart = i < rangesLength - 1 ? ranges[i + 1].start : void 0;
          while (thisSegment !== void 0) {
            if (rangeEnd < thisSegmentStart) {
              break;
            }
            if (rangeEnd - thisSegmentStart < MINIMUM_SEGMENT_SIZE && thisSegmentEnd - rangeEnd >= MINIMUM_SEGMENT_SIZE) {
              break;
            }
            if (nextRangeStart !== void 0 && rangeEnd - thisSegmentStart < thisSegmentEnd - nextRangeStart) {
              break;
            }
            const prevSegment = inventory[inventoryIndex - 1];
            if (prevSegment.bufferedEnd === void 0) {
              if (thisSegment.precizeStart) {
                prevSegment.bufferedEnd = thisSegment.start;
              } else if (prevSegment.infos.segment.complete) {
                prevSegment.bufferedEnd = prevSegment.end;
              } else {
                prevSegment.bufferedEnd = thisSegment.start;
              }
              log_default.debug(
                "SI: calculating buffered end of contiguous segment",
                bufferType,
                prevSegment.bufferedEnd,
                prevSegment.end
              );
            }
            thisSegment.bufferedStart = prevSegment.bufferedEnd;
            thisSegment = inventory[++inventoryIndex];
            if (thisSegment !== void 0) {
              thisSegmentStart = (_f = thisSegment.bufferedStart) != null ? _f : thisSegment.start;
              thisSegmentEnd = (_g = thisSegment.bufferedEnd) != null ? _g : thisSegment.end;
            }
          }
        }
        const lastSegmentInRange = inventory[inventoryIndex - 1];
        if (lastSegmentInRange !== void 0) {
          guessBufferedEndFromRangeEnd(lastSegmentInRange, rangeEnd, bufferType);
        }
      }
      if (!isNullOrUndefined(thisSegment)) {
        const { SEGMENT_SYNCHRONIZATION_DELAY } = config_default.getCurrent();
        const now = monotonic_timestamp_default();
        for (let i = inventoryIndex; i < inventory.length; i++) {
          const segmentInfo = inventory[i];
          if (now - segmentInfo.insertionTs >= SEGMENT_SYNCHRONIZATION_DELAY) {
            log_default.debug(
              "SI: A segment at the end has been completely GCed",
              bufferType,
              `${segmentInfo.start}-${segmentInfo.end}`
            );
            if (segmentInfo.bufferedStart === void 0 && segmentInfo.bufferedEnd === void 0 && segmentInfo.status !== 2 /* Failed */) {
              this._bufferedHistory.addBufferedSegment(segmentInfo.infos, null);
            }
            inventory.splice(i, 1);
            i--;
          }
        }
      }
      if (bufferType !== void 0 && log_default.hasLevel("DEBUG")) {
        log_default.debug(
          `SI: current ${bufferType} inventory timeline:
` + prettyPrintInventory(this._inventory)
        );
      }
    }
    /**
     * Add a new chunk in the inventory.
     *
     * Chunks are decodable sub-parts of a whole segment. Once all chunks in a
     * segment have been inserted, you should call the `completeSegment` method.
     * @param {Object} chunkInformation
     * @param {boolean} succeed - If `true` the insertion operation finished with
     * success, if `false` an error arised while doing it.
     * @param {number} insertionTs - The monotonically-increasing timestamp at the
     * time the segment has been confirmed to be inserted by the buffer.
     */
    insertChunk({
      period,
      adaptation,
      representation,
      segment,
      chunkSize,
      start,
      end
    }, succeed, insertionTs) {
      if (segment.isInit) {
        return;
      }
      const bufferType = adaptation.type;
      if (start >= end) {
        log_default.warn(
          "SI: Invalid chunked inserted: starts before it ends",
          bufferType,
          start,
          end
        );
        return;
      }
      const inventory = this._inventory;
      const newSegment = {
        status: succeed ? 0 /* PartiallyPushed */ : 2 /* Failed */,
        insertionTs,
        chunkSize,
        splitted: false,
        start,
        end,
        precizeStart: false,
        precizeEnd: false,
        bufferedStart: void 0,
        bufferedEnd: void 0,
        infos: { segment, period, adaptation, representation }
      };
      for (let i = inventory.length - 1; i >= 0; i--) {
        const segmentI = inventory[i];
        if (segmentI.start <= start) {
          if (segmentI.end <= start) {
            log_default.debug(
              "SI: Pushing segment strictly after previous one.",
              bufferType,
              start,
              segmentI.end
            );
            this._inventory.splice(i + 1, 0, newSegment);
            i += 2;
            while (i < inventory.length && inventory[i].start < newSegment.end) {
              if (inventory[i].end > newSegment.end) {
                log_default.debug(
                  "SI: Segment pushed updates the start of the next one",
                  bufferType,
                  newSegment.end,
                  inventory[i].start
                );
                inventory[i].start = newSegment.end;
                inventory[i].bufferedStart = void 0;
                inventory[i].precizeStart = inventory[i].precizeStart && newSegment.precizeEnd;
                return;
              }
              log_default.debug(
                "SI: Segment pushed removes the next one",
                bufferType,
                start,
                end,
                inventory[i].start,
                inventory[i].end
              );
              inventory.splice(i, 1);
            }
            return;
          } else {
            if (segmentI.start === start) {
              if (segmentI.end <= end) {
                log_default.debug(
                  "SI: Segment pushed replace another one",
                  bufferType,
                  start,
                  end,
                  segmentI.end
                );
                this._inventory.splice(i, 1, newSegment);
                i += 1;
                while (i < inventory.length && inventory[i].start < newSegment.end) {
                  if (inventory[i].end > newSegment.end) {
                    log_default.debug(
                      "SI: Segment pushed updates the start of the next one",
                      bufferType,
                      newSegment.end,
                      inventory[i].start
                    );
                    inventory[i].start = newSegment.end;
                    inventory[i].bufferedStart = void 0;
                    inventory[i].precizeStart = inventory[i].precizeStart && newSegment.precizeEnd;
                    return;
                  }
                  log_default.debug(
                    "SI: Segment pushed removes the next one",
                    bufferType,
                    start,
                    end,
                    inventory[i].start,
                    inventory[i].end
                  );
                  inventory.splice(i, 1);
                }
                return;
              } else {
                log_default.debug(
                  "SI: Segment pushed ends before another with the same start",
                  bufferType,
                  start,
                  end,
                  segmentI.end
                );
                inventory.splice(i, 0, newSegment);
                segmentI.start = newSegment.end;
                segmentI.bufferedStart = void 0;
                segmentI.precizeStart = segmentI.precizeStart && newSegment.precizeEnd;
                return;
              }
            } else {
              if (segmentI.end <= newSegment.end) {
                log_default.debug(
                  "SI: Segment pushed updates end of previous one",
                  bufferType,
                  start,
                  end,
                  segmentI.start,
                  segmentI.end
                );
                this._inventory.splice(i + 1, 0, newSegment);
                segmentI.end = newSegment.start;
                segmentI.bufferedEnd = void 0;
                segmentI.precizeEnd = segmentI.precizeEnd && newSegment.precizeStart;
                i += 2;
                while (i < inventory.length && inventory[i].start < newSegment.end) {
                  if (inventory[i].end > newSegment.end) {
                    log_default.debug(
                      "SI: Segment pushed updates the start of the next one",
                      bufferType,
                      newSegment.end,
                      inventory[i].start
                    );
                    inventory[i].start = newSegment.end;
                    inventory[i].bufferedStart = void 0;
                    inventory[i].precizeStart = inventory[i].precizeStart && newSegment.precizeEnd;
                    return;
                  }
                  log_default.debug(
                    "SI: Segment pushed removes the next one",
                    bufferType,
                    start,
                    end,
                    inventory[i].start,
                    inventory[i].end
                  );
                  inventory.splice(i, 1);
                }
                return;
              } else {
                log_default.warn(
                  "SI: Segment pushed is contained in a previous one",
                  bufferType,
                  start,
                  end,
                  segmentI.start,
                  segmentI.end
                );
                const nextSegment = {
                  status: segmentI.status,
                  insertionTs: segmentI.insertionTs,
                  /**
                   * Note: this sadly means we're doing as if
                   * that chunk is present two times.
                   * Thankfully, this scenario should be
                   * fairly rare.
                   */
                  chunkSize: segmentI.chunkSize,
                  splitted: true,
                  start: newSegment.end,
                  end: segmentI.end,
                  precizeStart: segmentI.precizeStart && segmentI.precizeEnd && newSegment.precizeEnd,
                  precizeEnd: segmentI.precizeEnd,
                  bufferedStart: void 0,
                  bufferedEnd: segmentI.end,
                  infos: segmentI.infos
                };
                segmentI.end = newSegment.start;
                segmentI.splitted = true;
                segmentI.bufferedEnd = void 0;
                segmentI.precizeEnd = segmentI.precizeEnd && newSegment.precizeStart;
                inventory.splice(i + 1, 0, newSegment);
                inventory.splice(i + 2, 0, nextSegment);
                return;
              }
            }
          }
        }
      }
      const firstSegment = this._inventory[0];
      if (firstSegment === void 0) {
        log_default.debug("SI: first segment pushed", bufferType, start, end);
        this._inventory.push(newSegment);
        return;
      }
      if (firstSegment.start >= end) {
        log_default.debug(
          "SI: Segment pushed comes before all previous ones",
          bufferType,
          start,
          end,
          firstSegment.start
        );
        this._inventory.splice(0, 0, newSegment);
      } else if (firstSegment.end <= end) {
        log_default.debug(
          "SI: Segment pushed starts before and completely recovers the previous first one",
          bufferType,
          start,
          end,
          firstSegment.start,
          firstSegment.end
        );
        this._inventory.splice(0, 1, newSegment);
        while (inventory.length > 1 && inventory[1].start < newSegment.end) {
          if (inventory[1].end > newSegment.end) {
            log_default.debug(
              "SI: Segment pushed updates the start of the next one",
              bufferType,
              newSegment.end,
              inventory[1].start
            );
            inventory[1].start = newSegment.end;
            inventory[1].bufferedStart = void 0;
            inventory[1].precizeStart = newSegment.precizeEnd;
            return;
          }
          log_default.debug(
            "SI: Segment pushed removes the next one",
            bufferType,
            start,
            end,
            inventory[1].start,
            inventory[1].end
          );
          inventory.splice(1, 1);
        }
        return;
      } else {
        log_default.debug(
          "SI: Segment pushed start of the next one",
          bufferType,
          start,
          end,
          firstSegment.start,
          firstSegment.end
        );
        firstSegment.start = end;
        firstSegment.bufferedStart = void 0;
        firstSegment.precizeStart = newSegment.precizeEnd;
        this._inventory.splice(0, 0, newSegment);
        return;
      }
    }
    /**
     * Indicate that inserted chunks can now be considered as a fully-loaded
     * segment.
     * Take in argument the same content than what was given to `insertChunk` for
     * the corresponding chunks.
     * @param {Object} content
     */
    completeSegment(content) {
      if (content.segment.isInit) {
        return;
      }
      const inventory = this._inventory;
      const resSegments = [];
      for (let i = 0; i < inventory.length; i++) {
        if (areSameContent(inventory[i].infos, content)) {
          let splitted = false;
          if (resSegments.length > 0) {
            splitted = true;
            if (resSegments.length === 1) {
              log_default.warn(
                "SI: Completed Segment is splitted.",
                content.segment.id,
                content.segment.time,
                content.segment.end
              );
              resSegments[0].splitted = true;
            }
          }
          const firstI = i;
          let segmentSize = inventory[i].chunkSize;
          i += 1;
          while (i < inventory.length && areSameContent(inventory[i].infos, content)) {
            const chunkSize = inventory[i].chunkSize;
            if (segmentSize !== void 0 && chunkSize !== void 0) {
              segmentSize += chunkSize;
            }
            i++;
          }
          const lastI = i - 1;
          const length = lastI - firstI;
          const lastEnd = inventory[lastI].end;
          const lastBufferedEnd = inventory[lastI].bufferedEnd;
          if (length > 0) {
            this._inventory.splice(firstI + 1, length);
            i -= length;
          }
          if (this._inventory[firstI].status === 0 /* PartiallyPushed */) {
            this._inventory[firstI].status = 1 /* FullyLoaded */;
          }
          this._inventory[firstI].chunkSize = segmentSize;
          this._inventory[firstI].end = lastEnd;
          this._inventory[firstI].bufferedEnd = lastBufferedEnd;
          this._inventory[firstI].splitted = splitted;
          resSegments.push(this._inventory[firstI]);
        }
      }
      if (resSegments.length === 0) {
        log_default.warn(
          "SI: Completed Segment not found",
          content.segment.id,
          content.segment.time
        );
      } else {
        for (const seg of resSegments) {
          if (seg.bufferedStart !== void 0 && seg.bufferedEnd !== void 0) {
            if (seg.status !== 2 /* Failed */) {
              this._bufferedHistory.addBufferedSegment(seg.infos, {
                start: seg.bufferedStart,
                end: seg.bufferedEnd
              });
            }
          } else {
            log_default.debug(
              "SI: buffered range not known after sync. Skipping history.",
              seg.start,
              seg.end
            );
          }
        }
      }
    }
    /**
     * Returns the whole inventory.
     *
     * To get a list synchronized with what a media buffer actually has buffered
     * you might want to call `synchronizeBuffered` before calling this method.
     * @returns {Array.<Object>}
     */
    getInventory() {
      return this._inventory;
    }
    /**
     * Returns a recent history of registered operations performed and event
     * received linked to the segment given in argument.
     *
     * Not all operations and events are registered in the returned history.
     * Please check the return type for more information on what is available.
     *
     * Note that history is short-lived for memory usage and performance reasons.
     * You may not receive any information on operations that happened too long
     * ago.
     * @param {Object} context
     * @returns {Array.<Object>}
     */
    getHistoryFor(context) {
      return this._bufferedHistory.getHistoryFor(context);
    }
  };
  function bufferedStartLooksCoherent(thisSegment) {
    if (thisSegment.bufferedStart === void 0 || thisSegment.status !== 1 /* FullyLoaded */) {
      return false;
    }
    const { start, end } = thisSegment;
    const duration = end - start;
    const {
      MAX_MANIFEST_BUFFERED_START_END_DIFFERENCE,
      MAX_MANIFEST_BUFFERED_DURATION_DIFFERENCE
    } = config_default.getCurrent();
    return Math.abs(start - thisSegment.bufferedStart) <= MAX_MANIFEST_BUFFERED_START_END_DIFFERENCE && (thisSegment.bufferedEnd === void 0 || thisSegment.bufferedEnd > thisSegment.bufferedStart && Math.abs(thisSegment.bufferedEnd - thisSegment.bufferedStart - duration) <= Math.min(MAX_MANIFEST_BUFFERED_DURATION_DIFFERENCE, duration / 3));
  }
  function bufferedEndLooksCoherent(thisSegment) {
    if (thisSegment.bufferedEnd === void 0 || !thisSegment.infos.segment.complete || thisSegment.status !== 1 /* FullyLoaded */) {
      return false;
    }
    const { start, end } = thisSegment;
    const duration = end - start;
    const {
      MAX_MANIFEST_BUFFERED_START_END_DIFFERENCE,
      MAX_MANIFEST_BUFFERED_DURATION_DIFFERENCE
    } = config_default.getCurrent();
    return Math.abs(end - thisSegment.bufferedEnd) <= MAX_MANIFEST_BUFFERED_START_END_DIFFERENCE && thisSegment.bufferedStart !== void 0 && thisSegment.bufferedEnd > thisSegment.bufferedStart && Math.abs(thisSegment.bufferedEnd - thisSegment.bufferedStart - duration) <= Math.min(MAX_MANIFEST_BUFFERED_DURATION_DIFFERENCE, duration / 3);
  }
  function guessBufferedStartFromRangeStart(firstSegmentInRange, rangeStart, lastDeletedSegmentInfos, bufferType) {
    const {
      MAX_MANIFEST_BUFFERED_START_END_DIFFERENCE,
      MISSING_DATA_TRIGGER_SYNC_DELAY,
      SEGMENT_SYNCHRONIZATION_DELAY
    } = config_default.getCurrent();
    if (firstSegmentInRange.bufferedStart !== void 0) {
      if (firstSegmentInRange.bufferedStart < rangeStart) {
        log_default.debug(
          "SI: Segment partially GCed at the start",
          bufferType,
          firstSegmentInRange.bufferedStart,
          rangeStart
        );
        firstSegmentInRange.bufferedStart = rangeStart;
      }
      if (!firstSegmentInRange.precizeStart && bufferedStartLooksCoherent(firstSegmentInRange)) {
        firstSegmentInRange.start = firstSegmentInRange.bufferedStart;
        firstSegmentInRange.precizeStart = true;
      }
    } else if (firstSegmentInRange.precizeStart) {
      log_default.debug(
        "SI: buffered start is precize start",
        bufferType,
        firstSegmentInRange.start
      );
      firstSegmentInRange.bufferedStart = firstSegmentInRange.start;
    } else if (lastDeletedSegmentInfos !== null && lastDeletedSegmentInfos.end > rangeStart && (lastDeletedSegmentInfos.precizeEnd || firstSegmentInRange.start - lastDeletedSegmentInfos.end <= MAX_MANIFEST_BUFFERED_START_END_DIFFERENCE)) {
      log_default.debug(
        "SI: buffered start is end of previous segment",
        bufferType,
        rangeStart,
        firstSegmentInRange.start,
        lastDeletedSegmentInfos.end
      );
      firstSegmentInRange.bufferedStart = lastDeletedSegmentInfos.end;
      if (bufferedStartLooksCoherent(firstSegmentInRange)) {
        firstSegmentInRange.start = lastDeletedSegmentInfos.end;
        firstSegmentInRange.precizeStart = true;
      }
    } else if (firstSegmentInRange.start - rangeStart <= MAX_MANIFEST_BUFFERED_START_END_DIFFERENCE) {
      const now = monotonic_timestamp_default();
      if (firstSegmentInRange.start - rangeStart >= MISSING_DATA_TRIGGER_SYNC_DELAY && now - firstSegmentInRange.insertionTs < SEGMENT_SYNCHRONIZATION_DELAY) {
        log_default.debug(
          "SI: Ignored bufferedStart synchronization",
          bufferType,
          rangeStart,
          firstSegmentInRange.start,
          now - firstSegmentInRange.insertionTs
        );
        return;
      }
      log_default.debug(
        "SI: found true buffered start",
        bufferType,
        rangeStart,
        firstSegmentInRange.start
      );
      firstSegmentInRange.bufferedStart = rangeStart;
      if (bufferedStartLooksCoherent(firstSegmentInRange)) {
        firstSegmentInRange.start = rangeStart;
        firstSegmentInRange.precizeStart = true;
      }
    } else if (rangeStart < firstSegmentInRange.start) {
      log_default.debug(
        "SI: range start too far from expected start",
        bufferType,
        rangeStart,
        firstSegmentInRange.start
      );
      firstSegmentInRange.bufferedStart = firstSegmentInRange.start;
    } else {
      const now = monotonic_timestamp_default();
      if (firstSegmentInRange.start - rangeStart >= MISSING_DATA_TRIGGER_SYNC_DELAY && now - firstSegmentInRange.insertionTs < SEGMENT_SYNCHRONIZATION_DELAY) {
        log_default.debug(
          "SI: Ignored bufferedStart synchronization",
          bufferType,
          rangeStart,
          firstSegmentInRange.start,
          now - firstSegmentInRange.insertionTs
        );
        return;
      }
      log_default.debug(
        "SI: Segment appears immediately garbage collected at the start",
        bufferType,
        rangeStart,
        firstSegmentInRange.start
      );
      firstSegmentInRange.bufferedStart = rangeStart;
    }
  }
  function guessBufferedEndFromRangeEnd(lastSegmentInRange, rangeEnd, bufferType) {
    const {
      MAX_MANIFEST_BUFFERED_START_END_DIFFERENCE,
      MISSING_DATA_TRIGGER_SYNC_DELAY,
      SEGMENT_SYNCHRONIZATION_DELAY
    } = config_default.getCurrent();
    if (lastSegmentInRange.bufferedEnd !== void 0) {
      if (lastSegmentInRange.bufferedEnd > rangeEnd) {
        log_default.debug(
          "SI: Segment partially GCed at the end",
          bufferType,
          lastSegmentInRange.bufferedEnd,
          rangeEnd
        );
        lastSegmentInRange.bufferedEnd = rangeEnd;
      }
      if (!lastSegmentInRange.precizeEnd && rangeEnd - lastSegmentInRange.end <= MAX_MANIFEST_BUFFERED_START_END_DIFFERENCE && bufferedEndLooksCoherent(lastSegmentInRange)) {
        lastSegmentInRange.precizeEnd = true;
        lastSegmentInRange.end = rangeEnd;
      }
    } else if (lastSegmentInRange.precizeEnd) {
      log_default.debug("SI: buffered end is precize end", bufferType, lastSegmentInRange.end);
      lastSegmentInRange.bufferedEnd = lastSegmentInRange.end;
    } else if (rangeEnd - lastSegmentInRange.end <= MAX_MANIFEST_BUFFERED_START_END_DIFFERENCE || !lastSegmentInRange.infos.segment.complete) {
      const now = monotonic_timestamp_default();
      if (rangeEnd - lastSegmentInRange.end >= MISSING_DATA_TRIGGER_SYNC_DELAY && now - lastSegmentInRange.insertionTs < SEGMENT_SYNCHRONIZATION_DELAY) {
        log_default.debug(
          "SI: Ignored bufferedEnd synchronization",
          bufferType,
          rangeEnd,
          lastSegmentInRange.end,
          now - lastSegmentInRange.insertionTs
        );
        return;
      }
      log_default.debug(
        "SI: found true buffered end",
        bufferType,
        rangeEnd,
        lastSegmentInRange.end
      );
      lastSegmentInRange.bufferedEnd = rangeEnd;
      if (bufferedEndLooksCoherent(lastSegmentInRange)) {
        lastSegmentInRange.end = rangeEnd;
        lastSegmentInRange.precizeEnd = true;
      }
    } else if (rangeEnd > lastSegmentInRange.end) {
      log_default.debug(
        "SI: range end too far from expected end",
        bufferType,
        rangeEnd,
        lastSegmentInRange.end
      );
      lastSegmentInRange.bufferedEnd = lastSegmentInRange.end;
    } else {
      const now = monotonic_timestamp_default();
      if (rangeEnd - lastSegmentInRange.end >= MISSING_DATA_TRIGGER_SYNC_DELAY && now - lastSegmentInRange.insertionTs < SEGMENT_SYNCHRONIZATION_DELAY) {
        log_default.debug(
          "SI: Ignored bufferedEnd synchronization",
          bufferType,
          rangeEnd,
          lastSegmentInRange.end,
          now - lastSegmentInRange.insertionTs
        );
        return;
      }
      log_default.debug(
        "SI: Segment appears immediately garbage collected at the end",
        bufferType,
        lastSegmentInRange.bufferedEnd,
        rangeEnd
      );
      lastSegmentInRange.bufferedEnd = rangeEnd;
    }
  }
  function prettyPrintInventory(inventory) {
    const roundingError = 1 / 60;
    const encounteredReps = {};
    const letters = [];
    let lastChunk = null;
    let lastLetter = null;
    function generateNewLetter(infos) {
      const currentLetter = String.fromCharCode(letters.length + 65);
      letters.push({
        letter: currentLetter,
        periodId: infos.period.id,
        representationId: infos.representation.id,
        bitrate: infos.representation.bitrate
      });
      return currentLetter;
    }
    let str = "";
    for (const chunk of inventory) {
      if (chunk.bufferedStart !== void 0 && chunk.bufferedEnd !== void 0) {
        const periodId = chunk.infos.period.id;
        const representationId = chunk.infos.representation.id;
        const encounteredPeriod = encounteredReps[periodId];
        let currentLetter;
        if (encounteredPeriod === void 0) {
          currentLetter = generateNewLetter(chunk.infos);
          encounteredReps[periodId] = { [representationId]: currentLetter };
        } else {
          const previousLetter = encounteredPeriod[representationId];
          if (previousLetter === void 0) {
            currentLetter = generateNewLetter(chunk.infos);
            encounteredPeriod[representationId] = currentLetter;
          } else {
            currentLetter = previousLetter;
          }
        }
        if (lastChunk === null) {
          str += `${chunk.bufferedStart.toFixed(2)}|${currentLetter}|`;
        } else if (lastLetter === currentLetter) {
          if (lastChunk.bufferedEnd + roundingError < chunk.bufferedStart) {
            str += `${lastChunk.bufferedEnd.toFixed(2)} ~ ${chunk.bufferedStart.toFixed(2)}|${currentLetter}|`;
          }
        } else {
          str += `${lastChunk.bufferedEnd.toFixed(2)} ~ ${chunk.bufferedStart.toFixed(2)}|${currentLetter}|`;
        }
        lastChunk = chunk;
        lastLetter = currentLetter;
      }
    }
    if (lastChunk !== null) {
      str += String(lastChunk.end.toFixed(2));
    }
    letters.forEach((letterInfo) => {
      var _a;
      str += `
[${letterInfo.letter}] P: ${letterInfo.periodId} || R: ${letterInfo.representationId}(${(_a = letterInfo.bitrate) != null ? _a : "unknown bitrate"})`;
    });
    return str;
  }

  // src/core/segment_sinks/inventory/utils.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function getLastSegmentBeforePeriod(inventory, period) {
    for (let i = 0; i < inventory.length; i++) {
      if (inventory[i].infos.period.start >= period.start) {
        if (i > 0) {
          return inventory[i - 1];
        }
        return null;
      }
    }
    return inventory.length > 0 ? inventory[inventory.length - 1] : null;
  }
  function getFirstSegmentAfterPeriod(inventory, period) {
    for (const segment of inventory) {
      if (segment.infos.period.start > period.start) {
        return segment;
      }
    }
    return null;
  }

  // src/core/segment_sinks/inventory/index.ts
  var inventory_default = SegmentInventory;

  // src/core/segment_sinks/implementations/types.ts
  var SegmentSink = class {
    constructor() {
      this._segmentInventory = new inventory_default();
    }
    /**
     * The maintained inventory can fall out of sync from garbage collection or
     * other events.
     *
     * This methods allow to manually trigger a synchronization by providing the
     * buffered time ranges of the real SourceBuffer implementation.
     */
    synchronizeInventory(ranges) {
      this._segmentInventory.synchronizeBuffered(ranges);
    }
    /**
     * Returns an inventory of the last known segments to be currently contained in
     * the SegmentSink.
     *
     * /!\ Note that this data may not be up-to-date with the real current content
     * of the SegmentSink.
     * Generally speaking, pushed segments are added right away to it but segments
     * may have been since removed, which might not be known right away.
     * Please consider this when using this method, by considering that it does
     * not reflect the full reality of the underlying buffer.
     * @returns {Array.<Object>}
     */
    getLastKnownInventory() {
      return this._segmentInventory.getInventory();
    }
    /**
     * Returns a recent history of registered operations performed and event
     * received linked to the segment given in argument.
     *
     * Not all operations and events are registered in the returned history.
     * Please check the return type for more information on what is available.
     *
     * Note that history is short-lived for memory usage and performance reasons.
     * You may not receive any information on operations that happened too long
     * ago.
     * @param {Object} context
     * @returns {Array.<Object>}
     */
    getSegmentHistory(context) {
      return this._segmentInventory.getHistoryFor(context);
    }
  };

  // src/core/segment_sinks/implementations/audio_video/audio_video_segment_buffer.ts
  var AudioVideoSegmentSink = class extends SegmentSink {
    /**
     * @constructor
     * @param {string} bufferType
     * @param {string} codec
     * @param {Object} mediaSource
     */
    constructor(bufferType, codec, mediaSource) {
      super();
      log_default.info("AVSB: calling `mediaSource.addSourceBuffer`", codec);
      const sourceBuffer = mediaSource.addSourceBuffer(bufferType, codec);
      this.bufferType = bufferType;
      this._sourceBuffer = sourceBuffer;
      this._lastInitSegmentUniqueId = null;
      this.codec = codec;
      this._initSegmentsMap = /* @__PURE__ */ new Map();
      this._pendingOperations = [];
    }
    /** @see SegmentSink */
    declareInitSegment(uniqueId, initSegmentData) {
      assertDataIsBufferSource(initSegmentData);
      this._initSegmentsMap.set(uniqueId, initSegmentData);
    }
    /** @see SegmentSink */
    freeInitSegment(uniqueId) {
      this._initSegmentsMap.delete(uniqueId);
    }
    /**
     * Push a chunk of the media segment given to the attached SourceBuffer.
     *
     * Once all chunks of a single Segment have been given to `pushChunk`, you
     * should call `signalSegmentComplete` to indicate that the whole Segment has
     * been pushed.
     *
     * Depending on the type of data appended, the pushed chunk might rely on an
     * initialization segment, given through the `data.initSegment` property.
     *
     * Such initialization segment will be first pushed to the SourceBuffer if the
     * last pushed segment was associated to another initialization segment.
     * This detection rely on the initialization segment's reference so you need
     * to avoid mutating in-place a initialization segment given to that function
     * (to avoid having two different values which have the same reference).
     *
     * If you don't need any initialization segment to push the wanted chunk, you
     * can just set `data.initSegment` to `null`.
     *
     * You can also only push an initialization segment by setting the
     * `data.chunk` argument to null.
     *
     * @param {Object} infos
     * @returns {Promise}
     */
    async pushChunk(infos) {
      assertDataIsBufferSource(infos.data.chunk);
      log_default.debug(
        "AVSB: receiving order to push data to the SourceBuffer",
        this.bufferType,
        getLoggableSegmentId(infos.inventoryInfos)
      );
      const dataToPush = this._getActualDataToPush(
        infos.data
      );
      if (dataToPush.length === 0) {
        dataToPush.push(new Uint8Array());
      }
      const promise = Promise.all(
        dataToPush.map((data2) => {
          const { codec, timestampOffset, appendWindow } = infos.data;
          log_default.debug(
            "AVSB: pushing segment",
            this.bufferType,
            getLoggableSegmentId(infos.inventoryInfos)
          );
          return this._sourceBuffer.appendBuffer(data2, {
            codec,
            timestampOffset,
            appendWindow
          });
        })
      );
      this._addToOperationQueue(promise, {
        type: 0 /* Push */,
        value: infos
      });
      let res;
      try {
        res = await promise;
      } catch (err) {
        this._segmentInventory.insertChunk(
          infos.inventoryInfos,
          false,
          monotonic_timestamp_default()
        );
        throw err;
      }
      if (infos.inventoryInfos !== null) {
        this._segmentInventory.insertChunk(
          infos.inventoryInfos,
          true,
          monotonic_timestamp_default()
        );
      }
      const ranges = res[res.length - 1];
      this._segmentInventory.synchronizeBuffered(ranges);
      return ranges;
    }
    /** @see SegmentSink */
    async removeBuffer(start, end) {
      log_default.debug(
        "AVSB: receiving order to remove data from the SourceBuffer",
        this.bufferType,
        start,
        end
      );
      const promise = this._sourceBuffer.remove(start, end);
      this._addToOperationQueue(promise, {
        type: 1 /* Remove */,
        value: { start, end }
      });
      const ranges = await promise;
      this._segmentInventory.synchronizeBuffered(ranges);
      return ranges;
    }
    /**
     * Indicate that every chunks from a Segment has been given to pushChunk so
     * far.
     * This will update our internal Segment inventory accordingly.
     * The returned Promise will resolve once the whole segment has been pushed
     * and this indication is acknowledged.
     * @param {Object} infos
     * @returns {Promise}
     */
    async signalSegmentComplete(infos) {
      if (this._pendingOperations.length > 0) {
        const { promise } = this._pendingOperations[this._pendingOperations.length - 1];
        this._addToOperationQueue(promise, {
          type: 2 /* SignalSegmentComplete */,
          value: infos
        });
        try {
          await promise;
        } catch (_) {
        }
      }
      this._segmentInventory.completeSegment(infos);
    }
    /**
     * Returns the list of every operations that the `AudioVideoSegmentSink` is
     * still processing.
     * @returns {Array.<Object>}
     */
    getPendingOperations() {
      return this._pendingOperations.map((p) => p.operation);
    }
    /** @see SegmentSink */
    dispose() {
      try {
        log_default.debug("AVSB: Calling `dispose` on the SourceBufferInterface");
        this._sourceBuffer.dispose();
      } catch (e) {
        log_default.debug(
          `AVSB: Failed to dispose a ${this.bufferType} SourceBufferInterface:`,
          e instanceof Error ? e : ""
        );
      }
    }
    /**
     * A single `pushChunk` might actually necessitate two `appendBuffer` call
     * if the initialization segment needs to be pushed again.
     *
     * This method perform this check and actually return both the
     * initialization segment then the media segment when the former needs to
     * be pushed again first.
     * @param {Object} data
     * @returns {Object}
     */
    _getActualDataToPush(data2) {
      const dataToPush = [];
      if (data2.initSegmentUniqueId !== null && !this._isLastInitSegment(data2.initSegmentUniqueId)) {
        let segmentData = this._initSegmentsMap.get(data2.initSegmentUniqueId);
        if (segmentData === void 0) {
          throw new Error("Invalid initialization segment uniqueId");
        }
        const dst = new ArrayBuffer(segmentData.byteLength);
        const tmpU8 = new Uint8Array(dst);
        tmpU8.set(
          segmentData instanceof ArrayBuffer ? new Uint8Array(segmentData) : new Uint8Array(segmentData.buffer)
        );
        segmentData = tmpU8;
        dataToPush.push(segmentData);
        this._lastInitSegmentUniqueId = data2.initSegmentUniqueId;
      }
      if (data2.chunk !== null) {
        dataToPush.push(data2.chunk);
      }
      return dataToPush;
    }
    /**
     * Return `true` if the given `uniqueId` is the identifier of the last
     * initialization segment pushed to the `AudioVideoSegmentSink`.
     * @param {string} uniqueId
     * @returns {boolean}
     */
    _isLastInitSegment(uniqueId) {
      if (this._lastInitSegmentUniqueId === null) {
        return false;
      }
      return this._lastInitSegmentUniqueId === uniqueId;
    }
    _addToOperationQueue(promise, operation) {
      const queueObject = { operation, promise };
      this._pendingOperations.push(queueObject);
      const endOperation = () => {
        const indexOf = this._pendingOperations.indexOf(queueObject);
        if (indexOf >= 0) {
          this._pendingOperations.splice(indexOf, 1);
        }
      };
      promise.then(endOperation, endOperation);
    }
  };
  function assertDataIsBufferSource(data2) {
    if (define_ENVIRONMENT_default.CURRENT_ENV === define_ENVIRONMENT_default.PRODUCTION) {
      return;
    }
    if (typeof data2 !== "object" || data2 !== null && !(data2 instanceof ArrayBuffer) && !(data2.buffer instanceof ArrayBuffer)) {
      throw new Error("Invalid data given to the AudioVideoSegmentSink");
    }
  }

  // src/core/segment_sinks/implementations/audio_video/index.ts
  var audio_video_default = AudioVideoSegmentSink;

  // src/core/segment_sinks/segment_buffers_store.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/core/segment_sinks/implementations/text/index.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/core/segment_sinks/implementations/text/text_segment_buffer.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var TextSegmentSink = class extends SegmentSink {
    /**
     * @param {Object} textDisplayerSender
     */
    constructor(textDisplayerSender) {
      log_default.debug("HTSB: Creating TextSegmentSink");
      super();
      this.bufferType = "text";
      this._sender = textDisplayerSender;
      this._pendingOperations = [];
      this._sender.reset();
    }
    /**
     * @param {string} uniqueId
     */
    declareInitSegment(uniqueId) {
      log_default.warn("HTSB: Declaring initialization segment for  Text SegmentSink", uniqueId);
    }
    /**
     * @param {string} uniqueId
     */
    freeInitSegment(uniqueId) {
      log_default.warn("HTSB: Freeing initialization segment for  Text SegmentSink", uniqueId);
    }
    /**
     * Push text segment to the TextSegmentSink.
     * @param {Object} infos
     * @returns {Promise}
     */
    async pushChunk(infos) {
      const { data: data2 } = infos;
      assertChunkIsTextTrackSegmentData(data2.chunk);
      const promise = this._sender.pushTextData(__spreadProps(__spreadValues({}, data2), {
        chunk: data2.chunk
      }));
      this._addToOperationQueue(promise, {
        type: 0 /* Push */,
        value: infos
      });
      const ranges = await promise;
      if (infos.inventoryInfos !== null) {
        this._segmentInventory.insertChunk(
          infos.inventoryInfos,
          true,
          monotonic_timestamp_default()
        );
      }
      this._segmentInventory.synchronizeBuffered(ranges);
      return ranges;
    }
    /**
     * Remove buffered data.
     * @param {number} start - start position, in seconds
     * @param {number} end - end position, in seconds
     * @returns {Promise}
     */
    async removeBuffer(start, end) {
      const promise = this._sender.remove(start, end);
      this._addToOperationQueue(promise, {
        type: 1 /* Remove */,
        value: { start, end }
      });
      const ranges = await promise;
      this._segmentInventory.synchronizeBuffered(ranges);
      return ranges;
    }
    /**
     * @param {Object} infos
     * @returns {Promise}
     */
    async signalSegmentComplete(infos) {
      if (this._pendingOperations.length > 0) {
        const { promise } = this._pendingOperations[this._pendingOperations.length - 1];
        this._addToOperationQueue(promise, {
          type: 2 /* SignalSegmentComplete */,
          value: infos
        });
        try {
          await promise;
        } catch (_) {
        }
      }
      this._segmentInventory.completeSegment(infos);
    }
    /**
     * @returns {Array.<Object>}
     */
    getPendingOperations() {
      return this._pendingOperations.map((p) => p.operation);
    }
    dispose() {
      log_default.debug("HTSB: Disposing TextSegmentSink");
      this._sender.reset();
    }
    _addToOperationQueue(promise, operation) {
      const queueObject = { operation, promise };
      this._pendingOperations.push(queueObject);
      const endOperation = () => {
        const indexOf = this._pendingOperations.indexOf(queueObject);
        if (indexOf >= 0) {
          this._pendingOperations.splice(indexOf, 1);
        }
      };
      promise.then(endOperation, endOperation);
    }
  };
  function assertChunkIsTextTrackSegmentData(chunk) {
    if (define_ENVIRONMENT_default.CURRENT_ENV === define_ENVIRONMENT_default.PRODUCTION) {
      return;
    }
    if (typeof chunk !== "object" || chunk === null || typeof chunk.data !== "string" || typeof chunk.type !== "string" || chunk.language !== void 0 && typeof chunk.language !== "string" || chunk.start !== void 0 && typeof chunk.start !== "number" || chunk.end !== void 0 && typeof chunk.end !== "number") {
      throw new Error("Invalid format given to a TextSegmentSink");
    }
  }
  if (define_ENVIRONMENT_default.CURRENT_ENV === define_ENVIRONMENT_default.DEV) {
    let _checkType = function(input) {
      function checkEqual(_arg) {
      }
      checkEqual(input);
    };
    _checkType2 = _checkType;
  }
  var _checkType2;

  // src/core/segment_sinks/implementations/text/index.ts
  var text_default = TextSegmentSink;

  // src/core/segment_sinks/segment_buffers_store.ts
  var POSSIBLE_BUFFER_TYPES = ["audio", "video", "text"];
  var SegmentSinksStore = class _SegmentSinksStore {
    /**
     * Returns true if the type is linked to a "native" media buffer (i.e. relying
     * on a SourceBuffer object, native to the browser).
     * Native media buffers needed for the current content must all be created
     * before the content begins to be played and cannot be disposed during
     * playback.
     * @param {string} bufferType
     * @returns {Boolean}
     */
    static isNative(bufferType) {
      return shouldHaveNativeBuffer(bufferType);
    }
    /**
     * @param {Object} mediaSource
     * @constructor
     */
    constructor(mediaSource, hasVideo, textDisplayerInterface) {
      this._mediaSource = mediaSource;
      this._textInterface = textDisplayerInterface;
      this._hasVideo = hasVideo;
      this._initializedSegmentSinks = {};
      this._onNativeBufferAddedOrDisabled = [];
    }
    /**
     * Get all currently available buffer types.
     * /!\ This list can evolve at runtime depending on feature switching.
     * @returns {Array.<string>}
     */
    getBufferTypes() {
      const bufferTypes = this.getNativeBufferTypes();
      if (this._textInterface !== null) {
        bufferTypes.push("text");
      }
      return bufferTypes;
    }
    /**
     * Get all "native" buffer types that should be created before beginning to
     * push contents.
     * @returns {Array.<string>}
     */
    getNativeBufferTypes() {
      return this._hasVideo ? ["video", "audio"] : ["audio"];
    }
    /**
     * Returns the current "status" of the SegmentSink linked to the buffer
     * type given.
     *
     * This function will return  an object containing a key named `type` which
     * can be equal to either one of those three value:
     *
     *   - "initialized": A SegmentSink has been created for that type.
     *     You will in this case also have a second key, `value`, which will
     *     contain the related SegmentSink instance.
     *     Please note that you will need to wait until
     *     `this.waitForUsableBuffers()` has emitted before pushing segment
     *     data to a SegmentSink relying on a SourceBuffer.
     *
     *   - "disabled": The SegmentSink has been explicitely disabled for this
     *     type.
     *
     *   - "uninitialized": No action has yet been yet for that SegmentSink.
     *
     * @param {string} bufferType
     * @returns {Object|null}
     */
    getStatus(bufferType) {
      const initializedBuffer = this._initializedSegmentSinks[bufferType];
      if (initializedBuffer === void 0) {
        return { type: "uninitialized" };
      }
      if (initializedBuffer === null) {
        return { type: "disabled" };
      }
      return { type: "initialized", value: initializedBuffer };
    }
    /**
     * Native media buffers (audio and video) needed for playing the current
     * content need to all be created (by creating SegmentSinks linked to them)
     * before any one can be used.
     *
     * This function will return a Promise resolving when any and all native
     * SourceBuffers can be used.
     *
     * From https://w3c.github.io/media-source/#methods
     *   For example, a user agent may throw a QuotaExceededError
     *   exception if the media element has reached the HAVE_METADATA
     *   readyState. This can occur if the user agent's media engine
     *   does not support adding more tracks during playback.
     * @param {Object} cancelWaitSignal
     * @return {Promise}
     */
    waitForUsableBuffers(cancelWaitSignal) {
      if (this._areNativeBuffersUsable()) {
        return Promise.resolve();
      }
      return createCancellablePromise(cancelWaitSignal, (res) => {
        let onAddedOrDisabled = noop_default;
        const removeCallback = () => {
          const indexOf = this._onNativeBufferAddedOrDisabled.indexOf(onAddedOrDisabled);
          if (indexOf >= 0) {
            this._onNativeBufferAddedOrDisabled.splice(indexOf, 1);
          }
        };
        onAddedOrDisabled = () => {
          if (this._areNativeBuffersUsable()) {
            removeCallback();
            res();
          }
        };
        this._onNativeBufferAddedOrDisabled.push(onAddedOrDisabled);
        return removeCallback;
      });
    }
    /**
     * Explicitely disable the SegmentSink for a given buffer type.
     * A call to this function is needed at least for unused native buffer types
     * (usually "audio" and "video"), to be able to emit through
     * `waitForUsableBuffers` when conditions are met.
     * @param {string} bufferType
     */
    disableSegmentSink(bufferType) {
      const currentValue = this._initializedSegmentSinks[bufferType];
      if (currentValue === null) {
        log_default.warn(`SBS: The ${bufferType} SegmentSink was already disabled.`);
        return;
      }
      if (currentValue !== void 0) {
        throw new Error("Cannot disable an active SegmentSink.");
      }
      this._initializedSegmentSinks[bufferType] = null;
      if (_SegmentSinksStore.isNative(bufferType)) {
        this._onNativeBufferAddedOrDisabled.slice().forEach((cb) => cb());
        assert(this._onNativeBufferAddedOrDisabled.length === 0);
      }
    }
    /**
     * Creates a new SegmentSink associated to a type.
     * Reuse an already created one if a SegmentSink for the given type
     * already exists.
     *
     * Please note that you will need to wait until `this.waitForUsableBuffers()`
     * has emitted before pushing segment data to a SegmentSink of a native
     * type.
     * @param {string} bufferType
     * @param {string} codec
     * @returns {Object}
     */
    createSegmentSink(bufferType, codec) {
      const memorizedSegmentSink = this._initializedSegmentSinks[bufferType];
      if (shouldHaveNativeBuffer(bufferType)) {
        if (!isNullOrUndefined(memorizedSegmentSink)) {
          if (memorizedSegmentSink instanceof audio_video_default && memorizedSegmentSink.codec !== codec) {
            log_default.warn(
              "SB: Reusing native SegmentSink with codec",
              memorizedSegmentSink.codec,
              "for codec",
              codec
            );
          } else {
            log_default.info("SB: Reusing native SegmentSink with codec", codec);
          }
          return memorizedSegmentSink;
        }
        log_default.info("SB: Adding native SegmentSink with codec", codec);
        const sourceBufferType = bufferType === "audio" ? "audio" /* Audio */ : "video" /* Video */;
        const nativeSegmentSink = new audio_video_default(
          sourceBufferType,
          codec,
          this._mediaSource
        );
        this._initializedSegmentSinks[bufferType] = nativeSegmentSink;
        this._onNativeBufferAddedOrDisabled.slice().forEach((cb) => cb());
        assert(this._onNativeBufferAddedOrDisabled.length === 0);
        return nativeSegmentSink;
      }
      if (!isNullOrUndefined(memorizedSegmentSink)) {
        log_default.info("SB: Reusing a previous custom SegmentSink for the type", bufferType);
        return memorizedSegmentSink;
      }
      let segmentSink;
      if (bufferType === "text") {
        log_default.info("SB: Creating a new text SegmentSink");
        if (this._textInterface === null) {
          throw new Error("HTML Text track feature not activated");
        }
        segmentSink = new text_default(this._textInterface);
        this._initializedSegmentSinks.text = segmentSink;
        return segmentSink;
      }
      log_default.error("SB: Unknown buffer type:", bufferType);
      throw new MediaError(
        "BUFFER_TYPE_UNKNOWN",
        "The player wants to create a SegmentSink of an unknown type."
      );
    }
    /**
     * Dispose of the active SegmentSink for the given type.
     * @param {string} bufferType
     */
    disposeSegmentSink(bufferType) {
      const memorizedSegmentSink = this._initializedSegmentSinks[bufferType];
      if (isNullOrUndefined(memorizedSegmentSink)) {
        log_default.warn("SB: Trying to dispose a SegmentSink that does not exist");
        return;
      }
      log_default.info("SB: Aborting SegmentSink", bufferType);
      memorizedSegmentSink.dispose();
      delete this._initializedSegmentSinks[bufferType];
    }
    /**
     * Dispose of all SegmentSink created on this SegmentSinksStore.
     */
    disposeAll() {
      POSSIBLE_BUFFER_TYPES.forEach((bufferType) => {
        if (this.getStatus(bufferType).type === "initialized") {
          this.disposeSegmentSink(bufferType);
        }
      });
    }
    /**
     * Returns `true` when we're ready to push and decode contents to
     * SourceBuffers created by SegmentSinks of a native buffer type.
     */
    _areNativeBuffersUsable() {
      const nativeBufferTypes = this.getNativeBufferTypes();
      const hasUnitializedBuffers = nativeBufferTypes.some(
        (sbType) => this._initializedSegmentSinks[sbType] === void 0
      );
      if (hasUnitializedBuffers) {
        return false;
      }
      const areAllDisabled = nativeBufferTypes.every(
        (sbType) => this._initializedSegmentSinks[sbType] === null
      );
      if (areAllDisabled) {
        return false;
      }
      return true;
    }
    createSegmentSinkMetricsForType(bufferType) {
      var _a, _b;
      return {
        bufferType,
        codec: (_a = this._initializedSegmentSinks[bufferType]) == null ? void 0 : _a.codec,
        segmentInventory: (_b = this._initializedSegmentSinks[bufferType]) == null ? void 0 : _b.getLastKnownInventory().map((chunk) => __spreadProps(__spreadValues({}, chunk), {
          infos: getChunkContextSnapshot(chunk.infos)
        }))
      };
    }
    getSegmentSinksMetrics() {
      return {
        segmentSinks: {
          audio: this.createSegmentSinkMetricsForType("audio"),
          video: this.createSegmentSinkMetricsForType("video"),
          text: this.createSegmentSinkMetricsForType("text")
        }
      };
    }
  };
  function shouldHaveNativeBuffer(bufferType) {
    return bufferType === "audio" || bufferType === "video";
  }
  function getChunkContextSnapshot(context) {
    return {
      adaptation: context.adaptation.getMetadataSnapshot(),
      period: context.period.getMetadataSnapshot(),
      representation: context.representation.getMetadataSnapshot()
    };
  }

  // src/core/segment_sinks/index.ts
  var segment_sinks_default = SegmentSinksStore;

  // src/core/stream/index.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/core/stream/orchestrator/index.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/core/stream/orchestrator/stream_orchestrator.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/utils/weak_map_memory.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var WeakMapMemory = class {
    /**
     * @param {Function}
     */
    constructor(fn) {
      this._weakMap = /* @__PURE__ */ new WeakMap();
      this._fn = fn;
    }
    /**
     * @param {Object} obj
     * @returns {*}
     */
    get(obj) {
      const fromMemory = this._weakMap.get(obj);
      if (fromMemory === void 0) {
        const newElement = this._fn(obj);
        this._weakMap.set(obj, newElement);
        return newElement;
      } else {
        return fromMemory;
      }
    }
    /**
     * @param {Object} obj
     */
    destroy(obj) {
      this._weakMap.delete(obj);
    }
  };

  // src/core/stream/period/index.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/core/stream/period/period_stream.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/core/stream/adaptation/index.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/core/stream/adaptation/adaptation_stream.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/core/stream/representation/index.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/core/stream/representation/representation_stream.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/core/stream/representation/utils/get_buffer_status.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/core/stream/representation/utils/check_for_discontinuity.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function checkForDiscontinuity(content, checkedRange, nextSegmentStart, hasFinishedLoading, bufferedSegments) {
    const { period, adaptation, representation } = content;
    const nextBufferedInRangeIdx = getIndexOfFirstChunkInRange(
      bufferedSegments,
      checkedRange
    );
    if (nextBufferedInRangeIdx === null) {
      if (nextSegmentStart === null) {
        if (hasFinishedLoading && period.end !== void 0 && checkedRange.end >= period.end) {
          return { start: void 0, end: null };
        }
        const discontinuityEnd = representation.index.checkDiscontinuity(
          checkedRange.start
        );
        if (discontinuityEnd !== null) {
          return { start: void 0, end: discontinuityEnd };
        }
      }
      return null;
    }
    const nextBufferedSegment = bufferedSegments[nextBufferedInRangeIdx];
    if (
      // Next buffered segment starts after the start of the current range
      nextBufferedSegment.bufferedStart !== void 0 && nextBufferedSegment.bufferedStart > checkedRange.start && // and no segment will fill in that hole
      (nextSegmentStart === null || nextBufferedSegment.infos.segment.end <= nextSegmentStart)
    ) {
      const discontinuityEnd = nextBufferedSegment.bufferedStart;
      if (!hasFinishedLoading && representation.index.awaitSegmentBetween(checkedRange.start, discontinuityEnd) !== false) {
        return null;
      }
      log_default.debug(
        "RS: current discontinuity encountered",
        adaptation.type,
        nextBufferedSegment.bufferedStart
      );
      return { start: void 0, end: discontinuityEnd };
    }
    const nextHoleIdx = getIndexOfFirstDiscontinuityBetweenChunks(
      bufferedSegments,
      checkedRange,
      nextBufferedInRangeIdx + 1
    );
    if (nextHoleIdx !== null) {
      const segmentInfoBeforeHole = bufferedSegments[nextHoleIdx - 1];
      const segmentInfoAfterHole = bufferedSegments[nextHoleIdx];
      if (nextSegmentStart === null || segmentInfoAfterHole.infos.segment.end <= nextSegmentStart) {
        if (!hasFinishedLoading && representation.index.awaitSegmentBetween(
          segmentInfoBeforeHole.infos.segment.end,
          segmentInfoAfterHole.infos.segment.time
        ) !== false) {
          return null;
        }
        const start = segmentInfoBeforeHole.bufferedEnd;
        const end = segmentInfoAfterHole.bufferedStart;
        log_default.debug("RS: future discontinuity encountered", adaptation.type, start, end);
        return { start, end };
      }
    }
    if (nextSegmentStart === null) {
      if (hasFinishedLoading && period.end !== void 0) {
        if (checkedRange.end < period.end) {
          return null;
        }
        const lastBufferedInPeriodIdx = getIndexOfLastChunkInPeriod(
          bufferedSegments,
          period.end
        );
        if (lastBufferedInPeriodIdx !== null) {
          const lastSegment = bufferedSegments[lastBufferedInPeriodIdx];
          if (lastSegment.bufferedEnd !== void 0 && lastSegment.bufferedEnd < period.end) {
            log_default.debug(
              "RS: discontinuity encountered at the end of the current period",
              adaptation.type,
              lastSegment.bufferedEnd,
              period.end
            );
            return { start: lastSegment.bufferedEnd, end: null };
          }
        }
      }
      if (period.end !== void 0 && checkedRange.end >= period.end) {
        return null;
      }
      for (let bufIdx = bufferedSegments.length - 1; bufIdx >= 0; bufIdx--) {
        const bufSeg = bufferedSegments[bufIdx];
        if (bufSeg.bufferedStart === void 0) {
          break;
        }
        if (bufSeg.bufferedStart < checkedRange.end) {
          if (bufSeg.bufferedEnd !== void 0 && bufSeg.bufferedEnd < checkedRange.end) {
            const discontinuityEnd = representation.index.checkDiscontinuity(
              checkedRange.end
            );
            if (discontinuityEnd !== null) {
              return { start: bufSeg.bufferedEnd, end: discontinuityEnd };
            }
          }
          return null;
        }
      }
    }
    return null;
  }
  function getIndexOfFirstChunkInRange(bufferedChunks, range) {
    for (let bufIdx = 0; bufIdx < bufferedChunks.length; bufIdx++) {
      const bufSeg = bufferedChunks[bufIdx];
      if (bufSeg.bufferedStart === void 0 || bufSeg.bufferedEnd === void 0 || bufSeg.bufferedStart >= range.end) {
        return null;
      }
      if (bufSeg.bufferedEnd > range.start) {
        return bufIdx;
      }
    }
    return null;
  }
  function getIndexOfFirstDiscontinuityBetweenChunks(bufferedChunks, range, startFromIndex) {
    if (startFromIndex <= 0) {
      log_default.error("RS: Asked to check a discontinuity before the first chunk.");
      return null;
    }
    for (let bufIdx = startFromIndex; bufIdx < bufferedChunks.length; bufIdx++) {
      const currSegment = bufferedChunks[bufIdx];
      const prevSegment = bufferedChunks[bufIdx - 1];
      if (currSegment.bufferedStart === void 0 || prevSegment.bufferedEnd === void 0 || currSegment.bufferedStart >= range.end) {
        return null;
      }
      if (currSegment.bufferedStart - prevSegment.bufferedEnd > 0) {
        return bufIdx;
      }
    }
    return null;
  }
  function getIndexOfLastChunkInPeriod(bufferedChunks, periodEnd) {
    for (let bufIdx = bufferedChunks.length - 1; bufIdx >= 0; bufIdx--) {
      const bufSeg = bufferedChunks[bufIdx];
      if (bufSeg.bufferedStart === void 0) {
        return null;
      }
      if (bufSeg.bufferedStart < periodEnd) {
        return bufIdx;
      }
    }
    return null;
  }

  // src/core/stream/representation/utils/get_needed_segments.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function getNeededSegments({
    bufferedSegments,
    content,
    currentPlaybackTime,
    fastSwitchThreshold,
    getBufferedHistory,
    neededRange,
    segmentsBeingPushed,
    maxBufferSize
  }) {
    const { adaptation, representation } = content;
    let availableBufferSize = getAvailableBufferSize(
      bufferedSegments,
      segmentsBeingPushed,
      maxBufferSize
    );
    const availableSegmentsForRange = representation.index.getSegments(
      neededRange.start,
      neededRange.end - neededRange.start
    );
    const segmentsToKeep = bufferedSegments.filter(
      (bufferedSegment) => !shouldContentBeReplaced(
        bufferedSegment.infos,
        content,
        currentPlaybackTime,
        fastSwitchThreshold
      )
    );
    const reusableSegments = filterOutGCedSegments(
      segmentsToKeep,
      neededRange,
      getBufferedHistory
    );
    const { MINIMUM_SEGMENT_SIZE, MIN_BUFFER_AHEAD } = config_default.getCurrent();
    let shouldStopLoadingSegments = false;
    const ROUNDING_ERROR = Math.min(1 / 60, MINIMUM_SEGMENT_SIZE);
    let isBufferFull = false;
    const segmentsOnHold = [];
    const segmentsToLoad = availableSegmentsForRange.filter((segment) => {
      const contentObject = object_assign_default({ segment }, content);
      if (segmentsBeingPushed.length > 0) {
        const isAlreadyBeingPushed = segmentsBeingPushed.some(
          (pendingSegment) => areSameContent(contentObject, pendingSegment)
        );
        if (isAlreadyBeingPushed) {
          return false;
        }
      }
      const { duration, time, end } = segment;
      if (segment.isInit) {
        return true;
      }
      if (shouldStopLoadingSegments) {
        segmentsOnHold.push(segment);
        return false;
      }
      if (segment.complete && duration < MINIMUM_SEGMENT_SIZE) {
        return false;
      }
      if (segmentsBeingPushed.length > 0) {
        const waitForPushedSegment = segmentsBeingPushed.some((pendingSegment) => {
          if (pendingSegment.period.id !== content.period.id || pendingSegment.adaptation.id !== content.adaptation.id) {
            return false;
          }
          const { segment: oldSegment } = pendingSegment;
          if (oldSegment.time - ROUNDING_ERROR > time) {
            return false;
          }
          if (oldSegment.complete) {
            if (oldSegment.end + ROUNDING_ERROR < end) {
              return false;
            }
          } else if (Math.abs(time - oldSegment.time) > time) {
            return false;
          }
          return !shouldContentBeReplaced(
            pendingSegment,
            contentObject,
            currentPlaybackTime,
            fastSwitchThreshold
          );
        });
        if (waitForPushedSegment) {
          return false;
        }
      }
      for (const completeSeg of reusableSegments) {
        const areFromSamePeriod = completeSeg.infos.period.id === content.period.id;
        if (completeSeg.status === 1 /* FullyLoaded */ && areFromSamePeriod) {
          const completeSegInfos = completeSeg.infos.segment;
          if (time - completeSegInfos.time > -ROUNDING_ERROR) {
            if (completeSegInfos.complete) {
              if (completeSegInfos.end - end > -ROUNDING_ERROR) {
                return false;
              }
            } else if (Math.abs(time - completeSegInfos.time) < ROUNDING_ERROR) {
              return false;
            }
          }
        }
      }
      const estimatedSegmentSize = duration * content.representation.bitrate;
      if (availableBufferSize - estimatedSegmentSize < 0) {
        isBufferFull = true;
        if (time > neededRange.start + MIN_BUFFER_AHEAD) {
          shouldStopLoadingSegments = true;
          segmentsOnHold.push(segment);
          return false;
        }
      }
      const segmentHistory = getBufferedHistory(contentObject);
      if (segmentHistory.length > 1) {
        const lastTimeItWasPushed = segmentHistory[segmentHistory.length - 1];
        const beforeLastTimeItWasPushed = segmentHistory[segmentHistory.length - 2];
        if (lastTimeItWasPushed.buffered === null && beforeLastTimeItWasPushed.buffered === null) {
          log_default.warn(
            "Stream: Segment GCed multiple times in a row, ignoring it.",
            "If this happens a lot and lead to unpleasant experience, please  check your device's available memory. If it's low when this message is emitted, you might want to update the RxPlayer's settings (`maxBufferAhead`, `maxVideoBufferSize` etc.) so less memory is used by regular media data buffering." + adaptation.type,
            representation.id,
            segment.time
          );
          return false;
        }
      }
      for (let i = 0; i < reusableSegments.length; i++) {
        const completeSeg = reusableSegments[i];
        if (completeSeg.end + ROUNDING_ERROR > time) {
          const shouldLoad = completeSeg.start > time + ROUNDING_ERROR || getLastContiguousSegment(reusableSegments, i).end < end - ROUNDING_ERROR;
          if (shouldLoad) {
            availableBufferSize -= estimatedSegmentSize;
          }
          return shouldLoad;
        }
      }
      availableBufferSize -= estimatedSegmentSize;
      return true;
    });
    return { segmentsToLoad, segmentsOnHold, isBufferFull };
  }
  function getAvailableBufferSize(bufferedSegments, segmentsBeingPushed, maxVideoBufferSize) {
    let availableBufferSize = maxVideoBufferSize * 8e3;
    availableBufferSize -= segmentsBeingPushed.reduce((size, segment) => {
      const { bitrate } = segment.representation;
      const { duration } = segment.segment;
      return size + bitrate * duration;
    }, 0);
    return bufferedSegments.reduce((size, chunk) => {
      if (chunk.chunkSize !== void 0) {
        return size - chunk.chunkSize * 8;
      } else {
        return size;
      }
    }, availableBufferSize);
  }
  function getLastContiguousSegment(bufferedSegments, startIndex) {
    let j = startIndex + 1;
    const { MINIMUM_SEGMENT_SIZE } = config_default.getCurrent();
    const ROUNDING_ERROR = Math.min(1 / 60, MINIMUM_SEGMENT_SIZE);
    while (j < bufferedSegments.length - 1 && bufferedSegments[j - 1].end + ROUNDING_ERROR > bufferedSegments[j].start) {
      j++;
    }
    j--;
    return bufferedSegments[j];
  }
  function shouldContentBeReplaced(oldContent, currentContent, currentPlaybackTime, fastSwitchThreshold) {
    const { CONTENT_REPLACEMENT_PADDING } = config_default.getCurrent();
    if (oldContent.period.id !== currentContent.period.id) {
      return false;
    }
    const { segment } = oldContent;
    if (segment.time < currentPlaybackTime + CONTENT_REPLACEMENT_PADDING) {
      return false;
    }
    if (oldContent.adaptation.id !== currentContent.adaptation.id) {
      return true;
    }
    return canFastSwitch(
      oldContent.representation,
      currentContent.representation,
      fastSwitchThreshold
    );
  }
  function canFastSwitch(oldSegmentRepresentation, newSegmentRepresentation, fastSwitchThreshold) {
    const oldContentBitrate = oldSegmentRepresentation.bitrate;
    const { BITRATE_REBUFFERING_RATIO } = config_default.getCurrent();
    if (fastSwitchThreshold === void 0) {
      const bitrateCeil = oldContentBitrate * BITRATE_REBUFFERING_RATIO;
      return newSegmentRepresentation.bitrate > bitrateCeil;
    }
    return oldContentBitrate < fastSwitchThreshold && newSegmentRepresentation.bitrate > oldContentBitrate;
  }
  function doesStartSeemGarbageCollected(currentSeg, prevSeg, maximumStartTime) {
    const { MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT } = config_default.getCurrent();
    if (currentSeg.bufferedStart === void 0) {
      return false;
    }
    if (prevSeg !== null && prevSeg.bufferedEnd !== void 0 && currentSeg.bufferedStart - prevSeg.bufferedEnd < 0.1) {
      return false;
    }
    if (maximumStartTime < currentSeg.bufferedStart && currentSeg.bufferedStart - currentSeg.start > MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT) {
      log_default.info(
        "Stream: The start of the wanted segment has been garbage collected",
        currentSeg.start,
        currentSeg.bufferedStart
      );
      return true;
    }
    return false;
  }
  function doesEndSeemGarbageCollected(currentSeg, nextSeg, minimumEndTime) {
    const { MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT } = config_default.getCurrent();
    if (currentSeg.bufferedEnd === void 0) {
      return false;
    }
    if (nextSeg !== null && nextSeg.bufferedStart !== void 0 && nextSeg.bufferedStart - currentSeg.bufferedEnd < 0.1) {
      return false;
    }
    if (minimumEndTime > currentSeg.bufferedEnd && currentSeg.end - currentSeg.bufferedEnd > MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT) {
      log_default.info(
        "Stream: The end of the wanted segment has been garbage collected",
        currentSeg.end,
        currentSeg.bufferedEnd
      );
      return true;
    }
    return false;
  }
  function shouldReloadSegmentGCedAtTheStart(segmentEntries, currentBufferedStart) {
    var _a, _b;
    if (segmentEntries.length < 2) {
      return true;
    }
    const lastEntry = segmentEntries[segmentEntries.length - 1];
    const lastBufferedStart = (_a = lastEntry.buffered) == null ? void 0 : _a.start;
    if (currentBufferedStart !== void 0 && lastBufferedStart !== void 0 && currentBufferedStart - lastBufferedStart > 0.05) {
      return true;
    }
    const prevEntry = segmentEntries[segmentEntries.length - 2];
    const prevBufferedStart = (_b = prevEntry.buffered) == null ? void 0 : _b.start;
    if (prevBufferedStart === void 0 || lastBufferedStart === void 0) {
      return true;
    }
    return Math.abs(prevBufferedStart - lastBufferedStart) > 0.01;
  }
  function shouldReloadSegmentGCedAtTheEnd(segmentEntries, currentBufferedEnd) {
    var _a, _b;
    if (segmentEntries.length < 2) {
      return true;
    }
    const lastEntry = segmentEntries[segmentEntries.length - 1];
    const lastBufferedEnd = (_a = lastEntry.buffered) == null ? void 0 : _a.end;
    if (currentBufferedEnd !== void 0 && lastBufferedEnd !== void 0 && lastBufferedEnd - currentBufferedEnd > 0.05) {
      return true;
    }
    const prevEntry = segmentEntries[segmentEntries.length - 2];
    const prevBufferedEnd = (_b = prevEntry.buffered) == null ? void 0 : _b.end;
    if (prevBufferedEnd === void 0 || lastBufferedEnd === void 0) {
      return true;
    }
    return Math.abs(prevBufferedEnd - lastBufferedEnd) > 0.01;
  }
  function filterOutGCedSegments(segments, neededRange, getBufferedHistory) {
    return segments.filter((currentSeg, i, consideredSegments) => {
      const prevSeg = i === 0 ? null : consideredSegments[i - 1];
      const nextSeg = i >= consideredSegments.length - 1 ? null : consideredSegments[i + 1];
      let lazySegmentHistory = null;
      if (doesStartSeemGarbageCollected(currentSeg, prevSeg, neededRange.start)) {
        lazySegmentHistory = getBufferedHistory(currentSeg.infos);
        if (shouldReloadSegmentGCedAtTheStart(lazySegmentHistory, currentSeg.bufferedStart)) {
          return false;
        }
        log_default.debug(
          "Stream: skipping segment gc-ed at the start",
          currentSeg.start,
          currentSeg.bufferedStart
        );
      }
      if (doesEndSeemGarbageCollected(currentSeg, nextSeg, neededRange.end)) {
        lazySegmentHistory = lazySegmentHistory != null ? lazySegmentHistory : getBufferedHistory(currentSeg.infos);
        if (shouldReloadSegmentGCedAtTheEnd(lazySegmentHistory, currentSeg.bufferedEnd)) {
          return false;
        }
        log_default.debug(
          "Stream: skipping segment gc-ed at the end",
          currentSeg.end,
          currentSeg.bufferedEnd
        );
      }
      return true;
    });
  }

  // src/core/stream/representation/utils/get_segment_priority.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function getSegmentPriority(segmentTime, wantedStartTimestamp) {
    const distance = segmentTime - wantedStartTimestamp;
    const { SEGMENT_PRIORITIES_STEPS } = config_default.getCurrent();
    for (let priority = 0; priority < SEGMENT_PRIORITIES_STEPS.length; priority++) {
      if (distance < SEGMENT_PRIORITIES_STEPS[priority]) {
        return priority;
      }
    }
    return SEGMENT_PRIORITIES_STEPS.length;
  }

  // src/core/stream/representation/utils/get_buffer_status.ts
  function getBufferStatus(content, initialWantedTime, playbackObserver, fastSwitchThreshold, bufferGoal, maxBufferSize, segmentSink) {
    var _a, _b, _c;
    const { representation } = content;
    const isPaused = (_b = (_a = playbackObserver.getIsPaused()) != null ? _a : playbackObserver.getReference().getValue().paused.pending) != null ? _b : playbackObserver.getReference().getValue().paused.last;
    const playbackRate = (_c = playbackObserver.getPlaybackRate()) != null ? _c : playbackObserver.getReference().getValue().speed;
    let askedStart = initialWantedTime;
    if (isPaused === void 0 || playbackRate === void 0 || isPaused || playbackRate <= 0) {
      askedStart -= 0.1;
    }
    const neededRange = getRangeOfNeededSegments(content, askedStart, bufferGoal);
    const shouldRefreshManifest = representation.index.shouldRefresh(
      neededRange.start,
      neededRange.end
    );
    const segmentsBeingPushed = segmentSink.getPendingOperations().filter(
      (operation) => operation.type === 2 /* SignalSegmentComplete */
    ).map((operation) => operation.value);
    const bufferedSegments = segmentSink.getLastKnownInventory();
    let currentPlaybackTime = playbackObserver.getCurrentTime();
    if (currentPlaybackTime === void 0) {
      currentPlaybackTime = playbackObserver.getReference().getValue().position.getWanted();
    }
    const getBufferedHistory = segmentSink.getSegmentHistory.bind(segmentSink);
    const { segmentsToLoad, segmentsOnHold, isBufferFull } = getNeededSegments({
      content,
      bufferedSegments,
      currentPlaybackTime,
      fastSwitchThreshold,
      getBufferedHistory,
      neededRange,
      segmentsBeingPushed,
      maxBufferSize
    });
    const prioritizedNeededSegments = segmentsToLoad.map((segment) => ({
      priority: getSegmentPriority(segment.time, askedStart),
      segment
    }));
    const hasFinishedLoading = representation.index.isInitialized() && !representation.index.isStillAwaitingFutureSegments() && neededRange.hasReachedPeriodEnd && prioritizedNeededSegments.length === 0 && segmentsOnHold.length === 0;
    let nextSegmentStart = null;
    if (segmentsBeingPushed.length > 0) {
      nextSegmentStart = Math.min(...segmentsBeingPushed.map((info) => info.segment.time));
    }
    if (segmentsOnHold.length > 0) {
      nextSegmentStart = nextSegmentStart !== null ? Math.min(nextSegmentStart, segmentsOnHold[0].time) : segmentsOnHold[0].time;
    }
    if (prioritizedNeededSegments.length > 0) {
      nextSegmentStart = nextSegmentStart !== null ? Math.min(nextSegmentStart, prioritizedNeededSegments[0].segment.time) : prioritizedNeededSegments[0].segment.time;
    }
    const imminentDiscontinuity = checkForDiscontinuity(
      content,
      neededRange,
      nextSegmentStart,
      hasFinishedLoading,
      bufferedSegments
    );
    return {
      imminentDiscontinuity,
      hasFinishedLoading,
      neededSegments: prioritizedNeededSegments,
      isBufferFull,
      shouldRefreshManifest
    };
  }
  function getRangeOfNeededSegments(content, initialWantedTime, bufferGoal) {
    var _a;
    let wantedStartPosition;
    const { manifest, period, representation } = content;
    const lastIndexPosition = representation.index.getLastAvailablePosition();
    const representationIndex = representation.index;
    if (!isNullOrUndefined(lastIndexPosition) && segment_sinks_default.isNative(content.adaptation.type) && initialWantedTime >= lastIndexPosition && representationIndex.isInitialized() && !representationIndex.isStillAwaitingFutureSegments() && isPeriodTheCurrentAndLastOne(manifest, period, initialWantedTime)) {
      wantedStartPosition = lastIndexPosition - 1;
    } else {
      wantedStartPosition = initialWantedTime - 0.1;
    }
    const wantedEndPosition = wantedStartPosition + bufferGoal;
    let hasReachedPeriodEnd;
    if (!representation.index.isInitialized() || representation.index.isStillAwaitingFutureSegments() || period.end === void 0) {
      hasReachedPeriodEnd = false;
    } else if (lastIndexPosition === void 0) {
      hasReachedPeriodEnd = wantedEndPosition >= period.end;
    } else if (lastIndexPosition === null) {
      hasReachedPeriodEnd = true;
    } else {
      hasReachedPeriodEnd = wantedEndPosition >= lastIndexPosition;
    }
    return {
      start: Math.max(wantedStartPosition, period.start),
      end: Math.min(wantedEndPosition, (_a = period.end) != null ? _a : Infinity),
      hasReachedPeriodEnd
    };
  }
  function isPeriodTheCurrentAndLastOne(manifest, period, time) {
    var _a;
    const nextPeriod = manifest.getPeriodAfter(period);
    return period.containsTime(time, nextPeriod) && manifest.isLastPeriodKnown && period.id === ((_a = manifest.periods[manifest.periods.length - 1]) == null ? void 0 : _a.id);
  }

  // src/core/stream/representation/utils/push_init_segment.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/core/stream/representation/utils/append_segment_to_buffer.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  async function appendSegmentToBuffer(playbackObserver, segmentSink, dataInfos, bufferGoal, cancellationSignal) {
    try {
      return await segmentSink.pushChunk(dataInfos);
    } catch (appendError) {
      if (cancellationSignal.isCancelled() && appendError instanceof CancellationError) {
        throw appendError;
      } else if (!(appendError instanceof SourceBufferError) || !appendError.isBufferFull) {
        const reason = appendError instanceof Error ? appendError.toString() : "An unknown error happened when pushing content";
        throw new MediaError("BUFFER_APPEND_ERROR", reason, {
          tracks: [toTaggedTrack(dataInfos.inventoryInfos.adaptation)]
        });
      }
      const { position } = playbackObserver.getReference().getValue();
      const currentPos = position.getWanted();
      try {
        log_default.warn("Stream: Running garbage collector");
        const start = Math.max(currentPos - 5, 0);
        const end = currentPos + bufferGoal.getValue() + 12;
        await segmentSink.removeBuffer(0, start);
        await segmentSink.removeBuffer(end, Number.MAX_VALUE);
        await sleep(200);
        if (cancellationSignal.cancellationError !== null) {
          throw cancellationSignal.cancellationError;
        }
        return await segmentSink.pushChunk(dataInfos);
      } catch (err2) {
        if (err2 instanceof CancellationError) {
          throw err2;
        }
        const reason = err2 instanceof Error ? err2.toString() : "Could not clean the buffer";
        throw new MediaError("BUFFER_FULL_ERROR", reason, {
          tracks: [toTaggedTrack(dataInfos.inventoryInfos.adaptation)]
        });
      }
    }
  }

  // src/core/stream/representation/utils/push_init_segment.ts
  async function pushInitSegment({
    playbackObserver,
    content,
    initSegmentUniqueId,
    segment,
    segmentSink,
    bufferGoal
  }, cancelSignal) {
    if (cancelSignal.cancellationError !== null) {
      throw cancelSignal.cancellationError;
    }
    const codec = content.representation.getMimeTypeString();
    const data2 = {
      initSegmentUniqueId,
      chunk: null,
      timestampOffset: 0,
      appendWindow: [void 0, void 0],
      codec
    };
    const inventoryInfos = object_assign_default(
      { segment, chunkSize: void 0, start: 0, end: 0 },
      content
    );
    const buffered = await appendSegmentToBuffer(
      playbackObserver,
      segmentSink,
      { data: data2, inventoryInfos },
      bufferGoal,
      cancelSignal
    );
    return { content, segment, buffered };
  }

  // src/core/stream/representation/utils/push_media_segment.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  async function pushMediaSegment({
    playbackObserver,
    bufferGoal,
    content,
    initSegmentUniqueId,
    parsedSegment,
    segment,
    segmentSink
  }, cancelSignal) {
    var _a, _b;
    if (parsedSegment.chunkData === null) {
      return null;
    }
    if (cancelSignal.cancellationError !== null) {
      throw cancelSignal.cancellationError;
    }
    const { chunkData, chunkInfos, chunkOffset, chunkSize, appendWindow } = parsedSegment;
    const codec = content.representation.getMimeTypeString();
    const { APPEND_WINDOW_SECURITIES } = config_default.getCurrent();
    const safeAppendWindow = [
      appendWindow[0] !== void 0 ? Math.max(0, appendWindow[0] - APPEND_WINDOW_SECURITIES.START) : void 0,
      appendWindow[1] !== void 0 ? appendWindow[1] + APPEND_WINDOW_SECURITIES.END : void 0
    ];
    const data2 = {
      initSegmentUniqueId,
      chunk: chunkData,
      timestampOffset: chunkOffset,
      appendWindow: safeAppendWindow,
      codec
    };
    let estimatedStart = (_a = chunkInfos == null ? void 0 : chunkInfos.time) != null ? _a : segment.time;
    const estimatedDuration = (_b = chunkInfos == null ? void 0 : chunkInfos.duration) != null ? _b : segment.duration;
    let estimatedEnd = estimatedStart + estimatedDuration;
    if (safeAppendWindow[0] !== void 0) {
      estimatedStart = Math.max(estimatedStart, safeAppendWindow[0]);
    }
    if (safeAppendWindow[1] !== void 0) {
      estimatedEnd = Math.min(estimatedEnd, safeAppendWindow[1]);
    }
    const inventoryInfos = object_assign_default(
      { segment, chunkSize, start: estimatedStart, end: estimatedEnd },
      content
    );
    const buffered = await appendSegmentToBuffer(
      playbackObserver,
      segmentSink,
      { data: data2, inventoryInfos },
      bufferGoal,
      cancelSignal
    );
    return { content, segment, buffered };
  }

  // src/core/stream/representation/representation_stream.ts
  function RepresentationStream({
    content,
    options,
    playbackObserver,
    segmentSink,
    segmentQueue,
    terminate
  }, callbacks, parentCancelSignal) {
    const { period, adaptation, representation } = content;
    const { bufferGoal, maxBufferSize, drmSystemId, fastSwitchThreshold } = options;
    const bufferType = adaptation.type;
    const globalCanceller = new TaskCanceller();
    globalCanceller.linkToSignal(parentCancelSignal);
    const segmentsLoadingCanceller = new TaskCanceller();
    segmentsLoadingCanceller.linkToSignal(globalCanceller.signal);
    const initSegmentState = {
      segment: representation.index.getInitSegment(),
      uniqueId: null,
      isLoaded: false
    };
    globalCanceller.signal.register(() => {
      if (initSegmentState.uniqueId !== null) {
        segmentSink.freeInitSegment(initSegmentState.uniqueId);
      }
    });
    const hasInitSegment = initSegmentState.segment !== null;
    if (!hasInitSegment) {
      initSegmentState.isLoaded = true;
    }
    let hasSentEncryptionData = false;
    if (drmSystemId !== void 0) {
      const encryptionData = representation.getEncryptionData(drmSystemId);
      if (encryptionData.length > 0 && encryptionData.every((e) => e.keyIds !== void 0)) {
        hasSentEncryptionData = true;
        callbacks.encryptionDataEncountered(
          encryptionData.map((d) => object_assign_default({ content }, d))
        );
        if (globalCanceller.isUsed()) {
          return;
        }
      }
    }
    segmentQueue.addEventListener("error", (err) => {
      if (segmentsLoadingCanceller.signal.isCancelled()) {
        return;
      }
      globalCanceller.cancel();
      callbacks.error(err);
    });
    segmentQueue.addEventListener(
      "parsedInitSegment",
      onParsedChunk,
      segmentsLoadingCanceller.signal
    );
    segmentQueue.addEventListener(
      "parsedMediaSegment",
      onParsedChunk,
      segmentsLoadingCanceller.signal
    );
    segmentQueue.addEventListener(
      "emptyQueue",
      checkStatus,
      segmentsLoadingCanceller.signal
    );
    segmentQueue.addEventListener(
      "requestRetry",
      (payload) => {
        callbacks.warning(payload.error);
        if (segmentsLoadingCanceller.signal.isCancelled()) {
          return;
        }
        const retriedSegment = payload.segment;
        const { index } = representation;
        if (index.isSegmentStillAvailable(retriedSegment) === false) {
          checkStatus();
        } else if (index.canBeOutOfSyncError(payload.error, retriedSegment)) {
          callbacks.manifestMightBeOufOfSync();
        }
      },
      segmentsLoadingCanceller.signal
    );
    segmentQueue.addEventListener(
      "fullyLoadedSegment",
      (segment) => {
        segmentSink.signalSegmentComplete(object_assign_default({ segment }, content)).catch(onFatalBufferError);
      },
      segmentsLoadingCanceller.signal
    );
    const segmentsToLoadRef = segmentQueue.resetForContent(content, hasInitSegment);
    segmentsLoadingCanceller.signal.register(() => {
      segmentQueue.stop();
    });
    playbackObserver.listen(checkStatus, {
      includeLastObservation: false,
      clearSignal: segmentsLoadingCanceller.signal
    });
    content.manifest.addEventListener(
      "manifestUpdate",
      checkStatus,
      segmentsLoadingCanceller.signal
    );
    bufferGoal.onUpdate(checkStatus, {
      emitCurrentValue: false,
      clearSignal: segmentsLoadingCanceller.signal
    });
    maxBufferSize.onUpdate(checkStatus, {
      emitCurrentValue: false,
      clearSignal: segmentsLoadingCanceller.signal
    });
    terminate.onUpdate(checkStatus, {
      emitCurrentValue: false,
      clearSignal: segmentsLoadingCanceller.signal
    });
    checkStatus();
    return;
    function checkStatus() {
      if (segmentsLoadingCanceller.isUsed()) {
        return;
      }
      const observation = playbackObserver.getReference().getValue();
      const initialWantedTime = observation.position.getWanted();
      const status = getBufferStatus(
        content,
        initialWantedTime,
        playbackObserver,
        fastSwitchThreshold.getValue(),
        bufferGoal.getValue(),
        maxBufferSize.getValue(),
        segmentSink
      );
      const { neededSegments } = status;
      let neededInitSegment = null;
      if (!representation.index.isInitialized()) {
        if (initSegmentState.segment === null) {
          log_default.warn("Stream: Uninitialized index without an initialization segment");
        } else if (initSegmentState.isLoaded) {
          log_default.warn(
            "Stream: Uninitialized index with an already loaded initialization segment"
          );
        } else {
          const wantedStart = observation.position.getWanted();
          neededInitSegment = {
            segment: initSegmentState.segment,
            priority: getSegmentPriority(period.start, wantedStart)
          };
        }
      } else if (neededSegments.length > 0 && !initSegmentState.isLoaded && initSegmentState.segment !== null) {
        const initSegmentPriority = neededSegments[0].priority;
        neededInitSegment = {
          segment: initSegmentState.segment,
          priority: initSegmentPriority
        };
      }
      const terminateVal = terminate.getValue();
      if (terminateVal === null) {
        segmentsToLoadRef.setValue({
          initSegment: neededInitSegment,
          segmentQueue: neededSegments
        });
      } else if (terminateVal.urgent) {
        log_default.debug("Stream: Urgent switch, terminate now.", bufferType);
        segmentsToLoadRef.setValue({ initSegment: null, segmentQueue: [] });
        segmentsToLoadRef.finish();
        segmentsLoadingCanceller.cancel();
        callbacks.terminating();
        return;
      } else {
        const mostNeededSegment = neededSegments[0];
        const initSegmentRequest = segmentQueue.getRequestedInitSegment();
        const currentSegmentRequest = segmentQueue.getRequestedMediaSegment();
        const nextQueue = currentSegmentRequest === null || mostNeededSegment === void 0 || currentSegmentRequest.id !== mostNeededSegment.segment.id ? [] : [mostNeededSegment];
        const nextInit = initSegmentRequest === null ? null : neededInitSegment;
        segmentsToLoadRef.setValue({
          initSegment: nextInit,
          segmentQueue: nextQueue
        });
        if (nextQueue.length === 0 && nextInit === null) {
          log_default.debug("Stream: No request left, terminate", bufferType);
          segmentsToLoadRef.finish();
          segmentsLoadingCanceller.cancel();
          callbacks.terminating();
          return;
        }
      }
      callbacks.streamStatusUpdate({
        period,
        position: observation.position.getWanted(),
        bufferType,
        imminentDiscontinuity: status.imminentDiscontinuity,
        isEmptyStream: false,
        hasFinishedLoading: status.hasFinishedLoading,
        neededSegments: status.neededSegments
      });
      if (segmentsLoadingCanceller.signal.isCancelled()) {
        return;
      }
      const { UPTO_CURRENT_POSITION_CLEANUP } = config_default.getCurrent();
      if (status.isBufferFull) {
        const gcedPosition = Math.max(0, initialWantedTime - UPTO_CURRENT_POSITION_CLEANUP);
        if (gcedPosition > 0) {
          segmentSink.removeBuffer(0, gcedPosition).catch(onFatalBufferError);
        }
      }
      if (status.shouldRefreshManifest) {
        callbacks.needsManifestRefresh();
      }
    }
    function onParsedChunk(evt) {
      if (globalCanceller.isUsed()) {
        return;
      }
      for (const protInfo of evt.protectionData) {
        representation.addProtectionData(
          protInfo.initDataType,
          protInfo.keyId,
          protInfo.initData
        );
      }
      if (!hasSentEncryptionData) {
        const allEncryptionData = representation.getAllEncryptionData();
        if (allEncryptionData.length > 0) {
          callbacks.encryptionDataEncountered(
            allEncryptionData.map((p) => object_assign_default({ content }, p))
          );
          hasSentEncryptionData = true;
          if (globalCanceller.isUsed()) {
            return;
          }
        }
      }
      if (evt.segmentType === "init") {
        if (!representation.index.isInitialized() && evt.segmentList !== void 0) {
          representation.index.initialize(evt.segmentList);
        }
        initSegmentState.isLoaded = true;
        if (evt.initializationData !== null) {
          const initSegmentUniqueId = representation.uniqueId;
          initSegmentState.uniqueId = initSegmentUniqueId;
          segmentSink.declareInitSegment(initSegmentUniqueId, evt.initializationData);
          pushInitSegment(
            {
              playbackObserver,
              bufferGoal,
              content,
              initSegmentUniqueId,
              segment: evt.segment,
              segmentData: evt.initializationData,
              segmentSink
            },
            globalCanceller.signal
          ).then((result) => {
            if (result !== null) {
              callbacks.addedSegment(result);
            }
          }).catch(onFatalBufferError);
        }
        checkStatus();
        return;
      } else {
        const { inbandEvents, predictedSegments, needsManifestRefresh } = evt;
        if (predictedSegments !== void 0) {
          representation.index.addPredictedSegments(predictedSegments, evt.segment);
        }
        if (needsManifestRefresh === true) {
          callbacks.needsManifestRefresh();
          if (globalCanceller.isUsed()) {
            return;
          }
        }
        if (inbandEvents !== void 0 && inbandEvents.length > 0) {
          callbacks.inbandEvent(inbandEvents);
          if (globalCanceller.isUsed()) {
            return;
          }
        }
        const initSegmentUniqueId = initSegmentState.uniqueId;
        pushMediaSegment(
          {
            playbackObserver,
            bufferGoal,
            content,
            initSegmentUniqueId,
            parsedSegment: evt,
            segment: evt.segment,
            segmentSink
          },
          globalCanceller.signal
        ).then((result) => {
          if (result !== null) {
            callbacks.addedSegment(result);
          }
        }).catch(onFatalBufferError);
      }
    }
    function onFatalBufferError(err) {
      if (globalCanceller.isUsed() && err instanceof CancellationError) {
        return;
      }
      globalCanceller.cancel();
      callbacks.error(err);
    }
  }

  // src/core/stream/representation/index.ts
  var representation_default2 = RepresentationStream;

  // src/core/stream/adaptation/get_representations_switch_strategy.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function getRepresentationsSwitchingStrategy(period, adaptation, settings, segmentSink, playbackObserver) {
    var _a, _b, _c, _d;
    if (settings.switchingMode === "lazy") {
      return { type: "continue", value: void 0 };
    }
    const inventory = segmentSink.getLastKnownInventory();
    const unwantedRange = [];
    for (const elt of inventory) {
      if (elt.infos.period.id === period.id && (elt.infos.adaptation.id !== adaptation.id || !arrayIncludes(settings.representationIds, elt.infos.representation.id))) {
        insertInto(unwantedRange, {
          start: (_a = elt.bufferedStart) != null ? _a : elt.start,
          end: (_b = elt.bufferedEnd) != null ? _b : elt.end
        });
      }
    }
    const pendingOperations = segmentSink.getPendingOperations();
    for (const operation of pendingOperations) {
      if (operation.type === 0 /* Push */) {
        const info = operation.value.inventoryInfos;
        if (info.period.id === period.id && (info.adaptation.id !== adaptation.id || !arrayIncludes(settings.representationIds, info.representation.id))) {
          const start = info.segment.time;
          const end = start + info.segment.duration;
          insertInto(unwantedRange, { start, end });
        }
      }
    }
    if (unwantedRange.length === 0) {
      return { type: "continue", value: void 0 };
    }
    if (settings.switchingMode === "reload") {
      const readyState = playbackObserver.getReadyState();
      if (readyState === void 0 || readyState > 1) {
        return { type: "needs-reload", value: void 0 };
      }
    }
    const shouldFlush = settings.switchingMode === "direct";
    const rangesToExclude = [];
    const lastSegmentBefore = getLastSegmentBeforePeriod(inventory, period);
    if (lastSegmentBefore !== null && (lastSegmentBefore.bufferedEnd === void 0 || period.start - lastSegmentBefore.bufferedEnd < 1)) {
      rangesToExclude.push({ start: 0, end: period.start + 1 });
    }
    if (!shouldFlush) {
      const { ADAP_REP_SWITCH_BUFFER_PADDINGS } = config_default.getCurrent();
      const bufferType = adaptation.type;
      const paddingBefore = (_c = ADAP_REP_SWITCH_BUFFER_PADDINGS[bufferType].before) != null ? _c : 0;
      const paddingAfter = (_d = ADAP_REP_SWITCH_BUFFER_PADDINGS[bufferType].after) != null ? _d : 0;
      let currentTime = playbackObserver.getCurrentTime();
      if (currentTime === void 0) {
        const lastObservation = playbackObserver.getReference().getValue();
        currentTime = lastObservation.position.getPolled();
      }
      rangesToExclude.push({
        start: currentTime - paddingBefore,
        end: currentTime + paddingAfter
      });
    }
    if (period.end !== void 0) {
      const firstSegmentAfter = getFirstSegmentAfterPeriod(inventory, period);
      if (firstSegmentAfter !== null && (firstSegmentAfter.bufferedStart === void 0 || // Close to Period's end
      firstSegmentAfter.bufferedStart - period.end < 1)) {
        rangesToExclude.push({ start: period.end - 1, end: Number.MAX_VALUE });
      }
    }
    const toRemove = excludeFromRanges(unwantedRange, rangesToExclude);
    if (toRemove.length === 0) {
      return { type: "continue", value: void 0 };
    }
    return shouldFlush ? { type: "flush-buffer", value: toRemove } : { type: "clean-buffer", value: toRemove };
  }

  // src/core/stream/adaptation/adaptation_stream.ts
  function AdaptationStream({
    playbackObserver,
    content,
    options,
    representationEstimator,
    segmentSink,
    segmentQueueCreator,
    wantedBufferAhead,
    maxVideoBufferSize
  }, callbacks, parentCancelSignal) {
    const { manifest, period, adaptation } = content;
    const adapStreamCanceller = new TaskCanceller();
    adapStreamCanceller.linkToSignal(parentCancelSignal);
    const bufferGoalRatioMap = /* @__PURE__ */ new Map();
    const currentRepresentation = new reference_default(
      null,
      adapStreamCanceller.signal
    );
    let previouslyEmittedBitrate;
    const initialRepIds = content.representations.getValue().representationIds;
    const initialRepresentations = content.adaptation.representations.filter(
      (r) => arrayIncludes(initialRepIds, r.id) && r.decipherable !== false && r.isSupported !== false
    );
    const representationsList = new reference_default(
      initialRepresentations,
      adapStreamCanceller.signal
    );
    const { estimates: estimateRef, callbacks: abrCallbacks } = representationEstimator(
      { manifest, period, adaptation },
      currentRepresentation,
      representationsList,
      playbackObserver,
      adapStreamCanceller.signal
    );
    const segmentQueue = segmentQueueCreator.createSegmentQueue(
      adaptation.type,
      /* eslint-disable @typescript-eslint/unbound-method */
      {
        onRequestBegin: abrCallbacks.requestBegin,
        onRequestEnd: abrCallbacks.requestEnd,
        onProgress: abrCallbacks.requestProgress,
        onMetrics: abrCallbacks.metrics
      }
    );
    const fastSwitchThreshold = new reference_default(0);
    estimateRef.onUpdate(
      ({ bitrate, knownStableBitrate }) => {
        if (options.enableFastSwitching) {
          fastSwitchThreshold.setValueIfChanged(knownStableBitrate);
        }
        if (bitrate === void 0 || bitrate === previouslyEmittedBitrate) {
          return;
        }
        previouslyEmittedBitrate = bitrate;
        log_default.debug(`Stream: new ${adaptation.type} bitrate estimate`, bitrate);
        callbacks.bitrateEstimateChange({ type: adaptation.type, bitrate });
      },
      { emitCurrentValue: true, clearSignal: adapStreamCanceller.signal }
    );
    let cancelCurrentStreams;
    content.representations.onUpdate(
      (val) => {
        if (cancelCurrentStreams !== void 0) {
          cancelCurrentStreams.cancel();
        }
        const newRepIds = content.representations.getValue().representationIds;
        const newRepresentations = content.adaptation.representations.filter(
          (r) => arrayIncludes(newRepIds, r.id)
        );
        representationsList.setValueIfChanged(newRepresentations);
        cancelCurrentStreams = new TaskCanceller();
        cancelCurrentStreams.linkToSignal(adapStreamCanceller.signal);
        onRepresentationsChoiceChange(val, cancelCurrentStreams.signal).catch((err) => {
          if ((cancelCurrentStreams == null ? void 0 : cancelCurrentStreams.isUsed()) === true && TaskCanceller.isCancellationError(err)) {
            return;
          }
          adapStreamCanceller.cancel();
          callbacks.error(err);
        });
      },
      { clearSignal: adapStreamCanceller.signal, emitCurrentValue: true }
    );
    return;
    async function onRepresentationsChoiceChange(choice, fnCancelSignal) {
      const switchStrat = getRepresentationsSwitchingStrategy(
        period,
        adaptation,
        choice,
        segmentSink,
        playbackObserver
      );
      switch (switchStrat.type) {
        case "continue":
          break;
        case "needs-reload":
          return queue_microtask_default(() => {
            playbackObserver.listen(
              () => {
                if (fnCancelSignal.isCancelled()) {
                  return;
                }
                const { DELTA_POSITION_AFTER_RELOAD } = config_default.getCurrent();
                const timeOffset = DELTA_POSITION_AFTER_RELOAD.bitrateSwitch;
                return callbacks.waitingMediaSourceReload({
                  bufferType: adaptation.type,
                  period,
                  timeOffset,
                  stayInPeriod: true
                });
              },
              { includeLastObservation: true, clearSignal: fnCancelSignal }
            );
          });
        case "flush-buffer":
        case "clean-buffer":
          for (const range of switchStrat.value) {
            await segmentSink.removeBuffer(range.start, range.end);
            if (fnCancelSignal.isCancelled()) {
              return;
            }
          }
          if (switchStrat.type === "flush-buffer") {
            callbacks.needsBufferFlush();
            if (fnCancelSignal.isCancelled()) {
              return;
            }
          }
          break;
        default:
          assertUnreachable(switchStrat);
      }
      recursivelyCreateRepresentationStreams(fnCancelSignal);
    }
    function recursivelyCreateRepresentationStreams(fnCancelSignal) {
      const repStreamTerminatingCanceller = new TaskCanceller();
      repStreamTerminatingCanceller.linkToSignal(fnCancelSignal);
      const { representation } = estimateRef.getValue();
      if (representation === null) {
        return;
      }
      const terminateCurrentStream = new reference_default(
        null,
        repStreamTerminatingCanceller.signal
      );
      estimateRef.onUpdate(
        (estimate) => {
          if (estimate.representation === null || estimate.representation.id === representation.id) {
            return;
          }
          if (estimate.urgent) {
            log_default.info("Stream: urgent Representation switch", adaptation.type);
            return terminateCurrentStream.setValue({ urgent: true });
          } else {
            log_default.info("Stream: slow Representation switch", adaptation.type);
            return terminateCurrentStream.setValue({ urgent: false });
          }
        },
        {
          clearSignal: repStreamTerminatingCanceller.signal,
          emitCurrentValue: true
        }
      );
      const repInfo = {
        type: adaptation.type,
        adaptation,
        period,
        representation
      };
      currentRepresentation.setValue(representation);
      if (adapStreamCanceller.isUsed()) {
        return;
      }
      callbacks.representationChange(repInfo);
      if (adapStreamCanceller.isUsed()) {
        return;
      }
      const representationStreamCallbacks = {
        streamStatusUpdate: callbacks.streamStatusUpdate,
        encryptionDataEncountered: callbacks.encryptionDataEncountered,
        manifestMightBeOufOfSync: callbacks.manifestMightBeOufOfSync,
        needsManifestRefresh: callbacks.needsManifestRefresh,
        inbandEvent: callbacks.inbandEvent,
        warning: callbacks.warning,
        error(err) {
          adapStreamCanceller.cancel();
          callbacks.error(err);
        },
        addedSegment(segmentInfo) {
          abrCallbacks.addedSegment(segmentInfo);
        },
        terminating() {
          if (repStreamTerminatingCanceller.isUsed()) {
            return;
          }
          repStreamTerminatingCanceller.cancel();
          return recursivelyCreateRepresentationStreams(fnCancelSignal);
        }
      };
      createRepresentationStream(
        representation,
        terminateCurrentStream,
        representationStreamCallbacks,
        fnCancelSignal
      );
    }
    function createRepresentationStream(representation, terminateCurrentStream, representationStreamCallbacks, fnCancelSignal) {
      const bufferGoalCanceller = new TaskCanceller();
      bufferGoalCanceller.linkToSignal(fnCancelSignal);
      const bufferGoal = createMappedReference(
        wantedBufferAhead,
        (prev) => {
          return prev * getBufferGoalRatio(representation);
        },
        bufferGoalCanceller.signal
      );
      const maxBufferSize = adaptation.type === "video" ? maxVideoBufferSize : new reference_default(Infinity);
      log_default.info(
        "Stream: changing representation",
        adaptation.type,
        representation.id,
        representation.bitrate
      );
      const updatedCallbacks = object_assign_default({}, representationStreamCallbacks, {
        error(err) {
          var _a;
          const formattedError = formatError(err, {
            defaultCode: "NONE",
            defaultReason: "Unknown `RepresentationStream` error"
          });
          if (formattedError.code !== "BUFFER_FULL_ERROR") {
            representationStreamCallbacks.error(err);
          } else {
            const wba = wantedBufferAhead.getValue();
            const lastBufferGoalRatio = (_a = bufferGoalRatioMap.get(representation.id)) != null ? _a : 1;
            const newBufferGoalRatio = lastBufferGoalRatio * 0.7;
            if (newBufferGoalRatio <= 0.05 || wba * newBufferGoalRatio <= 2) {
              throw formattedError;
            }
            bufferGoalRatioMap.set(representation.id, newBufferGoalRatio);
            cancellableSleep(4e3, adapStreamCanceller.signal).then(() => {
              return createRepresentationStream(
                representation,
                terminateCurrentStream,
                representationStreamCallbacks,
                fnCancelSignal
              );
            }).catch(noop_default);
          }
        },
        terminating() {
          bufferGoalCanceller.cancel();
          representationStreamCallbacks.terminating();
        }
      });
      representation_default2(
        {
          playbackObserver,
          content: { representation, adaptation, period, manifest },
          segmentSink,
          segmentQueue,
          terminate: terminateCurrentStream,
          options: {
            bufferGoal,
            maxBufferSize,
            drmSystemId: options.drmSystemId,
            fastSwitchThreshold
          }
        },
        updatedCallbacks,
        fnCancelSignal
      );
      manifest.addEventListener(
        "manifestUpdate",
        (updates) => {
          for (const element of updates.updatedPeriods) {
            if (element.period.id === period.id) {
              for (const updated of element.result.updatedAdaptations) {
                if (updated.adaptation === adaptation.id) {
                  for (const rep of updated.removedRepresentations) {
                    if (rep === representation.id) {
                      if (fnCancelSignal.isCancelled()) {
                        return;
                      }
                      return callbacks.waitingMediaSourceReload({
                        bufferType: adaptation.type,
                        period,
                        timeOffset: 0,
                        stayInPeriod: true
                      });
                    }
                  }
                }
              }
            } else if (element.period.start > period.start) {
              break;
            }
          }
        },
        fnCancelSignal
      );
    }
    function getBufferGoalRatio(representation) {
      const oldBufferGoalRatio = bufferGoalRatioMap.get(representation.id);
      const bufferGoalRatio = oldBufferGoalRatio !== void 0 ? oldBufferGoalRatio : 1;
      if (oldBufferGoalRatio === void 0) {
        bufferGoalRatioMap.set(representation.id, bufferGoalRatio);
      }
      return bufferGoalRatio;
    }
  }

  // src/core/stream/adaptation/index.ts
  var adaptation_default = AdaptationStream;

  // src/core/stream/period/utils/get_adaptation_switch_strategy.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function getAdaptationSwitchStrategy(segmentSink, period, adaptation, switchingMode, playbackObserver, options) {
    var _a, _b, _c, _d;
    if (segmentSink.codec !== void 0 && options.onCodecSwitch === "reload" && !hasCompatibleCodec(adaptation, segmentSink.codec)) {
      return { type: "needs-reload", value: void 0 };
    }
    const inventory = segmentSink.getLastKnownInventory();
    const unwantedRange = [];
    for (const elt of inventory) {
      if (elt.infos.period.id === period.id && elt.infos.adaptation.id !== adaptation.id) {
        insertInto(unwantedRange, {
          start: (_a = elt.bufferedStart) != null ? _a : elt.start,
          end: (_b = elt.bufferedEnd) != null ? _b : elt.end
        });
      }
    }
    const pendingOperations = segmentSink.getPendingOperations();
    for (const operation of pendingOperations) {
      if (operation.type === 0 /* Push */) {
        const info = operation.value.inventoryInfos;
        if (info.period.id === period.id && info.adaptation.id !== adaptation.id) {
          const start = info.segment.time;
          const end = start + info.segment.duration;
          insertInto(unwantedRange, { start, end });
        }
      }
    }
    if (unwantedRange.length === 0) {
      return { type: "continue", value: void 0 };
    }
    if (switchingMode === "reload") {
      const readyState = playbackObserver.getReadyState();
      if (readyState === void 0 || readyState > 1) {
        return { type: "needs-reload", value: void 0 };
      }
    }
    const shouldCleanAll = switchingMode === "direct";
    const rangesToExclude = [];
    const lastSegmentBefore = getLastSegmentBeforePeriod(inventory, period);
    if (lastSegmentBefore !== null && (lastSegmentBefore.bufferedEnd === void 0 || period.start - lastSegmentBefore.bufferedEnd < 1)) {
      rangesToExclude.push({ start: 0, end: period.start + 1 });
    }
    if (!shouldCleanAll) {
      const bufferType = adaptation.type;
      const { ADAP_REP_SWITCH_BUFFER_PADDINGS } = config_default.getCurrent();
      const paddingBefore = (_c = ADAP_REP_SWITCH_BUFFER_PADDINGS[bufferType].before) != null ? _c : 0;
      const paddingAfter = (_d = ADAP_REP_SWITCH_BUFFER_PADDINGS[bufferType].after) != null ? _d : 0;
      let currentTime = playbackObserver.getCurrentTime();
      if (currentTime === void 0) {
        const lastObservation = playbackObserver.getReference().getValue();
        currentTime = lastObservation.position.getPolled();
      }
      rangesToExclude.push({
        start: currentTime - paddingBefore,
        end: currentTime + paddingAfter
      });
    }
    if (period.end !== void 0) {
      const firstSegmentAfter = getFirstSegmentAfterPeriod(inventory, period);
      if (firstSegmentAfter !== null && (firstSegmentAfter.bufferedStart === void 0 || firstSegmentAfter.bufferedStart - period.end < 1)) {
        rangesToExclude.push({ start: period.end - 1, end: Number.MAX_VALUE });
      }
    }
    const toRemove = excludeFromRanges(unwantedRange, rangesToExclude);
    if (toRemove.length === 0) {
      return { type: "continue", value: void 0 };
    }
    return shouldCleanAll && adaptation.type !== "text" ? { type: "flush-buffer", value: toRemove } : { type: "clean-buffer", value: toRemove };
  }
  function hasCompatibleCodec(adaptation, segmentSinkCodec) {
    return adaptation.representations.some(
      (rep) => rep.isSupported === true && rep.decipherable !== false && are_codecs_compatible_default(rep.getMimeTypeString(), segmentSinkCodec)
    );
  }

  // src/core/stream/period/period_stream.ts
  function PeriodStream({
    bufferType,
    content,
    garbageCollectors,
    playbackObserver,
    representationEstimator,
    segmentQueueCreator,
    segmentSinksStore,
    options,
    wantedBufferAhead,
    maxVideoBufferSize
  }, callbacks, parentCancelSignal) {
    const { manifest, period } = content;
    const adaptationRef = new reference_default(
      void 0,
      parentCancelSignal
    );
    callbacks.periodStreamReady({
      type: bufferType,
      manifest,
      period,
      adaptationRef
    });
    if (parentCancelSignal.isCancelled()) {
      return;
    }
    let currentStreamCanceller;
    let isFirstAdaptationSwitch = true;
    adaptationRef.onUpdate(
      (choice) => {
        (async () => {
          var _a;
          if (choice === void 0) {
            return;
          }
          const streamCanceller = new TaskCanceller();
          streamCanceller.linkToSignal(parentCancelSignal);
          currentStreamCanceller == null ? void 0 : currentStreamCanceller.cancel();
          currentStreamCanceller = streamCanceller;
          if (choice === null) {
            log_default.info(`Stream: Set no ${bufferType} Adaptation. P:`, period.start);
            const segmentSinkStatus = segmentSinksStore.getStatus(bufferType);
            if (segmentSinkStatus.type === "initialized") {
              log_default.info(`Stream: Clearing previous ${bufferType} SegmentSink`);
              if (segment_sinks_default.isNative(bufferType)) {
                return askForMediaSourceReload(0, true, streamCanceller.signal);
              } else {
                const periodEnd = (_a = period.end) != null ? _a : Infinity;
                if (period.start > periodEnd) {
                  log_default.warn("Stream: Can't free buffer: period's start is after its end");
                } else {
                  await segmentSinkStatus.value.removeBuffer(period.start, periodEnd);
                  if (streamCanceller.isUsed()) {
                    return;
                  }
                }
              }
            } else if (segmentSinkStatus.type === "uninitialized") {
              segmentSinksStore.disableSegmentSink(bufferType);
              if (streamCanceller.isUsed()) {
                return;
              }
            }
            callbacks.adaptationChange({
              type: bufferType,
              adaptation: null,
              period
            });
            if (streamCanceller.isUsed()) {
              return;
            }
            return createEmptyAdaptationStream(
              playbackObserver,
              wantedBufferAhead,
              bufferType,
              { period },
              callbacks,
              streamCanceller.signal
            );
          }
          const adaptations = period.adaptations[bufferType];
          const adaptation = arrayFind(
            adaptations != null ? adaptations : [],
            (a) => a.id === choice.adaptationId
          );
          if (adaptation === void 0) {
            currentStreamCanceller.cancel();
            log_default.warn("Stream: Unfound chosen Adaptation choice", choice.adaptationId);
            return;
          }
          const { DELTA_POSITION_AFTER_RELOAD } = config_default.getCurrent();
          let relativePosHasBeenDefaulted = false;
          let relativePosAfterSwitch;
          if (isFirstAdaptationSwitch) {
            relativePosAfterSwitch = 0;
          } else if (choice.relativeResumingPosition !== void 0) {
            relativePosAfterSwitch = choice.relativeResumingPosition;
          } else {
            relativePosHasBeenDefaulted = true;
            switch (bufferType) {
              case "audio":
                relativePosAfterSwitch = DELTA_POSITION_AFTER_RELOAD.trackSwitch.audio;
                break;
              case "video":
                relativePosAfterSwitch = DELTA_POSITION_AFTER_RELOAD.trackSwitch.video;
                break;
              default:
                relativePosAfterSwitch = DELTA_POSITION_AFTER_RELOAD.trackSwitch.other;
                break;
            }
          }
          isFirstAdaptationSwitch = false;
          if (segment_sinks_default.isNative(bufferType) && segmentSinksStore.getStatus(bufferType).type === "disabled") {
            return askForMediaSourceReload(
              relativePosAfterSwitch,
              true,
              streamCanceller.signal
            );
          }
          manifest.addEventListener(
            "manifestUpdate",
            (updates) => {
              for (const element of updates.updatedPeriods) {
                if (element.period.id === period.id) {
                  for (const adap of element.result.removedAdaptations) {
                    if (adap.id === adaptation.id) {
                      return askForMediaSourceReload(
                        relativePosAfterSwitch,
                        true,
                        streamCanceller.signal
                      );
                    }
                  }
                } else if (element.period.start > period.start) {
                  break;
                }
              }
            },
            currentStreamCanceller.signal
          );
          const { representations } = choice;
          log_default.info(
            `Stream: Updating ${bufferType} adaptation`,
            `A: ${adaptation.id}`,
            `P: ${period.start}`
          );
          callbacks.adaptationChange({ type: bufferType, adaptation, period });
          if (streamCanceller.isUsed()) {
            return;
          }
          const segmentSink = createOrReuseSegmentSink(
            segmentSinksStore,
            bufferType,
            adaptation
          );
          const strategy = getAdaptationSwitchStrategy(
            segmentSink,
            period,
            adaptation,
            choice.switchingMode,
            playbackObserver,
            options
          );
          if (strategy.type === "needs-reload") {
            return askForMediaSourceReload(
              relativePosAfterSwitch,
              true,
              streamCanceller.signal
            );
          }
          await segmentSinksStore.waitForUsableBuffers(streamCanceller.signal);
          if (streamCanceller.isUsed()) {
            return;
          }
          if (strategy.type === "flush-buffer" || strategy.type === "clean-buffer") {
            for (const { start, end } of strategy.value) {
              await segmentSink.removeBuffer(start, end);
              if (streamCanceller.isUsed()) {
                return;
              }
            }
            if (strategy.type === "flush-buffer") {
              callbacks.needsBufferFlush({
                relativeResumingPosition: relativePosAfterSwitch,
                relativePosHasBeenDefaulted
              });
              if (streamCanceller.isUsed()) {
                return;
              }
            }
          }
          garbageCollectors.get(segmentSink)(streamCanceller.signal);
          createAdaptationStream(
            adaptation,
            representations,
            segmentSink,
            streamCanceller.signal
          );
        })().catch((err) => {
          if (err instanceof CancellationError) {
            return;
          }
          currentStreamCanceller == null ? void 0 : currentStreamCanceller.cancel();
          callbacks.error(err);
        });
      },
      { clearSignal: parentCancelSignal, emitCurrentValue: true }
    );
    function createAdaptationStream(adaptation, representations, segmentSink, cancelSignal) {
      const adaptationPlaybackObserver = createAdaptationStreamPlaybackObserver(
        playbackObserver,
        adaptation.type
      );
      adaptation_default(
        {
          content: { manifest, period, adaptation, representations },
          options,
          playbackObserver: adaptationPlaybackObserver,
          representationEstimator,
          segmentSink,
          segmentQueueCreator,
          wantedBufferAhead,
          maxVideoBufferSize
        },
        __spreadProps(__spreadValues({}, callbacks), { error: onAdaptationStreamError }),
        cancelSignal
      );
      function onAdaptationStreamError(error) {
        if (!segment_sinks_default.isNative(bufferType)) {
          log_default.error(
            `Stream: ${bufferType} Stream crashed. Aborting it.`,
            error instanceof Error ? error : ""
          );
          segmentSinksStore.disposeSegmentSink(bufferType);
          const formattedError = formatError(error, {
            defaultCode: "NONE",
            defaultReason: "Unknown `AdaptationStream` error"
          });
          callbacks.warning(formattedError);
          if (cancelSignal.isCancelled()) {
            return;
          }
          return createEmptyAdaptationStream(
            playbackObserver,
            wantedBufferAhead,
            bufferType,
            { period },
            callbacks,
            cancelSignal
          );
        }
        log_default.error(
          `Stream: ${bufferType} Stream crashed. Stopping playback.`,
          error instanceof Error ? error : ""
        );
        callbacks.error(error);
      }
    }
    function askForMediaSourceReload(timeOffset, stayInPeriod, cancelSignal) {
      queue_microtask_default(() => {
        playbackObserver.listen(
          () => {
            if (cancelSignal.isCancelled()) {
              return;
            }
            callbacks.waitingMediaSourceReload({
              bufferType,
              period,
              timeOffset,
              stayInPeriod
            });
          },
          { includeLastObservation: true, clearSignal: cancelSignal }
        );
      });
    }
  }
  function createOrReuseSegmentSink(segmentSinksStore, bufferType, adaptation) {
    const segmentSinkStatus = segmentSinksStore.getStatus(bufferType);
    if (segmentSinkStatus.type === "initialized") {
      log_default.info("Stream: Reusing a previous SegmentSink for the type", bufferType);
      return segmentSinkStatus.value;
    }
    const codec = getFirstDeclaredMimeType(adaptation);
    return segmentSinksStore.createSegmentSink(bufferType, codec);
  }
  function getFirstDeclaredMimeType(adaptation) {
    const representations = adaptation.representations.filter((r) => {
      return r.isSupported === true && r.decipherable !== false;
    });
    if (representations.length === 0) {
      const noRepErr = new MediaError(
        "NO_PLAYABLE_REPRESENTATION",
        "No Representation in the chosen " + adaptation.type + " Adaptation can be played",
        { tracks: [toTaggedTrack(adaptation)] }
      );
      throw noRepErr;
    }
    return representations[0].getMimeTypeString();
  }
  function createAdaptationStreamPlaybackObserver(initialPlaybackObserver, trackType) {
    return initialPlaybackObserver.deriveReadOnlyObserver(function transform(observationRef, cancellationSignal) {
      const newRef = new reference_default(
        constructAdaptationStreamPlaybackObservation(),
        cancellationSignal
      );
      observationRef.onUpdate(emitAdaptationStreamPlaybackObservation, {
        clearSignal: cancellationSignal,
        emitCurrentValue: false
      });
      return newRef;
      function constructAdaptationStreamPlaybackObservation() {
        const baseObservation = observationRef.getValue();
        const buffered = baseObservation.buffered[trackType];
        const bufferGap = buffered !== null ? getLeftSizeOfRange(buffered, baseObservation.position.getWanted()) : 0;
        return object_assign_default({}, baseObservation, { bufferGap, buffered });
      }
      function emitAdaptationStreamPlaybackObservation() {
        newRef.setValue(constructAdaptationStreamPlaybackObservation());
      }
    });
  }
  function createEmptyAdaptationStream(playbackObserver, wantedBufferAhead, bufferType, content, callbacks, cancelSignal) {
    const { period } = content;
    let hasFinishedLoading = false;
    wantedBufferAhead.onUpdate(sendStatus, {
      emitCurrentValue: false,
      clearSignal: cancelSignal
    });
    playbackObserver.listen(sendStatus, {
      includeLastObservation: false,
      clearSignal: cancelSignal
    });
    sendStatus();
    function sendStatus() {
      const observation = playbackObserver.getReference().getValue();
      const wba = wantedBufferAhead.getValue();
      const position = observation.position.getWanted();
      if (period.end !== void 0 && position + wba >= period.end) {
        log_default.debug('Stream: full "empty" AdaptationStream', bufferType);
        hasFinishedLoading = true;
      }
      callbacks.streamStatusUpdate({
        period,
        bufferType,
        imminentDiscontinuity: null,
        position,
        isEmptyStream: true,
        hasFinishedLoading,
        neededSegments: []
      });
    }
  }

  // src/core/stream/period/index.ts
  var period_default = PeriodStream;

  // src/core/stream/orchestrator/get_time_ranges_for_content.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function getTimeRangesForContent(segmentSink, contents) {
    if (contents.length === 0) {
      return [];
    }
    const accumulator = [];
    const inventory = segmentSink.getLastKnownInventory();
    for (const chunk of inventory) {
      const hasContent = contents.some((content) => {
        return chunk.infos.period.id === content.period.id && chunk.infos.adaptation.id === content.adaptation.id && chunk.infos.representation.id === content.representation.id;
      });
      if (hasContent) {
        const { bufferedStart, bufferedEnd } = chunk;
        if (bufferedStart === void 0 || bufferedEnd === void 0) {
          log_default.warn("SO: No buffered start or end found from a segment.");
          return [{ start: 0, end: Number.MAX_VALUE }];
        }
        const previousLastElement = accumulator[accumulator.length - 1];
        if (previousLastElement !== void 0 && previousLastElement.end === bufferedStart) {
          previousLastElement.end = bufferedEnd;
        } else {
          accumulator.push({ start: bufferedStart, end: bufferedEnd });
        }
      }
    }
    return accumulator;
  }

  // src/core/stream/orchestrator/stream_orchestrator.ts
  function StreamOrchestrator(content, playbackObserver, representationEstimator, segmentSinksStore, segmentQueueCreator, options, callbacks, orchestratorCancelSignal) {
    const { manifest, initialPeriod } = content;
    const { maxBufferAhead, maxBufferBehind, wantedBufferAhead, maxVideoBufferSize } = options;
    const {
      MINIMUM_MAX_BUFFER_AHEAD,
      MAXIMUM_MAX_BUFFER_AHEAD,
      MAXIMUM_MAX_BUFFER_BEHIND
    } = config_default.getCurrent();
    const garbageCollectors = new WeakMapMemory((segmentSink) => {
      var _a, _b;
      const { bufferType } = segmentSink;
      const defaultMaxBehind = (_a = MAXIMUM_MAX_BUFFER_BEHIND[bufferType]) != null ? _a : Infinity;
      const maxAheadHigherBound = (_b = MAXIMUM_MAX_BUFFER_AHEAD[bufferType]) != null ? _b : Infinity;
      return (gcCancelSignal) => {
        BufferGarbageCollector(
          {
            segmentSink,
            playbackObserver,
            maxBufferBehind: createMappedReference(
              maxBufferBehind,
              (val) => Math.min(val, defaultMaxBehind),
              gcCancelSignal
            ),
            maxBufferAhead: createMappedReference(
              maxBufferAhead,
              (val) => {
                var _a2;
                const lowerBound = Math.max(val, (_a2 = MINIMUM_MAX_BUFFER_AHEAD[bufferType]) != null ? _a2 : 0);
                return Math.min(lowerBound, maxAheadHigherBound);
              },
              gcCancelSignal
            )
          },
          gcCancelSignal
        );
      };
    });
    for (const bufferType of segmentSinksStore.getBufferTypes()) {
      manageEveryStreams(bufferType, initialPeriod);
    }
    function manageEveryStreams(bufferType, basePeriod) {
      const periodList = new SortedList((a, b) => a.start - b.start);
      let enableOutOfBoundsCheck = false;
      let currentCanceller = new TaskCanceller();
      currentCanceller.linkToSignal(orchestratorCancelSignal);
      playbackObserver.listen(
        ({ position }) => {
          var _a;
          const time = position.getWanted();
          if (!enableOutOfBoundsCheck || !isOutOfPeriodList(time)) {
            return;
          }
          log_default.info(
            "Stream: Destroying all PeriodStreams due to out of bounds situation",
            bufferType,
            time
          );
          enableOutOfBoundsCheck = false;
          while (periodList.length() > 0) {
            const period = periodList.get(periodList.length() - 1);
            periodList.removeElement(period);
            callbacks.periodStreamCleared({ type: bufferType, manifest, period });
          }
          currentCanceller.cancel();
          currentCanceller = new TaskCanceller();
          currentCanceller.linkToSignal(orchestratorCancelSignal);
          const nextPeriod = (_a = manifest.getPeriodForTime(time)) != null ? _a : manifest.getNextPeriod(time);
          if (nextPeriod === void 0) {
            log_default.warn("Stream: The wanted position is not found in the Manifest.");
            enableOutOfBoundsCheck = true;
            return;
          }
          launchConsecutiveStreamsForPeriod(nextPeriod);
        },
        { clearSignal: orchestratorCancelSignal, includeLastObservation: true }
      );
      manifest.addEventListener(
        "decipherabilityUpdate",
        (evt) => {
          if (orchestratorCancelSignal.isCancelled()) {
            return;
          }
          onDecipherabilityUpdates(evt).catch((err) => {
            if (orchestratorCancelSignal.isCancelled()) {
              return;
            }
            currentCanceller.cancel();
            callbacks.error(err);
          });
        },
        orchestratorCancelSignal
      );
      return launchConsecutiveStreamsForPeriod(basePeriod);
      function launchConsecutiveStreamsForPeriod(period) {
        const consecutivePeriodStreamCb = __spreadProps(__spreadValues({}, callbacks), {
          waitingMediaSourceReload(payload) {
            const firstPeriod = periodList.head();
            if (firstPeriod === void 0 || firstPeriod.id !== payload.period.id) {
              callbacks.lockedStream({
                bufferType: payload.bufferType,
                period: payload.period
              });
            } else {
              callbacks.needsMediaSourceReload({
                timeOffset: payload.timeOffset,
                minimumPosition: payload.stayInPeriod ? payload.period.start : void 0,
                maximumPosition: payload.stayInPeriod ? payload.period.end : void 0
              });
            }
          },
          periodStreamReady(payload) {
            enableOutOfBoundsCheck = true;
            periodList.add(payload.period);
            callbacks.periodStreamReady(payload);
          },
          periodStreamCleared(payload) {
            periodList.removeElement(payload.period);
            callbacks.periodStreamCleared(payload);
          },
          error(err) {
            currentCanceller.cancel();
            callbacks.error(err);
          }
        });
        manageConsecutivePeriodStreams(
          bufferType,
          period,
          consecutivePeriodStreamCb,
          currentCanceller.signal
        );
      }
      function isOutOfPeriodList(time) {
        const head = periodList.head();
        const last = periodList.last();
        if (head === void 0 || last === void 0) {
          return true;
        }
        return head.start > time || (isNullOrUndefined(last.end) ? Infinity : last.end) < time;
      }
      async function onDecipherabilityUpdates(updates) {
        const segmentSinkStatus = segmentSinksStore.getStatus(bufferType);
        const ofCurrentType = updates.filter(
          (update) => update.adaptation.type === bufferType
        );
        if (
          // No update concerns the current type of data
          ofCurrentType.length === 0 || segmentSinkStatus.type !== "initialized" || // The update only notifies of now-decipherable streams
          ofCurrentType.every((x) => x.representation.decipherable === true)
        ) {
          return;
        }
        const segmentSink = segmentSinkStatus.value;
        const resettedContent = ofCurrentType.filter(
          (update) => update.representation.decipherable === void 0
        );
        const undecipherableContent = ofCurrentType.filter(
          (update) => update.representation.decipherable === false
        );
        const undecipherableRanges = getTimeRangesForContent(
          segmentSink,
          undecipherableContent
        );
        const rangesToRemove = getTimeRangesForContent(segmentSink, resettedContent);
        enableOutOfBoundsCheck = false;
        log_default.info(
          "Stream: Destroying all PeriodStreams for decipherability matters",
          bufferType
        );
        while (periodList.length() > 0) {
          const period = periodList.get(periodList.length() - 1);
          periodList.removeElement(period);
          callbacks.periodStreamCleared({ type: bufferType, manifest, period });
        }
        currentCanceller.cancel();
        currentCanceller = new TaskCanceller();
        currentCanceller.linkToSignal(orchestratorCancelSignal);
        for (const { start, end } of [...undecipherableRanges, ...rangesToRemove]) {
          if (orchestratorCancelSignal.isCancelled()) {
            return;
          }
          if (start < end) {
            if (orchestratorCancelSignal.isCancelled()) {
              return;
            }
            await segmentSink.removeBuffer(start, end);
          }
        }
        queue_microtask_default(() => {
          if (orchestratorCancelSignal.isCancelled()) {
            return;
          }
          const observation = playbackObserver.getReference().getValue();
          if (needsFlushingAfterClean(observation, undecipherableRanges)) {
            callbacks.needsDecipherabilityFlush();
            if (orchestratorCancelSignal.isCancelled()) {
              return;
            }
          } else if (needsFlushingAfterClean(observation, rangesToRemove)) {
            callbacks.needsBufferFlush();
            if (orchestratorCancelSignal.isCancelled()) {
              return;
            }
          }
          const lastPosition = observation.position.getWanted();
          const newInitialPeriod = manifest.getPeriodForTime(lastPosition);
          if (newInitialPeriod === void 0) {
            callbacks.error(
              new MediaError(
                "MEDIA_TIME_NOT_FOUND",
                "The wanted position is not found in the Manifest."
              )
            );
            return;
          }
          launchConsecutiveStreamsForPeriod(newInitialPeriod);
        });
      }
    }
    function manageConsecutivePeriodStreams(bufferType, basePeriod, consecutivePeriodStreamCb, cancelSignal) {
      log_default.info("Stream: Creating new Stream for", bufferType, basePeriod.start);
      let nextStreamInfo = null;
      const currentStreamCanceller = new TaskCanceller();
      currentStreamCanceller.linkToSignal(cancelSignal);
      playbackObserver.listen(
        ({ position }, stopListeningObservations) => {
          if (basePeriod.end !== void 0 && position.getWanted() >= basePeriod.end) {
            const nextPeriod = manifest.getPeriodAfter(basePeriod);
            if (basePeriod.containsTime(position.getWanted(), nextPeriod)) {
              return;
            }
            log_default.info(
              "Stream: Destroying PeriodStream as the current playhead moved above it",
              bufferType,
              basePeriod.start,
              position.getWanted(),
              basePeriod.end
            );
            stopListeningObservations();
            consecutivePeriodStreamCb.periodStreamCleared({
              type: bufferType,
              manifest,
              period: basePeriod
            });
            currentStreamCanceller.cancel();
          }
        },
        { clearSignal: cancelSignal, includeLastObservation: true }
      );
      const periodStreamArgs = {
        bufferType,
        content: { manifest, period: basePeriod },
        garbageCollectors,
        maxVideoBufferSize,
        segmentQueueCreator,
        segmentSinksStore,
        options,
        playbackObserver,
        representationEstimator,
        wantedBufferAhead
      };
      const periodStreamCallbacks = __spreadProps(__spreadValues({}, consecutivePeriodStreamCb), {
        streamStatusUpdate(value) {
          if (value.hasFinishedLoading) {
            const nextPeriod = manifest.getPeriodAfter(basePeriod);
            if (nextPeriod !== null) {
              checkOrCreateNextPeriodStream(nextPeriod);
            }
          } else if (nextStreamInfo !== null) {
            log_default.info(
              "Stream: Destroying next PeriodStream due to current one being active",
              bufferType,
              nextStreamInfo.period.start
            );
            consecutivePeriodStreamCb.periodStreamCleared({
              type: bufferType,
              manifest,
              period: nextStreamInfo.period
            });
            nextStreamInfo.canceller.cancel();
            nextStreamInfo = null;
          }
          consecutivePeriodStreamCb.streamStatusUpdate(value);
        },
        error(err) {
          if (nextStreamInfo !== null) {
            nextStreamInfo.canceller.cancel();
            nextStreamInfo = null;
          }
          currentStreamCanceller.cancel();
          consecutivePeriodStreamCb.error(err);
        }
      });
      period_default(periodStreamArgs, periodStreamCallbacks, currentStreamCanceller.signal);
      handleUnexpectedManifestUpdates(currentStreamCanceller.signal);
      function checkOrCreateNextPeriodStream(nextPeriod) {
        if (nextStreamInfo !== null) {
          if (nextStreamInfo.period.id === nextPeriod.id) {
            return;
          }
          log_default.warn(
            "Stream: Creating next `PeriodStream` while one was already created.",
            bufferType,
            nextPeriod.id,
            nextStreamInfo.period.id
          );
          consecutivePeriodStreamCb.periodStreamCleared({
            type: bufferType,
            manifest,
            period: nextStreamInfo.period
          });
          nextStreamInfo.canceller.cancel();
        }
        const nextStreamCanceller = new TaskCanceller();
        nextStreamCanceller.linkToSignal(cancelSignal);
        nextStreamInfo = { canceller: nextStreamCanceller, period: nextPeriod };
        manageConsecutivePeriodStreams(
          bufferType,
          nextPeriod,
          consecutivePeriodStreamCb,
          nextStreamInfo.canceller.signal
        );
      }
      function handleUnexpectedManifestUpdates(innerCancelSignal) {
        manifest.addEventListener(
          "manifestUpdate",
          (updates) => {
            for (const period of updates.removedPeriods) {
              if (period.id === basePeriod.id) {
                if (manifest.periods.length > 0 && manifest.periods[0].start <= period.start) {
                  return queue_microtask_default(() => {
                    if (innerCancelSignal.isCancelled()) {
                      return;
                    }
                    return callbacks.needsMediaSourceReload({
                      timeOffset: 0,
                      minimumPosition: void 0,
                      maximumPosition: void 0
                    });
                  });
                }
              } else if (period.start > basePeriod.start) {
                break;
              }
            }
            if (updates.addedPeriods.length > 0) {
              if (nextStreamInfo !== null) {
                const newNextPeriod = manifest.getPeriodAfter(basePeriod);
                if (newNextPeriod === null || nextStreamInfo.period.id !== newNextPeriod.id) {
                  log_default.warn(
                    "Stream: Destroying next PeriodStream due to new one being added",
                    bufferType,
                    nextStreamInfo.period.start
                  );
                  consecutivePeriodStreamCb.periodStreamCleared({
                    type: bufferType,
                    manifest,
                    period: nextStreamInfo.period
                  });
                  nextStreamInfo.canceller.cancel();
                  nextStreamInfo = null;
                }
              }
            }
          },
          innerCancelSignal
        );
      }
    }
  }
  function needsFlushingAfterClean(observation, cleanedRanges) {
    if (cleanedRanges.length === 0) {
      return false;
    }
    const curPos = observation.position.getPolled();
    return observation.speed >= 0 ? cleanedRanges[cleanedRanges.length - 1].end >= curPos - 5 : cleanedRanges[0].start <= curPos + 5;
  }

  // src/core/stream/orchestrator/index.ts
  var orchestrator_default = StreamOrchestrator;

  // src/core/stream/index.ts
  var stream_default = orchestrator_default;

  // src/utils/sync_or_async.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var SyncOrAsync = {
    /**
     * Create the synchronous variant of an `ISyncOrAsyncValue`.
     * @param {*} val
     * @returns {Object}
     */
    createSync(val) {
      return {
        syncValue: val,
        getValueAsAsync() {
          return Promise.resolve(val);
        }
      };
    },
    /**
     * Create the asynchronous variant of an `ISyncOrAsyncValue`.
     * @param {Promise} val
     * @returns {Object}
     */
    createAsync(val) {
      let ret = null;
      val.then((resolved) => {
        ret = resolved;
      }, noop_default);
      return {
        syncValue: ret,
        getValueAsAsync() {
          return val;
        }
      };
    }
  };
  var sync_or_async_default = SyncOrAsync;

  // src/main_thread/init/types.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var ContentInitializer = class extends EventEmitter {
  };

  // src/main_thread/init/utils/create_core_playback_observer.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/core/main/common/get_buffered_data_per_media_buffer.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function getBufferedDataPerMediaBuffer(mediaSourceInterface, textDisplayer) {
    const buffered = {
      audio: null,
      video: null,
      text: null
    };
    if (textDisplayer !== null) {
      buffered.text = textDisplayer.getBufferedRanges();
    }
    if (mediaSourceInterface === null) {
      return buffered;
    }
    const audioBuffer = arrayFind(
      mediaSourceInterface.sourceBuffers,
      (s) => s.type === "audio" /* Audio */
    );
    const videoBuffer = arrayFind(
      mediaSourceInterface.sourceBuffers,
      (s) => s.type === "video" /* Video */
    );
    const audioBuffered = audioBuffer == null ? void 0 : audioBuffer.getBuffered();
    if (audioBuffered !== void 0) {
      buffered.audio = audioBuffered;
    }
    const videoBuffered = videoBuffer == null ? void 0 : videoBuffer.getBuffered();
    if (videoBuffered !== void 0) {
      buffered.video = videoBuffered;
    }
    return buffered;
  }

  // src/main_thread/init/utils/create_core_playback_observer.ts
  function createCorePlaybackObserver(srcPlaybackObserver, {
    autoPlay,
    initialPlayPerformed,
    manifest,
    mediaSource,
    speed,
    textDisplayer
  }, fnCancelSignal) {
    return srcPlaybackObserver.deriveReadOnlyObserver(function transform(observationRef, parentObserverCancelSignal) {
      const canceller = new TaskCanceller();
      canceller.linkToSignal(parentObserverCancelSignal);
      canceller.linkToSignal(fnCancelSignal);
      const newRef = new reference_default(
        constructCorePlaybackObservation(),
        canceller.signal
      );
      speed.onUpdate(emitCorePlaybackObservation, {
        clearSignal: canceller.signal,
        emitCurrentValue: false
      });
      observationRef.onUpdate(emitCorePlaybackObservation, {
        clearSignal: canceller.signal,
        emitCurrentValue: false
      });
      return newRef;
      function constructCorePlaybackObservation() {
        const observation = observationRef.getValue();
        const lastSpeed = speed.getValue();
        updateWantedPositionIfAfterManifest(observation, manifest);
        return {
          // TODO more exact according to the current Adaptation chosen?
          maximumPosition: getMaximumSafePosition(manifest),
          bufferGap: observation.bufferGap,
          position: observation.position,
          buffered: getBufferedDataPerMediaBuffer(mediaSource, textDisplayer),
          duration: observation.duration,
          rebuffering: observation.rebuffering,
          freezing: observation.freezing,
          paused: {
            last: observation.paused,
            pending: getPendingPaused(initialPlayPerformed, autoPlay)
          },
          readyState: observation.readyState,
          speed: lastSpeed
        };
      }
      function emitCorePlaybackObservation() {
        newRef.setValue(constructCorePlaybackObservation());
      }
    });
  }
  function updateWantedPositionIfAfterManifest(observation, manifest) {
    if (!manifest.isDynamic || manifest.isLastPeriodKnown) {
      const lastPeriod = manifest.periods[manifest.periods.length - 1];
      if (lastPeriod !== void 0 && lastPeriod.end !== void 0) {
        const wantedPosition = observation.position.getWanted();
        if (wantedPosition >= lastPeriod.start && wantedPosition >= lastPeriod.end - 1) {
          const buffered = observation.buffered;
          if (buffered.length === 0 || buffered.end(buffered.length - 1) < observation.duration - 1) {
            observation.position.forceWantedPosition(lastPeriod.end - 1);
          }
        }
      }
    }
  }
  function getPendingPaused(initialPlayPerformed, autoPlay) {
    return initialPlayPerformed.getValue() ? void 0 : !autoPlay;
  }

  // src/main_thread/init/utils/create_media_source.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/compat/clear_element_src.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function clearElementSrc(element) {
    const { textTracks } = element;
    if (!isNullOrUndefined(textTracks)) {
      for (let i = 0; i < textTracks.length; i++) {
        textTracks[i].mode = "disabled";
      }
      if (element.hasChildNodes()) {
        const { childNodes } = element;
        for (let j = childNodes.length - 1; j >= 0; j--) {
          if (childNodes[j].nodeName === "track") {
            try {
              element.removeChild(childNodes[j]);
            } catch (_err) {
              log_default.warn("Compat: Could not remove text track child from element.");
            }
          }
        }
      }
    }
    element.src = "";
    element.removeAttribute("src");
  }

  // src/mse/main_media_source_interface.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/compat/change_source_buffer_type.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function tryToChangeSourceBufferType(sourceBuffer, codec) {
    if (typeof sourceBuffer.changeType === "function") {
      try {
        sourceBuffer.changeType(codec);
      } catch (e) {
        log_default.warn(
          "Could not call 'changeType' on the given SourceBuffer:",
          e instanceof Error ? e : ""
        );
        return false;
      }
      return true;
    }
    return false;
  }

  // src/mse/utils/end_of_stream.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function getUpdatingSourceBuffers(sourceBuffers) {
    const updatingSourceBuffers = [];
    for (let i = 0; i < sourceBuffers.length; i++) {
      const SourceBuffer = sourceBuffers[i];
      if (SourceBuffer.updating) {
        updatingSourceBuffers.push(SourceBuffer);
      }
    }
    return updatingSourceBuffers;
  }
  function triggerEndOfStream(mediaSource, cancelSignal) {
    log_default.debug("Init: Trying to call endOfStream");
    if (mediaSource.readyState !== "open") {
      log_default.debug("Init: MediaSource not open, cancel endOfStream");
      return;
    }
    const { sourceBuffers } = mediaSource;
    const updatingSourceBuffers = getUpdatingSourceBuffers(sourceBuffers);
    if (updatingSourceBuffers.length === 0) {
      log_default.info("Init: Triggering end of stream");
      try {
        mediaSource.endOfStream();
      } catch (err) {
        log_default.error(
          "Unable to call endOfStream",
          err instanceof Error ? err : new Error("Unknown error")
        );
      }
      return;
    }
    log_default.debug("Init: Waiting SourceBuffers to be updated before calling endOfStream.");
    const innerCanceller = new TaskCanceller();
    innerCanceller.linkToSignal(cancelSignal);
    for (const sourceBuffer of updatingSourceBuffers) {
      onSourceBufferUpdate(
        sourceBuffer,
        () => {
          innerCanceller.cancel();
          triggerEndOfStream(mediaSource, cancelSignal);
        },
        innerCanceller.signal
      );
    }
    onRemoveSourceBuffers(
      sourceBuffers,
      () => {
        innerCanceller.cancel();
        triggerEndOfStream(mediaSource, cancelSignal);
      },
      innerCanceller.signal
    );
  }
  function maintainEndOfStream(mediaSource, cancelSignal) {
    let endOfStreamCanceller = new TaskCanceller();
    endOfStreamCanceller.linkToSignal(cancelSignal);
    onSourceOpen(
      mediaSource,
      () => {
        log_default.debug("Init: MediaSource re-opened while end-of-stream is active");
        endOfStreamCanceller.cancel();
        endOfStreamCanceller = new TaskCanceller();
        endOfStreamCanceller.linkToSignal(cancelSignal);
        triggerEndOfStream(mediaSource, endOfStreamCanceller.signal);
      },
      cancelSignal
    );
    triggerEndOfStream(mediaSource, endOfStreamCanceller.signal);
  }

  // src/mse/utils/media_source_duration_updater.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/compat/has_issues_with_high_media_source_duration.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function hasIssuesWithHighMediaSourceDuration() {
    return isPlayStation5;
  }

  // src/mse/utils/media_source_duration_updater.ts
  var YEAR_IN_SECONDS = 365 * 24 * 3600;
  var MediaSourceDurationUpdater = class {
    /**
     * Create a new `MediaSourceDurationUpdater`,
     * @param {MediaSource} mediaSource - The MediaSource on which the content is
     * played.
     */
    constructor(mediaSource) {
      this._mediaSource = mediaSource;
      this._currentMediaSourceDurationUpdateCanceller = null;
    }
    /**
     * Indicate to the `MediaSourceDurationUpdater` the currently known duration
     * of the content.
     *
     * The `MediaSourceDurationUpdater` will then use that value to determine
     * which `duration` attribute should be set on the `MediaSource` associated
     *
     * @param {number} newDuration
     * @param {boolean} isRealEndKnown - If set to `false`, the current content is
     * a dynamic content (it might evolve in the future) and the `newDuration`
     * communicated might be greater still. In effect the
     * `MediaSourceDurationUpdater` will actually set a much higher value to the
     * `MediaSource`'s duration to prevent being annoyed by the HTML-related
     * side-effects of having a too low duration (such as the impossibility to
     * seek over that value).
     */
    updateDuration(newDuration, isRealEndKnown) {
      if (this._currentMediaSourceDurationUpdateCanceller !== null) {
        this._currentMediaSourceDurationUpdateCanceller.cancel();
      }
      this._currentMediaSourceDurationUpdateCanceller = new TaskCanceller();
      const mediaSource = this._mediaSource;
      const currentSignal = this._currentMediaSourceDurationUpdateCanceller.signal;
      const isMediaSourceOpened = createMediaSourceOpenReference(
        mediaSource,
        currentSignal
      );
      let msOpenStatusCanceller = new TaskCanceller();
      msOpenStatusCanceller.linkToSignal(currentSignal);
      isMediaSourceOpened.onUpdate(onMediaSourceOpenedStatusChanged, {
        emitCurrentValue: true,
        clearSignal: currentSignal
      });
      function onMediaSourceOpenedStatusChanged() {
        msOpenStatusCanceller.cancel();
        if (!isMediaSourceOpened.getValue()) {
          return;
        }
        msOpenStatusCanceller = new TaskCanceller();
        msOpenStatusCanceller.linkToSignal(currentSignal);
        const areSourceBuffersUpdating = createSourceBuffersUpdatingReference(
          mediaSource.sourceBuffers,
          msOpenStatusCanceller.signal
        );
        let sourceBuffersUpdatingCanceller = new TaskCanceller();
        sourceBuffersUpdatingCanceller.linkToSignal(msOpenStatusCanceller.signal);
        return areSourceBuffersUpdating.onUpdate(
          (areUpdating) => {
            sourceBuffersUpdatingCanceller.cancel();
            sourceBuffersUpdatingCanceller = new TaskCanceller();
            sourceBuffersUpdatingCanceller.linkToSignal(msOpenStatusCanceller.signal);
            if (areUpdating) {
              return;
            }
            recursivelyForceDurationUpdate(
              mediaSource,
              newDuration,
              isRealEndKnown,
              sourceBuffersUpdatingCanceller.signal
            );
          },
          { clearSignal: msOpenStatusCanceller.signal, emitCurrentValue: true }
        );
      }
    }
    /**
     * Abort the last duration-setting operation and free its resources.
     */
    stopUpdating() {
      if (this._currentMediaSourceDurationUpdateCanceller !== null) {
        this._currentMediaSourceDurationUpdateCanceller.cancel();
        this._currentMediaSourceDurationUpdateCanceller = null;
      }
    }
  };
  function setMediaSourceDuration(mediaSource, duration, isRealEndKnown) {
    let newDuration = duration;
    if (!isRealEndKnown) {
      newDuration = hasIssuesWithHighMediaSourceDuration() ? Infinity : getMaximumLiveSeekablePosition(duration);
    }
    let maxBufferedEnd = 0;
    for (let i = 0; i < mediaSource.sourceBuffers.length; i++) {
      const sourceBuffer = mediaSource.sourceBuffers[i];
      const sbBufferedLen = sourceBuffer.buffered.length;
      if (sbBufferedLen > 0) {
        maxBufferedEnd = Math.max(sourceBuffer.buffered.end(sbBufferedLen - 1));
      }
    }
    if (newDuration === mediaSource.duration) {
      return "success" /* Success */;
    } else if (maxBufferedEnd > newDuration) {
      if (maxBufferedEnd < mediaSource.duration) {
        try {
          log_default.info("Init: Updating duration to what is currently buffered", maxBufferedEnd);
          mediaSource.duration = maxBufferedEnd;
        } catch (err) {
          log_default.warn(
            "Duration Updater: Can't update duration on the MediaSource.",
            err instanceof Error ? err : ""
          );
          return "failed" /* Failed */;
        }
      }
      return "partial" /* Partial */;
    } else {
      const oldDuration = mediaSource.duration;
      try {
        log_default.info("Init: Updating duration", newDuration);
        mediaSource.duration = newDuration;
        if (mediaSource.readyState === "open" && !isFinite(newDuration)) {
          const maxSeekable = getMaximumLiveSeekablePosition(duration);
          log_default.info("Init: calling `mediaSource.setLiveSeekableRange`", maxSeekable);
          mediaSource.setLiveSeekableRange(0, maxSeekable);
        }
      } catch (err) {
        log_default.warn(
          "Duration Updater: Can't update duration on the MediaSource.",
          err instanceof Error ? err : ""
        );
        return "failed" /* Failed */;
      }
      const deltaToExpected = Math.abs(mediaSource.duration - newDuration);
      if (deltaToExpected >= 0.1) {
        const deltaToBefore = Math.abs(mediaSource.duration - oldDuration);
        return deltaToExpected < deltaToBefore ? "partial" /* Partial */ : "failed" /* Failed */;
      }
      return "success" /* Success */;
    }
  }
  function createSourceBuffersUpdatingReference(sourceBuffers, cancelSignal) {
    if (sourceBuffers.length === 0) {
      const notOpenedRef = new reference_default(false);
      notOpenedRef.finish();
      return notOpenedRef;
    }
    const areUpdatingRef = new reference_default(false, cancelSignal);
    reCheck();
    for (let i = 0; i < sourceBuffers.length; i++) {
      const sourceBuffer = sourceBuffers[i];
      sourceBuffer.addEventListener("updatestart", reCheck);
      sourceBuffer.addEventListener("update", reCheck);
      cancelSignal.register(() => {
        sourceBuffer.removeEventListener("updatestart", reCheck);
        sourceBuffer.removeEventListener("update", reCheck);
      });
    }
    return areUpdatingRef;
    function reCheck() {
      for (let i = 0; i < sourceBuffers.length; i++) {
        const sourceBuffer = sourceBuffers[i];
        if (sourceBuffer.updating) {
          areUpdatingRef.setValueIfChanged(true);
          return;
        }
      }
      areUpdatingRef.setValueIfChanged(false);
    }
  }
  function createMediaSourceOpenReference(mediaSource, cancelSignal) {
    const isMediaSourceOpen = new reference_default(
      mediaSource.readyState === "open",
      cancelSignal
    );
    onSourceOpen(
      mediaSource,
      () => {
        log_default.debug("Init: Reacting to MediaSource open in duration updater");
        isMediaSourceOpen.setValueIfChanged(true);
      },
      cancelSignal
    );
    onSourceEnded(
      mediaSource,
      () => {
        log_default.debug("Init: Reacting to MediaSource ended in duration updater");
        isMediaSourceOpen.setValueIfChanged(false);
      },
      cancelSignal
    );
    onSourceClose(
      mediaSource,
      () => {
        log_default.debug("Init: Reacting to MediaSource close in duration updater");
        isMediaSourceOpen.setValueIfChanged(false);
      },
      cancelSignal
    );
    return isMediaSourceOpen;
  }
  function recursivelyForceDurationUpdate(mediaSource, duration, isRealEndKnown, cancelSignal) {
    const res = setMediaSourceDuration(mediaSource, duration, isRealEndKnown);
    if (res === "success" /* Success */) {
      return;
    }
    const timeoutId = setTimeout(() => {
      unregisterClear();
      recursivelyForceDurationUpdate(mediaSource, duration, isRealEndKnown, cancelSignal);
    }, 2e3);
    const unregisterClear = cancelSignal.register(() => {
      clearTimeout(timeoutId);
    });
  }
  function getMaximumLiveSeekablePosition(contentLastPosition) {
    return Math.max(Math.pow(2, 32), contentLastPosition + YEAR_IN_SECONDS);
  }

  // src/mse/main_media_source_interface.ts
  var MainMediaSourceInterface = class extends EventEmitter {
    /**
     * Creates a new `MainMediaSourceInterface` alongside its `MediaSource` MSE
     * object.
     *
     * You can then obtain a link to that `MediaSource`, for example to link it
     * to an `HTMLMediaElement`, through the `handle` property.
     */
    constructor(id) {
      super();
      this.id = id;
      this.sourceBuffers = [];
      this._canceller = new TaskCanceller();
      if (isNullOrUndefined(MediaSource_)) {
        throw new MediaError(
          "MEDIA_SOURCE_NOT_SUPPORTED",
          "No MediaSource Object was found in the current browser."
        );
      }
      log_default.info("Init: Creating MediaSource");
      const mediaSource = new MediaSource_();
      const handle = mediaSource.handle;
      this.handle = isNullOrUndefined(handle) ? (
        // eslint-disable-next-line @typescript-eslint/no-restricted-types
        { type: "media-source", value: mediaSource }
      ) : { type: "handle", value: handle };
      this._mediaSource = mediaSource;
      this.readyState = mediaSource.readyState;
      this._durationUpdater = new MediaSourceDurationUpdater(mediaSource);
      this._endOfStreamCanceller = null;
      onSourceOpen(
        mediaSource,
        () => {
          this.readyState = mediaSource.readyState;
          this.trigger("mediaSourceOpen", null);
        },
        this._canceller.signal
      );
      onSourceEnded(
        mediaSource,
        () => {
          this.readyState = mediaSource.readyState;
          this.trigger("mediaSourceEnded", null);
        },
        this._canceller.signal
      );
      onSourceClose(
        mediaSource,
        () => {
          this.readyState = mediaSource.readyState;
          this.trigger("mediaSourceClose", null);
        },
        this._canceller.signal
      );
    }
    /** @see IMediaSourceInterface */
    addSourceBuffer(sbType, codec) {
      const sourceBuffer = this._mediaSource.addSourceBuffer(codec);
      const sb = new MainSourceBufferInterface(sbType, codec, sourceBuffer);
      this.sourceBuffers.push(sb);
      return sb;
    }
    /** @see IMediaSourceInterface */
    setDuration(newDuration, isRealEndKnown) {
      this._durationUpdater.updateDuration(newDuration, isRealEndKnown);
    }
    /** @see IMediaSourceInterface */
    interruptDurationSetting() {
      this._durationUpdater.stopUpdating();
    }
    /** @see IMediaSourceInterface */
    maintainEndOfStream() {
      if (this._endOfStreamCanceller === null) {
        this._endOfStreamCanceller = new TaskCanceller();
        this._endOfStreamCanceller.linkToSignal(this._canceller.signal);
        log_default.debug("Init: end-of-stream order received.");
        maintainEndOfStream(this._mediaSource, this._endOfStreamCanceller.signal);
      }
    }
    /** @see IMediaSourceInterface */
    stopEndOfStream() {
      if (this._endOfStreamCanceller !== null) {
        log_default.debug("Init: resume-stream order received.");
        this._endOfStreamCanceller.cancel();
        this._endOfStreamCanceller = null;
      }
    }
    /** @see IMediaSourceInterface */
    dispose() {
      this.sourceBuffers.forEach((s) => s.dispose());
      this._canceller.cancel();
      resetMediaSource(this._mediaSource);
    }
  };
  var MainSourceBufferInterface = class {
    /**
     * Creates a new `SourceBufferInterface` linked to the given `SourceBuffer`
     * instance.
     * @param {string} sbType
     * @param {string} codec
     * @param {SourceBuffer} sourceBuffer
     */
    constructor(sbType, codec, sourceBuffer) {
      this.type = sbType;
      this.codec = codec;
      this._canceller = new TaskCanceller();
      this._sourceBuffer = sourceBuffer;
      this._operationQueue = [];
      this._currentOperations = [];
      const onError = (evt) => {
        let error;
        if (evt instanceof Error) {
          error = evt;
        } else if (evt.error instanceof Error) {
          error = evt.error;
        } else {
          error = new Error("Unknown SourceBuffer Error");
        }
        const currentOps = this._currentOperations;
        this._currentOperations = [];
        if (currentOps.length === 0) {
          log_default.error("SBI: error for an unknown operation", error);
        } else {
          const rejected = new SourceBufferError(
            error.name,
            error.message,
            error.name === "QuotaExceededError"
          );
          for (const op of currentOps) {
            op.reject(rejected);
          }
        }
      };
      const onUpdateEnd = () => {
        const currentOps = this._currentOperations;
        this._currentOperations = [];
        try {
          for (const op of currentOps) {
            op.resolve(convertToRanges(this._sourceBuffer.buffered));
          }
        } catch (err) {
          for (const op of currentOps) {
            if (err instanceof Error && err.name === "InvalidStateError") {
              op.resolve([]);
            } else {
              op.reject(err);
            }
          }
        }
        this._performNextOperation();
      };
      sourceBuffer.addEventListener("updateend", onUpdateEnd);
      sourceBuffer.addEventListener("error", onError);
      this._canceller.signal.register(() => {
        sourceBuffer.removeEventListener("updateend", onUpdateEnd);
        sourceBuffer.removeEventListener("error", onError);
      });
    }
    /** @see ISourceBufferInterface */
    appendBuffer(...args) {
      log_default.debug("SBI: receiving order to push data to the SourceBuffer", this.type);
      return this._addToQueue({
        operationName: 0 /* Push */,
        params: args
      });
    }
    /** @see ISourceBufferInterface */
    remove(start, end) {
      log_default.debug(
        "SBI: receiving order to remove data from the SourceBuffer",
        this.type,
        start,
        end
      );
      return this._addToQueue({
        operationName: 1 /* Remove */,
        params: [start, end]
      });
    }
    /** @see ISourceBufferInterface */
    getBuffered() {
      try {
        return convertToRanges(this._sourceBuffer.buffered);
      } catch (err) {
        log_default.error(
          "Failed to get buffered time range of SourceBuffer",
          this.type,
          err instanceof Error ? err : null
        );
        return [];
      }
    }
    /** @see ISourceBufferInterface */
    abort() {
      try {
        this._sourceBuffer.abort();
      } catch (err) {
        log_default.debug("Init: Failed to abort SourceBuffer:", err instanceof Error ? err : null);
      }
      this._emptyCurrentQueue();
    }
    /** @see ISourceBufferInterface */
    dispose() {
      try {
        this._sourceBuffer.abort();
      } catch (_) {
      }
      this._emptyCurrentQueue();
    }
    _emptyCurrentQueue() {
      const error = new CancellationError();
      if (this._currentOperations.length > 0) {
        this._currentOperations.forEach((op) => {
          op.reject(error);
        });
        this._currentOperations = [];
      }
      if (this._operationQueue.length > 0) {
        this._operationQueue.forEach((op) => {
          op.reject(error);
        });
        this._operationQueue = [];
      }
    }
    _addToQueue(operation) {
      return new Promise((resolve, reject) => {
        const shouldRestartQueue = this._operationQueue.length === 0 && this._currentOperations.length === 0;
        const queueItem = object_assign_default(
          { resolve, reject },
          operation
        );
        this._operationQueue.push(queueItem);
        if (shouldRestartQueue) {
          this._performNextOperation();
        }
      });
    }
    _performNextOperation() {
      var _a, _b, _c, _d, _e;
      if (this._currentOperations.length !== 0 || this._sourceBuffer.updating) {
        return;
      }
      const nextElem = this._operationQueue.shift();
      if (nextElem === void 0) {
        return;
      } else if (nextElem.operationName === 0 /* Push */) {
        this._currentOperations = [
          {
            operationName: 0 /* Push */,
            resolve: nextElem.resolve,
            reject: nextElem.reject
          }
        ];
        const ogData = nextElem.params[0];
        const params = nextElem.params[1];
        let segmentData = ogData;
        if (this._operationQueue.length > 0 && this._operationQueue[0].operationName === 0 /* Push */) {
          let prevU8;
          if (ogData instanceof ArrayBuffer) {
            prevU8 = new Uint8Array(ogData);
          } else if (ogData instanceof Uint8Array) {
            prevU8 = ogData;
          } else {
            prevU8 = new Uint8Array(ogData.buffer);
          }
          const toConcat = [prevU8];
          while (((_a = this._operationQueue[0]) == null ? void 0 : _a.operationName) === 0 /* Push */) {
            const followingElem = this._operationQueue[0];
            const cAw = (_b = params.appendWindow) != null ? _b : [void 0, void 0];
            const fAw = (_c = followingElem.params[1].appendWindow) != null ? _c : [void 0, void 0];
            const cTo = (_d = params.timestampOffset) != null ? _d : 0;
            const fTo = (_e = followingElem.params[1].timestampOffset) != null ? _e : 0;
            if (cAw[0] === fAw[0] && cAw[1] === fAw[1] && params.codec === followingElem.params[1].codec && cTo === fTo) {
              const newData = followingElem.params[0];
              let newU8;
              if (newData instanceof ArrayBuffer) {
                newU8 = new Uint8Array(newData);
              } else if (newData instanceof Uint8Array) {
                newU8 = newData;
              } else {
                newU8 = new Uint8Array(newData.buffer);
              }
              toConcat.push(newU8);
              this._operationQueue.splice(0, 1);
              this._currentOperations.push({
                operationName: 0 /* Push */,
                resolve: followingElem.resolve,
                reject: followingElem.reject
              });
            } else {
              break;
            }
          }
          if (toConcat.length > 1) {
            log_default.info(
              `MMSI: Merging ${toConcat.length} segments together for perf`,
              this.type
            );
            segmentData = concat(...toConcat);
          }
        }
        try {
          this._appendBufferNow(segmentData, params);
        } catch (err) {
          const error = err instanceof Error ? new SourceBufferError(
            err.name,
            err.message,
            err.name === "QuotaExceededError"
          ) : new SourceBufferError(
            "Error",
            "Unknown SourceBuffer Error during appendBuffer",
            false
          );
          this._currentOperations.forEach((op) => {
            op.reject(error);
          });
          this._currentOperations = [];
        }
      } else {
        this._currentOperations = [nextElem];
        const [start, end] = nextElem.params;
        log_default.debug("SBI: removing data from SourceBuffer", this.type, start, end);
        try {
          this._sourceBuffer.remove(start, end);
        } catch (err) {
          const error = err instanceof Error ? new SourceBufferError(err.name, err.message, false) : new SourceBufferError(
            "Error",
            "Unknown SourceBuffer Error during remove",
            false
          );
          nextElem.reject(error);
          this._currentOperations = [];
        }
      }
    }
    _appendBufferNow(data2, params) {
      const sourceBuffer = this._sourceBuffer;
      const { codec, timestampOffset, appendWindow = [] } = params;
      if (codec !== void 0 && codec !== this.codec) {
        log_default.debug("SBI: updating codec", codec);
        const hasUpdatedSourceBufferType = tryToChangeSourceBufferType(sourceBuffer, codec);
        if (hasUpdatedSourceBufferType) {
          this.codec = codec;
        } else {
          log_default.debug("SBI: could not update codec", codec, this.codec);
        }
      }
      if (timestampOffset !== void 0 && sourceBuffer.timestampOffset !== timestampOffset) {
        const newTimestampOffset = timestampOffset;
        log_default.debug(
          "SBI: updating timestampOffset",
          codec,
          sourceBuffer.timestampOffset,
          newTimestampOffset
        );
        sourceBuffer.timestampOffset = newTimestampOffset;
      }
      if (appendWindow[0] === void 0) {
        if (sourceBuffer.appendWindowStart > 0) {
          log_default.debug("SBI: re-setting `appendWindowStart` to `0`");
          sourceBuffer.appendWindowStart = 0;
        }
      } else if (appendWindow[0] !== sourceBuffer.appendWindowStart) {
        if (appendWindow[0] >= sourceBuffer.appendWindowEnd) {
          const newTmpEnd = appendWindow[0] + 1;
          log_default.debug("SBI: pre-updating `appendWindowEnd`", newTmpEnd);
          sourceBuffer.appendWindowEnd = newTmpEnd;
        }
        log_default.debug("SBI: setting `appendWindowStart`", appendWindow[0]);
        sourceBuffer.appendWindowStart = appendWindow[0];
      }
      if (appendWindow[1] === void 0) {
        if (sourceBuffer.appendWindowEnd !== Infinity) {
          log_default.debug("SBI: re-setting `appendWindowEnd` to `Infinity`");
          sourceBuffer.appendWindowEnd = Infinity;
        }
      } else if (appendWindow[1] !== sourceBuffer.appendWindowEnd) {
        log_default.debug("SBI: setting `appendWindowEnd`", appendWindow[1]);
        sourceBuffer.appendWindowEnd = appendWindow[1];
      }
      log_default.debug("SBI: pushing segment", this.type);
      sourceBuffer.appendBuffer(data2);
    }
  };
  function resetMediaSource(mediaSource) {
    if (mediaSource.readyState !== "closed") {
      const { readyState, sourceBuffers } = mediaSource;
      for (let i = sourceBuffers.length - 1; i >= 0; i--) {
        const sourceBuffer = sourceBuffers[i];
        try {
          if (readyState === "open") {
            log_default.info("Init: Aborting SourceBuffer before removing");
            try {
              sourceBuffer.abort();
            } catch (_) {
            }
          }
          log_default.info("Init: Removing SourceBuffer from mediaSource");
          mediaSource.removeSourceBuffer(sourceBuffer);
        } catch (_) {
        }
      }
      if (sourceBuffers.length > 0) {
        log_default.info("Init: Not all SourceBuffers could have been removed.");
      }
    }
  }

  // src/main_thread/init/utils/create_media_source.ts
  var generateMediaSourceId = idGenerator();
  function resetMediaElement(mediaElement, mediaSourceURL) {
    if (mediaSourceURL !== null && mediaElement.src === mediaSourceURL) {
      log_default.info("Init: Clearing HTMLMediaElement's src");
      clearElementSrc(mediaElement);
    }
    if (mediaSourceURL !== null) {
      try {
        log_default.debug("Init: Revoking previous URL");
        URL.revokeObjectURL(mediaSourceURL);
      } catch (e) {
        log_default.warn(
          "Init: Error while revoking the media source URL",
          e instanceof Error ? e : ""
        );
      }
    }
  }
  function createMediaSource(mediaElement, unlinkSignal) {
    const oldSrc = isNonEmptyString(mediaElement.src) ? mediaElement.src : null;
    resetMediaElement(mediaElement, oldSrc);
    const mediaSource = new MainMediaSourceInterface(generateMediaSourceId());
    unlinkSignal.register(() => {
      mediaSource.dispose();
    });
    return mediaSource;
  }
  function openMediaSource(mediaElement, unlinkSignal) {
    return createCancellablePromise(unlinkSignal, (resolve) => {
      const mediaSource = createMediaSource(mediaElement, unlinkSignal);
      mediaSource.addEventListener(
        "mediaSourceOpen",
        () => {
          log_default.info("Init: MediaSource opened");
          resolve(mediaSource);
        },
        unlinkSignal
      );
      log_default.info("MTCI: Attaching MediaSource URL to the media element");
      if (mediaSource.handle.type === "handle") {
        mediaElement.srcObject = mediaSource.handle.value;
        unlinkSignal.register(() => {
          resetMediaElement(mediaElement, null);
        });
      } else {
        const url = URL.createObjectURL(mediaSource.handle.value);
        mediaElement.src = url;
        unlinkSignal.register(() => {
          resetMediaElement(mediaElement, url);
        });
      }
    });
  }

  // src/main_thread/init/utils/get_initial_time.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function getInitialTime(manifest, lowLatencyMode, startAt) {
    var _a;
    if (!isNullOrUndefined(startAt)) {
      const min = getMinimumSafePosition(manifest);
      const max = getMaximumSafePosition(manifest);
      if (!isNullOrUndefined(startAt.position)) {
        log_default.debug("Init: using startAt.minimumPosition");
        return Math.max(Math.min(startAt.position, max), min);
      } else if (!isNullOrUndefined(startAt.wallClockTime)) {
        log_default.debug("Init: using startAt.wallClockTime");
        const ast = manifest.availabilityStartTime === void 0 ? 0 : manifest.availabilityStartTime;
        const position = startAt.wallClockTime - ast;
        return Math.max(Math.min(position, max), min);
      } else if (!isNullOrUndefined(startAt.fromFirstPosition)) {
        log_default.debug("Init: using startAt.fromFirstPosition");
        const { fromFirstPosition } = startAt;
        return fromFirstPosition <= 0 ? min : Math.min(max, min + fromFirstPosition);
      } else if (!isNullOrUndefined(startAt.fromLastPosition)) {
        log_default.debug("Init: using startAt.fromLastPosition");
        const { fromLastPosition } = startAt;
        return fromLastPosition >= 0 ? max : Math.max(min, max + fromLastPosition);
      } else if (!isNullOrUndefined(startAt.fromLivePosition)) {
        log_default.debug("Init: using startAt.fromLivePosition");
        const livePosition = (_a = getLivePosition(manifest)) != null ? _a : max;
        const { fromLivePosition } = startAt;
        return fromLivePosition >= 0 ? livePosition : Math.max(min, livePosition + fromLivePosition);
      } else if (!isNullOrUndefined(startAt.percentage)) {
        log_default.debug("Init: using startAt.percentage");
        const { percentage } = startAt;
        if (percentage > 100) {
          return max;
        } else if (percentage < 0) {
          return min;
        }
        const ratio = +percentage / 100;
        const extent = max - min;
        return min + extent * ratio;
      }
    }
    const minimumPosition = getMinimumSafePosition(manifest);
    if (manifest.isLive) {
      const { suggestedPresentationDelay, clockOffset } = manifest;
      const maximumPosition = getMaximumSafePosition(manifest);
      let liveTime;
      const { DEFAULT_LIVE_GAP } = config_default.getCurrent();
      if (clockOffset === void 0) {
        log_default.info(
          "Init: no clock offset found for a live content, starting close to maximum available position"
        );
        liveTime = maximumPosition;
      } else {
        log_default.info(
          "Init: clock offset found for a live content, checking if we can start close to it"
        );
        const ast = manifest.availabilityStartTime === void 0 ? 0 : manifest.availabilityStartTime;
        const clockRelativeLiveTime = (monotonic_timestamp_default() + clockOffset) / 1e3 - ast;
        liveTime = Math.min(maximumPosition, clockRelativeLiveTime);
      }
      const diffFromLiveTime = suggestedPresentationDelay != null ? suggestedPresentationDelay : lowLatencyMode ? DEFAULT_LIVE_GAP.LOW_LATENCY : DEFAULT_LIVE_GAP.DEFAULT;
      log_default.debug(
        `Init: ${liveTime} defined as the live time, applying a live gap of ${diffFromLiveTime}`
      );
      return Math.max(liveTime - diffFromLiveTime, minimumPosition);
    }
    log_default.info("Init: starting at the minimum available position:", minimumPosition);
    return minimumPosition;
  }

  // src/main_thread/init/utils/get_loaded_reference.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/compat/should_validate_metadata.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function shouldValidateMetadata() {
    return isSamsungBrowser;
  }

  // src/compat/should_wait_for_data_before_loaded.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function shouldWaitForDataBeforeLoaded(isDirectfile) {
    if (isDirectfile && isSafariMobile) {
      return false;
    } else {
      return true;
    }
  }

  // src/compat/should_wait_for_have_enough_data.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function shouldWaitForHaveEnoughData() {
    return isPlayStation5;
  }

  // src/main_thread/init/utils/get_loaded_reference.ts
  function getLoadedReference(playbackObserver, mediaElement, isDirectfile, cancelSignal) {
    const listenCanceller = new TaskCanceller();
    listenCanceller.linkToSignal(cancelSignal);
    const isLoaded = new reference_default(false, listenCanceller.signal);
    playbackObserver.listen(
      (observation) => {
        if (observation.rebuffering !== null || observation.freezing !== null || observation.readyState === 0) {
          return;
        }
        if (!shouldWaitForDataBeforeLoaded(isDirectfile)) {
          if (isNaN(mediaElement.duration)) {
            return;
          }
          if (mediaElement.duration > 0) {
            isLoaded.setValue(true);
            listenCanceller.cancel();
            return;
          }
        }
        const minReadyState = shouldWaitForHaveEnoughData() ? 4 : 3;
        if (observation.readyState >= minReadyState) {
          if (observation.currentRange !== null || observation.ended) {
            if (!shouldValidateMetadata() || mediaElement.duration > 0) {
              isLoaded.setValue(true);
              listenCanceller.cancel();
              return;
            }
          }
        }
      },
      { includeLastObservation: true, clearSignal: listenCanceller.signal }
    );
    return isLoaded;
  }

  // src/main_thread/init/utils/initial_seek_and_play.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/compat/can_seek_directly_after_loaded_metadata.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var canSeekDirectlyAfterLoadedMetadata = !isSafariMobile;
  var can_seek_directly_after_loaded_metadata_default = canSeekDirectlyAfterLoadedMetadata;

  // src/main_thread/init/utils/initial_seek_and_play.ts
  function performInitialSeekAndPlay({
    mediaElement,
    playbackObserver,
    startTime,
    mustAutoPlay,
    isDirectfile,
    onWarning
  }, cancelSignal) {
    const initialPlayPerformed = new reference_default(false, cancelSignal);
    const autoPlayResult = new Promise(
      (resolveAutoPlay, rejectAutoPlay) => {
        const deregisterCancellation = cancelSignal.register((err) => {
          rejectAutoPlay(err);
        });
        if (cancelSignal.isCancelled()) {
          return;
        }
        let hasAskedForInitialSeek = false;
        const performInitialSeek = (initialSeekTime) => {
          playbackObserver.setCurrentTime(initialSeekTime);
          hasAskedForInitialSeek = true;
        };
        if (!isDirectfile || typeof startTime === "number") {
          const initiallySeekedTime = typeof startTime === "number" ? startTime : startTime();
          if (initiallySeekedTime !== 0) {
            performInitialSeek(initiallySeekedTime);
          }
          waitForSeekable();
        } else {
          playbackObserver.listen(
            (obs, stopListening) => {
              if (obs.readyState >= 1) {
                stopListening();
                const initiallySeekedTime = typeof startTime === "number" ? startTime : startTime();
                if (initiallySeekedTime !== 0) {
                  if (can_seek_directly_after_loaded_metadata_default) {
                    performInitialSeek(initiallySeekedTime);
                  } else {
                    setTimeout(() => {
                      performInitialSeek(initiallySeekedTime);
                    }, 0);
                  }
                }
                waitForSeekable();
              }
            },
            { includeLastObservation: true, clearSignal: cancelSignal }
          );
        }
        function waitForSeekable() {
          let hasStartedSeeking = false;
          playbackObserver.listen(
            (obs, stopListening) => {
              if (!hasStartedSeeking && (obs.seeking !== 0 /* None */ || obs.event === "seeking" || obs.event === "internal-seeking")) {
                hasStartedSeeking = true;
              }
              if (hasAskedForInitialSeek && !hasStartedSeeking || obs.readyState === 0) {
                return;
              }
              stopListening();
              if (shouldValidateMetadata() && mediaElement.duration === 0) {
                const error = new MediaError(
                  "MEDIA_ERR_NOT_LOADED_METADATA",
                  "Cannot load automatically: your browser falsely announced having loaded the content."
                );
                onWarning(error);
              }
              if (cancelSignal.isCancelled()) {
                return;
              }
              waitForPlayable();
            },
            { includeLastObservation: true, clearSignal: cancelSignal }
          );
        }
        function waitForPlayable() {
          playbackObserver.listen(
            (observation, stopListening) => {
              if (observation.seeking === 0 /* None */ && observation.rebuffering === null && observation.readyState >= 1) {
                stopListening();
                onPlayable();
              }
            },
            { includeLastObservation: true, clearSignal: cancelSignal }
          );
        }
        function onPlayable() {
          var _a;
          log_default.info("Init: Can begin to play content");
          if (!mustAutoPlay) {
            if (mediaElement.autoplay) {
              log_default.warn(
                "Init: autoplay is enabled on HTML media element. Media will play as soon as possible."
              );
            }
            initialPlayPerformed.setValue(true);
            initialPlayPerformed.finish();
            deregisterCancellation();
            return resolveAutoPlay({ type: "skipped" });
          } else if (mediaElement.ended) {
            log_default.warn(
              "Init: autoplay is enabled but the video is ended. Skipping autoplay to prevent video to start again"
            );
            initialPlayPerformed.setValue(true);
            initialPlayPerformed.finish();
            deregisterCancellation();
            return resolveAutoPlay({ type: "skipped" });
          }
          let playResult;
          try {
            playResult = (_a = mediaElement.play()) != null ? _a : Promise.resolve();
          } catch (playError) {
            deregisterCancellation();
            return rejectAutoPlay(playError);
          }
          playResult.then(() => {
            if (cancelSignal.isCancelled()) {
              return;
            }
            initialPlayPerformed.setValue(true);
            initialPlayPerformed.finish();
            deregisterCancellation();
            return resolveAutoPlay({ type: "autoplay" });
          }).catch((playError) => {
            deregisterCancellation();
            if (cancelSignal.isCancelled()) {
              return;
            }
            if (playError instanceof Error && playError.name === "NotAllowedError") {
              log_default.warn(
                "Init: Media element can't play. It may be due to browser auto-play policies."
              );
              const error = new MediaError(
                "MEDIA_ERR_BLOCKED_AUTOPLAY",
                "Cannot trigger auto-play automatically: your browser does not allow it."
              );
              onWarning(error);
              if (cancelSignal.isCancelled()) {
                return;
              }
              return resolveAutoPlay({ type: "autoplay-blocked" });
            } else {
              rejectAutoPlay(playError);
            }
          });
        }
      }
    );
    return { autoPlayResult, initialPlayPerformed };
  }

  // src/main_thread/init/utils/initialize_content_decryption.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function initializeContentDecryption(mediaElement, keySystems, callbacks, cancelSignal) {
    if (keySystems.length === 0) {
      return createEmeDisabledReference("No `keySystems` option given.");
    } else if (features_default.decrypt === null) {
      return createEmeDisabledReference("EME feature not activated.");
    }
    const decryptorCanceller = new TaskCanceller();
    decryptorCanceller.linkToSignal(cancelSignal);
    const drmStatusRef = new reference_default(
      {
        initializationState: { type: "uninitialized", value: null },
        drmSystemId: void 0
      },
      cancelSignal
    );
    const ContentDecryptor2 = features_default.decrypt;
    if (!ContentDecryptor2.hasEmeApis()) {
      return createEmeDisabledReference("EME API not available on the current page.");
    }
    log_default.debug("Init: Creating ContentDecryptor");
    const contentDecryptor = new ContentDecryptor2(mediaElement, keySystems);
    const onStateChange = (state) => {
      var _a;
      if (state > 0 /* Initializing */) {
        (_a = callbacks.onCodecSupportUpdate) == null ? void 0 : _a.call(callbacks);
        contentDecryptor.removeEventListener("stateChange", onStateChange);
      }
    };
    contentDecryptor.addEventListener("stateChange", onStateChange);
    contentDecryptor.addEventListener("stateChange", (state) => {
      if (state === 1 /* WaitingForAttachment */) {
        const isMediaLinked = new reference_default(false);
        isMediaLinked.onUpdate(
          (isAttached, stopListening) => {
            if (isAttached) {
              stopListening();
              if (state === 1 /* WaitingForAttachment */) {
                contentDecryptor.attach();
              }
            }
          },
          { clearSignal: decryptorCanceller.signal }
        );
        drmStatusRef.setValue({
          initializationState: {
            type: "awaiting-media-link",
            value: { isMediaLinked }
          },
          drmSystemId: contentDecryptor.systemId
        });
      } else if (state === 2 /* ReadyForContent */) {
        drmStatusRef.setValue({
          initializationState: { type: "initialized", value: null },
          drmSystemId: contentDecryptor.systemId
        });
        contentDecryptor.removeEventListener("stateChange");
      }
    });
    contentDecryptor.addEventListener("error", (error) => {
      decryptorCanceller.cancel();
      callbacks.onError(error);
    });
    contentDecryptor.addEventListener("warning", (error) => {
      callbacks.onWarning(error);
    });
    contentDecryptor.addEventListener("blackListProtectionData", (x) => {
      callbacks.onBlackListProtectionData(x);
    });
    contentDecryptor.addEventListener("keyIdsCompatibilityUpdate", (x) => {
      callbacks.onKeyIdsCompatibilityUpdate(x);
    });
    decryptorCanceller.signal.register(() => {
      contentDecryptor.dispose();
    });
    return {
      statusRef: drmStatusRef,
      contentDecryptor: { enabled: true, value: contentDecryptor }
    };
    function createEmeDisabledReference(errMsg) {
      const err = new EncryptedMediaError("MEDIA_IS_ENCRYPTED_ERROR", errMsg);
      const ref = new reference_default({
        initializationState: { type: "initialized", value: null },
        drmSystemId: void 0
      });
      ref.finish();
      return { statusRef: ref, contentDecryptor: { enabled: false, value: err } };
    }
  }

  // src/main_thread/init/utils/main_thread_text_displayer_interface.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var MainThreadTextDisplayerInterface = class {
    /**
     * @param {Object} displayer
     */
    constructor(displayer) {
      this._displayer = displayer;
    }
    /**
     * @see ITextDisplayerInterface
     */
    pushTextData(infos) {
      try {
        return Promise.resolve(this._displayer.pushTextData(infos));
      } catch (err) {
        return Promise.reject(err);
      }
    }
    /**
     * @see ITextDisplayerInterface
     */
    remove(start, end) {
      try {
        return Promise.resolve(this._displayer.removeBuffer(start, end));
      } catch (err) {
        return Promise.reject(err);
      }
    }
    /**
     * @see ITextDisplayerInterface
     */
    reset() {
      this._displayer.reset();
    }
    /**
     * @see ITextDisplayerInterface
     */
    stop() {
      this._displayer.stop();
    }
  };

  // src/main_thread/init/utils/rebuffering_controller.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var EPSILON2 = 1 / 60;
  var RebufferingController = class extends EventEmitter {
    /**
     * @param {object} playbackObserver - emit the current playback conditions.
     * @param {Object} manifest - The Manifest of the currently-played content.
     * @param {Object} speed - The last speed set by the user
     */
    constructor(playbackObserver, manifest, speed) {
      super();
      this._playbackObserver = playbackObserver;
      this._manifest = manifest;
      this._speed = speed;
      this._discontinuitiesStore = [];
      this._isStarted = false;
      this._canceller = new TaskCanceller();
    }
    start() {
      if (this._isStarted) {
        return;
      }
      this._isStarted = true;
      const playbackRateUpdater = new PlaybackRateUpdater(
        this._playbackObserver,
        this._speed
      );
      this._canceller.signal.register(() => {
        playbackRateUpdater.dispose();
      });
      let prevFreezingState = null;
      this._playbackObserver.listen(
        (observation) => {
          const discontinuitiesStore = this._discontinuitiesStore;
          const { buffered, position, readyState, rebuffering, freezing } = observation;
          const {
            BUFFER_DISCONTINUITY_THRESHOLD,
            FREEZING_STALLED_DELAY,
            UNFREEZING_SEEK_DELAY,
            UNFREEZING_DELTA_POSITION
          } = config_default.getCurrent();
          if (freezing !== null) {
            const now = monotonic_timestamp_default();
            const referenceTimestamp = prevFreezingState === null ? freezing.timestamp : prevFreezingState.attemptTimestamp;
            if (!position.isAwaitingFuturePosition() && now - referenceTimestamp > UNFREEZING_SEEK_DELAY) {
              log_default.warn("Init: trying to seek to un-freeze player");
              this._playbackObserver.setCurrentTime(
                this._playbackObserver.getCurrentTime() + UNFREEZING_DELTA_POSITION
              );
              prevFreezingState = { attemptTimestamp: now };
            }
            if (now - freezing.timestamp > FREEZING_STALLED_DELAY) {
              if (rebuffering === null) {
                playbackRateUpdater.stopRebuffering();
              } else {
                playbackRateUpdater.startRebuffering();
              }
              this.trigger("stalled", "freezing");
              return;
            }
          } else {
            prevFreezingState = null;
          }
          if (rebuffering === null) {
            playbackRateUpdater.stopRebuffering();
            if (readyState === 1) {
              let reason;
              if (observation.seeking !== 0 /* None */) {
                reason = observation.seeking === 1 /* Internal */ ? "internal-seek" : "seeking";
              } else {
                reason = "not-ready";
              }
              this.trigger("stalled", reason);
              return;
            }
            this.trigger("unstalled", null);
            return;
          }
          const stalledReason = rebuffering.reason === "seeking" && observation.seeking === 1 /* Internal */ ? "internal-seek" : rebuffering.reason;
          if (position.isAwaitingFuturePosition()) {
            playbackRateUpdater.stopRebuffering();
            log_default.debug("Init: let rebuffering happen as we're awaiting a future position");
            this.trigger("stalled", stalledReason);
            return;
          }
          playbackRateUpdater.startRebuffering();
          if (this._manifest === null) {
            this.trigger("stalled", stalledReason);
            return;
          }
          const { position: stalledPosition } = rebuffering;
          if (stalledPosition !== null && stalledPosition !== void 0 && this._speed.getValue() > 0) {
            const skippableDiscontinuity = findSeekableDiscontinuity(
              discontinuitiesStore,
              this._manifest,
              stalledPosition
            );
            if (skippableDiscontinuity !== null) {
              const realSeekTime = skippableDiscontinuity + 1e-3;
              if (realSeekTime <= this._playbackObserver.getCurrentTime()) {
                log_default.info(
                  "Init: position to seek already reached, no seeking",
                  this._playbackObserver.getCurrentTime(),
                  realSeekTime
                );
              } else {
                log_default.warn(
                  "SA: skippable discontinuity found in the stream",
                  position.getPolled(),
                  realSeekTime
                );
                this._playbackObserver.setCurrentTime(realSeekTime);
                this.trigger(
                  "warning",
                  generateDiscontinuityError(stalledPosition, realSeekTime)
                );
                return;
              }
            }
          }
          const positionBlockedAt = stalledPosition != null ? stalledPosition : position.getPolled();
          const nextBufferRangeGap = getNextBufferedTimeRangeGap(
            buffered,
            positionBlockedAt
          );
          if (this._speed.getValue() > 0 && nextBufferRangeGap < BUFFER_DISCONTINUITY_THRESHOLD) {
            const seekTo = positionBlockedAt + nextBufferRangeGap + EPSILON2;
            if (this._playbackObserver.getCurrentTime() < seekTo) {
              log_default.warn(
                "Init: discontinuity encountered inferior to the threshold",
                positionBlockedAt,
                seekTo,
                BUFFER_DISCONTINUITY_THRESHOLD
              );
              this._playbackObserver.setCurrentTime(seekTo);
              this.trigger(
                "warning",
                generateDiscontinuityError(positionBlockedAt, seekTo)
              );
              return;
            }
          }
          for (let i = this._manifest.periods.length - 2; i >= 0; i--) {
            const period = this._manifest.periods[i];
            if (period.end !== void 0 && period.end <= positionBlockedAt) {
              if (this._manifest.periods[i + 1].start > positionBlockedAt && this._manifest.periods[i + 1].start > this._playbackObserver.getCurrentTime()) {
                const nextPeriod = this._manifest.periods[i + 1];
                this._playbackObserver.setCurrentTime(nextPeriod.start);
                this.trigger(
                  "warning",
                  generateDiscontinuityError(positionBlockedAt, nextPeriod.start)
                );
                return;
              }
              break;
            }
          }
          this.trigger("stalled", stalledReason);
        },
        { includeLastObservation: true, clearSignal: this._canceller.signal }
      );
    }
    /**
     * Update information on an upcoming discontinuity for a given buffer type and
     * Period.
     * Each new update for the same Period and type overwrites the previous one.
     * @param {Object} evt
     */
    updateDiscontinuityInfo(evt) {
      if (!this._isStarted) {
        this.start();
      }
      const lastObservation = this._playbackObserver.getReference().getValue();
      updateDiscontinuitiesStore(this._discontinuitiesStore, evt, lastObservation);
    }
    /**
     * Function to call when a Stream is currently locked, i.e. we cannot load
     * segments for the corresponding Period and buffer type until it is seeked
     * to.
     * @param {string} bufferType - Buffer type for which no segment will
     * currently load.
     * @param {Object} period - Period for which no segment will currently load.
     */
    onLockedStream(bufferType, period) {
      var _a;
      if (!this._isStarted) {
        this.start();
      }
      const observation = this._playbackObserver.getReference().getValue();
      if (!observation.rebuffering || observation.paused || this._speed.getValue() <= 0 || bufferType !== "audio" && bufferType !== "video") {
        return;
      }
      const loadedPos = observation.position.getWanted();
      const rebufferingPos = (_a = observation.rebuffering.position) != null ? _a : loadedPos;
      const lockedPeriodStart = period.start;
      if (loadedPos < lockedPeriodStart && Math.abs(rebufferingPos - lockedPeriodStart) < 1) {
        log_default.warn(
          "Init: rebuffering because of a future locked stream.\nTrying to unlock by seeking to the next Period"
        );
        this._playbackObserver.setCurrentTime(lockedPeriodStart + 1e-3);
      }
    }
    /**
     * Stops the `RebufferingController` from montoring stalling situations,
     * forever.
     */
    destroy() {
      this._canceller.cancel();
    }
  };
  function findSeekableDiscontinuity(discontinuitiesStore, manifest, stalledPosition) {
    if (discontinuitiesStore.length === 0) {
      return null;
    }
    let maxDiscontinuityEnd = null;
    for (const discontinuityInfo of discontinuitiesStore) {
      const { period } = discontinuityInfo;
      if (period.start > stalledPosition) {
        return maxDiscontinuityEnd;
      }
      let discontinuityEnd;
      if (period.end === void 0 || period.end > stalledPosition) {
        const { discontinuity, position } = discontinuityInfo;
        const { start, end } = discontinuity;
        const discontinuityLowerLimit = start != null ? start : position;
        if (stalledPosition >= discontinuityLowerLimit - EPSILON2) {
          if (end === null) {
            const nextPeriod = getPeriodAfter(manifest, period);
            if (nextPeriod !== null) {
              discontinuityEnd = nextPeriod.start + EPSILON2;
            } else {
              log_default.warn("Init: discontinuity at Period's end but no next Period");
            }
          } else if (stalledPosition < end + EPSILON2) {
            discontinuityEnd = end + EPSILON2;
          }
        }
        if (discontinuityEnd !== void 0) {
          log_default.info("Init: discontinuity found", stalledPosition, discontinuityEnd);
          maxDiscontinuityEnd = maxDiscontinuityEnd !== null && maxDiscontinuityEnd > discontinuityEnd ? maxDiscontinuityEnd : discontinuityEnd;
        }
      }
    }
    return maxDiscontinuityEnd;
  }
  function eventContainsDiscontinuity(evt) {
    return evt.discontinuity !== null;
  }
  function updateDiscontinuitiesStore(discontinuitiesStore, evt, observation) {
    const gcTime = Math.min(
      observation.position.getPolled(),
      observation.position.getWanted()
    );
    while (discontinuitiesStore.length > 0 && discontinuitiesStore[0].period.end !== void 0 && discontinuitiesStore[0].period.end + 10 < gcTime) {
      discontinuitiesStore.shift();
    }
    const { period, bufferType } = evt;
    if (bufferType !== "audio" && bufferType !== "video") {
      return;
    }
    for (let i = 0; i < discontinuitiesStore.length; i++) {
      if (discontinuitiesStore[i].period.id === period.id) {
        if (discontinuitiesStore[i].bufferType === bufferType) {
          if (!eventContainsDiscontinuity(evt)) {
            discontinuitiesStore.splice(i, 1);
          } else {
            discontinuitiesStore[i] = evt;
          }
          return;
        }
      } else if (discontinuitiesStore[i].period.start > period.start) {
        if (eventContainsDiscontinuity(evt)) {
          discontinuitiesStore.splice(i, 0, evt);
        }
        return;
      }
    }
    if (eventContainsDiscontinuity(evt)) {
      discontinuitiesStore.push(evt);
    }
    return;
  }
  function generateDiscontinuityError(stalledPosition, seekTo) {
    return new MediaError(
      "DISCONTINUITY_ENCOUNTERED",
      "A discontinuity has been encountered at position " + String(stalledPosition) + ", seeked at position " + String(seekTo)
    );
  }
  var PlaybackRateUpdater = class {
    /**
     * Create a new `PlaybackRateUpdater`.
     * @param {Object} playbackObserver
     * @param {Object} speed
     */
    constructor(playbackObserver, speed) {
      this._speedUpdateCanceller = new TaskCanceller();
      this._isRebuffering = false;
      this._playbackObserver = playbackObserver;
      this._isDisposed = false;
      this._speed = speed;
      this._updateSpeed();
    }
    /**
     * Force the playback rate to `0`, to start a rebuffering phase.
     *
     * You can call `stopRebuffering` when you want the rebuffering phase to end.
     */
    startRebuffering() {
      if (this._isRebuffering || this._isDisposed) {
        return;
      }
      this._isRebuffering = true;
      this._speedUpdateCanceller.cancel();
      log_default.info("Init: Pause playback to build buffer");
      this._playbackObserver.setPlaybackRate(0);
    }
    /**
     * If in a rebuffering phase (during which the playback rate is forced to
     * `0`), exit that phase to apply the wanted playback rate instead.
     *
     * Do nothing if not in a rebuffering phase.
     */
    stopRebuffering() {
      if (!this._isRebuffering || this._isDisposed) {
        return;
      }
      this._isRebuffering = false;
      this._speedUpdateCanceller = new TaskCanceller();
      this._updateSpeed();
    }
    /**
     * The `PlaybackRateUpdater` allocate resources to for example listen to
     * wanted speed changes and react to it.
     *
     * Consequently, you should call the `dispose` method, when you don't want the
     * `PlaybackRateUpdater` to have an effect anymore.
     */
    dispose() {
      this._speedUpdateCanceller.cancel();
      this._isDisposed = true;
    }
    _updateSpeed() {
      this._speed.onUpdate(
        (lastSpeed) => {
          log_default.info("Init: Resume playback speed", lastSpeed);
          this._playbackObserver.setPlaybackRate(lastSpeed);
        },
        {
          clearSignal: this._speedUpdateCanceller.signal,
          emitCurrentValue: true
        }
      );
    }
  };

  // src/main_thread/init/utils/stream_events_emitter/index.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/main_thread/init/utils/stream_events_emitter/stream_events_emitter.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/main_thread/init/utils/stream_events_emitter/refresh_scheduled_events_list.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/main_thread/init/utils/stream_events_emitter/are_same_stream_events.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function areSameStreamEvents(evt1, evt2) {
    return evt1.id === evt2.id && evt1.start === evt2.start && evt1.end === evt2.end;
  }
  var are_same_stream_events_default = areSameStreamEvents;

  // src/main_thread/init/utils/stream_events_emitter/refresh_scheduled_events_list.ts
  function refreshScheduledEventsList(oldScheduledEvents, manifest) {
    const scheduledEvents = [];
    const { periods } = manifest;
    for (const period of periods) {
      const { streamEvents } = period;
      streamEvents.forEach(({ start, end, id, data: data2 }) => {
        for (const currentScheduledEvent of oldScheduledEvents) {
          if (are_same_stream_events_default(currentScheduledEvent, { id, start, end })) {
            scheduledEvents.push(currentScheduledEvent);
            return;
          }
        }
        let element;
        if (data2.value.element !== void 0) {
          element = data2.value.element;
        } else if (data2.value.xmlData !== void 0) {
          let parentNode = data2.value.xmlData.namespaces.reduce((acc, ns) => {
            return acc + "xmlns:" + ns.key + '="' + ns.value + '" ';
          }, "<toremove ");
          parentNode += ">";
          const parsedDom = new DOMParser().parseFromString(
            parentNode + data2.value.xmlData.data + "</toremove>",
            "application/xml"
          ).documentElement;
          element = parsedDom.children.length > 0 ? parsedDom.children[0] : parsedDom.childNodes[0];
        } else {
          return;
        }
        const actualData = { type: data2.type, value: __spreadProps(__spreadValues({}, data2.value), { element }) };
        if (end === void 0) {
          const newScheduledEvent = {
            start,
            id,
            data: actualData,
            publicEvent: { start, data: actualData }
          };
          scheduledEvents.push(newScheduledEvent);
        } else {
          const newScheduledEvent = {
            start,
            end,
            id,
            data: actualData,
            publicEvent: { start, end, data: actualData }
          };
          scheduledEvents.push(newScheduledEvent);
        }
      });
    }
    return scheduledEvents;
  }
  var refresh_scheduled_events_list_default = refreshScheduledEventsList;

  // src/main_thread/init/utils/stream_events_emitter/stream_events_emitter.ts
  var StreamEventsEmitter = class extends EventEmitter {
    /**
     * @param {Object} manifest
     * @param {HTMLMediaElement} mediaElement
     * @param {Object} playbackObserver
     */
    constructor(manifest, mediaElement, playbackObserver) {
      super();
      this._manifest = manifest;
      this._mediaElement = mediaElement;
      this._playbackObserver = playbackObserver;
      this._canceller = null;
      this._scheduledEventsRef = new reference_default([]);
      this._eventsBeingPlayed = /* @__PURE__ */ new WeakMap();
    }
    start() {
      if (this._canceller !== null) {
        return;
      }
      this._canceller = new TaskCanceller();
      const cancelSignal = this._canceller.signal;
      const playbackObserver = this._playbackObserver;
      const mediaElement = this._mediaElement;
      let isPollingEvents = false;
      let cancelCurrentPolling = new TaskCanceller();
      cancelCurrentPolling.linkToSignal(cancelSignal);
      this._scheduledEventsRef.setValue(refresh_scheduled_events_list_default([], this._manifest));
      this._scheduledEventsRef.onUpdate(
        ({ length: scheduledEventsLength }) => {
          if (scheduledEventsLength === 0) {
            if (isPollingEvents) {
              cancelCurrentPolling.cancel();
              cancelCurrentPolling = new TaskCanceller();
              cancelCurrentPolling.linkToSignal(cancelSignal);
              isPollingEvents = false;
            }
            return;
          } else if (isPollingEvents) {
            return;
          }
          isPollingEvents = true;
          let oldObservation = constructObservation();
          const checkStreamEvents = () => {
            const newObservation = constructObservation();
            this._emitStreamEvents(
              this._scheduledEventsRef.getValue(),
              oldObservation,
              newObservation,
              cancelCurrentPolling.signal
            );
            oldObservation = newObservation;
          };
          const { STREAM_EVENT_EMITTER_POLL_INTERVAL } = config_default.getCurrent();
          const intervalId = setInterval(
            checkStreamEvents,
            STREAM_EVENT_EMITTER_POLL_INTERVAL
          );
          playbackObserver.listen(checkStreamEvents, {
            includeLastObservation: false,
            clearSignal: cancelCurrentPolling.signal
          });
          cancelCurrentPolling.signal.register(() => {
            clearInterval(intervalId);
          });
          function constructObservation() {
            const lastObservation = playbackObserver.getReference().getValue();
            const currentTime = mediaElement.currentTime;
            const isSeeking = lastObservation.seeking !== 0 /* None */;
            return { currentTime, isSeeking };
          }
        },
        { emitCurrentValue: true, clearSignal: cancelSignal }
      );
    }
    onManifestUpdate(man) {
      const prev = this._scheduledEventsRef.getValue();
      this._scheduledEventsRef.setValue(refresh_scheduled_events_list_default(prev, man));
    }
    stop() {
      if (this._canceller !== null) {
        this._canceller.cancel();
        this._canceller = null;
      }
    }
    /**
     * Examine playback situation from playback observations to emit stream events and
     * prepare set onExit callbacks if needed.
     * @param {Array.<Object>} scheduledEvents
     * @param {Object} oldObservation
     * @param {Object} newObservation
     * @param {Object} stopSignal
     */
    _emitStreamEvents(scheduledEvents, oldObservation, newObservation, stopSignal) {
      const { currentTime: previousTime } = oldObservation;
      const { isSeeking, currentTime } = newObservation;
      const eventsToSend = [];
      const eventsToExit = [];
      for (let i = 0; i < scheduledEvents.length; i++) {
        const event = scheduledEvents[i];
        const start = event.start;
        const end = isFiniteStreamEvent(event) ? event.end : void 0;
        const isBeingPlayed = this._eventsBeingPlayed.has(event);
        if (isBeingPlayed) {
          if (start > currentTime || end !== void 0 && currentTime >= end) {
            if (isFiniteStreamEvent(event)) {
              eventsToExit.push(event.publicEvent);
            }
            this._eventsBeingPlayed.delete(event);
          }
        } else if (start <= currentTime && end !== void 0 && currentTime < end) {
          eventsToSend.push({ type: "stream-event", value: event.publicEvent });
          this._eventsBeingPlayed.set(event, true);
        } else if (previousTime < start && currentTime >= (end != null ? end : start)) {
          if (isSeeking) {
            eventsToSend.push({
              type: "stream-event-skip",
              value: event.publicEvent
            });
          } else {
            eventsToSend.push({ type: "stream-event", value: event.publicEvent });
            if (isFiniteStreamEvent(event)) {
              eventsToExit.push(event.publicEvent);
            }
          }
        }
      }
      if (eventsToSend.length > 0) {
        for (const event of eventsToSend) {
          if (event.type === "stream-event") {
            this.trigger("event", event.value);
          } else {
            this.trigger("eventSkip", event.value);
          }
          if (stopSignal.isCancelled()) {
            return;
          }
        }
      }
      if (eventsToExit.length > 0) {
        for (const event of eventsToExit) {
          if (typeof event.onExit === "function") {
            event.onExit();
          }
          if (stopSignal.isCancelled()) {
            return;
          }
        }
      }
    }
  };
  function isFiniteStreamEvent(evt) {
    return evt.end !== void 0;
  }

  // src/main_thread/init/utils/stream_events_emitter/index.ts
  var stream_events_emitter_default = StreamEventsEmitter;

  // src/main_thread/init/utils/throw_on_media_error.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function listenToMediaError(mediaElement, onError, cancelSignal) {
    if (cancelSignal.isCancelled()) {
      return;
    }
    mediaElement.addEventListener("error", onMediaError);
    cancelSignal.register(() => {
      mediaElement.removeEventListener("error", onMediaError);
    });
    function onMediaError() {
      const mediaError = mediaElement.error;
      let errorCode;
      let errorMessage2;
      if (!isNullOrUndefined(mediaError)) {
        errorCode = mediaError.code;
        errorMessage2 = mediaError.message;
      }
      switch (errorCode) {
        case 1:
          errorMessage2 = errorMessage2 != null ? errorMessage2 : "The fetching of the associated resource was aborted by the user's request.";
          return onError(new MediaError("MEDIA_ERR_ABORTED", errorMessage2));
        case 2:
          errorMessage2 = errorMessage2 != null ? errorMessage2 : "A network error occurred which prevented the media from being successfully fetched";
          return onError(new MediaError("MEDIA_ERR_NETWORK", errorMessage2));
        case 3:
          errorMessage2 = errorMessage2 != null ? errorMessage2 : "An error occurred while trying to decode the media resource";
          return onError(new MediaError("MEDIA_ERR_DECODE", errorMessage2));
        case 4:
          errorMessage2 = errorMessage2 != null ? errorMessage2 : "The media resource has been found to be unsuitable.";
          return onError(new MediaError("MEDIA_ERR_SRC_NOT_SUPPORTED", errorMessage2));
        default:
          errorMessage2 = errorMessage2 != null ? errorMessage2 : "The HTMLMediaElement errored due to an unknown reason.";
          return onError(new MediaError("MEDIA_ERR_UNKNOWN", errorMessage2));
      }
    }
  }

  // src/main_thread/init/media_source_content_initializer.ts
  var MediaSourceContentInitializer = class extends ContentInitializer {
    /**
     * Create a new `MediaSourceContentInitializer`, associated to the given
     * settings.
     * @param {Object} settings
     */
    constructor(settings) {
      super();
      this._settings = settings;
      this._initCanceller = new TaskCanceller();
      this._manifest = null;
      this._decryptionCapabilities = { status: "uninitialized", value: null };
      const urls = settings.url === void 0 ? void 0 : [settings.url];
      this._cmcdDataBuilder = settings.cmcd === void 0 ? null : new cmcd_default(settings.cmcd);
      this._manifestFetcher = new manifest_default(urls, settings.transport, __spreadProps(__spreadValues({}, settings.manifestRequestSettings), {
        lowLatencyMode: settings.lowLatencyMode,
        cmcdDataBuilder: this._cmcdDataBuilder
      }));
    }
    /**
     * Perform non-destructive preparation steps, to prepare a future content.
     * For now, this mainly mean loading the Manifest document.
     */
    prepare() {
      if (this._manifest !== null) {
        return;
      }
      this._manifest = sync_or_async_default.createAsync(
        createCancellablePromise(this._initCanceller.signal, (res, rej) => {
          this._manifestFetcher.addEventListener(
            "warning",
            (err) => this.trigger("warning", err)
          );
          this._manifestFetcher.addEventListener("error", (err) => {
            this.trigger("error", err);
            rej(err);
          });
          this._manifestFetcher.addEventListener("manifestReady", (manifest) => {
            res(manifest);
          });
        })
      );
      this._manifestFetcher.start();
      this._initCanceller.signal.register(() => {
        this._manifestFetcher.dispose();
      });
    }
    /**
     * @param {HTMLMediaElement} mediaElement
     * @param {Object} playbackObserver
     */
    start(mediaElement, playbackObserver) {
      this.prepare();
      listenToMediaError(
        mediaElement,
        (error) => this._onFatalError(error),
        this._initCanceller.signal
      );
      this._initializeMediaSourceAndDecryption(mediaElement).then(
        (initResult) => this._onInitialMediaSourceReady(
          mediaElement,
          initResult.mediaSource,
          playbackObserver,
          initResult.drmSystemId,
          initResult.unlinkMediaSource
        )
      ).catch((err) => {
        this._onFatalError(err);
      });
    }
    /**
     * Update URL of the Manifest.
     * @param {Array.<string>|undefined} urls - URLs to reach that Manifest from
     * the most prioritized URL to the least prioritized URL.
     * @param {boolean} refreshNow - If `true` the resource in question (e.g.
     * DASH's MPD) will be refreshed immediately.
     */
    updateContentUrls(urls, refreshNow) {
      this._manifestFetcher.updateContentUrls(urls, refreshNow);
    }
    dispose() {
      this._initCanceller.cancel();
    }
    _onFatalError(err) {
      if (this._initCanceller.isUsed()) {
        return;
      }
      this._initCanceller.cancel();
      this.trigger("error", err);
    }
    _initializeMediaSourceAndDecryption(mediaElement) {
      const initCanceller = this._initCanceller;
      return createCancellablePromise(initCanceller.signal, (resolve) => {
        const { keySystems } = this._settings;
        const { statusRef: drmInitRef, contentDecryptor } = initializeContentDecryption(
          mediaElement,
          keySystems,
          {
            onWarning: (err) => this.trigger("warning", err),
            onError: (err) => this._onFatalError(err),
            onBlackListProtectionData: (val) => {
              (async () => {
                var _a;
                if (this._manifest === null) {
                  return;
                }
                const manifest = (_a = this._manifest.syncValue) != null ? _a : await this._manifest.getValueAsAsync();
                blackListProtectionDataOnManifest(manifest, val);
              })().catch(noop_default);
            },
            onKeyIdsCompatibilityUpdate: (updates) => {
              (async () => {
                var _a;
                if (this._manifest === null) {
                  return;
                }
                const manifest = (_a = this._manifest.syncValue) != null ? _a : await this._manifest.getValueAsAsync();
                updateKeyIdsDecipherabilityOnManifest(
                  manifest,
                  updates.whitelistedKeyIds,
                  updates.blacklistedKeyIds,
                  updates.delistedKeyIds
                );
              })().catch(noop_default);
            },
            onCodecSupportUpdate: () => {
              var _a, _b;
              const syncManifest = (_a = this._manifest) == null ? void 0 : _a.syncValue;
              if (isNullOrUndefined(syncManifest)) {
                (_b = this._manifest) == null ? void 0 : _b.getValueAsAsync().then((loadedManifest) => {
                  if (this._initCanceller.isUsed()) {
                    return;
                  }
                  this._refreshManifestCodecSupport(loadedManifest);
                }, noop_default);
              } else {
                this._refreshManifestCodecSupport(syncManifest);
              }
            }
          },
          initCanceller.signal
        );
        if (contentDecryptor.enabled) {
          this._decryptionCapabilities = {
            status: "enabled",
            value: contentDecryptor.value
          };
        } else {
          this._decryptionCapabilities = {
            status: "disabled",
            value: contentDecryptor.value
          };
        }
        drmInitRef.onUpdate(
          (drmStatus, stopListeningToDrmUpdates) => {
            if (drmStatus.initializationState.type === "uninitialized") {
              return;
            }
            stopListeningToDrmUpdates();
            const mediaSourceCanceller = new TaskCanceller();
            mediaSourceCanceller.linkToSignal(initCanceller.signal);
            openMediaSource(mediaElement, mediaSourceCanceller.signal).then((mediaSource) => {
              const lastDrmStatus = drmInitRef.getValue();
              if (lastDrmStatus.initializationState.type === "awaiting-media-link") {
                lastDrmStatus.initializationState.value.isMediaLinked.setValue(true);
                drmInitRef.onUpdate(
                  (newDrmStatus, stopListeningToDrmUpdatesAgain) => {
                    if (newDrmStatus.initializationState.type === "initialized") {
                      stopListeningToDrmUpdatesAgain();
                      resolve({
                        mediaSource,
                        drmSystemId: newDrmStatus.drmSystemId,
                        unlinkMediaSource: mediaSourceCanceller
                      });
                      return;
                    }
                  },
                  { emitCurrentValue: true, clearSignal: initCanceller.signal }
                );
              } else if (drmStatus.initializationState.type === "initialized") {
                resolve({
                  mediaSource,
                  drmSystemId: drmStatus.drmSystemId,
                  unlinkMediaSource: mediaSourceCanceller
                });
                return;
              }
            }).catch((err) => {
              if (mediaSourceCanceller.isUsed()) {
                return;
              }
              this._onFatalError(err);
            });
          },
          { emitCurrentValue: true, clearSignal: initCanceller.signal }
        );
      });
    }
    async _onInitialMediaSourceReady(mediaElement, initialMediaSource, playbackObserver, drmSystemId, initialMediaSourceCanceller) {
      var _a;
      const {
        adaptiveOptions,
        autoPlay,
        bufferOptions,
        lowLatencyMode,
        segmentRequestOptions,
        speed,
        startAt,
        textTrackOptions,
        transport
      } = this._settings;
      const initCanceller = this._initCanceller;
      assert(this._manifest !== null);
      let manifest;
      try {
        manifest = (_a = this._manifest.syncValue) != null ? _a : await this._manifest.getValueAsAsync();
      } catch (_e) {
        return;
      }
      manifest.addEventListener(
        "manifestUpdate",
        (updates) => {
          this.trigger("manifestUpdate", updates);
          this._refreshManifestCodecSupport(manifest);
        },
        initCanceller.signal
      );
      manifest.addEventListener(
        "decipherabilityUpdate",
        (elts) => {
          this.trigger("decipherabilityUpdate", elts);
        },
        initCanceller.signal
      );
      manifest.addEventListener(
        "supportUpdate",
        () => {
          this.trigger("codecSupportUpdate", null);
        },
        initCanceller.signal
      );
      log_default.debug("Init: Calculating initial time");
      const initialTime = getInitialTime(manifest, lowLatencyMode, startAt);
      log_default.debug("Init: Initial time calculated:", initialTime);
      const representationEstimator = adaptive_default(adaptiveOptions);
      const subBufferOptions = object_assign_default(
        { textTrackOptions, drmSystemId },
        bufferOptions
      );
      const cdnPrioritizer = new CdnPrioritizer(initCanceller.signal);
      const segmentQueueCreator = new segment_default(
        transport,
        cdnPrioritizer,
        this._cmcdDataBuilder,
        segmentRequestOptions
      );
      this._refreshManifestCodecSupport(manifest);
      this.trigger("manifestReady", manifest);
      if (initCanceller.isUsed()) {
        return;
      }
      const bufferOnMediaSource = this._startBufferingOnMediaSource.bind(this);
      const triggerEvent = this.trigger.bind(this);
      const onFatalError = this._onFatalError.bind(this);
      recursivelyLoadOnMediaSource(
        initialMediaSource,
        initialTime,
        autoPlay,
        initialMediaSourceCanceller
      );
      function recursivelyLoadOnMediaSource(mediaSource, startingPos, shouldPlay, currentCanceller) {
        const opts = {
          mediaElement,
          playbackObserver,
          mediaSource,
          initialTime: startingPos,
          autoPlay: shouldPlay,
          manifest,
          representationEstimator,
          cdnPrioritizer,
          segmentQueueCreator,
          speed,
          bufferOptions: subBufferOptions
        };
        bufferOnMediaSource(opts, onReloadMediaSource, currentCanceller.signal);
        function onReloadMediaSource(reloadOrder) {
          currentCanceller.cancel();
          if (initCanceller.isUsed()) {
            return;
          }
          triggerEvent("reloadingMediaSource", reloadOrder);
          if (initCanceller.isUsed()) {
            return;
          }
          const newCanceller = new TaskCanceller();
          newCanceller.linkToSignal(initCanceller.signal);
          openMediaSource(mediaElement, newCanceller.signal).then((newMediaSource) => {
            recursivelyLoadOnMediaSource(
              newMediaSource,
              reloadOrder.position,
              reloadOrder.autoPlay,
              newCanceller
            );
          }).catch((err) => {
            if (newCanceller.isUsed()) {
              return;
            }
            onFatalError(err);
          });
        }
      }
    }
    /**
     * Buffer the content on the given MediaSource.
     * @param {Object} args
     * @param {function} onReloadOrder
     * @param {Object} cancelSignal
     */
    _startBufferingOnMediaSource(args, onReloadOrder, cancelSignal) {
      var _a, _b;
      const {
        autoPlay,
        bufferOptions,
        initialTime,
        manifest,
        mediaElement,
        mediaSource,
        playbackObserver,
        representationEstimator,
        cdnPrioritizer,
        segmentQueueCreator,
        speed
      } = args;
      const { transport } = this._settings;
      const initialPeriod = (_a = manifest.getPeriodForTime(initialTime)) != null ? _a : manifest.getNextPeriod(initialTime);
      if (initialPeriod === void 0) {
        const error = new MediaError(
          "MEDIA_STARTING_TIME_NOT_FOUND",
          "Wanted starting time not found in the Manifest."
        );
        return this._onFatalError(error);
      }
      let textDisplayerInterface = null;
      let textDisplayer = null;
      if (this._settings.textTrackOptions.textTrackMode === "html" && features_default.htmlTextDisplayer !== null) {
        textDisplayer = new features_default.htmlTextDisplayer(
          mediaElement,
          this._settings.textTrackOptions.textTrackElement
        );
      } else if (features_default.nativeTextDisplayer !== null) {
        textDisplayer = new features_default.nativeTextDisplayer(mediaElement);
      }
      if (textDisplayer !== null) {
        const sender = new MainThreadTextDisplayerInterface(textDisplayer);
        textDisplayerInterface = sender;
        cancelSignal.register(() => {
          sender.stop();
          textDisplayer == null ? void 0 : textDisplayer.stop();
        });
      }
      const segmentSinksStore = new segment_sinks_default(
        mediaSource,
        mediaElement.nodeName === "VIDEO",
        textDisplayerInterface
      );
      cancelSignal.register(() => {
        segmentSinksStore.disposeAll();
      });
      const { autoPlayResult, initialPlayPerformed } = performInitialSeekAndPlay(
        {
          mediaElement,
          playbackObserver,
          startTime: initialTime,
          mustAutoPlay: autoPlay,
          onWarning: (err) => {
            this.trigger("warning", err);
          },
          isDirectfile: false
        },
        cancelSignal
      );
      if (cancelSignal.isCancelled()) {
        return;
      }
      initialPlayPerformed.onUpdate(
        (isPerformed, stopListening) => {
          if (isPerformed) {
            stopListening();
            const streamEventsEmitter = new stream_events_emitter_default(
              manifest,
              mediaElement,
              playbackObserver
            );
            manifest.addEventListener(
              "manifestUpdate",
              () => {
                streamEventsEmitter.onManifestUpdate(manifest);
              },
              cancelSignal
            );
            streamEventsEmitter.addEventListener(
              "event",
              (payload) => {
                this.trigger("streamEvent", payload);
              },
              cancelSignal
            );
            streamEventsEmitter.addEventListener(
              "eventSkip",
              (payload) => {
                this.trigger("streamEventSkip", payload);
              },
              cancelSignal
            );
            streamEventsEmitter.start();
            cancelSignal.register(() => {
              streamEventsEmitter.stop();
            });
          }
        },
        { clearSignal: cancelSignal, emitCurrentValue: true }
      );
      const coreObserver = createCorePlaybackObserver(
        playbackObserver,
        {
          autoPlay,
          manifest,
          mediaSource,
          textDisplayer,
          initialPlayPerformed,
          speed
        },
        cancelSignal
      );
      (_b = this._cmcdDataBuilder) == null ? void 0 : _b.startMonitoringPlayback(coreObserver);
      cancelSignal.register(() => {
        var _a2;
        (_a2 = this._cmcdDataBuilder) == null ? void 0 : _a2.stopMonitoringPlayback();
      });
      const rebufferingController = this._createRebufferingController(
        playbackObserver,
        manifest,
        speed,
        cancelSignal
      );
      const decipherabilityFreezeDetector = new DecipherabilityFreezeDetector(
        segmentSinksStore
      );
      if (may_media_element_fail_on_undecipherable_data_default) {
        manifest.addEventListener(
          "decipherabilityUpdate",
          (elts) => {
            if (elts.some((e) => e.representation.decipherable !== true)) {
              reloadMediaSource(0, void 0, void 0);
            }
          },
          cancelSignal
        );
      }
      playbackObserver.listen(
        (observation) => {
          if (decipherabilityFreezeDetector.needToReload(observation)) {
            let position;
            const lastObservation = playbackObserver.getReference().getValue();
            if (lastObservation.position.isAwaitingFuturePosition()) {
              position = lastObservation.position.getWanted();
            } else {
              position = playbackObserver.getCurrentTime();
            }
            const autoplay = initialPlayPerformed.getValue() ? !playbackObserver.getIsPaused() : autoPlay;
            onReloadOrder({ position, autoPlay: autoplay });
          }
        },
        { clearSignal: cancelSignal }
      );
      coreObserver.listen(
        (observation) => {
          ["video", "audio", "text"].forEach((tType) => {
            var _a2;
            const segmentSinkStatus = segmentSinksStore.getStatus(tType);
            if (segmentSinkStatus.type === "initialized") {
              segmentSinkStatus.value.synchronizeInventory(
                (_a2 = observation.buffered[tType]) != null ? _a2 : []
              );
            }
          });
        },
        { clearSignal: cancelSignal }
      );
      const contentTimeBoundariesObserver = createContentTimeBoundariesObserver(
        manifest,
        mediaSource,
        coreObserver,
        segmentSinksStore,
        {
          onWarning: (err) => this.trigger("warning", err),
          onPeriodChanged: (period) => this.trigger("activePeriodChanged", { period })
        },
        cancelSignal
      );
      autoPlayResult.then(() => {
        getLoadedReference(playbackObserver, mediaElement, false, cancelSignal).onUpdate(
          (isLoaded, stopListening) => {
            if (isLoaded) {
              stopListening();
              this.trigger("loaded", {
                getSegmentSinkMetrics: async () => {
                  return new Promise(
                    (resolve) => resolve(segmentSinksStore.getSegmentSinksMetrics())
                  );
                },
                getThumbnailData: async (periodId, thumbnailTrackId, time) => {
                  const fetchThumbnails = thumbnails_default(
                    transport.thumbnails,
                    cdnPrioritizer
                  );
                  return getThumbnailData(
                    fetchThumbnails,
                    manifest,
                    periodId,
                    thumbnailTrackId,
                    time
                  );
                }
              });
            }
          },
          { emitCurrentValue: true, clearSignal: cancelSignal }
        );
      }).catch((err) => {
        if (cancelSignal.isCancelled()) {
          return;
        }
        this._onFatalError(err);
      });
      const self2 = this;
      stream_default(
        { manifest, initialPeriod },
        coreObserver,
        representationEstimator,
        segmentSinksStore,
        segmentQueueCreator,
        bufferOptions,
        handleStreamOrchestratorCallbacks(),
        cancelSignal
      );
      function handleStreamOrchestratorCallbacks() {
        return {
          needsBufferFlush: (payload) => {
            var _a2;
            let wantedSeekingTime;
            const currentTime = playbackObserver.getCurrentTime();
            const relativeResumingPosition = (_a2 = payload == null ? void 0 : payload.relativeResumingPosition) != null ? _a2 : 0;
            const canBeApproximateSeek = Boolean(payload == null ? void 0 : payload.relativePosHasBeenDefaulted);
            if (relativeResumingPosition === 0 && canBeApproximateSeek) {
              wantedSeekingTime = currentTime + 1e-3;
            } else {
              wantedSeekingTime = currentTime + relativeResumingPosition;
            }
            playbackObserver.setCurrentTime(wantedSeekingTime);
            playbackObserver.listen(
              (obs, stopListening) => {
                if (
                  // Data is buffered around the current position
                  obs.currentRange !== null || // Or, for whatever reason, we have no buffer but we're already advancing
                  obs.position.getPolled() > wantedSeekingTime + 0.1
                ) {
                  stopListening();
                  playbackObserver.setCurrentTime(obs.position.getWanted() + 1e-3);
                }
              },
              { includeLastObservation: false, clearSignal: cancelSignal }
            );
          },
          streamStatusUpdate(value) {
            const { period, bufferType, imminentDiscontinuity, position } = value;
            rebufferingController.updateDiscontinuityInfo({
              period,
              bufferType,
              discontinuity: imminentDiscontinuity,
              position
            });
            if (cancelSignal.isCancelled()) {
              return;
            }
            if (manifest.isLastPeriodKnown && value.period.id === manifest.periods[manifest.periods.length - 1].id) {
              const hasFinishedLoadingLastPeriod = value.hasFinishedLoading || value.isEmptyStream;
              if (hasFinishedLoadingLastPeriod) {
                contentTimeBoundariesObserver.onLastSegmentFinishedLoading(
                  value.bufferType
                );
              } else {
                contentTimeBoundariesObserver.onLastSegmentLoadingResume(value.bufferType);
              }
            }
          },
          needsManifestRefresh: () => self2._manifestFetcher.scheduleManualRefresh({
            enablePartialRefresh: true,
            canUseUnsafeMode: true
          }),
          manifestMightBeOufOfSync: () => {
            const { OUT_OF_SYNC_MANIFEST_REFRESH_DELAY } = config_default.getCurrent();
            self2._manifestFetcher.scheduleManualRefresh({
              enablePartialRefresh: false,
              canUseUnsafeMode: false,
              delay: OUT_OF_SYNC_MANIFEST_REFRESH_DELAY
            });
          },
          lockedStream: (value) => rebufferingController.onLockedStream(value.bufferType, value.period),
          adaptationChange: (value) => {
            self2.trigger("adaptationChange", value);
            if (cancelSignal.isCancelled()) {
              return;
            }
            contentTimeBoundariesObserver.onAdaptationChange(
              value.type,
              value.period,
              value.adaptation
            );
          },
          representationChange: (value) => {
            self2.trigger("representationChange", value);
            if (cancelSignal.isCancelled()) {
              return;
            }
            contentTimeBoundariesObserver.onRepresentationChange(value.type, value.period);
          },
          inbandEvent: (value) => self2.trigger("inbandEvents", value),
          warning: (value) => self2.trigger("warning", value),
          periodStreamReady: (value) => self2.trigger("periodStreamReady", value),
          periodStreamCleared: (value) => {
            contentTimeBoundariesObserver.onPeriodCleared(value.type, value.period);
            if (cancelSignal.isCancelled()) {
              return;
            }
            self2.trigger("periodStreamCleared", value);
          },
          bitrateEstimateChange: (value) => {
            var _a2;
            (_a2 = self2._cmcdDataBuilder) == null ? void 0 : _a2.updateThroughput(value.type, value.bitrate);
            self2.trigger("bitrateEstimateChange", value);
          },
          needsMediaSourceReload: (payload) => {
            reloadMediaSource(
              payload.timeOffset,
              payload.minimumPosition,
              payload.maximumPosition
            );
          },
          needsDecipherabilityFlush() {
            var _a2, _b2, _c, _d;
            const keySystem = getKeySystemConfiguration(mediaElement);
            if (shouldReloadMediaSourceOnDecipherabilityUpdate(keySystem == null ? void 0 : keySystem[0])) {
              const lastObservation = coreObserver.getReference().getValue();
              const position = lastObservation.position.isAwaitingFuturePosition() ? lastObservation.position.getWanted() : (_a2 = coreObserver.getCurrentTime()) != null ? _a2 : lastObservation.position.getPolled();
              const isPaused = (_c = (_b2 = lastObservation.paused.pending) != null ? _b2 : coreObserver.getIsPaused()) != null ? _c : lastObservation.paused.last;
              onReloadOrder({ position, autoPlay: !isPaused });
            } else {
              const lastObservation = coreObserver.getReference().getValue();
              const position = lastObservation.position.isAwaitingFuturePosition() ? lastObservation.position.getWanted() : (_d = coreObserver.getCurrentTime()) != null ? _d : lastObservation.position.getPolled();
              if (position + 1e-3 < lastObservation.duration) {
                playbackObserver.setCurrentTime(mediaElement.currentTime + 1e-3);
              } else {
                playbackObserver.setCurrentTime(position);
              }
            }
          },
          encryptionDataEncountered: (value) => {
            if (self2._decryptionCapabilities.status === "disabled") {
              self2._onFatalError(self2._decryptionCapabilities.value);
              return;
            } else if (self2._decryptionCapabilities.status === "uninitialized") {
              log_default.error(
                "Init: received encryption data without known decryption capabilities"
              );
              return;
            }
            for (const protectionData of value) {
              self2._decryptionCapabilities.value.onInitializationData(protectionData);
              if (cancelSignal.isCancelled()) {
                return;
              }
            }
          },
          error: (err) => self2._onFatalError(err)
        };
      }
      function reloadMediaSource(deltaPosition, minimumPosition, maximumPosition) {
        var _a2, _b2, _c;
        const lastObservation = coreObserver.getReference().getValue();
        const currentPosition = lastObservation.position.isAwaitingFuturePosition() ? lastObservation.position.getWanted() : (_a2 = coreObserver.getCurrentTime()) != null ? _a2 : lastObservation.position.getPolled();
        const isPaused = (_c = (_b2 = lastObservation.paused.pending) != null ? _b2 : coreObserver.getIsPaused()) != null ? _c : lastObservation.paused.last;
        let position = currentPosition + deltaPosition;
        if (minimumPosition !== void 0) {
          position = Math.max(minimumPosition, position);
        }
        if (maximumPosition !== void 0) {
          position = Math.min(maximumPosition, position);
        }
        onReloadOrder({ position, autoPlay: !isPaused });
      }
    }
    /**
     * Creates a `RebufferingController`, a class trying to avoid various stalling
     * situations (such as rebuffering periods), and returns it.
     *
     * Various methods from that class need then to be called at various events
     * (see `RebufferingController` definition).
     *
     * This function also handles the `RebufferingController`'s events:
     *   - emit "stalled" events when stalling situations cannot be prevented,
     *   - emit "unstalled" events when we could get out of one,
     *   - emit "warning" on various rebuffering-related minor issues
     *     like discontinuity skipping.
     * @param {Object} playbackObserver
     * @param {Object} manifest
     * @param {Object} speed
     * @param {Object} cancelSignal
     * @returns {Object}
     */
    _createRebufferingController(playbackObserver, manifest, speed, cancelSignal) {
      const rebufferingController = new RebufferingController(
        playbackObserver,
        manifest,
        speed
      );
      rebufferingController.addEventListener(
        "stalled",
        (evt) => this.trigger("stalled", evt)
      );
      rebufferingController.addEventListener(
        "unstalled",
        () => this.trigger("unstalled", null)
      );
      rebufferingController.addEventListener(
        "warning",
        (err) => this.trigger("warning", err)
      );
      cancelSignal.register(() => rebufferingController.destroy());
      rebufferingController.start();
      return rebufferingController;
    }
    /**
     * Evaluates a list of codecs to determine their support status.
     *
     * @param {Array} codecsToCheck - The list of codecs to check.
     * @returns {Array} - The list of evaluated codecs with their support status updated.
     */
    getCodecsSupportInfo(codecsToCheck) {
      const codecsSupportInfo = codecsToCheck.map((codecToCheck) => {
        var _a;
        const inputCodec = `${codecToCheck.mimeType};codecs="${codecToCheck.codec}"`;
        const isSupported = isCodecSupported(inputCodec);
        if (!isSupported) {
          return {
            mimeType: codecToCheck.mimeType,
            codec: codecToCheck.codec,
            supported: false,
            supportedIfEncrypted: false
          };
        }
        let supportedIfEncrypted;
        if (this._decryptionCapabilities.status === "uninitialized") {
          supportedIfEncrypted = void 0;
        } else if (this._decryptionCapabilities.status === "disabled") {
          supportedIfEncrypted = true;
        } else {
          const contentDecryptor = this._decryptionCapabilities.value;
          if (contentDecryptor.getState() !== 0 /* Initializing */) {
            supportedIfEncrypted = (_a = contentDecryptor.isCodecSupported(
              codecToCheck.mimeType,
              codecToCheck.codec
            )) != null ? _a : true;
          }
        }
        return {
          mimeType: codecToCheck.mimeType,
          codec: codecToCheck.codec,
          supported: isSupported,
          supportedIfEncrypted
        };
      });
      return codecsSupportInfo;
    }
    /**
     * Update the support status of all Representations in the Manifest.
     *
     * To call anytime either the Manifest is linked to new codecs or new means
     * to test for codec support are available.
     * @param {Object} manifest
     */
    _refreshManifestCodecSupport(manifest) {
      const codecsToTest = manifest.getCodecsWithUnknownSupport();
      const codecsSupportInfo = this.getCodecsSupportInfo(codecsToTest);
      if (codecsSupportInfo.length > 0) {
        try {
          manifest.updateCodecSupport(codecsSupportInfo);
        } catch (err) {
          this._onFatalError(err);
        }
      }
    }
  };
  function updateKeyIdsDecipherabilityOnManifest(manifest, whitelistedKeyIds, blacklistedKeyIds, delistedKeyIds) {
    manifest.updateRepresentationsDeciperability((ctx) => {
      const { representation } = ctx;
      if (representation.contentProtections === void 0) {
        return representation.decipherable;
      }
      const contentKIDs = representation.contentProtections.keyIds;
      if (contentKIDs !== void 0) {
        for (const elt of contentKIDs) {
          for (const blacklistedKeyId of blacklistedKeyIds) {
            if (areArraysOfNumbersEqual(blacklistedKeyId, elt)) {
              return false;
            }
          }
          for (const whitelistedKeyId of whitelistedKeyIds) {
            if (areArraysOfNumbersEqual(whitelistedKeyId, elt)) {
              return true;
            }
          }
          for (const delistedKeyId of delistedKeyIds) {
            if (areArraysOfNumbersEqual(delistedKeyId, elt)) {
              return void 0;
            }
          }
        }
      }
      return representation.decipherable;
    });
  }
  function blackListProtectionDataOnManifest(manifest, initData) {
    manifest.updateRepresentationsDeciperability((ctx) => {
      var _a, _b;
      const rep = ctx.representation;
      if (rep.decipherable === false) {
        return false;
      }
      const segmentProtections = (_b = (_a = rep.contentProtections) == null ? void 0 : _a.initData) != null ? _b : [];
      for (const protection of segmentProtections) {
        if (initData.type === void 0 || protection.type === initData.type) {
          const containedInitData = initData.values.getFormattedValues().every((undecipherableVal) => {
            return protection.values.some((currVal) => {
              return (undecipherableVal.systemId === void 0 || currVal.systemId === undecipherableVal.systemId) && areArraysOfNumbersEqual(currVal.data, undecipherableVal.data);
            });
          });
          if (containedInitData) {
            return false;
          }
        }
      }
      return rep.decipherable;
    });
  }

  // src/parsers/manifest/dash/native-parser/index.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/parsers/manifest/dash/native-parser/parse_from_document.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/parsers/manifest/dash/common/index.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/parsers/manifest/dash/common/indexes/index.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/parsers/manifest/dash/common/indexes/base.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/parsers/manifest/utils/index_helpers.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function calculateRepeat(element, nextElement, maxPosition) {
    const { repeatCount } = element;
    if (repeatCount >= 0) {
      return repeatCount;
    }
    let segmentEnd;
    if (!isNullOrUndefined(nextElement)) {
      segmentEnd = nextElement.start;
    } else if (maxPosition !== void 0) {
      segmentEnd = maxPosition;
    } else {
      segmentEnd = Number.MAX_VALUE;
    }
    return Math.ceil((segmentEnd - element.start) / element.duration) - 1;
  }
  function getIndexSegmentEnd(segment, nextSegment, maxPosition) {
    const { start, duration } = segment;
    if (duration <= 0) {
      return start;
    }
    const repeat = calculateRepeat(segment, nextSegment, maxPosition);
    return start + (repeat + 1) * duration;
  }
  function toIndexTime(time, indexOptions) {
    var _a;
    return time * indexOptions.timescale + ((_a = indexOptions.indexTimeOffset) != null ? _a : 0);
  }
  function fromIndexTime(time, indexOptions) {
    var _a;
    return (time - ((_a = indexOptions.indexTimeOffset) != null ? _a : 0)) / indexOptions.timescale;
  }
  function getTimescaledRange(start, duration, timescale) {
    return [start * timescale, (start + duration) * timescale];
  }
  function getIndexOfLastObjectBefore(timeline, timeTScaled) {
    let low = 0;
    let high = timeline.length;
    while (low < high) {
      const mid = low + high >>> 1;
      if (timeline[mid].start <= timeTScaled) {
        low = mid + 1;
      } else {
        high = mid;
      }
    }
    return low - 1;
  }
  function checkDiscontinuity(index, timeSec, maxPosition) {
    const { timeline } = index;
    const scaledTime = toIndexTime(timeSec, index);
    if (scaledTime < 0) {
      return null;
    }
    const segmentIndex = getIndexOfLastObjectBefore(timeline, scaledTime);
    if (segmentIndex < 0 || segmentIndex >= timeline.length - 1) {
      return null;
    }
    const timelineItem = timeline[segmentIndex];
    if (timelineItem.duration <= 0) {
      return null;
    }
    const nextTimelineItem = timeline[segmentIndex + 1];
    if (nextTimelineItem === void 0) {
      return null;
    }
    const nextStart = nextTimelineItem.start;
    const segmentEnd = getIndexSegmentEnd(timelineItem, nextTimelineItem, maxPosition);
    return scaledTime >= segmentEnd && scaledTime < nextStart ? fromIndexTime(nextStart, index) : null;
  }

  // src/parsers/manifest/dash/common/indexes/get_init_segment.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function getInitSegment(index, isEMSGWhitelisted) {
    var _a;
    const { initialization } = index;
    const privateInfos = {};
    if (isEMSGWhitelisted !== void 0) {
      privateInfos.isEMSGWhitelisted = isEMSGWhitelisted;
    }
    return {
      id: "init",
      isInit: true,
      time: 0,
      end: 0,
      duration: 0,
      timescale: 1,
      range: !isNullOrUndefined(initialization) ? initialization.range : void 0,
      indexRange: index.indexRange,
      url: (_a = initialization == null ? void 0 : initialization.url) != null ? _a : null,
      complete: true,
      privateInfos,
      timestampOffset: -(index.indexTimeOffset / index.timescale)
    };
  }

  // src/parsers/manifest/dash/common/indexes/get_segments_from_timeline.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/parsers/manifest/dash/common/indexes/tokens.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function padLeftWithZeros(n, l) {
    const nToString = n.toString();
    if (nToString.length >= l) {
      return nToString;
    }
    const arr = new Array(l + 1).join("0") + nToString;
    return arr.slice(-l);
  }
  function processFormatedToken(replacer) {
    return (_match, _format, widthStr) => {
      const width = isNonEmptyString(widthStr) ? parseInt(widthStr, 10) : 1;
      return padLeftWithZeros(String(replacer), width);
    };
  }
  function constructRepresentationUrl(urlTemplate, representationId, bitrate) {
    return replaceRepresentationDASHTokens(urlTemplate, representationId, bitrate);
  }
  function replaceRepresentationDASHTokens(path, id, bitrate) {
    if (path.indexOf("$") === -1) {
      return path;
    } else {
      return path.replace(/\$\$/g, "$").replace(/\$RepresentationID\$/g, String(id)).replace(
        /\$Bandwidth(\%0(\d+)d)?\$/g,
        processFormatedToken(bitrate === void 0 ? 0 : bitrate)
      );
    }
  }
  function createDashUrlDetokenizer(time, nb) {
    return function replaceTokensInUrl(url) {
      if (url.indexOf("$") === -1) {
        return url;
      } else {
        return url.replace(/\$\$/g, "$").replace(/\$Number(\%0(\d+)d)?\$/g, (_x, _y, widthStr) => {
          if (nb === void 0) {
            throw new Error("Segment number not defined in a $Number$ scheme");
          }
          return processFormatedToken(nb)(_x, _y, widthStr);
        }).replace(/\$Time(\%0(\d+)d)?\$/g, (_x, _y, widthStr) => {
          if (time === void 0) {
            throw new Error("Segment time not defined in a $Time$ scheme");
          }
          return processFormatedToken(time)(_x, _y, widthStr);
        });
      }
    };
  }

  // src/parsers/manifest/dash/common/indexes/get_segments_from_timeline.ts
  function getWantedRepeatIndex(segmentStartTime, segmentDuration, wantedTime) {
    const diff = wantedTime - segmentStartTime;
    return diff > 0 ? Math.floor(diff / segmentDuration) : 0;
  }
  function getSegmentsFromTimeline(index, from, durationWanted, manifestBoundsCalculator, scaledPeriodEnd, isEMSGWhitelisted) {
    var _a;
    const maximumTime = manifestBoundsCalculator.getEstimatedMaximumPosition(
      (_a = index.availabilityTimeOffset) != null ? _a : 0
    );
    const wantedMaximum = Math.min(from + durationWanted, maximumTime != null ? maximumTime : Infinity);
    const scaledUp = toIndexTime(from, index);
    const scaledTo = toIndexTime(wantedMaximum, index);
    const { timeline, timescale, segmentUrlTemplate, startNumber, endNumber } = index;
    let currentNumber = startNumber != null ? startNumber : 1;
    const segments = [];
    const timelineLength = timeline.length;
    for (let i = 0; i < timelineLength; i++) {
      const timelineItem = timeline[i];
      const { duration, start, range } = timelineItem;
      let maxRepeatTime;
      if (maximumTime === void 0) {
        maxRepeatTime = scaledPeriodEnd;
      } else {
        maxRepeatTime = Math.min(maximumTime * timescale, scaledPeriodEnd != null ? scaledPeriodEnd : Infinity);
      }
      const repeat = calculateRepeat(timelineItem, timeline[i + 1], maxRepeatTime);
      const complete = index.availabilityTimeComplete !== false || i !== timelineLength - 1 && repeat !== 0;
      let segmentNumberInCurrentRange = getWantedRepeatIndex(start, duration, scaledUp);
      let segmentTime = start + segmentNumberInCurrentRange * duration;
      while (segmentTime < scaledTo && segmentNumberInCurrentRange <= repeat) {
        const segmentNumber = currentNumber + segmentNumberInCurrentRange;
        if (endNumber !== void 0 && segmentNumber > endNumber) {
          break;
        }
        const detokenizedURL = segmentUrlTemplate === null ? null : createDashUrlDetokenizer(segmentTime, segmentNumber)(segmentUrlTemplate);
        let time = segmentTime - index.indexTimeOffset;
        let realDuration = duration;
        if (time < 0) {
          realDuration = duration + time;
          time = 0;
        }
        const segment = {
          id: String(segmentTime),
          time: time / timescale,
          end: (time + realDuration) / timescale,
          duration: realDuration / timescale,
          isInit: false,
          range,
          timescale: 1,
          url: detokenizedURL,
          number: segmentNumber,
          timestampOffset: -(index.indexTimeOffset / timescale),
          complete,
          privateInfos: { isEMSGWhitelisted }
        };
        segments.push(segment);
        segmentNumberInCurrentRange++;
        segmentTime = start + segmentNumberInCurrentRange * duration;
      }
      if (segmentTime >= scaledTo) {
        return segments;
      }
      currentNumber += repeat + 1;
      if (endNumber !== void 0 && currentNumber > endNumber) {
        return segments;
      }
    }
    return segments;
  }

  // src/parsers/manifest/dash/common/indexes/base.ts
  function _addSegmentInfos(index, segmentInfos) {
    if (segmentInfos.timescale !== index.timescale) {
      const { timescale } = index;
      index.timeline.push({
        start: segmentInfos.time / segmentInfos.timescale * timescale,
        duration: segmentInfos.duration / segmentInfos.timescale * timescale,
        repeatCount: segmentInfos.count === void 0 ? 0 : segmentInfos.count,
        range: segmentInfos.range
      });
    } else {
      index.timeline.push({
        start: segmentInfos.time,
        duration: segmentInfos.duration,
        repeatCount: segmentInfos.count === void 0 ? 0 : segmentInfos.count,
        range: segmentInfos.range
      });
    }
    return true;
  }
  var BaseRepresentationIndex = class {
    /**
     * @param {Object} index
     * @param {Object} context
     */
    constructor(index, context) {
      var _a, _b, _c, _d;
      const {
        periodStart,
        periodEnd,
        representationId,
        representationBitrate,
        isEMSGWhitelisted
      } = context;
      const timescale = (_a = index.timescale) != null ? _a : 1;
      const presentationTimeOffset = (_b = index.presentationTimeOffset) != null ? _b : 0;
      const indexTimeOffset = presentationTimeOffset - periodStart * timescale;
      const initializationUrl = ((_c = index.initialization) == null ? void 0 : _c.media) === void 0 ? null : constructRepresentationUrl(
        index.initialization.media,
        representationId,
        representationBitrate
      );
      const segmentUrlTemplate = index.media === void 0 ? null : constructRepresentationUrl(
        index.media,
        representationId,
        representationBitrate
      );
      let range;
      if (index.initialization !== void 0) {
        range = index.initialization.range;
      } else if (index.indexRange !== void 0) {
        range = [0, index.indexRange[0] - 1];
      }
      this._index = {
        indexRange: index.indexRange,
        indexTimeOffset,
        initialization: { url: initializationUrl, range },
        segmentUrlTemplate,
        startNumber: index.startNumber,
        endNumber: index.endNumber,
        timeline: (_d = index.timeline) != null ? _d : [],
        timescale
      };
      this._manifestBoundsCalculator = context.manifestBoundsCalculator;
      this._scaledPeriodStart = toIndexTime(periodStart, this._index);
      this._scaledPeriodEnd = isNullOrUndefined(periodEnd) ? void 0 : toIndexTime(periodEnd, this._index);
      this._isInitialized = this._index.timeline.length > 0;
      this._isEMSGWhitelisted = isEMSGWhitelisted;
    }
    /**
     * Construct init Segment.
     * @returns {Object}
     */
    getInitSegment() {
      return getInitSegment(this._index, this._isEMSGWhitelisted);
    }
    /**
     * Get the list of segments that are currently available from the `from`
     * position, in seconds, ending `dur` seconds after that position.
     *
     * Note that if not already done, you might need to "initialize" the
     * `BaseRepresentationIndex` first so that the list of available segments
     * is known.
     *
     * @see isInitialized for more information on `BaseRepresentationIndex`
     * initialization.
     * @param {Number} from
     * @param {Number} dur
     * @returns {Array.<Object>}
     */
    getSegments(from, dur) {
      return getSegmentsFromTimeline(
        this._index,
        from,
        dur,
        this._manifestBoundsCalculator,
        this._scaledPeriodEnd,
        this._isEMSGWhitelisted
      );
    }
    /**
     * Returns false as no Segment-Base based index should need to be refreshed.
     * @returns {Boolean}
     */
    shouldRefresh() {
      return false;
    }
    /**
     * Returns first position in index.
     * @returns {Number|null}
     */
    getFirstAvailablePosition() {
      const index = this._index;
      if (index.timeline.length === 0) {
        return null;
      }
      return fromIndexTime(
        Math.max(this._scaledPeriodStart, index.timeline[0].start),
        index
      );
    }
    /**
     * Returns last position in index.
     * @returns {Number|null}
     */
    getLastAvailablePosition() {
      var _a;
      const { timeline } = this._index;
      if (timeline.length === 0) {
        return null;
      }
      const lastTimelineElement = timeline[timeline.length - 1];
      const lastTime = Math.min(
        getIndexSegmentEnd(lastTimelineElement, null, this._scaledPeriodEnd),
        (_a = this._scaledPeriodEnd) != null ? _a : Infinity
      );
      return fromIndexTime(lastTime, this._index);
    }
    /**
     * Returns the absolute end in seconds this RepresentationIndex can reach once
     * all segments are available.
     * @returns {number|null|undefined}
     */
    getEnd() {
      return this.getLastAvailablePosition();
    }
    /**
     * Returns:
     *   - `true` if in the given time interval, at least one new segment is
     *     expected to be available in the future.
     *   - `false` either if all segments in that time interval are already
     *     available for download or if none will ever be available for it.
     *   - `undefined` when it is not possible to tell.
     *
     * Always `false` in a `BaseRepresentationIndex` because all segments should
     * be directly available.
     * @returns {boolean}
     */
    awaitSegmentBetween() {
      return false;
    }
    /**
     * Segments in a segmentBase scheme should stay available.
     * @returns {Boolean|undefined}
     */
    isSegmentStillAvailable() {
      return true;
    }
    /**
     * We do not check for discontinuity in SegmentBase-based indexes.
     * @returns {null}
     */
    checkDiscontinuity() {
      return null;
    }
    /**
     * Returns `false` as a `BaseRepresentationIndex` should not be dynamic and as
     * such segments should never fall out-of-sync.
     * @returns {Boolean}
     */
    canBeOutOfSyncError() {
      return false;
    }
    /**
     * Returns `true` as SegmentBase are not dynamic and as such no new segment
     * should become available in the future.
     * @returns {Boolean}
     */
    isStillAwaitingFutureSegments() {
      return false;
    }
    /**
     * No segment in a `BaseRepresentationIndex` are known initially.
     * It is only defined generally in an "index segment" that will thus need to
     * be first loaded and parsed.
     *
     * Once the index segment or equivalent has been parsed, the `initializeIndex`
     * method have to be called with the corresponding segment information so the
     * `BaseRepresentationIndex` can be considered as "initialized" (and so this
     * method can return `true`).
     * Until then this method will return `false` and segments linked to that
     * Representation may be missing.
     * @returns {Boolean}
     */
    isInitialized() {
      return this._isInitialized;
    }
    /**
     * No segment in a `BaseRepresentationIndex` are known initially.
     *
     * It is only defined generally in an "index segment" that will thus need to
     * be first loaded and parsed.
     * Until then, this `BaseRepresentationIndex` is considered as `uninitialized`
     * (@see isInitialized).
     *
     * Once that those information are available, the present
     * `BaseRepresentationIndex` can be "initialized" by adding that parsed
     * segment information through this method.
     * @param {Array.<Object>} indexSegments
     * @returns {Array.<Object>}
     */
    initialize(indexSegments) {
      if (this._isInitialized) {
        return;
      }
      for (let i = 0; i < indexSegments.length; i++) {
        _addSegmentInfos(this._index, indexSegments[i]);
      }
      this._isInitialized = true;
    }
    addPredictedSegments() {
      log_default.warn("Cannot add predicted segments to a `BaseRepresentationIndex`");
    }
    /**
     * Replace in-place this `BaseRepresentationIndex` information by the
     * information from another one.
     * @param {Object} newIndex
     */
    _replace(newIndex) {
      this._index = newIndex._index;
      this._isInitialized = newIndex._isInitialized;
      this._scaledPeriodEnd = newIndex._scaledPeriodEnd;
      this._isEMSGWhitelisted = newIndex._isEMSGWhitelisted;
    }
    _update() {
      log_default.error("Base RepresentationIndex: Cannot update a SegmentList");
    }
  };

  // src/parsers/manifest/dash/common/indexes/list.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var ListRepresentationIndex = class {
    /**
     * @param {Object} index
     * @param {Object} context
     */
    constructor(index, context) {
      var _a, _b, _c;
      if (index.duration === void 0) {
        throw new Error("Invalid SegmentList: no duration");
      }
      const {
        periodStart,
        periodEnd,
        representationId,
        representationBitrate,
        isEMSGWhitelisted
      } = context;
      this._isEMSGWhitelisted = isEMSGWhitelisted;
      this._periodStart = periodStart;
      this._periodEnd = periodEnd;
      const presentationTimeOffset = (_a = index.presentationTimeOffset) != null ? _a : 0;
      const timescale = (_b = index.timescale) != null ? _b : 1;
      const indexTimeOffset = presentationTimeOffset - periodStart * timescale;
      const initializationUrl = ((_c = index.initialization) == null ? void 0 : _c.media) === void 0 ? null : constructRepresentationUrl(
        index.initialization.media,
        representationId,
        representationBitrate
      );
      const list = index.list.map((lItem) => ({
        url: lItem.media === void 0 ? null : constructRepresentationUrl(
          lItem.media,
          representationId,
          representationBitrate
        ),
        mediaRange: lItem.mediaRange
      }));
      this._index = {
        list,
        timescale,
        duration: index.duration,
        indexTimeOffset,
        indexRange: index.indexRange,
        initialization: isNullOrUndefined(index.initialization) ? void 0 : { url: initializationUrl, range: index.initialization.range }
      };
    }
    /**
     * Construct init Segment.
     * @returns {Object}
     */
    getInitSegment() {
      const initSegment = getInitSegment(this._index);
      if (initSegment.privateInfos === void 0) {
        initSegment.privateInfos = {};
      }
      initSegment.privateInfos.isEMSGWhitelisted = this._isEMSGWhitelisted;
      return initSegment;
    }
    /**
     * @param {Number} fromTime
     * @param {Number} dur
     * @returns {Array.<Object>}
     */
    getSegments(fromTime, dur) {
      const index = this._index;
      const { duration, list, timescale } = index;
      const durationInSeconds = duration / timescale;
      const fromTimeInPeriod = fromTime - this._periodStart;
      const [up, to] = getTimescaledRange(fromTimeInPeriod, dur, timescale);
      const length = Math.min(list.length - 1, Math.floor(to / duration));
      const segments = [];
      let i = Math.floor(up / duration);
      while (i <= length) {
        const range = list[i].mediaRange;
        const url = list[i].url;
        const time = i * durationInSeconds + this._periodStart;
        const segment = {
          id: String(i),
          time,
          isInit: false,
          range,
          duration: durationInSeconds,
          timescale: 1,
          end: time + durationInSeconds,
          url,
          timestampOffset: -(index.indexTimeOffset / timescale),
          complete: true,
          privateInfos: { isEMSGWhitelisted: this._isEMSGWhitelisted }
        };
        segments.push(segment);
        i++;
      }
      return segments;
    }
    /**
     * Returns whether the Manifest should be refreshed based on the
     * `ListRepresentationIndex`'s state and the time range the player is
     * currently considering.
     * @param {Number} _fromTime
     * @param {Number} _toTime
     * @returns {Boolean}
     */
    shouldRefresh(_fromTime, _toTime) {
      return false;
    }
    /**
     * Returns first position in this index, in seconds.
     * @returns {Number}
     */
    getFirstAvailablePosition() {
      return this._periodStart;
    }
    /**
     * Returns last position in this index, in seconds.
     * @returns {Number}
     */
    getLastAvailablePosition() {
      var _a;
      const index = this._index;
      const { duration, list } = index;
      return Math.min(
        list.length * duration / index.timescale + this._periodStart,
        (_a = this._periodEnd) != null ? _a : Infinity
      );
    }
    /**
     * Returns the absolute end in seconds this RepresentationIndex can reach once
     * all segments are available.
     * @returns {number|null|undefined}
     */
    getEnd() {
      return this.getLastAvailablePosition();
    }
    /**
     * Returns:
     *   - `true` if in the given time interval, at least one new segment is
     *     expected to be available in the future.
     *   - `false` either if all segments in that time interval are already
     *     available for download or if none will ever be available for it.
     *   - `undefined` when it is not possible to tell.
     *
     * Always `false` in a `ListRepresentationIndex` because all segments should
     * be directly available.
     * @returns {boolean}
     */
    awaitSegmentBetween() {
      return false;
    }
    /**
     * Returns true if a Segment returned by this index is still considered
     * available.
     * @returns {Boolean}
     */
    isSegmentStillAvailable() {
      return true;
    }
    /**
     * We do not check for discontinuity in SegmentList-based indexes.
     * @returns {null}
     */
    checkDiscontinuity() {
      return null;
    }
    /**
     * SegmentList should not be updated.
     * @returns {Boolean}
     */
    canBeOutOfSyncError() {
      return false;
    }
    /**
     * @returns {Boolean}
     */
    isStillAwaitingFutureSegments() {
      return false;
    }
    /**
     * @returns {Boolean}
     */
    isInitialized() {
      return true;
    }
    initialize() {
      log_default.error("A `ListRepresentationIndex` does not need to be initialized");
    }
    addPredictedSegments() {
      log_default.warn("Cannot add predicted segments to a `ListRepresentationIndex`");
    }
    /**
     * @param {Object} newIndex
     */
    _replace(newIndex) {
      this._index = newIndex._index;
    }
    _update() {
      log_default.error("A `ListRepresentationIndex` cannot be updated");
    }
  };

  // src/parsers/manifest/dash/common/indexes/template.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/parsers/manifest/dash/common/indexes/utils.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function getSegmentTimeRoundingError(timescale) {
    return config_default.getCurrent().DEFAULT_MAXIMUM_TIME_ROUNDING_ERROR * timescale;
  }

  // src/parsers/manifest/dash/common/indexes/template.ts
  var TemplateRepresentationIndex = class {
    /**
     * @param {Object} index
     * @param {Object} context
     */
    constructor(index, context) {
      var _a, _b, _c;
      const {
        availabilityTimeOffset,
        manifestBoundsCalculator,
        isDynamic,
        periodEnd,
        periodStart,
        representationId,
        representationBitrate,
        isEMSGWhitelisted
      } = context;
      const timescale = (_a = index.timescale) != null ? _a : 1;
      this._availabilityTimeOffset = availabilityTimeOffset;
      this._manifestBoundsCalculator = manifestBoundsCalculator;
      const presentationTimeOffset = (_b = index.presentationTimeOffset) != null ? _b : 0;
      const scaledStart = periodStart * timescale;
      const indexTimeOffset = presentationTimeOffset - scaledStart;
      if (index.duration === void 0) {
        throw new Error("Invalid SegmentTemplate: no duration");
      }
      const initializationUrl = ((_c = index.initialization) == null ? void 0 : _c.media) === void 0 ? null : constructRepresentationUrl(
        index.initialization.media,
        representationId,
        representationBitrate
      );
      const segmentUrlTemplate = index.media === void 0 ? null : constructRepresentationUrl(
        index.media,
        representationId,
        representationBitrate
      );
      this._index = {
        duration: index.duration,
        timescale,
        indexRange: index.indexRange,
        indexTimeOffset,
        initialization: isNullOrUndefined(index.initialization) ? void 0 : { url: initializationUrl, range: index.initialization.range },
        url: segmentUrlTemplate,
        presentationTimeOffset,
        startNumber: index.startNumber,
        endNumber: index.endNumber
      };
      this._isDynamic = isDynamic;
      this._periodStart = periodStart;
      this._scaledRelativePeriodEnd = periodEnd === void 0 ? void 0 : (periodEnd - periodStart) * timescale;
      this._isEMSGWhitelisted = isEMSGWhitelisted;
    }
    /**
     * Construct init Segment.
     * @returns {Object}
     */
    getInitSegment() {
      return getInitSegment(this._index, this._isEMSGWhitelisted);
    }
    /**
     * @param {Number} fromTime
     * @param {Number} dur
     * @returns {Array.<Object>}
     */
    getSegments(fromTime, dur) {
      const index = this._index;
      const { duration, startNumber, endNumber, timescale, url } = index;
      const scaledStart = this._periodStart * timescale;
      const scaledEnd = this._scaledRelativePeriodEnd;
      const upFromPeriodStart = fromTime * timescale - scaledStart;
      const toFromPeriodStart = (fromTime + dur) * timescale - scaledStart;
      const firstSegmentStart = this._getFirstSegmentStart();
      const lastSegmentStart = this._getLastSegmentStart();
      if (isNullOrUndefined(firstSegmentStart) || isNullOrUndefined(lastSegmentStart)) {
        return [];
      }
      const startPosition = Math.max(firstSegmentStart, upFromPeriodStart);
      const lastWantedStartPosition = Math.min(lastSegmentStart, toFromPeriodStart);
      if (lastWantedStartPosition + duration <= startPosition) {
        return [];
      }
      const segments = [];
      const numberOffset = startNumber != null ? startNumber : 1;
      let numberIndexedToZero = Math.floor(startPosition / duration);
      for (let timeFromPeriodStart = numberIndexedToZero * duration; timeFromPeriodStart <= lastWantedStartPosition; timeFromPeriodStart += duration) {
        const realNumber = numberIndexedToZero + numberOffset;
        if (endNumber !== void 0 && realNumber > endNumber) {
          return segments;
        }
        const realDuration = !isNullOrUndefined(scaledEnd) && timeFromPeriodStart + duration > scaledEnd ? scaledEnd - timeFromPeriodStart : duration;
        const realTime = timeFromPeriodStart + scaledStart;
        const manifestTime = timeFromPeriodStart + this._index.presentationTimeOffset;
        const detokenizedURL = url === null ? null : createDashUrlDetokenizer(manifestTime, realNumber)(url);
        const args = {
          id: String(realNumber),
          number: realNumber,
          time: realTime / timescale,
          end: (realTime + realDuration) / timescale,
          duration: realDuration / timescale,
          timescale: 1,
          isInit: false,
          scaledDuration: realDuration / timescale,
          url: detokenizedURL,
          timestampOffset: -(index.indexTimeOffset / timescale),
          complete: true,
          privateInfos: {
            isEMSGWhitelisted: this._isEMSGWhitelisted
          }
        };
        segments.push(args);
        numberIndexedToZero++;
      }
      return segments;
    }
    /**
     * Returns first possible position in the index, in seconds.
     * @returns {number|null|undefined}
     */
    getFirstAvailablePosition() {
      const firstSegmentStart = this._getFirstSegmentStart();
      if (isNullOrUndefined(firstSegmentStart)) {
        return firstSegmentStart;
      }
      return firstSegmentStart / this._index.timescale + this._periodStart;
    }
    /**
     * Returns last possible position in the index, in seconds.
     * @returns {number|null}
     */
    getLastAvailablePosition() {
      const lastSegmentStart = this._getLastSegmentStart();
      if (isNullOrUndefined(lastSegmentStart)) {
        return lastSegmentStart;
      }
      const scaledRelativeIndexEnd = this._estimateRelativeScaledEnd();
      const lastSegmentEnd = Math.min(
        lastSegmentStart + this._index.duration,
        scaledRelativeIndexEnd != null ? scaledRelativeIndexEnd : Infinity
      );
      return lastSegmentEnd / this._index.timescale + this._periodStart;
    }
    /**
     * Returns the absolute end in seconds this RepresentationIndex can reach once
     * all segments are available.
     * @returns {number|null|undefined}
     */
    getEnd() {
      if (!this._isDynamic) {
        return this.getLastAvailablePosition();
      }
      const scaledRelativeIndexEnd = this._estimateRelativeScaledEnd();
      if (scaledRelativeIndexEnd === void 0) {
        return void 0;
      }
      const { timescale } = this._index;
      const absoluteScaledIndexEnd = scaledRelativeIndexEnd + this._periodStart * timescale;
      return absoluteScaledIndexEnd / timescale;
    }
    /**
     * Returns:
     *   - `true` if in the given time interval, at least one new segment is
     *     expected to be available in the future.
     *   - `false` either if all segments in that time interval are already
     *     available for download or if none will ever be available for it.
     *   - `undefined` when it is not possible to tell.
     *
     * Always `false` in a `BaseRepresentationIndex` because all segments should
     * be directly available.
     * @returns {boolean}
     */
    awaitSegmentBetween(start, end) {
      assert(start <= end);
      if (!this._isDynamic) {
        return false;
      }
      const { timescale } = this._index;
      const segmentTimeRounding = getSegmentTimeRoundingError(timescale);
      const scaledPeriodStart = this._periodStart * timescale;
      const scaledRelativeStart = start * timescale - scaledPeriodStart;
      const scaledRelativeEnd = end * timescale - scaledPeriodStart;
      const lastSegmentStart = this._getLastSegmentStart();
      if (isNullOrUndefined(lastSegmentStart)) {
        const relativeScaledIndexEnd2 = this._estimateRelativeScaledEnd();
        if (relativeScaledIndexEnd2 === void 0) {
          return scaledRelativeEnd + segmentTimeRounding >= 0;
        }
        return scaledRelativeEnd + segmentTimeRounding >= 0 && scaledRelativeStart < relativeScaledIndexEnd2 - segmentTimeRounding;
      }
      const lastSegmentEnd = lastSegmentStart + this._index.duration;
      const relativeScaledIndexEnd = this._estimateRelativeScaledEnd();
      if (relativeScaledIndexEnd === void 0) {
        return scaledRelativeEnd > lastSegmentEnd - segmentTimeRounding;
      }
      return scaledRelativeEnd > lastSegmentEnd - segmentTimeRounding && scaledRelativeStart < relativeScaledIndexEnd - segmentTimeRounding;
    }
    /**
     * Returns true if, based on the arguments, the index should be refreshed.
     * We never have to refresh a SegmentTemplate-based manifest.
     * @returns {Boolean}
     */
    shouldRefresh() {
      return false;
    }
    /**
     * We cannot check for discontinuity in SegmentTemplate-based indexes.
     * @returns {null}
     */
    checkDiscontinuity() {
      return null;
    }
    /**
     * Returns `true` if the given segment should still be available as of now
     * (not removed since and still request-able).
     * Returns `false` if that's not the case.
     * Returns `undefined` if we do not know whether that's the case or not.
     * @param {Object} segment
     * @returns {boolean|undefined}
     */
    isSegmentStillAvailable(segment) {
      if (segment.isInit) {
        return true;
      }
      const segmentsForTime = this.getSegments(segment.time, 0.1);
      if (segmentsForTime.length === 0) {
        return false;
      }
      return segmentsForTime[0].time === segment.time && segmentsForTime[0].end === segment.end && segmentsForTime[0].number === segment.number;
    }
    /**
     * SegmentTemplate without a SegmentTimeline should not be updated.
     * @returns {Boolean}
     */
    canBeOutOfSyncError() {
      return false;
    }
    /**
     * Returns `false` if the last segments in this index have already been
     * generated so that we can freely go to the next period.
     * Returns `true` if the index is still waiting on future segments to be
     * generated.
     * @returns {Boolean}
     */
    isStillAwaitingFutureSegments() {
      if (!this._isDynamic) {
        return false;
      }
      const scaledRelativeIndexEnd = this._estimateRelativeScaledEnd();
      if (scaledRelativeIndexEnd === void 0) {
        return true;
      }
      const { timescale } = this._index;
      const lastSegmentStart = this._getLastSegmentStart();
      if (isNullOrUndefined(lastSegmentStart)) {
        return true;
      }
      const lastSegmentEnd = lastSegmentStart + this._index.duration;
      const segmentTimeRounding = getSegmentTimeRoundingError(timescale);
      return lastSegmentEnd + segmentTimeRounding < scaledRelativeIndexEnd;
    }
    /**
     * @returns {Boolean}
     */
    isInitialized() {
      return true;
    }
    initialize() {
      log_default.error("A `TemplateRepresentationIndex` does not need to be initialized");
    }
    addPredictedSegments() {
      log_default.warn("Cannot add predicted segments to a `TemplateRepresentationIndex`");
    }
    /**
     * @param {Object} newIndex
     */
    _replace(newIndex) {
      this._index = newIndex._index;
      this._isDynamic = newIndex._isDynamic;
      this._periodStart = newIndex._periodStart;
      this._scaledRelativePeriodEnd = newIndex._scaledRelativePeriodEnd;
      this._manifestBoundsCalculator = newIndex._manifestBoundsCalculator;
    }
    /**
     * @param {Object} newIndex
     */
    _update(newIndex) {
      this._replace(newIndex);
    }
    /**
     * Returns the timescaled start of the first segment that should be available,
     * relatively to the start of the Period.
     * @returns {number | null | undefined}
     */
    _getFirstSegmentStart() {
      var _a;
      if (!this._isDynamic) {
        return 0;
      }
      if (this._scaledRelativePeriodEnd === 0 || this._scaledRelativePeriodEnd === void 0) {
        const maximumSegmentTime = this._manifestBoundsCalculator.getEstimatedMaximumPosition(
          (_a = this._availabilityTimeOffset) != null ? _a : 0
        );
        if (maximumSegmentTime !== void 0 && maximumSegmentTime < this._periodStart) {
          return null;
        }
      }
      const { duration, timescale } = this._index;
      const firstPosition = this._manifestBoundsCalculator.getEstimatedMinimumSegmentTime(
        duration / timescale
      );
      if (firstPosition === void 0) {
        return void 0;
      }
      const segmentTime = firstPosition > this._periodStart ? (firstPosition - this._periodStart) * timescale : 0;
      const numberIndexedToZero = Math.floor(segmentTime / duration);
      return numberIndexedToZero * duration;
    }
    /**
     * Returns the timescaled start of the last segment that should be available,
     * relatively to the start of the Period.
     * Returns null if live time is before current period.
     * @returns {number|null|undefined}
     */
    _getLastSegmentStart() {
      var _a, _b;
      const { duration, timescale, endNumber, startNumber = 1 } = this._index;
      if (this._isDynamic) {
        const liveEdge = this._manifestBoundsCalculator.getEstimatedLiveEdge();
        if (liveEdge !== void 0 && this._scaledRelativePeriodEnd !== void 0 && this._scaledRelativePeriodEnd < liveEdge - this._periodStart * this._index.timescale) {
          let numberOfSegments = Math.ceil(this._scaledRelativePeriodEnd / duration);
          if (endNumber !== void 0 && endNumber - startNumber + 1 < numberOfSegments) {
            numberOfSegments = endNumber - startNumber + 1;
          }
          return (numberOfSegments - 1) * duration;
        }
        const lastPosition = this._manifestBoundsCalculator.getEstimatedMaximumPosition(
          (_a = this._availabilityTimeOffset) != null ? _a : 0
        );
        if (lastPosition === void 0) {
          return void 0;
        }
        const scaledLastPosition = (lastPosition - this._periodStart) * timescale;
        if (scaledLastPosition < 0) {
          return null;
        }
        let numberOfSegmentsAvailable = Math.floor(scaledLastPosition / duration);
        if (endNumber !== void 0 && endNumber - startNumber + 1 < numberOfSegmentsAvailable) {
          numberOfSegmentsAvailable = endNumber - startNumber + 1;
        }
        return numberOfSegmentsAvailable <= 0 ? null : (numberOfSegmentsAvailable - 1) * duration;
      } else {
        const maximumTime = (_b = this._scaledRelativePeriodEnd) != null ? _b : 0;
        let numberOfSegments = Math.ceil(maximumTime / duration);
        if (endNumber !== void 0 && endNumber - startNumber + 1 < numberOfSegments) {
          numberOfSegments = endNumber - startNumber + 1;
        }
        const regularLastSegmentStart = (numberOfSegments - 1) * duration;
        const minimumDuration = config_default.getCurrent().MINIMUM_SEGMENT_SIZE * timescale;
        if (endNumber !== void 0 || maximumTime - regularLastSegmentStart > minimumDuration || numberOfSegments < 2) {
          return regularLastSegmentStart;
        }
        return (numberOfSegments - 2) * duration;
      }
    }
    /**
     * Returns an estimate of the last available position in this
     * `RepresentationIndex` based on attributes such as the Period's end and
     * the `endNumber` attribute.
     * If the estimate cannot be made (e.g. this Period's segments are still being
     * generated and its end is yet unknown), returns `undefined`.
     * @returns {number|undefined}
     */
    _estimateRelativeScaledEnd() {
      var _a, _b;
      if (this._index.endNumber !== void 0) {
        const numberOfSegments = this._index.endNumber - ((_a = this._index.startNumber) != null ? _a : 1) + 1;
        return Math.max(
          Math.min(
            numberOfSegments * this._index.duration,
            (_b = this._scaledRelativePeriodEnd) != null ? _b : Infinity
          ),
          0
        );
      }
      if (this._scaledRelativePeriodEnd === void 0) {
        return void 0;
      }
      return Math.max(this._scaledRelativePeriodEnd, 0);
    }
  };

  // src/parsers/manifest/dash/common/indexes/timeline/index.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/parsers/manifest/dash/common/indexes/timeline/timeline_representation_index.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/parsers/manifest/utils/clear_timeline_from_position.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function clearTimelineFromPosition(timeline, firstAvailablePosition) {
    let nbEltsRemoved = 0;
    while (timeline.length > 0) {
      const firstElt = timeline[0];
      if (firstElt.start >= firstAvailablePosition) {
        return nbEltsRemoved;
      }
      if (firstElt.repeatCount === -1) {
        return nbEltsRemoved;
      } else if (firstElt.repeatCount === 0) {
        timeline.shift();
        nbEltsRemoved += 1;
      } else {
        const nextElt = timeline[1];
        if (nextElt !== void 0 && nextElt.start <= firstAvailablePosition) {
          timeline.shift();
          nbEltsRemoved += 1;
        } else {
          if (firstElt.duration <= 0) {
            return nbEltsRemoved;
          }
          let nextStart = firstElt.start + firstElt.duration;
          let nextRepeat = 1;
          while (nextStart < firstAvailablePosition && nextRepeat <= firstElt.repeatCount) {
            nextStart += firstElt.duration;
            nextRepeat++;
          }
          if (nextRepeat > firstElt.repeatCount) {
            timeline.shift();
            nbEltsRemoved = firstElt.repeatCount + 1;
          } else {
            const newRepeat = firstElt.repeatCount - nextRepeat;
            firstElt.start = nextStart;
            firstElt.repeatCount = newRepeat;
            nbEltsRemoved += nextRepeat;
            return nbEltsRemoved;
          }
        }
      }
    }
    return nbEltsRemoved;
  }

  // src/parsers/manifest/utils/update_segment_timeline.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function updateSegmentTimeline(oldTimeline, newTimeline) {
    if (oldTimeline.length === 0) {
      oldTimeline.push(...newTimeline);
      return true;
    } else if (newTimeline.length === 0) {
      return false;
    }
    const prevTimelineLength = oldTimeline.length;
    const newIndexStart = newTimeline[0].start;
    const oldLastElt = oldTimeline[prevTimelineLength - 1];
    const oldIndexEnd = getIndexSegmentEnd(oldLastElt, newTimeline[0]);
    if (oldIndexEnd < newIndexStart) {
      throw new MediaError(
        "MANIFEST_UPDATE_ERROR",
        "Cannot perform partial update: not enough data"
      );
    }
    for (let i = prevTimelineLength - 1; i >= 0; i--) {
      const currStart = oldTimeline[i].start;
      if (currStart === newIndexStart) {
        const nbEltsToRemove = prevTimelineLength - i;
        oldTimeline.splice(i, nbEltsToRemove, ...newTimeline);
        return false;
      } else if (currStart < newIndexStart) {
        const currElt = oldTimeline[i];
        if (currElt.start + currElt.duration > newIndexStart) {
          log_default.warn("RepresentationIndex: Manifest update removed all previous segments");
          oldTimeline.splice(0, prevTimelineLength, ...newTimeline);
          return true;
        } else if (currElt.repeatCount === void 0 || currElt.repeatCount <= 0) {
          if (currElt.repeatCount < 0) {
            currElt.repeatCount = Math.floor((newIndexStart - currElt.start) / currElt.duration) - 1;
          }
          oldTimeline.splice(i + 1, prevTimelineLength - (i + 1), ...newTimeline);
          return false;
        }
        const eltLastTime = currElt.start + currElt.duration * (currElt.repeatCount + 1);
        if (eltLastTime <= newIndexStart) {
          oldTimeline.splice(i + 1, prevTimelineLength - (i + 1), ...newTimeline);
          return false;
        }
        const newCurrRepeat = (newIndexStart - currElt.start) / currElt.duration - 1;
        if (newCurrRepeat % 1 === 0 && currElt.duration === newTimeline[0].duration) {
          const newRepeatCount = newTimeline[0].repeatCount < 0 ? -1 : newTimeline[0].repeatCount + newCurrRepeat + 1;
          oldTimeline.splice(i, prevTimelineLength - i, ...newTimeline);
          oldTimeline[i].start = currElt.start;
          oldTimeline[i].repeatCount = newRepeatCount;
          return false;
        }
        log_default.warn("RepresentationIndex: Manifest update removed previous segments");
        oldTimeline[i].repeatCount = Math.floor(newCurrRepeat);
        oldTimeline.splice(i + 1, prevTimelineLength - (i + 1), ...newTimeline);
        return false;
      }
    }
    const prevLastElt = oldTimeline[oldTimeline.length - 1];
    const newLastElt = newTimeline[newTimeline.length - 1];
    if (prevLastElt.repeatCount !== void 0 && prevLastElt.repeatCount < 0) {
      if (prevLastElt.start > newLastElt.start) {
        log_default.warn("RepresentationIndex: The new index is older than the previous one");
        return false;
      } else {
        log_default.warn('RepresentationIndex: The new index is "bigger" than the previous one');
        oldTimeline.splice(0, prevTimelineLength, ...newTimeline);
        return true;
      }
    }
    const prevLastTime = prevLastElt.start + prevLastElt.duration * (prevLastElt.repeatCount + 1);
    const newLastTime = newLastElt.start + newLastElt.duration * (newLastElt.repeatCount + 1);
    if (prevLastTime >= newLastTime) {
      log_default.warn("RepresentationIndex: The new index is older than the previous one");
      return false;
    }
    log_default.warn('RepresentationIndex: The new index is "bigger" than the previous one');
    oldTimeline.splice(0, prevTimelineLength, ...newTimeline);
    return true;
  }

  // src/parsers/manifest/dash/common/indexes/timeline/construct_timeline_from_elements.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/parsers/manifest/dash/common/indexes/timeline/convert_element_to_index_segment.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function convertElementsToIndexSegment(item, previousItem, nextItem) {
    let start = item.start;
    let duration = item.duration;
    const repeatCount = item.repeatCount;
    if (start === void 0) {
      if (previousItem === null) {
        start = 0;
      } else if (!isNullOrUndefined(previousItem.duration)) {
        start = previousItem.start + previousItem.duration * (previousItem.repeatCount + 1);
      }
    }
    if ((duration === void 0 || isNaN(duration)) && nextItem !== null && nextItem.start !== void 0 && !isNaN(nextItem.start) && start !== void 0 && !isNaN(start)) {
      duration = nextItem.start - start;
    }
    if (start !== void 0 && !isNaN(start) && duration !== void 0 && !isNaN(duration) && (repeatCount === void 0 || !isNaN(repeatCount))) {
      return {
        start,
        duration,
        repeatCount: repeatCount === void 0 ? 0 : repeatCount
      };
    }
    log_default.warn('DASH: A "S" Element could not have been parsed.');
    return null;
  }

  // src/parsers/manifest/dash/common/indexes/timeline/parse_s_element.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function parseSElementNode(root) {
    const parsedS = {};
    for (const attributeName of Object.keys(root.attributes)) {
      const attributeVal = root.attributes[attributeName];
      if (isNullOrUndefined(attributeVal)) {
        continue;
      }
      switch (attributeName) {
        case "t": {
          const start = parseInt(attributeVal, 10);
          if (isNaN(start)) {
            log_default.warn(`DASH: invalid t ("${attributeVal}")`);
          } else {
            parsedS.start = start;
          }
          break;
        }
        case "d": {
          const duration = parseInt(attributeVal, 10);
          if (isNaN(duration)) {
            log_default.warn(`DASH: invalid d ("${attributeVal}")`);
          } else {
            parsedS.duration = duration;
          }
          break;
        }
        case "r": {
          const repeatCount = parseInt(attributeVal, 10);
          if (isNaN(repeatCount)) {
            log_default.warn(`DASH: invalid r ("${attributeVal}")`);
          } else {
            parsedS.repeatCount = repeatCount;
          }
          break;
        }
      }
    }
    return parsedS;
  }
  function parseSHTMLElement(root) {
    const parsedS = {};
    for (let j = 0; j < root.attributes.length; j++) {
      const attribute = root.attributes[j];
      switch (attribute.name) {
        case "t": {
          const start = parseInt(attribute.value, 10);
          if (isNaN(start)) {
            log_default.warn(`DASH: invalid t ("${attribute.value}")`);
          } else {
            parsedS.start = start;
          }
          break;
        }
        case "d": {
          const duration = parseInt(attribute.value, 10);
          if (isNaN(duration)) {
            log_default.warn(`DASH: invalid d ("${attribute.value}")`);
          } else {
            parsedS.duration = duration;
          }
          break;
        }
        case "r": {
          const repeatCount = parseInt(attribute.value, 10);
          if (isNaN(repeatCount)) {
            log_default.warn(`DASH: invalid r ("${attribute.value}")`);
          } else {
            parsedS.repeatCount = repeatCount;
          }
          break;
        }
      }
    }
    return parsedS;
  }

  // src/parsers/manifest/dash/common/indexes/timeline/construct_timeline_from_elements.ts
  function constructTimelineFromElements(elements) {
    const initialTimeline = [];
    if (Array.isArray(elements)) {
      for (let i = 0; i < elements.length; i++) {
        initialTimeline.push(parseSElementNode(elements[i]));
      }
    } else {
      for (let i = 0; i < elements.length; i++) {
        initialTimeline.push(parseSHTMLElement(elements[i]));
      }
    }
    const timeline = [];
    for (let i = 0; i < initialTimeline.length; i++) {
      const item = initialTimeline[i];
      const previousItem = timeline[timeline.length - 1] === void 0 ? null : timeline[timeline.length - 1];
      const nextItem = initialTimeline[i + 1] === void 0 ? null : initialTimeline[i + 1];
      const timelineElement = convertElementsToIndexSegment(item, previousItem, nextItem);
      if (timelineElement !== null) {
        timeline.push(timelineElement);
      }
    }
    return timeline;
  }

  // src/parsers/manifest/dash/common/indexes/timeline/construct_timeline_from_previous_timeline.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/parsers/manifest/dash/common/indexes/timeline/find_first_common_start_time.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function findFirstCommonStartTime(prevTimeline, newElements) {
    if (prevTimeline.length === 0 || newElements.length === 0) {
      return null;
    }
    const prevInitialStart = prevTimeline[0].start;
    const newFirstTAttr = Array.isArray(newElements) ? newElements[0].attributes.t : newElements[0].getAttribute("t");
    const newInitialStart = isNullOrUndefined(newFirstTAttr) ? null : parseInt(newFirstTAttr, 10);
    if (newInitialStart === null || Number.isNaN(newInitialStart)) {
      return null;
    }
    if (prevInitialStart === newInitialStart) {
      return {
        prevSegmentsIdx: 0,
        newElementsIdx: 0,
        repeatNumberInPrevSegments: 0,
        repeatNumberInNewElements: 0
      };
    } else if (prevInitialStart < newInitialStart) {
      let prevElt = prevTimeline[0];
      let prevElementIndex = 0;
      while (true) {
        if (prevElt.repeatCount > 0) {
          const diff = newInitialStart - prevElt.start;
          if (diff % prevElt.duration === 0 && diff / prevElt.duration <= prevElt.repeatCount) {
            const repeatNumberInPrevSegments = diff / prevElt.duration;
            return {
              repeatNumberInPrevSegments,
              prevSegmentsIdx: prevElementIndex,
              newElementsIdx: 0,
              repeatNumberInNewElements: 0
            };
          }
        }
        prevElementIndex++;
        if (prevElementIndex >= prevTimeline.length) {
          return null;
        }
        prevElt = prevTimeline[prevElementIndex];
        if (prevElt.start === newInitialStart) {
          return {
            prevSegmentsIdx: prevElementIndex,
            newElementsIdx: 0,
            repeatNumberInPrevSegments: 0,
            repeatNumberInNewElements: 0
          };
        } else if (prevElt.start > newInitialStart) {
          return null;
        }
      }
    } else {
      let newElementsIdx = 0;
      let newNodeElt = Array.isArray(newElements) ? newElements[0] : null;
      let newDomElt = Array.isArray(newElements) ? null : newElements[0];
      let currentTimeOffset = newInitialStart;
      while (true) {
        const dAttr = newNodeElt !== null ? newNodeElt.attributes.d : newDomElt == null ? void 0 : newDomElt.getAttribute("d");
        const duration = isNullOrUndefined(dAttr) ? null : parseInt(dAttr, 10);
        if (duration === null || Number.isNaN(duration)) {
          return null;
        }
        const rAttr = newNodeElt !== null ? newNodeElt.attributes.r : newDomElt == null ? void 0 : newDomElt.getAttribute("r");
        const repeatCount = isNullOrUndefined(rAttr) ? null : parseInt(rAttr, 10);
        if (repeatCount !== null) {
          if (Number.isNaN(repeatCount) || repeatCount < 0) {
            return null;
          }
          if (repeatCount > 0) {
            const diff = prevInitialStart - currentTimeOffset;
            if (diff % duration === 0 && diff / duration <= repeatCount) {
              const repeatNumberInNewElements = diff / duration;
              return {
                repeatNumberInPrevSegments: 0,
                repeatNumberInNewElements,
                prevSegmentsIdx: 0,
                newElementsIdx
              };
            }
          }
          currentTimeOffset += duration * (repeatCount + 1);
        } else {
          currentTimeOffset += duration;
        }
        newElementsIdx++;
        if (newElementsIdx >= newElements.length) {
          return null;
        }
        if (Array.isArray(newElements)) {
          newNodeElt = newElements[newElementsIdx];
        } else {
          newDomElt = newElements[newElementsIdx];
        }
        const tAttr = newNodeElt !== null ? newNodeElt.attributes.t : newDomElt == null ? void 0 : newDomElt.getAttribute("t");
        const time = isNullOrUndefined(tAttr) ? null : parseInt(tAttr, 10);
        if (time !== null) {
          if (Number.isNaN(time)) {
            return null;
          }
          currentTimeOffset = time;
        }
        if (currentTimeOffset === prevInitialStart) {
          return {
            newElementsIdx,
            prevSegmentsIdx: 0,
            repeatNumberInPrevSegments: 0,
            repeatNumberInNewElements: 0
          };
        } else if (currentTimeOffset > newInitialStart) {
          return null;
        }
      }
    }
  }

  // src/parsers/manifest/dash/common/indexes/timeline/construct_timeline_from_previous_timeline.ts
  function constructTimelineFromPreviousTimeline(newElements, prevTimeline) {
    var _a;
    const commonStartInfo = findFirstCommonStartTime(prevTimeline, newElements);
    if (commonStartInfo === null) {
      log_default.warn('DASH: Cannot perform "based" update. Common segment not found.');
      return constructTimelineFromElements(newElements);
    }
    const {
      prevSegmentsIdx,
      newElementsIdx,
      repeatNumberInPrevSegments,
      repeatNumberInNewElements
    } = commonStartInfo;
    const numberCommonEltGuess = prevTimeline.length - prevSegmentsIdx;
    const lastCommonEltNewEltsIdx = numberCommonEltGuess + newElementsIdx - 1;
    if (lastCommonEltNewEltsIdx >= newElements.length) {
      log_default.info('DASH: Cannot perform "based" update. New timeline too short');
      return constructTimelineFromElements(newElements);
    }
    const newTimeline = prevTimeline.slice(prevSegmentsIdx);
    if (repeatNumberInPrevSegments > 0) {
      const commonEltInOldTimeline = newTimeline[0];
      commonEltInOldTimeline.start += commonEltInOldTimeline.duration * repeatNumberInPrevSegments;
      newTimeline[0].repeatCount -= repeatNumberInPrevSegments;
    }
    if (repeatNumberInNewElements > 0 && newElementsIdx !== 0) {
      log_default.info(
        'DASH: Cannot perform "based" update. The new timeline has a different form.'
      );
      return constructTimelineFromElements(newElements);
    }
    const prevLastElement = newTimeline[newTimeline.length - 1];
    const newCommonElt = Array.isArray(newElements) ? parseSElementNode(newElements[lastCommonEltNewEltsIdx]) : parseSHTMLElement(newElements[lastCommonEltNewEltsIdx]);
    const newRepeatCountOffseted = ((_a = newCommonElt.repeatCount) != null ? _a : 0) - repeatNumberInNewElements;
    if (newCommonElt.duration !== prevLastElement.duration || prevLastElement.repeatCount > newRepeatCountOffseted) {
      log_default.info(
        'DASH: Cannot perform "based" update. The new timeline has a different form at the beginning.'
      );
      return constructTimelineFromElements(newElements);
    }
    if (newCommonElt.repeatCount !== void 0 && newCommonElt.repeatCount > prevLastElement.repeatCount) {
      prevLastElement.repeatCount = newCommonElt.repeatCount;
    }
    const newEltsToPush = [];
    const items = [];
    if (Array.isArray(newElements)) {
      for (let i = lastCommonEltNewEltsIdx + 1; i < newElements.length; i++) {
        items.push(parseSElementNode(newElements[i]));
      }
    } else {
      for (let i = lastCommonEltNewEltsIdx + 1; i < newElements.length; i++) {
        items.push(parseSHTMLElement(newElements[i]));
      }
    }
    for (let i = 0; i < items.length; i++) {
      const item = items[i];
      const previousItem = newEltsToPush[newEltsToPush.length - 1] === void 0 ? prevLastElement : newEltsToPush[newEltsToPush.length - 1];
      const nextItem = items[i + 1] === void 0 ? null : items[i + 1];
      const timelineElement = convertElementsToIndexSegment(item, previousItem, nextItem);
      if (timelineElement !== null) {
        newEltsToPush.push(timelineElement);
      }
    }
    return newTimeline.concat(newEltsToPush);
  }

  // src/parsers/manifest/dash/common/indexes/timeline/timeline_representation_index.ts
  var TimelineRepresentationIndex = class _TimelineRepresentationIndex {
    /**
     * @param {Object} index
     * @param {Object} context
     */
    constructor(index, context) {
      var _a, _b, _c, _d, _e;
      if (!_TimelineRepresentationIndex.isTimelineIndexArgument(index)) {
        throw new Error(
          "The given index is not compatible with a TimelineRepresentationIndex."
        );
      }
      const {
        availabilityTimeComplete,
        availabilityTimeOffset,
        manifestBoundsCalculator,
        isDynamic,
        isLastPeriod,
        representationId,
        representationBitrate,
        periodStart,
        periodEnd,
        isEMSGWhitelisted
      } = context;
      const timescale = (_a = index.timescale) != null ? _a : 1;
      const presentationTimeOffset = (_b = index.presentationTimeOffset) != null ? _b : 0;
      const scaledStart = periodStart * timescale;
      const indexTimeOffset = presentationTimeOffset - scaledStart;
      this._manifestBoundsCalculator = manifestBoundsCalculator;
      this._isEMSGWhitelisted = isEMSGWhitelisted;
      this._isLastPeriod = isLastPeriod;
      this._lastUpdate = (_c = context.receivedTime) != null ? _c : monotonic_timestamp_default();
      this._unsafelyBaseOnPreviousIndex = null;
      if (context.unsafelyBaseOnPreviousRepresentation !== null && context.unsafelyBaseOnPreviousRepresentation.index instanceof _TimelineRepresentationIndex) {
        context.unsafelyBaseOnPreviousRepresentation.index._unsafelyBaseOnPreviousIndex = null;
        this._unsafelyBaseOnPreviousIndex = context.unsafelyBaseOnPreviousRepresentation.index;
      }
      this._isDynamic = isDynamic;
      this._parseTimeline = (_d = index.timelineParser) != null ? _d : null;
      const initializationUrl = ((_e = index.initialization) == null ? void 0 : _e.media) === void 0 ? null : constructRepresentationUrl(
        index.initialization.media,
        representationId,
        representationBitrate
      );
      const segmentUrlTemplate = index.media === void 0 ? null : constructRepresentationUrl(
        index.media,
        representationId,
        representationBitrate
      );
      let actualAvailabilityTimeOffset;
      if (availabilityTimeOffset === void 0 && availabilityTimeComplete === void 0) {
        actualAvailabilityTimeOffset = Infinity;
      } else {
        actualAvailabilityTimeOffset = availabilityTimeOffset != null ? availabilityTimeOffset : 0;
      }
      this._index = {
        availabilityTimeComplete: availabilityTimeComplete != null ? availabilityTimeComplete : true,
        availabilityTimeOffset: actualAvailabilityTimeOffset,
        indexRange: index.indexRange,
        indexTimeOffset,
        initialization: isNullOrUndefined(index.initialization) ? void 0 : {
          url: initializationUrl,
          range: index.initialization.range
        },
        segmentUrlTemplate,
        startNumber: index.startNumber,
        endNumber: index.endNumber,
        timeline: index.timeline === void 0 ? null : updateTimelineFromEndNumber(
          index.timeline,
          index.startNumber,
          index.endNumber
        ),
        timescale
      };
      this._scaledPeriodStart = toIndexTime(periodStart, this._index);
      this._scaledPeriodEnd = periodEnd === void 0 ? void 0 : toIndexTime(periodEnd, this._index);
    }
    /**
     * Construct init Segment.
     * @returns {Object}
     */
    getInitSegment() {
      return getInitSegment(this._index, this._isEMSGWhitelisted);
    }
    /**
     * Asks for segments to download for a given time range.
     * @param {Number} from - Beginning of the time wanted, in seconds
     * @param {Number} duration - duration wanted, in seconds
     * @returns {Array.<Object>}
     */
    getSegments(from, duration) {
      this._refreshTimeline();
      if (this._index.timeline === null) {
        this._index.timeline = this._getTimeline();
      }
      return getSegmentsFromTimeline(
        this._index,
        from,
        duration,
        this._manifestBoundsCalculator,
        this._scaledPeriodEnd,
        this._isEMSGWhitelisted
      );
    }
    /**
     * Returns true if the index should be refreshed.
     * @returns {Boolean}
     */
    shouldRefresh() {
      return false;
    }
    /**
     * Returns the starting time, in seconds, of the earliest segment currently
     * available.
     * Returns null if nothing is in the index
     * @returns {Number|null}
     */
    getFirstAvailablePosition() {
      this._refreshTimeline();
      if (this._index.timeline === null) {
        this._index.timeline = this._getTimeline();
      }
      const timeline = this._index.timeline;
      return timeline.length === 0 ? null : fromIndexTime(Math.max(this._scaledPeriodStart, timeline[0].start), this._index);
    }
    /**
     * Returns the ending time, in seconds, of the last segment currently
     * available.
     * Returns null if nothing is in the index
     * @returns {Number|null}
     */
    getLastAvailablePosition() {
      var _a;
      this._refreshTimeline();
      if (this._index.timeline === null) {
        this._index.timeline = this._getTimeline();
      }
      const lastReqSegInfo = getLastRequestableSegmentInfo(
        // Needed typecast for TypeScript
        this._index,
        this._manifestBoundsCalculator,
        this._scaledPeriodEnd
      );
      if (lastReqSegInfo === null) {
        return null;
      }
      const lastScaledPosition = Math.min(
        lastReqSegInfo.end,
        (_a = this._scaledPeriodEnd) != null ? _a : Infinity
      );
      return fromIndexTime(lastScaledPosition, this._index);
    }
    /**
     * Returns the absolute end in seconds this RepresentationIndex can reach once
     * all segments are available.
     * @returns {number|null|undefined}
     */
    getEnd() {
      var _a;
      if (this._isDynamic && !this._isLastPeriod) {
        return void 0;
      }
      this._refreshTimeline();
      if (this._index.timeline === null) {
        this._index.timeline = this._getTimeline();
      }
      if (this._index.timeline.length <= 0) {
        return null;
      }
      const lastSegment = this._index.timeline[this._index.timeline.length - 1];
      const lastTime = Math.min(
        getIndexSegmentEnd(lastSegment, null, this._scaledPeriodEnd),
        (_a = this._scaledPeriodEnd) != null ? _a : Infinity
      );
      return fromIndexTime(lastTime, this._index);
    }
    /**
     * Returns:
     *   - `true` if in the given time interval, at least one new segment is
     *     expected to be available in the future.
     *   - `false` either if all segments in that time interval are already
     *     available for download or if none will ever be available for it.
     *   - `undefined` when it is not possible to tell.
     * @param {number} start
     * @param {number} end
     * @returns {boolean|undefined}
     */
    awaitSegmentBetween(start, end) {
      var _a, _b;
      assert(start <= end);
      if (!this._isDynamic) {
        return false;
      }
      this._refreshTimeline();
      if (this._index.timeline === null) {
        this._index.timeline = this._getTimeline();
      }
      const { timescale, timeline } = this._index;
      const segmentTimeRounding = getSegmentTimeRoundingError(timescale);
      const scaledWantedEnd = toIndexTime(end, this._index);
      const lastReqSegInfo = getLastRequestableSegmentInfo(
        // Needed typecast for TypeScript
        this._index,
        this._manifestBoundsCalculator,
        this._scaledPeriodEnd
      );
      if (lastReqSegInfo !== null) {
        const lastReqSegmentEnd = Math.min(
          lastReqSegInfo.end,
          (_a = this._scaledPeriodEnd) != null ? _a : Infinity
        );
        const roundedReqSegmentEnd = lastReqSegmentEnd + segmentTimeRounding;
        if (roundedReqSegmentEnd >= Math.min(scaledWantedEnd, (_b = this._scaledPeriodEnd) != null ? _b : Infinity)) {
          return false;
        }
      }
      const scaledWantedStart = toIndexTime(start, this._index);
      if (timeline.length > 0 && lastReqSegInfo !== null && !lastReqSegInfo.isLastOfTimeline) {
        const lastSegment = timeline[timeline.length - 1];
        const lastSegmentEnd = getIndexSegmentEnd(lastSegment, null, this._scaledPeriodEnd);
        const roundedLastSegEnd = lastSegmentEnd + segmentTimeRounding;
        if (scaledWantedStart < roundedLastSegEnd + segmentTimeRounding) {
          return true;
        }
      }
      if (!this._isLastPeriod) {
        return false;
      }
      if (this._scaledPeriodEnd === void 0) {
        return scaledWantedEnd + segmentTimeRounding > this._scaledPeriodStart ? void 0 : false;
      }
      return scaledWantedStart - segmentTimeRounding < this._scaledPeriodEnd && scaledWantedEnd + segmentTimeRounding > this._scaledPeriodStart;
    }
    /**
     * Returns true if a Segment returned by this index is still considered
     * available.
     * Returns false if it is not available anymore.
     * Returns undefined if we cannot know whether it is still available or not.
     * @param {Object} segment
     * @returns {Boolean|undefined}
     */
    isSegmentStillAvailable(segment) {
      if (segment.isInit) {
        return true;
      }
      this._refreshTimeline();
      if (this._index.timeline === null) {
        this._index.timeline = this._getTimeline();
      }
      return isSegmentStillAvailable(
        segment,
        // Needed typecast for TypeScript
        this._index,
        this._manifestBoundsCalculator,
        this._scaledPeriodEnd
      );
    }
    /**
     * Checks if the time given is in a discontinuity. That is:
     *   - We're on the upper bound of the current range (end of the range - time
     *     is inferior to the timescale)
     *   - The next range starts after the end of the current range.
     * @param {Number} time
     * @returns {Number|null}
     */
    checkDiscontinuity(time) {
      this._refreshTimeline();
      let timeline = this._index.timeline;
      if (timeline === null) {
        timeline = this._getTimeline();
        this._index.timeline = timeline;
      }
      return checkDiscontinuity(
        {
          timeline,
          timescale: this._index.timescale,
          indexTimeOffset: this._index.indexTimeOffset
        },
        time,
        this._scaledPeriodEnd
      );
    }
    /**
     * @param {Error} error
     * @returns {Boolean}
     */
    canBeOutOfSyncError(error) {
      if (!this._isDynamic) {
        return false;
      }
      return error instanceof NetworkError && error.isHttpError(404);
    }
    /**
     * Replace this RepresentationIndex with one from a new version of the
     * Manifest.
     * @param {Object} newIndex
     */
    _replace(newIndex) {
      this._parseTimeline = newIndex._parseTimeline;
      this._index = newIndex._index;
      this._isDynamic = newIndex._isDynamic;
      this._scaledPeriodStart = newIndex._scaledPeriodStart;
      this._scaledPeriodEnd = newIndex._scaledPeriodEnd;
      this._lastUpdate = newIndex._lastUpdate;
      this._manifestBoundsCalculator = newIndex._manifestBoundsCalculator;
      this._isLastPeriod = newIndex._isLastPeriod;
    }
    /**
     * Update this RepresentationIndex with a shorter version of it coming from a
     * new version of the MPD.
     * @param {Object} newIndex
     */
    _update(newIndex) {
      if (this._index.timeline === null) {
        this._index.timeline = this._getTimeline();
      }
      if (newIndex._index.timeline === null) {
        newIndex._index.timeline = newIndex._getTimeline();
      }
      const hasReplaced = updateSegmentTimeline(
        this._index.timeline,
        newIndex._index.timeline
      );
      if (hasReplaced) {
        this._index.startNumber = newIndex._index.startNumber;
      }
      this._index.availabilityTimeOffset = newIndex._index.availabilityTimeOffset;
      this._index.availabilityTimeComplete = newIndex._index.availabilityTimeComplete;
      this._index.endNumber = newIndex._index.endNumber;
      this._isDynamic = newIndex._isDynamic;
      this._scaledPeriodStart = newIndex._scaledPeriodStart;
      this._scaledPeriodEnd = newIndex._scaledPeriodEnd;
      this._lastUpdate = newIndex._lastUpdate;
      this._isLastPeriod = newIndex._isLastPeriod;
    }
    /**
     * Returns `false` if this RepresentationIndex currently contains its last
     * segment.
     * Returns `true` if it's still pending.
     * @returns {Boolean}
     */
    isStillAwaitingFutureSegments() {
      var _a;
      if (!this._isDynamic) {
        return false;
      }
      this._refreshTimeline();
      if (this._index.timeline === null) {
        this._index.timeline = this._getTimeline();
      }
      const { timeline } = this._index;
      if (timeline.length === 0) {
        if (this._scaledPeriodEnd !== void 0) {
          const liveEdge = this._manifestBoundsCalculator.getEstimatedLiveEdge();
          if (liveEdge !== void 0 && toIndexTime(liveEdge, this._index) > this._scaledPeriodEnd) {
            return false;
          }
        }
        return this._isLastPeriod;
      }
      const segmentTimeRounding = getSegmentTimeRoundingError(this._index.timescale);
      const lastReqSegInfo = getLastRequestableSegmentInfo(
        // Needed typecast for TypeScript
        this._index,
        this._manifestBoundsCalculator,
        this._scaledPeriodEnd
      );
      if (lastReqSegInfo !== null && !lastReqSegInfo.isLastOfTimeline) {
        const lastReqSegmentEnd = Math.min(
          lastReqSegInfo.end,
          (_a = this._scaledPeriodEnd) != null ? _a : Infinity
        );
        if (this._scaledPeriodEnd !== void 0 && lastReqSegmentEnd + segmentTimeRounding >= this._scaledPeriodEnd) {
          return false;
        }
        return true;
      }
      if (!this._isLastPeriod) {
        return false;
      }
      if (this._scaledPeriodEnd === void 0) {
        return true;
      }
      const lastSegment = timeline[timeline.length - 1];
      const lastSegmentEnd = getIndexSegmentEnd(lastSegment, null, this._scaledPeriodEnd);
      return lastSegmentEnd + segmentTimeRounding < this._scaledPeriodEnd;
    }
    /**
     * @returns {Boolean}
     */
    isInitialized() {
      return true;
    }
    initialize() {
      log_default.error("A `TimelineRepresentationIndex` does not need to be initialized");
    }
    addPredictedSegments() {
      log_default.warn("Cannot add predicted segments to a `TimelineRepresentationIndex`");
    }
    /**
     * Returns `true` if the given object can be used as an "index" argument to
     * create a new `TimelineRepresentationIndex`.
     * @param {Object} index
     * @returns {boolean}
     */
    static isTimelineIndexArgument(index) {
      return typeof index.timelineParser === "function" || Array.isArray(index.timeline);
    }
    /**
     * Clean-up timeline to remove segment information which should not be
     * available due to timeshifting.
     */
    _refreshTimeline() {
      var _a, _b;
      if (this._index.timeline === null) {
        this._index.timeline = this._getTimeline();
      }
      if (!this._isDynamic) {
        return;
      }
      const firstPosition = this._manifestBoundsCalculator.getEstimatedMinimumSegmentTime(
        ((_b = (_a = this._index.timeline[0]) == null ? void 0 : _a.duration) != null ? _b : 0) / this._index.timescale
      );
      if (isNullOrUndefined(firstPosition)) {
        return;
      }
      const scaledFirstPosition = toIndexTime(firstPosition, this._index);
      const nbEltsRemoved = clearTimelineFromPosition(
        this._index.timeline,
        scaledFirstPosition
      );
      if (this._index.startNumber !== void 0) {
        this._index.startNumber += nbEltsRemoved;
      } else if (this._index.endNumber !== void 0) {
        this._index.startNumber = nbEltsRemoved + 1;
      }
    }
    /**
     * Allows to generate the "timeline" for this RepresentationIndex.
     * Call this function when the timeline is unknown.
     * This function was added to only perform that task lazily, i.e. only when
     * first needed.
     * After calling it, every now unneeded variable will be freed from memory.
     * This means that calling _getTimeline more than once will just return an
     * empty array.
     *
     * /!\ Please note that this structure should follow the exact same structure
     * than a SegmentTimeline element in the corresponding MPD.
     * This means:
     *   - It should have the same amount of elements in its array than there was
     *     `<S>` elements in the SegmentTimeline.
     *   - Each of those same elements should have the same start time, the same
     *     duration and the same repeat counter than what could be deduced from
     *     the SegmentTimeline.
     * This is needed to be able to run parsing optimization when refreshing the
     * MPD. Not doing so could lead to the RxPlayer not being able to play the
     * stream anymore.
     * @returns {Array.<Object>}
     */
    _getTimeline() {
      if (this._parseTimeline === null) {
        if (this._index.timeline !== null) {
          return this._index.timeline;
        }
        log_default.error("DASH: Timeline already lazily parsed.");
        return [];
      }
      const newElements = this._parseTimeline();
      this._parseTimeline = null;
      const { MIN_DASH_S_ELEMENTS_TO_PARSE_UNSAFELY } = config_default.getCurrent();
      if (this._unsafelyBaseOnPreviousIndex === null || newElements.length < MIN_DASH_S_ELEMENTS_TO_PARSE_UNSAFELY) {
        return updateTimelineFromEndNumber(
          constructTimelineFromElements(newElements),
          this._index.startNumber,
          this._index.endNumber
        );
      }
      let prevTimeline;
      if (this._unsafelyBaseOnPreviousIndex._index.timeline === null) {
        prevTimeline = this._unsafelyBaseOnPreviousIndex._getTimeline();
        this._unsafelyBaseOnPreviousIndex._index.timeline = prevTimeline;
      } else {
        prevTimeline = this._unsafelyBaseOnPreviousIndex._index.timeline;
      }
      this._unsafelyBaseOnPreviousIndex = null;
      return updateTimelineFromEndNumber(
        constructTimelineFromPreviousTimeline(newElements, prevTimeline),
        this._index.startNumber,
        this._index.endNumber
      );
    }
  };
  function updateTimelineFromEndNumber(timeline, startNumber, endNumber) {
    if (endNumber === void 0) {
      return timeline;
    }
    let currNumber = startNumber != null ? startNumber : 1;
    for (let idx = 0; idx < timeline.length; idx++) {
      const seg = timeline[idx];
      currNumber += seg.repeatCount + 1;
      if (currNumber > endNumber) {
        if (currNumber === endNumber + 1) {
          return timeline.slice(0, idx + 1);
        } else {
          const newTimeline = timeline.slice(0, idx);
          const lastElt = __spreadValues({}, seg);
          const beginningNumber = currNumber - seg.repeatCount - 1;
          lastElt.repeatCount = Math.max(0, endNumber - beginningNumber);
          newTimeline.push(lastElt);
          return newTimeline;
        }
      }
    }
    return timeline;
  }
  function isSegmentStillAvailable(segment, index, manifestBoundsCalculator, scaledPeriodEnd) {
    const lastReqSegInfo = getLastRequestableSegmentInfo(
      index,
      manifestBoundsCalculator,
      scaledPeriodEnd
    );
    if (lastReqSegInfo === null) {
      return false;
    }
    for (let i = 0; i < index.timeline.length; i++) {
      if (lastReqSegInfo.timelineIdx < i) {
        return false;
      }
      const tSegment = index.timeline[i];
      const tSegmentTime = (tSegment.start - index.indexTimeOffset) / index.timescale;
      if (tSegmentTime > segment.time) {
        return false;
      } else if (tSegmentTime === segment.time) {
        if (tSegment.range === void 0) {
          return segment.range === void 0;
        }
        return !isNullOrUndefined(segment.range) && tSegment.range[0] === segment.range[0] && tSegment.range[1] === segment.range[1];
      } else {
        if (tSegment.repeatCount >= 0 && tSegment.duration !== void 0) {
          const timeDiff = tSegmentTime - tSegment.start;
          const repeat = timeDiff / tSegment.duration - 1;
          return repeat % 1 === 0 && repeat <= lastReqSegInfo.newRepeatCount;
        }
      }
    }
    return false;
  }
  function getLastRequestableSegmentInfo(index, manifestBoundsCalculator, scaledPeriodEnd) {
    if (index.timeline.length <= 0) {
      return null;
    }
    if (index.availabilityTimeOffset === Infinity) {
      const lastIndex = index.timeline.length - 1;
      const lastElem = index.timeline[lastIndex];
      return {
        isLastOfTimeline: true,
        timelineIdx: lastIndex,
        newRepeatCount: lastElem.repeatCount,
        end: getIndexSegmentEnd(lastElem, null, scaledPeriodEnd)
      };
    }
    const adjustedMaxSeconds = manifestBoundsCalculator.getEstimatedMaximumPosition(
      index.availabilityTimeOffset
    );
    if (adjustedMaxSeconds === void 0) {
      const lastIndex = index.timeline.length - 1;
      const lastElem = index.timeline[lastIndex];
      return {
        isLastOfTimeline: true,
        timelineIdx: lastIndex,
        newRepeatCount: lastElem.repeatCount,
        end: getIndexSegmentEnd(lastElem, null, scaledPeriodEnd)
      };
    }
    for (let i = index.timeline.length - 1; i >= index.timeline.length; i--) {
      const element = index.timeline[i];
      const endOfFirstOccurence = element.start + element.duration;
      if (fromIndexTime(endOfFirstOccurence, index) <= adjustedMaxSeconds) {
        const endTime = getIndexSegmentEnd(element, index.timeline[i + 1], scaledPeriodEnd);
        if (fromIndexTime(endTime, index) <= adjustedMaxSeconds) {
          return {
            isLastOfTimeline: i === index.timeline.length - 1,
            timelineIdx: i,
            newRepeatCount: element.repeatCount,
            end: endOfFirstOccurence
          };
        } else {
          const maxIndexTime = toIndexTime(adjustedMaxSeconds, index);
          const diffToSegStart = maxIndexTime - element.start;
          const nbOfSegs = Math.floor(diffToSegStart / element.duration);
          assert(nbOfSegs >= 1);
          return {
            isLastOfTimeline: false,
            timelineIdx: i,
            newRepeatCount: nbOfSegs - 1,
            end: element.start + nbOfSegs * element.duration
          };
        }
      }
    }
    return null;
  }

  // src/parsers/manifest/dash/common/indexes/timeline/index.ts
  var timeline_default = TimelineRepresentationIndex;

  // src/parsers/manifest/dash/common/parse_mpd.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/utils/resolve_url.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var schemeRe = /^(?:[a-z]+:)?\/\//i;
  var urlComponentRegex = /^(?:([^:\/?#]+):)?(?:\/\/([^\/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?$/;
  function getFilenameIndexInUrl(url) {
    const indexOfLastSlash = url.lastIndexOf("/");
    if (indexOfLastSlash < 0) {
      return url.length;
    }
    if (schemeRe.test(url)) {
      const firstSlashIndex = url.indexOf("/");
      if (firstSlashIndex >= 0 && indexOfLastSlash === firstSlashIndex + 1) {
        return url.length;
      }
    }
    const indexOfQuestionMark = url.indexOf("?");
    if (indexOfQuestionMark >= 0 && indexOfQuestionMark < indexOfLastSlash) {
      return getFilenameIndexInUrl(url.substring(0, indexOfQuestionMark));
    }
    return indexOfLastSlash + 1;
  }
  function _resolveURL(base, relative) {
    const baseParts = parseURL(base);
    const relativeParts = parseURL(relative);
    if (relativeParts.scheme) {
      return formatURL(relativeParts);
    }
    const target = {
      scheme: baseParts.scheme,
      authority: baseParts.authority,
      path: "",
      query: relativeParts.query,
      fragment: relativeParts.fragment
    };
    if (relativeParts.authority) {
      target.authority = relativeParts.authority;
      target.path = removeDotSegment(relativeParts.path);
      return formatURL(target);
    }
    if (relativeParts.path === "") {
      target.path = baseParts.path;
      if (!relativeParts.query) {
        target.query = baseParts.query;
      }
    } else {
      if (startsWith(relativeParts.path, "/")) {
        target.path = removeDotSegment(relativeParts.path);
      } else {
        target.path = removeDotSegment(mergePaths(baseParts, relativeParts.path));
      }
    }
    return formatURL(target);
  }
  var parsedUrlCache = /* @__PURE__ */ new Map();
  var MAX_URL_CACHE_ENTRIES = 200;
  function parseURL(url) {
    var _a, _b, _c, _d, _e;
    if (parsedUrlCache.has(url)) {
      return parsedUrlCache.get(url);
    }
    const matches = url.match(urlComponentRegex);
    let parsed;
    if (matches === null) {
      parsed = {
        scheme: "",
        authority: "",
        path: "",
        query: "",
        fragment: ""
      };
    } else {
      parsed = {
        scheme: (_a = matches[1]) != null ? _a : "",
        authority: (_b = matches[2]) != null ? _b : "",
        path: (_c = matches[3]) != null ? _c : "",
        query: (_d = matches[4]) != null ? _d : "",
        fragment: (_e = matches[5]) != null ? _e : ""
      };
    }
    if (parsedUrlCache.size >= MAX_URL_CACHE_ENTRIES) {
      parsedUrlCache.clear();
    }
    parsedUrlCache.set(url, parsed);
    return parsed;
  }
  function formatURL(parts) {
    let url = "";
    if (parts.scheme) {
      url += parts.scheme + ":";
    }
    if (parts.authority) {
      url += "//" + parts.authority;
    }
    url += parts.path;
    if (parts.query) {
      url += "?" + parts.query;
    }
    if (parts.fragment) {
      url += "#" + parts.fragment;
    }
    return url;
  }
  function removeDotSegment(path) {
    const segments = path.split(/(?=\/)/);
    const output = [];
    for (let i = 0; i < segments.length; i++) {
      const segment = segments[i];
      if (segment === ".." || segment === "." || segment === "") {
        continue;
      }
      if (segment === "/..") {
        output.pop();
        if (i === segments.length - 1) {
          output.push("/");
        }
        continue;
      }
      if (segment === "/.") {
        if (i === segments.length - 1) {
          output.push("/");
        }
        continue;
      }
      output.push(segment);
    }
    return output.join("");
  }
  function mergePaths(baseParts, relativePath) {
    if (baseParts.authority && baseParts.path === "") {
      return "/" + relativePath;
    }
    const basePath = baseParts.path;
    return basePath.substring(0, basePath.lastIndexOf("/") + 1) + relativePath;
  }
  function resolveURL(...args) {
    var _a, _b, _c;
    const filteredArgs = args.filter((val) => val !== "");
    const len = filteredArgs.length;
    if (len === 0) {
      return "";
    }
    if (len === 1) {
      return (_a = filteredArgs[0]) != null ? _a : "";
    } else {
      const basePart = (_b = filteredArgs[0]) != null ? _b : "";
      const relativeParts = (_c = filteredArgs[1]) != null ? _c : "";
      const resolvedURL = _resolveURL(basePart, relativeParts);
      const remainingArgs = filteredArgs.slice(2);
      return resolveURL(resolvedURL, ...remainingArgs);
    }
  }
  var resolve_url_default = resolveURL;

  // src/parsers/manifest/dash/common/content_protection_parser.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var ContentProtectionParser = class {
    constructor() {
      this._refs = /* @__PURE__ */ new Map();
      this._stored = [];
    }
    /**
     * Add new `IContentProtectionIntermediateRepresentation` objects that can
     * be relied on as a reference by later
     * `IContentProtectionIntermediateRepresentation` objects, without the need
     * to actually apply it to a Representation.
     * @param {Object} contentProtections
     */
    addReferences(contentProtections) {
      for (const contentProt of contentProtections) {
        if (contentProt.attributes.refId !== void 0) {
          this._refs.set(contentProt.attributes.refId, contentProt);
        }
      }
    }
    /**
     * Add a new `IContentProtectionIntermediateRepresentation` object that should
     * be parsed with the result linked to the given `IParsedRepresentation`.
     * @param {Object} representation
     * @param {Object} contentProt
     */
    add(representation, contentProt) {
      if (!this._tryParsing(representation, contentProt, false)) {
        this._stored.push([representation, contentProt]);
      }
      if (contentProt.attributes.refId !== void 0) {
        this._refs.set(contentProt.attributes.refId, contentProt);
        this._resolveStoredRefs(false);
      }
    }
    /**
     * It is possible that even after parsing the full MPD,
     */
    finalize() {
      this._resolveStoredRefs(true);
    }
    /**
     * Try to parse all ContentProtection that are currently waiting due to a
     * referenced ContentProtection not being known yet.
     *
     * Return `true` if all ContentProtection references could have been found
     * and `false` if at least one wasn't.
     *
     * The `force` parameter indicate what should be done if a reference linked
     * to a ContentProtection couldn't be resolved: if `false`, we just keep that
     * ContentProtection aside for later, if `true` we parse it right now even if
     * information could be missing.
     *
     * @param {boolean} force
     * @returns {boolean}
     */
    _resolveStoredRefs(force) {
      for (let i = this._stored.length - 1; i >= 0; i--) {
        const [representation, contentProt] = this._stored[i];
        if (this._tryParsing(representation, contentProt, force) || force) {
          this._stored.splice(i, 1);
        }
      }
      return this._stored.length === 0;
    }
    /**
     * Parse the `IContentProtectionIntermediateRepresentation` given and add the
     * corresponding attributes to the given `IParsedRepresentation` when done.
     *
     * Because the `IContentProtectionIntermediateRepresentation` may be
     * referencing another `IContentProtectionIntermediateRepresentation`, this
     * method might not succeed to do so if the referenced
     * `IContentProtectionIntermediateRepresentation` has not yet been encountered.
     *
     * In that last scenario, this method returns `false` and:
     *   - Either `force` is set to `true`, in which case what could be parsed
     *     will still be set on the `IParsedRepresentation`.
     *   - Either `force` is set to `false`, in which case the parsing of this
     *     `IContentProtectionIntermediateRepresentation` is skipped.
     * @param {Object} representation
     * @param {Object} contentProt
     * @param {boolean} force
     * @returns {boolean}
     */
    _tryParsing(representation, contentProt, force) {
      if (contentProt.attributes.ref === void 0) {
        parseContentProtection(representation, contentProt);
        return true;
      }
      const referenced = this._getReferenced(contentProt.attributes.ref);
      if (referenced === void 0) {
        if (force) {
          log_default.warn("DASH: forcing the parsing of a referencing ContentProtection");
          parseContentProtection(representation, contentProt);
        }
        return false;
      }
      contentProt.children.cencPssh.push(...referenced.children.cencPssh);
      if (contentProt.attributes.keyId === void 0 && referenced.attributes.keyId !== void 0) {
        contentProt.attributes.keyId = referenced.attributes.keyId;
      }
      if (contentProt.attributes.schemeIdUri === void 0 && referenced.attributes.schemeIdUri !== void 0) {
        contentProt.attributes.schemeIdUri = referenced.attributes.schemeIdUri;
      }
      if (contentProt.attributes.value === void 0 && referenced.attributes.value !== void 0) {
        contentProt.attributes.value = referenced.attributes.value;
      }
      parseContentProtection(representation, contentProt);
      return true;
    }
    /**
     * Returns an `IContentProtectionIntermediateRepresentation` based on its
     * "refId".
     * Returns `undefined` if it is not known yet.
     *
     * @param {string} refId
     * @returns {Object|undefined}
     */
    _getReferenced(refId) {
      return this._refs.get(refId);
    }
  };
  function parseContentProtection(representation, contentProtectionIr) {
    let systemId;
    if (contentProtectionIr.attributes.schemeIdUri !== void 0 && contentProtectionIr.attributes.schemeIdUri.substring(0, 9) === "urn:uuid:") {
      systemId = contentProtectionIr.attributes.schemeIdUri.substring(9).replace(/-/g, "").toLowerCase();
    }
    if (contentProtectionIr.attributes.keyId !== void 0 && contentProtectionIr.attributes.keyId.length > 0) {
      const kid = contentProtectionIr.attributes.keyId;
      if (representation.contentProtections === void 0) {
        representation.contentProtections = { keyIds: [kid], initData: [] };
      } else if (representation.contentProtections.keyIds === void 0) {
        representation.contentProtections.keyIds = [kid];
      } else {
        representation.contentProtections.keyIds.push(kid);
      }
    }
    if (systemId === void 0) {
      return;
    }
    const { cencPssh } = contentProtectionIr.children;
    const values = [];
    for (const data2 of cencPssh) {
      values.push({ systemId, data: data2 });
    }
    if (values.length === 0) {
      return;
    }
    if (representation.contentProtections === void 0) {
      representation.contentProtections = {
        keyIds: [],
        initData: [{ type: "cenc", values }]
      };
      return;
    }
    const cencInitData = arrayFind(
      representation.contentProtections.initData,
      (i) => i.type === "cenc"
    );
    if (cencInitData === void 0) {
      representation.contentProtections.initData.push({ type: "cenc", values });
    } else {
      cencInitData.values.push(...values);
    }
  }

  // src/parsers/manifest/dash/common/get_clock_offset.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function getClockOffset(serverClock) {
    const httpOffset = Date.parse(serverClock) - monotonic_timestamp_default();
    if (isNaN(httpOffset)) {
      log_default.warn("DASH Parser: Invalid clock received: ", serverClock);
      return void 0;
    }
    return httpOffset;
  }

  // src/parsers/manifest/dash/common/get_http_utc-timing_url.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function getHTTPUTCTimingURL(mpdIR) {
    const UTCTimingHTTP = mpdIR.children.utcTimings.filter(
      (utcTiming) => (utcTiming.schemeIdUri === "urn:mpeg:dash:utc:http-iso:2014" || utcTiming.schemeIdUri === "urn:mpeg:dash:utc:http-xsdate:2014") && utcTiming.value !== void 0
    );
    return UTCTimingHTTP.length > 0 ? UTCTimingHTTP[0].value : void 0;
  }

  // src/parsers/manifest/dash/common/get_minimum_and_maximum_positions.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/parsers/manifest/utils/get_maximum_positions.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/parsers/manifest/utils/get_last_time_from_adaptation.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function getLastPositionFromAdaptation(adaptation) {
    const { representations } = adaptation;
    let min = null;
    for (const representation of representations) {
      const lastPosition = representation.index.getLastAvailablePosition();
      if (lastPosition === void 0) {
        return void 0;
      }
      if (lastPosition !== null) {
        min = min === null ? lastPosition : Math.min(min, lastPosition);
      }
    }
    if (min === null) {
      return null;
    }
    return min;
  }

  // src/parsers/manifest/utils/get_maximum_positions.ts
  function getMaximumPosition(periods) {
    for (let i = periods.length - 1; i >= 0; i--) {
      const periodAdaptations = periods[i].adaptations;
      const firstAudioAdaptationFromPeriod = periodAdaptations.audio === void 0 ? void 0 : periodAdaptations.audio[0];
      const firstVideoAdaptationFromPeriod = periodAdaptations.video === void 0 ? void 0 : periodAdaptations.video[0];
      if (firstAudioAdaptationFromPeriod !== void 0 || firstVideoAdaptationFromPeriod !== void 0) {
        let maximumAudioPosition = null;
        let maximumVideoPosition = null;
        if (firstAudioAdaptationFromPeriod !== void 0) {
          const lastPosition = getLastPositionFromAdaptation(
            firstAudioAdaptationFromPeriod
          );
          if (lastPosition === void 0) {
            return { safe: void 0, unsafe: void 0 };
          }
          maximumAudioPosition = lastPosition;
        }
        if (firstVideoAdaptationFromPeriod !== void 0) {
          const lastPosition = getLastPositionFromAdaptation(
            firstVideoAdaptationFromPeriod
          );
          if (lastPosition === void 0) {
            return { safe: void 0, unsafe: void 0 };
          }
          maximumVideoPosition = lastPosition;
        }
        if (firstAudioAdaptationFromPeriod !== void 0 && maximumAudioPosition === null || firstVideoAdaptationFromPeriod !== void 0 && maximumVideoPosition === null) {
          log_default.info(
            "Parser utils: found Period with no segment. ",
            "Going to previous one to calculate last position"
          );
          return { safe: void 0, unsafe: void 0 };
        }
        if (maximumVideoPosition !== null) {
          if (maximumAudioPosition !== null) {
            return {
              safe: Math.min(maximumAudioPosition, maximumVideoPosition),
              unsafe: Math.max(maximumAudioPosition, maximumVideoPosition)
            };
          }
          return { safe: maximumVideoPosition, unsafe: maximumVideoPosition };
        }
        if (maximumAudioPosition !== null) {
          return { safe: maximumAudioPosition, unsafe: maximumAudioPosition };
        }
      }
    }
    return { safe: void 0, unsafe: void 0 };
  }

  // src/parsers/manifest/utils/get_minimum_position.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/parsers/manifest/utils/get_first_time_from_adaptation.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function getFirstPositionFromAdaptation(adaptation) {
    const { representations } = adaptation;
    let max = null;
    for (const representation of representations) {
      const firstPosition = representation.index.getFirstAvailablePosition();
      if (firstPosition === void 0) {
        return void 0;
      }
      if (firstPosition !== null) {
        max = max === null ? firstPosition : Math.max(max, firstPosition);
      }
    }
    if (max === null) {
      return null;
    }
    return max;
  }

  // src/parsers/manifest/utils/get_minimum_position.ts
  function getMinimumPosition(periods) {
    for (let i = 0; i <= periods.length - 1; i++) {
      const periodAdaptations = periods[i].adaptations;
      const firstAudioAdaptationFromPeriod = periodAdaptations.audio === void 0 ? void 0 : periodAdaptations.audio[0];
      const firstVideoAdaptationFromPeriod = periodAdaptations.video === void 0 ? void 0 : periodAdaptations.video[0];
      if (firstAudioAdaptationFromPeriod !== void 0 || firstVideoAdaptationFromPeriod !== void 0) {
        let minimumAudioPosition = null;
        let minimumVideoPosition = null;
        if (firstAudioAdaptationFromPeriod !== void 0) {
          const firstPosition = getFirstPositionFromAdaptation(
            firstAudioAdaptationFromPeriod
          );
          if (firstPosition === void 0) {
            return void 0;
          }
          minimumAudioPosition = firstPosition;
        }
        if (firstVideoAdaptationFromPeriod !== void 0) {
          const firstPosition = getFirstPositionFromAdaptation(
            firstVideoAdaptationFromPeriod
          );
          if (firstPosition === void 0) {
            return void 0;
          }
          minimumVideoPosition = firstPosition;
        }
        if (firstAudioAdaptationFromPeriod !== void 0 && minimumAudioPosition === null || firstVideoAdaptationFromPeriod !== void 0 && minimumVideoPosition === null) {
          log_default.info(
            "Parser utils: found Period with no segment. ",
            "Going to next one to calculate first position"
          );
          return void 0;
        }
        if (minimumVideoPosition !== null) {
          if (minimumAudioPosition !== null) {
            return Math.max(minimumAudioPosition, minimumVideoPosition);
          }
          return minimumVideoPosition;
        }
        if (minimumAudioPosition !== null) {
          return minimumAudioPosition;
        }
      }
    }
  }

  // src/parsers/manifest/dash/common/get_minimum_and_maximum_positions.ts
  function getMinimumAndMaximumPositions(periods) {
    if (periods.length === 0) {
      throw new Error("DASH Parser: no period available for a dynamic content");
    }
    const minimumSafePosition = getMinimumPosition(periods);
    const maxPositions = getMaximumPosition(periods);
    return {
      minimumSafePosition,
      maximumSafePosition: maxPositions.safe,
      maximumUnsafePosition: maxPositions.unsafe
    };
  }

  // src/parsers/manifest/dash/common/manifest_bounds_calculator.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var ManifestBoundsCalculator = class {
    /**
     * @param {Object} args
     */
    constructor(args) {
      this._isDynamic = args.isDynamic;
      this._timeShiftBufferDepth = !args.isDynamic || args.timeShiftBufferDepth === void 0 ? null : args.timeShiftBufferDepth;
      this._serverTimestampOffset = args.serverTimestampOffset;
      this._availabilityStartTime = args.availabilityStartTime;
    }
    /**
     * Set the last position and the position time (the value of the RxPlayer's
     * monotonically-raising timestamp at the time that position was true
     * converted into seconds).
     *
     * @example
     * Example if you trust `Date.now()` to give you a reliable offset:
     * ```js
     * const lastPosition = Date.now();
     * const positionTime = getMonotonicTimeStamp() / 1000;
     * manifestBoundsCalculator.setLastPosition(lastPosition, positionTime);
     * ```
     *
     * @param {number} lastPosition
     * @param {number|undefined} positionTime
     */
    setLastPosition(lastPosition, positionTime) {
      this._lastPosition = lastPosition;
      this._positionTime = positionTime;
    }
    /**
     * Returns `true` if the last position and the position time
     * (for dynamic content only) have been comunicated.
     * `false` otherwise.
     * @returns {boolean}
     */
    lastPositionIsKnown() {
      if (this._isDynamic) {
        return this._positionTime !== void 0 && this._lastPosition !== void 0;
      }
      return this._lastPosition !== void 0;
    }
    /**
     * Estimate a minimum bound for the content from the last set segment time
     * and buffer depth.
     * Consider that it is only an estimate, not the real value.
     * @param {number} segmentDuration - In DASH, the buffer depth actually also
     * depend on a corresponding's segment duration (e.g. a segment become
     * unavailable once the `timeShiftBufferDepth` + its duration has elapsed).
     * This argument can thus be set the approximate duration of a segment.
     * @return {number|undefined}
     */
    getEstimatedMinimumSegmentTime(segmentDuration) {
      var _a;
      if (!this._isDynamic || this._timeShiftBufferDepth === null) {
        return 0;
      }
      const maximumBound = (_a = this.getEstimatedLiveEdge()) != null ? _a : this.getEstimatedMaximumPosition(0);
      if (maximumBound === void 0) {
        return void 0;
      }
      const minimumBound = maximumBound - (this._timeShiftBufferDepth + segmentDuration);
      return minimumBound;
    }
    /**
     * Estimate the segment time in seconds that corresponds to what could be
     * considered the live edge (or `undefined` for non-live contents).
     *
     * Note that for some contents which just anounce segments in advance, this
     * value might be very different than the maximum position that is
     * requestable.
     * @return {number|undefined}
     */
    getEstimatedLiveEdge() {
      if (!this._isDynamic || this._serverTimestampOffset === void 0) {
        return void 0;
      }
      return (monotonic_timestamp_default() + this._serverTimestampOffset) / 1e3 - this._availabilityStartTime;
    }
    /**
     * Produce a rough estimate of the ending time of the last requestable segment
     * in that content.
     *
     * This value is only an estimate and may be far from reality.
     *
     * The `availabilityTimeOffset` in argument is the corresponding
     * `availabilityTimeOffset` that applies to the current wanted segment, or `0`
     * if none exist. It will be applied on live content to deduce the maximum
     * segment time available.
     */
    getEstimatedMaximumPosition(availabilityTimeOffset) {
      if (!this._isDynamic) {
        return this._lastPosition;
      }
      const liveEdge = this.getEstimatedLiveEdge();
      if (liveEdge !== void 0 && availabilityTimeOffset !== Infinity) {
        return liveEdge + availabilityTimeOffset;
      } else if (this._positionTime !== void 0 && this._lastPosition !== void 0) {
        return Math.max(
          this._lastPosition - this._positionTime + monotonic_timestamp_default() / 1e3,
          0
        );
      }
      return this._lastPosition;
    }
  };

  // src/parsers/manifest/dash/common/parse_availability_start_time.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function parseAvailabilityStartTime(rootAttributes, referenceDateTime) {
    if (rootAttributes.type !== "dynamic") {
      return 0;
    }
    if (isNullOrUndefined(rootAttributes.availabilityStartTime)) {
      return referenceDateTime != null ? referenceDateTime : 0;
    }
    return rootAttributes.availabilityStartTime;
  }

  // src/parsers/manifest/dash/common/parse_periods.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/parsers/manifest/dash/common/flatten_overlapping_periods.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function flattenOverlappingPeriods(parsedPeriods) {
    if (parsedPeriods.length === 0) {
      return [];
    }
    const flattenedPeriods = [parsedPeriods[0]];
    for (let i = 1; i < parsedPeriods.length; i++) {
      const parsedPeriod = parsedPeriods[i];
      let lastFlattenedPeriod = flattenedPeriods[flattenedPeriods.length - 1];
      while (lastFlattenedPeriod.duration === void 0 || lastFlattenedPeriod.start + lastFlattenedPeriod.duration > parsedPeriod.start) {
        log_default.warn(
          "DASH: Updating overlapping Periods.",
          lastFlattenedPeriod == null ? void 0 : lastFlattenedPeriod.start,
          parsedPeriod.start
        );
        lastFlattenedPeriod.duration = parsedPeriod.start - lastFlattenedPeriod.start;
        lastFlattenedPeriod.end = parsedPeriod.start;
        if (lastFlattenedPeriod.duration > 0) {
          break;
        } else {
          flattenedPeriods.pop();
          if (flattenedPeriods.length === 0) {
            break;
          }
          lastFlattenedPeriod = flattenedPeriods[flattenedPeriods.length - 1];
        }
      }
      flattenedPeriods.push(parsedPeriod);
    }
    return flattenedPeriods;
  }

  // src/parsers/manifest/dash/common/get_periods_time_infos.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function getPeriodsTimeInformation(periodsIR, manifestInfos) {
    const periodsTimeInformation = [];
    periodsIR.forEach((currentPeriod, i) => {
      let periodStart;
      if (!isNullOrUndefined(currentPeriod.attributes.start)) {
        periodStart = currentPeriod.attributes.start;
      } else {
        if (i === 0) {
          periodStart = !manifestInfos.isDynamic || isNullOrUndefined(manifestInfos.availabilityStartTime) ? 0 : manifestInfos.availabilityStartTime;
        } else {
          const prevPeriodInfos = periodsTimeInformation[periodsTimeInformation.length - 1];
          if (!isNullOrUndefined(prevPeriodInfos) && !isNullOrUndefined(prevPeriodInfos.periodEnd)) {
            periodStart = prevPeriodInfos.periodEnd;
          } else {
            throw new Error("Missing start time when parsing periods.");
          }
        }
      }
      let periodDuration;
      const nextPeriod = periodsIR[i + 1];
      if (!isNullOrUndefined(currentPeriod.attributes.duration)) {
        periodDuration = currentPeriod.attributes.duration;
      } else if (i === periodsIR.length - 1) {
        periodDuration = manifestInfos.duration;
      } else if (!isNullOrUndefined(nextPeriod.attributes.start)) {
        periodDuration = nextPeriod.attributes.start - periodStart;
      }
      const periodEnd = !isNullOrUndefined(periodDuration) ? periodStart + periodDuration : void 0;
      periodsTimeInformation.push({ periodStart, periodDuration, periodEnd });
    });
    return periodsTimeInformation;
  }

  // src/parsers/manifest/dash/common/parse_adaptation_sets.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/parsers/manifest/dash/common/attach_trickmode_track.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function attachTrickModeTrack(adaptations, trickModeTracks) {
    for (const track of trickModeTracks) {
      const { adaptation, trickModeAttachedAdaptationIds } = track;
      for (const trickModeAttachedAdaptationId of trickModeAttachedAdaptationIds) {
        for (const adaptationType of SUPPORTED_ADAPTATIONS_TYPE) {
          const adaptationsByType = adaptations[adaptationType];
          if (adaptationsByType !== void 0) {
            for (const adaptationByType of adaptationsByType) {
              if (adaptationByType.id === trickModeAttachedAdaptationId) {
                if (adaptationByType.trickModeTracks === void 0) {
                  adaptationByType.trickModeTracks = [];
                }
                adaptationByType.trickModeTracks.push(adaptation);
              }
            }
          }
        }
      }
    }
  }
  var attach_trickmode_track_default = attachTrickModeTrack;

  // src/parsers/manifest/dash/common/infer_adaptation_type.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var SUPPORTED_TEXT_TYPES = ["subtitle", "caption"];
  function getThumbnailAdaptationSetInfo(adaptation, representation) {
    var _a, _b, _c, _d;
    const thumbnailProp = (_d = arrayFind(
      (_a = adaptation.children.essentialProperties) != null ? _a : [],
      (p) => p.schemeIdUri === "http://dashif.org/guidelines/thumbnail_tile" || p.schemeIdUri === "http://dashif.org/thumbnail_tile"
    )) != null ? _d : arrayFind(
      (_c = (_b = representation != null ? representation : adaptation.children.representations[0]) == null ? void 0 : _b.children.essentialProperties) != null ? _c : [],
      (p) => p.schemeIdUri === "http://dashif.org/guidelines/thumbnail_tile" || p.schemeIdUri === "http://dashif.org/thumbnail_tile"
    );
    if (thumbnailProp === void 0) {
      return null;
    }
    const tilesRegex = /(\d+)x(\d+)/;
    if (thumbnailProp === void 0 || thumbnailProp.value === void 0 || !tilesRegex.test(thumbnailProp.value)) {
      log_default.warn("DASH: Invalid thumbnails Representation, no tile-related information");
      return null;
    }
    const match = thumbnailProp.value.match(tilesRegex);
    const horizontalTiles = parseInt(match[1], 10);
    const verticalTiles = parseInt(match[2], 10);
    return {
      horizontalTiles,
      verticalTiles
    };
  }
  function inferAdaptationType(adaptation, representations) {
    if (adaptation.attributes.contentType === "image") {
      if (getThumbnailAdaptationSetInfo(adaptation) !== null) {
        return "thumbnails";
      }
      return void 0;
    }
    const adaptationMimeType = isNonEmptyString(adaptation.attributes.mimeType) ? adaptation.attributes.mimeType : null;
    const adaptationCodecs = isNonEmptyString(adaptation.attributes.codecs) ? adaptation.attributes.codecs : null;
    const adaptationRoles = !isNullOrUndefined(adaptation.children.roles) ? adaptation.children.roles : null;
    function fromMimeType(mimeType, roles) {
      const topLevel = mimeType.split("/")[0];
      if (arrayIncludes(
        SUPPORTED_ADAPTATIONS_TYPE,
        topLevel
      )) {
        return topLevel;
      }
      if (mimeType === "application/ttml+xml") {
        return "text";
      }
      if (mimeType === "application/mp4") {
        if (roles !== null) {
          if (arrayFind(
            roles,
            (role) => role.schemeIdUri === "urn:mpeg:dash:role:2011" && arrayIncludes(SUPPORTED_TEXT_TYPES, role.value)
          ) !== void 0) {
            return "text";
          }
        }
        return void 0;
      }
    }
    function fromCodecs(codecs) {
      switch (codecs.substring(0, 3)) {
        case "avc":
        case "hev":
        case "hvc":
        case "vp8":
        case "vp9":
        case "av1":
          return "video";
        case "vtt":
          return "text";
      }
      switch (codecs.substring(0, 4)) {
        case "mp4a":
          return "audio";
        case "wvtt":
        case "stpp":
          return "text";
      }
    }
    if (adaptationMimeType !== null) {
      const typeFromMimeType = fromMimeType(adaptationMimeType, adaptationRoles);
      if (typeFromMimeType !== void 0) {
        return typeFromMimeType;
      }
    }
    if (adaptationCodecs !== null) {
      const typeFromCodecs = fromCodecs(adaptationCodecs);
      if (typeFromCodecs !== void 0) {
        return typeFromCodecs;
      }
    }
    for (let i = 0; i < representations.length; i++) {
      const representation = representations[i];
      const { mimeType, codecs } = representation.attributes;
      if (mimeType !== void 0) {
        const typeFromMimeType = fromMimeType(mimeType, adaptationRoles);
        if (typeFromMimeType !== void 0) {
          return typeFromMimeType;
        }
      }
      if (codecs !== void 0) {
        const typeFromCodecs = fromCodecs(codecs);
        if (typeFromCodecs !== void 0) {
          return typeFromCodecs;
        }
      }
    }
    return void 0;
  }

  // src/parsers/manifest/dash/common/parse_representations.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/parsers/manifest/dash/common/convert_supplemental_codecs.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var supplementalCodecSeparator = /[, ]+/g;
  function convertSupplementalCodecsToRFC6381(val) {
    if (isNonEmptyString(val)) {
      return val.trim().replace(supplementalCodecSeparator, ", ");
    }
    return "";
  }

  // src/parsers/manifest/dash/common/get_hdr_information.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function getWEBMHDRInformation(codecString) {
    const [cccc, _PP, _LL, DD, _CC, cp, tc, mc] = codecString.split(".");
    if (cccc !== "vp08" && cccc !== "vp09" && cccc !== "vp10") {
      return void 0;
    }
    let colorDepth;
    let eotf;
    let colorSpace;
    if (DD !== void 0 && DD === "10" || DD === "12") {
      colorDepth = parseInt(DD, 10);
    }
    if (tc !== void 0) {
      if (tc === "16") {
        eotf = "pq";
      } else if (tc === "18") {
        eotf = "hlg";
      }
    }
    if (cp !== void 0 && mc !== void 0 && cp === "09" && mc === "09") {
      colorSpace = "rec2020";
    }
    if (colorDepth === void 0 || eotf === void 0) {
      return void 0;
    }
    return { colorDepth, eotf, colorSpace };
  }

  // src/parsers/manifest/dash/common/parse_representation_index.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function parseRepresentationIndex(representation, context) {
    var _a, _b, _c;
    const {
      availabilityTimeOffset,
      manifestBoundsCalculator,
      isDynamic,
      end: periodEnd,
      start: periodStart,
      receivedTime,
      unsafelyBaseOnPreviousRepresentation,
      inbandEventStreams,
      isLastPeriod
    } = context;
    const isEMSGWhitelisted = (inbandEvent) => {
      if (inbandEventStreams === void 0) {
        return false;
      }
      return inbandEventStreams.some(
        ({ schemeIdUri }) => schemeIdUri === inbandEvent.schemeIdUri
      );
    };
    const reprIndexCtxt = {
      availabilityTimeComplete: void 0,
      availabilityTimeOffset,
      unsafelyBaseOnPreviousRepresentation,
      isEMSGWhitelisted,
      isLastPeriod,
      manifestBoundsCalculator,
      isDynamic,
      periodEnd,
      periodStart,
      receivedTime,
      representationBitrate: representation.attributes.bitrate,
      representationId: representation.attributes.id
    };
    let representationIndex;
    if (representation.children.segmentBase !== void 0) {
      const { segmentBase } = representation.children;
      representationIndex = new BaseRepresentationIndex(segmentBase, reprIndexCtxt);
    } else if (representation.children.segmentList !== void 0) {
      const { segmentList } = representation.children;
      representationIndex = new ListRepresentationIndex(segmentList, reprIndexCtxt);
    } else if (representation.children.segmentTemplate !== void 0 || context.parentSegmentTemplates.length > 0) {
      const segmentTemplates = context.parentSegmentTemplates.slice();
      const childSegmentTemplate = representation.children.segmentTemplate;
      if (childSegmentTemplate !== void 0) {
        segmentTemplates.push(childSegmentTemplate);
      }
      const segmentTemplate = object_assign_default(
        {},
        ...segmentTemplates
      );
      if (segmentTemplate.availabilityTimeOffset !== void 0 || context.availabilityTimeOffset !== void 0) {
        reprIndexCtxt.availabilityTimeOffset = ((_a = segmentTemplate.availabilityTimeOffset) != null ? _a : 0) + ((_b = context.availabilityTimeOffset) != null ? _b : 0);
      }
      if (segmentTemplate.availabilityTimeComplete !== void 0 || context.availabilityTimeComplete !== void 0) {
        reprIndexCtxt.availabilityTimeComplete = (_c = segmentTemplate.availabilityTimeComplete) != null ? _c : context.availabilityTimeComplete;
      }
      representationIndex = timeline_default.isTimelineIndexArgument(
        segmentTemplate
      ) ? new timeline_default(segmentTemplate, reprIndexCtxt) : new TemplateRepresentationIndex(segmentTemplate, reprIndexCtxt);
    } else {
      const adaptationChildren = context.adaptation.children;
      if (adaptationChildren.segmentBase !== void 0) {
        const { segmentBase } = adaptationChildren;
        representationIndex = new BaseRepresentationIndex(segmentBase, reprIndexCtxt);
      } else if (adaptationChildren.segmentList !== void 0) {
        const { segmentList } = adaptationChildren;
        representationIndex = new ListRepresentationIndex(segmentList, reprIndexCtxt);
      } else {
        representationIndex = new TemplateRepresentationIndex(
          {
            duration: Number.MAX_VALUE,
            timescale: 1,
            startNumber: 0,
            media: ""
          },
          reprIndexCtxt
        );
      }
    }
    return representationIndex;
  }

  // src/parsers/manifest/dash/common/resolve_base_urls.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function resolveBaseURLs(currentBaseURLs, newBaseUrlsIR) {
    var _a;
    if (newBaseUrlsIR.length === 0) {
      return currentBaseURLs;
    }
    const newBaseUrls = newBaseUrlsIR.map((ir) => {
      return { url: ir.value };
    });
    if (currentBaseURLs.length === 0) {
      return newBaseUrls;
    }
    const result = [];
    for (let i = 0; i < currentBaseURLs.length; i++) {
      const curBaseUrl = currentBaseURLs[i];
      for (let j = 0; j < newBaseUrls.length; j++) {
        const newBaseUrl = newBaseUrls[j];
        const newUrl = resolve_url_default(curBaseUrl.url, newBaseUrl.url);
        result.push({
          url: newUrl,
          serviceLocation: (_a = newBaseUrl.serviceLocation) != null ? _a : curBaseUrl.serviceLocation
        });
      }
    }
    return result;
  }

  // src/parsers/manifest/dash/common/parse_representations.ts
  function combineInbandEventStreams(representation, adaptation) {
    const newSchemeId = [];
    if (representation.children.inbandEventStreams !== void 0) {
      newSchemeId.push(...representation.children.inbandEventStreams);
    }
    if (adaptation.children.inbandEventStreams !== void 0) {
      newSchemeId.push(...adaptation.children.inbandEventStreams);
    }
    if (newSchemeId.length === 0) {
      return void 0;
    }
    return newSchemeId;
  }
  function getHDRInformation({
    adaptationProfiles,
    essentialProperties,
    supplementalProperties,
    manifestProfiles,
    codecs
  }) {
    const profiles = (adaptationProfiles != null ? adaptationProfiles : "") + (manifestProfiles != null ? manifestProfiles : "");
    if (profiles.indexOf("http://dashif.org/guidelines/dash-if-uhd#hevc-hdr-pq10") !== -1) {
      if (codecs === "hvc1.2.4.L153.B0" || codecs === "hev1.2.4.L153.B0") {
        return { colorDepth: 10, eotf: "pq", colorSpace: "rec2020" };
      }
    }
    const transferCharacteristicScheme = arrayFind(
      [...essentialProperties != null ? essentialProperties : [], ...supplementalProperties != null ? supplementalProperties : []],
      (p) => p.schemeIdUri === "urn:mpeg:mpegB:cicp:TransferCharacteristics"
    );
    if (transferCharacteristicScheme !== void 0) {
      switch (transferCharacteristicScheme.value) {
        case "15":
          return void 0;
        case "16":
          return { eotf: "pq" };
        case "18":
          return { eotf: "hlg" };
      }
    }
    if (codecs !== void 0 && /^vp(08|09|10)/.exec(codecs)) {
      return getWEBMHDRInformation(codecs);
    }
  }
  function parseRepresentations(representationsIR, adaptation, context) {
    var _a, _b, _c, _d, _e, _f, _g;
    const parsedRepresentations = [];
    for (const representation of representationsIR) {
      let representationID = representation.attributes.id !== void 0 ? representation.attributes.id : String(representation.attributes.bitrate) + (representation.attributes.height !== void 0 ? `-${representation.attributes.height}` : "") + (representation.attributes.width !== void 0 ? `-${representation.attributes.width}` : "") + (representation.attributes.mimeType !== void 0 ? `-${representation.attributes.mimeType}` : "") + (representation.attributes.codecs !== void 0 ? `-${representation.attributes.codecs}` : "");
      while (parsedRepresentations.some((r) => r.id === representationID)) {
        representationID += "-dup";
      }
      const unsafelyBaseOnPreviousRepresentation = (_b = (_a = context.unsafelyBaseOnPreviousAdaptation) == null ? void 0 : _a.getRepresentation(representationID)) != null ? _b : null;
      const inbandEventStreams = combineInbandEventStreams(representation, adaptation);
      const availabilityTimeComplete = (_c = representation.attributes.availabilityTimeComplete) != null ? _c : context.availabilityTimeComplete;
      let availabilityTimeOffset;
      if (representation.attributes.availabilityTimeOffset !== void 0 || context.availabilityTimeOffset !== void 0) {
        availabilityTimeOffset = ((_d = representation.attributes.availabilityTimeOffset) != null ? _d : 0) + ((_e = context.availabilityTimeOffset) != null ? _e : 0);
      }
      const reprIndexCtxt = object_assign_default({}, context, {
        availabilityTimeOffset,
        availabilityTimeComplete,
        unsafelyBaseOnPreviousRepresentation,
        adaptation,
        inbandEventStreams
      });
      const representationIndex = parseRepresentationIndex(representation, reprIndexCtxt);
      let representationBitrate;
      if (representation.attributes.bitrate === void 0) {
        log_default.warn("DASH: No usable bitrate found in the Representation.");
        representationBitrate = 0;
      } else {
        representationBitrate = representation.attributes.bitrate;
      }
      const representationBaseURLs = resolveBaseURLs(
        context.baseURLs,
        representation.children.baseURLs
      );
      const cdnMetadata = representationBaseURLs.length === 0 ? (
        // No BaseURL seems to be associated to this Representation, nor to the MPD,
        // but underlying segments might have one. To indicate that segments should
        // still be available through a CDN without giving any root CDN URL here,
        // we just communicate about an empty `baseUrl`, as documented.
        [{ baseUrl: "", id: void 0 }]
      ) : representationBaseURLs.map((x) => ({
        baseUrl: x.url,
        id: x.serviceLocation
      }));
      const parsedRepresentation = {
        bitrate: representationBitrate,
        cdnMetadata,
        index: representationIndex,
        id: representationID
      };
      if (representation.children.supplementalProperties !== void 0 && arrayFind(
        representation.children.supplementalProperties,
        (r) => r.schemeIdUri === "tag:dolby.com,2018:dash:EC3_ExtensionType:2018" && r.value === "JOC"
      )) {
        parsedRepresentation.isSpatialAudio = true;
      }
      let codecs;
      if (representation.attributes.codecs !== void 0) {
        codecs = representation.attributes.codecs;
      } else if (adaptation.attributes.codecs !== void 0) {
        codecs = adaptation.attributes.codecs;
      }
      if (codecs !== void 0) {
        codecs = codecs === "mp4a.40.02" ? "mp4a.40.2" : codecs;
        parsedRepresentation.codecs = codecs;
      }
      let supplementalCodecs;
      if (representation.attributes.supplementalCodecs !== void 0) {
        supplementalCodecs = representation.attributes.supplementalCodecs;
      } else if (adaptation.attributes.supplementalCodecs !== void 0) {
        supplementalCodecs = adaptation.attributes.supplementalCodecs;
      }
      if (supplementalCodecs !== void 0) {
        parsedRepresentation.supplementalCodecs = convertSupplementalCodecsToRFC6381(supplementalCodecs);
      }
      if (representation.attributes.frameRate !== void 0) {
        parsedRepresentation.frameRate = representation.attributes.frameRate;
      } else if (adaptation.attributes.frameRate !== void 0) {
        parsedRepresentation.frameRate = adaptation.attributes.frameRate;
      }
      if (representation.attributes.height !== void 0) {
        parsedRepresentation.height = representation.attributes.height;
      } else if (adaptation.attributes.height !== void 0) {
        parsedRepresentation.height = adaptation.attributes.height;
      }
      if (representation.attributes.mimeType !== void 0) {
        parsedRepresentation.mimeType = representation.attributes.mimeType;
      } else if (adaptation.attributes.mimeType !== void 0) {
        parsedRepresentation.mimeType = adaptation.attributes.mimeType;
      }
      if (representation.attributes.width !== void 0) {
        parsedRepresentation.width = representation.attributes.width;
      } else if (adaptation.attributes.width !== void 0) {
        parsedRepresentation.width = adaptation.attributes.width;
      }
      {
        const contentProtIrArr = [
          ...(_f = adaptation.children.contentProtections) != null ? _f : [],
          ...(_g = representation.children.contentProtections) != null ? _g : []
        ];
        for (const contentProtIr of contentProtIrArr) {
          context.contentProtectionParser.add(parsedRepresentation, contentProtIr);
        }
      }
      parsedRepresentation.hdrInfo = getHDRInformation({
        adaptationProfiles: adaptation.attributes.profiles,
        supplementalProperties: adaptation.children.supplementalProperties,
        essentialProperties: adaptation.children.essentialProperties,
        manifestProfiles: context.manifestProfiles,
        codecs
      });
      parsedRepresentations.push(parsedRepresentation);
    }
    return parsedRepresentations;
  }

  // src/parsers/manifest/dash/common/parse_adaptation_sets.ts
  function isVisuallyImpaired(accessibility) {
    if (accessibility === void 0) {
      return false;
    }
    const isVisuallyImpairedAudioDvbDash = accessibility.schemeIdUri === "urn:tva:metadata:cs:AudioPurposeCS:2007" && accessibility.value === "1";
    const isVisuallyImpairedDashIf = accessibility.schemeIdUri === "urn:mpeg:dash:role:2011" && accessibility.value === "description";
    return isVisuallyImpairedAudioDvbDash || isVisuallyImpairedDashIf;
  }
  function isCaptionning(accessibilities, roles) {
    if (accessibilities !== void 0) {
      const hasDvbClosedCaptionSignaling = accessibilities.some(
        (accessibility) => accessibility.schemeIdUri === "urn:tva:metadata:cs:AudioPurposeCS:2007" && accessibility.value === "2"
      );
      if (hasDvbClosedCaptionSignaling) {
        return true;
      }
    }
    if (roles !== void 0) {
      const hasDashCaptionSinaling = roles.some(
        (role) => role.schemeIdUri === "urn:mpeg:dash:role:2011" && role.value === "caption"
      );
      if (hasDashCaptionSinaling) {
        return true;
      }
    }
    return false;
  }
  function hasSignLanguageInterpretation(accessibility) {
    if (accessibility === void 0) {
      return false;
    }
    return accessibility.schemeIdUri === "urn:mpeg:dash:role:2011" && accessibility.value === "sign";
  }
  function getAdaptationID(adaptation, infos) {
    if (isNonEmptyString(adaptation.attributes.id)) {
      return adaptation.attributes.id;
    }
    const {
      isClosedCaption,
      isForcedSubtitle,
      isAudioDescription,
      isSignInterpreted,
      isTrickModeTrack,
      type
    } = infos;
    let idString = type;
    if (isNonEmptyString(adaptation.attributes.language)) {
      idString += `-${adaptation.attributes.language}`;
    }
    if (isClosedCaption === true) {
      idString += "-cc";
    }
    if (isForcedSubtitle === true) {
      idString += "-cc";
    }
    if (isAudioDescription === true) {
      idString += "-ad";
    }
    if (isSignInterpreted === true) {
      idString += "-si";
    }
    if (isTrickModeTrack) {
      idString += "-trickMode";
    }
    if (isNonEmptyString(adaptation.attributes.contentType)) {
      idString += `-${adaptation.attributes.contentType}`;
    }
    if (isNonEmptyString(adaptation.attributes.codecs)) {
      idString += `-${adaptation.attributes.codecs}`;
    }
    if (isNonEmptyString(adaptation.attributes.mimeType)) {
      idString += `-${adaptation.attributes.mimeType}`;
    }
    if (adaptation.attributes.frameRate !== void 0) {
      idString += `-${String(adaptation.attributes.frameRate)}`;
    }
    return idString;
  }
  function getAdaptationSetSwitchingIDs(adaptation) {
    if (!isNullOrUndefined(adaptation.children.supplementalProperties)) {
      const { supplementalProperties } = adaptation.children;
      for (const supplementalProperty of supplementalProperties) {
        if (supplementalProperty.schemeIdUri === "urn:mpeg:dash:adaptation-set-switching:2016" && !isNullOrUndefined(supplementalProperty.value)) {
          return supplementalProperty.value.split(",").map((id) => id.trim()).filter((id) => id);
        }
      }
    }
    return [];
  }
  function parseAdaptationSets(adaptationsIR, context) {
    var _a, _b, _c, _d, _e, _f, _g;
    const parsedAdaptations = { video: [], audio: [], text: [] };
    const parsedThumbnailTracks = [];
    const trickModeAdaptations = [];
    const adaptationSwitchingInfos = {};
    const parsedAdaptationsIDs = [];
    for (let adaptationIdx = 0; adaptationIdx < adaptationsIR.length; adaptationIdx++) {
      const adaptation = adaptationsIR[adaptationIdx];
      const adaptationChildren = adaptation.children;
      const { essentialProperties, roles, label } = adaptationChildren;
      const isMainAdaptation = Array.isArray(roles) && roles.some((role) => role.value === "main") && roles.some((role) => role.schemeIdUri === "urn:mpeg:dash:role:2011");
      const representationsIR = adaptation.children.representations;
      const availabilityTimeComplete = (_a = adaptation.attributes.availabilityTimeComplete) != null ? _a : context.availabilityTimeComplete;
      let availabilityTimeOffset;
      if (adaptation.attributes.availabilityTimeOffset !== void 0 || context.availabilityTimeOffset !== void 0) {
        availabilityTimeOffset = ((_b = adaptation.attributes.availabilityTimeOffset) != null ? _b : 0) + ((_c = context.availabilityTimeOffset) != null ? _c : 0);
      }
      const type = inferAdaptationType(adaptation, representationsIR);
      if (type === void 0) {
        continue;
      }
      const priority = (_d = adaptation.attributes.selectionPriority) != null ? _d : 1;
      const originalID = adaptation.attributes.id;
      const adaptationSetSwitchingIDs = getAdaptationSetSwitchingIDs(adaptation);
      const parentSegmentTemplates = [];
      if (context.segmentTemplate !== void 0) {
        parentSegmentTemplates.push(context.segmentTemplate);
      }
      if (adaptation.children.segmentTemplate !== void 0) {
        parentSegmentTemplates.push(adaptation.children.segmentTemplate);
      }
      const reprCtxt = {
        availabilityTimeComplete,
        availabilityTimeOffset,
        baseURLs: resolveBaseURLs(context.baseURLs, adaptationChildren.baseURLs),
        contentProtectionParser: context.contentProtectionParser,
        manifestBoundsCalculator: context.manifestBoundsCalculator,
        end: context.end,
        isDynamic: context.isDynamic,
        isLastPeriod: context.isLastPeriod,
        manifestProfiles: context.manifestProfiles,
        parentSegmentTemplates,
        receivedTime: context.receivedTime,
        start: context.start,
        unsafelyBaseOnPreviousAdaptation: null
      };
      const trickModeProperty = Array.isArray(essentialProperties) ? arrayFind(essentialProperties, (scheme) => {
        return scheme.schemeIdUri === "http://dashif.org/guidelines/trickmode";
      }) : void 0;
      const trickModeAttachedAdaptationIds = (_e = trickModeProperty == null ? void 0 : trickModeProperty.value) == null ? void 0 : _e.split(" ");
      const isTrickModeTrack = trickModeAttachedAdaptationIds !== void 0;
      const { accessibilities } = adaptationChildren;
      let isDub;
      if (roles !== void 0 && roles.some((role) => role.value === "dub")) {
        isDub = true;
      }
      let isClosedCaption;
      if (type !== "text") {
        isClosedCaption = false;
      } else {
        isClosedCaption = isCaptionning(accessibilities, roles);
      }
      let isForcedSubtitle;
      if (type === "text" && roles !== void 0 && roles.some(
        (role) => role.value === "forced-subtitle" || role.value === "forced_subtitle"
      )) {
        isForcedSubtitle = true;
      }
      let isAudioDescription;
      if (type !== "audio") {
        isAudioDescription = false;
      } else if (accessibilities !== void 0) {
        isAudioDescription = accessibilities.some(isVisuallyImpaired);
      }
      let isSignInterpreted;
      if (type !== "video") {
        isSignInterpreted = false;
      } else if (accessibilities !== void 0) {
        isSignInterpreted = accessibilities.some(hasSignLanguageInterpretation);
      }
      let adaptationID = getAdaptationID(adaptation, {
        isAudioDescription,
        isForcedSubtitle,
        isClosedCaption,
        isSignInterpreted,
        isTrickModeTrack,
        type
      });
      while (arrayIncludes(parsedAdaptationsIDs, adaptationID)) {
        adaptationID += "-dup";
      }
      const newID = adaptationID;
      parsedAdaptationsIDs.push(adaptationID);
      reprCtxt.unsafelyBaseOnPreviousAdaptation = (_g = (_f = context.unsafelyBaseOnPreviousPeriod) == null ? void 0 : _f.getAdaptation(adaptationID)) != null ? _g : null;
      const representations = parseRepresentations(representationsIR, adaptation, reprCtxt);
      if (type === "thumbnails") {
        const track = createThumbnailTracks(adaptation, representations);
        if (track !== null) {
          parsedThumbnailTracks.push(...track);
        }
        continue;
      }
      const parsedAdaptationSet = {
        id: adaptationID,
        representations,
        type,
        isTrickModeTrack
      };
      if (!isNullOrUndefined(adaptation.attributes.language)) {
        parsedAdaptationSet.language = adaptation.attributes.language;
      }
      if (!isNullOrUndefined(isClosedCaption)) {
        parsedAdaptationSet.closedCaption = isClosedCaption;
      }
      if (!isNullOrUndefined(isAudioDescription)) {
        parsedAdaptationSet.audioDescription = isAudioDescription;
      }
      if (isDub === true) {
        parsedAdaptationSet.isDub = true;
      }
      if (isForcedSubtitle !== void 0) {
        parsedAdaptationSet.forcedSubtitles = isForcedSubtitle;
      }
      if (isSignInterpreted === true) {
        parsedAdaptationSet.isSignInterpreted = true;
      }
      if (label !== void 0) {
        parsedAdaptationSet.label = label;
      }
      if (trickModeAttachedAdaptationIds !== void 0) {
        trickModeAdaptations.push({
          adaptation: parsedAdaptationSet,
          trickModeAttachedAdaptationIds
        });
      } else {
        let mergedIntoIdx = -1;
        for (const id of adaptationSetSwitchingIDs) {
          const switchingInfos = adaptationSwitchingInfos[id];
          if (switchingInfos !== void 0 && switchingInfos.newID !== newID && arrayIncludes(switchingInfos.adaptationSetSwitchingIDs, originalID)) {
            mergedIntoIdx = arrayFindIndex(parsedAdaptations[type], (a) => a[0].id === id);
            const mergedInto = parsedAdaptations[type][mergedIntoIdx];
            if (mergedInto !== void 0 && mergedInto[0].audioDescription === parsedAdaptationSet.audioDescription && mergedInto[0].closedCaption === parsedAdaptationSet.closedCaption && mergedInto[0].language === parsedAdaptationSet.language) {
              log_default.info('DASH Parser: merging "switchable" AdaptationSets', originalID, id);
              mergedInto[0].representations.push(...parsedAdaptationSet.representations);
              mergedInto[1] = {
                priority: Math.max(priority, mergedInto[1].priority),
                isMainAdaptation: isMainAdaptation || mergedInto[1].isMainAdaptation,
                indexInMpd: Math.min(adaptationIdx, mergedInto[1].indexInMpd)
              };
              break;
            }
          }
        }
        if (mergedIntoIdx < 0) {
          parsedAdaptations[type].push([
            parsedAdaptationSet,
            { priority, isMainAdaptation, indexInMpd: adaptationIdx }
          ]);
        }
      }
      if (!isNullOrUndefined(originalID) && isNullOrUndefined(adaptationSwitchingInfos[originalID])) {
        adaptationSwitchingInfos[originalID] = {
          newID,
          adaptationSetSwitchingIDs
        };
      }
    }
    const adaptationsPerType = SUPPORTED_ADAPTATIONS_TYPE.reduce(
      (acc, adaptationType) => {
        const adaptationsParsedForType = parsedAdaptations[adaptationType];
        if (adaptationsParsedForType.length > 0) {
          adaptationsParsedForType.sort(compareAdaptations);
          acc[adaptationType] = adaptationsParsedForType.map(
            ([parsedAdaptation]) => parsedAdaptation
          );
        }
        return acc;
      },
      {}
    );
    parsedAdaptations.video.sort(compareAdaptations);
    attach_trickmode_track_default(adaptationsPerType, trickModeAdaptations);
    return {
      adaptations: adaptationsPerType,
      thumbnailTracks: parsedThumbnailTracks
    };
  }
  function createThumbnailTracks(adaptation, representations) {
    const tracks = [];
    for (let i = 0; i < representations.length; i++) {
      const representation = representations[i];
      if (representation !== void 0) {
        if (representation.mimeType === void 0) {
          log_default.warn("DASH: Invalid thumbnails Representation, no mime-type");
          continue;
        }
        const tileInfo = getThumbnailAdaptationSetInfo(
          adaptation,
          adaptation.children.representations[i]
        );
        if (tileInfo === null) {
          continue;
        }
        if (representation.height === void 0) {
          log_default.warn("DASH: Invalid thumbnails Representation, no height information");
          continue;
        }
        if (representation.width === void 0) {
          log_default.warn("DASH: Invalid thumbnails Representation, no width information");
          continue;
        }
        tracks.push({
          id: representation.id,
          cdnMetadata: representation.cdnMetadata,
          index: representation.index,
          mimeType: representation.mimeType,
          height: representation.height,
          width: representation.width,
          horizontalTiles: tileInfo.horizontalTiles,
          verticalTiles: tileInfo.verticalTiles
        });
      }
    }
    return tracks;
  }
  function compareAdaptations(a, b) {
    const priorityDiff = b[1].priority - a[1].priority;
    if (priorityDiff !== 0) {
      return priorityDiff;
    }
    if (a[1].isMainAdaptation !== b[1].isMainAdaptation) {
      return a[1].isMainAdaptation ? -1 : 1;
    }
    return a[1].indexInMpd - b[1].indexInMpd;
  }

  // src/parsers/manifest/dash/common/parse_periods.ts
  var generatePeriodID = idGenerator();
  function parsePeriods(periodsIR, context) {
    var _a, _b, _c, _d, _e;
    const parsedPeriods = [];
    const periodsTimeInformation = getPeriodsTimeInformation(periodsIR, context);
    if (periodsTimeInformation.length !== periodsIR.length) {
      throw new Error("MPD parsing error: the time information are incoherent.");
    }
    const { isDynamic, manifestBoundsCalculator } = context;
    if (!isDynamic && !isNullOrUndefined(context.duration)) {
      manifestBoundsCalculator.setLastPosition(context.duration);
    }
    for (let i = periodsIR.length - 1; i >= 0; i--) {
      const isLastPeriod = i === periodsIR.length - 1;
      const periodIR = periodsIR[i];
      const xlinkInfos = context.xlinkInfos.get(periodIR);
      const periodBaseURLs = resolveBaseURLs(context.baseURLs, periodIR.children.baseURLs);
      const { periodStart, periodDuration, periodEnd } = periodsTimeInformation[i];
      let periodID;
      if (isNullOrUndefined(periodIR.attributes.id)) {
        log_default.warn("DASH: No usable id found in the Period. Generating one.");
        periodID = "gen-dash-period-" + generatePeriodID();
      } else {
        periodID = periodIR.attributes.id;
      }
      while (parsedPeriods.some((p) => p.id === periodID)) {
        periodID += "-dup";
      }
      const receivedTime = xlinkInfos !== void 0 ? xlinkInfos.receivedTime : context.receivedTime;
      const unsafelyBaseOnPreviousPeriod = (_b = (_a = context.unsafelyBaseOnPreviousManifest) == null ? void 0 : _a.getPeriod(periodID)) != null ? _b : null;
      const availabilityTimeComplete = periodIR.attributes.availabilityTimeComplete;
      const availabilityTimeOffset = periodIR.attributes.availabilityTimeOffset;
      const { manifestProfiles, contentProtectionParser } = context;
      const { segmentTemplate } = periodIR.children;
      contentProtectionParser.addReferences((_c = periodIR.children.contentProtections) != null ? _c : []);
      const adapCtxt = {
        availabilityTimeComplete,
        availabilityTimeOffset,
        baseURLs: periodBaseURLs,
        contentProtectionParser,
        manifestBoundsCalculator,
        end: periodEnd,
        isDynamic,
        isLastPeriod,
        manifestProfiles,
        receivedTime,
        segmentTemplate,
        start: periodStart,
        unsafelyBaseOnPreviousPeriod
      };
      const { adaptations, thumbnailTracks } = parseAdaptationSets(
        periodIR.children.adaptations,
        adapCtxt
      );
      const namespaces = ((_d = context.xmlNamespaces) != null ? _d : []).concat(
        (_e = periodIR.attributes.namespaces) != null ? _e : []
      );
      const streamEvents = generateStreamEvents(
        periodIR.children.eventStreams,
        periodStart,
        namespaces
      );
      const parsedPeriod = {
        id: periodID,
        start: periodStart,
        end: periodEnd,
        duration: periodDuration,
        thumbnailTracks,
        adaptations,
        streamEvents
      };
      parsedPeriods.unshift(parsedPeriod);
      if (!manifestBoundsCalculator.lastPositionIsKnown()) {
        const lastPosition = getMaximumLastPosition(adaptations);
        if (!isDynamic) {
          if (typeof lastPosition === "number") {
            manifestBoundsCalculator.setLastPosition(lastPosition);
          }
        } else {
          if (typeof lastPosition === "number") {
            const positionTime = monotonic_timestamp_default() / 1e3;
            manifestBoundsCalculator.setLastPosition(lastPosition, positionTime);
          } else {
            const guessedLastPositionFromClock = guessLastPositionFromClock(
              context,
              periodStart
            );
            if (guessedLastPositionFromClock !== void 0) {
              const [guessedLastPosition, guessedPositionTime] = guessedLastPositionFromClock;
              manifestBoundsCalculator.setLastPosition(
                guessedLastPosition,
                guessedPositionTime
              );
            }
          }
        }
      }
    }
    if (context.isDynamic && !manifestBoundsCalculator.lastPositionIsKnown()) {
      const guessedLastPositionFromClock = guessLastPositionFromClock(context, 0);
      if (guessedLastPositionFromClock !== void 0) {
        const [lastPosition, positionTime] = guessedLastPositionFromClock;
        manifestBoundsCalculator.setLastPosition(lastPosition, positionTime);
      }
    }
    return flattenOverlappingPeriods(parsedPeriods);
  }
  function guessLastPositionFromClock(context, minimumTime) {
    if (!isNullOrUndefined(context.clockOffset)) {
      const lastPosition = context.clockOffset / 1e3 - context.availabilityStartTime;
      const positionTime = monotonic_timestamp_default() / 1e3;
      const timeInSec = positionTime + lastPosition;
      if (timeInSec >= minimumTime) {
        return [timeInSec, positionTime];
      }
    } else {
      const now = Date.now() / 1e3;
      if (now >= minimumTime) {
        log_default.warn(
          "DASH Parser: no clock synchronization mechanism found. Using the system clock instead."
        );
        const lastPosition = now - context.availabilityStartTime;
        const positionTime = monotonic_timestamp_default() / 1e3;
        return [lastPosition, positionTime];
      }
    }
    return void 0;
  }
  function getMaximumLastPosition(adaptationsPerType) {
    let maxEncounteredPosition = null;
    let allIndexAreEmpty = true;
    const adaptationsVal = object_values_default(adaptationsPerType).filter(
      (ada) => !isNullOrUndefined(ada)
    );
    const allAdaptations = flatMap(
      adaptationsVal,
      (adaptationsForType) => adaptationsForType
    );
    for (const adaptation of allAdaptations) {
      const representations = adaptation.representations;
      for (const representation of representations) {
        const position = representation.index.getLastAvailablePosition();
        if (position !== null) {
          allIndexAreEmpty = false;
          if (typeof position === "number") {
            maxEncounteredPosition = isNullOrUndefined(maxEncounteredPosition) ? position : Math.max(maxEncounteredPosition, position);
          }
        }
      }
    }
    if (!isNullOrUndefined(maxEncounteredPosition)) {
      return maxEncounteredPosition;
    } else if (allIndexAreEmpty) {
      return null;
    }
    return void 0;
  }
  function generateStreamEvents(baseIr, periodStart, xmlNamespaces) {
    var _a, _b;
    const res = [];
    for (const eventStreamIr of baseIr) {
      const { schemeIdUri = "", timescale = 1 } = eventStreamIr.attributes;
      const allNamespaces = xmlNamespaces.concat((_a = eventStreamIr.attributes.namespaces) != null ? _a : []);
      for (const eventIr of eventStreamIr.children.events) {
        if (eventIr.eventStreamData !== void 0) {
          const start = ((_b = eventIr.presentationTime) != null ? _b : 0) / timescale + periodStart;
          const end = eventIr.duration === void 0 ? void 0 : start + eventIr.duration / timescale;
          let element;
          let xmlData;
          if (!is_worker_default && eventIr.eventStreamData instanceof Element) {
            element = eventIr.eventStreamData;
          } else {
            try {
              xmlData = {
                namespaces: allNamespaces,
                data: typeof eventIr.eventStreamData === "string" ? eventIr.eventStreamData : utf8ToStr(new Uint8Array(eventIr.eventStreamData))
              };
            } catch (err) {
              log_default.error(
                "DASH: Error while parsing event-stream:",
                err instanceof Error ? err.message : "Unknown error"
              );
            }
          }
          res.push({
            start,
            end,
            id: eventIr.id,
            data: {
              type: "dash-event-stream",
              value: { schemeIdUri, timescale, element, xmlData }
            }
          });
        }
      }
    }
    return res;
  }

  // src/parsers/manifest/dash/common/parse_mpd.ts
  function parseMpdIr(mpdIR, args, warnings, hasLoadedClock, xlinkInfos = /* @__PURE__ */ new WeakMap()) {
    const { children: rootChildren, attributes: rootAttributes } = mpdIR;
    if (isNullOrUndefined(args.externalClockOffset)) {
      const isDynamic = rootAttributes.type === "dynamic";
      const directTiming = arrayFind(rootChildren.utcTimings, (utcTiming) => {
        return utcTiming.schemeIdUri === "urn:mpeg:dash:utc:direct:2014" && !isNullOrUndefined(utcTiming.value);
      });
      const clockOffsetFromDirectUTCTiming = !isNullOrUndefined(directTiming) && !isNullOrUndefined(directTiming.value) ? getClockOffset(directTiming.value) : void 0;
      const clockOffset = !isNullOrUndefined(clockOffsetFromDirectUTCTiming) && !isNaN(clockOffsetFromDirectUTCTiming) ? clockOffsetFromDirectUTCTiming : void 0;
      if (!isNullOrUndefined(clockOffset) && hasLoadedClock !== true) {
        args.externalClockOffset = clockOffset;
      } else if (isDynamic && hasLoadedClock !== true) {
        const UTCTimingHTTPURL = getHTTPUTCTimingURL(mpdIR);
        if (!isNullOrUndefined(UTCTimingHTTPURL) && UTCTimingHTTPURL.length > 0) {
          return {
            type: "needs-clock",
            value: {
              url: UTCTimingHTTPURL,
              continue: function continueParsingMPD(responseDataClock) {
                if (!responseDataClock.success) {
                  warnings.push(responseDataClock.error);
                  log_default.warn(
                    "DASH Parser: Error on fetching the clock ressource",
                    responseDataClock.error
                  );
                  return parseMpdIr(mpdIR, args, warnings, true);
                }
                args.externalClockOffset = getClockOffset(responseDataClock.data);
                return parseMpdIr(mpdIR, args, warnings, true);
              }
            }
          };
        }
      }
    }
    const xlinksToLoad = [];
    for (let i = 0; i < rootChildren.periods.length; i++) {
      const { xlinkHref, xlinkActuate } = rootChildren.periods[i].attributes;
      if (!isNullOrUndefined(xlinkHref) && xlinkActuate === "onLoad") {
        xlinksToLoad.push({ index: i, ressource: xlinkHref });
      }
    }
    if (xlinksToLoad.length === 0) {
      return parseCompleteIntermediateRepresentation(mpdIR, args, warnings, xlinkInfos);
    }
    return {
      type: "needs-xlinks",
      value: {
        xlinksUrls: xlinksToLoad.map(({ ressource }) => ressource),
        continue: function continueParsingMPD(loadedRessources) {
          if (loadedRessources.length !== xlinksToLoad.length) {
            throw new Error("DASH parser: wrong number of loaded ressources.");
          }
          for (let i = loadedRessources.length - 1; i >= 0; i--) {
            const index = xlinksToLoad[i].index;
            const {
              parsed: periodsIR,
              warnings: parsingWarnings,
              receivedTime,
              sendingTime,
              url
            } = loadedRessources[i];
            if (parsingWarnings.length > 0) {
              warnings.push(...parsingWarnings);
            }
            for (const periodIR of periodsIR) {
              xlinkInfos.set(periodIR, { receivedTime, sendingTime, url });
            }
            rootChildren.periods.splice(index, 1, ...periodsIR);
          }
          return parseMpdIr(mpdIR, args, warnings, hasLoadedClock, xlinkInfos);
        }
      }
    };
  }
  function parseCompleteIntermediateRepresentation(mpdIR, args, warnings, xlinkInfos) {
    var _a, _b, _c, _d, _e;
    const { children: rootChildren, attributes: rootAttributes } = mpdIR;
    const isDynamic = rootAttributes.type === "dynamic";
    const initialBaseUrl = args.url !== void 0 ? [{ url: args.url.substring(0, getFilenameIndexInUrl(args.url)) }] : [];
    const mpdBaseUrls = resolveBaseURLs(initialBaseUrl, rootChildren.baseURLs);
    const availabilityStartTime = parseAvailabilityStartTime(
      rootAttributes,
      args.referenceDateTime
    );
    const timeShiftBufferDepth = rootAttributes.timeShiftBufferDepth;
    const maxSegmentDuration = rootAttributes.maxSegmentDuration;
    const { externalClockOffset: clockOffset, unsafelyBaseOnPreviousManifest } = args;
    const { externalClockOffset } = args;
    const manifestBoundsCalculator = new ManifestBoundsCalculator({
      availabilityStartTime,
      isDynamic,
      timeShiftBufferDepth,
      serverTimestampOffset: externalClockOffset
    });
    const contentProtectionParser = new ContentProtectionParser();
    contentProtectionParser.addReferences((_a = rootChildren.contentProtections) != null ? _a : []);
    const manifestInfos = {
      availabilityStartTime,
      baseURLs: mpdBaseUrls,
      clockOffset,
      contentProtectionParser,
      duration: rootAttributes.duration,
      isDynamic,
      manifestBoundsCalculator,
      manifestProfiles: mpdIR.attributes.profiles,
      receivedTime: args.manifestReceivedTime,
      unsafelyBaseOnPreviousManifest,
      xlinkInfos,
      xmlNamespaces: mpdIR.attributes.namespaces
    };
    const parsedPeriods = parsePeriods(rootChildren.periods, manifestInfos);
    contentProtectionParser.finalize();
    const mediaPresentationDuration = rootAttributes.duration;
    let lifetime;
    let minimumTime;
    let timeshiftDepth = null;
    let maximumTimeData;
    if (rootAttributes.minimumUpdatePeriod !== void 0 && rootAttributes.minimumUpdatePeriod >= 0) {
      lifetime = rootAttributes.minimumUpdatePeriod === 0 ? config_default.getCurrent().DASH_FALLBACK_LIFETIME_WHEN_MINIMUM_UPDATE_PERIOD_EQUAL_0 : rootAttributes.minimumUpdatePeriod;
    }
    const { minimumSafePosition, maximumSafePosition, maximumUnsafePosition } = getMinimumAndMaximumPositions(parsedPeriods);
    const now = monotonic_timestamp_default();
    if (!isDynamic) {
      minimumTime = minimumSafePosition;
      if (minimumTime === void 0) {
        minimumTime = (_c = (_b = parsedPeriods[0]) == null ? void 0 : _b.start) != null ? _c : 0;
      }
      let finalMaximumSafePosition = mediaPresentationDuration != null ? mediaPresentationDuration : Infinity;
      if (parsedPeriods[parsedPeriods.length - 1] !== void 0) {
        const lastPeriod = parsedPeriods[parsedPeriods.length - 1];
        const lastPeriodEnd = (_d = lastPeriod.end) != null ? _d : lastPeriod.duration !== void 0 ? lastPeriod.start + lastPeriod.duration : void 0;
        if (lastPeriodEnd !== void 0 && lastPeriodEnd < finalMaximumSafePosition) {
          finalMaximumSafePosition = lastPeriodEnd;
        }
      }
      if (maximumSafePosition !== void 0 && maximumSafePosition < finalMaximumSafePosition) {
        finalMaximumSafePosition = maximumSafePosition;
      }
      maximumTimeData = {
        isLinear: false,
        maximumSafePosition: finalMaximumSafePosition,
        livePosition: void 0,
        time: now
      };
    } else {
      let finalMaximumSafePosition;
      if (maximumSafePosition !== void 0) {
        finalMaximumSafePosition = maximumSafePosition;
      } else {
        if (externalClockOffset === void 0) {
          log_default.warn("DASH Parser: use system clock to define maximum position");
          finalMaximumSafePosition = Date.now() / 1e3 - availabilityStartTime;
        } else {
          const serverTime = monotonic_timestamp_default() + externalClockOffset;
          finalMaximumSafePosition = serverTime / 1e3 - availabilityStartTime;
        }
      }
      let livePosition = manifestBoundsCalculator.getEstimatedLiveEdge();
      if (livePosition === void 0) {
        if (maximumUnsafePosition !== void 0) {
          livePosition = maximumUnsafePosition;
        } else {
          livePosition = finalMaximumSafePosition;
        }
      }
      maximumTimeData = {
        isLinear: true,
        maximumSafePosition: finalMaximumSafePosition,
        livePosition,
        time: now
      };
      minimumTime = minimumSafePosition;
      timeshiftDepth = timeShiftBufferDepth != null ? timeShiftBufferDepth : null;
      if (timeshiftDepth !== null) {
        timeshiftDepth += maxSegmentDuration != null ? maxSegmentDuration : 0;
      }
      if (timeshiftDepth !== null && minimumTime !== void 0 && livePosition - minimumTime > timeshiftDepth) {
        timeshiftDepth = livePosition - minimumTime;
      }
    }
    const isLastPeriodKnown = !isDynamic || mpdIR.attributes.minimumUpdatePeriod === void 0 && (((_e = parsedPeriods[parsedPeriods.length - 1]) == null ? void 0 : _e.end) !== void 0 || mpdIR.attributes.duration !== void 0);
    const parsedMPD = {
      availabilityStartTime,
      clockOffset: args.externalClockOffset,
      isDynamic,
      isLive: isDynamic,
      isLastPeriodKnown,
      periods: parsedPeriods,
      publishTime: rootAttributes.publishTime,
      suggestedPresentationDelay: rootAttributes.suggestedPresentationDelay,
      transportType: "dash",
      timeBounds: {
        minimumSafePosition: minimumTime,
        timeshiftDepth,
        maximumTimeData
      },
      lifetime,
      uris: isNullOrUndefined(args.url) ? rootChildren.locations : [args.url, ...rootChildren.locations]
    };
    return { type: "done", value: { parsed: parsedMPD, warnings } };
  }

  // src/parsers/manifest/dash/common/index.ts
  var common_default = parseMpdIr;

  // src/parsers/manifest/dash/native-parser/node_parsers/MPD.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/parsers/manifest/dash/native-parser/node_parsers/BaseURL.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function parseBaseURL(root) {
    const value = root.textContent;
    const warnings = [];
    if (value === null || value.length === 0) {
      return [void 0, warnings];
    }
    return [{ value }, warnings];
  }

  // src/parsers/manifest/dash/native-parser/node_parsers/ContentProtection.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/parsers/manifest/dash/native-parser/node_parsers/utils.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var iso8601Duration = /^P(([\d.]*)Y)?(([\d.]*)M)?(([\d.]*)D)?T?(([\d.]*)H)?(([\d.]*)M)?(([\d.]*)S)?/;
  var rangeRe = /([0-9]+)-([0-9]+)/;
  function parseBoolean(val, displayName) {
    if (val === "true") {
      return [true, null];
    }
    if (val === "false") {
      return [false, null];
    }
    const error = new MPDError(
      `\`${displayName}\` property is not a boolean value but "${val}"`
    );
    return [false, error];
  }
  function parseMPDInteger(val, displayName) {
    const toInt = parseInt(val, 10);
    if (isNaN(toInt)) {
      const error = new MPDError(
        `\`${displayName}\` property is not an integer value but "${val}"`
      );
      return [null, error];
    }
    return [toInt, null];
  }
  function parseMPDFloat(val, displayName) {
    if (val === "INF") {
      return [Infinity, null];
    }
    const toInt = parseFloat(val);
    if (isNaN(toInt)) {
      const error = new MPDError(`\`${displayName}\` property is invalid: "${val}"`);
      return [null, error];
    }
    return [toInt, null];
  }
  function parseIntOrBoolean(val, displayName) {
    if (val === "true") {
      return [true, null];
    }
    if (val === "false") {
      return [false, null];
    }
    const toInt = parseInt(val, 10);
    if (isNaN(toInt)) {
      const error = new MPDError(
        `\`${displayName}\` property is not a boolean nor an integer but "${val}"`
      );
      return [null, error];
    }
    return [toInt, null];
  }
  function parseDateTime(val, displayName) {
    const parsed = Date.parse(val);
    if (isNaN(parsed)) {
      const error = new MPDError(
        `\`${displayName}\` is in an invalid date format: "${val}"`
      );
      return [null, error];
    }
    return [new Date(Date.parse(val)).getTime() / 1e3, null];
  }
  function parseDuration(val, displayName) {
    if (!isNonEmptyString(val)) {
      const error = new MPDError(`\`${displayName}\` property is empty`);
      return [0, error];
    }
    const match = iso8601Duration.exec(val);
    if (match === null) {
      const error = new MPDError(
        `\`${displayName}\` property has an unrecognized format "${val}"`
      );
      return [null, error];
    }
    const duration = parseFloat(isNonEmptyString(match[2]) ? match[2] : "0") * 365 * 24 * 60 * 60 + parseFloat(isNonEmptyString(match[4]) ? match[4] : "0") * 30 * 24 * 60 * 60 + parseFloat(isNonEmptyString(match[6]) ? match[6] : "0") * 24 * 60 * 60 + parseFloat(isNonEmptyString(match[8]) ? match[8] : "0") * 60 * 60 + parseFloat(isNonEmptyString(match[10]) ? match[10] : "0") * 60 + parseFloat(isNonEmptyString(match[12]) ? match[12] : "0");
    return [duration, null];
  }
  function parseByteRange(val, displayName) {
    const match = rangeRe.exec(val);
    if (match === null) {
      const error = new MPDError(
        `\`${displayName}\` property has an unrecognized format "${val}"`
      );
      return [null, error];
    } else {
      return [[+match[1], +match[2]], null];
    }
  }
  function parseBase64(val, displayName) {
    try {
      return [base64ToBytes(val), null];
    } catch (_) {
      const error = new MPDError(
        `\`${displayName}\` is not a valid base64 string: "${val}"`
      );
      return [null, error];
    }
  }
  function parseMaybeDividedNumber(val, displayName) {
    const matches = /^(\d+)\/(\d+)$/.exec(val);
    if (matches !== null) {
      return [+matches[1] / +matches[2], null];
    }
    return parseMPDFloat(val, displayName);
  }
  function parseScheme(root) {
    let schemeIdUri;
    let value;
    for (let i = 0; i < root.attributes.length; i++) {
      const attribute = root.attributes[i];
      switch (attribute.name) {
        case "schemeIdUri":
          schemeIdUri = attribute.value;
          break;
        case "value":
          value = attribute.value;
          break;
      }
    }
    return { schemeIdUri, value };
  }
  function ValueParser(dest, warnings) {
    return function(val, {
      asKey,
      parser,
      dashName
    }) {
      const [parsingResult, parsingError] = parser(val, dashName);
      if (parsingError !== null) {
        log_default.warn(parsingError.message);
        warnings.push(parsingError);
      }
      if (parsingResult !== null) {
        dest[asKey] = parsingResult;
      }
    };
  }
  var MPDError = class _MPDError extends Error {
    /**
     * @param {string} message
     */
    constructor(message) {
      super(message);
      Object.setPrototypeOf(this, _MPDError.prototype);
      this.name = "MPDError";
    }
  };

  // src/parsers/manifest/dash/native-parser/node_parsers/ContentProtection.ts
  function parseContentProtectionChildren(contentProtectionChildren) {
    const warnings = [];
    const cencPssh = [];
    for (let i = 0; i < contentProtectionChildren.length; i++) {
      if (contentProtectionChildren[i].nodeType === Node.ELEMENT_NODE) {
        const currentElement = contentProtectionChildren[i];
        if (currentElement.nodeName === "cenc:pssh") {
          const content = currentElement.textContent;
          if (content !== null && content.length > 0) {
            const [toUint8Array, error] = parseBase64(content, "cenc:pssh");
            if (error !== null) {
              log_default.warn(error.message);
              warnings.push(error);
            }
            if (toUint8Array !== null) {
              cencPssh.push(toUint8Array);
            }
          }
        }
      }
    }
    return [{ cencPssh }, warnings];
  }
  function parseContentProtectionAttributes(root) {
    const ret = {};
    for (let i = 0; i < root.attributes.length; i++) {
      const attribute = root.attributes[i];
      switch (attribute.name) {
        case "schemeIdUri":
          ret.schemeIdUri = attribute.value;
          break;
        case "value":
          ret.value = attribute.value;
          break;
        case "cenc:default_KID":
          ret.keyId = hexToBytes(attribute.value.replace(/-/g, ""));
          break;
        case "ref":
          ret.ref = attribute.value;
          break;
        case "refId":
          ret.refId = attribute.value;
          break;
      }
    }
    return ret;
  }
  function parseContentProtection2(contentProtectionElement) {
    const [children, childrenWarnings] = parseContentProtectionChildren(
      contentProtectionElement.childNodes
    );
    const attributes = parseContentProtectionAttributes(contentProtectionElement);
    return [{ children, attributes }, childrenWarnings];
  }

  // src/parsers/manifest/dash/native-parser/node_parsers/Period.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/parsers/manifest/dash/native-parser/node_parsers/AdaptationSet.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/parsers/manifest/dash/native-parser/node_parsers/ContentComponent.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function parseContentComponent(root) {
    const ret = {};
    for (let i = 0; i < root.attributes.length; i++) {
      const attribute = root.attributes[i];
      switch (attribute.name) {
        case "id":
          ret.id = attribute.value;
          break;
        case "lang":
          ret.language = attribute.value;
          break;
        case "contentType":
          ret.contentType = attribute.value;
          break;
        case "par":
          ret.par = attribute.value;
          break;
      }
    }
    return ret;
  }

  // src/parsers/manifest/dash/native-parser/node_parsers/Representation.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/parsers/manifest/dash/native-parser/node_parsers/SegmentBase.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/parsers/manifest/dash/native-parser/node_parsers/Initialization.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function parseInitialization(root) {
    const parsedInitialization = {};
    const warnings = [];
    const parseValue = ValueParser(parsedInitialization, warnings);
    for (let i = 0; i < root.attributes.length; i++) {
      const attribute = root.attributes[i];
      switch (attribute.name) {
        case "range":
          parseValue(attribute.value, {
            asKey: "range",
            parser: parseByteRange,
            dashName: "range"
          });
          break;
        case "sourceURL":
          parsedInitialization.media = attribute.value;
          break;
      }
    }
    return [parsedInitialization, warnings];
  }

  // src/parsers/manifest/dash/native-parser/node_parsers/SegmentBase.ts
  function parseSegmentBase(root) {
    const attributes = {};
    let warnings = [];
    const parseValue = ValueParser(attributes, warnings);
    const segmentBaseChildren = root.childNodes;
    for (let i = 0; i < segmentBaseChildren.length; i++) {
      if (segmentBaseChildren[i].nodeType === Node.ELEMENT_NODE) {
        const currentNode = segmentBaseChildren[i];
        if (currentNode.nodeName === "Initialization") {
          const [initialization, initializationWarnings] = parseInitialization(currentNode);
          attributes.initialization = initialization;
          warnings = warnings.concat(initializationWarnings);
        }
      }
    }
    for (let i = 0; i < root.attributes.length; i++) {
      const attr = root.attributes[i];
      switch (attr.name) {
        case "timescale":
          parseValue(attr.value, {
            asKey: "timescale",
            parser: parseMPDInteger,
            dashName: "timescale"
          });
          break;
        case "presentationTimeOffset":
          parseValue(attr.value, {
            asKey: "presentationTimeOffset",
            parser: parseMPDFloat,
            dashName: "presentationTimeOffset"
          });
          break;
        case "indexRange":
          parseValue(attr.value, {
            asKey: "indexRange",
            parser: parseByteRange,
            dashName: "indexRange"
          });
          break;
        case "indexRangeExact":
          parseValue(attr.value, {
            asKey: "indexRangeExact",
            parser: parseBoolean,
            dashName: "indexRangeExact"
          });
          break;
        case "availabilityTimeOffset":
          parseValue(attr.value, {
            asKey: "availabilityTimeOffset",
            parser: parseMPDFloat,
            dashName: "availabilityTimeOffset"
          });
          break;
        case "availabilityTimeComplete":
          parseValue(attr.value, {
            asKey: "availabilityTimeComplete",
            parser: parseBoolean,
            dashName: "availabilityTimeComplete"
          });
          break;
        case "duration":
          parseValue(attr.value, {
            asKey: "duration",
            parser: parseMPDInteger,
            dashName: "duration"
          });
          break;
        case "startNumber":
          parseValue(attr.value, {
            asKey: "startNumber",
            parser: parseMPDInteger,
            dashName: "startNumber"
          });
          break;
        case "endNumber":
          parseValue(attr.value, {
            asKey: "endNumber",
            parser: parseMPDInteger,
            dashName: "endNumber"
          });
          break;
      }
    }
    return [attributes, warnings];
  }

  // src/parsers/manifest/dash/native-parser/node_parsers/SegmentList.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/parsers/manifest/dash/native-parser/node_parsers/SegmentURL.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function parseSegmentURL(root) {
    const parsedSegmentURL = {};
    const warnings = [];
    const parseValue = ValueParser(parsedSegmentURL, warnings);
    for (let i = 0; i < root.attributes.length; i++) {
      const attribute = root.attributes[i];
      switch (attribute.name) {
        case "media":
          parsedSegmentURL.media = attribute.value;
          break;
        case "indexRange":
          parseValue(attribute.value, {
            asKey: "indexRange",
            parser: parseByteRange,
            dashName: "indexRange"
          });
          break;
        case "index":
          parsedSegmentURL.index = attribute.value;
          break;
        case "mediaRange":
          parseValue(attribute.value, {
            asKey: "mediaRange",
            parser: parseByteRange,
            dashName: "mediaRange"
          });
          break;
      }
    }
    return [parsedSegmentURL, warnings];
  }

  // src/parsers/manifest/dash/native-parser/node_parsers/SegmentList.ts
  function parseSegmentList(root) {
    const [base, baseWarnings] = parseSegmentBase(root);
    let warnings = baseWarnings;
    const list = [];
    const segmentListChildren = root.childNodes;
    for (let i = 0; i < segmentListChildren.length; i++) {
      if (segmentListChildren[i].nodeType === Node.ELEMENT_NODE) {
        const currentNode = segmentListChildren[i];
        if (currentNode.nodeName === "SegmentURL") {
          const [segmentURL, segmentURLWarnings] = parseSegmentURL(currentNode);
          list.push(segmentURL);
          warnings = warnings.concat(segmentURLWarnings);
        }
      }
    }
    const ret = object_assign_default(base, { list });
    return [ret, warnings];
  }

  // src/parsers/manifest/dash/native-parser/node_parsers/SegmentTemplate.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/parsers/manifest/dash/native-parser/node_parsers/SegmentTimeline.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function createSegmentTimelineParser(root) {
    let result = null;
    return function() {
      if (result === null) {
        const elements = root.getElementsByTagName("S");
        result = elements;
        return elements;
      }
      return result;
    };
  }

  // src/parsers/manifest/dash/native-parser/node_parsers/SegmentTemplate.ts
  function parseSegmentTemplate(root) {
    const [base, segmentBaseWarnings] = parseSegmentBase(root);
    const warnings = segmentBaseWarnings;
    let timelineParser;
    for (let i = 0; i < root.childNodes.length; i++) {
      if (root.childNodes[i].nodeType === Node.ELEMENT_NODE) {
        const currentNode = root.childNodes[i];
        if (currentNode.nodeName === "SegmentTimeline") {
          timelineParser = createSegmentTimelineParser(currentNode);
        }
      }
    }
    const ret = object_assign_default({}, base, {
      duration: base.duration,
      timelineParser
    });
    const parseValue = ValueParser(ret, warnings);
    for (let i = 0; i < root.attributes.length; i++) {
      const attribute = root.attributes[i];
      switch (attribute.nodeName) {
        case "initialization":
          if (isNullOrUndefined(ret.initialization)) {
            ret.initialization = { media: attribute.value };
          }
          break;
        case "index":
          ret.index = attribute.value;
          break;
        case "availabilityTimeOffset":
          parseValue(attribute.value, {
            asKey: "availabilityTimeOffset",
            parser: parseMPDFloat,
            dashName: "availabilityTimeOffset"
          });
          break;
        case "availabilityTimeComplete":
          parseValue(attribute.value, {
            asKey: "availabilityTimeComplete",
            parser: parseBoolean,
            dashName: "availabilityTimeComplete"
          });
          break;
        case "media":
          ret.media = attribute.value;
          break;
        case "bitstreamSwitching":
          parseValue(attribute.value, {
            asKey: "bitstreamSwitching",
            parser: parseBoolean,
            dashName: "bitstreamSwitching"
          });
          break;
      }
    }
    return [ret, warnings];
  }

  // src/parsers/manifest/dash/native-parser/node_parsers/Representation.ts
  function parseRepresentationChildren(representationChildren) {
    const children = {
      baseURLs: []
    };
    const contentProtections = [];
    let warnings = [];
    for (let i = 0; i < representationChildren.length; i++) {
      if (representationChildren[i].nodeType === Node.ELEMENT_NODE) {
        const currentElement = representationChildren[i];
        switch (currentElement.nodeName) {
          case "BaseURL": {
            const [baseURLObj, baseURLWarnings] = parseBaseURL(currentElement);
            if (baseURLObj !== void 0) {
              children.baseURLs.push(baseURLObj);
            }
            warnings = warnings.concat(baseURLWarnings);
            break;
          }
          case "InbandEventStream":
            if (children.inbandEventStreams === void 0) {
              children.inbandEventStreams = [];
            }
            children.inbandEventStreams.push(parseScheme(currentElement));
            break;
          case "SegmentBase": {
            const [segmentBase, segmentBaseWarnings] = parseSegmentBase(currentElement);
            children.segmentBase = segmentBase;
            if (segmentBaseWarnings.length > 0) {
              warnings = warnings.concat(segmentBaseWarnings);
            }
            break;
          }
          case "SegmentList": {
            const [segmentList, segmentListWarnings] = parseSegmentList(currentElement);
            warnings = warnings.concat(segmentListWarnings);
            children.segmentList = segmentList;
            break;
          }
          case "SegmentTemplate": {
            const [segmentTemplate, segmentTemplateWarnings] = parseSegmentTemplate(currentElement);
            warnings = warnings.concat(segmentTemplateWarnings);
            children.segmentTemplate = segmentTemplate;
            break;
          }
          case "ContentProtection": {
            const [contentProtection, contentProtectionWarnings] = parseContentProtection2(currentElement);
            if (contentProtectionWarnings.length > 0) {
              warnings = warnings.concat(contentProtectionWarnings);
            }
            if (contentProtection !== void 0) {
              contentProtections.push(contentProtection);
            }
            break;
          }
          case "EssentialProperty":
            if (isNullOrUndefined(children.essentialProperties)) {
              children.essentialProperties = [parseScheme(currentElement)];
            } else {
              children.essentialProperties.push(parseScheme(currentElement));
            }
            break;
          case "SupplementalProperty":
            if (isNullOrUndefined(children.supplementalProperties)) {
              children.supplementalProperties = [parseScheme(currentElement)];
            } else {
              children.supplementalProperties.push(parseScheme(currentElement));
            }
            break;
        }
      }
    }
    if (contentProtections.length > 0) {
      children.contentProtections = contentProtections;
    }
    return [children, warnings];
  }
  function parseRepresentationAttributes(representationElement) {
    const attributes = {};
    const warnings = [];
    const parseValue = ValueParser(attributes, warnings);
    for (let i = 0; i < representationElement.attributes.length; i++) {
      const attr = representationElement.attributes[i];
      switch (attr.name) {
        case "audioSamplingRate":
          attributes.audioSamplingRate = attr.value;
          break;
        case "bandwidth":
          parseValue(attr.value, {
            asKey: "bitrate",
            parser: parseMPDInteger,
            dashName: "bandwidth"
          });
          break;
        case "codecs":
          attributes.codecs = attr.value;
          break;
        case "codingDependency":
          parseValue(attr.value, {
            asKey: "codingDependency",
            parser: parseBoolean,
            dashName: "codingDependency"
          });
          break;
        case "frameRate":
          parseValue(attr.value, {
            asKey: "frameRate",
            parser: parseMaybeDividedNumber,
            dashName: "frameRate"
          });
          break;
        case "height":
          parseValue(attr.value, {
            asKey: "height",
            parser: parseMPDInteger,
            dashName: "height"
          });
          break;
        case "id":
          attributes.id = attr.value;
          break;
        case "maxPlayoutRate":
          parseValue(attr.value, {
            asKey: "maxPlayoutRate",
            parser: parseMPDFloat,
            dashName: "maxPlayoutRate"
          });
          break;
        case "maximumSAPPeriod":
          parseValue(attr.value, {
            asKey: "maximumSAPPeriod",
            parser: parseMPDFloat,
            dashName: "maximumSAPPeriod"
          });
          break;
        case "mimeType":
          attributes.mimeType = attr.value;
          break;
        case "profiles":
          attributes.profiles = attr.value;
          break;
        case "qualityRanking":
          parseValue(attr.value, {
            asKey: "qualityRanking",
            parser: parseMPDInteger,
            dashName: "qualityRanking"
          });
          break;
        case "scte214:supplementalCodecs":
          attributes.supplementalCodecs = attr.value;
          break;
        case "segmentProfiles":
          attributes.segmentProfiles = attr.value;
          break;
        case "width":
          parseValue(attr.value, {
            asKey: "width",
            parser: parseMPDInteger,
            dashName: "width"
          });
          break;
        case "availabilityTimeOffset":
          parseValue(attr.value, {
            asKey: "availabilityTimeOffset",
            parser: parseMPDFloat,
            dashName: "availabilityTimeOffset"
          });
          break;
        case "availabilityTimeComplete":
          parseValue(attr.value, {
            asKey: "availabilityTimeComplete",
            parser: parseBoolean,
            dashName: "availabilityTimeComplete"
          });
          break;
      }
    }
    if (attributes.bitrate === void 0) {
      warnings.push(new MPDError("No bitrate found on a Representation"));
    }
    return [attributes, warnings];
  }
  function createRepresentationIntermediateRepresentation(representationElement) {
    const [children, childrenWarnings] = parseRepresentationChildren(
      representationElement.childNodes
    );
    const [attributes, attrsWarnings] = parseRepresentationAttributes(representationElement);
    const warnings = childrenWarnings.concat(attrsWarnings);
    return [{ children, attributes }, warnings];
  }

  // src/parsers/manifest/dash/native-parser/node_parsers/AdaptationSet.ts
  function parseAdaptationSetChildren(adaptationSetChildren) {
    const children = {
      baseURLs: [],
      representations: []
    };
    const contentProtections = [];
    let warnings = [];
    for (let i = 0; i < adaptationSetChildren.length; i++) {
      if (adaptationSetChildren[i].nodeType === Node.ELEMENT_NODE) {
        const currentElement = adaptationSetChildren[i];
        switch (currentElement.nodeName) {
          case "Accessibility":
            if (children.accessibilities === void 0) {
              children.accessibilities = [parseScheme(currentElement)];
            } else {
              children.accessibilities.push(parseScheme(currentElement));
            }
            break;
          case "BaseURL": {
            const [baseURLObj, baseURLWarnings] = parseBaseURL(currentElement);
            if (baseURLObj !== void 0) {
              children.baseURLs.push(baseURLObj);
            }
            if (baseURLWarnings.length > 0) {
              warnings = warnings.concat(baseURLWarnings);
            }
            break;
          }
          case "ContentComponent":
            children.contentComponent = parseContentComponent(currentElement);
            break;
          case "EssentialProperty":
            if (isNullOrUndefined(children.essentialProperties)) {
              children.essentialProperties = [parseScheme(currentElement)];
            } else {
              children.essentialProperties.push(parseScheme(currentElement));
            }
            break;
          case "InbandEventStream":
            if (children.inbandEventStreams === void 0) {
              children.inbandEventStreams = [];
            }
            children.inbandEventStreams.push(parseScheme(currentElement));
            break;
          case "Label": {
            const label = currentElement.textContent;
            if (label !== null && label !== void 0) {
              children.label = label;
            }
            break;
          }
          case "Representation": {
            const [representation, representationWarnings] = createRepresentationIntermediateRepresentation(currentElement);
            children.representations.push(representation);
            if (representationWarnings.length > 0) {
              warnings = warnings.concat(representationWarnings);
            }
            break;
          }
          case "Role":
            if (isNullOrUndefined(children.roles)) {
              children.roles = [parseScheme(currentElement)];
            } else {
              children.roles.push(parseScheme(currentElement));
            }
            break;
          case "SupplementalProperty":
            if (isNullOrUndefined(children.supplementalProperties)) {
              children.supplementalProperties = [parseScheme(currentElement)];
            } else {
              children.supplementalProperties.push(parseScheme(currentElement));
            }
            break;
          case "SegmentBase": {
            const [segmentBase, segmentBaseWarnings] = parseSegmentBase(currentElement);
            children.segmentBase = segmentBase;
            if (segmentBaseWarnings.length > 0) {
              warnings = warnings.concat(segmentBaseWarnings);
            }
            break;
          }
          case "SegmentList": {
            const [segmentList, segmentListWarnings] = parseSegmentList(currentElement);
            children.segmentList = segmentList;
            if (segmentListWarnings.length > 0) {
              warnings = warnings.concat(segmentListWarnings);
            }
            break;
          }
          case "SegmentTemplate": {
            const [segmentTemplate, segmentTemplateWarnings] = parseSegmentTemplate(currentElement);
            children.segmentTemplate = segmentTemplate;
            if (segmentTemplateWarnings.length > 0) {
              warnings = warnings.concat(segmentTemplateWarnings);
            }
            break;
          }
          case "ContentProtection": {
            const [contentProtection, contentProtectionWarnings] = parseContentProtection2(currentElement);
            if (contentProtectionWarnings.length > 0) {
              warnings = warnings.concat(contentProtectionWarnings);
            }
            if (contentProtection !== void 0) {
              contentProtections.push(contentProtection);
            }
            break;
          }
        }
      }
    }
    if (contentProtections.length > 0) {
      children.contentProtections = contentProtections;
    }
    return [children, warnings];
  }
  function parseAdaptationSetAttributes(root) {
    const parsedAdaptation = {};
    const warnings = [];
    const parseValue = ValueParser(parsedAdaptation, warnings);
    for (let i = 0; i < root.attributes.length; i++) {
      const attribute = root.attributes[i];
      switch (attribute.name) {
        case "id":
          parsedAdaptation.id = attribute.value;
          break;
        case "group":
          parseValue(attribute.value, {
            asKey: "group",
            parser: parseMPDInteger,
            dashName: "group"
          });
          break;
        case "lang":
          parsedAdaptation.language = attribute.value;
          break;
        case "contentType":
          parsedAdaptation.contentType = attribute.value;
          break;
        case "par":
          parsedAdaptation.par = attribute.value;
          break;
        case "minBandwidth":
          parseValue(attribute.value, {
            asKey: "minBitrate",
            parser: parseMPDInteger,
            dashName: "minBandwidth"
          });
          break;
        case "maxBandwidth":
          parseValue(attribute.value, {
            asKey: "maxBitrate",
            parser: parseMPDInteger,
            dashName: "maxBandwidth"
          });
          break;
        case "minWidth":
          parseValue(attribute.value, {
            asKey: "minWidth",
            parser: parseMPDInteger,
            dashName: "minWidth"
          });
          break;
        case "maxWidth":
          parseValue(attribute.value, {
            asKey: "maxWidth",
            parser: parseMPDInteger,
            dashName: "maxWidth"
          });
          break;
        case "minHeight":
          parseValue(attribute.value, {
            asKey: "minHeight",
            parser: parseMPDInteger,
            dashName: "minHeight"
          });
          break;
        case "maxHeight":
          parseValue(attribute.value, {
            asKey: "maxHeight",
            parser: parseMPDInteger,
            dashName: "maxHeight"
          });
          break;
        case "minFrameRate":
          parseValue(attribute.value, {
            asKey: "minFrameRate",
            parser: parseMaybeDividedNumber,
            dashName: "minFrameRate"
          });
          break;
        case "maxFrameRate":
          parseValue(attribute.value, {
            asKey: "maxFrameRate",
            parser: parseMaybeDividedNumber,
            dashName: "maxFrameRate"
          });
          break;
        case "selectionPriority":
          parseValue(attribute.value, {
            asKey: "selectionPriority",
            parser: parseMPDInteger,
            dashName: "selectionPriority"
          });
          break;
        case "segmentAlignment":
          parseValue(attribute.value, {
            asKey: "segmentAlignment",
            parser: parseIntOrBoolean,
            dashName: "segmentAlignment"
          });
          break;
        case "subsegmentAlignment":
          parseValue(attribute.value, {
            asKey: "subsegmentAlignment",
            parser: parseIntOrBoolean,
            dashName: "subsegmentAlignment"
          });
          break;
        case "bitstreamSwitching":
          parseValue(attribute.value, {
            asKey: "bitstreamSwitching",
            parser: parseBoolean,
            dashName: "bitstreamSwitching"
          });
          break;
        case "audioSamplingRate":
          parsedAdaptation.audioSamplingRate = attribute.value;
          break;
        case "codecs":
          parsedAdaptation.codecs = attribute.value;
          break;
        case "scte214:supplementalCodecs":
          parsedAdaptation.supplementalCodecs = attribute.value;
          break;
        case "codingDependency":
          parseValue(attribute.value, {
            asKey: "codingDependency",
            parser: parseBoolean,
            dashName: "codingDependency"
          });
          break;
        case "frameRate":
          parseValue(attribute.value, {
            asKey: "frameRate",
            parser: parseMaybeDividedNumber,
            dashName: "frameRate"
          });
          break;
        case "height":
          parseValue(attribute.value, {
            asKey: "height",
            parser: parseMPDInteger,
            dashName: "height"
          });
          break;
        case "maxPlayoutRate":
          parseValue(attribute.value, {
            asKey: "maxPlayoutRate",
            parser: parseMPDFloat,
            dashName: "maxPlayoutRate"
          });
          break;
        case "maximumSAPPeriod":
          parseValue(attribute.value, {
            asKey: "maximumSAPPeriod",
            parser: parseMPDFloat,
            dashName: "maximumSAPPeriod"
          });
          break;
        case "mimeType":
          parsedAdaptation.mimeType = attribute.value;
          break;
        case "profiles":
          parsedAdaptation.profiles = attribute.value;
          break;
        case "segmentProfiles":
          parsedAdaptation.segmentProfiles = attribute.value;
          break;
        case "width":
          parseValue(attribute.value, {
            asKey: "width",
            parser: parseMPDInteger,
            dashName: "width"
          });
          break;
        case "availabilityTimeOffset":
          parseValue(attribute.value, {
            asKey: "availabilityTimeOffset",
            parser: parseMPDFloat,
            dashName: "availabilityTimeOffset"
          });
          break;
        case "availabilityTimeComplete":
          parseValue(attribute.value, {
            asKey: "availabilityTimeComplete",
            parser: parseBoolean,
            dashName: "availabilityTimeComplete"
          });
          break;
      }
    }
    return [parsedAdaptation, warnings];
  }
  function createAdaptationSetIntermediateRepresentation(adaptationSetElement) {
    const childNodes = adaptationSetElement.childNodes;
    const [children, childrenWarnings] = parseAdaptationSetChildren(childNodes);
    const [attributes, attrsWarnings] = parseAdaptationSetAttributes(adaptationSetElement);
    const warnings = childrenWarnings.concat(attrsWarnings);
    return [{ children, attributes }, warnings];
  }

  // src/parsers/manifest/dash/native-parser/node_parsers/EventStream.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function parseEventStream(element) {
    const eventStreamIR = {
      children: { events: [] },
      attributes: {}
    };
    let warnings = [];
    const parseValue = ValueParser(eventStreamIR.attributes, warnings);
    for (let i = 0; i < element.attributes.length; i++) {
      const attr = element.attributes[i];
      switch (attr.name) {
        case "schemeIdUri":
          eventStreamIR.attributes.schemeIdUri = attr.value;
          break;
        case "timescale":
          parseValue(attr.value, {
            asKey: "timescale",
            parser: parseMPDInteger,
            dashName: "timescale"
          });
          break;
        case "value":
          eventStreamIR.attributes.value = attr.value;
          break;
      }
    }
    for (let i = 0; i < element.childNodes.length; i++) {
      if (element.childNodes[i].nodeType === Node.ELEMENT_NODE) {
        const currentElement = element.childNodes[i];
        switch (currentElement.nodeName) {
          case "Event": {
            const [event, eventWarnings] = parseEvent(currentElement);
            eventStreamIR.children.events.push(event);
            if (eventWarnings.length > 0) {
              warnings = warnings.concat(eventWarnings);
            }
            break;
          }
        }
      }
    }
    return [eventStreamIR, warnings];
  }
  function parseEvent(element) {
    const eventIR = {
      eventStreamData: element
    };
    const warnings = [];
    const parseValue = ValueParser(eventIR, warnings);
    for (let i = 0; i < element.attributes.length; i++) {
      const attr = element.attributes[i];
      switch (attr.name) {
        case "presentationTime":
          parseValue(attr.value, {
            asKey: "presentationTime",
            parser: parseMPDInteger,
            dashName: "presentationTime"
          });
          break;
        case "duration":
          parseValue(attr.value, {
            asKey: "duration",
            parser: parseMPDInteger,
            dashName: "duration"
          });
          break;
        case "id":
          eventIR.id = attr.value;
          break;
      }
    }
    return [eventIR, warnings];
  }

  // src/parsers/manifest/dash/native-parser/node_parsers/Period.ts
  function parsePeriodChildren(periodChildren) {
    const baseURLs = [];
    const adaptations = [];
    let segmentTemplate;
    const contentProtections = [];
    let warnings = [];
    const eventStreams = [];
    for (let i = 0; i < periodChildren.length; i++) {
      if (periodChildren[i].nodeType === Node.ELEMENT_NODE) {
        const currentElement = periodChildren[i];
        switch (currentElement.nodeName) {
          case "BaseURL": {
            const [baseURLObj, baseURLWarnings] = parseBaseURL(currentElement);
            if (baseURLObj !== void 0) {
              baseURLs.push(baseURLObj);
            }
            warnings = warnings.concat(baseURLWarnings);
            break;
          }
          case "AdaptationSet": {
            const [adaptation, adaptationWarnings] = createAdaptationSetIntermediateRepresentation(currentElement);
            adaptations.push(adaptation);
            warnings = warnings.concat(adaptationWarnings);
            break;
          }
          case "EventStream": {
            const [eventStream, eventStreamWarnings] = parseEventStream(currentElement);
            eventStreams.push(eventStream);
            warnings = warnings.concat(eventStreamWarnings);
            break;
          }
          case "SegmentTemplate": {
            const [parsedSegmentTemplate, segmentTemplateWarnings] = parseSegmentTemplate(currentElement);
            segmentTemplate = parsedSegmentTemplate;
            if (segmentTemplateWarnings.length > 0) {
              warnings = warnings.concat(segmentTemplateWarnings);
            }
            break;
          }
          case "ContentProtection": {
            const [contentProtection, contentProtectionWarnings] = parseContentProtection2(currentElement);
            if (contentProtectionWarnings.length > 0) {
              warnings = warnings.concat(contentProtectionWarnings);
            }
            if (contentProtection !== void 0) {
              contentProtections.push(contentProtection);
            }
            break;
          }
        }
      }
    }
    return [
      { baseURLs, adaptations, eventStreams, segmentTemplate, contentProtections },
      warnings
    ];
  }
  function parsePeriodAttributes(periodElement) {
    const res = {};
    const warnings = [];
    const parseValue = ValueParser(res, warnings);
    for (let i = 0; i < periodElement.attributes.length; i++) {
      const attr = periodElement.attributes[i];
      switch (attr.name) {
        case "id":
          res.id = attr.value;
          break;
        case "start":
          parseValue(attr.value, {
            asKey: "start",
            parser: parseDuration,
            dashName: "start"
          });
          break;
        case "duration":
          parseValue(attr.value, {
            asKey: "duration",
            parser: parseDuration,
            dashName: "duration"
          });
          break;
        case "bitstreamSwitching":
          parseValue(attr.value, {
            asKey: "bitstreamSwitching",
            parser: parseBoolean,
            dashName: "bitstreamSwitching"
          });
          break;
        case "xlink:href":
          res.xlinkHref = attr.value;
          break;
        case "xlink:actuate":
          res.xlinkActuate = attr.value;
          break;
      }
    }
    return [res, warnings];
  }
  function createPeriodIntermediateRepresentation(periodElement) {
    const [children, childrenWarnings] = parsePeriodChildren(periodElement.childNodes);
    const [attributes, attrsWarnings] = parsePeriodAttributes(periodElement);
    const warnings = childrenWarnings.concat(attrsWarnings);
    return [{ children, attributes }, warnings];
  }

  // src/parsers/manifest/dash/native-parser/node_parsers/MPD.ts
  function parseMPDChildren(mpdChildren) {
    const baseURLs = [];
    const locations = [];
    const periods = [];
    const utcTimings = [];
    const contentProtections = [];
    let warnings = [];
    for (let i = 0; i < mpdChildren.length; i++) {
      if (mpdChildren[i].nodeType === Node.ELEMENT_NODE) {
        const currentNode = mpdChildren[i];
        switch (currentNode.nodeName) {
          case "BaseURL": {
            const [baseURLObj, baseURLWarnings] = parseBaseURL(currentNode);
            if (baseURLObj !== void 0) {
              baseURLs.push(baseURLObj);
            }
            warnings = warnings.concat(baseURLWarnings);
            break;
          }
          case "Location":
            locations.push(currentNode.textContent === null ? "" : currentNode.textContent);
            break;
          case "Period": {
            const [period, periodWarnings] = createPeriodIntermediateRepresentation(currentNode);
            periods.push(period);
            warnings = warnings.concat(periodWarnings);
            break;
          }
          case "UTCTiming": {
            const utcTiming = parseScheme(currentNode);
            utcTimings.push(utcTiming);
            break;
          }
          case "ContentProtection": {
            const [contentProtection, contentProtectionWarnings] = parseContentProtection2(currentNode);
            if (contentProtectionWarnings.length > 0) {
              warnings = warnings.concat(contentProtectionWarnings);
            }
            if (contentProtection !== void 0) {
              contentProtections.push(contentProtection);
            }
            break;
          }
        }
      }
    }
    return [{ baseURLs, locations, periods, utcTimings, contentProtections }, warnings];
  }
  function parseMPDAttributes(root) {
    const res = {};
    const warnings = [];
    const parseValue = ValueParser(res, warnings);
    for (let i = 0; i < root.attributes.length; i++) {
      const attribute = root.attributes[i];
      switch (attribute.name) {
        case "id":
          res.id = attribute.value;
          break;
        case "profiles":
          res.profiles = attribute.value;
          break;
        case "type":
          res.type = attribute.value;
          break;
        case "availabilityStartTime":
          parseValue(attribute.value, {
            asKey: "availabilityStartTime",
            parser: parseDateTime,
            dashName: "availabilityStartTime"
          });
          break;
        case "availabilityEndTime":
          parseValue(attribute.value, {
            asKey: "availabilityEndTime",
            parser: parseDateTime,
            dashName: "availabilityEndTime"
          });
          break;
        case "publishTime":
          parseValue(attribute.value, {
            asKey: "publishTime",
            parser: parseDateTime,
            dashName: "publishTime"
          });
          break;
        case "mediaPresentationDuration":
          parseValue(attribute.value, {
            asKey: "duration",
            parser: parseDuration,
            dashName: "mediaPresentationDuration"
          });
          break;
        case "minimumUpdatePeriod":
          parseValue(attribute.value, {
            asKey: "minimumUpdatePeriod",
            parser: parseDuration,
            dashName: "minimumUpdatePeriod"
          });
          break;
        case "minBufferTime":
          parseValue(attribute.value, {
            asKey: "minBufferTime",
            parser: parseDuration,
            dashName: "minBufferTime"
          });
          break;
        case "timeShiftBufferDepth":
          parseValue(attribute.value, {
            asKey: "timeShiftBufferDepth",
            parser: parseDuration,
            dashName: "timeShiftBufferDepth"
          });
          break;
        case "suggestedPresentationDelay":
          parseValue(attribute.value, {
            asKey: "suggestedPresentationDelay",
            parser: parseDuration,
            dashName: "suggestedPresentationDelay"
          });
          break;
        case "maxSegmentDuration":
          parseValue(attribute.value, {
            asKey: "maxSegmentDuration",
            parser: parseDuration,
            dashName: "maxSegmentDuration"
          });
          break;
        case "maxSubsegmentDuration":
          parseValue(attribute.value, {
            asKey: "maxSubsegmentDuration",
            parser: parseDuration,
            dashName: "maxSubsegmentDuration"
          });
          break;
      }
    }
    return [res, warnings];
  }
  function createMPDIntermediateRepresentation(root) {
    const [children, childrenWarnings] = parseMPDChildren(root.childNodes);
    const [attributes, attrsWarnings] = parseMPDAttributes(root);
    const warnings = childrenWarnings.concat(attrsWarnings);
    return [{ children, attributes }, warnings];
  }

  // src/parsers/manifest/dash/native-parser/parse_from_document.ts
  function parseFromDocument(document3, args) {
    const root = document3.documentElement;
    if (isNullOrUndefined(root) || root.nodeName !== "MPD") {
      throw new Error("DASH Parser: document root should be MPD");
    }
    const [mpdIR, warnings] = createMPDIntermediateRepresentation(root);
    const ret = common_default(mpdIR, args, warnings);
    return processReturn(ret);
    function processReturn(initialRes) {
      if (initialRes.type === "done") {
        return initialRes;
      } else if (initialRes.type === "needs-clock") {
        return {
          type: "needs-resources",
          value: {
            urls: [initialRes.value.url],
            format: "string",
            continue(loadedClock) {
              if (loadedClock.length !== 1) {
                throw new Error("DASH parser: wrong number of loaded ressources.");
              }
              const newRet = initialRes.value.continue(loadedClock[0].responseData);
              return processReturn(newRet);
            }
          }
        };
      } else if (initialRes.type === "needs-xlinks") {
        return {
          type: "needs-resources",
          value: {
            urls: initialRes.value.xlinksUrls,
            format: "string",
            continue(loadedXlinks) {
              const resourceInfos = [];
              for (let i = 0; i < loadedXlinks.length; i++) {
                const {
                  responseData: xlinkResp,
                  receivedTime,
                  sendingTime,
                  url
                } = loadedXlinks[i];
                if (!xlinkResp.success) {
                  throw xlinkResp.error;
                }
                const wrappedData = "<root>" + xlinkResp.data + "</root>";
                const dataAsXML = new DOMParser().parseFromString(wrappedData, "text/xml");
                if (isNullOrUndefined(dataAsXML) || dataAsXML.children.length === 0) {
                  throw new Error("DASH parser: Invalid external ressources");
                }
                const periods = dataAsXML.children[0].children;
                const periodsIR = [];
                const periodsIRWarnings = [];
                for (let j = 0; j < periods.length; j++) {
                  if (periods[j].nodeType === Node.ELEMENT_NODE) {
                    const [periodIR, periodWarnings] = createPeriodIntermediateRepresentation(periods[j]);
                    periodsIRWarnings.push(...periodWarnings);
                    periodsIR.push(periodIR);
                  }
                }
                resourceInfos.push({
                  url,
                  receivedTime,
                  sendingTime,
                  parsed: periodsIR,
                  warnings: periodsIRWarnings
                });
              }
              const newRet = initialRes.value.continue(resourceInfos);
              return processReturn(newRet);
            }
          }
        };
      } else {
        assertUnreachable(initialRes);
      }
    }
  }

  // src/parsers/manifest/dash/native-parser/index.ts
  var native_parser_default = parseFromDocument;

  // src/transports/dash/index.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/transports/dash/pipelines.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/transports/utils/generate_manifest_loader.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/transports/utils/add_query_string.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function addQueryString(baseUrl, supplementaryQueryStringData) {
    if (supplementaryQueryStringData.length === 0) {
      return baseUrl;
    }
    let queryStringStartingChar;
    let urlFragment = "";
    const indexOfFragment = baseUrl.indexOf("#");
    let baseUrlWithoutFragment = baseUrl;
    if (indexOfFragment >= 0) {
      urlFragment = baseUrl.substring(indexOfFragment);
      baseUrlWithoutFragment = baseUrl.substring(0, indexOfFragment);
    }
    const indexOfQueryString = baseUrlWithoutFragment.indexOf("?");
    if (indexOfQueryString === -1) {
      queryStringStartingChar = "?";
    } else if (indexOfQueryString + 1 === baseUrlWithoutFragment.length) {
      queryStringStartingChar = "";
    } else {
      queryStringStartingChar = "&";
    }
    let url = baseUrlWithoutFragment + queryStringStartingChar;
    for (let i = 0; i < supplementaryQueryStringData.length; i++) {
      const queryStringElt = supplementaryQueryStringData[i];
      if (queryStringElt[1] === null) {
        url += queryStringElt[0];
      } else {
        url += `${queryStringElt[0]}=${queryStringElt[1]}`;
      }
      if (i < supplementaryQueryStringData.length - 1) {
        url += "&";
      }
    }
    if (urlFragment.length > 0) {
      url += urlFragment;
    }
    return url;
  }

  // src/transports/utils/call_custom_manifest_loader.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function callCustomManifestLoader(customManifestLoader, fallbackManifestLoader) {
    return (url, loaderOptions, cancelSignal) => {
      return new Promise((res, rej) => {
        const timeAPIsDelta = Date.now() - monotonic_timestamp_default();
        let hasFinished = false;
        const resolve = (_args) => {
          if (hasFinished || cancelSignal.isCancelled()) {
            return;
          }
          hasFinished = true;
          cancelSignal.deregister(abortCustomLoader);
          const receivedTime = _args.receivingTime !== void 0 ? _args.receivingTime - timeAPIsDelta : void 0;
          const sendingTime = _args.sendingTime !== void 0 ? _args.sendingTime - timeAPIsDelta : void 0;
          res({
            responseData: _args.data,
            size: _args.size,
            requestDuration: _args.duration,
            url: _args.url,
            receivedTime,
            sendingTime
          });
        };
        const reject = (err) => {
          var _a, _b;
          if (hasFinished || cancelSignal.isCancelled()) {
            return;
          }
          hasFinished = true;
          cancelSignal.deregister(abortCustomLoader);
          const castedErr = err;
          const message = (_a = castedErr == null ? void 0 : castedErr.message) != null ? _a : "Unknown error when fetching the Manifest through a custom manifestLoader.";
          const emittedErr = new CustomLoaderError(
            message,
            (_b = castedErr == null ? void 0 : castedErr.canRetry) != null ? _b : false,
            castedErr == null ? void 0 : castedErr.xhr
          );
          rej(emittedErr);
        };
        const fallback = () => {
          if (hasFinished || cancelSignal.isCancelled()) {
            return;
          }
          hasFinished = true;
          cancelSignal.deregister(abortCustomLoader);
          fallbackManifestLoader(url, loaderOptions, cancelSignal).then(res, rej);
        };
        const callbacks = { reject, resolve, fallback };
        const abort = customManifestLoader(
          { url, timeout: loaderOptions.timeout, cmcdPayload: loaderOptions.cmcdPayload },
          callbacks
        );
        cancelSignal.register(abortCustomLoader);
        function abortCustomLoader(err) {
          if (hasFinished) {
            return;
          }
          hasFinished = true;
          if (typeof abort === "function") {
            abort();
          }
          rej(err);
        }
      });
    };
  }

  // src/transports/utils/generate_manifest_loader.ts
  function generateRegularManifestLoader(preferredType) {
    return function regularManifestLoader2(initialUrl, loaderOptions, cancelSignal) {
      var _a, _b;
      if (initialUrl === void 0) {
        throw new Error("Cannot perform HTTP(s) request. URL not known");
      }
      const url = ((_a = loaderOptions.cmcdPayload) == null ? void 0 : _a.type) === "query" ? addQueryString(initialUrl, loaderOptions.cmcdPayload.value) : initialUrl;
      const cmcdHeaders = ((_b = loaderOptions.cmcdPayload) == null ? void 0 : _b.type) === "headers" ? loaderOptions.cmcdPayload.value : void 0;
      switch (preferredType) {
        case "arraybuffer":
          return request_default({
            url,
            headers: cmcdHeaders,
            responseType: "arraybuffer",
            timeout: loaderOptions.timeout,
            connectionTimeout: loaderOptions.connectionTimeout,
            cancelSignal
          });
        case "text":
          return request_default({
            url,
            headers: cmcdHeaders,
            responseType: "text",
            timeout: loaderOptions.timeout,
            connectionTimeout: loaderOptions.connectionTimeout,
            cancelSignal
          });
        case "document":
          return request_default({
            url,
            headers: cmcdHeaders,
            responseType: "document",
            timeout: loaderOptions.timeout,
            connectionTimeout: loaderOptions.connectionTimeout,
            cancelSignal
          });
        default:
          assertUnreachable(preferredType);
      }
    };
  }
  function generateManifestLoader({ customManifestLoader }, preferredType, integrityCheck) {
    const regularManifestLoader2 = generateRegularManifestLoader(preferredType);
    const actualLoader = typeof customManifestLoader !== "function" ? regularManifestLoader2 : callCustomManifestLoader(customManifestLoader, regularManifestLoader2);
    return integrityCheck !== null ? integrityCheck(actualLoader) : actualLoader;
  }

  // src/transports/dash/integrity_checks.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/transports/utils/check_isobmff_integrity.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function checkISOBMFFIntegrity(buffer, isInitSegment) {
    if (isInitSegment) {
      const ftypIndex = findCompleteBox(
        buffer,
        1718909296
        /* ftyp */
      );
      if (ftypIndex < 0) {
        throw new OtherError("INTEGRITY_ERROR", "Incomplete `ftyp` box");
      }
      const moovIndex = findCompleteBox(
        buffer,
        1836019574
        /* moov */
      );
      if (moovIndex < 0) {
        throw new OtherError("INTEGRITY_ERROR", "Incomplete `moov` box");
      }
    } else {
      const moofIndex = findCompleteBox(
        buffer,
        1836019558
        /* moof */
      );
      if (moofIndex < 0) {
        throw new OtherError("INTEGRITY_ERROR", "Incomplete `moof` box");
      }
      const mdatIndex = findCompleteBox(
        buffer,
        1835295092
        /* mdat */
      );
      if (mdatIndex < 0) {
        throw new OtherError("INTEGRITY_ERROR", "Incomplete `mdat` box");
      }
    }
  }

  // src/transports/utils/infer_segment_container.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function inferSegmentContainer(adaptationType, mimeType) {
    if (adaptationType === "audio" || adaptationType === "video") {
      if (mimeType === "video/mp4" || mimeType === "audio/mp4") {
        return "mp4";
      }
      if (mimeType === "video/webm" || mimeType === "audio/webm") {
        return "webm";
      }
      return void 0;
    } else if (adaptationType === "text") {
      return mimeType === "application/mp4" ? "mp4" : void 0;
    }
    return void 0;
  }

  // src/transports/dash/integrity_checks.ts
  function addSegmentIntegrityChecks(segmentLoader) {
    return (url, context, loaderOptions, initialCancelSignal, callbacks) => {
      return new Promise((resolve, reject) => {
        const requestCanceller = new TaskCanceller();
        const unlinkCanceller = requestCanceller.linkToSignal(initialCancelSignal);
        requestCanceller.signal.register(reject);
        segmentLoader(url, context, loaderOptions, requestCanceller.signal, __spreadProps(__spreadValues({}, callbacks), {
          onNewChunk(data2) {
            try {
              throwOnIntegrityError(data2);
              callbacks.onNewChunk(data2);
            } catch (err) {
              cleanUpCancellers();
              requestCanceller.cancel();
              reject(err);
            }
          }
        })).then(
          (info) => {
            cleanUpCancellers();
            if (requestCanceller.isUsed()) {
              return;
            }
            if (info.resultType === "segment-loaded") {
              try {
                throwOnIntegrityError(info.resultData.responseData);
              } catch (err) {
                reject(err);
                return;
              }
            }
            resolve(info);
          },
          (err) => {
            cleanUpCancellers();
            reject(err);
          }
        );
        function cleanUpCancellers() {
          requestCanceller.signal.deregister(reject);
          unlinkCanceller();
        }
      });
      function throwOnIntegrityError(data2) {
        if (!(data2 instanceof ArrayBuffer) && !(data2 instanceof Uint8Array) || inferSegmentContainer(context.type, context.mimeType) !== "mp4") {
          return;
        }
        checkISOBMFFIntegrity(new Uint8Array(data2), context.segment.isInit);
      }
    };
  }
  function addManifestIntegrityChecks(manifestLoader) {
    return async (url, options, initialCancelSignal) => {
      const res = await manifestLoader(url, options, initialCancelSignal);
      throwOnIntegrityError(res.responseData);
      return res;
      function throwOnIntegrityError(data2) {
        if (typeof data2 === "string") {
          let currOffset = data2.length - 1;
          const expectedStrings = ["</", "MPD", ">"];
          for (let i = expectedStrings.length - 1; i >= 0; i--) {
            const currentExpectedStr = expectedStrings[i];
            while (isCharXmlWhiteSpace(data2[currOffset])) {
              currOffset--;
            }
            for (let j = currentExpectedStr.length - 1; j >= 0; j--) {
              if (data2[currOffset] !== currentExpectedStr[j]) {
                throw new Error("INTEGRITY_ERROR MPD does not end with </MPD>");
              } else {
                currOffset--;
              }
            }
          }
        } else if (data2 instanceof ArrayBuffer) {
          let currOffset = data2.byteLength - 1;
          const dv = new DataView(data2);
          const expectedCharGroups = [[60, 47], [77, 80, 68], [62]];
          for (let i = expectedCharGroups.length - 1; i >= 0; i--) {
            const currentExpectedCharGroup = expectedCharGroups[i];
            while (isUtf8XmlWhiteSpace(dv.getUint8(currOffset))) {
              currOffset--;
            }
            for (let j = currentExpectedCharGroup.length - 1; j >= 0; j--) {
              if (dv.getUint8(currOffset) !== currentExpectedCharGroup[j]) {
                throw new Error("INTEGRITY_ERROR MPD does not end with </MPD>");
              } else {
                currOffset--;
              }
            }
          }
        } else if (!isNullOrUndefined(global_scope_default.Document) && data2 instanceof global_scope_default.Document) {
          if (data2.documentElement.nodeName !== "MPD") {
            throw new OtherError("INTEGRITY_ERROR", "MPD does not end with </MPD>");
          }
        }
      }
    };
  }
  function isCharXmlWhiteSpace(char) {
    return char === " " || char === "	" || char === "\r" || char === "\n";
  }
  function isUtf8XmlWhiteSpace(char) {
    return char === 32 || char === 9 || char === 13 || char === 10;
  }

  // src/transports/dash/manifest_parser.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function generateManifestParser(options) {
    const { referenceDateTime } = options;
    const serverTimeOffset = options.serverSyncInfos !== void 0 ? options.serverSyncInfos.serverTimestamp - options.serverSyncInfos.clientTime : void 0;
    return function manifestParser(manifestData, parserOptions, onWarnings, cancelSignal, scheduleRequest) {
      var _a;
      const { responseData } = manifestData;
      const argClockOffset = parserOptions.externalClockOffset;
      const url = (_a = manifestData.url) != null ? _a : parserOptions.originalUrl;
      const externalClockOffset = serverTimeOffset != null ? serverTimeOffset : argClockOffset;
      const unsafelyBaseOnPreviousManifest = parserOptions.unsafeMode ? parserOptions.previousManifest : null;
      const dashParserOpts = {
        unsafelyBaseOnPreviousManifest,
        url,
        referenceDateTime,
        externalClockOffset
      };
      const parsers = features_default.dashParsers;
      if (parsers.wasm === null || parsers.wasm.status === "uninitialized" || parsers.wasm.status === "failure") {
        log_default.debug("DASH: WASM MPD Parser not initialized. Running JS one.");
        return runDefaultJsParser();
      } else {
        const manifestAB = getManifestAsArrayBuffer(responseData);
        if (!doesXmlSeemsUtf8Encoded(manifestAB)) {
          log_default.info(
            "DASH: MPD doesn't seem to be UTF-8-encoded. Running JS parser instead of the WASM one."
          );
          return runDefaultJsParser();
        }
        if (parsers.wasm.status === "initialized") {
          log_default.debug("DASH: Running WASM MPD Parser.");
          const parsed = parsers.wasm.runWasmParser(manifestAB, dashParserOpts);
          return processMpdParserResponse(parsed);
        } else {
          log_default.debug("DASH: Awaiting WASM initialization before parsing the MPD.");
          const initProm = parsers.wasm.waitForInitialization().catch(() => {
          });
          return initProm.then(() => {
            if (parsers.wasm === null || parsers.wasm.status !== "initialized") {
              log_default.warn(
                "DASH: WASM MPD parser initialization failed. Running JS parser instead"
              );
              return runDefaultJsParser();
            }
            log_default.debug("DASH: Running WASM MPD Parser.");
            const parsed = parsers.wasm.runWasmParser(manifestAB, dashParserOpts);
            return processMpdParserResponse(parsed);
          });
        }
      }
      function runDefaultJsParser() {
        if (parsers.fastJs !== null) {
          const manifestStr = getManifestAsString(responseData);
          const parsedManifest = parsers.fastJs(manifestStr, dashParserOpts);
          return processMpdParserResponse(parsedManifest);
        } else if (parsers.native !== null) {
          const manifestDocument = getManifestAsDocument(responseData);
          const parsedManifest = parsers.native(manifestDocument, dashParserOpts);
          return processMpdParserResponse(parsedManifest);
        } else {
          throw new Error("No MPD parser is imported");
        }
      }
      function processMpdParserResponse(parserResponse) {
        if (parserResponse.type === "done") {
          if (parserResponse.value.warnings.length > 0) {
            onWarnings(parserResponse.value.warnings);
          }
          if (cancelSignal.isCancelled()) {
            return Promise.reject(cancelSignal.cancellationError);
          }
          const warnings = [];
          const manifest = new classes_default(parserResponse.value.parsed, options, warnings);
          return { manifest, url, warnings };
        }
        const { value } = parserResponse;
        const externalResources = value.urls.map((resourceUrl) => {
          return scheduleRequest(() => {
            const defaultTimeout = config_default.getCurrent().DEFAULT_REQUEST_TIMEOUT;
            const defaultConnectionTimeout = config_default.getCurrent().DEFAULT_CONNECTION_TIMEOUT;
            return value.format === "string" ? request_default({
              url: resourceUrl,
              responseType: "text",
              timeout: defaultTimeout,
              connectionTimeout: defaultConnectionTimeout,
              cancelSignal
            }) : request_default({
              url: resourceUrl,
              responseType: "arraybuffer",
              timeout: defaultTimeout,
              connectionTimeout: defaultConnectionTimeout,
              cancelSignal
            });
          }).then(
            (res) => {
              if (value.format === "string") {
                if (typeof res.responseData !== "string") {
                  throw new Error("External DASH resources should have been a string");
                }
                return object_assign_default(res, {
                  responseData: {
                    success: true,
                    data: res.responseData
                  }
                });
              } else {
                if (!(res.responseData instanceof ArrayBuffer)) {
                  throw new Error("External DASH resources should have been ArrayBuffers");
                }
                return object_assign_default(res, {
                  responseData: {
                    success: true,
                    data: res.responseData
                  }
                });
              }
            },
            (err) => {
              const error = formatError(err, {
                defaultCode: "PIPELINE_PARSE_ERROR",
                defaultReason: "An unknown error occured when parsing ressources."
              });
              return object_assign_default(
                {},
                {
                  size: void 0,
                  requestDuration: void 0,
                  responseData: {
                    success: false,
                    error
                  }
                }
              );
            }
          );
        });
        return Promise.all(externalResources).then((loadedResources) => {
          if (value.format === "string") {
            assertLoadedResourcesFormatString(loadedResources);
            return processMpdParserResponse(value.continue(loadedResources));
          } else {
            assertLoadedResourcesFormatArrayBuffer(loadedResources);
            return processMpdParserResponse(value.continue(loadedResources));
          }
        });
      }
    };
  }
  function assertLoadedResourcesFormatString(loadedResources) {
    if (define_ENVIRONMENT_default.CURRENT_ENV === define_ENVIRONMENT_default.PRODUCTION) {
      return;
    }
    loadedResources.forEach((loadedResource) => {
      const { responseData } = loadedResource;
      if (responseData.success && typeof responseData.data === "string") {
        return;
      } else if (!responseData.success) {
        return;
      }
      throw new Error("Invalid data given to the LoadedRessource");
    });
  }
  function assertLoadedResourcesFormatArrayBuffer(loadedResources) {
    if (define_ENVIRONMENT_default.CURRENT_ENV === define_ENVIRONMENT_default.PRODUCTION) {
      return;
    }
    loadedResources.forEach((loadedResource) => {
      const { responseData } = loadedResource;
      if (responseData.success && responseData.data instanceof ArrayBuffer) {
        return;
      } else if (!responseData.success) {
        return;
      }
      throw new Error("Invalid data given to the LoadedRessource");
    });
  }
  function getManifestAsString(manifestSrc) {
    if (manifestSrc instanceof ArrayBuffer) {
      return utf8ToStr(new Uint8Array(manifestSrc));
    } else if (typeof manifestSrc === "string") {
      return manifestSrc;
    } else if (manifestSrc instanceof Document) {
      return manifestSrc.documentElement.outerHTML;
    } else {
      throw new Error("DASH Manifest Parser: Unrecognized Manifest format");
    }
  }
  function getManifestAsDocument(manifestSrc) {
    if (manifestSrc instanceof ArrayBuffer) {
      return new DOMParser().parseFromString(
        utf8ToStr(new Uint8Array(manifestSrc)),
        "text/xml"
      );
    } else if (typeof manifestSrc === "string") {
      return new DOMParser().parseFromString(manifestSrc, "text/xml");
    } else if (manifestSrc instanceof Document) {
      return manifestSrc;
    } else {
      throw new Error("DASH Manifest Parser: Unrecognized Manifest format");
    }
  }
  function getManifestAsArrayBuffer(manifestSrc) {
    if (manifestSrc instanceof ArrayBuffer) {
      return manifestSrc;
    } else if (typeof manifestSrc === "string") {
      return strToUtf8(manifestSrc).buffer;
    } else if (manifestSrc instanceof Document) {
      return strToUtf8(manifestSrc.documentElement.innerHTML).buffer;
    } else {
      throw new Error("DASH Manifest Parser: Unrecognized Manifest format");
    }
  }
  function doesXmlSeemsUtf8Encoded(xmlData) {
    const dv = new DataView(xmlData);
    if (dv.getUint16(0) === 61371 && dv.getUint8(2) === 191) {
      return true;
    } else if (dv.getUint16(0) === 65279 || dv.getUint16(0) === 65534) {
      return false;
    }
    return true;
  }

  // src/transports/dash/segment_loader.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/transports/utils/byte_range.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function byteRange([start, end]) {
    return end === Infinity ? `bytes=${start}-` : `bytes=${start}-${end}`;
  }

  // src/transports/dash/construct_segment_url.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function constructSegmentUrl(wantedCdn, segment) {
    if (wantedCdn === null) {
      return null;
    }
    if (segment.url === null) {
      return wantedCdn.baseUrl;
    }
    return resolve_url_default(wantedCdn.baseUrl, segment.url);
  }

  // src/transports/dash/init_segment_loader.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function initSegmentLoader(initialUrl, segment, options, cancelSignal, callbacks) {
    var _a, _b;
    let url = initialUrl;
    if (((_a = options.cmcdPayload) == null ? void 0 : _a.type) === "query") {
      url = addQueryString(url, options.cmcdPayload.value);
    }
    const cmcdHeaders = ((_b = options.cmcdPayload) == null ? void 0 : _b.type) === "headers" ? options.cmcdPayload.value : void 0;
    if (segment.range === void 0) {
      return request_default({
        url,
        responseType: "arraybuffer",
        headers: cmcdHeaders,
        timeout: options.timeout,
        connectionTimeout: options.connectionTimeout,
        cancelSignal,
        onProgress: callbacks.onProgress
      }).then((data2) => ({ resultType: "segment-loaded", resultData: data2 }));
    }
    if (segment.indexRange === void 0) {
      return request_default({
        url,
        headers: __spreadProps(__spreadValues({}, cmcdHeaders), {
          Range: byteRange(segment.range)
        }),
        responseType: "arraybuffer",
        timeout: options.timeout,
        connectionTimeout: options.connectionTimeout,
        cancelSignal,
        onProgress: callbacks.onProgress
      }).then((data2) => ({ resultType: "segment-loaded", resultData: data2 }));
    }
    if (segment.range[1] + 1 === segment.indexRange[0]) {
      return request_default({
        url,
        headers: __spreadProps(__spreadValues({}, cmcdHeaders), {
          Range: byteRange([segment.range[0], segment.indexRange[1]])
        }),
        responseType: "arraybuffer",
        timeout: options.timeout,
        connectionTimeout: options.connectionTimeout,
        cancelSignal,
        onProgress: callbacks.onProgress
      }).then((data2) => ({ resultType: "segment-loaded", resultData: data2 }));
    }
    const rangeRequest$ = request_default({
      url,
      headers: __spreadProps(__spreadValues({}, cmcdHeaders), {
        Range: byteRange(segment.range)
      }),
      responseType: "arraybuffer",
      timeout: options.timeout,
      connectionTimeout: options.connectionTimeout,
      cancelSignal,
      onProgress: callbacks.onProgress
    });
    const indexRequest$ = request_default({
      url,
      headers: __spreadProps(__spreadValues({}, cmcdHeaders), {
        Range: byteRange(segment.indexRange)
      }),
      responseType: "arraybuffer",
      timeout: options.timeout,
      connectionTimeout: options.connectionTimeout,
      cancelSignal,
      onProgress: callbacks.onProgress
    });
    return Promise.all([rangeRequest$, indexRequest$]).then(([initData, indexData]) => {
      const data2 = concat(
        new Uint8Array(initData.responseData),
        new Uint8Array(indexData.responseData)
      );
      const sendingTime = Math.min(initData.sendingTime, indexData.sendingTime);
      const receivedTime = Math.max(initData.receivedTime, indexData.receivedTime);
      return {
        resultType: "segment-loaded",
        resultData: {
          url,
          responseData: data2,
          size: initData.size + indexData.size,
          requestDuration: receivedTime - sendingTime,
          sendingTime,
          receivedTime
        }
      };
    });
  }

  // src/transports/dash/load_chunked_segment_data.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  async function loadChunkedSegmentData(url, requestOptions, callbacks, cancelSignal) {
    let partialChunk = null;
    function onData(info) {
      const chunk = new Uint8Array(info.chunk);
      const concatenated = partialChunk !== null ? concat(partialChunk, chunk) : chunk;
      const res2 = extractCompleteChunks(concatenated);
      const completeChunks = res2[0];
      partialChunk = res2[1];
      if (completeChunks !== null) {
        completeChunks.forEach((completedChunk) => {
          callbacks.onNewChunk(completedChunk);
        });
        if (cancelSignal.isCancelled()) {
          return;
        }
      }
      callbacks.onProgress({
        duration: info.duration,
        size: info.size,
        totalSize: info.totalSize
      });
      if (cancelSignal.isCancelled()) {
        return;
      }
    }
    const res = await fetchRequest({
      url,
      headers: requestOptions.headers,
      onData,
      timeout: requestOptions.timeout,
      connectionTimeout: requestOptions.connectionTimeout,
      cancelSignal
    });
    return {
      resultType: "chunk-complete",
      resultData: res
    };
  }

  // src/transports/dash/segment_loader.ts
  async function regularSegmentLoader(initialUrl, context, lowLatencyMode, options, callbacks, cancelSignal) {
    var _a, _b;
    if (context.segment.isInit) {
      return initSegmentLoader(
        initialUrl,
        context.segment,
        options,
        cancelSignal,
        callbacks
      );
    }
    const url = ((_a = options.cmcdPayload) == null ? void 0 : _a.type) === "query" ? addQueryString(initialUrl, options.cmcdPayload.value) : initialUrl;
    const cmcdHeaders = ((_b = options.cmcdPayload) == null ? void 0 : _b.type) === "headers" ? options.cmcdPayload.value : void 0;
    const { segment } = context;
    let headers;
    if (segment.range !== void 0) {
      headers = __spreadProps(__spreadValues({}, cmcdHeaders), {
        Range: byteRange(segment.range)
      });
    } else if (cmcdHeaders !== void 0) {
      headers = cmcdHeaders;
    }
    const containerType = inferSegmentContainer(context.type, context.mimeType);
    if (lowLatencyMode && (containerType === "mp4" || containerType === void 0)) {
      if (fetchIsSupported()) {
        return loadChunkedSegmentData(
          url,
          {
            headers,
            timeout: options.timeout,
            connectionTimeout: options.connectionTimeout
          },
          callbacks,
          cancelSignal
        );
      } else {
        warnOnce(
          "DASH: Your browser does not have the fetch API. You will have a higher chance of rebuffering when playing close to the live edge"
        );
      }
    }
    const data2 = await request_default({
      url,
      responseType: "arraybuffer",
      headers,
      timeout: options.timeout,
      connectionTimeout: options.connectionTimeout,
      cancelSignal,
      onProgress: callbacks.onProgress
    });
    return { resultType: "segment-loaded", resultData: data2 };
  }
  function generateSegmentLoader({
    lowLatencyMode,
    segmentLoader: customSegmentLoader,
    checkMediaSegmentIntegrity
  }) {
    return checkMediaSegmentIntegrity !== true ? segmentLoader : addSegmentIntegrityChecks(segmentLoader);
    function segmentLoader(wantedCdn, context, options, cancelSignal, callbacks) {
      const url = constructSegmentUrl(wantedCdn, context.segment);
      if (url === null) {
        return Promise.resolve({
          resultType: "segment-created",
          resultData: null
        });
      }
      if (lowLatencyMode || customSegmentLoader === void 0) {
        return regularSegmentLoader(
          url,
          context,
          lowLatencyMode,
          options,
          callbacks,
          cancelSignal
        );
      }
      return new Promise((res, rej) => {
        let hasFinished = false;
        const resolve = (_args) => {
          if (hasFinished || cancelSignal.isCancelled()) {
            return;
          }
          hasFinished = true;
          cancelSignal.deregister(abortCustomLoader);
          res({
            resultType: "segment-loaded",
            resultData: {
              responseData: _args.data,
              size: _args.size,
              requestDuration: _args.duration
            }
          });
        };
        const reject = (err) => {
          var _a, _b;
          if (hasFinished || cancelSignal.isCancelled()) {
            return;
          }
          hasFinished = true;
          cancelSignal.deregister(abortCustomLoader);
          const castedErr = err;
          const message = (_a = castedErr == null ? void 0 : castedErr.message) != null ? _a : "Unknown error when fetching a DASH segment through a custom segmentLoader.";
          const emittedErr = new CustomLoaderError(
            message,
            (_b = castedErr == null ? void 0 : castedErr.canRetry) != null ? _b : false,
            castedErr == null ? void 0 : castedErr.xhr
          );
          rej(emittedErr);
        };
        const progress = (_args) => {
          if (hasFinished || cancelSignal.isCancelled()) {
            return;
          }
          callbacks.onProgress({
            duration: _args.duration,
            size: _args.size,
            totalSize: _args.totalSize
          });
        };
        const fallback = () => {
          if (hasFinished || cancelSignal.isCancelled()) {
            return;
          }
          hasFinished = true;
          cancelSignal.deregister(abortCustomLoader);
          regularSegmentLoader(
            url,
            context,
            lowLatencyMode,
            options,
            callbacks,
            cancelSignal
          ).then(res, rej);
        };
        const customCallbacks = { reject, resolve, progress, fallback };
        let byteRanges;
        if (context.segment.range !== void 0) {
          byteRanges = [context.segment.range];
          if (context.segment.indexRange !== void 0) {
            byteRanges.push(context.segment.indexRange);
          }
        }
        const args = {
          isInit: context.segment.isInit,
          timeout: options.timeout,
          byteRanges,
          trackType: context.type,
          url,
          cmcdPayload: options.cmcdPayload
        };
        const abort = customSegmentLoader(args, customCallbacks);
        cancelSignal.register(abortCustomLoader);
        function abortCustomLoader(err) {
          if (hasFinished) {
            return;
          }
          hasFinished = true;
          if (typeof abort === "function") {
            abort();
          }
          rej(err);
        }
      });
    }
  }

  // src/transports/dash/segment_parser.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/parsers/containers/matroska/index.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/parsers/containers/matroska/utils.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var SEGMENT_ID = 408125543;
  var INFO_ID = 357149030;
  var TIMECODESCALE_ID = 2807729;
  var DURATION_ID = 17545;
  var CUES_ID = 475249515;
  var CUE_POINT_ID = 187;
  var CUE_TIME_ID = 179;
  var CUE_TRACK_POSITIONS_ID = 183;
  var CUE_CLUSTER_POSITIONS_ID = 241;
  function findNextElement(elementID, parents, buffer, [initialOffset, maxOffset]) {
    let currentOffset = initialOffset;
    while (currentOffset < maxOffset) {
      const parsedID = getEBMLID(buffer, currentOffset);
      if (parsedID === null) {
        return null;
      }
      const { value: ebmlTagID, length: ebmlTagLength } = parsedID;
      const sizeOffset = currentOffset + ebmlTagLength;
      const parsedValue = getEBMLValue(buffer, sizeOffset);
      if (parsedValue === null) {
        return null;
      }
      const { length: valueLengthLength, value: valueLength } = parsedValue;
      const valueOffset = sizeOffset + valueLengthLength;
      const valueEndOffset = valueOffset + valueLength;
      if (ebmlTagID === elementID) {
        return [valueOffset, valueEndOffset];
      } else if (parents.length > 0) {
        for (let i = 0; i < parents.length; i++) {
          if (ebmlTagID === parents[i]) {
            const newParents = parents.slice(i + 1, parents.length);
            return findNextElement(elementID, newParents, buffer, [
              valueOffset,
              valueEndOffset
            ]);
          }
        }
      }
      currentOffset = valueEndOffset;
    }
    return null;
  }
  function getTimeCodeScale(buffer, initialOffset) {
    const timeCodeScaleOffsets = findNextElement(
      TIMECODESCALE_ID,
      [SEGMENT_ID, INFO_ID],
      buffer,
      [initialOffset, buffer.length]
    );
    if (timeCodeScaleOffsets === null) {
      return null;
    }
    const length = timeCodeScaleOffsets[1] - timeCodeScaleOffsets[0];
    return 1e9 / bytesToNumber(buffer, timeCodeScaleOffsets[0], length);
  }
  function getDuration(buffer, initialOffset) {
    const timeCodeScaleOffsets = findNextElement(
      DURATION_ID,
      [SEGMENT_ID, INFO_ID],
      buffer,
      [initialOffset, buffer.length]
    );
    if (timeCodeScaleOffsets === null) {
      return null;
    }
    const length = timeCodeScaleOffsets[1] - timeCodeScaleOffsets[0];
    if (length === 4) {
      return get_IEEE754_32Bits(buffer, timeCodeScaleOffsets[0]);
    } else if (length === 8) {
      return get_IEEE754_64Bits(buffer, timeCodeScaleOffsets[0]);
    }
    return null;
  }
  function getSegmentsFromCues(buffer, initialOffset) {
    const segmentRange = findNextElement(SEGMENT_ID, [], buffer, [
      initialOffset,
      buffer.length
    ]);
    if (segmentRange === null) {
      return null;
    }
    const [segmentRangeStart, segmentRangeEnd] = segmentRange;
    const timescale = getTimeCodeScale(buffer, segmentRangeStart);
    if (timescale === null) {
      return null;
    }
    const duration = getDuration(buffer, segmentRangeStart);
    if (duration === null) {
      return null;
    }
    const cuesRange = findNextElement(CUES_ID, [], buffer, [
      segmentRangeStart,
      segmentRangeEnd
    ]);
    if (cuesRange === null) {
      return null;
    }
    const rawInfos = [];
    let currentOffset = cuesRange[0];
    while (currentOffset < cuesRange[1]) {
      const cuePointRange = findNextElement(CUE_POINT_ID, [], buffer, [
        currentOffset,
        cuesRange[1]
      ]);
      if (cuePointRange === null) {
        break;
      }
      const cueTimeRange = findNextElement(CUE_TIME_ID, [], buffer, [
        cuePointRange[0],
        cuePointRange[1]
      ]);
      if (cueTimeRange === null) {
        return null;
      }
      const time = bytesToNumber(
        buffer,
        cueTimeRange[0],
        cueTimeRange[1] - cueTimeRange[0]
      );
      const cueOffsetRange = findNextElement(
        CUE_CLUSTER_POSITIONS_ID,
        [CUE_TRACK_POSITIONS_ID],
        buffer,
        [cuePointRange[0], cuePointRange[1]]
      );
      if (cueOffsetRange === null) {
        return null;
      }
      const rangeStart = bytesToNumber(buffer, cueOffsetRange[0], cueOffsetRange[1] - cueOffsetRange[0]) + segmentRangeStart;
      rawInfos.push({ time, rangeStart });
      currentOffset = cuePointRange[1];
    }
    const segments = [];
    for (let i = 0; i < rawInfos.length; i++) {
      const currentSegment = rawInfos[i];
      if (i === rawInfos.length - 1) {
        segments.push({
          time: currentSegment.time,
          timescale,
          duration: i === 0 ? duration : duration - currentSegment.time,
          range: [currentSegment.rangeStart, Infinity]
        });
      } else {
        segments.push({
          time: currentSegment.time,
          timescale,
          duration: rawInfos[i + 1].time - currentSegment.time,
          range: [currentSegment.rangeStart, rawInfos[i + 1].rangeStart - 1]
        });
      }
    }
    return segments;
  }
  function getLength(buffer, offset) {
    for (let length = 1; length <= 8; length++) {
      if (buffer[offset] >= Math.pow(2, 8 - length)) {
        return length;
      }
    }
    return void 0;
  }
  function getEBMLID(buffer, offset) {
    const length = getLength(buffer, offset);
    if (length === void 0) {
      log_default.warn("webm: unrepresentable length");
      return null;
    }
    if (offset + length > buffer.length) {
      log_default.warn("webm: impossible length");
      return null;
    }
    let value = 0;
    for (let i = 0; i < length; i++) {
      value = buffer[offset + i] * Math.pow(2, (length - i - 1) * 8) + value;
    }
    return { length, value };
  }
  function getEBMLValue(buffer, offset) {
    const length = getLength(buffer, offset);
    if (length === void 0) {
      log_default.warn("webm: unrepresentable length");
      return null;
    }
    if (offset + length > buffer.length) {
      log_default.warn("webm: impossible length");
      return null;
    }
    let value = (buffer[offset] & (1 << 8 - length) - 1) * Math.pow(2, (length - 1) * 8);
    for (let i = 1; i < length; i++) {
      value = buffer[offset + i] * Math.pow(2, (length - i - 1) * 8) + value;
    }
    return { length, value };
  }
  function get_IEEE754_32Bits(buffer, offset) {
    return new DataView(buffer.buffer).getFloat32(offset);
  }
  function get_IEEE754_64Bits(buffer, offset) {
    return new DataView(buffer.buffer).getFloat64(offset);
  }
  function bytesToNumber(buffer, offset, length) {
    let value = 0;
    for (let i = 0; i < length; i++) {
      value = buffer[offset + i] * Math.pow(2, (length - i - 1) * 8) + value;
    }
    return value;
  }

  // src/transports/utils/get_isobmff_timing_infos.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function getISOBMFFTimingInfos(buffer, isChunked, segment, initTimescale) {
    const baseDecodeTime = getTrackFragmentDecodeTime(buffer);
    if (baseDecodeTime === void 0 || initTimescale === void 0) {
      return null;
    }
    let startTime = segment.timestampOffset !== void 0 ? baseDecodeTime + segment.timestampOffset * initTimescale : baseDecodeTime;
    let trunDuration = getDurationFromTrun(buffer);
    if (startTime < 0) {
      if (trunDuration !== void 0) {
        trunDuration += startTime;
      }
      startTime = 0;
    }
    if (isChunked || !segment.complete) {
      if (trunDuration === void 0) {
        log_default.warn(
          "DASH: Chunked segments should indicate a duration through their trun boxes"
        );
      }
      return {
        time: startTime / initTimescale,
        duration: trunDuration !== void 0 ? trunDuration / initTimescale : void 0
      };
    }
    let duration;
    const segmentDuration = segment.duration * initTimescale;
    const maxDecodeTimeDelta = Math.min(initTimescale * 0.9, segmentDuration / 4);
    if (trunDuration !== void 0 && Math.abs(trunDuration - segmentDuration) <= maxDecodeTimeDelta) {
      duration = trunDuration;
    }
    return {
      time: startTime / initTimescale,
      duration: duration !== void 0 ? duration / initTimescale : duration
    };
  }

  // src/transports/dash/get_events_out_of_emsgs.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function manifestNeedsToBeRefreshed(emsgs, manifestPublishTime) {
    if (emsgs.length <= 0) {
      return false;
    }
    const len = emsgs.length;
    for (let i = 0; i < len; i++) {
      const manifestRefreshEventFromEMSGs = emsgs[i];
      const currentManifestPublishTime = manifestPublishTime;
      const { messageData } = manifestRefreshEventFromEMSGs;
      const strPublishTime = utf8ToStr(messageData);
      const eventManifestPublishTime = Date.parse(strPublishTime);
      if (currentManifestPublishTime === void 0 || eventManifestPublishTime === void 0 || isNaN(eventManifestPublishTime) || // DASH-if 4.3 tells (4.5.2.1) :
      // "The media presentation time beyond the event time (indicated
      // time by presentation_time_delta) is correctly described only
      // by MPDs with publish time greater than indicated value in the
      // message_data field."
      //
      // Here, if the current manifest has its publish time inferior or
      // identical to the event manifest publish time, then the manifest needs
      // to be updated
      eventManifestPublishTime >= currentManifestPublishTime) {
        return true;
      }
    }
    return false;
  }
  function getEventsOutOfEMSGs(parsedEMSGs, manifestPublishTime) {
    if (parsedEMSGs.length === 0) {
      return void 0;
    }
    const { manifestRefreshEventsFromEMSGs, EMSGs } = parsedEMSGs.reduce(
      (acc, val) => {
        if (val.schemeIdUri === "urn:mpeg:dash:event:2012" && // TODO support value 2 and 3
        val.value === "1") {
          if (acc.manifestRefreshEventsFromEMSGs === void 0) {
            acc.manifestRefreshEventsFromEMSGs = [];
          }
          acc.manifestRefreshEventsFromEMSGs.push(val);
        } else {
          if (acc.EMSGs === void 0) {
            acc.EMSGs = [];
          }
          acc.EMSGs.push(val);
        }
        return acc;
      },
      {
        manifestRefreshEventsFromEMSGs: void 0,
        EMSGs: void 0
      }
    );
    const inbandEvents = EMSGs == null ? void 0 : EMSGs.map((evt) => ({
      type: "emsg",
      value: evt
    }));
    const needsManifestRefresh = manifestPublishTime === void 0 || manifestRefreshEventsFromEMSGs === void 0 ? false : manifestNeedsToBeRefreshed(manifestRefreshEventsFromEMSGs, manifestPublishTime);
    return { inbandEvents, needsManifestRefresh };
  }

  // src/transports/dash/segment_parser.ts
  function generateAudioVideoSegmentParser({
    __priv_patchLastSegmentInSidx
  }) {
    return function audioVideoSegmentParser(loadedSegment, context, initTimescale) {
      var _a, _b;
      const { segment, periodStart, periodEnd } = context;
      const { data: data2, isChunked } = loadedSegment;
      const appendWindow = [periodStart, periodEnd];
      if (data2 === null) {
        if (segment.isInit) {
          return {
            segmentType: "init",
            initializationData: null,
            initializationDataSize: 0,
            protectionData: [],
            initTimescale: void 0
          };
        }
        return {
          segmentType: "media",
          chunkData: null,
          chunkSize: 0,
          chunkInfos: null,
          chunkOffset: 0,
          protectionData: [],
          appendWindow
        };
      }
      const chunkData = data2 instanceof Uint8Array ? data2 : new Uint8Array(data2);
      const containerType = inferSegmentContainer(context.type, context.mimeType);
      const seemsToBeMP4 = containerType === "mp4" || containerType === void 0;
      const protectionData = [];
      if (seemsToBeMP4) {
        const psshInfo = takePSSHOut(chunkData);
        let keyId;
        if (segment.isInit) {
          keyId = (_a = getKeyIdFromInitSegment(chunkData)) != null ? _a : void 0;
        }
        if (psshInfo.length > 0 || keyId !== void 0) {
          protectionData.push({
            initDataType: "cenc",
            keyId,
            initData: psshInfo
          });
        }
      }
      if (!segment.isInit) {
        const chunkInfos = seemsToBeMP4 ? getISOBMFFTimingInfos(chunkData, isChunked, segment, initTimescale) : null;
        const chunkOffset = (_b = segment.timestampOffset) != null ? _b : 0;
        if (seemsToBeMP4) {
          const parsedEMSGs = parseEmsgBoxes(chunkData);
          if (parsedEMSGs !== void 0) {
            const whitelistedEMSGs = parsedEMSGs.filter((evt) => {
              if (segment.privateInfos === void 0 || segment.privateInfos.isEMSGWhitelisted === void 0) {
                return false;
              }
              return segment.privateInfos.isEMSGWhitelisted(evt);
            });
            const events = getEventsOutOfEMSGs(
              whitelistedEMSGs,
              context.manifestPublishTime
            );
            if (events !== void 0) {
              const { needsManifestRefresh, inbandEvents } = events;
              return {
                segmentType: "media",
                chunkData,
                chunkSize: chunkData.length,
                chunkInfos,
                chunkOffset,
                appendWindow,
                inbandEvents,
                protectionData,
                needsManifestRefresh
              };
            }
          }
        }
        return {
          segmentType: "media",
          chunkData,
          chunkSize: chunkData.length,
          chunkInfos,
          chunkOffset,
          protectionData,
          appendWindow
        };
      }
      const { indexRange } = segment;
      let segmentList;
      if (containerType === "webm") {
        segmentList = getSegmentsFromCues(chunkData, 0);
      } else if (seemsToBeMP4) {
        segmentList = getSegmentsFromSidx(
          chunkData,
          Array.isArray(indexRange) ? indexRange[0] : 0
        );
        if (__priv_patchLastSegmentInSidx === true && segmentList !== null && segmentList.length > 0) {
          const lastSegment = segmentList[segmentList.length - 1];
          if (Array.isArray(lastSegment.range)) {
            lastSegment.range[1] = Infinity;
          }
        }
      }
      let timescale;
      if (seemsToBeMP4) {
        timescale = getMDHDTimescale(chunkData);
      } else if (containerType === "webm") {
        timescale = getTimeCodeScale(chunkData, 0);
      }
      const parsedTimescale = isNullOrUndefined(timescale) ? void 0 : timescale;
      return {
        segmentType: "init",
        initializationData: chunkData,
        initializationDataSize: chunkData.length,
        protectionData,
        initTimescale: parsedTimescale,
        segmentList: segmentList != null ? segmentList : void 0
      };
    };
  }

  // src/transports/dash/text_loader.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function generateTextTrackLoader({
    lowLatencyMode,
    checkMediaSegmentIntegrity
  }) {
    return checkMediaSegmentIntegrity !== true ? textTrackLoader : addSegmentIntegrityChecks(textTrackLoader);
    async function textTrackLoader(wantedCdn, context, options, cancelSignal, callbacks) {
      var _a, _b;
      const { segment } = context;
      const initialUrl = constructSegmentUrl(wantedCdn, segment);
      if (initialUrl === null) {
        return Promise.resolve({
          resultType: "segment-created",
          resultData: null
        });
      }
      if (segment.isInit) {
        return initSegmentLoader(initialUrl, segment, options, cancelSignal, callbacks);
      }
      const url = ((_a = options.cmcdPayload) == null ? void 0 : _a.type) === "query" ? addQueryString(initialUrl, options.cmcdPayload.value) : initialUrl;
      const cmcdHeaders = ((_b = options.cmcdPayload) == null ? void 0 : _b.type) === "headers" ? options.cmcdPayload.value : void 0;
      let headers;
      if (segment.range !== void 0) {
        headers = __spreadProps(__spreadValues({}, cmcdHeaders), {
          Range: byteRange(segment.range)
        });
      } else if (cmcdHeaders !== void 0) {
        headers = cmcdHeaders;
      }
      const containerType = inferSegmentContainer(context.type, context.mimeType);
      const seemsToBeMP4 = containerType === "mp4" || containerType === void 0;
      if (lowLatencyMode && seemsToBeMP4) {
        if (fetchIsSupported()) {
          return loadChunkedSegmentData(
            url,
            {
              headers,
              timeout: options.timeout,
              connectionTimeout: options.connectionTimeout
            },
            callbacks,
            cancelSignal
          );
        } else {
          warnOnce(
            "DASH: Your browser does not have the fetch API. You will have a higher chance of rebuffering when playing close to the live edge"
          );
        }
      }
      let data2;
      if (seemsToBeMP4) {
        data2 = await request_default({
          url,
          responseType: "arraybuffer",
          headers,
          timeout: options.timeout,
          connectionTimeout: options.connectionTimeout,
          onProgress: callbacks.onProgress,
          cancelSignal
        });
      } else {
        data2 = await request_default({
          url,
          responseType: "text",
          headers,
          timeout: options.timeout,
          connectionTimeout: options.connectionTimeout,
          onProgress: callbacks.onProgress,
          cancelSignal
        });
      }
      return { resultType: "segment-loaded", resultData: data2 };
    }
  }

  // src/transports/dash/text_parser.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/transports/utils/parse_text_track.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function extractTextTrackFromISOBMFF(chunkBytes) {
    const mdat = getMDAT(chunkBytes);
    return mdat === null ? "" : utf8ToStr(mdat);
  }
  function getISOBMFFTextTrackFormat(codecs) {
    if (codecs === void 0) {
      throw new Error("Cannot parse subtitles: unknown format");
    }
    switch (codecs.toLowerCase()) {
      case "stpp":
      case "stpp.ttml.im1t":
        return "ttml";
      case "wvtt":
        return "vtt";
    }
    throw new Error(
      `The codec used for the subtitles "${codecs}" is not managed yet.`
    );
  }
  function getPlainTextTrackFormat(codecs, mimeType) {
    switch (mimeType) {
      case "application/ttml+xml":
        return "ttml";
      case "application/x-sami":
      case "application/smil":
        return "sami";
      case "text/vtt":
        return "vtt";
    }
    if (codecs !== void 0) {
      const codeLC = codecs.toLowerCase();
      if (codeLC === "srt") {
        return "srt";
      }
    }
    throw new Error(`could not find a text-track parser for the type ${mimeType != null ? mimeType : ""}`);
  }
  function getISOBMFFEmbeddedTextTrackData({
    segment,
    language,
    codecs
  }, chunkBytes, chunkInfos, isChunked) {
    if (segment.isInit) {
      return null;
    }
    let startTime;
    let endTime;
    if (chunkInfos === null) {
      if (!isChunked) {
        log_default.warn("Transport: Unavailable time data for current text track.");
      } else {
        startTime = segment.time;
        endTime = segment.end;
      }
    } else {
      startTime = chunkInfos.time;
      if (chunkInfos.duration !== void 0) {
        endTime = startTime + chunkInfos.duration;
      } else if (!isChunked && segment.complete) {
        endTime = startTime + segment.duration;
      }
    }
    const type = getISOBMFFTextTrackFormat(codecs);
    const textData = extractTextTrackFromISOBMFF(chunkBytes);
    return { data: textData, type, language, start: startTime, end: endTime };
  }
  function getPlainTextTrackData(context, textTrackData, isChunked) {
    const { segment } = context;
    if (segment.isInit) {
      return null;
    }
    let start;
    let end;
    if (isChunked) {
      log_default.warn("Transport: Unavailable time data for current text track.");
    } else {
      start = segment.time;
      if (segment.complete) {
        end = segment.time + segment.duration;
      }
    }
    const type = getPlainTextTrackFormat(context.codecs, context.mimeType);
    return { data: textTrackData, type, language: context.language, start, end };
  }

  // src/transports/dash/text_parser.ts
  function parseISOBMFFEmbeddedTextTrack(data2, isChunked, context, initTimescale, __priv_patchLastSegmentInSidx) {
    var _a;
    const { segment } = context;
    const { isInit, indexRange } = segment;
    let chunkBytes;
    if (typeof data2 === "string") {
      chunkBytes = strToUtf8(data2);
    } else if (data2 instanceof Uint8Array) {
      chunkBytes = data2;
    } else {
      chunkBytes = new Uint8Array(data2);
    }
    if (isInit) {
      const segmentList = getSegmentsFromSidx(
        chunkBytes,
        Array.isArray(indexRange) ? indexRange[0] : 0
      );
      if (__priv_patchLastSegmentInSidx === true && segmentList !== null && segmentList.length > 0) {
        const lastSegment = segmentList[segmentList.length - 1];
        if (Array.isArray(lastSegment.range)) {
          lastSegment.range[1] = Infinity;
        }
      }
      const mdhdTimescale = getMDHDTimescale(chunkBytes);
      return {
        segmentType: "init",
        initializationData: null,
        initializationDataSize: 0,
        protectionData: [],
        initTimescale: mdhdTimescale,
        segmentList: segmentList != null ? segmentList : void 0
      };
    }
    const chunkInfos = getISOBMFFTimingInfos(chunkBytes, isChunked, segment, initTimescale);
    const chunkData = getISOBMFFEmbeddedTextTrackData(
      context,
      chunkBytes,
      chunkInfos,
      isChunked
    );
    const chunkOffset = (_a = segment.timestampOffset) != null ? _a : 0;
    return {
      segmentType: "media",
      chunkData,
      chunkSize: chunkBytes.length,
      chunkInfos,
      chunkOffset,
      protectionData: [],
      appendWindow: [context.periodStart, context.periodEnd]
    };
  }
  function parsePlainTextTrack(data2, isChunked, context) {
    const { periodStart, periodEnd, segment } = context;
    const { timestampOffset = 0 } = segment;
    if (segment.isInit) {
      return {
        segmentType: "init",
        initializationData: null,
        initializationDataSize: 0,
        protectionData: [],
        initTimescale: void 0
      };
    }
    let textTrackData;
    let chunkSize;
    if (typeof data2 !== "string") {
      const bytesData = data2 instanceof Uint8Array ? data2 : new Uint8Array(data2);
      textTrackData = utf8ToStr(bytesData);
      chunkSize = bytesData.length;
    } else {
      textTrackData = data2;
    }
    const chunkData = getPlainTextTrackData(context, textTrackData, isChunked);
    return {
      segmentType: "media",
      chunkData,
      chunkSize,
      chunkInfos: null,
      chunkOffset: timestampOffset,
      protectionData: [],
      appendWindow: [periodStart, periodEnd]
    };
  }
  function generateTextTrackParser({
    __priv_patchLastSegmentInSidx
  }) {
    return function textTrackParser(loadedSegment, context, initTimescale) {
      var _a;
      const { periodStart, periodEnd, segment } = context;
      const { data: data2, isChunked } = loadedSegment;
      if (data2 === null) {
        return segment.isInit ? {
          segmentType: "init",
          initializationData: null,
          initializationDataSize: 0,
          protectionData: [],
          initTimescale: void 0
        } : {
          segmentType: "media",
          chunkData: null,
          chunkSize: 0,
          chunkInfos: null,
          chunkOffset: (_a = segment.timestampOffset) != null ? _a : 0,
          protectionData: [],
          appendWindow: [periodStart, periodEnd]
        };
      }
      const containerType = inferSegmentContainer(context.type, context.mimeType);
      if (containerType === "webm") {
        throw new Error("Text tracks with a WEBM container are not yet handled.");
      } else if (containerType === "mp4") {
        return parseISOBMFFEmbeddedTextTrack(
          data2,
          isChunked,
          context,
          initTimescale,
          __priv_patchLastSegmentInSidx
        );
      } else {
        return parsePlainTextTrack(data2, isChunked, context);
      }
    };
  }

  // src/transports/dash/thumbnails.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  async function loadThumbnail(wantedCdn, thumbnail, options, cancelSignal) {
    var _a, _b;
    const initialUrl = constructSegmentUrl(wantedCdn, thumbnail);
    if (initialUrl === null) {
      return Promise.reject(new Error("Cannot load thumbnail: no URL"));
    }
    const url = ((_a = options.cmcdPayload) == null ? void 0 : _a.type) === "query" ? addQueryString(initialUrl, options.cmcdPayload.value) : initialUrl;
    const cmcdHeaders = ((_b = options.cmcdPayload) == null ? void 0 : _b.type) === "headers" ? options.cmcdPayload.value : void 0;
    let headers;
    if (thumbnail.range !== void 0) {
      headers = __spreadProps(__spreadValues({}, cmcdHeaders), {
        Range: byteRange(thumbnail.range)
      });
    } else if (cmcdHeaders !== void 0) {
      headers = cmcdHeaders;
    }
    return request({
      url,
      responseType: "arraybuffer",
      headers,
      timeout: options.timeout,
      connectionTimeout: options.connectionTimeout,
      cancelSignal
    });
  }
  function parseThumbnail(data2, context) {
    const { thumbnailTrack, thumbnail: wantedThumbnail } = context;
    const height = thumbnailTrack.height / thumbnailTrack.verticalTiles;
    const width = thumbnailTrack.width / thumbnailTrack.horizontalTiles;
    const thumbnails = [];
    const tileDuration = (wantedThumbnail.end - wantedThumbnail.time) / (thumbnailTrack.horizontalTiles * thumbnailTrack.verticalTiles);
    let start = wantedThumbnail.time;
    for (let row = 0; row < thumbnailTrack.verticalTiles; row++) {
      for (let column = 0; column < thumbnailTrack.horizontalTiles; column++) {
        thumbnails.push({
          start,
          end: start + tileDuration,
          offsetX: Math.round(column * width),
          offsetY: Math.round(row * height),
          height: Math.floor(height),
          width: Math.floor(width)
        });
        start += tileDuration;
      }
    }
    return {
      mimeType: thumbnailTrack.mimeType,
      data: data2,
      thumbnails
    };
  }

  // src/transports/dash/pipelines.ts
  function pipelines_default(options) {
    const manifestLoader = generateManifestLoader(
      { customManifestLoader: options.manifestLoader },
      mightUseDashWasmFeature() ? "text" : "arraybuffer",
      options.checkManifestIntegrity === true ? addManifestIntegrityChecks : null
    );
    const manifestParser = generateManifestParser(options);
    const segmentLoader = generateSegmentLoader(options);
    const audioVideoSegmentParser = generateAudioVideoSegmentParser(options);
    const textTrackLoader = generateTextTrackLoader(options);
    const textTrackParser = generateTextTrackParser(options);
    return {
      transportName: "dash",
      manifest: { loadManifest: manifestLoader, parseManifest: manifestParser },
      audio: {
        loadSegment: segmentLoader,
        parseSegment: audioVideoSegmentParser
      },
      video: {
        loadSegment: segmentLoader,
        parseSegment: audioVideoSegmentParser
      },
      text: { loadSegment: textTrackLoader, parseSegment: textTrackParser },
      thumbnails: {
        loadThumbnail,
        parseThumbnail
      }
    };
  }
  function mightUseDashWasmFeature() {
    return features_default.dashParsers.wasm !== null && (features_default.dashParsers.wasm.status === "initialized" || features_default.dashParsers.wasm.status === "initializing");
  }

  // src/transports/dash/index.ts
  var dash_default = pipelines_default;

  // src/features/list/dash.ts
  function addDASHFeature(features2) {
    if (features2.transports.dash === void 0) {
      features2.transports.dash = dash_default;
    }
    features2.dashParsers.native = native_parser_default;
    features2.mainThreadMediaSourceInit = MediaSourceContentInitializer;
  }

  // src/features/list/debug_element.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/main_thread/api/debug/index.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/main_thread/api/debug/render.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/main_thread/api/debug/modules/general_info.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/main_thread/api/debug/constants.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var DEFAULT_REFRESH_INTERVAL = 1e3;

  // src/main_thread/api/debug/utils.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function createElement3(elementName, { textContent, className } = {}) {
    const elt = document.createElement(elementName);
    if (className !== void 0) {
      elt.className = className;
    }
    if (textContent !== void 0) {
      elt.textContent = textContent;
    }
    return elt;
  }
  function createCompositeElement(rootElementName, parts, { className } = {}) {
    const elt = document.createElement(rootElementName);
    if (className !== void 0) {
      elt.className = className;
    }
    for (const subElt of parts) {
      if (typeof subElt === "string") {
        elt.appendChild(document.createTextNode(subElt));
      } else {
        elt.appendChild(subElt);
      }
    }
    return elt;
  }
  function isExtendedMode(parentElt) {
    return parentElt.clientHeight > 400;
  }
  function createMetricTitle(title) {
    const elt = createElement3("span", {
      textContent: title + "/"
    });
    elt.style.fontWeight = "bold";
    return elt;
  }
  function createGraphCanvas() {
    const canvasElt = createElement3("canvas");
    canvasElt.style.border = "1px solid white";
    canvasElt.style.height = "15px";
    canvasElt.style.marginLeft = "2px";
    return canvasElt;
  }

  // src/main_thread/api/debug/modules/general_info.ts
  function constructDebugGeneralInfo(instance, parentElt, cancelSignal) {
    const generalInfoElt = createElement3("div");
    const adaptationsElt = createElement3("div");
    const representationsElt = createElement3("div");
    updateGeneralInfo();
    const generalInfoItv = setInterval(() => {
      updateGeneralInfo();
    }, DEFAULT_REFRESH_INTERVAL);
    cancelSignal.register(() => {
      clearInterval(generalInfoItv);
    });
    return createCompositeElement("div", [
      generalInfoElt,
      adaptationsElt,
      representationsElt
    ]);
    function updateGeneralInfo() {
      var _a, _b, _c, _d, _e, _f;
      const videoElement = instance.getVideoElement();
      if (videoElement === null) {
        generalInfoElt.innerHTML = "";
        adaptationsElt.innerHTML = "";
        representationsElt.innerHTML = "";
        clearInterval(generalInfoItv);
        return;
      } else {
        const currentTime = instance.getPosition();
        const bufferGap = instance.getCurrentBufferGap();
        const bufferGapStr = bufferGap === Infinity ? "0" : bufferGap.toFixed(2);
        const valuesLine1 = [
          ["ct", currentTime.toFixed(2)],
          ["bg", bufferGapStr],
          ["rs", String(videoElement.readyState)],
          ["pr", String(videoElement.playbackRate)],
          ["sp", String(instance.getPlaybackRate())],
          ["pa", String(videoElement.paused ? 1 : 0)],
          ["en", String(videoElement.ended ? 1 : 0)],
          ["li", String(instance.isLive() ? 1 : 0)],
          ["wba", String(instance.getWantedBufferAhead())],
          ["st", `"${instance.getPlayerState()}"`]
        ];
        if (((_a = instance.getCurrentModeInformation()) == null ? void 0 : _a.useWorker) === true) {
          if (has_mse_in_worker_default) {
            valuesLine1.push(["wo", "2"]);
          } else {
            valuesLine1.push(["wo", "1"]);
          }
        } else {
          valuesLine1.push(["wo", "0"]);
        }
        const valuesLine2 = [];
        const ks = instance.getKeySystemConfiguration();
        if (ks !== null) {
          valuesLine2.push(["ks", ks.keySystem]);
        }
        const mbb = instance.getMaxBufferBehind();
        if (mbb !== Infinity) {
          valuesLine2.push(["mbb", String(mbb)]);
        }
        const mba = instance.getMaxBufferAhead();
        if (mba !== Infinity) {
          valuesLine2.push(["mba", String(mba)]);
        }
        const mbs = instance.getMaxVideoBufferSize();
        if (mbs !== Infinity) {
          valuesLine2.push(["mbs", String(mbs)]);
        }
        const minPos = instance.getMinimumPosition();
        if (minPos !== null) {
          valuesLine1.push(["mip", minPos.toFixed(2)]);
          valuesLine2.push(["dmi", (currentTime - minPos).toFixed(2)]);
        }
        const maxPos = instance.getMaximumPosition();
        if (maxPos !== null) {
          valuesLine1.push(["map", maxPos.toFixed(2)]);
          valuesLine2.push(["dma", (maxPos - currentTime).toFixed(2)]);
        }
        const valuesLine3 = [];
        const error = instance.getError();
        if (error !== null) {
          valuesLine3.push(["er", `"${String(error)}"`]);
        }
        generalInfoElt.innerHTML = "";
        for (const valueSet of [valuesLine1, valuesLine2, valuesLine3]) {
          if (valueSet.length > 0) {
            const lineInfoElt = createElement3("div");
            for (const value of valueSet) {
              lineInfoElt.appendChild(createMetricTitle(value[0]));
              lineInfoElt.appendChild(
                createElement3("span", {
                  textContent: value[1] + " "
                })
              );
            }
            generalInfoElt.appendChild(lineInfoElt);
          }
        }
        if (isExtendedMode(parentElt)) {
          const url = (_b = instance.getContentUrls()) == null ? void 0 : _b[0];
          if (url !== void 0) {
            const reducedUrl = url.length > 100 ? url.substring(0, 99) + "\u2026" : url;
            generalInfoElt.appendChild(
              createCompositeElement("div", [
                createMetricTitle("url"),
                createElement3("span", {
                  textContent: reducedUrl
                })
              ])
            );
          }
        }
      }
      if (isExtendedMode(parentElt)) {
        const videoId = instance.getAvailableVideoTracks().map(({ id, active }) => active ? `*${id}` : id);
        const audioId = instance.getAvailableAudioTracks().map(({ id, active }) => active ? `*${id}` : id);
        const textId = instance.getAvailableTextTracks().map(({ id, active }) => active ? `*${id}` : id);
        adaptationsElt.innerHTML = "";
        if (videoId.length > 0) {
          let textContent = `${videoId.length}:${videoId.join(" ")} `;
          if (textContent.length > 100) {
            textContent = textContent.substring(0, 98) + "\u2026 ";
          }
          const videoAdaps = createCompositeElement("div", [
            createMetricTitle("vt"),
            createElement3("span", { textContent })
          ]);
          adaptationsElt.appendChild(videoAdaps);
        }
        if (audioId.length > 0) {
          let textContent = `${audioId.length}:${audioId.join(" ")} `;
          if (textContent.length > 100) {
            textContent = textContent.substring(0, 98) + "\u2026 ";
          }
          const audioAdaps = createCompositeElement("div", [
            createMetricTitle("at"),
            createElement3("span", { textContent })
          ]);
          adaptationsElt.appendChild(audioAdaps);
        }
        if (textId.length > 0) {
          let textContent = `${textId.length}:${textId.join(" ")} `;
          if (textContent.length > 100) {
            textContent = textContent.substring(0, 98) + "\u2026 ";
          }
          const textAdaps = createCompositeElement("div", [
            createMetricTitle("tt"),
            createElement3("span", { textContent })
          ]);
          adaptationsElt.appendChild(textAdaps);
        }
        const adaptations = instance.__priv_getCurrentAdaptation();
        const videoBitratesStr = (_d = (_c = adaptations == null ? void 0 : adaptations.video) == null ? void 0 : _c.representations.map((r) => {
          var _a2;
          return String((_a2 = r.bitrate) != null ? _a2 : "N/A") + (r.isSupported !== false ? "" : " U!") + (r.decipherable !== false ? "" : " E!");
        })) != null ? _d : [];
        const audioBitratesStr = (_f = (_e = adaptations == null ? void 0 : adaptations.audio) == null ? void 0 : _e.representations.map((r) => {
          var _a2;
          return String((_a2 = r.bitrate) != null ? _a2 : "N/A") + (r.isSupported !== false ? "" : " U!") + (r.decipherable !== false ? "" : " E!");
        })) != null ? _f : [];
        representationsElt.innerHTML = "";
        if (videoBitratesStr.length > 0) {
          representationsElt.appendChild(createMetricTitle("vb"));
          representationsElt.appendChild(
            createElement3("span", {
              textContent: videoBitratesStr.join(" ") + " "
            })
          );
        }
        if (audioBitratesStr.length > 0) {
          representationsElt.appendChild(createMetricTitle("ab"));
          representationsElt.appendChild(
            createElement3("span", {
              textContent: audioBitratesStr.join(" ") + " "
            })
          );
        }
      } else {
        adaptationsElt.innerHTML = "";
        representationsElt.innerHTML = "";
      }
    }
  }

  // src/main_thread/api/debug/modules/segment_buffer_content.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/main_thread/api/debug/buffer_graph.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var BUFFER_WIDTH_IN_SECONDS = 30 * 60;
  var COLORS = [
    "#2ab7ca",
    "#fed766",
    "#4dd248",
    "#a22c28",
    "#556b2f",
    // darkolivegreen
    "#add8e6",
    // lightblue
    "#90ee90",
    // lightgreen
    "#444444",
    "#40bfc1",
    "#57557e",
    "#fbe555"
  ];
  var SegmentSinkGraph = class {
    constructor(canvasElt) {
      this._colorMap = /* @__PURE__ */ new Map();
      this._currNbColors = 0;
      this._canvasElt = canvasElt;
      this._canvasCtxt = this._canvasElt.getContext("2d");
      this.clear();
    }
    clear() {
      if (this._canvasCtxt !== null) {
        this._canvasCtxt.clearRect(0, 0, this._canvasElt.width, this._canvasElt.height);
      }
    }
    update(data2) {
      var _a, _b, _c, _d;
      const representationStillInUse = /* @__PURE__ */ new Set();
      data2.inventory.forEach((chunk) => {
        representationStillInUse.add(chunk.infos.representation.uniqueId);
      });
      this._colorMap.forEach((representationId) => {
        if (!representationStillInUse.has(representationId)) {
          this._colorMap.delete(representationId);
        }
      });
      if (this._canvasCtxt === null) {
        return;
      }
      const { inventory, currentTime, width, height } = data2;
      this._canvasElt.style.width = `${width}px`;
      this._canvasElt.style.height = `${height}px`;
      this._canvasElt.width = width;
      this._canvasElt.height = height;
      this.clear();
      let minimumPoint;
      if (data2.minimumPosition !== void 0) {
        if (inventory.length > 0) {
          minimumPoint = Math.min(data2.minimumPosition, inventory[0].start);
        } else {
          minimumPoint = data2.minimumPosition;
        }
      } else {
        minimumPoint = (_b = (_a = inventory[0]) == null ? void 0 : _a.start) != null ? _b : 0;
      }
      let maximumPoint;
      if (data2.maximumPosition !== void 0) {
        if (inventory.length > 0) {
          maximumPoint = Math.max(
            data2.maximumPosition,
            inventory[inventory.length - 1].end
          );
        } else {
          maximumPoint = data2.maximumPosition;
        }
      } else {
        maximumPoint = (_d = (_c = inventory[inventory.length - 1]) == null ? void 0 : _c.end) != null ? _d : 1e3;
      }
      minimumPoint = Math.min(currentTime, minimumPoint);
      maximumPoint = Math.max(currentTime, maximumPoint);
      let minimumPosition;
      let maximumPosition;
      if (maximumPoint - minimumPoint > BUFFER_WIDTH_IN_SECONDS) {
        if (maximumPoint - currentTime < BUFFER_WIDTH_IN_SECONDS / 2) {
          maximumPosition = maximumPoint;
          minimumPosition = maximumPoint - BUFFER_WIDTH_IN_SECONDS;
        } else if (currentTime - minimumPoint < BUFFER_WIDTH_IN_SECONDS / 2) {
          minimumPosition = minimumPoint;
          maximumPosition = minimumPoint + BUFFER_WIDTH_IN_SECONDS;
        } else {
          minimumPosition = currentTime - BUFFER_WIDTH_IN_SECONDS / 2;
          maximumPosition = currentTime + BUFFER_WIDTH_IN_SECONDS / 2;
        }
      } else {
        minimumPosition = minimumPoint;
        maximumPosition = maximumPoint;
      }
      if (minimumPosition >= maximumPosition) {
        this.clear();
        return;
      }
      const currentRangesScaled = scaleSegments(
        inventory,
        minimumPosition,
        maximumPosition
      );
      for (const currentRange of currentRangesScaled) {
        this._paintRange(currentRange, width, height);
      }
      if (currentTime !== void 0) {
        paintCurrentPosition(
          currentTime,
          minimumPosition,
          maximumPosition,
          this._canvasCtxt,
          width,
          height
        );
      }
    }
    /**
     * Paint a given range in the canvas
     * @param {Object} rangeScaled - Buffered segment information with added
     * "scaling" information to know where it fits in the canvas.
     */
    _paintRange(rangeScaled, width, height) {
      if (this._canvasCtxt === null) {
        return;
      }
      const startX = rangeScaled.scaledStart * width;
      const endX = rangeScaled.scaledEnd * width;
      this._canvasCtxt.fillStyle = this._getColorForRepresentation(
        rangeScaled.info.infos.representation
      );
      this._canvasCtxt.fillRect(Math.ceil(startX), 0, Math.ceil(endX - startX), height);
    }
    _getColorForRepresentation(representation) {
      const color = this._colorMap.get(representation.uniqueId);
      if (color !== void 0) {
        return color;
      }
      const newColor = COLORS[this._currNbColors % COLORS.length];
      this._currNbColors++;
      this._colorMap.set(representation.uniqueId, newColor);
      return newColor;
    }
  };
  function paintCurrentPosition(position, minimumPosition, maximumPosition, canvasCtx, width, height) {
    if (typeof position === "number" && position >= minimumPosition && position < maximumPosition) {
      const lengthCanvas = maximumPosition - minimumPosition;
      canvasCtx.fillStyle = "#FF0000";
      canvasCtx.fillRect(
        Math.ceil((position - minimumPosition) / lengthCanvas * width) - 1,
        5,
        5,
        height
      );
    }
  }
  function scaleSegments(bufferedData, minimumPosition, maximumPosition) {
    var _a, _b;
    const scaledSegments = [];
    const wholeDuration = maximumPosition - minimumPosition;
    for (const info of bufferedData) {
      const start = (_a = info.bufferedStart) != null ? _a : info.start;
      const end = (_b = info.bufferedEnd) != null ? _b : info.end;
      if (end > minimumPosition && start < maximumPosition) {
        const startPoint = Math.max(start - minimumPosition, 0);
        const endPoint = Math.min(end - minimumPosition, maximumPosition);
        const scaledStart = startPoint / wholeDuration;
        const scaledEnd = endPoint / wholeDuration;
        scaledSegments.push({ scaledStart, scaledEnd, info });
      }
    }
    return scaledSegments;
  }

  // src/main_thread/api/debug/modules/segment_buffer_content.ts
  function createSegmentSinkGraph(instance, bufferType, title, parentElt, cancelSignal) {
    const bufferGraphWrapper = createElement3("div");
    const bufferTitle = createMetricTitle(title);
    const canvasElt = createGraphCanvas();
    const currentRangeRepInfoElt = createElement3("div");
    const loadingRangeRepInfoElt = createElement3("div");
    const bufferGraph = new SegmentSinkGraph(canvasElt);
    const intervalId = setInterval(update, DEFAULT_REFRESH_INTERVAL);
    cancelSignal.register(() => {
      clearInterval(intervalId);
    });
    let bufferMetrics = null;
    instance.__priv_getSegmentSinkMetrics().then((metrics) => {
      bufferMetrics = metrics != null ? metrics : null;
    }).catch(() => {
    });
    bufferGraphWrapper.appendChild(bufferTitle);
    bufferGraphWrapper.appendChild(canvasElt);
    bufferGraphWrapper.appendChild(currentRangeRepInfoElt);
    bufferGraphWrapper.appendChild(loadingRangeRepInfoElt);
    bufferGraphWrapper.style.padding = "5px 0px";
    update();
    return bufferGraphWrapper;
    function update() {
      if (instance.getVideoElement() === null) {
        bufferGraphWrapper.style.display = "none";
        bufferGraphWrapper.innerHTML = "";
        clearInterval(intervalId);
        return;
      }
      instance.__priv_getSegmentSinkMetrics().then((metrics) => {
        bufferMetrics = metrics != null ? metrics : null;
        updateBufferMetrics();
      }).catch(() => {
      });
    }
    function updateBufferMetrics() {
      var _a, _b, _c, _d;
      const showAllInfo = isExtendedMode(parentElt);
      const inventory = bufferMetrics == null ? void 0 : bufferMetrics.segmentSinks[bufferType].segmentInventory;
      if (bufferMetrics === null || inventory === void 0) {
        bufferGraphWrapper.style.display = "none";
        currentRangeRepInfoElt.innerHTML = "";
        loadingRangeRepInfoElt.innerHTML = "";
      } else {
        bufferGraphWrapper.style.display = "block";
        const currentTime = instance.getPosition();
        const width = Math.min(parentElt.clientWidth - 150, 600);
        bufferGraph.update({
          currentTime,
          minimumPosition: (_a = instance.getMinimumPosition()) != null ? _a : void 0,
          maximumPosition: (_b = instance.getMaximumPosition()) != null ? _b : void 0,
          inventory,
          width,
          height: 10
        });
        if (!showAllInfo) {
          currentRangeRepInfoElt.innerHTML = "";
          loadingRangeRepInfoElt.innerHTML = "";
          return;
        }
        currentRangeRepInfoElt.innerHTML = "";
        for (const rangeInfo of inventory) {
          const { bufferedStart, bufferedEnd, infos } = rangeInfo;
          if (bufferedStart !== void 0 && bufferedEnd !== void 0 && currentTime >= bufferedStart && currentTime < bufferedEnd) {
            currentRangeRepInfoElt.appendChild(createMetricTitle("play"));
            currentRangeRepInfoElt.appendChild(
              createElement3("span", {
                textContent: constructRepresentationInfo(infos)
              })
            );
            break;
          }
        }
        loadingRangeRepInfoElt.innerHTML = "";
        const rep = (_c = instance.__priv_getCurrentRepresentations()) == null ? void 0 : _c[bufferType];
        const adap = (_d = instance.__priv_getCurrentAdaptation()) == null ? void 0 : _d[bufferType];
        const manifest = instance.__priv_getManifest();
        if (manifest !== null && !isNullOrUndefined(rep) && !isNullOrUndefined(adap)) {
          const period = getPeriodForTime(manifest, currentTime);
          if (period !== void 0) {
            loadingRangeRepInfoElt.appendChild(createMetricTitle("load"));
            loadingRangeRepInfoElt.appendChild(
              createElement3("span", {
                textContent: constructRepresentationInfo({
                  period,
                  adaptation: adap,
                  representation: rep
                })
              })
            );
          }
        }
      }
    }
  }
  function constructRepresentationInfo(content) {
    var _a;
    const period = content.period;
    const {
      language,
      isAudioDescription,
      isClosedCaption,
      isTrickModeTrack,
      isSignInterpreted,
      type: bufferType
    } = content.adaptation;
    const { id, height, width, bitrate, codecs } = content.representation;
    let representationInfo = `"${id}" `;
    if (height !== void 0 && width !== void 0) {
      representationInfo += `${width}x${height} `;
    }
    if (bitrate !== void 0) {
      representationInfo += `(${(bitrate / 1e3).toFixed(0)}kbps) `;
    }
    if (codecs !== void 0 && codecs.length > 0) {
      representationInfo += `c:"${codecs.join(" / ")}" `;
    }
    if (language !== void 0) {
      representationInfo += `l:"${language}" `;
    }
    if (bufferType === "video" && typeof isSignInterpreted === "boolean") {
      representationInfo += `si:${isSignInterpreted ? 1 : 0} `;
    }
    if (bufferType === "video" && typeof isTrickModeTrack === "boolean") {
      representationInfo += `tm:${isTrickModeTrack ? 1 : 0} `;
    }
    if (bufferType === "audio" && typeof isAudioDescription === "boolean") {
      representationInfo += `ad:${isAudioDescription ? 1 : 0} `;
    }
    if (bufferType === "text" && typeof isClosedCaption === "boolean") {
      representationInfo += `cc:${isClosedCaption ? 1 : 0} `;
    }
    representationInfo += `p:${period.start}-${(_a = period.end) != null ? _a : "?"}`;
    return representationInfo;
  }

  // src/main_thread/api/debug/modules/segment_buffer_size.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/main_thread/api/debug/buffer_size_graph.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var TIME_SAMPLES_MS = 3e4;
  var MINIMUM_MAX_BUFFER_SIZE = 20;
  var BufferSizeGraph = class {
    constructor(canvasElt) {
      this._canvasElt = canvasElt;
      this._canvasCtxt = this._canvasElt.getContext("2d");
      this._history = [];
    }
    pushBufferSize(bufferSize) {
      const now = monotonic_timestamp_default();
      this._history.push({ timestamp: now, bufferSize });
      if (this._history.length > 0) {
        const minimumTime = now - TIME_SAMPLES_MS;
        let i;
        for (i = this._history.length - 1; i >= 1; i--) {
          if (this._history[i].timestamp <= minimumTime) {
            break;
          }
        }
        this._history = this._history.slice(i);
      } else {
        this._history = [];
      }
    }
    clear() {
      if (this._canvasCtxt !== null) {
        this._canvasCtxt.clearRect(0, 0, this._canvasElt.width, this._canvasElt.height);
      }
    }
    reRender(width, height) {
      this._canvasElt.style.width = `${width}px`;
      this._canvasElt.style.height = `${height}px`;
      this._canvasElt.width = width;
      this._canvasElt.height = height;
      this.clear();
      const history = this._history;
      const canvasCtx = this._canvasCtxt;
      if (history.length === 0) {
        return;
      }
      const currentMaxSize = getNewMaxBufferSize();
      const minDate = history[0].timestamp;
      const gridHeight = height / currentMaxSize;
      const gridWidth = width / TIME_SAMPLES_MS;
      drawData();
      function getNewMaxBufferSize() {
        const maxPoint = Math.max(...history.map((d) => d.bufferSize));
        return Math.max(maxPoint + 5, MINIMUM_MAX_BUFFER_SIZE);
      }
      function drawData() {
        if (canvasCtx === null) {
          return;
        }
        canvasCtx.beginPath();
        canvasCtx.fillStyle = "rgb(200, 100, 200)";
        for (let i = 1; i < history.length; i++) {
          const diff = dateToX(history[i].timestamp) - dateToX(history[i - 1].timestamp);
          const y = height - bufferValueToHeight(history[i].bufferSize);
          canvasCtx.fillRect(dateToX(history[i - 1].timestamp), y, diff, height);
        }
        canvasCtx.stroke();
      }
      function bufferValueToHeight(bufferVal) {
        return height - (currentMaxSize - bufferVal) * gridHeight;
      }
      function dateToX(date) {
        return (date - minDate) * gridWidth;
      }
    }
  };

  // src/main_thread/api/debug/modules/segment_buffer_size.ts
  function createSegmentSinkSizeGraph(instance, parentElt, cancelSignal) {
    const bufferSizeGraphWrapperElt = createElement3("div");
    const bufferSizeTitle = createMetricTitle("bgap");
    const canvasElt = createGraphCanvas();
    const bufferSizeGraph = new BufferSizeGraph(canvasElt);
    const intervalId = setInterval(addBufferSize, DEFAULT_REFRESH_INTERVAL);
    cancelSignal.register(() => {
      clearInterval(intervalId);
    });
    bufferSizeGraphWrapperElt.appendChild(bufferSizeTitle);
    bufferSizeGraphWrapperElt.appendChild(canvasElt);
    bufferSizeGraphWrapperElt.style.padding = "7px 0px";
    addBufferSize();
    return bufferSizeGraphWrapperElt;
    function addBufferSize() {
      if (instance.getVideoElement() === null) {
        bufferSizeGraphWrapperElt.innerHTML = "";
        clearInterval(intervalId);
        return;
      }
      const bufferGap = instance.getCurrentBufferGap();
      if (bufferGap === Infinity) {
        bufferSizeGraph.pushBufferSize(0);
      } else {
        bufferSizeGraph.pushBufferSize(bufferGap);
      }
      const width = Math.min(parentElt.clientWidth - 150, 600);
      bufferSizeGraph.reRender(width, 10);
    }
  }

  // src/main_thread/api/debug/render.ts
  function renderDebugElement(parentElt, instance, cancelSignal) {
    const debugElementTitleElt = createElement3("div", {
      textContent: "RxPlayer Debug Information"
    });
    debugElementTitleElt.style.fontWeight = "bold";
    debugElementTitleElt.style.borderBottom = "1px solid white";
    debugElementTitleElt.style.marginBottom = "5px";
    debugElementTitleElt.style.fontStyle = "italic";
    const debugWrapperElt = createCompositeElement("div", [
      debugElementTitleElt,
      constructDebugGeneralInfo(instance, parentElt, cancelSignal),
      createSegmentSinkGraph(instance, "video", "vbuf", parentElt, cancelSignal),
      createSegmentSinkGraph(instance, "audio", "abuf", parentElt, cancelSignal),
      createSegmentSinkGraph(instance, "text", "tbuf", parentElt, cancelSignal),
      createSegmentSinkSizeGraph(instance, parentElt, cancelSignal)
    ]);
    debugWrapperElt.style.backgroundColor = "#00000099";
    debugWrapperElt.style.padding = "7px";
    debugWrapperElt.style.fontSize = "13px";
    debugWrapperElt.style.fontFamily = "mono, monospace";
    debugWrapperElt.style.color = "white";
    debugWrapperElt.style.display = "inline-block";
    debugWrapperElt.style.bottom = "0px";
    parentElt.appendChild(debugWrapperElt);
    cancelSignal.register(() => {
      parentElt.removeChild(debugWrapperElt);
    });
  }

  // src/main_thread/api/debug/index.ts
  var debug_default = renderDebugElement;

  // src/features/list/debug_element.ts
  function addDebugElementFeature(features2) {
    features2.createDebugElement = debug_default;
  }

  // src/features/list/directfile.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/main_thread/init/directfile_content_initializer.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var DirectFileContentInitializer = class extends ContentInitializer {
    /**
     * Creates a new `DirectFileContentInitializer` linked to the given settings.
     * @param {Object} settings
     */
    constructor(settings) {
      super();
      this._settings = settings;
      this._initCanceller = new TaskCanceller();
    }
    /**
     * "Prepare" content so it can later be played by calling `start`.
     */
    prepare() {
      return;
    }
    /**
     * Start playback of the content linked to this `DirectFileContentInitializer`
     * on the given `HTMLMediaElement` and its associated `PlaybackObserver`.
     * @param {HTMLMediaElement} mediaElement - HTMLMediaElement on which the
     * content will be played.
     * @param {Object} playbackObserver - Object regularly emitting playback
     * information.
     */
    start(mediaElement, playbackObserver) {
      const cancelSignal = this._initCanceller.signal;
      const { keySystems, speed, url } = this._settings;
      clearElementSrc(mediaElement);
      const { statusRef: drmInitRef } = initializeContentDecryption(
        mediaElement,
        keySystems,
        {
          onError: (err) => this._onFatalError(err),
          onWarning: (err) => this.trigger("warning", err),
          onBlackListProtectionData: noop_default,
          onKeyIdsCompatibilityUpdate: noop_default
        },
        cancelSignal
      );
      listenToMediaError(
        mediaElement,
        (error) => this._onFatalError(error),
        cancelSignal
      );
      const rebufferingController = new RebufferingController(
        playbackObserver,
        null,
        speed
      );
      rebufferingController.addEventListener(
        "stalled",
        (evt) => this.trigger("stalled", evt)
      );
      rebufferingController.addEventListener(
        "unstalled",
        () => this.trigger("unstalled", null)
      );
      rebufferingController.addEventListener(
        "warning",
        (err) => this.trigger("warning", err)
      );
      cancelSignal.register(() => {
        rebufferingController.destroy();
      });
      rebufferingController.start();
      drmInitRef.onUpdate(
        (evt, stopListeningToDrmUpdates) => {
          if (evt.initializationState.type === "uninitialized") {
            return;
          }
          stopListeningToDrmUpdates();
          log_default.info("Setting URL to HTMLMediaElement", url);
          mediaElement.src = url;
          cancelSignal.register(() => {
            log_default.info("Init: Removing directfile src from media element", mediaElement.src);
            clearElementSrc(mediaElement);
          });
          if (evt.initializationState.type === "awaiting-media-link") {
            evt.initializationState.value.isMediaLinked.setValue(true);
            drmInitRef.onUpdate(
              (newDrmStatus, stopListeningToDrmUpdatesAgain) => {
                if (newDrmStatus.initializationState.type === "initialized") {
                  stopListeningToDrmUpdatesAgain();
                  this._seekAndPlay(mediaElement, playbackObserver);
                }
              },
              { emitCurrentValue: true, clearSignal: cancelSignal }
            );
          } else {
            assert(evt.initializationState.type === "initialized");
            this._seekAndPlay(mediaElement, playbackObserver);
          }
        },
        { emitCurrentValue: true, clearSignal: cancelSignal }
      );
    }
    /**
     * Update URL this `ContentIntializer` depends on.
     * @param {Array.<string>|undefined} _urls
     * @param {boolean} _refreshNow
     */
    updateContentUrls(_urls, _refreshNow) {
      throw new Error("Cannot update content URL of directfile contents");
    }
    /**
     * Stop content and free all resources linked to this `ContentIntializer`.
     */
    dispose() {
      this._initCanceller.cancel();
    }
    /**
     * Logic performed when a fatal error was triggered.
     * @param {*} err - The fatal error in question.
     */
    _onFatalError(err) {
      this._initCanceller.cancel();
      this.trigger("error", err);
    }
    /**
     * Perform the initial seek (to begin playback at an initially-calculated
     * position based on settings) and auto-play if needed when loaded.
     * @param {HTMLMediaElement} mediaElement
     * @param {Object} playbackObserver
     */
    _seekAndPlay(mediaElement, playbackObserver) {
      const cancelSignal = this._initCanceller.signal;
      const { autoPlay, startAt } = this._settings;
      const initialTime = () => {
        log_default.debug("Init: Calculating initial time");
        const initTime = getDirectFileInitialTime(mediaElement, startAt);
        log_default.debug("Init: Initial time calculated:", initTime);
        return initTime;
      };
      performInitialSeekAndPlay(
        {
          mediaElement,
          playbackObserver,
          startTime: initialTime,
          mustAutoPlay: autoPlay,
          onWarning: (err) => this.trigger("warning", err),
          isDirectfile: true
        },
        cancelSignal
      ).autoPlayResult.then(
        () => getLoadedReference(playbackObserver, mediaElement, true, cancelSignal).onUpdate(
          (isLoaded, stopListening) => {
            if (isLoaded) {
              stopListening();
              this.trigger("loaded", {
                getSegmentSinkMetrics: null,
                getThumbnailData: () => Promise.reject(
                  new Error("Thumbnail data not available with directfile contents")
                )
              });
            }
          },
          { emitCurrentValue: true, clearSignal: cancelSignal }
        )
      ).catch((err) => {
        if (!cancelSignal.isCancelled()) {
          this._onFatalError(err);
        }
      });
    }
  };
  function getDirectFileInitialTime(mediaElement, startAt) {
    if (isNullOrUndefined(startAt)) {
      return 0;
    }
    if (!isNullOrUndefined(startAt.position)) {
      return startAt.position;
    } else if (!isNullOrUndefined(startAt.wallClockTime)) {
      return startAt.wallClockTime;
    } else if (!isNullOrUndefined(startAt.fromFirstPosition)) {
      return startAt.fromFirstPosition;
    }
    const duration = mediaElement.duration;
    if (typeof startAt.fromLastPosition === "number") {
      if (isNullOrUndefined(duration) || !isFinite(duration)) {
        log_default.warn(
          "startAt.fromLastPosition set but no known duration, beginning at 0."
        );
        return 0;
      }
      return Math.max(0, duration + startAt.fromLastPosition);
    } else if (typeof startAt.fromLivePosition === "number") {
      const livePosition = mediaElement.seekable.length > 0 ? mediaElement.seekable.end(0) : duration;
      if (isNullOrUndefined(livePosition)) {
        log_default.warn(
          "startAt.fromLivePosition set but no known live position, beginning at 0."
        );
        return 0;
      }
      return Math.max(0, livePosition + startAt.fromLivePosition);
    } else if (!isNullOrUndefined(startAt.percentage)) {
      if (isNullOrUndefined(duration) || !isFinite(duration)) {
        log_default.warn("startAt.percentage set but no known duration, beginning at 0.");
        return 0;
      }
      const { percentage } = startAt;
      if (percentage >= 100) {
        return duration;
      } else if (percentage <= 0) {
        return 0;
      }
      const ratio = +percentage / 100;
      return duration * ratio;
    }
    return 0;
  }

  // src/main_thread/tracks_store/media_element_tracks_store.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/compat/enable_audio_track.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function enableAudioTrack(audioTracks, indexToEnable) {
    for (let i = 0; i < audioTracks.length; i++) {
      if (!isTizen || i !== indexToEnable) {
        audioTracks[i].enabled = false;
      }
    }
    if (indexToEnable < 0 || indexToEnable >= audioTracks.length) {
      return false;
    }
    audioTracks[indexToEnable].enabled = true;
    return true;
  }

  // src/main_thread/tracks_store/media_element_tracks_store.ts
  function areTrackArraysDifferent(oldTrackArray, newTrackArray) {
    var _a;
    if (newTrackArray.length !== oldTrackArray.length) {
      return true;
    }
    for (let i = 0; i < newTrackArray.length; i++) {
      if (newTrackArray[i].nativeTrack !== ((_a = oldTrackArray[i]) == null ? void 0 : _a.nativeTrack)) {
        return true;
      }
    }
    return false;
  }
  function createAudioTracks(audioTracks) {
    var _a;
    const newAudioTracks = [];
    const languagesOccurences = {};
    for (let i = 0; i < audioTracks.length; i++) {
      const audioTrack = audioTracks[i];
      const language = audioTrack.language === "" ? "nolang" : audioTrack.language;
      const occurences = (_a = languagesOccurences[language]) != null ? _a : 1;
      const id = "gen_audio_" + language + "_" + occurences.toString();
      languagesOccurences[language] = occurences + 1;
      const track = {
        language: audioTrack.language,
        id,
        normalized: languages_default(audioTrack.language),
        audioDescription: audioTrack.kind === "descriptions" || // Safari seem to prefer the non-standard singular
        // version, funnily enough
        audioTrack.kind === "description",
        representations: []
      };
      newAudioTracks.push({ track, nativeTrack: audioTrack });
    }
    return newAudioTracks;
  }
  function createTextTracks(textTracks) {
    var _a;
    const newTextTracks = [];
    const languagesOccurences = {};
    for (let i = 0; i < textTracks.length; i++) {
      const textTrack = textTracks[i];
      const language = textTrack.language === "" ? "nolang" : textTrack.language;
      const occurences = (_a = languagesOccurences[language]) != null ? _a : 1;
      const id = "gen_text_" + language + "_" + occurences.toString();
      languagesOccurences[language] = occurences + 1;
      const forced = textTrack.kind === "forced" ? true : void 0;
      const track = {
        language: textTrack.language,
        forced,
        label: textTrack.label,
        id,
        normalized: languages_default(textTrack.language),
        closedCaption: textTrack.kind === "captions"
      };
      newTextTracks.push({ track, nativeTrack: textTrack });
    }
    return newTextTracks;
  }
  function createVideoTracks(videoTracks) {
    var _a;
    const newVideoTracks = [];
    const languagesOccurences = {};
    for (let i = 0; i < videoTracks.length; i++) {
      const videoTrack = videoTracks[i];
      const language = videoTrack.language === "" ? "nolang" : videoTrack.language;
      const occurences = (_a = languagesOccurences[language]) != null ? _a : 1;
      const id = "gen_video_" + language + "_" + occurences.toString();
      languagesOccurences[language] = occurences + 1;
      newVideoTracks.push({
        track: { id, representations: [] },
        nativeTrack: videoTrack
      });
    }
    return newVideoTracks;
  }
  var MediaElementTracksStore = class extends EventEmitter {
    constructor(mediaElement) {
      var _a, _b, _c;
      super();
      this._nativeAudioTracks = mediaElement.audioTracks;
      this._nativeVideoTracks = mediaElement.videoTracks;
      this._nativeTextTracks = mediaElement.textTracks;
      this._audioTracks = this._nativeAudioTracks !== void 0 ? createAudioTracks(this._nativeAudioTracks) : [];
      this._videoTracks = this._nativeVideoTracks !== void 0 ? createVideoTracks(this._nativeVideoTracks) : [];
      this._textTracks = this._nativeTextTracks !== void 0 ? createTextTracks(this._nativeTextTracks) : [];
      this._lastEmittedNativeAudioTrack = (_a = this._getCurrentAudioTrack()) == null ? void 0 : _a.nativeTrack;
      this._lastEmittedNativeVideoTrack = (_b = this._getCurrentVideoTrack()) == null ? void 0 : _b.nativeTrack;
      this._lastEmittedNativeTextTrack = (_c = this._getCurrentTextTrack()) == null ? void 0 : _c.nativeTrack;
      this._handleNativeTracksCallbacks();
    }
    /**
     * Update the currently active audio track by setting the wanted audio track's
     * ID property.
     * Throws if the wanted audio track is not found.
     * @param {string|number|undefined} id
     */
    setAudioTrackById(id) {
      for (let i = 0; i < this._audioTracks.length; i++) {
        const { track, nativeTrack } = this._audioTracks[i];
        if (track.id === id) {
          this._enableAudioTrackFromIndex(i);
          this._audioTrackLockedOn = nativeTrack;
          return;
        }
      }
      throw new Error("Audio track not found.");
    }
    /**
     * Disable the currently-active text track, if one.
     */
    disableTextTrack() {
      disableTextTracks(this._textTracks);
      this._textTrackLockedOn = null;
    }
    /**
     * Update the currently active text track by setting the wanted text track's
     * ID property.
     * Throws if the wanted text track is not found.
     * @param {string|number|undefined} id
     */
    setTextTrackById(id) {
      let hasSetTrack = false;
      for (let i = 0; i < this._textTracks.length; i++) {
        const { track, nativeTrack } = this._textTracks[i];
        if (track.id === id) {
          nativeTrack.mode = "showing";
          hasSetTrack = true;
          this._textTrackLockedOn = nativeTrack;
        } else if (nativeTrack.mode === "showing" || nativeTrack.mode === "hidden") {
          nativeTrack.mode = "disabled";
        }
      }
      if (!hasSetTrack) {
        throw new Error("Text track not found.");
      }
    }
    /**
     * Disable the currently-active video track, if one.
     */
    disableVideoTrack() {
      disableVideoTracks(this._videoTracks);
      this._videoTrackLockedOn = null;
    }
    /**
     * Update the currently active video track by setting the wanted video track's
     * ID property.
     * Throws if the wanted video track is not found.
     * @param {string|number|undefined} id
     */
    setVideoTrackById(id) {
      for (let i = 0; i < this._videoTracks.length; i++) {
        const { track, nativeTrack } = this._videoTracks[i];
        if (track.id === id) {
          nativeTrack.selected = true;
          this._videoTrackLockedOn = nativeTrack;
          return;
        }
      }
      throw new Error("Video track not found.");
    }
    /**
     * Returns the currently active audio track.
     * Returns `null` if no audio track is active.
     * Returns `undefined` if we cannot know which audio track is active.
     * @returns {Object|null|undefined}
     */
    getChosenAudioTrack() {
      const currentAudioTrack = this._getCurrentAudioTrack();
      return isNullOrUndefined(currentAudioTrack) ? currentAudioTrack : currentAudioTrack.track;
    }
    /**
     * Returns the currently active text track.
     * Returns `null` if no text track is active.
     * Returns `undefined` if we cannot know which text track is active.
     * @returns {Object|null|undefined}
     */
    getChosenTextTrack() {
      const currentTextTrack = this._getCurrentTextTrack();
      return isNullOrUndefined(currentTextTrack) ? currentTextTrack : currentTextTrack.track;
    }
    /**
     * Returns the currently active video track.
     * Returns `null` if no video track is active.
     * Returns `undefined` if we cannot know which video track is active.
     * @returns {Object|null|undefined}
     */
    getChosenVideoTrack() {
      const currentVideoTrack = this._getCurrentVideoTrack();
      return isNullOrUndefined(currentVideoTrack) ? currentVideoTrack : currentVideoTrack.track;
    }
    /**
     * Returns a description of every available audio tracks.
     * @returns {Array.<Object>}
     */
    getAvailableAudioTracks() {
      return this._audioTracks.map(({ track, nativeTrack }) => {
        return {
          id: track.id,
          language: track.language,
          normalized: track.normalized,
          audioDescription: track.audioDescription,
          active: nativeTrack.enabled,
          representations: track.representations
        };
      });
    }
    /**
     * Returns a description of every available text tracks.
     * @returns {Array.<Object>}
     */
    getAvailableTextTracks() {
      return this._textTracks.map(({ track, nativeTrack }) => {
        return {
          id: track.id,
          label: track.label,
          forced: track.forced,
          language: track.language,
          normalized: track.normalized,
          closedCaption: track.closedCaption,
          active: nativeTrack.mode === "showing"
        };
      });
    }
    /**
     * Returns a description of every available video tracks.
     * @returns {Array.<Object>}
     */
    getAvailableVideoTracks() {
      return this._videoTracks.map(({ track, nativeTrack }) => {
        return {
          id: track.id,
          representations: track.representations,
          active: nativeTrack.selected
        };
      });
    }
    /**
     * Free the resources used by the MediaElementTracksStore.
     */
    dispose() {
      if (this._nativeVideoTracks !== void 0) {
        this._nativeVideoTracks.onchange = null;
        this._nativeVideoTracks.onaddtrack = null;
        this._nativeVideoTracks.onremovetrack = null;
      }
      if (this._nativeAudioTracks !== void 0) {
        this._nativeAudioTracks.onchange = null;
        this._nativeAudioTracks.onaddtrack = null;
        this._nativeAudioTracks.onremovetrack = null;
      }
      if (this._nativeTextTracks !== void 0) {
        this._nativeTextTracks.onchange = null;
        this._nativeTextTracks.onaddtrack = null;
        this._nativeTextTracks.onremovetrack = null;
      }
      this.removeEventListener();
    }
    /**
     * Get information about the currently chosen audio track.
     * `undefined` if we cannot know it.
     * `null` if no audio track is chosen.
     * @returns {Object|undefined|null}
     */
    _getCurrentAudioTrack() {
      if (this._nativeAudioTracks === void 0) {
        return void 0;
      }
      for (let i = 0; i < this._audioTracks.length; i++) {
        const audioTrack = this._audioTracks[i];
        if (audioTrack.nativeTrack.enabled) {
          return audioTrack;
        }
      }
      return null;
    }
    /**
     * Get information about the currently chosen video track.
     * `undefined` if we cannot know it.
     * `null` if no video track is chosen.
     * @returns {Object|undefined|null}
     */
    _getCurrentVideoTrack() {
      if (this._nativeVideoTracks === void 0) {
        return void 0;
      }
      for (let i = 0; i < this._videoTracks.length; i++) {
        const videoTrack = this._videoTracks[i];
        if (videoTrack.nativeTrack.selected) {
          return videoTrack;
        }
      }
      return null;
    }
    /**
     * Get information about the currently chosen text track.
     * `undefined` if we cannot know it.
     * `null` if no text track is chosen.
     * @returns {Object|undefined|null}
     */
    _getCurrentTextTrack() {
      if (this._nativeTextTracks === void 0) {
        return void 0;
      }
      for (let i = 0; i < this._textTracks.length; i++) {
        const textTrack = this._textTracks[i];
        if (textTrack.nativeTrack.mode === "showing") {
          return textTrack;
        }
      }
      return null;
    }
    /**
     * Iterate over every available audio tracks on the media element and either:
     *   - if the last manually set audio track is found, set that one.
     *   - if we still do not find an optimal track, let the one chosen by default
     */
    _setPreviouslyLockedAudioTrack() {
      if (this._audioTrackLockedOn === void 0) {
        return;
      } else if (this._audioTrackLockedOn === null) {
        for (let i = 0; i < this._audioTracks.length; i++) {
          const { nativeTrack } = this._audioTracks[i];
          nativeTrack.enabled = false;
        }
      } else {
        for (let i = 0; i < this._audioTracks.length; i++) {
          const { nativeTrack } = this._audioTracks[i];
          if (nativeTrack === this._audioTrackLockedOn) {
            this._enableAudioTrackFromIndex(i);
            return;
          }
        }
      }
    }
    /**
     * Iterate over every available text tracks on the media element and either:
     *   - if the last manually set text track is found, set that one.
     *   - if we still do not find an optimal track, just disable it.
     */
    _setPreviouslyLockedTextTrack() {
      if (this._textTrackLockedOn === void 0) {
        return;
      } else if (this._textTrackLockedOn === null) {
        disableTextTracks(this._textTracks);
        return;
      } else {
        for (let i = 0; i < this._textTracks.length; i++) {
          const { nativeTrack } = this._textTracks[i];
          if (nativeTrack === this._textTrackLockedOn) {
            disableAllTextTracksBut(this._textTracks, nativeTrack);
            if (nativeTrack.mode !== "showing") {
              nativeTrack.mode = "showing";
            }
            return;
          }
        }
      }
    }
    /**
     * Iterate over every available video tracks on the media element and either:
     *   - if the last manually set video track is found, set that one.
     *   - if we still do not find an optimal track, let the one chosen by default
     */
    _setPreviouslyLockedVideoTrack() {
      if (this._videoTrackLockedOn === void 0) {
        return;
      } else if (this._videoTrackLockedOn === null) {
        disableVideoTracks(this._videoTracks);
        return;
      } else {
        for (let i = 0; i < this._videoTracks.length; i++) {
          const { nativeTrack } = this._videoTracks[i];
          if (nativeTrack === this._videoTrackLockedOn) {
            nativeTrack.selected = true;
            return;
          }
        }
      }
    }
    /**
     * Monitor native tracks add, remove and change callback and trigger the
     * change events.
     */
    _handleNativeTracksCallbacks() {
      if (this._nativeAudioTracks !== void 0) {
        this._nativeAudioTracks.onaddtrack = () => {
          var _a, _b;
          if (this._nativeAudioTracks !== void 0) {
            const newAudioTracks = createAudioTracks(this._nativeAudioTracks);
            if (areTrackArraysDifferent(this._audioTracks, newAudioTracks)) {
              this._audioTracks = newAudioTracks;
              this._setPreviouslyLockedAudioTrack();
              this.trigger("availableAudioTracksChange", this.getAvailableAudioTracks());
              const chosenAudioTrack = this._getCurrentAudioTrack();
              if ((chosenAudioTrack == null ? void 0 : chosenAudioTrack.nativeTrack) !== this._lastEmittedNativeAudioTrack) {
                this.trigger("audioTrackChange", (_a = chosenAudioTrack == null ? void 0 : chosenAudioTrack.track) != null ? _a : null);
                this._lastEmittedNativeAudioTrack = (_b = chosenAudioTrack == null ? void 0 : chosenAudioTrack.nativeTrack) != null ? _b : null;
              }
            }
          }
        };
        this._nativeAudioTracks.onremovetrack = () => {
          var _a, _b;
          if (this._nativeAudioTracks !== void 0) {
            const newAudioTracks = createAudioTracks(this._nativeAudioTracks);
            if (areTrackArraysDifferent(this._audioTracks, newAudioTracks)) {
              this._audioTracks = newAudioTracks;
              this.trigger("availableAudioTracksChange", this.getAvailableAudioTracks());
              const chosenAudioTrack = this._getCurrentAudioTrack();
              if ((chosenAudioTrack == null ? void 0 : chosenAudioTrack.nativeTrack) !== this._lastEmittedNativeAudioTrack) {
                this.trigger("audioTrackChange", (_a = chosenAudioTrack == null ? void 0 : chosenAudioTrack.track) != null ? _a : null);
                this._lastEmittedNativeAudioTrack = (_b = chosenAudioTrack == null ? void 0 : chosenAudioTrack.nativeTrack) != null ? _b : null;
              }
            }
          }
        };
        this._nativeAudioTracks.onchange = () => {
          if (this._audioTracks !== void 0) {
            for (let i = 0; i < this._audioTracks.length; i++) {
              const { track, nativeTrack } = this._audioTracks[i];
              if (nativeTrack.enabled) {
                if (nativeTrack !== this._lastEmittedNativeAudioTrack) {
                  this.trigger("audioTrackChange", track);
                  this._lastEmittedNativeAudioTrack = nativeTrack;
                }
                return;
              }
            }
          }
          if (this._lastEmittedNativeAudioTrack !== null) {
            this.trigger("audioTrackChange", null);
            this._lastEmittedNativeAudioTrack = null;
          }
          return;
        };
      }
      if (this._nativeTextTracks !== void 0) {
        this._nativeTextTracks.onaddtrack = () => {
          var _a, _b;
          if (this._nativeTextTracks !== void 0) {
            const newTextTracks = createTextTracks(this._nativeTextTracks);
            if (areTrackArraysDifferent(this._textTracks, newTextTracks)) {
              this._textTracks = newTextTracks;
              this._setPreviouslyLockedTextTrack();
              this.trigger("availableTextTracksChange", this.getAvailableTextTracks());
              const chosenTextTrack = this._getCurrentTextTrack();
              if ((chosenTextTrack == null ? void 0 : chosenTextTrack.nativeTrack) !== this._lastEmittedNativeTextTrack) {
                this.trigger("textTrackChange", (_a = chosenTextTrack == null ? void 0 : chosenTextTrack.track) != null ? _a : null);
                this._lastEmittedNativeTextTrack = (_b = chosenTextTrack == null ? void 0 : chosenTextTrack.nativeTrack) != null ? _b : null;
              }
            }
          }
        };
        this._nativeTextTracks.onremovetrack = () => {
          var _a, _b;
          if (this._nativeTextTracks !== void 0) {
            const newTextTracks = createTextTracks(this._nativeTextTracks);
            if (areTrackArraysDifferent(this._textTracks, newTextTracks)) {
              this._textTracks = newTextTracks;
              this._setPreviouslyLockedTextTrack();
              this.trigger("availableTextTracksChange", this.getAvailableTextTracks());
              const chosenTextTrack = this._getCurrentTextTrack();
              if ((chosenTextTrack == null ? void 0 : chosenTextTrack.nativeTrack) !== this._lastEmittedNativeTextTrack) {
                this.trigger("textTrackChange", (_a = chosenTextTrack == null ? void 0 : chosenTextTrack.track) != null ? _a : null);
                this._lastEmittedNativeTextTrack = (_b = chosenTextTrack == null ? void 0 : chosenTextTrack.nativeTrack) != null ? _b : null;
              }
            }
          }
        };
        this._nativeTextTracks.onchange = () => {
          if (this._textTracks !== void 0) {
            for (let i = 0; i < this._textTracks.length; i++) {
              const { track, nativeTrack } = this._textTracks[i];
              if (nativeTrack.mode === "showing") {
                if (nativeTrack !== this._lastEmittedNativeTextTrack) {
                  this.trigger("textTrackChange", track);
                  this._lastEmittedNativeTextTrack = nativeTrack;
                }
                return;
              }
            }
          }
          if (this._lastEmittedNativeTextTrack !== null) {
            this.trigger("textTrackChange", null);
            this._lastEmittedNativeTextTrack = null;
          }
          return;
        };
      }
      if (this._nativeVideoTracks !== void 0) {
        this._nativeVideoTracks.onaddtrack = () => {
          var _a, _b;
          if (this._nativeVideoTracks !== void 0) {
            const newVideoTracks = createVideoTracks(this._nativeVideoTracks);
            if (areTrackArraysDifferent(this._videoTracks, newVideoTracks)) {
              this._videoTracks = newVideoTracks;
              this._setPreviouslyLockedVideoTrack();
              this.trigger("availableVideoTracksChange", this.getAvailableVideoTracks());
              const chosenVideoTrack = this._getCurrentVideoTrack();
              if ((chosenVideoTrack == null ? void 0 : chosenVideoTrack.nativeTrack) !== this._lastEmittedNativeVideoTrack) {
                this.trigger("videoTrackChange", (_a = chosenVideoTrack == null ? void 0 : chosenVideoTrack.track) != null ? _a : null);
                this._lastEmittedNativeVideoTrack = (_b = chosenVideoTrack == null ? void 0 : chosenVideoTrack.nativeTrack) != null ? _b : null;
              }
            }
          }
        };
        this._nativeVideoTracks.onremovetrack = () => {
          var _a, _b;
          if (this._nativeVideoTracks !== void 0) {
            const newVideoTracks = createVideoTracks(this._nativeVideoTracks);
            if (areTrackArraysDifferent(this._videoTracks, newVideoTracks)) {
              this._videoTracks = newVideoTracks;
              this._setPreviouslyLockedVideoTrack();
              this.trigger("availableVideoTracksChange", this.getAvailableVideoTracks());
              const chosenVideoTrack = this._getCurrentVideoTrack();
              if ((chosenVideoTrack == null ? void 0 : chosenVideoTrack.nativeTrack) !== this._lastEmittedNativeVideoTrack) {
                this.trigger("videoTrackChange", (_a = chosenVideoTrack == null ? void 0 : chosenVideoTrack.track) != null ? _a : null);
                this._lastEmittedNativeVideoTrack = (_b = chosenVideoTrack == null ? void 0 : chosenVideoTrack.nativeTrack) != null ? _b : null;
              }
            }
          }
        };
        this._nativeVideoTracks.onchange = () => {
          if (this._videoTracks !== void 0) {
            for (let i = 0; i < this._videoTracks.length; i++) {
              const { track, nativeTrack } = this._videoTracks[i];
              if (nativeTrack.selected) {
                if (nativeTrack !== this._lastEmittedNativeVideoTrack) {
                  this.trigger("videoTrackChange", track);
                  this._lastEmittedNativeVideoTrack = nativeTrack;
                }
                return;
              }
            }
          }
          if (this._lastEmittedNativeVideoTrack !== null) {
            this.trigger("videoTrackChange", null);
            this._lastEmittedNativeVideoTrack = null;
          }
          return;
        };
      }
    }
    /**
     * Enable an audio track (and disable all others), based on its index in the
     * `this._audioTracks` array.
     * @param {number} index}
     */
    _enableAudioTrackFromIndex(index) {
      enableAudioTrack(
        this._audioTracks.map(({ nativeTrack }) => nativeTrack),
        index
      );
    }
  };
  function disableTextTracks(textTracks) {
    for (let i = 0; i < textTracks.length; i++) {
      const { nativeTrack } = textTracks[i];
      nativeTrack.mode = "disabled";
    }
  }
  function disableAllTextTracksBut(textTracks, track) {
    for (let i = 0; i < textTracks.length; i++) {
      const { nativeTrack } = textTracks[i];
      if (nativeTrack !== track && (nativeTrack.mode === "showing" || nativeTrack.mode === "hidden")) {
        nativeTrack.mode = "disabled";
      }
    }
  }
  function disableVideoTracks(videoTracks) {
    for (let i = 0; i < videoTracks.length; i++) {
      const { nativeTrack } = videoTracks[i];
      nativeTrack.selected = false;
    }
  }

  // src/features/list/directfile.ts
  function addDirectfileFeature(features2) {
    features2.directfile = { initDirectFile: DirectFileContentInitializer, mediaElementTracksStore: MediaElementTracksStore };
  }

  // src/features/list/eme.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function addEMEFeature(features2) {
    features2.decrypt = decrypt_default;
  }

  // src/features/list/html_sami_parser.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/main_thread/text_displayer/html/index.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/main_thread/text_displayer/html/html_text_displayer.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/compat/on_height_width_change.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var _ResizeObserver = global_scope_default.ResizeObserver;
  function onHeightWidthChange(element, interval, cancellationSignal) {
    const { height: initHeight, width: initWidth } = element.getBoundingClientRect();
    const ref = new reference_default(
      {
        height: initHeight,
        width: initWidth
      },
      cancellationSignal
    );
    let lastHeight = initHeight;
    let lastWidth = initWidth;
    if (_ResizeObserver !== void 0) {
      const resizeObserver = new _ResizeObserver((entries) => {
        if (entries.length === 0) {
          log_default.error("Compat: Resized but no observed element.");
          return;
        }
        const entry = entries[0];
        const { height, width } = entry.contentRect;
        if (height !== lastHeight || width !== lastWidth) {
          lastHeight = height;
          lastWidth = width;
          ref.setValue({ height, width });
        }
      });
      resizeObserver.observe(element);
      cancellationSignal.register(() => {
        resizeObserver.disconnect();
      });
    } else {
      const intervalId = setInterval(() => {
        const { height, width } = element.getBoundingClientRect();
        if (height !== lastHeight || width !== lastWidth) {
          lastHeight = height;
          lastWidth = width;
          ref.setValue({ height, width });
        }
      }, interval);
      cancellationSignal.register(() => {
        clearInterval(intervalId);
      });
    }
    return ref;
  }

  // src/main_thread/text_displayer/manual_time_ranges.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var ManualTimeRanges = class {
    constructor() {
      this._ranges = [];
      this.length = 0;
    }
    insert(start, end) {
      if (define_ENVIRONMENT_default.CURRENT_ENV === define_ENVIRONMENT_default.DEV) {
        assert(start >= 0, "invalid start time");
        assert(end - start > 0, "invalid end time");
      }
      insertInto(this._ranges, { start, end });
      this.length = this._ranges.length;
    }
    remove(start, end) {
      if (define_ENVIRONMENT_default.CURRENT_ENV === define_ENVIRONMENT_default.DEV) {
        assert(start >= 0, "invalid start time");
        assert(end - start > 0, "invalid end time");
      }
      const rangesToIntersect = [];
      if (start > 0) {
        rangesToIntersect.push({ start: 0, end: start });
      }
      if (end < Infinity) {
        rangesToIntersect.push({ start: end, end: Infinity });
      }
      this._ranges = keepRangeIntersection(this._ranges, rangesToIntersect);
      this.length = this._ranges.length;
    }
    start(index) {
      if (index >= this._ranges.length) {
        throw new Error("INDEX_SIZE_ERROR");
      }
      return this._ranges[index].start;
    }
    end(index) {
      if (index >= this._ranges.length) {
        throw new Error("INDEX_SIZE_ERROR");
      }
      return this._ranges[index].end;
    }
  };

  // src/main_thread/text_displayer/html/html_parsers.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function parseTextTrackToElements(type, data2, timestampOffset, language) {
    log_default.debug("HTSB: Finding parser for html text tracks:", type);
    const parser = features_default.htmlTextTracksParsers[type];
    if (typeof parser !== "function") {
      throw new Error("no parser found for the given text track");
    }
    log_default.debug("HTSB: Parser found, parsing...");
    const parsed = parser(data2, timestampOffset, language);
    log_default.debug("HTTB: Parsed successfully!", parsed.length);
    return parsed;
  }

  // src/main_thread/text_displayer/html/text_track_cues_store.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/main_thread/text_displayer/html/utils.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var MAX_DELTA_BUFFER_TIME = 0.2;
  function areNearlyEqual(a, b, delta = MAX_DELTA_BUFFER_TIME) {
    return Math.abs(a - b) <= Math.min(delta, MAX_DELTA_BUFFER_TIME);
  }
  var EPSILON3 = 0.05;
  function areCuesStartNearlyEqual(firstCue, secondCue) {
    const firstCueDuration = firstCue.end - firstCue.start;
    const secondCueDuration = secondCue.end - secondCue.start;
    const diffBetweenStart = Math.abs(firstCue.start - secondCue.start);
    const minDuration = Math.min(
      firstCueDuration,
      secondCueDuration,
      MAX_DELTA_BUFFER_TIME
    );
    return diffBetweenStart / minDuration <= EPSILON3;
  }
  function getCuesBefore(cues, time) {
    for (let i = cues.length - 1; i >= 0; i--) {
      const cue = cues[i];
      if (cue.start < time) {
        return cues.slice(0, i + 1);
      }
    }
    return [];
  }
  function getCuesAfter(cues, time) {
    for (let i = 0; i < cues.length; i++) {
      const cue = cues[i];
      if (cue.end > time) {
        return cues.slice(i, cues.length);
      }
    }
    return [];
  }
  function removeCuesInfosBetween(cuesInfos, start, end) {
    const endCuesInfos1 = Math.max(cuesInfos.start, start);
    const cues1 = getCuesBefore(cuesInfos.cues, start);
    const cuesInfos1 = {
      start: cuesInfos.start,
      end: endCuesInfos1,
      cues: cues1
    };
    const startCuesInfos2 = Math.min(end, cuesInfos.end);
    const cues2 = getCuesAfter(cuesInfos.cues, end);
    const cuesInfos2 = {
      start: startCuesInfos2,
      end: cuesInfos.end,
      cues: cues2
    };
    return [cuesInfos1, cuesInfos2];
  }

  // src/main_thread/text_displayer/html/text_track_cues_store.ts
  var DELTA_CUES_GROUP = 1e-3;
  var RELATIVE_DELTA_RATIO = 5;
  var TextTrackCuesStore = class {
    constructor() {
      this._cuesBuffer = [];
    }
    isEmpty() {
      return this._cuesBuffer.length === 0;
    }
    /**
     * Get corresponding cue(s) for the given time.
     * A cue is an object with three properties:
     *   - start {Number}: start time for which the cue should be displayed.
     *   - end {Number}: end time for which the cue should be displayed.
     *   - element {HTMLElement}: The cue to diplay
     *
     * We do not mutate individual cue here.
     * That is, if the ``get`` method returns the same cue's reference than a
     * previous ``get`` call, its properties are guaranteed to have the exact same
     * values than before, if you did not mutate it on your side.
     * The inverse is true, if the values are the same than before, the reference
     * will stay the same (this is useful to easily check if the DOM should be
     * updated, for example).
     *
     * @param {Number} time
     * @returns {Array.<HTMLElement>} - The cues that need to be displayed at that
     * time.
     */
    get(time) {
      const cuesBuffer = this._cuesBuffer;
      const ret = [];
      for (let cueIdx = cuesBuffer.length - 1; cueIdx >= 0; cueIdx--) {
        const segment = cuesBuffer[cueIdx];
        if (time < segment.end && time >= segment.start) {
          const cues = segment.cues;
          for (const cue of cues) {
            if (time >= cue.start && time < cue.end) {
              ret.push(cue.element);
            }
          }
          if (ret.length === 0 && cues.length > 0) {
            for (const cue of cues) {
              if (areNearlyEqual(time, cue.start, DELTA_CUES_GROUP) || areNearlyEqual(time, cue.end, DELTA_CUES_GROUP)) {
                ret.push(cue.element);
              }
            }
          }
          return ret;
        }
      }
      return [];
    }
    /**
     * Remove cue from a certain range of time.
     * @param {Number} from
     * @param {Number} _to
     */
    remove(from, _to) {
      if (define_ENVIRONMENT_default.CURRENT_ENV === define_ENVIRONMENT_default.DEV) {
        assert(from >= 0);
        assert(_to >= 0);
        assert(_to > from);
      }
      const to = Math.max(from, _to);
      const cuesBuffer = this._cuesBuffer;
      for (let cueIdx = 0; cueIdx < cuesBuffer.length; cueIdx++) {
        if (cuesBuffer[cueIdx].end > from) {
          const startCuesInfos = cuesBuffer[cueIdx];
          if (startCuesInfos.start >= to) {
            return;
          }
          if (startCuesInfos.end >= to) {
            if (from <= startCuesInfos.start) {
              startCuesInfos.cues = getCuesAfter(startCuesInfos.cues, to);
              startCuesInfos.start = to;
            } else {
              const [cuesInfos1, cuesInfos2] = removeCuesInfosBetween(
                startCuesInfos,
                from,
                to
              );
              this._cuesBuffer[cueIdx] = cuesInfos1;
              cuesBuffer.splice(cueIdx + 1, 0, cuesInfos2);
            }
            return;
          }
          if (startCuesInfos.start >= from) {
            cuesBuffer.splice(cueIdx, 1);
            cueIdx--;
          } else {
            startCuesInfos.cues = getCuesBefore(startCuesInfos.cues, from);
            startCuesInfos.end = Math.max(from, startCuesInfos.start);
          }
        }
      }
    }
    /**
     * Insert new cues in our text buffer.
     * cues is an array of objects with three properties:
     *   - start {Number}: start time for which the cue should be displayed.
     *   - end {Number}: end time for which the cue should be displayed.
     *   - element {HTMLElement}: The cue to diplay
     *
     * @param {Array.<Object>} cues - CuesGroups, array of objects with the
     * following properties:
     *   - start {Number}: the time at which the cue will start to be displayed
     *   - end {Number}: the time at which the cue will end to be displayed
     *   - cue {HTMLElement}: The cue
     * @param {Number} start - Start time at which the CuesGroup applies.
     * This is different than the start of the first cue to display in it, this
     * has more to do with the time at which the _text segment_ starts.
     * @param {Number} end - End time at which the CuesGroup applies.
     * This is different than the end of the last cue to display in it, this
     * has more to do with the time at which the _text segment_ ends.
     *
     * TODO add securities to ensure that:
     *   - the start of a CuesGroup is inferior or equal to the start of the first
     *     cue in it
     *   - the end of a CuesGroup is superior or equal to the end of the last
     *     cue in it
     * If those requirements are not met, we could delete some cues when adding
     * a CuesGroup before/after. Find a solution.
     */
    insert(cues, start, end) {
      const cuesBuffer = this._cuesBuffer;
      const cuesInfosToInsert = { start, end, cues };
      const relativeDelta = Math.abs(start - end) / RELATIVE_DELTA_RATIO;
      function onIndexOfNextCueFound(indexOfNextCue) {
        const nextCue = cuesBuffer[indexOfNextCue];
        if (nextCue === void 0 || // no cue
        areNearlyEqual(cuesInfosToInsert.end, nextCue.end, relativeDelta)) {
          cuesBuffer[indexOfNextCue] = cuesInfosToInsert;
        } else if (nextCue.start >= cuesInfosToInsert.end) {
          cuesBuffer.splice(indexOfNextCue, 0, cuesInfosToInsert);
        } else {
          nextCue.cues = getCuesAfter(nextCue.cues, cuesInfosToInsert.end);
          nextCue.start = cuesInfosToInsert.end;
          cuesBuffer.splice(indexOfNextCue, 0, cuesInfosToInsert);
        }
      }
      for (let cueIdx = 0; cueIdx < cuesBuffer.length; cueIdx++) {
        let cuesInfos = cuesBuffer[cueIdx];
        if (start < cuesInfos.end) {
          if (areCuesStartNearlyEqual(cuesInfosToInsert, cuesInfos)) {
            if (areNearlyEqual(end, cuesInfos.end, relativeDelta)) {
              cuesBuffer[cueIdx] = cuesInfosToInsert;
              return;
            } else if (end < cuesInfos.end) {
              cuesInfos.cues = getCuesAfter(cuesInfos.cues, end);
              cuesInfos.start = end;
              cuesBuffer.splice(cueIdx, 0, cuesInfosToInsert);
              return;
            }
            do {
              cuesBuffer.splice(cueIdx, 1);
              cuesInfos = cuesBuffer[cueIdx];
            } while (cuesInfos !== void 0 && end > cuesInfos.end);
            onIndexOfNextCueFound(cueIdx);
            return;
          } else if (start < cuesInfos.start) {
            if (end < cuesInfos.start) {
              cuesBuffer.splice(cueIdx, 0, cuesInfosToInsert);
              return;
            } else if (areNearlyEqual(end, cuesInfos.start, relativeDelta)) {
              cuesInfos.start = end;
              cuesBuffer.splice(cueIdx, 0, cuesInfosToInsert);
              return;
            } else if (areNearlyEqual(end, cuesInfos.end, relativeDelta)) {
              cuesBuffer.splice(cueIdx, 1, cuesInfosToInsert);
              return;
            } else if (end < cuesInfos.end) {
              cuesInfos.cues = getCuesAfter(cuesInfos.cues, end);
              cuesInfos.start = end;
              cuesBuffer.splice(cueIdx, 0, cuesInfosToInsert);
              return;
            }
            do {
              cuesBuffer.splice(cueIdx, 1);
              cuesInfos = cuesBuffer[cueIdx];
            } while (cuesInfos !== void 0 && end > cuesInfos.end);
            onIndexOfNextCueFound(cueIdx);
            return;
          }
          if (areNearlyEqual(cuesInfos.end, end, relativeDelta)) {
            cuesInfos.cues = getCuesBefore(cuesInfos.cues, start);
            cuesInfos.end = start;
            cuesBuffer.splice(cueIdx + 1, 0, cuesInfosToInsert);
            return;
          } else if (cuesInfos.end > end) {
            const [cuesInfos1, cuesInfos2] = removeCuesInfosBetween(cuesInfos, start, end);
            this._cuesBuffer[cueIdx] = cuesInfos1;
            cuesBuffer.splice(cueIdx + 1, 0, cuesInfosToInsert);
            cuesBuffer.splice(cueIdx + 2, 0, cuesInfos2);
            return;
          } else {
            cuesInfos.cues = getCuesBefore(cuesInfos.cues, start);
            cuesInfos.end = start;
            const nextCueIdx = cueIdx + 1;
            cuesInfos = cuesBuffer[nextCueIdx];
            while (cuesInfos !== void 0 && end > cuesInfos.end) {
              cuesBuffer.splice(nextCueIdx, 1);
              cuesInfos = cuesBuffer[nextCueIdx];
            }
            onIndexOfNextCueFound(nextCueIdx);
            return;
          }
        }
      }
      if (cuesBuffer.length) {
        const lastCue = cuesBuffer[cuesBuffer.length - 1];
        if (areNearlyEqual(lastCue.end, start, relativeDelta)) {
          lastCue.end = start;
        }
      }
      cuesBuffer.push(cuesInfosToInsert);
    }
  };

  // src/main_thread/text_displayer/html/update_proportional_elements.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function updateProportionalElements(currentHeight, currentWidth, resolution, textTrackElement) {
    const cellUnit = [currentWidth / resolution.columns, currentHeight / resolution.rows];
    const proportElts = textTrackElement.getElementsByClassName("proportional-style");
    for (let eltIdx = 0; eltIdx < proportElts.length; eltIdx++) {
      const elt = proportElts[eltIdx];
      if (elt instanceof HTMLElement) {
        const fontSizeVal = elt.getAttribute("data-proportional-font-size");
        if (fontSizeVal !== null && !isNaN(+fontSizeVal)) {
          elt.style.fontSize = String(+fontSizeVal * cellUnit[1]) + "px";
        }
        const widthVal = elt.getAttribute("data-proportional-width");
        if (widthVal !== null && !isNaN(+widthVal)) {
          elt.style.width = String(+widthVal * cellUnit[0]) + "px";
        }
        const heightVal = elt.getAttribute("data-proportional-height");
        if (heightVal !== null && !isNaN(+heightVal)) {
          elt.style.height = String(+heightVal * cellUnit[1]) + "px";
        }
        const lineHeightVal = elt.getAttribute("data-proportional-line-height");
        if (lineHeightVal !== null && !isNaN(+lineHeightVal)) {
          elt.style.lineHeight = String(+lineHeightVal * cellUnit[1]) + "px";
        }
        const leftVal = elt.getAttribute("data-proportional-left");
        if (leftVal !== null && !isNaN(+leftVal)) {
          elt.style.left = String(+leftVal * cellUnit[0]) + "px";
        }
        const topVal = elt.getAttribute("data-proportional-top");
        if (topVal !== null && !isNaN(+topVal)) {
          elt.style.top = String(+topVal * cellUnit[1]) + "px";
        }
        const paddingTopVal = elt.getAttribute("data-proportional-padding-top");
        if (paddingTopVal !== null && !isNaN(+paddingTopVal)) {
          elt.style.paddingTop = String(+paddingTopVal * cellUnit[1]) + "px";
        }
        const paddingBottomVal = elt.getAttribute("data-proportional-padding-bottom");
        if (paddingBottomVal !== null && !isNaN(+paddingBottomVal)) {
          elt.style.paddingBottom = String(+paddingBottomVal * cellUnit[1]) + "px";
        }
        const paddingLeftVal = elt.getAttribute("data-proportional-padding-left");
        if (paddingLeftVal !== null && !isNaN(+paddingLeftVal)) {
          elt.style.paddingLeft = String(+paddingLeftVal * cellUnit[0]) + "px";
        }
        const paddingRightVal = elt.getAttribute("data-proportional-padding-right");
        if (paddingRightVal !== null && !isNaN(+paddingRightVal)) {
          elt.style.paddingRight = String(+paddingRightVal * cellUnit[0]) + "px";
        }
      }
    }
    return proportElts.length > 0;
  }

  // src/main_thread/text_displayer/html/html_text_displayer.ts
  function safelyRemoveChild(element, child) {
    try {
      element.removeChild(child);
    } catch (_error) {
      log_default.warn("HTD: Can't remove text track: not in the element.");
    }
  }
  function getElementResolution(element) {
    const strRows = element.getAttribute("data-resolution-rows");
    const strColumns = element.getAttribute("data-resolution-columns");
    if (strRows === null || strColumns === null) {
      return null;
    }
    const rows = parseInt(strRows, 10);
    const columns = parseInt(strColumns, 10);
    if (rows === null || columns === null) {
      return null;
    }
    return { rows, columns };
  }
  var HTMLTextDisplayer = class {
    /**
     * @param {HTMLMediaElement} videoElement
     * @param {HTMLElement} textTrackElement
     */
    constructor(videoElement, textTrackElement) {
      log_default.debug("HTD: Creating HTMLTextDisplayer");
      this._buffered = new ManualTimeRanges();
      this._videoElement = videoElement;
      this._textTrackElement = textTrackElement;
      this._sizeUpdateCanceller = new TaskCanceller();
      this._subtitlesIntervalCanceller = new TaskCanceller();
      this._buffer = new TextTrackCuesStore();
      this._currentCues = [];
      this._isAutoRefreshing = false;
    }
    /**
     * Push text segment to the HTMLTextDisplayer.
     * @param {Object} infos
     * @returns {Object}
     */
    pushTextData(infos) {
      var _a, _b;
      log_default.debug("HTD: Appending new html text tracks");
      const { timestampOffset, appendWindow, chunk } = infos;
      if (chunk === null) {
        return convertToRanges(this._buffered);
      }
      const { start: startTime, end: endTime, data: dataString, type, language } = chunk;
      const appendWindowStart = (_a = appendWindow[0]) != null ? _a : 0;
      const appendWindowEnd = (_b = appendWindow[1]) != null ? _b : Infinity;
      const cues = parseTextTrackToElements(type, dataString, timestampOffset, language);
      if (appendWindowStart !== 0 && appendWindowEnd !== Infinity) {
        let i = 0;
        while (i < cues.length && cues[i].end <= appendWindowStart) {
          i++;
        }
        cues.splice(0, i);
        i = 0;
        while (i < cues.length && cues[i].start < appendWindowStart) {
          cues[i].start = appendWindowStart;
          i++;
        }
        i = cues.length - 1;
        while (i >= 0 && cues[i].start >= appendWindowEnd) {
          i--;
        }
        cues.splice(i, cues.length);
        i = cues.length - 1;
        while (i >= 0 && cues[i].end > appendWindowEnd) {
          cues[i].end = appendWindowEnd;
          i--;
        }
      }
      let start;
      if (startTime !== void 0) {
        start = Math.max(appendWindowStart, startTime);
      } else {
        if (cues.length <= 0) {
          log_default.warn("HTD: Current text tracks have no cues nor start time. Aborting");
          return convertToRanges(this._buffered);
        }
        log_default.warn("HTD: No start time given. Guessing from cues.");
        start = cues[0].start;
      }
      let end;
      if (endTime !== void 0) {
        end = Math.min(appendWindowEnd, endTime);
      } else {
        if (cues.length <= 0) {
          log_default.warn("HTD: Current text tracks have no cues nor end time. Aborting");
          return convertToRanges(this._buffered);
        }
        log_default.warn("HTD: No end time given. Guessing from cues.");
        end = cues[cues.length - 1].end;
      }
      if (end <= start) {
        log_default.warn(
          "HTD: Invalid text track appended: ",
          "the start time is inferior or equal to the end time."
        );
        return convertToRanges(this._buffered);
      }
      this._buffer.insert(cues, start, end);
      this._buffered.insert(start, end);
      if (!this._isAutoRefreshing && !this._buffer.isEmpty()) {
        this.autoRefreshSubtitles(this._subtitlesIntervalCanceller.signal);
      }
      return convertToRanges(this._buffered);
    }
    /**
     * Remove buffered data.
     * @param {number} start - start position, in seconds
     * @param {number} end - end position, in seconds
     * @returns {Object}
     */
    removeBuffer(start, end) {
      log_default.debug("HTD: Removing html text track data", start, end);
      this._buffer.remove(start, end);
      this._buffered.remove(start, end);
      if (this._isAutoRefreshing && this._buffer.isEmpty()) {
        this.refreshSubtitles();
        this._isAutoRefreshing = false;
        this._subtitlesIntervalCanceller.cancel();
        this._subtitlesIntervalCanceller = new TaskCanceller();
      }
      return convertToRanges(this._buffered);
    }
    /**
     * Returns the currently buffered data, in a TimeRanges object.
     * @returns {TimeRanges}
     */
    getBufferedRanges() {
      return convertToRanges(this._buffered);
    }
    reset() {
      log_default.debug("HTD: Resetting HTMLTextDisplayer");
      this.stop();
      this._subtitlesIntervalCanceller = new TaskCanceller();
    }
    stop() {
      if (this._subtitlesIntervalCanceller.isUsed()) {
        return;
      }
      log_default.debug("HTD: Stopping HTMLTextDisplayer");
      this._disableCurrentCues();
      this._buffer.remove(0, Infinity);
      this._buffered.remove(0, Infinity);
      this._isAutoRefreshing = false;
      this._subtitlesIntervalCanceller.cancel();
    }
    /**
     * Remove the current cue from being displayed.
     */
    _disableCurrentCues() {
      this._sizeUpdateCanceller.cancel();
      if (this._currentCues.length > 0) {
        for (const cue of this._currentCues) {
          safelyRemoveChild(this._textTrackElement, cue.element);
        }
        this._currentCues = [];
      }
    }
    /**
     * Display a new Cue. If one was already present, it will be replaced.
     * @param {HTMLElement} elements
     */
    _displayCues(elements) {
      const nothingChanged = this._currentCues.length === elements.length && this._currentCues.every((current, index) => current.element === elements[index]);
      if (nothingChanged) {
        return;
      }
      this._sizeUpdateCanceller.cancel();
      for (const cue of this._currentCues) {
        safelyRemoveChild(this._textTrackElement, cue.element);
      }
      this._currentCues = [];
      for (const element of elements) {
        const resolution = getElementResolution(element);
        this._currentCues.push({ element, resolution });
        this._textTrackElement.appendChild(element);
      }
      const proportionalCues = this._currentCues.filter(
        (cue) => cue.resolution !== null
      );
      if (proportionalCues.length > 0) {
        this._sizeUpdateCanceller = new TaskCanceller();
        this._sizeUpdateCanceller.linkToSignal(this._subtitlesIntervalCanceller.signal);
        const { TEXT_TRACK_SIZE_CHECKS_INTERVAL } = config_default.getCurrent();
        const heightWidthRef = onHeightWidthChange(
          this._textTrackElement,
          TEXT_TRACK_SIZE_CHECKS_INTERVAL,
          this._sizeUpdateCanceller.signal
        );
        heightWidthRef.onUpdate(
          ({ height, width }) => {
            for (const cue of proportionalCues) {
              const { resolution, element } = cue;
              updateProportionalElements(height, width, resolution, element);
            }
          },
          {
            clearSignal: this._sizeUpdateCanceller.signal,
            emitCurrentValue: true
          }
        );
      }
    }
    /**
     * Auto-refresh the display of subtitles according to the media element's
     * position and events.
     * @param {Object} cancellationSignal
     */
    autoRefreshSubtitles(cancellationSignal) {
      if (this._isAutoRefreshing || cancellationSignal.isCancelled()) {
        return;
      }
      let autoRefreshCanceller = null;
      const { MAXIMUM_HTML_TEXT_TRACK_UPDATE_INTERVAL } = config_default.getCurrent();
      const stopAutoRefresh = () => {
        this._isAutoRefreshing = false;
        if (autoRefreshCanceller !== null) {
          autoRefreshCanceller.cancel();
          autoRefreshCanceller = null;
        }
      };
      const startAutoRefresh = () => {
        stopAutoRefresh();
        this._isAutoRefreshing = true;
        autoRefreshCanceller = new TaskCanceller();
        autoRefreshCanceller.linkToSignal(cancellationSignal);
        const intervalId = setInterval(
          () => this.refreshSubtitles(),
          MAXIMUM_HTML_TEXT_TRACK_UPDATE_INTERVAL
        );
        autoRefreshCanceller.signal.register(() => {
          clearInterval(intervalId);
        });
        this.refreshSubtitles();
      };
      onSeeking(
        this._videoElement,
        () => {
          stopAutoRefresh();
          this._disableCurrentCues();
        },
        cancellationSignal
      );
      onSeeked(this._videoElement, startAutoRefresh, cancellationSignal);
      onEnded(this._videoElement, startAutoRefresh, cancellationSignal);
      startAutoRefresh();
    }
    /**
     * Refresh current subtitles according to the current media element's
     * position.
     */
    refreshSubtitles() {
      const { MAXIMUM_HTML_TEXT_TRACK_UPDATE_INTERVAL } = config_default.getCurrent();
      let time;
      if (this._videoElement.paused || this._videoElement.playbackRate <= 0) {
        time = this._videoElement.currentTime;
      } else {
        time = Math.max(
          this._videoElement.currentTime + MAXIMUM_HTML_TEXT_TRACK_UPDATE_INTERVAL / 1e3 / 2,
          0
        );
      }
      const cues = this._buffer.get(time);
      if (cues.length === 0) {
        this._disableCurrentCues();
      } else {
        this._displayCues(cues);
      }
    }
  };
  if (define_ENVIRONMENT_default.CURRENT_ENV === define_ENVIRONMENT_default.DEV) {
    let _checkType = function(input) {
      function checkEqual(_arg) {
      }
      checkEqual(input);
    };
    _checkType2 = _checkType;
  }
  var _checkType2;

  // src/main_thread/text_displayer/html/index.ts
  var html_default = HTMLTextDisplayer;

  // src/parsers/texttracks/sami/html.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var HTML_ENTITIES = /&#([0-9]+);/g;
  var BR = /<br>/gi;
  var STYLE = /<style[^>]*>([\s\S]*?)<\/style[^>]*>/i;
  var PARAG = /\s*<p (?:class=([^>]+))?>(.*)/i;
  var START = /<sync[^>]+?start="?([0-9]*)"?[^0-9]/i;
  function getClassNameByLang(str) {
    const ruleRe = /\.(\S+)\s*{([^}]*)}/gi;
    const langs = {};
    let m = ruleRe.exec(str);
    while (m !== null) {
      const name2 = m[1];
      const lang = getCSSProperty(m[2], "lang");
      if (!isNullOrUndefined(name2) && !isNullOrUndefined(lang)) {
        langs[lang] = name2;
      }
      m = ruleRe.exec(str);
    }
    return langs;
  }
  function getPCSSRules(str) {
    const pRuleRegex = /p\s*{([^}]*)}/gi;
    const rule = pRuleRegex.exec(str);
    if (rule === null) {
      return "";
    }
    return rule[1];
  }
  function getCSSProperty(str, name2) {
    const matches = new RegExp("\\s*" + name2 + ":\\s*(\\S+);", "i").exec(str);
    return Array.isArray(matches) ? matches[1] : null;
  }
  function decodeEntities(text) {
    return text.replace(HTML_ENTITIES, (_, $1) => String.fromCharCode(Number($1)));
  }
  function parseSami(smi, timeOffset, lang) {
    const syncOpen = /<sync[ >]/gi;
    const syncClose = /<sync[ >]|<\/body>/gi;
    const subs = [];
    const styleMatches = STYLE.exec(smi);
    const css = Array.isArray(styleMatches) ? styleMatches[1] : "";
    let up;
    let to;
    syncClose.exec(smi);
    const langs = getClassNameByLang(css);
    const pCSS = getPCSSRules(css);
    let klass;
    if (isNonEmptyString(lang)) {
      klass = langs[lang];
      if (klass === void 0) {
        throw new Error(`sami: could not find lang ${lang} in CSS`);
      }
    }
    while (true) {
      up = syncOpen.exec(smi);
      to = syncClose.exec(smi);
      if (up === null && to === null) {
        break;
      }
      if (up === null || to === null || up.index >= to.index) {
        throw new Error("parse error");
      }
      const str = smi.slice(up.index, to.index);
      const tim = START.exec(str);
      if (!Array.isArray(tim)) {
        throw new Error("parse error (sync time attribute)");
      }
      const start = +tim[1];
      if (isNaN(start)) {
        throw new Error("parse error (sync time attribute NaN)");
      }
      appendToSubs(str.split("\n"), start / 1e3);
    }
    return subs;
    function appendToSubs(lines, start) {
      let i = lines.length;
      while (--i >= 0) {
        const paragraphInfos = PARAG.exec(lines[i]);
        if (!Array.isArray(paragraphInfos)) {
          continue;
        }
        const [, className, txt] = paragraphInfos;
        if (klass !== className) {
          continue;
        }
        if (txt === "&nbsp;") {
          subs[subs.length - 1].end = start;
        } else {
          const wrapperEl = document.createElement("DIV");
          wrapperEl.className = "rxp-texttrack-region";
          const divEl = document.createElement("DIV");
          divEl.className = "rxp-texttrack-div";
          divEl.style.position = "absolute";
          divEl.style.bottom = "0";
          divEl.style.width = "100%";
          divEl.style.color = "#fff";
          divEl.style.textShadow = "-1px -1px 0 #000,1px -1px 0 #000,-1px 1px 0 #000,1px 1px 0 #000";
          const pEl = document.createElement("div");
          pEl.className = "rxp-texttrack-p";
          if (isNonEmptyString(pCSS)) {
            pEl.style.cssText = pCSS;
          }
          const textEls = txt.split(BR);
          for (let j = 0; j < textEls.length; j++) {
            if (j !== 0) {
              pEl.appendChild(document.createElement("BR"));
            }
            const spanEl = document.createElement("SPAN");
            spanEl.className = "rxp-texttrack-span";
            spanEl.textContent = decodeEntities(textEls[j]);
            pEl.appendChild(spanEl);
          }
          divEl.appendChild(pEl);
          wrapperEl.appendChild(divEl);
          subs.push({
            element: wrapperEl,
            start: start + timeOffset,
            end: -1
          });
        }
      }
    }
  }
  var html_default2 = parseSami;

  // src/features/list/html_sami_parser.ts
  function addHTMLSAMIFeature(features2) {
    features2.htmlTextTracksParsers.sami = html_default2;
    features2.htmlTextDisplayer = html_default;
  }

  // src/features/list/html_srt_parser.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/parsers/texttracks/srt/html.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/parsers/texttracks/srt/get_cue_blocks.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/parsers/texttracks/srt/find_end_of_cue_block.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function findEndOfCueBlock(linified, startIndex) {
    let firstEmptyLineIndex = startIndex + 1;
    while (isNonEmptyString(linified[firstEmptyLineIndex])) {
      firstEmptyLineIndex++;
    }
    return firstEmptyLineIndex;
  }

  // src/parsers/texttracks/srt/get_cue_blocks.ts
  function getCueBlocks(linified) {
    const cueBlocks = [];
    for (let i = 0; i < linified.length; i++) {
      if (isNonEmptyString(linified[i])) {
        const endOfCue = findEndOfCueBlock(linified, i);
        const cueBlockCandidate = linified.slice(i, endOfCue);
        if (cueBlockCandidate.length > 0) {
          if (cueBlockCandidate.length === 1) {
            if (cueBlockCandidate[0].indexOf("-->") >= 0) {
              cueBlocks.push(cueBlockCandidate);
            }
          } else {
            if (cueBlockCandidate[1].indexOf("-->") >= 0 || cueBlockCandidate[0].indexOf("-->") >= 0) {
              cueBlocks.push(cueBlockCandidate);
            }
          }
        }
        i = endOfCue;
      }
    }
    return cueBlocks;
  }

  // src/parsers/texttracks/srt/parse_cue.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/parsers/texttracks/srt/parse_timestamp.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function parseTimestamp(timestampString) {
    const splittedTS = timestampString.split(":");
    if (isNonEmptyString(splittedTS[2])) {
      const hours = parseInt(splittedTS[0], 10);
      const minutes = parseInt(splittedTS[1], 10);
      const seconds = parseFloat(splittedTS[2].replace(",", "."));
      if (isNaN(hours) || isNaN(minutes) || isNaN(seconds)) {
        return void 0;
      }
      return hours * 60 * 60 + minutes * 60 + seconds;
    }
  }

  // src/parsers/texttracks/srt/parse_cue.ts
  function parseCueBlock(cueLines, timeOffset) {
    if (cueLines.length === 0) {
      return null;
    }
    let startTimeString;
    let endTimeString;
    let payload = [];
    if (isNonEmptyString(cueLines[1]) && cueLines[1].indexOf("-->") !== -1) {
      [startTimeString, endTimeString] = cueLines[1].split("-->").map((s) => s.trim());
      payload = cueLines.slice(2, cueLines.length);
    }
    if (!isNonEmptyString(startTimeString) || !isNonEmptyString(endTimeString)) {
      [startTimeString, endTimeString] = cueLines[0].split("-->").map((s) => s.trim());
      payload = cueLines.slice(1, cueLines.length);
    }
    if (!isNonEmptyString(startTimeString) || !isNonEmptyString(endTimeString)) {
      return null;
    }
    const start = parseTimestamp(startTimeString);
    const end = parseTimestamp(endTimeString);
    if (start === void 0 || end === void 0) {
      return null;
    }
    return { start: start + timeOffset, end: end + timeOffset, payload };
  }

  // src/parsers/texttracks/srt/html.ts
  function parseSRTStringToHTML(srtStr, timeOffset) {
    const lines = srtStr.split(/\r\n|\n|\r/);
    const cueBlocks = getCueBlocks(lines);
    const cues = [];
    for (const cueBlock of cueBlocks) {
      const cueObject = parseCueBlock(cueBlock, timeOffset);
      if (cueObject !== null) {
        const htmlCue = toHTML(cueObject);
        if (htmlCue !== null) {
          cues.push(htmlCue);
        }
      }
    }
    return cues;
  }
  function toHTML(cueObj) {
    const { start, end, payload } = cueObj;
    const pEl = document.createElement("div");
    pEl.className = "rxp-texttrack-p";
    pEl.style.fontSize = "28px";
    pEl.style.position = "absolute";
    pEl.style.bottom = "5%";
    pEl.style.width = "100%";
    pEl.style.textAlign = "center";
    pEl.style.color = "#fff";
    pEl.style.textShadow = "-1px -1px 2px #000,1px -1px 2px #000,-1px 1px 2px #000,1px 1px 2px #000";
    for (let i = 0; i < payload.length; i++) {
      if (i !== 0) {
        pEl.appendChild(document.createElement("br"));
      }
      const span = generateSpansFromSRTText(payload[i]);
      pEl.appendChild(span);
    }
    return {
      start,
      end,
      element: pEl
    };
  }
  function generateSpansFromSRTText(text) {
    const secureDiv = document.createElement("div");
    secureDiv.innerHTML = text;
    const _loop = function(node) {
      const childNodes = node.childNodes;
      const span = document.createElement("span");
      span.className = "rxp-texttrack-span";
      for (let i = 0; i < childNodes.length; i++) {
        const currentNode = childNodes[i];
        if (currentNode.nodeName === "#text") {
          const linifiedText = currentNode.wholeText.split("\n");
          for (let line = 0; line < linifiedText.length; line++) {
            if (line !== 0) {
              span.appendChild(document.createElement("br"));
            }
            if (linifiedText[line].length > 0) {
              const textNode = document.createTextNode(linifiedText[line]);
              span.appendChild(textNode);
            }
          }
        } else if (currentNode.nodeName === "B") {
          const spanChild = _loop(currentNode);
          spanChild.style.fontWeight = "bold";
          span.appendChild(spanChild);
        } else if (currentNode.nodeName === "I") {
          const spanChild = _loop(currentNode);
          spanChild.style.fontStyle = "italic";
          span.appendChild(spanChild);
        } else if (currentNode.nodeName === "U") {
          const spanChild = _loop(currentNode);
          spanChild.style.textDecoration = "underline";
          span.appendChild(spanChild);
        } else if (isNodeFontWithColorProp(currentNode) && typeof currentNode.color === "string") {
          const spanChild = _loop(currentNode);
          spanChild.style.color = currentNode.color;
          span.appendChild(spanChild);
        } else {
          const spanChild = _loop(currentNode);
          span.appendChild(spanChild);
        }
      }
      return span;
    };
    return _loop(secureDiv);
  }
  function isNodeFontWithColorProp(node) {
    return node.nodeName === "FONT" && "color" in node;
  }

  // src/features/list/html_srt_parser.ts
  function addHTMLSRTFeature(features2) {
    features2.htmlTextTracksParsers.srt = parseSRTStringToHTML;
    features2.htmlTextDisplayer = html_default;
  }

  // src/features/list/html_text_buffer.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function addHTMLTextBuffer(features2) {
    features2.htmlTextDisplayer = html_default;
  }

  // src/features/list/html_ttml_parser.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/parsers/texttracks/ttml/html/index.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/parsers/texttracks/ttml/html/parse_ttml_to_div.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/parsers/texttracks/ttml/parse_ttml.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/parsers/texttracks/ttml/get_parameters.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var CELL_RESOLUTION_REGEXP = /(\d+) (\d+)/;
  function getParameters(tt) {
    const parsedFrameRate = tt.getAttribute("ttp:frameRate");
    const parsedSubFrameRate = tt.getAttribute("ttp:subFramRate");
    const parsedTickRate = tt.getAttribute("ttp:tickRate");
    const parsedFrameRateMultiplier = tt.getAttribute("ttp:frameRateMultiplier");
    const parsedSpaceStyle = tt.getAttribute("xml:space");
    const parsedCellResolution = tt.getAttribute("ttp:cellResolution");
    let cellResolution = {
      columns: 32,
      rows: 15
    };
    if (parsedCellResolution !== null) {
      const extractedData = CELL_RESOLUTION_REGEXP.exec(parsedCellResolution);
      if (extractedData === null || extractedData.length < 3) {
        log_default.warn("TTML Parser: Invalid cellResolution");
      } else {
        const columns = parseInt(extractedData[1], 10);
        const rows = parseInt(extractedData[2], 10);
        if (isNaN(columns) || isNaN(rows)) {
          log_default.warn("TTML Parser: Invalid cellResolution");
        } else {
          cellResolution = { columns, rows };
        }
      }
    }
    if (isNonEmptyString(parsedSpaceStyle) && parsedSpaceStyle !== "default" && parsedSpaceStyle !== "preserve") {
      throw new Error("Invalid spacing style");
    }
    let nbFrameRate = Number(parsedFrameRate);
    if (isNaN(nbFrameRate) || nbFrameRate <= 0) {
      nbFrameRate = 30;
    }
    let nbSubFrameRate = Number(parsedSubFrameRate);
    if (isNaN(nbSubFrameRate) || nbSubFrameRate <= 0) {
      nbSubFrameRate = 1;
    }
    let nbTickRate = Number(parsedTickRate);
    if (isNaN(nbTickRate) || nbTickRate <= 0) {
      nbTickRate = void 0;
    }
    let frameRate = nbFrameRate;
    const subFrameRate = nbSubFrameRate != null ? nbSubFrameRate : 1;
    const spaceStyle = parsedSpaceStyle != null ? parsedSpaceStyle : "default";
    const tickRate = nbTickRate != null ? nbTickRate : nbFrameRate * nbSubFrameRate;
    if (parsedFrameRateMultiplier !== null) {
      const multiplierResults = /^(\d+) (\d+)$/g.exec(parsedFrameRateMultiplier);
      if (multiplierResults !== null) {
        const numerator = Number(multiplierResults[1]);
        const denominator = Number(multiplierResults[2]);
        const multiplierNum = numerator / denominator;
        frameRate = nbFrameRate * multiplierNum;
      }
    }
    return { cellResolution, tickRate, frameRate, subFrameRate, spaceStyle };
  }

  // src/parsers/texttracks/ttml/get_styling.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function getStylingAttributes(attributes, nodes, styles, regions) {
    const currentStyle = {};
    const leftAttributes = attributes.slice();
    for (let i = 0; i <= nodes.length - 1; i++) {
      const node = nodes[i];
      if (node !== void 0) {
        let styleID;
        let regionID;
        if (node.nodeType === Node.ELEMENT_NODE) {
          const element = node;
          for (let j = 0; j <= element.attributes.length - 1; j++) {
            const attribute = element.attributes[j];
            const name2 = attribute.name;
            if (name2 === "style") {
              styleID = attribute.value;
            } else if (name2 === "region") {
              regionID = attribute.value;
            } else {
              const nameWithoutTTS = name2.substring(4);
              if (arrayIncludes(leftAttributes, nameWithoutTTS)) {
                currentStyle[nameWithoutTTS] = attribute.value;
                leftAttributes.splice(j, 1);
                if (leftAttributes.length === 0) {
                  return currentStyle;
                }
              }
            }
          }
        }
        if (isNonEmptyString(styleID)) {
          const style = arrayFind(styles, (x) => x.id === styleID);
          if (style !== void 0) {
            for (let j = 0; j <= leftAttributes.length - 1; j++) {
              const attribute = leftAttributes[j];
              if (!isNonEmptyString(currentStyle[attribute])) {
                if (isNonEmptyString(style.style[attribute])) {
                  currentStyle[attribute] = style.style[attribute];
                  leftAttributes.splice(j, 1);
                  if (leftAttributes.length === 0) {
                    return currentStyle;
                  }
                  j--;
                }
              }
            }
          }
        }
        if (isNonEmptyString(regionID)) {
          const region = arrayFind(regions, (x) => x.id === regionID);
          if (region !== void 0) {
            for (let j = 0; j <= leftAttributes.length - 1; j++) {
              const attribute = leftAttributes[j];
              if (!isNonEmptyString(currentStyle[attribute])) {
                if (isNonEmptyString(region.style[attribute])) {
                  currentStyle[attribute] = region.style[attribute];
                  leftAttributes.splice(j, 1);
                  if (leftAttributes.length === 0) {
                    return currentStyle;
                  }
                  j--;
                }
              }
            }
          }
        }
      }
    }
    return currentStyle;
  }
  function getStylingFromElement(node) {
    if (node.nodeType !== Node.ELEMENT_NODE) {
      return {};
    }
    const element = node;
    const currentStyle = {};
    for (let i = 0; i <= element.attributes.length - 1; i++) {
      const styleAttribute = element.attributes[i];
      if (startsWith(styleAttribute.name, "tts")) {
        const nameWithoutTTS = styleAttribute.name.substring(4);
        currentStyle[nameWithoutTTS] = styleAttribute.value;
      }
    }
    return currentStyle;
  }

  // src/parsers/texttracks/ttml/resolve_styles_inheritance.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function resolveStylesInheritance(styles) {
    const recursivelyBrowsedIndexes = [];
    function resolveStyleInheritance(styleElt, index) {
      recursivelyBrowsedIndexes.push(index);
      for (const extendedStyleID of styleElt.extendsStyles) {
        const extendedStyleIndex = arrayFindIndex(styles, (x) => x.id === extendedStyleID);
        if (extendedStyleIndex < 0) {
          log_default.warn("TTML Parser: unknown style inheritance: " + extendedStyleID);
        } else {
          const extendedStyle = styles[extendedStyleIndex];
          if (arrayIncludes(recursivelyBrowsedIndexes, extendedStyleIndex)) {
            log_default.warn("TTML Parser: infinite style inheritance loop avoided");
          } else {
            resolveStyleInheritance(extendedStyle, extendedStyleIndex);
          }
          styleElt.style = object_assign_default({}, extendedStyle.style, styleElt.style);
        }
      }
      styleElt.extendsStyles.length = 0;
    }
    for (let i = 0; i < styles.length; i++) {
      resolveStyleInheritance(styles[i], i);
      recursivelyBrowsedIndexes.length = 0;
    }
  }

  // src/parsers/texttracks/ttml/xml_utils.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function getParentElementsByTagName(element, tagName) {
    if (!(element.parentNode instanceof Element)) {
      return [];
    }
    function constructArray(_element) {
      const elements = [];
      if (_element.tagName.toLowerCase() === tagName.toLowerCase()) {
        elements.push(_element);
      }
      const parentNode = _element.parentNode;
      if (parentNode instanceof Element) {
        elements.push(...constructArray(parentNode));
      }
      return elements;
    }
    return constructArray(element.parentNode);
  }
  function getParentDivElements(element) {
    let divs = getParentElementsByTagName(element, "div");
    if (divs.length === 0) {
      const ttDivs = getParentElementsByTagName(element, "tt:div");
      if (ttDivs.length > 0) {
        divs = ttDivs;
      }
    }
    return divs;
  }
  function getBodyNode(tt) {
    const bodyNodes = tt.getElementsByTagName("body");
    if (bodyNodes.length > 0) {
      return bodyNodes[0];
    }
    const namespacedBodyNodes = tt.getElementsByTagName("tt:body");
    if (namespacedBodyNodes.length > 0) {
      return namespacedBodyNodes[0];
    }
    return null;
  }
  function getStyleNodes(tt) {
    const styleNodes = tt.getElementsByTagName("style");
    if (styleNodes.length > 0) {
      return styleNodes;
    }
    const namespacedStyleNodes = tt.getElementsByTagName("tt:style");
    if (namespacedStyleNodes.length > 0) {
      return namespacedStyleNodes;
    }
    return styleNodes;
  }
  function getRegionNodes(tt) {
    const regionNodes = tt.getElementsByTagName("region");
    if (regionNodes.length > 0) {
      return regionNodes;
    }
    const namespacedRegionNodes = tt.getElementsByTagName("tt:region");
    if (namespacedRegionNodes.length > 0) {
      return namespacedRegionNodes;
    }
    return regionNodes;
  }
  function getTextNodes(tt) {
    const pNodes = tt.getElementsByTagName("p");
    if (pNodes.length > 0) {
      return pNodes;
    }
    const namespacedPNodes = tt.getElementsByTagName("tt:p");
    if (namespacedPNodes.length > 0) {
      return namespacedPNodes;
    }
    return pNodes;
  }
  function isLineBreakElement(node) {
    return node.nodeName === "br" || node.nodeName === "tt:br";
  }
  function isSpanElement(node) {
    return node.nodeName === "span" || node.nodeName === "tt:span";
  }

  // src/parsers/texttracks/ttml/parse_ttml.ts
  var STYLE_ATTRIBUTES = [
    "align",
    "backgroundColor",
    "color",
    "direction",
    "display",
    "displayAlign",
    "extent",
    "fontFamily",
    "fontSize",
    "fontStyle",
    "fontWeight",
    "lineHeight",
    "opacity",
    "origin",
    "overflow",
    "padding",
    "textAlign",
    "textDecoration",
    "textOutline",
    "unicodeBidi",
    "visibility",
    "wrapOption",
    "writingMode"
    // Not managed anywhere for now
    // "showBackground",
    // "zIndex",
  ];
  function parseTTMLString(str, timeOffset) {
    const cues = [];
    const xml = new DOMParser().parseFromString(str, "text/xml");
    if (xml !== null && xml !== void 0) {
      const tts = xml.getElementsByTagName("tt");
      let tt = tts[0];
      if (tt === void 0) {
        const namespacedTT = xml.getElementsByTagNameNS("*", "tt");
        tt = namespacedTT[0];
        if (tt === void 0) {
          throw new Error("invalid XML");
        }
      }
      const body = getBodyNode(tt);
      const styleNodes = getStyleNodes(tt);
      const regionNodes = getRegionNodes(tt);
      const paragraphNodes = getTextNodes(tt);
      const ttParams = getParameters(tt);
      const idStyles = [];
      for (let i = 0; i <= styleNodes.length - 1; i++) {
        const styleNode = styleNodes[i];
        if (styleNode instanceof Element) {
          const styleID = styleNode.getAttribute("xml:id");
          if (styleID !== null) {
            const subStyles = styleNode.getAttribute("style");
            const extendsStyles = subStyles === null ? [] : subStyles.split(" ");
            idStyles.push({
              id: styleID,
              style: getStylingFromElement(styleNode),
              extendsStyles
            });
          }
        }
      }
      resolveStylesInheritance(idStyles);
      const regionStyles = [];
      for (let i = 0; i <= regionNodes.length - 1; i++) {
        const regionNode = regionNodes[i];
        if (regionNode instanceof Element) {
          const regionID = regionNode.getAttribute("xml:id");
          if (regionID !== null) {
            let regionStyle = getStylingFromElement(regionNode);
            const associatedStyleID = regionNode.getAttribute("style");
            if (isNonEmptyString(associatedStyleID)) {
              const style = arrayFind(idStyles, (x) => x.id === associatedStyleID);
              if (style !== void 0) {
                regionStyle = object_assign_default({}, style.style, regionStyle);
              }
            }
            regionStyles.push({
              id: regionID,
              style: regionStyle,
              // already handled
              extendsStyles: []
            });
          }
        }
      }
      const bodyStyle = getStylingAttributes(
        STYLE_ATTRIBUTES,
        body !== null ? [body] : [],
        idStyles,
        regionStyles
      );
      const bodySpaceAttribute = body !== null ? body.getAttribute("xml:space") : void 0;
      const shouldTrimWhiteSpaceOnBody = bodySpaceAttribute === "default" || ttParams.spaceStyle === "default";
      for (let i = 0; i < paragraphNodes.length; i++) {
        const paragraph = paragraphNodes[i];
        if (paragraph instanceof Element) {
          const divs = getParentDivElements(paragraph);
          const paragraphStyle = object_assign_default(
            {},
            bodyStyle,
            getStylingAttributes(
              STYLE_ATTRIBUTES,
              [paragraph, ...divs],
              idStyles,
              regionStyles
            )
          );
          const paragraphSpaceAttribute = paragraph.getAttribute("xml:space");
          const shouldTrimWhiteSpace = isNonEmptyString(paragraphSpaceAttribute) ? paragraphSpaceAttribute === "default" : shouldTrimWhiteSpaceOnBody;
          const cue = {
            paragraph,
            timeOffset,
            idStyles,
            regionStyles,
            body,
            paragraphStyle,
            ttParams,
            shouldTrimWhiteSpace
          };
          if (cue !== null) {
            cues.push(cue);
          }
        }
      }
    }
    return cues;
  }

  // src/parsers/texttracks/ttml/html/apply_default_ttml_paragraph_style.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function shouldApplyDefaultTTMLStyle(paragraphStyle) {
    return paragraphStyle.extent === void 0 && paragraphStyle.origin === void 0 && paragraphStyle.displayAlign === void 0 && paragraphStyle.display === void 0 && paragraphStyle.textAlign === void 0 && paragraphStyle.fontSize === void 0;
  }
  function applyDefaultTTMLStyle(paragraphStyle) {
    paragraphStyle.extent = "70% 20%";
    paragraphStyle.fontSize = "1c";
    paragraphStyle.origin = "15% 80%";
    paragraphStyle.displayAlign = "before";
    paragraphStyle.textAlign = "center";
  }

  // src/parsers/texttracks/ttml/html/parse_cue.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/parsers/texttracks/ttml/get_time_delimiters.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/parsers/texttracks/ttml/time_parsing.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/parsers/texttracks/ttml/regexps.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var REGXP_TIME_COLON_FRAMES = /^(\d{2,}):(\d{2}):(\d{2}):(\d{2})\.?(\d+)?$/;
  var REGXP_TIME_COLON = /^(?:(\d{2,}):)?(\d{2}):(\d{2})$/;
  var REGXP_TIME_COLON_MS = /^(?:(\d{2,}):)?(\d{2}):(\d{2}\.\d{2,})$/;
  var REGXP_TIME_FRAMES = /^(\d*\.?\d*)f$/;
  var REGXP_TIME_TICK = /^(\d*\.?\d*)t$/;
  var REGXP_TIME_HMS = /^(?:(\d*\.?\d*)h)?(?:(\d*\.?\d*)m)?(?:(\d*\.?\d*)s)?(?:(\d*\.?\d*)ms)?$/;
  var REGXP_LENGTH = /^((?:\+|\-)?\d*(?:\.\d+)?)(px|em|c|%|rh|rw)$/;
  var REGXP_8_HEX_COLOR = /^#([0-9A-f]{2})([0-9A-f]{2})([0-9A-f]{2})([0-9A-f]{2})$/;
  var REGXP_4_HEX_COLOR = /^#([0-9A-f])([0-9A-f])([0-9A-f])([0-9A-f])$/;
  var REGXP_RGB_COLOR = /^rgb\( *(\d+) *, *(\d+) *, *(\d+) *\)/;
  var REGXP_RGBA_COLOR = /^rgba\( *(\d+) *, *(\d+) *, *(\d+) *, *(\d+) *\)/;

  // src/parsers/texttracks/ttml/time_parsing.ts
  function parseTime(text, ttParams) {
    if (REGXP_TIME_COLON_FRAMES.test(text)) {
      return parseColonTimeWithFrames(ttParams, text);
    } else if (REGXP_TIME_COLON.test(text)) {
      return parseTimeFromRegExp(REGXP_TIME_COLON, text);
    } else if (REGXP_TIME_COLON_MS.test(text)) {
      return parseTimeFromRegExp(REGXP_TIME_COLON_MS, text);
    } else if (REGXP_TIME_FRAMES.test(text)) {
      return parseFramesTime(ttParams, text);
    } else if (REGXP_TIME_TICK.test(text)) {
      return parseTickTime(ttParams, text);
    } else if (REGXP_TIME_HMS.test(text)) {
      return parseTimeFromRegExp(REGXP_TIME_HMS, text);
    }
  }
  function parseFramesTime(ttParams, text) {
    const results = REGXP_TIME_FRAMES.exec(text);
    const frames = Number(results[1]);
    return frames / ttParams.frameRate;
  }
  function parseTickTime(ttParams, text) {
    const results = REGXP_TIME_TICK.exec(text);
    const ticks = Number(results[1]);
    return ticks / ttParams.tickRate;
  }
  function parseColonTimeWithFrames(ttParams, text) {
    const results = REGXP_TIME_COLON_FRAMES.exec(text);
    const hours = Number(results[1]);
    const minutes = Number(results[2]);
    let seconds = Number(results[3]);
    let frames = Number(results[4]);
    let subframes = Number(results[5]);
    if (isNaN(subframes)) {
      subframes = 0;
    }
    frames += subframes / ttParams.subFrameRate;
    seconds += frames / ttParams.frameRate;
    return seconds + minutes * 60 + hours * 3600;
  }
  function parseTimeFromRegExp(regex, text) {
    const results = regex.exec(text);
    if (results === null || results[0] === "") {
      return null;
    }
    let hours = Number(results[1]);
    if (isNaN(hours)) {
      hours = 0;
    }
    let minutes = Number(results[2]);
    if (isNaN(minutes)) {
      minutes = 0;
    }
    let seconds = Number(results[3]);
    if (isNaN(seconds)) {
      seconds = 0;
    }
    let milliseconds = Number(results[4]);
    if (isNaN(milliseconds)) {
      milliseconds = 0;
    }
    return milliseconds / 1e3 + seconds + minutes * 60 + hours * 3600;
  }
  var time_parsing_default = parseTime;

  // src/parsers/texttracks/ttml/get_time_delimiters.ts
  function getTimeDelimiters(element, ttParams) {
    const beginAttr = element.getAttribute("begin");
    const durationAttr = element.getAttribute("dur");
    const endAttr = element.getAttribute("end");
    const start = isNonEmptyString(beginAttr) ? time_parsing_default(beginAttr, ttParams) : null;
    const duration = isNonEmptyString(durationAttr) ? time_parsing_default(durationAttr, ttParams) : null;
    const parsedEnd = isNonEmptyString(endAttr) ? time_parsing_default(endAttr, ttParams) : null;
    if (isNullOrUndefined(start) || isNullOrUndefined(parsedEnd) && isNullOrUndefined(duration)) {
      throw new Error("Invalid text cue");
    }
    const end = isNullOrUndefined(parsedEnd) ? start + duration : parsedEnd;
    return { start, end };
  }

  // src/parsers/texttracks/ttml/html/create_element.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/compat/add_class_name.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var hasClassList;
  function addClassName(elt, className) {
    if (hasClassList === void 0) {
      hasClassList = elt.classList !== void 0 && // eslint-disable-next-line @typescript-eslint/unbound-method
      typeof elt.classList.add === "function";
    }
    if (hasClassList) {
      elt.classList.add(className);
    } else {
      const classNamesWithSpaces = " " + elt.className + " ";
      if (classNamesWithSpaces.indexOf(" " + className + " ") < 0) {
        elt.className += " " + className;
      }
    }
  }

  // src/parsers/texttracks/ttml/html/apply_extent.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function applyExtent(element, extent) {
    const trimmedExtent = extent.trim();
    if (trimmedExtent === "auto") {
      return;
    }
    const splittedExtent = trimmedExtent.split(" ");
    if (splittedExtent.length !== 2) {
      return;
    }
    const firstExtent = REGXP_LENGTH.exec(splittedExtent[0]);
    const secondExtent = REGXP_LENGTH.exec(splittedExtent[1]);
    if (firstExtent !== null && secondExtent !== null) {
      if (firstExtent[2] === "px" || firstExtent[2] === "%" || firstExtent[2] === "em") {
        element.style.width = firstExtent[1] + firstExtent[2];
      } else if (firstExtent[2] === "c") {
        addClassName(element, "proportional-style");
        element.setAttribute("data-proportional-width", firstExtent[1]);
      } else {
        log_default.warn("TTML Parser: unhandled extent unit:", firstExtent[2]);
      }
      if (secondExtent[2] === "px" || secondExtent[2] === "%" || secondExtent[2] === "em") {
        element.style.height = secondExtent[1] + secondExtent[2];
      } else if (secondExtent[2] === "c") {
        addClassName(element, "proportional-style");
        element.setAttribute("data-proportional-height", secondExtent[1]);
      } else {
        log_default.warn("TTML Parser: unhandled extent unit:", secondExtent[2]);
      }
    }
  }

  // src/parsers/texttracks/ttml/html/apply_font_size.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function applyFontSize(element, fontSize) {
    const trimmedFontSize = fontSize.trim();
    const splittedFontSize = trimmedFontSize.split(" ");
    if (splittedFontSize.length === 0) {
      return;
    }
    const firstFontSize = REGXP_LENGTH.exec(splittedFontSize[0]);
    if (firstFontSize === null) {
      return;
    }
    if (firstFontSize[2] === "px" || firstFontSize[2] === "em") {
      element.style.fontSize = firstFontSize[1] + firstFontSize[2];
    } else if (firstFontSize[2] === "c") {
      element.style.position = "relative";
      addClassName(element, "proportional-style");
      element.setAttribute("data-proportional-font-size", firstFontSize[1]);
    } else if (firstFontSize[2] === "%") {
      const toNum = Number(firstFontSize[1]);
      if (isNaN(toNum)) {
        log_default.warn(
          'TTML Parser: could not parse fontSize value "' + firstFontSize[1] + '" into a number'
        );
      } else {
        element.style.position = "relative";
        addClassName(element, "proportional-style");
        element.setAttribute("data-proportional-font-size", String(toNum / 100));
      }
    } else {
      log_default.warn("TTML Parser: unhandled fontSize unit:", firstFontSize[2]);
    }
  }

  // src/parsers/texttracks/ttml/html/apply_line_height.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function applyLineHeight(element, lineHeight) {
    const trimmedLineHeight = lineHeight.trim();
    const splittedLineHeight = trimmedLineHeight.split(" ");
    if (trimmedLineHeight === "auto") {
      return;
    }
    const firstLineHeight = REGXP_LENGTH.exec(splittedLineHeight[0]);
    if (firstLineHeight === null) {
      return;
    }
    if (firstLineHeight[2] === "px" || firstLineHeight[2] === "%" || firstLineHeight[2] === "em") {
      element.style.lineHeight = firstLineHeight[1] + firstLineHeight[2];
    } else if (firstLineHeight[2] === "c") {
      addClassName(element, "proportional-style");
      element.setAttribute("data-proportional-line-height", firstLineHeight[1]);
    } else {
      log_default.warn("TTML Parser: unhandled lineHeight unit:", firstLineHeight[2]);
    }
  }

  // src/parsers/texttracks/ttml/html/apply_origin.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function applyOrigin(element, origin) {
    const trimmedOrigin = origin.trim();
    if (trimmedOrigin === "auto") {
      return;
    }
    const splittedOrigin = trimmedOrigin.split(" ");
    if (splittedOrigin.length !== 2) {
      return;
    }
    const firstOrigin = REGXP_LENGTH.exec(splittedOrigin[0]);
    const secondOrigin = REGXP_LENGTH.exec(splittedOrigin[1]);
    if (firstOrigin !== null && secondOrigin !== null) {
      if (firstOrigin[2] === "px" || firstOrigin[2] === "%" || firstOrigin[2] === "em") {
        element.style.left = firstOrigin[1] + firstOrigin[2];
      } else if (firstOrigin[2] === "c") {
        addClassName(element, "proportional-style");
        element.setAttribute("data-proportional-left", firstOrigin[1]);
      } else {
        log_default.warn("TTML Parser: unhandled origin unit:", firstOrigin[2]);
      }
      if (secondOrigin[2] === "px" || secondOrigin[2] === "%" || secondOrigin[2] === "em") {
        element.style.top = secondOrigin[1] + secondOrigin[2];
      } else if (secondOrigin[2] === "c") {
        addClassName(element, "proportional-style");
        element.setAttribute("data-proportional-top", secondOrigin[1]);
      } else {
        log_default.warn("TTML Parser: unhandled origin unit:", secondOrigin[2]);
      }
    }
  }

  // src/parsers/texttracks/ttml/html/apply_padding.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function applyPadding(element, padding) {
    const trimmedPadding = padding.trim();
    const splittedPadding = trimmedPadding.split(" ");
    if (splittedPadding.length < 1) {
      return;
    }
    const firstPadding = REGXP_LENGTH.exec(splittedPadding[0]);
    if (firstPadding === null) {
      return;
    }
    if (firstPadding[2] === "px" || firstPadding[2] === "%" || firstPadding[2] === "em") {
      const firstPaddingValue = firstPadding[1] + firstPadding[2];
      if (splittedPadding.length === 1) {
        element.style.padding = firstPaddingValue;
      } else if (splittedPadding.length === 2) {
        element.style.paddingTop = firstPaddingValue;
        element.style.paddingBottom = firstPaddingValue;
      } else {
        element.style.paddingTop = firstPaddingValue;
      }
    } else if (firstPadding[2] === "c") {
      addClassName(element, "proportional-style");
      if (splittedPadding.length === 1) {
        element.setAttribute("data-proportional-padding-top", firstPadding[1]);
        element.setAttribute("data-proportional-padding-bottom", firstPadding[1]);
        element.setAttribute("data-proportional-padding-left", firstPadding[1]);
        element.setAttribute("data-proportional-padding-right", firstPadding[1]);
      } else if (splittedPadding.length === 2) {
        element.setAttribute("data-proportional-padding-top", firstPadding[1]);
        element.setAttribute("data-proportional-padding-bottom", firstPadding[1]);
      } else {
        element.setAttribute("data-proportional-padding-top", firstPadding[1]);
      }
    } else {
      log_default.warn("TTML Parser: unhandled padding unit:", firstPadding[2]);
    }
    if (splittedPadding.length === 1) {
      return;
    }
    const secondPadding = REGXP_LENGTH.exec(splittedPadding[1]);
    if (secondPadding === null) {
      return;
    }
    if (secondPadding[2] === "px" || secondPadding[2] === "%" || secondPadding[2] === "em") {
      const secondPaddingValue = secondPadding[1] + secondPadding[2];
      if (splittedPadding.length < 4) {
        element.style.paddingLeft = secondPaddingValue;
        element.style.paddingRight = secondPaddingValue;
      } else {
        element.style.paddingRight = secondPaddingValue;
      }
    } else if (secondPadding[2] === "c") {
      addClassName(element, "proportional-style");
      if (splittedPadding.length < 4) {
        element.setAttribute("data-proportional-padding-left", secondPadding[1]);
        element.setAttribute("data-proportional-padding-right", secondPadding[1]);
      } else {
        element.setAttribute("data-proportional-padding-right", secondPadding[1]);
      }
    } else {
      log_default.warn("TTML Parser: unhandled padding unit:", secondPadding[2]);
    }
    if (splittedPadding.length === 2) {
      return;
    }
    const thirdPadding = REGXP_LENGTH.exec(splittedPadding[2]);
    if (thirdPadding === null) {
      return;
    }
    if (thirdPadding[2] === "px" || thirdPadding[2] === "%" || thirdPadding[2] === "em") {
      const thirdPaddingValue = thirdPadding[1] + thirdPadding[2];
      element.style.paddingBottom = thirdPaddingValue;
    } else if (thirdPadding[2] === "c") {
      addClassName(element, "proportional-style");
      element.setAttribute("data-proportional-padding-bottom", thirdPadding[1]);
    } else {
      log_default.warn("TTML Parser: unhandled padding unit:", thirdPadding[2]);
    }
    if (splittedPadding.length === 3) {
      return;
    }
    const fourthPadding = REGXP_LENGTH.exec(splittedPadding[3]);
    if (fourthPadding === null) {
      return;
    }
    if (fourthPadding[2] === "px" || fourthPadding[2] === "%" || fourthPadding[2] === "em") {
      const fourthPaddingValue = fourthPadding[1] + fourthPadding[2];
      element.style.paddingLeft = fourthPaddingValue;
    } else if (fourthPadding[2] === "c") {
      addClassName(element, "proportional-style");
      element.setAttribute("data-proportional-padding-left", fourthPadding[1]);
    } else {
      log_default.warn("TTML Parser: unhandled padding unit:", fourthPadding[2]);
    }
  }

  // src/parsers/texttracks/ttml/html/generate_css_test_outline.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function generateCSSTextOutline(color, thickness) {
    let thick = thickness;
    if (isNonEmptyString(thickness) && thickness.trim().endsWith("%")) {
      thick = thickness.trim().slice(0, -1);
      thick = (parseInt(thick, 10) / 100).toString() + "em";
    }
    return `-1px -1px ${thick} ${color},1px -1px ${thick} ${color},-1px 1px ${thick} ${color},1px 1px ${thick} ${color}`;
  }

  // src/parsers/texttracks/ttml/html/ttml_color_to_css_color.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function ttmlColorToCSSColor(color) {
    let regRes;
    regRes = REGXP_8_HEX_COLOR.exec(color);
    if (!isNullOrUndefined(regRes)) {
      return "rgba(" + String(parseInt(regRes[1], 16)) + "," + String(parseInt(regRes[2], 16)) + "," + String(parseInt(regRes[3], 16)) + "," + String(parseInt(regRes[4], 16) / 255) + ")";
    }
    regRes = REGXP_4_HEX_COLOR.exec(color);
    if (!isNullOrUndefined(regRes)) {
      return "rgba(" + String(parseInt(regRes[1] + regRes[1], 16)) + "," + String(parseInt(regRes[2] + regRes[2], 16)) + "," + String(parseInt(regRes[3] + regRes[3], 16)) + "," + String(parseInt(regRes[4] + regRes[4], 16) / 255) + ")";
    }
    regRes = REGXP_RGB_COLOR.exec(color);
    if (!isNullOrUndefined(regRes)) {
      return "rgb(" + String(+regRes[1]) + "," + String(+regRes[2]) + "," + String(+regRes[3]) + ")";
    }
    regRes = REGXP_RGBA_COLOR.exec(color);
    if (!isNullOrUndefined(regRes)) {
      return "rgba(" + String(+regRes[1]) + "," + String(+regRes[2]) + "," + String(+regRes[3]) + "," + String(+regRes[4] / 255) + ")";
    }
    return color;
  }

  // src/parsers/texttracks/ttml/html/create_element.ts
  var SPAN_LEVEL_ATTRIBUTES = [
    "color",
    "direction",
    "display",
    "fontFamily",
    "fontSize",
    "fontStyle",
    "fontWeight",
    "textDecoration",
    "textOutline",
    "unicodeBidi",
    "visibility",
    "wrapOption"
  ];
  function applyTextStyle(element, style, shouldTrimWhiteSpace) {
    const color = style.color;
    if (isNonEmptyString(color)) {
      element.style.color = ttmlColorToCSSColor(color);
    }
    const backgroundColor = style.backgroundColor;
    if (isNonEmptyString(backgroundColor)) {
      element.style.backgroundColor = ttmlColorToCSSColor(backgroundColor);
    }
    const textOutline = style.textOutline;
    if (isNonEmptyString(textOutline)) {
      const outlineData = textOutline.trim().replace(/\s+/g, " ").split(" ");
      const len = outlineData.length;
      if (len === 3) {
        const outlineColor = ttmlColorToCSSColor(outlineData[0]);
        const thickness = outlineData[1];
        element.style.textShadow = generateCSSTextOutline(outlineColor, thickness);
      } else if (isNonEmptyString(color) && len === 1) {
        const thickness = outlineData[0];
        element.style.textShadow = generateCSSTextOutline(color, thickness);
      } else if (len === 2) {
        const isFirstArgAColor = /^[#A-Z]/i.test(outlineData[0]);
        const isFirstArgANumber = /^[0-9]/.test(outlineData[0]);
        if (isFirstArgAColor !== isFirstArgANumber) {
          if (isFirstArgAColor) {
            const outlineColor = ttmlColorToCSSColor(outlineData[0]);
            const thickness = outlineData[1];
            element.style.textShadow = generateCSSTextOutline(outlineColor, thickness);
          } else if (isNonEmptyString(color)) {
            const thickness = outlineData[0];
            element.style.textShadow = generateCSSTextOutline(color, thickness);
          }
        }
      }
    }
    const textDecoration = style.textDecoration;
    if (isNonEmptyString(textDecoration)) {
      switch (textDecoration) {
        case "noUnderline":
        case "noLineThrough":
        case "noOverline":
          element.style.textDecoration = "none";
          break;
        case "lineThrough":
          element.style.textDecoration = "line-through";
          break;
        default:
          element.style.textDecoration = textDecoration;
          break;
      }
    }
    const fontFamily = style.fontFamily;
    if (isNonEmptyString(fontFamily)) {
      switch (fontFamily) {
        case "proportionalSansSerif":
          element.style.fontFamily = "Arial, Helvetica, Liberation Sans, sans-serif";
          break;
        case "monospaceSansSerif":
        case "sansSerif":
          element.style.fontFamily = "sans-serif";
          break;
        case "monospaceSerif":
        case "default":
          element.style.fontFamily = "Courier New, Liberation Mono, monospace";
          break;
        case "proportionalSerif":
          element.style.fontFamily = "serif";
          break;
        default:
          element.style.fontFamily = fontFamily;
      }
    }
    const fontStyle = style.fontStyle;
    if (isNonEmptyString(fontStyle)) {
      element.style.fontStyle = fontStyle;
    }
    const fontWeight = style.fontWeight;
    if (isNonEmptyString(fontWeight)) {
      element.style.fontWeight = fontWeight;
    }
    const fontSize = style.fontSize;
    if (isNonEmptyString(fontSize)) {
      applyFontSize(element, fontSize);
    } else {
      addClassName(element, "proportional-style");
      element.setAttribute("data-proportional-font-size", "1");
    }
    const direction = style.direction;
    if (isNonEmptyString(direction)) {
      element.style.direction = direction;
    }
    const unicodeBidi = style.unicodeBidi;
    if (isNonEmptyString(unicodeBidi)) {
      switch (unicodeBidi) {
        case "bidiOverride":
          element.style.unicodeBidi = "bidi-override";
          break;
        case "embed":
          element.style.unicodeBidi = "embed";
          break;
        default:
          element.style.unicodeBidi = "normal";
      }
    }
    const visibility = style.visibility;
    if (isNonEmptyString(visibility)) {
      element.style.visibility = visibility;
    }
    const display = style.display;
    if (display === "none") {
      element.style.display = "none";
    }
    const wrapOption = style.wrapOption;
    if (wrapOption === "noWrap") {
      if (shouldTrimWhiteSpace) {
        element.style.whiteSpace = "nowrap";
      } else {
        element.style.whiteSpace = "pre";
      }
    } else if (shouldTrimWhiteSpace) {
      element.style.whiteSpace = "normal";
    } else {
      element.style.whiteSpace = "pre-wrap";
    }
  }
  function applyGeneralStyle(element, style) {
    element.style.color = "white";
    element.style.position = "absolute";
    const extent = style.extent;
    if (isNonEmptyString(extent)) {
      applyExtent(element, extent);
    }
    const writingMode = style.writingMode;
    if (isNonEmptyString(writingMode)) {
    }
    const overflow = style.overflow;
    element.style.overflow = isNonEmptyString(overflow) ? overflow : "hidden";
    const padding = style.padding;
    if (isNonEmptyString(padding)) {
      applyPadding(element, padding);
    }
    const origin = style.origin;
    if (isNonEmptyString(origin)) {
      applyOrigin(element, origin);
    }
    const displayAlign = style.displayAlign;
    if (isNonEmptyString(displayAlign)) {
      element.style.display = "flex";
      element.style.flexDirection = "column";
      switch (displayAlign) {
        case "before":
          element.style.justifyContent = "flex-start";
          break;
        case "center":
          element.style.justifyContent = "center";
          break;
        case "after":
          element.style.justifyContent = "flex-end";
          break;
      }
    }
    const opacity = style.opacity;
    if (isNonEmptyString(opacity)) {
      element.style.opacity = opacity;
    }
    const visibility = style.visibility;
    if (isNonEmptyString(visibility)) {
      element.style.visibility = visibility;
    }
    const display = style.display;
    if (display === "none") {
      element.style.display = "none";
    }
  }
  function applyPStyle(element, style) {
    element.style.margin = "0px";
    addClassName(element, "proportional-style");
    element.setAttribute("data-proportional-font-size", "1");
    const paragraphBackgroundColor = style.backgroundColor;
    if (isNonEmptyString(paragraphBackgroundColor)) {
      element.style.backgroundColor = ttmlColorToCSSColor(paragraphBackgroundColor);
    }
    const lineHeight = style.lineHeight;
    if (isNonEmptyString(lineHeight)) {
      applyLineHeight(element, lineHeight);
    }
    const textAlign = style.textAlign;
    if (isNonEmptyString(textAlign)) {
      switch (textAlign) {
        case "center":
          element.style.textAlign = "center";
          break;
        case "left":
        case "start":
          element.style.textAlign = "left";
          break;
        case "right":
        case "end":
          element.style.textAlign = "right";
          break;
      }
    }
  }
  function createTextElement(el, style, shouldTrimWhiteSpace) {
    const textElement = document.createElement("span");
    let textContent = el.textContent === null ? "" : el.textContent;
    if (shouldTrimWhiteSpace) {
      let trimmed = textContent.trim();
      trimmed = trimmed.replace(/\s+/g, " ");
      textContent = trimmed;
    }
    const textNode = document.createTextNode(textContent);
    textElement.appendChild(textNode);
    textElement.className = "rxp-texttrack-span";
    applyTextStyle(textElement, style, shouldTrimWhiteSpace);
    return textElement;
  }
  function generateTextContent(paragraph, regions, styles, paragraphStyle, shouldTrimWhiteSpace) {
    function loop(node, style, spans, shouldTrimWhiteSpaceFromParent) {
      const childNodes = node.childNodes;
      const elements = [];
      for (let i = 0; i < childNodes.length; i++) {
        const currentNode = childNodes[i];
        if (currentNode.nodeName === "#text") {
          const { backgroundColor } = getStylingAttributes(
            ["backgroundColor"],
            spans,
            styles,
            regions
          );
          if (isNonEmptyString(backgroundColor)) {
            style.backgroundColor = backgroundColor;
          } else {
            style.backgroundColor = "";
          }
          const el = createTextElement(currentNode, style, shouldTrimWhiteSpaceFromParent);
          elements.push(el);
        } else if (isLineBreakElement(currentNode)) {
          const br = document.createElement("BR");
          elements.push(br);
        } else if (isSpanElement(currentNode) && currentNode.nodeType === Node.ELEMENT_NODE && currentNode.childNodes.length > 0) {
          const spaceAttribute = currentNode.getAttribute("xml:space");
          const shouldTrimWhiteSpaceOnSpan = isNonEmptyString(spaceAttribute) ? spaceAttribute === "default" : shouldTrimWhiteSpaceFromParent;
          const newStyle = object_assign_default(
            {},
            style,
            getStylingAttributes(SPAN_LEVEL_ATTRIBUTES, [currentNode], styles, regions)
          );
          elements.push(
            ...loop(
              currentNode,
              newStyle,
              [currentNode, ...spans],
              shouldTrimWhiteSpaceOnSpan
            )
          );
        }
      }
      return elements;
    }
    return loop(paragraph, object_assign_default({}, paragraphStyle), [], shouldTrimWhiteSpace);
  }
  function createElement4(paragraph, body, regions, styles, paragraphStyle, {
    cellResolution,
    shouldTrimWhiteSpace
  }) {
    const divs = getParentDivElements(paragraph);
    const parentElement = document.createElement("DIV");
    parentElement.className = "rxp-texttrack-region";
    parentElement.setAttribute("data-resolution-columns", String(cellResolution.columns));
    parentElement.setAttribute("data-resolution-rows", String(cellResolution.rows));
    applyGeneralStyle(parentElement, paragraphStyle);
    if (body !== null) {
      const { bodyBackgroundColor } = getStylingAttributes(
        ["backgroundColor"],
        [...divs, body],
        styles,
        regions
      );
      if (isNonEmptyString(bodyBackgroundColor)) {
        parentElement.style.backgroundColor = ttmlColorToCSSColor(bodyBackgroundColor);
      }
    }
    const pElement = document.createElement("p");
    pElement.className = "rxp-texttrack-p";
    applyPStyle(pElement, paragraphStyle);
    const textContent = generateTextContent(
      paragraph,
      regions,
      styles,
      paragraphStyle,
      shouldTrimWhiteSpace
    );
    for (let i = 0; i < textContent.length; i++) {
      pElement.appendChild(textContent[i]);
    }
    parentElement.appendChild(pElement);
    return parentElement;
  }

  // src/parsers/texttracks/ttml/html/parse_cue.ts
  function parseCue(parsedCue) {
    const {
      paragraph,
      ttParams,
      body,
      regionStyles,
      idStyles,
      paragraphStyle,
      timeOffset,
      shouldTrimWhiteSpace
    } = parsedCue;
    if (!paragraph.hasAttribute("begin") && !paragraph.hasAttribute("end") && /^\s*$/.test(paragraph.textContent === null ? "" : paragraph.textContent)) {
      return null;
    }
    const { cellResolution } = ttParams;
    const { start, end } = getTimeDelimiters(paragraph, ttParams);
    const element = createElement4(paragraph, body, regionStyles, idStyles, paragraphStyle, {
      cellResolution,
      shouldTrimWhiteSpace
    });
    return { start: start + timeOffset, end: end + timeOffset, element };
  }

  // src/parsers/texttracks/ttml/html/parse_ttml_to_div.ts
  function parseTTMLToDiv(str, timeOffset) {
    const parsedCues = parseTTMLString(str, timeOffset);
    const cues = [];
    for (const parsedCue of parsedCues) {
      const { paragraphStyle } = parsedCue;
      if (shouldApplyDefaultTTMLStyle(paragraphStyle)) {
        applyDefaultTTMLStyle(paragraphStyle);
      }
      const cue = parseCue(parsedCue);
      if (cue !== null) {
        cues.push(cue);
      }
    }
    return cues;
  }

  // src/parsers/texttracks/ttml/html/index.ts
  var html_default3 = parseTTMLToDiv;

  // src/features/list/html_ttml_parser.ts
  function addHTMLTTMLFeature(features2) {
    features2.htmlTextTracksParsers.ttml = html_default3;
    features2.htmlTextDisplayer = html_default;
  }

  // src/features/list/html_vtt_parser.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/parsers/texttracks/webvtt/html/index.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/parsers/texttracks/webvtt/html/parse_webvtt_to_div.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/parsers/texttracks/webvtt/get_cue_blocks.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/parsers/texttracks/webvtt/utils.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function getFirstLineAfterHeader(linified) {
    let i = 0;
    while (i < linified.length) {
      if (linified[i] === "") {
        return i + 1;
      }
      i++;
    }
    return i;
  }
  function isStartOfStyleBlock(lines, index) {
    return typeof lines[index] === "string" && /^STYLE( .*)?$/g.test(lines[index]) && // A cue identifer can also contain "STYLE". Check that we have no timings
    // on the second line
    (lines[index + 1] === void 0 || lines[index + 1].indexOf("-->") < 0);
  }
  function isStartOfNoteBlock(lines, index) {
    return typeof lines[index] === "string" && /^NOTE( .*)?$/g.test(lines[index]) && // A cue identifer can also contain "NOTE". Check that we have no timings
    // on the second line
    (lines[index + 1] === void 0 || lines[index + 1].indexOf("-->") < 0);
  }
  function isStartOfRegionBlock(lines, index) {
    return typeof lines[index] === "string" && /^REGION( .*)?$/g.test(lines[index]) && // A cue identifer can also contain "REGION". Check that we have no timings
    // on the second line
    (lines[index + 1] === void 0 || lines[index + 1].indexOf("-->") < 0);
  }
  function isStartOfCueBlock(lines, index) {
    const firstLine = lines[index];
    if (firstLine === void 0 || firstLine === "" || isStartOfStyleBlock(lines, index) || isStartOfRegionBlock(lines, index) || isStartOfNoteBlock(lines, index)) {
      return false;
    }
    if (firstLine.indexOf("-->") >= 0) {
      return true;
    }
    const secondLine = lines[index + 1];
    return secondLine !== void 0 && secondLine.indexOf("-->") >= 0;
  }
  function findEndOfCueBlock2(linified, startOfCueBlock) {
    let firstEmptyLineIndex = startOfCueBlock + 1;
    while (isNonEmptyString(linified[firstEmptyLineIndex])) {
      firstEmptyLineIndex++;
    }
    return firstEmptyLineIndex;
  }

  // src/parsers/texttracks/webvtt/get_cue_blocks.ts
  function getCueBlocks2(linified, headerOffset) {
    const cueBlocks = [];
    for (let i = headerOffset; i < linified.length; i++) {
      if (isStartOfCueBlock(linified, i)) {
        const endOfCue = findEndOfCueBlock2(linified, i);
        cueBlocks.push(linified.slice(i, endOfCue));
        i = endOfCue;
      } else if (isNonEmptyString(linified[i])) {
        while (isNonEmptyString(linified[i])) {
          i++;
        }
      }
    }
    return cueBlocks;
  }

  // src/parsers/texttracks/webvtt/get_style_blocks.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function getStyleBlocks(linified, headerOffset) {
    const styleBlocks = [];
    for (let i = headerOffset; i < linified.length; i++) {
      if (isStartOfStyleBlock(linified, i)) {
        const startOfStyleBlock = i;
        i++;
        while (isNonEmptyString(linified[i])) {
          i++;
        }
        const styleBlock = linified.slice(startOfStyleBlock, i);
        styleBlocks.push(styleBlock);
      } else if (isNonEmptyString(linified[i])) {
        while (isNonEmptyString(linified[i])) {
          i++;
        }
      }
    }
    return styleBlocks;
  }

  // src/parsers/texttracks/webvtt/parse_cue_block.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/parsers/texttracks/webvtt/parse_timestamp.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function parseTimestamp2(timestampString) {
    const splittedTS = timestampString.split(":").reverse();
    if (isNonEmptyString(splittedTS[2]) || isNonEmptyString(splittedTS[1])) {
      const hours = isNonEmptyString(splittedTS[2]) ? parseInt(splittedTS[2], 10) : 0;
      const minutes = parseInt(splittedTS[1], 10);
      const seconds = parseFloat(splittedTS[0].replace(",", "."));
      if (isNaN(hours) || isNaN(minutes) || isNaN(seconds)) {
        return void 0;
      }
      return hours * 60 * 60 + minutes * 60 + seconds;
    }
  }

  // src/parsers/texttracks/webvtt/parse_cue_block.ts
  function parseSettings(settingsString) {
    const splittedSettings = settingsString.split(/ |\t/);
    return splittedSettings.reduce(
      (acc, setting) => {
        const splittedSetting = setting.split(":");
        if (splittedSetting.length === 2) {
          acc[splittedSetting[0]] = splittedSetting[1];
        }
        return acc;
      },
      {}
    );
  }
  function parseTimeAndSettings(timeString) {
    const lineRegex = /^([\d:.]+)[ |\t]+-->[ |\t]+([\d:.]+)[ |\t]*(.*)$/;
    const matches = lineRegex.exec(timeString);
    if (matches === null) {
      return null;
    }
    const start = parseTimestamp2(matches[1]);
    const end = parseTimestamp2(matches[2]);
    if (start === void 0 || end === void 0) {
      return null;
    }
    const settings = parseSettings(matches[3]);
    return { start, end, settings };
  }
  function parseCueBlock2(cueLines, timeOffset) {
    const timingRegexp = /-->/;
    let timeString;
    let payload;
    let header;
    if (!timingRegexp.test(cueLines[0])) {
      if (!timingRegexp.test(cueLines[1])) {
        return null;
      }
      header = cueLines[0];
      timeString = cueLines[1];
      payload = cueLines.slice(2, cueLines.length);
    } else {
      timeString = cueLines[0];
      payload = cueLines.slice(1, cueLines.length);
    }
    const timeAndSettings = parseTimeAndSettings(timeString);
    if (timeAndSettings === null) {
      return null;
    }
    const { start, end, settings } = timeAndSettings;
    return {
      start: start + timeOffset,
      end: end + timeOffset,
      settings,
      payload,
      header
    };
  }

  // src/parsers/texttracks/webvtt/html/parse_style_block.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/parsers/texttracks/webvtt/html/create_default_style_elements.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var colorMap = {
    white: "#ffffff",
    lime: "#00ff00",
    cyan: "#00ffff",
    red: "#ff0000",
    yellow: "#ffff00",
    magenta: "#ff00ff",
    blue: "#0000ff",
    black: "#000000"
  };
  function createDefaultStyleElements() {
    return Object.keys(colorMap).reduce((result, key) => {
      result[key] = `color: ${colorMap[key]};`;
      result[`bg_${key}`] = `background-color: ${colorMap[key]};`;
      return result;
    }, {});
  }

  // src/parsers/texttracks/webvtt/html/parse_style_block.ts
  function parseStyleBlocks(styleBlocks) {
    const classes = createDefaultStyleElements();
    let global2 = "";
    styleBlocks.forEach((styleBlock) => {
      if (styleBlock.length >= 2) {
        for (let index = 1; index < styleBlock.length; index++) {
          let line = styleBlock[index];
          if (Array.isArray(/::cue {/.exec(line))) {
            line = styleBlock[++index];
            while (isNonEmptyString(line) && !(Array.isArray(/}/.exec(line)) || line.length === 0)) {
              global2 += line;
              line = styleBlock[++index];
            }
          } else {
            const classNames = [];
            let cueClassLine = /::cue\(\.?(.*?)\)(?:,| {)/.exec(line);
            while (isNonEmptyString(line) && Array.isArray(cueClassLine)) {
              classNames.push(cueClassLine[1]);
              line = styleBlock[++index];
              cueClassLine = /::cue\(\.?(.*?)\)(?:,| {)/.exec(line);
            }
            let styleContent = "";
            while (isNonEmptyString(line) && !(Array.isArray(/}/.exec(line)) || line.length === 0)) {
              styleContent += line;
              line = styleBlock[++index];
            }
            classNames.forEach((className) => {
              const styleElement = classes[className];
              if (styleElement === void 0) {
                classes[className] = styleContent;
              } else {
                classes[className] += styleContent;
              }
            });
          }
        }
      }
    });
    return { classes, global: global2 };
  }

  // src/parsers/texttracks/webvtt/html/to_html.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/parsers/texttracks/webvtt/html/convert_payload_to_html.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/parsers/texttracks/webvtt/html/create_styled_element.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function createStyledElement(baseNode, styleElements) {
    const HTMLTags = ["u", "i", "b"];
    const authorizedNodeNames = ["u", "i", "b", "c", "#text"];
    const mainNodeName = baseNode.nodeName.toLowerCase().split(".")[0];
    let nodeWithStyle;
    if (arrayIncludes(authorizedNodeNames, mainNodeName)) {
      if (mainNodeName === "#text") {
        const linifiedText = baseNode.wholeText.split("\n");
        nodeWithStyle = document.createElement("span");
        for (let i = 0; i < linifiedText.length; i++) {
          if (i > 0) {
            nodeWithStyle.appendChild(document.createElement("br"));
          }
          if (linifiedText[i].length > 0) {
            const textNode = document.createTextNode(linifiedText[i]);
            nodeWithStyle.appendChild(textNode);
          }
        }
      } else {
        const nodeClasses = baseNode.nodeName.toLowerCase().split(".");
        const styleContents = [];
        nodeClasses.forEach((nodeClass) => {
          if (isNonEmptyString(styleElements[nodeClass])) {
            styleContents.push(styleElements[nodeClass]);
          }
        });
        if (styleContents.length !== 0) {
          const attr = document.createAttribute("style");
          styleContents.forEach((styleContent) => {
            attr.value += styleContent;
          });
          const nameClass = arrayIncludes(HTMLTags, mainNodeName) ? mainNodeName : "span";
          nodeWithStyle = document.createElement(nameClass);
          nodeWithStyle.setAttributeNode(attr);
        } else {
          const elementTag = !arrayIncludes(HTMLTags, mainNodeName) ? "span" : mainNodeName;
          nodeWithStyle = document.createElement(elementTag);
        }
        for (let j = 0; j < baseNode.childNodes.length; j++) {
          const child = createStyledElement(baseNode.childNodes[j], styleElements);
          nodeWithStyle.appendChild(child);
        }
      }
    } else {
      nodeWithStyle = document.createElement("span");
      for (let j = 0; j < baseNode.childNodes.length; j++) {
        const child = createStyledElement(baseNode.childNodes[j], styleElements);
        nodeWithStyle.appendChild(child);
      }
    }
    return nodeWithStyle;
  }

  // src/parsers/texttracks/webvtt/html/convert_payload_to_html.ts
  function convertPayloadToHTML(text, styleElements) {
    const filteredText = text.replace(/<[0-9]{2}:[0-9]{2}.[0-9]{3}>/, "").replace(/<([u,i,b,c])(\..*?)?(?: .*?)?>(.*?)<\/\1>/g, "<$1$2>$3</$1$2>");
    const parsedWebVTT = new DOMParser().parseFromString(filteredText, "text/html");
    const nodes = parsedWebVTT.body.childNodes;
    const styledElements = [];
    for (let i = 0; i < nodes.length; i++) {
      styledElements.push(createStyledElement(nodes[i], styleElements));
    }
    return styledElements;
  }

  // src/parsers/texttracks/webvtt/html/create_style_attribute.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function createStyleAttribute(settings) {
    const pAttr = document.createAttribute("style");
    pAttr.value = getAttrValue(settings);
    return pAttr;
  }
  var getAttrValue = (settings) => {
    const hasSettings = settings !== void 0 && object_values_default(settings).length !== 0;
    if (!hasSettings) {
      return "text-align:center";
    }
    const xPositioning = getPositioningX(settings);
    const yPositioning = getPositioningY(settings);
    return `position: absolute;margin: 0;transform: translate(${xPositioning.offset}%,${yPositioning.offset}%);width: ${getSizePercentage(settings.size)}%;left: ${xPositioning.position}%;top: ${yPositioning.position !== null ? `${yPositioning.position}%` : "auto"};text-align: ${getAlignValue(settings.align)};`;
  };
  var getPositioningX = (settings) => {
    return {
      position: getXPositionPercentage(settings),
      offset: getXOffsetPercentage(settings)
    };
  };
  var getXPositionPercentage = (settings) => {
    const positionPercentage = getPercentageValue(settings.position);
    if (positionPercentage !== null) {
      return positionPercentage;
    }
    const align = getAlignValue(settings.align);
    const alignMap = {
      ["left" /* LEFT */]: 0,
      ["center" /* CENTER */]: 50,
      ["right" /* RIGHT */]: 100
    };
    return alignMap[align];
  };
  var getXOffsetPercentage = (settings) => {
    const getPositionAlignment = (positionSetting) => {
      const positionRegex = /,(line-left|line-right|center)/;
      const matches = positionRegex.exec(positionSetting);
      if (!Array.isArray(matches) || matches.length < 2) {
        return null;
      }
      return matches[1];
    };
    const positionAlignmentMap = {
      ["line-left" /* LINE_LEFT */]: 0,
      ["center" /* CENTER */]: -50,
      ["line-right" /* LINE_RIGHT */]: -100
    };
    const positionAlignment = settings.position !== void 0 ? getPositionAlignment(settings.position) : null;
    if (positionAlignment !== null) {
      return positionAlignmentMap[positionAlignment];
    }
    const alignMap = {
      ["left" /* LEFT */]: 0,
      ["center" /* CENTER */]: -50,
      ["right" /* RIGHT */]: -100
    };
    const align = settings.align !== void 0 ? getAlignValue(settings.align) : "center" /* CENTER */;
    return alignMap[align];
  };
  var getPositioningY = (settings) => {
    return {
      position: getYPositionPercentage(settings.line),
      offset: getYOffsetPercentage(settings.line)
    };
  };
  var getYPositionPercentage = (lineSetting) => {
    return getPercentageValue(lineSetting);
  };
  var getYOffsetPercentage = (lineSetting) => {
    const getLineAlignment = (line) => {
      const positionRegex = /,(start|center|end)/;
      const matches = positionRegex.exec(line);
      if (!Array.isArray(matches) || matches.length < 2) {
        return null;
      }
      return matches[1];
    };
    const lineAlignmentMap = {
      ["start" /* START */]: 0,
      ["center" /* CENTER */]: -50,
      ["end" /* END */]: -100
    };
    if (lineSetting === void 0) {
      return lineAlignmentMap["start" /* START */];
    }
    const lineAlignment = getLineAlignment(lineSetting);
    return lineAlignment !== null ? lineAlignmentMap[lineAlignment] : lineAlignmentMap["start" /* START */];
  };
  var getAlignValue = (alignSetting) => {
    switch (alignSetting) {
      case "left":
      case "start":
        return "left";
      case "right":
      case "end":
        return "right";
      default:
        return "center";
    }
  };
  var getSizePercentage = (sizeSetting) => {
    const defaultSize = 100;
    return getPercentageValueOrDefault(sizeSetting, defaultSize);
  };
  var getPercentageValueOrDefault = (percentageString, defaultValue) => {
    const value = getPercentageValue(percentageString);
    return value !== null ? value : defaultValue;
  };
  var getPercentageValue = (percentageString) => {
    if (percentageString === void 0) {
      return null;
    }
    const percentageValueRegex = /^([\d.]+)%/;
    const matches = percentageValueRegex.exec(percentageString);
    if (!Array.isArray(matches) || matches.length < 2) {
      return null;
    }
    return parseInt(matches[1], 10);
  };

  // src/parsers/texttracks/webvtt/html/to_html.ts
  function toHTML2(cueObj, styling) {
    const { start, end, settings, header, payload } = cueObj;
    const region = document.createElement("div");
    const regionAttr = document.createAttribute("style");
    regionAttr.value = "width:100%;height:100%;display:flex;flex-direction:column;justify-content:flex-end;align-items:center;";
    region.setAttributeNode(regionAttr);
    const pElement = document.createElement("p");
    const pAttr = createStyleAttribute(settings);
    pElement.setAttributeNode(pAttr);
    const spanElement = document.createElement("span");
    const attr = document.createAttribute("style");
    attr.value = "background-color:rgba(0,0,0,0.8);color:white;";
    spanElement.setAttributeNode(attr);
    const { global: global2, classes } = styling;
    const localStyle = isNonEmptyString(header) ? classes[header] : void 0;
    const styles = [global2, localStyle].filter((s) => s !== void 0).join("");
    attr.value += styles;
    spanElement.setAttributeNode(attr);
    convertPayloadToHTML(payload.join("\n"), classes).forEach((element) => {
      spanElement.appendChild(element);
    });
    region.appendChild(pElement);
    pElement.appendChild(spanElement);
    return { start, end, element: region };
  }

  // src/parsers/texttracks/webvtt/html/parse_webvtt_to_div.ts
  function parseWebVTT(text, timeOffset) {
    const newLineChar = /\r\n|\n|\r/g;
    const linified = text.split(newLineChar);
    const cuesArray = [];
    if (/^WEBVTT( |\t|\n|\r|$)/.exec(linified[0]) === null) {
      throw new Error("Can't parse WebVTT: Invalid File.");
    }
    const firstLineAfterHeader = getFirstLineAfterHeader(linified);
    const styleBlocks = getStyleBlocks(linified, firstLineAfterHeader);
    const cueBlocks = getCueBlocks2(linified, firstLineAfterHeader);
    const styles = parseStyleBlocks(styleBlocks);
    for (let i = 0; i < cueBlocks.length; i++) {
      const cueObject = parseCueBlock2(cueBlocks[i], timeOffset);
      if (cueObject !== null) {
        const htmlCue = toHTML2(cueObject, styles);
        cuesArray.push(htmlCue);
      }
    }
    return cuesArray;
  }

  // src/parsers/texttracks/webvtt/html/index.ts
  var html_default4 = parseWebVTT;

  // src/features/list/html_vtt_parser.ts
  function addHTMLVTTFeature(features2) {
    features2.htmlTextTracksParsers.vtt = html_default4;
    features2.htmlTextDisplayer = html_default;
  }

  // src/features/list/smooth.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/transports/smooth/index.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/transports/smooth/pipelines.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/parsers/manifest/smooth/index.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/parsers/manifest/smooth/create_parser.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/parsers/manifest/utils/check_manifest_ids.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function checkManifestIDs(manifest) {
    const periodIDS = [];
    manifest.periods.forEach((period) => {
      const periodID = period.id;
      if (arrayIncludes(periodIDS, periodID)) {
        log_default.warn("Two periods with the same ID found. Updating.");
        const newID = periodID + "-dup";
        period.id = newID;
        checkManifestIDs(manifest);
        periodIDS.push(newID);
      } else {
        periodIDS.push(periodID);
      }
      const { adaptations } = period;
      const adaptationIDs = [];
      Object.keys(adaptations).forEach((type) => {
        const adaptationsForType = adaptations[type];
        if (adaptationsForType === void 0) {
          return;
        }
        adaptationsForType.forEach((adaptation) => {
          const adaptationID = adaptation.id;
          if (arrayIncludes(adaptationIDs, adaptationID)) {
            log_default.warn("Two adaptations with the same ID found. Updating.", adaptationID);
            const newID = adaptationID + "-dup";
            adaptation.id = newID;
            checkManifestIDs(manifest);
            adaptationIDs.push(newID);
          } else {
            adaptationIDs.push(adaptationID);
          }
          const representationIDs = [];
          adaptation.representations.forEach((representation) => {
            const representationID = representation.id;
            if (arrayIncludes(representationIDs, representationID)) {
              log_default.warn(
                "Two representations with the same ID found. Updating.",
                representationID
              );
              const newID = `${representationID}-dup`;
              representation.id = newID;
              checkManifestIDs(manifest);
              representationIDs.push(newID);
            } else {
              representationIDs.push(representationID);
            }
          });
        });
      });
    });
  }

  // src/parsers/manifest/smooth/get_codecs.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function getAudioCodecs(codecPrivateData, fourCC) {
    let mpProfile;
    if (fourCC === "AACH") {
      mpProfile = 5;
    } else {
      mpProfile = isNonEmptyString(codecPrivateData) ? (parseInt(codecPrivateData.substring(0, 2), 16) & 248) >> 3 : 2;
    }
    if (mpProfile === 0) {
      return "mp4a.40.2";
    }
    return `mp4a.40.${mpProfile}`;
  }
  function getVideoCodecs(codecPrivateData) {
    const arr = /00000001\d7([0-9a-fA-F]{6})/.exec(codecPrivateData);
    if (arr === null || !isNonEmptyString(arr[1])) {
      return "avc1.4D401E";
    }
    return "avc1." + arr[1];
  }

  // src/parsers/manifest/smooth/parse_C_nodes.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function parseCNodes(nodes) {
    return nodes.reduce((timeline, node, i) => {
      const dAttr = node.getAttribute("d");
      const tAttr = node.getAttribute("t");
      const rAttr = node.getAttribute("r");
      const repeatCount = rAttr !== null ? +rAttr - 1 : 0;
      let start = tAttr !== null ? +tAttr : void 0;
      let duration = dAttr !== null ? +dAttr : void 0;
      if (i === 0) {
        start = start === void 0 || isNaN(start) ? 0 : start;
      } else {
        const prev = timeline[i - 1];
        if (start === void 0 || isNaN(start)) {
          if (prev.duration === void 0 || isNaN(prev.duration)) {
            throw new Error("Smooth: Invalid CNodes. Missing timestamp.");
          }
          start = prev.start + prev.duration * (prev.repeatCount + 1);
        }
      }
      if (duration === void 0 || isNaN(duration)) {
        const nextNode = nodes[i + 1];
        if (nextNode !== void 0) {
          const nextTAttr = nextNode.getAttribute("t");
          const nextStart = isNonEmptyString(nextTAttr) ? +nextTAttr : null;
          if (nextStart === null) {
            throw new Error("Can't build index timeline from Smooth Manifest.");
          }
          duration = nextStart - start;
        } else {
          return timeline;
        }
      }
      timeline.push({ duration, start, repeatCount });
      return timeline;
    }, []);
  }

  // src/parsers/manifest/smooth/parse_protection_node.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function createWidevineKeySystem(keyIdBytes) {
    return [
      {
        systemId: "edef8ba9-79d6-4ace-a3c8-27dcd51d21ed",
        // Widevine
        privateData: concat([8, 1, 18, 16], keyIdBytes)
      }
    ];
  }
  function parseProtectionNode(protectionNode, keySystemCreator = createWidevineKeySystem) {
    if (protectionNode.firstElementChild === null || protectionNode.firstElementChild.nodeName !== "ProtectionHeader") {
      throw new Error("Protection should have ProtectionHeader child");
    }
    const header = protectionNode.firstElementChild;
    const privateData = base64ToBytes(
      header.textContent === null ? "" : header.textContent
    );
    const keyIdHex = getPlayReadyKIDFromPrivateData(privateData);
    const keyIdBytes = hexToBytes(keyIdHex);
    const systemIdAttr = header.getAttribute("SystemID");
    const systemId = (systemIdAttr !== null ? systemIdAttr : "").toLowerCase().replace(/\{|\}/g, "");
    return {
      keyId: keyIdBytes,
      keySystems: [
        {
          systemId,
          privateData
          /* keyIds: [keyIdBytes], */
        }
      ].concat(keySystemCreator(keyIdBytes))
    };
  }

  // src/parsers/manifest/smooth/representation_index.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/parsers/manifest/smooth/utils/tokens.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function replaceRepresentationSmoothTokens(url, bitrate, customAttributes) {
    return url.replace(/\{bitrate\}/g, String(bitrate)).replace(
      /{CustomAttributes}/g,
      customAttributes.length > 0 ? customAttributes[0] : ""
    );
  }
  function replaceSegmentSmoothTokens(url, time) {
    return url.replace(/\{start time\}/g, String(time));
  }

  // src/parsers/manifest/smooth/representation_index.ts
  function getSegmentNumber(start, up, duration) {
    const diff = up - start;
    return diff > 0 ? Math.floor(diff / duration) : 0;
  }
  function normalizeRange(timescale, start, duration) {
    const ts = timescale === void 0 || timescale === 0 ? 1 : timescale;
    return { up: start * ts, to: (start + duration) * ts };
  }
  function calculateRepeat2(segment, nextSegment) {
    let repeatCount = segment.repeatCount;
    if (segment.duration !== void 0 && repeatCount < 0) {
      const repeatEnd = nextSegment !== void 0 ? nextSegment.start : Infinity;
      repeatCount = Math.ceil((repeatEnd - segment.start) / segment.duration) - 1;
    }
    return repeatCount;
  }
  var SmoothRepresentationIndex = class {
    /**
     * Creates a new `SmoothRepresentationIndex`.
     * @param {Object} index
     * @param {Object} options
     */
    constructor(options) {
      const { isLive, segmentPrivateInfos, media, sharedSmoothTimeline } = options;
      this._sharedSmoothTimeline = sharedSmoothTimeline;
      this._initSegmentInfos = {
        bitsPerSample: segmentPrivateInfos.bitsPerSample,
        channels: segmentPrivateInfos.channels,
        codecPrivateData: segmentPrivateInfos.codecPrivateData,
        packetSize: segmentPrivateInfos.packetSize,
        samplingRate: segmentPrivateInfos.samplingRate,
        timescale: sharedSmoothTimeline.timescale,
        height: segmentPrivateInfos.height,
        width: segmentPrivateInfos.width,
        protection: segmentPrivateInfos.protection
      };
      this._isLive = isLive;
      this._media = media;
      if (sharedSmoothTimeline.timeline.length !== 0 && isLive) {
        const { timeline, validityTime } = sharedSmoothTimeline;
        const lastItem = timeline[timeline.length - 1];
        const scaledEnd = getIndexSegmentEnd(lastItem, null);
        const scaledTimelineValidityTime = validityTime / 1e3 * sharedSmoothTimeline.timescale;
        this._scaledLiveGap = scaledTimelineValidityTime - scaledEnd;
      }
    }
    /**
     * Construct init Segment compatible with a Smooth Manifest.
     * @returns {Object}
     */
    getInitSegment() {
      return {
        id: "init",
        isInit: true,
        privateInfos: { smoothInitSegment: this._initSegmentInfos },
        url: null,
        time: 0,
        end: 0,
        duration: 0,
        timescale: 1,
        complete: true
      };
    }
    /**
     * Generate a list of Segments for a particular period of time.
     *
     * @param {Number} from
     * @param {Number} dur
     * @returns {Array.<Object>}
     */
    getSegments(from, dur) {
      this._refreshTimeline();
      const { timescale, timeline } = this._sharedSmoothTimeline;
      const { up, to } = normalizeRange(timescale, from, dur);
      const media = this._media;
      let currentNumber;
      const segments = [];
      const timelineLength = timeline.length;
      const maxPosition = this._scaledLiveGap === void 0 ? void 0 : monotonic_timestamp_default() / 1e3 * timescale - this._scaledLiveGap;
      for (let i = 0; i < timelineLength; i++) {
        const segmentRange = timeline[i];
        const { duration, start } = segmentRange;
        const repeat = calculateRepeat2(segmentRange, timeline[i + 1]);
        let segmentNumberInCurrentRange = getSegmentNumber(start, up, duration);
        let segmentTime = start + segmentNumberInCurrentRange * duration;
        const timeToAddToCheckMaxPosition = duration;
        while (segmentTime < to && segmentNumberInCurrentRange <= repeat && (maxPosition === void 0 || segmentTime + timeToAddToCheckMaxPosition <= maxPosition)) {
          const time = segmentTime;
          const number = currentNumber !== void 0 ? currentNumber + segmentNumberInCurrentRange : void 0;
          const segment = {
            id: String(segmentTime),
            isInit: false,
            time: time / timescale,
            end: (time + duration) / timescale,
            duration: duration / timescale,
            timescale: 1,
            number,
            url: replaceSegmentSmoothTokens(media, time),
            complete: true,
            privateInfos: { smoothMediaSegment: { time, duration } }
          };
          segments.push(segment);
          segmentNumberInCurrentRange++;
          segmentTime = start + segmentNumberInCurrentRange * duration;
        }
        if (segmentTime >= to) {
          return segments;
        }
        if (currentNumber !== void 0) {
          currentNumber += repeat + 1;
        }
      }
      return segments;
    }
    /**
     * Returns true if, based on the arguments, the index should be refreshed.
     * (If we should re-fetch the manifest)
     * @param {Number} up
     * @param {Number} to
     * @returns {Boolean}
     */
    shouldRefresh(up, to) {
      this._refreshTimeline();
      if (!this._isLive) {
        return false;
      }
      const { timeline, timescale } = this._sharedSmoothTimeline;
      const lastSegmentInCurrentTimeline = timeline[timeline.length - 1];
      if (lastSegmentInCurrentTimeline === void 0) {
        return false;
      }
      const repeat = lastSegmentInCurrentTimeline.repeatCount;
      const endOfLastSegmentInCurrentTimeline = lastSegmentInCurrentTimeline.start + (repeat + 1) * lastSegmentInCurrentTimeline.duration;
      if (to * timescale < endOfLastSegmentInCurrentTimeline) {
        return false;
      }
      if (up * timescale >= endOfLastSegmentInCurrentTimeline) {
        return true;
      }
      const startOfLastSegmentInCurrentTimeline = lastSegmentInCurrentTimeline.start + repeat * lastSegmentInCurrentTimeline.duration;
      return up * timescale > startOfLastSegmentInCurrentTimeline;
    }
    /**
     * Returns first position available in the index.
     * @returns {Number|null}
     */
    getFirstAvailablePosition() {
      this._refreshTimeline();
      const { timeline, timescale } = this._sharedSmoothTimeline;
      if (timeline.length === 0) {
        return null;
      }
      return timeline[0].start / timescale;
    }
    /**
     * Returns last position available in the index.
     * @returns {Number}
     */
    getLastAvailablePosition() {
      this._refreshTimeline();
      const { timeline, timescale } = this._sharedSmoothTimeline;
      if (this._scaledLiveGap === void 0) {
        const lastTimelineElement = timeline[timeline.length - 1];
        return getIndexSegmentEnd(lastTimelineElement, null) / timescale;
      }
      for (let i = timeline.length - 1; i >= 0; i--) {
        const timelineElt = timeline[i];
        const timescaledNow = monotonic_timestamp_default() / 1e3 * timescale;
        const { start, duration, repeatCount } = timelineElt;
        for (let j = repeatCount; j >= 0; j--) {
          const end = start + duration * (j + 1);
          const positionToReach = end;
          if (positionToReach <= timescaledNow - this._scaledLiveGap) {
            return end / timescale;
          }
        }
      }
      return void 0;
    }
    /**
     * Returns the absolute end in seconds this RepresentationIndex can reach once
     * all segments are available.
     * @returns {number|null|undefined}
     */
    getEnd() {
      if (!this._isLive) {
        return this.getLastAvailablePosition();
      }
      return void 0;
    }
    /**
     * Returns:
     *   - `true` if in the given time interval, at least one new segment is
     *     expected to be available in the future.
     *   - `false` either if all segments in that time interval are already
     *     available for download or if none will ever be available for it.
     *   - `undefined` when it is not possible to tell.
     * @param {number} start
     * @param {number} end
     * @returns {boolean|undefined}
     */
    awaitSegmentBetween(start, end) {
      var _a;
      assert(start <= end);
      if (this.isStillAwaitingFutureSegments()) {
        return false;
      }
      const lastAvailablePosition = this.getLastAvailablePosition();
      if (lastAvailablePosition !== void 0 && end < lastAvailablePosition) {
        return false;
      }
      return end > ((_a = this.getFirstAvailablePosition()) != null ? _a : 0) ? void 0 : false;
    }
    /**
     * Checks if `timeSec` is in a discontinuity.
     * That is, if there's no segment available for the `timeSec` position.
     * @param {number} timeSec - The time to check if it's in a discontinuity, in
     * seconds.
     * @returns {number | null} - If `null`, no discontinuity is encountered at
     * `time`. If this is a number instead, there is one and that number is the
     * position for which a segment is available in seconds.
     */
    checkDiscontinuity(timeSec) {
      this._refreshTimeline();
      return checkDiscontinuity(this._sharedSmoothTimeline, timeSec, void 0);
    }
    /**
     * Returns `true` if a Segment returned by this index is still considered
     * available.
     * Returns `false` if it is not available anymore.
     * Returns `undefined` if we cannot know whether it is still available or not.
     * @param {Object} segment
     * @returns {Boolean|undefined}
     */
    isSegmentStillAvailable(segment) {
      if (segment.isInit) {
        return true;
      }
      this._refreshTimeline();
      const { timeline, timescale } = this._sharedSmoothTimeline;
      for (let i = 0; i < timeline.length; i++) {
        const tSegment = timeline[i];
        const tSegmentTime = tSegment.start / timescale;
        if (tSegmentTime > segment.time) {
          return false;
        } else if (tSegmentTime === segment.time) {
          return true;
        } else {
          if (tSegment.repeatCount >= 0 && tSegment.duration !== void 0) {
            const timeDiff = tSegmentTime - tSegment.start;
            const repeat = timeDiff / tSegment.duration - 1;
            return repeat % 1 === 0 && repeat <= tSegment.repeatCount;
          }
        }
      }
      return false;
    }
    /**
     * @param {Error} error
     * @returns {Boolean}
     */
    canBeOutOfSyncError(error) {
      if (!this._isLive) {
        return false;
      }
      return error instanceof NetworkError && (error.isHttpError(404) || error.isHttpError(412));
    }
    /**
     * Replace this RepresentationIndex by a newly downloaded one.
     * Check if the old index had more information about new segments and re-add
     * them if that's the case.
     * @param {Object} newIndex
     */
    _replace(newIndex) {
      this._initialScaledLastPosition = newIndex._initialScaledLastPosition;
      this._scaledLiveGap = newIndex._scaledLiveGap;
      this._sharedSmoothTimeline.replace(newIndex._sharedSmoothTimeline);
    }
    /**
     * Update the current index with a new, partial, version.
     * This method might be use to only add information about new segments.
     * @param {Object} newIndex
     */
    _update(newIndex) {
      this._scaledLiveGap = newIndex._scaledLiveGap;
      this._sharedSmoothTimeline.update(newIndex._sharedSmoothTimeline);
    }
    /**
     * Returns `false` if the last segments in this index have already been
     * generated.
     * Returns `true` if the index is still waiting on future segments to be
     * generated.
     *
     * For Smooth, it should only depend on whether the content is a live content
     * or not.
     * TODO What about Smooth live content that finishes at some point?
     * @returns {boolean}
     */
    isStillAwaitingFutureSegments() {
      return this._isLive;
    }
    /**
     * @returns {Boolean}
     */
    isInitialized() {
      return true;
    }
    initialize() {
      log_default.error("A `SmoothRepresentationIndex` does not need to be initialized");
    }
    /**
     * Add segments to a `SharedSmoothSegmentTimeline` that were predicted to come
     * after `currentSegment`.
     * @param {Array.<Object>} nextSegments - The segment information parsed.
     * @param {Object} currentSegment - Information on the segment which contained
     * that new segment information.
     */
    addPredictedSegments(nextSegments, currentSegment) {
      this._sharedSmoothTimeline.addPredictedSegments(nextSegments, currentSegment);
    }
    /**
     * Clean-up timeline to remove segment information which should not be
     * available due to the timeshift window
     */
    _refreshTimeline() {
      this._sharedSmoothTimeline.refresh();
    }
  };

  // src/parsers/manifest/smooth/shared_smooth_segment_timeline.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/parsers/manifest/smooth/utils/add_segment_infos.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function _addSegmentInfos2(timeline, timescale, newSegment, currentSegment) {
    const timelineLength = timeline.length;
    const last = timeline[timelineLength - 1];
    const scaledNewSegment = newSegment.timescale === timescale ? { time: newSegment.time, duration: newSegment.duration } : {
      time: newSegment.time / newSegment.timescale * timescale,
      duration: newSegment.duration / newSegment.timescale * timescale
    };
    const shouldDeductNextSegment = currentSegment.time === scaledNewSegment.time;
    if (shouldDeductNextSegment) {
      return false;
    } else if (scaledNewSegment.time >= getIndexSegmentEnd(last, null)) {
      if (last.duration === scaledNewSegment.duration) {
        last.repeatCount++;
      } else {
        timeline.push({
          duration: scaledNewSegment.duration,
          start: scaledNewSegment.time,
          repeatCount: 0
        });
      }
      return true;
    }
    return false;
  }

  // src/parsers/manifest/smooth/shared_smooth_segment_timeline.ts
  var SharedSmoothSegmentTimeline = class {
    constructor(args) {
      const { timeline, timescale, timeShiftBufferDepth, manifestReceivedTime } = args;
      this.timeline = timeline;
      this.timescale = timescale;
      const estimatedReceivedTime = manifestReceivedTime != null ? manifestReceivedTime : monotonic_timestamp_default();
      this.validityTime = estimatedReceivedTime;
      this._timeShiftBufferDepth = timeShiftBufferDepth;
      if (timeline.length !== 0) {
        const lastItem = timeline[timeline.length - 1];
        const scaledEnd = getIndexSegmentEnd(lastItem, null);
        this._initialScaledLastPosition = scaledEnd;
      }
    }
    /**
     * Clean-up timeline to remove segment information which should not be
     * available due to the timeshift window
     */
    refresh() {
      if (this._initialScaledLastPosition === void 0) {
        return;
      }
      const timeShiftBufferDepth = this._timeShiftBufferDepth;
      const timeSinceLastRealUpdate = (monotonic_timestamp_default() - this.validityTime) / 1e3;
      const lastPositionEstimate = timeSinceLastRealUpdate + this._initialScaledLastPosition / this.timescale;
      if (timeShiftBufferDepth !== void 0) {
        const minimumPosition = (lastPositionEstimate - timeShiftBufferDepth) * this.timescale;
        clearTimelineFromPosition(this.timeline, minimumPosition);
      }
    }
    /**
     * Replace this SharedSmoothSegmentTimeline by a newly downloaded one.
     * Check if the old timeline had more information about new segments and re-add
     * them if that's the case.
     * @param {Object} newSmoothTimeline
     */
    replace(newSmoothTimeline) {
      const oldTimeline = this.timeline;
      const newTimeline = newSmoothTimeline.timeline;
      const oldTimescale = this.timescale;
      const newTimescale = newSmoothTimeline.timescale;
      this._initialScaledLastPosition = newSmoothTimeline._initialScaledLastPosition;
      this.validityTime = newSmoothTimeline.validityTime;
      if (oldTimeline.length === 0 || newTimeline.length === 0 || oldTimescale !== newTimescale) {
        return;
      }
      const lastOldTimelineElement = oldTimeline[oldTimeline.length - 1];
      const lastNewTimelineElement = newTimeline[newTimeline.length - 1];
      const newEnd = getIndexSegmentEnd(lastNewTimelineElement, null);
      if (getIndexSegmentEnd(lastOldTimelineElement, null) <= newEnd) {
        return;
      }
      for (let i = 0; i < oldTimeline.length; i++) {
        const oldTimelineRange = oldTimeline[i];
        const oldEnd = getIndexSegmentEnd(oldTimelineRange, null);
        if (oldEnd === newEnd) {
          this.timeline = this.timeline.concat(oldTimeline.slice(i + 1));
          return;
        }
        if (oldEnd > newEnd) {
          if (oldTimelineRange.duration !== lastNewTimelineElement.duration) {
            return;
          }
          const rangeDuration = newEnd - oldTimelineRange.start;
          if (rangeDuration === 0) {
            log_default.warn(
              "Smooth Parser: a discontinuity detected in the previous manifest has been resolved."
            );
            this.timeline = this.timeline.concat(oldTimeline.slice(i));
            return;
          }
          if (rangeDuration < 0 || rangeDuration % oldTimelineRange.duration !== 0) {
            return;
          }
          const repeatWithOld = rangeDuration / oldTimelineRange.duration - 1;
          const relativeRepeat = oldTimelineRange.repeatCount - repeatWithOld;
          if (relativeRepeat < 0) {
            return;
          }
          lastNewTimelineElement.repeatCount += relativeRepeat;
          const supplementarySegments = oldTimeline.slice(i + 1);
          this.timeline = this.timeline.concat(supplementarySegments);
          return;
        }
      }
    }
    /**
     * Update the current SharedSmoothSegmentTimeline with a new, partial, version.
     * This method might be use to only add information about new segments.
     * @param {Object} newSmoothTimeline
     */
    update(newSmoothTimeline) {
      updateSegmentTimeline(this.timeline, newSmoothTimeline.timeline);
      this._initialScaledLastPosition = newSmoothTimeline._initialScaledLastPosition;
      this.validityTime = newSmoothTimeline.validityTime;
    }
    /**
     * Add segments to a `SharedSmoothSegmentTimeline` that were predicted to come
     * after `currentSegment`.
     * @param {Array.<Object>} nextSegments - The segment information parsed.
     * @param {Object} segment - Information on the segment which contained that
     * new segment information.
     */
    addPredictedSegments(nextSegments, currentSegment) {
      var _a;
      if (((_a = currentSegment.privateInfos) == null ? void 0 : _a.smoothMediaSegment) === void 0) {
        log_default.warn("Smooth Parser: should only encounter SmoothRepresentationIndex");
        return;
      }
      this.refresh();
      for (const nextSeg of nextSegments) {
        _addSegmentInfos2(
          this.timeline,
          this.timescale,
          nextSeg,
          currentSegment.privateInfos.smoothMediaSegment
        );
      }
    }
  };

  // src/parsers/manifest/smooth/utils/parseBoolean.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function parseBoolean2(val) {
    if (typeof val === "boolean") {
      return val;
    } else if (typeof val === "string") {
      return val.toUpperCase() === "TRUE";
    } else {
      return false;
    }
  }

  // src/parsers/manifest/smooth/utils/reduceChildren.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function reduceChildren(root, fn, init) {
    let node = root.firstElementChild;
    let accumulator = init;
    while (node !== null) {
      accumulator = fn(accumulator, node.nodeName, node);
      node = node.nextElementSibling;
    }
    return accumulator;
  }

  // src/parsers/manifest/smooth/create_parser.ts
  var DEFAULT_MIME_TYPES = {
    audio: "audio/mp4",
    video: "video/mp4",
    text: "application/ttml+xml"
  };
  var MIME_TYPES = {
    AACL: "audio/mp4",
    AVC1: "video/mp4",
    H264: "video/mp4",
    TTML: "application/ttml+xml+mp4",
    DFXP: "application/ttml+xml+mp4"
  };
  function createSmoothStreamingParser(parserOptions = {}) {
    const referenceDateTime = parserOptions.referenceDateTime === void 0 ? Date.UTC(1970, 0, 1, 0, 0, 0, 0) / 1e3 : parserOptions.referenceDateTime;
    const minRepresentationBitrate = parserOptions.minRepresentationBitrate === void 0 ? 0 : parserOptions.minRepresentationBitrate;
    const { serverSyncInfos } = parserOptions;
    const serverTimeOffset = serverSyncInfos !== void 0 ? serverSyncInfos.serverTimestamp - serverSyncInfos.clientTime : void 0;
    function parseQualityLevel(q, streamType) {
      const customAttributes = reduceChildren(
        q,
        (acc, qName, qNode) => {
          if (qName === "CustomAttributes") {
            acc.push(
              ...reduceChildren(
                qNode,
                (cAttrs, cName, cNode) => {
                  if (cName === "Attribute") {
                    const name2 = cNode.getAttribute("Name");
                    const value = cNode.getAttribute("Value");
                    if (name2 !== null && value !== null) {
                      cAttrs.push(name2 + "=" + value);
                    }
                  }
                  return cAttrs;
                },
                []
              )
            );
          }
          return acc;
        },
        []
      );
      function getAttribute(name2) {
        const attr = q.getAttribute(name2);
        return attr === null ? void 0 : attr;
      }
      switch (streamType) {
        case "audio": {
          const audiotag = getAttribute("AudioTag");
          const bitsPerSample = getAttribute("BitsPerSample");
          const channels = getAttribute("Channels");
          const codecPrivateData = getAttribute("CodecPrivateData");
          const fourCC = getAttribute("FourCC");
          const packetSize = getAttribute("PacketSize");
          const samplingRate = getAttribute("SamplingRate");
          const bitrateAttr = getAttribute("Bitrate");
          let bitrate = bitrateAttr === void 0 ? 0 : parseInt(bitrateAttr, 10);
          bitrate = isNaN(bitrate) ? 0 : bitrate;
          if (fourCC !== void 0 && MIME_TYPES[fourCC] === void 0 || codecPrivateData === void 0) {
            log_default.warn("Smooth parser: Unsupported audio codec. Ignoring quality level.");
            return null;
          }
          const codecs = getAudioCodecs(codecPrivateData, fourCC);
          return {
            audiotag: audiotag !== void 0 ? parseInt(audiotag, 10) : audiotag,
            bitrate,
            bitsPerSample: bitsPerSample !== void 0 ? parseInt(bitsPerSample, 10) : bitsPerSample,
            channels: channels !== void 0 ? parseInt(channels, 10) : channels,
            codecPrivateData,
            codecs,
            customAttributes,
            mimeType: fourCC !== void 0 ? MIME_TYPES[fourCC] : fourCC,
            packetSize: packetSize !== void 0 ? parseInt(packetSize, 10) : packetSize,
            samplingRate: samplingRate !== void 0 ? parseInt(samplingRate, 10) : samplingRate
          };
        }
        case "video": {
          const codecPrivateData = getAttribute("CodecPrivateData");
          const fourCC = getAttribute("FourCC");
          const width = getAttribute("MaxWidth");
          const height = getAttribute("MaxHeight");
          const bitrateAttr = getAttribute("Bitrate");
          let bitrate = bitrateAttr === void 0 ? 0 : parseInt(bitrateAttr, 10);
          bitrate = isNaN(bitrate) ? 0 : bitrate;
          if (fourCC !== void 0 && MIME_TYPES[fourCC] === void 0 || codecPrivateData === void 0) {
            log_default.warn("Smooth parser: Unsupported video codec. Ignoring quality level.");
            return null;
          }
          const codecs = getVideoCodecs(codecPrivateData);
          return {
            bitrate,
            customAttributes,
            mimeType: fourCC !== void 0 ? MIME_TYPES[fourCC] : fourCC,
            codecPrivateData,
            codecs,
            width: width !== void 0 ? parseInt(width, 10) : void 0,
            height: height !== void 0 ? parseInt(height, 10) : void 0
          };
        }
        case "text": {
          const codecPrivateData = getAttribute("CodecPrivateData");
          const fourCC = getAttribute("FourCC");
          const bitrateAttr = getAttribute("Bitrate");
          let bitrate = bitrateAttr === void 0 ? 0 : parseInt(bitrateAttr, 10);
          bitrate = isNaN(bitrate) ? 0 : bitrate;
          return {
            bitrate,
            customAttributes,
            mimeType: fourCC !== void 0 ? MIME_TYPES[fourCC] : fourCC,
            codecPrivateData: codecPrivateData != null ? codecPrivateData : ""
          };
        }
        default:
          log_default.error("Smooth Parser: Unrecognized StreamIndex type: " + streamType);
          return null;
      }
    }
    function parseAdaptation(args) {
      const {
        root,
        timescale,
        baseUrl,
        protections,
        timeShiftBufferDepth,
        manifestReceivedTime,
        isLive
      } = args;
      const timescaleAttr = root.getAttribute("Timescale");
      let _timescale = timescaleAttr === null ? timescale : +timescaleAttr;
      if (isNaN(_timescale)) {
        _timescale = timescale;
      }
      const typeAttribute = root.getAttribute("Type");
      if (typeAttribute === null) {
        throw new Error("StreamIndex without type.");
      }
      if (!arrayIncludes(SUPPORTED_ADAPTATIONS_TYPE, typeAttribute)) {
        log_default.warn("Smooth Parser: Unrecognized adaptation type:", typeAttribute);
      }
      const adaptationType = typeAttribute;
      const subType = root.getAttribute("Subtype");
      const language = root.getAttribute("Language");
      const UrlAttr = root.getAttribute("Url");
      const UrlPathWithTokens = UrlAttr === null ? "" : UrlAttr;
      if (define_ENVIRONMENT_default.CURRENT_ENV === define_ENVIRONMENT_default.DEV) {
        assert(UrlPathWithTokens !== "");
      }
      const { qualityLevels, cNodes } = reduceChildren(
        root,
        (res, _name, node) => {
          switch (_name) {
            case "QualityLevel": {
              const qualityLevel = parseQualityLevel(node, adaptationType);
              if (qualityLevel === null) {
                return res;
              }
              if (adaptationType !== "video" || qualityLevel.bitrate > minRepresentationBitrate) {
                res.qualityLevels.push(qualityLevel);
              }
              break;
            }
            case "c":
              res.cNodes.push(node);
              break;
          }
          return res;
        },
        { qualityLevels: [], cNodes: [] }
      );
      const sharedSmoothTimeline = new SharedSmoothSegmentTimeline({
        timeline: parseCNodes(cNodes),
        timescale: _timescale,
        timeShiftBufferDepth,
        manifestReceivedTime
      });
      assert(
        qualityLevels.length !== 0,
        "Adaptation should have at least one playable representation."
      );
      const adaptationID = adaptationType + (isNonEmptyString(language) ? "_" + language : "");
      const representations = qualityLevels.map((qualityLevel) => {
        const media = replaceRepresentationSmoothTokens(
          UrlPathWithTokens,
          qualityLevel.bitrate,
          qualityLevel.customAttributes
        );
        const mimeType = isNonEmptyString(qualityLevel.mimeType) ? qualityLevel.mimeType : DEFAULT_MIME_TYPES[adaptationType];
        const codecs = qualityLevel.codecs;
        const id = adaptationID + "_" + (!isNullOrUndefined(adaptationType) ? adaptationType + "-" : "") + (!isNullOrUndefined(mimeType) ? mimeType + "-" : "") + (!isNullOrUndefined(codecs) ? codecs + "-" : "") + String(qualityLevel.bitrate);
        const keyIDs = [];
        let firstProtection;
        if (protections.length > 0) {
          firstProtection = protections[0];
          protections.forEach((protection) => {
            keyIDs.push(protection.keyId);
          });
        }
        const segmentPrivateInfos = {
          bitsPerSample: qualityLevel.bitsPerSample,
          channels: qualityLevel.channels,
          codecPrivateData: qualityLevel.codecPrivateData,
          packetSize: qualityLevel.packetSize,
          samplingRate: qualityLevel.samplingRate,
          height: qualityLevel.height,
          width: qualityLevel.width,
          // TODO set multiple protections here
          // instead of the first one
          protection: !isNullOrUndefined(firstProtection) ? {
            keyId: firstProtection.keyId
          } : void 0
        };
        const reprIndex = new SmoothRepresentationIndex({
          isLive,
          sharedSmoothTimeline,
          media,
          segmentPrivateInfos
        });
        const representation = object_assign_default({}, qualityLevel, {
          index: reprIndex,
          cdnMetadata: [{ baseUrl }],
          mimeType,
          codecs,
          id
        });
        if (keyIDs.length > 0 || firstProtection !== void 0) {
          const initDataValues = firstProtection === void 0 ? [] : firstProtection.keySystems.map((keySystemData) => {
            const { systemId, privateData } = keySystemData;
            const cleanedSystemId = systemId.replace(/-/g, "");
            const pssh = createPSSHBox(cleanedSystemId, privateData);
            return { systemId: cleanedSystemId, data: pssh };
          });
          if (initDataValues.length > 0) {
            const initData = [{ type: "cenc", values: initDataValues }];
            representation.contentProtections = { keyIds: keyIDs, initData };
          } else {
            representation.contentProtections = { keyIds: keyIDs, initData: [] };
          }
        }
        return representation;
      });
      if (subType === "ADVT") {
        return null;
      }
      const parsedAdaptation = {
        id: adaptationID,
        type: adaptationType,
        representations,
        language: language === null ? void 0 : language
      };
      if (adaptationType === "text" && subType === "DESC") {
        parsedAdaptation.closedCaption = true;
      }
      return parsedAdaptation;
    }
    function parseFromDocument2(doc, url, manifestReceivedTime) {
      let baseUrl = "";
      if (url !== void 0) {
        const filenameIdx = getFilenameIndexInUrl(url);
        baseUrl = url.substring(0, filenameIdx);
      }
      const root = doc.documentElement;
      if (isNullOrUndefined(root) || root.nodeName !== "SmoothStreamingMedia") {
        throw new Error("document root should be SmoothStreamingMedia");
      }
      const majorVersionAttr = root.getAttribute("MajorVersion");
      const minorVersionAttr = root.getAttribute("MinorVersion");
      if (majorVersionAttr === null || minorVersionAttr === null || !/^[2]-[0-2]$/.test(majorVersionAttr + "-" + minorVersionAttr)) {
        throw new Error("Version should be 2.0, 2.1 or 2.2");
      }
      const timescaleAttr = root.getAttribute("Timescale");
      let timescale = !isNonEmptyString(timescaleAttr) ? 1e7 : +timescaleAttr;
      if (isNaN(timescale)) {
        timescale = 1e7;
      }
      const { protections, adaptationNodes } = reduceChildren(
        root,
        (res, name2, node) => {
          switch (name2) {
            case "Protection": {
              res.protections.push(parseProtectionNode(node, parserOptions.keySystems));
              break;
            }
            case "StreamIndex":
              res.adaptationNodes.push(node);
              break;
          }
          return res;
        },
        {
          adaptationNodes: [],
          protections: []
        }
      );
      const initialAdaptations = {};
      const isLive = parseBoolean2(root.getAttribute("IsLive"));
      let timeShiftBufferDepth;
      if (isLive) {
        const dvrWindowLength = root.getAttribute("DVRWindowLength");
        if (dvrWindowLength !== null && !isNaN(+dvrWindowLength) && +dvrWindowLength !== 0) {
          timeShiftBufferDepth = +dvrWindowLength / timescale;
        }
      }
      const adaptations = adaptationNodes.reduce(
        (acc, node) => {
          const adaptation = parseAdaptation({
            root: node,
            baseUrl,
            timescale,
            protections,
            isLive,
            timeShiftBufferDepth,
            manifestReceivedTime
          });
          if (adaptation === null) {
            return acc;
          }
          const type = adaptation.type;
          const adaps = acc[type];
          if (adaps === void 0) {
            acc[type] = [adaptation];
          } else {
            adaps.push(adaptation);
          }
          return acc;
        },
        initialAdaptations
      );
      let suggestedPresentationDelay;
      let availabilityStartTime;
      let minimumTime;
      let timeshiftDepth = null;
      let maximumTimeData;
      const firstVideoAdaptation = adaptations.video !== void 0 ? adaptations.video[0] : void 0;
      const firstAudioAdaptation = adaptations.audio !== void 0 ? adaptations.audio[0] : void 0;
      let safeMinimumTime;
      let safeMaximumTime;
      let unsafeMaximumTime;
      if (firstVideoAdaptation !== void 0 || firstAudioAdaptation !== void 0) {
        const firstTimeReferences = [];
        const lastTimeReferences = [];
        if (firstVideoAdaptation !== void 0) {
          const firstVideoRepresentation = firstVideoAdaptation.representations[0];
          if (firstVideoRepresentation !== void 0) {
            const firstVideoTimeReference = firstVideoRepresentation.index.getFirstAvailablePosition();
            const lastVideoTimeReference = firstVideoRepresentation.index.getLastAvailablePosition();
            if (!isNullOrUndefined(firstVideoTimeReference)) {
              firstTimeReferences.push(firstVideoTimeReference);
            }
            if (!isNullOrUndefined(lastVideoTimeReference)) {
              lastTimeReferences.push(lastVideoTimeReference);
            }
          }
        }
        if (firstAudioAdaptation !== void 0) {
          const firstAudioRepresentation = firstAudioAdaptation.representations[0];
          if (firstAudioRepresentation !== void 0) {
            const firstAudioTimeReference = firstAudioRepresentation.index.getFirstAvailablePosition();
            const lastAudioTimeReference = firstAudioRepresentation.index.getLastAvailablePosition();
            if (!isNullOrUndefined(firstAudioTimeReference)) {
              firstTimeReferences.push(firstAudioTimeReference);
            }
            if (!isNullOrUndefined(lastAudioTimeReference)) {
              lastTimeReferences.push(lastAudioTimeReference);
            }
          }
        }
        if (firstTimeReferences.length > 0) {
          safeMinimumTime = Math.max(...firstTimeReferences);
        }
        if (lastTimeReferences.length > 0) {
          safeMaximumTime = Math.min(...lastTimeReferences);
          unsafeMaximumTime = Math.max(...lastTimeReferences);
        }
      }
      const manifestDuration = root.getAttribute("Duration");
      const duration = manifestDuration !== null && +manifestDuration !== 0 ? +manifestDuration / timescale : void 0;
      if (isLive) {
        suggestedPresentationDelay = parserOptions.suggestedPresentationDelay;
        availabilityStartTime = referenceDateTime;
        minimumTime = safeMinimumTime != null ? safeMinimumTime : availabilityStartTime;
        let livePosition = unsafeMaximumTime;
        if (livePosition === void 0) {
          livePosition = Date.now() / 1e3 - availabilityStartTime;
        }
        let maximumSafePosition = safeMaximumTime;
        if (maximumSafePosition === void 0) {
          maximumSafePosition = livePosition;
        }
        maximumTimeData = {
          isLinear: true,
          maximumSafePosition,
          livePosition,
          time: monotonic_timestamp_default()
        };
        timeshiftDepth = timeShiftBufferDepth != null ? timeShiftBufferDepth : null;
      } else {
        minimumTime = safeMinimumTime != null ? safeMinimumTime : 0;
        let maximumTime = safeMaximumTime;
        if (maximumTime === void 0) {
          maximumTime = duration !== void 0 ? minimumTime + duration : Infinity;
        }
        maximumTimeData = {
          isLinear: false,
          maximumSafePosition: maximumTime,
          livePosition: void 0,
          time: monotonic_timestamp_default()
        };
      }
      const periodStart = isLive ? 0 : minimumTime;
      const periodEnd = isLive ? void 0 : maximumTimeData.maximumSafePosition;
      const manifest = {
        availabilityStartTime: availabilityStartTime === void 0 ? 0 : availabilityStartTime,
        clockOffset: serverTimeOffset,
        isLive,
        isDynamic: isLive,
        isLastPeriodKnown: true,
        timeBounds: {
          minimumSafePosition: minimumTime,
          timeshiftDepth,
          maximumTimeData
        },
        periods: [
          {
            adaptations,
            duration: periodEnd !== void 0 ? periodEnd - periodStart : duration,
            end: periodEnd,
            id: "gen-smooth-period-0",
            start: periodStart,
            thumbnailTracks: []
          }
        ],
        suggestedPresentationDelay,
        transportType: "smooth",
        uris: isNullOrUndefined(url) ? [] : [url]
      };
      checkManifestIDs(manifest);
      return manifest;
    }
    return parseFromDocument2;
  }
  function createPSSHBox(systemId, privateData) {
    if (systemId.length !== 32) {
      throw new Error("HSS: wrong system id length");
    }
    const version2 = 0;
    return createBox(
      "pssh",
      concat(
        [version2, 0, 0, 0],
        hexToBytes(systemId),
        /** To put there KIDs if it exists (necessitate PSSH v1) */
        itobe4(privateData.length),
        privateData
      )
    );
  }
  var create_parser_default = createSmoothStreamingParser;

  // src/parsers/manifest/smooth/index.ts
  var smooth_default = create_parser_default;

  // src/transports/smooth/extract_timings_infos.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/transports/smooth/isobmff/index.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/transports/smooth/isobmff/create_audio_init_segment.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/transports/smooth/isobmff/create_boxes.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function createAVC1Box(width, height, hRes, vRes, encName, colorDepth, avcc) {
    return createBox(
      "avc1",
      concat(
        6,
        // 6 bytes reserved
        itobe2(1),
        16,
        // drefIdx + QuickTime reserved, zeroes
        itobe2(width),
        // size 2 w
        itobe2(height),
        // size 2 h
        itobe2(hRes),
        2,
        // reso 4 h
        itobe2(vRes),
        2 + 4,
        // reso 4 v + QuickTime reserved, zeroes
        [0, 1, encName.length],
        // frame count (default 1)
        strToUtf8(encName),
        // 1byte len + encoder name str
        31 - encName.length,
        // + padding
        itobe2(colorDepth),
        // color depth
        [255, 255],
        // reserved ones
        avcc
        // avcc atom,
      )
    );
  }
  function createENCVBox(width, height, hRes, vRes, encName, colorDepth, avcc, sinf) {
    return createBox(
      "encv",
      concat(
        6,
        // 6 bytes reserved
        itobe2(1),
        16,
        // drefIdx + QuickTime reserved, zeroes
        itobe2(width),
        // size 2 w
        itobe2(height),
        // size 2 h
        itobe2(hRes),
        2,
        // reso 4 h
        itobe2(vRes),
        2 + 4,
        // reso 4 v + QuickTime reserved, zeroes
        [0, 1, encName.length],
        // frame count (default 1)
        strToUtf8(encName),
        // 1byte len + encoder name str
        31 - encName.length,
        // + padding
        itobe2(colorDepth),
        // color depth
        [255, 255],
        // reserved ones
        avcc,
        // avcc atom,
        sinf
      )
    );
  }
  function createMP4ABox(drefIdx, channelsCount, sampleSize, packetSize, sampleRate, esds) {
    return createBox(
      "mp4a",
      concat(
        6,
        itobe2(drefIdx),
        8,
        itobe2(channelsCount),
        itobe2(sampleSize),
        2,
        itobe2(packetSize),
        itobe2(sampleRate),
        2,
        esds
      )
    );
  }
  function createENCABox(drefIdx, channelsCount, sampleSize, packetSize, sampleRate, esds, sinf) {
    return createBox(
      "enca",
      concat(
        6,
        itobe2(drefIdx),
        8,
        itobe2(channelsCount),
        itobe2(sampleSize),
        2,
        itobe2(packetSize),
        itobe2(sampleRate),
        2,
        esds,
        sinf
      )
    );
  }
  function createDREFBox(url) {
    return createBox("dref", concat(7, [1], url));
  }
  function createFTYPBox(majorBrand, brands) {
    const content = concat(
      ...[strToUtf8(majorBrand), [0, 0, 0, 1]].concat(brands.map(strToUtf8))
    );
    return createBox("ftyp", content);
  }
  function createSCHMBox(schemeType, schemeVersion) {
    return createBox("schm", concat(4, strToUtf8(schemeType), itobe4(schemeVersion)));
  }
  function createTfdtBox(decodeTime) {
    return createBox("tfdt", concat([1, 0, 0, 0], itobe8(decodeTime)));
  }
  function createVMHDBox() {
    const arr = new Uint8Array(12);
    arr[3] = 1;
    return createBox("vmhd", arr);
  }
  function createTREXBox(trackId) {
    return createBox("trex", concat(4, itobe4(trackId), [0, 0, 0, 1], 12));
  }
  function createFreeBox(length) {
    return createBox("free", new Uint8Array(length - 8));
  }
  function createESDSBox(stream, codecPrivateData) {
    return createBox(
      "esds",
      concat(
        4,
        [3, 25],
        itobe2(stream),
        [0, 4, 17, 64, 21],
        11,
        [5, 2],
        hexToBytes(codecPrivateData),
        [6, 1, 2]
      )
    );
  }
  function createFRMABox(dataFormat) {
    return createBox("frma", strToUtf8(dataFormat));
  }
  function createAVCCBox(sps, pps, nalLen) {
    let nal;
    if (nalLen === 2) {
      nal = 1;
    } else if (nalLen === 4) {
      nal = 3;
    } else {
      nal = 0;
    }
    const h264Profile = sps[1];
    const h264CompatibleProfile = sps[2];
    const h264Level = sps[3];
    return createBox(
      "avcC",
      concat(
        [1, h264Profile, h264CompatibleProfile, h264Level, 63 << 2 | nal, 224 | 1],
        itobe2(sps.length),
        sps,
        [1],
        itobe2(pps.length),
        pps
      )
    );
  }
  function createHDLRBox(type) {
    let name2;
    let handlerName;
    switch (type) {
      case "video":
        name2 = "vide";
        handlerName = "VideoHandler";
        break;
      case "audio":
        name2 = "soun";
        handlerName = "SoundHandler";
        break;
      default:
        name2 = "hint";
        handlerName = "";
        break;
    }
    return createBox(
      "hdlr",
      concat(
        8,
        strToUtf8(name2),
        12,
        strToUtf8(handlerName),
        1
        // handler name is C-style string (0 terminated)
      )
    );
  }
  function createMDHDBox(timescale) {
    return createBox("mdhd", concat(12, itobe4(timescale), 8));
  }
  function createMVHDBox(timescale, trackId) {
    return createBox(
      "mvhd",
      concat(
        12,
        itobe4(timescale),
        4,
        [0, 1],
        2,
        // we assume rate = 1;
        [1, 0],
        10,
        // we assume volume = 100%;
        [0, 1],
        14,
        // default matrix
        [0, 1],
        14,
        // default matrix
        [64, 0, 0, 0],
        26,
        itobe2(trackId + 1)
        // next trackId (=trackId + 1);
      )
    );
  }
  function createSAIOBox(mfhd, tfhd, tfdt, trun) {
    return createBox(
      "saio",
      concat(
        4,
        [0, 0, 0, 1],
        // ??
        itobe4(mfhd.length + tfhd.length + tfdt.length + trun.length + 8 + 8 + 8 + 8)
      )
    );
  }
  function createSAIZBox(sencContent) {
    if (sencContent.length === 0) {
      return createBox("saiz", new Uint8Array(0));
    }
    const flags = be4toi(sencContent, 0);
    const entries = be4toi(sencContent, 4);
    const arr = new Uint8Array(entries + 9);
    arr.set(itobe4(entries), 5);
    let i = 9;
    let j = 8;
    let pairsCnt;
    let pairsLen;
    while (j < sencContent.length) {
      j += 8;
      if ((flags & 2) === 2) {
        pairsLen = 2;
        pairsCnt = be2toi(sencContent, j);
        j += pairsCnt * 6 + 2;
      } else {
        pairsCnt = 0;
        pairsLen = 0;
      }
      arr[i] = pairsCnt * 6 + 8 + pairsLen;
      i++;
    }
    return createBox("saiz", arr);
  }
  function createSMHDBox() {
    return createBox("smhd", new Uint8Array(8));
  }
  function createSTSDBox(reps) {
    const arrBase = [7, [reps.length]];
    return createBox("stsd", concat(...arrBase.concat(reps)));
  }
  function createTKHDBox(width, height, trackId) {
    return createBox(
      "tkhd",
      concat(
        itobe4(1 + 2 + 4),
        8,
        // we assume track is enabled,
        // in media and in preview.
        itobe4(trackId),
        20,
        // we assume trackId = 1;
        [1, 0, 0, 0],
        // we assume volume = 100%;
        [0, 1, 0, 0],
        12,
        // default matrix
        [0, 1, 0, 0],
        12,
        // default matrix
        [64, 0, 0, 0],
        // ??
        itobe2(width),
        2,
        // width (TODO handle fixed)
        itobe2(height),
        2
        // height (TODO handle fixed)
      )
    );
  }
  function createTENCBox(algId, ivSize, keyId) {
    return createBox("tenc", concat(6, [algId, ivSize], keyId));
  }

  // src/transports/smooth/isobmff/create_init_segment.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function createMOOVBox(mvhd, mvex, trak) {
    const children = [mvhd, mvex, trak];
    return createBoxWithChildren("moov", children);
  }
  function createInitSegment(timescale, type, stsd, mhd, width, height) {
    const stbl = createBoxWithChildren("stbl", [
      stsd,
      createBox("stts", new Uint8Array(8)),
      createBox("stsc", new Uint8Array(8)),
      createBox("stsz", new Uint8Array(12)),
      createBox("stco", new Uint8Array(8))
    ]);
    const url = createBox("url ", new Uint8Array([0, 0, 0, 1]));
    const dref = createDREFBox(url);
    const dinf = createBoxWithChildren("dinf", [dref]);
    const minf = createBoxWithChildren("minf", [mhd, dinf, stbl]);
    const hdlr = createHDLRBox(type);
    const mdhd = createMDHDBox(timescale);
    const mdia = createBoxWithChildren("mdia", [mdhd, hdlr, minf]);
    const tkhd = createTKHDBox(width, height, 1);
    const trak = createBoxWithChildren("trak", [tkhd, mdia]);
    const trex = createTREXBox(1);
    const mvex = createBoxWithChildren("mvex", [trex]);
    const mvhd = createMVHDBox(timescale, 1);
    const moov = createMOOVBox(mvhd, mvex, trak);
    const ftyp = createFTYPBox("isom", ["isom", "iso2", "iso6", "avc1", "dash"]);
    return concat(ftyp, moov);
  }

  // src/transports/smooth/isobmff/get_aaces_header.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var SAMPLING_FREQUENCIES = [
    96e3,
    88200,
    64e3,
    48e3,
    44100,
    32e3,
    24e3,
    22050,
    16e3,
    12e3,
    11025,
    8e3,
    7350
  ];
  function getAacesHeader(type, frequency, chans) {
    const freq = SAMPLING_FREQUENCIES.indexOf(frequency);
    let val;
    val = (type & 63) << 4;
    val = (val | freq & 31) << 4;
    val = (val | chans & 31) << 3;
    return bytesToHex(itobe2(val));
  }

  // src/transports/smooth/isobmff/create_audio_init_segment.ts
  function createAudioInitSegment(timescale, channelsCount, sampleSize, packetSize, sampleRate, codecPrivateData, keyId) {
    const _codecPrivateData = codecPrivateData.length === 0 ? getAacesHeader(2, sampleRate, channelsCount) : codecPrivateData;
    const esds = createESDSBox(1, _codecPrivateData);
    const stsd = (() => {
      if (keyId === void 0) {
        const mp4a = createMP4ABox(
          1,
          channelsCount,
          sampleSize,
          packetSize,
          sampleRate,
          esds
        );
        return createSTSDBox([mp4a]);
      }
      const tenc = createTENCBox(1, 8, keyId);
      const schi = createBoxWithChildren("schi", [tenc]);
      const schm = createSCHMBox("cenc", 65536);
      const frma = createFRMABox("mp4a");
      const sinf = createBoxWithChildren("sinf", [frma, schm, schi]);
      const enca = createENCABox(
        1,
        channelsCount,
        sampleSize,
        packetSize,
        sampleRate,
        esds,
        sinf
      );
      return createSTSDBox([enca]);
    })();
    return createInitSegment(timescale, "audio", stsd, createSMHDBox(), 0, 0);
  }

  // src/transports/smooth/isobmff/create_video_init_segment.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function createVideoInitSegment(timescale, width, height, hRes, vRes, nalLength, codecPrivateData, keyId) {
    const [, spsHex, ppsHex] = codecPrivateData.split("00000001");
    if (spsHex === void 0 || ppsHex === void 0) {
      throw new Error("Smooth: unsupported codec private data.");
    }
    const sps = hexToBytes(spsHex);
    const pps = hexToBytes(ppsHex);
    const avcc = createAVCCBox(sps, pps, nalLength);
    let stsd;
    if (keyId === void 0) {
      const avc1 = createAVC1Box(width, height, hRes, vRes, "AVC Coding", 24, avcc);
      stsd = createSTSDBox([avc1]);
    } else {
      const tenc = createTENCBox(1, 8, keyId);
      const schi = createBoxWithChildren("schi", [tenc]);
      const schm = createSCHMBox("cenc", 65536);
      const frma = createFRMABox("avc1");
      const sinf = createBoxWithChildren("sinf", [frma, schm, schi]);
      const encv = createENCVBox(width, height, hRes, vRes, "AVC Coding", 24, avcc, sinf);
      stsd = createSTSDBox([encv]);
    }
    return createInitSegment(timescale, "video", stsd, createVMHDBox(), width, height);
  }

  // src/transports/smooth/isobmff/parse_tfrf.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function parseTfrf(traf) {
    const tfrf = getUuidContent(traf, 3565190898, 3392751253, 2387879627, 2655430559);
    if (tfrf === void 0) {
      return [];
    }
    const frags = [];
    const version2 = tfrf[0];
    const fragCount = tfrf[4];
    for (let i = 0; i < fragCount; i++) {
      let duration;
      let time;
      if (version2 === 1) {
        time = be8toi(tfrf, i * 16 + 5);
        duration = be8toi(tfrf, i * 16 + 5 + 8);
      } else {
        time = be4toi(tfrf, i * 8 + 5);
        duration = be4toi(tfrf, i * 8 + 5 + 4);
      }
      frags.push({
        time,
        duration
      });
    }
    return frags;
  }

  // src/transports/smooth/isobmff/parse_tfxd.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function parseTfxd(traf) {
    const tfxd = getUuidContent(traf, 1830656773, 1121273062, 2162299933, 2952222642);
    if (tfxd === void 0) {
      return void 0;
    }
    return {
      duration: be8toi(tfxd, 12),
      time: be8toi(tfxd, 4)
    };
  }

  // src/transports/smooth/isobmff/patch_segment.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/compat/can_patch_isobmff.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function canPatchISOBMFFSegment() {
    return !isIEOrEdge;
  }

  // src/transports/smooth/isobmff/create_traf_box.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function createTrafBox(tfhd, tfdt, trun, mfhd, senc) {
    const trafs = [tfhd, tfdt, trun];
    if (senc !== void 0) {
      trafs.push(
        createBox("senc", senc),
        createSAIZBox(senc),
        createSAIOBox(mfhd, tfhd, tfdt, trun)
      );
    }
    return createBoxWithChildren("traf", trafs);
  }

  // src/transports/smooth/isobmff/patch_segment.ts
  function patchSegment(segment, decodeTime) {
    const oldMoofOffsets = getBoxOffsets(
      segment,
      1836019558
      /* moof */
    );
    if (oldMoofOffsets === null) {
      throw new Error("Smooth: Invalid ISOBMFF given");
    }
    const oldMoofContent = segment.subarray(oldMoofOffsets[1], oldMoofOffsets[2]);
    const mfhdBox = getBox(
      oldMoofContent,
      1835427940
      /* mfhd */
    );
    const trafContent = getBoxContent(
      oldMoofContent,
      1953653094
      /* traf */
    );
    if (trafContent === null || mfhdBox === null) {
      throw new Error("Smooth: Invalid ISOBMFF given");
    }
    const tfhdOffsets = getBoxOffsets(
      trafContent,
      1952868452
      /* tfhd */
    );
    const oldTrunOffsets = getBoxOffsets(
      trafContent,
      1953658222
      /* trun */
    );
    if (tfhdOffsets === null || oldTrunOffsets === null) {
      throw new Error("Smooth: Invalid ISOBMFF given");
    }
    const tfhdBox = trafContent.subarray(tfhdOffsets[0], tfhdOffsets[2]);
    const oldTrunBox = trafContent.subarray(oldTrunOffsets[0], oldTrunOffsets[2]);
    tfhdBox.set(
      [0, 0, 0, 1],
      tfhdOffsets[1] - tfhdOffsets[0] + 4
      /* version + flags */
    );
    const tfdtBox = createTfdtBox(decodeTime);
    const newTrunBox = updateTrunDataOffset(
      oldTrunBox,
      oldTrunOffsets[1] - oldTrunOffsets[0]
    );
    const sencContent = getUuidContent(
      trafContent,
      2721664850,
      1520127764,
      2722393154,
      2086964724
    );
    const newTrafBox = createTrafBox(tfhdBox, tfdtBox, newTrunBox, mfhdBox, sencContent);
    const newMoof = createBoxWithChildren("moof", [mfhdBox, newTrafBox]);
    const newMoofOffsets = getBoxOffsets(
      newMoof,
      1836019558
      /* moof */
    );
    const newTrafOffsets = getBoxOffsets(
      newTrafBox,
      1953653094
      /* traf */
    );
    const newTrunOffsets = getBoxOffsets(
      newTrunBox,
      1953658222
      /* trun */
    );
    if (newMoofOffsets === null || newTrafOffsets === null || newTrunOffsets === null) {
      throw new Error("Smooth: Invalid moof, trun or traf generation");
    }
    const indexOfTrunDataOffsetInMoof = newMoofOffsets[1] - newMoofOffsets[0] + mfhdBox.length + /* new traf size + name */
    (newTrafOffsets[1] - newTrafOffsets[0]) + tfhdBox.length + tfdtBox.length + /* new trun size + name */
    (newTrunOffsets[1] - newTrunOffsets[0]) + 8;
    const oldMoofLength = oldMoofOffsets[2] - oldMoofOffsets[0];
    const newMoofSizeDiff = newMoof.length - oldMoofLength;
    const oldMdatOffset = getBoxOffsets(
      segment,
      1835295092
      /* "mdat" */
    );
    if (oldMdatOffset === null) {
      throw new Error("Smooth: Invalid ISOBMFF given");
    }
    if (canPatchISOBMFFSegment() && (newMoofSizeDiff === 0 || newMoofSizeDiff <= -8)) {
      const mdatContentOffset = oldMdatOffset[1];
      newMoof.set(itobe4(mdatContentOffset), indexOfTrunDataOffsetInMoof);
      segment.set(newMoof, oldMoofOffsets[0]);
      if (newMoofSizeDiff <= -8) {
        segment.set(createFreeBox(-newMoofSizeDiff), newMoof.length);
      }
      return segment;
    } else {
      const mdatContentOffset = oldMdatOffset[1] + newMoofSizeDiff;
      newMoof.set(itobe4(mdatContentOffset), indexOfTrunDataOffsetInMoof);
      const newSegment = new Uint8Array(segment.length + newMoofSizeDiff);
      const beforeMoof = segment.subarray(0, oldMoofOffsets[0]);
      const afterMoof = segment.subarray(oldMoofOffsets[2], segment.length);
      newSegment.set(beforeMoof, 0);
      newSegment.set(newMoof, beforeMoof.length);
      newSegment.set(afterMoof, beforeMoof.length + newMoof.length);
      return newSegment;
    }
  }
  function updateTrunDataOffset(oldTrunBox, initialDataOffset) {
    const trunHasDataOffset = (oldTrunBox[
      initialDataOffset + 3
      /* last flag */
    ] & 1) > 0;
    if (trunHasDataOffset) {
      return oldTrunBox;
    }
    const newTrunBox = new Uint8Array(oldTrunBox.length + 4);
    newTrunBox.set(oldTrunBox.subarray(0, initialDataOffset + 8), 0);
    newTrunBox[initialDataOffset + 3] = newTrunBox[initialDataOffset + 3] | 1;
    newTrunBox.set([0, 0, 0, 0], initialDataOffset + 8);
    newTrunBox.set(
      oldTrunBox.subarray(initialDataOffset + 8, oldTrunBox.length),
      initialDataOffset + 12
    );
    return updateBoxLength(newTrunBox);
  }

  // src/transports/smooth/extract_timings_infos.ts
  function extractTimingsInfos(data2, isChunked, initTimescale, segment, isLive) {
    var _a;
    const nextSegments = [];
    let chunkInfos;
    let tfxdSegment;
    let tfrfSegments;
    if (isLive) {
      const traf = getTRAF(data2);
      if (traf !== null) {
        tfrfSegments = parseTfrf(traf);
        tfxdSegment = parseTfxd(traf);
      } else {
        log_default.warn("smooth: could not find traf atom");
      }
    }
    if (tfrfSegments !== void 0) {
      for (const tfrfSeg of tfrfSegments) {
        nextSegments.push({
          time: tfrfSeg.time,
          duration: tfrfSeg.duration,
          timescale: initTimescale
        });
      }
    }
    if (tfxdSegment !== void 0) {
      chunkInfos = {
        time: tfxdSegment.time / initTimescale,
        duration: tfxdSegment.duration / initTimescale
      };
      return { nextSegments, chunkInfos, scaledSegmentTime: tfxdSegment.time };
    }
    if (isChunked || !segment.complete) {
      return { nextSegments, chunkInfos: null, scaledSegmentTime: void 0 };
    }
    const segmentDuration = segment.duration * initTimescale;
    const maxDecodeTimeDelta = Math.min(initTimescale * 0.9, segmentDuration / 4);
    const trunDuration = getDurationFromTrun(data2);
    const scaledSegmentTime = ((_a = segment.privateInfos) == null ? void 0 : _a.smoothMediaSegment) !== void 0 ? segment.privateInfos.smoothMediaSegment.time : Math.round(segment.time * initTimescale);
    if (trunDuration !== void 0 && Math.abs(trunDuration - segmentDuration) <= maxDecodeTimeDelta) {
      chunkInfos = { time: segment.time, duration: trunDuration / initTimescale };
    } else {
      chunkInfos = { time: segment.time, duration: segment.duration };
    }
    return { nextSegments, chunkInfos, scaledSegmentTime };
  }

  // src/transports/smooth/is_mp4_embedded_track.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function isMP4EmbeddedTrack(mimeType) {
    return typeof mimeType === "string" && mimeType.indexOf("mp4") >= 0;
  }

  // src/transports/smooth/segment_loader.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  async function regularSegmentLoader2(initialUrl, context, callbacks, loaderOptions, cancelSignal, checkMediaSegmentIntegrity) {
    var _a, _b;
    const cmcdHeaders = ((_a = loaderOptions.cmcdPayload) == null ? void 0 : _a.type) === "headers" ? loaderOptions.cmcdPayload.value : void 0;
    const range = context.segment.range;
    let headers;
    if (Array.isArray(range)) {
      headers = __spreadProps(__spreadValues({}, cmcdHeaders), {
        Range: byteRange(range)
      });
    } else if (cmcdHeaders !== void 0) {
      headers = cmcdHeaders;
    }
    const url = ((_b = loaderOptions.cmcdPayload) == null ? void 0 : _b.type) === "query" ? addQueryString(initialUrl, loaderOptions.cmcdPayload.value) : initialUrl;
    const data2 = await request_default({
      url,
      responseType: "arraybuffer",
      headers,
      timeout: loaderOptions.timeout,
      connectionTimeout: loaderOptions.connectionTimeout,
      cancelSignal,
      onProgress: callbacks.onProgress
    });
    const isMP4 = isMP4EmbeddedTrack(context.mimeType);
    if (!isMP4 || checkMediaSegmentIntegrity !== true) {
      return { resultType: "segment-loaded", resultData: data2 };
    }
    const dataU8 = new Uint8Array(data2.responseData);
    checkISOBMFFIntegrity(dataU8, context.segment.isInit);
    return {
      resultType: "segment-loaded",
      resultData: __spreadProps(__spreadValues({}, data2), { responseData: dataU8 })
    };
  }
  var generateSegmentLoader2 = ({
    checkMediaSegmentIntegrity,
    segmentLoader
  }) => (url, context, loaderOptions, cancelSignal, callbacks) => {
    const { segment } = context;
    if (segment.isInit) {
      if (segment.privateInfos === void 0 || segment.privateInfos.smoothInitSegment === void 0) {
        throw new Error("Smooth: Invalid segment format");
      }
      const smoothInitPrivateInfos = segment.privateInfos.smoothInitSegment;
      let responseData;
      const {
        codecPrivateData,
        timescale,
        height,
        width,
        protection = { keyId: void 0, keySystems: void 0 }
      } = smoothInitPrivateInfos;
      if (codecPrivateData === void 0) {
        throw new Error("Smooth: no codec private data.");
      }
      switch (context.type) {
        case "video": {
          responseData = createVideoInitSegment(
            timescale,
            width != null ? width : 0,
            height != null ? height : 0,
            72,
            72,
            4,
            // vRes, hRes, nal
            codecPrivateData,
            protection.keyId
          );
          break;
        }
        case "audio": {
          const {
            channels = 0,
            bitsPerSample = 0,
            packetSize = 0,
            samplingRate = 0
          } = smoothInitPrivateInfos;
          responseData = createAudioInitSegment(
            timescale,
            channels,
            bitsPerSample,
            packetSize,
            samplingRate,
            codecPrivateData,
            protection.keyId
          );
          break;
        }
        default:
          if (define_ENVIRONMENT_default.CURRENT_ENV === define_ENVIRONMENT_default.DEV) {
            assert(false, "responseData should have been set");
          }
          responseData = new Uint8Array(0);
      }
      return Promise.resolve({
        resultType: "segment-created",
        resultData: responseData
      });
    } else if (url === null) {
      return Promise.resolve({
        resultType: "segment-created",
        resultData: null
      });
    } else {
      if (typeof segmentLoader !== "function") {
        return regularSegmentLoader2(
          url,
          context,
          callbacks,
          loaderOptions,
          cancelSignal,
          checkMediaSegmentIntegrity
        );
      }
      return new Promise((res, rej) => {
        let hasFinished = false;
        const resolve = (_args) => {
          if (hasFinished || cancelSignal.isCancelled()) {
            return;
          }
          hasFinished = true;
          cancelSignal.deregister(abortCustomLoader);
          const isMP4 = isMP4EmbeddedTrack(context.mimeType);
          if (!isMP4 || checkMediaSegmentIntegrity !== true) {
            res({
              resultType: "segment-loaded",
              resultData: {
                responseData: _args.data,
                size: _args.size,
                requestDuration: _args.duration
              }
            });
          }
          const dataU8 = _args.data instanceof Uint8Array ? _args.data : new Uint8Array(_args.data);
          checkISOBMFFIntegrity(dataU8, context.segment.isInit);
          res({
            resultType: "segment-loaded",
            resultData: {
              responseData: dataU8,
              size: _args.size,
              requestDuration: _args.duration
            }
          });
        };
        const reject = (err) => {
          var _a, _b;
          if (hasFinished || cancelSignal.isCancelled()) {
            return;
          }
          hasFinished = true;
          cancelSignal.deregister(abortCustomLoader);
          const castedErr = err;
          const message = (_a = castedErr == null ? void 0 : castedErr.message) != null ? _a : "Unknown error when fetching a Smooth segment through a custom segmentLoader.";
          const emittedErr = new CustomLoaderError(
            message,
            (_b = castedErr == null ? void 0 : castedErr.canRetry) != null ? _b : false,
            castedErr == null ? void 0 : castedErr.xhr
          );
          rej(emittedErr);
        };
        const progress = (_args) => {
          if (hasFinished || cancelSignal.isCancelled()) {
            return;
          }
          callbacks.onProgress({
            duration: _args.duration,
            size: _args.size,
            totalSize: _args.totalSize
          });
        };
        const fallback = () => {
          if (hasFinished || cancelSignal.isCancelled()) {
            return;
          }
          hasFinished = true;
          cancelSignal.deregister(abortCustomLoader);
          regularSegmentLoader2(
            url,
            context,
            callbacks,
            loaderOptions,
            cancelSignal,
            checkMediaSegmentIntegrity
          ).then(res, rej);
        };
        const customCallbacks = { reject, resolve, fallback, progress };
        let byteRanges;
        if (context.segment.range !== void 0) {
          byteRanges = [context.segment.range];
          if (context.segment.indexRange !== void 0) {
            byteRanges.push(context.segment.indexRange);
          }
        }
        const args = {
          isInit: context.segment.isInit,
          timeout: loaderOptions.timeout,
          byteRanges,
          trackType: context.type,
          url,
          cmcdPayload: loaderOptions.cmcdPayload
        };
        const abort = segmentLoader(args, customCallbacks);
        cancelSignal.register(abortCustomLoader);
        function abortCustomLoader(err) {
          if (hasFinished) {
            return;
          }
          hasFinished = true;
          if (!hasFinished && typeof abort === "function") {
            abort();
          }
          rej(err);
        }
      });
    }
  };
  var segment_loader_default = generateSegmentLoader2;

  // src/transports/smooth/utils.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function constructSegmentUrl2(wantedCdn, segment) {
    if (wantedCdn === null) {
      return null;
    }
    if (segment.url === null) {
      return wantedCdn.baseUrl;
    }
    return resolve_url_default(wantedCdn.baseUrl, segment.url);
  }

  // src/transports/smooth/pipelines.ts
  function pipelines_default2(transportOptions) {
    const smoothManifestParser = smooth_default(transportOptions);
    const segmentLoader = segment_loader_default(transportOptions);
    const manifestLoaderOptions = {
      customManifestLoader: transportOptions.manifestLoader
    };
    const manifestLoader = generateManifestLoader(manifestLoaderOptions, "text", null);
    const manifestPipeline = {
      loadManifest: manifestLoader,
      parseManifest(manifestData, parserOptions) {
        var _a;
        const url = (_a = manifestData.url) != null ? _a : parserOptions.originalUrl;
        const { receivedTime: manifestReceivedTime, responseData } = manifestData;
        const documentData = typeof responseData === "string" ? new DOMParser().parseFromString(responseData, "text/xml") : responseData;
        const parserResult = smoothManifestParser(documentData, url, manifestReceivedTime);
        const warnings = [];
        const manifest = new classes_default(
          parserResult,
          {
            representationFilter: transportOptions.representationFilter
          },
          warnings
        );
        return { manifest, url, warnings };
      }
    };
    const audioVideoPipeline = {
      /**
       * Load a Smooth audio/video segment.
       * @param {Object|null} wantedCdn
       * @param {Object} context
       * @param {Object} loaderOptions
       * @param {Object} cancelSignal
       * @param {Object} callbacks
       * @returns {Promise}
       */
      loadSegment(wantedCdn, context, loaderOptions, cancelSignal, callbacks) {
        const url = constructSegmentUrl2(wantedCdn, context.segment);
        return segmentLoader(url, context, loaderOptions, cancelSignal, callbacks);
      },
      parseSegment(loadedSegment, context, initTimescale) {
        var _a, _b;
        const { segment } = context;
        const { data: data2, isChunked } = loadedSegment;
        if (data2 === null) {
          if (segment.isInit) {
            return {
              segmentType: "init",
              initializationData: null,
              initializationDataSize: 0,
              protectionData: [],
              initTimescale: void 0
            };
          }
          return {
            segmentType: "media",
            chunkData: null,
            chunkInfos: null,
            chunkOffset: 0,
            chunkSize: 0,
            protectionData: [],
            appendWindow: [void 0, void 0]
          };
        }
        const responseBuffer = data2 instanceof Uint8Array ? data2 : new Uint8Array(data2);
        if (segment.isInit) {
          const timescale = (_b = (_a = segment.privateInfos) == null ? void 0 : _a.smoothInitSegment) == null ? void 0 : _b.timescale;
          return {
            segmentType: "init",
            initializationData: data2,
            initializationDataSize: data2.byteLength,
            // smooth init segments are crafted by hand.
            // Their timescale is the one from the manifest.
            initTimescale: timescale,
            protectionData: []
          };
        }
        const timingInfos = initTimescale !== void 0 ? extractTimingsInfos(
          responseBuffer,
          isChunked,
          initTimescale,
          segment,
          context.isLive
        ) : null;
        if (timingInfos === null || timingInfos.chunkInfos === null || timingInfos.scaledSegmentTime === void 0) {
          throw new Error("Smooth Segment without time information");
        }
        const { nextSegments, chunkInfos, scaledSegmentTime } = timingInfos;
        const chunkData = patchSegment(responseBuffer, scaledSegmentTime);
        const predictedSegments = nextSegments.length > 0 ? nextSegments : void 0;
        return {
          segmentType: "media",
          chunkData,
          chunkInfos,
          chunkOffset: 0,
          chunkSize: chunkData.length,
          protectionData: [],
          predictedSegments,
          appendWindow: [void 0, void 0]
        };
      }
    };
    const textTrackPipeline = {
      loadSegment(wantedCdn, context, loaderOptions, cancelSignal, callbacks) {
        var _a, _b, _c, _d;
        const { segment } = context;
        const url = constructSegmentUrl2(wantedCdn, segment);
        if (segment.isInit || url === null) {
          return Promise.resolve({
            resultType: "segment-created",
            resultData: null
          });
        }
        const isMP4 = isMP4EmbeddedTrack(context.mimeType);
        if (!isMP4) {
          return request_default({
            url: ((_a = loaderOptions.cmcdPayload) == null ? void 0 : _a.type) === "query" ? addQueryString(url, loaderOptions.cmcdPayload.value) : url,
            headers: ((_b = loaderOptions.cmcdPayload) == null ? void 0 : _b.type) === "headers" ? loaderOptions.cmcdPayload.value : void 0,
            responseType: "text",
            timeout: loaderOptions.timeout,
            connectionTimeout: loaderOptions.connectionTimeout,
            cancelSignal,
            onProgress: callbacks.onProgress
          }).then((data2) => ({
            resultType: "segment-loaded",
            resultData: data2
          }));
        } else {
          return request_default({
            url: ((_c = loaderOptions.cmcdPayload) == null ? void 0 : _c.type) === "query" ? addQueryString(url, loaderOptions.cmcdPayload.value) : url,
            headers: ((_d = loaderOptions.cmcdPayload) == null ? void 0 : _d.type) === "headers" ? loaderOptions.cmcdPayload.value : void 0,
            responseType: "arraybuffer",
            timeout: loaderOptions.timeout,
            connectionTimeout: loaderOptions.connectionTimeout,
            cancelSignal,
            onProgress: callbacks.onProgress
          }).then((data2) => {
            if (transportOptions.checkMediaSegmentIntegrity !== true) {
              return { resultType: "segment-loaded", resultData: data2 };
            }
            const dataU8 = new Uint8Array(data2.responseData);
            checkISOBMFFIntegrity(dataU8, context.segment.isInit);
            return {
              resultType: "segment-loaded",
              resultData: __spreadProps(__spreadValues({}, data2), { responseData: dataU8 })
            };
          });
        }
      },
      parseSegment(loadedSegment, context, initTimescale) {
        var _a;
        const { segment, language, mimeType = "", codecs = "" } = context;
        const isMP4 = isMP4EmbeddedTrack(context.mimeType);
        const { data: data2, isChunked } = loadedSegment;
        let chunkSize;
        if (segment.isInit) {
          return {
            segmentType: "init",
            initializationData: null,
            initializationDataSize: 0,
            protectionData: [],
            initTimescale: void 0
          };
        }
        if (data2 === null) {
          return {
            segmentType: "media",
            chunkData: null,
            chunkInfos: null,
            chunkOffset: 0,
            chunkSize: 0,
            protectionData: [],
            appendWindow: [void 0, void 0]
          };
        }
        let nextSegments;
        let chunkInfos = null;
        let segmentStart;
        let segmentEnd;
        let _sdData;
        let _sdType;
        if (isMP4) {
          let chunkBytes;
          if (typeof data2 === "string") {
            chunkBytes = strToUtf8(data2);
          } else {
            chunkBytes = data2 instanceof Uint8Array ? data2 : new Uint8Array(data2);
          }
          chunkSize = chunkBytes.length;
          const timingInfos = initTimescale !== void 0 ? extractTimingsInfos(
            chunkBytes,
            isChunked,
            initTimescale,
            segment,
            context.isLive
          ) : null;
          nextSegments = timingInfos == null ? void 0 : timingInfos.nextSegments;
          chunkInfos = (_a = timingInfos == null ? void 0 : timingInfos.chunkInfos) != null ? _a : null;
          if (chunkInfos === null) {
            if (isChunked) {
              log_default.warn("Smooth: Unavailable time data for current text track.");
            } else {
              segmentStart = segment.time;
              segmentEnd = segment.end;
            }
          } else {
            segmentStart = chunkInfos.time;
            segmentEnd = chunkInfos.duration !== void 0 ? chunkInfos.time + chunkInfos.duration : segment.end;
          }
          const lcCodec = codecs.toLowerCase();
          if (mimeType === "application/ttml+xml+mp4" || lcCodec === "stpp" || lcCodec === "stpp.ttml.im1t") {
            _sdType = "ttml";
          } else if (lcCodec === "wvtt") {
            _sdType = "vtt";
          } else {
            throw new Error(`could not find a text-track parser for the type ${mimeType}`);
          }
          const mdat = getMDAT(chunkBytes);
          _sdData = mdat === null ? "" : utf8ToStr(mdat);
        } else {
          segmentStart = segment.time;
          segmentEnd = segment.end;
          let chunkString;
          if (typeof data2 !== "string") {
            const bytesData = data2 instanceof Uint8Array ? data2 : new Uint8Array(data2);
            chunkSize = bytesData.length;
            chunkString = utf8ToStr(bytesData);
          } else {
            chunkString = data2;
          }
          switch (mimeType) {
            case "application/x-sami":
            case "application/smil":
              _sdType = "sami";
              break;
            case "application/ttml+xml":
              _sdType = "ttml";
              break;
            case "text/vtt":
              _sdType = "vtt";
              break;
          }
          if (_sdType === void 0) {
            const lcCodec = codecs.toLowerCase();
            if (lcCodec === "srt") {
              _sdType = "srt";
            } else {
              throw new Error(
                `could not find a text-track parser for the type ${mimeType}`
              );
            }
          }
          _sdData = chunkString;
        }
        const predictedSegments = Array.isArray(nextSegments) && nextSegments.length > 0 ? nextSegments : void 0;
        const chunkOffset = segmentStart != null ? segmentStart : 0;
        return {
          segmentType: "media",
          chunkData: {
            type: _sdType,
            data: _sdData,
            start: segmentStart,
            end: segmentEnd,
            language
          },
          chunkSize,
          chunkInfos,
          chunkOffset,
          protectionData: [],
          predictedSegments,
          appendWindow: [void 0, void 0]
        };
      }
    };
    return {
      transportName: "smooth",
      manifest: manifestPipeline,
      audio: audioVideoPipeline,
      video: audioVideoPipeline,
      text: textTrackPipeline,
      thumbnails: {
        loadThumbnail: () => Promise.reject(new Error("Thumbnail tracks aren't implemented with smooth")),
        parseThumbnail: () => {
          throw new Error("Thumbnail tracks aren't implemented with smooth");
        }
      }
    };
  }

  // src/transports/smooth/index.ts
  var smooth_default2 = pipelines_default2;

  // src/features/list/smooth.ts
  function addSmoothFeature(features2) {
    if (features2.transports.smooth === void 0) {
      features2.transports.smooth = smooth_default2;
    }
    features2.mainThreadMediaSourceInit = MediaSourceContentInitializer;
  }

  // src/experimental/features/index.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/experimental/features/metaplaylist.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/transports/metaplaylist/index.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/transports/metaplaylist/pipelines.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/parsers/manifest/metaplaylist/index.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/parsers/manifest/metaplaylist/metaplaylist_parser.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/parsers/manifest/metaplaylist/representation_index.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var MetaRepresentationIndex = class _MetaRepresentationIndex {
    /**
     * Create a new `MetaRepresentationIndex`.
     * @param {Object} wrappedIndex - "Real" RepresentationIndex implementation of
     * the concerned Representation.
     * @param {Array.<number|undefined>} contentBounds - Start time and end time
     * the Representation will be played between, in seconds.
     * @param {string} transport - Transport for the "real" RepresentationIndex
     * (e.g. "dash" or "smooth").
     * @param {Object} baseContentInfos - Various information about the "real"
     * Representation.
     */
    constructor(wrappedIndex, contentBounds, transport, baseContentInfos) {
      this._wrappedIndex = wrappedIndex;
      this._timeOffset = contentBounds[0];
      this._contentEnd = contentBounds[1];
      this._transport = transport;
      this._baseContentMetadata = baseContentInfos;
    }
    /**
     * Returns information about the initialization segment.
     */
    getInitSegment() {
      const segment = this._wrappedIndex.getInitSegment();
      if (segment === null) {
        return null;
      }
      return this._cloneWithPrivateInfos(segment);
    }
    /**
     * Returns information about the segments asked.
     * @param {number} up - Starting time wanted, in seconds.
     * @param {Number} duration - Amount of time wanted, in seconds
     * @returns {Array.<Object>}
     */
    getSegments(up, duration) {
      return this._wrappedIndex.getSegments(up - this._timeOffset, duration).map((segment) => {
        const clonedSegment = this._cloneWithPrivateInfos(segment);
        clonedSegment.time += this._timeOffset;
        clonedSegment.end += this._timeOffset;
        return clonedSegment;
      });
    }
    /**
     * Whether this RepresentationIndex should be refreshed now.
     * Returns `false` as MetaPlaylist contents do not support underlying live
     * contents yet.
     * @returns {Boolean}
     */
    shouldRefresh() {
      return false;
    }
    /**
     * Returns first possible position the first segment plays at, in seconds.
     * `undefined` if we do not know this value.
     * @return {Number|undefined}
     */
    getFirstAvailablePosition() {
      const wrappedFirstPosition = this._wrappedIndex.getFirstAvailablePosition();
      return !isNullOrUndefined(wrappedFirstPosition) ? wrappedFirstPosition + this._timeOffset : void 0;
    }
    /**
     * Returns last possible position the last segment plays at, in seconds.
     * `undefined` if we do not know this value.
     * @return {Number|undefined}
     */
    getLastAvailablePosition() {
      const wrappedLastPosition = this._wrappedIndex.getLastAvailablePosition();
      return !isNullOrUndefined(wrappedLastPosition) ? wrappedLastPosition + this._timeOffset : void 0;
    }
    /**
     * Returns the absolute end in seconds this RepresentationIndex can reach once
     * all segments are available.
     * @returns {number|null|undefined}
     */
    getEnd() {
      const wrappedEnd = this._wrappedIndex.getEnd();
      return !isNullOrUndefined(wrappedEnd) ? wrappedEnd + this._timeOffset : void 0;
    }
    /**
     * Returns:
     *   - `true` if in the given time interval, at least one new segment is
     *     expected to be available in the future.
     *   - `false` either if all segments in that time interval are already
     *     available for download or if none will ever be available for it.
     *   - `undefined` when it is not possible to tell.
     * @param {number} start
     * @param {number} end
     * @returns {boolean|undefined}
     */
    awaitSegmentBetween(start, end) {
      return this._wrappedIndex.awaitSegmentBetween(
        start - this._timeOffset,
        end - this._timeOffset
      );
    }
    /**
     * Returns `false` if that segment is not currently available in the Manifest
     * (e.g. it corresponds to a segment which is before the current buffer
     * depth).
     * @param {Object} segment
     * @returns {boolean|undefined}
     */
    isSegmentStillAvailable(segment) {
      var _a;
      if (((_a = segment.privateInfos) == null ? void 0 : _a.metaplaylistInfos) === void 0) {
        return false;
      }
      const { originalSegment } = segment.privateInfos.metaplaylistInfos;
      return this._wrappedIndex.isSegmentStillAvailable(originalSegment);
    }
    /**
     * @param {Error} error
     * @param {Object} segment
     * @returns {Boolean}
     */
    canBeOutOfSyncError(error, segment) {
      var _a;
      if (((_a = segment.privateInfos) == null ? void 0 : _a.metaplaylistInfos) === void 0) {
        return false;
      }
      const { originalSegment } = segment.privateInfos.metaplaylistInfos;
      return this._wrappedIndex.canBeOutOfSyncError(error, originalSegment);
    }
    /**
     *
     * @param {Number} time
     * @returns {Number | null}
     */
    checkDiscontinuity(time) {
      return this._wrappedIndex.checkDiscontinuity(time - this._timeOffset);
    }
    /**
     * @returns {Boolean}
     */
    isStillAwaitingFutureSegments() {
      return this._wrappedIndex.isStillAwaitingFutureSegments();
    }
    /**
     * @returns {Boolean}
     */
    isInitialized() {
      return this._wrappedIndex.isInitialized();
    }
    initialize(indexSegments) {
      return this._wrappedIndex.initialize(indexSegments);
    }
    addPredictedSegments(nextSegments, currentSegment) {
      return this._wrappedIndex.addPredictedSegments(nextSegments, currentSegment);
    }
    /**
     * @param {Object} newIndex
     */
    _replace(newIndex) {
      if (!(newIndex instanceof _MetaRepresentationIndex)) {
        throw new Error("A MetaPlaylist can only be replaced with another MetaPlaylist");
      }
      this._wrappedIndex._replace(newIndex._wrappedIndex);
    }
    /**
     * @param {Object} newIndex
     */
    _update(newIndex) {
      if (!(newIndex instanceof _MetaRepresentationIndex)) {
        throw new Error("A MetaPlaylist can only be updated with another MetaPlaylist");
      }
      this._wrappedIndex._update(newIndex._wrappedIndex);
    }
    /**
     * Clone the given segment, presumably coming from its original
     * RepresentationIndex, and add the linked metaplaylist privateInfos to it.
     * Return that cloned and enhanced segment.
     * @param {Object} segment
     * @returns {Object}
     */
    _cloneWithPrivateInfos(segment) {
      const clonedSegment = object_assign_default({}, segment);
      if (clonedSegment.privateInfos === void 0) {
        clonedSegment.privateInfos = {};
      }
      clonedSegment.privateInfos.metaplaylistInfos = {
        transportType: this._transport,
        contentStart: this._timeOffset,
        contentEnd: this._contentEnd,
        originalSegment: segment,
        isLive: this._baseContentMetadata.isLive,
        manifestPublishTime: this._baseContentMetadata.manifestPublishTime,
        periodStart: this._baseContentMetadata.periodStart,
        periodEnd: this._baseContentMetadata.periodEnd
      };
      return clonedSegment;
    }
  };

  // src/parsers/manifest/metaplaylist/metaplaylist_parser.ts
  function parseMetaPlaylist(data2, parserOptions) {
    let parsedData;
    if (typeof data2 === "object" && data2 !== null) {
      parsedData = data2;
    } else if (typeof data2 === "string") {
      try {
        parsedData = JSON.parse(data2);
      } catch (_error) {
        throw new Error("MPL Parser: Bad MetaPlaylist file. Expected JSON.");
      }
    } else {
      throw new Error(
        "MPL Parser: Parser input must be either a string or the MetaPlaylist data directly."
      );
    }
    const { contents, version: version2, type } = parsedData;
    if (type !== "MPL") {
      throw new Error(
        "MPL Parser: Bad MetaPlaylist. The `type` property is not set to `MPL`"
      );
    }
    if (version2 !== "0.1") {
      throw new Error("MPL Parser: Bad MetaPlaylist version");
    }
    if (isNullOrUndefined(contents) || contents.length === 0) {
      throw new Error("MPL Parser: No content found.");
    }
    const ressources = [];
    for (const content of contents) {
      if (isNullOrUndefined(content.url) || isNullOrUndefined(content.startTime) || isNullOrUndefined(content.endTime) || isNullOrUndefined(content.transport)) {
        throw new Error("MPL Parser: Malformed content.");
      }
      ressources.push({ url: content.url, transportType: content.transport });
    }
    const metaPlaylist = parsedData;
    return {
      type: "needs-manifest-loader",
      value: {
        ressources,
        continue: function parseWholeMPL(loadedRessources) {
          const parsedManifest = createManifest(
            metaPlaylist,
            loadedRessources,
            parserOptions
          );
          return { type: "done", value: parsedManifest };
        }
      }
    };
  }
  function createManifest(mplData, manifests, parserOptions) {
    const { url, serverSyncInfos } = parserOptions;
    const clockOffset = serverSyncInfos !== void 0 ? serverSyncInfos.serverTimestamp - serverSyncInfos.clientTime : void 0;
    const generateAdaptationID = idGenerator();
    const generateRepresentationID = idGenerator();
    const { contents } = mplData;
    const minimumTime = contents.length > 0 ? contents[0].startTime : 0;
    const maximumTime = contents.length > 0 ? contents[contents.length - 1].endTime : 0;
    const isDynamic = mplData.dynamic === true;
    let firstStart = null;
    let lastEnd = null;
    const periods = [];
    for (let iMan = 0; iMan < contents.length; iMan++) {
      const content = contents[iMan];
      firstStart = firstStart !== null ? Math.min(firstStart, content.startTime) : content.startTime;
      lastEnd = lastEnd !== null ? Math.max(lastEnd, content.endTime) : content.endTime;
      const currentManifest = manifests[iMan];
      if (currentManifest.periods.length <= 0) {
        continue;
      }
      const contentOffset = content.startTime - currentManifest.periods[0].start;
      const contentEnd = content.endTime;
      const manifestPeriods = [];
      for (let iPer = 0; iPer < currentManifest.periods.length; iPer++) {
        const currentPeriod = currentManifest.periods[iPer];
        const adaptations = SUPPORTED_ADAPTATIONS_TYPE.reduce(
          (acc, type) => {
            const currentAdaptations = currentPeriod.adaptations[type];
            if (isNullOrUndefined(currentAdaptations)) {
              return acc;
            }
            const adaptationsForCurrentType = [];
            for (let iAda = 0; iAda < currentAdaptations.length; iAda++) {
              const currentAdaptation = currentAdaptations[iAda];
              const representations = [];
              for (let iRep = 0; iRep < currentAdaptation.representations.length; iRep++) {
                const currentRepresentation = currentAdaptation.representations[iRep];
                const baseContentMetadata = {
                  isLive: currentManifest.isLive,
                  manifestPublishTime: currentManifest.publishTime,
                  periodStart: currentPeriod.start,
                  periodEnd: currentPeriod.end
                };
                const newIndex = new MetaRepresentationIndex(
                  currentRepresentation.index,
                  [contentOffset, contentEnd],
                  content.transport,
                  baseContentMetadata
                );
                let supplementalCodecs;
                if (currentRepresentation.codecs.length > 1) {
                  if (currentRepresentation.codecs.length > 2) {
                    log_default.warn(
                      "MP: MetaPlaylist relying on more than 2 groups of codecs with retro-compatibility"
                    );
                  }
                  supplementalCodecs = currentRepresentation.codecs[0];
                }
                const codecs = currentRepresentation.codecs[currentRepresentation.codecs.length - 1];
                representations.push({
                  bitrate: currentRepresentation.bitrate,
                  index: newIndex,
                  cdnMetadata: currentRepresentation.cdnMetadata,
                  id: currentRepresentation.id,
                  height: currentRepresentation.height,
                  width: currentRepresentation.width,
                  mimeType: currentRepresentation.mimeType,
                  frameRate: currentRepresentation.frameRate,
                  codecs,
                  supplementalCodecs,
                  isSpatialAudio: currentRepresentation.isSpatialAudio,
                  contentProtections: currentRepresentation.contentProtections
                });
              }
              adaptationsForCurrentType.push({
                id: currentAdaptation.id,
                representations,
                type: currentAdaptation.type,
                audioDescription: currentAdaptation.isAudioDescription,
                closedCaption: currentAdaptation.isClosedCaption,
                isDub: currentAdaptation.isDub,
                language: currentAdaptation.language,
                isSignInterpreted: currentAdaptation.isSignInterpreted
              });
              acc[type] = adaptationsForCurrentType;
            }
            return acc;
          },
          {}
        );
        const textTracks = content.textTracks === void 0 ? [] : content.textTracks;
        const newTextAdaptations = textTracks.map((track) => {
          const adaptationID = "gen-text-ada-" + generateAdaptationID();
          const representationID = "gen-text-rep-" + generateRepresentationID();
          const indexOfFilename = getFilenameIndexInUrl(track.url);
          const cdnUrl = track.url.substring(0, indexOfFilename);
          const filename = track.url.substring(indexOfFilename);
          return {
            id: adaptationID,
            type: "text",
            language: track.language,
            closedCaption: track.closedCaption,
            manuallyAdded: true,
            representations: [
              {
                bitrate: 0,
                cdnMetadata: [{ baseUrl: cdnUrl }],
                id: representationID,
                mimeType: track.mimeType,
                codecs: track.codecs,
                index: new StaticRepresentationIndex({ media: filename })
              }
            ]
          };
        }, []);
        if (newTextAdaptations.length > 0) {
          if (isNullOrUndefined(adaptations.text)) {
            adaptations.text = newTextAdaptations;
          } else {
            adaptations.text.push(...newTextAdaptations);
          }
        }
        const newPeriod = {
          id: formatId(currentManifest.id) + "_" + formatId(currentPeriod.id),
          adaptations,
          duration: currentPeriod.duration,
          start: contentOffset + currentPeriod.start,
          thumbnailTracks: currentPeriod.thumbnailTracks
        };
        manifestPeriods.push(newPeriod);
      }
      for (let i = manifestPeriods.length - 1; i >= 0; i--) {
        const period = manifestPeriods[i];
        if (period.start >= content.endTime) {
          manifestPeriods.splice(i, 1);
        } else if (!isNullOrUndefined(period.duration)) {
          if (period.start + period.duration > content.endTime) {
            period.duration = content.endTime - period.start;
          }
        } else if (i === manifestPeriods.length - 1) {
          period.duration = content.endTime - period.start;
        }
      }
      periods.push(...manifestPeriods);
    }
    const time = monotonic_timestamp_default();
    const isLastPeriodKnown = !isDynamic || mplData.pollInterval === void 0 && (manifests.length <= 0 || manifests[manifests.length - 1].isLastPeriodKnown);
    const manifest = {
      availabilityStartTime: 0,
      clockOffset,
      suggestedPresentationDelay: 10,
      periods,
      transportType: "metaplaylist",
      isLive: isDynamic,
      isDynamic,
      isLastPeriodKnown,
      uris: isNullOrUndefined(url) ? [] : [url],
      // TODO more precize time bounds?
      timeBounds: {
        minimumSafePosition: minimumTime,
        timeshiftDepth: null,
        maximumTimeData: {
          isLinear: false,
          maximumSafePosition: maximumTime,
          livePosition: void 0,
          time
        }
      },
      lifetime: mplData.pollInterval
    };
    return manifest;
  }
  function formatId(str) {
    return str.replace(/_/g, "_");
  }

  // src/parsers/manifest/metaplaylist/index.ts
  var metaplaylist_default = parseMetaPlaylist;

  // src/transports/metaplaylist/manifest_loader.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function regularManifestLoader(initialUrl, loaderOptions, cancelSignal) {
    var _a, _b;
    if (initialUrl === void 0) {
      throw new Error("Cannot perform HTTP(s) request. URL not known");
    }
    const url = ((_a = loaderOptions.cmcdPayload) == null ? void 0 : _a.type) === "query" ? addQueryString(initialUrl, loaderOptions.cmcdPayload.value) : initialUrl;
    return request_default({
      url,
      headers: ((_b = loaderOptions.cmcdPayload) == null ? void 0 : _b.type) === "headers" ? loaderOptions.cmcdPayload.value : void 0,
      responseType: "text",
      timeout: loaderOptions.timeout,
      connectionTimeout: loaderOptions.connectionTimeout,
      cancelSignal
    });
  }
  function generateManifestLoader2({
    customManifestLoader
  }) {
    return typeof customManifestLoader !== "function" ? regularManifestLoader : callCustomManifestLoader(customManifestLoader, regularManifestLoader);
  }

  // src/transports/metaplaylist/pipelines.ts
  function getOriginalContext(mplContext) {
    var _a;
    const { segment } = mplContext;
    if (((_a = segment.privateInfos) == null ? void 0 : _a.metaplaylistInfos) === void 0) {
      throw new Error("MetaPlaylist: missing private infos");
    }
    const { isLive, periodStart, periodEnd, manifestPublishTime } = segment.privateInfos.metaplaylistInfos;
    const { originalSegment } = segment.privateInfos.metaplaylistInfos;
    return {
      segment: originalSegment,
      type: mplContext.type,
      language: mplContext.language,
      mimeType: mplContext.mimeType,
      codecs: mplContext.codecs,
      isLive,
      periodStart,
      periodEnd,
      manifestPublishTime
    };
  }
  function getTransportPipelines(transports, transportName, options) {
    const initialTransport = transports[transportName];
    if (initialTransport !== void 0) {
      return initialTransport;
    }
    const feature = features_default.transports[transportName];
    if (feature === void 0) {
      throw new Error(`MetaPlaylist: Unknown transport ${transportName}.`);
    }
    const transport = feature(options);
    transports[transportName] = transport;
    return transport;
  }
  function getMetaPlaylistPrivateInfos(segment) {
    const { privateInfos } = segment;
    if ((privateInfos == null ? void 0 : privateInfos.metaplaylistInfos) === void 0) {
      throw new Error("MetaPlaylist: Undefined transport for content for metaplaylist.");
    }
    return privateInfos.metaplaylistInfos;
  }
  function pipelines_default3(options) {
    const transports = {};
    const manifestLoader = generateManifestLoader2({
      customManifestLoader: options.manifestLoader
    });
    const otherTransportOptions = object_assign_default({}, options, {
      manifestLoader: void 0
    });
    const manifestPipeline = {
      loadManifest: manifestLoader,
      parseManifest(manifestData, parserOptions, onWarnings, cancelSignal, scheduleRequest) {
        var _a;
        const url = (_a = manifestData.url) != null ? _a : parserOptions.originalUrl;
        const { responseData } = manifestData;
        const mplParserOptions = {
          url,
          serverSyncInfos: options.serverSyncInfos
        };
        const parsed = metaplaylist_default(responseData, mplParserOptions);
        return handleParsedResult(parsed);
        function handleParsedResult(parsedResult) {
          if (parsedResult.type === "done") {
            const warnings = [];
            const manifest = new classes_default(parsedResult.value, options, warnings);
            return Promise.resolve({ manifest, warnings });
          }
          const parsedValue = parsedResult.value;
          const loaderProms = parsedValue.ressources.map((resource) => {
            const transport = getTransportPipelines(
              transports,
              resource.transportType,
              otherTransportOptions
            );
            return scheduleRequest(loadSubManifest).then(
              (data2) => transport.manifest.parseManifest(
                data2,
                __spreadProps(__spreadValues({}, parserOptions), { originalUrl: resource.url }),
                onWarnings,
                cancelSignal,
                scheduleRequest
              )
            );
            function loadSubManifest() {
              const manOpts = {
                timeout: config_default.getCurrent().DEFAULT_REQUEST_TIMEOUT,
                connectionTimeout: config_default.getCurrent().DEFAULT_CONNECTION_TIMEOUT,
                cmcdPayload: void 0
              };
              return transport.manifest.loadManifest(resource.url, manOpts, cancelSignal);
            }
          });
          return Promise.all(loaderProms).then((parsedReqs) => {
            const loadedRessources = parsedReqs.map((e) => e.manifest);
            return handleParsedResult(parsedResult.value.continue(loadedRessources));
          });
        }
      }
    };
    function getTransportPipelinesFromSegment(segment) {
      const { transportType } = getMetaPlaylistPrivateInfos(segment);
      return getTransportPipelines(transports, transportType, otherTransportOptions);
    }
    function offsetTimeInfos(contentOffset, contentEnd, segmentResponse) {
      const offsetedSegmentOffset = segmentResponse.chunkOffset + contentOffset;
      if (isNullOrUndefined(segmentResponse.chunkData)) {
        return {
          chunkInfos: segmentResponse.chunkInfos,
          chunkOffset: offsetedSegmentOffset,
          appendWindow: [void 0, void 0]
        };
      }
      const { chunkInfos, appendWindow } = segmentResponse;
      const offsetedChunkInfos = chunkInfos === null ? null : object_assign_default({}, chunkInfos);
      if (offsetedChunkInfos !== null) {
        offsetedChunkInfos.time += contentOffset;
      }
      const offsetedWindowStart = appendWindow[0] !== void 0 ? Math.max(appendWindow[0] + contentOffset, contentOffset) : contentOffset;
      let offsetedWindowEnd;
      if (appendWindow[1] !== void 0) {
        offsetedWindowEnd = contentEnd !== void 0 ? Math.min(appendWindow[1] + contentOffset, contentEnd) : appendWindow[1] + contentOffset;
      } else if (contentEnd !== void 0) {
        offsetedWindowEnd = contentEnd;
      }
      return {
        chunkInfos: offsetedChunkInfos,
        chunkOffset: offsetedSegmentOffset,
        appendWindow: [offsetedWindowStart, offsetedWindowEnd]
      };
    }
    const audioPipeline = {
      loadSegment(wantedCdn, context, loaderOptions, cancelToken, callbacks) {
        const { segment } = context;
        const { audio } = getTransportPipelinesFromSegment(segment);
        const ogContext = getOriginalContext(context);
        return audio.loadSegment(
          wantedCdn,
          ogContext,
          loaderOptions,
          cancelToken,
          callbacks
        );
      },
      parseSegment(loadedSegment, context, initTimescale) {
        const { segment } = context;
        const { contentStart, contentEnd } = getMetaPlaylistPrivateInfos(segment);
        const { audio } = getTransportPipelinesFromSegment(segment);
        const ogContext = getOriginalContext(context);
        const parsed = audio.parseSegment(loadedSegment, ogContext, initTimescale);
        if (parsed.segmentType === "init") {
          return parsed;
        }
        const timeInfos = offsetTimeInfos(contentStart, contentEnd, parsed);
        return object_assign_default({}, parsed, timeInfos);
      }
    };
    const videoPipeline = {
      loadSegment(wantedCdn, context, loaderOptions, cancelToken, callbacks) {
        const { segment } = context;
        const { video } = getTransportPipelinesFromSegment(segment);
        const ogContext = getOriginalContext(context);
        return video.loadSegment(
          wantedCdn,
          ogContext,
          loaderOptions,
          cancelToken,
          callbacks
        );
      },
      parseSegment(loadedSegment, context, initTimescale) {
        const { segment } = context;
        const { contentStart, contentEnd } = getMetaPlaylistPrivateInfos(segment);
        const { video } = getTransportPipelinesFromSegment(segment);
        const ogContext = getOriginalContext(context);
        const parsed = video.parseSegment(loadedSegment, ogContext, initTimescale);
        if (parsed.segmentType === "init") {
          return parsed;
        }
        const timeInfos = offsetTimeInfos(contentStart, contentEnd, parsed);
        return object_assign_default({}, parsed, timeInfos);
      }
    };
    const textTrackPipeline = {
      loadSegment(wantedCdn, context, loaderOptions, cancelToken, callbacks) {
        const { segment } = context;
        const { text } = getTransportPipelinesFromSegment(segment);
        const ogContext = getOriginalContext(context);
        return text.loadSegment(
          wantedCdn,
          ogContext,
          loaderOptions,
          cancelToken,
          callbacks
        );
      },
      parseSegment(loadedSegment, context, initTimescale) {
        const { segment } = context;
        const { contentStart, contentEnd } = getMetaPlaylistPrivateInfos(segment);
        const { text } = getTransportPipelinesFromSegment(segment);
        const ogContext = getOriginalContext(context);
        const parsed = text.parseSegment(loadedSegment, ogContext, initTimescale);
        if (parsed.segmentType === "init") {
          return parsed;
        }
        const timeInfos = offsetTimeInfos(contentStart, contentEnd, parsed);
        return object_assign_default({}, parsed, timeInfos);
      }
    };
    return {
      transportName: "metaplaylist",
      manifest: manifestPipeline,
      audio: audioPipeline,
      video: videoPipeline,
      text: textTrackPipeline,
      thumbnails: {
        loadThumbnail: () => Promise.reject(
          new Error("Thumbnail tracks aren't implemented with MetaPlaylist")
        ),
        parseThumbnail: () => {
          throw new Error("Thumbnail tracks aren't implemented with MetaPlaylist");
        }
      }
    };
  }

  // src/transports/metaplaylist/index.ts
  var metaplaylist_default2 = pipelines_default3;

  // src/experimental/features/metaplaylist.ts
  function addMetaPlaylistFeature(features2) {
    features2.transports.metaplaylist = metaplaylist_default2;
    features2.mainThreadMediaSourceInit = MediaSourceContentInitializer;
  }

  // src/experimental/features/multi_thread.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/main_thread/init/multi_thread_content_initializer.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/main_thread/init/send_message.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function sendMessage(worker, msg, transferables) {
    log_default.debug("---> Sending to Worker:", msg.type);
    if (transferables === void 0) {
      worker.postMessage(msg);
    } else {
      worker.postMessage(msg, transferables);
    }
  }

  // src/main_thread/init/multi_thread_content_initializer.ts
  var generateContentId2 = idGenerator();
  var MultiThreadContentInitializer = class extends ContentInitializer {
    /**
     * Create a new `MultiThreadContentInitializer`, associated to the given
     * settings.
     * @param {Object} settings
     */
    constructor(settings) {
      super();
      this._settings = settings;
      this._initCanceller = new TaskCanceller();
      this._currentMediaSourceCanceller = new TaskCanceller();
      this._currentMediaSourceCanceller.linkToSignal(this._initCanceller.signal);
      this._currentContentInfo = null;
      this._awaitingRequests = {
        nextRequestId: 0,
        pendingSinkMetrics: /* @__PURE__ */ new Map(),
        pendingThumbnailFetching: /* @__PURE__ */ new Map()
      };
    }
    /**
     * Perform non-destructive preparation steps, to prepare a future content.
     */
    prepare() {
      var _a, _b;
      if (this._currentContentInfo !== null || this._initCanceller.isUsed()) {
        return;
      }
      const contentId = generateContentId2();
      const { adaptiveOptions, transportOptions, worker } = this._settings;
      const { wantedBufferAhead, maxVideoBufferSize, maxBufferAhead, maxBufferBehind } = this._settings.bufferOptions;
      const initialVideoBitrate = adaptiveOptions.initialBitrates.video;
      const initialAudioBitrate = adaptiveOptions.initialBitrates.audio;
      this._currentContentInfo = {
        contentId,
        contentDecryptor: null,
        manifest: null,
        mainThreadMediaSource: null,
        rebufferingController: null,
        streamEventsEmitter: null,
        initialTime: void 0,
        autoPlay: void 0,
        initialPlayPerformed: null
      };
      sendMessage(worker, {
        type: "prepare" /* PrepareContent */,
        value: {
          contentId,
          cmcd: this._settings.cmcd,
          url: this._settings.url,
          hasText: this._hasTextBufferFeature(),
          transportOptions,
          initialVideoBitrate,
          initialAudioBitrate,
          manifestRetryOptions: __spreadProps(__spreadValues({}, this._settings.manifestRequestSettings), {
            lowLatencyMode: this._settings.lowLatencyMode
          }),
          segmentRetryOptions: this._settings.segmentRequestOptions
        }
      });
      this._initCanceller.signal.register(() => {
        sendMessage(worker, {
          type: "stop" /* StopContent */,
          contentId,
          value: null
        });
      });
      if (this._initCanceller.isUsed()) {
        return;
      }
      const throttleVideoBitrate = (_a = adaptiveOptions.throttlers.throttleBitrate.video) != null ? _a : new reference_default(Infinity);
      bindNumberReferencesToWorker(
        worker,
        this._initCanceller.signal,
        [wantedBufferAhead, "wantedBufferAhead"],
        [maxVideoBufferSize, "maxVideoBufferSize"],
        [maxBufferAhead, "maxBufferAhead"],
        [maxBufferBehind, "maxBufferBehind"],
        [throttleVideoBitrate, "throttleVideoBitrate"]
      );
      const limitVideoResolution = (_b = adaptiveOptions.throttlers.limitResolution.video) != null ? _b : new reference_default({
        height: void 0,
        width: void 0,
        pixelRatio: 1
      });
      limitVideoResolution.onUpdate(
        (newVal) => {
          sendMessage(worker, {
            type: "ref-update" /* ReferenceUpdate */,
            value: { name: "limitVideoResolution", newVal }
          });
        },
        { clearSignal: this._initCanceller.signal, emitCurrentValue: true }
      );
    }
    /**
     * Update URL of the Manifest.
     * @param {Array.<string>|undefined} urls - URLs to reach that Manifest from
     * the most prioritized URL to the least prioritized URL.
     * @param {boolean} refreshNow - If `true` the resource in question (e.g.
     * DASH's MPD) will be refreshed immediately.
     */
    updateContentUrls(urls, refreshNow) {
      if (this._currentContentInfo === null) {
        return;
      }
      sendMessage(this._settings.worker, {
        type: "urls-update" /* ContentUrlsUpdate */,
        contentId: this._currentContentInfo.contentId,
        value: { urls, refreshNow }
      });
    }
    /**
     * @param {HTMLMediaElement} mediaElement
     * @param {Object} playbackObserver
     */
    start(mediaElement, playbackObserver) {
      this.prepare();
      if (this._initCanceller.isUsed()) {
        return;
      }
      let textDisplayer = null;
      if (this._settings.textTrackOptions.textTrackMode === "html" && features_default.htmlTextDisplayer !== null) {
        assert(this._hasTextBufferFeature());
        textDisplayer = new features_default.htmlTextDisplayer(
          mediaElement,
          this._settings.textTrackOptions.textTrackElement
        );
      } else if (features_default.nativeTextDisplayer !== null) {
        assert(this._hasTextBufferFeature());
        textDisplayer = new features_default.nativeTextDisplayer(mediaElement);
      } else {
        assert(!this._hasTextBufferFeature());
      }
      this._initCanceller.signal.register(() => {
        textDisplayer == null ? void 0 : textDisplayer.stop();
      });
      listenToMediaError(
        mediaElement,
        (error) => this._onFatalError(error),
        this._initCanceller.signal
      );
      const lastContentProtection = new reference_default(null);
      const mediaSourceStatus = new reference_default(
        0 /* Nothing */
      );
      const { statusRef: drmInitializationStatus, contentDecryptor } = this._initializeContentDecryption(
        mediaElement,
        lastContentProtection,
        mediaSourceStatus,
        () => reloadMediaSource(0, void 0, void 0),
        this._initCanceller.signal
      );
      const contentInfo = this._currentContentInfo;
      if (contentInfo !== null) {
        contentInfo.contentDecryptor = contentDecryptor;
      }
      const playbackStartParams = {
        mediaElement,
        textDisplayer,
        playbackObserver,
        drmInitializationStatus,
        mediaSourceStatus
      };
      mediaSourceStatus.onUpdate(
        (msInitStatus, stopListeningMSStatus) => {
          if (msInitStatus === 2 /* Attached */) {
            stopListeningMSStatus();
            this._startPlaybackIfReady(playbackStartParams);
          }
        },
        { clearSignal: this._initCanceller.signal, emitCurrentValue: true }
      );
      drmInitializationStatus.onUpdate(
        (initializationStatus, stopListeningDrm) => {
          if (initializationStatus.initializationState.type === "initialized") {
            stopListeningDrm();
            this._startPlaybackIfReady(playbackStartParams);
          }
        },
        { emitCurrentValue: true, clearSignal: this._initCanceller.signal }
      );
      const reloadMediaSource = (deltaPosition, minimumPosition, maximumPosition) => {
        var _a;
        const reloadingContentInfo = this._currentContentInfo;
        if (reloadingContentInfo === null) {
          log_default.warn("MTCI: Asked to reload when no content is loaded.");
          return;
        }
        const lastObservation = playbackObserver.getReference().getValue();
        const currentPosition = lastObservation.position.getWanted();
        const isPaused = ((_a = reloadingContentInfo.initialPlayPerformed) == null ? void 0 : _a.getValue()) === true || reloadingContentInfo.autoPlay === void 0 ? lastObservation.paused : !reloadingContentInfo.autoPlay;
        let position = currentPosition + deltaPosition;
        if (minimumPosition !== void 0) {
          position = Math.max(minimumPosition, position);
        }
        if (maximumPosition !== void 0) {
          position = Math.min(maximumPosition, position);
        }
        this._reload(
          mediaElement,
          textDisplayer,
          playbackObserver,
          mediaSourceStatus,
          position,
          !isPaused
        );
      };
      const onmessage = (msg) => {
        var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _A, _B, _C, _D, _E, _F, _G, _H, _I, _J, _K, _L, _M, _N, _O, _P, _Q, _R, _S, _T, _U, _V, _W, _X, _Y, _Z, __;
        const msgData = msg.data;
        switch (msgData.type) {
          case "attach-media-source" /* AttachMediaSource */: {
            if (((_a = this._currentContentInfo) == null ? void 0 : _a.contentId) !== msgData.contentId) {
              return;
            }
            const mediaSourceLink = msgData.value;
            mediaSourceStatus.onUpdate(
              (currStatus, stopListening) => {
                if (currStatus === 1 /* AttachNow */) {
                  stopListening();
                  log_default.info("MTCI: Attaching MediaSource URL to the media element");
                  if (mediaSourceLink.type === "handle") {
                    mediaElement.srcObject = mediaSourceLink.value;
                    this._currentMediaSourceCanceller.signal.register(() => {
                      mediaElement.srcObject = null;
                    });
                  } else {
                    mediaElement.src = mediaSourceLink.value;
                    this._currentMediaSourceCanceller.signal.register(() => {
                      resetMediaElement(mediaElement, mediaSourceLink.value);
                    });
                  }
                  mediaSourceStatus.setValue(2 /* Attached */);
                }
              },
              { emitCurrentValue: true, clearSignal: this._initCanceller.signal }
            );
            break;
          }
          case "warning" /* Warning */:
            if (((_b = this._currentContentInfo) == null ? void 0 : _b.contentId) !== msgData.contentId) {
              return;
            }
            this.trigger("warning", formatWorkerError(msgData.value));
            break;
          case "error" /* Error */:
            if (((_c = this._currentContentInfo) == null ? void 0 : _c.contentId) !== msgData.contentId) {
              return;
            }
            this._onFatalError(formatWorkerError(msgData.value));
            break;
          case "create-media-source" /* CreateMediaSource */:
            this._onCreateMediaSourceMessage(
              msgData,
              mediaElement,
              mediaSourceStatus,
              this._settings.worker
            );
            break;
          case "add-source-buffer" /* AddSourceBuffer */:
            {
              if (((_e = (_d = this._currentContentInfo) == null ? void 0 : _d.mainThreadMediaSource) == null ? void 0 : _e.id) !== msgData.mediaSourceId) {
                return;
              }
              const mediaSource = this._currentContentInfo.mainThreadMediaSource;
              mediaSource.addSourceBuffer(
                msgData.value.sourceBufferType,
                msgData.value.codec
              );
            }
            break;
          case "source-buffer-append" /* SourceBufferAppend */:
            {
              if (((_g = (_f = this._currentContentInfo) == null ? void 0 : _f.mainThreadMediaSource) == null ? void 0 : _g.id) !== msgData.mediaSourceId) {
                return;
              }
              const mediaSource = this._currentContentInfo.mainThreadMediaSource;
              const sourceBuffer = arrayFind(
                mediaSource.sourceBuffers,
                (s) => s.type === msgData.sourceBufferType
              );
              if (sourceBuffer === void 0) {
                return;
              }
              sourceBuffer.appendBuffer(msgData.value.data, msgData.value.params).then((buffered) => {
                sendMessage(this._settings.worker, {
                  type: "sb-success" /* SourceBufferSuccess */,
                  mediaSourceId: mediaSource.id,
                  sourceBufferType: sourceBuffer.type,
                  operationId: msgData.operationId,
                  value: { buffered }
                });
              }).catch((error) => {
                sendMessage(this._settings.worker, {
                  type: "sb-error" /* SourceBufferError */,
                  mediaSourceId: mediaSource.id,
                  sourceBufferType: sourceBuffer.type,
                  operationId: msgData.operationId,
                  value: error instanceof CancellationError ? { errorName: "CancellationError" } : formatSourceBufferError(error).serialize()
                });
              });
            }
            break;
          case "source-buffer-remove" /* SourceBufferRemove */:
            {
              if (((_i = (_h = this._currentContentInfo) == null ? void 0 : _h.mainThreadMediaSource) == null ? void 0 : _i.id) !== msgData.mediaSourceId) {
                return;
              }
              const mediaSource = this._currentContentInfo.mainThreadMediaSource;
              const sourceBuffer = arrayFind(
                mediaSource.sourceBuffers,
                (s) => s.type === msgData.sourceBufferType
              );
              if (sourceBuffer === void 0) {
                return;
              }
              sourceBuffer.remove(msgData.value.start, msgData.value.end).then((buffered) => {
                sendMessage(this._settings.worker, {
                  type: "sb-success" /* SourceBufferSuccess */,
                  mediaSourceId: mediaSource.id,
                  sourceBufferType: sourceBuffer.type,
                  operationId: msgData.operationId,
                  value: { buffered }
                });
              }).catch((error) => {
                sendMessage(this._settings.worker, {
                  type: "sb-error" /* SourceBufferError */,
                  mediaSourceId: mediaSource.id,
                  sourceBufferType: sourceBuffer.type,
                  operationId: msgData.operationId,
                  value: error instanceof CancellationError ? { errorName: "CancellationError" } : formatSourceBufferError(error).serialize()
                });
              });
            }
            break;
          case "abort-source-buffer" /* AbortSourceBuffer */:
            {
              if (((_k = (_j = this._currentContentInfo) == null ? void 0 : _j.mainThreadMediaSource) == null ? void 0 : _k.id) !== msgData.mediaSourceId) {
                return;
              }
              const mediaSource = this._currentContentInfo.mainThreadMediaSource;
              const sourceBuffer = arrayFind(
                mediaSource.sourceBuffers,
                (s) => s.type === msgData.sourceBufferType
              );
              if (sourceBuffer === void 0) {
                return;
              }
              sourceBuffer.abort();
            }
            break;
          case "update-media-source-duration" /* UpdateMediaSourceDuration */:
            {
              if (((_m = (_l = this._currentContentInfo) == null ? void 0 : _l.mainThreadMediaSource) == null ? void 0 : _m.id) !== msgData.mediaSourceId) {
                return;
              }
              const mediaSource = this._currentContentInfo.mainThreadMediaSource;
              if ((mediaSource == null ? void 0 : mediaSource.id) !== msgData.mediaSourceId) {
                return;
              }
              mediaSource.setDuration(msgData.value.duration, msgData.value.isRealEndKnown);
            }
            break;
          case "stop-media-source-duration" /* InterruptMediaSourceDurationUpdate */:
            {
              if (((_o = (_n = this._currentContentInfo) == null ? void 0 : _n.mainThreadMediaSource) == null ? void 0 : _o.id) !== msgData.mediaSourceId) {
                return;
              }
              const mediaSource = this._currentContentInfo.mainThreadMediaSource;
              if ((mediaSource == null ? void 0 : mediaSource.id) !== msgData.mediaSourceId) {
                return;
              }
              mediaSource.interruptDurationSetting();
            }
            break;
          case "end-of-stream" /* EndOfStream */:
            {
              if (((_q = (_p = this._currentContentInfo) == null ? void 0 : _p.mainThreadMediaSource) == null ? void 0 : _q.id) !== msgData.mediaSourceId) {
                return;
              }
              this._currentContentInfo.mainThreadMediaSource.maintainEndOfStream();
            }
            break;
          case "stop-end-of-stream" /* InterruptEndOfStream */:
            {
              if (((_s = (_r = this._currentContentInfo) == null ? void 0 : _r.mainThreadMediaSource) == null ? void 0 : _s.id) !== msgData.mediaSourceId) {
                return;
              }
              this._currentContentInfo.mainThreadMediaSource.stopEndOfStream();
            }
            break;
          case "dispose-media-source" /* DisposeMediaSource */:
            {
              if (((_u = (_t = this._currentContentInfo) == null ? void 0 : _t.mainThreadMediaSource) == null ? void 0 : _u.id) !== msgData.mediaSourceId) {
                return;
              }
              this._currentContentInfo.mainThreadMediaSource.dispose();
            }
            break;
          case "needs-buffer-flush" /* NeedsBufferFlush */: {
            if (((_v = this._currentContentInfo) == null ? void 0 : _v.contentId) !== msgData.contentId) {
              return;
            }
            const currentTime = mediaElement.currentTime;
            const relativeResumingPosition = (_x = (_w = msgData.value) == null ? void 0 : _w.relativeResumingPosition) != null ? _x : 0;
            const canBeApproximateSeek = Boolean(
              (_y = msgData.value) == null ? void 0 : _y.relativePosHasBeenDefaulted
            );
            let wantedSeekingTime;
            if (relativeResumingPosition === 0 && canBeApproximateSeek) {
              wantedSeekingTime = currentTime + 1e-3;
            } else {
              wantedSeekingTime = currentTime + relativeResumingPosition;
            }
            playbackObserver.setCurrentTime(wantedSeekingTime);
            break;
          }
          case "active-period-changed" /* ActivePeriodChanged */: {
            if (((_z = this._currentContentInfo) == null ? void 0 : _z.contentId) !== msgData.contentId || this._currentContentInfo.manifest === null) {
              return;
            }
            const period = arrayFind(
              this._currentContentInfo.manifest.periods,
              (p) => p.id === msgData.value.periodId
            );
            if (period !== void 0) {
              this.trigger("activePeriodChanged", { period });
            }
            break;
          }
          case "adaptation-changed" /* AdaptationChanged */: {
            if (((_A = this._currentContentInfo) == null ? void 0 : _A.contentId) !== msgData.contentId || this._currentContentInfo.manifest === null) {
              return;
            }
            const period = arrayFind(
              this._currentContentInfo.manifest.periods,
              (p) => p.id === msgData.value.periodId
            );
            if (period === void 0) {
              return;
            }
            if (msgData.value.adaptationId === null) {
              this.trigger("adaptationChange", {
                period,
                adaptation: null,
                type: msgData.value.type
              });
              return;
            }
            const adaptations = (_B = period.adaptations[msgData.value.type]) != null ? _B : [];
            const adaptation = arrayFind(
              adaptations,
              (a) => a.id === msgData.value.adaptationId
            );
            if (adaptation !== void 0) {
              this.trigger("adaptationChange", {
                period,
                adaptation,
                type: msgData.value.type
              });
            }
            break;
          }
          case "representation-changed" /* RepresentationChanged */: {
            if (((_C = this._currentContentInfo) == null ? void 0 : _C.contentId) !== msgData.contentId || this._currentContentInfo.manifest === null) {
              return;
            }
            const period = arrayFind(
              this._currentContentInfo.manifest.periods,
              (p) => p.id === msgData.value.periodId
            );
            if (period === void 0) {
              return;
            }
            if (msgData.value.representationId === null) {
              this.trigger("representationChange", {
                period,
                type: msgData.value.type,
                representation: null
              });
              return;
            }
            const adaptations = (_D = period.adaptations[msgData.value.type]) != null ? _D : [];
            const adaptation = arrayFind(
              adaptations,
              (a) => a.id === msgData.value.adaptationId
            );
            if (adaptation === void 0) {
              return;
            }
            const representation = arrayFind(
              adaptation.representations,
              (r) => r.id === msgData.value.representationId
            );
            if (representation !== void 0) {
              this.trigger("representationChange", {
                period,
                type: msgData.value.type,
                representation
              });
            }
            break;
          }
          case "encryption-data-encountered" /* EncryptionDataEncountered */:
            if (((_E = this._currentContentInfo) == null ? void 0 : _E.contentId) !== msgData.contentId) {
              return;
            }
            lastContentProtection.setValue(msgData.value);
            break;
          case "manifest-ready" /* ManifestReady */: {
            if (((_F = this._currentContentInfo) == null ? void 0 : _F.contentId) !== msgData.contentId) {
              return;
            }
            const manifest = msgData.value.manifest;
            this._currentContentInfo.manifest = manifest;
            this._updateCodecSupport(manifest);
            this._startPlaybackIfReady(playbackStartParams);
            break;
          }
          case "manifest-update" /* ManifestUpdate */: {
            if (((_G = this._currentContentInfo) == null ? void 0 : _G.contentId) !== msgData.contentId) {
              return;
            }
            const manifest = (_H = this._currentContentInfo) == null ? void 0 : _H.manifest;
            if (isNullOrUndefined(manifest)) {
              log_default.error("MTCI: Manifest update but no Manifest loaded");
              return;
            }
            replicateUpdatesOnManifestMetadata(
              manifest,
              msgData.value.manifest,
              msgData.value.updates
            );
            (_J = (_I = this._currentContentInfo) == null ? void 0 : _I.streamEventsEmitter) == null ? void 0 : _J.onManifestUpdate(manifest);
            this._updateCodecSupport(manifest);
            this.trigger("manifestUpdate", msgData.value.updates);
            break;
          }
          case "update-playback-rate" /* UpdatePlaybackRate */:
            if (((_K = this._currentContentInfo) == null ? void 0 : _K.contentId) !== msgData.contentId) {
              return;
            }
            playbackObserver.setPlaybackRate(msgData.value);
            break;
          case "bitrate-estimate-change" /* BitrateEstimateChange */:
            if (((_L = this._currentContentInfo) == null ? void 0 : _L.contentId) !== msgData.contentId) {
              return;
            }
            this.trigger("bitrateEstimateChange", {
              type: msgData.value.bufferType,
              bitrate: msgData.value.bitrate
            });
            break;
          case "inband-event" /* InbandEvent */:
            if (((_M = this._currentContentInfo) == null ? void 0 : _M.contentId) !== msgData.contentId) {
              return;
            }
            this.trigger("inbandEvents", msgData.value);
            break;
          case "locked-stream" /* LockedStream */: {
            if (((_N = this._currentContentInfo) == null ? void 0 : _N.contentId) !== msgData.contentId || this._currentContentInfo.manifest === null) {
              return;
            }
            const period = arrayFind(
              this._currentContentInfo.manifest.periods,
              (p) => p.id === msgData.value.periodId
            );
            if (period === void 0) {
              return;
            }
            (_O = this._currentContentInfo.rebufferingController) == null ? void 0 : _O.onLockedStream(
              msgData.value.bufferType,
              period
            );
            break;
          }
          case "period-stream-ready" /* PeriodStreamReady */: {
            if (((_P = this._currentContentInfo) == null ? void 0 : _P.contentId) !== msgData.contentId || this._currentContentInfo.manifest === null) {
              return;
            }
            const period = arrayFind(
              this._currentContentInfo.manifest.periods,
              (p) => p.id === msgData.value.periodId
            );
            if (period === void 0) {
              return;
            }
            const ref = new reference_default(
              void 0
            );
            ref.onUpdate((adapChoice) => {
              if (this._currentContentInfo === null) {
                ref.finish();
                return;
              }
              if (!isNullOrUndefined(adapChoice)) {
                adapChoice.representations.onUpdate((repChoice, stopListening) => {
                  if (this._currentContentInfo === null) {
                    stopListening();
                    return;
                  }
                  sendMessage(this._settings.worker, {
                    type: "rep-update" /* RepresentationUpdate */,
                    contentId: this._currentContentInfo.contentId,
                    value: {
                      periodId: msgData.value.periodId,
                      adaptationId: adapChoice.adaptationId,
                      bufferType: msgData.value.bufferType,
                      choice: repChoice
                    }
                  });
                });
              }
              sendMessage(this._settings.worker, {
                type: "track-update" /* TrackUpdate */,
                contentId: this._currentContentInfo.contentId,
                value: {
                  periodId: msgData.value.periodId,
                  bufferType: msgData.value.bufferType,
                  choice: isNullOrUndefined(adapChoice) ? adapChoice : {
                    adaptationId: adapChoice.adaptationId,
                    switchingMode: adapChoice.switchingMode,
                    initialRepresentations: adapChoice.representations.getValue(),
                    relativeResumingPosition: adapChoice.relativeResumingPosition
                  }
                }
              });
            });
            this.trigger("periodStreamReady", {
              period,
              type: msgData.value.bufferType,
              adaptationRef: ref
            });
            break;
          }
          case "period-stream-cleared" /* PeriodStreamCleared */: {
            if (((_Q = this._currentContentInfo) == null ? void 0 : _Q.contentId) !== msgData.contentId || this._currentContentInfo.manifest === null) {
              return;
            }
            const period = arrayFind(
              this._currentContentInfo.manifest.periods,
              (p) => p.id === msgData.value.periodId
            );
            if (period === void 0) {
              return;
            }
            this.trigger("periodStreamCleared", {
              period,
              type: msgData.value.bufferType
            });
            break;
          }
          case "discontinuity-update" /* DiscontinuityUpdate */: {
            if (((_R = this._currentContentInfo) == null ? void 0 : _R.contentId) !== msgData.contentId || this._currentContentInfo.manifest === null) {
              return;
            }
            const period = arrayFind(
              this._currentContentInfo.manifest.periods,
              (p) => p.id === msgData.value.periodId
            );
            if (period === void 0) {
              log_default.warn("MTCI: Discontinuity's Period not found", msgData.value.periodId);
              return;
            }
            (_S = this._currentContentInfo.rebufferingController) == null ? void 0 : _S.updateDiscontinuityInfo({
              period,
              bufferType: msgData.value.bufferType,
              discontinuity: msgData.value.discontinuity,
              position: msgData.value.position
            });
            break;
          }
          case "push-text-data" /* PushTextData */: {
            if (((_T = this._currentContentInfo) == null ? void 0 : _T.contentId) !== msgData.contentId) {
              return;
            }
            if (textDisplayer === null) {
              log_default.warn("Init: Received AddTextData message but no text displayer exists");
            } else {
              try {
                const ranges = textDisplayer.pushTextData(msgData.value);
                sendMessage(this._settings.worker, {
                  type: "add-text-success" /* PushTextDataSuccess */,
                  contentId: msgData.contentId,
                  value: { ranges }
                });
              } catch (err) {
                const message = err instanceof Error ? err.message : "Unknown error";
                sendMessage(this._settings.worker, {
                  type: "push-text-error" /* PushTextDataError */,
                  contentId: msgData.contentId,
                  value: { message }
                });
              }
            }
            break;
          }
          case "remove-text-data" /* RemoveTextData */: {
            if (((_U = this._currentContentInfo) == null ? void 0 : _U.contentId) !== msgData.contentId) {
              return;
            }
            if (textDisplayer === null) {
              log_default.warn(
                "Init: Received RemoveTextData message but no text displayer exists"
              );
            } else {
              try {
                const ranges = textDisplayer.removeBuffer(
                  msgData.value.start,
                  msgData.value.end
                );
                sendMessage(this._settings.worker, {
                  type: "remove-text-success" /* RemoveTextDataSuccess */,
                  contentId: msgData.contentId,
                  value: { ranges }
                });
              } catch (err) {
                const message = err instanceof Error ? err.message : "Unknown error";
                sendMessage(this._settings.worker, {
                  type: "remove-text-error" /* RemoveTextDataError */,
                  contentId: msgData.contentId,
                  value: { message }
                });
              }
            }
            break;
          }
          case "reset-text-displayer" /* ResetTextDisplayer */: {
            if (((_V = this._currentContentInfo) == null ? void 0 : _V.contentId) !== msgData.contentId) {
              return;
            }
            if (textDisplayer === null) {
              log_default.warn(
                "Init: Received ResetTextDisplayer message but no text displayer exists"
              );
            } else {
              textDisplayer.reset();
            }
            break;
          }
          case "stop-text-displayer" /* StopTextDisplayer */: {
            if (((_W = this._currentContentInfo) == null ? void 0 : _W.contentId) !== msgData.contentId) {
              return;
            }
            if (textDisplayer === null) {
              log_default.warn(
                "Init: Received StopTextDisplayer message but no text displayer exists"
              );
            } else {
              textDisplayer.stop();
            }
            break;
          }
          case "reloading-media-source" /* ReloadingMediaSource */:
            {
              if (((_X = this._currentContentInfo) == null ? void 0 : _X.contentId) !== msgData.contentId) {
                return;
              }
              reloadMediaSource(
                msgData.value.timeOffset,
                msgData.value.minimumPosition,
                msgData.value.maximumPosition
              );
            }
            break;
          case "needs-decipherability-flush" /* NeedsDecipherabilityFlush */:
            {
              if (((_Y = this._currentContentInfo) == null ? void 0 : _Y.contentId) !== msgData.contentId) {
                return;
              }
              const keySystem = getKeySystemConfiguration(mediaElement);
              if (shouldReloadMediaSourceOnDecipherabilityUpdate(keySystem == null ? void 0 : keySystem[0])) {
                reloadMediaSource(0, void 0, void 0);
              } else {
                const lastObservation = playbackObserver.getReference().getValue();
                const currentPosition = lastObservation.position.getWanted();
                if (currentPosition + 1e-3 < lastObservation.duration) {
                  playbackObserver.setCurrentTime(mediaElement.currentTime + 1e-3);
                } else {
                  playbackObserver.setCurrentTime(currentPosition);
                }
              }
            }
            break;
          case "log" /* LogMessage */: {
            const formatted = msgData.value.logs.map((l) => {
              switch (typeof l) {
                case "string":
                case "number":
                case "boolean":
                case "undefined":
                  return l;
                case "object":
                  if (l === null) {
                    return null;
                  }
                  return formatWorkerError(l);
                default:
                  assertUnreachable(l);
              }
            });
            switch (msgData.value.logLevel) {
              case "NONE":
                break;
              case "ERROR":
                log_default.error(...formatted);
                break;
              case "WARNING":
                log_default.warn(...formatted);
                break;
              case "INFO":
                log_default.info(...formatted);
                break;
              case "DEBUG":
                log_default.debug(...formatted);
                break;
              default:
                assertUnreachable(msgData.value.logLevel);
            }
            break;
          }
          case "init-success" /* InitSuccess */:
          case "init-error" /* InitError */:
            break;
          case "segment-sink-store-update" /* SegmentSinkStoreUpdate */: {
            if (((_Z = this._currentContentInfo) == null ? void 0 : _Z.contentId) !== msgData.contentId) {
              return;
            }
            const sinkObj = this._awaitingRequests.pendingSinkMetrics.get(
              msgData.value.requestId
            );
            if (sinkObj !== void 0) {
              sinkObj.resolve(msgData.value.segmentSinkMetrics);
              this._awaitingRequests.pendingSinkMetrics.delete(msgData.value.requestId);
            } else {
              log_default.error("MTCI: Failed to send segment sink store update");
            }
            break;
          }
          case "thumbnail-response" /* ThumbnailDataResponse */:
            if (((__ = this._currentContentInfo) == null ? void 0 : __.contentId) !== msgData.contentId) {
              return;
            }
            const tObj = this._awaitingRequests.pendingThumbnailFetching.get(
              msgData.value.requestId
            );
            if (tObj !== void 0) {
              if (msgData.value.status === "error") {
                tObj.reject(formatWorkerError(msgData.value.error));
              } else {
                tObj.resolve(msgData.value.data);
              }
              this._awaitingRequests.pendingThumbnailFetching.delete(
                msgData.value.requestId
              );
            } else {
              log_default.error("MTCI: Failed to send segment sink store update");
            }
            break;
          default:
            assertUnreachable(msgData);
        }
      };
      this._settings.worker.addEventListener("message", onmessage);
      this._initCanceller.signal.register(() => {
        this._settings.worker.removeEventListener("message", onmessage);
      });
    }
    dispose() {
      var _a;
      this._initCanceller.cancel();
      if (this._currentContentInfo !== null) {
        (_a = this._currentContentInfo.mainThreadMediaSource) == null ? void 0 : _a.dispose();
        this._currentContentInfo = null;
      }
    }
    _onFatalError(err) {
      if (this._initCanceller.isUsed()) {
        return;
      }
      this._initCanceller.cancel();
      this.trigger("error", err);
    }
    _initializeContentDecryption(mediaElement, lastContentProtection, mediaSourceStatus, reloadMediaSource, cancelSignal) {
      const { keySystems } = this._settings;
      const createEmeDisabledReference = (errMsg) => {
        mediaSourceStatus.setValue(1 /* AttachNow */);
        lastContentProtection.onUpdate(
          (data2, stopListening) => {
            if (data2 === null) {
              return;
            }
            stopListening();
            const err = new EncryptedMediaError("MEDIA_IS_ENCRYPTED_ERROR", errMsg);
            this._onFatalError(err);
          },
          { clearSignal: cancelSignal }
        );
        const ref = new reference_default({
          initializationState: {
            type: "initialized",
            value: null
          },
          contentDecryptor: null,
          drmSystemId: void 0
        });
        ref.finish();
        return { statusRef: ref, contentDecryptor: null };
      };
      if (keySystems.length === 0) {
        return createEmeDisabledReference("No `keySystems` option given.");
      } else if (features_default.decrypt === null) {
        return createEmeDisabledReference("EME feature not activated.");
      }
      const ContentDecryptor2 = features_default.decrypt;
      if (!ContentDecryptor2.hasEmeApis()) {
        return createEmeDisabledReference("EME API not available on the current page.");
      }
      log_default.debug("MTCI: Creating ContentDecryptor");
      const contentDecryptor = new ContentDecryptor2(mediaElement, keySystems);
      const drmStatusRef = new reference_default(
        {
          initializationState: { type: "uninitialized", value: null },
          drmSystemId: void 0
        },
        cancelSignal
      );
      const updateCodecSupportOnStateChange = (state) => {
        var _a;
        if (state > 0 /* Initializing */) {
          const manifest = (_a = this._currentContentInfo) == null ? void 0 : _a.manifest;
          if (isNullOrUndefined(manifest)) {
            return;
          }
          this._updateCodecSupport(manifest);
          contentDecryptor.removeEventListener(
            "stateChange",
            updateCodecSupportOnStateChange
          );
        }
      };
      contentDecryptor.addEventListener("stateChange", updateCodecSupportOnStateChange);
      contentDecryptor.addEventListener("keyIdsCompatibilityUpdate", (updates) => {
        if (this._currentContentInfo === null || this._currentContentInfo.manifest === null) {
          return;
        }
        const manUpdates = updateDecipherabilityFromKeyIds(
          this._currentContentInfo.manifest,
          updates
        );
        if (may_media_element_fail_on_undecipherable_data_default && manUpdates.some((e) => e.representation.decipherable !== true)) {
          reloadMediaSource();
        } else {
          sendMessage(this._settings.worker, {
            type: "decipherability-update" /* DecipherabilityStatusUpdate */,
            contentId: this._currentContentInfo.contentId,
            value: manUpdates.map((s) => ({
              representationUniqueId: s.representation.uniqueId,
              decipherable: s.representation.decipherable
            }))
          });
        }
        this.trigger("decipherabilityUpdate", manUpdates);
      });
      contentDecryptor.addEventListener("blackListProtectionData", (protData) => {
        if (this._currentContentInfo === null || this._currentContentInfo.manifest === null) {
          return;
        }
        const manUpdates = updateDecipherabilityFromProtectionData(
          this._currentContentInfo.manifest,
          protData
        );
        if (may_media_element_fail_on_undecipherable_data_default && manUpdates.some((e) => e.representation.decipherable !== true)) {
          reloadMediaSource();
        } else {
          sendMessage(this._settings.worker, {
            type: "decipherability-update" /* DecipherabilityStatusUpdate */,
            contentId: this._currentContentInfo.contentId,
            value: manUpdates.map((s) => ({
              representationUniqueId: s.representation.uniqueId,
              decipherable: s.representation.decipherable
            }))
          });
        }
        this.trigger("decipherabilityUpdate", manUpdates);
      });
      contentDecryptor.addEventListener("stateChange", (state) => {
        if (state === 1 /* WaitingForAttachment */) {
          mediaSourceStatus.onUpdate(
            (currStatus, stopListening) => {
              if (currStatus === 0 /* Nothing */) {
                mediaSourceStatus.setValue(1 /* AttachNow */);
              } else if (currStatus === 2 /* Attached */) {
                stopListening();
                if (state === 1 /* WaitingForAttachment */) {
                  contentDecryptor.attach();
                }
              }
            },
            { clearSignal: cancelSignal, emitCurrentValue: true }
          );
        } else if (state === 2 /* ReadyForContent */) {
          drmStatusRef.setValue({
            initializationState: { type: "initialized", value: null },
            drmSystemId: contentDecryptor.systemId
          });
          contentDecryptor.removeEventListener("stateChange");
        }
      });
      contentDecryptor.addEventListener("error", (error) => {
        this._onFatalError(error);
      });
      contentDecryptor.addEventListener("warning", (error) => {
        this.trigger("warning", error);
      });
      lastContentProtection.onUpdate(
        (data2) => {
          if (data2 === null) {
            return;
          }
          contentDecryptor.onInitializationData(data2);
        },
        { clearSignal: cancelSignal }
      );
      cancelSignal.register(() => {
        contentDecryptor.dispose();
      });
      return { statusRef: drmStatusRef, contentDecryptor };
    }
    /**
     * Retrieves all unknown codecs from the current manifest, checks these unknown codecs
     * to determine if they are supported, updates the manifest with the support
     * status of these codecs, and forwards the list of supported codecs to the web worker.
     * @param manifest
     */
    _updateCodecSupport(manifest) {
      var _a, _b;
      try {
        const updatedCodecs = updateManifestCodecSupport(
          manifest,
          (_b = (_a = this._currentContentInfo) == null ? void 0 : _a.contentDecryptor) != null ? _b : null
        );
        if (updatedCodecs.length > 0) {
          sendMessage(this._settings.worker, {
            type: "codec-support-update" /* CodecSupportUpdate */,
            value: updatedCodecs
          });
          this.trigger("codecSupportUpdate", null);
        }
      } catch (err) {
        this._onFatalError(err);
      }
    }
    _hasTextBufferFeature() {
      return this._settings.textTrackOptions.textTrackMode === "html" && features_default.htmlTextDisplayer !== null || features_default.nativeTextDisplayer !== null;
    }
    _reload(mediaElement, textDisplayer, playbackObserver, mediaSourceStatus, position, autoPlay) {
      this._currentMediaSourceCanceller.cancel();
      this._currentMediaSourceCanceller = new TaskCanceller();
      this._currentMediaSourceCanceller.linkToSignal(this._initCanceller.signal);
      mediaSourceStatus.setValue(1 /* AttachNow */);
      this.trigger("reloadingMediaSource", { position, autoPlay });
      mediaSourceStatus.onUpdate(
        (status, stopListeningMSStatusUpdates) => {
          if (status !== 2 /* Attached */) {
            return;
          }
          stopListeningMSStatusUpdates();
          const corePlaybackObserver = this._setUpModulesOnNewMediaSource(
            {
              initialTime: position,
              autoPlay,
              mediaElement,
              textDisplayer,
              playbackObserver
            },
            this._currentMediaSourceCanceller.signal
          );
          if (!this._currentMediaSourceCanceller.isUsed() && corePlaybackObserver !== null && this._currentContentInfo !== null) {
            const contentId = this._currentContentInfo.contentId;
            corePlaybackObserver.listen(
              (obs) => {
                sendMessage(this._settings.worker, {
                  type: "observation" /* PlaybackObservation */,
                  contentId,
                  value: object_assign_default(obs, {
                    position: obs.position.serialize()
                  })
                });
              },
              {
                includeLastObservation: true,
                clearSignal: this._currentMediaSourceCanceller.signal
              }
            );
          }
        },
        {
          clearSignal: this._currentMediaSourceCanceller.signal,
          emitCurrentValue: true
        }
      );
    }
    /**
     * Start-up modules and mechanisms (initial seek, auto-play etc.) needed each
     * time a content is loaded AND re-loaded on a `HTMLMediaElement`, when the
     * manifest is known.
     *
     * Note that this does not include reacting to incoming worker messages nor
     * sending them, those actions have to be handled separately.
     *
     * @param {Object} parameters
     * @param {Object} cancelSignal
     * @returns {Object|null} - Playback Observer created for this content. `null`
     * only if playback initialization failed (most likely because it has been
     * cancelled).
     */
    _setUpModulesOnNewMediaSource(parameters, cancelSignal) {
      if (cancelSignal.isCancelled()) {
        return null;
      }
      if (this._currentContentInfo === null) {
        log_default.error("MTCI: Setting up modules without a contentId");
        return null;
      }
      if (this._currentContentInfo.manifest === null) {
        log_default.error("MTCI: Setting up modules without a loaded Manifest");
        return null;
      }
      const { manifest, mainThreadMediaSource: mediaSource } = this._currentContentInfo;
      const { speed } = this._settings;
      const { initialTime, autoPlay, mediaElement, textDisplayer, playbackObserver } = parameters;
      this._currentContentInfo.initialTime = initialTime;
      this._currentContentInfo.autoPlay = autoPlay;
      const { autoPlayResult, initialPlayPerformed } = performInitialSeekAndPlay(
        {
          mediaElement,
          playbackObserver,
          startTime: initialTime,
          mustAutoPlay: autoPlay,
          onWarning: (err) => this.trigger("warning", err),
          isDirectfile: false
        },
        cancelSignal
      );
      this._currentContentInfo.initialPlayPerformed = initialPlayPerformed;
      const corePlaybackObserver = createCorePlaybackObserver(
        playbackObserver,
        {
          autoPlay,
          initialPlayPerformed,
          manifest,
          mediaSource,
          speed,
          textDisplayer
        },
        cancelSignal
      );
      if (cancelSignal.isCancelled()) {
        return null;
      }
      const rebufferingController = new RebufferingController(
        playbackObserver,
        manifest,
        speed
      );
      rebufferingController.addEventListener(
        "stalled",
        (evt) => this.trigger("stalled", evt)
      );
      rebufferingController.addEventListener(
        "unstalled",
        () => this.trigger("unstalled", null)
      );
      rebufferingController.addEventListener(
        "warning",
        (err) => this.trigger("warning", err)
      );
      cancelSignal.register(() => {
        rebufferingController.destroy();
      });
      rebufferingController.start();
      this._currentContentInfo.rebufferingController = rebufferingController;
      const currentContentInfo = this._currentContentInfo;
      initialPlayPerformed.onUpdate(
        (isPerformed, stopListening) => {
          if (isPerformed) {
            stopListening();
            const streamEventsEmitter = new StreamEventsEmitter(
              manifest,
              mediaElement,
              playbackObserver
            );
            currentContentInfo.streamEventsEmitter = streamEventsEmitter;
            streamEventsEmitter.addEventListener(
              "event",
              (payload) => {
                this.trigger("streamEvent", payload);
              },
              cancelSignal
            );
            streamEventsEmitter.addEventListener(
              "eventSkip",
              (payload) => {
                this.trigger("streamEventSkip", payload);
              },
              cancelSignal
            );
            streamEventsEmitter.start();
            cancelSignal.register(() => {
              streamEventsEmitter.stop();
            });
          }
        },
        { clearSignal: cancelSignal, emitCurrentValue: true }
      );
      const _getSegmentSinkMetrics = async () => {
        this._awaitingRequests.nextRequestId++;
        const requestId = this._awaitingRequests.nextRequestId;
        sendMessage(this._settings.worker, {
          type: "pull-segment-sink-store-infos" /* PullSegmentSinkStoreInfos */,
          value: { requestId }
        });
        return new Promise((resolve, reject) => {
          this._awaitingRequests.pendingSinkMetrics.set(requestId, { resolve });
          const rejectFn = (err) => {
            this._awaitingRequests.pendingSinkMetrics.delete(requestId);
            return reject(err);
          };
          cancelSignal.register(rejectFn);
        });
      };
      const _getThumbnailsData = (periodId, thumbnailTrackId, time) => {
        if (this._currentContentInfo === null) {
          return Promise.reject(new Error("Cannot fetch thumbnails: No content loaded."));
        }
        this._awaitingRequests.nextRequestId++;
        const requestId = this._awaitingRequests.nextRequestId;
        sendMessage(this._settings.worker, {
          type: "thumbnail-request" /* ThumbnailDataRequest */,
          contentId: this._currentContentInfo.contentId,
          value: { requestId, periodId, thumbnailTrackId, time }
        });
        return new Promise((resolve, reject) => {
          this._awaitingRequests.pendingThumbnailFetching.set(requestId, {
            resolve,
            reject
          });
        });
      };
      autoPlayResult.then(() => {
        getLoadedReference(playbackObserver, mediaElement, false, cancelSignal).onUpdate(
          (isLoaded, stopListening) => {
            if (isLoaded) {
              stopListening();
              this.trigger("loaded", {
                getSegmentSinkMetrics: _getSegmentSinkMetrics,
                getThumbnailData: _getThumbnailsData
              });
            }
          },
          { emitCurrentValue: true, clearSignal: cancelSignal }
        );
      }).catch((err) => {
        if (cancelSignal.isCancelled()) {
          return;
        }
        this._onFatalError(err);
      });
      return corePlaybackObserver;
    }
    /**
     * Initialize content playback if and only if those conditions are filled:
     *   - The Manifest is fetched and stored in `this._currentContentInfo`.
     *   - `drmInitializationStatus` indicates that DRM matters are initialized.
     *   - `mediaSourceStatus` indicates that the MediaSource is attached to the
     *     `mediaElement`.
     *
     * In other cases, this method will do nothing.
     *
     * To call when any of those conditions might become `true`, to start-up
     * playback.
     *
     * @param {Object} parameters
     * @returns {boolean} - Returns `true` if all conditions where met for
     * playback start.
     */
    _startPlaybackIfReady(parameters) {
      if (this._currentContentInfo === null || this._currentContentInfo.manifest === null) {
        return false;
      }
      const drmInitStatus = parameters.drmInitializationStatus.getValue();
      if (drmInitStatus.initializationState.type !== "initialized") {
        return false;
      }
      const msInitStatus = parameters.mediaSourceStatus.getValue();
      if (msInitStatus !== 2 /* Attached */) {
        return false;
      }
      const { contentId, manifest } = this._currentContentInfo;
      log_default.debug("MTCI: Calculating initial time");
      const initialTime = getInitialTime(
        manifest,
        this._settings.lowLatencyMode,
        this._settings.startAt
      );
      log_default.debug("MTCI: Initial time calculated:", initialTime);
      const { enableFastSwitching, onCodecSwitch } = this._settings.bufferOptions;
      const corePlaybackObserver = this._setUpModulesOnNewMediaSource(
        {
          initialTime,
          autoPlay: this._settings.autoPlay,
          mediaElement: parameters.mediaElement,
          textDisplayer: parameters.textDisplayer,
          playbackObserver: parameters.playbackObserver
        },
        this._currentMediaSourceCanceller.signal
      );
      if (this._currentMediaSourceCanceller.isUsed() || corePlaybackObserver === null) {
        return true;
      }
      const initialObservation = corePlaybackObserver.getReference().getValue();
      const sentInitialObservation = object_assign_default(initialObservation, {
        position: initialObservation.position.serialize()
      });
      sendMessage(this._settings.worker, {
        type: "start" /* StartPreparedContent */,
        contentId,
        value: {
          initialTime,
          initialObservation: sentInitialObservation,
          drmSystemId: drmInitStatus.drmSystemId,
          enableFastSwitching,
          onCodecSwitch
        }
      });
      corePlaybackObserver.listen(
        (obs) => {
          sendMessage(this._settings.worker, {
            type: "observation" /* PlaybackObservation */,
            contentId,
            value: object_assign_default(obs, { position: obs.position.serialize() })
          });
        },
        {
          includeLastObservation: false,
          clearSignal: this._currentMediaSourceCanceller.signal
        }
      );
      this.trigger("manifestReady", manifest);
      return true;
    }
    /**
     * Handles Worker messages asking to create a MediaSource.
     * @param {Object} msg - The worker's message received.
     * @param {HTMLMediaElement} mediaElement - HTMLMediaElement on which the
     * content plays.
     * @param {Worker} worker - The WebWorker concerned, messages may be sent back
     * to it.
     */
    _onCreateMediaSourceMessage(msg, mediaElement, mediaSourceStatus, worker) {
      var _a;
      if (((_a = this._currentContentInfo) == null ? void 0 : _a.contentId) !== msg.contentId) {
        log_default.info("MTCI: Ignoring MediaSource attachment due to wrong `contentId`");
      } else {
        const { mediaSourceId } = msg;
        try {
          mediaSourceStatus.onUpdate(
            (currStatus, stopListening) => {
              if (this._currentContentInfo === null) {
                stopListening();
                return;
              }
              if (currStatus === 1 /* AttachNow */) {
                stopListening();
                const mediaSource = new MainMediaSourceInterface(mediaSourceId);
                this._currentContentInfo.mainThreadMediaSource = mediaSource;
                mediaSource.addEventListener("mediaSourceOpen", () => {
                  sendMessage(worker, {
                    type: "media-source-ready-state-change" /* MediaSourceReadyStateChange */,
                    mediaSourceId,
                    value: "open"
                  });
                });
                mediaSource.addEventListener("mediaSourceEnded", () => {
                  sendMessage(worker, {
                    type: "media-source-ready-state-change" /* MediaSourceReadyStateChange */,
                    mediaSourceId,
                    value: "ended"
                  });
                });
                mediaSource.addEventListener("mediaSourceClose", () => {
                  sendMessage(worker, {
                    type: "media-source-ready-state-change" /* MediaSourceReadyStateChange */,
                    mediaSourceId,
                    value: "closed"
                  });
                });
                let url = null;
                if (mediaSource.handle.type === "handle") {
                  mediaElement.srcObject = mediaSource.handle.value;
                } else {
                  url = URL.createObjectURL(mediaSource.handle.value);
                  mediaElement.src = url;
                }
                this._currentMediaSourceCanceller.signal.register(() => {
                  mediaSource.dispose();
                  resetMediaElement(mediaElement, url);
                });
                mediaSourceStatus.setValue(2 /* Attached */);
              }
            },
            {
              emitCurrentValue: true,
              clearSignal: this._currentMediaSourceCanceller.signal
            }
          );
        } catch (_err) {
          const error = new OtherError(
            "NONE",
            "Unknown error when creating the MediaSource"
          );
          this._onFatalError(error);
        }
      }
    }
  };
  function bindNumberReferencesToWorker(worker, cancellationSignal, ...refs) {
    for (const ref of refs) {
      ref[0].onUpdate(
        (newVal) => {
          sendMessage(worker, {
            type: "ref-update" /* ReferenceUpdate */,
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access
            value: { name: ref[1], newVal }
          });
        },
        { clearSignal: cancellationSignal, emitCurrentValue: true }
      );
    }
  }
  function formatWorkerError(sentError) {
    var _a;
    switch (sentError.name) {
      case "NetworkError":
        return new NetworkError(
          sentError.code,
          new RequestError(
            sentError.baseError.url,
            sentError.baseError.status,
            sentError.baseError.type
          )
        );
      case "MediaError":
        return new MediaError(sentError.code, sentError.reason, {
          tracks: sentError.tracks
        });
      case "EncryptedMediaError":
        if (sentError.code === "KEY_STATUS_CHANGE_ERROR") {
          return new EncryptedMediaError(sentError.code, sentError.reason, {
            keyStatuses: (_a = sentError.keyStatuses) != null ? _a : []
          });
        } else {
          return new EncryptedMediaError(sentError.code, sentError.reason);
        }
      case "OtherError":
        return new OtherError(sentError.code, sentError.reason);
    }
  }
  function formatSourceBufferError(error) {
    if (error instanceof SourceBufferError) {
      return error;
    } else if (error instanceof Error) {
      return new SourceBufferError(
        error.name,
        error.message,
        error.name === "QuotaExceededError"
      );
    } else {
      return new SourceBufferError("Error", "Unknown SourceBufferError Error", false);
    }
  }

  // src/experimental/features/multi_thread.ts
  function addMultiThreadFeature(features2) {
    features2.multithread = { init: MultiThreadContentInitializer };
  }

  // demo/scripts/modules/player/events.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var POSITION_UPDATES_INTERVAL = 100;
  var BUFFERED_DATA_UPDATES_INTERVAL = 100;
  function linkPlayerEventsToState(player, state, abortSignal) {
    linkPlayerEventToState("textTrackChange", "subtitle");
    linkPlayerEventToState("videoRepresentationChange", "videoRepresentation");
    linkPlayerEventToState("audioRepresentationChange", "audioRepresentation");
    linkPlayerEventToState("error", "error");
    linkPlayerEventToState("volumeChange", "volumeInfo");
    linkPlayerEventToState("audioTrackChange", "audioTrack");
    linkPlayerEventToState("videoTrackChange", "videoTrack");
    linkPlayerEventToState("availableAudioTracksChange", "availableAudioTracks");
    linkPlayerEventToState("availableVideoTracksChange", "availableVideoTracks");
    linkPlayerEventToState("availableTextTracksChange", "availableSubtitles");
    let positionUpdatesInterval = null;
    function startPositionUpdates() {
      stopPositionUpdates();
      positionUpdatesInterval = window.setInterval(
        updatePositionInfo,
        POSITION_UPDATES_INTERVAL
      );
      updatePositionInfo();
      function updatePositionInfo() {
        const position = player.getPosition();
        const duration = player.getMediaDuration();
        const videoTrack = player.getVideoTrack();
        const livePosition = player.getLivePosition();
        const maximumPosition = player.getMaximumPosition();
        let bufferGap = player.getCurrentBufferGap();
        bufferGap = !isFinite(bufferGap) || isNaN(bufferGap) ? 0 : bufferGap;
        const livePos = livePosition != null ? livePosition : maximumPosition;
        state.updateBulk({
          currentTime: player.getPosition(),
          wallClockDiff: player.getWallClockTime() - position,
          bufferGap,
          duration: Number.isNaN(duration) ? void 0 : duration,
          livePosition,
          minimumPosition: player.getMinimumPosition(),
          maximumPosition,
          liveGap: typeof livePos === "number" ? livePos - player.getPosition() : void 0,
          playbackRate: player.getPlaybackRate(),
          videoTrackHasTrickMode: videoTrack !== null && videoTrack !== void 0 && videoTrack.trickModeTracks !== void 0 && videoTrack.trickModeTracks.length > 0
        });
      }
    }
    function stopPositionUpdates() {
      if (positionUpdatesInterval === null) {
        return;
      }
      clearInterval(positionUpdatesInterval);
      positionUpdatesInterval = null;
    }
    abortSignal.addEventListener("abort", stopPositionUpdates);
    player.addEventListener("playerStateChange", onStateUpdate);
    abortSignal.addEventListener("abort", () => {
      player.removeEventListener("playerStateChange", onStateUpdate);
    });
    async function updateBufferedData() {
      var _a, _b, _c;
      if (player.getPlayerState() === "STOPPED") {
        return;
      }
      try {
        const metrics = await player.__priv_getSegmentSinkMetrics();
        let audioContent = (_a = metrics == null ? void 0 : metrics.segmentSinks.audio.segmentInventory) != null ? _a : null;
        if (Array.isArray(audioContent)) {
          audioContent = audioContent.slice();
        }
        let textContent = (_b = metrics == null ? void 0 : metrics.segmentSinks.text.segmentInventory) != null ? _b : null;
        if (Array.isArray(textContent)) {
          textContent = textContent.slice();
        }
        let videoContent = (_c = metrics == null ? void 0 : metrics.segmentSinks.video.segmentInventory) != null ? _c : null;
        if (Array.isArray(videoContent)) {
          videoContent = videoContent.slice();
        }
        state.update("bufferedData", {
          audio: audioContent,
          video: videoContent,
          text: textContent
        });
      } catch (err) {
      }
    }
    const bufferedDataItv = setInterval(updateBufferedData, BUFFERED_DATA_UPDATES_INTERVAL);
    updateBufferedData().catch(() => {
    });
    abortSignal.addEventListener("abort", () => {
      clearInterval(bufferedDataItv);
    });
    player.addEventListener("warning", onWarning);
    abortSignal.addEventListener("abort", () => {
      player.removeEventListener("warning", onWarning);
    });
    player.addEventListener("brokenRepresentationsLock", onBrokenRepresentationsLock);
    abortSignal.addEventListener("abort", () => {
      player.removeEventListener("brokenRepresentationsLock", onBrokenRepresentationsLock);
    });
    player.addEventListener("videoTrackChange", onVideoTrackChange);
    abortSignal.addEventListener("abort", () => {
      player.removeEventListener("videoTrackChange", onVideoTrackChange);
    });
    player.addEventListener("audioTrackChange", onAudioTrackChange);
    abortSignal.addEventListener("abort", () => {
      player.removeEventListener("audioTrackChange", onAudioTrackChange);
    });
    function onBrokenRepresentationsLock(evt) {
      const currentPeriod = player.getCurrentPeriod();
      if (evt.period.id !== (currentPeriod == null ? void 0 : currentPeriod.id)) {
        return;
      }
      if (evt.trackType === "video") {
        state.update("videoRepresentationsLocked", false);
      } else if (evt.trackType === "audio") {
        state.update("audioRepresentationsLocked", false);
      }
    }
    function onVideoTrackChange(videoTrack) {
      const videoRepresentationsLocked = player.getLockedVideoRepresentations() !== null;
      state.updateBulk({
        videoRepresentationsLocked,
        videoTrackHasTrickMode: videoTrack !== null && videoTrack !== void 0 && videoTrack.trickModeTracks !== void 0 && videoTrack.trickModeTracks.length > 0
      });
    }
    function onAudioTrackChange() {
      const audioRepresentationsLocked = player.getLockedAudioRepresentations() !== null;
      state.update("audioRepresentationsLocked", audioRepresentationsLocked);
    }
    function onWarning(warning) {
      if ("code" in warning) {
        switch (warning.code) {
          case "MEDIA_ERR_NOT_LOADED_METADATA":
            state.update("cannotLoadMetadata", true);
            break;
          case "MEDIA_ERR_BLOCKED_AUTOPLAY":
            state.update("autoPlayBlocked", true);
            break;
        }
      }
    }
    function linkPlayerEventToState(event, stateItem) {
      player.addEventListener(event, onEvent2);
      function onEvent2(payload) {
        state.update(stateItem, payload);
      }
      abortSignal.addEventListener("abort", () => {
        player.removeEventListener(event, onEvent2);
      });
    }
    function onStateUpdate(playerState) {
      var _a;
      const stateUpdates = {
        cannotLoadMetadata: false,
        hasEnded: playerState === "ENDED",
        hasCurrentContent: !["STOPPED", "LOADING"].includes(playerState),
        isContentLoaded: !["STOPPED", "LOADING", "RELOADING"].includes(playerState),
        isBuffering: playerState === "BUFFERING" || playerState === "FREEZING",
        isLoading: playerState === "LOADING",
        isReloading: playerState === "RELOADING",
        isSeeking: playerState === "SEEKING",
        isStopped: playerState === "STOPPED"
      };
      switch (playerState) {
        case "LOADING":
          stateUpdates.useWorker = ((_a = player.getCurrentModeInformation()) == null ? void 0 : _a.useWorker) === true;
          break;
        case "ENDED":
          stateUpdates.autoPlayBlocked = false;
          stateUpdates.isPaused = true;
          break;
        case "PAUSED":
          stateUpdates.isPaused = true;
          break;
        case "PLAYING":
          stateUpdates.autoPlayBlocked = false;
          stateUpdates.isPaused = false;
          break;
        case "LOADED":
          startPositionUpdates();
          stateUpdates.isPaused = true;
          stateUpdates.isLive = player.isLive();
          break;
        case "STOPPED":
          stopPositionUpdates();
          stateUpdates.audioRepresentation = void 0;
          stateUpdates.autoPlayBlocked = false;
          stateUpdates.videoRepresentation = void 0;
          stateUpdates.availableVideoTracks = [];
          stateUpdates.availableAudioTracks = [];
          stateUpdates.availableSubtitles = [];
          stateUpdates.lowLatencyMode = false;
          stateUpdates.subtitle = null;
          stateUpdates.audioTrack = null;
          stateUpdates.videoTrack = null;
          stateUpdates.currentTime = void 0;
          stateUpdates.wallClockDiff = void 0;
          stateUpdates.bufferGap = 0;
          stateUpdates.bufferedData = null;
          stateUpdates.duration = void 0;
          stateUpdates.minimumPosition = void 0;
          stateUpdates.maximumPosition = void 0;
          stateUpdates.livePosition = void 0;
          stateUpdates.useWorker = false;
          break;
      }
      if (playerState !== "STOPPED") {
        stateUpdates.error = null;
      }
      state.updateBulk(stateUpdates);
    }
  }

  // src/experimental/tools/VideoThumbnailLoader/index.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/experimental/tools/VideoThumbnailLoader/video_thumbnail_loader.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // src/experimental/tools/VideoThumbnailLoader/load_and_push_segment.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function loadAndPushSegment(segmentInfo, sourceBufferInterface, segmentFetcher, cancelSignal) {
    const pushOperations = [];
    return segmentFetcher(
      segmentInfo,
      {
        onChunk(parseChunk) {
          const parsed = parseChunk(void 0);
          let data2;
          let timestampOffset;
          const codec = segmentInfo.representation.getMimeTypeString();
          if (parsed.segmentType === "init") {
            data2 = parsed.initializationData;
            timestampOffset = 0;
          } else {
            data2 = parsed.chunkData;
            timestampOffset = parsed.chunkOffset;
          }
          let pushOperation;
          if (data2 === null) {
            pushOperation = Promise.resolve(null);
          } else {
            pushOperation = sourceBufferInterface.appendBuffer(data2, {
              appendWindow: [segmentInfo.period.start, segmentInfo.period.end],
              timestampOffset,
              codec
            });
          }
          pushOperations.push(pushOperation);
        },
        onAllChunksReceived() {
          return;
        },
        onRetry(error) {
          log_default.warn("Retrying segment request", error);
        }
      },
      cancelSignal
    ).then(() => Promise.all(pushOperations));
  }

  // src/experimental/tools/VideoThumbnailLoader/prepare_source_buffer.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var generateMediaSourceId2 = idGenerator();
  function prepareSourceBuffer(videoElement, codec, cleanUpSignal) {
    return createCancellablePromise(cleanUpSignal, (resolve, reject) => {
      if (isNullOrUndefined(MediaSource_)) {
        throw new Error("No MediaSource Object was found in the current browser.");
      }
      const oldSrc = isNonEmptyString(videoElement.src) ? videoElement.src : null;
      resetMediaElement(videoElement, oldSrc);
      log_default.info("Init: Creating MediaSource");
      const mediaSource = new MainMediaSourceInterface(generateMediaSourceId2());
      if (mediaSource.handle.type === "handle") {
        videoElement.srcObject = mediaSource.handle.value;
        cleanUpSignal.register(() => {
          resetMediaElement(videoElement, null);
        });
      } else {
        const objectURL = URL.createObjectURL(mediaSource.handle.value);
        log_default.info("Init: Attaching MediaSource URL to the media element", objectURL);
        videoElement.src = objectURL;
        cleanUpSignal.register(() => {
          resetMediaElement(videoElement, objectURL);
        });
      }
      mediaSource.addEventListener("mediaSourceOpen", onSourceOpen2);
      return () => {
        mediaSource.removeEventListener("mediaSourceOpen", onSourceOpen2);
      };
      function onSourceOpen2() {
        try {
          mediaSource.removeEventListener("mediaSourceOpen", onSourceOpen2);
          resolve(mediaSource.addSourceBuffer("video" /* Video */, codec));
        } catch (err) {
          reject(err);
        }
      }
    });
  }

  // src/experimental/tools/VideoThumbnailLoader/remove_buffer_around_time.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function removeBufferAroundTime(videoElement, sourceBufferInterface, time, margin) {
    const removalMargin = margin != null ? margin : 10 * 60;
    if (videoElement.buffered.length === 0) {
      return Promise.resolve();
    }
    const bufferRemovals = [];
    if (time - removalMargin > 0) {
      bufferRemovals.push(sourceBufferInterface.remove(0, time - removalMargin));
    }
    if (time + removalMargin < videoElement.duration) {
      bufferRemovals.push(
        sourceBufferInterface.remove(time + removalMargin, videoElement.duration)
      );
    }
    return Promise.all(bufferRemovals);
  }

  // src/experimental/tools/VideoThumbnailLoader/video_thumbnail_loader_error.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var VideoThumbnailLoaderError = class _VideoThumbnailLoaderError extends Error {
    /**
     * @param {string} code
     * @param {string} message
     */
    constructor(code, message) {
      super(errorMessage(code, message));
      Object.setPrototypeOf(this, _VideoThumbnailLoaderError.prototype);
      this.name = "VideoThumbnailLoaderError";
      this.code = code;
    }
  };

  // src/experimental/tools/VideoThumbnailLoader/features/dash.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function addDashFeature(loaders2) {
    const transports = dash_default({ lowLatencyMode: false });
    loaders2.dash = transports;
  }

  // src/experimental/tools/VideoThumbnailLoader/video_thumbnail_loader.ts
  var MIN_NEEDED_DATA_AFTER_TIME = 2;
  var loaders = {};
  var VideoThumbnailLoader = class {
    constructor(videoElement, player) {
      this._videoElement = videoElement;
      this._player = player;
      this._lastRepresentationInfo = null;
    }
    /**
     * Add imported loader to thumbnail loader loader object.
     * It allows to use it when setting time.
     * @param {function} loaderFunc
     */
    static addLoader(loaderFunc) {
      loaderFunc(loaders);
    }
    /**
     * Set time of thumbnail video media element :
     * - Remove buffer when too much buffered data
     * - Search for thumbnail track element to display
     * - Load data
     * - Append data
     * Resolves when time is set.
     * @param {number} time
     * @returns {Promise}
     */
    setTime(time) {
      const manifest = this._player.__priv_getManifest();
      if (manifest === null) {
        if (this._lastRepresentationInfo !== null) {
          this._lastRepresentationInfo.cleaner.cancel();
          this._lastRepresentationInfo = null;
        }
        return Promise.reject(
          new VideoThumbnailLoaderError("NO_MANIFEST", "No manifest available.")
        );
      }
      if (!(manifest instanceof classes_default)) {
        throw new Error(
          "Impossible to run VideoThumbnailLoader in the current context.\nAre you running the RxPlayer in a WebWorker?"
        );
      }
      const content = getTrickModeInfo(time, manifest);
      if (content === null) {
        if (this._lastRepresentationInfo !== null) {
          this._lastRepresentationInfo.cleaner.cancel();
          this._lastRepresentationInfo = null;
        }
        return Promise.reject(
          new VideoThumbnailLoaderError(
            "NO_TRACK",
            "Couldn't find a trickmode track for this time."
          )
        );
      }
      if (this._lastRepresentationInfo !== null && !areSameRepresentation(this._lastRepresentationInfo.content, content)) {
        this._lastRepresentationInfo.cleaner.cancel();
        this._lastRepresentationInfo = null;
      }
      const neededSegments = content.representation.index.getSegments(
        time,
        MIN_NEEDED_DATA_AFTER_TIME
      );
      if (neededSegments.length === 0) {
        if (this._lastRepresentationInfo !== null) {
          this._lastRepresentationInfo.cleaner.cancel();
          this._lastRepresentationInfo = null;
        }
        return Promise.reject(
          new VideoThumbnailLoaderError(
            "NO_THUMBNAIL",
            "Couldn't find any thumbnail for the given time."
          )
        );
      }
      for (let j = 0; j < neededSegments.length; j++) {
        const { time: stime, duration, timescale } = neededSegments[j];
        const start = stime / timescale;
        const end = start + duration / timescale;
        for (let i = 0; i < this._videoElement.buffered.length; i++) {
          if (this._videoElement.buffered.start(i) - 1e-3 <= start && this._videoElement.buffered.end(i) + 1e-3 >= end) {
            neededSegments.splice(j, 1);
            j--;
            break;
          }
        }
      }
      if (neededSegments.length === 0) {
        this._videoElement.currentTime = time;
        log_default.debug("VTL: Thumbnails already loaded.", time);
        return Promise.resolve(time);
      }
      if (log_default.hasLevel("DEBUG")) {
        log_default.debug(
          "VTL: Found thumbnail for time",
          time,
          neededSegments.map((s) => `start: ${s.time} - end: ${s.end}`).join(", ")
        );
      }
      const loader = loaders[content.manifest.transport];
      if (loader === void 0) {
        if (this._lastRepresentationInfo !== null) {
          this._lastRepresentationInfo.cleaner.cancel();
          this._lastRepresentationInfo = null;
        }
        return Promise.reject(
          new VideoThumbnailLoaderError(
            "NO_LOADER",
            "VideoThumbnailLoaderError: No imported loader for this transport type: " + content.manifest.transport
          )
        );
      }
      let lastRepInfo;
      if (this._lastRepresentationInfo === null) {
        const lastRepInfoCleaner = new TaskCanceller();
        const segmentFetcher = createSegmentFetcher({
          bufferType: "video",
          pipeline: loader.video,
          cdnPrioritizer: null,
          cmcdDataBuilder: null,
          requestOptions: {
            baseDelay: 0,
            maxDelay: 0,
            maxRetry: 0,
            requestTimeout: config_default.getCurrent().DEFAULT_REQUEST_TIMEOUT,
            connectionTimeout: config_default.getCurrent().DEFAULT_CONNECTION_TIMEOUT
          },
          // We don't care about the SegmentFetcher's lifecycle events
          eventListeners: {}
        });
        const initSegment = content.representation.index.getInitSegment();
        const initSegmentUniqueId = initSegment !== null ? content.representation.uniqueId : null;
        const sourceBufferProm = prepareSourceBuffer(
          this._videoElement,
          content.representation.getMimeTypeString(),
          lastRepInfoCleaner.signal
        ).then(async (sourceBufferInterface) => {
          if (initSegment === null || initSegmentUniqueId === null) {
            lastRepInfo.initSegmentUniqueId = null;
            return sourceBufferInterface;
          }
          const segmentInfo = object_assign_default({ segment: initSegment }, content);
          await loadAndPushSegment(
            segmentInfo,
            sourceBufferInterface,
            lastRepInfo.segmentFetcher,
            lastRepInfoCleaner.signal
          );
          return sourceBufferInterface;
        });
        lastRepInfo = {
          cleaner: lastRepInfoCleaner,
          sourceBuffer: sourceBufferProm,
          content,
          initSegmentUniqueId,
          segmentFetcher,
          pendingRequests: []
        };
        this._lastRepresentationInfo = lastRepInfo;
      } else {
        lastRepInfo = this._lastRepresentationInfo;
      }
      abortUnlistedSegmentRequests(lastRepInfo.pendingRequests, neededSegments);
      const currentTaskCanceller = new TaskCanceller();
      return lastRepInfo.sourceBuffer.catch((err) => {
        if (this._lastRepresentationInfo !== null) {
          this._lastRepresentationInfo.cleaner.cancel();
          this._lastRepresentationInfo = null;
        }
        throw new VideoThumbnailLoaderError(
          "LOADING_ERROR",
          "VideoThumbnailLoaderError: Error when initializing buffers: " + String(err)
        );
      }).then(async (sourceBufferInterface) => {
        abortUnlistedSegmentRequests(lastRepInfo.pendingRequests, neededSegments);
        log_default.debug("VTL: Removing buffer around time.", time);
        await removeBufferAroundTime(
          this._videoElement,
          sourceBufferInterface,
          time,
          void 0
        );
        if (currentTaskCanceller.signal.cancellationError !== null) {
          throw currentTaskCanceller.signal.cancellationError;
        }
        abortUnlistedSegmentRequests(lastRepInfo.pendingRequests, neededSegments);
        const promises = [];
        for (const segment of neededSegments) {
          const pending = arrayFind(
            lastRepInfo.pendingRequests,
            ({ segmentId }) => segmentId === segment.id
          );
          if (pending !== void 0) {
            promises.push(pending.promise);
          } else {
            const requestCanceller = new TaskCanceller();
            const unlinkSignal = requestCanceller.linkToSignal(
              lastRepInfo.cleaner.signal
            );
            const segmentInfo = object_assign_default({ segment }, content);
            const prom = loadAndPushSegment(
              segmentInfo,
              sourceBufferInterface,
              lastRepInfo.segmentFetcher,
              requestCanceller.signal
            ).then(unlinkSignal, (err) => {
              unlinkSignal();
              throw err;
            });
            const newReq = {
              segmentId: segment.id,
              canceller: requestCanceller,
              promise: prom
            };
            lastRepInfo.pendingRequests.push(newReq);
            const removePendingRequest = () => {
              const indexOf = lastRepInfo.pendingRequests.indexOf(newReq);
              if (indexOf >= 0) {
                lastRepInfo.pendingRequests.splice(indexOf, 1);
              }
            };
            prom.then(removePendingRequest, removePendingRequest);
            promises.push(prom);
          }
        }
        await Promise.all(promises);
        this._videoElement.currentTime = time;
        return time;
      }).catch((err) => {
        if (err instanceof CancellationError) {
          throw new VideoThumbnailLoaderError(
            "ABORTED",
            "VideoThumbnailLoaderError: Aborted job."
          );
        }
        throw err;
      });
    }
    /**
     * Dispose thumbnail loader.
     * @returns {void}
     */
    dispose() {
      if (this._lastRepresentationInfo !== null) {
        this._lastRepresentationInfo.cleaner.cancel();
        this._lastRepresentationInfo = null;
      }
    }
  };
  function areSameRepresentation(contentInfo1, contentInfo2) {
    return contentInfo1.representation.id === contentInfo2.representation.id && contentInfo1.adaptation.id === contentInfo2.adaptation.id && contentInfo1.period.id === contentInfo2.period.id && contentInfo1.manifest.id === contentInfo2.manifest.id;
  }
  function getTrickModeInfo(time, manifest) {
    var _a, _b;
    const period = manifest.getPeriodForTime(time);
    if (period === void 0 || period.adaptations.video === void 0 || period.adaptations.video.length === 0) {
      return null;
    }
    for (const videoAdaptation of period.adaptations.video) {
      const representation = (_b = (_a = videoAdaptation.trickModeTracks) == null ? void 0 : _a[0].representations) == null ? void 0 : _b[0];
      if (!isNullOrUndefined(representation)) {
        return { manifest, period, adaptation: videoAdaptation, representation };
      }
    }
    return null;
  }
  function abortUnlistedSegmentRequests(pendingRequests, neededSegments) {
    pendingRequests.filter((req) => !neededSegments.some(({ id }) => id === req.segmentId)).forEach((req) => {
      req.canceller.cancel();
    });
  }

  // src/experimental/tools/VideoThumbnailLoader/index.ts
  var VideoThumbnailLoader_default = VideoThumbnailLoader;

  // demo/scripts/modules/player/catchUp.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var LIVE_GAP_GOAL_WHEN_CATCHING_UP = 3.5;
  var CATCH_UP_CHANGE_RATE_STEP = 6;
  var CATCH_UP_SEEKING_STEP = 15;
  var MAX_RATE = 5;
  var CatchUpModeController = class {
    constructor(rxPlayer, state) {
      this._rxPlayer = rxPlayer;
      this._state = state;
      this._catchUpAborter = null;
    }
    enableCatchUp() {
      var _a;
      if (this._catchUpAborter !== null) {
        return;
      }
      this._catchUpAborter = new AbortController();
      let interval = null;
      const onStateChange = () => {
        var _a2;
        if (interval !== null) {
          clearInterval(interval);
          interval = null;
        }
        const playerState = this._rxPlayer.getPlayerState();
        const canCatchUp = playerState === "LOADED" || playerState === "PLAYING" || playerState === "PAUSED" || playerState === "BUFFERING" || playerState === "FREEZING" || playerState === "SEEKING";
        if (!this._rxPlayer.isLive()) {
          this.stopCatchUp();
        } else if (!canCatchUp) {
          this._rxPlayer.setPlaybackRate(1);
          this._state.updateBulk({ isCatchingUp: false, playbackRate: 1 });
        } else {
          const checkCatchUp = () => {
            var _a3;
            const livePos = (_a3 = this._rxPlayer.getLivePosition()) != null ? _a3 : this._rxPlayer.getMaximumPosition();
            if (livePos === null) {
              this._rxPlayer.setPlaybackRate(1);
              this._state.updateBulk({ isCatchingUp: false, playbackRate: 1 });
              return;
            }
            const position = this._rxPlayer.getPosition();
            const liveGap = livePos - position;
            if (liveGap >= CATCH_UP_SEEKING_STEP) {
              this._rxPlayer.seekTo(livePos - LIVE_GAP_GOAL_WHEN_CATCHING_UP);
              this._rxPlayer.setPlaybackRate(1);
              this._state.updateBulk({ isCatchingUp: false, playbackRate: 1 });
              return;
            }
            if (this._state.get("isCatchingUp")) {
              if (liveGap <= LIVE_GAP_GOAL_WHEN_CATCHING_UP) {
                this._rxPlayer.setPlaybackRate(1);
                this._state.updateBulk({ isCatchingUp: false, playbackRate: 1 });
                return;
              }
            } else if (liveGap < CATCH_UP_CHANGE_RATE_STEP) {
              return;
            }
            const factor = (liveGap - LIVE_GAP_GOAL_WHEN_CATCHING_UP) / 4;
            const rate = Math.round(Math.min(MAX_RATE, 1.1 + factor) * 10) / 10;
            if (rate <= 1) {
              this._rxPlayer.setPlaybackRate(1);
              this._state.updateBulk({ isCatchingUp: false, playbackRate: 1 });
              return;
            }
            const currentPlaybackRate = this._rxPlayer.getPlaybackRate();
            if (rate !== currentPlaybackRate) {
              this._rxPlayer.setPlaybackRate(rate);
            }
            this._state.updateBulk({ isCatchingUp: true, playbackRate: rate });
          };
          interval = window.setInterval(checkCatchUp, 200);
          checkCatchUp();
          (_a2 = this._catchUpAborter) == null ? void 0 : _a2.signal.addEventListener("abort", () => {
            if (interval !== null) {
              clearInterval(interval);
              interval = null;
            }
          });
        }
      };
      this._rxPlayer.addEventListener("playerStateChange", onStateChange);
      (_a = this._catchUpAborter) == null ? void 0 : _a.signal.addEventListener("abort", () => {
        this._rxPlayer.removeEventListener("playerStateChange", onStateChange);
      });
    }
    stopCatchUp() {
      if (this._catchUpAborter === null) {
        return;
      }
      this._catchUpAborter.abort();
      this._catchUpAborter = null;
      this._rxPlayer.setPlaybackRate(1);
      this._state.updateBulk({
        isCatchUpEnabled: false,
        isCatchingUp: false,
        playbackRate: 1
      });
    }
  };

  // demo/scripts/lib/declareModule.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function declareModule(generateInitialState, initialize) {
    return class {
      constructor(moduleArg) {
        this._listeners = {};
        const stateObject = generateInitialState();
        this._stateObject = stateObject;
        this._abortController = new AbortController();
        const notifyUpdatedValue = (stateName) => {
          const listeners = this._listeners[stateName];
          if (!Array.isArray(listeners)) {
            return;
          }
          listeners.slice().forEach((listener) => {
            try {
              listener(stateObject[stateName]);
            } catch (e) {
              console.error("EventEmitter: listener error", e instanceof Error ? e : null);
            }
          });
        };
        const stateUpdater = {
          get(stateName) {
            return stateObject[stateName];
          },
          update(stateName, value) {
            stateObject[stateName] = value;
            notifyUpdatedValue(stateName);
          },
          updateBulk(bulk) {
            Object.assign(stateObject, bulk);
            for (const stateName of Object.keys(bulk)) {
              notifyUpdatedValue(stateName);
            }
          }
        };
        this.actions = initialize(moduleArg, stateUpdater, this._abortController.signal);
      }
      getState(stateName) {
        return this._stateObject[stateName];
      }
      listenToState(stateName, callback) {
        const listeners = this._listeners[stateName];
        if (!Array.isArray(listeners)) {
          this._listeners[stateName] = [callback];
        } else {
          listeners.push(callback);
        }
        return () => {
          const currListeners = this._listeners[stateName];
          if (!Array.isArray(currListeners)) {
            return;
          }
          const index = currListeners.indexOf(callback);
          if (index !== -1) {
            currListeners.splice(index, 1);
          }
          if (currListeners.length === 0) {
            delete this._listeners[stateName];
          }
        };
      }
      destroy() {
        this._listeners = {};
        return this._abortController.abort();
      }
    };
  }

  // demo/scripts/modules/player/index.ts
  minimal_default.addFeatures([
    addDASHFeature,
    addDirectfileFeature,
    addEMEFeature,
    addHTMLSAMIFeature,
    addHTMLSRTFeature,
    addHTMLTextBuffer,
    addHTMLTTMLFeature,
    addHTMLVTTFeature,
    addSmoothFeature,
    addMetaPlaylistFeature,
    addDebugElementFeature,
    addMultiThreadFeature
  ]);
  window.RxPlayer = minimal_default;
  if (false) {
    minimal_default.addFeatures([DASH_WASM]);
    DASH_WASM.initialize({ wasmUrl: "./mpd-parser.wasm" }).catch((err) => {
      console.error("Error when initializing WASM DASH MPD parser:", err);
    });
  }
  VideoThumbnailLoader_default.addLoader(addDashFeature);
  var PlayerModule = declareModule(
    () => ({
      audioRepresentation: void 0,
      audioRepresentationsLocked: false,
      autoPlayBlocked: false,
      availableAudioTracks: [],
      availableSubtitles: [],
      availableVideoTracks: [],
      bufferGap: 0,
      bufferedData: null,
      cannotLoadMetadata: false,
      currentTime: void 0,
      defaultAudioRepresentationsSwitchingMode: "reload",
      defaultVideoRepresentationsSwitchingMode: "reload",
      duration: void 0,
      error: null,
      hasCurrentContent: false,
      hasEnded: false,
      isBuffering: false,
      isCatchUpEnabled: false,
      isCatchingUp: false,
      isContentLoaded: false,
      isLive: false,
      isLoading: false,
      imageThumbnailContainerElement: document.createElement("div"),
      isPaused: false,
      isReloading: false,
      isSeeking: false,
      isStopped: true,
      audioTrack: void 0,
      liveGap: void 0,
      loadedVideo: null,
      lowLatencyMode: false,
      livePosition: void 0,
      maximumPosition: void 0,
      minimumPosition: void 0,
      playbackRate: 1,
      relyOnWorker: false,
      useWorker: false,
      subtitle: void 0,
      videoRepresentation: void 0,
      videoRepresentationsLocked: false,
      videoTrack: void 0,
      volumeInfo: {
        volume: 1,
        muted: false
      },
      wallClockDiff: void 0,
      videoTrackHasTrickMode: false,
      videoThumbnailsElement: null,
      videoThumbnailLoader: null
    }),
    (initOpts, state, abortSignal) => {
      let hasAttachedMultithread = false;
      const _a = initOpts, { debugElement, textTrackElement } = _a, constructorOpts = __objRest(_a, ["debugElement", "textTrackElement"]);
      const player = new minimal_default(constructorOpts);
      let debugEltInstance;
      window.player = player;
      window.rxPlayer = player;
      linkPlayerEventsToState(player, state, abortSignal);
      const catchUpModeController = new CatchUpModeController(player, state);
      abortSignal.addEventListener("abort", () => {
        player.dispose();
        if (debugEltInstance !== void 0) {
          debugEltInstance.dispose();
        }
      });
      return {
        attachVideoThumbnailLoader() {
          const prevVideoThumbnailLoader = state.get("videoThumbnailLoader");
          if (prevVideoThumbnailLoader !== null) {
            prevVideoThumbnailLoader.dispose();
          }
          const thumbnailVideoElement = document.createElement("video");
          const videoThumbnailLoader = new VideoThumbnailLoader_default(
            thumbnailVideoElement,
            player
          );
          state.updateBulk({
            videoThumbnailLoader,
            videoThumbnailsElement: thumbnailVideoElement
          });
        },
        dettachVideoThumbnailLoader() {
          dettachVideoThumbnailLoader();
        },
        setVolume(volume) {
          player.setVolume(volume);
        },
        updateWorkerMode(enabled) {
          if (enabled && !hasAttachedMultithread) {
            attachMultithread(player);
          }
          state.update("relyOnWorker", enabled);
        },
        load(arg) {
          dettachVideoThumbnailLoader();
          player.loadVideo(
            Object.assign(
              {
                mode: state.get("relyOnWorker") ? "auto" : "main",
                textTrackElement
              },
              arg
            )
          );
          const newState = {
            loadedVideo: arg,
            lowLatencyMode: arg.lowLatencyMode === true
          };
          state.updateBulk(newState);
        },
        play() {
          player.play().catch(() => {
          });
          const isStopped = state.get("isStopped");
          const hasEnded = state.get("hasEnded");
          if (!isStopped && !hasEnded) {
            state.update("isPaused", false);
          }
        },
        pause() {
          player.pause();
          const isStopped = state.get("isStopped");
          const hasEnded = state.get("hasEnded");
          if (!isStopped && !hasEnded) {
            state.update("isPaused", true);
          }
        },
        stop() {
          dettachVideoThumbnailLoader();
          player.stop();
        },
        seek(position) {
          player.seekTo({ position });
        },
        mute() {
          player.mute();
        },
        unmute() {
          player.unMute();
        },
        getThumbnailMetadata(time) {
          const metadata = player.getThumbnailMetadata({ time });
          return metadata != null ? metadata : [];
        },
        renderThumbnail(time, thumbnailTrackId) {
          return player.renderThumbnail({
            container: state.get("imageThumbnailContainerElement"),
            time,
            thumbnailTrackId
          });
        },
        setDefaultVideoRepresentationSwitchingMode(mode) {
          state.update("defaultVideoRepresentationsSwitchingMode", mode);
        },
        setDefaultAudioRepresentationSwitchingMode(mode) {
          state.update("defaultAudioRepresentationsSwitchingMode", mode);
        },
        lockVideoRepresentations(reps) {
          player.lockVideoRepresentations({
            representations: reps.map((r) => r.id),
            switchingMode: state.get("defaultVideoRepresentationsSwitchingMode")
          });
          state.update(
            "videoRepresentationsLocked",
            player.getLockedVideoRepresentations() !== null
          );
        },
        unlockVideoRepresentations: () => {
          player.unlockVideoRepresentations();
          state.update(
            "videoRepresentationsLocked",
            player.getLockedVideoRepresentations() !== null
          );
        },
        lockAudioRepresentations(reps) {
          player.lockAudioRepresentations({
            representations: reps.map((r) => String(r.id)),
            switchingMode: state.get("defaultAudioRepresentationsSwitchingMode")
          });
          state.update(
            "audioRepresentationsLocked",
            player.getLockedAudioRepresentations() !== null
          );
        },
        unlockAudioRepresentations: () => {
          player.unlockAudioRepresentations();
          state.update(
            "audioRepresentationsLocked",
            player.getLockedAudioRepresentations() !== null
          );
        },
        setAudioTrack(track) {
          player.setAudioTrack(track.id);
        },
        setVideoTrack(track) {
          player.setVideoTrack(track.id);
        },
        disableVideoTrack() {
          player.disableVideoTrack();
        },
        setTextTrack(track) {
          player.setTextTrack(track.id);
        },
        disableSubtitlesTrack() {
          player.disableTextTrack();
        },
        setPlaybackRate(rate) {
          player.setPlaybackRate(rate);
          state.update("playbackRate", rate);
        },
        enableLiveCatchUp() {
          catchUpModeController.enableCatchUp();
        },
        disableLiveCatchUp() {
          catchUpModeController.stopCatchUp();
        },
        showDebugElement() {
          if (debugEltInstance !== void 0) {
            debugEltInstance.dispose();
          }
          debugEltInstance = player.createDebugElement(debugElement);
        },
        hideDebugElement() {
          if (debugEltInstance !== void 0) {
            debugEltInstance.dispose();
            debugEltInstance = void 0;
          }
        },
        isDebugElementShown() {
          return debugEltInstance !== void 0;
        }
      };
      function dettachVideoThumbnailLoader() {
        const videoThumbnailLoader = state.get("videoThumbnailLoader");
        if (videoThumbnailLoader !== null) {
          videoThumbnailLoader.dispose();
          state.updateBulk({
            videoThumbnailLoader: null,
            videoThumbnailsElement: null
          });
        }
      }
      function attachMultithread(player2) {
        hasAttachedMultithread = true;
        player2.attachWorker({
          workerUrl: "./worker.js",
          dashWasmUrl: "./mpd-parser.wasm"
        }).catch((err) => {
          console.error("Error when attaching worker:", err);
        });
      }
    }
  );
  var player_default = PlayerModule;

  // demo/scripts/controllers/ControlBar.tsx
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var React14 = __toESM(require_react());

  // demo/scripts/components/Button.tsx
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var React2 = __toESM(require_react());
  function Button({
    ariaLabel,
    className = "",
    onClick,
    value,
    disabled,
    title
  }) {
    if (disabled) {
      return /* @__PURE__ */ React2.createElement(
        "button",
        {
          "aria-label": ariaLabel,
          disabled: true,
          className: className + " disabled",
          title
        },
        value
      );
    }
    return /* @__PURE__ */ React2.createElement(
      "button",
      {
        "aria-label": ariaLabel,
        className,
        tabIndex: 0,
        onClick,
        title
      },
      value
    );
  }
  var Button_default = React2.memo(Button);

  // demo/scripts/components/PositionInfos.tsx
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var React3 = __toESM(require_react());

  // demo/scripts/lib/time.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var toMinutes = (timeInSeconds) => {
    const toInt = Math.floor(timeInSeconds);
    if (!toInt) {
      return "00:00";
    }
    if (toInt < 60) {
      const str = String(toInt);
      return "00:" + str.padStart(2, "0");
    }
    const numberOfMinutes = Math.floor(toInt / 60);
    const numberOfSecondsRemaining = toInt % 60;
    return String(numberOfMinutes).padStart(2, "0") + ":" + String(numberOfSecondsRemaining).padStart(2, "0");
  };
  var toHours = (timeInSeconds) => {
    const toInt = Math.floor(timeInSeconds);
    if (!toInt) {
      return "00:00";
    }
    if (toInt < 60) {
      const str = String(toInt);
      return "00:" + str.padStart(2, "0");
    }
    const numberOfMinutes = Math.floor(toInt / 60);
    const numberOfSecondsRemaining = toInt % 60;
    if (numberOfMinutes < 60) {
      return String(numberOfMinutes).padStart(2, "0") + ":" + String(numberOfSecondsRemaining).padStart(2, "0");
    }
    const numberOfHours = Math.floor(numberOfMinutes / 60);
    const numberOfMinutesRemaining = numberOfMinutes % 60;
    return String(numberOfHours).padStart(2, "0") + ":" + String(numberOfMinutesRemaining).padStart(2, "0") + ":" + String(numberOfSecondsRemaining).padStart(2, "0");
  };

  // demo/scripts/components/PositionInfos.tsx
  function PositionInfos({
    className = "",
    position = 0,
    duration = 0
  }) {
    const convertTime = duration >= 60 * 60 ? toHours : toMinutes;
    return /* @__PURE__ */ React3.createElement("div", { className: "position-infos " + className }, /* @__PURE__ */ React3.createElement("span", { className: "current-position" }, convertTime(position)), /* @__PURE__ */ React3.createElement("span", { className: "separator" }, " / "), /* @__PURE__ */ React3.createElement("span", { className: "duration" }, convertTime(duration)));
  }
  var PositionInfos_default = React3.memo(PositionInfos);

  // demo/scripts/components/LivePosition.tsx
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var React4 = __toESM(require_react());
  function LivePosition({ className = "" }) {
    return /* @__PURE__ */ React4.createElement("div", { className: "position-infos live " + className }, "Live");
  }
  var LivePosition_default = React4.memo(LivePosition);

  // demo/scripts/components/StickToLiveEdgeButton.tsx
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var React5 = __toESM(require_react());
  function StickToLiveEdgeButton({
    isStickingToTheLiveEdge,
    changeStickToLiveEdge
  }) {
    const onClick = React5.useCallback(() => {
      changeStickToLiveEdge(!isStickingToTheLiveEdge);
    }, [changeStickToLiveEdge, isStickingToTheLiveEdge]);
    return /* @__PURE__ */ React5.createElement(
      "button",
      {
        className: "running" + (isStickingToTheLiveEdge ? " clicked" : ""),
        "aria-label": "Stay close to the live edge",
        title: "Stick to the live edge",
        onClick
      },
      /* @__PURE__ */ React5.createElement("svg", { version: "1.1", viewBox: "0 0 21.803 21.803" }, /* @__PURE__ */ React5.createElement("path", { d: "m18.374 16.605l-4.076-2.101-1.107-1.773-0.757-4.503 2.219 1.092-0.375 1.494c-0.13 0.519 0.185 1.041 0.699 1.17 0.077 0.021 0.157 0.03 0.235 0.03 0.432-2e-3 0.823-0.293 0.935-0.729l0.565-2.25c0.11-0.439-0.103-0.897-0.511-1.101 0 0-5.303-2.603-5.328-2.612-0.406-0.188-0.868-0.267-1.342-0.198-0.625 0.088-1.158 0.407-1.528 0.86-0.029 0.027-2.565 3.15-2.565 3.15l-1.95 0.525c-0.514 0.141-0.818 0.668-0.679 1.184 0.116 0.43 0.505 0.713 0.93 0.713 0.083 0 0.168-0.011 0.252-0.033l2.252-0.606c0.196-0.055 0.37-0.167 0.498-0.324l1.009-1.247 0.725 4.026-1.27 1.01c-0.379 0.304-0.541 0.802-0.411 1.269l1.469 5.271c0.148 0.532 0.633 0.881 1.16 0.881 0.107 0 0.216-0.015 0.324-0.045 0.641-0.178 1.016-0.842 0.837-1.482l-1.254-4.502 1.948-1.498 1.151 1.791c0.115 0.186 0.277 0.334 0.471 0.436l4.371 2.25c0.177 0.092 0.363 0.135 0.552 0.135 0.438 0 0.856-0.238 1.072-0.653 0.303-0.6 0.07-1.325-0.521-1.63z" }), /* @__PURE__ */ React5.createElement("circle", { cx: "8.602", cy: "2.568", r: "2.568" }))
    );
  }
  var StickToLiveEdgeButton_default = React5.memo(StickToLiveEdgeButton);

  // demo/scripts/controllers/PlayPauseButton.tsx
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var React6 = __toESM(require_react());

  // demo/scripts/lib/useModuleState.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var import_react = __toESM(require_react());
  function useModuleState(modul, stateName) {
    const [value, setValue] = (0, import_react.useState)(modul.getState(stateName));
    (0, import_react.useEffect)(() => {
      setValue(modul.getState(stateName));
      const stopListening = modul.listenToState(
        stateName,
        (newVal) => setValue(newVal)
      );
      return stopListening;
    }, [modul]);
    return value;
  }

  // demo/scripts/controllers/PlayPauseButton.tsx
  function PlayPauseButton({
    className = "",
    player
  }) {
    const cannotLoadMetadata = useModuleState(player, "cannotLoadMetadata");
    const isPaused = useModuleState(player, "isPaused");
    const isContentLoaded = useModuleState(player, "isContentLoaded");
    const hasEnded = useModuleState(player, "hasEnded");
    const disabled = !isContentLoaded && !cannotLoadMetadata;
    const displayPause = !isPaused && isContentLoaded && !hasEnded;
    const completeClassName = "play-pause-button " + className + (disabled ? " disabled" : "");
    const play = React6.useCallback(() => {
      player.actions.play();
    }, [player]);
    const pause = React6.useCallback(() => {
      player.actions.disableLiveCatchUp();
      player.actions.pause();
    }, [player]);
    return /* @__PURE__ */ React6.createElement(
      Button_default,
      {
        ariaLabel: "Pause/Resume the content",
        className: completeClassName,
        disabled,
        onClick: displayPause ? pause : play,
        value: String.fromCharCode(displayPause ? 61516 : 61515)
      }
    );
  }
  var PlayPauseButton_default = React6.memo(PlayPauseButton);

  // demo/scripts/controllers/FullScreenButton.tsx
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var React7 = __toESM(require_react());

  // demo/scripts/lib/fullscreen.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function addFullscreenListener(listener) {
    document.addEventListener("webkitfullscreenchange", listener, false);
    document.addEventListener("mozfullscreenchange", listener, false);
    document.addEventListener("fullscreenchange", listener, false);
    document.addEventListener("MSFullscreenChange", listener, false);
  }
  function removeFullscreenListener(listener) {
    document.removeEventListener("webkitfullscreenchange", listener, false);
    document.removeEventListener("mozfullscreenchange", listener, false);
    document.removeEventListener("fullscreenchange", listener, false);
    document.removeEventListener("MSFullscreenChange", listener, false);
  }
  function isFullscreen() {
    return !!(document.fullscreenElement || /* eslint-disable */
    document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement);
  }
  function requestFullscreen(elt) {
    if (!isFullscreen()) {
      if (elt.requestFullscreen) {
        elt.requestFullscreen();
      } else if (elt.msRequestFullscreen) {
        elt.msRequestFullscreen();
      } else if (elt.mozRequestFullScreen) {
        elt.mozRequestFullScreen();
      } else if (elt.webkitRequestFullscreen) {
        elt.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
      }
    }
  }
  function exitFullscreen() {
    if (isFullscreen()) {
      if (document.exitFullscreen) {
        document.exitFullscreen();
      } else if (document.msExitFullscreen) {
        document.msExitFullscreen();
      } else if (document.mozCancelFullScreen) {
        document.mozCancelFullScreen();
      } else if (document.webkitExitFullscreen) {
        document.webkitExitFullscreen();
      }
    }
  }

  // demo/scripts/controllers/FullScreenButton.tsx
  var { useCallback: useCallback3, useEffect: useEffect3, useMemo, useState: useState2 } = React7;
  function FullscreenButton({
    playerWrapperElementRef,
    player,
    className
  }) {
    const hasCurrentContent = useModuleState(player, "hasCurrentContent");
    const isInitiallyFullscreen = useMemo(() => isFullscreen(), []);
    const [isCurrentlyFullScreen, setIsCurrentlyFullScreen] = useState2(isInitiallyFullscreen);
    useEffect3(() => {
      const fullscreenListener = () => {
        const isInFullscreen = isFullscreen();
        if (!isInFullscreen && playerWrapperElementRef.current !== null) {
          playerWrapperElementRef.current.classList.remove("fullscreen");
        }
        setIsCurrentlyFullScreen(isInFullscreen);
      };
      addFullscreenListener(fullscreenListener);
      return () => {
        removeFullscreenListener(fullscreenListener);
      };
    }, [playerWrapperElementRef]);
    const setFullscreen = useCallback3(() => {
      if (playerWrapperElementRef.current === null) {
        return;
      }
      requestFullscreen(playerWrapperElementRef.current);
      playerWrapperElementRef.current.classList.add("fullscreen");
    }, [playerWrapperElementRef]);
    return /* @__PURE__ */ React7.createElement(
      Button_default,
      {
        ariaLabel: "Go/Quit fullscreen",
        className: "fullscreen-button " + className,
        onClick: isCurrentlyFullScreen ? exitFullscreen : setFullscreen,
        disabled: !hasCurrentContent,
        value: String.fromCharCode(isCurrentlyFullScreen ? 61542 : 61541)
      }
    );
  }
  var FullScreenButton_default = React7.memo(FullscreenButton);

  // demo/scripts/controllers/ProgressBar.tsx
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var React11 = __toESM(require_react());

  // demo/scripts/components/ProgressBar.tsx
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var React8 = __toESM(require_react());
  function ProgressBar({
    seek,
    // seek callback, will be called with the position clicked
    position,
    bufferGap,
    minimumPosition,
    maximumPosition,
    onMouseOut,
    // callback called when the mouse stops hovering
    onMouseMove
    // callback called when the mouse starts hovering, with the
    // position and the event in arguments
  }) {
    const wrapperRef = React8.useRef(null);
    const usedMinimum = minimumPosition != null ? minimumPosition : 0;
    const usedMaximum = maximumPosition != null ? maximumPosition : 300;
    const duration = Math.max(usedMaximum - usedMinimum, 0);
    const getMousePosition = React8.useCallback(
      (event) => {
        if (wrapperRef.current === null) {
          return null;
        }
        const rect = wrapperRef.current.getBoundingClientRect();
        const point0 = rect.left;
        const clickPosPx = Math.max(event.clientX - point0, 0);
        const endPointPx = Math.max(rect.right - point0, 0);
        if (!endPointPx) {
          return 0;
        }
        return clickPosPx / endPointPx * duration + usedMinimum;
      },
      [duration, usedMinimum]
    );
    const bufferGapHotFix = isFinite(bufferGap) ? bufferGap : 0;
    const relativePosition = Math.max(position - usedMinimum, 0);
    const percentBuffered = Math.min((bufferGapHotFix + relativePosition) / duration, 1) * 100;
    const percentPosition = Math.min(relativePosition / duration, 1) * 100;
    const onProgressBarClick = React8.useCallback(
      (event) => {
        const mousePosition = getMousePosition(event);
        if (mousePosition !== null) {
          seek(mousePosition);
        }
      },
      [getMousePosition, seek]
    );
    const onProgressMouseMove = React8.useCallback(
      (event) => {
        const mousePosition = getMousePosition(event);
        if (mousePosition !== null) {
          onMouseMove(mousePosition, event);
        }
      },
      [getMousePosition, onMouseMove]
    );
    return /* @__PURE__ */ React8.createElement(
      "div",
      {
        className: "progress-bar-wrapper",
        ref: wrapperRef,
        onClick: onProgressBarClick,
        onMouseOut,
        onMouseMove: onProgressMouseMove
      },
      /* @__PURE__ */ React8.createElement(
        "div",
        {
          className: "progress-bar-current",
          style: {
            width: `${percentPosition}%`
          }
        }
      ),
      /* @__PURE__ */ React8.createElement(
        "div",
        {
          className: "progress-bar-buffered",
          style: {
            width: `${percentBuffered}%`
          }
        }
      )
    );
  }
  var ProgressBar_default = React8.memo(ProgressBar);

  // demo/scripts/components/ToolTip.tsx
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var React9 = __toESM(require_react());
  var { useEffect: useEffect4, useRef: useRef3 } = React9;
  function ToolTip({
    className,
    offset,
    text,
    xPosition
  }) {
    const wrapperEl = useRef3(null);
    useEffect4(() => {
      if (isNaN(+xPosition) || !wrapperEl.current) {
        return;
      }
      const rect = wrapperEl.current.getBoundingClientRect();
      const width = rect.width;
      const height = rect.height;
      const toSlideY = -height - 11;
      const toSlideX = xPosition - offset - width / 2;
      wrapperEl.current.style.transform = `translate(${toSlideX}px, ${toSlideY}px)`;
    });
    return /* @__PURE__ */ React9.createElement("div", { className: "tooltip-wrapper", ref: wrapperEl }, /* @__PURE__ */ React9.createElement("pre", { className: "tooltip " + className }, text));
  }
  var ToolTip_default = React9.memo(ToolTip);

  // demo/scripts/components/ThumbnailPreview.tsx
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var React10 = __toESM(require_react());
  var DIV_SPINNER_STYLE = {
    backgroundColor: "gray",
    position: "absolute",
    width: "100%",
    height: "100%",
    opacity: "50%",
    display: "flex",
    justifyContent: "center",
    alignItems: "center"
  };
  var IMG_SPINNER_STYLE = {
    width: "50%",
    margin: "auto"
  };
  function ThumbnailPreview({
    xPosition,
    time,
    player,
    showVideoThumbnail
  }) {
    const videoThumbnailLoader = useModuleState(player, "videoThumbnailLoader");
    const videoElement = useModuleState(player, "videoThumbnailsElement");
    const imageThumbnailElement = useModuleState(player, "imageThumbnailContainerElement");
    const parentElementRef = React10.useRef(null);
    const [shouldDisplaySpinner, setShouldDisplaySpinner] = React10.useState(true);
    const ceiledTime = Math.ceil(time);
    React10.useEffect(() => {
      if (showVideoThumbnail) {
        return;
      }
      if (parentElementRef.current !== null) {
        parentElementRef.current.appendChild(imageThumbnailElement);
      }
      return () => {
        if (parentElementRef.current !== null && parentElementRef.current.contains(imageThumbnailElement)) {
          parentElementRef.current.removeChild(imageThumbnailElement);
        }
      };
    }, [showVideoThumbnail]);
    React10.useEffect(() => {
      if (!showVideoThumbnail) {
        return;
      }
      if (videoElement !== null && parentElementRef.current !== null) {
        parentElementRef.current.appendChild(videoElement);
      }
      return () => {
        if (videoElement !== null && parentElementRef.current !== null && parentElementRef.current.contains(videoElement)) {
          parentElementRef.current.removeChild(videoElement);
        }
      };
    }, [videoElement, showVideoThumbnail]);
    React10.useEffect(() => {
      if (!showVideoThumbnail) {
        return;
      }
      player.actions.attachVideoThumbnailLoader();
      return () => {
        player.actions.dettachVideoThumbnailLoader();
      };
    }, [showVideoThumbnail]);
    React10.useEffect(() => {
      let spinnerTimeout = null;
      let loadThumbnailTimeout = null;
      startSpinnerTimeoutIfNotAlreadyStarted();
      loadThumbnailTimeout = window.setTimeout(() => {
        loadThumbnailTimeout = null;
        if (showVideoThumbnail) {
          if (videoThumbnailLoader === null) {
            return;
          }
          videoThumbnailLoader.setTime(ceiledTime).then(hideSpinner).catch((err) => {
            if (typeof err === "object" && err !== null && err.code === "ABORTED") {
              return;
            } else {
              hideSpinner();
              console.error("Error while loading thumbnails:", err);
            }
          });
        } else {
          const metadata = player.actions.getThumbnailMetadata(ceiledTime);
          const thumbnailTrack = metadata.reduce((acc, t) => {
            if (acc === null || acc.height === void 0) {
              return t;
            }
            if (t.height === void 0) {
              return acc;
            }
            if (acc.height > t.height) {
              return t.height > 100 ? t : acc;
            } else {
              return acc.height > 100 ? acc : t;
            }
          }, null);
          if (thumbnailTrack === null) {
            hideSpinner();
            return;
          }
          player.actions.renderThumbnail(ceiledTime, thumbnailTrack.id).then(hideSpinner).catch((err) => {
            if (typeof err === "object" && err !== null && err.code === "ABORTED") {
              return;
            } else {
              hideSpinner();
              console.warn("Error while loading thumbnails:", err);
            }
          });
        }
      }, 30);
      return () => {
        if (loadThumbnailTimeout !== null) {
          clearTimeout(loadThumbnailTimeout);
        }
        hideSpinner();
      };
      function startSpinnerTimeoutIfNotAlreadyStarted() {
        if (spinnerTimeout !== null) {
          return;
        }
        spinnerTimeout = window.setTimeout(() => {
          spinnerTimeout = null;
          setShouldDisplaySpinner(true);
        }, 150);
      }
      function hideSpinner() {
        if (spinnerTimeout !== null) {
          clearTimeout(spinnerTimeout);
          spinnerTimeout = null;
        }
        setShouldDisplaySpinner(false);
      }
    }, [ceiledTime, videoThumbnailLoader, parentElementRef]);
    return /* @__PURE__ */ React10.createElement(
      "div",
      {
        className: "thumbnail-wrapper",
        style: xPosition !== null ? { transform: `translate(${xPosition}px, -136px)` } : {},
        ref: parentElementRef
      },
      shouldDisplaySpinner ? /* @__PURE__ */ React10.createElement("div", { style: DIV_SPINNER_STYLE }, /* @__PURE__ */ React10.createElement("img", { src: "./assets/spinner.gif", style: IMG_SPINNER_STYLE })) : null
    );
  }

  // demo/scripts/controllers/ProgressBar.tsx
  function ProgressBar2({
    player,
    enableVideoThumbnails,
    onSeek
  }) {
    const bufferGap = useModuleState(player, "bufferGap");
    const currentTime = useModuleState(player, "currentTime");
    const isContentLoaded = useModuleState(player, "isContentLoaded");
    const isLive = useModuleState(player, "isLive");
    const minimumPosition = useModuleState(player, "minimumPosition");
    const livePosition = useModuleState(player, "livePosition");
    const maximumPosition = useModuleState(player, "maximumPosition");
    const [timeIndicatorVisible, setTimeIndicatorVisible] = React11.useState(false);
    const [timeIndicatorPosition, setTimeIndicatorPosition] = React11.useState(0);
    const [timeIndicatorText, setTimeIndicatorText] = React11.useState("");
    const [thumbnailIsVisible, setThumbnailIsVisible] = React11.useState(false);
    const [tipPosition, setTipPosition] = React11.useState(0);
    const [imageTime, setImageTime] = React11.useState(null);
    const wrapperElementRef = React11.useRef(null);
    const showTimeIndicator = React11.useCallback(
      (wallClockTime, clientX) => {
        let hours;
        let minutes;
        let seconds;
        if (isLive) {
          const date = new Date(wallClockTime * 1e3);
          hours = date.getHours();
          minutes = date.getMinutes();
          seconds = date.getSeconds();
        } else {
          hours = Math.floor(wallClockTime / 3600);
          minutes = Math.floor((wallClockTime - hours * 3600) / 60);
          seconds = Math.floor(wallClockTime - (minutes * 60 + hours * 3600));
        }
        const currentReadableTime = hours.toString().padStart(2, "0") + ":" + minutes.toString().padStart(2, "0") + ":" + seconds.toString().padStart(2, "0");
        setTimeIndicatorVisible(true);
        setTimeIndicatorPosition(clientX);
        setTimeIndicatorText(currentReadableTime);
      },
      [isLive]
    );
    const hideTimeIndicator = React11.useCallback(() => {
      setTimeIndicatorVisible(false);
      setTimeIndicatorPosition(0);
      setTimeIndicatorText("");
    }, [isLive]);
    const showThumbnail = React11.useCallback((ts, clientX) => {
      const timestampToMs = ts;
      setThumbnailIsVisible(true);
      setTipPosition(clientX);
      setImageTime(timestampToMs);
    }, []);
    const hideThumbnail = React11.useCallback(() => {
      setThumbnailIsVisible(false);
      setTipPosition(0);
      setImageTime(null);
    }, []);
    const seek = React11.useCallback(
      (position) => {
        player.actions.seek(position);
        onSeek();
      },
      [player]
    );
    const hideToolTips = React11.useCallback(() => {
      hideTimeIndicator();
      hideThumbnail();
    }, [hideThumbnail, hideTimeIndicator]);
    const onMouseMove = React11.useCallback(
      (position, event) => {
        const wallClockDiff = player.getState("wallClockDiff");
        const wallClockTime = position + (wallClockDiff != null ? wallClockDiff : 0);
        showTimeIndicator(wallClockTime, event.clientX);
        showThumbnail(position, event.clientX);
      },
      [player, showTimeIndicator, showThumbnail]
    );
    const toolTipOffset = wrapperElementRef.current !== null ? wrapperElementRef.current.getBoundingClientRect().left : 0;
    if (!isContentLoaded) {
      return /* @__PURE__ */ React11.createElement("div", { className: "progress-bar-parent", ref: wrapperElementRef }, /* @__PURE__ */ React11.createElement("div", { className: "progress-bar-wrapper" }));
    }
    let thumbnailElement = null;
    if (thumbnailIsVisible) {
      const xThumbnailPosition = tipPosition - toolTipOffset;
      if (imageTime !== null) {
        thumbnailElement = /* @__PURE__ */ React11.createElement(
          ThumbnailPreview,
          {
            xPosition: xThumbnailPosition,
            time: imageTime,
            player,
            showVideoThumbnail: enableVideoThumbnails
          }
        );
      }
    }
    return /* @__PURE__ */ React11.createElement("div", { className: "progress-bar-parent", ref: wrapperElementRef }, timeIndicatorVisible ? /* @__PURE__ */ React11.createElement(
      ToolTip_default,
      {
        className: "progress-tip",
        text: timeIndicatorText,
        xPosition: timeIndicatorPosition,
        offset: toolTipOffset
      }
    ) : null, thumbnailElement, currentTime === void 0 ? null : /* @__PURE__ */ React11.createElement(
      ProgressBar_default,
      {
        seek,
        onMouseOut: hideToolTips,
        onMouseMove,
        position: currentTime,
        minimumPosition,
        maximumPosition: livePosition != null ? livePosition : maximumPosition,
        bufferGap
      }
    ));
  }
  var ProgressBar_default2 = React11.memo(ProgressBar2);

  // demo/scripts/controllers/VolumeButton.tsx
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var React12 = __toESM(require_react());
  function VolumeButton({
    className = "",
    player
  }) {
    const { muted, volume } = useModuleState(player, "volumeInfo");
    let volumeLevelClass;
    let charCode;
    if (muted || volume === 0) {
      volumeLevelClass = "muted";
      charCode = 61478;
    } else if (volume <= 0.5) {
      volumeLevelClass = "low";
      charCode = 61479;
    } else {
      volumeLevelClass = "high";
      charCode = 61480;
    }
    const onClick = React12.useCallback(() => {
      if (muted) {
        player.actions.unmute();
      } else {
        player.actions.mute();
      }
      if (volume === 0) {
        player.actions.setVolume(0.3);
      }
    }, [volume, muted]);
    return /* @__PURE__ */ React12.createElement(
      Button_default,
      {
        ariaLabel: "Mute/Unmute audio",
        className: `volume-button ${className} ${volumeLevelClass}`,
        onClick,
        value: String.fromCharCode(charCode),
        disabled: false
      }
    );
  }
  var VolumeButton_default = React12.memo(VolumeButton);

  // demo/scripts/controllers/VolumeBar.tsx
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var React13 = __toESM(require_react());
  function VolumeBar({
    player
    // current volume percentage
  }) {
    const { volume, muted } = useModuleState(player, "volumeInfo");
    const elementRef = React13.useRef(null);
    const getMouseVolume = React13.useCallback((event) => {
      if (elementRef.current === null) {
        return;
      }
      const rect = elementRef.current.getBoundingClientRect();
      const point0 = rect.left;
      const clickPosPx = Math.max(event.clientX - point0, 0);
      const endPointPx = Math.max(rect.right - point0, 0);
      if (!endPointPx) {
        return 0;
      }
      return Math.min(clickPosPx / endPointPx, 1);
    }, []);
    const onVolumeClick = React13.useCallback(
      (evt) => {
        const newVol = getMouseVolume(evt);
        if (newVol !== void 0) {
          if (newVol === 0) {
            player.actions.mute();
          } else {
            player.actions.setVolume(newVol);
            player.actions.unmute();
          }
        }
      },
      [player]
    );
    return /* @__PURE__ */ React13.createElement(
      "div",
      {
        className: "volume-bar-wrapper",
        ref: elementRef,
        tabIndex: 0,
        onKeyDown: (evt) => {
          if (evt.keyCode === 39 || evt.code === "ArrowRight") {
            player.actions.setVolume(Math.min(1, volume + 0.1));
          } else if (evt.keyCode === 37 || evt.code === "ArrowLeft") {
            player.actions.setVolume(Math.max(0, volume - 0.1));
          }
        },
        onClick: onVolumeClick
      },
      /* @__PURE__ */ React13.createElement(
        "div",
        {
          className: "volume-bar-current",
          style: { width: muted ? "0%" : `${volume * 100}%` }
        }
      )
    );
  }
  var VolumeBar_default = React13.memo(VolumeBar);

  // demo/scripts/controllers/ControlBar.tsx
  var { useCallback: useCallback9, useMemo: useMemo2 } = React14;
  function ControlBar({
    enableVideoThumbnails,
    player,
    stopVideo,
    toggleSettings,
    playerWrapperElementRef
  }) {
    const currentTime = useModuleState(player, "currentTime");
    const duration = useModuleState(player, "duration");
    const isCatchUpEnabled = useModuleState(player, "isCatchUpEnabled");
    const isCatchingUp = useModuleState(player, "isCatchingUp");
    const isContentLoaded = useModuleState(player, "isContentLoaded");
    const isLive = useModuleState(player, "isLive");
    const isPaused = useModuleState(player, "isPaused");
    const isStopped = useModuleState(player, "isStopped");
    const liveGap = useModuleState(player, "liveGap");
    const lowLatencyMode = useModuleState(player, "lowLatencyMode");
    const livePosition = useModuleState(player, "livePosition");
    const maximumPosition = useModuleState(player, "maximumPosition");
    const playbackRate = useModuleState(player, "playbackRate");
    const changeStickToLiveEdge = useCallback9(
      (shouldStick) => {
        if (shouldStick) {
          player.actions.enableLiveCatchUp();
        } else {
          player.actions.disableLiveCatchUp();
        }
      },
      [player]
    );
    let isCloseToLive = void 0;
    if (isLive && lowLatencyMode != null && liveGap != null) {
      isCloseToLive = lowLatencyMode ? liveGap < 7 : liveGap < 18;
    }
    const positionElement = useMemo2(() => {
      if (!isContentLoaded) {
        return null;
      } else if (isLive) {
        return /* @__PURE__ */ React14.createElement(LivePosition_default, null);
      } else {
        return /* @__PURE__ */ React14.createElement(PositionInfos_default, { position: currentTime, duration });
      }
    }, [isContentLoaded, isLive, currentTime, duration]);
    const onSeek = useCallback9(() => {
      changeStickToLiveEdge(false);
    }, [changeStickToLiveEdge]);
    const toggleSeekToLiveEdge = useCallback9(() => {
      changeStickToLiveEdge(!isCatchUpEnabled);
    }, [changeStickToLiveEdge, isCatchUpEnabled]);
    const isAtLiveEdge = isLive && isCloseToLive && !isCatchingUp;
    const onLiveDotClick = React14.useCallback(() => {
      const livePos = livePosition != null ? livePosition : maximumPosition;
      if (livePos == null) {
        console.error("Cannot go back to live: live position not found");
        return;
      }
      if (!isAtLiveEdge) {
        player.actions.seek(livePos - (lowLatencyMode ? 4 : 10));
      }
    }, [isAtLiveEdge, player, livePosition, maximumPosition, lowLatencyMode]);
    return /* @__PURE__ */ React14.createElement("div", { className: "controls-bar-container" }, /* @__PURE__ */ React14.createElement(
      ProgressBar_default2,
      {
        player,
        enableVideoThumbnails,
        onSeek
      }
    ), /* @__PURE__ */ React14.createElement("div", { className: "controls-bar" }, /* @__PURE__ */ React14.createElement(PlayPauseButton_default, { className: "control-button", player }), /* @__PURE__ */ React14.createElement(
      Button_default,
      {
        className: "control-button",
        ariaLabel: "Stop playback",
        onClick: stopVideo,
        value: String.fromCharCode(61517),
        disabled: isStopped
      }
    ), isContentLoaded && isLive && lowLatencyMode ? /* @__PURE__ */ React14.createElement(
      StickToLiveEdgeButton_default,
      {
        isStickingToTheLiveEdge: isCatchUpEnabled,
        changeStickToLiveEdge: toggleSeekToLiveEdge
      }
    ) : null, positionElement, isLive && isContentLoaded ? /* @__PURE__ */ React14.createElement(
      Button_default,
      {
        ariaLabel: isAtLiveEdge ? "We're playing live" : "Go back to live",
        className: "dot" + (isAtLiveEdge ? " live" : ""),
        onClick: onLiveDotClick,
        disabled: !!isAtLiveEdge,
        value: ""
      }
    ) : null, /* @__PURE__ */ React14.createElement("div", { className: "controls-right-side" }, !isPaused && isCatchingUp && playbackRate > 1 ? /* @__PURE__ */ React14.createElement("div", { className: "catch-up" }, "Catch-up playback rate: " + String(playbackRate)) : null, /* @__PURE__ */ React14.createElement(
      Button_default,
      {
        ariaLabel: "Display/Hide controls",
        disabled: !isContentLoaded,
        className: "control-button",
        onClick: toggleSettings,
        value: String.fromCharCode(61459)
      }
    ), /* @__PURE__ */ React14.createElement("div", { className: "volume" }, /* @__PURE__ */ React14.createElement(VolumeButton_default, { className: "control-button", player }), /* @__PURE__ */ React14.createElement(VolumeBar_default, { player })), /* @__PURE__ */ React14.createElement(
      FullScreenButton_default,
      {
        className: "control-button",
        player,
        playerWrapperElementRef
      }
    ))));
  }
  var ControlBar_default = React14.memo(ControlBar);

  // demo/scripts/controllers/ContentList.tsx
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var React21 = __toESM(require_react());

  // demo/scripts/lib/localStorage.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var { localStorage } = window;
  var hasLocalStorage = !!localStorage;
  if (!hasLocalStorage) {
    console.warn(
      "`localStorage` is not available. You will not be able to store content information."
    );
  }
  var JS_LOCAL_STORAGE = [];
  function getLocalStorageContents() {
    if (!hasLocalStorage) {
      return JS_LOCAL_STORAGE;
    }
    const localStorageContents = [];
    const localContentItems = localStorage.getItem("rxPlayerLocalContents");
    if (localContentItems !== null) {
      try {
        const parsed = JSON.parse(localContentItems);
        localStorageContents.push(...parsed);
      } catch (err) {
        console.warn("Demo: Can't parse local storage content.");
      }
    }
    return localStorageContents;
  }
  function saveLocalStorageContents(localStorageContents) {
    if (!hasLocalStorage) {
      JS_LOCAL_STORAGE = localStorageContents;
      return;
    }
    localStorage.setItem("rxPlayerLocalContents", JSON.stringify(localStorageContents));
  }
  function storeContent(content) {
    const localStorageContents = getLocalStorageContents();
    let id;
    let index;
    if (content.id != null) {
      index = localStorageContents.findIndex((e) => e.id === id);
      id = content.id;
    } else {
      const lastContentID = localStorageContents.reduce((acc, val) => {
        const contentId = val.id || 0;
        return Math.max(acc, contentId);
      }, 0);
      id = lastContentID + 1;
      index = -1;
    }
    const localContent = {
      drmInfos: content.drmInfos,
      fallbackKeyError: content.fallbackKeyError,
      fallbackLicenseRequest: content.fallbackLicenseRequest,
      id,
      localContent: true,
      lowLatency: content.lowLatency,
      name: content.name,
      transport: content.transport,
      url: content.url
    };
    if (index > -1) {
      localStorageContents.splice(index, 1, localContent);
    } else {
      localStorageContents.push(localContent);
    }
    saveLocalStorageContents(localStorageContents);
    return localContent;
  }
  function removeStoredContent(id) {
    const localStorageContents = getLocalStorageContents();
    const idx = localStorageContents.findIndex((e) => e.id === id);
    if (idx < 0) {
      return false;
    }
    localStorageContents.splice(idx, 1);
    saveLocalStorageContents(localStorageContents);
    return true;
  }

  // demo/scripts/lib/parseDRMConfigurations.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // demo/scripts/lib/bytes.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function leUtf16ToStr(bytes) {
    let str = "";
    for (let i = 0; i < bytes.length; i += 2) {
      str += String.fromCharCode((bytes[i + 1] << 8) + bytes[i]);
    }
    return str;
  }
  function strToUtf82(str) {
    let utf8Str;
    const pcStr = encodeURIComponent(str);
    if (typeof window.unescape === "function") {
      utf8Str = unescape(pcStr);
    } else {
      const isHexChar = /[0-9a-fA-F]/;
      const pcStrLen = pcStr.length;
      utf8Str = "";
      for (let i = 0; i < pcStr.length; i++) {
        let wasPercentEncoded = false;
        if (pcStr[i] === "%") {
          if (i <= pcStrLen - 6 && pcStr[i + 1] === "u" && isHexChar.test(pcStr[i + 2]) && isHexChar.test(pcStr[i + 3]) && isHexChar.test(pcStr[i + 4]) && isHexChar.test(pcStr[i + 5])) {
            const charCode = parseInt(pcStr.substring(i + 1, i + 6), 16);
            utf8Str += String.fromCharCode(charCode);
            wasPercentEncoded = true;
            i += 5;
          } else if (i <= pcStrLen - 3 && isHexChar.test(pcStr[i + 1]) && isHexChar.test(pcStr[i + 2])) {
            const charCode = parseInt(pcStr.substring(i + 1, i + 3), 16);
            utf8Str += String.fromCharCode(charCode);
            wasPercentEncoded = true;
            i += 2;
          }
        }
        if (!wasPercentEncoded) {
          utf8Str += pcStr[i];
        }
      }
    }
    const res = new Uint8Array(utf8Str.length);
    for (let i = 0; i < utf8Str.length; i++) {
      res[i] = utf8Str.charCodeAt(i) & 255;
    }
    return res;
  }
  function stringFromCharCodes2(args) {
    const max = 16e3;
    let ret = "";
    for (let i = 0; i < args.length; i += max) {
      const subArray = args.subarray(i, i + max);
      ret += String.fromCharCode.apply(null, subArray);
    }
    return ret;
  }
  function intToHex2(num, size) {
    const toStr = num.toString(16);
    return toStr.length >= size ? toStr : new Array(size - toStr.length + 1).join("0") + toStr;
  }
  function utf8ToStr2(data2) {
    let uint8 = data2;
    if (uint8[0] === 239 && uint8[1] === 187 && uint8[2] === 191) {
      uint8 = uint8.subarray(3);
    }
    const utf8Str = stringFromCharCodes2(uint8);
    let escaped;
    if (typeof window.escape !== "function") {
      escaped = escape(utf8Str);
    } else {
      const nonEscapedChar = /[A-Za-z0-9*_+-./]/;
      escaped = "";
      for (let i = 0; i < utf8Str.length; i++) {
        if (nonEscapedChar.test(utf8Str[i])) {
          escaped += utf8Str[i];
        } else {
          const charCode = utf8Str.charCodeAt(i);
          escaped += charCode >= 256 ? "%u" + intToHex2(charCode, 4) : "%" + intToHex2(charCode, 2);
        }
      }
    }
    return decodeURIComponent(escaped);
  }

  // demo/scripts/lib/parseDRMConfigurations.ts
  async function parseDRMConfigurations(drmConfigurations) {
    const keySystems = await Promise.all(
      drmConfigurations.map((drmConfig) => {
        const {
          drm,
          fallbackKeyError,
          fallbackLicenseRequest,
          licenseServerUrl,
          serverCertificateUrl
        } = drmConfig;
        if (!licenseServerUrl) {
          return;
        }
        const type = drm.toLowerCase();
        const keySystem = {
          type,
          getLicense: generateGetLicense(licenseServerUrl, type, !!fallbackLicenseRequest),
          onKeyInternalError: fallbackKeyError ? "fallback" : "error",
          onKeyOutputRestricted: fallbackKeyError ? "fallback" : "error"
        };
        if (!serverCertificateUrl) {
          return keySystem;
        }
        return getServerCertificate(serverCertificateUrl).then((serverCertificate) => {
          keySystem.serverCertificate = serverCertificate;
          return keySystem;
        });
      })
    );
    return keySystems.filter((ks) => ks !== void 0);
  }
  function getServerCertificate(url) {
    return new Promise((resolve, reject) => {
      const xhr = new XMLHttpRequest();
      xhr.open("GET", url, true);
      xhr.responseType = "arraybuffer";
      xhr.onload = () => {
        if (xhr.status >= 200 && xhr.status < 300) {
          const serverCertificate = xhr.response;
          resolve(serverCertificate);
        } else {
          reject(new Error("Could not fetch serverCertificate: HTTP Status Error"));
        }
      };
      xhr.onerror = () => {
        reject(new Error("Could not fetch serverCertificate: Request Error"));
      };
      xhr.send();
    });
  }
  function formatPlayreadyChallenge(challenge) {
    let u8Challenge;
    if (!(challenge instanceof Uint8Array)) {
      if (challenge instanceof ArrayBuffer) {
        u8Challenge = new Uint8Array(challenge);
      } else {
        u8Challenge = new Uint8Array(challenge.buffer);
      }
    } else {
      u8Challenge = challenge;
    }
    const str = leUtf16ToStr(u8Challenge);
    const match = /<Challenge encoding="base64encoded">(.*)<\/Challenge>/.exec(str);
    const xml = match ? atob(match[1]) : utf8ToStr2(u8Challenge);
    return xml;
  }
  function generateGetLicense(licenseServerUrl, drmType, fallbackOnLastTry) {
    const isPlayready = drmType.indexOf("playready") !== -1;
    return (rawChallenge) => {
      const challenge = isPlayready ? formatPlayreadyChallenge(rawChallenge) : rawChallenge;
      const xhr = new XMLHttpRequest();
      xhr.open("POST", licenseServerUrl, true);
      return new Promise((resolve, reject) => {
        xhr.onerror = () => {
          const error = new Error("getLicense's request failed on an error");
          error.fallbackOnLastTry = fallbackOnLastTry;
          reject(error);
        };
        xhr.onload = (evt) => {
          if (xhr.status >= 200 && xhr.status < 300) {
            if (evt.target === null) {
              resolve(null);
              return;
            }
            const license = xhr.response;
            resolve(license);
          } else {
            const error = new Error(
              `getLicense's request finished with a ${xhr.status} HTTP error`
            );
            error.noRetry = fallbackOnLastTry;
            error.fallbackOnLastTry = fallbackOnLastTry;
            reject(error);
          }
        };
        if (isPlayready) {
          xhr.setRequestHeader("content-type", "text/xml; charset=utf-8");
        } else {
          xhr.responseType = "arraybuffer";
        }
        xhr.send(challenge);
      }).then(
        (license) => isPlayready && typeof license === "string" ? strToUtf82(license) : license
      );
    };
  }

  // demo/scripts/lib/url_hash.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function parseHashInURL(hashStr) {
    if (hashStr.length <= 1) {
      return null;
    }
    const parsed = {};
    const separatorChar = hashStr[1];
    let hashOffset = 2;
    const hashLen = hashStr.length;
    while (hashOffset + 1 <= hashLen) {
      const unparsedStr = hashStr.substring(hashOffset);
      const nextSeparator = unparsedStr.indexOf(separatorChar);
      const nextUnderscore = unparsedStr.indexOf("_");
      if (nextUnderscore <= 0 || nextSeparator >= 0 && nextUnderscore > nextSeparator) {
        const fieldLength = nextSeparator >= 0 ? nextSeparator : unparsedStr.length;
        const fieldName = unparsedStr.substring(0, fieldLength);
        hashOffset += fieldLength;
        parsed[fieldName] = true;
      } else {
        const fieldName = unparsedStr.substring(0, nextUnderscore);
        hashOffset += nextUnderscore + 1;
        const splitted = unparsedStr.substring(nextUnderscore + 1).split("=");
        if (!splitted.length) {
          return null;
        }
        const dataLength = splitted[0];
        const dataLengthLen = splitted[0].length + 1;
        hashOffset += dataLengthLen;
        const lenNb = parseInt(dataLength, 36);
        if (isNaN(lenNb)) {
          return null;
        }
        const dataStart = hashOffset;
        hashOffset += lenNb;
        const data2 = hashStr.substring(dataStart, hashOffset);
        parsed[fieldName] = data2;
      }
      hashOffset += 1;
    }
    return parsed;
  }
  function generateLinkForCustomContent({
    chosenDRMType,
    // DRM Choice
    customKeySystem,
    // key system of a custom DRM if one
    fallbackKeyError,
    // `true` if the corresponding switch is enabled
    fallbackLicenseRequest,
    // `true` if the corresponding switch is enabled
    licenseServerUrl,
    lowLatency,
    // True if the low-latency switch is enabled
    manifestURL,
    serverCertificateUrl,
    transport
    // Choice for the transport protocol
  }) {
    let urlString = "";
    let transportString = "";
    let licenseServerUrlString = "";
    let serverCertificateUrlString = "";
    let drmTypeString = "";
    let customKeySystemString = "";
    if (manifestURL) {
      urlString = "!manifest_" + manifestURL.length.toString(36) + "=" + manifestURL;
    }
    if (transport) {
      transportString = "!tech_" + transport.length.toString(36) + "=" + transport;
    }
    if (chosenDRMType) {
      drmTypeString = "!drm_" + chosenDRMType.length.toString(36) + "=" + chosenDRMType;
    }
    if (customKeySystem) {
      customKeySystemString = "!customKeySystem_" + customKeySystem.length.toString(36) + "=" + customKeySystem;
    }
    if (licenseServerUrl) {
      licenseServerUrlString = "!licenseServ_" + licenseServerUrl.length.toString(36) + "=" + licenseServerUrl;
    }
    if (serverCertificateUrl) {
      serverCertificateUrlString = "!certServ_" + serverCertificateUrl.length.toString(36) + "=" + serverCertificateUrl;
    }
    if (!transportString) {
      return null;
    }
    return location.protocol + "//" + location.hostname + (location.port ? ":" + location.port : "") + location.pathname + (location.search ? location.search : "") + "#" + (lowLatency ? "!lowLatency" : "") + (fallbackKeyError ? "!fallbackKeyError" : "") + (fallbackLicenseRequest ? "!fallbackLicenseRequest" : "") + transportString + urlString + drmTypeString + customKeySystemString + licenseServerUrlString + serverCertificateUrlString;
  }

  // demo/scripts/components/CheckBox.tsx
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var React15 = __toESM(require_react());

  // demo/scripts/lib/getCheckboxValue.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function getCheckBoxValue(checkBoxElt) {
    return checkBoxElt.type === "checkbox" ? !!checkBoxElt.checked : !!checkBoxElt.value;
  }
  var getCheckboxValue_default = getCheckBoxValue;

  // demo/scripts/components/CheckBox.tsx
  function Checkbox({
    ariaLabel,
    name: name2,
    checked,
    disabled,
    onChange,
    children,
    className
  }) {
    const onInputChange = React15.useCallback(
      (evt) => {
        onChange(getCheckboxValue_default(evt.target));
      },
      [onChange]
    );
    return (
      // TODO is "disabled properly handled here? To check
      /* @__PURE__ */ React15.createElement("div", { className: (className != null ? className : "") + (disabled ? " disabled" : "") }, /* @__PURE__ */ React15.createElement("label", { className: "switch" }, /* @__PURE__ */ React15.createElement(
        "input",
        {
          type: "checkbox",
          "aria-label": ariaLabel,
          name: name2,
          id: name2,
          checked,
          disabled,
          onChange: onInputChange
        }
      ), /* @__PURE__ */ React15.createElement("span", { className: "slider round" })), /* @__PURE__ */ React15.createElement("label", { htmlFor: name2 }, children))
    );
  }
  var CheckBox_default = Checkbox;

  // demo/scripts/components/FocusedInput.tsx
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var React16 = __toESM(require_react());
  var { useEffect: useEffect6, useRef: useRef7 } = React16;
  function FocusedInput({
    ariaLabel,
    className = "",
    onChange,
    value = "",
    placeholder = ""
  }) {
    const inputEl = useRef7(null);
    useEffect6(
      () => {
        if (inputEl.current != null) {
          inputEl.current.focus();
        }
      },
      []
    );
    const onInputChange = React16.useCallback(
      (evt) => {
        onChange(evt.target.value);
      },
      [onChange]
    );
    return /* @__PURE__ */ React16.createElement(
      "input",
      {
        ref: inputEl,
        className: "input " + className,
        "aria-label": ariaLabel,
        type: "text",
        placeholder,
        onChange: onInputChange,
        value
      }
    );
  }
  var FocusedInput_default = React16.memo(FocusedInput);

  // demo/scripts/components/Input.tsx
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var React17 = __toESM(require_react());
  function Input({
    ariaLabel,
    className = "",
    onChange,
    value = "",
    placeholder = ""
  }) {
    const onInputChange = React17.useCallback(
      (evt) => {
        onChange(evt.target.value);
      },
      [onChange]
    );
    return /* @__PURE__ */ React17.createElement(
      "input",
      {
        "aria-label": ariaLabel,
        className: "input " + className,
        type: "text",
        placeholder,
        onChange: onInputChange,
        value
      }
    );
  }
  var Input_default = React17.memo(Input);

  // demo/scripts/components/Select.tsx
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var React18 = __toESM(require_react());
  function Select({
    ariaLabel,
    children,
    className = "",
    name: name2,
    onChange,
    selected,
    options = [],
    disabled
  }) {
    let selectedIndex = typeof selected.index === "number" ? selected.index : void 0;
    const optionsEl = options.map((val, index) => {
      let optName;
      let optDisabled = false;
      if (typeof val === "object") {
        optName = val.name;
        optDisabled = val.disabled;
      } else {
        optName = val;
      }
      if (selectedIndex === void 0 && selected.value === optName) {
        selectedIndex = index;
      }
      return /* @__PURE__ */ React18.createElement("option", { key: index, value: index, disabled: optDisabled }, optName);
    });
    selectedIndex = selectedIndex || 0;
    const onSelectChange = React18.useCallback(
      (evt) => {
        const index = +evt.target.value;
        const valueObj = options[index];
        const value = typeof valueObj === "object" ? valueObj.name : valueObj;
        onChange({ index, value });
      },
      [options, onChange]
    );
    const selectEl = disabled ? /* @__PURE__ */ React18.createElement(
      "select",
      {
        "aria-label": ariaLabel,
        name: name2,
        value: selectedIndex,
        disabled: true,
        onChange: onSelectChange
      },
      optionsEl
    ) : /* @__PURE__ */ React18.createElement(
      "select",
      {
        name: name2,
        "aria-label": ariaLabel,
        value: selectedIndex,
        onChange: onSelectChange
      },
      optionsEl
    );
    if (children) {
      return /* @__PURE__ */ React18.createElement("section", { className: "select " + className }, /* @__PURE__ */ React18.createElement("label", { htmlFor: name2 }, children), selectEl);
    }
    return /* @__PURE__ */ React18.createElement("section", { className: "select " + className }, selectEl);
  }
  var Select_default = React18.memo(Select);

  // demo/scripts/contents.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // demo/scripts/metaplaylist_url.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var MetaPlaylistDASHSmooth = {
    type: "MPL",
    version: "0.1",
    dynamic: false,
    contents: [
      {
        url: "https://www.bok.net/dash/tears_of_steel/cleartext/stream.mpd",
        startTime: 0,
        endTime: 733.3,
        transport: "dash"
      },
      {
        url: "https://amssamples.streaming.mediaservices.windows.net/683f7e47-bd83-4427-b0a3-26a6c4547782/BigBuckBunny.ism/manifest",
        startTime: 733.3,
        endTime: 1368,
        transport: "smooth"
      }
    ]
  };
  var MetaPlaylistDASHSmoothBlob = new Blob([JSON.stringify(MetaPlaylistDASHSmooth)], {
    type: "application/json"
  });
  var metaplaylist_url_default = URL.createObjectURL(MetaPlaylistDASHSmoothBlob);

  // demo/scripts/contents.ts
  var DEFAULT_CONTENTS = [
    {
      name: "Tears of Steel (clear)",
      url: "https://www.bok.net/dash/tears_of_steel/cleartext/stream.mpd",
      transport: "dash",
      live: false
    },
    {
      name: "Live with thumbnail track",
      url: "https://livesim2.dashif.org/livesim2/testpic_2s/Manifest_thumbs.mpd",
      transport: "dash",
      live: true
    },
    {
      name: "Axinom CMAF multiple Audio and Text tracks Tears of steel",
      url: "https://media.axprod.net/TestVectors/Cmaf/clear_1080p_h264/manifest.mpd",
      transport: "dash",
      live: false
    },
    {
      name: "Multiple audio language",
      url: "https://dash.akamaized.net/dash264/TestCasesIOP41/MultiTrack/alternative_content/6/manifest_alternative_lang.mpd",
      transport: "dash",
      live: false
    },
    {
      name: "DASH-IF - Trickmode",
      url: "https://dash.akamaized.net/dash264/TestCases/9b/qualcomm/1/MultiRate.mpd",
      transport: "dash",
      live: false
    },
    {
      name: "DASH-IF - Multi-Subtitles",
      url: "https://livesim.dashif.org/dash/vod/testpic_2s/multi_subs.mpd",
      transport: "dash",
      live: false
    },
    {
      name: "DASH-IF - Audio-only",
      url: "https://dash.akamaized.net/dash264/TestCases/3a/fraunhofer/aac-lc_stereo_without_video/Sintel/sintel_audio_only_aaclc_stereo_sidx.mpd",
      transport: "dash",
      live: false
    },
    {
      name: "DASH IF - SegmentTemplate",
      url: "https://livesim.dashif.org/livesim/testpic_2s/Manifest.mpd",
      transport: "dash",
      live: true
    },
    {
      name: "DASH IF - SegmentTimeline",
      url: "https://livesim.dashif.org/livesim/segtimeline_1/testpic_2s/Manifest.mpd",
      transport: "dash",
      live: true
    },
    {
      name: "VOD with thumbnail track",
      url: "https://dash.akamaized.net/akamai/bbb_30fps/bbb_with_tiled_thumbnails.mpd",
      transport: "dash",
      live: false
    },
    {
      name: "Super SpeedWay",
      url: "https://playready.directtaps.net/smoothstreaming/SSWSS720H264/SuperSpeedway_720.ism/Manifest",
      transport: "smooth",
      live: false
    },
    {
      name: "Big Buck Bunny",
      url: "https://amssamples.streaming.mediaservices.windows.net/683f7e47-bd83-4427-b0a3-26a6c4547782/BigBuckBunny.ism/manifest",
      transport: "smooth",
      live: false
    },
    {
      name: "Taxi 3 SoundTrack (Audio-Only)",
      url: "https://playready.directtaps.net/smoothstreaming/ISMAAACLC/Taxi3_AACLC.ism/Manifest",
      transport: "smooth",
      live: false
    },
    {
      name: "Multi-Period (5 Periods of 2 min)",
      url: "https://download.tsi.telecom-paristech.fr/gpac/DASH_CONFORMANCE/TelecomParisTech/mp4-live-periods/mp4-live-periods-mpd.mpd",
      transport: "dash",
      live: false
    },
    {
      name: "Big Buck Bunny WEBM",
      url: "https://upload.wikimedia.org/wikipedia/commons/transcoded/8/88/Big_Buck_Bunny_alt.webm/Big_Buck_Bunny_alt.webm.360p.webm",
      transport: "directfile",
      live: false
    },
    {
      name: "Big Buck Bunny MP4",
      url: "http://download.blender.org/peach/bigbuckbunny_movies/BigBuckBunny_320x180.mp4",
      transport: "directfile",
      live: false
    },
    {
      name: "Wikipedia test OGG (AUDIO ONLY)",
      url: "https://upload.wikimedia.org/wikipedia/commons/f/f2/Median_test.ogg",
      transport: "directfile",
      live: false
    },
    {
      name: "Google - Sintel webm only",
      url: "https://storage.googleapis.com/shaka-demo-assets/sintel-webm-only/dash.mpd",
      transport: "dash",
      live: false
    },
    {
      name: "Multi Video Tracks",
      url: "https://storage.googleapis.com/shaka-demo-assets/angel-one/dash.mpd",
      transport: "dash",
      live: false
    },
    {
      name: "Mix of DASH and Smooth VOD Contents",
      url: metaplaylist_url_default,
      transport: "metaplaylist",
      live: false
    }
  ];
  var contents_default = DEFAULT_CONTENTS;

  // demo/scripts/components/GenerateLinkURL.tsx
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var React19 = __toESM(require_react());
  function GeneratedLinkURL({ url }) {
    if (url === void 0 || url === null || url === "") {
      return /* @__PURE__ */ React19.createElement("span", null, "URL: ", /* @__PURE__ */ React19.createElement("a", { className: "generated-url-link none" }, "Not a valid content!"));
    }
    return /* @__PURE__ */ React19.createElement("span", null, "URL: ", /* @__PURE__ */ React19.createElement("a", { className: "generated-url-link", href: url }, url));
  }
  var GenerateLinkURL_default = React19.memo(GeneratedLinkURL);

  // demo/scripts/components/GenerateLinkButton.tsx
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var React20 = __toESM(require_react());
  function GenerateLinkButton({
    enabled,
    onClick
  }) {
    return /* @__PURE__ */ React20.createElement(
      "button",
      {
        "aria-label": "Generate link for the current custom button",
        className: "link" + (enabled ? " enabled" : ""),
        onClick
      },
      /* @__PURE__ */ React20.createElement(
        "svg",
        {
          "aria-hidden": "true",
          focusable: "false",
          role: "img",
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 512 512"
        },
        /* @__PURE__ */ React20.createElement(
          "path",
          {
            fill: "currentColor",
            d: "M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"
          }
        )
      )
    );
  }
  var GenerateLinkButton_default = React20.memo(GenerateLinkButton);

  // demo/scripts/controllers/ContentList.tsx
  var win = window;
  var MediaKeys_ = win.MediaKeys || win.MozMediaKeys || win.WebKitMediaKeys || win.MSMediaKeys || null;
  var HAS_EME_APIs = typeof navigator.requestMediaKeySystemAccess === "function" || MediaKeys_ != null && MediaKeys_.prototype && typeof MediaKeys_.isTypeSupported === "function" || typeof HTMLVideoElement.prototype.webkitGenerateKeyRequest === "function";
  var IS_HTTPS = window.location.protocol.startsWith("https");
  var CUSTOM_DRM_NAME = "Other";
  var TRANSPORT_TYPES = ["DASH", "Smooth", "DirectFile", "MetaPlaylist"];
  var DRM_TYPES = ["Widevine", "Playready", "Clearkey", CUSTOM_DRM_NAME];
  var DISABLE_ENCRYPTED_CONTENT = !HAS_EME_APIs && !IS_HTTPS;
  var URL_DENOMINATIONS = {
    DASH: "URL to the MPD",
    Smooth: "URL to the Manifest",
    DirectFile: "URL to the content"
  };
  function formatContent(content) {
    var _a, _b, _c, _d;
    let displayName = (_a = content.name) != null ? _a : "undefined";
    let isDisabled = false;
    let isLocalContent = false;
    const url = (_b = content.url) != null ? _b : "";
    if (IS_HTTPS) {
      if ("localContent" in content && !content.localContent && url.startsWith("http:")) {
        displayName = "[HTTP only] " + displayName;
        isDisabled = true;
      }
    } else if (!HAS_EME_APIs && content.drmInfos && content.drmInfos.length) {
      displayName = "[HTTPS only] " + displayName;
      isDisabled = true;
    }
    if ("live" in content && content.live) {
      displayName += " (live)";
    }
    if ("localContent" in content && content.localContent) {
      displayName = (hasLocalStorage ? "[Stored] " : "[Saved] ") + displayName;
      isLocalContent = true;
    }
    return {
      contentName: (_c = content.name) != null ? _c : "undefined",
      displayName,
      drmInfos: (_d = content.drmInfos) != null ? _d : null,
      fallbackKeyError: "fallbackKeyError" in content && content.fallbackKeyError,
      fallbackLicenseRequest: "fallbackLicenseRequest" in content && content.fallbackLicenseRequest,
      id: "id" in content ? content.id : void 0,
      isDisabled,
      isLocalContent,
      isLowLatency: "lowLatency" in content && !!content.lowLatency,
      transport: content.transport,
      url
    };
  }
  function constructContentList() {
    const localStorageContents = getLocalStorageContents();
    const reversedStoredContents = localStorageContents.slice().reverse();
    const storedAndRegularContents = [...reversedStoredContents, ...contents_default];
    return TRANSPORT_TYPES.reduce(
      (acc, tech) => {
        const customLinkContent = {
          url: "",
          contentName: "",
          transport: tech,
          drmInfos: null,
          displayName: "Custom link",
          isLocalContent: false,
          isDisabled: false,
          isLowLatency: false,
          fallbackKeyError: void 0,
          fallbackLicenseRequest: void 0,
          id: void 0
        };
        const contents = storedAndRegularContents.filter(({ transport }) => transport === tech.toLowerCase()).map(formatContent);
        acc[tech] = [customLinkContent].concat(contents);
        return acc;
      },
      {}
    );
  }
  function generateLinkForContent(content, {
    transportType,
    fallbackKeyError,
    fallbackLicenseRequest
  }) {
    var _a, _b, _c, _d, _e;
    if (content == null) {
      return null;
    }
    const licenseServerUrl = content.drmInfos && content.drmInfos[0] && content.drmInfos[0].licenseServerUrl;
    const serverCertificateUrl = content.drmInfos && content.drmInfos[0] && content.drmInfos[0].serverCertificateUrl;
    return generateLinkForCustomContent({
      chosenDRMType: (_b = (_a = content.drmInfos) == null ? void 0 : _a[0]) == null ? void 0 : _b.drm,
      customKeySystem: (_e = (_d = (_c = content.drmInfos) == null ? void 0 : _c[0]) == null ? void 0 : _d.customKeySystem) != null ? _e : void 0,
      fallbackKeyError,
      fallbackLicenseRequest,
      manifestURL: content.url,
      licenseServerUrl: licenseServerUrl != null ? licenseServerUrl : void 0,
      lowLatency: !!content.isLowLatency,
      serverCertificateUrl: serverCertificateUrl != null ? serverCertificateUrl : void 0,
      transport: transportType
    });
  }
  function getIndexOfFirstEnabledContent(contentList) {
    let contentChoiceIndex = 1;
    if (contentList.length <= 0) {
      throw new Error("No content for the transport: " + TRANSPORT_TYPES[0]);
    }
    while (contentChoiceIndex < contentList.length && contentList[contentChoiceIndex].isDisabled) {
      contentChoiceIndex++;
    }
    if (contentChoiceIndex >= contentList.length) {
      return 0;
    }
    return contentChoiceIndex;
  }
  function getKeySystemsOption(drmInfos, {
    fallbackKeyError,
    fallbackLicenseRequest
  }) {
    const wantedDRMs = drmInfos.map((drmInfo) => ({
      drm: drmInfo.drm === CUSTOM_DRM_NAME ? drmInfo.customKeySystem : drmInfo.drm,
      licenseServerUrl: drmInfo.licenseServerUrl,
      serverCertificateUrl: drmInfo.serverCertificateUrl,
      fallbackKeyError,
      fallbackLicenseRequest
    })).filter((drmInfo) => drmInfo.drm !== void 0);
    return parseDRMConfigurations(wantedDRMs);
  }
  function ContentList({
    loadVideo,
    showOptions,
    onOptionToggle
  }) {
    var _a, _b;
    const initialContents = React21.useMemo(() => {
      return constructContentList();
    }, []);
    const [transportType, setTransportType] = React21.useState(TRANSPORT_TYPES[0]);
    const [contentChoiceIndex, setContentChoiceIndex] = React21.useState(0);
    const [contentNameField, setContentNameField] = React21.useState("");
    const [contentsPerType, setContentsPerType] = React21.useState(initialContents);
    const [chosenDRMType, setChosenDRMType] = React21.useState(DRM_TYPES[0]);
    const [customKeySystem, setCustomKeySystem] = React21.useState("");
    const [currentManifestURL, setCurrentManifestUrl] = React21.useState("");
    const [shouldDisplayGeneratedLink, setShouldDisplayGeneratedLink] = React21.useState(false);
    const [shouldDisplayDRMSettings, setShouldDisplayDRMSettings] = React21.useState(false);
    const [shouldFallbackOnKeyError, setShouldFallbackOnKeyError] = React21.useState(false);
    const [shouldFallbackOnLicenseReqError, setShouldFallbackOnLicenseReqError] = React21.useState(false);
    const [isSavingOrUpdating, setIsSavingOrUpdating] = React21.useState(false);
    const [licenseServerUrl, setLicenseServerUrl] = React21.useState("");
    const [serverCertificateUrl, setServerCertificateUrl] = React21.useState("");
    const [isLowLatencyChecked, setIsLowLatencyChecked] = React21.useState(false);
    const loadContent2 = React21.useCallback(
      (content) => {
        const {
          url,
          transport,
          fallbackKeyError,
          fallbackLicenseRequest,
          isLowLatency,
          drmInfos
        } = content;
        getKeySystemsOption(drmInfos != null ? drmInfos : [], {
          fallbackKeyError: !!fallbackKeyError,
          fallbackLicenseRequest: !!fallbackLicenseRequest
        }).then(
          (keySystems) => {
            loadVideo({
              url: url != null ? url : "",
              transport: transport != null ? transport : "",
              textTrackMode: "html",
              lowLatencyMode: isLowLatency,
              keySystems
            });
          },
          () => {
            console.error("Could not construct key systems option");
          }
        );
      },
      [loadVideo]
    );
    const loadUrl = React21.useCallback(
      (url, drmInfos) => {
        getKeySystemsOption(drmInfos, {
          fallbackKeyError: !!shouldFallbackOnKeyError,
          fallbackLicenseRequest: !!shouldFallbackOnLicenseReqError
        }).then(
          (keySystems) => {
            loadVideo({
              url,
              transport: transportType.toLowerCase(),
              textTrackMode: "html",
              lowLatencyMode: isLowLatencyChecked,
              keySystems
            });
          },
          () => {
            console.error("Could not construct key systems option");
          }
        );
      },
      [
        loadVideo,
        shouldFallbackOnKeyError,
        shouldFallbackOnLicenseReqError,
        transportType,
        isLowLatencyChecked
      ]
    );
    const changeSelectedContent = React21.useCallback(
      (index, content) => {
        var _a2, _b2;
        const fallbackKeyError = !!content.fallbackKeyError;
        const fallbackLicenseRequest = !!content.fallbackLicenseRequest;
        const isLowLatency = !!content.isLowLatency;
        let hasDRMSettings = false;
        let drm = null;
        let customKeySystem2 = "";
        let licenseServerUrl2 = "";
        let serverCertificateUrl2 = "";
        if (content.drmInfos != null && content.drmInfos.length > 0) {
          hasDRMSettings = true;
          drm = content.drmInfos[0].drm;
          customKeySystem2 = content.drmInfos[0].customKeySystem || "";
          licenseServerUrl2 = content.drmInfos[0].licenseServerUrl;
          serverCertificateUrl2 = (_a2 = content.drmInfos[0].serverCertificateUrl) != null ? _a2 : "";
        }
        setContentChoiceIndex(index);
        setContentNameField(content.contentName);
        setChosenDRMType(drm != null ? drm : DRM_TYPES[0]);
        setCustomKeySystem(customKeySystem2);
        setCurrentManifestUrl((_b2 = content.url) != null ? _b2 : "");
        setShouldDisplayDRMSettings(hasDRMSettings);
        setShouldDisplayGeneratedLink(false);
        setShouldFallbackOnLicenseReqError(fallbackLicenseRequest);
        setShouldFallbackOnKeyError(fallbackKeyError);
        setIsSavingOrUpdating(false);
        setIsLowLatencyChecked(isLowLatency);
        setLicenseServerUrl(licenseServerUrl2);
        setServerCertificateUrl(serverCertificateUrl2);
      },
      []
    );
    React21.useEffect(() => {
      var _a2;
      const parsedHash = parseHashInURL(location.hash);
      if (parsedHash !== null) {
        const { tech } = parsedHash;
        if (typeof tech === "string" && TRANSPORT_TYPES.includes(tech)) {
          const { fallbackKeyError, fallbackLicenseRequest, lowLatency } = parsedHash;
          setContentChoiceIndex(0);
          setContentNameField("");
          if (typeof parsedHash.manifest === "string") {
            setCurrentManifestUrl(parsedHash.manifest);
          }
          setShouldFallbackOnKeyError(!!fallbackKeyError);
          setShouldFallbackOnLicenseReqError(!!fallbackLicenseRequest);
          setIsLowLatencyChecked(tech === "DASH" && !!lowLatency);
          setTransportType(tech);
          const chosenDRMType2 = typeof parsedHash.drm === "string" && DRM_TYPES.includes(parsedHash.drm) ? parsedHash.drm : void 0;
          if (chosenDRMType2 !== void 0) {
            setShouldDisplayDRMSettings(true);
            setChosenDRMType(chosenDRMType2);
            if (typeof parsedHash.customKeySystem === "string") {
              setCustomKeySystem(parsedHash.customKeySystem);
            }
            if (typeof parsedHash.licenseServ === "string") {
              setLicenseServerUrl(parsedHash.licenseServ);
            }
            if (typeof parsedHash.certServ === "string") {
              setServerCertificateUrl(parsedHash.certServ);
            }
          }
          return;
        }
      }
      const contentList = (_a2 = contentsPerType[transportType]) != null ? _a2 : [];
      const firstEnabledContentIndex = getIndexOfFirstEnabledContent(contentList);
      const content = contentList[firstEnabledContentIndex];
      changeSelectedContent(firstEnabledContentIndex, content);
    }, []);
    const isCustomContent = contentChoiceIndex === 0;
    const isCustomDRM = chosenDRMType === CUSTOM_DRM_NAME;
    const contentsToSelect = (_a = contentsPerType[transportType]) != null ? _a : [];
    const chosenContent = contentsToSelect[contentChoiceIndex];
    let generatedLink = null;
    if (shouldDisplayGeneratedLink) {
      generatedLink = contentChoiceIndex === 0 || isSavingOrUpdating ? generateLinkForCustomContent({
        chosenDRMType: shouldDisplayDRMSettings ? chosenDRMType : void 0,
        customKeySystem: shouldDisplayDRMSettings ? customKeySystem : void 0,
        fallbackKeyError: shouldFallbackOnKeyError,
        fallbackLicenseRequest: shouldFallbackOnLicenseReqError,
        manifestURL: currentManifestURL,
        licenseServerUrl: shouldDisplayDRMSettings ? licenseServerUrl : void 0,
        lowLatency: isLowLatencyChecked,
        serverCertificateUrl: shouldDisplayDRMSettings ? serverCertificateUrl : void 0,
        transport: transportType
      }) : generateLinkForContent(chosenContent, {
        transportType,
        fallbackKeyError: shouldFallbackOnKeyError,
        fallbackLicenseRequest: shouldFallbackOnLicenseReqError
      });
    }
    const hasURL = currentManifestURL !== "";
    const isLocalContent = !!(chosenContent && chosenContent.isLocalContent);
    const onTransportChange = React21.useCallback(
      ({ value }) => {
        var _a2;
        setContentChoiceIndex(0);
        setContentNameField("");
        setChosenDRMType(DRM_TYPES[0]);
        setCustomKeySystem("");
        setCurrentManifestUrl("");
        setShouldDisplayDRMSettings(false);
        setShouldDisplayGeneratedLink(false);
        setShouldFallbackOnLicenseReqError(false);
        setShouldFallbackOnKeyError(false);
        setIsSavingOrUpdating(false);
        setLicenseServerUrl("");
        setIsLowLatencyChecked(false);
        setServerCertificateUrl("");
        setTransportType(value);
        const contents = (_a2 = contentsPerType[value]) != null ? _a2 : [];
        const firstEnabledContentIndex = getIndexOfFirstEnabledContent(contents);
        changeSelectedContent(firstEnabledContentIndex, contents[firstEnabledContentIndex]);
      },
      [contentsPerType, changeSelectedContent]
    );
    const onContentChoiceChange = React21.useCallback(
      ({ index }) => {
        const content = contentsToSelect[index];
        changeSelectedContent(index, content);
      },
      [contentsToSelect, changeSelectedContent]
    );
    const onClickLoad = () => {
      if (contentChoiceIndex === 0) {
        const drmInfos = [
          {
            licenseServerUrl,
            serverCertificateUrl,
            drm: chosenDRMType,
            customKeySystem
          }
        ];
        loadUrl(currentManifestURL, drmInfos);
      } else {
        loadContent2(contentsToSelect[contentChoiceIndex]);
      }
    };
    const saveCurrentContent = () => {
      var _a2;
      const contentToSave = {
        name: contentNameField,
        url: currentManifestURL,
        fallbackLicenseRequest: shouldFallbackOnLicenseReqError,
        fallbackKeyError: shouldFallbackOnKeyError,
        lowLatency: isLowLatencyChecked,
        transport: transportType.toLowerCase(),
        drmInfos: shouldDisplayDRMSettings ? [
          {
            drm: chosenDRMType,
            customKeySystem,
            licenseServerUrl,
            serverCertificateUrl
          }
        ] : null,
        id: chosenContent.id
      };
      const storedContent = storeContent(contentToSave);
      const contentList = constructContentList();
      setContentsPerType(contentList);
      setIsSavingOrUpdating(false);
      const contents = (_a2 = contentList[transportType]) != null ? _a2 : [];
      const firstEnabledContentIndex = contents.findIndex((c) => c.id === storedContent.id);
      if (firstEnabledContentIndex < 0) {
        console.warn("Stored content not found in local storage.");
        changeSelectedContent(0, contents[0]);
      } else {
        changeSelectedContent(firstEnabledContentIndex, contents[firstEnabledContentIndex]);
      }
    };
    const onClickSaveOrUpdate = React21.useCallback(() => {
      setIsSavingOrUpdating(true);
    }, []);
    const onClickErase = React21.useCallback(() => {
      var _a2;
      const content = contentsToSelect[contentChoiceIndex];
      if (content) {
        if (content.id === void 0) {
          console.error("Cannot erase: no id on the content");
          return;
        }
        const hasRemoved = removeStoredContent(content.id);
        if (hasRemoved) {
          const contentList = constructContentList();
          setContentsPerType(contentList);
          const contents = (_a2 = contentList[transportType]) != null ? _a2 : [];
          if (contentChoiceIndex >= contents.length) {
            changeSelectedContent(0, contents[0]);
          } else {
            changeSelectedContent(contentChoiceIndex, contents[contentChoiceIndex]);
          }
        }
      }
    }, [contentsToSelect, contentChoiceIndex]);
    const onNameInput = React21.useCallback((name2) => {
      setContentNameField(name2);
    }, []);
    const onManifestInput = React21.useCallback((manifestUrl) => {
      setCurrentManifestUrl(manifestUrl);
    }, []);
    const onCustomKeySystemInput = React21.useCallback((customKs) => {
      setCustomKeySystem(customKs);
    }, []);
    const onLicenseServerInput = React21.useCallback((licenseServUrl) => {
      setLicenseServerUrl(licenseServUrl);
    }, []);
    const onServerCertificateInput = React21.useCallback((serverCertUrl) => {
      setServerCertificateUrl(serverCertUrl);
    }, []);
    const onChangeDisplayDRMSettings = React21.useCallback((shouldDisplay) => {
      if (shouldDisplay) {
        setShouldDisplayDRMSettings(true);
      } else {
        setShouldDisplayDRMSettings(false);
        setLicenseServerUrl("");
        setServerCertificateUrl("");
      }
    }, []);
    const onLowLatencyClick = React21.useCallback((value) => {
      setIsLowLatencyChecked(value);
    }, []);
    const onDRMTypeClick = React21.useCallback((value) => {
      setChosenDRMType((oldType) => {
        if (oldType === value) {
          return value;
        }
        setCustomKeySystem("");
        return value;
      });
    }, []);
    const onCancel = React21.useCallback(() => {
      setIsSavingOrUpdating(false);
      changeSelectedContent(contentChoiceIndex, chosenContent);
    }, [changeSelectedContent, contentChoiceIndex, chosenContent]);
    const generateDRMButtons = React21.useCallback(() => {
      return DRM_TYPES.map((typ) => /* @__PURE__ */ React21.createElement("span", { key: typ }, /* @__PURE__ */ React21.createElement(
        Button_default,
        {
          className: "choice-input-button drm-button" + (chosenDRMType === typ ? " selected" : ""),
          ariaLabel: "Key system choice",
          onClick: () => onDRMTypeClick(typ),
          value: typ,
          disabled: false
        }
      )));
    }, [onDRMTypeClick, chosenDRMType]);
    const onClickGenerateLink = React21.useCallback(() => {
      setShouldDisplayGeneratedLink((oldVal) => !oldVal);
    }, []);
    const onChangeFallbackLicenseRequest = React21.useCallback((should) => {
      setShouldFallbackOnLicenseReqError(should);
    }, []);
    const onChangeFallbackKeyError = React21.useCallback((should) => {
      setShouldFallbackOnKeyError(should);
    }, []);
    const selectValues = React21.useMemo(() => {
      return contentsToSelect.map((c) => {
        return { name: c.displayName, disabled: c.isDisabled };
      });
    }, [contentsToSelect]);
    return /* @__PURE__ */ React21.createElement("div", { className: "choice-inputs-wrapper" }, /* @__PURE__ */ React21.createElement("span", { className: "generated-url" + (shouldDisplayGeneratedLink ? " enabled" : "") }, shouldDisplayGeneratedLink ? /* @__PURE__ */ React21.createElement(GenerateLinkURL_default, { url: generatedLink }) : null), /* @__PURE__ */ React21.createElement("div", { className: "content-inputs" }, /* @__PURE__ */ React21.createElement("div", { className: "content-inputs-selects" }, /* @__PURE__ */ React21.createElement(
      Select_default,
      {
        className: "choice-input transport-type-choice white-select",
        ariaLabel: "Select a transport",
        name: "transport",
        onChange: onTransportChange,
        options: TRANSPORT_TYPES,
        selected: { index: void 0, value: transportType },
        disabled: false
      }
    ), /* @__PURE__ */ React21.createElement(
      Select_default,
      {
        className: "choice-input content-choice white-select",
        ariaLabel: "Select a content",
        name: "content",
        onChange: onContentChoiceChange,
        options: selectValues,
        selected: { index: contentChoiceIndex, value: void 0 },
        disabled: false
      }
    )), /* @__PURE__ */ React21.createElement("div", { className: "content-inputs-middle" }, isCustomContent || isLocalContent ? [
      /* @__PURE__ */ React21.createElement(
        Button_default,
        {
          key: 0,
          className: "choice-input-button content-button enter-name-button" + (!hasURL ? " disabled" : ""),
          ariaLabel: "Save or update custom content",
          onClick: onClickSaveOrUpdate,
          disabled: !hasURL || isSavingOrUpdating,
          value: isLocalContent ? isSavingOrUpdating ? "Updating..." : "Update content" : isSavingOrUpdating ? "Saving..." : "Store content"
        }
      ),
      /* @__PURE__ */ React21.createElement(
        GenerateLinkButton_default,
        {
          key: 1,
          enabled: shouldDisplayGeneratedLink,
          onClick: onClickGenerateLink
        }
      )
    ] : null, isLocalContent ? /* @__PURE__ */ React21.createElement(
      Button_default,
      {
        className: "choice-input-button erase-button",
        ariaLabel: "Remove custom content from saved contents",
        onClick: onClickErase,
        value: String.fromCharCode(61944),
        disabled: false
      }
    ) : null), /* @__PURE__ */ React21.createElement("div", { className: "choice-input-button-wrapper" }, /* @__PURE__ */ React21.createElement(
      CheckBox_default,
      {
        className: "show-options",
        ariaLabel: "Show player options",
        checked: showOptions,
        onChange: onOptionToggle,
        name: "showOptions"
      },
      "Show Options"
    ), /* @__PURE__ */ React21.createElement(
      Button_default,
      {
        className: "choice-input-button load-button",
        ariaLabel: "Load the selected content now",
        onClick: onClickLoad,
        value: String.fromCharCode(61764),
        disabled: false
      }
    ))), isCustomContent || isLocalContent && isSavingOrUpdating ? /* @__PURE__ */ React21.createElement("div", { className: "custom-input-wrapper" }, isSavingOrUpdating ? /* @__PURE__ */ React21.createElement("div", { className: "update-control" }, /* @__PURE__ */ React21.createElement(
      FocusedInput_default,
      {
        className: "text-input need-to-fill",
        ariaLabel: "Name of the custom content to save",
        onChange: onNameInput,
        value: contentNameField,
        placeholder: "Content name"
      }
    ), /* @__PURE__ */ React21.createElement("div", { className: "update-control-buttons" }, /* @__PURE__ */ React21.createElement(
      Button_default,
      {
        className: "choice-input-button content-button save-button",
        ariaLabel: "Save/Update custom content",
        onClick: saveCurrentContent,
        disabled: !contentNameField || !currentManifestURL,
        value: isLocalContent ? "Update" : "Save"
      }
    ), /* @__PURE__ */ React21.createElement(
      Button_default,
      {
        ariaLabel: "Cancel current modifications for the custom content",
        className: "choice-input-button content-button cancel-button",
        onClick: onCancel,
        value: "Cancel",
        disabled: false
      }
    ))) : null, /* @__PURE__ */ React21.createElement(
      Input_default,
      {
        ariaLabel: "Enter here the Manifest's URL",
        className: "text-input",
        onChange: onManifestInput,
        value: currentManifestURL,
        placeholder: ((_b = URL_DENOMINATIONS[transportType]) != null ? _b : `URL to the ${transportType} content`) + (IS_HTTPS ? " (HTTPS only if mixed contents disabled)" : "")
      }
    ), /* @__PURE__ */ React21.createElement("div", { className: "player-box player-box-load" }, /* @__PURE__ */ React21.createElement(
      "span",
      {
        className: "encryption-checkbox custom-checkbox" + (DISABLE_ENCRYPTED_CONTENT ? " disabled" : "")
      },
      (DISABLE_ENCRYPTED_CONTENT ? "[HTTPS only] " : "") + "Encrypted content",
      /* @__PURE__ */ React21.createElement(
        CheckBox_default,
        {
          ariaLabel: "Enable for an encrypted content",
          disabled: DISABLE_ENCRYPTED_CONTENT,
          name: "displayDRMSettingsTextInput",
          checked: shouldDisplayDRMSettings,
          onChange: onChangeDisplayDRMSettings
        }
      )
    ), shouldDisplayDRMSettings ? /* @__PURE__ */ React21.createElement("div", { className: "drm-settings" }, /* @__PURE__ */ React21.createElement("div", { className: "drm-choice" }, generateDRMButtons()), isCustomDRM ? /* @__PURE__ */ React21.createElement("div", null, /* @__PURE__ */ React21.createElement(
      Input_default,
      {
        ariaLabel: 'Key system reverse domain name (e.g. "org.w3.clearkey")',
        className: "choice-input text-input",
        onChange: onCustomKeySystemInput,
        value: customKeySystem,
        placeholder: "Key system (reverse domain name)"
      }
    )) : null, /* @__PURE__ */ React21.createElement("div", null, /* @__PURE__ */ React21.createElement(
      Input_default,
      {
        ariaLabel: "URL for the license server",
        className: "choice-input text-input",
        onChange: onLicenseServerInput,
        value: licenseServerUrl,
        placeholder: "License URL Server"
      }
    )), /* @__PURE__ */ React21.createElement(
      Input_default,
      {
        ariaLabel: "URL for the server certificate (optional)",
        className: "choice-input text-input",
        onChange: onServerCertificateInput,
        value: serverCertificateUrl,
        placeholder: "Server certificate URL (optional)"
      }
    ), /* @__PURE__ */ React21.createElement("div", null, /* @__PURE__ */ React21.createElement("span", { className: "custom-checkbox fallback-checkbox" }, /* @__PURE__ */ React21.createElement("span", null, "Fallback if a key is refused ", /* @__PURE__ */ React21.createElement("span", { className: "checkbox-indication" }, "(for content with multiple keys)")), /* @__PURE__ */ React21.createElement(
      CheckBox_default,
      {
        ariaLabel: "Should fallback on key errors",
        name: "shouldFallbackOnKeyError",
        checked: shouldFallbackOnKeyError,
        onChange: onChangeFallbackKeyError
      }
    ))), /* @__PURE__ */ React21.createElement("div", null, /* @__PURE__ */ React21.createElement("span", { className: "custom-checkbox fallback-checkbox" }, /* @__PURE__ */ React21.createElement("span", null, "Fallback if the license request fails ", /* @__PURE__ */ React21.createElement("span", { className: "checkbox-indication" }, "(for content with multiple keys)")), /* @__PURE__ */ React21.createElement(
      CheckBox_default,
      {
        ariaLabel: "Should fallback on license requesting errors",
        name: "shouldFallbackOnLicenseReqError",
        checked: shouldFallbackOnLicenseReqError,
        onChange: onChangeFallbackLicenseRequest
      }
    )))) : null), transportType === "DASH" ? /* @__PURE__ */ React21.createElement("div", { className: "player-box player-box-load button-low-latency" }, /* @__PURE__ */ React21.createElement("span", { className: "low-latency-checkbox custom-checkbox" }, "Low-Latency content", /* @__PURE__ */ React21.createElement(
      CheckBox_default,
      {
        ariaLabel: "Enable for a low-latency content",
        name: "isLowLatencyChecked",
        checked: isLowLatencyChecked,
        onChange: onLowLatencyClick
      }
    ))) : null) : null);
  }
  var ContentList_default = React21.memo(ContentList);

  // demo/scripts/controllers/Settings.tsx
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var React30 = __toESM(require_react());

  // demo/scripts/components/Options/Option.tsx
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var React22 = __toESM(require_react());
  function Option({
    title,
    children
  }) {
    return /* @__PURE__ */ React22.createElement("div", { className: "optionWrapper" }, /* @__PURE__ */ React22.createElement("h4", { className: "optionTitle" }, title), /* @__PURE__ */ React22.createElement("hr", { className: "spacer" }), /* @__PURE__ */ React22.createElement("ul", { className: "loadVideooptions" }, children));
  }
  var Option_default = React22.memo(Option);

  // demo/scripts/components/Options/Playback.tsx
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var React23 = __toESM(require_react());
  function PlaybackConfig({
    autoPlay,
    onAutoPlayChange,
    tryRelyOnWorker,
    onTryRelyOnWorkerChange
  }) {
    return /* @__PURE__ */ React23.createElement(React23.Fragment, null, /* @__PURE__ */ React23.createElement("li", null, /* @__PURE__ */ React23.createElement(
      CheckBox_default,
      {
        className: "playerOptionsCheckBox playerOptionsCheckBoxTitle",
        name: "autoPlay",
        ariaLabel: "Auto play option",
        checked: autoPlay,
        onChange: onAutoPlayChange
      },
      "Auto Play"
    ), /* @__PURE__ */ React23.createElement("span", { className: "option-desc" }, autoPlay ? "Playing directly when the content is loaded." : "Staying in pause when the content is loaded.")), /* @__PURE__ */ React23.createElement("li", null, /* @__PURE__ */ React23.createElement(
      CheckBox_default,
      {
        className: "playerOptionsCheckBox playerOptionsCheckBoxTitle",
        name: "tryRelyOnWorker",
        ariaLabel: "Rely in a WebWorker when possible",
        checked: tryRelyOnWorker,
        onChange: onTryRelyOnWorkerChange
      },
      "Multithread mode (when possible)"
    ), /* @__PURE__ */ React23.createElement("span", { className: "option-desc" }, tryRelyOnWorker ? "Running the RxPlayer's main logic in a WebWorker when possible" : "Currently running the RxPlayer's main logic only in main thread.")));
  }
  var Playback_default = React23.memo(PlaybackConfig);

  // demo/scripts/components/Options/AudioAdaptiveSettings.tsx
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var React24 = __toESM(require_react());
  function AudioAdaptiveSettings({
    defaultAudioRepresentationsSwitchingMode,
    onDefaultAudioRepresentationsSwitchingModeChange
  }) {
    let defaultAudioRepresentationsSwitchingModeDescMsg;
    switch (defaultAudioRepresentationsSwitchingMode) {
      case "reload":
        defaultAudioRepresentationsSwitchingModeDescMsg = "Reloading by default when audio Representations are manually changed";
        break;
      case "lazy":
        defaultAudioRepresentationsSwitchingModeDescMsg = "Keeping previous data when audio Representations are manually changed";
        break;
      case "direct":
        defaultAudioRepresentationsSwitchingModeDescMsg = "Directly visible transition when audio Representations are manually changed";
        break;
      case "seamless":
        defaultAudioRepresentationsSwitchingModeDescMsg = "Smooth transition when audio Representations are manually changed";
        break;
      default:
        defaultAudioRepresentationsSwitchingModeDescMsg = "Unknown value";
        break;
    }
    const onSwitchModeChange = React24.useCallback(
      ({ value }) => {
        onDefaultAudioRepresentationsSwitchingModeChange(
          value
        );
      },
      [onDefaultAudioRepresentationsSwitchingModeChange]
    );
    return /* @__PURE__ */ React24.createElement(React24.Fragment, null, /* @__PURE__ */ React24.createElement("li", { className: "featureWrapperWithSelectMode" }, /* @__PURE__ */ React24.createElement(
      Select_default,
      {
        ariaLabel: "Select the defaultAudioRepresentationsSwitchingMode",
        className: "playerOptionInput",
        disabled: false,
        name: "defaultAudioRepresentationsSwitchingMode",
        onChange: onSwitchModeChange,
        selected: {
          value: defaultAudioRepresentationsSwitchingMode,
          index: void 0
        },
        options: ["seamless", "lazy", "direct", "reload"]
      },
      "Default Audio Representations switching mode"
    ), /* @__PURE__ */ React24.createElement("span", { className: "option-desc" }, defaultAudioRepresentationsSwitchingModeDescMsg)));
  }
  var AudioAdaptiveSettings_default = React24.memo(AudioAdaptiveSettings);

  // demo/scripts/components/Options/VideoAdaptiveSettings.tsx
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var React25 = __toESM(require_react());
  var { Fragment: Fragment3 } = React25;
  function VideoAdaptiveSettings({
    defaultVideoRepresentationsSwitchingMode,
    onDefaultVideoRepresentationsSwitchingModeChange,
    videoResolutionLimit,
    throttleVideoBitrateWhenHidden,
    onVideoResolutionLimitChange,
    onThrottleVideoBitrateWhenHiddenChange
  }) {
    let defaultVideoRepresentationsSwitchingModeDescMsg;
    switch (defaultVideoRepresentationsSwitchingMode) {
      case "reload":
        defaultVideoRepresentationsSwitchingModeDescMsg = "Reloading by default when video Representations are manually changed";
        break;
      case "lazy":
        defaultVideoRepresentationsSwitchingModeDescMsg = "Keeping previous data when video Representations are manually changed";
        break;
      case "direct":
        defaultVideoRepresentationsSwitchingModeDescMsg = "Directly visible transition when video Representations are manually changed";
        break;
      case "seamless":
        defaultVideoRepresentationsSwitchingModeDescMsg = "Smooth transition when video Representations are manually changed";
        break;
      default:
        defaultVideoRepresentationsSwitchingModeDescMsg = "Unknown value";
        break;
    }
    let videoResolutionLimitDescMsg;
    switch (videoResolutionLimit) {
      case "none":
        videoResolutionLimitDescMsg = "No limit on the video Representation\u2019s resolution will be automatically applied.";
        break;
      case "screen":
        videoResolutionLimitDescMsg = "The loaded video Representation will be throttled according to the screen\u2019s dimensions.";
        break;
      case "videoElement":
        videoResolutionLimitDescMsg = "The loaded video Representation will be throttled according to the given videoElement\u2019s dimensions.";
        break;
    }
    const onSwitchModeChange = React25.useCallback(
      ({ value }) => {
        onDefaultVideoRepresentationsSwitchingModeChange(
          value
        );
      },
      [onDefaultVideoRepresentationsSwitchingModeChange]
    );
    return /* @__PURE__ */ React25.createElement(Fragment3, null, /* @__PURE__ */ React25.createElement("li", { className: "featureWrapperWithSelectMode" }, /* @__PURE__ */ React25.createElement(
      Select_default,
      {
        ariaLabel: "Select the defaultVideoRepresentationsSwitchingMode",
        className: "playerOptionInput",
        disabled: false,
        name: "defaultVideoRepresentationsSwitchingMode",
        onChange: onSwitchModeChange,
        selected: {
          value: defaultVideoRepresentationsSwitchingMode,
          index: void 0
        },
        options: ["seamless", "lazy", "direct", "reload"]
      },
      "Default Video Representations switching mode"
    ), /* @__PURE__ */ React25.createElement("span", { className: "option-desc" }, defaultVideoRepresentationsSwitchingModeDescMsg)), /* @__PURE__ */ React25.createElement("li", null, /* @__PURE__ */ React25.createElement(
      Select_default,
      {
        ariaLabel: "Select the videoResolutionLimit",
        className: "playerOptionInput",
        disabled: false,
        name: "videoResolutionLimit",
        onChange: onVideoResolutionLimitChange,
        selected: {
          value: videoResolutionLimit,
          index: void 0
        },
        options: ["videoElement", "screen", "none"]
      },
      "Limit Video Resolution"
    ), /* @__PURE__ */ React25.createElement("span", { className: "option-desc" }, videoResolutionLimitDescMsg)), /* @__PURE__ */ React25.createElement("li", null, /* @__PURE__ */ React25.createElement("div", { className: "playerOptionInput" }, /* @__PURE__ */ React25.createElement(
      CheckBox_default,
      {
        className: "playerOptionsCheckBox playerOptionsCheckBoxTitle",
        name: "throttleVideoBitrateWhenHidden",
        ariaLabel: "Throttle video bitrate when hidden option",
        checked: throttleVideoBitrateWhenHidden,
        onChange: onThrottleVideoBitrateWhenHiddenChange
      },
      "Throttle Video Bitrate When Hidden"
    ), /* @__PURE__ */ React25.createElement("span", { className: "option-desc" }, throttleVideoBitrateWhenHidden ? "Throttling the video bitrate when the page is hidden for a time" : "Not throttling the video bitrate when the page is hidden for a time"))));
  }
  var VideoAdaptiveSettings_default = React25.memo(VideoAdaptiveSettings);

  // demo/scripts/components/Options/RequestConfig.tsx
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var React27 = __toESM(require_react());

  // demo/scripts/lib/defaultOptionsValues.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var defaultOptionsValues = {
    player: {
      videoResolutionLimit: "none",
      maxBufferAhead: Infinity,
      maxBufferBehind: Infinity,
      maxVideoBufferSize: Infinity,
      throttleVideoBitrateWhenHidden: false,
      wantedBufferAhead: 30
    },
    loadVideo: {
      autoPlay: true,
      checkManifestIntegrity: false,
      checkMediaSegmentIntegrity: false,
      cmcd: void 0,
      defaultAudioTrackSwitchingMode: "reload",
      enableFastSwitching: true,
      requestConfig: {
        segment: {
          maxRetry: 4,
          timeout: 3e4
        },
        manifest: {
          maxRetry: 4,
          timeout: 3e4
        }
      },
      onCodecSwitch: "continue"
    }
  };
  var defaultOptionsValues_default = defaultOptionsValues;

  // demo/scripts/components/Options/PlayerOptionNumberInput.tsx
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var React26 = __toESM(require_react());
  function PlayerOptionNumberInput({
    ariaLabel,
    label,
    title,
    onUpdateValue,
    valueAsString,
    defaultValueAsNumber,
    isDisabled,
    onResetClick
  }) {
    const shouldBeDisabled = parseFloat(valueAsString) === defaultValueAsNumber;
    const onInputChange = React26.useCallback(
      (evt) => {
        onUpdateValue(evt.target.value);
      },
      [onUpdateValue]
    );
    return /* @__PURE__ */ React26.createElement("div", { className: "playerOptionInput" }, /* @__PURE__ */ React26.createElement("label", { htmlFor: label }, title), /* @__PURE__ */ React26.createElement("span", { className: "wrapperInputWithResetBtn" }, /* @__PURE__ */ React26.createElement(
      "input",
      {
        type: "text",
        name: label,
        "aria-label": ariaLabel,
        placeholder: "Number",
        onChange: onInputChange,
        value: valueAsString,
        disabled: isDisabled,
        className: "optionInput"
      }
    ), /* @__PURE__ */ React26.createElement(
      Button_default,
      {
        disabled: shouldBeDisabled,
        className: shouldBeDisabled ? "resetBtn disabledResetBtn" : "resetBtn",
        ariaLabel: "Reset option to default value",
        title: "Reset option to default value",
        onClick: onResetClick,
        value: String.fromCharCode(61473)
      }
    )));
  }
  var PlayerOptionNumberInput_default = PlayerOptionNumberInput;

  // demo/scripts/components/Options/RequestConfig.tsx
  var { Fragment: Fragment4, useCallback: useCallback19, useEffect: useEffect8, useState: useState6 } = React27;
  var DEFAULT_SEGMENT_RETRY = defaultOptionsValues_default.loadVideo.requestConfig.segment.maxRetry;
  var DEFAULT_SEGMENT_REQUEST_TIMEOUT = defaultOptionsValues_default.loadVideo.requestConfig.segment.timeout;
  var DEFAULT_MANIFEST_RETRY = defaultOptionsValues_default.loadVideo.requestConfig.manifest.maxRetry;
  var DEFAULT_MANIFEST_REQUEST_TIMEOUT = defaultOptionsValues_default.loadVideo.requestConfig.manifest.timeout;
  function RequestConfig({
    manifestRequestTimeout,
    manifestRetry,
    checkManifestIntegrity,
    checkMediaSegmentIntegrity,
    cmcdCommunicationMethod,
    onManifestRequestTimeoutChange,
    onManifestRetryChange,
    onSegmentRequestTimeoutChange,
    onSegmentRetryChange,
    onCheckManifestIntegrityChange,
    onCheckMediaSegmentIntegrityChange,
    onCmcdChange,
    segmentRequestTimeout,
    segmentRetry
  }) {
    const [segmentRetryStr, setSegmentRetryStr] = useState6(String(segmentRetry));
    const [segmentRequestTimeoutStr, setSegmentRequestTimeoutStr] = useState6(
      String(segmentRequestTimeout)
    );
    const [manifestRetryStr, setManifestRetryStr] = useState6(String(manifestRetry));
    const [manifestRequestTimeoutStr, setManifestRequestTimeoutStr] = useState6(
      String(manifestRequestTimeout)
    );
    const [isSegmentRetryLimited, setSegmentRetryLimit] = useState6(
      segmentRetry !== Infinity
    );
    const [isSegmentRequestTimeoutLimited, setSegmentRequestTimeoutLimit] = useState6(
      segmentRequestTimeout !== -1
    );
    const [isManifestRetryLimited, setManifestRetryLimit] = useState6(
      manifestRetry !== Infinity
    );
    const [isManifestRequestTimeoutLimited, setManifestRequestTimeoutLimit] = useState6(
      manifestRequestTimeout !== -1
    );
    let cmcdDescMsg;
    switch (cmcdCommunicationMethod) {
      case "disabled":
        cmcdDescMsg = "Not relying on CMCD with the CDN";
        break;
      case "query":
        cmcdDescMsg = "Communicate CMCD payload through URL's query strings";
        break;
      case "headers":
        cmcdDescMsg = "Communicate CMCD payload through HTTP(S) headers";
        break;
      default:
        cmcdDescMsg = "Unknown value";
        break;
    }
    const onCmcdSelection = React27.useCallback(
      ({ value }) => onCmcdChange(value),
      [onCmcdChange]
    );
    useEffect8(() => {
      let newVal = parseFloat(manifestRequestTimeoutStr);
      newVal = isNaN(newVal) ? DEFAULT_MANIFEST_REQUEST_TIMEOUT : newVal;
      onManifestRequestTimeoutChange(newVal);
    }, [manifestRequestTimeoutStr]);
    useEffect8(() => {
      let newVal = parseFloat(manifestRetryStr);
      newVal = isNaN(newVal) ? DEFAULT_MANIFEST_RETRY : newVal;
      onManifestRetryChange(newVal);
    }, [manifestRetryStr]);
    useEffect8(() => {
      let newVal = parseFloat(segmentRequestTimeoutStr);
      newVal = isNaN(newVal) ? DEFAULT_SEGMENT_REQUEST_TIMEOUT : newVal;
      onSegmentRequestTimeoutChange(newVal);
    }, [segmentRequestTimeoutStr]);
    useEffect8(() => {
      let newVal = parseFloat(segmentRetryStr);
      newVal = isNaN(newVal) ? DEFAULT_SEGMENT_RETRY : newVal;
      onSegmentRetryChange(newVal);
    }, [segmentRetryStr]);
    const onChangeLimitSegmentRetry = useCallback19((isNotLimited) => {
      if (isNotLimited) {
        setSegmentRetryLimit(false);
        setSegmentRetryStr(String(Infinity));
      } else {
        setSegmentRetryLimit(true);
        setSegmentRetryStr(String(DEFAULT_SEGMENT_RETRY));
      }
    }, []);
    const onChangeLimitSegmentRequestTimeout = useCallback19((isNotLimited) => {
      if (isNotLimited) {
        setSegmentRequestTimeoutLimit(false);
        setSegmentRequestTimeoutStr(String(-1));
      } else {
        setSegmentRequestTimeoutLimit(true);
        setSegmentRequestTimeoutStr(String(DEFAULT_SEGMENT_REQUEST_TIMEOUT));
      }
    }, []);
    const onChangeLimitManifestRetry = useCallback19((isNotLimited) => {
      if (isNotLimited) {
        setManifestRetryLimit(false);
        setManifestRetryStr(String(Infinity));
      } else {
        setManifestRetryLimit(true);
        setManifestRetryStr(String(DEFAULT_MANIFEST_RETRY));
      }
    }, []);
    const onChangeLimitManifestRequestTimeout = useCallback19((isNotLimited) => {
      if (isNotLimited) {
        setManifestRequestTimeoutLimit(false);
        setManifestRequestTimeoutStr(String(-1));
      } else {
        setManifestRequestTimeoutLimit(true);
        setManifestRequestTimeoutStr(String(DEFAULT_MANIFEST_REQUEST_TIMEOUT));
      }
    }, []);
    const onSegmentRetryResetClick = React27.useCallback(() => {
      setSegmentRetryStr(String(DEFAULT_SEGMENT_RETRY));
      setSegmentRetryLimit(DEFAULT_SEGMENT_RETRY !== Infinity);
    }, []);
    const onSegmentTimeoutResetClick = React27.useCallback(() => {
      setSegmentRequestTimeoutStr(String(DEFAULT_SEGMENT_REQUEST_TIMEOUT));
      setSegmentRequestTimeoutLimit(DEFAULT_SEGMENT_REQUEST_TIMEOUT !== Infinity);
    }, []);
    const onManifestRetryResetClick = React27.useCallback(() => {
      setManifestRetryStr(String(DEFAULT_MANIFEST_RETRY));
      setManifestRetryLimit(DEFAULT_MANIFEST_RETRY !== Infinity);
    }, []);
    const onManifestTimeoutResetClick = React27.useCallback(() => {
      setManifestRequestTimeoutStr(String(DEFAULT_MANIFEST_REQUEST_TIMEOUT));
      setManifestRequestTimeoutLimit(DEFAULT_MANIFEST_REQUEST_TIMEOUT !== Infinity);
    }, []);
    return /* @__PURE__ */ React27.createElement(Fragment4, null, /* @__PURE__ */ React27.createElement("li", null, /* @__PURE__ */ React27.createElement(
      PlayerOptionNumberInput_default,
      {
        ariaLabel: "Segment retry option",
        label: "segmentRetry",
        title: "Segment Retry",
        valueAsString: segmentRetryStr,
        defaultValueAsNumber: DEFAULT_SEGMENT_RETRY,
        isDisabled: isSegmentRetryLimited === false,
        onUpdateValue: setSegmentRetryStr,
        onResetClick: onSegmentRetryResetClick
      }
    ), /* @__PURE__ */ React27.createElement(
      CheckBox_default,
      {
        className: "playerOptionsCheckBox",
        ariaLabel: "Segment retry limit option",
        name: "segmentRetryLimit",
        checked: isSegmentRetryLimited === false,
        onChange: onChangeLimitSegmentRetry
      },
      "Do not limit"
    ), /* @__PURE__ */ React27.createElement("span", { className: "option-desc" }, segmentRetry === Infinity || !isSegmentRetryLimited ? 'Retry "retryable" segment requests with no limit' : `Retry "retryable" segment requests at most ${segmentRetry} time(s)`)), /* @__PURE__ */ React27.createElement("li", null, /* @__PURE__ */ React27.createElement(
      PlayerOptionNumberInput_default,
      {
        ariaLabel: "Segment Timeout option",
        label: "segmentRequestTimeout",
        title: "Segment Timeout",
        valueAsString: segmentRequestTimeoutStr,
        defaultValueAsNumber: DEFAULT_SEGMENT_REQUEST_TIMEOUT,
        isDisabled: isSegmentRequestTimeoutLimited === false,
        onUpdateValue: setSegmentRequestTimeoutStr,
        onResetClick: onSegmentTimeoutResetClick
      }
    ), /* @__PURE__ */ React27.createElement(
      CheckBox_default,
      {
        className: "playerOptionsCheckBox",
        ariaLabel: "Segment timeout limit option",
        name: "segmentRequestTimeoutLimit",
        checked: isSegmentRequestTimeoutLimited === false,
        onChange: onChangeLimitSegmentRequestTimeout
      },
      "Do not limit"
    ), /* @__PURE__ */ React27.createElement("span", { className: "option-desc" }, segmentRequestTimeout === -1 || !isSegmentRequestTimeoutLimited ? "Perform segment requests without timeout" : `Stop segment requests after ${segmentRequestTimeout} millisecond(s)`)), /* @__PURE__ */ React27.createElement("li", null, /* @__PURE__ */ React27.createElement(
      PlayerOptionNumberInput_default,
      {
        ariaLabel: "manifestRetry option",
        label: "manifestRetry",
        title: "Manifest Retry",
        valueAsString: manifestRetryStr,
        defaultValueAsNumber: DEFAULT_MANIFEST_RETRY,
        isDisabled: isManifestRetryLimited === false,
        onUpdateValue: setManifestRetryStr,
        onResetClick: onManifestRetryResetClick
      }
    ), /* @__PURE__ */ React27.createElement(
      CheckBox_default,
      {
        className: "playerOptionsCheckBox",
        ariaLabel: "Manifest retry limit option",
        name: "manifestRetryLimit",
        checked: isManifestRetryLimited === false,
        onChange: onChangeLimitManifestRetry
      },
      "Do not limit"
    ), /* @__PURE__ */ React27.createElement("span", { className: "option-desc" }, manifestRetry === Infinity || !isManifestRetryLimited ? 'Retry "retryable" manifest requests with no limit' : `Retry "retryable" manifest requests at most ${manifestRetry} time(s)`)), /* @__PURE__ */ React27.createElement("li", null, /* @__PURE__ */ React27.createElement(
      PlayerOptionNumberInput_default,
      {
        ariaLabel: "manifestRequestTimeout option",
        label: "manifestRequestTimeout",
        title: "Manifest Timeout",
        valueAsString: manifestRequestTimeoutStr,
        defaultValueAsNumber: DEFAULT_MANIFEST_REQUEST_TIMEOUT,
        isDisabled: isManifestRequestTimeoutLimited === false,
        onUpdateValue: setManifestRequestTimeoutStr,
        onResetClick: onManifestTimeoutResetClick
      }
    ), /* @__PURE__ */ React27.createElement(
      CheckBox_default,
      {
        className: "playerOptionsCheckBox",
        ariaLabel: "Manifest timeout limit option",
        name: "manifestRequestTimeoutLimit",
        checked: isManifestRequestTimeoutLimited === false,
        onChange: onChangeLimitManifestRequestTimeout
      },
      "Do not limit"
    ), /* @__PURE__ */ React27.createElement("span", { className: "option-desc" }, manifestRequestTimeout === -1 || !isManifestRequestTimeoutLimited ? "Perform manifest requests without timeout" : `Stop manifest requests after ${manifestRequestTimeout} millisecond(s)`)), /* @__PURE__ */ React27.createElement("li", { className: "featureWrapperWithSelectMode" }, /* @__PURE__ */ React27.createElement(
      Select_default,
      {
        ariaLabel: "Selecting the CMCD communication method",
        disabled: false,
        className: "playerOptionInput",
        name: "cmcd",
        onChange: onCmcdSelection,
        selected: { value: cmcdCommunicationMethod, index: void 0 },
        options: ["disabled", "query", "headers"]
      },
      "CMCD (Common Media Client Data) communication type"
    ), /* @__PURE__ */ React27.createElement("span", { className: "option-desc" }, cmcdDescMsg)), /* @__PURE__ */ React27.createElement("li", null, /* @__PURE__ */ React27.createElement(
      CheckBox_default,
      {
        className: "playerOptionsCheckBox playerOptionsCheckBoxTitle",
        ariaLabel: "Check segment integrity",
        name: "checkMediaSegmentIntegrity",
        checked: checkMediaSegmentIntegrity,
        onChange: onCheckMediaSegmentIntegrityChange
      },
      "Check Media Segment integrity"
    ), /* @__PURE__ */ React27.createElement("span", { className: "option-desc" }, checkMediaSegmentIntegrity ? "Retry segment requests if those delivered by the CDN appear truncated." : "Do not retry request if a segment seems truncated.")), /* @__PURE__ */ React27.createElement("li", null, /* @__PURE__ */ React27.createElement(
      CheckBox_default,
      {
        className: "playerOptionsCheckBox playerOptionsCheckBoxTitle",
        ariaLabel: "Check Manifest integrity",
        name: "checkManifestIntegrity",
        checked: checkManifestIntegrity,
        onChange: onCheckManifestIntegrityChange
      },
      "Check Manifest integrity"
    ), /* @__PURE__ */ React27.createElement("span", { className: "option-desc" }, checkManifestIntegrity ? "Retry Manifest requests if those delivered by the CDN appear truncated." : "Do not retry request if a Manifest seems truncated.")));
  }
  var RequestConfig_default = React27.memo(RequestConfig);

  // demo/scripts/components/Options/TrackSwitch.tsx
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var React28 = __toESM(require_react());
  function TrackSwitchConfig({
    enableFastSwitching,
    defaultAudioTrackSwitchingMode,
    onCodecSwitch,
    onDefaultAudioTrackSwitchingModeChange,
    onCodecSwitchChange,
    onEnableFastSwitchingChange
  }) {
    let defaultAudioTrackSwitchingModeDescMsg;
    switch (defaultAudioTrackSwitchingMode) {
      case "reload":
        defaultAudioTrackSwitchingModeDescMsg = "Reloading by default when the audio track is changed";
        break;
      case "direct":
        defaultAudioTrackSwitchingModeDescMsg = "Directly audible transition when the audio track is changed";
        break;
      case "seamless":
        defaultAudioTrackSwitchingModeDescMsg = "Smooth transition when the audio track is changed";
        break;
      default:
        defaultAudioTrackSwitchingModeDescMsg = "Unknown value";
        break;
    }
    let onCodecSwitchDescMsg;
    switch (onCodecSwitch) {
      case "reload":
        onCodecSwitchDescMsg = "Reloading buffers when the codec changes";
        break;
      case "continue":
        onCodecSwitchDescMsg = "Keeping the same buffers even when the codec changes";
        break;
      default:
        onCodecSwitchDescMsg = "Unknown value";
        break;
    }
    const onCodecSwitchSelection = React28.useCallback(
      ({ value }) => onCodecSwitchChange(value),
      [onCodecSwitchChange]
    );
    const onDefaultAudioTrackSwitchingModeSelection = React28.useCallback(
      ({ value }) => onDefaultAudioTrackSwitchingModeChange(value),
      [onDefaultAudioTrackSwitchingModeChange]
    );
    return /* @__PURE__ */ React28.createElement(React28.Fragment, null, /* @__PURE__ */ React28.createElement("li", null, /* @__PURE__ */ React28.createElement(
      CheckBox_default,
      {
        className: "playerOptionsCheckBox playerOptionsCheckBoxTitle",
        ariaLabel: "Fast switching option",
        name: "fastSwitching",
        checked: enableFastSwitching,
        onChange: onEnableFastSwitchingChange
      },
      "Fast Switching"
    ), /* @__PURE__ */ React28.createElement("span", { className: "option-desc" }, enableFastSwitching ? "Fast quality switch by replacing lower qualities in the buffer by higher ones when possible." : "Not replacing lower qualities in the buffer by an higher one when possible.")), /* @__PURE__ */ React28.createElement("li", { className: "featureWrapperWithSelectMode" }, /* @__PURE__ */ React28.createElement(
      Select_default,
      {
        ariaLabel: "Selecting the defaultAudioTrackSwitchingMode attribute",
        disabled: false,
        className: "playerOptionInput",
        name: "defaultAudioTrackSwitchingMode",
        onChange: onDefaultAudioTrackSwitchingModeSelection,
        selected: { value: defaultAudioTrackSwitchingMode, index: void 0 },
        options: ["seamless", "direct", "reload"]
      },
      "Audio track switching mode"
    ), /* @__PURE__ */ React28.createElement("span", { className: "option-desc" }, defaultAudioTrackSwitchingModeDescMsg)), /* @__PURE__ */ React28.createElement("li", { className: "featureWrapperWithSelectMode" }, /* @__PURE__ */ React28.createElement(
      Select_default,
      {
        ariaLabel: "Selecting the onCodecSwitch attribute",
        disabled: false,
        className: "playerOptionInput",
        name: "onCodecSwitch",
        onChange: onCodecSwitchSelection,
        selected: { value: onCodecSwitch, index: void 0 },
        options: ["continue", "reload"]
      },
      "On Codec Switch"
    ), /* @__PURE__ */ React28.createElement("span", { className: "option-desc" }, onCodecSwitchDescMsg)));
  }
  var TrackSwitch_default = React28.memo(TrackSwitchConfig);

  // demo/scripts/components/Options/BufferOptions.tsx
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var React29 = __toESM(require_react());
  var { Fragment: Fragment6, useCallback: useCallback22, useEffect: useEffect9, useState: useState7 } = React29;
  var DEFAULT_MAX_BUFFER_AHEAD = defaultOptionsValues_default.player.maxBufferAhead;
  var DEFAULT_MAX_BUFFER_BEHIND = defaultOptionsValues_default.player.maxBufferBehind;
  var DEFAULT_MAX_VIDEO_BUFFER_SIZE = defaultOptionsValues_default.player.maxVideoBufferSize;
  var DEFAULT_WANTED_BUFFER_AHEAD = defaultOptionsValues_default.player.wantedBufferAhead;
  function BufferOptions({
    wantedBufferAhead,
    maxVideoBufferSize,
    maxBufferAhead,
    maxBufferBehind,
    onWantedBufferAheadChange,
    onMaxVideoBufferSizeChange,
    onMaxBufferAheadChange,
    onMaxBufferBehindChange
  }) {
    const [wantedBufferAheadStr, setWantedBufferAheadStr] = useState7(
      String(wantedBufferAhead)
    );
    const [maxVideoBufferSizeStr, setMaxVideoBufferSizeStr] = useState7(
      String(maxVideoBufferSize)
    );
    const [maxBufferBehindStr, setMaxBufferBehindStr] = useState7(String(maxBufferBehind));
    const [maxBufferAheadStr, setMaxBufferAheadStr] = useState7(String(maxBufferAhead));
    const [isMaxBufferAheadLimited, setMaxBufferAheadLimit] = useState7(
      maxBufferAhead !== Infinity
    );
    const [isMaxBufferBehindLimited, setMaxBufferBehindLimit] = useState7(
      maxBufferBehind !== Infinity
    );
    const [isMaxVideoBufferSizeLimited, setMaxVideoBufferSizeLimit] = useState7(
      maxVideoBufferSize !== Infinity
    );
    useEffect9(() => {
      let newVal = parseFloat(wantedBufferAheadStr);
      newVal = isNaN(newVal) ? DEFAULT_WANTED_BUFFER_AHEAD : newVal;
      onWantedBufferAheadChange(newVal);
    }, [wantedBufferAheadStr]);
    useEffect9(() => {
      let newVal = parseFloat(maxVideoBufferSizeStr);
      newVal = isNaN(newVal) ? DEFAULT_MAX_VIDEO_BUFFER_SIZE : newVal;
      onMaxVideoBufferSizeChange(newVal);
    }, [maxVideoBufferSizeStr]);
    useEffect9(() => {
      let newVal = parseFloat(maxBufferAheadStr);
      newVal = isNaN(newVal) ? DEFAULT_MAX_BUFFER_AHEAD : newVal;
      onMaxBufferAheadChange(newVal);
    }, [maxBufferAheadStr]);
    useEffect9(() => {
      let newVal = parseFloat(maxBufferBehindStr);
      newVal = isNaN(newVal) ? DEFAULT_MAX_BUFFER_BEHIND : newVal;
      onMaxBufferBehindChange(newVal);
    }, [maxBufferBehindStr]);
    const onChangeLimitMaxBufferAhead = useCallback22((isNotLimited) => {
      if (isNotLimited) {
        setMaxBufferAheadLimit(false);
        setMaxBufferAheadStr(String(Infinity));
      } else {
        setMaxBufferAheadLimit(true);
        setMaxBufferAheadStr(String(DEFAULT_MAX_BUFFER_AHEAD));
      }
    }, []);
    const onChangeLimitMaxBufferBehind = useCallback22((isNotLimited) => {
      if (isNotLimited) {
        setMaxBufferBehindLimit(false);
        setMaxBufferBehindStr(String(DEFAULT_MAX_BUFFER_AHEAD));
      } else {
        setMaxBufferBehindLimit(true);
        setMaxBufferBehindStr(String(DEFAULT_MAX_BUFFER_BEHIND));
      }
    }, []);
    const onChangeLimitMaxVideoBufferSize = useCallback22((isNotLimited) => {
      if (isNotLimited) {
        setMaxVideoBufferSizeLimit(false);
        setMaxVideoBufferSizeStr(String(Infinity));
      } else {
        setMaxVideoBufferSizeLimit(true);
        setMaxVideoBufferSizeStr(String(DEFAULT_MAX_VIDEO_BUFFER_SIZE));
      }
    }, []);
    const onWantedBufferAheadResetClick = React29.useCallback(() => {
      setWantedBufferAheadStr(String(DEFAULT_WANTED_BUFFER_AHEAD));
    }, []);
    const onMaxVideoBufferSizeResetClick = React29.useCallback(() => {
      setMaxVideoBufferSizeStr(String(DEFAULT_MAX_VIDEO_BUFFER_SIZE));
      setMaxVideoBufferSizeLimit(DEFAULT_MAX_VIDEO_BUFFER_SIZE !== Infinity);
    }, []);
    const onMaxBufferAheadResetClick = React29.useCallback(() => {
      setMaxBufferAheadStr(String(DEFAULT_MAX_BUFFER_AHEAD));
      setMaxBufferAheadLimit(DEFAULT_MAX_BUFFER_AHEAD !== Infinity);
    }, []);
    const onMaxBufferBehindResetClick = React29.useCallback(() => {
      setMaxBufferBehindStr(String(DEFAULT_MAX_BUFFER_BEHIND));
      setMaxBufferBehindLimit(DEFAULT_MAX_BUFFER_BEHIND !== Infinity);
    }, []);
    return /* @__PURE__ */ React29.createElement(Fragment6, null, /* @__PURE__ */ React29.createElement("li", null, /* @__PURE__ */ React29.createElement(
      PlayerOptionNumberInput_default,
      {
        ariaLabel: "Wanted Buffer Ahead option",
        label: "wantedBufferAhead",
        title: "Wanted Buffer Ahead",
        valueAsString: wantedBufferAheadStr,
        defaultValueAsNumber: DEFAULT_WANTED_BUFFER_AHEAD,
        isDisabled: false,
        onUpdateValue: setWantedBufferAheadStr,
        onResetClick: onWantedBufferAheadResetClick
      }
    ), /* @__PURE__ */ React29.createElement("span", { className: "option-desc" }, "Buffering around ", wantedBufferAhead, " second(s) ahead of the current position")), /* @__PURE__ */ React29.createElement("li", null, /* @__PURE__ */ React29.createElement(
      PlayerOptionNumberInput_default,
      {
        ariaLabel: "maxVideoBufferSize option",
        label: "maxVideoBufferSize",
        title: "Max Video Buffer Size",
        valueAsString: maxVideoBufferSizeStr,
        defaultValueAsNumber: DEFAULT_MAX_VIDEO_BUFFER_SIZE,
        isDisabled: isMaxVideoBufferSizeLimited === false,
        onUpdateValue: setMaxVideoBufferSizeStr,
        onResetClick: onMaxVideoBufferSizeResetClick
      }
    ), /* @__PURE__ */ React29.createElement(
      CheckBox_default,
      {
        className: "playerOptionsCheckBox",
        ariaLabel: "Do not limit maxVideoBufferSize option",
        name: "maxVideoBufferSizeLimit",
        checked: isMaxVideoBufferSizeLimited === false,
        onChange: onChangeLimitMaxVideoBufferSize
      },
      "Do not limit"
    ), /* @__PURE__ */ React29.createElement("span", { className: "option-desc" }, maxVideoBufferSize === Infinity || !isMaxVideoBufferSizeLimited ? "Not setting a size limit to the video buffer (relying only on the wantedBufferAhead option)" : `Buffering at most around ${maxVideoBufferSize} kilobyte(s) on the video buffer`)), /* @__PURE__ */ React29.createElement("li", null, /* @__PURE__ */ React29.createElement(
      PlayerOptionNumberInput_default,
      {
        ariaLabel: "maxBufferAhead option",
        label: "maxBufferAhead",
        title: "Max Buffer Ahead",
        valueAsString: maxBufferAheadStr,
        defaultValueAsNumber: DEFAULT_MAX_BUFFER_AHEAD,
        isDisabled: isMaxBufferAheadLimited === false,
        onUpdateValue: setMaxBufferAheadStr,
        onResetClick: onMaxBufferAheadResetClick
      }
    ), /* @__PURE__ */ React29.createElement(
      CheckBox_default,
      {
        className: "playerOptionsCheckBox",
        ariaLabel: "Do not limit max buffer a head option",
        name: "maxBufferAheadLimit",
        checked: isMaxBufferAheadLimited === false,
        onChange: onChangeLimitMaxBufferAhead
      },
      "Do not limit"
    ), /* @__PURE__ */ React29.createElement("span", { className: "option-desc" }, maxBufferAhead === Infinity || !isMaxBufferAheadLimited ? "Not manually cleaning buffer far ahead of the current position" : `Manually cleaning data ${maxBufferAhead} second(s) ahead of the current position`)), /* @__PURE__ */ React29.createElement("li", null, /* @__PURE__ */ React29.createElement(
      PlayerOptionNumberInput_default,
      {
        ariaLabel: "maxBufferBehind option",
        label: "maxBufferBehind",
        title: "Max Buffer Behind",
        valueAsString: maxBufferBehindStr,
        defaultValueAsNumber: DEFAULT_MAX_BUFFER_BEHIND,
        isDisabled: isMaxBufferBehindLimited === false,
        onUpdateValue: setMaxBufferBehindStr,
        onResetClick: onMaxBufferBehindResetClick
      }
    ), /* @__PURE__ */ React29.createElement(
      CheckBox_default,
      {
        className: "playerOptionsCheckBox",
        ariaLabel: "Do not limit max buffer behind option",
        name: "maxBufferBehindLimit",
        checked: isMaxBufferBehindLimited === false,
        onChange: onChangeLimitMaxBufferBehind
      },
      "Do not limit"
    ), /* @__PURE__ */ React29.createElement("span", { className: "option-desc" }, maxBufferBehind === Infinity || !isMaxBufferBehindLimited ? "Not manually cleaning buffer behind the current position" : `Manually cleaning data ${maxBufferBehind} second(s) behind the current position`)));
  }
  var BufferOptions_default = React29.memo(BufferOptions);

  // demo/scripts/controllers/Settings.tsx
  var { useCallback: useCallback23 } = React30;
  function Settings({
    // TODO add to RxPlayer API?
    defaultAudioRepresentationsSwitchingMode,
    defaultVideoRepresentationsSwitchingMode,
    playerOptions,
    updatePlayerOptions,
    loadVideoOptions,
    updateLoadVideoOptions,
    showOptions,
    updateDefaultAudioRepresentationsSwitchingMode,
    updateDefaultVideoRepresentationsSwitchingMode,
    tryRelyOnWorker,
    updateTryRelyOnWorker
  }) {
    var _a;
    const {
      videoResolutionLimit,
      maxBufferAhead,
      maxBufferBehind,
      maxVideoBufferSize,
      throttleVideoBitrateWhenHidden,
      wantedBufferAhead
    } = playerOptions;
    const {
      autoPlay,
      cmcd,
      defaultAudioTrackSwitchingMode,
      enableFastSwitching,
      checkMediaSegmentIntegrity,
      checkManifestIntegrity,
      requestConfig,
      onCodecSwitch
    } = loadVideoOptions;
    const cmcdCommunicationMethod = (_a = cmcd == null ? void 0 : cmcd.communicationType) != null ? _a : "disabled";
    const { manifest: manifestRequestConfig, segment: segmentRequestConfig } = requestConfig;
    const { maxRetry: segmentRetry, timeout: segmentRequestTimeout } = segmentRequestConfig;
    const { maxRetry: manifestRetry, timeout: manifestRequestTimeout } = manifestRequestConfig;
    const onAutoPlayChange = useCallback23(
      (autoPlay2) => {
        updateLoadVideoOptions((prevOptions) => {
          if (autoPlay2 === prevOptions.autoPlay) {
            return prevOptions;
          }
          return Object.assign({}, prevOptions, { autoPlay: autoPlay2 });
        });
      },
      [updateLoadVideoOptions]
    );
    const onTryRelyOnWorkerChange = useCallback23(
      (tryRelyOnWorker2) => {
        updateTryRelyOnWorker(tryRelyOnWorker2);
      },
      [updateTryRelyOnWorker]
    );
    const onCmcdChange = useCallback23(
      (value) => {
        updateLoadVideoOptions((prevOptions) => {
          var _a2;
          let newCmcdType;
          if (value === "query") {
            newCmcdType = "query";
          } else if (value === "headers") {
            newCmcdType = "headers";
          } else {
            newCmcdType = void 0;
          }
          if (newCmcdType === ((_a2 = prevOptions.cmcd) == null ? void 0 : _a2.communicationType)) {
            return prevOptions;
          }
          return Object.assign({}, prevOptions, {
            cmcd: newCmcdType === void 0 ? void 0 : {
              communicationType: newCmcdType
            }
          });
        });
      },
      [updateLoadVideoOptions]
    );
    const onVideoResolutionLimitChange = useCallback23(
      (videoResolutionLimitArg) => {
        updatePlayerOptions((prevOptions) => {
          if (videoResolutionLimitArg.value === prevOptions.videoResolutionLimit) {
            return prevOptions;
          }
          return Object.assign({}, prevOptions, {
            videoResolutionLimit: videoResolutionLimitArg.value
          });
        });
      },
      [updatePlayerOptions]
    );
    const onThrottleVideoBitrateWhenHiddenChange = useCallback23(
      (value) => {
        updatePlayerOptions((prevOptions) => {
          if (value === prevOptions.throttleVideoBitrateWhenHidden) {
            return prevOptions;
          }
          return Object.assign({}, prevOptions, {
            throttleVideoBitrateWhenHidden: value
          });
        });
      },
      [updatePlayerOptions]
    );
    const onSegmentRetryChange = useCallback23(
      (segmentRetry2) => {
        updateLoadVideoOptions((prevOptions) => {
          if (segmentRetry2 === prevOptions.requestConfig.segment.maxRetry) {
            return prevOptions;
          }
          return Object.assign({}, prevOptions, {
            requestConfig: Object.assign({}, prevOptions.requestConfig, {
              segment: Object.assign({}, prevOptions.requestConfig.segment, {
                maxRetry: segmentRetry2
              })
            })
          });
        });
      },
      [updateLoadVideoOptions]
    );
    const onSegmentRequestTimeoutChange = useCallback23(
      (segmentRequestTimeout2) => {
        updateLoadVideoOptions((prevOptions) => {
          if (segmentRequestTimeout2 === prevOptions.requestConfig.segment.timeout) {
            return prevOptions;
          }
          return Object.assign({}, prevOptions, {
            requestConfig: Object.assign({}, prevOptions.requestConfig, {
              segment: Object.assign({}, prevOptions.requestConfig.segment, {
                timeout: segmentRequestTimeout2
              })
            })
          });
        });
      },
      [updateLoadVideoOptions]
    );
    const onManifestRetryChange = useCallback23(
      (manifestRetry2) => {
        updateLoadVideoOptions((prevOptions) => {
          if (manifestRetry2 === prevOptions.requestConfig.manifest.maxRetry) {
            return prevOptions;
          }
          return Object.assign({}, prevOptions, {
            requestConfig: Object.assign({}, prevOptions.requestConfig, {
              manifest: Object.assign({}, prevOptions.requestConfig.manifest, {
                maxRetry: manifestRetry2
              })
            })
          });
        });
      },
      [updateLoadVideoOptions]
    );
    const onManifestRequestTimeoutChange = useCallback23(
      (manifestRequestTimeout2) => {
        updateLoadVideoOptions((prevOptions) => {
          if (manifestRequestTimeout2 === prevOptions.requestConfig.manifest.timeout) {
            return prevOptions;
          }
          return Object.assign({}, prevOptions, {
            requestConfig: Object.assign({}, prevOptions.requestConfig, {
              manifest: Object.assign({}, prevOptions.requestConfig.manifest, {
                timeout: manifestRequestTimeout2
              })
            })
          });
        });
      },
      [updateLoadVideoOptions]
    );
    const onCheckMediaSegmentIntegrityChange = useCallback23(
      (checkMediaSegmentIntegrity2) => {
        updateLoadVideoOptions((prevOptions) => {
          if (checkMediaSegmentIntegrity2 === prevOptions.checkMediaSegmentIntegrity) {
            return prevOptions;
          }
          return Object.assign({}, prevOptions, { checkMediaSegmentIntegrity: checkMediaSegmentIntegrity2 });
        });
      },
      [updateLoadVideoOptions]
    );
    const onCheckManifestIntegrityChange = useCallback23(
      (checkManifestIntegrity2) => {
        updateLoadVideoOptions((prevOptions) => {
          if (checkManifestIntegrity2 === prevOptions.checkManifestIntegrity) {
            return prevOptions;
          }
          return Object.assign({}, prevOptions, { checkManifestIntegrity: checkManifestIntegrity2 });
        });
      },
      [updateLoadVideoOptions]
    );
    const onEnableFastSwitchingChange = useCallback23(
      (enableFastSwitching2) => {
        updateLoadVideoOptions((prevOptions) => {
          if (enableFastSwitching2 === prevOptions.enableFastSwitching) {
            return prevOptions;
          }
          return Object.assign({}, prevOptions, { enableFastSwitching: enableFastSwitching2 });
        });
      },
      [updateLoadVideoOptions]
    );
    const onDefaultAudioTrackSwitchingModeChange = useCallback23(
      (value) => {
        updateLoadVideoOptions((prevOptions) => {
          if (value === prevOptions.defaultAudioTrackSwitchingMode) {
            return prevOptions;
          }
          return Object.assign({}, prevOptions, {
            defaultAudioTrackSwitchingMode: value
          });
        });
      },
      [updateLoadVideoOptions]
    );
    const onDefaultVideoRepresentationsSwitchingModeChange = useCallback23(
      (value) => {
        updateDefaultVideoRepresentationsSwitchingMode(value);
      },
      [updateLoadVideoOptions]
    );
    const onDefaultAudioRepresentationsSwitchingModeChange = useCallback23(
      (value) => {
        updateDefaultAudioRepresentationsSwitchingMode(value);
      },
      [updateLoadVideoOptions]
    );
    const onCodecSwitchChange = useCallback23(
      (value) => {
        updateLoadVideoOptions((prevOptions) => {
          if (value === prevOptions.onCodecSwitch) {
            return prevOptions;
          }
          return Object.assign({}, prevOptions, {
            onCodecSwitch: value
          });
        });
      },
      [updateLoadVideoOptions]
    );
    const onWantedBufferAheadChange = useCallback23(
      (wantedBufferAhead2) => {
        updatePlayerOptions((prevOptions) => {
          if (wantedBufferAhead2 === prevOptions.wantedBufferAhead) {
            return prevOptions;
          }
          return Object.assign({}, prevOptions, { wantedBufferAhead: wantedBufferAhead2 });
        });
      },
      [playerOptions]
    );
    const onMaxVideoBufferSizeChange = useCallback23(
      (maxVideoBufferSize2) => {
        updatePlayerOptions((prevOptions) => {
          if (maxVideoBufferSize2 === prevOptions.maxVideoBufferSize) {
            return prevOptions;
          }
          return Object.assign({}, prevOptions, { maxVideoBufferSize: maxVideoBufferSize2 });
        });
      },
      [playerOptions]
    );
    const onMaxBufferBehindChange = useCallback23(
      (maxBufferBehind2) => {
        updatePlayerOptions((prevOptions) => {
          if (maxBufferBehind2 === prevOptions.maxBufferBehind) {
            return prevOptions;
          }
          return Object.assign({}, prevOptions, { maxBufferBehind: maxBufferBehind2 });
        });
      },
      [playerOptions]
    );
    const onMaxBufferAheadChange = useCallback23(
      (maxBufferAhead2) => {
        updatePlayerOptions((prevOptions) => {
          if (maxBufferAhead2 === prevOptions.maxBufferAhead) {
            return prevOptions;
          }
          return Object.assign({}, prevOptions, { maxBufferAhead: maxBufferAhead2 });
        });
      },
      [playerOptions]
    );
    if (!showOptions) {
      return null;
    }
    return /* @__PURE__ */ React30.createElement("div", { className: "settingsWrapper" }, /* @__PURE__ */ React30.createElement("div", { className: "settings-title" }, "Content options"), /* @__PURE__ */ React30.createElement("div", { className: "settings-note" }, "Note: Those options won't be retroactively applied to already-loaded contents"), /* @__PURE__ */ React30.createElement("div", { style: { display: "flex" } }, /* @__PURE__ */ React30.createElement(Option_default, { title: "Playback" }, /* @__PURE__ */ React30.createElement(
      Playback_default,
      {
        autoPlay,
        onAutoPlayChange,
        tryRelyOnWorker,
        onTryRelyOnWorkerChange
      }
    )), /* @__PURE__ */ React30.createElement(Option_default, { title: "Video adaptive settings" }, /* @__PURE__ */ React30.createElement(
      VideoAdaptiveSettings_default,
      {
        defaultVideoRepresentationsSwitchingMode,
        videoResolutionLimit,
        throttleVideoBitrateWhenHidden,
        onDefaultVideoRepresentationsSwitchingModeChange,
        onVideoResolutionLimitChange,
        onThrottleVideoBitrateWhenHiddenChange
      }
    )), /* @__PURE__ */ React30.createElement(Option_default, { title: "Audio adaptive settings" }, /* @__PURE__ */ React30.createElement(
      AudioAdaptiveSettings_default,
      {
        defaultAudioRepresentationsSwitchingMode,
        onDefaultAudioRepresentationsSwitchingModeChange
      }
    ))), /* @__PURE__ */ React30.createElement("div", { style: { display: "flex" } }, /* @__PURE__ */ React30.createElement(Option_default, { title: "Request Configuration" }, /* @__PURE__ */ React30.createElement(
      RequestConfig_default,
      {
        manifestRequestTimeout,
        segmentRetry,
        segmentRequestTimeout,
        manifestRetry,
        checkManifestIntegrity,
        checkMediaSegmentIntegrity,
        cmcdCommunicationMethod,
        onSegmentRetryChange,
        onSegmentRequestTimeoutChange,
        onManifestRetryChange,
        onManifestRequestTimeoutChange,
        onCheckManifestIntegrityChange,
        onCheckMediaSegmentIntegrityChange,
        onCmcdChange
      }
    )), /* @__PURE__ */ React30.createElement(Option_default, { title: "Track Switch Mode" }, /* @__PURE__ */ React30.createElement(
      TrackSwitch_default,
      {
        defaultAudioTrackSwitchingMode,
        enableFastSwitching,
        onCodecSwitch,
        onDefaultAudioTrackSwitchingModeChange,
        onEnableFastSwitchingChange,
        onCodecSwitchChange
      }
    )), /* @__PURE__ */ React30.createElement(Option_default, { title: "Buffer Options" }, /* @__PURE__ */ React30.createElement(
      BufferOptions_default,
      {
        wantedBufferAhead,
        maxVideoBufferSize,
        maxBufferAhead,
        maxBufferBehind,
        onWantedBufferAheadChange,
        onMaxBufferAheadChange,
        onMaxBufferBehindChange,
        onMaxVideoBufferSizeChange
      }
    ))));
  }
  var Settings_default = Settings;

  // demo/scripts/controllers/ErrorDisplayer.tsx
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var React31 = __toESM(require_react());
  function PlayerError({ error }) {
    const message = typeof error.message === "string" ? error.message : String(error);
    return /* @__PURE__ */ React31.createElement("span", { className: "fatal-error" }, /* @__PURE__ */ React31.createElement("span", { className: "error-icon icon" }, String.fromCharCode(61553)), /* @__PURE__ */ React31.createElement("span", { className: "error-intro" }, "The Player encountered a fatal Error:"), /* @__PURE__ */ React31.createElement("span", { className: "error-message" }, message));
  }
  function ErrorDisplayer({ player }) {
    const error = useModuleState(player, "error");
    return /* @__PURE__ */ React31.createElement("div", { className: "player-error" }, error ? /* @__PURE__ */ React31.createElement(PlayerError, { error }) : null);
  }
  var ErrorDisplayer_default = React31.memo(ErrorDisplayer);

  // demo/scripts/controllers/charts/index.tsx
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var React35 = __toESM(require_react());

  // demo/scripts/modules/ChartData.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var DEFAULT_MAX_SIZE = 100;
  var ChartModule = declareModule(
    () => ({
      data: []
    }),
    (maxSize = DEFAULT_MAX_SIZE, state) => {
      return {
        addData(val) {
          const data2 = state.get("data");
          if (data2.length >= maxSize) {
            data2.splice(0, data2.length + 1 - maxSize);
          }
          data2.push({
            date: performance.now(),
            value: val
          });
          state.update("data", data2.slice());
        },
        removeData(nb = 1) {
          const data2 = state.get("data");
          data2.splice(0, nb);
          state.update("data", data2.slice());
        }
      };
    }
  );
  var ChartData_default = ChartModule;

  // demo/scripts/controllers/charts/BufferContent.tsx
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var React33 = __toESM(require_react());

  // demo/scripts/components/BufferContentGraph.tsx
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var React32 = __toESM(require_react());

  // demo/scripts/lib/capitalizeFirstLetter.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function capitalizeFirstLetter(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }

  // demo/scripts/lib/shuffleArray.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  function shuffleArray(arr) {
    const clonedArr = arr.slice();
    let currentIndex = arr.length;
    while (0 !== currentIndex) {
      const randomIndex = Math.floor(Math.random() * currentIndex);
      currentIndex -= 1;
      const temporaryValue = clonedArr[currentIndex];
      clonedArr[currentIndex] = clonedArr[randomIndex];
      clonedArr[randomIndex] = temporaryValue;
    }
    return clonedArr;
  }

  // demo/scripts/components/BufferContentGraph.tsx
  var { useEffect: useEffect10, useMemo: useMemo4, useRef: useRef8, useState: useState8 } = React32;
  var CANVAS_WIDTH = 1e3;
  var CANVAS_HEIGHT = 1;
  var COLORS2 = [
    // "#fe4a49",
    "#2ab7ca",
    "#fed766",
    "#4dd248",
    "#a22c28",
    "#556b2f",
    // darkolivegreen
    "#add8e6",
    // lightblue
    "#90ee90",
    // lightgreen
    "#444444",
    "#40bfc1",
    "#57557e",
    "#fbe555"
    // "#f0134d",
  ];
  var COLOR_CURRENT_POSITION = "#FF2323";
  function clearCanvas(canvasContext) {
    canvasContext.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
  }
  function paintCurrentPosition2(position, minimumPosition, maximumPosition, canvasCtx) {
    if (typeof position === "number" && position >= minimumPosition && position < maximumPosition) {
      const lengthCanvas = maximumPosition - minimumPosition;
      canvasCtx.fillStyle = COLOR_CURRENT_POSITION;
      canvasCtx.fillRect(
        Math.ceil((position - minimumPosition) / lengthCanvas * CANVAS_WIDTH) - 1,
        0,
        2,
        CANVAS_HEIGHT
      );
    }
  }
  function scaleSegments2(bufferedData, minimumPosition, maximumPosition) {
    var _a, _b;
    const scaledSegments = [];
    const wholeDuration = maximumPosition - minimumPosition;
    for (const bufferedInfos of bufferedData) {
      const start = (_a = bufferedInfos.bufferedStart) != null ? _a : bufferedInfos.start;
      const end = (_b = bufferedInfos.bufferedEnd) != null ? _b : bufferedInfos.end;
      if (end > minimumPosition && start < maximumPosition) {
        const startPoint = Math.max(start - minimumPosition, 0);
        const endPoint = Math.min(end - minimumPosition, maximumPosition);
        const scaledStart = startPoint / wholeDuration;
        const scaledEnd = endPoint / wholeDuration;
        scaledSegments.push({ scaledStart, scaledEnd, bufferedInfos });
      }
    }
    return scaledSegments;
  }
  function BufferContentGraph({
    currentTime,
    // The time currently played
    data: data2,
    // The buffered data for a single type of buffer (e.g. "audio")
    maximumPosition,
    // The maximum seekable position
    minimumPosition,
    // The minimum seekable position
    seek,
    // function allowing to seek in the content
    type
    // The type of buffer (e.g. "audio", "video" or "text")
  }) {
    const randomColors = useMemo4(() => shuffleArray(COLORS2), []);
    const [tipVisible, setTipVisible] = useState8(false);
    const [tipPosition, setTipPosition] = useState8(0);
    const [tipText, setTipText] = useState8("");
    const canvasEl = useRef8(null);
    const representationsIdEncountered = useRef8([]);
    const usedMaximum = maximumPosition != null ? maximumPosition : 300;
    const usedMinimum = minimumPosition != null ? minimumPosition : 0;
    const duration = Math.max(usedMaximum - usedMinimum, 0);
    const paintSegment = React32.useCallback(
      (scaledSegment, canvasCtx) => {
        const representation = scaledSegment.bufferedInfos.infos.representation;
        let indexOfRepr = representationsIdEncountered.current.indexOf(
          representation.uniqueId
        );
        if (indexOfRepr < 0) {
          representationsIdEncountered.current.push(representation.uniqueId);
          indexOfRepr = representationsIdEncountered.current.length - 1;
        }
        const colorIndex = indexOfRepr % COLORS2.length;
        const color = randomColors[colorIndex];
        const startX = scaledSegment.scaledStart * CANVAS_WIDTH;
        const endX = scaledSegment.scaledEnd * CANVAS_WIDTH;
        canvasCtx.fillStyle = color;
        canvasCtx.fillRect(Math.ceil(startX), 0, Math.ceil(endX - startX), CANVAS_HEIGHT);
      },
      [randomColors]
    );
    const currentSegmentsScaled = useMemo4(() => {
      return scaleSegments2(data2, usedMinimum, usedMaximum);
    }, [data2, usedMinimum, usedMaximum]);
    useEffect10(() => {
      if (canvasEl.current === null) {
        return;
      }
      const ctx = canvasEl.current.getContext("2d");
      if (ctx === null) {
        return;
      }
      canvasEl.current.width = CANVAS_WIDTH;
      canvasEl.current.height = CANVAS_HEIGHT;
      clearCanvas(ctx);
      if (usedMinimum === void 0 || usedMaximum === void 0 || usedMinimum >= usedMaximum) {
        return;
      }
      for (const scaledSegment of currentSegmentsScaled) {
        paintSegment(scaledSegment, ctx);
      }
      paintCurrentPosition2(currentTime, usedMinimum, usedMaximum, ctx);
    }, [usedMinimum, usedMaximum, currentSegmentsScaled]);
    const getMousePositionInPercentage = React32.useCallback((event) => {
      if (canvasEl.current === null) {
        return;
      }
      const rect = canvasEl.current.getBoundingClientRect();
      const point0 = rect.left;
      const clickPosPx = Math.max(event.clientX - point0, 0);
      const endPointPx = Math.max(rect.right - point0, 0);
      if (!endPointPx) {
        return 0;
      }
      return clickPosPx / endPointPx;
    }, []);
    const getMousePosition = React32.useCallback(
      (event) => {
        const mousePercent = getMousePositionInPercentage(event);
        return mousePercent === void 0 ? void 0 : mousePercent * duration + usedMinimum;
      },
      [getMousePositionInPercentage, duration, usedMinimum]
    );
    const toolTipOffset = canvasEl !== null && canvasEl.current !== null ? canvasEl.current.getBoundingClientRect().left : 0;
    const hideTip = React32.useCallback(() => {
      setTipVisible(false);
      setTipPosition(0);
      setTipText("");
    }, []);
    const onMouseMove = React32.useCallback(
      (event) => {
        var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
        const mousePercent = getMousePositionInPercentage(event);
        if (mousePercent === void 0) {
          return;
        }
        for (let i = 0; i < currentSegmentsScaled.length; i++) {
          const scaledSegment = currentSegmentsScaled[i];
          if (mousePercent >= scaledSegment.scaledStart && mousePercent < scaledSegment.scaledEnd) {
            const { start, end } = scaledSegment.bufferedInfos;
            const { adaptation, representation } = scaledSegment.bufferedInfos.infos;
            setTipVisible(true);
            setTipPosition(event.clientX);
            let newTipText = "";
            switch (adaptation.type) {
              case "video": {
                const rep = representation;
                newTipText += `width: ${(_a = rep.width) != null ? _a : "?"}
height: ${(_b = rep.height) != null ? _b : "?"}
codec: ${(_d = (_c = representation.codecs) == null ? void 0 : _c.join("-")) != null ? _d : "?"}
bitrate: ${(_e = representation.bitrate) != null ? _e : "?"}
`;
                break;
              }
              case "audio":
                newTipText += `language: ${(_f = adaptation.language) != null ? _f : "?"}
audioDescription: ${String(adaptation.isAudioDescription)}
codec: ${(_h = (_g = representation.codecs) == null ? void 0 : _g.join("-")) != null ? _h : "?"}
bitrate: ${(_i = representation.bitrate) != null ? _i : "?"}
`;
                break;
              case "text":
                newTipText += `language: ${(_j = adaptation.language) != null ? _j : "?"}
closedCaption: ${String(adaptation.isClosedCaption)}
`;
                break;
            }
            newTipText += `segment: [${start.toFixed(1)}, ${end.toFixed(1)}]`;
            setTipText(newTipText);
            return;
          }
        }
        hideTip();
      },
      [getMousePositionInPercentage, currentSegmentsScaled, hideTip]
    );
    const onCanvasClick = React32.useCallback(
      (event) => {
        const mousePosition = getMousePosition(event);
        if (mousePosition !== void 0) {
          seek(mousePosition);
        }
      },
      [getMousePosition, seek]
    );
    return /* @__PURE__ */ React32.createElement("div", { className: "container-buffer-graph" }, /* @__PURE__ */ React32.createElement("div", { className: "buffer-graph-title" }, `${capitalizeFirstLetter(type)} Buffer`), /* @__PURE__ */ React32.createElement(
      "div",
      {
        className: "canvas-buffer-graph-container",
        onMouseLeave: hideTip,
        onMouseMove
      },
      tipVisible ? /* @__PURE__ */ React32.createElement(
        ToolTip_default,
        {
          className: "buffer-content-tip",
          text: tipText,
          xPosition: tipPosition,
          offset: toolTipOffset
        }
      ) : null,
      /* @__PURE__ */ React32.createElement(
        "canvas",
        {
          onClick: onCanvasClick,
          height: String(CANVAS_HEIGHT),
          width: String(CANVAS_WIDTH),
          className: "canvas-buffer-graph",
          ref: canvasEl
        }
      )
    ));
  }

  // demo/scripts/controllers/charts/BufferContent.tsx
  function BufferContentChart({ player }) {
    const bufferedData = useModuleState(player, "bufferedData");
    const currentTime = useModuleState(player, "currentTime");
    const maximumPosition = useModuleState(player, "maximumPosition");
    const minimumPosition = useModuleState(player, "minimumPosition");
    const seek = React33.useCallback(
      (position) => {
        player.actions.seek(position);
      },
      [player]
    );
    if (bufferedData === null || Object.keys(bufferedData).length === 0) {
      return /* @__PURE__ */ React33.createElement("div", { className: "buffer-content-no-content" }, " No content yet ");
    }
    const subCharts = Object.keys(bufferedData).filter((type) => {
      return bufferedData[type] !== null;
    }).map((type) => {
      return /* @__PURE__ */ React33.createElement(
        BufferContentGraph,
        {
          key: type,
          type,
          currentTime,
          minimumPosition,
          maximumPosition,
          data: bufferedData[type],
          seek
        }
      );
    });
    if (subCharts.length === 0) {
      return /* @__PURE__ */ React33.createElement("div", { className: "buffer-content-no-content" }, " No content yet ");
    }
    return /* @__PURE__ */ React33.createElement("div", { className: "buffer-content-graphs-parent" }, subCharts);
  }

  // demo/scripts/controllers/charts/BufferSize.tsx
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var React34 = __toESM(require_react());
  var { useEffect: useEffect12, useRef: useRef9 } = React34;
  var HEIGHT_MARGIN_BOTTOM = 5;
  var HEIGHT_MARGIN_TOP = 20;
  var DRAWABLE_HEIGHT = 400;
  var DRAWABLE_WIDTH = 960;
  var TIME_SAMPLES_MS2 = 3e4;
  var CANVAS_WIDTH2 = DRAWABLE_WIDTH;
  var CANVAS_HEIGHT2 = DRAWABLE_HEIGHT + HEIGHT_MARGIN_TOP + HEIGHT_MARGIN_BOTTOM;
  var MINIMUM_MAX_BUFFER_SIZE2 = 20;
  var NUMBER_GRID_LINES_HEIGHT = 10;
  function BufferSizeChart({ module }) {
    const data2 = useModuleState(module, "data");
    const canvasEl = useRef9(null);
    const canvasCtx = useRef9(null);
    const currentMaxSize = useRef9(MINIMUM_MAX_BUFFER_SIZE2);
    const onNewData = React34.useCallback(
      (innerData) => {
        if (canvasCtx.current === null) {
          return;
        }
        clearAndResizeCanvas(canvasCtx.current);
        if (innerData.length === 0) {
          return;
        }
        currentMaxSize.current = getNewMaxBufferSize();
        const minDate = innerData[0].date;
        const gridHeight = DRAWABLE_HEIGHT / currentMaxSize.current;
        const gridWidth = DRAWABLE_WIDTH / TIME_SAMPLES_MS2;
        drawData();
        drawGrid();
        function getNewMaxBufferSize() {
          const maxPoint = Math.max(...innerData.map((d) => d.value || 0));
          if (maxPoint >= currentMaxSize.current) {
            return maxPoint + 5;
          } else if (maxPoint < currentMaxSize.current - 5) {
            return Math.max(maxPoint + 5, MINIMUM_MAX_BUFFER_SIZE2);
          }
          return currentMaxSize.current;
        }
        function drawGrid() {
          if (canvasCtx.current === null) {
            return;
          }
          canvasCtx.current.beginPath();
          canvasCtx.current.strokeStyle = "lightgrey";
          canvasCtx.current.lineWidth = 1;
          const stepHeight = DRAWABLE_HEIGHT / NUMBER_GRID_LINES_HEIGHT;
          const stepVal = currentMaxSize.current / NUMBER_GRID_LINES_HEIGHT;
          for (let i = 0; i <= NUMBER_GRID_LINES_HEIGHT; i++) {
            const height = stepHeight * i + HEIGHT_MARGIN_TOP;
            canvasCtx.current.moveTo(0, height);
            canvasCtx.current.font = "14px Arial";
            const currStepVal = (stepVal * (NUMBER_GRID_LINES_HEIGHT - i)).toFixed(1);
            canvasCtx.current.fillText(`${currStepVal} s`, 0, height - 5);
            canvasCtx.current.lineTo(CANVAS_WIDTH2, height);
          }
          canvasCtx.current.stroke();
        }
        function drawData() {
          if (canvasCtx.current === null) {
            return;
          }
          canvasCtx.current.beginPath();
          canvasCtx.current.strokeStyle = "rgb(200, 100, 200)";
          canvasCtx.current.lineWidth = 2;
          canvasCtx.current.moveTo(0, bufferValueToY(innerData[0].value));
          for (let i = 1; i < innerData.length; i++) {
            canvasCtx.current.lineTo(
              dateToX(innerData[i].date),
              bufferValueToY(innerData[i].value)
            );
          }
          canvasCtx.current.stroke();
        }
        function bufferValueToY(bufferVal) {
          return HEIGHT_MARGIN_TOP + (currentMaxSize.current - bufferVal) * gridHeight;
        }
        function dateToX(date) {
          return (date - minDate) * gridWidth;
        }
      },
      []
    );
    React34.useEffect(() => {
      if (data2.length > 0) {
        const lastDate = data2[data2.length - 1].date;
        const minimumTime = lastDate - TIME_SAMPLES_MS2;
        let i;
        for (i = data2.length - 1; i >= 1; i--) {
          if (data2[i].date <= minimumTime) {
            break;
          }
        }
        const consideredData = data2.slice(i);
        onNewData(consideredData);
      } else {
        onNewData([]);
      }
    }, [data2, onNewData]);
    useEffect12(() => {
      if (!canvasEl.current) {
        return;
      }
      canvasCtx.current = canvasEl.current.getContext("2d");
    }, []);
    return /* @__PURE__ */ React34.createElement("div", { className: "canvas-buffer-size-container" }, /* @__PURE__ */ React34.createElement(
      "canvas",
      {
        className: "canvas-buffer-size",
        ref: canvasEl,
        width: CANVAS_WIDTH2,
        height: CANVAS_HEIGHT2
      }
    ));
  }
  function clearAndResizeCanvas(canvasContext) {
    const canvasElt = canvasContext.canvas;
    canvasElt.width = CANVAS_WIDTH2;
    canvasElt.height = CANVAS_HEIGHT2;
    canvasContext.clearRect(0, 0, canvasElt.width, canvasElt.height);
  }
  var BufferSize_default = React34.memo(BufferSizeChart);

  // demo/scripts/controllers/charts/index.tsx
  var { useEffect: useEffect13, useState: useState9 } = React35;
  var BUFFER_GAP_REFRESH_TIME = 500;
  var MAX_BUFFER_SIZE_LENGTH = 2e3;
  function ChartsManager({ player }) {
    const [displayBufferContentChart, setDisplayBufferContentChart] = useState9(false);
    const [displayBufferSizeChart, setDisplayBufferSizeChart] = useState9(false);
    const [bufferSizeChart, setBufferSizeChart] = useState9(null);
    const [displayDebugElement, setDisplayDebugElement] = useState9(false);
    useEffect13(() => {
      if (!player) {
        return;
      }
      const newChartModule = new ChartData_default(MAX_BUFFER_SIZE_LENGTH);
      newChartModule.actions.addData(player.getState("bufferGap"));
      const interval = setInterval(() => {
        newChartModule.actions.addData(player.getState("bufferGap"));
      }, BUFFER_GAP_REFRESH_TIME);
      setBufferSizeChart(newChartModule);
      return () => {
        clearInterval(interval);
        newChartModule.destroy();
        setBufferSizeChart(null);
      };
    }, [player]);
    useEffect13(() => {
      if (!player) {
        return;
      }
      if (displayDebugElement) {
        if (!player.actions.isDebugElementShown()) {
          player.actions.showDebugElement();
        }
      } else if (player.actions.isDebugElementShown()) {
        player.actions.hideDebugElement();
      }
    }, [player, displayDebugElement]);
    const onBufferContentCheckBoxChange = React35.useCallback(
      (e) => {
        const target = e.target;
        const value = target.type === "checkbox" ? target.checked : target.value;
        setDisplayBufferContentChart(!!value);
      },
      []
    );
    const onBufferSizeCheckBoxChange = React35.useCallback(
      (e) => {
        const target = e.target;
        const value = target.type === "checkbox" ? target.checked : target.value;
        setDisplayBufferSizeChart(!!value);
      },
      []
    );
    const onDebugElementCheckBoxChange = React35.useCallback(
      (e) => {
        const target = e.target;
        const value = target.type === "checkbox" ? target.checked : target.value;
        setDisplayDebugElement(!!value);
      },
      [player]
    );
    return /* @__PURE__ */ React35.createElement("div", { className: "player-charts" }, /* @__PURE__ */ React35.createElement("div", { className: "player-box" }, /* @__PURE__ */ React35.createElement("div", { className: "chart-checkbox" }, "Buffer content chart", /* @__PURE__ */ React35.createElement("label", { className: "switch" }, /* @__PURE__ */ React35.createElement(
      "input",
      {
        name: "displayBufferContentChart",
        type: "checkbox",
        "aria-label": "Display/Hide chart about the buffer's content",
        checked: displayBufferContentChart,
        onChange: onBufferContentCheckBoxChange
      }
    ), /* @__PURE__ */ React35.createElement("span", { className: "slider round" }))), displayBufferContentChart && player ? /* @__PURE__ */ React35.createElement(BufferContentChart, { player }) : null), /* @__PURE__ */ React35.createElement("div", { className: "player-box" }, /* @__PURE__ */ React35.createElement("div", { className: "chart-checkbox" }, "Buffer size chart", /* @__PURE__ */ React35.createElement("label", { className: "switch" }, /* @__PURE__ */ React35.createElement(
      "input",
      {
        "aria-label": "Display/Hide chart about the buffer's size",
        name: "displayBufferSizeChart",
        type: "checkbox",
        checked: displayBufferSizeChart,
        onChange: onBufferSizeCheckBoxChange
      }
    ), /* @__PURE__ */ React35.createElement("span", { className: "slider round" }))), displayBufferSizeChart && bufferSizeChart !== null ? /* @__PURE__ */ React35.createElement(BufferSize_default, { module: bufferSizeChart }) : null), /* @__PURE__ */ React35.createElement("div", { className: "player-box" }, /* @__PURE__ */ React35.createElement("div", { className: "chart-checkbox" }, "Display debug element (on top of the player)", /* @__PURE__ */ React35.createElement("label", { className: "switch" }, /* @__PURE__ */ React35.createElement(
      "input",
      {
        "aria-label": "Display/Hide debug element on top of the video",
        name: "displayDebugElement",
        type: "checkbox",
        checked: displayDebugElement,
        onChange: onDebugElementCheckBoxChange
      }
    ), /* @__PURE__ */ React35.createElement("span", { className: "slider round" })))));
  }
  var charts_default = React35.memo(ChartsManager);

  // demo/scripts/controllers/PlayerKnobsSettings.tsx
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var React43 = __toESM(require_react());

  // demo/scripts/controllers/knobs/AudioRepresentation.tsx
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var React37 = __toESM(require_react());

  // demo/scripts/components/Knob.tsx
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var React36 = __toESM(require_react());
  function Knob({
    ariaLabel,
    className = "",
    name: name2 = "",
    onChange,
    options = [],
    selected,
    disabled
  }) {
    return /* @__PURE__ */ React36.createElement("div", { className: `knob ${className}` }, /* @__PURE__ */ React36.createElement("span", { className: "knob-name" }, name2), /* @__PURE__ */ React36.createElement(
      Select_default,
      {
        ariaLabel,
        name: name2,
        className: "knob-value",
        onChange,
        options,
        selected,
        disabled
      }
    ));
  }
  var Knob_default = React36.memo(Knob);

  // demo/scripts/controllers/knobs/AudioRepresentation.tsx
  function AudioRepresentationKnob({
    player,
    className
  }) {
    const isAudioRepresentationLocked = useModuleState(
      player,
      "audioRepresentationsLocked"
    );
    const audioRepresentation = useModuleState(player, "audioRepresentation");
    const audioTrack = useModuleState(player, "audioTrack");
    const availableAudioRepresentations = audioTrack === null || audioTrack === void 0 ? [] : audioTrack.representations;
    const [options, selectedIndex] = React37.useMemo(() => {
      if (!availableAudioRepresentations.length || audioRepresentation == null) {
        return [["Not available"], 0];
      }
      if (availableAudioRepresentations.length > 1) {
        let autoValue = "auto";
        if (!isAudioRepresentationLocked) {
          const info = getAudioRepresentationInfo(audioRepresentation);
          if (info.length > 0) {
            autoValue += " (" + info.join(", ") + ")";
          }
        }
        const correspondingInfo = availableAudioRepresentations.map(
          (r) => getAudioRepresentationInfo(r).join(", ")
        );
        return [
          [autoValue, ...correspondingInfo],
          isAudioRepresentationLocked ? availableAudioRepresentations.findIndex(
            (r) => r.id === (audioRepresentation == null ? void 0 : audioRepresentation.id)
          ) + 1 || 0 : 0
        ];
      }
      return [
        availableAudioRepresentations.map((r) => getAudioRepresentationInfo(r).join(", ")),
        0
      ];
    }, [availableAudioRepresentations, isAudioRepresentationLocked, audioRepresentation]);
    const onAudioRepresentationChange = React37.useCallback(
      ({ index }) => {
        if (index > 0) {
          const rep = availableAudioRepresentations[index - 1];
          player.actions.lockAudioRepresentations([rep]);
        } else {
          player.actions.unlockAudioRepresentations();
        }
      },
      [availableAudioRepresentations, player]
    );
    return /* @__PURE__ */ React37.createElement(
      Knob_default,
      {
        name: "Audio quality",
        ariaLabel: "Update the audio quality",
        className,
        disabled: availableAudioRepresentations.length < 2,
        onChange: onAudioRepresentationChange,
        options,
        selected: { index: selectedIndex, value: void 0 }
      }
    );
  }
  var AudioRepresentation_default = AudioRepresentationKnob;
  function getAudioRepresentationInfo(audioRepresentation) {
    const info = [];
    if (audioRepresentation.bitrate !== void 0) {
      info.push(`${Math.round(audioRepresentation.bitrate / 1e3)}kbps`);
    }
    if (info.length === 0) {
      info.push("id: " + String(audioRepresentation.id));
    }
    return info;
  }

  // demo/scripts/controllers/knobs/VideoRepresentation.tsx
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var React38 = __toESM(require_react());
  function VideoRepresentationKnob({
    player,
    className
  }) {
    const isVideoRepresentationLocked = useModuleState(
      player,
      "videoRepresentationsLocked"
    );
    const videoRepresentation = useModuleState(player, "videoRepresentation");
    const videoTrack = useModuleState(player, "videoTrack");
    const availableVideoRepresentations = videoTrack === null || videoTrack === void 0 ? [] : videoTrack.representations;
    const [options, selectedIndex] = React38.useMemo(() => {
      if (!availableVideoRepresentations.length || videoRepresentation == null) {
        return [["Not available"], 0];
      }
      if (availableVideoRepresentations.length > 1) {
        let autoValue = "auto";
        if (!isVideoRepresentationLocked) {
          const info = getVideoRepresentationInfo(videoRepresentation);
          if (info.length > 0) {
            autoValue += " (" + info.join(", ") + ")";
          }
        }
        const correspondingInfo = availableVideoRepresentations.map(
          (r) => getVideoRepresentationInfo(r).join(", ")
        );
        return [
          [autoValue, ...correspondingInfo],
          isVideoRepresentationLocked ? availableVideoRepresentations.findIndex(
            (r) => r.id === (videoRepresentation == null ? void 0 : videoRepresentation.id)
          ) + 1 || 0 : 0
        ];
      }
      return [
        availableVideoRepresentations.map((r) => getVideoRepresentationInfo(r).join(", ")),
        0
      ];
    }, [availableVideoRepresentations, isVideoRepresentationLocked, videoRepresentation]);
    const onVideoRepresentationChange = React38.useCallback(
      ({ index }) => {
        if (index > 0) {
          const rep = availableVideoRepresentations[index - 1];
          player.actions.lockVideoRepresentations([rep]);
        } else {
          player.actions.unlockVideoRepresentations();
        }
      },
      [availableVideoRepresentations, player]
    );
    return /* @__PURE__ */ React38.createElement(
      Knob_default,
      {
        name: "Video quality",
        ariaLabel: "Update the video quality",
        className,
        disabled: availableVideoRepresentations.length < 2,
        onChange: onVideoRepresentationChange,
        options,
        selected: { index: selectedIndex, value: void 0 }
      }
    );
  }
  var VideoRepresentation_default = VideoRepresentationKnob;
  function getVideoRepresentationInfo(videoRepresentation) {
    const info = [];
    if (videoRepresentation.height !== void 0) {
      info.push(`${videoRepresentation.height}p`);
    }
    if (videoRepresentation.bitrate !== void 0) {
      info.push(`${Math.round(videoRepresentation.bitrate / 1e3)}kbps`);
    }
    if (info.length === 0) {
      info.push("id: " + videoRepresentation.id);
    }
    return info;
  }

  // demo/scripts/controllers/knobs/AudioTrack.tsx
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var React39 = __toESM(require_react());

  // demo/scripts/lib/translateLanguageCode.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();

  // demo/assets/languages.ts
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var languages_default2 = {
    aaa: "Ghotuo",
    aab: "Alumu-Tesu",
    aac: "Ari",
    aad: "Amal",
    aae: "Arb\xEBresh\xEB Albanian",
    aaf: "Aranadan",
    aag: "Ambrak",
    aah: "Abu' Arapesh",
    aai: "Arifama-Miniafia",
    aak: "Ankave",
    aal: "Afade",
    aan: "Anamb\xE9",
    aao: "Algerian Saharan Arabic",
    aap: "Par\xE1 Ar\xE1ra",
    aaq: "Eastern Abnaki",
    aar: "Afar",
    aas: "Aas\xE1x",
    aat: "Arvanitika Albanian",
    aau: "Abau",
    aaw: "Solong",
    aax: "Mandobo Atas",
    aaz: "Amarasi",
    aba: "Ab\xE9",
    abb: "Bankon",
    abc: "Ambala Ayta",
    abd: "Manide",
    abe: "Western Abnaki",
    abf: "Abai Sungai",
    abg: "Abaga",
    abh: "Tajiki Arabic",
    abi: "Abidji",
    abj: "Aka-Bea",
    abk: "Abkhazian",
    abl: "Lampung Nyo",
    abm: "Abanyom",
    abn: "Abua",
    abo: "Abon",
    abp: "Abellen Ayta",
    abq: "Abaza",
    abr: "Abron",
    abs: "Ambonese Malay",
    abt: "Ambulas",
    abu: "Abure",
    abv: "Baharna Arabic",
    abw: "Pal",
    abx: "Inabaknon",
    aby: "Aneme Wake",
    abz: "Abui",
    aca: "Achagua",
    acb: "\xC1nc\xE1",
    acd: "Gikyode",
    ace: "Achinese",
    acf: "Saint Lucian Creole French",
    ach: "Acoli",
    aci: "Aka-Cari",
    ack: "Aka-Kora",
    acl: "Akar-Bale",
    acm: "Mesopotamian Arabic",
    acn: "Achang",
    acp: "Eastern Acipa",
    acq: "Ta'izzi-Adeni Arabic",
    acr: "Achi",
    acs: "Acro\xE1",
    act: "Achterhoeks",
    acu: "Achuar-Shiwiar",
    acv: "Achumawi",
    acw: "Hijazi Arabic",
    acx: "Omani Arabic",
    acy: "Cypriot Arabic",
    acz: "Acheron",
    ada: "Adangme",
    adb: "Adabe",
    add: "Dzodinka",
    ade: "Adele",
    adf: "Dhofari Arabic",
    adg: "Andegerebinha",
    adh: "Adhola",
    adi: "Adi",
    adj: "Adioukrou",
    adl: "Galo",
    adn: "Adang",
    ado: "Abu",
    adq: "Adangbe",
    adr: "Adonara",
    ads: "Adamorobe Sign Language",
    adt: "Adnyamathanha",
    adu: "Aduge",
    adw: "Amundava",
    adx: "Amdo Tibetan",
    ady: "Adyghe",
    adz: "Adzera",
    aea: "Areba",
    aeb: "Tunisian Arabic",
    aec: "Saidi Arabic",
    aed: "Argentine Sign Language",
    aee: "Northeast Pashai",
    aek: "Haeke",
    ael: "Ambele",
    aem: "Arem",
    aen: "Armenian Sign Language",
    aeq: "Aer",
    aer: "Eastern Arrernte",
    aes: "Alsea",
    aeu: "Akeu",
    aew: "Ambakich",
    aey: "Amele",
    aez: "Aeka",
    afb: "Gulf Arabic",
    afd: "Andai",
    afe: "Putukwam",
    afg: "Afghan Sign Language",
    afh: "Afrihili",
    afi: "Akrukay",
    afk: "Nanubae",
    afn: "Defaka",
    afo: "Eloyi",
    afp: "Tapei",
    afr: "Afrikaans",
    afs: "Afro-Seminole Creole",
    aft: "Afitti",
    afu: "Awutu",
    afz: "Obokuitai",
    aga: "Aguano",
    agb: "Legbo",
    agc: "Agatu",
    agd: "Agarabi",
    age: "Angal",
    agf: "Arguni",
    agg: "Angor",
    agh: "Ngelima",
    agi: "Agariya",
    agj: "Argobba",
    agk: "Isarog Agta",
    agl: "Fembe",
    agm: "Angaataha",
    agn: "Agutaynen",
    ago: "Tainae",
    agq: "Aghem",
    agr: "Aguaruna",
    ags: "Esimbi",
    agt: "Central Cagayan Agta",
    agu: "Aguacateco",
    agv: "Remontado Dumagat",
    agw: "Kahua",
    agx: "Aghul",
    agy: "Southern Alta",
    agz: "Mt. Iriga Agta",
    aha: "Ahanta",
    ahb: "Axamb",
    ahg: "Qimant",
    ahh: "Aghu",
    ahi: "Tiagbamrin Aizi",
    ahk: "Akha",
    ahl: "Igo",
    ahm: "Mobumrin Aizi",
    ahn: "\xC0h\xE0n",
    aho: "Ahom",
    ahp: "Aproumu Aizi",
    ahr: "Ahirani",
    ahs: "Ashe",
    aht: "Ahtena",
    aia: "Arosi",
    aib: "Ainu (China)",
    aic: "Ainbai",
    aid: "Alngith",
    aie: "Amara",
    aif: "Agi",
    aig: "Antigua and Barbuda Creole English",
    aih: "Ai-Cham",
    aii: "Assyrian Neo-Aramaic",
    aij: "Lishanid Noshan",
    aik: "Ake",
    ail: "Aimele",
    aim: "Aimol",
    ain: "Ainu (Japan)",
    aio: "Aiton",
    aip: "Burumakok",
    aiq: "Aimaq",
    air: "Airoran",
    ais: "Nataoran Amis",
    ait: "Arikem",
    aiw: "Aari",
    aix: "Aighon",
    aiy: "Ali",
    aja: "Aja (Sudan)",
    ajg: "Aja (Benin)",
    aji: "Aji\xEB",
    ajn: "Andajin",
    ajp: "South Levantine Arabic",
    ajt: "Judeo-Tunisian Arabic",
    aju: "Judeo-Moroccan Arabic",
    ajw: "Ajawa",
    ajz: "Amri Karbi",
    aka: "Akan",
    akb: "Batak Angkola",
    akc: "Mpur",
    akd: "Ukpet-Ehom",
    ake: "Akawaio",
    akf: "Akpa",
    akg: "Anakalangu",
    akh: "Angal Heneng",
    aki: "Aiome",
    akj: "Aka-Jeru",
    akk: "Akkadian",
    akl: "Aklanon",
    akm: "Aka-Bo",
    ako: "Akurio",
    akp: "Siwu",
    akq: "Ak",
    akr: "Araki",
    aks: "Akaselem",
    akt: "Akolet",
    aku: "Akum",
    akv: "Akhvakh",
    akw: "Akwa",
    akx: "Aka-Kede",
    aky: "Aka-Kol",
    akz: "Alabama",
    ala: "Alago",
    alc: "Qawasqar",
    ald: "Alladian",
    ale: "Aleut",
    alf: "Alege",
    alh: "Alawa",
    ali: "Amaimon",
    alj: "Alangan",
    alk: "Alak",
    all: "Allar",
    alm: "Amblong",
    aln: "Gheg Albanian",
    alo: "Larike-Wakasihu",
    alp: "Alune",
    alq: "Algonquin",
    alr: "Alutor",
    als: "Tosk Albanian",
    alt: "Southern Altai",
    alu: "'Are'are",
    alw: "Alaba-K\u2019abeena",
    alx: "Amol",
    aly: "Alyawarr",
    alz: "Alur",
    ama: "Amanay\xE9",
    amb: "Ambo",
    amc: "Amahuaca",
    ame: "Yanesha'",
    amf: "Hamer-Banna",
    amg: "Amurdak",
    amh: "Amharic",
    ami: "Amis",
    amj: "Amdang",
    amk: "Ambai",
    aml: "War-Jaintia",
    amm: "Ama (Papua New Guinea)",
    amn: "Amanab",
    amo: "Amo",
    amp: "Alamblak",
    amq: "Amahai",
    amr: "Amarakaeri",
    ams: "Southern Amami-Oshima",
    amt: "Amto",
    amu: "Guerrero Amuzgo",
    amv: "Ambelau",
    amw: "Western Neo-Aramaic",
    amx: "Anmatyerre",
    amy: "Ami",
    amz: "Atampaya",
    ana: "Andaqui",
    anb: "Andoa",
    anc: "Ngas",
    and: "Ansus",
    ane: "X\xE2r\xE2c\xF9\xF9",
    anf: "Animere",
    ang: "Old English (ca. 450-1100)",
    anh: "Nend",
    ani: "Andi",
    anj: "Anor",
    ank: "Goemai",
    anl: "Anu-Hkongso Chin",
    anm: "Anal",
    ann: "Obolo",
    ano: "Andoque",
    anp: "Angika",
    anq: "Jarawa (India)",
    anr: "Andh",
    ans: "Anserma",
    ant: "Antakarinya",
    anu: "Anuak",
    anv: "Denya",
    anw: "Anaang",
    anx: "Andra-Hus",
    any: "Anyin",
    anz: "Anem",
    aoa: "Angolar",
    aob: "Abom",
    aoc: "Pemon",
    aod: "Andarum",
    aoe: "Angal Enen",
    aof: "Bragat",
    aog: "Angoram",
    aoh: "Arma",
    aoi: "Anindilyakwa",
    aoj: "Mufian",
    aok: "Arh\xF6",
    aol: "Alor",
    aom: "\xD6mie",
    aon: "Bumbita Arapesh",
    aor: "Aore",
    aos: "Taikat",
    aot: "Atong (India)",
    aou: "A'ou",
    aox: "Atorada",
    aoz: "Uab Meto",
    apb: "Sa'a",
    apc: "North Levantine Arabic",
    apd: "Sudanese Arabic",
    ape: "Bukiyip",
    apf: "Pahanan Agta",
    apg: "Ampanang",
    aph: "Athpariya",
    api: "Apiak\xE1",
    apj: "Jicarilla Apache",
    apk: "Kiowa Apache",
    apl: "Lipan Apache",
    apm: "Mescalero-Chiricahua Apache",
    apn: "Apinay\xE9",
    apo: "Ambul",
    app: "Apma",
    apq: "A-Pucikwar",
    apr: "Arop-Lokep",
    aps: "Arop-Sissano",
    apt: "Apatani",
    apu: "Apurin\xE3",
    apv: "Alapmunte",
    apw: "Western Apache",
    apx: "Aputai",
    apy: "Apala\xED",
    apz: "Safeyoka",
    aqc: "Archi",
    aqd: "Ampari Dogon",
    aqg: "Arigidi",
    aqm: "Atohwaim",
    aqn: "Northern Alta",
    aqp: "Atakapa",
    aqr: "Arh\xE2",
    aqt: "Angait\xE9",
    aqz: "Akuntsu",
    ara: "Arabic",
    arb: "Standard Arabic",
    arc: "Official Aramaic (700-300 BCE)",
    ard: "Arabana",
    are: "Western Arrarnta",
    arg: "Aragonese",
    arh: "Arhuaco",
    ari: "Arikara",
    arj: "Arapaso",
    ark: "Arikap\xFA",
    arl: "Arabela",
    arn: "Mapudungun",
    aro: "Araona",
    arp: "Arapaho",
    arq: "Algerian Arabic",
    arr: "Karo (Brazil)",
    ars: "Najdi Arabic",
    aru: "Aru\xE1 (Amazonas State)",
    arv: "Arbore",
    arw: "Arawak",
    arx: "Aru\xE1 (Rodonia State)",
    ary: "Moroccan Arabic",
    arz: "Egyptian Arabic",
    asa: "Asu (Tanzania)",
    asb: "Assiniboine",
    asc: "Casuarina Coast Asmat",
    asd: "Asas",
    ase: "American Sign Language",
    asf: "Australian Sign Language",
    asg: "Cishingini",
    ash: "Abishira",
    asi: "Buruwai",
    asj: "Sari",
    ask: "Ashkun",
    asl: "Asilulu",
    asm: "Assamese",
    asn: "Xing\xFA Asurin\xED",
    aso: "Dano",
    asp: "Algerian Sign Language",
    asq: "Austrian Sign Language",
    asr: "Asuri",
    ass: "Ipulo",
    ast: "Asturian",
    asu: "Tocantins Asurini",
    asv: "Asoa",
    asw: "Australian Aborigines Sign Language",
    asx: "Muratayak",
    asy: "Yaosakor Asmat",
    asz: "As",
    ata: "Pele-Ata",
    atb: "Zaiwa",
    atc: "Atsahuaca",
    atd: "Ata Manobo",
    ate: "Atemble",
    atg: "Ivbie North-Okpela-Arhe",
    ati: "Atti\xE9",
    atj: "Atikamekw",
    atk: "Ati",
    atl: "Mt. Iraya Agta",
    atm: "Ata",
    atn: "Ashtiani",
    ato: "Atong (Cameroon)",
    atp: "Pudtol Atta",
    atq: "Aralle-Tabulahan",
    atr: "Waimiri-Atroari",
    ats: "Gros Ventre",
    att: "Pamplona Atta",
    atu: "Reel",
    atv: "Northern Altai",
    atw: "Atsugewi",
    atx: "Arutani",
    aty: "Aneityum",
    atz: "Arta",
    aua: "Asumboa",
    aub: "Alugu",
    auc: "Waorani",
    aud: "Anuta",
    aug: "Aguna",
    auh: "Aushi",
    aui: "Anuki",
    auj: "Awjilah",
    auk: "Heyo",
    aul: "Aulua",
    aum: "Asu (Nigeria)",
    aun: "Molmo One",
    auo: "Auyokawa",
    aup: "Makayam",
    auq: "Anus",
    aur: "Aruek",
    aut: "Austral",
    auu: "Auye",
    auw: "Awyi",
    aux: "Aur\xE1",
    auy: "Awiyaana",
    auz: "Uzbeki Arabic",
    ava: "Avaric",
    avb: "Avau",
    avd: "Alviri-Vidari",
    ave: "Avestan",
    avi: "Avikam",
    avk: "Kotava",
    avl: "Eastern Egyptian Bedawi Arabic",
    avm: "Angkamuthi",
    avn: "Avatime",
    avo: "Agavotaguerra",
    avs: "Aushiri",
    avt: "Au",
    avu: "Avokaya",
    avv: "Av\xE1-Canoeiro",
    awa: "Awadhi",
    awb: "Awa (Papua New Guinea)",
    awc: "Cicipu",
    awe: "Awet\xED",
    awg: "Anguthimri",
    awh: "Awbono",
    awi: "Aekyom",
    awk: "Awabakal",
    awm: "Arawum",
    awn: "Awngi",
    awo: "Awak",
    awr: "Awera",
    aws: "South Awyu",
    awt: "Arawet\xE9",
    awu: "Central Awyu",
    awv: "Jair Awyu",
    aww: "Awun",
    awx: "Awara",
    awy: "Edera Awyu",
    axb: "Abipon",
    axe: "Ayerrerenge",
    axg: "Mato Grosso Ar\xE1ra",
    axk: "Yaka (Central African Republic)",
    axl: "Lower Southern Aranda",
    axm: "Middle Armenian",
    axx: "X\xE2r\xE2gur\xE8",
    aya: "Awar",
    ayb: "Ayizo Gbe",
    ayc: "Southern Aymara",
    ayd: "Ayabadhu",
    aye: "Ayere",
    ayg: "Ginyanga",
    ayh: "Hadrami Arabic",
    ayi: "Leyigha",
    ayk: "Akuku",
    ayl: "Libyan Arabic",
    aym: "Aymara",
    ayn: "Sanaani Arabic",
    ayo: "Ayoreo",
    ayp: "North Mesopotamian Arabic",
    ayq: "Ayi (Papua New Guinea)",
    ayr: "Central Aymara",
    ays: "Sorsogon Ayta",
    ayt: "Magbukun Ayta",
    ayu: "Ayu",
    ayy: "Tayabas Ayta",
    ayz: "Mai Brat",
    aza: "Azha",
    azb: "South Azerbaijani",
    azd: "Eastern Durango Nahuatl",
    aze: "Azerbaijani",
    azg: "San Pedro Amuzgos Amuzgo",
    azj: "North Azerbaijani",
    azm: "Ipalapa Amuzgo",
    azn: "Western Durango Nahuatl",
    azo: "Awing",
    azt: "Faire Atta",
    azz: "Highland Puebla Nahuatl",
    baa: "Babatana",
    bab: "Bainouk-Gunyu\xF1o",
    bac: "Badui",
    bae: "Bar\xE9",
    baf: "Nubaca",
    bag: "Tuki",
    bah: "Bahamas Creole English",
    baj: "Barakai",
    bak: "Bashkir",
    bal: "Baluchi",
    bam: "Bambara",
    ban: "Balinese",
    bao: "Waimaha",
    bap: "Bantawa",
    bar: "Bavarian",
    bas: "Basa (Cameroon)",
    bau: "Bada (Nigeria)",
    bav: "Vengo",
    baw: "Bambili-Bambui",
    bax: "Bamun",
    bay: "Batuley",
    bba: "Baatonum",
    bbb: "Barai",
    bbc: "Batak Toba",
    bbd: "Bau",
    bbe: "Bangba",
    bbf: "Baibai",
    bbg: "Barama",
    bbh: "Bugan",
    bbi: "Barombi",
    bbj: "Ghom\xE1l\xE1'",
    bbk: "Babanki",
    bbl: "Bats",
    bbm: "Babango",
    bbn: "Uneapa",
    bbo: "Northern Bobo Madar\xE9",
    bbp: "West Central Banda",
    bbq: "Bamali",
    bbr: "Girawa",
    bbs: "Bakpinka",
    bbt: "Mburku",
    bbu: "Kulung (Nigeria)",
    bbv: "Karnai",
    bbw: "Baba",
    bbx: "Bubia",
    bby: "Befang",
    bbz: "Babalia Creole Arabic",
    bca: "Central Bai",
    bcb: "Bainouk-Samik",
    bcc: "Southern Balochi",
    bcd: "North Babar",
    bce: "Bamenyam",
    bcf: "Bamu",
    bcg: "Baga Pokur",
    bch: "Bariai",
    bci: "Baoul\xE9",
    bcj: "Bardi",
    bck: "Bunaba",
    bcl: "Central Bikol",
    bcm: "Bannoni",
    bcn: "Bali (Nigeria)",
    bco: "Kaluli",
    bcp: "Bali (Democratic Republic of Congo)",
    bcq: "Bench",
    bcr: "Babine",
    bcs: "Kohumono",
    bct: "Bendi",
    bcu: "Awad Bing",
    bcv: "Shoo-Minda-Nye",
    bcw: "Bana",
    bcy: "Bacama",
    bcz: "Bainouk-Gunyaamolo",
    bda: "Bayot",
    bdb: "Basap",
    bdc: "Ember\xE1-Baud\xF3",
    bdd: "Bunama",
    bde: "Bade",
    bdf: "Biage",
    bdg: "Bonggi",
    bdh: "Baka (Sudan)",
    bdi: "Burun",
    bdj: "Bai",
    bdk: "Budukh",
    bdl: "Indonesian Bajau",
    bdm: "Buduma",
    bdn: "Baldemu",
    bdo: "Morom",
    bdp: "Bende",
    bdq: "Bahnar",
    bdr: "West Coast Bajau",
    bds: "Burunge",
    bdt: "Bokoto",
    bdu: "Oroko",
    bdv: "Bodo Parja",
    bdw: "Baham",
    bdx: "Budong-Budong",
    bdy: "Bandjalang",
    bdz: "Badeshi",
    bea: "Beaver",
    beb: "Bebele",
    bec: "Iceve-Maci",
    bed: "Bedoanas",
    bee: "Byangsi",
    bef: "Benabena",
    beg: "Belait",
    beh: "Biali",
    bei: "Bekati'",
    bej: "Beja",
    bek: "Bebeli",
    bel: "Belarusian",
    bem: "Bemba (Zambia)",
    ben: "Bengali",
    beo: "Beami",
    bep: "Besoa",
    beq: "Beembe",
    bes: "Besme",
    bet: "Guiberoua B\xE9te",
    beu: "Blagar",
    bev: "Daloa B\xE9t\xE9",
    bew: "Betawi",
    bex: "Jur Modo",
    bey: "Beli (Papua New Guinea)",
    bez: "Bena (Tanzania)",
    bfa: "Bari",
    bfb: "Pauri Bareli",
    bfc: "Panyi Bai",
    bfd: "Bafut",
    bfe: "Betaf",
    bff: "Bofi",
    bfg: "Busang Kayan",
    bfh: "Blafe",
    bfi: "British Sign Language",
    bfj: "Bafanji",
    bfk: "Ban Khor Sign Language",
    bfl: "Banda-Nd\xE9l\xE9",
    bfm: "Mmen",
    bfn: "Bunak",
    bfo: "Malba Birifor",
    bfp: "Beba",
    bfq: "Badaga",
    bfr: "Bazigar",
    bfs: "Southern Bai",
    bft: "Balti",
    bfu: "Gahri",
    bfw: "Bondo",
    bfx: "Bantayanon",
    bfy: "Bagheli",
    bfz: "Mahasu Pahari",
    bga: "Gwamhi-Wuri",
    bgb: "Bobongko",
    bgc: "Haryanvi",
    bgd: "Rathwi Bareli",
    bge: "Bauria",
    bgf: "Bangandu",
    bgg: "Bugun",
    bgi: "Giangan",
    bgj: "Bangolan",
    bgk: "Bit",
    bgl: "Bo (Laos)",
    bgn: "Western Balochi",
    bgo: "Baga Koga",
    bgp: "Eastern Balochi",
    bgq: "Bagri",
    bgr: "Bawm Chin",
    bgs: "Tagabawa",
    bgt: "Bughotu",
    bgu: "Mbongno",
    bgv: "Warkay-Bipim",
    bgw: "Bhatri",
    bgx: "Balkan Gagauz Turkish",
    bgy: "Benggoi",
    bgz: "Banggai",
    bha: "Bharia",
    bhb: "Bhili",
    bhc: "Biga",
    bhd: "Bhadrawahi",
    bhe: "Bhaya",
    bhf: "Odiai",
    bhg: "Binandere",
    bhh: "Bukharic",
    bhi: "Bhilali",
    bhj: "Bahing",
    bhl: "Bimin",
    bhm: "Bathari",
    bhn: "Bohtan Neo-Aramaic",
    bho: "Bhojpuri",
    bhp: "Bima",
    bhq: "Tukang Besi South",
    bhr: "Bara Malagasy",
    bhs: "Buwal",
    bht: "Bhattiyali",
    bhu: "Bhunjia",
    bhv: "Bahau",
    bhw: "Biak",
    bhx: "Bhalay",
    bhy: "Bhele",
    bhz: "Bada (Indonesia)",
    bia: "Badimaya",
    bib: "Bissa",
    bic: "Bikaru",
    bid: "Bidiyo",
    bie: "Bepour",
    bif: "Biafada",
    big: "Biangai",
    bij: "Vaghat-Ya-Bijim-Legeri",
    bik: "Bikol",
    bil: "Bile",
    bim: "Bimoba",
    bin: "Bini",
    bio: "Nai",
    bip: "Bila",
    biq: "Bipi",
    bir: "Bisorio",
    bis: "Bislama",
    bit: "Berinomo",
    biu: "Biete",
    biv: "Southern Birifor",
    biw: "Kol (Cameroon)",
    bix: "Bijori",
    biy: "Birhor",
    biz: "Baloi",
    bja: "Budza",
    bjb: "Banggarla",
    bjc: "Bariji",
    bje: "Biao-Jiao Mien",
    bjf: "Barzani Jewish Neo-Aramaic",
    bjg: "Bidyogo",
    bjh: "Bahinemo",
    bji: "Burji",
    bjj: "Kanauji",
    bjk: "Barok",
    bjl: "Bulu (Papua New Guinea)",
    bjm: "Bajelani",
    bjn: "Banjar",
    bjo: "Mid-Southern Banda",
    bjp: "Fanamaket",
    bjr: "Binumarien",
    bjs: "Bajan",
    bjt: "Balanta-Ganja",
    bju: "Busuu",
    bjv: "Bedjond",
    bjw: "Bakw\xE9",
    bjx: "Banao Itneg",
    bjy: "Bayali",
    bjz: "Baruga",
    bka: "Kyak",
    bkc: "Baka (Cameroon)",
    bkd: "Binukid",
    bkf: "Beeke",
    bkg: "Buraka",
    bkh: "Bakoko",
    bki: "Baki",
    bkj: "Pande",
    bkk: "Brokskat",
    bkl: "Berik",
    bkm: "Kom (Cameroon)",
    bkn: "Bukitan",
    bko: "Kwa'",
    bkp: "Boko (Democratic Republic of Congo)",
    bkq: "Bakair\xED",
    bkr: "Bakumpai",
    bks: "Northern Sorsoganon",
    bkt: "Boloki",
    bku: "Buhid",
    bkv: "Bekwarra",
    bkw: "Bekwel",
    bkx: "Baikeno",
    bky: "Bokyi",
    bkz: "Bungku",
    bla: "Siksika",
    blb: "Bilua",
    blc: "Bella Coola",
    bld: "Bolango",
    ble: "Balanta-Kentohe",
    blf: "Buol",
    blg: "Balau",
    blh: "Kuwaa",
    bli: "Bolia",
    blj: "Bolongan",
    blk: "Pa'o Karen",
    bll: "Biloxi",
    blm: "Beli (Sudan)",
    bln: "Southern Catanduanes Bikol",
    blo: "Anii",
    blp: "Blablanga",
    blq: "Baluan-Pam",
    blr: "Blang",
    bls: "Balaesang",
    blt: "Tai Dam",
    blv: "Kibala",
    blw: "Balangao",
    blx: "Mag-Indi Ayta",
    bly: "Notre",
    blz: "Balantak",
    bma: "Lame",
    bmb: "Bembe",
    bmc: "Biem",
    bmd: "Baga Manduri",
    bme: "Limassa",
    bmf: "Bom-Kim",
    bmg: "Bamwe",
    bmh: "Kein",
    bmi: "Bagirmi",
    bmj: "Bote-Majhi",
    bmk: "Ghayavi",
    bml: "Bomboli",
    bmm: "Northern Betsimisaraka Malagasy",
    bmn: "Bina (Papua New Guinea)",
    bmo: "Bambalang",
    bmp: "Bulgebi",
    bmq: "Bomu",
    bmr: "Muinane",
    bms: "Bilma Kanuri",
    bmt: "Biao Mon",
    bmu: "Somba-Siawari",
    bmv: "Bum",
    bmw: "Bomwali",
    bmx: "Baimak",
    bmz: "Baramu",
    bna: "Bonerate",
    bnb: "Bookan",
    bnc: "Bontok",
    bnd: "Banda (Indonesia)",
    bne: "Bintauna",
    bnf: "Masiwang",
    bng: "Benga",
    bni: "Bangi",
    bnj: "Eastern Tawbuid",
    bnk: "Bierebo",
    bnl: "Boon",
    bnm: "Batanga",
    bnn: "Bunun",
    bno: "Bantoanon",
    bnp: "Bola",
    bnq: "Bantik",
    bnr: "Butmas-Tur",
    bns: "Bundeli",
    bnu: "Bentong",
    bnv: "Bonerif",
    bnw: "Bisis",
    bnx: "Bangubangu",
    bny: "Bintulu",
    bnz: "Beezen",
    boa: "Bora",
    bob: "Aweer",
    bod: "Tibetan",
    boe: "Mundabli",
    bof: "Bolon",
    bog: "Bamako Sign Language",
    boh: "Boma",
    boi: "Barbare\xF1o",
    boj: "Anjam",
    bok: "Bonjo",
    bol: "Bole",
    bom: "Berom",
    bon: "Bine",
    boo: "Tiemac\xE8w\xE8 Bozo",
    bop: "Bonkiman",
    boq: "Bogaya",
    bor: "Bor\xF4ro",
    bos: "Bosnian",
    bot: "Bongo",
    bou: "Bondei",
    bov: "Tuwuli",
    bow: "Rema",
    box: "Buamu",
    boy: "Bodo (Central African Republic)",
    boz: "Ti\xE9yaxo Bozo",
    bpa: "Daakaka",
    bpb: "Barbacoas",
    bpd: "Banda-Banda",
    bpg: "Bonggo",
    bph: "Botlikh",
    bpi: "Bagupi",
    bpj: "Binji",
    bpk: "Orowe",
    bpl: "Broome Pearling Lugger Pidgin",
    bpm: "Biyom",
    bpn: "Dzao Min",
    bpo: "Anasi",
    bpp: "Kaure",
    bpq: "Banda Malay",
    bpr: "Koronadal Blaan",
    bps: "Sarangani Blaan",
    bpt: "Barrow Point",
    bpu: "Bongu",
    bpv: "Bian Marind",
    bpw: "Bo (Papua New Guinea)",
    bpx: "Palya Bareli",
    bpy: "Bishnupriya",
    bpz: "Bilba",
    bqa: "Tchumbuli",
    bqb: "Bagusa",
    bqc: "Boko (Benin)",
    bqd: "Bung",
    bqf: "Baga Kaloum",
    bqg: "Bago-Kusuntu",
    bqh: "Baima",
    bqi: "Bakhtiari",
    bqj: "Bandial",
    bqk: "Banda-Mbr\xE8s",
    bql: "Bilakura",
    bqm: "Wumboko",
    bqn: "Bulgarian Sign Language",
    bqo: "Balo",
    bqp: "Busa",
    bqq: "Biritai",
    bqr: "Burusu",
    bqs: "Bosngun",
    bqt: "Bamukumbit",
    bqu: "Boguru",
    bqv: "Koro Wachi",
    bqw: "Buru (Nigeria)",
    bqx: "Baangi",
    bqy: "Bengkala Sign Language",
    bqz: "Bakaka",
    bra: "Braj",
    brb: "Lave",
    brc: "Berbice Creole Dutch",
    brd: "Baraamu",
    bre: "Breton",
    brf: "Bera",
    brg: "Baure",
    brh: "Brahui",
    bri: "Mokpwe",
    brj: "Bieria",
    brk: "Birked",
    brl: "Birwa",
    brm: "Barambu",
    brn: "Boruca",
    bro: "Brokkat",
    brp: "Barapasi",
    brq: "Breri",
    brr: "Birao",
    brs: "Baras",
    brt: "Bitare",
    bru: "Eastern Bru",
    brv: "Western Bru",
    brw: "Bellari",
    brx: "Bodo (India)",
    bry: "Burui",
    brz: "Bilbil",
    bsa: "Abinomn",
    bsb: "Brunei Bisaya",
    bsc: "Bassari",
    bse: "Wushi",
    bsf: "Bauchi",
    bsg: "Bashkardi",
    bsh: "Kati",
    bsi: "Bassossi",
    bsj: "Bangwinji",
    bsk: "Burushaski",
    bsl: "Basa-Gumna",
    bsm: "Busami",
    bsn: "Barasana-Eduria",
    bso: "Buso",
    bsp: "Baga Sitemu",
    bsq: "Bassa",
    bsr: "Bassa-Kontagora",
    bss: "Akoose",
    bst: "Basketo",
    bsu: "Bahonsuai",
    bsv: "Baga Soban\xE9",
    bsw: "Baiso",
    bsx: "Yangkam",
    bsy: "Sabah Bisaya",
    bta: "Bata",
    btc: "Bati (Cameroon)",
    btd: "Batak Dairi",
    bte: "Gamo-Ningi",
    btf: "Birgit",
    btg: "Gagnoa B\xE9t\xE9",
    bth: "Biatah Bidayuh",
    bti: "Burate",
    btj: "Bacanese Malay",
    btm: "Batak Mandailing",
    btn: "Ratagnon",
    bto: "Rinconada Bikol",
    btp: "Budibud",
    btq: "Batek",
    btr: "Baetora",
    bts: "Batak Simalungun",
    btt: "Bete-Bendi",
    btu: "Batu",
    btv: "Bateri",
    btw: "Butuanon",
    btx: "Batak Karo",
    bty: "Bobot",
    btz: "Batak Alas-Kluet",
    bua: "Buriat",
    bub: "Bua",
    buc: "Bushi",
    bud: "Ntcham",
    bue: "Beothuk",
    buf: "Bushoong",
    bug: "Buginese",
    buh: "Younuo Bunu",
    bui: "Bongili",
    buj: "Basa-Gurmana",
    buk: "Bugawac",
    bul: "Bulgarian",
    bum: "Bulu (Cameroon)",
    bun: "Sherbro",
    buo: "Terei",
    bup: "Busoa",
    buq: "Brem",
    bus: "Bokobaru",
    but: "Bungain",
    buu: "Budu",
    buv: "Bun",
    buw: "Bubi",
    bux: "Boghom",
    buy: "Bullom So",
    buz: "Bukwen",
    bva: "Barein",
    bvb: "Bube",
    bvc: "Baelelea",
    bvd: "Baeggu",
    bve: "Berau Malay",
    bvf: "Boor",
    bvg: "Bonkeng",
    bvh: "Bure",
    bvi: "Belanda Viri",
    bvj: "Baan",
    bvk: "Bukat",
    bvl: "Bolivian Sign Language",
    bvm: "Bamunka",
    bvn: "Buna",
    bvo: "Bolgo",
    bvp: "Bumang",
    bvq: "Birri",
    bvr: "Burarra",
    bvt: "Bati (Indonesia)",
    bvu: "Bukit Malay",
    bvv: "Baniva",
    bvw: "Boga",
    bvx: "Dibole",
    bvy: "Baybayanon",
    bvz: "Bauzi",
    bwa: "Bwatoo",
    bwb: "Namosi-Naitasiri-Serua",
    bwc: "Bwile",
    bwd: "Bwaidoka",
    bwe: "Bwe Karen",
    bwf: "Boselewa",
    bwg: "Barwe",
    bwh: "Bishuo",
    bwi: "Baniwa",
    bwj: "L\xE1\xE1 L\xE1\xE1 Bwamu",
    bwk: "Bauwaki",
    bwl: "Bwela",
    bwm: "Biwat",
    bwn: "Wunai Bunu",
    bwo: "Boro (Ethiopia)",
    bwp: "Mandobo Bawah",
    bwq: "Southern Bobo Madar\xE9",
    bwr: "Bura-Pabir",
    bws: "Bomboma",
    bwt: "Bafaw-Balong",
    bwu: "Buli (Ghana)",
    bww: "Bwa",
    bwx: "Bu-Nao Bunu",
    bwy: "Cwi Bwamu",
    bwz: "Bwisi",
    bxa: "Tairaha",
    bxb: "Belanda Bor",
    bxc: "Molengue",
    bxd: "Pela",
    bxe: "Birale",
    bxf: "Bilur",
    bxg: "Bangala",
    bxh: "Buhutu",
    bxi: "Pirlatapa",
    bxj: "Bayungu",
    bxk: "Bukusu",
    bxl: "Jalkunan",
    bxm: "Mongolia Buriat",
    bxn: "Burduna",
    bxo: "Barikanchi",
    bxp: "Bebil",
    bxq: "Beele",
    bxr: "Russia Buriat",
    bxs: "Busam",
    bxu: "China Buriat",
    bxv: "Berakou",
    bxw: "Bankagooma",
    bxz: "Binahari",
    bya: "Batak",
    byb: "Bikya",
    byc: "Ubaghara",
    byd: "Benyadu'",
    bye: "Pouye",
    byf: "Bete",
    byg: "Baygo",
    byh: "Bhujel",
    byi: "Buyu",
    byj: "Bina (Nigeria)",
    byk: "Biao",
    byl: "Bayono",
    bym: "Bidyara",
    byn: "Bilin",
    byo: "Biyo",
    byp: "Bumaji",
    byq: "Basay",
    byr: "Baruya",
    bys: "Burak",
    byt: "Berti",
    byv: "Medumba",
    byw: "Belhariya",
    byx: "Qaqet",
    byz: "Banaro",
    bza: "Bandi",
    bzb: "Andio",
    bzc: "Southern Betsimisaraka Malagasy",
    bzd: "Bribri",
    bze: "Jenaama Bozo",
    bzf: "Boikin",
    bzg: "Babuza",
    bzh: "Mapos Buang",
    bzi: "Bisu",
    bzj: "Belize Kriol English",
    bzk: "Nicaragua Creole English",
    bzl: "Boano (Sulawesi)",
    bzm: "Bolondo",
    bzn: "Boano (Maluku)",
    bzo: "Bozaba",
    bzp: "Kemberano",
    bzq: "Buli (Indonesia)",
    bzr: "Biri",
    bzs: "Brazilian Sign Language",
    bzt: "Brithenig",
    bzu: "Burmeso",
    bzv: "Naami",
    bzw: "Basa (Nigeria)",
    bzx: "K\u025Bl\u025Bngaxo Bozo",
    bzy: "Obanliku",
    bzz: "Evant",
    caa: "Chort\xED",
    cab: "Garifuna",
    cac: "Chuj",
    cad: "Caddo",
    cae: "Lehar",
    caf: "Southern Carrier",
    cag: "Nivacl\xE9",
    cah: "Cahuarano",
    caj: "Chan\xE9",
    cak: "Kaqchikel",
    cal: "Carolinian",
    cam: "Cemuh\xEE",
    can: "Chambri",
    cao: "Ch\xE1cobo",
    cap: "Chipaya",
    caq: "Car Nicobarese",
    car: "Galibi Carib",
    cas: "Tsiman\xE9",
    cat: "Catalan",
    cav: "Cavine\xF1a",
    caw: "Callawalla",
    cax: "Chiquitano",
    cay: "Cayuga",
    caz: "Canichana",
    cbb: "Cabiyar\xED",
    cbc: "Carapana",
    cbd: "Carijona",
    cbg: "Chimila",
    cbi: "Chachi",
    cbj: "Ede Cabe",
    cbk: "Chavacano",
    cbl: "Bualkhaw Chin",
    cbn: "Nyahkur",
    cbo: "Izora",
    cbq: "Tsucuba",
    cbr: "Cashibo-Cacataibo",
    cbs: "Cashinahua",
    cbt: "Chayahuita",
    cbu: "Candoshi-Shapra",
    cbv: "Cacua",
    cbw: "Kinabalian",
    cby: "Carabayo",
    cca: "Cauca",
    ccc: "Chamicuro",
    ccd: "Cafundo Creole",
    cce: "Chopi",
    ccg: "Samba Daka",
    cch: "Atsam",
    ccj: "Kasanga",
    ccl: "Cutchi-Swahili",
    ccm: "Malaccan Creole Malay",
    cco: "Comaltepec Chinantec",
    ccp: "Chakma",
    ccr: "Cacaopera",
    cda: "Choni",
    cde: "Chenchu",
    cdf: "Chiru",
    cdg: "Chamari",
    cdh: "Chambeali",
    cdi: "Chodri",
    cdj: "Churahi",
    cdm: "Chepang",
    cdn: "Chaudangsi",
    cdo: "Min Dong Chinese",
    cdr: "Cinda-Regi-Tiyal",
    cds: "Chadian Sign Language",
    cdy: "Chadong",
    cdz: "Koda",
    cea: "Lower Chehalis",
    ceb: "Cebuano",
    ceg: "Chamacoco",
    cek: "Eastern Khumi Chin",
    cen: "Cen",
    ces: "Czech",
    cet: "Cent\xFA\xFAm",
    cfa: "Dijim-Bwilim",
    cfd: "Cara",
    cfg: "Como Karim",
    cfm: "Falam Chin",
    cga: "Changriwa",
    cgc: "Kagayanen",
    cgg: "Chiga",
    cgk: "Chocangacakha",
    cha: "Chamorro",
    chb: "Chibcha",
    chc: "Catawba",
    chd: "Highland Oaxaca Chontal",
    che: "Chechen",
    chf: "Tabasco Chontal",
    chg: "Chagatai",
    chh: "Chinook",
    chj: "Ojitl\xE1n Chinantec",
    chk: "Chuukese",
    chl: "Cahuilla",
    chm: "Mari (Russia)",
    chn: "Chinook jargon",
    cho: "Choctaw",
    chp: "Chipewyan",
    chq: "Quiotepec Chinantec",
    chr: "Cherokee",
    cht: "Chol\xF3n",
    chu: "Church Slavic",
    chv: "Chuvash",
    chw: "Chuwabu",
    chx: "Chantyal",
    chy: "Cheyenne",
    chz: "Ozumac\xEDn Chinantec",
    cia: "Cia-Cia",
    cib: "Ci Gbe",
    cic: "Chickasaw",
    cid: "Chimariko",
    cie: "Cineni",
    cih: "Chinali",
    cik: "Chitkuli Kinnauri",
    cim: "Cimbrian",
    cin: "Cinta Larga",
    cip: "Chiapanec",
    cir: "Tiri",
    ciw: "Chippewa",
    ciy: "Chaima",
    cja: "Western Cham",
    cje: "Chru",
    cjh: "Upper Chehalis",
    cji: "Chamalal",
    cjk: "Chokwe",
    cjm: "Eastern Cham",
    cjn: "Chenapian",
    cjo: "Ash\xE9ninka Pajonal",
    cjp: "Cab\xE9car",
    cjs: "Shor",
    cjv: "Chuave",
    cjy: "Jinyu Chinese",
    ckb: "Central Kurdish",
    ckh: "Chak",
    ckl: "Cibak",
    ckn: "Kaang Chin",
    cko: "Anufo",
    ckq: "Kajakse",
    ckr: "Kairak",
    cks: "Tayo",
    ckt: "Chukot",
    cku: "Koasati",
    ckv: "Kavalan",
    ckx: "Caka",
    cky: "Cakfem-Mushere",
    ckz: "Cakchiquel-Quich\xE9 Mixed Language",
    cla: "Ron",
    clc: "Chilcotin",
    cld: "Chaldean Neo-Aramaic",
    cle: "Lealao Chinantec",
    clh: "Chilisso",
    cli: "Chakali",
    clj: "Laitu Chin",
    clk: "Idu-Mishmi",
    cll: "Chala",
    clm: "Clallam",
    clo: "Lowland Oaxaca Chontal",
    clt: "Lautu Chin",
    clu: "Caluyanun",
    clw: "Chulym",
    cly: "Eastern Highland Chatino",
    cma: "Maa",
    cme: "Cerma",
    cmg: "Classical Mongolian",
    cmi: "Ember\xE1-Cham\xED",
    cml: "Campalagian",
    cmm: "Michigamea",
    cmn: "Mandarin Chinese",
    cmo: "Central Mnong",
    cmr: "Mro-Khimi Chin",
    cms: "Messapic",
    cmt: "Camtho",
    cna: "Changthang",
    cnb: "Chinbon Chin",
    cnc: "C\xF4\xF4ng",
    cng: "Northern Qiang",
    cnh: "Hakha Chin",
    cni: "Ash\xE1ninka",
    cnk: "Khumi Chin",
    cnl: "Lalana Chinantec",
    cno: "Con",
    cns: "Central Asmat",
    cnt: "Tepetotutla Chinantec",
    cnu: "Chenoua",
    cnw: "Ngawn Chin",
    cnx: "Middle Cornish",
    coa: "Cocos Islands Malay",
    cob: "Chicomuceltec",
    coc: "Cocopa",
    cod: "Cocama-Cocamilla",
    coe: "Koreguaje",
    cof: "Colorado",
    cog: "Chong",
    coh: "Chonyi-Dzihana-Kauma",
    coj: "Cochimi",
    cok: "Santa Teresa Cora",
    col: "Columbia-Wenatchi",
    com: "Comanche",
    con: "Cof\xE1n",
    coo: "Comox",
    cop: "Coptic",
    coq: "Coquille",
    cor: "Cornish",
    cos: "Corsican",
    cot: "Caquinte",
    cou: "Wamey",
    cov: "Cao Miao",
    cow: "Cowlitz",
    cox: "Nanti",
    coz: "Chochotec",
    cpa: "Palantla Chinantec",
    cpb: "Ucayali-Yur\xFAa Ash\xE9ninka",
    cpc: "Ajy\xEDninka Apurucayali",
    cpg: "Cappadocian Greek",
    cpi: "Chinese Pidgin English",
    cpn: "Cherepon",
    cpo: "Kpeego",
    cps: "Capiznon",
    cpu: "Pichis Ash\xE9ninka",
    cpx: "Pu-Xian Chinese",
    cpy: "South Ucayali Ash\xE9ninka",
    cqd: "Chuanqiandian Cluster Miao",
    cra: "Chara",
    crb: "Island Carib",
    crc: "Lonwolwol",
    crd: "Coeur d'Alene",
    cre: "Cree",
    crf: "Caramanta",
    crg: "Michif",
    crh: "Crimean Tatar",
    cri: "S\xE3otomense",
    crj: "Southern East Cree",
    crk: "Plains Cree",
    crl: "Northern East Cree",
    crm: "Moose Cree",
    crn: "El Nayar Cora",
    cro: "Crow",
    crq: "Iyo'wujwa Chorote",
    crr: "Carolina Algonquian",
    crs: "Seselwa Creole French",
    crt: "Iyojwa'ja Chorote",
    crv: "Chaura",
    crw: "Chrau",
    crx: "Carrier",
    cry: "Cori",
    crz: "Cruze\xF1o",
    csa: "Chiltepec Chinantec",
    csb: "Kashubian",
    csc: "Catalan Sign Language",
    csd: "Chiangmai Sign Language",
    cse: "Czech Sign Language",
    csf: "Cuba Sign Language",
    csg: "Chilean Sign Language",
    csh: "Asho Chin",
    csi: "Coast Miwok",
    csj: "Songlai Chin",
    csk: "Jola-Kasa",
    csl: "Chinese Sign Language",
    csm: "Central Sierra Miwok",
    csn: "Colombian Sign Language",
    cso: "Sochiapam Chinantec",
    csq: "Croatia Sign Language",
    csr: "Costa Rican Sign Language",
    css: "Southern Ohlone",
    cst: "Northern Ohlone",
    csv: "Sumtu Chin",
    csw: "Swampy Cree",
    csy: "Siyin Chin",
    csz: "Coos",
    cta: "Tataltepec Chatino",
    ctc: "Chetco",
    ctd: "Tedim Chin",
    cte: "Tepinapa Chinantec",
    ctg: "Chittagonian",
    cth: "Thaiphum Chin",
    ctl: "Tlacoatzintepec Chinantec",
    ctm: "Chitimacha",
    ctn: "Chhintange",
    cto: "Ember\xE1-Cat\xEDo",
    ctp: "Western Highland Chatino",
    cts: "Northern Catanduanes Bikol",
    ctt: "Wayanad Chetti",
    ctu: "Chol",
    ctz: "Zacatepec Chatino",
    cua: "Cua",
    cub: "Cubeo",
    cuc: "Usila Chinantec",
    cug: "Chungmboko",
    cuh: "Chuka",
    cui: "Cuiba",
    cuj: "Mashco Piro",
    cuk: "San Blas Kuna",
    cul: "Culina",
    cuo: "Cumanagoto",
    cup: "Cupe\xF1o",
    cuq: "Cun",
    cur: "Chhulung",
    cut: "Teutila Cuicatec",
    cuu: "Tai Ya",
    cuv: "Cuvok",
    cuw: "Chukwa",
    cux: "Tepeuxila Cuicatec",
    cvg: "Chug",
    cvn: "Valle Nacional Chinantec",
    cwa: "Kabwa",
    cwb: "Maindo",
    cwd: "Woods Cree",
    cwe: "Kwere",
    cwg: "Chewong",
    cwt: "Kuwaataay",
    cya: "Nopala Chatino",
    cyb: "Cayubaba",
    cym: "Welsh",
    cyo: "Cuyonon",
    czh: "Huizhou Chinese",
    czk: "Knaanic",
    czn: "Zenzontepec Chatino",
    czo: "Min Zhong Chinese",
    czt: "Zotung Chin",
    daa: "Dangal\xE9at",
    dac: "Dambi",
    dad: "Marik",
    dae: "Duupa",
    dag: "Dagbani",
    dah: "Gwahatike",
    dai: "Day",
    daj: "Dar Fur Daju",
    dak: "Dakota",
    dal: "Dahalo",
    dam: "Damakawa",
    dan: "Danish",
    dao: "Daai Chin",
    daq: "Dandami Maria",
    dar: "Dargwa",
    das: "Daho-Doo",
    dau: "Dar Sila Daju",
    dav: "Taita",
    daw: "Davawenyo",
    dax: "Dayi",
    daz: "Dao",
    dba: "Bangime",
    dbb: "Deno",
    dbd: "Dadiya",
    dbe: "Dabe",
    dbf: "Edopi",
    dbg: "Dogul Dom Dogon",
    dbi: "Doka",
    dbj: "Ida'an",
    dbl: "Dyirbal",
    dbm: "Duguri",
    dbn: "Duriankere",
    dbo: "Dulbu",
    dbp: "Duwai",
    dbq: "Daba",
    dbr: "Dabarre",
    dbt: "Ben Tey Dogon",
    dbu: "Bondum Dom Dogon",
    dbv: "Dungu",
    dbw: "Bankan Tey Dogon",
    dby: "Dibiyaso",
    dcc: "Deccan",
    dcr: "Negerhollands",
    dda: "Dadi Dadi",
    ddd: "Dongotono",
    dde: "Doondo",
    ddg: "Fataluku",
    ddi: "West Goodenough",
    ddj: "Jaru",
    ddn: "Dendi (Benin)",
    ddo: "Dido",
    ddr: "Dhudhuroa",
    dds: "Donno So Dogon",
    ddw: "Dawera-Daweloor",
    dec: "Dagik",
    ded: "Dedua",
    dee: "Dewoin",
    def: "Dezfuli",
    deg: "Degema",
    deh: "Dehwari",
    dei: "Demisa",
    dek: "Dek",
    del: "Delaware",
    dem: "Dem",
    den: "Slave (Athapascan)",
    dep: "Pidgin Delaware",
    deq: "Dendi (Central African Republic)",
    der: "Deori",
    des: "Desano",
    deu: "German",
    dev: "Domung",
    dez: "Dengese",
    dga: "Southern Dagaare",
    dgb: "Bunoge Dogon",
    dgc: "Casiguran Dumagat Agta",
    dgd: "Dagaari Dioula",
    dge: "Degenan",
    dgg: "Doga",
    dgh: "Dghwede",
    dgi: "Northern Dagara",
    dgk: "Dagba",
    dgl: "Andaandi",
    dgn: "Dagoman",
    dgo: "Dogri (individual language)",
    dgr: "Dogrib",
    dgs: "Dogoso",
    dgt: "Ndra'ngith",
    dgu: "Degaru",
    dgw: "Daungwurrung",
    dgx: "Doghoro",
    dgz: "Daga",
    dhd: "Dhundari",
    dhg: "Dhangu-Djangu",
    dhi: "Dhimal",
    dhl: "Dhalandji",
    dhm: "Zemba",
    dhn: "Dhanki",
    dho: "Dhodia",
    dhr: "Dhargari",
    dhs: "Dhaiso",
    dhu: "Dhurga",
    dhv: "Dehu",
    dhw: "Dhanwar (Nepal)",
    dhx: "Dhungaloo",
    dia: "Dia",
    dib: "South Central Dinka",
    dic: "Lakota Dida",
    did: "Didinga",
    dif: "Dieri",
    dig: "Digo",
    dih: "Kumiai",
    dii: "Dimbong",
    dij: "Dai",
    dik: "Southwestern Dinka",
    dil: "Dilling",
    dim: "Dime",
    din: "Dinka",
    dio: "Dibo",
    dip: "Northeastern Dinka",
    diq: "Dimli (individual language)",
    dir: "Dirim",
    dis: "Dimasa",
    dit: "Dirari",
    diu: "Diriku",
    div: "Dhivehi",
    diw: "Northwestern Dinka",
    dix: "Dixon Reef",
    diy: "Diuwe",
    diz: "Ding",
    dja: "Djadjawurrung",
    djb: "Djinba",
    djc: "Dar Daju Daju",
    djd: "Djamindjung",
    dje: "Zarma",
    djf: "Djangun",
    dji: "Djinang",
    djj: "Djeebbana",
    djk: "Eastern Maroon Creole",
    djm: "Jamsay Dogon",
    djn: "Djauan",
    djo: "Jangkang",
    djr: "Djambarrpuyngu",
    dju: "Kapriman",
    djw: "Djawi",
    dka: "Dakpakha",
    dkk: "Dakka",
    dkr: "Kuijau",
    dks: "Southeastern Dinka",
    dkx: "Mazagway",
    dlg: "Dolgan",
    dlk: "Dahalik",
    dlm: "Dalmatian",
    dln: "Darlong",
    dma: "Duma",
    dmb: "Mombo Dogon",
    dmc: "Gavak",
    dmd: "Madhi Madhi",
    dme: "Dugwor",
    dmg: "Upper Kinabatangan",
    dmk: "Domaaki",
    dml: "Dameli",
    dmm: "Dama",
    dmo: "Kemedzung",
    dmr: "East Damar",
    dms: "Dampelas",
    dmu: "Dubu",
    dmv: "Dumpas",
    dmw: "Mudburra",
    dmx: "Dema",
    dmy: "Demta",
    dna: "Upper Grand Valley Dani",
    dnd: "Daonda",
    dne: "Ndendeule",
    dng: "Dungan",
    dni: "Lower Grand Valley Dani",
    dnj: "Dan",
    dnk: "Dengka",
    dnn: "Dz\xF9\xF9ngoo",
    dnr: "Danaru",
    dnt: "Mid Grand Valley Dani",
    dnu: "Danau",
    dnv: "Danu",
    dnw: "Western Dani",
    dny: "Den\xED",
    doa: "Dom",
    dob: "Dobu",
    doc: "Northern Dong",
    doe: "Doe",
    dof: "Domu",
    doh: "Dong",
    doi: "Dogri (macrolanguage)",
    dok: "Dondo",
    dol: "Doso",
    don: "Toura (Papua New Guinea)",
    doo: "Dongo",
    dop: "Lukpa",
    doq: "Dominican Sign Language",
    dor: "Dori'o",
    dos: "Dogos\xE9",
    dot: "Dass",
    dov: "Dombe",
    dow: "Doyayo",
    dox: "Bussa",
    doy: "Dompo",
    doz: "Dorze",
    dpp: "Papar",
    drb: "Dair",
    drc: "Minderico",
    drd: "Darmiya",
    dre: "Dolpo",
    drg: "Rungus",
    dri: "C'Lela",
    drl: "Paakantyi",
    drn: "West Damar",
    dro: "Daro-Matu Melanau",
    drq: "Dura",
    drr: "Dororo",
    drs: "Gedeo",
    drt: "Drents",
    dru: "Rukai",
    dry: "Darai",
    dsb: "Lower Sorbian",
    dse: "Dutch Sign Language",
    dsh: "Daasanach",
    dsi: "Disa",
    dsl: "Danish Sign Language",
    dsn: "Dusner",
    dso: "Desiya",
    dsq: "Tadaksahak",
    dta: "Daur",
    dtb: "Labuk-Kinabatangan Kadazan",
    dtd: "Ditidaht",
    dth: "Adithinngithigh",
    dti: "Ana Tinga Dogon",
    dtk: "Tene Kan Dogon",
    dtm: "Tomo Kan Dogon",
    dtn: "Daats\u02BCi\u0301in",
    dto: "Tommo So Dogon",
    dtp: "Kadazan Dusun",
    dtr: "Lotud",
    dts: "Toro So Dogon",
    dtt: "Toro Tegu Dogon",
    dtu: "Tebul Ure Dogon",
    dty: "Dotyali",
    dua: "Duala",
    dub: "Dubli",
    duc: "Duna",
    dud: "Hun-Saare",
    due: "Umiray Dumaget Agta",
    duf: "Dumbea",
    dug: "Duruma",
    duh: "Dungra Bhil",
    dui: "Dumun",
    duk: "Uyajitaya",
    dul: "Alabat Island Agta",
    dum: "Middle Dutch (ca. 1050-1350)",
    dun: "Dusun Deyah",
    duo: "Dupaninan Agta",
    dup: "Duano",
    duq: "Dusun Malang",
    dur: "Dii",
    dus: "Dumi",
    duu: "Drung",
    duv: "Duvle",
    duw: "Dusun Witu",
    dux: "Duungooma",
    duy: "Dicamay Agta",
    duz: "Duli-Gey",
    dva: "Duau",
    dwa: "Diri",
    dwr: "Dawro",
    dws: "Dutton World Speedwords",
    dwu: "Dhuwal",
    dww: "Dawawa",
    dwy: "Dhuwaya",
    dya: "Dyan",
    dyb: "Dyaberdyaber",
    dyd: "Dyugun",
    dyg: "Villa Viciosa Agta",
    dyi: "Djimini Senoufo",
    dym: "Yanda Dom Dogon",
    dyn: "Dyangadi",
    dyo: "Jola-Fonyi",
    dyu: "Dyula",
    dyy: "Dyaabugay",
    dza: "Tunzu",
    dze: "Djiwarli",
    dzg: "Dazaga",
    dzl: "Dzalakha",
    dzn: "Dzando",
    dzo: "Dzongkha",
    eaa: "Karenggapa",
    ebg: "Ebughu",
    ebk: "Eastern Bontok",
    ebo: "Teke-Ebo",
    ebr: "Ebri\xE9",
    ebu: "Embu",
    ecr: "Eteocretan",
    ecs: "Ecuadorian Sign Language",
    ecy: "Eteocypriot",
    eee: "E",
    efa: "Efai",
    efe: "Efe",
    efi: "Efik",
    ega: "Ega",
    egl: "Emilian",
    ego: "Eggon",
    egy: "Egyptian (Ancient)",
    ehu: "Ehueun",
    eip: "Eipomek",
    eit: "Eitiep",
    eiv: "Askopan",
    eja: "Ejamat",
    eka: "Ekajuk",
    ekc: "Eastern Karnic",
    eke: "Ekit",
    ekg: "Ekari",
    eki: "Eki",
    ekk: "Standard Estonian",
    ekl: "Kol (Bangladesh)",
    ekm: "Elip",
    eko: "Koti",
    ekp: "Ekpeye",
    ekr: "Yace",
    eky: "Eastern Kayah",
    ele: "Elepi",
    elh: "El Hugeirat",
    eli: "Nding",
    elk: "Elkei",
    ell: "Modern Greek (1453-)",
    elm: "Eleme",
    elo: "El Molo",
    elu: "Elu",
    elx: "Elamite",
    ema: "Emai-Iuleha-Ora",
    emb: "Embaloh",
    eme: "Emerillon",
    emg: "Eastern Meohang",
    emi: "Mussau-Emira",
    emk: "Eastern Maninkakan",
    emm: "Mamulique",
    emn: "Eman",
    emp: "Northern Ember\xE1",
    ems: "Pacific Gulf Yupik",
    emu: "Eastern Muria",
    emw: "Emplawas",
    emx: "Erromintxela",
    emy: "Epigraphic Mayan",
    ena: "Apali",
    enb: "Markweeta",
    enc: "En",
    end: "Ende",
    enf: "Forest Enets",
    eng: "English",
    enh: "Tundra Enets",
    enl: "Enlhet",
    enm: "Middle English (1100-1500)",
    enn: "Engenni",
    eno: "Enggano",
    enq: "Enga",
    enr: "Emumu",
    enu: "Enu",
    env: "Enwan (Edu State)",
    enw: "Enwan (Akwa Ibom State)",
    enx: "Enxet",
    eot: "Beti (C\xF4te d'Ivoire)",
    epi: "Epie",
    epo: "Esperanto",
    era: "Eravallan",
    erg: "Sie",
    erh: "Eruwa",
    eri: "Ogea",
    erk: "South Efate",
    ero: "Horpa",
    err: "Erre",
    ers: "Ersu",
    ert: "Eritai",
    erw: "Erokwanas",
    ese: "Ese Ejja",
    esg: "Aheri Gondi",
    esh: "Eshtehardi",
    esi: "North Alaskan Inupiatun",
    esk: "Northwest Alaska Inupiatun",
    esl: "Egypt Sign Language",
    esm: "Esuma",
    esn: "Salvadoran Sign Language",
    eso: "Estonian Sign Language",
    esq: "Esselen",
    ess: "Central Siberian Yupik",
    est: "Estonian",
    esu: "Central Yupik",
    esy: "Eskayan",
    etb: "Etebi",
    etc: "Etchemin",
    eth: "Ethiopian Sign Language",
    etn: "Eton (Vanuatu)",
    eto: "Eton (Cameroon)",
    etr: "Edolo",
    ets: "Yekhee",
    ett: "Etruscan",
    etu: "Ejagham",
    etx: "Eten",
    etz: "Semimi",
    eus: "Basque",
    eve: "Even",
    evh: "Uvbie",
    evn: "Evenki",
    ewe: "Ewe",
    ewo: "Ewondo",
    ext: "Extremaduran",
    eya: "Eyak",
    eyo: "Keiyo",
    eza: "Ezaa",
    eze: "Uzekwe",
    faa: "Fasu",
    fab: "Fa d'Ambu",
    fad: "Wagi",
    faf: "Fagani",
    fag: "Finongan",
    fah: "Baissa Fali",
    fai: "Faiwol",
    faj: "Faita",
    fak: "Fang (Cameroon)",
    fal: "South Fali",
    fam: "Fam",
    fan: "Fang (Equatorial Guinea)",
    fao: "Faroese",
    fap: "Palor",
    far: "Fataleka",
    fas: "Persian",
    fat: "Fanti",
    fau: "Fayu",
    fax: "Fala",
    fay: "Southwestern Fars",
    faz: "Northwestern Fars",
    fbl: "West Albay Bikol",
    fcs: "Quebec Sign Language",
    fer: "Feroge",
    ffi: "Foia Foia",
    ffm: "Maasina Fulfulde",
    fgr: "Fongoro",
    fia: "Nobiin",
    fie: "Fyer",
    fij: "Fijian",
    fil: "Filipino",
    fin: "Finnish",
    fip: "Fipa",
    fir: "Firan",
    fit: "Tornedalen Finnish",
    fiw: "Fiwaga",
    fkk: "Kirya-Konz\u0259l",
    fkv: "Kven Finnish",
    fla: "Kalispel-Pend d'Oreille",
    flh: "Foau",
    fli: "Fali",
    fll: "North Fali",
    fln: "Flinders Island",
    flr: "Fuliiru",
    fly: "Flaaitaal",
    fmp: "Fe'fe'",
    fmu: "Far Western Muria",
    fnb: "Fanbak",
    fng: "Fanagalo",
    fni: "Fania",
    fod: "Foodo",
    foi: "Foi",
    fom: "Foma",
    fon: "Fon",
    for: "Fore",
    fos: "Siraya",
    fpe: "Fernando Po Creole English",
    fqs: "Fas",
    fra: "French",
    frc: "Cajun French",
    frd: "Fordata",
    frk: "Frankish",
    frm: "Middle French (ca. 1400-1600)",
    fro: "Old French (842-ca. 1400)",
    frp: "Arpitan",
    frq: "Forak",
    frr: "Northern Frisian",
    frs: "Eastern Frisian",
    frt: "Fortsenal",
    fry: "Western Frisian",
    fse: "Finnish Sign Language",
    fsl: "French Sign Language",
    fss: "Finland-Swedish Sign Language",
    fub: "Adamawa Fulfulde",
    fuc: "Pulaar",
    fud: "East Futuna",
    fue: "Borgu Fulfulde",
    fuf: "Pular",
    fuh: "Western Niger Fulfulde",
    fui: "Bagirmi Fulfulde",
    fuj: "Ko",
    ful: "Fulah",
    fum: "Fum",
    fun: "Fulni\xF4",
    fuq: "Central-Eastern Niger Fulfulde",
    fur: "Friulian",
    fut: "Futuna-Aniwa",
    fuu: "Furu",
    fuv: "Nigerian Fulfulde",
    fuy: "Fuyug",
    fvr: "Fur",
    fwa: "Fw\xE2i",
    fwe: "Fwe",
    gaa: "Ga",
    gab: "Gabri",
    gac: "Mixed Great Andamanese",
    gad: "Gaddang",
    gae: "Guarequena",
    gaf: "Gende",
    gag: "Gagauz",
    gah: "Alekano",
    gai: "Borei",
    gaj: "Gadsup",
    gak: "Gamkonora",
    gal: "Galolen",
    gam: "Kandawo",
    gan: "Gan Chinese",
    gao: "Gants",
    gap: "Gal",
    gaq: "Gata'",
    gar: "Galeya",
    gas: "Adiwasi Garasia",
    gat: "Kenati",
    gau: "Mudhili Gadaba",
    gaw: "Nobonob",
    gax: "Borana-Arsi-Guji Oromo",
    gay: "Gayo",
    gaz: "West Central Oromo",
    gba: "Gbaya (Central African Republic)",
    gbb: "Kaytetye",
    gbd: "Karadjeri",
    gbe: "Niksek",
    gbf: "Gaikundi",
    gbg: "Gbanziri",
    gbh: "Defi Gbe",
    gbi: "Galela",
    gbj: "Bodo Gadaba",
    gbk: "Gaddi",
    gbl: "Gamit",
    gbm: "Garhwali",
    gbn: "Mo'da",
    gbo: "Northern Grebo",
    gbp: "Gbaya-Bossangoa",
    gbq: "Gbaya-Bozoum",
    gbr: "Gbagyi",
    gbs: "Gbesi Gbe",
    gbu: "Gagadu",
    gbv: "Gbanu",
    gbw: "Gabi-Gabi",
    gbx: "Eastern Xwla Gbe",
    gby: "Gbari",
    gbz: "Zoroastrian Dari",
    gcc: "Mali",
    gcd: "Ganggalida",
    gce: "Galice",
    gcf: "Guadeloupean Creole French",
    gcl: "Grenadian Creole English",
    gcn: "Gaina",
    gcr: "Guianese Creole French",
    gct: "Colonia Tovar German",
    gda: "Gade Lohar",
    gdb: "Pottangi Ollar Gadaba",
    gdc: "Gugu Badhun",
    gdd: "Gedaged",
    gde: "Gude",
    gdf: "Guduf-Gava",
    gdg: "Ga'dang",
    gdh: "Gadjerawang",
    gdi: "Gundi",
    gdj: "Gurdjar",
    gdk: "Gadang",
    gdl: "Dirasha",
    gdm: "Laal",
    gdn: "Umanakaina",
    gdo: "Ghodoberi",
    gdq: "Mehri",
    gdr: "Wipi",
    gds: "Ghandruk Sign Language",
    gdt: "Kungardutyi",
    gdu: "Gudu",
    gdx: "Godwari",
    gea: "Geruma",
    geb: "Kire",
    gec: "Gboloo Grebo",
    ged: "Gade",
    geg: "Gengle",
    geh: "Hutterite German",
    gei: "Gebe",
    gej: "Gen",
    gek: "Ywom",
    gel: "ut-Ma'in",
    geq: "Geme",
    ges: "Geser-Gorom",
    gev: "Eviya",
    gew: "Gera",
    gex: "Garre",
    gey: "Enya",
    gez: "Geez",
    gfk: "Patpatar",
    gft: "Gafat",
    gga: "Gao",
    ggb: "Gbii",
    ggd: "Gugadj",
    gge: "Guragone",
    ggg: "Gurgula",
    ggk: "Kungarakany",
    ggl: "Ganglau",
    ggt: "Gitua",
    ggu: "Gagu",
    ggw: "Gogodala",
    gha: "Ghadam\xE8s",
    ghc: "Hiberno-Scottish Gaelic",
    ghe: "Southern Ghale",
    ghh: "Northern Ghale",
    ghk: "Geko Karen",
    ghl: "Ghulfan",
    ghn: "Ghanongga",
    gho: "Ghomara",
    ghr: "Ghera",
    ghs: "Guhu-Samane",
    ght: "Kuke",
    gia: "Kitja",
    gib: "Gibanawa",
    gic: "Gail",
    gid: "Gidar",
    gie: "Ga\u0253ogbo",
    gig: "Goaria",
    gih: "Githabul",
    gil: "Gilbertese",
    gim: "Gimi (Eastern Highlands)",
    gin: "Hinukh",
    gip: "Gimi (West New Britain)",
    giq: "Green Gelao",
    gir: "Red Gelao",
    gis: "North Giziga",
    git: "Gitxsan",
    giu: "Mulao",
    giw: "White Gelao",
    gix: "Gilima",
    giy: "Giyug",
    giz: "South Giziga",
    gji: "Geji",
    gjk: "Kachi Koli",
    gjm: "Gunditjmara",
    gjn: "Gonja",
    gjr: "Gurindji Kriol",
    gju: "Gujari",
    gka: "Guya",
    gke: "Ndai",
    gkn: "Gokana",
    gko: "Kok-Nar",
    gkp: "Guinea Kpelle",
    gku: "\u01C2Ungkue",
    gla: "Scottish Gaelic",
    glc: "Bon Gula",
    gld: "Nanai",
    gle: "Irish",
    glg: "Galician",
    glh: "Northwest Pashai",
    gli: "Guliguli",
    glj: "Gula Iro",
    glk: "Gilaki",
    gll: "Garlali",
    glo: "Galambu",
    glr: "Glaro-Twabo",
    glu: "Gula (Chad)",
    glv: "Manx",
    glw: "Glavda",
    gly: "Gule",
    gma: "Gambera",
    gmb: "Gula'alaa",
    gmd: "M\xE1ghd\xEC",
    gmg: "Mag\u0268yi",
    gmh: "Middle High German (ca. 1050-1500)",
    gml: "Middle Low German",
    gmm: "Gbaya-Mbodomo",
    gmn: "Gimnime",
    gmu: "Gumalu",
    gmv: "Gamo",
    gmx: "Magoma",
    gmy: "Mycenaean Greek",
    gmz: "Mgbolizhia",
    gna: "Kaansa",
    gnb: "Gangte",
    gnc: "Guanche",
    gnd: "Zulgo-Gemzek",
    gne: "Ganang",
    gng: "Ngangam",
    gnh: "Lere",
    gni: "Gooniyandi",
    gnk: "//Gana",
    gnl: "Gangulu",
    gnm: "Ginuman",
    gnn: "Gumatj",
    gno: "Northern Gondi",
    gnq: "Gana",
    gnr: "Gureng Gureng",
    gnt: "Guntai",
    gnu: "Gnau",
    gnw: "Western Bolivian Guaran\xED",
    gnz: "Ganzi",
    goa: "Guro",
    gob: "Playero",
    goc: "Gorakor",
    god: "Godi\xE9",
    goe: "Gongduk",
    gof: "Gofa",
    gog: "Gogo",
    goh: "Old High German (ca. 750-1050)",
    goi: "Gobasi",
    goj: "Gowlan",
    gok: "Gowli",
    gol: "Gola",
    gom: "Goan Konkani",
    gon: "Gondi",
    goo: "Gone Dau",
    gop: "Yeretuar",
    goq: "Gorap",
    gor: "Gorontalo",
    gos: "Gronings",
    got: "Gothic",
    gou: "Gavar",
    gow: "Gorowa",
    gox: "Gobu",
    goy: "Goundo",
    goz: "Gozarkhani",
    gpa: "Gupa-Abawa",
    gpe: "Ghanaian Pidgin English",
    gpn: "Taiap",
    gqa: "Ga'anda",
    gqi: "Guiqiong",
    gqn: "Guana (Brazil)",
    gqr: "Gor",
    gqu: "Qau",
    gra: "Rajput Garasia",
    grb: "Grebo",
    grc: "Ancient Greek (to 1453)",
    grd: "Guruntum-Mbaaru",
    grg: "Madi",
    grh: "Gbiri-Niragu",
    gri: "Ghari",
    grj: "Southern Grebo",
    grm: "Kota Marudu Talantang",
    grn: "Guarani",
    gro: "Groma",
    grq: "Gorovu",
    grr: "Taznatit",
    grs: "Gresi",
    grt: "Garo",
    gru: "Kistane",
    grv: "Central Grebo",
    grw: "Gweda",
    grx: "Guriaso",
    gry: "Barclayville Grebo",
    grz: "Guramalum",
    gse: "Ghanaian Sign Language",
    gsg: "German Sign Language",
    gsl: "Gusilay",
    gsm: "Guatemalan Sign Language",
    gsn: "Nema",
    gso: "Southwest Gbaya",
    gsp: "Wasembo",
    gss: "Greek Sign Language",
    gsw: "Swiss German",
    gta: "Guat\xF3",
    gtu: "Aghu-Tharnggala",
    gua: "Shiki",
    gub: "Guajaj\xE1ra",
    guc: "Wayuu",
    gud: "Yocobou\xE9 Dida",
    gue: "Gurinji",
    guf: "Gupapuyngu",
    gug: "Paraguayan Guaran\xED",
    guh: "Guahibo",
    gui: "Eastern Bolivian Guaran\xED",
    guj: "Gujarati",
    guk: "Gumuz",
    gul: "Sea Island Creole English",
    gum: "Guambiano",
    gun: "Mby\xE1 Guaran\xED",
    guo: "Guayabero",
    gup: "Gunwinggu",
    guq: "Ach\xE9",
    gur: "Farefare",
    gus: "Guinean Sign Language",
    gut: "Mal\xE9ku Ja\xEDka",
    guu: "Yanomam\xF6",
    guw: "Gun",
    gux: "Gourmanch\xE9ma",
    guz: "Gusii",
    gva: "Guana (Paraguay)",
    gvc: "Guanano",
    gve: "Duwet",
    gvf: "Golin",
    gvj: "Guaj\xE1",
    gvl: "Gulay",
    gvm: "Gurmana",
    gvn: "Kuku-Yalanji",
    gvo: "Gavi\xE3o Do Jiparan\xE1",
    gvp: "Par\xE1 Gavi\xE3o",
    gvr: "Gurung",
    gvs: "Gumawana",
    gvy: "Guyani",
    gwa: "Mbato",
    gwb: "Gwa",
    gwc: "Kalami",
    gwd: "Gawwada",
    gwe: "Gweno",
    gwf: "Gowro",
    gwg: "Moo",
    gwi: "Gwich\u02BCin",
    gwj: "/Gwi",
    gwm: "Awngthim",
    gwn: "Gwandara",
    gwr: "Gwere",
    gwt: "Gawar-Bati",
    gwu: "Guwamu",
    gww: "Kwini",
    gwx: "Gua",
    gxx: "W\xE8 Southern",
    gya: "Northwest Gbaya",
    gyb: "Garus",
    gyd: "Kayardild",
    gye: "Gyem",
    gyf: "Gungabula",
    gyg: "Gbayi",
    gyi: "Gyele",
    gyl: "Gayil",
    gym: "Ng\xE4bere",
    gyn: "Guyanese Creole English",
    gyr: "Guarayu",
    gyy: "Gunya",
    gza: "Ganza",
    gzi: "Gazi",
    gzn: "Gane",
    haa: "Han",
    hab: "Hanoi Sign Language",
    hac: "Gurani",
    had: "Hatam",
    hae: "Eastern Oromo",
    haf: "Haiphong Sign Language",
    hag: "Hanga",
    hah: "Hahon",
    hai: "Haida",
    haj: "Hajong",
    hak: "Hakka Chinese",
    hal: "Halang",
    ham: "Hewa",
    han: "Hangaza",
    hao: "Hak\xF6",
    hap: "Hupla",
    haq: "Ha",
    har: "Harari",
    has: "Haisla",
    hat: "Haitian",
    hau: "Hausa",
    hav: "Havu",
    haw: "Hawaiian",
    hax: "Southern Haida",
    hay: "Haya",
    haz: "Hazaragi",
    hba: "Hamba",
    hbb: "Huba",
    hbn: "Heiban",
    hbo: "Ancient Hebrew",
    hbs: "Serbo-Croatian",
    hbu: "Habu",
    hca: "Andaman Creole Hindi",
    hch: "Huichol",
    hdn: "Northern Haida",
    hds: "Honduras Sign Language",
    hdy: "Hadiyya",
    hea: "Northern Qiandong Miao",
    heb: "Hebrew",
    hed: "Herd\xE9",
    heg: "Helong",
    heh: "Hehe",
    hei: "Heiltsuk",
    hem: "Hemba",
    her: "Herero",
    hgm: "Hai//om",
    hgw: "Haigwai",
    hhi: "Hoia Hoia",
    hhr: "Kerak",
    hhy: "Hoyahoya",
    hia: "Lamang",
    hib: "Hibito",
    hid: "Hidatsa",
    hif: "Fiji Hindi",
    hig: "Kamwe",
    hih: "Pamosu",
    hii: "Hinduri",
    hij: "Hijuk",
    hik: "Seit-Kaitetu",
    hil: "Hiligaynon",
    hin: "Hindi",
    hio: "Tsoa",
    hir: "Himarim\xE3",
    hit: "Hittite",
    hiw: "Hiw",
    hix: "Hixkary\xE1na",
    hji: "Haji",
    hka: "Kahe",
    hke: "Hunde",
    hkk: "Hunjara-Kaina Ke",
    hks: "Hong Kong Sign Language",
    hla: "Halia",
    hlb: "Halbi",
    hld: "Halang Doan",
    hle: "Hlersu",
    hlt: "Matu Chin",
    hlu: "Hieroglyphic Luwian",
    hma: "Southern Mashan Hmong",
    hmb: "Humburi Senni Songhay",
    hmc: "Central Huishui Hmong",
    hmd: "Large Flowery Miao",
    hme: "Eastern Huishui Hmong",
    hmf: "Hmong Don",
    hmg: "Southwestern Guiyang Hmong",
    hmh: "Southwestern Huishui Hmong",
    hmi: "Northern Huishui Hmong",
    hmj: "Ge",
    hmk: "Maek",
    hml: "Luopohe Hmong",
    hmm: "Central Mashan Hmong",
    hmn: "Hmong",
    hmo: "Hiri Motu",
    hmp: "Northern Mashan Hmong",
    hmq: "Eastern Qiandong Miao",
    hmr: "Hmar",
    hms: "Southern Qiandong Miao",
    hmt: "Hamtai",
    hmu: "Hamap",
    hmv: "Hmong D\xF4",
    hmw: "Western Mashan Hmong",
    hmy: "Southern Guiyang Hmong",
    hmz: "Hmong Shua",
    hna: "Mina (Cameroon)",
    hnd: "Southern Hindko",
    hne: "Chhattisgarhi",
    hnh: "//Ani",
    hni: "Hani",
    hnj: "Hmong Njua",
    hnn: "Hanunoo",
    hno: "Northern Hindko",
    hns: "Caribbean Hindustani",
    hnu: "Hung",
    hoa: "Hoava",
    hob: "Mari (Madang Province)",
    hoc: "Ho",
    hod: "Holma",
    hoe: "Horom",
    hoh: "Hoby\xF3t",
    hoi: "Holikachuk",
    hoj: "Hadothi",
    hol: "Holu",
    hom: "Homa",
    hoo: "Holoholo",
    hop: "Hopi",
    hor: "Horo",
    hos: "Ho Chi Minh City Sign Language",
    hot: "Hote",
    hov: "Hovongan",
    how: "Honi",
    hoy: "Holiya",
    hoz: "Hozo",
    hpo: "Hpon",
    hps: "Hawai'i Sign Language (HSL)",
    hra: "Hrangkhol",
    hrc: "Niwer Mil",
    hre: "Hre",
    hrk: "Haruku",
    hrm: "Horned Miao",
    hro: "Haroi",
    hrp: "Nhirrpi",
    hrt: "H\xE9rtevin",
    hru: "Hruso",
    hrv: "Croatian",
    hrw: "Warwar Feni",
    hrx: "Hunsrik",
    hrz: "Harzani",
    hsb: "Upper Sorbian",
    hsh: "Hungarian Sign Language",
    hsl: "Hausa Sign Language",
    hsn: "Xiang Chinese",
    hss: "Harsusi",
    hti: "Hoti",
    hto: "Minica Huitoto",
    hts: "Hadza",
    htu: "Hitu",
    htx: "Middle Hittite",
    hub: "Huambisa",
    huc: "Err:510",
    hud: "Huaulu",
    hue: "San Francisco Del Mar Huave",
    huf: "Humene",
    hug: "Huachipaeri",
    huh: "Huilliche",
    hui: "Huli",
    huj: "Northern Guiyang Hmong",
    huk: "Hulung",
    hul: "Hula",
    hum: "Hungana",
    hun: "Hungarian",
    huo: "Hu",
    hup: "Hupa",
    huq: "Tsat",
    hur: "Halkomelem",
    hus: "Huastec",
    hut: "Humla",
    huu: "Murui Huitoto",
    huv: "San Mateo Del Mar Huave",
    huw: "Hukumina",
    hux: "N\xFCpode Huitoto",
    huy: "Hulaul\xE1",
    huz: "Hunzib",
    hvc: "Haitian Vodoun Culture Language",
    hve: "San Dionisio Del Mar Huave",
    hvk: "Haveke",
    hvn: "Sabu",
    hvv: "Santa Mar\xEDa Del Mar Huave",
    hwa: "Wan\xE9",
    hwc: "Hawai'i Creole English",
    hwo: "Hwana",
    hya: "Hya",
    hye: "Armenian",
    iai: "Iaai",
    ian: "Iatmul",
    iar: "Purari",
    iba: "Iban",
    ibb: "Ibibio",
    ibd: "Iwaidja",
    ibe: "Akpes",
    ibg: "Ibanag",
    ibh: "Bih",
    ibl: "Ibaloi",
    ibm: "Agoi",
    ibn: "Ibino",
    ibo: "Igbo",
    ibr: "Ibuoro",
    ibu: "Ibu",
    iby: "Ibani",
    ica: "Ede Ica",
    ich: "Etkywan",
    icl: "Icelandic Sign Language",
    icr: "Islander Creole English",
    ida: "Idakho-Isukha-Tiriki",
    idb: "Indo-Portuguese",
    idc: "Idon",
    idd: "Ede Idaca",
    ide: "Idere",
    idi: "Idi",
    ido: "Ido",
    idr: "Indri",
    ids: "Idesa",
    idt: "Idat\xE9",
    idu: "Idoma",
    ifa: "Amganad Ifugao",
    ifb: "Batad Ifugao",
    ife: "If\xE8",
    iff: "Ifo",
    ifk: "Tuwali Ifugao",
    ifm: "Teke-Fuumu",
    ifu: "Mayoyao Ifugao",
    ify: "Keley-I Kallahan",
    igb: "Ebira",
    ige: "Igede",
    igg: "Igana",
    igl: "Igala",
    igm: "Kanggape",
    ign: "Ignaciano",
    igo: "Isebe",
    igs: "Interglossa",
    igw: "Igwe",
    ihb: "Iha Based Pidgin",
    ihi: "Ihievbe",
    ihp: "Iha",
    ihw: "Bidhawal",
    iii: "Sichuan Yi",
    iin: "Thiin",
    ijc: "Izon",
    ije: "Biseni",
    ijj: "Ede Ije",
    ijn: "Kalabari",
    ijs: "Southeast Ijo",
    ike: "Eastern Canadian Inuktitut",
    iki: "Iko",
    ikk: "Ika",
    ikl: "Ikulu",
    iko: "Olulumo-Ikom",
    ikp: "Ikpeshi",
    ikr: "Ikaranggal",
    iks: "Inuit Sign Language",
    ikt: "Inuinnaqtun",
    iku: "Inuktitut",
    ikv: "Iku-Gora-Ankwa",
    ikw: "Ikwere",
    ikx: "Ik",
    ikz: "Ikizu",
    ila: "Ile Ape",
    ilb: "Ila",
    ile: "Interlingue",
    ilg: "Garig-Ilgar",
    ili: "Ili Turki",
    ilk: "Ilongot",
    ilm: "Iranun (Malaysia)",
    ilo: "Iloko",
    ilp: "Iranun (Philippines)",
    ils: "International Sign",
    ilu: "Ili'uun",
    ilv: "Ilue",
    ima: "Mala Malasar",
    imi: "Anamgura",
    iml: "Miluk",
    imn: "Imonda",
    imo: "Imbongu",
    imr: "Imroing",
    ims: "Marsian",
    imy: "Milyan",
    ina: "Interlingua (International Auxiliary Language Association)",
    inb: "Inga",
    ind: "Indonesian",
    ing: "Degexit'an",
    inh: "Ingush",
    inj: "Jungle Inga",
    inl: "Indonesian Sign Language",
    inm: "Minaean",
    inn: "Isinai",
    ino: "Inoke-Yate",
    inp: "I\xF1apari",
    ins: "Indian Sign Language",
    int: "Intha",
    inz: "Inese\xF1o",
    ior: "Inor",
    iou: "Tuma-Irumu",
    iow: "Iowa-Oto",
    ipi: "Ipili",
    ipk: "Inupiaq",
    ipo: "Ipiko",
    iqu: "Iquito",
    iqw: "Ikwo",
    ire: "Iresim",
    irh: "Irarutu",
    iri: "Irigwe",
    irk: "Iraqw",
    irn: "Ir\xE1ntxe",
    irr: "Ir",
    iru: "Irula",
    irx: "Kamberau",
    iry: "Iraya",
    isa: "Isabi",
    isc: "Isconahua",
    isd: "Isnag",
    ise: "Italian Sign Language",
    isg: "Irish Sign Language",
    ish: "Esan",
    isi: "Nkem-Nkum",
    isk: "Ishkashimi",
    isl: "Icelandic",
    ism: "Masimasi",
    isn: "Isanzu",
    iso: "Isoko",
    isr: "Israeli Sign Language",
    ist: "Istriot",
    isu: "Isu (Menchum Division)",
    ita: "Italian",
    itb: "Binongan Itneg",
    itd: "Southern Tidung",
    ite: "Itene",
    iti: "Inlaod Itneg",
    itk: "Judeo-Italian",
    itl: "Itelmen",
    itm: "Itu Mbon Uzo",
    ito: "Itonama",
    itr: "Iteri",
    its: "Isekiri",
    itt: "Maeng Itneg",
    itv: "Itawit",
    itw: "Ito",
    itx: "Itik",
    ity: "Moyadan Itneg",
    itz: "Itz\xE1",
    ium: "Iu Mien",
    ivb: "Ibatan",
    ivv: "Ivatan",
    iwk: "I-Wak",
    iwm: "Iwam",
    iwo: "Iwur",
    iws: "Sepik Iwam",
    ixc: "Ixcatec",
    ixl: "Ixil",
    iya: "Iyayu",
    iyo: "Mesaka",
    iyx: "Yaka (Congo)",
    izh: "Ingrian",
    izr: "Izere",
    izz: "Izii",
    jaa: "Jamamad\xED",
    jab: "Hyam",
    jac: "Popti'",
    jad: "Jahanka",
    jae: "Yabem",
    jaf: "Jara",
    jah: "Jah Hut",
    jaj: "Zazao",
    jak: "Jakun",
    jal: "Yalahatan",
    jam: "Jamaican Creole English",
    jan: "Jandai",
    jao: "Yanyuwa",
    jaq: "Yaqay",
    jas: "New Caledonian Javanese",
    jat: "Jakati",
    jau: "Yaur",
    jav: "Javanese",
    jax: "Jambi Malay",
    jay: "Yan-nhangu",
    jaz: "Jawe",
    jbe: "Judeo-Berber",
    jbi: "Badjiri",
    jbj: "Arandai",
    jbk: "Barikewa",
    jbn: "Nafusi",
    jbo: "Lojban",
    jbr: "Jofotek-Bromnya",
    jbt: "Jabut\xED",
    jbu: "Jukun Takum",
    jbw: "Yawijibaya",
    jcs: "Jamaican Country Sign Language",
    jct: "Krymchak",
    jda: "Jad",
    jdg: "Jadgali",
    jdt: "Judeo-Tat",
    jeb: "Jebero",
    jee: "Jerung",
    jeh: "Jeh",
    jei: "Yei",
    jek: "Jeri Kuo",
    jel: "Yelmek",
    jen: "Dza",
    jer: "Jere",
    jet: "Manem",
    jeu: "Jonkor Bourmataguil",
    jgb: "Ngbee",
    jge: "Judeo-Georgian",
    jgk: "Gwak",
    jgo: "Ngomba",
    jhi: "Jehai",
    jhs: "Jhankot Sign Language",
    jia: "Jina",
    jib: "Jibu",
    jic: "Tol",
    jid: "Bu",
    jie: "Jilbe",
    jig: "Djingili",
    jih: "sTodsde",
    jii: "Jiiddu",
    jil: "Jilim",
    jim: "Jimi (Cameroon)",
    jio: "Jiamao",
    jiq: "Guanyinqiao",
    jit: "Jita",
    jiu: "Youle Jinuo",
    jiv: "Shuar",
    jiy: "Buyuan Jinuo",
    jje: "Jejueo",
    jjr: "Bankal",
    jka: "Kaera",
    jkm: "Mobwa Karen",
    jko: "Kubo",
    jkp: "Paku Karen",
    jkr: "Koro (India)",
    jku: "Labir",
    jle: "Ngile",
    jls: "Jamaican Sign Language",
    jma: "Dima",
    jmb: "Zumbun",
    jmc: "Machame",
    jmd: "Yamdena",
    jmi: "Jimi (Nigeria)",
    jml: "Jumli",
    jmn: "Makuri Naga",
    jmr: "Kamara",
    jms: "Mashi (Nigeria)",
    jmw: "Mouwase",
    jmx: "Western Juxtlahuaca Mixtec",
    jna: "Jangshung",
    jnd: "Jandavra",
    jng: "Yangman",
    jni: "Janji",
    jnj: "Yemsa",
    jnl: "Rawat",
    jns: "Jaunsari",
    job: "Joba",
    jod: "Wojenaka",
    jog: "Jogi",
    jor: "Jor\xE1",
    jos: "Jordanian Sign Language",
    jow: "Jowulu",
    jpa: "Jewish Palestinian Aramaic",
    jpn: "Japanese",
    jpr: "Judeo-Persian",
    jqr: "Jaqaru",
    jra: "Jarai",
    jrb: "Judeo-Arabic",
    jrr: "Jiru",
    jrt: "Jorto",
    jru: "Japrer\xEDa",
    jsl: "Japanese Sign Language",
    jua: "J\xFAma",
    jub: "Wannu",
    juc: "Jurchen",
    jud: "Worodougou",
    juh: "H\xF5ne",
    jui: "Ngadjuri",
    juk: "Wapan",
    jul: "Jirel",
    jum: "Jumjum",
    jun: "Juang",
    juo: "Jiba",
    jup: "Hupd\xEB",
    jur: "Jur\xFAna",
    jus: "Jumla Sign Language",
    jut: "Jutish",
    juu: "Ju",
    juw: "W\xE3pha",
    juy: "Juray",
    jvd: "Javindo",
    jvn: "Caribbean Javanese",
    jwi: "Jwira-Pepesa",
    jya: "Jiarong",
    jye: "Judeo-Yemeni Arabic",
    jyy: "Jaya",
    kaa: "Kara-Kalpak",
    kab: "Kabyle",
    kac: "Kachin",
    kad: "Adara",
    kae: "Ketangalan",
    kaf: "Katso",
    kag: "Kajaman",
    kah: "Kara (Central African Republic)",
    kai: "Karekare",
    kaj: "Jju",
    kak: "Kalanguya",
    kal: "Kalaallisut",
    kam: "Kamba (Kenya)",
    kan: "Kannada",
    kao: "Xaasongaxango",
    kap: "Bezhta",
    kaq: "Capanahua",
    kas: "Kashmiri",
    kat: "Georgian",
    kau: "Kanuri",
    kav: "Katuk\xEDna",
    kaw: "Kawi",
    kax: "Kao",
    kay: "Kamayur\xE1",
    kaz: "Kazakh",
    kba: "Kalarko",
    kbb: "Kaxui\xE2na",
    kbc: "Kadiw\xE9u",
    kbd: "Kabardian",
    kbe: "Kanju",
    kbg: "Khamba",
    kbh: "Cams\xE1",
    kbi: "Kaptiau",
    kbj: "Kari",
    kbk: "Grass Koiari",
    kbl: "Kanembu",
    kbm: "Iwal",
    kbn: "Kare (Central African Republic)",
    kbo: "Keliko",
    kbp: "Kabiy\xE8",
    kbq: "Kamano",
    kbr: "Kafa",
    kbs: "Kande",
    kbt: "Abadi",
    kbu: "Kabutra",
    kbv: "Dera (Indonesia)",
    kbw: "Kaiep",
    kbx: "Ap Ma",
    kby: "Manga Kanuri",
    kbz: "Duhwa",
    kca: "Khanty",
    kcb: "Kawacha",
    kcc: "Lubila",
    kcd: "Ngk\xE2lmpw Kanum",
    kce: "Kaivi",
    kcf: "Ukaan",
    kcg: "Tyap",
    kch: "Vono",
    kci: "Kamantan",
    kcj: "Kobiana",
    kck: "Kalanga",
    kcl: "Kela (Papua New Guinea)",
    kcm: "Gula (Central African Republic)",
    kcn: "Nubi",
    kco: "Kinalakna",
    kcp: "Kanga",
    kcq: "Kamo",
    kcr: "Katla",
    kcs: "Koenoem",
    kct: "Kaian",
    kcu: "Kami (Tanzania)",
    kcv: "Kete",
    kcw: "Kabwari",
    kcx: "Kachama-Ganjule",
    kcy: "Korandje",
    kcz: "Konongo",
    kda: "Worimi",
    kdc: "Kutu",
    kdd: "Yankunytjatjara",
    kde: "Makonde",
    kdf: "Mamusi",
    kdg: "Seba",
    kdh: "Tem",
    kdi: "Kumam",
    kdj: "Karamojong",
    kdk: "Num\xE8\xE8",
    kdl: "Tsikimba",
    kdm: "Kagoma",
    kdn: "Kunda",
    kdp: "Kaningdon-Nindem",
    kdq: "Koch",
    kdr: "Karaim",
    kdt: "Kuy",
    kdu: "Kadaru",
    kdw: "Koneraw",
    kdx: "Kam",
    kdy: "Keder",
    kdz: "Kwaja",
    kea: "Kabuverdianu",
    keb: "K\xE9l\xE9",
    kec: "Keiga",
    ked: "Kerewe",
    kee: "Eastern Keres",
    kef: "Kpessi",
    keg: "Tese",
    keh: "Keak",
    kei: "Kei",
    kej: "Kadar",
    kek: "Kekch\xED",
    kel: "Kela (Democratic Republic of Congo)",
    kem: "Kemak",
    ken: "Kenyang",
    keo: "Kakwa",
    kep: "Kaikadi",
    keq: "Kamar",
    ker: "Kera",
    kes: "Kugbo",
    ket: "Ket",
    keu: "Akebu",
    kev: "Kanikkaran",
    kew: "West Kewa",
    kex: "Kukna",
    key: "Kupia",
    kez: "Kukele",
    kfa: "Kodava",
    kfb: "Northwestern Kolami",
    kfc: "Konda-Dora",
    kfd: "Korra Koraga",
    kfe: "Kota (India)",
    kff: "Koya",
    kfg: "Kudiya",
    kfh: "Kurichiya",
    kfi: "Kannada Kurumba",
    kfj: "Kemiehua",
    kfk: "Kinnauri",
    kfl: "Kung",
    kfm: "Khunsari",
    kfn: "Kuk",
    kfo: "Koro (C\xF4te d'Ivoire)",
    kfp: "Korwa",
    kfq: "Korku",
    kfr: "Kachhi",
    kfs: "Bilaspuri",
    kft: "Kanjari",
    kfu: "Katkari",
    kfv: "Kurmukar",
    kfw: "Kharam Naga",
    kfx: "Kullu Pahari",
    kfy: "Kumaoni",
    kfz: "Koromf\xE9",
    kga: "Koyaga",
    kgb: "Kawe",
    kge: "Komering",
    kgf: "Kube",
    kgg: "Kusunda",
    kgi: "Selangor Sign Language",
    kgj: "Gamale Kham",
    kgk: "Kaiw\xE1",
    kgl: "Kunggari",
    kgm: "Karip\xFAna",
    kgn: "Karingani",
    kgo: "Krongo",
    kgp: "Kaingang",
    kgq: "Kamoro",
    kgr: "Abun",
    kgs: "Kumbainggar",
    kgt: "Somyev",
    kgu: "Kobol",
    kgv: "Karas",
    kgw: "Karon Dori",
    kgx: "Kamaru",
    kgy: "Kyerung",
    kha: "Khasi",
    khb: "L\xFC",
    khc: "Tukang Besi North",
    khd: "B\xE4di Kanum",
    khe: "Korowai",
    khf: "Khuen",
    khg: "Khams Tibetan",
    khh: "Kehu",
    khj: "Kuturmi",
    khk: "Halh Mongolian",
    khl: "Lusi",
    khm: "Central Khmer",
    khn: "Khandesi",
    kho: "Khotanese",
    khp: "Kapori",
    khq: "Koyra Chiini Songhay",
    khr: "Kharia",
    khs: "Kasua",
    kht: "Khamti",
    khu: "Nkhumbi",
    khv: "Khvarshi",
    khw: "Khowar",
    khx: "Kanu",
    khy: "Kele (Democratic Republic of Congo)",
    khz: "Keapara",
    kia: "Kim",
    kib: "Koalib",
    kic: "Kickapoo",
    kid: "Koshin",
    kie: "Kibet",
    kif: "Eastern Parbate Kham",
    kig: "Kimaama",
    kih: "Kilmeri",
    kii: "Kitsai",
    kij: "Kilivila",
    kik: "Kikuyu",
    kil: "Kariya",
    kim: "Karagas",
    kin: "Kinyarwanda",
    kio: "Kiowa",
    kip: "Sheshi Kham",
    kiq: "Kosadle",
    kir: "Kirghiz",
    kis: "Kis",
    kit: "Agob",
    kiu: "Kirmanjki (individual language)",
    kiv: "Kimbu",
    kiw: "Northeast Kiwai",
    kix: "Khiamniungan Naga",
    kiy: "Kirikiri",
    kiz: "Kisi",
    kja: "Mlap",
    kjb: "Q'anjob'al",
    kjc: "Coastal Konjo",
    kjd: "Southern Kiwai",
    kje: "Kisar",
    kjf: "Khalaj",
    kjg: "Khmu",
    kjh: "Khakas",
    kji: "Zabana",
    kjj: "Khinalugh",
    kjk: "Highland Konjo",
    kjl: "Western Parbate Kham",
    kjm: "Kh\xE1ng",
    kjn: "Kunjen",
    kjo: "Harijan Kinnauri",
    kjp: "Pwo Eastern Karen",
    kjq: "Western Keres",
    kjr: "Kurudu",
    kjs: "East Kewa",
    kjt: "Phrae Pwo Karen",
    kju: "Kashaya",
    kjv: "Kaikavian Literary Language",
    kjx: "Ramopa",
    kjy: "Erave",
    kjz: "Bumthangkha",
    kka: "Kakanda",
    kkb: "Kwerisa",
    kkc: "Odoodee",
    kkd: "Kinuku",
    kke: "Kakabe",
    kkf: "Kalaktang Monpa",
    kkg: "Mabaka Valley Kalinga",
    kkh: "Kh\xFCn",
    kki: "Kagulu",
    kkj: "Kako",
    kkk: "Kokota",
    kkl: "Kosarek Yale",
    kkm: "Kiong",
    kkn: "Kon Keu",
    kko: "Karko",
    kkp: "Gugubera",
    kkq: "Kaiku",
    kkr: "Kir-Balar",
    kks: "Giiwo",
    kkt: "Koi",
    kku: "Tumi",
    kkv: "Kangean",
    kkw: "Teke-Kukuya",
    kkx: "Kohin",
    kky: "Guguyimidjir",
    kkz: "Kaska",
    kla: "Klamath-Modoc",
    klb: "Kiliwa",
    klc: "Kolbila",
    kld: "Gamilaraay",
    kle: "Kulung (Nepal)",
    klf: "Kendeje",
    klg: "Tagakaulo",
    klh: "Weliki",
    kli: "Kalumpang",
    klj: "Turkic Khalaj",
    klk: "Kono (Nigeria)",
    kll: "Kagan Kalagan",
    klm: "Migum",
    kln: "Kalenjin",
    klo: "Kapya",
    klp: "Kamasa",
    klq: "Rumu",
    klr: "Khaling",
    kls: "Kalasha",
    klt: "Nukna",
    klu: "Klao",
    klv: "Maskelynes",
    klw: "Tado",
    klx: "Koluwawa",
    kly: "Kalao",
    klz: "Kabola",
    kma: "Konni",
    kmb: "Kimbundu",
    kmc: "Southern Dong",
    kmd: "Majukayang Kalinga",
    kme: "Bakole",
    kmf: "Kare (Papua New Guinea)",
    kmg: "K\xE2te",
    kmh: "Kalam",
    kmi: "Kami (Nigeria)",
    kmj: "Kumarbhag Paharia",
    kmk: "Limos Kalinga",
    kml: "Tanudan Kalinga",
    kmm: "Kom (India)",
    kmn: "Awtuw",
    kmo: "Kwoma",
    kmp: "Gimme",
    kmq: "Kwama",
    kmr: "Northern Kurdish",
    kms: "Kamasau",
    kmt: "Kemtuik",
    kmu: "Kanite",
    kmv: "Karip\xFAna Creole French",
    kmw: "Komo (Democratic Republic of Congo)",
    kmx: "Waboda",
    kmy: "Koma",
    kmz: "Khorasani Turkish",
    kna: "Dera (Nigeria)",
    knb: "Lubuagan Kalinga",
    knc: "Central Kanuri",
    knd: "Konda",
    kne: "Kankanaey",
    knf: "Mankanya",
    kng: "Koongo",
    kni: "Kanufi",
    knj: "Western Kanjobal",
    knk: "Kuranko",
    knl: "Keninjal",
    knm: "Kanamar\xED",
    knn: "Konkani (individual language)",
    kno: "Kono (Sierra Leone)",
    knp: "Kwanja",
    knq: "Kintaq",
    knr: "Kaningra",
    kns: "Kensiu",
    knt: "Panoan Katuk\xEDna",
    knu: "Kono (Guinea)",
    knv: "Tabo",
    knw: "Kung-Ekoka",
    knx: "Kendayan",
    kny: "Kanyok",
    knz: "Kalams\xE9",
    koa: "Konomala",
    koc: "Kpati",
    kod: "Kodi",
    koe: "Kacipo-Balesi",
    kof: "Kubi",
    kog: "Cogui",
    koh: "Koyo",
    koi: "Komi-Permyak",
    kok: "Konkani (macrolanguage)",
    kol: "Kol (Papua New Guinea)",
    kom: "Komi",
    kon: "Kongo",
    koo: "Konzo",
    kop: "Waube",
    koq: "Kota (Gabon)",
    kor: "Korean",
    kos: "Kosraean",
    kot: "Lagwan",
    kou: "Koke",
    kov: "Kudu-Camo",
    kow: "Kugama",
    koy: "Koyukon",
    koz: "Korak",
    kpa: "Kutto",
    kpb: "Mullu Kurumba",
    kpc: "Curripaco",
    kpd: "Koba",
    kpe: "Kpelle",
    kpf: "Komba",
    kpg: "Kapingamarangi",
    kph: "Kplang",
    kpi: "Kofei",
    kpj: "Karaj\xE1",
    kpk: "Kpan",
    kpl: "Kpala",
    kpm: "Koho",
    kpn: "Kepkiriw\xE1t",
    kpo: "Ikposo",
    kpq: "Korupun-Sela",
    kpr: "Korafe-Yegha",
    kps: "Tehit",
    kpt: "Karata",
    kpu: "Kafoa",
    kpv: "Komi-Zyrian",
    kpw: "Kobon",
    kpx: "Mountain Koiali",
    kpy: "Koryak",
    kpz: "Kupsabiny",
    kqa: "Mum",
    kqb: "Kovai",
    kqc: "Doromu-Koki",
    kqd: "Koy Sanjaq Surat",
    kqe: "Kalagan",
    kqf: "Kakabai",
    kqg: "Khe",
    kqh: "Kisankasa",
    kqi: "Koitabu",
    kqj: "Koromira",
    kqk: "Kotafon Gbe",
    kql: "Kyenele",
    kqm: "Khisa",
    kqn: "Kaonde",
    kqo: "Eastern Krahn",
    kqp: "Kimr\xE9",
    kqq: "Krenak",
    kqr: "Kimaragang",
    kqs: "Northern Kissi",
    kqt: "Klias River Kadazan",
    kqu: "Seroa",
    kqv: "Okolod",
    kqw: "Kandas",
    kqx: "Mser",
    kqy: "Koorete",
    kqz: "Korana",
    kra: "Kumhali",
    krb: "Karkin",
    krc: "Karachay-Balkar",
    krd: "Kairui-Midiki",
    kre: "Panar\xE1",
    krf: "Koro (Vanuatu)",
    krh: "Kurama",
    kri: "Krio",
    krj: "Kinaray-A",
    krk: "Kerek",
    krl: "Karelian",
    krn: "Sapo",
    krp: "Korop",
    krr: "Krung",
    krs: "Gbaya (Sudan)",
    krt: "Tumari Kanuri",
    kru: "Kurukh",
    krv: "Kavet",
    krw: "Western Krahn",
    krx: "Karon",
    kry: "Kryts",
    krz: "Sota Kanum",
    ksa: "Shuwa-Zamani",
    ksb: "Shambala",
    ksc: "Southern Kalinga",
    ksd: "Kuanua",
    kse: "Kuni",
    ksf: "Bafia",
    ksg: "Kusaghe",
    ksh: "K\xF6lsch",
    ksi: "Krisa",
    ksj: "Uare",
    ksk: "Kansa",
    ksl: "Kumalu",
    ksm: "Kumba",
    ksn: "Kasiguranin",
    kso: "Kofa",
    ksp: "Kaba",
    ksq: "Kwaami",
    ksr: "Borong",
    kss: "Southern Kisi",
    kst: "Winy\xE9",
    ksu: "Khamyang",
    ksv: "Kusu",
    ksw: "S'gaw Karen",
    ksx: "Kedang",
    ksy: "Kharia Thar",
    ksz: "Kodaku",
    kta: "Katua",
    ktb: "Kambaata",
    ktc: "Kholok",
    ktd: "Kokata",
    kte: "Nubri",
    ktf: "Kwami",
    ktg: "Kalkutung",
    kth: "Karanga",
    kti: "North Muyu",
    ktj: "Plapo Krumen",
    ktk: "Kaniet",
    ktl: "Koroshi",
    ktm: "Kurti",
    ktn: "Kariti\xE2na",
    kto: "Kuot",
    ktp: "Kaduo",
    ktq: "Katabaga",
    kts: "South Muyu",
    ktt: "Ketum",
    ktu: "Kituba (Democratic Republic of Congo)",
    ktv: "Eastern Katu",
    ktw: "Kato",
    ktx: "Kaxarar\xED",
    kty: "Kango (Bas-U\xE9l\xE9 District)",
    ktz: "Ju/'hoan",
    kua: "Kuanyama",
    kub: "Kutep",
    kuc: "Kwinsu",
    kud: "'Auhelawa",
    kue: "Kuman (Papua New Guinea)",
    kuf: "Western Katu",
    kug: "Kupa",
    kuh: "Kushi",
    kui: "Kuik\xFAro-Kalap\xE1lo",
    kuj: "Kuria",
    kuk: "Kepo'",
    kul: "Kulere",
    kum: "Kumyk",
    kun: "Kunama",
    kuo: "Kumukio",
    kup: "Kunimaipa",
    kuq: "Karipuna",
    kur: "Kurdish",
    kus: "Kusaal",
    kut: "Kutenai",
    kuu: "Upper Kuskokwim",
    kuv: "Kur",
    kuw: "Kpagua",
    kux: "Kukatja",
    kuy: "Kuuku-Ya'u",
    kuz: "Kunza",
    kva: "Bagvalal",
    kvb: "Kubu",
    kvc: "Kove",
    kvd: "Kui (Indonesia)",
    kve: "Kalabakan",
    kvf: "Kabalai",
    kvg: "Kuni-Boazi",
    kvh: "Komodo",
    kvi: "Kwang",
    kvj: "Psikye",
    kvk: "Korean Sign Language",
    kvl: "Kayaw",
    kvm: "Kendem",
    kvn: "Border Kuna",
    kvo: "Dobel",
    kvp: "Kompane",
    kvq: "Geba Karen",
    kvr: "Kerinci",
    kvt: "Lahta Karen",
    kvu: "Yinbaw Karen",
    kvv: "Kola",
    kvw: "Wersing",
    kvx: "Parkari Koli",
    kvy: "Yintale Karen",
    kvz: "Tsakwambo",
    kwa: "D\xE2w",
    kwb: "Kwa",
    kwc: "Likwala",
    kwd: "Kwaio",
    kwe: "Kwerba",
    kwf: "Kwara'ae",
    kwg: "Sara Kaba Deme",
    kwh: "Kowiai",
    kwi: "Awa-Cuaiquer",
    kwj: "Kwanga",
    kwk: "Kwakiutl",
    kwl: "Kofyar",
    kwm: "Kwambi",
    kwn: "Kwangali",
    kwo: "Kwomtari",
    kwp: "Kodia",
    kwr: "Kwer",
    kws: "Kwese",
    kwt: "Kwesten",
    kwu: "Kwakum",
    kwv: "Sara Kaba N\xE1\xE0",
    kww: "Kwinti",
    kwx: "Khirwar",
    kwy: "San Salvador Kongo",
    kwz: "Kwadi",
    kxa: "Kairiru",
    kxb: "Krobu",
    kxc: "Konso",
    kxd: "Brunei",
    kxf: "Manumanaw Karen",
    kxh: "Karo (Ethiopia)",
    kxi: "Keningau Murut",
    kxj: "Kulfa",
    kxk: "Zayein Karen",
    kxl: "Nepali Kurux",
    kxm: "Northern Khmer",
    kxn: "Kanowit-Tanjong Melanau",
    kxo: "Kano\xE9",
    kxp: "Wadiyara Koli",
    kxq: "Sm\xE4rky Kanum",
    kxr: "Koro (Papua New Guinea)",
    kxs: "Kangjia",
    kxt: "Koiwat",
    kxu: "Kui (India)",
    kxv: "Kuvi",
    kxw: "Konai",
    kxx: "Likuba",
    kxy: "Kayong",
    kxz: "Kerewo",
    kya: "Kwaya",
    kyb: "Butbut Kalinga",
    kyc: "Kyaka",
    kyd: "Karey",
    kye: "Krache",
    kyf: "Kouya",
    kyg: "Keyagana",
    kyh: "Karok",
    kyi: "Kiput",
    kyj: "Karao",
    kyk: "Kamayo",
    kyl: "Kalapuya",
    kym: "Kpatili",
    kyn: "Northern Binukidnon",
    kyo: "Kelon",
    kyp: "Kang",
    kyq: "Kenga",
    kyr: "Kuru\xE1ya",
    kys: "Baram Kayan",
    kyt: "Kayagar",
    kyu: "Western Kayah",
    kyv: "Kayort",
    kyw: "Kudmali",
    kyx: "Rapoisi",
    kyy: "Kambaira",
    kyz: "Kayab\xED",
    kza: "Western Karaboro",
    kzb: "Kaibobo",
    kzc: "Bondoukou Kulango",
    kzd: "Kadai",
    kze: "Kosena",
    kzf: "Da'a Kaili",
    kzg: "Kikai",
    kzi: "Kelabit",
    kzk: "Kazukuru",
    kzl: "Kayeli",
    kzm: "Kais",
    kzn: "Kokola",
    kzo: "Kaningi",
    kzp: "Kaidipang",
    kzq: "Kaike",
    kzr: "Karang",
    kzs: "Sugut Dusun",
    kzu: "Kayupulau",
    kzv: "Komyandaret",
    kzw: "Karir\xED-Xoc\xF3",
    kzx: "Kamarian",
    kzy: "Kango (Tshopo District)",
    kzz: "Kalabra",
    laa: "Southern Subanen",
    lab: "Linear A",
    lac: "Lacandon",
    lad: "Ladino",
    lae: "Pattani",
    laf: "Lafofa",
    lag: "Langi",
    lah: "Lahnda",
    lai: "Lambya",
    laj: "Lango (Uganda)",
    lak: "Laka (Nigeria)",
    lal: "Lalia",
    lam: "Lamba",
    lan: "Laru",
    lao: "Lao",
    lap: "Laka (Chad)",
    laq: "Qabiao",
    lar: "Larteh",
    las: "Lama (Togo)",
    lat: "Latin",
    lau: "Laba",
    lav: "Latvian",
    law: "Lauje",
    lax: "Tiwa",
    lay: "Lama Bai",
    laz: "Aribwatsa",
    lba: "Lui",
    lbb: "Label",
    lbc: "Lakkia",
    lbe: "Lak",
    lbf: "Tinani",
    lbg: "Laopang",
    lbi: "La'bi",
    lbj: "Ladakhi",
    lbk: "Central Bontok",
    lbl: "Libon Bikol",
    lbm: "Lodhi",
    lbn: "Lamet",
    lbo: "Laven",
    lbq: "Wampar",
    lbr: "Lohorung",
    lbs: "Libyan Sign Language",
    lbt: "Lachi",
    lbu: "Labu",
    lbv: "Lavatbura-Lamusong",
    lbw: "Tolaki",
    lbx: "Lawangan",
    lby: "Lamu-Lamu",
    lbz: "Lardil",
    lcc: "Legenyem",
    lcd: "Lola",
    lce: "Loncong",
    lcf: "Lubu",
    lch: "Luchazi",
    lcl: "Lisela",
    lcm: "Tungag",
    lcp: "Western Lawa",
    lcq: "Luhu",
    lcs: "Lisabata-Nuniali",
    lda: "Kla-Dan",
    ldb: "Du\u0303ya",
    ldd: "Luri",
    ldg: "Lenyima",
    ldh: "Lamja-Dengsa-Tola",
    ldi: "Laari",
    ldj: "Lemoro",
    ldk: "Leelau",
    ldl: "Kaan",
    ldm: "Landoma",
    ldn: "L\xE1adan",
    ldo: "Loo",
    ldp: "Tso",
    ldq: "Lufu",
    lea: "Lega-Shabunda",
    leb: "Lala-Bisa",
    lec: "Leco",
    led: "Lendu",
    lee: "Ly\xE9l\xE9",
    lef: "Lelemi",
    leh: "Lenje",
    lei: "Lemio",
    lej: "Lengola",
    lek: "Leipon",
    lel: "Lele (Democratic Republic of Congo)",
    lem: "Nomaande",
    len: "Lenca",
    leo: "Leti (Cameroon)",
    lep: "Lepcha",
    leq: "Lembena",
    ler: "Lenkau",
    les: "Lese",
    let: "Lesing-Gelimi",
    leu: "Kara (Papua New Guinea)",
    lev: "Lamma",
    lew: "Ledo Kaili",
    lex: "Luang",
    ley: "Lemolang",
    lez: "Lezghian",
    lfa: "Lefa",
    lfn: "Lingua Franca Nova",
    lga: "Lungga",
    lgb: "Laghu",
    lgg: "Lugbara",
    lgh: "Laghuu",
    lgi: "Lengilu",
    lgk: "Lingarak",
    lgl: "Wala",
    lgm: "Lega-Mwenga",
    lgn: "T'apo",
    lgq: "Logba",
    lgr: "Lengo",
    lgt: "Pahi",
    lgu: "Longgu",
    lgz: "Ligenza",
    lha: "Laha (Viet Nam)",
    lhh: "Laha (Indonesia)",
    lhi: "Lahu Shi",
    lhl: "Lahul Lohar",
    lhm: "Lhomi",
    lhn: "Lahanan",
    lhp: "Lhokpu",
    lhs: "Mlahs\xF6",
    lht: "Lo-Toga",
    lhu: "Lahu",
    lia: "West-Central Limba",
    lib: "Likum",
    lic: "Hlai",
    lid: "Nyindrou",
    lie: "Likila",
    lif: "Limbu",
    lig: "Ligbi",
    lih: "Lihir",
    lij: "Ligurian",
    lik: "Lika",
    lil: "Lillooet",
    lim: "Limburgan",
    lin: "Lingala",
    lio: "Liki",
    lip: "Sekpele",
    liq: "Libido",
    lir: "Liberian English",
    lis: "Lisu",
    lit: "Lithuanian",
    liu: "Logorik",
    liv: "Liv",
    liw: "Col",
    lix: "Liabuku",
    liy: "Banda-Bambari",
    liz: "Libinza",
    lja: "Golpa",
    lje: "Rampi",
    lji: "Laiyolo",
    ljl: "Li'o",
    ljp: "Lampung Api",
    ljw: "Yirandali",
    ljx: "Yuru",
    lka: "Lakalei",
    lkb: "Kabras",
    lkc: "Kucong",
    lkd: "Lakond\xEA",
    lke: "Kenyi",
    lkh: "Lakha",
    lki: "Laki",
    lkj: "Remun",
    lkl: "Laeko-Libuat",
    lkm: "Kalaamaya",
    lkn: "Lakon",
    lko: "Khayo",
    lkr: "P\xE4ri",
    lks: "Kisa",
    lkt: "Lakota",
    lku: "Kungkari",
    lky: "Lokoya",
    lla: "Lala-Roba",
    llb: "Lolo",
    llc: "Lele (Guinea)",
    lld: "Ladin",
    lle: "Lele (Papua New Guinea)",
    llf: "Hermit",
    llg: "Lole",
    llh: "Lamu",
    lli: "Teke-Laali",
    llj: "Ladji Ladji",
    llk: "Lelak",
    lll: "Lilau",
    llm: "Lasalimu",
    lln: "Lele (Chad)",
    llo: "Khlor",
    llp: "North Efate",
    llq: "Lolak",
    lls: "Lithuanian Sign Language",
    llu: "Lau",
    llx: "Lauan",
    lma: "East Limba",
    lmb: "Merei",
    lmc: "Limilngan",
    lmd: "Lumun",
    lme: "P\xE9v\xE9",
    lmf: "South Lembata",
    lmg: "Lamogai",
    lmh: "Lambichhong",
    lmi: "Lombi",
    lmj: "West Lembata",
    lmk: "Lamkang",
    lml: "Hano",
    lmn: "Lambadi",
    lmo: "Lombard",
    lmp: "Limbum",
    lmq: "Lamatuka",
    lmr: "Lamalera",
    lmu: "Lamenu",
    lmv: "Lomaiviti",
    lmw: "Lake Miwok",
    lmx: "Laimbue",
    lmy: "Lamboya",
    lmz: "Lumbee",
    lna: "Langbashe",
    lnb: "Mbalanhu",
    lnd: "Lundayeh",
    lng: "Langobardic",
    lnh: "Lanoh",
    lni: "Daantanai'",
    lnj: "Leningitij",
    lnl: "South Central Banda",
    lnm: "Langam",
    lnn: "Lorediakarkar",
    lno: "Lango (Sudan)",
    lns: "Lamnso'",
    lnu: "Longuda",
    lnw: "Lanima",
    lnz: "Lonzo",
    loa: "Loloda",
    lob: "Lobi",
    loc: "Inonhan",
    loe: "Saluan",
    lof: "Logol",
    log: "Logo",
    loh: "Narim",
    loi: "Loma (C\xF4te d'Ivoire)",
    loj: "Lou",
    lok: "Loko",
    lol: "Mongo",
    lom: "Loma (Liberia)",
    lon: "Malawi Lomwe",
    loo: "Lombo",
    lop: "Lopa",
    loq: "Lobala",
    lor: "T\xE9\xE9n",
    los: "Loniu",
    lot: "Otuho",
    lou: "Louisiana Creole",
    lov: "Lopi",
    low: "Tampias Lobu",
    lox: "Loun",
    loy: "Loke",
    loz: "Lozi",
    lpa: "Lelepa",
    lpe: "Lepki",
    lpn: "Long Phuri Naga",
    lpo: "Lipo",
    lpx: "Lopit",
    lra: "Rara Bakati'",
    lrc: "Northern Luri",
    lre: "Laurentian",
    lrg: "Laragia",
    lri: "Marachi",
    lrk: "Loarki",
    lrl: "Lari",
    lrm: "Marama",
    lrn: "Lorang",
    lro: "Laro",
    lrr: "Southern Yamphu",
    lrt: "Larantuka Malay",
    lrv: "Larevat",
    lrz: "Lemerig",
    lsa: "Lasgerdi",
    lsd: "Lishana Deni",
    lse: "Lusengo",
    lsg: "Lyons Sign Language",
    lsh: "Lish",
    lsi: "Lashi",
    lsl: "Latvian Sign Language",
    lsm: "Saamia",
    lso: "Laos Sign Language",
    lsp: "Panamanian Sign Language",
    lsr: "Aruop",
    lss: "Lasi",
    lst: "Trinidad and Tobago Sign Language",
    lsy: "Mauritian Sign Language",
    ltc: "Late Middle Chinese",
    ltg: "Latgalian",
    lth: "Thur",
    lti: "Leti (Indonesia)",
    ltn: "Latund\xEA",
    lto: "Tsotso",
    lts: "Tachoni",
    ltu: "Latu",
    ltz: "Luxembourgish",
    lua: "Luba-Lulua",
    lub: "Luba-Katanga",
    luc: "Aringa",
    lud: "Ludian",
    lue: "Luvale",
    luf: "Laua",
    lug: "Ganda",
    lui: "Luiseno",
    luj: "Luna",
    luk: "Lunanakha",
    lul: "Olu'bo",
    lum: "Luimbi",
    lun: "Lunda",
    luo: "Luo (Kenya and Tanzania)",
    lup: "Lumbu",
    luq: "Lucumi",
    lur: "Laura",
    lus: "Lushai",
    lut: "Lushootseed",
    luu: "Lumba-Yakkha",
    luv: "Luwati",
    luw: "Luo (Cameroon)",
    luy: "Luyia",
    luz: "Southern Luri",
    lva: "Maku'a",
    lvk: "Lavukaleve",
    lvs: "Standard Latvian",
    lvu: "Levuka",
    lwa: "Lwalu",
    lwe: "Lewo Eleng",
    lwg: "Wanga",
    lwh: "White Lachi",
    lwl: "Eastern Lawa",
    lwm: "Laomian",
    lwo: "Luwo",
    lwt: "Lewotobi",
    lwu: "Lawu",
    lww: "Lewo",
    lya: "Layakha",
    lyg: "Lyngngam",
    lyn: "Luyana",
    lzh: "Literary Chinese",
    lzl: "Litzlitz",
    lzn: "Leinong Naga",
    lzz: "Laz",
    maa: "San Jer\xF3nimo Tec\xF3atl Mazatec",
    mab: "Yutanduchi Mixtec",
    mad: "Madurese",
    mae: "Bo-Rukul",
    maf: "Mafa",
    mag: "Magahi",
    mah: "Marshallese",
    mai: "Maithili",
    maj: "Jalapa De D\xEDaz Mazatec",
    mak: "Makasar",
    mal: "Malayalam",
    mam: "Mam",
    man: "Mandingo",
    maq: "Chiquihuitl\xE1n Mazatec",
    mar: "Marathi",
    mas: "Masai",
    mat: "San Francisco Matlatzinca",
    mau: "Huautla Mazatec",
    mav: "Sater\xE9-Maw\xE9",
    maw: "Mampruli",
    max: "North Moluccan Malay",
    maz: "Central Mazahua",
    mba: "Higaonon",
    mbb: "Western Bukidnon Manobo",
    mbc: "Macushi",
    mbd: "Dibabawon Manobo",
    mbe: "Molale",
    mbf: "Baba Malay",
    mbh: "Mangseng",
    mbi: "Ilianen Manobo",
    mbj: "Nad\xEBb",
    mbk: "Malol",
    mbl: "Maxakal\xED",
    mbm: "Ombamba",
    mbn: "Macagu\xE1n",
    mbo: "Mbo (Cameroon)",
    mbp: "Malayo",
    mbq: "Maisin",
    mbr: "Nukak Mak\xFA",
    mbs: "Sarangani Manobo",
    mbt: "Matigsalug Manobo",
    mbu: "Mbula-Bwazza",
    mbv: "Mbulungish",
    mbw: "Maring",
    mbx: "Mari (East Sepik Province)",
    mby: "Memoni",
    mbz: "Amoltepec Mixtec",
    mca: "Maca",
    mcb: "Machiguenga",
    mcc: "Bitur",
    mcd: "Sharanahua",
    mce: "Itundujia Mixtec",
    mcf: "Mats\xE9s",
    mcg: "Mapoyo",
    mch: "Maquiritari",
    mci: "Mese",
    mcj: "Mvanip",
    mck: "Mbunda",
    mcl: "Macaguaje",
    mcm: "Malaccan Creole Portuguese",
    mcn: "Masana",
    mco: "Coatl\xE1n Mixe",
    mcp: "Makaa",
    mcq: "Ese",
    mcr: "Menya",
    mcs: "Mambai",
    mct: "Mengisa",
    mcu: "Cameroon Mambila",
    mcv: "Minanibai",
    mcw: "Mawa (Chad)",
    mcx: "Mpiemo",
    mcy: "South Watut",
    mcz: "Mawan",
    mda: "Mada (Nigeria)",
    mdb: "Morigi",
    mdc: "Male (Papua New Guinea)",
    mdd: "Mbum",
    mde: "Maba (Chad)",
    mdf: "Moksha",
    mdg: "Massalat",
    mdh: "Maguindanaon",
    mdi: "Mamvu",
    mdj: "Mangbetu",
    mdk: "Mangbutu",
    mdl: "Maltese Sign Language",
    mdm: "Mayogo",
    mdn: "Mbati",
    mdp: "Mbala",
    mdq: "Mbole",
    mdr: "Mandar",
    mds: "Maria (Papua New Guinea)",
    mdt: "Mbere",
    mdu: "Mboko",
    mdv: "Santa Luc\xEDa Monteverde Mixtec",
    mdw: "Mbosi",
    mdx: "Dizin",
    mdy: "Male (Ethiopia)",
    mdz: "Suru\xED Do Par\xE1",
    mea: "Menka",
    meb: "Ikobi",
    mec: "Mara",
    med: "Melpa",
    mee: "Mengen",
    mef: "Megam",
    meh: "Southwestern Tlaxiaco Mixtec",
    mei: "Midob",
    mej: "Meyah",
    mek: "Mekeo",
    mel: "Central Melanau",
    mem: "Mangala",
    men: "Mende (Sierra Leone)",
    meo: "Kedah Malay",
    mep: "Miriwung",
    meq: "Merey",
    mer: "Meru",
    mes: "Masmaje",
    met: "Mato",
    meu: "Motu",
    mev: "Mano",
    mew: "Maaka",
    mey: "Hassaniyya",
    mez: "Menominee",
    mfa: "Pattani Malay",
    mfb: "Bangka",
    mfc: "Mba",
    mfd: "Mendankwe-Nkwen",
    mfe: "Morisyen",
    mff: "Naki",
    mfg: "Mogofin",
    mfh: "Matal",
    mfi: "Wandala",
    mfj: "Mefele",
    mfk: "North Mofu",
    mfl: "Putai",
    mfm: "Marghi South",
    mfn: "Cross River Mbembe",
    mfo: "Mbe",
    mfp: "Makassar Malay",
    mfq: "Moba",
    mfr: "Marithiel",
    mfs: "Mexican Sign Language",
    mft: "Mokerang",
    mfu: "Mbwela",
    mfv: "Mandjak",
    mfw: "Mulaha",
    mfx: "Melo",
    mfy: "Mayo",
    mfz: "Mabaan",
    mga: "Middle Irish (900-1200)",
    mgb: "Mararit",
    mgc: "Morokodo",
    mgd: "Moru",
    mge: "Mango",
    mgf: "Maklew",
    mgg: "Mpumpong",
    mgh: "Makhuwa-Meetto",
    mgi: "Lijili",
    mgj: "Abureni",
    mgk: "Mawes",
    mgl: "Maleu-Kilenge",
    mgm: "Mambae",
    mgn: "Mbangi",
    mgo: "Meta'",
    mgp: "Eastern Magar",
    mgq: "Malila",
    mgr: "Mambwe-Lungu",
    mgs: "Manda (Tanzania)",
    mgt: "Mongol",
    mgu: "Mailu",
    mgv: "Matengo",
    mgw: "Matumbi",
    mgy: "Mbunga",
    mgz: "Mbugwe",
    mha: "Manda (India)",
    mhb: "Mahongwe",
    mhc: "Mocho",
    mhd: "Mbugu",
    mhe: "Besisi",
    mhf: "Mamaa",
    mhg: "Margu",
    mhi: "Ma'di",
    mhj: "Mogholi",
    mhk: "Mungaka",
    mhl: "Mauwake",
    mhm: "Makhuwa-Moniga",
    mhn: "M\xF3cheno",
    mho: "Mashi (Zambia)",
    mhp: "Balinese Malay",
    mhq: "Mandan",
    mhr: "Eastern Mari",
    mhs: "Buru (Indonesia)",
    mht: "Mandahuaca",
    mhu: "Digaro-Mishmi",
    mhw: "Mbukushu",
    mhx: "Maru",
    mhy: "Ma'anyan",
    mhz: "Mor (Mor Islands)",
    mia: "Miami",
    mib: "Atatl\xE1huca Mixtec",
    mic: "Mi'kmaq",
    mid: "Mandaic",
    mie: "Ocotepec Mixtec",
    mif: "Mofu-Gudur",
    mig: "San Miguel El Grande Mixtec",
    mih: "Chayuco Mixtec",
    mii: "Chigmecatitl\xE1n Mixtec",
    mij: "Abar",
    mik: "Mikasuki",
    mil: "Pe\xF1oles Mixtec",
    mim: "Alacatlatzala Mixtec",
    min: "Minangkabau",
    mio: "Pinotepa Nacional Mixtec",
    mip: "Apasco-Apoala Mixtec",
    miq: "M\xEDskito",
    mir: "Isthmus Mixe",
    mis: "Uncoded languages",
    mit: "Southern Puebla Mixtec",
    miu: "Cacaloxtepec Mixtec",
    miw: "Akoye",
    mix: "Mixtepec Mixtec",
    miy: "Ayutla Mixtec",
    miz: "Coatzospan Mixtec",
    mjb: "Makalero",
    mjc: "San Juan Colorado Mixtec",
    mjd: "Northwest Maidu",
    mje: "Muskum",
    mjg: "Tu",
    mjh: "Mwera (Nyasa)",
    mji: "Kim Mun",
    mjj: "Mawak",
    mjk: "Matukar",
    mjl: "Mandeali",
    mjm: "Medebur",
    mjn: "Ma (Papua New Guinea)",
    mjo: "Malankuravan",
    mjp: "Malapandaram",
    mjq: "Malaryan",
    mjr: "Malavedan",
    mjs: "Miship",
    mjt: "Sauria Paharia",
    mju: "Manna-Dora",
    mjv: "Mannan",
    mjw: "Karbi",
    mjx: "Mahali",
    mjy: "Mahican",
    mjz: "Majhi",
    mka: "Mbre",
    mkb: "Mal Paharia",
    mkc: "Siliput",
    mkd: "Macedonian",
    mke: "Mawchi",
    mkf: "Miya",
    mkg: "Mak (China)",
    mki: "Dhatki",
    mkj: "Mokilese",
    mkk: "Byep",
    mkl: "Mokole",
    mkm: "Moklen",
    mkn: "Kupang Malay",
    mko: "Mingang Doso",
    mkp: "Moikodi",
    mkq: "Bay Miwok",
    mkr: "Malas",
    mks: "Silacayoapan Mixtec",
    mkt: "Vamale",
    mku: "Konyanka Maninka",
    mkv: "Mafea",
    mkw: "Kituba (Congo)",
    mkx: "Kinamiging Manobo",
    mky: "East Makian",
    mkz: "Makasae",
    mla: "Malo",
    mlb: "Mbule",
    mlc: "Cao Lan",
    mle: "Manambu",
    mlf: "Mal",
    mlg: "Malagasy",
    mlh: "Mape",
    mli: "Malimpung",
    mlj: "Miltu",
    mlk: "Ilwana",
    mll: "Malua Bay",
    mlm: "Mulam",
    mln: "Malango",
    mlo: "Mlomp",
    mlp: "Bargam",
    mlq: "Western Maninkakan",
    mlr: "Vame",
    mls: "Masalit",
    mlt: "Maltese",
    mlu: "To'abaita",
    mlv: "Motlav",
    mlw: "Moloko",
    mlx: "Malfaxal",
    mlz: "Malaynon",
    mma: "Mama",
    mmb: "Momina",
    mmc: "Michoac\xE1n Mazahua",
    mmd: "Maonan",
    mme: "Mae",
    mmf: "Mundat",
    mmg: "North Ambrym",
    mmh: "Mehin\xE1ku",
    mmi: "Musar",
    mmj: "Majhwar",
    mmk: "Mukha-Dora",
    mml: "Man Met",
    mmm: "Maii",
    mmn: "Mamanwa",
    mmo: "Mangga Buang",
    mmp: "Siawi",
    mmq: "Musak",
    mmr: "Western Xiangxi Miao",
    mmt: "Malalamai",
    mmu: "Mmaala",
    mmv: "Miriti",
    mmw: "Emae",
    mmx: "Madak",
    mmy: "Migaama",
    mmz: "Mabaale",
    mna: "Mbula",
    mnb: "Muna",
    mnc: "Manchu",
    mnd: "Mond\xE9",
    mne: "Naba",
    mnf: "Mundani",
    mng: "Eastern Mnong",
    mnh: "Mono (Democratic Republic of Congo)",
    mni: "Manipuri",
    mnj: "Munji",
    mnk: "Mandinka",
    mnl: "Tiale",
    mnm: "Mapena",
    mnn: "Southern Mnong",
    mnp: "Min Bei Chinese",
    mnq: "Minriq",
    mnr: "Mono (USA)",
    mns: "Mansi",
    mnu: "Mer",
    mnv: "Rennell-Bellona",
    mnw: "Mon",
    mnx: "Manikion",
    mny: "Manyawa",
    mnz: "Moni",
    moa: "Mwan",
    moc: "Mocov\xED",
    mod: "Mobilian",
    moe: "Montagnais",
    mog: "Mongondow",
    moh: "Mohawk",
    moi: "Mboi",
    moj: "Monzombo",
    mok: "Morori",
    mom: "Mangue",
    mon: "Mongolian",
    moo: "Monom",
    mop: "Mop\xE1n Maya",
    moq: "Mor (Bomberai Peninsula)",
    mor: "Moro",
    mos: "Mossi",
    mot: "Bar\xED",
    mou: "Mogum",
    mov: "Mohave",
    mow: "Moi (Congo)",
    mox: "Molima",
    moy: "Shekkacho",
    moz: "Mukulu",
    mpa: "Mpoto",
    mpb: "Mullukmulluk",
    mpc: "Mangarayi",
    mpd: "Machinere",
    mpe: "Majang",
    mpg: "Marba",
    mph: "Maung",
    mpi: "Mpade",
    mpj: "Martu Wangka",
    mpk: "Mbara (Chad)",
    mpl: "Middle Watut",
    mpm: "Yosond\xFAa Mixtec",
    mpn: "Mindiri",
    mpo: "Miu",
    mpp: "Migabac",
    mpq: "Mat\xEDs",
    mpr: "Vangunu",
    mps: "Dadibi",
    mpt: "Mian",
    mpu: "Makur\xE1p",
    mpv: "Mungkip",
    mpw: "Mapidian",
    mpx: "Misima-Panaeati",
    mpy: "Mapia",
    mpz: "Mpi",
    mqa: "Maba (Indonesia)",
    mqb: "Mbuko",
    mqc: "Mangole",
    mqe: "Matepi",
    mqf: "Momuna",
    mqg: "Kota Bangun Kutai Malay",
    mqh: "Tlazoyaltepec Mixtec",
    mqi: "Mariri",
    mqj: "Mamasa",
    mqk: "Rajah Kabunsuwan Manobo",
    mql: "Mbelime",
    mqm: "South Marquesan",
    mqn: "Moronene",
    mqo: "Modole",
    mqp: "Manipa",
    mqq: "Minokok",
    mqr: "Mander",
    mqs: "West Makian",
    mqt: "Mok",
    mqu: "Mandari",
    mqv: "Mosimo",
    mqw: "Murupi",
    mqx: "Mamuju",
    mqy: "Manggarai",
    mqz: "Pano",
    mra: "Mlabri",
    mrb: "Marino",
    mrc: "Maricopa",
    mrd: "Western Magar",
    mre: "Martha's Vineyard Sign Language",
    mrf: "Elseng",
    mrg: "Mising",
    mrh: "Mara Chin",
    mri: "Maori",
    mrj: "Western Mari",
    mrk: "Hmwaveke",
    mrl: "Mortlockese",
    mrm: "Merlav",
    mrn: "Cheke Holo",
    mro: "Mru",
    mrp: "Morouas",
    mrq: "North Marquesan",
    mrr: "Maria (India)",
    mrs: "Maragus",
    mrt: "Marghi Central",
    mru: "Mono (Cameroon)",
    mrv: "Mangareva",
    mrw: "Maranao",
    mrx: "Maremgi",
    mry: "Mandaya",
    mrz: "Marind",
    msa: "Malay (macrolanguage)",
    msb: "Masbatenyo",
    msc: "Sankaran Maninka",
    msd: "Yucatec Maya Sign Language",
    mse: "Musey",
    msf: "Mekwei",
    msg: "Moraid",
    msh: "Masikoro Malagasy",
    msi: "Sabah Malay",
    msj: "Ma (Democratic Republic of Congo)",
    msk: "Mansaka",
    msl: "Molof",
    msm: "Agusan Manobo",
    msn: "Vur\xEBs",
    mso: "Mombum",
    msp: "Maritsau\xE1",
    msq: "Caac",
    msr: "Mongolian Sign Language",
    mss: "West Masela",
    msu: "Musom",
    msv: "Maslam",
    msw: "Mansoanka",
    msx: "Moresada",
    msy: "Aruamu",
    msz: "Momare",
    mta: "Cotabato Manobo",
    mtb: "Anyin Morofo",
    mtc: "Munit",
    mtd: "Mualang",
    mte: "Mono (Solomon Islands)",
    mtf: "Murik (Papua New Guinea)",
    mtg: "Una",
    mth: "Munggui",
    mti: "Maiwa (Papua New Guinea)",
    mtj: "Moskona",
    mtk: "Mbe'",
    mtl: "Montol",
    mtm: "Mator",
    mtn: "Matagalpa",
    mto: "Totontepec Mixe",
    mtp: "Wich\xED Lhamt\xE9s Nocten",
    mtq: "Muong",
    mtr: "Mewari",
    mts: "Yora",
    mtt: "Mota",
    mtu: "Tututepec Mixtec",
    mtv: "Asaro'o",
    mtw: "Southern Binukidnon",
    mtx: "Tida\xE1 Mixtec",
    mty: "Nabi",
    mua: "Mundang",
    mub: "Mubi",
    muc: "Ajumbu",
    mud: "Mednyj Aleut",
    mue: "Media Lengua",
    mug: "Musgu",
    muh: "M\xFCnd\xFC",
    mui: "Musi",
    muj: "Mabire",
    muk: "Mugom",
    mul: "Multiple languages",
    mum: "Maiwala",
    muo: "Nyong",
    mup: "Malvi",
    muq: "Eastern Xiangxi Miao",
    mur: "Murle",
    mus: "Creek",
    mut: "Western Muria",
    muu: "Yaaku",
    muv: "Muthuvan",
    mux: "Bo-Ung",
    muy: "Muyang",
    muz: "Mursi",
    mva: "Manam",
    mvb: "Mattole",
    mvd: "Mamboru",
    mve: "Marwari (Pakistan)",
    mvf: "Peripheral Mongolian",
    mvg: "Yucua\xF1e Mixtec",
    mvh: "Mulgi",
    mvi: "Miyako",
    mvk: "Mekmek",
    mvl: "Mbara (Australia)",
    mvm: "Muya",
    mvn: "Minaveha",
    mvo: "Marovo",
    mvp: "Duri",
    mvq: "Moere",
    mvr: "Marau",
    mvs: "Massep",
    mvt: "Mpotovoro",
    mvu: "Marfa",
    mvv: "Tagal Murut",
    mvw: "Machinga",
    mvx: "Meoswar",
    mvy: "Indus Kohistani",
    mvz: "Mesqan",
    mwa: "Mwatebu",
    mwb: "Juwal",
    mwc: "Are",
    mwe: "Mwera (Chimwera)",
    mwf: "Murrinh-Patha",
    mwg: "Aiklep",
    mwh: "Mouk-Aria",
    mwi: "Labo",
    mwk: "Kita Maninkakan",
    mwl: "Mirandese",
    mwm: "Sar",
    mwn: "Nyamwanga",
    mwo: "Central Maewo",
    mwp: "Kala Lagaw Ya",
    mwq: "M\xFCn Chin",
    mwr: "Marwari",
    mws: "Mwimbi-Muthambi",
    mwt: "Moken",
    mwu: "Mittu",
    mwv: "Mentawai",
    mww: "Hmong Daw",
    mwx: "Mediak",
    mwy: "Mosiro",
    mwz: "Moingi",
    mxa: "Northwest Oaxaca Mixtec",
    mxb: "Tezoatl\xE1n Mixtec",
    mxc: "Manyika",
    mxd: "Modang",
    mxe: "Mele-Fila",
    mxf: "Malgbe",
    mxg: "Mbangala",
    mxh: "Mvuba",
    mxi: "Mozarabic",
    mxj: "Miju-Mishmi",
    mxk: "Monumbo",
    mxl: "Maxi Gbe",
    mxm: "Meramera",
    mxn: "Moi (Indonesia)",
    mxo: "Mbowe",
    mxp: "Tlahuitoltepec Mixe",
    mxq: "Juquila Mixe",
    mxr: "Murik (Malaysia)",
    mxs: "Huitepec Mixtec",
    mxt: "Jamiltepec Mixtec",
    mxu: "Mada (Cameroon)",
    mxv: "Metlat\xF3noc Mixtec",
    mxw: "Namo",
    mxx: "Mahou",
    mxy: "Southeastern Nochixtl\xE1n Mixtec",
    mxz: "Central Masela",
    mya: "Burmese",
    myb: "Mbay",
    myc: "Mayeka",
    myd: "Maramba",
    mye: "Myene",
    myf: "Bambassi",
    myg: "Manta",
    myh: "Makah",
    myi: "Mina (India)",
    myj: "Mangayat",
    myk: "Mamara Senoufo",
    myl: "Moma",
    mym: "Me'en",
    myo: "Anfillo",
    myp: "Pirah\xE3",
    myr: "Muniche",
    mys: "Mesmes",
    myu: "Munduruk\xFA",
    myv: "Erzya",
    myw: "Muyuw",
    myx: "Masaaba",
    myy: "Macuna",
    myz: "Classical Mandaic",
    mza: "Santa Mar\xEDa Zacatepec Mixtec",
    mzb: "Tumzabt",
    mzc: "Madagascar Sign Language",
    mzd: "Malimba",
    mze: "Morawa",
    mzg: "Monastic Sign Language",
    mzh: "Wich\xED Lhamt\xE9s G\xFCisnay",
    mzi: "Ixcatl\xE1n Mazatec",
    mzj: "Manya",
    mzk: "Nigeria Mambila",
    mzl: "Mazatl\xE1n Mixe",
    mzm: "Mumuye",
    mzn: "Mazanderani",
    mzo: "Matipuhy",
    mzp: "Movima",
    mzq: "Mori Atas",
    mzr: "Mar\xFAbo",
    mzs: "Macanese",
    mzt: "Mintil",
    mzu: "Inapang",
    mzv: "Manza",
    mzw: "Deg",
    mzx: "Mawayana",
    mzy: "Mozambican Sign Language",
    mzz: "Maiadomu",
    naa: "Namla",
    nab: "Southern Nambiku\xE1ra",
    nac: "Narak",
    nae: "Naka'ela",
    naf: "Nabak",
    nag: "Naga Pidgin",
    naj: "Nalu",
    nak: "Nakanai",
    nal: "Nalik",
    nam: "Ngan'gityemerri",
    nan: "Min Nan Chinese",
    nao: "Naaba",
    nap: "Neapolitan",
    naq: "Khoekhoe",
    nar: "Iguta",
    nas: "Naasioi",
    nat: "Ca\u0331hungwa\u0331rya\u0331",
    nau: "Nauru",
    nav: "Navajo",
    naw: "Nawuri",
    nax: "Nakwi",
    nay: "Narrinyeri",
    naz: "Coatepec Nahuatl",
    nba: "Nyemba",
    nbb: "Ndoe",
    nbc: "Chang Naga",
    nbd: "Ngbinda",
    nbe: "Konyak Naga",
    nbg: "Nagarchal",
    nbh: "Ngamo",
    nbi: "Mao Naga",
    nbj: "Ngarinman",
    nbk: "Nake",
    nbl: "South Ndebele",
    nbm: "Ngbaka Ma'bo",
    nbn: "Kuri",
    nbo: "Nkukoli",
    nbp: "Nnam",
    nbq: "Nggem",
    nbr: "Numana-Nunku-Gbantu-Numbu",
    nbs: "Namibian Sign Language",
    nbt: "Na",
    nbu: "Rongmei Naga",
    nbv: "Ngamambo",
    nbw: "Southern Ngbandi",
    nby: "Ningera",
    nca: "Iyo",
    ncb: "Central Nicobarese",
    ncc: "Ponam",
    ncd: "Nachering",
    nce: "Yale",
    ncf: "Notsi",
    ncg: "Nisga'a",
    nch: "Central Huasteca Nahuatl",
    nci: "Classical Nahuatl",
    ncj: "Northern Puebla Nahuatl",
    nck: "Nakara",
    ncl: "Michoac\xE1n Nahuatl",
    ncm: "Nambo",
    ncn: "Nauna",
    nco: "Sibe",
    ncp: "Ndaktup",
    ncq: "Northern Katang",
    ncr: "Ncane",
    ncs: "Nicaraguan Sign Language",
    nct: "Chothe Naga",
    ncu: "Chumburung",
    ncx: "Central Puebla Nahuatl",
    ncz: "Natchez",
    nda: "Ndasa",
    ndb: "Kenswei Nsei",
    ndc: "Ndau",
    ndd: "Nde-Nsele-Nta",
    nde: "North Ndebele",
    ndf: "Nadruvian",
    ndg: "Ndengereko",
    ndh: "Ndali",
    ndi: "Samba Leko",
    ndj: "Ndamba",
    ndk: "Ndaka",
    ndl: "Ndolo",
    ndm: "Ndam",
    ndn: "Ngundi",
    ndo: "Ndonga",
    ndp: "Ndo",
    ndq: "Ndombe",
    ndr: "Ndoola",
    nds: "Low German",
    ndt: "Ndunga",
    ndu: "Dugun",
    ndv: "Ndut",
    ndw: "Ndobo",
    ndx: "Nduga",
    ndy: "Lutos",
    ndz: "Ndogo",
    nea: "Eastern Ngad'a",
    neb: "Toura (C\xF4te d'Ivoire)",
    nec: "Nedebang",
    ned: "Nde-Gbite",
    nee: "N\xEAl\xEAmwa-Nixumwak",
    nef: "Nefamese",
    neg: "Negidal",
    neh: "Nyenkha",
    nei: "Neo-Hittite",
    nej: "Neko",
    nek: "Neku",
    nem: "Nemi",
    nen: "Nengone",
    neo: "N\xE1-Meo",
    nep: "Nepali (macrolanguage)",
    neq: "North Central Mixe",
    ner: "Yahadian",
    nes: "Bhoti Kinnauri",
    net: "Nete",
    neu: "Neo",
    nev: "Nyaheun",
    new: "Newari",
    nex: "Neme",
    ney: "Neyo",
    nez: "Nez Perce",
    nfa: "Dhao",
    nfd: "Ahwai",
    nfl: "Ayiwo",
    nfr: "Nafaanra",
    nfu: "Mfumte",
    nga: "Ngbaka",
    ngb: "Northern Ngbandi",
    ngc: "Ngombe (Democratic Republic of Congo)",
    ngd: "Ngando (Central African Republic)",
    nge: "Ngemba",
    ngg: "Ngbaka Manza",
    ngh: "N/u",
    ngi: "Ngizim",
    ngj: "Ngie",
    ngk: "Dalabon",
    ngl: "Lomwe",
    ngm: "Ngatik Men's Creole",
    ngn: "Ngwo",
    ngo: "Ngoni",
    ngp: "Ngulu",
    ngq: "Ngurimi",
    ngr: "Engdewu",
    ngs: "Gvoko",
    ngt: "Kriang",
    ngu: "Guerrero Nahuatl",
    ngv: "Nagumi",
    ngw: "Ngwaba",
    ngx: "Nggwahyi",
    ngy: "Tibea",
    ngz: "Ngungwel",
    nha: "Nhanda",
    nhb: "Beng",
    nhc: "Tabasco Nahuatl",
    nhd: "Chirip\xE1",
    nhe: "Eastern Huasteca Nahuatl",
    nhf: "Nhuwala",
    nhg: "Tetelcingo Nahuatl",
    nhh: "Nahari",
    nhi: "Zacatl\xE1n-Ahuacatl\xE1n-Tepetzintla Nahuatl",
    nhk: "Isthmus-Cosoleacaque Nahuatl",
    nhm: "Morelos Nahuatl",
    nhn: "Central Nahuatl",
    nho: "Takuu",
    nhp: "Isthmus-Pajapan Nahuatl",
    nhq: "Huaxcaleca Nahuatl",
    nhr: "Naro",
    nht: "Ometepec Nahuatl",
    nhu: "Noone",
    nhv: "Temascaltepec Nahuatl",
    nhw: "Western Huasteca Nahuatl",
    nhx: "Isthmus-Mecayapan Nahuatl",
    nhy: "Northern Oaxaca Nahuatl",
    nhz: "Santa Mar\xEDa La Alta Nahuatl",
    nia: "Nias",
    nib: "Nakame",
    nid: "Ngandi",
    nie: "Niellim",
    nif: "Nek",
    nig: "Ngalakan",
    nih: "Nyiha (Tanzania)",
    nii: "Nii",
    nij: "Ngaju",
    nik: "Southern Nicobarese",
    nil: "Nila",
    nim: "Nilamba",
    nin: "Ninzo",
    nio: "Nganasan",
    niq: "Nandi",
    nir: "Nimboran",
    nis: "Nimi",
    nit: "Southeastern Kolami",
    niu: "Niuean",
    niv: "Gilyak",
    niw: "Nimo",
    nix: "Hema",
    niy: "Ngiti",
    niz: "Ningil",
    nja: "Nzanyi",
    njb: "Nocte Naga",
    njd: "Ndonde Hamba",
    njh: "Lotha Naga",
    nji: "Gudanji",
    njj: "Njen",
    njl: "Njalgulgule",
    njm: "Angami Naga",
    njn: "Liangmai Naga",
    njo: "Ao Naga",
    njr: "Njerep",
    njs: "Nisa",
    njt: "Ndyuka-Trio Pidgin",
    nju: "Ngadjunmaya",
    njx: "Kunyi",
    njy: "Njyem",
    njz: "Nyishi",
    nka: "Nkoya",
    nkb: "Khoibu Naga",
    nkc: "Nkongho",
    nkd: "Koireng",
    nke: "Duke",
    nkf: "Inpui Naga",
    nkg: "Nekgini",
    nkh: "Khezha Naga",
    nki: "Thangal Naga",
    nkj: "Nakai",
    nkk: "Nokuku",
    nkm: "Namat",
    nkn: "Nkangala",
    nko: "Nkonya",
    nkp: "Niuatoputapu",
    nkq: "Nkami",
    nkr: "Nukuoro",
    nks: "North Asmat",
    nkt: "Nyika (Tanzania)",
    nku: "Bouna Kulango",
    nkv: "Nyika (Malawi and Zambia)",
    nkw: "Nkutu",
    nkx: "Nkoroo",
    nkz: "Nkari",
    nla: "Ngombale",
    nlc: "Nalca",
    nld: "Dutch",
    nle: "East Nyala",
    nlg: "Gela",
    nli: "Grangali",
    nlj: "Nyali",
    nlk: "Ninia Yali",
    nll: "Nihali",
    nlo: "Ngul",
    nlq: "Lao Naga",
    nlu: "Nchumbulu",
    nlv: "Orizaba Nahuatl",
    nlw: "Walangama",
    nlx: "Nahali",
    nly: "Nyamal",
    nlz: "Nal\xF6go",
    nma: "Maram Naga",
    nmb: "Big Nambas",
    nmc: "Ngam",
    nmd: "Ndumu",
    nme: "Mzieme Naga",
    nmf: "Tangkhul Naga (India)",
    nmg: "Kwasio",
    nmh: "Monsang Naga",
    nmi: "Nyam",
    nmj: "Ngombe (Central African Republic)",
    nmk: "Namakura",
    nml: "Ndemli",
    nmm: "Manangba",
    nmn: "!X\xF3\xF5",
    nmo: "Moyon Naga",
    nmp: "Nimanbur",
    nmq: "Nambya",
    nmr: "Nimbari",
    nms: "Letemboi",
    nmt: "Namonuito",
    nmu: "Northeast Maidu",
    nmv: "Ngamini",
    nmw: "Nimoa",
    nmx: "Nama (Papua New Guinea)",
    nmy: "Namuyi",
    nmz: "Nawdm",
    nna: "Nyangumarta",
    nnb: "Nande",
    nnc: "Nancere",
    nnd: "West Ambae",
    nne: "Ngandyera",
    nnf: "Ngaing",
    nng: "Maring Naga",
    nnh: "Ngiemboon",
    nni: "North Nuaulu",
    nnj: "Nyangatom",
    nnk: "Nankina",
    nnl: "Northern Rengma Naga",
    nnm: "Namia",
    nnn: "Ngete",
    nno: "Norwegian Nynorsk",
    nnp: "Wancho Naga",
    nnq: "Ngindo",
    nnr: "Narungga",
    nns: "Ningye",
    nnt: "Nanticoke",
    nnu: "Dwang",
    nnv: "Nugunu (Australia)",
    nnw: "Southern Nuni",
    nny: "Nyangga",
    nnz: "Nda'nda'",
    noa: "Woun Meu",
    nob: "Norwegian Bokm\xE5l",
    noc: "Nuk",
    nod: "Northern Thai",
    noe: "Nimadi",
    nof: "Nomane",
    nog: "Nogai",
    noh: "Nomu",
    noi: "Noiri",
    noj: "Nonuya",
    nok: "Nooksack",
    nol: "Nomlaki",
    nom: "Nocam\xE1n",
    non: "Old Norse",
    nop: "Numanggang",
    noq: "Ngongo",
    nor: "Norwegian",
    nos: "Eastern Nisu",
    not: "Nomatsiguenga",
    nou: "Ewage-Notu",
    nov: "Novial",
    now: "Nyambo",
    noy: "Noy",
    noz: "Nayi",
    npa: "Nar Phu",
    npb: "Nupbikha",
    npg: "Ponyo-Gongwang Naga",
    nph: "Phom Naga",
    npi: "Nepali (individual language)",
    npl: "Southeastern Puebla Nahuatl",
    npn: "Mondropolon",
    npo: "Pochuri Naga",
    nps: "Nipsan",
    npu: "Puimei Naga",
    npx: "Noipx",
    npy: "Napu",
    nqg: "Southern Nago",
    nqk: "Kura Ede Nago",
    nql: "Ngendelengo",
    nqm: "Ndom",
    nqn: "Nen",
    nqo: "N'Ko",
    nqq: "Kyan-Karyaw Naga",
    nqy: "Akyaung Ari Naga",
    nra: "Ngom",
    nrb: "Nara",
    nrc: "Noric",
    nre: "Southern Rengma Naga",
    nrf: "J\xE8rriais",
    nrg: "Narango",
    nri: "Chokri Naga",
    nrk: "Ngarla",
    nrl: "Ngarluma",
    nrm: "Narom",
    nrn: "Norn",
    nrp: "North Picene",
    nrr: "Norra",
    nrt: "Northern Kalapuya",
    nru: "Narua",
    nrx: "Ngurmbur",
    nrz: "Lala",
    nsa: "Sangtam Naga",
    nsc: "Nshi",
    nsd: "Southern Nisu",
    nse: "Nsenga",
    nsf: "Northwestern Nisu",
    nsg: "Ngasa",
    nsh: "Ngoshie",
    nsi: "Nigerian Sign Language",
    nsk: "Naskapi",
    nsl: "Norwegian Sign Language",
    nsm: "Sumi Naga",
    nsn: "Nehan",
    nso: "Pedi",
    nsp: "Nepalese Sign Language",
    nsq: "Northern Sierra Miwok",
    nsr: "Maritime Sign Language",
    nss: "Nali",
    nst: "Tase Naga",
    nsu: "Sierra Negra Nahuatl",
    nsv: "Southwestern Nisu",
    nsw: "Navut",
    nsx: "Nsongo",
    nsy: "Nasal",
    nsz: "Nisenan",
    ntd: "Northern Tidung",
    nte: "Nathembo",
    ntg: "Ngantangarra",
    nti: "Natioro",
    ntj: "Ngaanyatjarra",
    ntk: "Ikoma-Nata-Isenye",
    ntm: "Nateni",
    nto: "Ntomba",
    ntp: "Northern Tepehuan",
    ntr: "Delo",
    ntu: "Nat\xFCgu",
    ntw: "Nottoway",
    ntx: "Tangkhul Naga (Myanmar)",
    nty: "Mantsi",
    ntz: "Natanzi",
    nua: "Yuanga",
    nuc: "Nukuini",
    nud: "Ngala",
    nue: "Ngundu",
    nuf: "Nusu",
    nug: "Nungali",
    nuh: "Ndunda",
    nui: "Ngumbi",
    nuj: "Nyole",
    nuk: "Nuu-chah-nulth",
    nul: "Nusa Laut",
    num: "Niuafo'ou",
    nun: "Anong",
    nuo: "Ngu\xF4n",
    nup: "Nupe-Nupe-Tako",
    nuq: "Nukumanu",
    nur: "Nukuria",
    nus: "Nuer",
    nut: "Nung (Viet Nam)",
    nuu: "Ngbundu",
    nuv: "Northern Nuni",
    nuw: "Nguluwan",
    nux: "Mehek",
    nuy: "Nunggubuyu",
    nuz: "Tlamacazapa Nahuatl",
    nvh: "Nasarian",
    nvm: "Namiae",
    nvo: "Nyokon",
    nwa: "Nawathinehena",
    nwb: "Nyabwa",
    nwc: "Classical Newari",
    nwe: "Ngwe",
    nwg: "Ngayawung",
    nwi: "Southwest Tanna",
    nwm: "Nyamusa-Molo",
    nwo: "Nauo",
    nwr: "Nawaru",
    nwx: "Middle Newar",
    nwy: "Nottoway-Meherrin",
    nxa: "Nauete",
    nxd: "Ngando (Democratic Republic of Congo)",
    nxe: "Nage",
    nxg: "Ngad'a",
    nxi: "Nindi",
    nxk: "Koki Naga",
    nxl: "South Nuaulu",
    nxm: "Numidian",
    nxn: "Ngawun",
    nxo: "Ndambomo",
    nxq: "Naxi",
    nxr: "Ninggerum",
    nxu: "Narau",
    nxx: "Nafri",
    nya: "Nyanja",
    nyb: "Nyangbo",
    nyc: "Nyanga-li",
    nyd: "Nyore",
    nye: "Nyengo",
    nyf: "Giryama",
    nyg: "Nyindu",
    nyh: "Nyigina",
    nyi: "Ama (Sudan)",
    nyj: "Nyanga",
    nyk: "Nyaneka",
    nyl: "Nyeu",
    nym: "Nyamwezi",
    nyn: "Nyankole",
    nyo: "Nyoro",
    nyp: "Nyang'i",
    nyq: "Nayini",
    nyr: "Nyiha (Malawi)",
    nys: "Nyunga",
    nyt: "Nyawaygi",
    nyu: "Nyungwe",
    nyv: "Nyulnyul",
    nyw: "Nyaw",
    nyx: "Nganyaywana",
    nyy: "Nyakyusa-Ngonde",
    nza: "Tigon Mbembe",
    nzb: "Njebi",
    nzi: "Nzima",
    nzk: "Nzakara",
    nzm: "Zeme Naga",
    nzs: "New Zealand Sign Language",
    nzu: "Teke-Nzikou",
    nzy: "Nzakambay",
    nzz: "Nanga Dama Dogon",
    oaa: "Orok",
    oac: "Oroch",
    oar: "Old Aramaic (up to 700 BCE)",
    oav: "Old Avar",
    obi: "Obispe\xF1o",
    obk: "Southern Bontok",
    obl: "Oblo",
    obm: "Moabite",
    obo: "Obo Manobo",
    obr: "Old Burmese",
    obt: "Old Breton",
    obu: "Obulom",
    oca: "Ocaina",
    och: "Old Chinese",
    oci: "Occitan (post 1500)",
    oco: "Old Cornish",
    ocu: "Atzingo Matlatzinca",
    oda: "Odut",
    odk: "Od",
    odt: "Old Dutch",
    odu: "Odual",
    ofo: "Ofo",
    ofs: "Old Frisian",
    ofu: "Efutop",
    ogb: "Ogbia",
    ogc: "Ogbah",
    oge: "Old Georgian",
    ogg: "Ogbogolo",
    ogo: "Khana",
    ogu: "Ogbronuagum",
    oht: "Old Hittite",
    ohu: "Old Hungarian",
    oia: "Oirata",
    oin: "Inebu One",
    ojb: "Northwestern Ojibwa",
    ojc: "Central Ojibwa",
    ojg: "Eastern Ojibwa",
    oji: "Ojibwa",
    ojp: "Old Japanese",
    ojs: "Severn Ojibwa",
    ojv: "Ontong Java",
    ojw: "Western Ojibwa",
    oka: "Okanagan",
    okb: "Okobo",
    okd: "Okodia",
    oke: "Okpe (Southwestern Edo)",
    okg: "Koko Babangk",
    okh: "Koresh-e Rostam",
    oki: "Okiek",
    okj: "Oko-Juwoi",
    okk: "Kwamtim One",
    okl: "Old Kentish Sign Language",
    okm: "Middle Korean (10th-16th cent.)",
    okn: "Oki-No-Erabu",
    oko: "Old Korean (3rd-9th cent.)",
    okr: "Kirike",
    oks: "Oko-Eni-Osayen",
    oku: "Oku",
    okv: "Orokaiva",
    okx: "Okpe (Northwestern Edo)",
    ola: "Walungge",
    old: "Mochi",
    ole: "Olekha",
    olk: "Olkol",
    olm: "Oloma",
    olo: "Livvi",
    olr: "Olrat",
    olt: "Old Lithuanian",
    olu: "Kuvale",
    oma: "Omaha-Ponca",
    omb: "East Ambae",
    omc: "Mochica",
    omg: "Omagua",
    omi: "Omi",
    omk: "Omok",
    oml: "Ombo",
    omn: "Minoan",
    omo: "Utarmbung",
    omp: "Old Manipuri",
    omr: "Old Marathi",
    omt: "Omotik",
    omu: "Omurano",
    omw: "South Tairora",
    omx: "Old Mon",
    ona: "Ona",
    onb: "Lingao",
    one: "Oneida",
    ong: "Olo",
    oni: "Onin",
    onj: "Onjob",
    onk: "Kabore One",
    onn: "Onobasulu",
    ono: "Onondaga",
    onp: "Sartang",
    onr: "Northern One",
    ons: "Ono",
    ont: "Ontenu",
    onu: "Unua",
    onw: "Old Nubian",
    onx: "Onin Based Pidgin",
    ood: "Tohono O'odham",
    oog: "Ong",
    oon: "\xD6nge",
    oor: "Oorlams",
    oos: "Old Ossetic",
    opa: "Okpamheri",
    opk: "Kopkaka",
    opm: "Oksapmin",
    opo: "Opao",
    opt: "Opata",
    opy: "Ofay\xE9",
    ora: "Oroha",
    orc: "Orma",
    ore: "Orej\xF3n",
    org: "Oring",
    orh: "Oroqen",
    ori: "Oriya (macrolanguage)",
    orm: "Oromo",
    orn: "Orang Kanaq",
    oro: "Orokolo",
    orr: "Oruma",
    ors: "Orang Seletar",
    ort: "Adivasi Oriya",
    oru: "Ormuri",
    orv: "Old Russian",
    orw: "Oro Win",
    orx: "Oro",
    ory: "Odia",
    orz: "Ormu",
    osa: "Osage",
    osc: "Oscan",
    osi: "Osing",
    oso: "Ososo",
    osp: "Old Spanish",
    oss: "Ossetian",
    ost: "Osatu",
    osu: "Southern One",
    osx: "Old Saxon",
    ota: "Ottoman Turkish (1500-1928)",
    otb: "Old Tibetan",
    otd: "Ot Danum",
    ote: "Mezquital Otomi",
    oti: "Oti",
    otk: "Old Turkish",
    otl: "Tilapa Otomi",
    otm: "Eastern Highland Otomi",
    otn: "Tenango Otomi",
    otq: "Quer\xE9taro Otomi",
    otr: "Otoro",
    ots: "Estado de M\xE9xico Otomi",
    ott: "Temoaya Otomi",
    otu: "Otuke",
    otw: "Ottawa",
    otx: "Texcatepec Otomi",
    oty: "Old Tamil",
    otz: "Ixtenco Otomi",
    oua: "Tagargrent",
    oub: "Glio-Oubi",
    oue: "Oune",
    oui: "Old Uighur",
    oum: "Ouma",
    ovd: "Elfdalian",
    owi: "Owiniga",
    owl: "Old Welsh",
    oyb: "Oy",
    oyd: "Oyda",
    oym: "Wayampi",
    oyy: "Oya'oya",
    ozm: "Koonzime",
    pab: "Parec\xEDs",
    pac: "Pacoh",
    pad: "Paumar\xED",
    pae: "Pagibete",
    paf: "Paranaw\xE1t",
    pag: "Pangasinan",
    pah: "Tenharim",
    pai: "Pe",
    pak: "Parakan\xE3",
    pal: "Pahlavi",
    pam: "Pampanga",
    pan: "Panjabi",
    pao: "Northern Paiute",
    pap: "Papiamento",
    paq: "Parya",
    par: "Panamint",
    pas: "Papasena",
    pat: "Papitalai",
    pau: "Palauan",
    pav: "Paka\xE1snovos",
    paw: "Pawnee",
    pax: "Pankarar\xE9",
    pay: "Pech",
    paz: "Pankarar\xFA",
    pbb: "P\xE1ez",
    pbc: "Patamona",
    pbe: "Mezontla Popoloca",
    pbf: "Coyotepec Popoloca",
    pbg: "Paraujano",
    pbh: "E'\xF1apa Woromaipu",
    pbi: "Parkwa",
    pbl: "Mak (Nigeria)",
    pbn: "Kpasam",
    pbo: "Papel",
    pbp: "Badyara",
    pbr: "Pangwa",
    pbs: "Central Pame",
    pbt: "Southern Pashto",
    pbu: "Northern Pashto",
    pbv: "Pnar",
    pby: "Pyu (Papua New Guinea)",
    pca: "Santa In\xE9s Ahuatempan Popoloca",
    pcb: "Pear",
    pcc: "Bouyei",
    pcd: "Picard",
    pce: "Ruching Palaung",
    pcf: "Paliyan",
    pcg: "Paniya",
    pch: "Pardhan",
    pci: "Duruwa",
    pcj: "Parenga",
    pck: "Paite Chin",
    pcl: "Pardhi",
    pcm: "Nigerian Pidgin",
    pcn: "Piti",
    pcp: "Pacahuara",
    pcw: "Pyapun",
    pda: "Anam",
    pdc: "Pennsylvania German",
    pdi: "Pa Di",
    pdn: "Podena",
    pdo: "Padoe",
    pdt: "Plautdietsch",
    pdu: "Kayan",
    pea: "Peranakan Indonesian",
    peb: "Eastern Pomo",
    ped: "Mala (Papua New Guinea)",
    pee: "Taje",
    pef: "Northeastern Pomo",
    peg: "Pengo",
    peh: "Bonan",
    pei: "Chichimeca-Jonaz",
    pej: "Northern Pomo",
    pek: "Penchal",
    pel: "Pekal",
    pem: "Phende",
    peo: "Old Persian (ca. 600-400 B.C.)",
    pep: "Kunja",
    peq: "Southern Pomo",
    pes: "Iranian Persian",
    pev: "P\xE9mono",
    pex: "Petats",
    pey: "Petjo",
    pez: "Eastern Penan",
    pfa: "P\xE1\xE1fang",
    pfe: "Peere",
    pfl: "Pfaelzisch",
    pga: "Sudanese Creole Arabic",
    pgd: "G\u0101ndh\u0101r\u012B",
    pgg: "Pangwali",
    pgi: "Pagi",
    pgk: "Rerep",
    pgl: "Primitive Irish",
    pgn: "Paelignian",
    pgs: "Pangseng",
    pgu: "Pagu",
    pgz: "Papua New Guinean Sign Language",
    pha: "Pa-Hng",
    phd: "Phudagi",
    phg: "Phuong",
    phh: "Phukha",
    phk: "Phake",
    phl: "Phalura",
    phm: "Phimbi",
    phn: "Phoenician",
    pho: "Phunoi",
    phq: "Phana'",
    phr: "Pahari-Potwari",
    pht: "Phu Thai",
    phu: "Phuan",
    phv: "Pahlavani",
    phw: "Phangduwali",
    pia: "Pima Bajo",
    pib: "Yine",
    pic: "Pinji",
    pid: "Piaroa",
    pie: "Piro",
    pif: "Pingelapese",
    pig: "Pisabo",
    pih: "Pitcairn-Norfolk",
    pii: "Pini",
    pij: "Pijao",
    pil: "Yom",
    pim: "Powhatan",
    pin: "Piame",
    pio: "Piapoco",
    pip: "Pero",
    pir: "Piratapuyo",
    pis: "Pijin",
    pit: "Pitta Pitta",
    piu: "Pintupi-Luritja",
    piv: "Pileni",
    piw: "Pimbwe",
    pix: "Piu",
    piy: "Piya-Kwonci",
    piz: "Pije",
    pjt: "Pitjantjatjara",
    pka: "Ardham\u0101gadh\u012B Pr\u0101krit",
    pkb: "Pokomo",
    pkc: "Paekche",
    pkg: "Pak-Tong",
    pkh: "Pankhu",
    pkn: "Pakanha",
    pko: "P\xF6koot",
    pkp: "Pukapuka",
    pkr: "Attapady Kurumba",
    pks: "Pakistan Sign Language",
    pkt: "Maleng",
    pku: "Paku",
    pla: "Miani",
    plb: "Polonombauk",
    plc: "Central Palawano",
    pld: "Polari",
    ple: "Palu'e",
    plg: "Pilag\xE1",
    plh: "Paulohi",
    pli: "Pali",
    plj: "Polci",
    plk: "Kohistani Shina",
    pll: "Shwe Palaung",
    pln: "Palenquero",
    plo: "Oluta Popoluca",
    plp: "Palpa",
    plq: "Palaic",
    plr: "Palaka Senoufo",
    pls: "San Marcos Tlacoyalco Popoloca",
    plt: "Plateau Malagasy",
    plu: "Palik\xFAr",
    plv: "Southwest Palawano",
    plw: "Brooke's Point Palawano",
    ply: "Bolyu",
    plz: "Paluan",
    pma: "Paama",
    pmb: "Pambia",
    pmd: "Pallanganmiddang",
    pme: "Pwaamei",
    pmf: "Pamona",
    pmh: "M\u0101h\u0101r\u0101\u1E63\u1E6Dri Pr\u0101krit",
    pmi: "Northern Pumi",
    pmj: "Southern Pumi",
    pmk: "Pamlico",
    pml: "Lingua Franca",
    pmm: "Pomo",
    pmn: "Pam",
    pmo: "Pom",
    pmq: "Northern Pame",
    pmr: "Paynamar",
    pms: "Piemontese",
    pmt: "Tuamotuan",
    pmw: "Plains Miwok",
    pmx: "Poumei Naga",
    pmy: "Papuan Malay",
    pmz: "Southern Pame",
    pna: "Punan Bah-Biau",
    pnb: "Western Panjabi",
    pnc: "Pannei",
    pne: "Western Penan",
    png: "Pongu",
    pnh: "Penrhyn",
    pni: "Aoheng",
    pnj: "Pinjarup",
    pnk: "Paunaka",
    pnl: "Paleni",
    pnm: "Punan Batu 1",
    pnn: "Pinai-Hagahai",
    pno: "Panobo",
    pnp: "Pancana",
    pnq: "Pana (Burkina Faso)",
    pnr: "Panim",
    pns: "Ponosakan",
    pnt: "Pontic",
    pnu: "Jiongnai Bunu",
    pnv: "Pinigura",
    pnw: "Panytyima",
    pnx: "Phong-Kniang",
    pny: "Pinyin",
    pnz: "Pana (Central African Republic)",
    poc: "Poqomam",
    poe: "San Juan Atzingo Popoloca",
    pof: "Poke",
    pog: "Potigu\xE1ra",
    poh: "Poqomchi'",
    poi: "Highland Popoluca",
    pok: "Pokang\xE1",
    pol: "Polish",
    pom: "Southeastern Pomo",
    pon: "Pohnpeian",
    poo: "Central Pomo",
    pop: "Pwapw\xE2",
    poq: "Texistepec Popoluca",
    por: "Portuguese",
    pos: "Sayula Popoluca",
    pot: "Potawatomi",
    pov: "Upper Guinea Crioulo",
    pow: "San Felipe Otlaltepec Popoloca",
    pox: "Polabian",
    poy: "Pogolo",
    ppe: "Papi",
    ppi: "Paipai",
    ppk: "Uma",
    ppl: "Pipil",
    ppm: "Papuma",
    ppn: "Papapana",
    ppo: "Folopa",
    ppp: "Pelende",
    ppq: "Pei",
    pps: "San Lu\xEDs Temalacayuca Popoloca",
    ppt: "Pare",
    ppu: "Papora",
    pqa: "Pa'a",
    pqm: "Malecite-Passamaquoddy",
    prc: "Parachi",
    prd: "Parsi-Dari",
    pre: "Principense",
    prf: "Paranan",
    prg: "Prussian",
    prh: "Porohanon",
    pri: "Paic\xEE",
    prk: "Parauk",
    prl: "Peruvian Sign Language",
    prm: "Kibiri",
    prn: "Prasuni",
    pro: "Old Proven\xE7al (to 1500)",
    prp: "Parsi",
    prq: "Ash\xE9ninka Peren\xE9",
    prr: "Puri",
    prs: "Dari",
    prt: "Phai",
    pru: "Puragi",
    prw: "Parawen",
    prx: "Purik",
    prz: "Providencia Sign Language",
    psa: "Asue Awyu",
    psc: "Persian Sign Language",
    psd: "Plains Indian Sign Language",
    pse: "Central Malay",
    psg: "Penang Sign Language",
    psh: "Southwest Pashai",
    psi: "Southeast Pashai",
    psl: "Puerto Rican Sign Language",
    psm: "Pauserna",
    psn: "Panasuan",
    pso: "Polish Sign Language",
    psp: "Philippine Sign Language",
    psq: "Pasi",
    psr: "Portuguese Sign Language",
    pss: "Kaulong",
    pst: "Central Pashto",
    psu: "Sauraseni Pr\u0101krit",
    psw: "Port Sandwich",
    psy: "Piscataway",
    pta: "Pai Tavytera",
    pth: "Patax\xF3 H\xE3-Ha-H\xE3e",
    pti: "Pintiini",
    ptn: "Patani",
    pto: "Zo'\xE9",
    ptp: "Patep",
    ptq: "Pattapu",
    ptr: "Piamatsina",
    ptt: "Enrekang",
    ptu: "Bambam",
    ptv: "Port Vato",
    ptw: "Pentlatch",
    pty: "Pathiya",
    pua: "Western Highland Purepecha",
    pub: "Purum",
    puc: "Punan Merap",
    pud: "Punan Aput",
    pue: "Puelche",
    puf: "Punan Merah",
    pug: "Phuie",
    pui: "Puinave",
    puj: "Punan Tubu",
    pum: "Puma",
    puo: "Puoc",
    pup: "Pulabu",
    puq: "Puquina",
    pur: "Purubor\xE1",
    pus: "Pushto",
    put: "Putoh",
    puu: "Punu",
    puw: "Puluwatese",
    pux: "Puare",
    puy: "Purisime\xF1o",
    pwa: "Pawaia",
    pwb: "Panawa",
    pwg: "Gapapaiwa",
    pwi: "Patwin",
    pwm: "Molbog",
    pwn: "Paiwan",
    pwo: "Pwo Western Karen",
    pwr: "Powari",
    pww: "Pwo Northern Karen",
    pxm: "Quetzaltepec Mixe",
    pye: "Pye Krumen",
    pym: "Fyam",
    pyn: "Poyan\xE1wa",
    pys: "Paraguayan Sign Language",
    pyu: "Puyuma",
    pyx: "Pyu (Myanmar)",
    pyy: "Pyen",
    pzn: "Para Naga",
    qaa: "Original audio",
    qad: "Audio Description",
    qua: "Quapaw",
    qub: "Huallaga Hu\xE1nuco Quechua",
    quc: "K'iche'",
    qud: "Calder\xF3n Highland Quichua",
    que: "Quechua",
    quf: "Lambayeque Quechua",
    qug: "Chimborazo Highland Quichua",
    quh: "South Bolivian Quechua",
    qui: "Quileute",
    quk: "Chachapoyas Quechua",
    qul: "North Bolivian Quechua",
    qum: "Sipacapense",
    qun: "Quinault",
    qup: "Southern Pastaza Quechua",
    quq: "Quinqui",
    qur: "Yanahuanca Pasco Quechua",
    qus: "Santiago del Estero Quichua",
    quv: "Sacapulteco",
    quw: "Tena Lowland Quichua",
    qux: "Yauyos Quechua",
    quy: "Ayacucho Quechua",
    quz: "Cusco Quechua",
    qva: "Ambo-Pasco Quechua",
    qvc: "Cajamarca Quechua",
    qve: "Eastern Apur\xEDmac Quechua",
    qvh: "Huamal\xEDes-Dos de Mayo Hu\xE1nuco Quechua",
    qvi: "Imbabura Highland Quichua",
    qvj: "Loja Highland Quichua",
    qvl: "Cajatambo North Lima Quechua",
    qvm: "Margos-Yarowilca-Lauricocha Quechua",
    qvn: "North Jun\xEDn Quechua",
    qvo: "Napo Lowland Quechua",
    qvp: "Pacaraos Quechua",
    qvs: "San Mart\xEDn Quechua",
    qvw: "Huaylla Wanca Quechua",
    qvy: "Queyu",
    qvz: "Northern Pastaza Quichua",
    qwa: "Corongo Ancash Quechua",
    qwc: "Classical Quechua",
    qwh: "Huaylas Ancash Quechua",
    qwm: "Kuman (Russia)",
    qws: "Sihuas Ancash Quechua",
    qwt: "Kwalhioqua-Tlatskanai",
    qxa: "Chiqui\xE1n Ancash Quechua",
    qxc: "Chincha Quechua",
    qxh: "Panao Hu\xE1nuco Quechua",
    qxl: "Salasaca Highland Quichua",
    qxn: "Northern Conchucos Ancash Quechua",
    qxo: "Southern Conchucos Ancash Quechua",
    qxp: "Puno Quechua",
    qxq: "Qashqa'i",
    qxr: "Ca\xF1ar Highland Quichua",
    qxs: "Southern Qiang",
    qxt: "Santa Ana de Tusi Pasco Quechua",
    qxu: "Arequipa-La Uni\xF3n Quechua",
    qxw: "Jauja Wanca Quechua",
    qya: "Quenya",
    qyp: "Quiripi",
    raa: "Dungmali",
    rab: "Camling",
    rac: "Rasawa",
    rad: "Rade",
    raf: "Western Meohang",
    rag: "Logooli",
    rah: "Rabha",
    rai: "Ramoaaina",
    raj: "Rajasthani",
    rak: "Tulu-Bohuai",
    ral: "Ralte",
    ram: "Canela",
    ran: "Riantana",
    rao: "Rao",
    rap: "Rapanui",
    raq: "Saam",
    rar: "Rarotongan",
    ras: "Tegali",
    rat: "Razajerdi",
    rau: "Raute",
    rav: "Sampang",
    raw: "Rawang",
    rax: "Rang",
    ray: "Rapa",
    raz: "Rahambuu",
    rbb: "Rumai Palaung",
    rbk: "Northern Bontok",
    rbl: "Miraya Bikol",
    rbp: "Barababaraba",
    rcf: "R\xE9union Creole French",
    rdb: "Rudbari",
    rea: "Rerau",
    reb: "Rembong",
    ree: "Rejang Kayan",
    reg: "Kara (Tanzania)",
    rei: "Reli",
    rej: "Rejang",
    rel: "Rendille",
    rem: "Remo",
    ren: "Rengao",
    rer: "Rer Bare",
    res: "Reshe",
    ret: "Retta",
    rey: "Reyesano",
    rga: "Roria",
    rge: "Romano-Greek",
    rgk: "Rangkas",
    rgn: "Romagnol",
    rgr: "Res\xEDgaro",
    rgs: "Southern Roglai",
    rgu: "Ringgou",
    rhg: "Rohingya",
    rhp: "Yahang",
    ria: "Riang (India)",
    rif: "Tarifit",
    ril: "Riang (Myanmar)",
    rim: "Nyaturu",
    rin: "Nungu",
    rir: "Ribun",
    rit: "Ritarungo",
    riu: "Riung",
    rjg: "Rajong",
    rji: "Raji",
    rjs: "Rajbanshi",
    rka: "Kraol",
    rkb: "Rikbaktsa",
    rkh: "Rakahanga-Manihiki",
    rki: "Rakhine",
    rkm: "Marka",
    rkt: "Rangpuri",
    rkw: "Arakwal",
    rma: "Rama",
    rmb: "Rembarunga",
    rmc: "Carpathian Romani",
    rmd: "Traveller Danish",
    rme: "Angloromani",
    rmf: "Kalo Finnish Romani",
    rmg: "Traveller Norwegian",
    rmh: "Murkim",
    rmi: "Lomavren",
    rmk: "Romkun",
    rml: "Baltic Romani",
    rmm: "Roma",
    rmn: "Balkan Romani",
    rmo: "Sinte Romani",
    rmp: "Rempi",
    rmq: "Cal\xF3",
    rms: "Romanian Sign Language",
    rmt: "Domari",
    rmu: "Tavringer Romani",
    rmv: "Romanova",
    rmw: "Welsh Romani",
    rmx: "Romam",
    rmy: "Vlax Romani",
    rmz: "Marma",
    rnd: "Ruund",
    rng: "Ronga",
    rnl: "Ranglong",
    rnn: "Roon",
    rnp: "Rongpo",
    rnr: "Nari Nari",
    rnw: "Rungwa",
    rob: "Tae'",
    roc: "Cacgia Roglai",
    rod: "Rogo",
    roe: "Ronji",
    rof: "Rombo",
    rog: "Northern Roglai",
    roh: "Romansh",
    rol: "Romblomanon",
    rom: "Romany",
    ron: "Romanian",
    roo: "Rotokas",
    rop: "Kriol",
    ror: "Rongga",
    rou: "Runga",
    row: "Dela-Oenale",
    rpn: "Repanbitip",
    rpt: "Rapting",
    rri: "Ririo",
    rro: "Waima",
    rrt: "Arritinngithigh",
    rsb: "Romano-Serbian",
    rsl: "Russian Sign Language",
    rsm: "Miriwoong Sign Language",
    rtc: "Rungtu Chin",
    rth: "Ratahan",
    rtm: "Rotuman",
    rts: "Yurats",
    rtw: "Rathawi",
    rub: "Gungu",
    ruc: "Ruuli",
    rue: "Rusyn",
    ruf: "Luguru",
    rug: "Roviana",
    ruh: "Ruga",
    rui: "Rufiji",
    ruk: "Che",
    run: "Rundi",
    ruo: "Istro Romanian",
    rup: "Macedo-Romanian",
    ruq: "Megleno Romanian",
    rus: "Russian",
    rut: "Rutul",
    ruu: "Lanas Lobu",
    ruy: "Mala (Nigeria)",
    ruz: "Ruma",
    rwa: "Rawo",
    rwk: "Rwa",
    rwm: "Amba (Uganda)",
    rwo: "Rawa",
    rwr: "Marwari (India)",
    rxd: "Ngardi",
    rxw: "Karuwali",
    ryn: "Northern Amami-Oshima",
    rys: "Yaeyama",
    ryu: "Central Okinawan",
    rzh: "R\u0101zi\u1E25\u012B",
    saa: "Saba",
    sab: "Buglere",
    sac: "Meskwaki",
    sad: "Sandawe",
    sae: "Saban\xEA",
    saf: "Safaliba",
    sag: "Sango",
    sah: "Yakut",
    saj: "Sahu",
    sak: "Sake",
    sam: "Samaritan Aramaic",
    san: "Sanskrit",
    sao: "Sause",
    saq: "Samburu",
    sar: "Saraveca",
    sas: "Sasak",
    sat: "Santali",
    sau: "Saleman",
    sav: "Saafi-Saafi",
    saw: "Sawi",
    sax: "Sa",
    say: "Saya",
    saz: "Saurashtra",
    sba: "Ngambay",
    sbb: "Simbo",
    sbc: "Kele (Papua New Guinea)",
    sbd: "Southern Samo",
    sbe: "Saliba",
    sbf: "Chabu",
    sbg: "Seget",
    sbh: "Sori-Harengan",
    sbi: "Seti",
    sbj: "Surbakhal",
    sbk: "Safwa",
    sbl: "Botolan Sambal",
    sbm: "Sagala",
    sbn: "Sindhi Bhil",
    sbo: "Sab\xFCm",
    sbp: "Sangu (Tanzania)",
    sbq: "Sileibi",
    sbr: "Sembakung Murut",
    sbs: "Subiya",
    sbt: "Kimki",
    sbu: "Stod Bhoti",
    sbv: "Sabine",
    sbw: "Simba",
    sbx: "Seberuang",
    sby: "Soli",
    sbz: "Sara Kaba",
    scb: "Chut",
    sce: "Dongxiang",
    scf: "San Miguel Creole French",
    scg: "Sanggau",
    sch: "Sakachep",
    sci: "Sri Lankan Creole Malay",
    sck: "Sadri",
    scl: "Shina",
    scn: "Sicilian",
    sco: "Scots",
    scp: "Helambu Sherpa",
    scq: "Sa'och",
    scs: "North Slavey",
    sct: "Southern Katang",
    scu: "Shumcho",
    scv: "Sheni",
    scw: "Sha",
    scx: "Sicel",
    sda: "Toraja-Sa'dan",
    sdb: "Shabak",
    sdc: "Sassarese Sardinian",
    sde: "Surubu",
    sdf: "Sarli",
    sdg: "Savi",
    sdh: "Southern Kurdish",
    sdj: "Suundi",
    sdk: "Sos Kundi",
    sdl: "Saudi Arabian Sign Language",
    sdm: "Semandang",
    sdn: "Gallurese Sardinian",
    sdo: "Bukar-Sadung Bidayuh",
    sdp: "Sherdukpen",
    sdr: "Oraon Sadri",
    sds: "Sened",
    sdt: "Shuadit",
    sdu: "Sarudu",
    sdx: "Sibu Melanau",
    sdz: "Sallands",
    sea: "Semai",
    seb: "Shempire Senoufo",
    sec: "Sechelt",
    sed: "Sedang",
    see: "Seneca",
    sef: "Cebaara Senoufo",
    seg: "Segeju",
    seh: "Sena",
    sei: "Seri",
    sej: "Sene",
    sek: "Sekani",
    sel: "Selkup",
    sen: "Nanerig\xE9 S\xE9noufo",
    seo: "Suarmin",
    sep: "S\xECc\xECt\xE9 S\xE9noufo",
    seq: "Senara S\xE9noufo",
    ser: "Serrano",
    ses: "Koyraboro Senni Songhai",
    set: "Sentani",
    seu: "Serui-Laut",
    sev: "Nyarafolo Senoufo",
    sew: "Sewa Bay",
    sey: "Secoya",
    sez: "Senthang Chin",
    sfb: "Langue des signes de Belgique Francophone",
    sfe: "Eastern Subanen",
    sfm: "Small Flowery Miao",
    sfs: "South African Sign Language",
    sfw: "Sehwi",
    sga: "Old Irish (to 900)",
    sgb: "Mag-antsi Ayta",
    sgc: "Kipsigis",
    sgd: "Surigaonon",
    sge: "Segai",
    sgg: "Swiss-German Sign Language",
    sgh: "Shughni",
    sgi: "Suga",
    sgj: "Surgujia",
    sgk: "Sangkong",
    sgm: "Singa",
    sgp: "Singpho",
    sgr: "Sangisari",
    sgs: "Samogitian",
    sgt: "Brokpake",
    sgu: "Salas",
    sgw: "Sebat Bet Gurage",
    sgx: "Sierra Leone Sign Language",
    sgy: "Sanglechi",
    sgz: "Sursurunga",
    sha: "Shall-Zwall",
    shb: "Ninam",
    shc: "Sonde",
    shd: "Kundal Shahi",
    she: "Sheko",
    shg: "Shua",
    shh: "Shoshoni",
    shi: "Tachelhit",
    shj: "Shatt",
    shk: "Shilluk",
    shl: "Shendu",
    shm: "Shahrudi",
    shn: "Shan",
    sho: "Shanga",
    shp: "Shipibo-Conibo",
    shq: "Sala",
    shr: "Shi",
    shs: "Shuswap",
    sht: "Shasta",
    shu: "Chadian Arabic",
    shv: "Shehri",
    shw: "Shwai",
    shx: "She",
    shy: "Tachawit",
    shz: "Syenara Senoufo",
    sia: "Akkala Sami",
    sib: "Sebop",
    sid: "Sidamo",
    sie: "Simaa",
    sif: "Siamou",
    sig: "Paasaal",
    sih: "Zire",
    sii: "Shom Peng",
    sij: "Numbami",
    sik: "Sikiana",
    sil: "Tumulung Sisaala",
    sim: "Mende (Papua New Guinea)",
    sin: "Sinhala",
    sip: "Sikkimese",
    siq: "Sonia",
    sir: "Siri",
    sis: "Siuslaw",
    siu: "Sinagen",
    siv: "Sumariup",
    siw: "Siwai",
    six: "Sumau",
    siy: "Sivandi",
    siz: "Siwi",
    sja: "Epena",
    sjb: "Sajau Basap",
    sjd: "Kildin Sami",
    sje: "Pite Sami",
    sjg: "Assangori",
    sjk: "Kemi Sami",
    sjl: "Sajalong",
    sjm: "Mapun",
    sjn: "Sindarin",
    sjo: "Xibe",
    sjp: "Surjapuri",
    sjr: "Siar-Lak",
    sjs: "Senhaja De Srair",
    sjt: "Ter Sami",
    sju: "Ume Sami",
    sjw: "Shawnee",
    ska: "Skagit",
    skb: "Saek",
    skc: "Ma Manda",
    skd: "Southern Sierra Miwok",
    ske: "Seke (Vanuatu)",
    skf: "Sakirabi\xE1",
    skg: "Sakalava Malagasy",
    skh: "Sikule",
    ski: "Sika",
    skj: "Seke (Nepal)",
    skm: "Kutong",
    skn: "Kolibugan Subanon",
    sko: "Seko Tengah",
    skp: "Sekapan",
    skq: "Sininkere",
    skr: "Saraiki",
    sks: "Maia",
    skt: "Sakata",
    sku: "Sakao",
    skv: "Skou",
    skw: "Skepi Creole Dutch",
    skx: "Seko Padang",
    sky: "Sikaiana",
    skz: "Sekar",
    slc: "S\xE1liba",
    sld: "Sissala",
    sle: "Sholaga",
    slf: "Swiss-Italian Sign Language",
    slg: "Selungai Murut",
    slh: "Southern Puget Sound Salish",
    sli: "Lower Silesian",
    slj: "Salum\xE1",
    slk: "Slovak",
    sll: "Salt-Yui",
    slm: "Pangutaran Sama",
    sln: "Salinan",
    slp: "Lamaholot",
    slq: "Salchuq",
    slr: "Salar",
    sls: "Singapore Sign Language",
    slt: "Sila",
    slu: "Selaru",
    slv: "Slovenian",
    slw: "Sialum",
    slx: "Salampasu",
    sly: "Selayar",
    slz: "Ma'ya",
    sma: "Southern Sami",
    smb: "Simbari",
    smc: "Som",
    smd: "Sama",
    sme: "Northern Sami",
    smf: "Auwe",
    smg: "Simbali",
    smh: "Samei",
    smj: "Lule Sami",
    smk: "Bolinao",
    sml: "Central Sama",
    smm: "Musasa",
    smn: "Inari Sami",
    smo: "Samoan",
    smp: "Samaritan",
    smq: "Samo",
    smr: "Simeulue",
    sms: "Skolt Sami",
    smt: "Simte",
    smu: "Somray",
    smv: "Samvedi",
    smw: "Sumbawa",
    smx: "Samba",
    smy: "Semnani",
    smz: "Simeku",
    sna: "Shona",
    snb: "Sebuyau",
    snc: "Sinaugoro",
    snd: "Sindhi",
    sne: "Bau Bidayuh",
    snf: "Noon",
    sng: "Sanga (Democratic Republic of Congo)",
    sni: "Sensi",
    snj: "Riverain Sango",
    snk: "Soninke",
    snl: "Sangil",
    snm: "Southern Ma'di",
    snn: "Siona",
    sno: "Snohomish",
    snp: "Siane",
    snq: "Sangu (Gabon)",
    snr: "Sihan",
    sns: "South West Bay",
    snu: "Senggi",
    snv: "Sa'ban",
    snw: "Selee",
    snx: "Sam",
    sny: "Saniyo-Hiyewe",
    snz: "Sinsauru",
    soa: "Thai Song",
    sob: "Sobei",
    soc: "So (Democratic Republic of Congo)",
    sod: "Songoora",
    soe: "Songomeno",
    sog: "Sogdian",
    soh: "Aka",
    soi: "Sonha",
    soj: "Soi",
    sok: "Sokoro",
    sol: "Solos",
    som: "Somali",
    soo: "Songo",
    sop: "Songe",
    soq: "Kanasi",
    sor: "Somrai",
    sos: "Seeku",
    sot: "Southern Sotho",
    sou: "Southern Thai",
    sov: "Sonsorol",
    sow: "Sowanda",
    sox: "Swo",
    soy: "Miyobe",
    soz: "Temi",
    spa: "Spanish",
    spb: "Sepa (Indonesia)",
    spc: "Sap\xE9",
    spd: "Saep",
    spe: "Sepa (Papua New Guinea)",
    spg: "Sian",
    spi: "Saponi",
    spk: "Sengo",
    spl: "Selepet",
    spm: "Akukem",
    spn: "Sanapan\xE1",
    spo: "Spokane",
    spp: "Supyire Senoufo",
    spq: "Loreto-Ucayali Spanish",
    spr: "Saparua",
    sps: "Saposa",
    spt: "Spiti Bhoti",
    spu: "Sapuan",
    spv: "Sambalpuri",
    spx: "South Picene",
    spy: "Sabaot",
    sqa: "Shama-Sambuga",
    sqh: "Shau",
    sqi: "Albanian",
    sqk: "Albanian Sign Language",
    sqm: "Suma",
    sqn: "Susquehannock",
    sqo: "Sorkhei",
    sqq: "Sou",
    sqr: "Siculo Arabic",
    sqs: "Sri Lankan Sign Language",
    sqt: "Soqotri",
    squ: "Squamish",
    sra: "Saruga",
    srb: "Sora",
    src: "Logudorese Sardinian",
    srd: "Sardinian",
    sre: "Sara",
    srf: "Nafi",
    srg: "Sulod",
    srh: "Sarikoli",
    sri: "Siriano",
    srk: "Serudung Murut",
    srl: "Isirawa",
    srm: "Saramaccan",
    srn: "Sranan Tongo",
    sro: "Campidanese Sardinian",
    srp: "Serbian",
    srq: "Sirion\xF3",
    srr: "Serer",
    srs: "Sarsi",
    srt: "Sauri",
    sru: "Suru\xED",
    srv: "Southern Sorsoganon",
    srw: "Serua",
    srx: "Sirmauri",
    sry: "Sera",
    srz: "Shahmirzadi",
    ssb: "Southern Sama",
    ssc: "Suba-Simbiti",
    ssd: "Siroi",
    sse: "Balangingi",
    ssf: "Thao",
    ssg: "Seimat",
    ssh: "Shihhi Arabic",
    ssi: "Sansi",
    ssj: "Sausi",
    ssk: "Sunam",
    ssl: "Western Sisaala",
    ssm: "Semnam",
    ssn: "Waata",
    sso: "Sissano",
    ssp: "Spanish Sign Language",
    ssq: "So'a",
    ssr: "Swiss-French Sign Language",
    sss: "S\xF4",
    sst: "Sinasina",
    ssu: "Susuami",
    ssv: "Shark Bay",
    ssw: "Swati",
    ssx: "Samberigi",
    ssy: "Saho",
    ssz: "Sengseng",
    sta: "Settla",
    stb: "Northern Subanen",
    std: "Sentinel",
    ste: "Liana-Seti",
    stf: "Seta",
    stg: "Trieng",
    sth: "Shelta",
    sti: "Bulo Stieng",
    stj: "Matya Samo",
    stk: "Arammba",
    stl: "Stellingwerfs",
    stm: "Setaman",
    stn: "Owa",
    sto: "Stoney",
    stp: "Southeastern Tepehuan",
    stq: "Saterfriesisch",
    str: "Straits Salish",
    sts: "Shumashti",
    stt: "Budeh Stieng",
    stu: "Samtao",
    stv: "Silt'e",
    stw: "Satawalese",
    sty: "Siberian Tatar",
    sua: "Sulka",
    sub: "Suku",
    suc: "Western Subanon",
    sue: "Suena",
    sug: "Suganga",
    sui: "Suki",
    suj: "Shubi",
    suk: "Sukuma",
    sun: "Sundanese",
    suq: "Suri",
    sur: "Mwaghavul",
    sus: "Susu",
    sut: "Subtiaba",
    suv: "Puroik",
    suw: "Sumbwa",
    sux: "Sumerian",
    suy: "Suy\xE1",
    suz: "Sunwar",
    sva: "Svan",
    svb: "Ulau-Suain",
    svc: "Vincentian Creole English",
    sve: "Serili",
    svk: "Slovakian Sign Language",
    svm: "Slavomolisano",
    svs: "Savosavo",
    svx: "Skalvian",
    swa: "Swahili (macrolanguage)",
    swb: "Maore Comorian",
    swc: "Congo Swahili",
    swe: "Swedish",
    swf: "Sere",
    swg: "Swabian",
    swh: "Swahili (individual language)",
    swi: "Sui",
    swj: "Sira",
    swk: "Malawi Sena",
    swl: "Swedish Sign Language",
    swm: "Samosa",
    swn: "Sawknah",
    swo: "Shanenawa",
    swp: "Suau",
    swq: "Sharwa",
    swr: "Saweru",
    sws: "Seluwasan",
    swt: "Sawila",
    swu: "Suwawa",
    swv: "Shekhawati",
    sww: "Sowa",
    swx: "Suruah\xE1",
    swy: "Sarua",
    sxb: "Suba",
    sxc: "Sicanian",
    sxe: "Sighu",
    sxg: "Shixing",
    sxk: "Southern Kalapuya",
    sxl: "Selian",
    sxm: "Samre",
    sxn: "Sangir",
    sxo: "Sorothaptic",
    sxr: "Saaroa",
    sxs: "Sasaru",
    sxu: "Upper Saxon",
    sxw: "Saxwe Gbe",
    sya: "Siang",
    syb: "Central Subanen",
    syc: "Classical Syriac",
    syi: "Seki",
    syk: "Sukur",
    syl: "Sylheti",
    sym: "Maya Samo",
    syn: "Senaya",
    syo: "Suoy",
    syr: "Syriac",
    sys: "Sinyar",
    syw: "Kagate",
    syx: "Samay",
    syy: "Al-Sayyid Bedouin Sign Language",
    sza: "Semelai",
    szb: "Ngalum",
    szc: "Semaq Beri",
    szd: "Seru",
    sze: "Seze",
    szg: "Sengele",
    szl: "Silesian",
    szn: "Sula",
    szp: "Suabo",
    szs: "Solomon Islands Sign Language",
    szv: "Isu (Fako Division)",
    szw: "Sawai",
    taa: "Lower Tanana",
    tab: "Tabassaran",
    tac: "Lowland Tarahumara",
    tad: "Tause",
    tae: "Tariana",
    taf: "Tapirap\xE9",
    tag: "Tagoi",
    tah: "Tahitian",
    taj: "Eastern Tamang",
    tak: "Tala",
    tal: "Tal",
    tam: "Tamil",
    tan: "Tangale",
    tao: "Yami",
    tap: "Taabwa",
    taq: "Tamasheq",
    tar: "Central Tarahumara",
    tas: "Tay Boi",
    tat: "Tatar",
    tau: "Upper Tanana",
    tav: "Tatuyo",
    taw: "Tai",
    tax: "Tamki",
    tay: "Atayal",
    taz: "Tocho",
    tba: "Aikan\xE3",
    tbb: "Tapeba",
    tbc: "Takia",
    tbd: "Kaki Ae",
    tbe: "Tanimbili",
    tbf: "Mandara",
    tbg: "North Tairora",
    tbh: "Thurawal",
    tbi: "Gaam",
    tbj: "Tiang",
    tbk: "Calamian Tagbanwa",
    tbl: "Tboli",
    tbm: "Tagbu",
    tbn: "Barro Negro Tunebo",
    tbo: "Tawala",
    tbp: "Taworta",
    tbr: "Tumtum",
    tbs: "Tanguat",
    tbt: "Tembo (Kitembo)",
    tbu: "Tubar",
    tbv: "Tobo",
    tbw: "Tagbanwa",
    tbx: "Kapin",
    tby: "Tabaru",
    tbz: "Ditammari",
    tca: "Ticuna",
    tcb: "Tanacross",
    tcc: "Datooga",
    tcd: "Tafi",
    tce: "Southern Tutchone",
    tcf: "Malinaltepec Me'phaa",
    tcg: "Tamagario",
    tch: "Turks And Caicos Creole English",
    tci: "W\xE1ra",
    tck: "Tchitchege",
    tcl: "Taman (Myanmar)",
    tcm: "Tanahmerah",
    tcn: "Tichurong",
    tco: "Taungyo",
    tcp: "Tawr Chin",
    tcq: "Kaiy",
    tcs: "Torres Strait Creole",
    tct: "T'en",
    tcu: "Southeastern Tarahumara",
    tcw: "Tecpatl\xE1n Totonac",
    tcx: "Toda",
    tcy: "Tulu",
    tcz: "Thado Chin",
    tda: "Tagdal",
    tdb: "Panchpargania",
    tdc: "Ember\xE1-Tad\xF3",
    tdd: "Tai N\xFCa",
    tde: "Tiranige Diga Dogon",
    tdf: "Talieng",
    tdg: "Western Tamang",
    tdh: "Thulung",
    tdi: "Tomadino",
    tdj: "Tajio",
    tdk: "Tambas",
    tdl: "Sur",
    tdm: "Taruma",
    tdn: "Tondano",
    tdo: "Teme",
    tdq: "Tita",
    tdr: "Todrah",
    tds: "Doutai",
    tdt: "Tetun Dili",
    tdv: "Toro",
    tdx: "Tandroy-Mahafaly Malagasy",
    tdy: "Tadyawan",
    tea: "Temiar",
    teb: "Tetete",
    tec: "Terik",
    ted: "Tepo Krumen",
    tee: "Huehuetla Tepehua",
    tef: "Teressa",
    teg: "Teke-Tege",
    teh: "Tehuelche",
    tei: "Torricelli",
    tek: "Ibali Teke",
    tel: "Telugu",
    tem: "Timne",
    ten: "Tama (Colombia)",
    teo: "Teso",
    tep: "Tepecano",
    teq: "Temein",
    ter: "Tereno",
    tes: "Tengger",
    tet: "Tetum",
    teu: "Soo",
    tev: "Teor",
    tew: "Tewa (USA)",
    tex: "Tennet",
    tey: "Tulishi",
    tfi: "Tofin Gbe",
    tfn: "Tanaina",
    tfo: "Tefaro",
    tfr: "Teribe",
    tft: "Ternate",
    tga: "Sagalla",
    tgb: "Tobilung",
    tgc: "Tigak",
    tgd: "Ciwogai",
    tge: "Eastern Gorkha Tamang",
    tgf: "Chalikha",
    tgh: "Tobagonian Creole English",
    tgi: "Lawunuia",
    tgj: "Tagin",
    tgk: "Tajik",
    tgl: "Tagalog",
    tgn: "Tandaganon",
    tgo: "Sudest",
    tgp: "Tangoa",
    tgq: "Tring",
    tgr: "Tareng",
    tgs: "Nume",
    tgt: "Central Tagbanwa",
    tgu: "Tanggu",
    tgv: "Tingui-Boto",
    tgw: "Tagwana Senoufo",
    tgx: "Tagish",
    tgy: "Togoyo",
    tgz: "Tagalaka",
    tha: "Thai",
    thd: "Thayore",
    the: "Chitwania Tharu",
    thf: "Thangmi",
    thh: "Northern Tarahumara",
    thi: "Tai Long",
    thk: "Tharaka",
    thl: "Dangaura Tharu",
    thm: "Aheu",
    thn: "Thachanadan",
    thp: "Thompson",
    thq: "Kochila Tharu",
    thr: "Rana Tharu",
    ths: "Thakali",
    tht: "Tahltan",
    thu: "Thuri",
    thv: "Tahaggart Tamahaq",
    thw: "Thudam",
    thy: "Tha",
    thz: "Tayart Tamajeq",
    tia: "Tidikelt Tamazight",
    tic: "Tira",
    tif: "Tifal",
    tig: "Tigre",
    tih: "Timugon Murut",
    tii: "Tiene",
    tij: "Tilung",
    tik: "Tikar",
    til: "Tillamook",
    tim: "Timbe",
    tin: "Tindi",
    tio: "Teop",
    tip: "Trimuris",
    tiq: "Ti\xE9fo",
    tir: "Tigrinya",
    tis: "Masadiit Itneg",
    tit: "Tinigua",
    tiu: "Adasen",
    tiv: "Tiv",
    tiw: "Tiwi",
    tix: "Southern Tiwa",
    tiy: "Tiruray",
    tiz: "Tai Hongjin",
    tja: "Tajuasohn",
    tjg: "Tunjung",
    tji: "Northern Tujia",
    tjl: "Tai Laing",
    tjm: "Timucua",
    tjn: "Tonjon",
    tjo: "Temacine Tamazight",
    tjs: "Southern Tujia",
    tju: "Tjurruru",
    tjw: "Djabwurrung",
    tka: "Truk\xE1",
    tkb: "Buksa",
    tkd: "Tukudede",
    tke: "Takwane",
    tkf: "Tukumanf\xE9d",
    tkg: "Tesaka Malagasy",
    tkl: "Tokelau",
    tkm: "Takelma",
    tkn: "Toku-No-Shima",
    tkp: "Tikopia",
    tkq: "Tee",
    tkr: "Tsakhur",
    tks: "Takestani",
    tkt: "Kathoriya Tharu",
    tku: "Upper Necaxa Totonac",
    tkv: "Mur Pano",
    tkw: "Teanu",
    tkx: "Tangko",
    tkz: "Takua",
    tla: "Southwestern Tepehuan",
    tlb: "Tobelo",
    tlc: "Yecuatla Totonac",
    tld: "Talaud",
    tlf: "Telefol",
    tlg: "Tofanma",
    tlh: "Klingon",
    tli: "Tlingit",
    tlj: "Talinga-Bwisi",
    tlk: "Taloki",
    tll: "Tetela",
    tlm: "Tolomako",
    tln: "Talondo'",
    tlo: "Talodi",
    tlp: "Filomena Mata-Coahuitl\xE1n Totonac",
    tlq: "Tai Loi",
    tlr: "Talise",
    tls: "Tambotalo",
    tlt: "Sou Nama",
    tlu: "Tulehu",
    tlv: "Taliabu",
    tlx: "Khehek",
    tly: "Talysh",
    tma: "Tama (Chad)",
    tmb: "Katbol",
    tmc: "Tumak",
    tmd: "Haruai",
    tme: "Trememb\xE9",
    tmf: "Toba-Maskoy",
    tmg: "Ternate\xF1o",
    tmh: "Tamashek",
    tmi: "Tutuba",
    tmj: "Samarokena",
    tmk: "Northwestern Tamang",
    tml: "Tamnim Citak",
    tmm: "Tai Thanh",
    tmn: "Taman (Indonesia)",
    tmo: "Temoq",
    tmq: "Tumleo",
    tmr: "Jewish Babylonian Aramaic (ca. 200-1200 CE)",
    tms: "Tima",
    tmt: "Tasmate",
    tmu: "Iau",
    tmv: "Tembo (Motembo)",
    tmw: "Temuan",
    tmy: "Tami",
    tmz: "Tamanaku",
    tna: "Tacana",
    tnb: "Western Tunebo",
    tnc: "Tanimuca-Retuar\xE3",
    tnd: "Angosturas Tunebo",
    tng: "Tobanga",
    tnh: "Maiani",
    tni: "Tandia",
    tnk: "Kwamera",
    tnl: "Lenakel",
    tnm: "Tabla",
    tnn: "North Tanna",
    tno: "Toromono",
    tnp: "Whitesands",
    tnq: "Taino",
    tnr: "M\xE9nik",
    tns: "Tenis",
    tnt: "Tontemboan",
    tnu: "Tay Khang",
    tnv: "Tangchangya",
    tnw: "Tonsawang",
    tnx: "Tanema",
    tny: "Tongwe",
    tnz: "Ten'edn",
    tob: "Toba",
    toc: "Coyutla Totonac",
    tod: "Toma",
    tof: "Gizrra",
    tog: "Tonga (Nyasa)",
    toh: "Gitonga",
    toi: "Tonga (Zambia)",
    toj: "Tojolabal",
    tol: "Tolowa",
    tom: "Tombulu",
    ton: "Tonga (Tonga Islands)",
    too: "Xicotepec De Ju\xE1rez Totonac",
    top: "Papantla Totonac",
    toq: "Toposa",
    tor: "Togbo-Vara Banda",
    tos: "Highland Totonac",
    tou: "Tho",
    tov: "Upper Taromi",
    tow: "Jemez",
    tox: "Tobian",
    toy: "Topoiyo",
    toz: "To",
    tpa: "Taupota",
    tpc: "Azoy\xFA Me'phaa",
    tpe: "Tippera",
    tpf: "Tarpia",
    tpg: "Kula",
    tpi: "Tok Pisin",
    tpj: "Tapiet\xE9",
    tpk: "Tupinikin",
    tpl: "Tlacoapa Me'phaa",
    tpm: "Tampulma",
    tpn: "Tupinamb\xE1",
    tpo: "Tai Pao",
    tpp: "Pisaflores Tepehua",
    tpq: "Tukpa",
    tpr: "Tupar\xED",
    tpt: "Tlachichilco Tepehua",
    tpu: "Tampuan",
    tpv: "Tanapag",
    tpw: "Tup\xED",
    tpx: "Acatepec Me'phaa",
    tpy: "Trumai",
    tpz: "Tinputz",
    tqb: "Temb\xE9",
    tql: "Lehali",
    tqm: "Turumsa",
    tqn: "Tenino",
    tqo: "Toaripi",
    tqp: "Tomoip",
    tqq: "Tunni",
    tqr: "Torona",
    tqt: "Western Totonac",
    tqu: "Touo",
    tqw: "Tonkawa",
    tra: "Tirahi",
    trb: "Terebu",
    trc: "Copala Triqui",
    trd: "Turi",
    tre: "East Tarangan",
    trf: "Trinidadian Creole English",
    trg: "Lish\xE1n Did\xE1n",
    trh: "Turaka",
    tri: "Tri\xF3",
    trj: "Toram",
    trl: "Traveller Scottish",
    trm: "Tregami",
    trn: "Trinitario",
    tro: "Tarao Naga",
    trp: "Kok Borok",
    trq: "San Mart\xEDn Itunyoso Triqui",
    trr: "Taushiro",
    trs: "Chicahuaxtla Triqui",
    trt: "Tunggare",
    tru: "Turoyo",
    trv: "Taroko",
    trw: "Torwali",
    trx: "Tringgus-Sembaan Bidayuh",
    try: "Turung",
    trz: "Tor\xE1",
    tsa: "Tsaangi",
    tsb: "Tsamai",
    tsc: "Tswa",
    tsd: "Tsakonian",
    tse: "Tunisian Sign Language",
    tsg: "Tausug",
    tsh: "Tsuvan",
    tsi: "Tsimshian",
    tsj: "Tshangla",
    tsk: "Tseku",
    tsl: "Ts'\xFCn-Lao",
    tsm: "Turkish Sign Language",
    tsn: "Tswana",
    tso: "Tsonga",
    tsp: "Northern Toussian",
    tsq: "Thai Sign Language",
    tsr: "Akei",
    tss: "Taiwan Sign Language",
    tst: "Tondi Songway Kiini",
    tsu: "Tsou",
    tsv: "Tsogo",
    tsw: "Tsishingini",
    tsx: "Mubami",
    tsy: "Tebul Sign Language",
    tsz: "Purepecha",
    tta: "Tutelo",
    ttb: "Gaa",
    ttc: "Tektiteko",
    ttd: "Tauade",
    tte: "Bwanabwana",
    ttf: "Tuotomb",
    ttg: "Tutong",
    tth: "Upper Ta'oih",
    tti: "Tobati",
    ttj: "Tooro",
    ttk: "Totoro",
    ttl: "Totela",
    ttm: "Northern Tutchone",
    ttn: "Towei",
    tto: "Lower Ta'oih",
    ttp: "Tombelala",
    ttq: "Tawallammat Tamajaq",
    ttr: "Tera",
    tts: "Northeastern Thai",
    ttt: "Muslim Tat",
    ttu: "Torau",
    ttv: "Titan",
    ttw: "Long Wat",
    tty: "Sikaritai",
    ttz: "Tsum",
    tua: "Wiarumus",
    tub: "T\xFCbatulabal",
    tuc: "Mutu",
    tud: "Tux\xE1",
    tue: "Tuyuca",
    tuf: "Central Tunebo",
    tug: "Tunia",
    tuh: "Taulil",
    tui: "Tupuri",
    tuj: "Tugutil",
    tuk: "Turkmen",
    tul: "Tula",
    tum: "Tumbuka",
    tun: "Tunica",
    tuo: "Tucano",
    tuq: "Tedaga",
    tur: "Turkish",
    tus: "Tuscarora",
    tuu: "Tututni",
    tuv: "Turkana",
    tux: "Tuxin\xE1wa",
    tuy: "Tugen",
    tuz: "Turka",
    tva: "Vaghua",
    tvd: "Tsuvadi",
    tve: "Te'un",
    tvk: "Southeast Ambrym",
    tvl: "Tuvalu",
    tvm: "Tela-Masbuar",
    tvn: "Tavoyan",
    tvo: "Tidore",
    tvs: "Taveta",
    tvt: "Tutsa Naga",
    tvu: "Tunen",
    tvw: "Sedoa",
    tvy: "Timor Pidgin",
    twa: "Twana",
    twb: "Western Tawbuid",
    twc: "Teshenawa",
    twd: "Twents",
    twe: "Tewa (Indonesia)",
    twf: "Northern Tiwa",
    twg: "Tereweng",
    twh: "Tai D\xF3n",
    twi: "Twi",
    twl: "Tawara",
    twm: "Tawang Monpa",
    twn: "Twendi",
    two: "Tswapong",
    twp: "Ere",
    twq: "Tasawaq",
    twr: "Southwestern Tarahumara",
    twt: "Turiw\xE1ra",
    twu: "Termanu",
    tww: "Tuwari",
    twx: "Tewe",
    twy: "Tawoyan",
    txa: "Tombonuo",
    txb: "Tokharian B",
    txc: "Tsetsaut",
    txe: "Totoli",
    txg: "Tangut",
    txh: "Thracian",
    txi: "Ikpeng",
    txj: "Tarjumo",
    txm: "Tomini",
    txn: "West Tarangan",
    txo: "Toto",
    txq: "Tii",
    txr: "Tartessian",
    txs: "Tonsea",
    txt: "Citak",
    txu: "Kayap\xF3",
    txx: "Tatana",
    txy: "Tanosy Malagasy",
    tya: "Tauya",
    tye: "Kyanga",
    tyh: "O'du",
    tyi: "Teke-Tsaayi",
    tyj: "Tai Do",
    tyl: "Thu Lao",
    tyn: "Kombai",
    typ: "Thaypan",
    tyr: "Tai Daeng",
    tys: "T\xE0y Sa Pa",
    tyt: "T\xE0y Tac",
    tyu: "Kua",
    tyv: "Tuvinian",
    tyx: "Teke-Tyee",
    tyz: "T\xE0y",
    tza: "Tanzanian Sign Language",
    tzh: "Tzeltal",
    tzj: "Tz'utujil",
    tzl: "Talossan",
    tzm: "Central Atlas Tamazight",
    tzn: "Tugun",
    tzo: "Tzotzil",
    tzx: "Tabriak",
    uam: "Uamu\xE9",
    uan: "Kuan",
    uar: "Tairuma",
    uba: "Ubang",
    ubi: "Ubi",
    ubl: "Buhi'non Bikol",
    ubr: "Ubir",
    ubu: "Umbu-Ungu",
    uby: "Ubykh",
    uda: "Uda",
    ude: "Udihe",
    udg: "Muduga",
    udi: "Udi",
    udj: "Ujir",
    udl: "Wuzlam",
    udm: "Udmurt",
    udu: "Uduk",
    ues: "Kioko",
    ufi: "Ufim",
    uga: "Ugaritic",
    ugb: "Kuku-Ugbanh",
    uge: "Ughele",
    ugn: "Ugandan Sign Language",
    ugo: "Ugong",
    ugy: "Uruguayan Sign Language",
    uha: "Uhami",
    uhn: "Damal",
    uig: "Uighur",
    uis: "Uisai",
    uiv: "Iyive",
    uji: "Tanjijili",
    uka: "Kaburi",
    ukg: "Ukuriguma",
    ukh: "Ukhwejo",
    ukk: "Muak Sa-aak",
    ukl: "Ukrainian Sign Language",
    ukp: "Ukpe-Bayobiri",
    ukq: "Ukwa",
    ukr: "Ukrainian",
    uks: "Urub\xFA-Kaapor Sign Language",
    uku: "Ukue",
    ukw: "Ukwuani-Aboh-Ndoni",
    uky: "Kuuk-Yak",
    ula: "Fungwa",
    ulb: "Ulukwumi",
    ulc: "Ulch",
    ule: "Lule",
    ulf: "Usku",
    uli: "Ulithian",
    ulk: "Meriam",
    ull: "Ullatan",
    ulm: "Ulumanda'",
    uln: "Unserdeutsch",
    ulu: "Uma' Lung",
    ulw: "Ulwa",
    uma: "Umatilla",
    umb: "Umbundu",
    umc: "Marrucinian",
    umd: "Umbindhamu",
    umg: "Umbuygamu",
    umi: "Ukit",
    umm: "Umon",
    umn: "Makyan Naga",
    umo: "Umot\xEDna",
    ump: "Umpila",
    umr: "Umbugarla",
    ums: "Pendau",
    umu: "Munsee",
    una: "North Watut",
    und: "Undetermined",
    une: "Uneme",
    ung: "Ngarinyin",
    unk: "Enawen\xE9-Naw\xE9",
    unm: "Unami",
    unn: "Kurnai",
    unr: "Mundari",
    unu: "Unubahe",
    unx: "Munda",
    unz: "Unde Kaili",
    upi: "Umeda",
    upv: "Uripiv-Wala-Rano-Atchin",
    ura: "Urarina",
    urb: "Urub\xFA-Kaapor",
    urc: "Urningangg",
    urd: "Urdu",
    ure: "Uru",
    urf: "Uradhi",
    urg: "Urigina",
    urh: "Urhobo",
    uri: "Urim",
    urk: "Urak Lawoi'",
    url: "Urali",
    urm: "Urapmin",
    urn: "Uruangnirin",
    uro: "Ura (Papua New Guinea)",
    urp: "Uru-Pa-In",
    urr: "Lehalurup",
    urt: "Urat",
    uru: "Urumi",
    urv: "Uruava",
    urw: "Sop",
    urx: "Urimo",
    ury: "Orya",
    urz: "Uru-Eu-Wau-Wau",
    usa: "Usarufa",
    ush: "Ushojo",
    usi: "Usui",
    usk: "Usaghade",
    usp: "Uspanteco",
    usu: "Uya",
    uta: "Otank",
    ute: "Ute-Southern Paiute",
    utp: "Amba (Solomon Islands)",
    utr: "Etulo",
    utu: "Utu",
    uum: "Urum",
    uun: "Kulon-Pazeh",
    uur: "Ura (Vanuatu)",
    uuu: "U",
    uve: "West Uvean",
    uvh: "Uri",
    uvl: "Lote",
    uwa: "Kuku-Uwanh",
    uya: "Doko-Uyanga",
    uzb: "Uzbek",
    uzn: "Northern Uzbek",
    uzs: "Southern Uzbek",
    vaa: "Vaagri Booli",
    vae: "Vale",
    vaf: "Vafsi",
    vag: "Vagla",
    vah: "Varhadi-Nagpuri",
    vai: "Vai",
    vaj: "Sekele",
    val: "Vehes",
    vam: "Vanimo",
    van: "Valman",
    vao: "Vao",
    vap: "Vaiphei",
    var: "Huarijio",
    vas: "Vasavi",
    vau: "Vanuma",
    vav: "Varli",
    vay: "Wayu",
    vbb: "Southeast Babar",
    vbk: "Southwestern Bontok",
    vec: "Venetian",
    ved: "Veddah",
    vel: "Veluws",
    vem: "Vemgo-Mabas",
    ven: "Venda",
    veo: "Venture\xF1o",
    vep: "Veps",
    ver: "Mom Jango",
    vgr: "Vaghri",
    vgt: "Vlaamse Gebarentaal",
    vic: "Virgin Islands Creole English",
    vid: "Vidunda",
    vie: "Vietnamese",
    vif: "Vili",
    vig: "Viemo",
    vil: "Vilela",
    vin: "Vinza",
    vis: "Vishavan",
    vit: "Viti",
    viv: "Iduna",
    vka: "Kariyarra",
    vki: "Ija-Zuba",
    vkj: "Kujarge",
    vkk: "Kaur",
    vkl: "Kulisusu",
    vkm: "Kamakan",
    vko: "Kodeoha",
    vkp: "Korlai Creole Portuguese",
    vkt: "Tenggarong Kutai Malay",
    vku: "Kurrama",
    vlp: "Valpei",
    vls: "Vlaams",
    vma: "Martuyhunira",
    vmb: "Barbaram",
    vmc: "Juxtlahuaca Mixtec",
    vmd: "Mudu Koraga",
    vme: "East Masela",
    vmf: "Mainfr\xE4nkisch",
    vmg: "Lungalunga",
    vmh: "Maraghei",
    vmi: "Miwa",
    vmj: "Ixtayutla Mixtec",
    vmk: "Makhuwa-Shirima",
    vml: "Malgana",
    vmm: "Mitlatongo Mixtec",
    vmp: "Soyaltepec Mazatec",
    vmq: "Soyaltepec Mixtec",
    vmr: "Marenje",
    vms: "Moksela",
    vmu: "Muluridyi",
    vmv: "Valley Maidu",
    vmw: "Makhuwa",
    vmx: "Tamazola Mixtec",
    vmy: "Ayautla Mazatec",
    vmz: "Mazatl\xE1n Mazatec",
    vnk: "Vano",
    vnm: "Vinmavis",
    vnp: "Vunapu",
    vol: "Volap\xFCk",
    vor: "Voro",
    vot: "Votic",
    vra: "Vera'a",
    vro: "V\xF5ro",
    vrs: "Varisi",
    vrt: "Burmbar",
    vsi: "Moldova Sign Language",
    vsl: "Venezuelan Sign Language",
    vsv: "Valencian Sign Language",
    vto: "Vitou",
    vum: "Vumbu",
    vun: "Vunjo",
    vut: "Vute",
    vwa: "Awa (China)",
    waa: "Walla Walla",
    wab: "Wab",
    wac: "Wasco-Wishram",
    wad: "Wandamen",
    wae: "Walser",
    waf: "Wakon\xE1",
    wag: "Wa'ema",
    wah: "Watubela",
    wai: "Wares",
    waj: "Waffa",
    wal: "Wolaytta",
    wam: "Wampanoag",
    wan: "Wan",
    wao: "Wappo",
    wap: "Wapishana",
    waq: "Wageman",
    war: "Waray (Philippines)",
    was: "Washo",
    wat: "Kaninuwa",
    wau: "Waur\xE1",
    wav: "Waka",
    waw: "Waiwai",
    wax: "Watam",
    way: "Wayana",
    waz: "Wampur",
    wba: "Warao",
    wbb: "Wabo",
    wbe: "Waritai",
    wbf: "Wara",
    wbh: "Wanda",
    wbi: "Vwanji",
    wbj: "Alagwa",
    wbk: "Waigali",
    wbl: "Wakhi",
    wbm: "Wa",
    wbp: "Warlpiri",
    wbq: "Waddar",
    wbr: "Wagdi",
    wbs: "West Bengal Sign Language",
    wbt: "Wanman",
    wbv: "Wajarri",
    wbw: "Woi",
    wca: "Yanom\xE1mi",
    wci: "Waci Gbe",
    wdd: "Wandji",
    wdg: "Wadaginam",
    wdj: "Wadjiginy",
    wdk: "Wadikali",
    wdu: "Wadjigu",
    wdy: "Wadjabangayi",
    wea: "Wewaw",
    wec: "W\xE8 Western",
    wed: "Wedau",
    weg: "Wergaia",
    weh: "Weh",
    wei: "Kiunum",
    wem: "Weme Gbe",
    weo: "Wemale",
    wep: "Westphalien",
    wer: "Weri",
    wes: "Cameroon Pidgin",
    wet: "Perai",
    weu: "Rawngtu Chin",
    wew: "Wejewa",
    wfg: "Yafi",
    wga: "Wagaya",
    wgb: "Wagawaga",
    wgg: "Wangganguru",
    wgi: "Wahgi",
    wgo: "Waigeo",
    wgu: "Wirangu",
    wgy: "Warrgamay",
    wha: "Sou Upaa",
    whg: "North Wahgi",
    whk: "Wahau Kenyah",
    whu: "Wahau Kayan",
    wib: "Southern Toussian",
    wic: "Wichita",
    wie: "Wik-Epa",
    wif: "Wik-Keyangan",
    wig: "Wik-Ngathana",
    wih: "Wik-Me'anha",
    wii: "Minidien",
    wij: "Wik-Iiyanh",
    wik: "Wikalkan",
    wil: "Wilawila",
    wim: "Wik-Mungkan",
    win: "Ho-Chunk",
    wir: "Wiraf\xE9d",
    wiu: "Wiru",
    wiv: "Vitu",
    wiy: "Wiyot",
    wja: "Waja",
    wji: "Warji",
    wka: "Kw'adza",
    wkb: "Kumbaran",
    wkd: "Wakde",
    wkl: "Kalanadi",
    wku: "Kunduvadi",
    wkw: "Wakawaka",
    wky: "Wangkayutyuru",
    wla: "Walio",
    wlc: "Mwali Comorian",
    wle: "Wolane",
    wlg: "Kunbarlang",
    wli: "Waioli",
    wlk: "Wailaki",
    wll: "Wali (Sudan)",
    wlm: "Middle Welsh",
    wln: "Walloon",
    wlo: "Wolio",
    wlr: "Wailapa",
    wls: "Wallisian",
    wlu: "Wuliwuli",
    wlv: "Wich\xED Lhamt\xE9s Vejoz",
    wlw: "Walak",
    wlx: "Wali (Ghana)",
    wly: "Waling",
    wma: "Mawa (Nigeria)",
    wmb: "Wambaya",
    wmc: "Wamas",
    wmd: "Mamaind\xE9",
    wme: "Wambule",
    wmh: "Waima'a",
    wmi: "Wamin",
    wmm: "Maiwa (Indonesia)",
    wmn: "Waamwang",
    wmo: "Wom (Papua New Guinea)",
    wms: "Wambon",
    wmt: "Walmajarri",
    wmw: "Mwani",
    wmx: "Womo",
    wnb: "Wanambre",
    wnc: "Wantoat",
    wnd: "Wandarang",
    wne: "Waneci",
    wng: "Wanggom",
    wni: "Ndzwani Comorian",
    wnk: "Wanukaka",
    wnm: "Wanggamala",
    wnn: "Wunumara",
    wno: "Wano",
    wnp: "Wanap",
    wnu: "Usan",
    wnw: "Wintu",
    wny: "Wanyi",
    woa: "Tyaraity",
    wob: "W\xE8 Northern",
    woc: "Wogeo",
    wod: "Wolani",
    woe: "Woleaian",
    wof: "Gambian Wolof",
    wog: "Wogamusin",
    woi: "Kamang",
    wok: "Longto",
    wol: "Wolof",
    wom: "Wom (Nigeria)",
    won: "Wongo",
    woo: "Manombai",
    wor: "Woria",
    wos: "Hanga Hundi",
    wow: "Wawonii",
    woy: "Weyto",
    wpc: "Maco",
    wra: "Warapu",
    wrb: "Warluwara",
    wrd: "Warduji",
    wrg: "Warungu",
    wrh: "Wiradhuri",
    wri: "Wariyangga",
    wrk: "Garrwa",
    wrl: "Warlmanpa",
    wrm: "Warumungu",
    wrn: "Warnang",
    wro: "Worrorra",
    wrp: "Waropen",
    wrr: "Wardaman",
    wrs: "Waris",
    wru: "Waru",
    wrv: "Waruna",
    wrw: "Gugu Warra",
    wrx: "Wae Rana",
    wry: "Merwari",
    wrz: "Waray (Australia)",
    wsa: "Warembori",
    wsg: "Adilabad Gondi",
    wsi: "Wusi",
    wsk: "Waskia",
    wsr: "Owenia",
    wss: "Wasa",
    wsu: "Wasu",
    wsv: "Wotapuri-Katarqalai",
    wtf: "Watiwa",
    wth: "Wathawurrung",
    wti: "Berta",
    wtk: "Watakataui",
    wtm: "Mewati",
    wtw: "Wotu",
    wua: "Wikngenchera",
    wub: "Wunambal",
    wud: "Wudu",
    wuh: "Wutunhua",
    wul: "Silimo",
    wum: "Wumbvu",
    wun: "Bungu",
    wur: "Wurrugu",
    wut: "Wutung",
    wuu: "Wu Chinese",
    wuv: "Wuvulu-Aua",
    wux: "Wulna",
    wuy: "Wauyai",
    wwa: "Waama",
    wwb: "Wakabunga",
    wwo: "Wetamut",
    wwr: "Warrwa",
    www: "Wawa",
    wxa: "Waxianghua",
    wxw: "Wardandi",
    wya: "Wyandot",
    wyb: "Wangaaybuwan-Ngiyambaa",
    wyi: "Woiwurrung",
    wym: "Wymysorys",
    wyr: "Wayor\xF3",
    wyy: "Western Fijian",
    xaa: "Andalusian Arabic",
    xab: "Sambe",
    xac: "Kachari",
    xad: "Adai",
    xae: "Aequian",
    xag: "Aghwan",
    xai: "Kaimb\xE9",
    xaj: "Ararandew\xE1ra",
    xak: "M\xE1ku",
    xal: "Kalmyk",
    xam: "/Xam",
    xan: "Xamtanga",
    xao: "Khao",
    xap: "Apalachee",
    xaq: "Aquitanian",
    xar: "Karami",
    xas: "Kamas",
    xat: "Katawixi",
    xau: "Kauwera",
    xav: "Xav\xE1nte",
    xaw: "Kawaiisu",
    xay: "Kayan Mahakam",
    xbb: "Lower Burdekin",
    xbc: "Bactrian",
    xbd: "Bindal",
    xbe: "Bigambal",
    xbg: "Bunganditj",
    xbi: "Kombio",
    xbj: "Birrpayi",
    xbm: "Middle Breton",
    xbn: "Kenaboi",
    xbo: "Bolgarian",
    xbp: "Bibbulman",
    xbr: "Kambera",
    xbw: "Kambiw\xE1",
    xby: "Batyala",
    xcb: "Cumbric",
    xcc: "Camunic",
    xce: "Celtiberian",
    xcg: "Cisalpine Gaulish",
    xch: "Chemakum",
    xcl: "Classical Armenian",
    xcm: "Comecrudo",
    xcn: "Cotoname",
    xco: "Chorasmian",
    xcr: "Carian",
    xct: "Classical Tibetan",
    xcu: "Curonian",
    xcv: "Chuvantsy",
    xcw: "Coahuilteco",
    xcy: "Cayuse",
    xda: "Darkinyung",
    xdc: "Dacian",
    xdk: "Dharuk",
    xdm: "Edomite",
    xdo: "Kwandu",
    xdy: "Malayic Dayak",
    xeb: "Eblan",
    xed: "Hdi",
    xeg: "//Xegwi",
    xel: "Kelo",
    xem: "Kembayan",
    xep: "Epi-Olmec",
    xer: "Xer\xE9nte",
    xes: "Kesawai",
    xet: "Xet\xE1",
    xeu: "Keoru-Ahia",
    xfa: "Faliscan",
    xga: "Galatian",
    xgb: "Gbin",
    xgd: "Gudang",
    xgf: "Gabrielino-Fernande\xF1o",
    xgg: "Goreng",
    xgi: "Garingbal",
    xgl: "Galindan",
    xgm: "Dharumbal",
    xgr: "Garza",
    xgu: "Unggumi",
    xgw: "Guwa",
    xha: "Harami",
    xhc: "Hunnic",
    xhd: "Hadrami",
    xhe: "Khetrani",
    xho: "Xhosa",
    xhr: "Hernican",
    xht: "Hattic",
    xhu: "Hurrian",
    xhv: "Khua",
    xib: "Iberian",
    xii: "Xiri",
    xil: "Illyrian",
    xin: "Xinca",
    xir: "Xiri\xE2na",
    xis: "Kisan",
    xiv: "Indus Valley Language",
    xiy: "Xipaya",
    xjb: "Minjungbal",
    xjt: "Jaitmatang",
    xka: "Kalkoti",
    xkb: "Northern Nago",
    xkc: "Kho'ini",
    xkd: "Mendalam Kayan",
    xke: "Kereho",
    xkf: "Khengkha",
    xkg: "Kagoro",
    xki: "Kenyan Sign Language",
    xkj: "Kajali",
    xkk: "Kaco'",
    xkl: "Mainstream Kenyah",
    xkn: "Kayan River Kayan",
    xko: "Kiorr",
    xkp: "Kabatei",
    xkq: "Koroni",
    xkr: "Xakriab\xE1",
    xks: "Kumbewaha",
    xkt: "Kantosi",
    xku: "Kaamba",
    xkv: "Kgalagadi",
    xkw: "Kembra",
    xkx: "Karore",
    xky: "Uma' Lasan",
    xkz: "Kurtokha",
    xla: "Kamula",
    xlb: "Loup B",
    xlc: "Lycian",
    xld: "Lydian",
    xle: "Lemnian",
    xlg: "Ligurian (Ancient)",
    xli: "Liburnian",
    xln: "Alanic",
    xlo: "Loup A",
    xlp: "Lepontic",
    xls: "Lusitanian",
    xlu: "Cuneiform Luwian",
    xly: "Elymian",
    xma: "Mushungulu",
    xmb: "Mbonga",
    xmc: "Makhuwa-Marrevone",
    xmd: "Mbudum",
    xme: "Median",
    xmf: "Mingrelian",
    xmg: "Mengaka",
    xmh: "Kuku-Muminh",
    xmj: "Majera",
    xmk: "Ancient Macedonian",
    xml: "Malaysian Sign Language",
    xmm: "Manado Malay",
    xmn: "Manichaean Middle Persian",
    xmo: "Morerebi",
    xmp: "Kuku-Mu'inh",
    xmq: "Kuku-Mangk",
    xmr: "Meroitic",
    xms: "Moroccan Sign Language",
    xmt: "Matbat",
    xmu: "Kamu",
    xmv: "Antankarana Malagasy",
    xmw: "Tsimihety Malagasy",
    xmx: "Maden",
    xmy: "Mayaguduna",
    xmz: "Mori Bawah",
    xna: "Ancient North Arabian",
    xnb: "Kanakanabu",
    xng: "Middle Mongolian",
    xnh: "Kuanhua",
    xni: "Ngarigu",
    xnk: "Nganakarti",
    xnn: "Northern Kankanay",
    xno: "Anglo-Norman",
    xnr: "Kangri",
    xns: "Kanashi",
    xnt: "Narragansett",
    xnu: "Nukunul",
    xny: "Nyiyaparli",
    xnz: "Kenzi",
    xoc: "O'chi'chi'",
    xod: "Kokoda",
    xog: "Soga",
    xoi: "Kominimung",
    xok: "Xokleng",
    xom: "Komo (Sudan)",
    xon: "Konkomba",
    xoo: "Xukur\xFA",
    xop: "Kopar",
    xor: "Korubo",
    xow: "Kowaki",
    xpa: "Pirriya",
    xpc: "Pecheneg",
    xpe: "Liberia Kpelle",
    xpg: "Phrygian",
    xpi: "Pictish",
    xpj: "Mpalitjanh",
    xpk: "Kulina Pano",
    xpm: "Pumpokol",
    xpn: "Kapinaw\xE1",
    xpo: "Pochutec",
    xpp: "Puyo-Paekche",
    xpq: "Mohegan-Pequot",
    xpr: "Parthian",
    xps: "Pisidian",
    xpt: "Punthamara",
    xpu: "Punic",
    xpy: "Puyo",
    xqa: "Karakhanid",
    xqt: "Qatabanian",
    xra: "Krah\xF4",
    xrb: "Eastern Karaboro",
    xrd: "Gundungurra",
    xre: "Kreye",
    xrg: "Minang",
    xri: "Krikati-Timbira",
    xrm: "Armazic",
    xrn: "Arin",
    xrq: "Karranga",
    xrr: "Raetic",
    xrt: "Aranama-Tamique",
    xru: "Marriammu",
    xrw: "Karawa",
    xsa: "Sabaean",
    xsb: "Sambal",
    xsc: "Scythian",
    xsd: "Sidetic",
    xse: "Sempan",
    xsh: "Shamang",
    xsi: "Sio",
    xsl: "South Slavey",
    xsm: "Kasem",
    xsn: "Sanga (Nigeria)",
    xso: "Solano",
    xsp: "Silopi",
    xsq: "Makhuwa-Saka",
    xsr: "Sherpa",
    xss: "Assan",
    xsu: "Sanum\xE1",
    xsv: "Sudovian",
    xsy: "Saisiyat",
    xta: "Alcozauca Mixtec",
    xtb: "Chazumba Mixtec",
    xtc: "Katcha-Kadugli-Miri",
    xtd: "Diuxi-Tilantongo Mixtec",
    xte: "Ketengban",
    xtg: "Transalpine Gaulish",
    xth: "Yitha Yitha",
    xti: "Sinicahua Mixtec",
    xtj: "San Juan Teita Mixtec",
    xtl: "Tijaltepec Mixtec",
    xtm: "Magdalena Pe\xF1asco Mixtec",
    xtn: "Northern Tlaxiaco Mixtec",
    xto: "Tokharian A",
    xtp: "San Miguel Piedras Mixtec",
    xtq: "Tumshuqese",
    xtr: "Early Tripuri",
    xts: "Sindihui Mixtec",
    xtt: "Tacahua Mixtec",
    xtu: "Cuyamecalco Mixtec",
    xtv: "Thawa",
    xtw: "Tawand\xEA",
    xty: "Yoloxochitl Mixtec",
    xtz: "Tasmanian",
    xua: "Alu Kurumba",
    xub: "Betta Kurumba",
    xud: "Umiida",
    xug: "Kunigami",
    xuj: "Jennu Kurumba",
    xul: "Ngunawal",
    xum: "Umbrian",
    xun: "Unggaranggu",
    xuo: "Kuo",
    xup: "Upper Umpqua",
    xur: "Urartian",
    xut: "Kuthant",
    xuu: "Kxoe",
    xve: "Venetic",
    xvi: "Kamviri",
    xvn: "Vandalic",
    xvo: "Volscian",
    xvs: "Vestinian",
    xwa: "Kwaza",
    xwc: "Woccon",
    xwd: "Wadi Wadi",
    xwe: "Xwela Gbe",
    xwg: "Kwegu",
    xwj: "Wajuk",
    xwk: "Wangkumara",
    xwl: "Western Xwla Gbe",
    xwo: "Written Oirat",
    xwr: "Kwerba Mamberamo",
    xwt: "Wotjobaluk",
    xww: "Wemba Wemba",
    xxb: "Boro (Ghana)",
    xxk: "Ke'o",
    xxm: "Minkin",
    xxr: "Korop\xF3",
    xxt: "Tambora",
    xya: "Yaygir",
    xyb: "Yandjibara",
    xyj: "Mayi-Yapi",
    xyk: "Mayi-Kulan",
    xyl: "Yalakalore",
    xyt: "Mayi-Thakurti",
    xyy: "Yorta Yorta",
    xzh: "Zhang-Zhung",
    xzm: "Zemgalian",
    xzp: "Ancient Zapotec",
    yaa: "Yaminahua",
    yab: "Yuhup",
    yac: "Pass Valley Yali",
    yad: "Yagua",
    yae: "Pum\xE9",
    yaf: "Yaka (Democratic Republic of Congo)",
    yag: "Y\xE1mana",
    yah: "Yazgulyam",
    yai: "Yagnobi",
    yaj: "Banda-Yangere",
    yak: "Yakama",
    yal: "Yalunka",
    yam: "Yamba",
    yan: "Mayangna",
    yao: "Yao",
    yap: "Yapese",
    yaq: "Yaqui",
    yar: "Yabarana",
    yas: "Nugunu (Cameroon)",
    yat: "Yambeta",
    yau: "Yuwana",
    yav: "Yangben",
    yaw: "Yawalapit\xED",
    yax: "Yauma",
    yay: "Agwagwune",
    yaz: "Lokaa",
    yba: "Yala",
    ybb: "Yemba",
    ybe: "West Yugur",
    ybh: "Yakha",
    ybi: "Yamphu",
    ybj: "Hasha",
    ybk: "Bokha",
    ybl: "Yukuben",
    ybm: "Yaben",
    ybn: "Yaba\xE2na",
    ybo: "Yabong",
    ybx: "Yawiyo",
    yby: "Yaweyuha",
    ych: "Chesu",
    ycl: "Lolopo",
    ycn: "Yucuna",
    ycp: "Chepya",
    yda: "Yanda",
    ydd: "Eastern Yiddish",
    yde: "Yangum Dey",
    ydg: "Yidgha",
    ydk: "Yoidik",
    yea: "Ravula",
    yec: "Yeniche",
    yee: "Yimas",
    yei: "Yeni",
    yej: "Yevanic",
    yel: "Yela",
    yer: "Tarok",
    yes: "Nyankpa",
    yet: "Yetfa",
    yeu: "Yerukula",
    yev: "Yapunda",
    yey: "Yeyi",
    yga: "Malyangapa",
    ygi: "Yiningayi",
    ygl: "Yangum Gel",
    ygm: "Yagomi",
    ygp: "Gepo",
    ygr: "Yagaria",
    ygs: "Yol\u014Bu Sign Language",
    ygu: "Yugul",
    ygw: "Yagwoia",
    yha: "Baha Buyang",
    yhd: "Judeo-Iraqi Arabic",
    yhl: "Hlepho Phowa",
    yhs: "Yan-nha\u014Bu Sign Language",
    yia: "Yinggarda",
    yid: "Yiddish",
    yif: "Ache",
    yig: "Wusa Nasu",
    yih: "Western Yiddish",
    yii: "Yidiny",
    yij: "Yindjibarndi",
    yik: "Dongshanba Lalo",
    yil: "Yindjilandji",
    yim: "Yimchungru Naga",
    yin: "Yinchia",
    yip: "Pholo",
    yiq: "Miqie",
    yir: "North Awyu",
    yis: "Yis",
    yit: "Eastern Lalu",
    yiu: "Awu",
    yiv: "Northern Nisu",
    yix: "Axi Yi",
    yiz: "Azhe",
    yka: "Yakan",
    ykg: "Northern Yukaghir",
    yki: "Yoke",
    ykk: "Yakaikeke",
    ykl: "Khlula",
    ykm: "Kap",
    ykn: "Kua-nsi",
    yko: "Yasa",
    ykr: "Yekora",
    ykt: "Kathu",
    yku: "Kuamasi",
    yky: "Yakoma",
    yla: "Yaul",
    ylb: "Yaleba",
    yle: "Yele",
    ylg: "Yelogu",
    yli: "Angguruk Yali",
    yll: "Yil",
    ylm: "Limi",
    yln: "Langnian Buyang",
    ylo: "Naluo Yi",
    ylr: "Yalarnnga",
    ylu: "Aribwaung",
    yly: "Ny\xE2layu",
    ymb: "Yambes",
    ymc: "Southern Muji",
    ymd: "Muda",
    yme: "Yameo",
    ymg: "Yamongeri",
    ymh: "Mili",
    ymi: "Moji",
    ymk: "Makwe",
    yml: "Iamalele",
    ymm: "Maay",
    ymn: "Yamna",
    ymo: "Yangum Mon",
    ymp: "Yamap",
    ymq: "Qila Muji",
    ymr: "Malasar",
    yms: "Mysian",
    ymx: "Northern Muji",
    ymz: "Muzi",
    yna: "Aluo",
    ynd: "Yandruwandha",
    yne: "Lang'e",
    yng: "Yango",
    ynk: "Naukan Yupik",
    ynl: "Yangulam",
    ynn: "Yana",
    yno: "Yong",
    ynq: "Yendang",
    yns: "Yansi",
    ynu: "Yahuna",
    yob: "Yoba",
    yog: "Yogad",
    yoi: "Yonaguni",
    yok: "Yokuts",
    yol: "Yola",
    yom: "Yombe",
    yon: "Yongkom",
    yor: "Yoruba",
    yot: "Yotti",
    yox: "Yoron",
    yoy: "Yoy",
    ypa: "Phala",
    ypb: "Labo Phowa",
    ypg: "Phola",
    yph: "Phupha",
    ypm: "Phuma",
    ypn: "Ani Phowa",
    ypo: "Alo Phola",
    ypp: "Phupa",
    ypz: "Phuza",
    yra: "Yerakai",
    yrb: "Yareba",
    yre: "Yaour\xE9",
    yrk: "Nenets",
    yrl: "Nhengatu",
    yrm: "Yirrk-Mel",
    yrn: "Yerong",
    yro: "Yaroam\xEB",
    yrs: "Yarsun",
    yrw: "Yarawata",
    yry: "Yarluyandi",
    ysc: "Yassic",
    ysd: "Samatao",
    ysg: "Sonaga",
    ysl: "Yugoslavian Sign Language",
    ysn: "Sani",
    yso: "Nisi (China)",
    ysp: "Southern Lolopo",
    ysr: "Sirenik Yupik",
    yss: "Yessan-Mayo",
    ysy: "Sanie",
    yta: "Talu",
    ytl: "Tanglang",
    ytp: "Thopho",
    ytw: "Yout Wam",
    yty: "Yatay",
    yua: "Yucateco",
    yub: "Yugambal",
    yuc: "Yuchi",
    yud: "Judeo-Tripolitanian Arabic",
    yue: "Yue Chinese",
    yuf: "Havasupai-Walapai-Yavapai",
    yug: "Yug",
    yui: "Yurut\xED",
    yuj: "Karkar-Yuri",
    yuk: "Yuki",
    yul: "Yulu",
    yum: "Quechan",
    yun: "Bena (Nigeria)",
    yup: "Yukpa",
    yuq: "Yuqui",
    yur: "Yurok",
    yut: "Yopno",
    yuw: "Yau (Morobe Province)",
    yux: "Southern Yukaghir",
    yuy: "East Yugur",
    yuz: "Yuracare",
    yva: "Yawa",
    yvt: "Yavitero",
    ywa: "Kalou",
    ywg: "Yinhawangka",
    ywl: "Western Lalu",
    ywn: "Yawanawa",
    ywq: "Wuding-Luquan Yi",
    ywr: "Yawuru",
    ywt: "Xishanba Lalo",
    ywu: "Wumeng Nasu",
    yww: "Yawarawarga",
    yxa: "Mayawali",
    yxg: "Yagara",
    yxl: "Yardliyawarra",
    yxm: "Yinwum",
    yxu: "Yuyu",
    yxy: "Yabula Yabula",
    yyr: "Yir Yoront",
    yyu: "Yau (Sandaun Province)",
    yyz: "Ayizi",
    yzg: "E'ma Buyang",
    yzk: "Zokhuo",
    zaa: "Sierra de Ju\xE1rez Zapotec",
    zab: "Western Tlacolula Valley Zapotec",
    zac: "Ocotl\xE1n Zapotec",
    zad: "Cajonos Zapotec",
    zae: "Yareni Zapotec",
    zaf: "Ayoquesco Zapotec",
    zag: "Zaghawa",
    zah: "Zangwal",
    zai: "Isthmus Zapotec",
    zaj: "Zaramo",
    zak: "Zanaki",
    zal: "Zauzou",
    zam: "Miahuatl\xE1n Zapotec",
    zao: "Ozolotepec Zapotec",
    zap: "Zapotec",
    zaq: "Alo\xE1pam Zapotec",
    zar: "Rinc\xF3n Zapotec",
    zas: "Santo Domingo Albarradas Zapotec",
    zat: "Tabaa Zapotec",
    zau: "Zangskari",
    zav: "Yatzachi Zapotec",
    zaw: "Mitla Zapotec",
    zax: "Xadani Zapotec",
    zay: "Zayse-Zergulla",
    zaz: "Zari",
    zbc: "Central Berawan",
    zbe: "East Berawan",
    zbl: "Blissymbols",
    zbt: "Batui",
    zbw: "West Berawan",
    zca: "Coatecas Altas Zapotec",
    zch: "Central Hongshuihe Zhuang",
    zdj: "Ngazidja Comorian",
    zea: "Zeeuws",
    zeg: "Zenag",
    zeh: "Eastern Hongshuihe Zhuang",
    zen: "Zenaga",
    zga: "Kinga",
    zgb: "Guibei Zhuang",
    zgh: "Standard Moroccan Tamazight",
    zgm: "Minz Zhuang",
    zgn: "Guibian Zhuang",
    zgr: "Magori",
    zha: "Zhuang",
    zhb: "Zhaba",
    zhd: "Dai Zhuang",
    zhi: "Zhire",
    zhn: "Nong Zhuang",
    zho: "Chinese",
    zhw: "Zhoa",
    zia: "Zia",
    zib: "Zimbabwe Sign Language",
    zik: "Zimakani",
    zil: "Zialo",
    zim: "Mesme",
    zin: "Zinza",
    zir: "Ziriya",
    ziw: "Zigula",
    ziz: "Zizilivakan",
    zka: "Kaimbulawa",
    zkb: "Koibal",
    zkd: "Kadu",
    zkg: "Koguryo",
    zkh: "Khorezmian",
    zkk: "Karankawa",
    zkn: "Kanan",
    zko: "Kott",
    zkp: "S\xE3o Paulo Kaing\xE1ng",
    zkr: "Zakhring",
    zkt: "Kitan",
    zku: "Kaurna",
    zkv: "Krevinian",
    zkz: "Khazar",
    zlj: "Liujiang Zhuang",
    zlm: "Malay (individual language)",
    zln: "Lianshan Zhuang",
    zlq: "Liuqian Zhuang",
    zma: "Manda (Australia)",
    zmb: "Zimba",
    zmc: "Margany",
    zmd: "Maridan",
    zme: "Mangerr",
    zmf: "Mfinu",
    zmg: "Marti Ke",
    zmh: "Makolkol",
    zmi: "Negeri Sembilan Malay",
    zmj: "Maridjabin",
    zmk: "Mandandanyi",
    zml: "Madngele",
    zmm: "Marimanindji",
    zmn: "Mbangwe",
    zmo: "Molo",
    zmp: "Mpuono",
    zmq: "Mituku",
    zmr: "Maranunggu",
    zms: "Mbesa",
    zmt: "Maringarr",
    zmu: "Muruwari",
    zmv: "Mbariman-Gudhinma",
    zmw: "Mbo (Democratic Republic of Congo)",
    zmx: "Bomitaba",
    zmy: "Mariyedi",
    zmz: "Mbandja",
    zna: "Zan Gula",
    zne: "Zande (individual language)",
    zng: "Mang",
    znk: "Manangkari",
    zns: "Mangas",
    zoc: "Copainal\xE1 Zoque",
    zoh: "Chimalapa Zoque",
    zom: "Zou",
    zoo: "Asunci\xF3n Mixtepec Zapotec",
    zoq: "Tabasco Zoque",
    zor: "Ray\xF3n Zoque",
    zos: "Francisco Le\xF3n Zoque",
    zpa: "Lachiguiri Zapotec",
    zpb: "Yautepec Zapotec",
    zpc: "Choapan Zapotec",
    zpd: "Southeastern Ixtl\xE1n Zapotec",
    zpe: "Petapa Zapotec",
    zpf: "San Pedro Quiatoni Zapotec",
    zpg: "Guevea De Humboldt Zapotec",
    zph: "Totomachapan Zapotec",
    zpi: "Santa Mar\xEDa Quiegolani Zapotec",
    zpj: "Quiavicuzas Zapotec",
    zpk: "Tlacolulita Zapotec",
    zpl: "Lachix\xEDo Zapotec",
    zpm: "Mixtepec Zapotec",
    zpn: "Santa In\xE9s Yatzechi Zapotec",
    zpo: "Amatl\xE1n Zapotec",
    zpp: "El Alto Zapotec",
    zpq: "Zoogocho Zapotec",
    zpr: "Santiago Xanica Zapotec",
    zps: "Coatl\xE1n Zapotec",
    zpt: "San Vicente Coatl\xE1n Zapotec",
    zpu: "Yal\xE1lag Zapotec",
    zpv: "Chichicapan Zapotec",
    zpw: "Zaniza Zapotec",
    zpx: "San Baltazar Loxicha Zapotec",
    zpy: "Mazaltepec Zapotec",
    zpz: "Texmelucan Zapotec",
    zqe: "Qiubei Zhuang",
    zra: "Kara (Korea)",
    zrg: "Mirgan",
    zrn: "Zerenkel",
    zro: "Z\xE1paro",
    zrp: "Zarphatic",
    zrs: "Mairasi",
    zsa: "Sarasira",
    zsk: "Kaskean",
    zsl: "Zambian Sign Language",
    zsm: "Standard Malay",
    zsr: "Southern Rincon Zapotec",
    zsu: "Sukurum",
    zte: "Elotepec Zapotec",
    ztg: "Xanagu\xEDa Zapotec",
    ztl: "Lapagu\xEDa-Guivini Zapotec",
    ztm: "San Agust\xEDn Mixtepec Zapotec",
    ztn: "Santa Catarina Albarradas Zapotec",
    ztp: "Loxicha Zapotec",
    ztq: "Quioquitani-Quier\xED Zapotec",
    zts: "Tilquiapan Zapotec",
    ztt: "Tejalapan Zapotec",
    ztu: "G\xFCil\xE1 Zapotec",
    ztx: "Zaachila Zapotec",
    zty: "Yatee Zapotec",
    zua: "Zeem",
    zuh: "Tokano",
    zul: "Zulu",
    zum: "Kumzari",
    zun: "Zuni",
    zuy: "Zumaya",
    zwa: "Zay",
    zxx: "No linguistic content",
    zyb: "Yongbei Zhuang",
    zyg: "Yang Zhuang",
    zyj: "Youjiang Zhuang",
    zyn: "Yongnan Zhuang",
    zyp: "Zyphe Chin",
    zza: "Zaza",
    zzj: "Zuojiang Zhuang"
  };

  // demo/scripts/lib/translateLanguageCode.ts
  function translateLanguageCode(langCode) {
    var _a;
    if (!langCode) {
      return "unknown";
    }
    return (_a = languages_default2[langCode.toLowerCase()]) != null ? _a : langCode;
  }

  // demo/scripts/controllers/knobs/AudioTrack.tsx
  var AUDIO_DESCRIPTION_ICON = "(AD)";
  function findAudioTrackIndex(audioTrack, audioTracks) {
    return audioTracks.findIndex((ln) => ln.id === audioTrack.id);
  }
  function AudioTrackKnob({
    player,
    className
  }) {
    const currentAudioTrack = useModuleState(player, "audioTrack");
    const availableAudioTracks = useModuleState(player, "availableAudioTracks");
    const [options, selectedIndex] = React39.useMemo(() => {
      if (availableAudioTracks.length === 0) {
        return [["Not available"], 0];
      }
      return [
        availableAudioTracks.map((audioTrack) => {
          return translateLanguageCode(audioTrack.normalized) + (audioTrack.audioDescription ? " " + AUDIO_DESCRIPTION_ICON : "");
        }),
        currentAudioTrack ? Math.max(findAudioTrackIndex(currentAudioTrack, availableAudioTracks), 0) : 0
      ];
    }, [availableAudioTracks, currentAudioTrack]);
    const onAudioTrackChange = React39.useCallback(
      ({ index }) => {
        const track = availableAudioTracks[index];
        if (track !== void 0) {
          player.actions.setAudioTrack(track);
        } else {
          console.error("Error: audio track not found");
        }
      },
      [availableAudioTracks, player]
    );
    return /* @__PURE__ */ React39.createElement(
      Knob_default,
      {
        name: "Audio AudioTrack",
        ariaLabel: "Update the audio track",
        className,
        disabled: availableAudioTracks.length < 2,
        onChange: onAudioTrackChange,
        options,
        selected: { index: selectedIndex, value: void 0 }
      }
    );
  }
  var AudioTrack_default = React39.memo(AudioTrackKnob);

  // demo/scripts/controllers/knobs/Subtitles.tsx
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var React40 = __toESM(require_react());
  var CLOSED_CAPTION_ICON = "(CC)";
  function findSubtitlesIndex(language, languages) {
    return languages.findIndex((ln) => ln.id === language.id);
  }
  function SubtitlesKnob({
    player,
    className
  }) {
    const currentSubtitle = useModuleState(player, "subtitle");
    const availableSubtitles = useModuleState(player, "availableSubtitles");
    const options = React40.useMemo(() => {
      return [
        "no subtitles",
        ...availableSubtitles.map((subtitle) => {
          return translateLanguageCode(subtitle.normalized) + (subtitle.closedCaption ? " " + CLOSED_CAPTION_ICON : "");
        })
      ];
    }, [availableSubtitles]);
    const currentLanguageIndex = currentSubtitle ? findSubtitlesIndex(currentSubtitle, availableSubtitles) + 1 : 0;
    const onSubtitlesChange = React40.useCallback(
      ({ index }) => {
        if (index > 0) {
          const track = availableSubtitles[index - 1];
          if (track !== void 0) {
            player.actions.setTextTrack(track);
          } else {
            console.error("Error: subtitles track not found");
          }
        } else {
          player.actions.disableSubtitlesTrack();
        }
      },
      [availableSubtitles, player]
    );
    return /* @__PURE__ */ React40.createElement(
      Knob_default,
      {
        name: "Subtitles Track",
        ariaLabel: "Update the current subtitles",
        className,
        disabled: options.length <= 1,
        onChange: onSubtitlesChange,
        options,
        selected: { index: currentLanguageIndex, value: void 0 }
      }
    );
  }
  var Subtitles_default = React40.memo(SubtitlesKnob);

  // demo/scripts/controllers/knobs/VideoTrack.tsx
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var React41 = __toESM(require_react());
  function findVideoTrackIndex(videoTrack, availableVideoTracks) {
    return availableVideoTracks.findIndex((t) => t.id === videoTrack.id);
  }
  function VideoTrackKnob({
    player,
    className
  }) {
    const currentVideoTrack = useModuleState(player, "videoTrack");
    const availableVideoTracks = useModuleState(player, "availableVideoTracks");
    const [options, selectedIndex] = React41.useMemo(() => {
      if (availableVideoTracks.length === 0) {
        return [["Not available"], 0];
      }
      return [
        ["no video track"].concat(
          availableVideoTracks.map((track, i) => `track ${i}: ${track.id}`)
        ),
        currentVideoTrack != null ? 1 + findVideoTrackIndex(currentVideoTrack, availableVideoTracks) : 0
      ];
    }, [currentVideoTrack, availableVideoTracks]);
    const onVideoTrackChange = React41.useCallback(
      ({ index }) => {
        if (index > 0) {
          const track = availableVideoTracks[index - 1];
          if (track !== void 0) {
            player.actions.setVideoTrack(track);
          } else {
            console.error("Error: video track not found");
          }
        } else {
          player.actions.disableVideoTrack();
        }
      },
      [availableVideoTracks, player]
    );
    return /* @__PURE__ */ React41.createElement(
      Knob_default,
      {
        name: "Video Track",
        ariaLabel: "Update the video track",
        className,
        disabled: options.length <= 1,
        onChange: onVideoTrackChange,
        options,
        selected: { index: selectedIndex, value: void 0 }
      }
    );
  }
  var VideoTrack_default = React41.memo(VideoTrackKnob);

  // demo/scripts/controllers/knobs/SpeedKnob.tsx
  init_define_ENVIRONMENT();
  init_define_LOGGER_LEVEL();
  var React42 = __toESM(require_react());
  var AVAILABLE_RATES = [0.25, 0.5, 0.75, 1, 1.25, 1.5, 1.75, 2, 2.5, 3];
  var ALIASES = { 1: "Normal" };
  var OPTIONS = AVAILABLE_RATES.map((rate) => {
    var _a;
    return (_a = ALIASES[rate]) != null ? _a : String(rate);
  });
  function SpeedKnob({
    player,
    className
  }) {
    const playbackRate = useModuleState(player, "playbackRate");
    let selectedIndex = AVAILABLE_RATES.findIndex((rate) => playbackRate === rate);
    const onPlaybackRateChange = React42.useCallback(
      ({ index }) => {
        if (index > -1) {
          selectedIndex = index;
          const rate = AVAILABLE_RATES[index];
          if (rate !== void 0) {
            player.actions.setPlaybackRate(rate);
          } else {
            console.error("Error: playback rate not found");
          }
        }
      },
      [player]
    );
    return /* @__PURE__ */ React42.createElement(
      Knob_default,
      {
        className,
        ariaLabel: "Update the current playback speed",
        name: "Playback Rate",
        disabled: OPTIONS.length < 2,
        onChange: onPlaybackRateChange,
        options: OPTIONS,
        selected: { index: selectedIndex, value: void 0 }
      }
    );
  }
  var SpeedKnob_default = React42.memo(SpeedKnob);

  // demo/scripts/controllers/PlayerKnobsSettings.tsx
  function PlayerKnobsSettings({
    shouldDisplay,
    close,
    player
  }) {
    const lowLatencyMode = useModuleState(player, "lowLatencyMode");
    const isContentLoaded = useModuleState(player, "isContentLoaded");
    if (!isContentLoaded) {
      return null;
    }
    const className = "player-knobs settings" + (shouldDisplay ? " fade-in-out" : "");
    return /* @__PURE__ */ React43.createElement("div", { className }, /* @__PURE__ */ React43.createElement("div", { className: "player-knobs-header" }, /* @__PURE__ */ React43.createElement("span", { className: "player-knobs-title" }, "Settings"), /* @__PURE__ */ React43.createElement(
      "span",
      {
        className: "player-knobs-close",
        onKeyDown: (evt) => {
          if (evt.keyCode === 13 || evt.code === "Enter") {
            close();
          }
        },
        onClick: close
      },
      String.fromCharCode(61453)
    )), /* @__PURE__ */ React43.createElement("div", { className: "player-knobs-content" }, lowLatencyMode ? null : (
      // In lowLatencyMode, we take back control of the rate
      /* @__PURE__ */ React43.createElement(SpeedKnob_default, { className: "black-knob", player })
    ), /* @__PURE__ */ React43.createElement(AudioRepresentation_default, { className: "black-knob", player }), /* @__PURE__ */ React43.createElement(VideoRepresentation_default, { className: "black-knob", player }), /* @__PURE__ */ React43.createElement(AudioTrack_default, { className: "black-knob", player }), /* @__PURE__ */ React43.createElement(Subtitles_default, { className: "black-knob", player }), /* @__PURE__ */ React43.createElement(VideoTrack_default, { className: "black-knob", player })));
  }
  var PlayerKnobsSettings_default = React43.memo(PlayerKnobsSettings);

  // demo/scripts/controllers/Player.tsx
  var { useCallback: useCallback34, useEffect: useEffect14, useRef: useRef10, useState: useState10 } = React44;
  var SPINNER_TIMEOUT = 300;
  function Player2() {
    const [
      defaultAudioRepresentationsSwitchingMode,
      setDefaultAudioRepresentationsSwitchingMode
    ] = useState10("reload");
    const [
      defaultVideoRepresentationsSwitchingMode,
      setDefaultVideoRepresentationsSwitchingMode
    ] = useState10("reload");
    const [playerModule, setPlayerModule] = useState10(null);
    const [autoPlayBlocked, setAutoPlayBlocked] = useState10(false);
    const [displaySpinner, setDisplaySpinner] = useState10(false);
    const [displaySettings, setDisplaySettings] = useState10(false);
    const [enableVideoThumbnails, setEnableVideoThumbnails] = useState10(false);
    const [showOptions, setShowOptions] = useState10(false);
    const [playerOpts, setPlayerOpts] = useState10(
      defaultOptionsValues_default.player
    );
    const [loadVideoOpts, setLoadVideoOpts] = useState10(
      defaultOptionsValues_default.loadVideo
    );
    const [relyOnWorker, setRelyOnWorker] = useState10(false);
    const [hasUpdatedPlayerOptions, setHasUpdatedPlayerOptions] = useState10(false);
    const displaySpinnerTimeoutRef = useRef10(null);
    const videoElementRef = useRef10(null);
    const textTrackElementRef = useRef10(null);
    const debugElementRef = useRef10(null);
    const playerWrapperElementRef = useRef10(null);
    const onOptionToggle = useCallback34(() => {
      setShowOptions((prevState) => !prevState);
    }, []);
    const clearSpinner = useCallback34(() => {
      if (displaySpinnerTimeoutRef.current) {
        clearTimeout(displaySpinnerTimeoutRef.current);
        displaySpinnerTimeoutRef.current = null;
      }
    }, []);
    useEffect14(() => {
      if (playerModule === null) {
        return;
      }
      playerModule.actions.updateWorkerMode(relyOnWorker);
    }, [relyOnWorker, playerModule]);
    useEffect14(() => {
      if (playerModule === null) {
        return;
      }
      function reCheckSpinner() {
        if (playerModule === null) {
          if (displaySpinnerTimeoutRef.current !== null) {
            clearTimeout(displaySpinnerTimeoutRef.current);
            displaySpinnerTimeoutRef.current = null;
          }
          setDisplaySpinner(false);
          return;
        }
        playerModule.actions.setDefaultAudioRepresentationSwitchingMode(
          defaultAudioRepresentationsSwitchingMode
        );
        playerModule.actions.setDefaultVideoRepresentationSwitchingMode(
          defaultVideoRepresentationsSwitchingMode
        );
        const isSeeking = playerModule.getState("isSeeking");
        const isBuffering = playerModule.getState("isBuffering");
        const isLoading = playerModule.getState("isLoading");
        const isReloading = playerModule.getState("isReloading");
        if (isLoading || isReloading) {
          if (displaySpinnerTimeoutRef.current !== null) {
            clearTimeout(displaySpinnerTimeoutRef.current);
            displaySpinnerTimeoutRef.current = null;
          }
          setDisplaySpinner(true);
        } else if (isSeeking || isBuffering) {
          if (displaySpinnerTimeoutRef.current === null) {
            displaySpinnerTimeoutRef.current = window.setTimeout(() => {
              setDisplaySpinner(true);
            }, SPINNER_TIMEOUT);
          }
        } else {
          if (displaySpinnerTimeoutRef.current !== null) {
            clearTimeout(displaySpinnerTimeoutRef.current);
            displaySpinnerTimeoutRef.current = null;
          }
          setDisplaySpinner(false);
        }
      }
      playerModule.listenToState(
        "defaultAudioRepresentationsSwitchingMode",
        (newVal) => setDefaultAudioRepresentationsSwitchingMode(newVal)
      );
      playerModule.listenToState(
        "defaultVideoRepresentationsSwitchingMode",
        (newVal) => setDefaultVideoRepresentationsSwitchingMode(newVal)
      );
      playerModule.listenToState("autoPlayBlocked", (newAutoPlayBlocked) => {
        setAutoPlayBlocked(newAutoPlayBlocked);
      });
      playerModule.listenToState("videoTrackHasTrickMode", (videoTrackHasTrickMode) => {
        setEnableVideoThumbnails(videoTrackHasTrickMode);
      });
      playerModule.listenToState("isSeeking", reCheckSpinner);
      playerModule.listenToState("isBuffering", reCheckSpinner);
      playerModule.listenToState("isLoading", reCheckSpinner);
      playerModule.listenToState("isReloading", reCheckSpinner);
      reCheckSpinner();
      return () => {
        playerModule.destroy();
        clearSpinner();
      };
    }, [playerModule]);
    const createNewPlayerModule = useCallback34(() => {
      if (videoElementRef.current === null || textTrackElementRef.current === null || debugElementRef.current === null) {
        return;
      }
      if (playerModule) {
        playerModule.destroy();
      }
      const playerMod = new player_default(
        Object.assign(
          {},
          {
            videoElement: videoElementRef.current,
            textTrackElement: textTrackElementRef.current,
            debugElement: debugElementRef.current
          },
          playerOpts
        )
      );
      setPlayerModule(playerMod);
      return playerMod;
    }, [playerOpts, playerModule]);
    const onVideoClick = useCallback34(() => {
      if (playerModule === null) {
        return;
      }
      const isPaused = playerModule.getState("isPaused");
      const isContentLoaded = playerModule.getState("isContentLoaded");
      if (!isContentLoaded) {
        return;
      }
      if (isPaused) {
        playerModule.actions.play();
      } else {
        playerModule.actions.disableLiveCatchUp();
        playerModule.actions.pause();
      }
    }, [playerModule]);
    const startContent = useCallback34(
      (contentInfo) => {
        let playerMod = playerModule;
        if (playerMod === null || hasUpdatedPlayerOptions) {
          setHasUpdatedPlayerOptions(false);
          const created = createNewPlayerModule();
          if (created === void 0) {
            return;
          }
          created.actions.updateWorkerMode(relyOnWorker);
          playerMod = created;
        }
        loadContent(playerMod, contentInfo, loadVideoOpts);
      },
      [
        playerModule,
        relyOnWorker,
        hasUpdatedPlayerOptions,
        createNewPlayerModule,
        loadVideoOpts
      ]
    );
    const stopVideo = useCallback34(() => {
      playerModule == null ? void 0 : playerModule.actions.stop();
    }, [playerModule]);
    const closeSettings = useCallback34(() => {
      setDisplaySettings(false);
    }, []);
    const toggleSettings = useCallback34(() => {
      setDisplaySettings(!displaySettings);
    }, [displaySettings]);
    const updatePlayerOptions = useCallback34(
      (cb) => {
        setHasUpdatedPlayerOptions(true);
        setPlayerOpts(cb);
      },
      []
    );
    const updateDefaultAudioRepresentationsSwitchingMode = useCallback34(
      (mod) => {
        if (playerModule === null) {
          setDefaultAudioRepresentationsSwitchingMode(mod);
          setHasUpdatedPlayerOptions(true);
          return;
        }
        playerModule.actions.setDefaultAudioRepresentationSwitchingMode(mod);
      },
      [playerModule]
    );
    const updateDefaultVideoRepresentationsSwitchingMode = useCallback34(
      (mod) => {
        if (playerModule === null) {
          setDefaultVideoRepresentationsSwitchingMode(mod);
          setHasUpdatedPlayerOptions(true);
          return;
        }
        playerModule.actions.setDefaultVideoRepresentationSwitchingMode(mod);
      },
      [playerModule]
    );
    return /* @__PURE__ */ React44.createElement("section", { className: "video-player-section" }, /* @__PURE__ */ React44.createElement("div", { className: "video-player-content" }, /* @__PURE__ */ React44.createElement(
      ContentList_default,
      {
        loadVideo: startContent,
        showOptions,
        onOptionToggle
      }
    ), /* @__PURE__ */ React44.createElement(
      Settings_default,
      {
        playerOptions: playerOpts,
        updatePlayerOptions,
        loadVideoOptions: loadVideoOpts,
        updateLoadVideoOptions: setLoadVideoOpts,
        showOptions,
        defaultAudioRepresentationsSwitchingMode,
        updateDefaultAudioRepresentationsSwitchingMode,
        defaultVideoRepresentationsSwitchingMode,
        updateDefaultVideoRepresentationsSwitchingMode,
        tryRelyOnWorker: relyOnWorker,
        updateTryRelyOnWorker: setRelyOnWorker
      }
    ), /* @__PURE__ */ React44.createElement("div", { className: "video-player-wrapper", ref: playerWrapperElementRef }, /* @__PURE__ */ React44.createElement("div", { className: "video-screen-parent" }, /* @__PURE__ */ React44.createElement(
      "div",
      {
        className: "video-screen",
        onKeyDown: (evt) => {
          if (evt.keyCode === 32 || evt.code === "Space") {
            onVideoClick();
          }
        },
        onClick: () => onVideoClick()
      },
      playerModule ? /* @__PURE__ */ React44.createElement(ErrorDisplayer_default, { player: playerModule }) : null,
      autoPlayBlocked ? /* @__PURE__ */ React44.createElement("div", { className: "video-player-manual-play-container" }, /* @__PURE__ */ React44.createElement(
        "img",
        {
          className: "video-player-manual-play",
          alt: "Play",
          src: "./assets/play.svg"
        }
      )) : null,
      !autoPlayBlocked && displaySpinner ? /* @__PURE__ */ React44.createElement("img", { src: "./assets/spinner.gif", className: "video-player-spinner" }) : null,
      /* @__PURE__ */ React44.createElement("div", { className: "text-track", ref: textTrackElementRef }),
      /* @__PURE__ */ React44.createElement("div", { className: "debug-element", ref: debugElementRef }),
      /* @__PURE__ */ React44.createElement("video", { ref: videoElementRef })
    ), playerModule ? /* @__PURE__ */ React44.createElement(
      PlayerKnobsSettings_default,
      {
        close: closeSettings,
        shouldDisplay: displaySettings,
        player: playerModule
      }
    ) : null), playerModule && playerWrapperElementRef ? /* @__PURE__ */ React44.createElement(
      ControlBar_default,
      {
        player: playerModule,
        playerWrapperElementRef,
        toggleSettings,
        stopVideo,
        enableVideoThumbnails
      }
    ) : null), /* @__PURE__ */ React44.createElement(charts_default, { player: playerModule })));
  }
  function loadContent(playerModule, contentInfo, loadVideoOpts) {
    if (contentInfo.lowLatencyMode) {
      playerModule.actions.enableLiveCatchUp();
    } else {
      playerModule.actions.disableLiveCatchUp();
    }
    playerModule.actions.setPlaybackRate(1);
    playerModule.actions.load(Object.assign({}, contentInfo, loadVideoOpts));
  }
  var Player_default = Player2;

  // demo/scripts/controllers/Main.tsx
  function MainComponent() {
    return /* @__PURE__ */ React45.createElement(React45.Fragment, null, /* @__PURE__ */ React45.createElement("header", null, /* @__PURE__ */ React45.createElement("div", { className: "left" }, /* @__PURE__ */ React45.createElement("h1", { className: "title" }, /* @__PURE__ */ React45.createElement("a", { href: "https://github.com/canalplus/rx-player" }, /* @__PURE__ */ React45.createElement("img", { className: "logo", alt: "RxPlayer", src: "./assets/logo_white.png" })), /* @__PURE__ */ React45.createElement(
      "a",
      {
        href: "https://developers.canal-plus.com/rx-player/demo_page_by_version.html",
        className: "version"
      },
      " v" + minimal_default.version
    )), /* @__PURE__ */ React45.createElement("nav", null, /* @__PURE__ */ React45.createElement("a", { href: "https://developers.canal-plus.com/rx-player/doc/Getting_Started/Welcome.html" }, "Getting Started"), /* @__PURE__ */ React45.createElement("a", { href: "https://developers.canal-plus.com/rx-player/doc/api/Overview.html" }, "API Docs"))), /* @__PURE__ */ React45.createElement("div", { className: "right" }, /* @__PURE__ */ React45.createElement("a", { "aria-label": "Go to Canal+ website", href: "https://canalplus.com" }, /* @__PURE__ */ React45.createElement("img", { className: "canal-logo", alt: "CANAL+", src: "./assets/canalp.svg" })), /* @__PURE__ */ React45.createElement(
      GitHubButton_default,
      {
        href: "https://github.com/canalplus/rx-player",
        ariaLabel: "Star the RxPlayer on GitHub",
        dataIcon: "octicon-star",
        dataShowCount: "true",
        dataText: "Star"
      }
    ), /* @__PURE__ */ React45.createElement(
      GitHubButton_default,
      {
        href: "https://github.com/canalplus/rx-player/fork",
        ariaLabel: "Fork the RxPlayer on GitHub",
        dataIcon: "octicon-repo-forked",
        dataText: "Fork"
      }
    ))), /* @__PURE__ */ React45.createElement(Player_default, null));
  }
  var Main_default = MainComponent;

  // demo/scripts/index.tsx
  window.onload = function() {
    const rootElt = document.getElementById("player-container");
    if (rootElt === null) {
      console.error("Error: missing `player-container` element");
      return;
    }
    const root = ReactDOM.createRoot(rootElt);
    root.render(
      /* @__PURE__ */ React46.createElement(React46.StrictMode, null, /* @__PURE__ */ React46.createElement(Main_default, null))
    );
  };
})();
/*! Bundled license information:

react/cjs/react.production.min.js:
  (**
   * @license React
   * react.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

scheduler/cjs/scheduler.production.min.js:
  (**
   * @license React
   * scheduler.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom.production.min.js:
  (**
   * @license React
   * react-dom.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

github-buttons/dist/buttons.esm.js:
  (*!
   * github-buttons v2.28.1
   * (c) 2024 
   * @license BSD-2-Clause
   *)
*/
