(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["RxPlayer"] = factory();
	else
		root["RxPlayer"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/exports.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/array-find-index/index.js":
/*!************************************************!*\
  !*** ./node_modules/array-find-index/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function (arr, predicate, ctx) {\n\tif (typeof Array.prototype.findIndex === 'function') {\n\t\treturn arr.findIndex(predicate, ctx);\n\t}\n\n\tif (typeof predicate !== 'function') {\n\t\tthrow new TypeError('predicate must be a function');\n\t}\n\n\tvar list = Object(arr);\n\tvar len = list.length;\n\n\tif (len === 0) {\n\t\treturn -1;\n\t}\n\n\tfor (var i = 0; i < len; i++) {\n\t\tif (predicate.call(ctx, list[i], i, list)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -1;\n};\n\n\n//# sourceURL=webpack://RxPlayer/./node_modules/array-find-index/index.js?");

/***/ }),

/***/ "./node_modules/array-find/find.js":
/*!*****************************************!*\
  !*** ./node_modules/array-find/find.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction find(array, predicate, context) {\n  if (typeof Array.prototype.find === 'function') {\n    return array.find(predicate, context);\n  }\n\n  context = context || this;\n  var length = array.length;\n  var i;\n\n  if (typeof predicate !== 'function') {\n    throw new TypeError(predicate + ' is not a function');\n  }\n\n  for (i = 0; i < length; i++) {\n    if (predicate.call(context, array[i], i, array)) {\n      return array[i];\n    }\n  }\n}\n\nmodule.exports = find;\n\n\n//# sourceURL=webpack://RxPlayer/./node_modules/array-find/find.js?");

/***/ }),

/***/ "./node_modules/deep-equal/index.js":
/*!******************************************!*\
  !*** ./node_modules/deep-equal/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var pSlice = Array.prototype.slice;\nvar objectKeys = __webpack_require__(/*! ./lib/keys.js */ \"./node_modules/deep-equal/lib/keys.js\");\nvar isArguments = __webpack_require__(/*! ./lib/is_arguments.js */ \"./node_modules/deep-equal/lib/is_arguments.js\");\n\nvar deepEqual = module.exports = function (actual, expected, opts) {\n  if (!opts) opts = {};\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return true;\n\n  } else if (actual instanceof Date && expected instanceof Date) {\n    return actual.getTime() === expected.getTime();\n\n  // 7.3. Other pairs that do not both pass typeof value == 'object',\n  // equivalence is determined by ==.\n  } else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {\n    return opts.strict ? actual === expected : actual == expected;\n\n  // 7.4. For all other Object pairs, including Array objects, equivalence is\n  // determined by having the same number of owned properties (as verified\n  // with Object.prototype.hasOwnProperty.call), the same set of keys\n  // (although not necessarily the same order), equivalent values for every\n  // corresponding key, and an identical 'prototype' property. Note: this\n  // accounts for both named and indexed properties on Arrays.\n  } else {\n    return objEquiv(actual, expected, opts);\n  }\n}\n\nfunction isUndefinedOrNull(value) {\n  return value === null || value === undefined;\n}\n\nfunction isBuffer (x) {\n  if (!x || typeof x !== 'object' || typeof x.length !== 'number') return false;\n  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {\n    return false;\n  }\n  if (x.length > 0 && typeof x[0] !== 'number') return false;\n  return true;\n}\n\nfunction objEquiv(a, b, opts) {\n  var i, key;\n  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))\n    return false;\n  // an identical 'prototype' property.\n  if (a.prototype !== b.prototype) return false;\n  //~~~I've managed to break Object.keys through screwy arguments passing.\n  //   Converting to array solves the problem.\n  if (isArguments(a)) {\n    if (!isArguments(b)) {\n      return false;\n    }\n    a = pSlice.call(a);\n    b = pSlice.call(b);\n    return deepEqual(a, b, opts);\n  }\n  if (isBuffer(a)) {\n    if (!isBuffer(b)) {\n      return false;\n    }\n    if (a.length !== b.length) return false;\n    for (i = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) return false;\n    }\n    return true;\n  }\n  try {\n    var ka = objectKeys(a),\n        kb = objectKeys(b);\n  } catch (e) {//happens when one is a string literal and the other isn't\n    return false;\n  }\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (ka.length != kb.length)\n    return false;\n  //the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  //~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] != kb[i])\n      return false;\n  }\n  //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!deepEqual(a[key], b[key], opts)) return false;\n  }\n  return typeof a === typeof b;\n}\n\n\n//# sourceURL=webpack://RxPlayer/./node_modules/deep-equal/index.js?");

/***/ }),

/***/ "./node_modules/deep-equal/lib/is_arguments.js":
/*!*****************************************************!*\
  !*** ./node_modules/deep-equal/lib/is_arguments.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var supportsArgumentsClass = (function(){\n  return Object.prototype.toString.call(arguments)\n})() == '[object Arguments]';\n\nexports = module.exports = supportsArgumentsClass ? supported : unsupported;\n\nexports.supported = supported;\nfunction supported(object) {\n  return Object.prototype.toString.call(object) == '[object Arguments]';\n};\n\nexports.unsupported = unsupported;\nfunction unsupported(object){\n  return object &&\n    typeof object == 'object' &&\n    typeof object.length == 'number' &&\n    Object.prototype.hasOwnProperty.call(object, 'callee') &&\n    !Object.prototype.propertyIsEnumerable.call(object, 'callee') ||\n    false;\n};\n\n\n//# sourceURL=webpack://RxPlayer/./node_modules/deep-equal/lib/is_arguments.js?");

/***/ }),

/***/ "./node_modules/deep-equal/lib/keys.js":
/*!*********************************************!*\
  !*** ./node_modules/deep-equal/lib/keys.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("exports = module.exports = typeof Object.keys === 'function'\n  ? Object.keys : shim;\n\nexports.shim = shim;\nfunction shim (obj) {\n  var keys = [];\n  for (var key in obj) keys.push(key);\n  return keys;\n}\n\n\n//# sourceURL=webpack://RxPlayer/./node_modules/deep-equal/lib/keys.js?");

/***/ }),

/***/ "./node_modules/object-assign/index.js":
/*!*********************************************!*\
  !*** ./node_modules/object-assign/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n\n\n/* eslint-disable no-unused-vars */\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (err) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (getOwnPropertySymbols) {\n\t\t\tsymbols = getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n\n\n//# sourceURL=webpack://RxPlayer/./node_modules/object-assign/index.js?");

/***/ }),

/***/ "./node_modules/rxjs/BehaviorSubject.js":
/*!**********************************************!*\
  !*** ./node_modules/rxjs/BehaviorSubject.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = __webpack_require__(/*! ./Subject */ \"./node_modules/rxjs/Subject.js\");\nvar ObjectUnsubscribedError_1 = __webpack_require__(/*! ./util/ObjectUnsubscribedError */ \"./node_modules/rxjs/util/ObjectUnsubscribedError.js\");\n/**\n * @class BehaviorSubject<T>\n */\nvar BehaviorSubject = (function (_super) {\n    __extends(BehaviorSubject, _super);\n    function BehaviorSubject(_value) {\n        _super.call(this);\n        this._value = _value;\n    }\n    Object.defineProperty(BehaviorSubject.prototype, \"value\", {\n        get: function () {\n            return this.getValue();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    BehaviorSubject.prototype._subscribe = function (subscriber) {\n        var subscription = _super.prototype._subscribe.call(this, subscriber);\n        if (subscription && !subscription.closed) {\n            subscriber.next(this._value);\n        }\n        return subscription;\n    };\n    BehaviorSubject.prototype.getValue = function () {\n        if (this.hasError) {\n            throw this.thrownError;\n        }\n        else if (this.closed) {\n            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n        }\n        else {\n            return this._value;\n        }\n    };\n    BehaviorSubject.prototype.next = function (value) {\n        _super.prototype.next.call(this, this._value = value);\n    };\n    return BehaviorSubject;\n}(Subject_1.Subject));\nexports.BehaviorSubject = BehaviorSubject;\n//# sourceMappingURL=BehaviorSubject.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/BehaviorSubject.js?");

/***/ }),

/***/ "./node_modules/rxjs/InnerSubscriber.js":
/*!**********************************************!*\
  !*** ./node_modules/rxjs/InnerSubscriber.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(/*! ./Subscriber */ \"./node_modules/rxjs/Subscriber.js\");\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar InnerSubscriber = (function (_super) {\n    __extends(InnerSubscriber, _super);\n    function InnerSubscriber(parent, outerValue, outerIndex) {\n        _super.call(this);\n        this.parent = parent;\n        this.outerValue = outerValue;\n        this.outerIndex = outerIndex;\n        this.index = 0;\n    }\n    InnerSubscriber.prototype._next = function (value) {\n        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);\n    };\n    InnerSubscriber.prototype._error = function (error) {\n        this.parent.notifyError(error, this);\n        this.unsubscribe();\n    };\n    InnerSubscriber.prototype._complete = function () {\n        this.parent.notifyComplete(this);\n        this.unsubscribe();\n    };\n    return InnerSubscriber;\n}(Subscriber_1.Subscriber));\nexports.InnerSubscriber = InnerSubscriber;\n//# sourceMappingURL=InnerSubscriber.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/InnerSubscriber.js?");

/***/ }),

/***/ "./node_modules/rxjs/Notification.js":
/*!*******************************************!*\
  !*** ./node_modules/rxjs/Notification.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Observable_1 = __webpack_require__(/*! ./Observable */ \"./node_modules/rxjs/Observable.js\");\n/**\n * Represents a push-based event or value that an {@link Observable} can emit.\n * This class is particularly useful for operators that manage notifications,\n * like {@link materialize}, {@link dematerialize}, {@link observeOn}, and\n * others. Besides wrapping the actual delivered value, it also annotates it\n * with metadata of, for instance, what type of push message it is (`next`,\n * `error`, or `complete`).\n *\n * @see {@link materialize}\n * @see {@link dematerialize}\n * @see {@link observeOn}\n *\n * @class Notification<T>\n */\nvar Notification = (function () {\n    function Notification(kind, value, error) {\n        this.kind = kind;\n        this.value = value;\n        this.error = error;\n        this.hasValue = kind === 'N';\n    }\n    /**\n     * Delivers to the given `observer` the value wrapped by this Notification.\n     * @param {Observer} observer\n     * @return\n     */\n    Notification.prototype.observe = function (observer) {\n        switch (this.kind) {\n            case 'N':\n                return observer.next && observer.next(this.value);\n            case 'E':\n                return observer.error && observer.error(this.error);\n            case 'C':\n                return observer.complete && observer.complete();\n        }\n    };\n    /**\n     * Given some {@link Observer} callbacks, deliver the value represented by the\n     * current Notification to the correctly corresponding callback.\n     * @param {function(value: T): void} next An Observer `next` callback.\n     * @param {function(err: any): void} [error] An Observer `error` callback.\n     * @param {function(): void} [complete] An Observer `complete` callback.\n     * @return {any}\n     */\n    Notification.prototype.do = function (next, error, complete) {\n        var kind = this.kind;\n        switch (kind) {\n            case 'N':\n                return next && next(this.value);\n            case 'E':\n                return error && error(this.error);\n            case 'C':\n                return complete && complete();\n        }\n    };\n    /**\n     * Takes an Observer or its individual callback functions, and calls `observe`\n     * or `do` methods accordingly.\n     * @param {Observer|function(value: T): void} nextOrObserver An Observer or\n     * the `next` callback.\n     * @param {function(err: any): void} [error] An Observer `error` callback.\n     * @param {function(): void} [complete] An Observer `complete` callback.\n     * @return {any}\n     */\n    Notification.prototype.accept = function (nextOrObserver, error, complete) {\n        if (nextOrObserver && typeof nextOrObserver.next === 'function') {\n            return this.observe(nextOrObserver);\n        }\n        else {\n            return this.do(nextOrObserver, error, complete);\n        }\n    };\n    /**\n     * Returns a simple Observable that just delivers the notification represented\n     * by this Notification instance.\n     * @return {any}\n     */\n    Notification.prototype.toObservable = function () {\n        var kind = this.kind;\n        switch (kind) {\n            case 'N':\n                return Observable_1.Observable.of(this.value);\n            case 'E':\n                return Observable_1.Observable.throw(this.error);\n            case 'C':\n                return Observable_1.Observable.empty();\n        }\n        throw new Error('unexpected notification kind value');\n    };\n    /**\n     * A shortcut to create a Notification instance of the type `next` from a\n     * given value.\n     * @param {T} value The `next` value.\n     * @return {Notification<T>} The \"next\" Notification representing the\n     * argument.\n     */\n    Notification.createNext = function (value) {\n        if (typeof value !== 'undefined') {\n            return new Notification('N', value);\n        }\n        return Notification.undefinedValueNotification;\n    };\n    /**\n     * A shortcut to create a Notification instance of the type `error` from a\n     * given error.\n     * @param {any} [err] The `error` error.\n     * @return {Notification<T>} The \"error\" Notification representing the\n     * argument.\n     */\n    Notification.createError = function (err) {\n        return new Notification('E', undefined, err);\n    };\n    /**\n     * A shortcut to create a Notification instance of the type `complete`.\n     * @return {Notification<any>} The valueless \"complete\" Notification.\n     */\n    Notification.createComplete = function () {\n        return Notification.completeNotification;\n    };\n    Notification.completeNotification = new Notification('C');\n    Notification.undefinedValueNotification = new Notification('N', undefined);\n    return Notification;\n}());\nexports.Notification = Notification;\n//# sourceMappingURL=Notification.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/Notification.js?");

/***/ }),

/***/ "./node_modules/rxjs/Observable.js":
/*!*****************************************!*\
  !*** ./node_modules/rxjs/Observable.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar root_1 = __webpack_require__(/*! ./util/root */ \"./node_modules/rxjs/util/root.js\");\nvar toSubscriber_1 = __webpack_require__(/*! ./util/toSubscriber */ \"./node_modules/rxjs/util/toSubscriber.js\");\nvar observable_1 = __webpack_require__(/*! ./symbol/observable */ \"./node_modules/rxjs/symbol/observable.js\");\nvar pipe_1 = __webpack_require__(/*! ./util/pipe */ \"./node_modules/rxjs/util/pipe.js\");\n/**\n * A representation of any set of values over any amount of time. This is the most basic building block\n * of RxJS.\n *\n * @class Observable<T>\n */\nvar Observable = (function () {\n    /**\n     * @constructor\n     * @param {Function} subscribe the function that is called when the Observable is\n     * initially subscribed to. This function is given a Subscriber, to which new values\n     * can be `next`ed, or an `error` method can be called to raise an error, or\n     * `complete` can be called to notify of a successful completion.\n     */\n    function Observable(subscribe) {\n        this._isScalar = false;\n        if (subscribe) {\n            this._subscribe = subscribe;\n        }\n    }\n    /**\n     * Creates a new Observable, with this Observable as the source, and the passed\n     * operator defined as the new observable's operator.\n     * @method lift\n     * @param {Operator} operator the operator defining the operation to take on the observable\n     * @return {Observable} a new observable with the Operator applied\n     */\n    Observable.prototype.lift = function (operator) {\n        var observable = new Observable();\n        observable.source = this;\n        observable.operator = operator;\n        return observable;\n    };\n    /**\n     * Invokes an execution of an Observable and registers Observer handlers for notifications it will emit.\n     *\n     * <span class=\"informal\">Use it when you have all these Observables, but still nothing is happening.</span>\n     *\n     * `subscribe` is not a regular operator, but a method that calls Observable's internal `subscribe` function. It\n     * might be for example a function that you passed to a {@link create} static factory, but most of the time it is\n     * a library implementation, which defines what and when will be emitted by an Observable. This means that calling\n     * `subscribe` is actually the moment when Observable starts its work, not when it is created, as it is often\n     * thought.\n     *\n     * Apart from starting the execution of an Observable, this method allows you to listen for values\n     * that an Observable emits, as well as for when it completes or errors. You can achieve this in two\n     * following ways.\n     *\n     * The first way is creating an object that implements {@link Observer} interface. It should have methods\n     * defined by that interface, but note that it should be just a regular JavaScript object, which you can create\n     * yourself in any way you want (ES6 class, classic function constructor, object literal etc.). In particular do\n     * not attempt to use any RxJS implementation details to create Observers - you don't need them. Remember also\n     * that your object does not have to implement all methods. If you find yourself creating a method that doesn't\n     * do anything, you can simply omit it. Note however, that if `error` method is not provided, all errors will\n     * be left uncaught.\n     *\n     * The second way is to give up on Observer object altogether and simply provide callback functions in place of its methods.\n     * This means you can provide three functions as arguments to `subscribe`, where first function is equivalent\n     * of a `next` method, second of an `error` method and third of a `complete` method. Just as in case of Observer,\n     * if you do not need to listen for something, you can omit a function, preferably by passing `undefined` or `null`,\n     * since `subscribe` recognizes these functions by where they were placed in function call. When it comes\n     * to `error` function, just as before, if not provided, errors emitted by an Observable will be thrown.\n     *\n     * Whatever style of calling `subscribe` you use, in both cases it returns a Subscription object.\n     * This object allows you to call `unsubscribe` on it, which in turn will stop work that an Observable does and will clean\n     * up all resources that an Observable used. Note that cancelling a subscription will not call `complete` callback\n     * provided to `subscribe` function, which is reserved for a regular completion signal that comes from an Observable.\n     *\n     * Remember that callbacks provided to `subscribe` are not guaranteed to be called asynchronously.\n     * It is an Observable itself that decides when these functions will be called. For example {@link of}\n     * by default emits all its values synchronously. Always check documentation for how given Observable\n     * will behave when subscribed and if its default behavior can be modified with a {@link Scheduler}.\n     *\n     * @example <caption>Subscribe with an Observer</caption>\n     * const sumObserver = {\n     *   sum: 0,\n     *   next(value) {\n     *     console.log('Adding: ' + value);\n     *     this.sum = this.sum + value;\n     *   },\n     *   error() { // We actually could just remove this method,\n     *   },        // since we do not really care about errors right now.\n     *   complete() {\n     *     console.log('Sum equals: ' + this.sum);\n     *   }\n     * };\n     *\n     * Rx.Observable.of(1, 2, 3) // Synchronously emits 1, 2, 3 and then completes.\n     * .subscribe(sumObserver);\n     *\n     * // Logs:\n     * // \"Adding: 1\"\n     * // \"Adding: 2\"\n     * // \"Adding: 3\"\n     * // \"Sum equals: 6\"\n     *\n     *\n     * @example <caption>Subscribe with functions</caption>\n     * let sum = 0;\n     *\n     * Rx.Observable.of(1, 2, 3)\n     * .subscribe(\n     *   function(value) {\n     *     console.log('Adding: ' + value);\n     *     sum = sum + value;\n     *   },\n     *   undefined,\n     *   function() {\n     *     console.log('Sum equals: ' + sum);\n     *   }\n     * );\n     *\n     * // Logs:\n     * // \"Adding: 1\"\n     * // \"Adding: 2\"\n     * // \"Adding: 3\"\n     * // \"Sum equals: 6\"\n     *\n     *\n     * @example <caption>Cancel a subscription</caption>\n     * const subscription = Rx.Observable.interval(1000).subscribe(\n     *   num => console.log(num),\n     *   undefined,\n     *   () => console.log('completed!') // Will not be called, even\n     * );                                // when cancelling subscription\n     *\n     *\n     * setTimeout(() => {\n     *   subscription.unsubscribe();\n     *   console.log('unsubscribed!');\n     * }, 2500);\n     *\n     * // Logs:\n     * // 0 after 1s\n     * // 1 after 2s\n     * // \"unsubscribed!\" after 2.5s\n     *\n     *\n     * @param {Observer|Function} observerOrNext (optional) Either an observer with methods to be called,\n     *  or the first of three possible handlers, which is the handler for each value emitted from the subscribed\n     *  Observable.\n     * @param {Function} error (optional) A handler for a terminal event resulting from an error. If no error handler is provided,\n     *  the error will be thrown as unhandled.\n     * @param {Function} complete (optional) A handler for a terminal event resulting from successful completion.\n     * @return {ISubscription} a subscription reference to the registered handlers\n     * @method subscribe\n     */\n    Observable.prototype.subscribe = function (observerOrNext, error, complete) {\n        var operator = this.operator;\n        var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);\n        if (operator) {\n            operator.call(sink, this.source);\n        }\n        else {\n            sink.add(this.source || !sink.syncErrorThrowable ? this._subscribe(sink) : this._trySubscribe(sink));\n        }\n        if (sink.syncErrorThrowable) {\n            sink.syncErrorThrowable = false;\n            if (sink.syncErrorThrown) {\n                throw sink.syncErrorValue;\n            }\n        }\n        return sink;\n    };\n    Observable.prototype._trySubscribe = function (sink) {\n        try {\n            return this._subscribe(sink);\n        }\n        catch (err) {\n            sink.syncErrorThrown = true;\n            sink.syncErrorValue = err;\n            sink.error(err);\n        }\n    };\n    /**\n     * @method forEach\n     * @param {Function} next a handler for each value emitted by the observable\n     * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise\n     * @return {Promise} a promise that either resolves on observable completion or\n     *  rejects with the handled error\n     */\n    Observable.prototype.forEach = function (next, PromiseCtor) {\n        var _this = this;\n        if (!PromiseCtor) {\n            if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {\n                PromiseCtor = root_1.root.Rx.config.Promise;\n            }\n            else if (root_1.root.Promise) {\n                PromiseCtor = root_1.root.Promise;\n            }\n        }\n        if (!PromiseCtor) {\n            throw new Error('no Promise impl found');\n        }\n        return new PromiseCtor(function (resolve, reject) {\n            // Must be declared in a separate statement to avoid a RefernceError when\n            // accessing subscription below in the closure due to Temporal Dead Zone.\n            var subscription;\n            subscription = _this.subscribe(function (value) {\n                if (subscription) {\n                    // if there is a subscription, then we can surmise\n                    // the next handling is asynchronous. Any errors thrown\n                    // need to be rejected explicitly and unsubscribe must be\n                    // called manually\n                    try {\n                        next(value);\n                    }\n                    catch (err) {\n                        reject(err);\n                        subscription.unsubscribe();\n                    }\n                }\n                else {\n                    // if there is NO subscription, then we're getting a nexted\n                    // value synchronously during subscription. We can just call it.\n                    // If it errors, Observable's `subscribe` will ensure the\n                    // unsubscription logic is called, then synchronously rethrow the error.\n                    // After that, Promise will trap the error and send it\n                    // down the rejection path.\n                    next(value);\n                }\n            }, reject, resolve);\n        });\n    };\n    Observable.prototype._subscribe = function (subscriber) {\n        return this.source.subscribe(subscriber);\n    };\n    /**\n     * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable\n     * @method Symbol.observable\n     * @return {Observable} this instance of the observable\n     */\n    Observable.prototype[observable_1.observable] = function () {\n        return this;\n    };\n    /* tslint:enable:max-line-length */\n    /**\n     * Used to stitch together functional operators into a chain.\n     * @method pipe\n     * @return {Observable} the Observable result of all of the operators having\n     * been called in the order they were passed in.\n     *\n     * @example\n     *\n     * import { map, filter, scan } from 'rxjs/operators';\n     *\n     * Rx.Observable.interval(1000)\n     *   .pipe(\n     *     filter(x => x % 2 === 0),\n     *     map(x => x + x),\n     *     scan((acc, x) => acc + x)\n     *   )\n     *   .subscribe(x => console.log(x))\n     */\n    Observable.prototype.pipe = function () {\n        var operations = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            operations[_i - 0] = arguments[_i];\n        }\n        if (operations.length === 0) {\n            return this;\n        }\n        return pipe_1.pipeFromArray(operations)(this);\n    };\n    /* tslint:enable:max-line-length */\n    Observable.prototype.toPromise = function (PromiseCtor) {\n        var _this = this;\n        if (!PromiseCtor) {\n            if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {\n                PromiseCtor = root_1.root.Rx.config.Promise;\n            }\n            else if (root_1.root.Promise) {\n                PromiseCtor = root_1.root.Promise;\n            }\n        }\n        if (!PromiseCtor) {\n            throw new Error('no Promise impl found');\n        }\n        return new PromiseCtor(function (resolve, reject) {\n            var value;\n            _this.subscribe(function (x) { return value = x; }, function (err) { return reject(err); }, function () { return resolve(value); });\n        });\n    };\n    // HACK: Since TypeScript inherits static properties too, we have to\n    // fight against TypeScript here so Subject can have a different static create signature\n    /**\n     * Creates a new cold Observable by calling the Observable constructor\n     * @static true\n     * @owner Observable\n     * @method create\n     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor\n     * @return {Observable} a new cold observable\n     */\n    Observable.create = function (subscribe) {\n        return new Observable(subscribe);\n    };\n    return Observable;\n}());\nexports.Observable = Observable;\n//# sourceMappingURL=Observable.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/Observable.js?");

/***/ }),

/***/ "./node_modules/rxjs/Observer.js":
/*!***************************************!*\
  !*** ./node_modules/rxjs/Observer.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nexports.empty = {\n    closed: true,\n    next: function (value) { },\n    error: function (err) { throw err; },\n    complete: function () { }\n};\n//# sourceMappingURL=Observer.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/Observer.js?");

/***/ }),

/***/ "./node_modules/rxjs/OuterSubscriber.js":
/*!**********************************************!*\
  !*** ./node_modules/rxjs/OuterSubscriber.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(/*! ./Subscriber */ \"./node_modules/rxjs/Subscriber.js\");\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar OuterSubscriber = (function (_super) {\n    __extends(OuterSubscriber, _super);\n    function OuterSubscriber() {\n        _super.apply(this, arguments);\n    }\n    OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.destination.next(innerValue);\n    };\n    OuterSubscriber.prototype.notifyError = function (error, innerSub) {\n        this.destination.error(error);\n    };\n    OuterSubscriber.prototype.notifyComplete = function (innerSub) {\n        this.destination.complete();\n    };\n    return OuterSubscriber;\n}(Subscriber_1.Subscriber));\nexports.OuterSubscriber = OuterSubscriber;\n//# sourceMappingURL=OuterSubscriber.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/OuterSubscriber.js?");

/***/ }),

/***/ "./node_modules/rxjs/ReplaySubject.js":
/*!********************************************!*\
  !*** ./node_modules/rxjs/ReplaySubject.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = __webpack_require__(/*! ./Subject */ \"./node_modules/rxjs/Subject.js\");\nvar queue_1 = __webpack_require__(/*! ./scheduler/queue */ \"./node_modules/rxjs/scheduler/queue.js\");\nvar Subscription_1 = __webpack_require__(/*! ./Subscription */ \"./node_modules/rxjs/Subscription.js\");\nvar observeOn_1 = __webpack_require__(/*! ./operators/observeOn */ \"./node_modules/rxjs/operators/observeOn.js\");\nvar ObjectUnsubscribedError_1 = __webpack_require__(/*! ./util/ObjectUnsubscribedError */ \"./node_modules/rxjs/util/ObjectUnsubscribedError.js\");\nvar SubjectSubscription_1 = __webpack_require__(/*! ./SubjectSubscription */ \"./node_modules/rxjs/SubjectSubscription.js\");\n/**\n * @class ReplaySubject<T>\n */\nvar ReplaySubject = (function (_super) {\n    __extends(ReplaySubject, _super);\n    function ReplaySubject(bufferSize, windowTime, scheduler) {\n        if (bufferSize === void 0) { bufferSize = Number.POSITIVE_INFINITY; }\n        if (windowTime === void 0) { windowTime = Number.POSITIVE_INFINITY; }\n        _super.call(this);\n        this.scheduler = scheduler;\n        this._events = [];\n        this._bufferSize = bufferSize < 1 ? 1 : bufferSize;\n        this._windowTime = windowTime < 1 ? 1 : windowTime;\n    }\n    ReplaySubject.prototype.next = function (value) {\n        var now = this._getNow();\n        this._events.push(new ReplayEvent(now, value));\n        this._trimBufferThenGetEvents();\n        _super.prototype.next.call(this, value);\n    };\n    ReplaySubject.prototype._subscribe = function (subscriber) {\n        var _events = this._trimBufferThenGetEvents();\n        var scheduler = this.scheduler;\n        var subscription;\n        if (this.closed) {\n            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n        }\n        else if (this.hasError) {\n            subscription = Subscription_1.Subscription.EMPTY;\n        }\n        else if (this.isStopped) {\n            subscription = Subscription_1.Subscription.EMPTY;\n        }\n        else {\n            this.observers.push(subscriber);\n            subscription = new SubjectSubscription_1.SubjectSubscription(this, subscriber);\n        }\n        if (scheduler) {\n            subscriber.add(subscriber = new observeOn_1.ObserveOnSubscriber(subscriber, scheduler));\n        }\n        var len = _events.length;\n        for (var i = 0; i < len && !subscriber.closed; i++) {\n            subscriber.next(_events[i].value);\n        }\n        if (this.hasError) {\n            subscriber.error(this.thrownError);\n        }\n        else if (this.isStopped) {\n            subscriber.complete();\n        }\n        return subscription;\n    };\n    ReplaySubject.prototype._getNow = function () {\n        return (this.scheduler || queue_1.queue).now();\n    };\n    ReplaySubject.prototype._trimBufferThenGetEvents = function () {\n        var now = this._getNow();\n        var _bufferSize = this._bufferSize;\n        var _windowTime = this._windowTime;\n        var _events = this._events;\n        var eventsCount = _events.length;\n        var spliceCount = 0;\n        // Trim events that fall out of the time window.\n        // Start at the front of the list. Break early once\n        // we encounter an event that falls within the window.\n        while (spliceCount < eventsCount) {\n            if ((now - _events[spliceCount].time) < _windowTime) {\n                break;\n            }\n            spliceCount++;\n        }\n        if (eventsCount > _bufferSize) {\n            spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);\n        }\n        if (spliceCount > 0) {\n            _events.splice(0, spliceCount);\n        }\n        return _events;\n    };\n    return ReplaySubject;\n}(Subject_1.Subject));\nexports.ReplaySubject = ReplaySubject;\nvar ReplayEvent = (function () {\n    function ReplayEvent(time, value) {\n        this.time = time;\n        this.value = value;\n    }\n    return ReplayEvent;\n}());\n//# sourceMappingURL=ReplaySubject.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/ReplaySubject.js?");

/***/ }),

/***/ "./node_modules/rxjs/Scheduler.js":
/*!****************************************!*\
  !*** ./node_modules/rxjs/Scheduler.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * An execution context and a data structure to order tasks and schedule their\n * execution. Provides a notion of (potentially virtual) time, through the\n * `now()` getter method.\n *\n * Each unit of work in a Scheduler is called an {@link Action}.\n *\n * ```ts\n * class Scheduler {\n *   now(): number;\n *   schedule(work, delay?, state?): Subscription;\n * }\n * ```\n *\n * @class Scheduler\n */\nvar Scheduler = (function () {\n    function Scheduler(SchedulerAction, now) {\n        if (now === void 0) { now = Scheduler.now; }\n        this.SchedulerAction = SchedulerAction;\n        this.now = now;\n    }\n    /**\n     * Schedules a function, `work`, for execution. May happen at some point in\n     * the future, according to the `delay` parameter, if specified. May be passed\n     * some context object, `state`, which will be passed to the `work` function.\n     *\n     * The given arguments will be processed an stored as an Action object in a\n     * queue of actions.\n     *\n     * @param {function(state: ?T): ?Subscription} work A function representing a\n     * task, or some unit of work to be executed by the Scheduler.\n     * @param {number} [delay] Time to wait before executing the work, where the\n     * time unit is implicit and defined by the Scheduler itself.\n     * @param {T} [state] Some contextual data that the `work` function uses when\n     * called by the Scheduler.\n     * @return {Subscription} A subscription in order to be able to unsubscribe\n     * the scheduled work.\n     */\n    Scheduler.prototype.schedule = function (work, delay, state) {\n        if (delay === void 0) { delay = 0; }\n        return new this.SchedulerAction(this, work).schedule(state, delay);\n    };\n    Scheduler.now = Date.now ? Date.now : function () { return +new Date(); };\n    return Scheduler;\n}());\nexports.Scheduler = Scheduler;\n//# sourceMappingURL=Scheduler.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/Scheduler.js?");

/***/ }),

/***/ "./node_modules/rxjs/Subject.js":
/*!**************************************!*\
  !*** ./node_modules/rxjs/Subject.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = __webpack_require__(/*! ./Observable */ \"./node_modules/rxjs/Observable.js\");\nvar Subscriber_1 = __webpack_require__(/*! ./Subscriber */ \"./node_modules/rxjs/Subscriber.js\");\nvar Subscription_1 = __webpack_require__(/*! ./Subscription */ \"./node_modules/rxjs/Subscription.js\");\nvar ObjectUnsubscribedError_1 = __webpack_require__(/*! ./util/ObjectUnsubscribedError */ \"./node_modules/rxjs/util/ObjectUnsubscribedError.js\");\nvar SubjectSubscription_1 = __webpack_require__(/*! ./SubjectSubscription */ \"./node_modules/rxjs/SubjectSubscription.js\");\nvar rxSubscriber_1 = __webpack_require__(/*! ./symbol/rxSubscriber */ \"./node_modules/rxjs/symbol/rxSubscriber.js\");\n/**\n * @class SubjectSubscriber<T>\n */\nvar SubjectSubscriber = (function (_super) {\n    __extends(SubjectSubscriber, _super);\n    function SubjectSubscriber(destination) {\n        _super.call(this, destination);\n        this.destination = destination;\n    }\n    return SubjectSubscriber;\n}(Subscriber_1.Subscriber));\nexports.SubjectSubscriber = SubjectSubscriber;\n/**\n * @class Subject<T>\n */\nvar Subject = (function (_super) {\n    __extends(Subject, _super);\n    function Subject() {\n        _super.call(this);\n        this.observers = [];\n        this.closed = false;\n        this.isStopped = false;\n        this.hasError = false;\n        this.thrownError = null;\n    }\n    Subject.prototype[rxSubscriber_1.rxSubscriber] = function () {\n        return new SubjectSubscriber(this);\n    };\n    Subject.prototype.lift = function (operator) {\n        var subject = new AnonymousSubject(this, this);\n        subject.operator = operator;\n        return subject;\n    };\n    Subject.prototype.next = function (value) {\n        if (this.closed) {\n            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n        }\n        if (!this.isStopped) {\n            var observers = this.observers;\n            var len = observers.length;\n            var copy = observers.slice();\n            for (var i = 0; i < len; i++) {\n                copy[i].next(value);\n            }\n        }\n    };\n    Subject.prototype.error = function (err) {\n        if (this.closed) {\n            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n        }\n        this.hasError = true;\n        this.thrownError = err;\n        this.isStopped = true;\n        var observers = this.observers;\n        var len = observers.length;\n        var copy = observers.slice();\n        for (var i = 0; i < len; i++) {\n            copy[i].error(err);\n        }\n        this.observers.length = 0;\n    };\n    Subject.prototype.complete = function () {\n        if (this.closed) {\n            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n        }\n        this.isStopped = true;\n        var observers = this.observers;\n        var len = observers.length;\n        var copy = observers.slice();\n        for (var i = 0; i < len; i++) {\n            copy[i].complete();\n        }\n        this.observers.length = 0;\n    };\n    Subject.prototype.unsubscribe = function () {\n        this.isStopped = true;\n        this.closed = true;\n        this.observers = null;\n    };\n    Subject.prototype._trySubscribe = function (subscriber) {\n        if (this.closed) {\n            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n        }\n        else {\n            return _super.prototype._trySubscribe.call(this, subscriber);\n        }\n    };\n    Subject.prototype._subscribe = function (subscriber) {\n        if (this.closed) {\n            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n        }\n        else if (this.hasError) {\n            subscriber.error(this.thrownError);\n            return Subscription_1.Subscription.EMPTY;\n        }\n        else if (this.isStopped) {\n            subscriber.complete();\n            return Subscription_1.Subscription.EMPTY;\n        }\n        else {\n            this.observers.push(subscriber);\n            return new SubjectSubscription_1.SubjectSubscription(this, subscriber);\n        }\n    };\n    Subject.prototype.asObservable = function () {\n        var observable = new Observable_1.Observable();\n        observable.source = this;\n        return observable;\n    };\n    Subject.create = function (destination, source) {\n        return new AnonymousSubject(destination, source);\n    };\n    return Subject;\n}(Observable_1.Observable));\nexports.Subject = Subject;\n/**\n * @class AnonymousSubject<T>\n */\nvar AnonymousSubject = (function (_super) {\n    __extends(AnonymousSubject, _super);\n    function AnonymousSubject(destination, source) {\n        _super.call(this);\n        this.destination = destination;\n        this.source = source;\n    }\n    AnonymousSubject.prototype.next = function (value) {\n        var destination = this.destination;\n        if (destination && destination.next) {\n            destination.next(value);\n        }\n    };\n    AnonymousSubject.prototype.error = function (err) {\n        var destination = this.destination;\n        if (destination && destination.error) {\n            this.destination.error(err);\n        }\n    };\n    AnonymousSubject.prototype.complete = function () {\n        var destination = this.destination;\n        if (destination && destination.complete) {\n            this.destination.complete();\n        }\n    };\n    AnonymousSubject.prototype._subscribe = function (subscriber) {\n        var source = this.source;\n        if (source) {\n            return this.source.subscribe(subscriber);\n        }\n        else {\n            return Subscription_1.Subscription.EMPTY;\n        }\n    };\n    return AnonymousSubject;\n}(Subject));\nexports.AnonymousSubject = AnonymousSubject;\n//# sourceMappingURL=Subject.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/Subject.js?");

/***/ }),

/***/ "./node_modules/rxjs/SubjectSubscription.js":
/*!**************************************************!*\
  !*** ./node_modules/rxjs/SubjectSubscription.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscription_1 = __webpack_require__(/*! ./Subscription */ \"./node_modules/rxjs/Subscription.js\");\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SubjectSubscription = (function (_super) {\n    __extends(SubjectSubscription, _super);\n    function SubjectSubscription(subject, subscriber) {\n        _super.call(this);\n        this.subject = subject;\n        this.subscriber = subscriber;\n        this.closed = false;\n    }\n    SubjectSubscription.prototype.unsubscribe = function () {\n        if (this.closed) {\n            return;\n        }\n        this.closed = true;\n        var subject = this.subject;\n        var observers = subject.observers;\n        this.subject = null;\n        if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {\n            return;\n        }\n        var subscriberIndex = observers.indexOf(this.subscriber);\n        if (subscriberIndex !== -1) {\n            observers.splice(subscriberIndex, 1);\n        }\n    };\n    return SubjectSubscription;\n}(Subscription_1.Subscription));\nexports.SubjectSubscription = SubjectSubscription;\n//# sourceMappingURL=SubjectSubscription.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/SubjectSubscription.js?");

/***/ }),

/***/ "./node_modules/rxjs/Subscriber.js":
/*!*****************************************!*\
  !*** ./node_modules/rxjs/Subscriber.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar isFunction_1 = __webpack_require__(/*! ./util/isFunction */ \"./node_modules/rxjs/util/isFunction.js\");\nvar Subscription_1 = __webpack_require__(/*! ./Subscription */ \"./node_modules/rxjs/Subscription.js\");\nvar Observer_1 = __webpack_require__(/*! ./Observer */ \"./node_modules/rxjs/Observer.js\");\nvar rxSubscriber_1 = __webpack_require__(/*! ./symbol/rxSubscriber */ \"./node_modules/rxjs/symbol/rxSubscriber.js\");\n/**\n * Implements the {@link Observer} interface and extends the\n * {@link Subscription} class. While the {@link Observer} is the public API for\n * consuming the values of an {@link Observable}, all Observers get converted to\n * a Subscriber, in order to provide Subscription-like capabilities such as\n * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for\n * implementing operators, but it is rarely used as a public API.\n *\n * @class Subscriber<T>\n */\nvar Subscriber = (function (_super) {\n    __extends(Subscriber, _super);\n    /**\n     * @param {Observer|function(value: T): void} [destinationOrNext] A partially\n     * defined Observer or a `next` callback function.\n     * @param {function(e: ?any): void} [error] The `error` callback of an\n     * Observer.\n     * @param {function(): void} [complete] The `complete` callback of an\n     * Observer.\n     */\n    function Subscriber(destinationOrNext, error, complete) {\n        _super.call(this);\n        this.syncErrorValue = null;\n        this.syncErrorThrown = false;\n        this.syncErrorThrowable = false;\n        this.isStopped = false;\n        switch (arguments.length) {\n            case 0:\n                this.destination = Observer_1.empty;\n                break;\n            case 1:\n                if (!destinationOrNext) {\n                    this.destination = Observer_1.empty;\n                    break;\n                }\n                if (typeof destinationOrNext === 'object') {\n                    if (destinationOrNext instanceof Subscriber) {\n                        this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;\n                        this.destination = destinationOrNext;\n                        this.destination.add(this);\n                    }\n                    else {\n                        this.syncErrorThrowable = true;\n                        this.destination = new SafeSubscriber(this, destinationOrNext);\n                    }\n                    break;\n                }\n            default:\n                this.syncErrorThrowable = true;\n                this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);\n                break;\n        }\n    }\n    Subscriber.prototype[rxSubscriber_1.rxSubscriber] = function () { return this; };\n    /**\n     * A static factory for a Subscriber, given a (potentially partial) definition\n     * of an Observer.\n     * @param {function(x: ?T): void} [next] The `next` callback of an Observer.\n     * @param {function(e: ?any): void} [error] The `error` callback of an\n     * Observer.\n     * @param {function(): void} [complete] The `complete` callback of an\n     * Observer.\n     * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)\n     * Observer represented by the given arguments.\n     */\n    Subscriber.create = function (next, error, complete) {\n        var subscriber = new Subscriber(next, error, complete);\n        subscriber.syncErrorThrowable = false;\n        return subscriber;\n    };\n    /**\n     * The {@link Observer} callback to receive notifications of type `next` from\n     * the Observable, with a value. The Observable may call this method 0 or more\n     * times.\n     * @param {T} [value] The `next` value.\n     * @return {void}\n     */\n    Subscriber.prototype.next = function (value) {\n        if (!this.isStopped) {\n            this._next(value);\n        }\n    };\n    /**\n     * The {@link Observer} callback to receive notifications of type `error` from\n     * the Observable, with an attached {@link Error}. Notifies the Observer that\n     * the Observable has experienced an error condition.\n     * @param {any} [err] The `error` exception.\n     * @return {void}\n     */\n    Subscriber.prototype.error = function (err) {\n        if (!this.isStopped) {\n            this.isStopped = true;\n            this._error(err);\n        }\n    };\n    /**\n     * The {@link Observer} callback to receive a valueless notification of type\n     * `complete` from the Observable. Notifies the Observer that the Observable\n     * has finished sending push-based notifications.\n     * @return {void}\n     */\n    Subscriber.prototype.complete = function () {\n        if (!this.isStopped) {\n            this.isStopped = true;\n            this._complete();\n        }\n    };\n    Subscriber.prototype.unsubscribe = function () {\n        if (this.closed) {\n            return;\n        }\n        this.isStopped = true;\n        _super.prototype.unsubscribe.call(this);\n    };\n    Subscriber.prototype._next = function (value) {\n        this.destination.next(value);\n    };\n    Subscriber.prototype._error = function (err) {\n        this.destination.error(err);\n        this.unsubscribe();\n    };\n    Subscriber.prototype._complete = function () {\n        this.destination.complete();\n        this.unsubscribe();\n    };\n    Subscriber.prototype._unsubscribeAndRecycle = function () {\n        var _a = this, _parent = _a._parent, _parents = _a._parents;\n        this._parent = null;\n        this._parents = null;\n        this.unsubscribe();\n        this.closed = false;\n        this.isStopped = false;\n        this._parent = _parent;\n        this._parents = _parents;\n        return this;\n    };\n    return Subscriber;\n}(Subscription_1.Subscription));\nexports.Subscriber = Subscriber;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SafeSubscriber = (function (_super) {\n    __extends(SafeSubscriber, _super);\n    function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {\n        _super.call(this);\n        this._parentSubscriber = _parentSubscriber;\n        var next;\n        var context = this;\n        if (isFunction_1.isFunction(observerOrNext)) {\n            next = observerOrNext;\n        }\n        else if (observerOrNext) {\n            next = observerOrNext.next;\n            error = observerOrNext.error;\n            complete = observerOrNext.complete;\n            if (observerOrNext !== Observer_1.empty) {\n                context = Object.create(observerOrNext);\n                if (isFunction_1.isFunction(context.unsubscribe)) {\n                    this.add(context.unsubscribe.bind(context));\n                }\n                context.unsubscribe = this.unsubscribe.bind(this);\n            }\n        }\n        this._context = context;\n        this._next = next;\n        this._error = error;\n        this._complete = complete;\n    }\n    SafeSubscriber.prototype.next = function (value) {\n        if (!this.isStopped && this._next) {\n            var _parentSubscriber = this._parentSubscriber;\n            if (!_parentSubscriber.syncErrorThrowable) {\n                this.__tryOrUnsub(this._next, value);\n            }\n            else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {\n                this.unsubscribe();\n            }\n        }\n    };\n    SafeSubscriber.prototype.error = function (err) {\n        if (!this.isStopped) {\n            var _parentSubscriber = this._parentSubscriber;\n            if (this._error) {\n                if (!_parentSubscriber.syncErrorThrowable) {\n                    this.__tryOrUnsub(this._error, err);\n                    this.unsubscribe();\n                }\n                else {\n                    this.__tryOrSetError(_parentSubscriber, this._error, err);\n                    this.unsubscribe();\n                }\n            }\n            else if (!_parentSubscriber.syncErrorThrowable) {\n                this.unsubscribe();\n                throw err;\n            }\n            else {\n                _parentSubscriber.syncErrorValue = err;\n                _parentSubscriber.syncErrorThrown = true;\n                this.unsubscribe();\n            }\n        }\n    };\n    SafeSubscriber.prototype.complete = function () {\n        var _this = this;\n        if (!this.isStopped) {\n            var _parentSubscriber = this._parentSubscriber;\n            if (this._complete) {\n                var wrappedComplete = function () { return _this._complete.call(_this._context); };\n                if (!_parentSubscriber.syncErrorThrowable) {\n                    this.__tryOrUnsub(wrappedComplete);\n                    this.unsubscribe();\n                }\n                else {\n                    this.__tryOrSetError(_parentSubscriber, wrappedComplete);\n                    this.unsubscribe();\n                }\n            }\n            else {\n                this.unsubscribe();\n            }\n        }\n    };\n    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {\n        try {\n            fn.call(this._context, value);\n        }\n        catch (err) {\n            this.unsubscribe();\n            throw err;\n        }\n    };\n    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {\n        try {\n            fn.call(this._context, value);\n        }\n        catch (err) {\n            parent.syncErrorValue = err;\n            parent.syncErrorThrown = true;\n            return true;\n        }\n        return false;\n    };\n    SafeSubscriber.prototype._unsubscribe = function () {\n        var _parentSubscriber = this._parentSubscriber;\n        this._context = null;\n        this._parentSubscriber = null;\n        _parentSubscriber.unsubscribe();\n    };\n    return SafeSubscriber;\n}(Subscriber));\n//# sourceMappingURL=Subscriber.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/Subscriber.js?");

/***/ }),

/***/ "./node_modules/rxjs/Subscription.js":
/*!*******************************************!*\
  !*** ./node_modules/rxjs/Subscription.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar isArray_1 = __webpack_require__(/*! ./util/isArray */ \"./node_modules/rxjs/util/isArray.js\");\nvar isObject_1 = __webpack_require__(/*! ./util/isObject */ \"./node_modules/rxjs/util/isObject.js\");\nvar isFunction_1 = __webpack_require__(/*! ./util/isFunction */ \"./node_modules/rxjs/util/isFunction.js\");\nvar tryCatch_1 = __webpack_require__(/*! ./util/tryCatch */ \"./node_modules/rxjs/util/tryCatch.js\");\nvar errorObject_1 = __webpack_require__(/*! ./util/errorObject */ \"./node_modules/rxjs/util/errorObject.js\");\nvar UnsubscriptionError_1 = __webpack_require__(/*! ./util/UnsubscriptionError */ \"./node_modules/rxjs/util/UnsubscriptionError.js\");\n/**\n * Represents a disposable resource, such as the execution of an Observable. A\n * Subscription has one important method, `unsubscribe`, that takes no argument\n * and just disposes the resource held by the subscription.\n *\n * Additionally, subscriptions may be grouped together through the `add()`\n * method, which will attach a child Subscription to the current Subscription.\n * When a Subscription is unsubscribed, all its children (and its grandchildren)\n * will be unsubscribed as well.\n *\n * @class Subscription\n */\nvar Subscription = (function () {\n    /**\n     * @param {function(): void} [unsubscribe] A function describing how to\n     * perform the disposal of resources when the `unsubscribe` method is called.\n     */\n    function Subscription(unsubscribe) {\n        /**\n         * A flag to indicate whether this Subscription has already been unsubscribed.\n         * @type {boolean}\n         */\n        this.closed = false;\n        this._parent = null;\n        this._parents = null;\n        this._subscriptions = null;\n        if (unsubscribe) {\n            this._unsubscribe = unsubscribe;\n        }\n    }\n    /**\n     * Disposes the resources held by the subscription. May, for instance, cancel\n     * an ongoing Observable execution or cancel any other type of work that\n     * started when the Subscription was created.\n     * @return {void}\n     */\n    Subscription.prototype.unsubscribe = function () {\n        var hasErrors = false;\n        var errors;\n        if (this.closed) {\n            return;\n        }\n        var _a = this, _parent = _a._parent, _parents = _a._parents, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;\n        this.closed = true;\n        this._parent = null;\n        this._parents = null;\n        // null out _subscriptions first so any child subscriptions that attempt\n        // to remove themselves from this subscription will noop\n        this._subscriptions = null;\n        var index = -1;\n        var len = _parents ? _parents.length : 0;\n        // if this._parent is null, then so is this._parents, and we\n        // don't have to remove ourselves from any parent subscriptions.\n        while (_parent) {\n            _parent.remove(this);\n            // if this._parents is null or index >= len,\n            // then _parent is set to null, and the loop exits\n            _parent = ++index < len && _parents[index] || null;\n        }\n        if (isFunction_1.isFunction(_unsubscribe)) {\n            var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);\n            if (trial === errorObject_1.errorObject) {\n                hasErrors = true;\n                errors = errors || (errorObject_1.errorObject.e instanceof UnsubscriptionError_1.UnsubscriptionError ?\n                    flattenUnsubscriptionErrors(errorObject_1.errorObject.e.errors) : [errorObject_1.errorObject.e]);\n            }\n        }\n        if (isArray_1.isArray(_subscriptions)) {\n            index = -1;\n            len = _subscriptions.length;\n            while (++index < len) {\n                var sub = _subscriptions[index];\n                if (isObject_1.isObject(sub)) {\n                    var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);\n                    if (trial === errorObject_1.errorObject) {\n                        hasErrors = true;\n                        errors = errors || [];\n                        var err = errorObject_1.errorObject.e;\n                        if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {\n                            errors = errors.concat(flattenUnsubscriptionErrors(err.errors));\n                        }\n                        else {\n                            errors.push(err);\n                        }\n                    }\n                }\n            }\n        }\n        if (hasErrors) {\n            throw new UnsubscriptionError_1.UnsubscriptionError(errors);\n        }\n    };\n    /**\n     * Adds a tear down to be called during the unsubscribe() of this\n     * Subscription.\n     *\n     * If the tear down being added is a subscription that is already\n     * unsubscribed, is the same reference `add` is being called on, or is\n     * `Subscription.EMPTY`, it will not be added.\n     *\n     * If this subscription is already in an `closed` state, the passed\n     * tear down logic will be executed immediately.\n     *\n     * @param {TeardownLogic} teardown The additional logic to execute on\n     * teardown.\n     * @return {Subscription} Returns the Subscription used or created to be\n     * added to the inner subscriptions list. This Subscription can be used with\n     * `remove()` to remove the passed teardown logic from the inner subscriptions\n     * list.\n     */\n    Subscription.prototype.add = function (teardown) {\n        if (!teardown || (teardown === Subscription.EMPTY)) {\n            return Subscription.EMPTY;\n        }\n        if (teardown === this) {\n            return this;\n        }\n        var subscription = teardown;\n        switch (typeof teardown) {\n            case 'function':\n                subscription = new Subscription(teardown);\n            case 'object':\n                if (subscription.closed || typeof subscription.unsubscribe !== 'function') {\n                    return subscription;\n                }\n                else if (this.closed) {\n                    subscription.unsubscribe();\n                    return subscription;\n                }\n                else if (typeof subscription._addParent !== 'function' /* quack quack */) {\n                    var tmp = subscription;\n                    subscription = new Subscription();\n                    subscription._subscriptions = [tmp];\n                }\n                break;\n            default:\n                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');\n        }\n        var subscriptions = this._subscriptions || (this._subscriptions = []);\n        subscriptions.push(subscription);\n        subscription._addParent(this);\n        return subscription;\n    };\n    /**\n     * Removes a Subscription from the internal list of subscriptions that will\n     * unsubscribe during the unsubscribe process of this Subscription.\n     * @param {Subscription} subscription The subscription to remove.\n     * @return {void}\n     */\n    Subscription.prototype.remove = function (subscription) {\n        var subscriptions = this._subscriptions;\n        if (subscriptions) {\n            var subscriptionIndex = subscriptions.indexOf(subscription);\n            if (subscriptionIndex !== -1) {\n                subscriptions.splice(subscriptionIndex, 1);\n            }\n        }\n    };\n    Subscription.prototype._addParent = function (parent) {\n        var _a = this, _parent = _a._parent, _parents = _a._parents;\n        if (!_parent || _parent === parent) {\n            // If we don't have a parent, or the new parent is the same as the\n            // current parent, then set this._parent to the new parent.\n            this._parent = parent;\n        }\n        else if (!_parents) {\n            // If there's already one parent, but not multiple, allocate an Array to\n            // store the rest of the parent Subscriptions.\n            this._parents = [parent];\n        }\n        else if (_parents.indexOf(parent) === -1) {\n            // Only add the new parent to the _parents list if it's not already there.\n            _parents.push(parent);\n        }\n    };\n    Subscription.EMPTY = (function (empty) {\n        empty.closed = true;\n        return empty;\n    }(new Subscription()));\n    return Subscription;\n}());\nexports.Subscription = Subscription;\nfunction flattenUnsubscriptionErrors(errors) {\n    return errors.reduce(function (errs, err) { return errs.concat((err instanceof UnsubscriptionError_1.UnsubscriptionError) ? err.errors : err); }, []);\n}\n//# sourceMappingURL=Subscription.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/Subscription.js?");

/***/ }),

/***/ "./node_modules/rxjs/add/observable/combineLatest.js":
/*!***********************************************************!*\
  !*** ./node_modules/rxjs/add/observable/combineLatest.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Observable_1 = __webpack_require__(/*! ../../Observable */ \"./node_modules/rxjs/Observable.js\");\nvar combineLatest_1 = __webpack_require__(/*! ../../observable/combineLatest */ \"./node_modules/rxjs/observable/combineLatest.js\");\nObservable_1.Observable.combineLatest = combineLatest_1.combineLatest;\n//# sourceMappingURL=combineLatest.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/add/observable/combineLatest.js?");

/***/ }),

/***/ "./node_modules/rxjs/add/observable/defer.js":
/*!***************************************************!*\
  !*** ./node_modules/rxjs/add/observable/defer.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Observable_1 = __webpack_require__(/*! ../../Observable */ \"./node_modules/rxjs/Observable.js\");\nvar defer_1 = __webpack_require__(/*! ../../observable/defer */ \"./node_modules/rxjs/observable/defer.js\");\nObservable_1.Observable.defer = defer_1.defer;\n//# sourceMappingURL=defer.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/add/observable/defer.js?");

/***/ }),

/***/ "./node_modules/rxjs/add/observable/empty.js":
/*!***************************************************!*\
  !*** ./node_modules/rxjs/add/observable/empty.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Observable_1 = __webpack_require__(/*! ../../Observable */ \"./node_modules/rxjs/Observable.js\");\nvar empty_1 = __webpack_require__(/*! ../../observable/empty */ \"./node_modules/rxjs/observable/empty.js\");\nObservable_1.Observable.empty = empty_1.empty;\n//# sourceMappingURL=empty.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/add/observable/empty.js?");

/***/ }),

/***/ "./node_modules/rxjs/add/observable/from.js":
/*!**************************************************!*\
  !*** ./node_modules/rxjs/add/observable/from.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Observable_1 = __webpack_require__(/*! ../../Observable */ \"./node_modules/rxjs/Observable.js\");\nvar from_1 = __webpack_require__(/*! ../../observable/from */ \"./node_modules/rxjs/observable/from.js\");\nObservable_1.Observable.from = from_1.from;\n//# sourceMappingURL=from.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/add/observable/from.js?");

/***/ }),

/***/ "./node_modules/rxjs/add/observable/fromEvent.js":
/*!*******************************************************!*\
  !*** ./node_modules/rxjs/add/observable/fromEvent.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Observable_1 = __webpack_require__(/*! ../../Observable */ \"./node_modules/rxjs/Observable.js\");\nvar fromEvent_1 = __webpack_require__(/*! ../../observable/fromEvent */ \"./node_modules/rxjs/observable/fromEvent.js\");\nObservable_1.Observable.fromEvent = fromEvent_1.fromEvent;\n//# sourceMappingURL=fromEvent.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/add/observable/fromEvent.js?");

/***/ }),

/***/ "./node_modules/rxjs/add/observable/fromPromise.js":
/*!*********************************************************!*\
  !*** ./node_modules/rxjs/add/observable/fromPromise.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Observable_1 = __webpack_require__(/*! ../../Observable */ \"./node_modules/rxjs/Observable.js\");\nvar fromPromise_1 = __webpack_require__(/*! ../../observable/fromPromise */ \"./node_modules/rxjs/observable/fromPromise.js\");\nObservable_1.Observable.fromPromise = fromPromise_1.fromPromise;\n//# sourceMappingURL=fromPromise.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/add/observable/fromPromise.js?");

/***/ }),

/***/ "./node_modules/rxjs/add/observable/interval.js":
/*!******************************************************!*\
  !*** ./node_modules/rxjs/add/observable/interval.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Observable_1 = __webpack_require__(/*! ../../Observable */ \"./node_modules/rxjs/Observable.js\");\nvar interval_1 = __webpack_require__(/*! ../../observable/interval */ \"./node_modules/rxjs/observable/interval.js\");\nObservable_1.Observable.interval = interval_1.interval;\n//# sourceMappingURL=interval.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/add/observable/interval.js?");

/***/ }),

/***/ "./node_modules/rxjs/add/observable/merge.js":
/*!***************************************************!*\
  !*** ./node_modules/rxjs/add/observable/merge.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Observable_1 = __webpack_require__(/*! ../../Observable */ \"./node_modules/rxjs/Observable.js\");\nvar merge_1 = __webpack_require__(/*! ../../observable/merge */ \"./node_modules/rxjs/observable/merge.js\");\nObservable_1.Observable.merge = merge_1.merge;\n//# sourceMappingURL=merge.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/add/observable/merge.js?");

/***/ }),

/***/ "./node_modules/rxjs/add/observable/never.js":
/*!***************************************************!*\
  !*** ./node_modules/rxjs/add/observable/never.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Observable_1 = __webpack_require__(/*! ../../Observable */ \"./node_modules/rxjs/Observable.js\");\nvar never_1 = __webpack_require__(/*! ../../observable/never */ \"./node_modules/rxjs/observable/never.js\");\nObservable_1.Observable.never = never_1.never;\n//# sourceMappingURL=never.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/add/observable/never.js?");

/***/ }),

/***/ "./node_modules/rxjs/add/observable/of.js":
/*!************************************************!*\
  !*** ./node_modules/rxjs/add/observable/of.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Observable_1 = __webpack_require__(/*! ../../Observable */ \"./node_modules/rxjs/Observable.js\");\nvar of_1 = __webpack_require__(/*! ../../observable/of */ \"./node_modules/rxjs/observable/of.js\");\nObservable_1.Observable.of = of_1.of;\n//# sourceMappingURL=of.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/add/observable/of.js?");

/***/ }),

/***/ "./node_modules/rxjs/add/observable/throw.js":
/*!***************************************************!*\
  !*** ./node_modules/rxjs/add/observable/throw.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Observable_1 = __webpack_require__(/*! ../../Observable */ \"./node_modules/rxjs/Observable.js\");\nvar throw_1 = __webpack_require__(/*! ../../observable/throw */ \"./node_modules/rxjs/observable/throw.js\");\nObservable_1.Observable.throw = throw_1._throw;\n//# sourceMappingURL=throw.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/add/observable/throw.js?");

/***/ }),

/***/ "./node_modules/rxjs/add/observable/timer.js":
/*!***************************************************!*\
  !*** ./node_modules/rxjs/add/observable/timer.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Observable_1 = __webpack_require__(/*! ../../Observable */ \"./node_modules/rxjs/Observable.js\");\nvar timer_1 = __webpack_require__(/*! ../../observable/timer */ \"./node_modules/rxjs/observable/timer.js\");\nObservable_1.Observable.timer = timer_1.timer;\n//# sourceMappingURL=timer.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/add/observable/timer.js?");

/***/ }),

/***/ "./node_modules/rxjs/add/operator/catch.js":
/*!*************************************************!*\
  !*** ./node_modules/rxjs/add/operator/catch.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Observable_1 = __webpack_require__(/*! ../../Observable */ \"./node_modules/rxjs/Observable.js\");\nvar catch_1 = __webpack_require__(/*! ../../operator/catch */ \"./node_modules/rxjs/operator/catch.js\");\nObservable_1.Observable.prototype.catch = catch_1._catch;\nObservable_1.Observable.prototype._catch = catch_1._catch;\n//# sourceMappingURL=catch.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/add/operator/catch.js?");

/***/ }),

/***/ "./node_modules/rxjs/add/operator/concat.js":
/*!**************************************************!*\
  !*** ./node_modules/rxjs/add/operator/concat.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Observable_1 = __webpack_require__(/*! ../../Observable */ \"./node_modules/rxjs/Observable.js\");\nvar concat_1 = __webpack_require__(/*! ../../operator/concat */ \"./node_modules/rxjs/operator/concat.js\");\nObservable_1.Observable.prototype.concat = concat_1.concat;\n//# sourceMappingURL=concat.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/add/operator/concat.js?");

/***/ }),

/***/ "./node_modules/rxjs/add/operator/concatAll.js":
/*!*****************************************************!*\
  !*** ./node_modules/rxjs/add/operator/concatAll.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Observable_1 = __webpack_require__(/*! ../../Observable */ \"./node_modules/rxjs/Observable.js\");\nvar concatAll_1 = __webpack_require__(/*! ../../operator/concatAll */ \"./node_modules/rxjs/operator/concatAll.js\");\nObservable_1.Observable.prototype.concatAll = concatAll_1.concatAll;\n//# sourceMappingURL=concatAll.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/add/operator/concatAll.js?");

/***/ }),

/***/ "./node_modules/rxjs/add/operator/concatMap.js":
/*!*****************************************************!*\
  !*** ./node_modules/rxjs/add/operator/concatMap.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Observable_1 = __webpack_require__(/*! ../../Observable */ \"./node_modules/rxjs/Observable.js\");\nvar concatMap_1 = __webpack_require__(/*! ../../operator/concatMap */ \"./node_modules/rxjs/operator/concatMap.js\");\nObservable_1.Observable.prototype.concatMap = concatMap_1.concatMap;\n//# sourceMappingURL=concatMap.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/add/operator/concatMap.js?");

/***/ }),

/***/ "./node_modules/rxjs/add/operator/debounceTime.js":
/*!********************************************************!*\
  !*** ./node_modules/rxjs/add/operator/debounceTime.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Observable_1 = __webpack_require__(/*! ../../Observable */ \"./node_modules/rxjs/Observable.js\");\nvar debounceTime_1 = __webpack_require__(/*! ../../operator/debounceTime */ \"./node_modules/rxjs/operator/debounceTime.js\");\nObservable_1.Observable.prototype.debounceTime = debounceTime_1.debounceTime;\n//# sourceMappingURL=debounceTime.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/add/operator/debounceTime.js?");

/***/ }),

/***/ "./node_modules/rxjs/add/operator/distinctUntilChanged.js":
/*!****************************************************************!*\
  !*** ./node_modules/rxjs/add/operator/distinctUntilChanged.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Observable_1 = __webpack_require__(/*! ../../Observable */ \"./node_modules/rxjs/Observable.js\");\nvar distinctUntilChanged_1 = __webpack_require__(/*! ../../operator/distinctUntilChanged */ \"./node_modules/rxjs/operator/distinctUntilChanged.js\");\nObservable_1.Observable.prototype.distinctUntilChanged = distinctUntilChanged_1.distinctUntilChanged;\n//# sourceMappingURL=distinctUntilChanged.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/add/operator/distinctUntilChanged.js?");

/***/ }),

/***/ "./node_modules/rxjs/add/operator/do.js":
/*!**********************************************!*\
  !*** ./node_modules/rxjs/add/operator/do.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Observable_1 = __webpack_require__(/*! ../../Observable */ \"./node_modules/rxjs/Observable.js\");\nvar do_1 = __webpack_require__(/*! ../../operator/do */ \"./node_modules/rxjs/operator/do.js\");\nObservable_1.Observable.prototype.do = do_1._do;\nObservable_1.Observable.prototype._do = do_1._do;\n//# sourceMappingURL=do.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/add/operator/do.js?");

/***/ }),

/***/ "./node_modules/rxjs/add/operator/exhaustMap.js":
/*!******************************************************!*\
  !*** ./node_modules/rxjs/add/operator/exhaustMap.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Observable_1 = __webpack_require__(/*! ../../Observable */ \"./node_modules/rxjs/Observable.js\");\nvar exhaustMap_1 = __webpack_require__(/*! ../../operator/exhaustMap */ \"./node_modules/rxjs/operator/exhaustMap.js\");\nObservable_1.Observable.prototype.exhaustMap = exhaustMap_1.exhaustMap;\n//# sourceMappingURL=exhaustMap.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/add/operator/exhaustMap.js?");

/***/ }),

/***/ "./node_modules/rxjs/add/operator/filter.js":
/*!**************************************************!*\
  !*** ./node_modules/rxjs/add/operator/filter.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Observable_1 = __webpack_require__(/*! ../../Observable */ \"./node_modules/rxjs/Observable.js\");\nvar filter_1 = __webpack_require__(/*! ../../operator/filter */ \"./node_modules/rxjs/operator/filter.js\");\nObservable_1.Observable.prototype.filter = filter_1.filter;\n//# sourceMappingURL=filter.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/add/operator/filter.js?");

/***/ }),

/***/ "./node_modules/rxjs/add/operator/finally.js":
/*!***************************************************!*\
  !*** ./node_modules/rxjs/add/operator/finally.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Observable_1 = __webpack_require__(/*! ../../Observable */ \"./node_modules/rxjs/Observable.js\");\nvar finally_1 = __webpack_require__(/*! ../../operator/finally */ \"./node_modules/rxjs/operator/finally.js\");\nObservable_1.Observable.prototype.finally = finally_1._finally;\nObservable_1.Observable.prototype._finally = finally_1._finally;\n//# sourceMappingURL=finally.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/add/operator/finally.js?");

/***/ }),

/***/ "./node_modules/rxjs/add/operator/ignoreElements.js":
/*!**********************************************************!*\
  !*** ./node_modules/rxjs/add/operator/ignoreElements.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Observable_1 = __webpack_require__(/*! ../../Observable */ \"./node_modules/rxjs/Observable.js\");\nvar ignoreElements_1 = __webpack_require__(/*! ../../operator/ignoreElements */ \"./node_modules/rxjs/operator/ignoreElements.js\");\nObservable_1.Observable.prototype.ignoreElements = ignoreElements_1.ignoreElements;\n//# sourceMappingURL=ignoreElements.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/add/operator/ignoreElements.js?");

/***/ }),

/***/ "./node_modules/rxjs/add/operator/map.js":
/*!***********************************************!*\
  !*** ./node_modules/rxjs/add/operator/map.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Observable_1 = __webpack_require__(/*! ../../Observable */ \"./node_modules/rxjs/Observable.js\");\nvar map_1 = __webpack_require__(/*! ../../operator/map */ \"./node_modules/rxjs/operator/map.js\");\nObservable_1.Observable.prototype.map = map_1.map;\n//# sourceMappingURL=map.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/add/operator/map.js?");

/***/ }),

/***/ "./node_modules/rxjs/add/operator/mapTo.js":
/*!*************************************************!*\
  !*** ./node_modules/rxjs/add/operator/mapTo.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Observable_1 = __webpack_require__(/*! ../../Observable */ \"./node_modules/rxjs/Observable.js\");\nvar mapTo_1 = __webpack_require__(/*! ../../operator/mapTo */ \"./node_modules/rxjs/operator/mapTo.js\");\nObservable_1.Observable.prototype.mapTo = mapTo_1.mapTo;\n//# sourceMappingURL=mapTo.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/add/operator/mapTo.js?");

/***/ }),

/***/ "./node_modules/rxjs/add/operator/merge.js":
/*!*************************************************!*\
  !*** ./node_modules/rxjs/add/operator/merge.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Observable_1 = __webpack_require__(/*! ../../Observable */ \"./node_modules/rxjs/Observable.js\");\nvar merge_1 = __webpack_require__(/*! ../../operator/merge */ \"./node_modules/rxjs/operator/merge.js\");\nObservable_1.Observable.prototype.merge = merge_1.merge;\n//# sourceMappingURL=merge.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/add/operator/merge.js?");

/***/ }),

/***/ "./node_modules/rxjs/add/operator/mergeMap.js":
/*!****************************************************!*\
  !*** ./node_modules/rxjs/add/operator/mergeMap.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Observable_1 = __webpack_require__(/*! ../../Observable */ \"./node_modules/rxjs/Observable.js\");\nvar mergeMap_1 = __webpack_require__(/*! ../../operator/mergeMap */ \"./node_modules/rxjs/operator/mergeMap.js\");\nObservable_1.Observable.prototype.mergeMap = mergeMap_1.mergeMap;\nObservable_1.Observable.prototype.flatMap = mergeMap_1.mergeMap;\n//# sourceMappingURL=mergeMap.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/add/operator/mergeMap.js?");

/***/ }),

/***/ "./node_modules/rxjs/add/operator/mergeMapTo.js":
/*!******************************************************!*\
  !*** ./node_modules/rxjs/add/operator/mergeMapTo.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Observable_1 = __webpack_require__(/*! ../../Observable */ \"./node_modules/rxjs/Observable.js\");\nvar mergeMapTo_1 = __webpack_require__(/*! ../../operator/mergeMapTo */ \"./node_modules/rxjs/operator/mergeMapTo.js\");\nObservable_1.Observable.prototype.flatMapTo = mergeMapTo_1.mergeMapTo;\nObservable_1.Observable.prototype.mergeMapTo = mergeMapTo_1.mergeMapTo;\n//# sourceMappingURL=mergeMapTo.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/add/operator/mergeMapTo.js?");

/***/ }),

/***/ "./node_modules/rxjs/add/operator/multicast.js":
/*!*****************************************************!*\
  !*** ./node_modules/rxjs/add/operator/multicast.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Observable_1 = __webpack_require__(/*! ../../Observable */ \"./node_modules/rxjs/Observable.js\");\nvar multicast_1 = __webpack_require__(/*! ../../operator/multicast */ \"./node_modules/rxjs/operator/multicast.js\");\nObservable_1.Observable.prototype.multicast = multicast_1.multicast;\n//# sourceMappingURL=multicast.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/add/operator/multicast.js?");

/***/ }),

/***/ "./node_modules/rxjs/add/operator/pairwise.js":
/*!****************************************************!*\
  !*** ./node_modules/rxjs/add/operator/pairwise.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Observable_1 = __webpack_require__(/*! ../../Observable */ \"./node_modules/rxjs/Observable.js\");\nvar pairwise_1 = __webpack_require__(/*! ../../operator/pairwise */ \"./node_modules/rxjs/operator/pairwise.js\");\nObservable_1.Observable.prototype.pairwise = pairwise_1.pairwise;\n//# sourceMappingURL=pairwise.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/add/operator/pairwise.js?");

/***/ }),

/***/ "./node_modules/rxjs/add/operator/publish.js":
/*!***************************************************!*\
  !*** ./node_modules/rxjs/add/operator/publish.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Observable_1 = __webpack_require__(/*! ../../Observable */ \"./node_modules/rxjs/Observable.js\");\nvar publish_1 = __webpack_require__(/*! ../../operator/publish */ \"./node_modules/rxjs/operator/publish.js\");\nObservable_1.Observable.prototype.publish = publish_1.publish;\n//# sourceMappingURL=publish.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/add/operator/publish.js?");

/***/ }),

/***/ "./node_modules/rxjs/add/operator/scan.js":
/*!************************************************!*\
  !*** ./node_modules/rxjs/add/operator/scan.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Observable_1 = __webpack_require__(/*! ../../Observable */ \"./node_modules/rxjs/Observable.js\");\nvar scan_1 = __webpack_require__(/*! ../../operator/scan */ \"./node_modules/rxjs/operator/scan.js\");\nObservable_1.Observable.prototype.scan = scan_1.scan;\n//# sourceMappingURL=scan.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/add/operator/scan.js?");

/***/ }),

/***/ "./node_modules/rxjs/add/operator/share.js":
/*!*************************************************!*\
  !*** ./node_modules/rxjs/add/operator/share.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Observable_1 = __webpack_require__(/*! ../../Observable */ \"./node_modules/rxjs/Observable.js\");\nvar share_1 = __webpack_require__(/*! ../../operator/share */ \"./node_modules/rxjs/operator/share.js\");\nObservable_1.Observable.prototype.share = share_1.share;\n//# sourceMappingURL=share.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/add/operator/share.js?");

/***/ }),

/***/ "./node_modules/rxjs/add/operator/skip.js":
/*!************************************************!*\
  !*** ./node_modules/rxjs/add/operator/skip.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Observable_1 = __webpack_require__(/*! ../../Observable */ \"./node_modules/rxjs/Observable.js\");\nvar skip_1 = __webpack_require__(/*! ../../operator/skip */ \"./node_modules/rxjs/operator/skip.js\");\nObservable_1.Observable.prototype.skip = skip_1.skip;\n//# sourceMappingURL=skip.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/add/operator/skip.js?");

/***/ }),

/***/ "./node_modules/rxjs/add/operator/skipUntil.js":
/*!*****************************************************!*\
  !*** ./node_modules/rxjs/add/operator/skipUntil.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Observable_1 = __webpack_require__(/*! ../../Observable */ \"./node_modules/rxjs/Observable.js\");\nvar skipUntil_1 = __webpack_require__(/*! ../../operator/skipUntil */ \"./node_modules/rxjs/operator/skipUntil.js\");\nObservable_1.Observable.prototype.skipUntil = skipUntil_1.skipUntil;\n//# sourceMappingURL=skipUntil.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/add/operator/skipUntil.js?");

/***/ }),

/***/ "./node_modules/rxjs/add/operator/skipWhile.js":
/*!*****************************************************!*\
  !*** ./node_modules/rxjs/add/operator/skipWhile.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Observable_1 = __webpack_require__(/*! ../../Observable */ \"./node_modules/rxjs/Observable.js\");\nvar skipWhile_1 = __webpack_require__(/*! ../../operator/skipWhile */ \"./node_modules/rxjs/operator/skipWhile.js\");\nObservable_1.Observable.prototype.skipWhile = skipWhile_1.skipWhile;\n//# sourceMappingURL=skipWhile.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/add/operator/skipWhile.js?");

/***/ }),

/***/ "./node_modules/rxjs/add/operator/startWith.js":
/*!*****************************************************!*\
  !*** ./node_modules/rxjs/add/operator/startWith.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Observable_1 = __webpack_require__(/*! ../../Observable */ \"./node_modules/rxjs/Observable.js\");\nvar startWith_1 = __webpack_require__(/*! ../../operator/startWith */ \"./node_modules/rxjs/operator/startWith.js\");\nObservable_1.Observable.prototype.startWith = startWith_1.startWith;\n//# sourceMappingURL=startWith.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/add/operator/startWith.js?");

/***/ }),

/***/ "./node_modules/rxjs/add/operator/switchMap.js":
/*!*****************************************************!*\
  !*** ./node_modules/rxjs/add/operator/switchMap.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Observable_1 = __webpack_require__(/*! ../../Observable */ \"./node_modules/rxjs/Observable.js\");\nvar switchMap_1 = __webpack_require__(/*! ../../operator/switchMap */ \"./node_modules/rxjs/operator/switchMap.js\");\nObservable_1.Observable.prototype.switchMap = switchMap_1.switchMap;\n//# sourceMappingURL=switchMap.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/add/operator/switchMap.js?");

/***/ }),

/***/ "./node_modules/rxjs/add/operator/switchMapTo.js":
/*!*******************************************************!*\
  !*** ./node_modules/rxjs/add/operator/switchMapTo.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Observable_1 = __webpack_require__(/*! ../../Observable */ \"./node_modules/rxjs/Observable.js\");\nvar switchMapTo_1 = __webpack_require__(/*! ../../operator/switchMapTo */ \"./node_modules/rxjs/operator/switchMapTo.js\");\nObservable_1.Observable.prototype.switchMapTo = switchMapTo_1.switchMapTo;\n//# sourceMappingURL=switchMapTo.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/add/operator/switchMapTo.js?");

/***/ }),

/***/ "./node_modules/rxjs/add/operator/take.js":
/*!************************************************!*\
  !*** ./node_modules/rxjs/add/operator/take.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Observable_1 = __webpack_require__(/*! ../../Observable */ \"./node_modules/rxjs/Observable.js\");\nvar take_1 = __webpack_require__(/*! ../../operator/take */ \"./node_modules/rxjs/operator/take.js\");\nObservable_1.Observable.prototype.take = take_1.take;\n//# sourceMappingURL=take.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/add/operator/take.js?");

/***/ }),

/***/ "./node_modules/rxjs/add/operator/takeUntil.js":
/*!*****************************************************!*\
  !*** ./node_modules/rxjs/add/operator/takeUntil.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Observable_1 = __webpack_require__(/*! ../../Observable */ \"./node_modules/rxjs/Observable.js\");\nvar takeUntil_1 = __webpack_require__(/*! ../../operator/takeUntil */ \"./node_modules/rxjs/operator/takeUntil.js\");\nObservable_1.Observable.prototype.takeUntil = takeUntil_1.takeUntil;\n//# sourceMappingURL=takeUntil.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/add/operator/takeUntil.js?");

/***/ }),

/***/ "./node_modules/rxjs/add/operator/timeout.js":
/*!***************************************************!*\
  !*** ./node_modules/rxjs/add/operator/timeout.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Observable_1 = __webpack_require__(/*! ../../Observable */ \"./node_modules/rxjs/Observable.js\");\nvar timeout_1 = __webpack_require__(/*! ../../operator/timeout */ \"./node_modules/rxjs/operator/timeout.js\");\nObservable_1.Observable.prototype.timeout = timeout_1.timeout;\n//# sourceMappingURL=timeout.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/add/operator/timeout.js?");

/***/ }),

/***/ "./node_modules/rxjs/add/operator/withLatestFrom.js":
/*!**********************************************************!*\
  !*** ./node_modules/rxjs/add/operator/withLatestFrom.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Observable_1 = __webpack_require__(/*! ../../Observable */ \"./node_modules/rxjs/Observable.js\");\nvar withLatestFrom_1 = __webpack_require__(/*! ../../operator/withLatestFrom */ \"./node_modules/rxjs/operator/withLatestFrom.js\");\nObservable_1.Observable.prototype.withLatestFrom = withLatestFrom_1.withLatestFrom;\n//# sourceMappingURL=withLatestFrom.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/add/operator/withLatestFrom.js?");

/***/ }),

/***/ "./node_modules/rxjs/observable/ArrayLikeObservable.js":
/*!*************************************************************!*\
  !*** ./node_modules/rxjs/observable/ArrayLikeObservable.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = __webpack_require__(/*! ../Observable */ \"./node_modules/rxjs/Observable.js\");\nvar ScalarObservable_1 = __webpack_require__(/*! ./ScalarObservable */ \"./node_modules/rxjs/observable/ScalarObservable.js\");\nvar EmptyObservable_1 = __webpack_require__(/*! ./EmptyObservable */ \"./node_modules/rxjs/observable/EmptyObservable.js\");\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar ArrayLikeObservable = (function (_super) {\n    __extends(ArrayLikeObservable, _super);\n    function ArrayLikeObservable(arrayLike, scheduler) {\n        _super.call(this);\n        this.arrayLike = arrayLike;\n        this.scheduler = scheduler;\n        if (!scheduler && arrayLike.length === 1) {\n            this._isScalar = true;\n            this.value = arrayLike[0];\n        }\n    }\n    ArrayLikeObservable.create = function (arrayLike, scheduler) {\n        var length = arrayLike.length;\n        if (length === 0) {\n            return new EmptyObservable_1.EmptyObservable();\n        }\n        else if (length === 1) {\n            return new ScalarObservable_1.ScalarObservable(arrayLike[0], scheduler);\n        }\n        else {\n            return new ArrayLikeObservable(arrayLike, scheduler);\n        }\n    };\n    ArrayLikeObservable.dispatch = function (state) {\n        var arrayLike = state.arrayLike, index = state.index, length = state.length, subscriber = state.subscriber;\n        if (subscriber.closed) {\n            return;\n        }\n        if (index >= length) {\n            subscriber.complete();\n            return;\n        }\n        subscriber.next(arrayLike[index]);\n        state.index = index + 1;\n        this.schedule(state);\n    };\n    ArrayLikeObservable.prototype._subscribe = function (subscriber) {\n        var index = 0;\n        var _a = this, arrayLike = _a.arrayLike, scheduler = _a.scheduler;\n        var length = arrayLike.length;\n        if (scheduler) {\n            return scheduler.schedule(ArrayLikeObservable.dispatch, 0, {\n                arrayLike: arrayLike, index: index, length: length, subscriber: subscriber\n            });\n        }\n        else {\n            for (var i = 0; i < length && !subscriber.closed; i++) {\n                subscriber.next(arrayLike[i]);\n            }\n            subscriber.complete();\n        }\n    };\n    return ArrayLikeObservable;\n}(Observable_1.Observable));\nexports.ArrayLikeObservable = ArrayLikeObservable;\n//# sourceMappingURL=ArrayLikeObservable.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/observable/ArrayLikeObservable.js?");

/***/ }),

/***/ "./node_modules/rxjs/observable/ArrayObservable.js":
/*!*********************************************************!*\
  !*** ./node_modules/rxjs/observable/ArrayObservable.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = __webpack_require__(/*! ../Observable */ \"./node_modules/rxjs/Observable.js\");\nvar ScalarObservable_1 = __webpack_require__(/*! ./ScalarObservable */ \"./node_modules/rxjs/observable/ScalarObservable.js\");\nvar EmptyObservable_1 = __webpack_require__(/*! ./EmptyObservable */ \"./node_modules/rxjs/observable/EmptyObservable.js\");\nvar isScheduler_1 = __webpack_require__(/*! ../util/isScheduler */ \"./node_modules/rxjs/util/isScheduler.js\");\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar ArrayObservable = (function (_super) {\n    __extends(ArrayObservable, _super);\n    function ArrayObservable(array, scheduler) {\n        _super.call(this);\n        this.array = array;\n        this.scheduler = scheduler;\n        if (!scheduler && array.length === 1) {\n            this._isScalar = true;\n            this.value = array[0];\n        }\n    }\n    ArrayObservable.create = function (array, scheduler) {\n        return new ArrayObservable(array, scheduler);\n    };\n    /**\n     * Creates an Observable that emits some values you specify as arguments,\n     * immediately one after the other, and then emits a complete notification.\n     *\n     * <span class=\"informal\">Emits the arguments you provide, then completes.\n     * </span>\n     *\n     * <img src=\"./img/of.png\" width=\"100%\">\n     *\n     * This static operator is useful for creating a simple Observable that only\n     * emits the arguments given, and the complete notification thereafter. It can\n     * be used for composing with other Observables, such as with {@link concat}.\n     * By default, it uses a `null` IScheduler, which means the `next`\n     * notifications are sent synchronously, although with a different IScheduler\n     * it is possible to determine when those notifications will be delivered.\n     *\n     * @example <caption>Emit 10, 20, 30, then 'a', 'b', 'c', then start ticking every second.</caption>\n     * var numbers = Rx.Observable.of(10, 20, 30);\n     * var letters = Rx.Observable.of('a', 'b', 'c');\n     * var interval = Rx.Observable.interval(1000);\n     * var result = numbers.concat(letters).concat(interval);\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link create}\n     * @see {@link empty}\n     * @see {@link never}\n     * @see {@link throw}\n     *\n     * @param {...T} values Arguments that represent `next` values to be emitted.\n     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling\n     * the emissions of the `next` notifications.\n     * @return {Observable<T>} An Observable that emits each given input value.\n     * @static true\n     * @name of\n     * @owner Observable\n     */\n    ArrayObservable.of = function () {\n        var array = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            array[_i - 0] = arguments[_i];\n        }\n        var scheduler = array[array.length - 1];\n        if (isScheduler_1.isScheduler(scheduler)) {\n            array.pop();\n        }\n        else {\n            scheduler = null;\n        }\n        var len = array.length;\n        if (len > 1) {\n            return new ArrayObservable(array, scheduler);\n        }\n        else if (len === 1) {\n            return new ScalarObservable_1.ScalarObservable(array[0], scheduler);\n        }\n        else {\n            return new EmptyObservable_1.EmptyObservable(scheduler);\n        }\n    };\n    ArrayObservable.dispatch = function (state) {\n        var array = state.array, index = state.index, count = state.count, subscriber = state.subscriber;\n        if (index >= count) {\n            subscriber.complete();\n            return;\n        }\n        subscriber.next(array[index]);\n        if (subscriber.closed) {\n            return;\n        }\n        state.index = index + 1;\n        this.schedule(state);\n    };\n    ArrayObservable.prototype._subscribe = function (subscriber) {\n        var index = 0;\n        var array = this.array;\n        var count = array.length;\n        var scheduler = this.scheduler;\n        if (scheduler) {\n            return scheduler.schedule(ArrayObservable.dispatch, 0, {\n                array: array, index: index, count: count, subscriber: subscriber\n            });\n        }\n        else {\n            for (var i = 0; i < count && !subscriber.closed; i++) {\n                subscriber.next(array[i]);\n            }\n            subscriber.complete();\n        }\n    };\n    return ArrayObservable;\n}(Observable_1.Observable));\nexports.ArrayObservable = ArrayObservable;\n//# sourceMappingURL=ArrayObservable.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/observable/ArrayObservable.js?");

/***/ }),

/***/ "./node_modules/rxjs/observable/ConnectableObservable.js":
/*!***************************************************************!*\
  !*** ./node_modules/rxjs/observable/ConnectableObservable.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = __webpack_require__(/*! ../Subject */ \"./node_modules/rxjs/Subject.js\");\nvar Observable_1 = __webpack_require__(/*! ../Observable */ \"./node_modules/rxjs/Observable.js\");\nvar Subscriber_1 = __webpack_require__(/*! ../Subscriber */ \"./node_modules/rxjs/Subscriber.js\");\nvar Subscription_1 = __webpack_require__(/*! ../Subscription */ \"./node_modules/rxjs/Subscription.js\");\nvar refCount_1 = __webpack_require__(/*! ../operators/refCount */ \"./node_modules/rxjs/operators/refCount.js\");\n/**\n * @class ConnectableObservable<T>\n */\nvar ConnectableObservable = (function (_super) {\n    __extends(ConnectableObservable, _super);\n    function ConnectableObservable(source, subjectFactory) {\n        _super.call(this);\n        this.source = source;\n        this.subjectFactory = subjectFactory;\n        this._refCount = 0;\n        this._isComplete = false;\n    }\n    ConnectableObservable.prototype._subscribe = function (subscriber) {\n        return this.getSubject().subscribe(subscriber);\n    };\n    ConnectableObservable.prototype.getSubject = function () {\n        var subject = this._subject;\n        if (!subject || subject.isStopped) {\n            this._subject = this.subjectFactory();\n        }\n        return this._subject;\n    };\n    ConnectableObservable.prototype.connect = function () {\n        var connection = this._connection;\n        if (!connection) {\n            this._isComplete = false;\n            connection = this._connection = new Subscription_1.Subscription();\n            connection.add(this.source\n                .subscribe(new ConnectableSubscriber(this.getSubject(), this)));\n            if (connection.closed) {\n                this._connection = null;\n                connection = Subscription_1.Subscription.EMPTY;\n            }\n            else {\n                this._connection = connection;\n            }\n        }\n        return connection;\n    };\n    ConnectableObservable.prototype.refCount = function () {\n        return refCount_1.refCount()(this);\n    };\n    return ConnectableObservable;\n}(Observable_1.Observable));\nexports.ConnectableObservable = ConnectableObservable;\nvar connectableProto = ConnectableObservable.prototype;\nexports.connectableObservableDescriptor = {\n    operator: { value: null },\n    _refCount: { value: 0, writable: true },\n    _subject: { value: null, writable: true },\n    _connection: { value: null, writable: true },\n    _subscribe: { value: connectableProto._subscribe },\n    _isComplete: { value: connectableProto._isComplete, writable: true },\n    getSubject: { value: connectableProto.getSubject },\n    connect: { value: connectableProto.connect },\n    refCount: { value: connectableProto.refCount }\n};\nvar ConnectableSubscriber = (function (_super) {\n    __extends(ConnectableSubscriber, _super);\n    function ConnectableSubscriber(destination, connectable) {\n        _super.call(this, destination);\n        this.connectable = connectable;\n    }\n    ConnectableSubscriber.prototype._error = function (err) {\n        this._unsubscribe();\n        _super.prototype._error.call(this, err);\n    };\n    ConnectableSubscriber.prototype._complete = function () {\n        this.connectable._isComplete = true;\n        this._unsubscribe();\n        _super.prototype._complete.call(this);\n    };\n    ConnectableSubscriber.prototype._unsubscribe = function () {\n        var connectable = this.connectable;\n        if (connectable) {\n            this.connectable = null;\n            var connection = connectable._connection;\n            connectable._refCount = 0;\n            connectable._subject = null;\n            connectable._connection = null;\n            if (connection) {\n                connection.unsubscribe();\n            }\n        }\n    };\n    return ConnectableSubscriber;\n}(Subject_1.SubjectSubscriber));\nvar RefCountOperator = (function () {\n    function RefCountOperator(connectable) {\n        this.connectable = connectable;\n    }\n    RefCountOperator.prototype.call = function (subscriber, source) {\n        var connectable = this.connectable;\n        connectable._refCount++;\n        var refCounter = new RefCountSubscriber(subscriber, connectable);\n        var subscription = source.subscribe(refCounter);\n        if (!refCounter.closed) {\n            refCounter.connection = connectable.connect();\n        }\n        return subscription;\n    };\n    return RefCountOperator;\n}());\nvar RefCountSubscriber = (function (_super) {\n    __extends(RefCountSubscriber, _super);\n    function RefCountSubscriber(destination, connectable) {\n        _super.call(this, destination);\n        this.connectable = connectable;\n    }\n    RefCountSubscriber.prototype._unsubscribe = function () {\n        var connectable = this.connectable;\n        if (!connectable) {\n            this.connection = null;\n            return;\n        }\n        this.connectable = null;\n        var refCount = connectable._refCount;\n        if (refCount <= 0) {\n            this.connection = null;\n            return;\n        }\n        connectable._refCount = refCount - 1;\n        if (refCount > 1) {\n            this.connection = null;\n            return;\n        }\n        ///\n        // Compare the local RefCountSubscriber's connection Subscription to the\n        // connection Subscription on the shared ConnectableObservable. In cases\n        // where the ConnectableObservable source synchronously emits values, and\n        // the RefCountSubscriber's downstream Observers synchronously unsubscribe,\n        // execution continues to here before the RefCountOperator has a chance to\n        // supply the RefCountSubscriber with the shared connection Subscription.\n        // For example:\n        // ```\n        // Observable.range(0, 10)\n        //   .publish()\n        //   .refCount()\n        //   .take(5)\n        //   .subscribe();\n        // ```\n        // In order to account for this case, RefCountSubscriber should only dispose\n        // the ConnectableObservable's shared connection Subscription if the\n        // connection Subscription exists, *and* either:\n        //   a. RefCountSubscriber doesn't have a reference to the shared connection\n        //      Subscription yet, or,\n        //   b. RefCountSubscriber's connection Subscription reference is identical\n        //      to the shared connection Subscription\n        ///\n        var connection = this.connection;\n        var sharedConnection = connectable._connection;\n        this.connection = null;\n        if (sharedConnection && (!connection || sharedConnection === connection)) {\n            sharedConnection.unsubscribe();\n        }\n    };\n    return RefCountSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=ConnectableObservable.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/observable/ConnectableObservable.js?");

/***/ }),

/***/ "./node_modules/rxjs/observable/DeferObservable.js":
/*!*********************************************************!*\
  !*** ./node_modules/rxjs/observable/DeferObservable.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = __webpack_require__(/*! ../Observable */ \"./node_modules/rxjs/Observable.js\");\nvar subscribeToResult_1 = __webpack_require__(/*! ../util/subscribeToResult */ \"./node_modules/rxjs/util/subscribeToResult.js\");\nvar OuterSubscriber_1 = __webpack_require__(/*! ../OuterSubscriber */ \"./node_modules/rxjs/OuterSubscriber.js\");\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar DeferObservable = (function (_super) {\n    __extends(DeferObservable, _super);\n    function DeferObservable(observableFactory) {\n        _super.call(this);\n        this.observableFactory = observableFactory;\n    }\n    /**\n     * Creates an Observable that, on subscribe, calls an Observable factory to\n     * make an Observable for each new Observer.\n     *\n     * <span class=\"informal\">Creates the Observable lazily, that is, only when it\n     * is subscribed.\n     * </span>\n     *\n     * <img src=\"./img/defer.png\" width=\"100%\">\n     *\n     * `defer` allows you to create the Observable only when the Observer\n     * subscribes, and create a fresh Observable for each Observer. It waits until\n     * an Observer subscribes to it, and then it generates an Observable,\n     * typically with an Observable factory function. It does this afresh for each\n     * subscriber, so although each subscriber may think it is subscribing to the\n     * same Observable, in fact each subscriber gets its own individual\n     * Observable.\n     *\n     * @example <caption>Subscribe to either an Observable of clicks or an Observable of interval, at random</caption>\n     * var clicksOrInterval = Rx.Observable.defer(function () {\n     *   if (Math.random() > 0.5) {\n     *     return Rx.Observable.fromEvent(document, 'click');\n     *   } else {\n     *     return Rx.Observable.interval(1000);\n     *   }\n     * });\n     * clicksOrInterval.subscribe(x => console.log(x));\n     *\n     * // Results in the following behavior:\n     * // If the result of Math.random() is greater than 0.5 it will listen\n     * // for clicks anywhere on the \"document\"; when document is clicked it\n     * // will log a MouseEvent object to the console. If the result is less\n     * // than 0.5 it will emit ascending numbers, one every second(1000ms).\n     *\n     * @see {@link create}\n     *\n     * @param {function(): SubscribableOrPromise} observableFactory The Observable\n     * factory function to invoke for each Observer that subscribes to the output\n     * Observable. May also return a Promise, which will be converted on the fly\n     * to an Observable.\n     * @return {Observable} An Observable whose Observers' subscriptions trigger\n     * an invocation of the given Observable factory function.\n     * @static true\n     * @name defer\n     * @owner Observable\n     */\n    DeferObservable.create = function (observableFactory) {\n        return new DeferObservable(observableFactory);\n    };\n    DeferObservable.prototype._subscribe = function (subscriber) {\n        return new DeferSubscriber(subscriber, this.observableFactory);\n    };\n    return DeferObservable;\n}(Observable_1.Observable));\nexports.DeferObservable = DeferObservable;\nvar DeferSubscriber = (function (_super) {\n    __extends(DeferSubscriber, _super);\n    function DeferSubscriber(destination, factory) {\n        _super.call(this, destination);\n        this.factory = factory;\n        this.tryDefer();\n    }\n    DeferSubscriber.prototype.tryDefer = function () {\n        try {\n            this._callFactory();\n        }\n        catch (err) {\n            this._error(err);\n        }\n    };\n    DeferSubscriber.prototype._callFactory = function () {\n        var result = this.factory();\n        if (result) {\n            this.add(subscribeToResult_1.subscribeToResult(this, result));\n        }\n    };\n    return DeferSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=DeferObservable.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/observable/DeferObservable.js?");

/***/ }),

/***/ "./node_modules/rxjs/observable/EmptyObservable.js":
/*!*********************************************************!*\
  !*** ./node_modules/rxjs/observable/EmptyObservable.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = __webpack_require__(/*! ../Observable */ \"./node_modules/rxjs/Observable.js\");\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar EmptyObservable = (function (_super) {\n    __extends(EmptyObservable, _super);\n    function EmptyObservable(scheduler) {\n        _super.call(this);\n        this.scheduler = scheduler;\n    }\n    /**\n     * Creates an Observable that emits no items to the Observer and immediately\n     * emits a complete notification.\n     *\n     * <span class=\"informal\">Just emits 'complete', and nothing else.\n     * </span>\n     *\n     * <img src=\"./img/empty.png\" width=\"100%\">\n     *\n     * This static operator is useful for creating a simple Observable that only\n     * emits the complete notification. It can be used for composing with other\n     * Observables, such as in a {@link mergeMap}.\n     *\n     * @example <caption>Emit the number 7, then complete.</caption>\n     * var result = Rx.Observable.empty().startWith(7);\n     * result.subscribe(x => console.log(x));\n     *\n     * @example <caption>Map and flatten only odd numbers to the sequence 'a', 'b', 'c'</caption>\n     * var interval = Rx.Observable.interval(1000);\n     * var result = interval.mergeMap(x =>\n     *   x % 2 === 1 ? Rx.Observable.of('a', 'b', 'c') : Rx.Observable.empty()\n     * );\n     * result.subscribe(x => console.log(x));\n     *\n     * // Results in the following to the console:\n     * // x is equal to the count on the interval eg(0,1,2,3,...)\n     * // x will occur every 1000ms\n     * // if x % 2 is equal to 1 print abc\n     * // if x % 2 is not equal to 1 nothing will be output\n     *\n     * @see {@link create}\n     * @see {@link never}\n     * @see {@link of}\n     * @see {@link throw}\n     *\n     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling\n     * the emission of the complete notification.\n     * @return {Observable} An \"empty\" Observable: emits only the complete\n     * notification.\n     * @static true\n     * @name empty\n     * @owner Observable\n     */\n    EmptyObservable.create = function (scheduler) {\n        return new EmptyObservable(scheduler);\n    };\n    EmptyObservable.dispatch = function (arg) {\n        var subscriber = arg.subscriber;\n        subscriber.complete();\n    };\n    EmptyObservable.prototype._subscribe = function (subscriber) {\n        var scheduler = this.scheduler;\n        if (scheduler) {\n            return scheduler.schedule(EmptyObservable.dispatch, 0, { subscriber: subscriber });\n        }\n        else {\n            subscriber.complete();\n        }\n    };\n    return EmptyObservable;\n}(Observable_1.Observable));\nexports.EmptyObservable = EmptyObservable;\n//# sourceMappingURL=EmptyObservable.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/observable/EmptyObservable.js?");

/***/ }),

/***/ "./node_modules/rxjs/observable/ErrorObservable.js":
/*!*********************************************************!*\
  !*** ./node_modules/rxjs/observable/ErrorObservable.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = __webpack_require__(/*! ../Observable */ \"./node_modules/rxjs/Observable.js\");\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar ErrorObservable = (function (_super) {\n    __extends(ErrorObservable, _super);\n    function ErrorObservable(error, scheduler) {\n        _super.call(this);\n        this.error = error;\n        this.scheduler = scheduler;\n    }\n    /**\n     * Creates an Observable that emits no items to the Observer and immediately\n     * emits an error notification.\n     *\n     * <span class=\"informal\">Just emits 'error', and nothing else.\n     * </span>\n     *\n     * <img src=\"./img/throw.png\" width=\"100%\">\n     *\n     * This static operator is useful for creating a simple Observable that only\n     * emits the error notification. It can be used for composing with other\n     * Observables, such as in a {@link mergeMap}.\n     *\n     * @example <caption>Emit the number 7, then emit an error.</caption>\n     * var result = Rx.Observable.throw(new Error('oops!')).startWith(7);\n     * result.subscribe(x => console.log(x), e => console.error(e));\n     *\n     * @example <caption>Map and flatten numbers to the sequence 'a', 'b', 'c', but throw an error for 13</caption>\n     * var interval = Rx.Observable.interval(1000);\n     * var result = interval.mergeMap(x =>\n     *   x === 13 ?\n     *     Rx.Observable.throw('Thirteens are bad') :\n     *     Rx.Observable.of('a', 'b', 'c')\n     * );\n     * result.subscribe(x => console.log(x), e => console.error(e));\n     *\n     * @see {@link create}\n     * @see {@link empty}\n     * @see {@link never}\n     * @see {@link of}\n     *\n     * @param {any} error The particular Error to pass to the error notification.\n     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling\n     * the emission of the error notification.\n     * @return {Observable} An error Observable: emits only the error notification\n     * using the given error argument.\n     * @static true\n     * @name throw\n     * @owner Observable\n     */\n    ErrorObservable.create = function (error, scheduler) {\n        return new ErrorObservable(error, scheduler);\n    };\n    ErrorObservable.dispatch = function (arg) {\n        var error = arg.error, subscriber = arg.subscriber;\n        subscriber.error(error);\n    };\n    ErrorObservable.prototype._subscribe = function (subscriber) {\n        var error = this.error;\n        var scheduler = this.scheduler;\n        subscriber.syncErrorThrowable = true;\n        if (scheduler) {\n            return scheduler.schedule(ErrorObservable.dispatch, 0, {\n                error: error, subscriber: subscriber\n            });\n        }\n        else {\n            subscriber.error(error);\n        }\n    };\n    return ErrorObservable;\n}(Observable_1.Observable));\nexports.ErrorObservable = ErrorObservable;\n//# sourceMappingURL=ErrorObservable.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/observable/ErrorObservable.js?");

/***/ }),

/***/ "./node_modules/rxjs/observable/FromEventObservable.js":
/*!*************************************************************!*\
  !*** ./node_modules/rxjs/observable/FromEventObservable.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = __webpack_require__(/*! ../Observable */ \"./node_modules/rxjs/Observable.js\");\nvar tryCatch_1 = __webpack_require__(/*! ../util/tryCatch */ \"./node_modules/rxjs/util/tryCatch.js\");\nvar isFunction_1 = __webpack_require__(/*! ../util/isFunction */ \"./node_modules/rxjs/util/isFunction.js\");\nvar errorObject_1 = __webpack_require__(/*! ../util/errorObject */ \"./node_modules/rxjs/util/errorObject.js\");\nvar Subscription_1 = __webpack_require__(/*! ../Subscription */ \"./node_modules/rxjs/Subscription.js\");\nvar toString = Object.prototype.toString;\nfunction isNodeStyleEventEmitter(sourceObj) {\n    return !!sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';\n}\nfunction isJQueryStyleEventEmitter(sourceObj) {\n    return !!sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';\n}\nfunction isNodeList(sourceObj) {\n    return !!sourceObj && toString.call(sourceObj) === '[object NodeList]';\n}\nfunction isHTMLCollection(sourceObj) {\n    return !!sourceObj && toString.call(sourceObj) === '[object HTMLCollection]';\n}\nfunction isEventTarget(sourceObj) {\n    return !!sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';\n}\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar FromEventObservable = (function (_super) {\n    __extends(FromEventObservable, _super);\n    function FromEventObservable(sourceObj, eventName, selector, options) {\n        _super.call(this);\n        this.sourceObj = sourceObj;\n        this.eventName = eventName;\n        this.selector = selector;\n        this.options = options;\n    }\n    /* tslint:enable:max-line-length */\n    /**\n     * Creates an Observable that emits events of a specific type coming from the\n     * given event target.\n     *\n     * <span class=\"informal\">Creates an Observable from DOM events, or Node.js\n     * EventEmitter events or others.</span>\n     *\n     * <img src=\"./img/fromEvent.png\" width=\"100%\">\n     *\n     * `fromEvent` accepts as a first argument event target, which is an object with methods\n     * for registering event handler functions. As a second argument it takes string that indicates\n     * type of event we want to listen for. `fromEvent` supports selected types of event targets,\n     * which are described in detail below. If your event target does not match any of the ones listed,\n     * you should use {@link fromEventPattern}, which can be used on arbitrary APIs.\n     * When it comes to APIs supported by `fromEvent`, their methods for adding and removing event\n     * handler functions have different names, but they all accept a string describing event type\n     * and function itself, which will be called whenever said event happens.\n     *\n     * Every time resulting Observable is subscribed, event handler function will be registered\n     * to event target on given event type. When that event fires, value\n     * passed as a first argument to registered function will be emitted by output Observable.\n     * When Observable is unsubscribed, function will be unregistered from event target.\n     *\n     * Note that if event target calls registered function with more than one argument, second\n     * and following arguments will not appear in resulting stream. In order to get access to them,\n     * you can pass to `fromEvent` optional project function, which will be called with all arguments\n     * passed to event handler. Output Observable will then emit value returned by project function,\n     * instead of the usual value.\n     *\n     * Remember that event targets listed below are checked via duck typing. It means that\n     * no matter what kind of object you have and no matter what environment you work in,\n     * you can safely use `fromEvent` on that object if it exposes described methods (provided\n     * of course they behave as was described above). So for example if Node.js library exposes\n     * event target which has the same method names as DOM EventTarget, `fromEvent` is still\n     * a good choice.\n     *\n     * If the API you use is more callback then event handler oriented (subscribed\n     * callback function fires only once and thus there is no need to manually\n     * unregister it), you should use {@link bindCallback} or {@link bindNodeCallback}\n     * instead.\n     *\n     * `fromEvent` supports following types of event targets:\n     *\n     * **DOM EventTarget**\n     *\n     * This is an object with `addEventListener` and `removeEventListener` methods.\n     *\n     * In the browser, `addEventListener` accepts - apart from event type string and event\n     * handler function arguments - optional third parameter, which is either an object or boolean,\n     * both used for additional configuration how and when passed function will be called. When\n     * `fromEvent` is used with event target of that type, you can provide this values\n     * as third parameter as well.\n     *\n     * **Node.js EventEmitter**\n     *\n     * An object with `addListener` and `removeListener` methods.\n     *\n     * **JQuery-style event target**\n     *\n     * An object with `on` and `off` methods\n     *\n     * **DOM NodeList**\n     *\n     * List of DOM Nodes, returned for example by `document.querySelectorAll` or `Node.childNodes`.\n     *\n     * Although this collection is not event target in itself, `fromEvent` will iterate over all Nodes\n     * it contains and install event handler function in every of them. When returned Observable\n     * is unsubscribed, function will be removed from all Nodes.\n     *\n     * **DOM HtmlCollection**\n     *\n     * Just as in case of NodeList it is a collection of DOM nodes. Here as well event handler function is\n     * installed and removed in each of elements.\n     *\n     *\n     * @example <caption>Emits clicks happening on the DOM document</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * clicks.subscribe(x => console.log(x));\n     *\n     * // Results in:\n     * // MouseEvent object logged to console every time a click\n     * // occurs on the document.\n     *\n     *\n     * @example <caption>Use addEventListener with capture option</caption>\n     * var clicksInDocument = Rx.Observable.fromEvent(document, 'click', true); // note optional configuration parameter\n     *                                                                          // which will be passed to addEventListener\n     * var clicksInDiv = Rx.Observable.fromEvent(someDivInDocument, 'click');\n     *\n     * clicksInDocument.subscribe(() => console.log('document'));\n     * clicksInDiv.subscribe(() => console.log('div'));\n     *\n     * // By default events bubble UP in DOM tree, so normally\n     * // when we would click on div in document\n     * // \"div\" would be logged first and then \"document\".\n     * // Since we specified optional `capture` option, document\n     * // will catch event when it goes DOWN DOM tree, so console\n     * // will log \"document\" and then \"div\".\n     *\n     * @see {@link bindCallback}\n     * @see {@link bindNodeCallback}\n     * @see {@link fromEventPattern}\n     *\n     * @param {EventTargetLike} target The DOM EventTarget, Node.js\n     * EventEmitter, JQuery-like event target, NodeList or HTMLCollection to attach the event handler to.\n     * @param {string} eventName The event name of interest, being emitted by the\n     * `target`.\n     * @param {EventListenerOptions} [options] Options to pass through to addEventListener\n     * @param {SelectorMethodSignature<T>} [selector] An optional function to\n     * post-process results. It takes the arguments from the event handler and\n     * should return a single value.\n     * @return {Observable<T>}\n     * @static true\n     * @name fromEvent\n     * @owner Observable\n     */\n    FromEventObservable.create = function (target, eventName, options, selector) {\n        if (isFunction_1.isFunction(options)) {\n            selector = options;\n            options = undefined;\n        }\n        return new FromEventObservable(target, eventName, selector, options);\n    };\n    FromEventObservable.setupSubscription = function (sourceObj, eventName, handler, subscriber, options) {\n        var unsubscribe;\n        if (isNodeList(sourceObj) || isHTMLCollection(sourceObj)) {\n            for (var i = 0, len = sourceObj.length; i < len; i++) {\n                FromEventObservable.setupSubscription(sourceObj[i], eventName, handler, subscriber, options);\n            }\n        }\n        else if (isEventTarget(sourceObj)) {\n            var source_1 = sourceObj;\n            sourceObj.addEventListener(eventName, handler, options);\n            unsubscribe = function () { return source_1.removeEventListener(eventName, handler); };\n        }\n        else if (isJQueryStyleEventEmitter(sourceObj)) {\n            var source_2 = sourceObj;\n            sourceObj.on(eventName, handler);\n            unsubscribe = function () { return source_2.off(eventName, handler); };\n        }\n        else if (isNodeStyleEventEmitter(sourceObj)) {\n            var source_3 = sourceObj;\n            sourceObj.addListener(eventName, handler);\n            unsubscribe = function () { return source_3.removeListener(eventName, handler); };\n        }\n        else {\n            throw new TypeError('Invalid event target');\n        }\n        subscriber.add(new Subscription_1.Subscription(unsubscribe));\n    };\n    FromEventObservable.prototype._subscribe = function (subscriber) {\n        var sourceObj = this.sourceObj;\n        var eventName = this.eventName;\n        var options = this.options;\n        var selector = this.selector;\n        var handler = selector ? function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i - 0] = arguments[_i];\n            }\n            var result = tryCatch_1.tryCatch(selector).apply(void 0, args);\n            if (result === errorObject_1.errorObject) {\n                subscriber.error(errorObject_1.errorObject.e);\n            }\n            else {\n                subscriber.next(result);\n            }\n        } : function (e) { return subscriber.next(e); };\n        FromEventObservable.setupSubscription(sourceObj, eventName, handler, subscriber, options);\n    };\n    return FromEventObservable;\n}(Observable_1.Observable));\nexports.FromEventObservable = FromEventObservable;\n//# sourceMappingURL=FromEventObservable.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/observable/FromEventObservable.js?");

/***/ }),

/***/ "./node_modules/rxjs/observable/FromObservable.js":
/*!********************************************************!*\
  !*** ./node_modules/rxjs/observable/FromObservable.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar isArray_1 = __webpack_require__(/*! ../util/isArray */ \"./node_modules/rxjs/util/isArray.js\");\nvar isArrayLike_1 = __webpack_require__(/*! ../util/isArrayLike */ \"./node_modules/rxjs/util/isArrayLike.js\");\nvar isPromise_1 = __webpack_require__(/*! ../util/isPromise */ \"./node_modules/rxjs/util/isPromise.js\");\nvar PromiseObservable_1 = __webpack_require__(/*! ./PromiseObservable */ \"./node_modules/rxjs/observable/PromiseObservable.js\");\nvar IteratorObservable_1 = __webpack_require__(/*! ./IteratorObservable */ \"./node_modules/rxjs/observable/IteratorObservable.js\");\nvar ArrayObservable_1 = __webpack_require__(/*! ./ArrayObservable */ \"./node_modules/rxjs/observable/ArrayObservable.js\");\nvar ArrayLikeObservable_1 = __webpack_require__(/*! ./ArrayLikeObservable */ \"./node_modules/rxjs/observable/ArrayLikeObservable.js\");\nvar iterator_1 = __webpack_require__(/*! ../symbol/iterator */ \"./node_modules/rxjs/symbol/iterator.js\");\nvar Observable_1 = __webpack_require__(/*! ../Observable */ \"./node_modules/rxjs/Observable.js\");\nvar observeOn_1 = __webpack_require__(/*! ../operators/observeOn */ \"./node_modules/rxjs/operators/observeOn.js\");\nvar observable_1 = __webpack_require__(/*! ../symbol/observable */ \"./node_modules/rxjs/symbol/observable.js\");\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar FromObservable = (function (_super) {\n    __extends(FromObservable, _super);\n    function FromObservable(ish, scheduler) {\n        _super.call(this, null);\n        this.ish = ish;\n        this.scheduler = scheduler;\n    }\n    /**\n     * Creates an Observable from an Array, an array-like object, a Promise, an\n     * iterable object, or an Observable-like object.\n     *\n     * <span class=\"informal\">Converts almost anything to an Observable.</span>\n     *\n     * <img src=\"./img/from.png\" width=\"100%\">\n     *\n     * Convert various other objects and data types into Observables. `from`\n     * converts a Promise or an array-like or an\n     * [iterable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable)\n     * object into an Observable that emits the items in that promise or array or\n     * iterable. A String, in this context, is treated as an array of characters.\n     * Observable-like objects (contains a function named with the ES2015 Symbol\n     * for Observable) can also be converted through this operator.\n     *\n     * @example <caption>Converts an array to an Observable</caption>\n     * var array = [10, 20, 30];\n     * var result = Rx.Observable.from(array);\n     * result.subscribe(x => console.log(x));\n     *\n     * // Results in the following:\n     * // 10 20 30\n     *\n     * @example <caption>Convert an infinite iterable (from a generator) to an Observable</caption>\n     * function* generateDoubles(seed) {\n     *   var i = seed;\n     *   while (true) {\n     *     yield i;\n     *     i = 2 * i; // double it\n     *   }\n     * }\n     *\n     * var iterator = generateDoubles(3);\n     * var result = Rx.Observable.from(iterator).take(10);\n     * result.subscribe(x => console.log(x));\n     *\n     * // Results in the following:\n     * // 3 6 12 24 48 96 192 384 768 1536\n     *\n     * @see {@link create}\n     * @see {@link fromEvent}\n     * @see {@link fromEventPattern}\n     * @see {@link fromPromise}\n     *\n     * @param {ObservableInput<T>} ish A subscribable object, a Promise, an\n     * Observable-like, an Array, an iterable or an array-like object to be\n     * converted.\n     * @param {Scheduler} [scheduler] The scheduler on which to schedule the\n     * emissions of values.\n     * @return {Observable<T>} The Observable whose values are originally from the\n     * input object that was converted.\n     * @static true\n     * @name from\n     * @owner Observable\n     */\n    FromObservable.create = function (ish, scheduler) {\n        if (ish != null) {\n            if (typeof ish[observable_1.observable] === 'function') {\n                if (ish instanceof Observable_1.Observable && !scheduler) {\n                    return ish;\n                }\n                return new FromObservable(ish, scheduler);\n            }\n            else if (isArray_1.isArray(ish)) {\n                return new ArrayObservable_1.ArrayObservable(ish, scheduler);\n            }\n            else if (isPromise_1.isPromise(ish)) {\n                return new PromiseObservable_1.PromiseObservable(ish, scheduler);\n            }\n            else if (typeof ish[iterator_1.iterator] === 'function' || typeof ish === 'string') {\n                return new IteratorObservable_1.IteratorObservable(ish, scheduler);\n            }\n            else if (isArrayLike_1.isArrayLike(ish)) {\n                return new ArrayLikeObservable_1.ArrayLikeObservable(ish, scheduler);\n            }\n        }\n        throw new TypeError((ish !== null && typeof ish || ish) + ' is not observable');\n    };\n    FromObservable.prototype._subscribe = function (subscriber) {\n        var ish = this.ish;\n        var scheduler = this.scheduler;\n        if (scheduler == null) {\n            return ish[observable_1.observable]().subscribe(subscriber);\n        }\n        else {\n            return ish[observable_1.observable]().subscribe(new observeOn_1.ObserveOnSubscriber(subscriber, scheduler, 0));\n        }\n    };\n    return FromObservable;\n}(Observable_1.Observable));\nexports.FromObservable = FromObservable;\n//# sourceMappingURL=FromObservable.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/observable/FromObservable.js?");

/***/ }),

/***/ "./node_modules/rxjs/observable/IntervalObservable.js":
/*!************************************************************!*\
  !*** ./node_modules/rxjs/observable/IntervalObservable.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar isNumeric_1 = __webpack_require__(/*! ../util/isNumeric */ \"./node_modules/rxjs/util/isNumeric.js\");\nvar Observable_1 = __webpack_require__(/*! ../Observable */ \"./node_modules/rxjs/Observable.js\");\nvar async_1 = __webpack_require__(/*! ../scheduler/async */ \"./node_modules/rxjs/scheduler/async.js\");\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar IntervalObservable = (function (_super) {\n    __extends(IntervalObservable, _super);\n    function IntervalObservable(period, scheduler) {\n        if (period === void 0) { period = 0; }\n        if (scheduler === void 0) { scheduler = async_1.async; }\n        _super.call(this);\n        this.period = period;\n        this.scheduler = scheduler;\n        if (!isNumeric_1.isNumeric(period) || period < 0) {\n            this.period = 0;\n        }\n        if (!scheduler || typeof scheduler.schedule !== 'function') {\n            this.scheduler = async_1.async;\n        }\n    }\n    /**\n     * Creates an Observable that emits sequential numbers every specified\n     * interval of time, on a specified IScheduler.\n     *\n     * <span class=\"informal\">Emits incremental numbers periodically in time.\n     * </span>\n     *\n     * <img src=\"./img/interval.png\" width=\"100%\">\n     *\n     * `interval` returns an Observable that emits an infinite sequence of\n     * ascending integers, with a constant interval of time of your choosing\n     * between those emissions. The first emission is not sent immediately, but\n     * only after the first period has passed. By default, this operator uses the\n     * `async` IScheduler to provide a notion of time, but you may pass any\n     * IScheduler to it.\n     *\n     * @example <caption>Emits ascending numbers, one every second (1000ms)</caption>\n     * var numbers = Rx.Observable.interval(1000);\n     * numbers.subscribe(x => console.log(x));\n     *\n     * @see {@link timer}\n     * @see {@link delay}\n     *\n     * @param {number} [period=0] The interval size in milliseconds (by default)\n     * or the time unit determined by the scheduler's clock.\n     * @param {Scheduler} [scheduler=async] The IScheduler to use for scheduling\n     * the emission of values, and providing a notion of \"time\".\n     * @return {Observable} An Observable that emits a sequential number each time\n     * interval.\n     * @static true\n     * @name interval\n     * @owner Observable\n     */\n    IntervalObservable.create = function (period, scheduler) {\n        if (period === void 0) { period = 0; }\n        if (scheduler === void 0) { scheduler = async_1.async; }\n        return new IntervalObservable(period, scheduler);\n    };\n    IntervalObservable.dispatch = function (state) {\n        var index = state.index, subscriber = state.subscriber, period = state.period;\n        subscriber.next(index);\n        if (subscriber.closed) {\n            return;\n        }\n        state.index += 1;\n        this.schedule(state, period);\n    };\n    IntervalObservable.prototype._subscribe = function (subscriber) {\n        var index = 0;\n        var period = this.period;\n        var scheduler = this.scheduler;\n        subscriber.add(scheduler.schedule(IntervalObservable.dispatch, period, {\n            index: index, subscriber: subscriber, period: period\n        }));\n    };\n    return IntervalObservable;\n}(Observable_1.Observable));\nexports.IntervalObservable = IntervalObservable;\n//# sourceMappingURL=IntervalObservable.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/observable/IntervalObservable.js?");

/***/ }),

/***/ "./node_modules/rxjs/observable/IteratorObservable.js":
/*!************************************************************!*\
  !*** ./node_modules/rxjs/observable/IteratorObservable.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar root_1 = __webpack_require__(/*! ../util/root */ \"./node_modules/rxjs/util/root.js\");\nvar Observable_1 = __webpack_require__(/*! ../Observable */ \"./node_modules/rxjs/Observable.js\");\nvar iterator_1 = __webpack_require__(/*! ../symbol/iterator */ \"./node_modules/rxjs/symbol/iterator.js\");\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar IteratorObservable = (function (_super) {\n    __extends(IteratorObservable, _super);\n    function IteratorObservable(iterator, scheduler) {\n        _super.call(this);\n        this.scheduler = scheduler;\n        if (iterator == null) {\n            throw new Error('iterator cannot be null.');\n        }\n        this.iterator = getIterator(iterator);\n    }\n    IteratorObservable.create = function (iterator, scheduler) {\n        return new IteratorObservable(iterator, scheduler);\n    };\n    IteratorObservable.dispatch = function (state) {\n        var index = state.index, hasError = state.hasError, iterator = state.iterator, subscriber = state.subscriber;\n        if (hasError) {\n            subscriber.error(state.error);\n            return;\n        }\n        var result = iterator.next();\n        if (result.done) {\n            subscriber.complete();\n            return;\n        }\n        subscriber.next(result.value);\n        state.index = index + 1;\n        if (subscriber.closed) {\n            if (typeof iterator.return === 'function') {\n                iterator.return();\n            }\n            return;\n        }\n        this.schedule(state);\n    };\n    IteratorObservable.prototype._subscribe = function (subscriber) {\n        var index = 0;\n        var _a = this, iterator = _a.iterator, scheduler = _a.scheduler;\n        if (scheduler) {\n            return scheduler.schedule(IteratorObservable.dispatch, 0, {\n                index: index, iterator: iterator, subscriber: subscriber\n            });\n        }\n        else {\n            do {\n                var result = iterator.next();\n                if (result.done) {\n                    subscriber.complete();\n                    break;\n                }\n                else {\n                    subscriber.next(result.value);\n                }\n                if (subscriber.closed) {\n                    if (typeof iterator.return === 'function') {\n                        iterator.return();\n                    }\n                    break;\n                }\n            } while (true);\n        }\n    };\n    return IteratorObservable;\n}(Observable_1.Observable));\nexports.IteratorObservable = IteratorObservable;\nvar StringIterator = (function () {\n    function StringIterator(str, idx, len) {\n        if (idx === void 0) { idx = 0; }\n        if (len === void 0) { len = str.length; }\n        this.str = str;\n        this.idx = idx;\n        this.len = len;\n    }\n    StringIterator.prototype[iterator_1.iterator] = function () { return (this); };\n    StringIterator.prototype.next = function () {\n        return this.idx < this.len ? {\n            done: false,\n            value: this.str.charAt(this.idx++)\n        } : {\n            done: true,\n            value: undefined\n        };\n    };\n    return StringIterator;\n}());\nvar ArrayIterator = (function () {\n    function ArrayIterator(arr, idx, len) {\n        if (idx === void 0) { idx = 0; }\n        if (len === void 0) { len = toLength(arr); }\n        this.arr = arr;\n        this.idx = idx;\n        this.len = len;\n    }\n    ArrayIterator.prototype[iterator_1.iterator] = function () { return this; };\n    ArrayIterator.prototype.next = function () {\n        return this.idx < this.len ? {\n            done: false,\n            value: this.arr[this.idx++]\n        } : {\n            done: true,\n            value: undefined\n        };\n    };\n    return ArrayIterator;\n}());\nfunction getIterator(obj) {\n    var i = obj[iterator_1.iterator];\n    if (!i && typeof obj === 'string') {\n        return new StringIterator(obj);\n    }\n    if (!i && obj.length !== undefined) {\n        return new ArrayIterator(obj);\n    }\n    if (!i) {\n        throw new TypeError('object is not iterable');\n    }\n    return obj[iterator_1.iterator]();\n}\nvar maxSafeInteger = Math.pow(2, 53) - 1;\nfunction toLength(o) {\n    var len = +o.length;\n    if (isNaN(len)) {\n        return 0;\n    }\n    if (len === 0 || !numberIsFinite(len)) {\n        return len;\n    }\n    len = sign(len) * Math.floor(Math.abs(len));\n    if (len <= 0) {\n        return 0;\n    }\n    if (len > maxSafeInteger) {\n        return maxSafeInteger;\n    }\n    return len;\n}\nfunction numberIsFinite(value) {\n    return typeof value === 'number' && root_1.root.isFinite(value);\n}\nfunction sign(value) {\n    var valueAsNumber = +value;\n    if (valueAsNumber === 0) {\n        return valueAsNumber;\n    }\n    if (isNaN(valueAsNumber)) {\n        return valueAsNumber;\n    }\n    return valueAsNumber < 0 ? -1 : 1;\n}\n//# sourceMappingURL=IteratorObservable.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/observable/IteratorObservable.js?");

/***/ }),

/***/ "./node_modules/rxjs/observable/NeverObservable.js":
/*!*********************************************************!*\
  !*** ./node_modules/rxjs/observable/NeverObservable.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = __webpack_require__(/*! ../Observable */ \"./node_modules/rxjs/Observable.js\");\nvar noop_1 = __webpack_require__(/*! ../util/noop */ \"./node_modules/rxjs/util/noop.js\");\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar NeverObservable = (function (_super) {\n    __extends(NeverObservable, _super);\n    function NeverObservable() {\n        _super.call(this);\n    }\n    /**\n     * Creates an Observable that emits no items to the Observer.\n     *\n     * <span class=\"informal\">An Observable that never emits anything.</span>\n     *\n     * <img src=\"./img/never.png\" width=\"100%\">\n     *\n     * This static operator is useful for creating a simple Observable that emits\n     * neither values nor errors nor the completion notification. It can be used\n     * for testing purposes or for composing with other Observables. Please note\n     * that by never emitting a complete notification, this Observable keeps the\n     * subscription from being disposed automatically. Subscriptions need to be\n     * manually disposed.\n     *\n     * @example <caption>Emit the number 7, then never emit anything else (not even complete).</caption>\n     * function info() {\n     *   console.log('Will not be called');\n     * }\n     * var result = Rx.Observable.never().startWith(7);\n     * result.subscribe(x => console.log(x), info, info);\n     *\n     * @see {@link create}\n     * @see {@link empty}\n     * @see {@link of}\n     * @see {@link throw}\n     *\n     * @return {Observable} A \"never\" Observable: never emits anything.\n     * @static true\n     * @name never\n     * @owner Observable\n     */\n    NeverObservable.create = function () {\n        return new NeverObservable();\n    };\n    NeverObservable.prototype._subscribe = function (subscriber) {\n        noop_1.noop();\n    };\n    return NeverObservable;\n}(Observable_1.Observable));\nexports.NeverObservable = NeverObservable;\n//# sourceMappingURL=NeverObservable.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/observable/NeverObservable.js?");

/***/ }),

/***/ "./node_modules/rxjs/observable/PromiseObservable.js":
/*!***********************************************************!*\
  !*** ./node_modules/rxjs/observable/PromiseObservable.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar root_1 = __webpack_require__(/*! ../util/root */ \"./node_modules/rxjs/util/root.js\");\nvar Observable_1 = __webpack_require__(/*! ../Observable */ \"./node_modules/rxjs/Observable.js\");\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar PromiseObservable = (function (_super) {\n    __extends(PromiseObservable, _super);\n    function PromiseObservable(promise, scheduler) {\n        _super.call(this);\n        this.promise = promise;\n        this.scheduler = scheduler;\n    }\n    /**\n     * Converts a Promise to an Observable.\n     *\n     * <span class=\"informal\">Returns an Observable that just emits the Promise's\n     * resolved value, then completes.</span>\n     *\n     * Converts an ES2015 Promise or a Promises/A+ spec compliant Promise to an\n     * Observable. If the Promise resolves with a value, the output Observable\n     * emits that resolved value as a `next`, and then completes. If the Promise\n     * is rejected, then the output Observable emits the corresponding Error.\n     *\n     * @example <caption>Convert the Promise returned by Fetch to an Observable</caption>\n     * var result = Rx.Observable.fromPromise(fetch('http://myserver.com/'));\n     * result.subscribe(x => console.log(x), e => console.error(e));\n     *\n     * @see {@link bindCallback}\n     * @see {@link from}\n     *\n     * @param {PromiseLike<T>} promise The promise to be converted.\n     * @param {Scheduler} [scheduler] An optional IScheduler to use for scheduling\n     * the delivery of the resolved value (or the rejection).\n     * @return {Observable<T>} An Observable which wraps the Promise.\n     * @static true\n     * @name fromPromise\n     * @owner Observable\n     */\n    PromiseObservable.create = function (promise, scheduler) {\n        return new PromiseObservable(promise, scheduler);\n    };\n    PromiseObservable.prototype._subscribe = function (subscriber) {\n        var _this = this;\n        var promise = this.promise;\n        var scheduler = this.scheduler;\n        if (scheduler == null) {\n            if (this._isScalar) {\n                if (!subscriber.closed) {\n                    subscriber.next(this.value);\n                    subscriber.complete();\n                }\n            }\n            else {\n                promise.then(function (value) {\n                    _this.value = value;\n                    _this._isScalar = true;\n                    if (!subscriber.closed) {\n                        subscriber.next(value);\n                        subscriber.complete();\n                    }\n                }, function (err) {\n                    if (!subscriber.closed) {\n                        subscriber.error(err);\n                    }\n                })\n                    .then(null, function (err) {\n                    // escape the promise trap, throw unhandled errors\n                    root_1.root.setTimeout(function () { throw err; });\n                });\n            }\n        }\n        else {\n            if (this._isScalar) {\n                if (!subscriber.closed) {\n                    return scheduler.schedule(dispatchNext, 0, { value: this.value, subscriber: subscriber });\n                }\n            }\n            else {\n                promise.then(function (value) {\n                    _this.value = value;\n                    _this._isScalar = true;\n                    if (!subscriber.closed) {\n                        subscriber.add(scheduler.schedule(dispatchNext, 0, { value: value, subscriber: subscriber }));\n                    }\n                }, function (err) {\n                    if (!subscriber.closed) {\n                        subscriber.add(scheduler.schedule(dispatchError, 0, { err: err, subscriber: subscriber }));\n                    }\n                })\n                    .then(null, function (err) {\n                    // escape the promise trap, throw unhandled errors\n                    root_1.root.setTimeout(function () { throw err; });\n                });\n            }\n        }\n    };\n    return PromiseObservable;\n}(Observable_1.Observable));\nexports.PromiseObservable = PromiseObservable;\nfunction dispatchNext(arg) {\n    var value = arg.value, subscriber = arg.subscriber;\n    if (!subscriber.closed) {\n        subscriber.next(value);\n        subscriber.complete();\n    }\n}\nfunction dispatchError(arg) {\n    var err = arg.err, subscriber = arg.subscriber;\n    if (!subscriber.closed) {\n        subscriber.error(err);\n    }\n}\n//# sourceMappingURL=PromiseObservable.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/observable/PromiseObservable.js?");

/***/ }),

/***/ "./node_modules/rxjs/observable/ScalarObservable.js":
/*!**********************************************************!*\
  !*** ./node_modules/rxjs/observable/ScalarObservable.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = __webpack_require__(/*! ../Observable */ \"./node_modules/rxjs/Observable.js\");\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar ScalarObservable = (function (_super) {\n    __extends(ScalarObservable, _super);\n    function ScalarObservable(value, scheduler) {\n        _super.call(this);\n        this.value = value;\n        this.scheduler = scheduler;\n        this._isScalar = true;\n        if (scheduler) {\n            this._isScalar = false;\n        }\n    }\n    ScalarObservable.create = function (value, scheduler) {\n        return new ScalarObservable(value, scheduler);\n    };\n    ScalarObservable.dispatch = function (state) {\n        var done = state.done, value = state.value, subscriber = state.subscriber;\n        if (done) {\n            subscriber.complete();\n            return;\n        }\n        subscriber.next(value);\n        if (subscriber.closed) {\n            return;\n        }\n        state.done = true;\n        this.schedule(state);\n    };\n    ScalarObservable.prototype._subscribe = function (subscriber) {\n        var value = this.value;\n        var scheduler = this.scheduler;\n        if (scheduler) {\n            return scheduler.schedule(ScalarObservable.dispatch, 0, {\n                done: false, value: value, subscriber: subscriber\n            });\n        }\n        else {\n            subscriber.next(value);\n            if (!subscriber.closed) {\n                subscriber.complete();\n            }\n        }\n    };\n    return ScalarObservable;\n}(Observable_1.Observable));\nexports.ScalarObservable = ScalarObservable;\n//# sourceMappingURL=ScalarObservable.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/observable/ScalarObservable.js?");

/***/ }),

/***/ "./node_modules/rxjs/observable/TimerObservable.js":
/*!*********************************************************!*\
  !*** ./node_modules/rxjs/observable/TimerObservable.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar isNumeric_1 = __webpack_require__(/*! ../util/isNumeric */ \"./node_modules/rxjs/util/isNumeric.js\");\nvar Observable_1 = __webpack_require__(/*! ../Observable */ \"./node_modules/rxjs/Observable.js\");\nvar async_1 = __webpack_require__(/*! ../scheduler/async */ \"./node_modules/rxjs/scheduler/async.js\");\nvar isScheduler_1 = __webpack_require__(/*! ../util/isScheduler */ \"./node_modules/rxjs/util/isScheduler.js\");\nvar isDate_1 = __webpack_require__(/*! ../util/isDate */ \"./node_modules/rxjs/util/isDate.js\");\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar TimerObservable = (function (_super) {\n    __extends(TimerObservable, _super);\n    function TimerObservable(dueTime, period, scheduler) {\n        if (dueTime === void 0) { dueTime = 0; }\n        _super.call(this);\n        this.period = -1;\n        this.dueTime = 0;\n        if (isNumeric_1.isNumeric(period)) {\n            this.period = Number(period) < 1 && 1 || Number(period);\n        }\n        else if (isScheduler_1.isScheduler(period)) {\n            scheduler = period;\n        }\n        if (!isScheduler_1.isScheduler(scheduler)) {\n            scheduler = async_1.async;\n        }\n        this.scheduler = scheduler;\n        this.dueTime = isDate_1.isDate(dueTime) ?\n            (+dueTime - this.scheduler.now()) :\n            dueTime;\n    }\n    /**\n     * Creates an Observable that starts emitting after an `initialDelay` and\n     * emits ever increasing numbers after each `period` of time thereafter.\n     *\n     * <span class=\"informal\">Its like {@link interval}, but you can specify when\n     * should the emissions start.</span>\n     *\n     * <img src=\"./img/timer.png\" width=\"100%\">\n     *\n     * `timer` returns an Observable that emits an infinite sequence of ascending\n     * integers, with a constant interval of time, `period` of your choosing\n     * between those emissions. The first emission happens after the specified\n     * `initialDelay`. The initial delay may be a {@link Date}. By default, this\n     * operator uses the `async` IScheduler to provide a notion of time, but you\n     * may pass any IScheduler to it. If `period` is not specified, the output\n     * Observable emits only one value, `0`. Otherwise, it emits an infinite\n     * sequence.\n     *\n     * @example <caption>Emits ascending numbers, one every second (1000ms), starting after 3 seconds</caption>\n     * var numbers = Rx.Observable.timer(3000, 1000);\n     * numbers.subscribe(x => console.log(x));\n     *\n     * @example <caption>Emits one number after five seconds</caption>\n     * var numbers = Rx.Observable.timer(5000);\n     * numbers.subscribe(x => console.log(x));\n     *\n     * @see {@link interval}\n     * @see {@link delay}\n     *\n     * @param {number|Date} initialDelay The initial delay time to wait before\n     * emitting the first value of `0`.\n     * @param {number} [period] The period of time between emissions of the\n     * subsequent numbers.\n     * @param {Scheduler} [scheduler=async] The IScheduler to use for scheduling\n     * the emission of values, and providing a notion of \"time\".\n     * @return {Observable} An Observable that emits a `0` after the\n     * `initialDelay` and ever increasing numbers after each `period` of time\n     * thereafter.\n     * @static true\n     * @name timer\n     * @owner Observable\n     */\n    TimerObservable.create = function (initialDelay, period, scheduler) {\n        if (initialDelay === void 0) { initialDelay = 0; }\n        return new TimerObservable(initialDelay, period, scheduler);\n    };\n    TimerObservable.dispatch = function (state) {\n        var index = state.index, period = state.period, subscriber = state.subscriber;\n        var action = this;\n        subscriber.next(index);\n        if (subscriber.closed) {\n            return;\n        }\n        else if (period === -1) {\n            return subscriber.complete();\n        }\n        state.index = index + 1;\n        action.schedule(state, period);\n    };\n    TimerObservable.prototype._subscribe = function (subscriber) {\n        var index = 0;\n        var _a = this, period = _a.period, dueTime = _a.dueTime, scheduler = _a.scheduler;\n        return scheduler.schedule(TimerObservable.dispatch, dueTime, {\n            index: index, period: period, subscriber: subscriber\n        });\n    };\n    return TimerObservable;\n}(Observable_1.Observable));\nexports.TimerObservable = TimerObservable;\n//# sourceMappingURL=TimerObservable.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/observable/TimerObservable.js?");

/***/ }),

/***/ "./node_modules/rxjs/observable/combineLatest.js":
/*!*******************************************************!*\
  !*** ./node_modules/rxjs/observable/combineLatest.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar isScheduler_1 = __webpack_require__(/*! ../util/isScheduler */ \"./node_modules/rxjs/util/isScheduler.js\");\nvar isArray_1 = __webpack_require__(/*! ../util/isArray */ \"./node_modules/rxjs/util/isArray.js\");\nvar ArrayObservable_1 = __webpack_require__(/*! ./ArrayObservable */ \"./node_modules/rxjs/observable/ArrayObservable.js\");\nvar combineLatest_1 = __webpack_require__(/*! ../operators/combineLatest */ \"./node_modules/rxjs/operators/combineLatest.js\");\n/* tslint:enable:max-line-length */\n/**\n * Combines multiple Observables to create an Observable whose values are\n * calculated from the latest values of each of its input Observables.\n *\n * <span class=\"informal\">Whenever any input Observable emits a value, it\n * computes a formula using the latest values from all the inputs, then emits\n * the output of that formula.</span>\n *\n * <img src=\"./img/combineLatest.png\" width=\"100%\">\n *\n * `combineLatest` combines the values from all the Observables passed as\n * arguments. This is done by subscribing to each Observable in order and,\n * whenever any Observable emits, collecting an array of the most recent\n * values from each Observable. So if you pass `n` Observables to operator,\n * returned Observable will always emit an array of `n` values, in order\n * corresponding to order of passed Observables (value from the first Observable\n * on the first place and so on).\n *\n * Static version of `combineLatest` accepts either an array of Observables\n * or each Observable can be put directly as an argument. Note that array of\n * Observables is good choice, if you don't know beforehand how many Observables\n * you will combine. Passing empty array will result in Observable that\n * completes immediately.\n *\n * To ensure output array has always the same length, `combineLatest` will\n * actually wait for all input Observables to emit at least once,\n * before it starts emitting results. This means if some Observable emits\n * values before other Observables started emitting, all that values but last\n * will be lost. On the other hand, is some Observable does not emit value but\n * completes, resulting Observable will complete at the same moment without\n * emitting anything, since it will be now impossible to include value from\n * completed Observable in resulting array. Also, if some input Observable does\n * not emit any value and never completes, `combineLatest` will also never emit\n * and never complete, since, again, it will wait for all streams to emit some\n * value.\n *\n * If at least one Observable was passed to `combineLatest` and all passed Observables\n * emitted something, resulting Observable will complete when all combined\n * streams complete. So even if some Observable completes, result of\n * `combineLatest` will still emit values when other Observables do. In case\n * of completed Observable, its value from now on will always be the last\n * emitted value. On the other hand, if any Observable errors, `combineLatest`\n * will error immediately as well, and all other Observables will be unsubscribed.\n *\n * `combineLatest` accepts as optional parameter `project` function, which takes\n * as arguments all values that would normally be emitted by resulting Observable.\n * `project` can return any kind of value, which will be then emitted by Observable\n * instead of default array. Note that `project` does not take as argument that array\n * of values, but values themselves. That means default `project` can be imagined\n * as function that takes all its arguments and puts them into an array.\n *\n *\n * @example <caption>Combine two timer Observables</caption>\n * const firstTimer = Rx.Observable.timer(0, 1000); // emit 0, 1, 2... after every second, starting from now\n * const secondTimer = Rx.Observable.timer(500, 1000); // emit 0, 1, 2... after every second, starting 0,5s from now\n * const combinedTimers = Rx.Observable.combineLatest(firstTimer, secondTimer);\n * combinedTimers.subscribe(value => console.log(value));\n * // Logs\n * // [0, 0] after 0.5s\n * // [1, 0] after 1s\n * // [1, 1] after 1.5s\n * // [2, 1] after 2s\n *\n *\n * @example <caption>Combine an array of Observables</caption>\n * const observables = [1, 5, 10].map(\n *   n => Rx.Observable.of(n).delay(n * 1000).startWith(0) // emit 0 and then emit n after n seconds\n * );\n * const combined = Rx.Observable.combineLatest(observables);\n * combined.subscribe(value => console.log(value));\n * // Logs\n * // [0, 0, 0] immediately\n * // [1, 0, 0] after 1s\n * // [1, 5, 0] after 5s\n * // [1, 5, 10] after 10s\n *\n *\n * @example <caption>Use project function to dynamically calculate the Body-Mass Index</caption>\n * var weight = Rx.Observable.of(70, 72, 76, 79, 75);\n * var height = Rx.Observable.of(1.76, 1.77, 1.78);\n * var bmi = Rx.Observable.combineLatest(weight, height, (w, h) => w / (h * h));\n * bmi.subscribe(x => console.log('BMI is ' + x));\n *\n * // With output to console:\n * // BMI is 24.212293388429753\n * // BMI is 23.93948099205209\n * // BMI is 23.671253629592222\n *\n *\n * @see {@link combineAll}\n * @see {@link merge}\n * @see {@link withLatestFrom}\n *\n * @param {ObservableInput} observable1 An input Observable to combine with other Observables.\n * @param {ObservableInput} observable2 An input Observable to combine with other Observables.\n * More than one input Observables may be given as arguments\n * or an array of Observables may be given as the first argument.\n * @param {function} [project] An optional function to project the values from\n * the combined latest values into a new value on the output Observable.\n * @param {Scheduler} [scheduler=null] The IScheduler to use for subscribing to\n * each input Observable.\n * @return {Observable} An Observable of projected values from the most recent\n * values from each input Observable, or an array of the most recent values from\n * each input Observable.\n * @static true\n * @name combineLatest\n * @owner Observable\n */\nfunction combineLatest() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    var project = null;\n    var scheduler = null;\n    if (isScheduler_1.isScheduler(observables[observables.length - 1])) {\n        scheduler = observables.pop();\n    }\n    if (typeof observables[observables.length - 1] === 'function') {\n        project = observables.pop();\n    }\n    // if the first and only other argument besides the resultSelector is an array\n    // assume it's been called with `combineLatest([obs1, obs2, obs3], project)`\n    if (observables.length === 1 && isArray_1.isArray(observables[0])) {\n        observables = observables[0];\n    }\n    return new ArrayObservable_1.ArrayObservable(observables, scheduler).lift(new combineLatest_1.CombineLatestOperator(project));\n}\nexports.combineLatest = combineLatest;\n//# sourceMappingURL=combineLatest.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/observable/combineLatest.js?");

/***/ }),

/***/ "./node_modules/rxjs/observable/concat.js":
/*!************************************************!*\
  !*** ./node_modules/rxjs/observable/concat.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar isScheduler_1 = __webpack_require__(/*! ../util/isScheduler */ \"./node_modules/rxjs/util/isScheduler.js\");\nvar of_1 = __webpack_require__(/*! ./of */ \"./node_modules/rxjs/observable/of.js\");\nvar from_1 = __webpack_require__(/*! ./from */ \"./node_modules/rxjs/observable/from.js\");\nvar concatAll_1 = __webpack_require__(/*! ../operators/concatAll */ \"./node_modules/rxjs/operators/concatAll.js\");\n/* tslint:enable:max-line-length */\n/**\n * Creates an output Observable which sequentially emits all values from given\n * Observable and then moves on to the next.\n *\n * <span class=\"informal\">Concatenates multiple Observables together by\n * sequentially emitting their values, one Observable after the other.</span>\n *\n * <img src=\"./img/concat.png\" width=\"100%\">\n *\n * `concat` joins multiple Observables together, by subscribing to them one at a time and\n * merging their results into the output Observable. You can pass either an array of\n * Observables, or put them directly as arguments. Passing an empty array will result\n * in Observable that completes immediately.\n *\n * `concat` will subscribe to first input Observable and emit all its values, without\n * changing or affecting them in any way. When that Observable completes, it will\n * subscribe to then next Observable passed and, again, emit its values. This will be\n * repeated, until the operator runs out of Observables. When last input Observable completes,\n * `concat` will complete as well. At any given moment only one Observable passed to operator\n * emits values. If you would like to emit values from passed Observables concurrently, check out\n * {@link merge} instead, especially with optional `concurrent` parameter. As a matter of fact,\n * `concat` is an equivalent of `merge` operator with `concurrent` parameter set to `1`.\n *\n * Note that if some input Observable never completes, `concat` will also never complete\n * and Observables following the one that did not complete will never be subscribed. On the other\n * hand, if some Observable simply completes immediately after it is subscribed, it will be\n * invisible for `concat`, which will just move on to the next Observable.\n *\n * If any Observable in chain errors, instead of passing control to the next Observable,\n * `concat` will error immediately as well. Observables that would be subscribed after\n * the one that emitted error, never will.\n *\n * If you pass to `concat` the same Observable many times, its stream of values\n * will be \"replayed\" on every subscription, which means you can repeat given Observable\n * as many times as you like. If passing the same Observable to `concat` 1000 times becomes tedious,\n * you can always use {@link repeat}.\n *\n * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>\n * var timer = Rx.Observable.interval(1000).take(4);\n * var sequence = Rx.Observable.range(1, 10);\n * var result = Rx.Observable.concat(timer, sequence);\n * result.subscribe(x => console.log(x));\n *\n * // results in:\n * // 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10\n *\n *\n * @example <caption>Concatenate an array of 3 Observables</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var result = Rx.Observable.concat([timer1, timer2, timer3]); // note that array is passed\n * result.subscribe(x => console.log(x));\n *\n * // results in the following:\n * // (Prints to console sequentially)\n * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9\n * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5\n * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9\n *\n *\n * @example <caption>Concatenate the same Observable to repeat it</caption>\n * const timer = Rx.Observable.interval(1000).take(2);\n *\n * Rx.Observable.concat(timer, timer) // concating the same Observable!\n * .subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('...and it is done!')\n * );\n *\n * // Logs:\n * // 0 after 1s\n * // 1 after 2s\n * // 0 after 3s\n * // 1 after 4s\n * // \"...and it is done!\" also after 4s\n *\n * @see {@link concatAll}\n * @see {@link concatMap}\n * @see {@link concatMapTo}\n *\n * @param {ObservableInput} input1 An input Observable to concatenate with others.\n * @param {ObservableInput} input2 An input Observable to concatenate with others.\n * More than one input Observables may be given as argument.\n * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each\n * Observable subscription on.\n * @return {Observable} All values of each passed Observable merged into a\n * single Observable, in order, in serial fashion.\n * @static true\n * @name concat\n * @owner Observable\n */\nfunction concat() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    if (observables.length === 1 || (observables.length === 2 && isScheduler_1.isScheduler(observables[1]))) {\n        return from_1.from(observables[0]);\n    }\n    return concatAll_1.concatAll()(of_1.of.apply(void 0, observables));\n}\nexports.concat = concat;\n//# sourceMappingURL=concat.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/observable/concat.js?");

/***/ }),

/***/ "./node_modules/rxjs/observable/defer.js":
/*!***********************************************!*\
  !*** ./node_modules/rxjs/observable/defer.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar DeferObservable_1 = __webpack_require__(/*! ./DeferObservable */ \"./node_modules/rxjs/observable/DeferObservable.js\");\nexports.defer = DeferObservable_1.DeferObservable.create;\n//# sourceMappingURL=defer.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/observable/defer.js?");

/***/ }),

/***/ "./node_modules/rxjs/observable/empty.js":
/*!***********************************************!*\
  !*** ./node_modules/rxjs/observable/empty.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar EmptyObservable_1 = __webpack_require__(/*! ./EmptyObservable */ \"./node_modules/rxjs/observable/EmptyObservable.js\");\nexports.empty = EmptyObservable_1.EmptyObservable.create;\n//# sourceMappingURL=empty.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/observable/empty.js?");

/***/ }),

/***/ "./node_modules/rxjs/observable/from.js":
/*!**********************************************!*\
  !*** ./node_modules/rxjs/observable/from.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar FromObservable_1 = __webpack_require__(/*! ./FromObservable */ \"./node_modules/rxjs/observable/FromObservable.js\");\nexports.from = FromObservable_1.FromObservable.create;\n//# sourceMappingURL=from.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/observable/from.js?");

/***/ }),

/***/ "./node_modules/rxjs/observable/fromEvent.js":
/*!***************************************************!*\
  !*** ./node_modules/rxjs/observable/fromEvent.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar FromEventObservable_1 = __webpack_require__(/*! ./FromEventObservable */ \"./node_modules/rxjs/observable/FromEventObservable.js\");\nexports.fromEvent = FromEventObservable_1.FromEventObservable.create;\n//# sourceMappingURL=fromEvent.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/observable/fromEvent.js?");

/***/ }),

/***/ "./node_modules/rxjs/observable/fromPromise.js":
/*!*****************************************************!*\
  !*** ./node_modules/rxjs/observable/fromPromise.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar PromiseObservable_1 = __webpack_require__(/*! ./PromiseObservable */ \"./node_modules/rxjs/observable/PromiseObservable.js\");\nexports.fromPromise = PromiseObservable_1.PromiseObservable.create;\n//# sourceMappingURL=fromPromise.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/observable/fromPromise.js?");

/***/ }),

/***/ "./node_modules/rxjs/observable/interval.js":
/*!**************************************************!*\
  !*** ./node_modules/rxjs/observable/interval.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar IntervalObservable_1 = __webpack_require__(/*! ./IntervalObservable */ \"./node_modules/rxjs/observable/IntervalObservable.js\");\nexports.interval = IntervalObservable_1.IntervalObservable.create;\n//# sourceMappingURL=interval.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/observable/interval.js?");

/***/ }),

/***/ "./node_modules/rxjs/observable/merge.js":
/*!***********************************************!*\
  !*** ./node_modules/rxjs/observable/merge.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Observable_1 = __webpack_require__(/*! ../Observable */ \"./node_modules/rxjs/Observable.js\");\nvar ArrayObservable_1 = __webpack_require__(/*! ./ArrayObservable */ \"./node_modules/rxjs/observable/ArrayObservable.js\");\nvar isScheduler_1 = __webpack_require__(/*! ../util/isScheduler */ \"./node_modules/rxjs/util/isScheduler.js\");\nvar mergeAll_1 = __webpack_require__(/*! ../operators/mergeAll */ \"./node_modules/rxjs/operators/mergeAll.js\");\n/* tslint:enable:max-line-length */\n/**\n * Creates an output Observable which concurrently emits all values from every\n * given input Observable.\n *\n * <span class=\"informal\">Flattens multiple Observables together by blending\n * their values into one Observable.</span>\n *\n * <img src=\"./img/merge.png\" width=\"100%\">\n *\n * `merge` subscribes to each given input Observable (as arguments), and simply\n * forwards (without doing any transformation) all the values from all the input\n * Observables to the output Observable. The output Observable only completes\n * once all input Observables have completed. Any error delivered by an input\n * Observable will be immediately emitted on the output Observable.\n *\n * @example <caption>Merge together two Observables: 1s interval and clicks</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var timer = Rx.Observable.interval(1000);\n * var clicksOrTimer = Rx.Observable.merge(clicks, timer);\n * clicksOrTimer.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // timer will emit ascending values, one every second(1000ms) to console\n * // clicks logs MouseEvents to console everytime the \"document\" is clicked\n * // Since the two streams are merged you see these happening\n * // as they occur.\n *\n * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var concurrent = 2; // the argument\n * var merged = Rx.Observable.merge(timer1, timer2, timer3, concurrent);\n * merged.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // - First timer1 and timer2 will run concurrently\n * // - timer1 will emit a value every 1000ms for 10 iterations\n * // - timer2 will emit a value every 2000ms for 6 iterations\n * // - after timer1 hits it's max iteration, timer2 will\n * //   continue, and timer3 will start to run concurrently with timer2\n * // - when timer2 hits it's max iteration it terminates, and\n * //   timer3 will continue to emit a value every 500ms until it is complete\n *\n * @see {@link mergeAll}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n *\n * @param {...ObservableInput} observables Input Observables to merge together.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @param {Scheduler} [scheduler=null] The IScheduler to use for managing\n * concurrency of input Observables.\n * @return {Observable} an Observable that emits items that are the result of\n * every input Observable.\n * @static true\n * @name merge\n * @owner Observable\n */\nfunction merge() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    var concurrent = Number.POSITIVE_INFINITY;\n    var scheduler = null;\n    var last = observables[observables.length - 1];\n    if (isScheduler_1.isScheduler(last)) {\n        scheduler = observables.pop();\n        if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {\n            concurrent = observables.pop();\n        }\n    }\n    else if (typeof last === 'number') {\n        concurrent = observables.pop();\n    }\n    if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable_1.Observable) {\n        return observables[0];\n    }\n    return mergeAll_1.mergeAll(concurrent)(new ArrayObservable_1.ArrayObservable(observables, scheduler));\n}\nexports.merge = merge;\n//# sourceMappingURL=merge.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/observable/merge.js?");

/***/ }),

/***/ "./node_modules/rxjs/observable/never.js":
/*!***********************************************!*\
  !*** ./node_modules/rxjs/observable/never.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar NeverObservable_1 = __webpack_require__(/*! ./NeverObservable */ \"./node_modules/rxjs/observable/NeverObservable.js\");\nexports.never = NeverObservable_1.NeverObservable.create;\n//# sourceMappingURL=never.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/observable/never.js?");

/***/ }),

/***/ "./node_modules/rxjs/observable/of.js":
/*!********************************************!*\
  !*** ./node_modules/rxjs/observable/of.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar ArrayObservable_1 = __webpack_require__(/*! ./ArrayObservable */ \"./node_modules/rxjs/observable/ArrayObservable.js\");\nexports.of = ArrayObservable_1.ArrayObservable.of;\n//# sourceMappingURL=of.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/observable/of.js?");

/***/ }),

/***/ "./node_modules/rxjs/observable/throw.js":
/*!***********************************************!*\
  !*** ./node_modules/rxjs/observable/throw.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar ErrorObservable_1 = __webpack_require__(/*! ./ErrorObservable */ \"./node_modules/rxjs/observable/ErrorObservable.js\");\nexports._throw = ErrorObservable_1.ErrorObservable.create;\n//# sourceMappingURL=throw.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/observable/throw.js?");

/***/ }),

/***/ "./node_modules/rxjs/observable/timer.js":
/*!***********************************************!*\
  !*** ./node_modules/rxjs/observable/timer.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar TimerObservable_1 = __webpack_require__(/*! ./TimerObservable */ \"./node_modules/rxjs/observable/TimerObservable.js\");\nexports.timer = TimerObservable_1.TimerObservable.create;\n//# sourceMappingURL=timer.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/observable/timer.js?");

/***/ }),

/***/ "./node_modules/rxjs/operator/catch.js":
/*!*********************************************!*\
  !*** ./node_modules/rxjs/operator/catch.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar catchError_1 = __webpack_require__(/*! ../operators/catchError */ \"./node_modules/rxjs/operators/catchError.js\");\n/**\n * Catches errors on the observable to be handled by returning a new observable or throwing an error.\n *\n * <img src=\"./img/catch.png\" width=\"100%\">\n *\n * @example <caption>Continues with a different Observable when there's an error</caption>\n *\n * Observable.of(1, 2, 3, 4, 5)\n *   .map(n => {\n * \t   if (n == 4) {\n * \t     throw 'four!';\n *     }\n *\t   return n;\n *   })\n *   .catch(err => Observable.of('I', 'II', 'III', 'IV', 'V'))\n *   .subscribe(x => console.log(x));\n *   // 1, 2, 3, I, II, III, IV, V\n *\n * @example <caption>Retries the caught source Observable again in case of error, similar to retry() operator</caption>\n *\n * Observable.of(1, 2, 3, 4, 5)\n *   .map(n => {\n * \t   if (n === 4) {\n * \t     throw 'four!';\n *     }\n * \t   return n;\n *   })\n *   .catch((err, caught) => caught)\n *   .take(30)\n *   .subscribe(x => console.log(x));\n *   // 1, 2, 3, 1, 2, 3, ...\n *\n * @example <caption>Throws a new error when the source Observable throws an error</caption>\n *\n * Observable.of(1, 2, 3, 4, 5)\n *   .map(n => {\n *     if (n == 4) {\n *       throw 'four!';\n *     }\n *     return n;\n *   })\n *   .catch(err => {\n *     throw 'error in source. Details: ' + err;\n *   })\n *   .subscribe(\n *     x => console.log(x),\n *     err => console.log(err)\n *   );\n *   // 1, 2, 3, error in source. Details: four!\n *\n * @param {function} selector a function that takes as arguments `err`, which is the error, and `caught`, which\n *  is the source observable, in case you'd like to \"retry\" that observable by returning it again. Whatever observable\n *  is returned by the `selector` will be used to continue the observable chain.\n * @return {Observable} An observable that originates from either the source or the observable returned by the\n *  catch `selector` function.\n * @method catch\n * @name catch\n * @owner Observable\n */\nfunction _catch(selector) {\n    return catchError_1.catchError(selector)(this);\n}\nexports._catch = _catch;\n//# sourceMappingURL=catch.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/operator/catch.js?");

/***/ }),

/***/ "./node_modules/rxjs/operator/concat.js":
/*!**********************************************!*\
  !*** ./node_modules/rxjs/operator/concat.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar concat_1 = __webpack_require__(/*! ../operators/concat */ \"./node_modules/rxjs/operators/concat.js\");\nvar concat_2 = __webpack_require__(/*! ../observable/concat */ \"./node_modules/rxjs/observable/concat.js\");\nexports.concatStatic = concat_2.concat;\n/* tslint:enable:max-line-length */\n/**\n * Creates an output Observable which sequentially emits all values from every\n * given input Observable after the current Observable.\n *\n * <span class=\"informal\">Concatenates multiple Observables together by\n * sequentially emitting their values, one Observable after the other.</span>\n *\n * <img src=\"./img/concat.png\" width=\"100%\">\n *\n * Joins this Observable with multiple other Observables by subscribing to them\n * one at a time, starting with the source, and merging their results into the\n * output Observable. Will wait for each Observable to complete before moving\n * on to the next.\n *\n * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>\n * var timer = Rx.Observable.interval(1000).take(4);\n * var sequence = Rx.Observable.range(1, 10);\n * var result = timer.concat(sequence);\n * result.subscribe(x => console.log(x));\n *\n * // results in:\n * // 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10\n *\n * @example <caption>Concatenate 3 Observables</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var result = timer1.concat(timer2, timer3);\n * result.subscribe(x => console.log(x));\n *\n * // results in the following:\n * // (Prints to console sequentially)\n * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9\n * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5\n * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9\n *\n * @see {@link concatAll}\n * @see {@link concatMap}\n * @see {@link concatMapTo}\n *\n * @param {ObservableInput} other An input Observable to concatenate after the source\n * Observable. More than one input Observables may be given as argument.\n * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each\n * Observable subscription on.\n * @return {Observable} All values of each passed Observable merged into a\n * single Observable, in order, in serial fashion.\n * @method concat\n * @owner Observable\n */\nfunction concat() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    return concat_1.concat.apply(void 0, observables)(this);\n}\nexports.concat = concat;\n//# sourceMappingURL=concat.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/operator/concat.js?");

/***/ }),

/***/ "./node_modules/rxjs/operator/concatAll.js":
/*!*************************************************!*\
  !*** ./node_modules/rxjs/operator/concatAll.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar concatAll_1 = __webpack_require__(/*! ../operators/concatAll */ \"./node_modules/rxjs/operators/concatAll.js\");\n/* tslint:enable:max-line-length */\n/**\n * Converts a higher-order Observable into a first-order Observable by\n * concatenating the inner Observables in order.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables by putting one\n * inner Observable after the other.</span>\n *\n * <img src=\"./img/concatAll.png\" width=\"100%\">\n *\n * Joins every Observable emitted by the source (a higher-order Observable), in\n * a serial fashion. It subscribes to each inner Observable only after the\n * previous inner Observable has completed, and merges all of their values into\n * the returned observable.\n *\n * __Warning:__ If the source Observable emits Observables quickly and\n * endlessly, and the inner Observables it emits generally complete slower than\n * the source emits, you can run into memory issues as the incoming Observables\n * collect in an unbounded buffer.\n *\n * Note: `concatAll` is equivalent to `mergeAll` with concurrency parameter set\n * to `1`.\n *\n * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var higherOrder = clicks.map(ev => Rx.Observable.interval(1000).take(4));\n * var firstOrder = higherOrder.concatAll();\n * firstOrder.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // (results are not concurrent)\n * // For every click on the \"document\" it will emit values 0 to 3 spaced\n * // on a 1000ms interval\n * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3\n *\n * @see {@link combineAll}\n * @see {@link concat}\n * @see {@link concatMap}\n * @see {@link concatMapTo}\n * @see {@link exhaust}\n * @see {@link mergeAll}\n * @see {@link switch}\n * @see {@link zipAll}\n *\n * @return {Observable} An Observable emitting values from all the inner\n * Observables concatenated.\n * @method concatAll\n * @owner Observable\n */\nfunction concatAll() {\n    return concatAll_1.concatAll()(this);\n}\nexports.concatAll = concatAll;\n//# sourceMappingURL=concatAll.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/operator/concatAll.js?");

/***/ }),

/***/ "./node_modules/rxjs/operator/concatMap.js":
/*!*************************************************!*\
  !*** ./node_modules/rxjs/operator/concatMap.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar concatMap_1 = __webpack_require__(/*! ../operators/concatMap */ \"./node_modules/rxjs/operators/concatMap.js\");\n/* tslint:enable:max-line-length */\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable, in a serialized fashion waiting for each one to complete before\n * merging the next.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link concatAll}.</span>\n *\n * <img src=\"./img/concatMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. Each new inner Observable is\n * concatenated with the previous inner Observable.\n *\n * __Warning:__ if source values arrive endlessly and faster than their\n * corresponding inner Observables can complete, it will result in memory issues\n * as inner Observables amass in an unbounded buffer waiting for their turn to\n * be subscribed to.\n *\n * Note: `concatMap` is equivalent to `mergeMap` with concurrency parameter set\n * to `1`.\n *\n * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.concatMap(ev => Rx.Observable.interval(1000).take(4));\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // (results are not concurrent)\n * // For every click on the \"document\" it will emit values 0 to 3 spaced\n * // on a 1000ms interval\n * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3\n *\n * @see {@link concat}\n * @see {@link concatAll}\n * @see {@link concatMapTo}\n * @see {@link exhaustMap}\n * @see {@link mergeMap}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An Observable that emits the result of applying the\n * projection function (and the optional `resultSelector`) to each item emitted\n * by the source Observable and taking values from each projected inner\n * Observable sequentially.\n * @method concatMap\n * @owner Observable\n */\nfunction concatMap(project, resultSelector) {\n    return concatMap_1.concatMap(project, resultSelector)(this);\n}\nexports.concatMap = concatMap;\n//# sourceMappingURL=concatMap.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/operator/concatMap.js?");

/***/ }),

/***/ "./node_modules/rxjs/operator/debounceTime.js":
/*!****************************************************!*\
  !*** ./node_modules/rxjs/operator/debounceTime.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar async_1 = __webpack_require__(/*! ../scheduler/async */ \"./node_modules/rxjs/scheduler/async.js\");\nvar debounceTime_1 = __webpack_require__(/*! ../operators/debounceTime */ \"./node_modules/rxjs/operators/debounceTime.js\");\n/**\n * Emits a value from the source Observable only after a particular time span\n * has passed without another source emission.\n *\n * <span class=\"informal\">It's like {@link delay}, but passes only the most\n * recent value from each burst of emissions.</span>\n *\n * <img src=\"./img/debounceTime.png\" width=\"100%\">\n *\n * `debounceTime` delays values emitted by the source Observable, but drops\n * previous pending delayed emissions if a new value arrives on the source\n * Observable. This operator keeps track of the most recent value from the\n * source Observable, and emits that only when `dueTime` enough time has passed\n * without any other value appearing on the source Observable. If a new value\n * appears before `dueTime` silence occurs, the previous value will be dropped\n * and will not be emitted on the output Observable.\n *\n * This is a rate-limiting operator, because it is impossible for more than one\n * value to be emitted in any time window of duration `dueTime`, but it is also\n * a delay-like operator since output emissions do not occur at the same time as\n * they did on the source Observable. Optionally takes a {@link IScheduler} for\n * managing timers.\n *\n * @example <caption>Emit the most recent click after a burst of clicks</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.debounceTime(1000);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link auditTime}\n * @see {@link debounce}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttleTime}\n *\n * @param {number} dueTime The timeout duration in milliseconds (or the time\n * unit determined internally by the optional `scheduler`) for the window of\n * time required to wait for emission silence before emitting the most recent\n * source value.\n * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n * managing the timers that handle the timeout for each value.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by the specified `dueTime`, and may drop some values if they occur\n * too frequently.\n * @method debounceTime\n * @owner Observable\n */\nfunction debounceTime(dueTime, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    return debounceTime_1.debounceTime(dueTime, scheduler)(this);\n}\nexports.debounceTime = debounceTime;\n//# sourceMappingURL=debounceTime.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/operator/debounceTime.js?");

/***/ }),

/***/ "./node_modules/rxjs/operator/distinctUntilChanged.js":
/*!************************************************************!*\
  !*** ./node_modules/rxjs/operator/distinctUntilChanged.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar distinctUntilChanged_1 = __webpack_require__(/*! ../operators/distinctUntilChanged */ \"./node_modules/rxjs/operators/distinctUntilChanged.js\");\n/* tslint:enable:max-line-length */\n/**\n * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item.\n *\n * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.\n *\n * If a comparator function is not provided, an equality check is used by default.\n *\n * @example <caption>A simple example with numbers</caption>\n * Observable.of(1, 1, 2, 2, 2, 1, 1, 2, 3, 3, 4)\n *   .distinctUntilChanged()\n *   .subscribe(x => console.log(x)); // 1, 2, 1, 2, 3, 4\n *\n * @example <caption>An example using a compare function</caption>\n * interface Person {\n *    age: number,\n *    name: string\n * }\n *\n * Observable.of<Person>(\n *     { age: 4, name: 'Foo'},\n *     { age: 7, name: 'Bar'},\n *     { age: 5, name: 'Foo'})\n *     { age: 6, name: 'Foo'})\n *     .distinctUntilChanged((p: Person, q: Person) => p.name === q.name)\n *     .subscribe(x => console.log(x));\n *\n * // displays:\n * // { age: 4, name: 'Foo' }\n * // { age: 7, name: 'Bar' }\n * // { age: 5, name: 'Foo' }\n *\n * @see {@link distinct}\n * @see {@link distinctUntilKeyChanged}\n *\n * @param {function} [compare] Optional comparison function called to test if an item is distinct from the previous item in the source.\n * @return {Observable} An Observable that emits items from the source Observable with distinct values.\n * @method distinctUntilChanged\n * @owner Observable\n */\nfunction distinctUntilChanged(compare, keySelector) {\n    return distinctUntilChanged_1.distinctUntilChanged(compare, keySelector)(this);\n}\nexports.distinctUntilChanged = distinctUntilChanged;\n//# sourceMappingURL=distinctUntilChanged.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/operator/distinctUntilChanged.js?");

/***/ }),

/***/ "./node_modules/rxjs/operator/do.js":
/*!******************************************!*\
  !*** ./node_modules/rxjs/operator/do.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar tap_1 = __webpack_require__(/*! ../operators/tap */ \"./node_modules/rxjs/operators/tap.js\");\n/* tslint:enable:max-line-length */\n/**\n * Perform a side effect for every emission on the source Observable, but return\n * an Observable that is identical to the source.\n *\n * <span class=\"informal\">Intercepts each emission on the source and runs a\n * function, but returns an output which is identical to the source as long as errors don't occur.</span>\n *\n * <img src=\"./img/do.png\" width=\"100%\">\n *\n * Returns a mirrored Observable of the source Observable, but modified so that\n * the provided Observer is called to perform a side effect for every value,\n * error, and completion emitted by the source. Any errors that are thrown in\n * the aforementioned Observer or handlers are safely sent down the error path\n * of the output Observable.\n *\n * This operator is useful for debugging your Observables for the correct values\n * or performing other side effects.\n *\n * Note: this is different to a `subscribe` on the Observable. If the Observable\n * returned by `do` is not subscribed, the side effects specified by the\n * Observer will never happen. `do` therefore simply spies on existing\n * execution, it does not trigger an execution to happen like `subscribe` does.\n *\n * @example <caption>Map every click to the clientX position of that click, while also logging the click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var positions = clicks\n *   .do(ev => console.log(ev))\n *   .map(ev => ev.clientX);\n * positions.subscribe(x => console.log(x));\n *\n * @see {@link map}\n * @see {@link subscribe}\n *\n * @param {Observer|function} [nextOrObserver] A normal Observer object or a\n * callback for `next`.\n * @param {function} [error] Callback for errors in the source.\n * @param {function} [complete] Callback for the completion of the source.\n * @return {Observable} An Observable identical to the source, but runs the\n * specified Observer or callback(s) for each item.\n * @method do\n * @name do\n * @owner Observable\n */\nfunction _do(nextOrObserver, error, complete) {\n    return tap_1.tap(nextOrObserver, error, complete)(this);\n}\nexports._do = _do;\n//# sourceMappingURL=do.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/operator/do.js?");

/***/ }),

/***/ "./node_modules/rxjs/operator/exhaustMap.js":
/*!**************************************************!*\
  !*** ./node_modules/rxjs/operator/exhaustMap.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar exhaustMap_1 = __webpack_require__(/*! ../operators/exhaustMap */ \"./node_modules/rxjs/operators/exhaustMap.js\");\n/* tslint:enable:max-line-length */\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable only if the previous projected Observable has completed.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link exhaust}.</span>\n *\n * <img src=\"./img/exhaustMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. When it projects a source value to\n * an Observable, the output Observable begins emitting the items emitted by\n * that projected Observable. However, `exhaustMap` ignores every new projected\n * Observable if the previous projected Observable has not yet completed. Once\n * that one completes, it will accept and flatten the next projected Observable\n * and repeat this process.\n *\n * @example <caption>Run a finite timer for each click, only if there is no currently active timer</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.exhaustMap((ev) => Rx.Observable.interval(1000).take(5));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMap}\n * @see {@link exhaust}\n * @see {@link mergeMap}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An Observable containing projected Observables\n * of each item of the source, ignoring projected Observables that start before\n * their preceding Observable has completed.\n * @method exhaustMap\n * @owner Observable\n */\nfunction exhaustMap(project, resultSelector) {\n    return exhaustMap_1.exhaustMap(project, resultSelector)(this);\n}\nexports.exhaustMap = exhaustMap;\n//# sourceMappingURL=exhaustMap.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/operator/exhaustMap.js?");

/***/ }),

/***/ "./node_modules/rxjs/operator/filter.js":
/*!**********************************************!*\
  !*** ./node_modules/rxjs/operator/filter.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar filter_1 = __webpack_require__(/*! ../operators/filter */ \"./node_modules/rxjs/operators/filter.js\");\n/* tslint:enable:max-line-length */\n/**\n * Filter items emitted by the source Observable by only emitting those that\n * satisfy a specified predicate.\n *\n * <span class=\"informal\">Like\n * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),\n * it only emits a value from the source if it passes a criterion function.</span>\n *\n * <img src=\"./img/filter.png\" width=\"100%\">\n *\n * Similar to the well-known `Array.prototype.filter` method, this operator\n * takes values from the source Observable, passes them through a `predicate`\n * function and only emits those values that yielded `true`.\n *\n * @example <caption>Emit only click events whose target was a DIV element</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var clicksOnDivs = clicks.filter(ev => ev.target.tagName === 'DIV');\n * clicksOnDivs.subscribe(x => console.log(x));\n *\n * @see {@link distinct}\n * @see {@link distinctUntilChanged}\n * @see {@link distinctUntilKeyChanged}\n * @see {@link ignoreElements}\n * @see {@link partition}\n * @see {@link skip}\n *\n * @param {function(value: T, index: number): boolean} predicate A function that\n * evaluates each value emitted by the source Observable. If it returns `true`,\n * the value is emitted, if `false` the value is not passed to the output\n * Observable. The `index` parameter is the number `i` for the i-th source\n * emission that has happened since the subscription, starting from the number\n * `0`.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {Observable} An Observable of values from the source that were\n * allowed by the `predicate` function.\n * @method filter\n * @owner Observable\n */\nfunction filter(predicate, thisArg) {\n    return filter_1.filter(predicate, thisArg)(this);\n}\nexports.filter = filter;\n//# sourceMappingURL=filter.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/operator/filter.js?");

/***/ }),

/***/ "./node_modules/rxjs/operator/finally.js":
/*!***********************************************!*\
  !*** ./node_modules/rxjs/operator/finally.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar finalize_1 = __webpack_require__(/*! ../operators/finalize */ \"./node_modules/rxjs/operators/finalize.js\");\n/**\n * Returns an Observable that mirrors the source Observable, but will call a specified function when\n * the source terminates on complete or error.\n * @param {function} callback Function to be called when source terminates.\n * @return {Observable} An Observable that mirrors the source, but will call the specified function on termination.\n * @method finally\n * @owner Observable\n */\nfunction _finally(callback) {\n    return finalize_1.finalize(callback)(this);\n}\nexports._finally = _finally;\n//# sourceMappingURL=finally.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/operator/finally.js?");

/***/ }),

/***/ "./node_modules/rxjs/operator/ignoreElements.js":
/*!******************************************************!*\
  !*** ./node_modules/rxjs/operator/ignoreElements.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar ignoreElements_1 = __webpack_require__(/*! ../operators/ignoreElements */ \"./node_modules/rxjs/operators/ignoreElements.js\");\n/**\n * Ignores all items emitted by the source Observable and only passes calls of `complete` or `error`.\n *\n * <img src=\"./img/ignoreElements.png\" width=\"100%\">\n *\n * @return {Observable} An empty Observable that only calls `complete`\n * or `error`, based on which one is called by the source Observable.\n * @method ignoreElements\n * @owner Observable\n */\nfunction ignoreElements() {\n    return ignoreElements_1.ignoreElements()(this);\n}\nexports.ignoreElements = ignoreElements;\n;\n//# sourceMappingURL=ignoreElements.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/operator/ignoreElements.js?");

/***/ }),

/***/ "./node_modules/rxjs/operator/map.js":
/*!*******************************************!*\
  !*** ./node_modules/rxjs/operator/map.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar map_1 = __webpack_require__(/*! ../operators/map */ \"./node_modules/rxjs/operators/map.js\");\n/**\n * Applies a given `project` function to each value emitted by the source\n * Observable, and emits the resulting values as an Observable.\n *\n * <span class=\"informal\">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),\n * it passes each source value through a transformation function to get\n * corresponding output values.</span>\n *\n * <img src=\"./img/map.png\" width=\"100%\">\n *\n * Similar to the well known `Array.prototype.map` function, this operator\n * applies a projection to each value and emits that projection in the output\n * Observable.\n *\n * @example <caption>Map every click to the clientX position of that click</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var positions = clicks.map(ev => ev.clientX);\n * positions.subscribe(x => console.log(x));\n *\n * @see {@link mapTo}\n * @see {@link pluck}\n *\n * @param {function(value: T, index: number): R} project The function to apply\n * to each `value` emitted by the source Observable. The `index` parameter is\n * the number `i` for the i-th emission that has happened since the\n * subscription, starting from the number `0`.\n * @param {any} [thisArg] An optional argument to define what `this` is in the\n * `project` function.\n * @return {Observable<R>} An Observable that emits the values from the source\n * Observable transformed by the given `project` function.\n * @method map\n * @owner Observable\n */\nfunction map(project, thisArg) {\n    return map_1.map(project, thisArg)(this);\n}\nexports.map = map;\n//# sourceMappingURL=map.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/operator/map.js?");

/***/ }),

/***/ "./node_modules/rxjs/operator/mapTo.js":
/*!*********************************************!*\
  !*** ./node_modules/rxjs/operator/mapTo.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar mapTo_1 = __webpack_require__(/*! ../operators/mapTo */ \"./node_modules/rxjs/operators/mapTo.js\");\n/**\n * Emits the given constant value on the output Observable every time the source\n * Observable emits a value.\n *\n * <span class=\"informal\">Like {@link map}, but it maps every source value to\n * the same output value every time.</span>\n *\n * <img src=\"./img/mapTo.png\" width=\"100%\">\n *\n * Takes a constant `value` as argument, and emits that whenever the source\n * Observable emits a value. In other words, ignores the actual source value,\n * and simply uses the emission moment to know when to emit the given `value`.\n *\n * @example <caption>Map every click to the string 'Hi'</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var greetings = clicks.mapTo('Hi');\n * greetings.subscribe(x => console.log(x));\n *\n * @see {@link map}\n *\n * @param {any} value The value to map each source value to.\n * @return {Observable} An Observable that emits the given `value` every time\n * the source Observable emits something.\n * @method mapTo\n * @owner Observable\n */\nfunction mapTo(value) {\n    return mapTo_1.mapTo(value)(this);\n}\nexports.mapTo = mapTo;\n//# sourceMappingURL=mapTo.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/operator/mapTo.js?");

/***/ }),

/***/ "./node_modules/rxjs/operator/merge.js":
/*!*********************************************!*\
  !*** ./node_modules/rxjs/operator/merge.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar merge_1 = __webpack_require__(/*! ../operators/merge */ \"./node_modules/rxjs/operators/merge.js\");\nvar merge_2 = __webpack_require__(/*! ../observable/merge */ \"./node_modules/rxjs/observable/merge.js\");\nexports.mergeStatic = merge_2.merge;\n/* tslint:enable:max-line-length */\n/**\n * Creates an output Observable which concurrently emits all values from every\n * given input Observable.\n *\n * <span class=\"informal\">Flattens multiple Observables together by blending\n * their values into one Observable.</span>\n *\n * <img src=\"./img/merge.png\" width=\"100%\">\n *\n * `merge` subscribes to each given input Observable (either the source or an\n * Observable given as argument), and simply forwards (without doing any\n * transformation) all the values from all the input Observables to the output\n * Observable. The output Observable only completes once all input Observables\n * have completed. Any error delivered by an input Observable will be immediately\n * emitted on the output Observable.\n *\n * @example <caption>Merge together two Observables: 1s interval and clicks</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var timer = Rx.Observable.interval(1000);\n * var clicksOrTimer = clicks.merge(timer);\n * clicksOrTimer.subscribe(x => console.log(x));\n *\n * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var concurrent = 2; // the argument\n * var merged = timer1.merge(timer2, timer3, concurrent);\n * merged.subscribe(x => console.log(x));\n *\n * @see {@link mergeAll}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n *\n * @param {ObservableInput} other An input Observable to merge with the source\n * Observable. More than one input Observables may be given as argument.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @param {Scheduler} [scheduler=null] The IScheduler to use for managing\n * concurrency of input Observables.\n * @return {Observable} An Observable that emits items that are the result of\n * every input Observable.\n * @method merge\n * @owner Observable\n */\nfunction merge() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    return merge_1.merge.apply(void 0, observables)(this);\n}\nexports.merge = merge;\n//# sourceMappingURL=merge.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/operator/merge.js?");

/***/ }),

/***/ "./node_modules/rxjs/operator/mergeMap.js":
/*!************************************************!*\
  !*** ./node_modules/rxjs/operator/mergeMap.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar mergeMap_1 = __webpack_require__(/*! ../operators/mergeMap */ \"./node_modules/rxjs/operators/mergeMap.js\");\n/* tslint:enable:max-line-length */\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link mergeAll}.</span>\n *\n * <img src=\"./img/mergeMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an Observable, and then merging those resulting Observables and\n * emitting the results of this merger.\n *\n * @example <caption>Map and flatten each letter to an Observable ticking every 1 second</caption>\n * var letters = Rx.Observable.of('a', 'b', 'c');\n * var result = letters.mergeMap(x =>\n *   Rx.Observable.interval(1000).map(i => x+i)\n * );\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // a0\n * // b0\n * // c0\n * // a1\n * // b1\n * // c1\n * // continues to list a,b,c with respective ascending integers\n *\n * @see {@link concatMap}\n * @see {@link exhaustMap}\n * @see {@link merge}\n * @see {@link mergeAll}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @return {Observable} An Observable that emits the result of applying the\n * projection function (and the optional `resultSelector`) to each item emitted\n * by the source Observable and merging the results of the Observables obtained\n * from this transformation.\n * @method mergeMap\n * @owner Observable\n */\nfunction mergeMap(project, resultSelector, concurrent) {\n    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n    return mergeMap_1.mergeMap(project, resultSelector, concurrent)(this);\n}\nexports.mergeMap = mergeMap;\n//# sourceMappingURL=mergeMap.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/operator/mergeMap.js?");

/***/ }),

/***/ "./node_modules/rxjs/operator/mergeMapTo.js":
/*!**************************************************!*\
  !*** ./node_modules/rxjs/operator/mergeMapTo.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar mergeMapTo_1 = __webpack_require__(/*! ../operators/mergeMapTo */ \"./node_modules/rxjs/operators/mergeMapTo.js\");\n/* tslint:enable:max-line-length */\n/**\n * Projects each source value to the same Observable which is merged multiple\n * times in the output Observable.\n *\n * <span class=\"informal\">It's like {@link mergeMap}, but maps each value always\n * to the same inner Observable.</span>\n *\n * <img src=\"./img/mergeMapTo.png\" width=\"100%\">\n *\n * Maps each source value to the given Observable `innerObservable` regardless\n * of the source value, and then merges those resulting Observables into one\n * single Observable, which is the output Observable.\n *\n * @example <caption>For each click event, start an interval Observable ticking every 1 second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.mergeMapTo(Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMapTo}\n * @see {@link merge}\n * @see {@link mergeAll}\n * @see {@link mergeMap}\n * @see {@link mergeScan}\n * @see {@link switchMapTo}\n *\n * @param {ObservableInput} innerObservable An Observable to replace each value from\n * the source Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @return {Observable} An Observable that emits items from the given\n * `innerObservable` (and optionally transformed through `resultSelector`) every\n * time a value is emitted on the source Observable.\n * @method mergeMapTo\n * @owner Observable\n */\nfunction mergeMapTo(innerObservable, resultSelector, concurrent) {\n    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n    return mergeMapTo_1.mergeMapTo(innerObservable, resultSelector, concurrent)(this);\n}\nexports.mergeMapTo = mergeMapTo;\n//# sourceMappingURL=mergeMapTo.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/operator/mergeMapTo.js?");

/***/ }),

/***/ "./node_modules/rxjs/operator/multicast.js":
/*!*************************************************!*\
  !*** ./node_modules/rxjs/operator/multicast.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar multicast_1 = __webpack_require__(/*! ../operators/multicast */ \"./node_modules/rxjs/operators/multicast.js\");\n/* tslint:enable:max-line-length */\n/**\n * Allows source Observable to be subscribed only once with a Subject of choice,\n * while still sharing its values between multiple subscribers.\n *\n * <span class=\"informal\">Subscribe to Observable once, but send its values to multiple subscribers.</span>\n *\n * <img src=\"./img/multicast.png\" width=\"100%\">\n *\n * `multicast` is an operator that works in two modes.\n *\n * In the first mode you provide a single argument to it, which can be either an initialized Subject or a Subject\n * factory. As a result you will get a special kind of an Observable - a {@link ConnectableObservable}. It can be\n * subscribed multiple times, just as regular Observable, but it won't subscribe to the source Observable at that\n * moment. It will do it only if you call its `connect` method. This means you can essentially control by hand, when\n * source Observable will be actually subscribed. What is more, ConnectableObservable will share this one subscription\n * between all of its subscribers. This means that, for example, `ajax` Observable will only send a request once,\n * even though usually it would send a request per every subscriber. Since it sends a request at the moment of\n * subscription, here request would be sent when the `connect` method of a ConnectableObservable is called.\n *\n * The most common pattern of using ConnectableObservable is calling `connect` when the first consumer subscribes,\n * keeping the subscription alive while several consumers come and go and finally unsubscribing from the source\n * Observable, when the last consumer unsubscribes. To not implement that logic over and over again,\n * ConnectableObservable has a special operator, `refCount`. When called, it returns an Observable, which will count\n * the number of consumers subscribed to it and keep ConnectableObservable connected as long as there is at least\n * one consumer. So if you don't actually need to decide yourself when to connect and disconnect a\n * ConnectableObservable, use `refCount`.\n *\n * The second mode is invoked by calling `multicast` with an additional, second argument - selector function.\n * This function accepts an Observable - which basically mirrors the source Observable - and returns Observable\n * as well, which should be the input stream modified by any operators you want. Note that in this\n * mode you cannot provide initialized Subject as a first argument - it has to be a Subject factory. If\n * you provide selector function, `multicast` returns just a regular Observable, instead of ConnectableObservable.\n * Thus, as usual, each subscription to this stream triggers subscription to the source Observable. However,\n * if inside the selector function you subscribe to the input Observable multiple times, actual source stream\n * will be subscribed only once. So if you have a chain of operators that use some Observable many times,\n * but you want to subscribe to that Observable only once, this is the mode you would use.\n *\n * Subject provided as a first parameter of `multicast` is used as a proxy for the single subscription to the\n * source Observable. It means that all values from the source stream go through that Subject. Thus, if a Subject\n * has some special properties, Observable returned by `multicast` will have them as well. If you want to use\n * `multicast` with a Subject that is one of the ones included in RxJS by default - {@link Subject},\n * {@link AsyncSubject}, {@link BehaviorSubject}, or {@link ReplaySubject} - simply use {@link publish},\n * {@link publishLast}, {@link publishBehavior} or {@link publishReplay} respectively. These are actually\n * just wrappers around `multicast`, with a specific Subject hardcoded inside.\n *\n * Also, if you use {@link publish} or {@link publishReplay} with a ConnectableObservables `refCount` operator,\n * you can simply use {@link share} and {@link shareReplay} respectively, which chain these two.\n *\n * @example <caption>Use ConnectableObservable</caption>\n * const seconds = Rx.Observable.interval(1000);\n * const connectableSeconds = seconds.multicast(new Subject());\n *\n * connectableSeconds.subscribe(value => console.log('first: ' + value));\n * connectableSeconds.subscribe(value => console.log('second: ' + value));\n *\n * // At this point still nothing happens, even though we subscribed twice.\n *\n * connectableSeconds.connect();\n *\n * // From now on `seconds` are being logged to the console,\n * // twice per every second. `seconds` Observable was however only subscribed once,\n * // so under the hood Observable.interval had only one clock started.\n *\n * @example <caption>Use selector</caption>\n * const seconds = Rx.Observable.interval(1000);\n *\n * seconds\n *     .multicast(\n *         () => new Subject(),\n *         seconds => seconds.zip(seconds) // Usually zip would subscribe to `seconds` twice.\n *                                         // Because we are inside selector, `seconds` is subscribed once,\n *     )                                   // thus starting only one clock used internally by Observable.interval.\n *     .subscribe();\n *\n * @see {@link publish}\n * @see {@link publishLast}\n * @see {@link publishBehavior}\n * @see {@link publishReplay}\n * @see {@link share}\n * @see {@link shareReplay}\n *\n * @param {Function|Subject} subjectOrSubjectFactory - Factory function to create an intermediate Subject through\n * which the source sequence's elements will be multicast to the selector function input Observable or\n * ConnectableObservable returned by the operator.\n * @param {Function} [selector] - Optional selector function that can use the input stream\n * as many times as needed, without causing multiple subscriptions to the source stream.\n * Subscribers to the input source will receive all notifications of the source from the\n * time of the subscription forward.\n * @return {Observable<T>|ConnectableObservable<T>} An Observable that emits the results of invoking the selector\n * on the source stream or a special {@link ConnectableObservable}, if selector was not provided.\n *\n * @method multicast\n * @owner Observable\n */\nfunction multicast(subjectOrSubjectFactory, selector) {\n    return multicast_1.multicast(subjectOrSubjectFactory, selector)(this);\n}\nexports.multicast = multicast;\n//# sourceMappingURL=multicast.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/operator/multicast.js?");

/***/ }),

/***/ "./node_modules/rxjs/operator/pairwise.js":
/*!************************************************!*\
  !*** ./node_modules/rxjs/operator/pairwise.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar pairwise_1 = __webpack_require__(/*! ../operators/pairwise */ \"./node_modules/rxjs/operators/pairwise.js\");\n/**\n * Groups pairs of consecutive emissions together and emits them as an array of\n * two values.\n *\n * <span class=\"informal\">Puts the current value and previous value together as\n * an array, and emits that.</span>\n *\n * <img src=\"./img/pairwise.png\" width=\"100%\">\n *\n * The Nth emission from the source Observable will cause the output Observable\n * to emit an array [(N-1)th, Nth] of the previous and the current value, as a\n * pair. For this reason, `pairwise` emits on the second and subsequent\n * emissions from the source Observable, but not on the first emission, because\n * there is no previous value in that case.\n *\n * @example <caption>On every click (starting from the second), emit the relative distance to the previous click</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var pairs = clicks.pairwise();\n * var distance = pairs.map(pair => {\n *   var x0 = pair[0].clientX;\n *   var y0 = pair[0].clientY;\n *   var x1 = pair[1].clientX;\n *   var y1 = pair[1].clientY;\n *   return Math.sqrt(Math.pow(x0 - x1, 2) + Math.pow(y0 - y1, 2));\n * });\n * distance.subscribe(x => console.log(x));\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n *\n * @return {Observable<Array<T>>} An Observable of pairs (as arrays) of\n * consecutive values from the source Observable.\n * @method pairwise\n * @owner Observable\n */\nfunction pairwise() {\n    return pairwise_1.pairwise()(this);\n}\nexports.pairwise = pairwise;\n//# sourceMappingURL=pairwise.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/operator/pairwise.js?");

/***/ }),

/***/ "./node_modules/rxjs/operator/publish.js":
/*!***********************************************!*\
  !*** ./node_modules/rxjs/operator/publish.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar publish_1 = __webpack_require__(/*! ../operators/publish */ \"./node_modules/rxjs/operators/publish.js\");\n/* tslint:enable:max-line-length */\n/**\n * Returns a ConnectableObservable, which is a variety of Observable that waits until its connect method is called\n * before it begins emitting items to those Observers that have subscribed to it.\n *\n * <img src=\"./img/publish.png\" width=\"100%\">\n *\n * @param {Function} [selector] - Optional selector function which can use the multicasted source sequence as many times\n * as needed, without causing multiple subscriptions to the source sequence.\n * Subscribers to the given source will receive all notifications of the source from the time of the subscription on.\n * @return A ConnectableObservable that upon connection causes the source Observable to emit items to its Observers.\n * @method publish\n * @owner Observable\n */\nfunction publish(selector) {\n    return publish_1.publish(selector)(this);\n}\nexports.publish = publish;\n//# sourceMappingURL=publish.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/operator/publish.js?");

/***/ }),

/***/ "./node_modules/rxjs/operator/scan.js":
/*!********************************************!*\
  !*** ./node_modules/rxjs/operator/scan.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar scan_1 = __webpack_require__(/*! ../operators/scan */ \"./node_modules/rxjs/operators/scan.js\");\n/* tslint:enable:max-line-length */\n/**\n * Applies an accumulator function over the source Observable, and returns each\n * intermediate result, with an optional seed value.\n *\n * <span class=\"informal\">It's like {@link reduce}, but emits the current\n * accumulation whenever the source emits a value.</span>\n *\n * <img src=\"./img/scan.png\" width=\"100%\">\n *\n * Combines together all values emitted on the source, using an accumulator\n * function that knows how to join a new source value into the accumulation from\n * the past. Is similar to {@link reduce}, but emits the intermediate\n * accumulations.\n *\n * Returns an Observable that applies a specified `accumulator` function to each\n * item emitted by the source Observable. If a `seed` value is specified, then\n * that value will be used as the initial value for the accumulator. If no seed\n * value is specified, the first item of the source is used as the seed.\n *\n * @example <caption>Count the number of click events</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var ones = clicks.mapTo(1);\n * var seed = 0;\n * var count = ones.scan((acc, one) => acc + one, seed);\n * count.subscribe(x => console.log(x));\n *\n * @see {@link expand}\n * @see {@link mergeScan}\n * @see {@link reduce}\n *\n * @param {function(acc: R, value: T, index: number): R} accumulator\n * The accumulator function called on each source value.\n * @param {T|R} [seed] The initial accumulation value.\n * @return {Observable<R>} An observable of the accumulated values.\n * @method scan\n * @owner Observable\n */\nfunction scan(accumulator, seed) {\n    if (arguments.length >= 2) {\n        return scan_1.scan(accumulator, seed)(this);\n    }\n    return scan_1.scan(accumulator)(this);\n}\nexports.scan = scan;\n//# sourceMappingURL=scan.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/operator/scan.js?");

/***/ }),

/***/ "./node_modules/rxjs/operator/share.js":
/*!*********************************************!*\
  !*** ./node_modules/rxjs/operator/share.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar share_1 = __webpack_require__(/*! ../operators/share */ \"./node_modules/rxjs/operators/share.js\");\n/**\n * Returns a new Observable that multicasts (shares) the original Observable. As long as there is at least one\n * Subscriber this Observable will be subscribed and emitting data. When all subscribers have unsubscribed it will\n * unsubscribe from the source Observable. Because the Observable is multicasting it makes the stream `hot`.\n *\n * This behaves similarly to .publish().refCount(), with a behavior difference when the source observable emits complete.\n * .publish().refCount() will not resubscribe to the original source, however .share() will resubscribe to the original source.\n * Observable.of(\"test\").publish().refCount() will not re-emit \"test\" on new subscriptions, Observable.of(\"test\").share() will\n * re-emit \"test\" to new subscriptions.\n *\n * <img src=\"./img/share.png\" width=\"100%\">\n *\n * @return {Observable<T>} An Observable that upon connection causes the source Observable to emit items to its Observers.\n * @method share\n * @owner Observable\n */\nfunction share() {\n    return share_1.share()(this);\n}\nexports.share = share;\n;\n//# sourceMappingURL=share.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/operator/share.js?");

/***/ }),

/***/ "./node_modules/rxjs/operator/skip.js":
/*!********************************************!*\
  !*** ./node_modules/rxjs/operator/skip.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar skip_1 = __webpack_require__(/*! ../operators/skip */ \"./node_modules/rxjs/operators/skip.js\");\n/**\n * Returns an Observable that skips the first `count` items emitted by the source Observable.\n *\n * <img src=\"./img/skip.png\" width=\"100%\">\n *\n * @param {Number} count - The number of times, items emitted by source Observable should be skipped.\n * @return {Observable} An Observable that skips values emitted by the source Observable.\n *\n * @method skip\n * @owner Observable\n */\nfunction skip(count) {\n    return skip_1.skip(count)(this);\n}\nexports.skip = skip;\n//# sourceMappingURL=skip.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/operator/skip.js?");

/***/ }),

/***/ "./node_modules/rxjs/operator/skipUntil.js":
/*!*************************************************!*\
  !*** ./node_modules/rxjs/operator/skipUntil.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar skipUntil_1 = __webpack_require__(/*! ../operators/skipUntil */ \"./node_modules/rxjs/operators/skipUntil.js\");\n/**\n * Returns an Observable that skips items emitted by the source Observable until a second Observable emits an item.\n *\n * <img src=\"./img/skipUntil.png\" width=\"100%\">\n *\n * @param {Observable} notifier - The second Observable that has to emit an item before the source Observable's elements begin to\n * be mirrored by the resulting Observable.\n * @return {Observable<T>} An Observable that skips items from the source Observable until the second Observable emits\n * an item, then emits the remaining items.\n * @method skipUntil\n * @owner Observable\n */\nfunction skipUntil(notifier) {\n    return skipUntil_1.skipUntil(notifier)(this);\n}\nexports.skipUntil = skipUntil;\n//# sourceMappingURL=skipUntil.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/operator/skipUntil.js?");

/***/ }),

/***/ "./node_modules/rxjs/operator/skipWhile.js":
/*!*************************************************!*\
  !*** ./node_modules/rxjs/operator/skipWhile.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar skipWhile_1 = __webpack_require__(/*! ../operators/skipWhile */ \"./node_modules/rxjs/operators/skipWhile.js\");\n/**\n * Returns an Observable that skips all items emitted by the source Observable as long as a specified condition holds\n * true, but emits all further source items as soon as the condition becomes false.\n *\n * <img src=\"./img/skipWhile.png\" width=\"100%\">\n *\n * @param {Function} predicate - A function to test each item emitted from the source Observable.\n * @return {Observable<T>} An Observable that begins emitting items emitted by the source Observable when the\n * specified predicate becomes false.\n * @method skipWhile\n * @owner Observable\n */\nfunction skipWhile(predicate) {\n    return skipWhile_1.skipWhile(predicate)(this);\n}\nexports.skipWhile = skipWhile;\n//# sourceMappingURL=skipWhile.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/operator/skipWhile.js?");

/***/ }),

/***/ "./node_modules/rxjs/operator/startWith.js":
/*!*************************************************!*\
  !*** ./node_modules/rxjs/operator/startWith.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar startWith_1 = __webpack_require__(/*! ../operators/startWith */ \"./node_modules/rxjs/operators/startWith.js\");\n/* tslint:enable:max-line-length */\n/**\n * Returns an Observable that emits the items you specify as arguments before it begins to emit\n * items emitted by the source Observable.\n *\n * <img src=\"./img/startWith.png\" width=\"100%\">\n *\n * @param {...T} values - Items you want the modified Observable to emit first.\n * @param {Scheduler} [scheduler] - A {@link IScheduler} to use for scheduling\n * the emissions of the `next` notifications.\n * @return {Observable} An Observable that emits the items in the specified Iterable and then emits the items\n * emitted by the source Observable.\n * @method startWith\n * @owner Observable\n */\nfunction startWith() {\n    var array = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        array[_i - 0] = arguments[_i];\n    }\n    return startWith_1.startWith.apply(void 0, array)(this);\n}\nexports.startWith = startWith;\n//# sourceMappingURL=startWith.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/operator/startWith.js?");

/***/ }),

/***/ "./node_modules/rxjs/operator/switchMap.js":
/*!*************************************************!*\
  !*** ./node_modules/rxjs/operator/switchMap.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar switchMap_1 = __webpack_require__(/*! ../operators/switchMap */ \"./node_modules/rxjs/operators/switchMap.js\");\n/* tslint:enable:max-line-length */\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable, emitting values only from the most recently projected Observable.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link switch}.</span>\n *\n * <img src=\"./img/switchMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. Each time it observes one of these\n * inner Observables, the output Observable begins emitting the items emitted by\n * that inner Observable. When a new inner Observable is emitted, `switchMap`\n * stops emitting items from the earlier-emitted inner Observable and begins\n * emitting items from the new one. It continues to behave like this for\n * subsequent inner Observables.\n *\n * @example <caption>Rerun an interval Observable on every click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.switchMap((ev) => Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMap}\n * @see {@link exhaustMap}\n * @see {@link mergeMap}\n * @see {@link switch}\n * @see {@link switchMapTo}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An Observable that emits the result of applying the\n * projection function (and the optional `resultSelector`) to each item emitted\n * by the source Observable and taking only the values from the most recently\n * projected inner Observable.\n * @method switchMap\n * @owner Observable\n */\nfunction switchMap(project, resultSelector) {\n    return switchMap_1.switchMap(project, resultSelector)(this);\n}\nexports.switchMap = switchMap;\n//# sourceMappingURL=switchMap.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/operator/switchMap.js?");

/***/ }),

/***/ "./node_modules/rxjs/operator/switchMapTo.js":
/*!***************************************************!*\
  !*** ./node_modules/rxjs/operator/switchMapTo.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar switchMapTo_1 = __webpack_require__(/*! ../operators/switchMapTo */ \"./node_modules/rxjs/operators/switchMapTo.js\");\n/* tslint:enable:max-line-length */\n/**\n * Projects each source value to the same Observable which is flattened multiple\n * times with {@link switch} in the output Observable.\n *\n * <span class=\"informal\">It's like {@link switchMap}, but maps each value\n * always to the same inner Observable.</span>\n *\n * <img src=\"./img/switchMapTo.png\" width=\"100%\">\n *\n * Maps each source value to the given Observable `innerObservable` regardless\n * of the source value, and then flattens those resulting Observables into one\n * single Observable, which is the output Observable. The output Observables\n * emits values only from the most recently emitted instance of\n * `innerObservable`.\n *\n * @example <caption>Rerun an interval Observable on every click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.switchMapTo(Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMapTo}\n * @see {@link switch}\n * @see {@link switchMap}\n * @see {@link mergeMapTo}\n *\n * @param {ObservableInput} innerObservable An Observable to replace each value from\n * the source Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An Observable that emits items from the given\n * `innerObservable` (and optionally transformed through `resultSelector`) every\n * time a value is emitted on the source Observable, and taking only the values\n * from the most recently projected inner Observable.\n * @method switchMapTo\n * @owner Observable\n */\nfunction switchMapTo(innerObservable, resultSelector) {\n    return switchMapTo_1.switchMapTo(innerObservable, resultSelector)(this);\n}\nexports.switchMapTo = switchMapTo;\n//# sourceMappingURL=switchMapTo.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/operator/switchMapTo.js?");

/***/ }),

/***/ "./node_modules/rxjs/operator/take.js":
/*!********************************************!*\
  !*** ./node_modules/rxjs/operator/take.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar take_1 = __webpack_require__(/*! ../operators/take */ \"./node_modules/rxjs/operators/take.js\");\n/**\n * Emits only the first `count` values emitted by the source Observable.\n *\n * <span class=\"informal\">Takes the first `count` values from the source, then\n * completes.</span>\n *\n * <img src=\"./img/take.png\" width=\"100%\">\n *\n * `take` returns an Observable that emits only the first `count` values emitted\n * by the source Observable. If the source emits fewer than `count` values then\n * all of its values are emitted. After that, it completes, regardless if the\n * source completes.\n *\n * @example <caption>Take the first 5 seconds of an infinite 1-second interval Observable</caption>\n * var interval = Rx.Observable.interval(1000);\n * var five = interval.take(5);\n * five.subscribe(x => console.log(x));\n *\n * @see {@link takeLast}\n * @see {@link takeUntil}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @throws {ArgumentOutOfRangeError} When using `take(i)`, it delivers an\n * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.\n *\n * @param {number} count The maximum number of `next` values to emit.\n * @return {Observable<T>} An Observable that emits only the first `count`\n * values emitted by the source Observable, or all of the values from the source\n * if the source emits fewer than `count` values.\n * @method take\n * @owner Observable\n */\nfunction take(count) {\n    return take_1.take(count)(this);\n}\nexports.take = take;\n//# sourceMappingURL=take.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/operator/take.js?");

/***/ }),

/***/ "./node_modules/rxjs/operator/takeUntil.js":
/*!*************************************************!*\
  !*** ./node_modules/rxjs/operator/takeUntil.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar takeUntil_1 = __webpack_require__(/*! ../operators/takeUntil */ \"./node_modules/rxjs/operators/takeUntil.js\");\n/**\n * Emits the values emitted by the source Observable until a `notifier`\n * Observable emits a value.\n *\n * <span class=\"informal\">Lets values pass until a second Observable,\n * `notifier`, emits something. Then, it completes.</span>\n *\n * <img src=\"./img/takeUntil.png\" width=\"100%\">\n *\n * `takeUntil` subscribes and begins mirroring the source Observable. It also\n * monitors a second Observable, `notifier` that you provide. If the `notifier`\n * emits a value, the output Observable stops mirroring the source Observable\n * and completes.\n *\n * @example <caption>Tick every second until the first click happens</caption>\n * var interval = Rx.Observable.interval(1000);\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = interval.takeUntil(clicks);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link take}\n * @see {@link takeLast}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @param {Observable} notifier The Observable whose first emitted value will\n * cause the output Observable of `takeUntil` to stop emitting values from the\n * source Observable.\n * @return {Observable<T>} An Observable that emits the values from the source\n * Observable until such time as `notifier` emits its first value.\n * @method takeUntil\n * @owner Observable\n */\nfunction takeUntil(notifier) {\n    return takeUntil_1.takeUntil(notifier)(this);\n}\nexports.takeUntil = takeUntil;\n//# sourceMappingURL=takeUntil.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/operator/takeUntil.js?");

/***/ }),

/***/ "./node_modules/rxjs/operator/timeout.js":
/*!***********************************************!*\
  !*** ./node_modules/rxjs/operator/timeout.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar async_1 = __webpack_require__(/*! ../scheduler/async */ \"./node_modules/rxjs/scheduler/async.js\");\nvar timeout_1 = __webpack_require__(/*! ../operators/timeout */ \"./node_modules/rxjs/operators/timeout.js\");\n/**\n *\n * Errors if Observable does not emit a value in given time span.\n *\n * <span class=\"informal\">Timeouts on Observable that doesn't emit values fast enough.</span>\n *\n * <img src=\"./img/timeout.png\" width=\"100%\">\n *\n * `timeout` operator accepts as an argument either a number or a Date.\n *\n * If number was provided, it returns an Observable that behaves like a source\n * Observable, unless there is a period of time where there is no value emitted.\n * So if you provide `100` as argument and first value comes after 50ms from\n * the moment of subscription, this value will be simply re-emitted by the resulting\n * Observable. If however after that 100ms passes without a second value being emitted,\n * stream will end with an error and source Observable will be unsubscribed.\n * These checks are performed throughout whole lifecycle of Observable - from the moment\n * it was subscribed to, until it completes or errors itself. Thus every value must be\n * emitted within specified period since previous value.\n *\n * If provided argument was Date, returned Observable behaves differently. It throws\n * if Observable did not complete before provided Date. This means that periods between\n * emission of particular values do not matter in this case. If Observable did not complete\n * before provided Date, source Observable will be unsubscribed. Other than that, resulting\n * stream behaves just as source Observable.\n *\n * `timeout` accepts also a Scheduler as a second parameter. It is used to schedule moment (or moments)\n * when returned Observable will check if source stream emitted value or completed.\n *\n * @example <caption>Check if ticks are emitted within certain timespan</caption>\n * const seconds = Rx.Observable.interval(1000);\n *\n * seconds.timeout(1100) // Let's use bigger timespan to be safe,\n *                       // since `interval` might fire a bit later then scheduled.\n * .subscribe(\n *     value => console.log(value), // Will emit numbers just as regular `interval` would.\n *     err => console.log(err) // Will never be called.\n * );\n *\n * seconds.timeout(900).subscribe(\n *     value => console.log(value), // Will never be called.\n *     err => console.log(err) // Will emit error before even first value is emitted,\n *                             // since it did not arrive within 900ms period.\n * );\n *\n * @example <caption>Use Date to check if Observable completed</caption>\n * const seconds = Rx.Observable.interval(1000);\n *\n * seconds.timeout(new Date(\"December 17, 2020 03:24:00\"))\n * .subscribe(\n *     value => console.log(value), // Will emit values as regular `interval` would\n *                                  // until December 17, 2020 at 03:24:00.\n *     err => console.log(err) // On December 17, 2020 at 03:24:00 it will emit an error,\n *                             // since Observable did not complete by then.\n * );\n *\n * @see {@link timeoutWith}\n *\n * @param {number|Date} due Number specifying period within which Observable must emit values\n *                          or Date specifying before when Observable should complete\n * @param {Scheduler} [scheduler] Scheduler controlling when timeout checks occur.\n * @return {Observable<T>} Observable that mirrors behaviour of source, unless timeout checks fail.\n * @method timeout\n * @owner Observable\n */\nfunction timeout(due, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    return timeout_1.timeout(due, scheduler)(this);\n}\nexports.timeout = timeout;\n//# sourceMappingURL=timeout.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/operator/timeout.js?");

/***/ }),

/***/ "./node_modules/rxjs/operator/withLatestFrom.js":
/*!******************************************************!*\
  !*** ./node_modules/rxjs/operator/withLatestFrom.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar withLatestFrom_1 = __webpack_require__(/*! ../operators/withLatestFrom */ \"./node_modules/rxjs/operators/withLatestFrom.js\");\n/* tslint:enable:max-line-length */\n/**\n * Combines the source Observable with other Observables to create an Observable\n * whose values are calculated from the latest values of each, only when the\n * source emits.\n *\n * <span class=\"informal\">Whenever the source Observable emits a value, it\n * computes a formula using that value plus the latest values from other input\n * Observables, then emits the output of that formula.</span>\n *\n * <img src=\"./img/withLatestFrom.png\" width=\"100%\">\n *\n * `withLatestFrom` combines each value from the source Observable (the\n * instance) with the latest values from the other input Observables only when\n * the source emits a value, optionally using a `project` function to determine\n * the value to be emitted on the output Observable. All input Observables must\n * emit at least one value before the output Observable will emit a value.\n *\n * @example <caption>On every click event, emit an array with the latest timer event plus the click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var timer = Rx.Observable.interval(1000);\n * var result = clicks.withLatestFrom(timer);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link combineLatest}\n *\n * @param {ObservableInput} other An input Observable to combine with the source\n * Observable. More than one input Observables may be given as argument.\n * @param {Function} [project] Projection function for combining values\n * together. Receives all values in order of the Observables passed, where the\n * first parameter is a value from the source Observable. (e.g.\n * `a.withLatestFrom(b, c, (a1, b1, c1) => a1 + b1 + c1)`). If this is not\n * passed, arrays will be emitted on the output Observable.\n * @return {Observable} An Observable of projected values from the most recent\n * values from each input Observable, or an array of the most recent values from\n * each input Observable.\n * @method withLatestFrom\n * @owner Observable\n */\nfunction withLatestFrom() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i - 0] = arguments[_i];\n    }\n    return withLatestFrom_1.withLatestFrom.apply(void 0, args)(this);\n}\nexports.withLatestFrom = withLatestFrom;\n//# sourceMappingURL=withLatestFrom.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/operator/withLatestFrom.js?");

/***/ }),

/***/ "./node_modules/rxjs/operators/catchError.js":
/*!***************************************************!*\
  !*** ./node_modules/rxjs/operators/catchError.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = __webpack_require__(/*! ../OuterSubscriber */ \"./node_modules/rxjs/OuterSubscriber.js\");\nvar subscribeToResult_1 = __webpack_require__(/*! ../util/subscribeToResult */ \"./node_modules/rxjs/util/subscribeToResult.js\");\n/**\n * Catches errors on the observable to be handled by returning a new observable or throwing an error.\n *\n * <img src=\"./img/catch.png\" width=\"100%\">\n *\n * @example <caption>Continues with a different Observable when there's an error</caption>\n *\n * Observable.of(1, 2, 3, 4, 5)\n *   .map(n => {\n * \t   if (n == 4) {\n * \t     throw 'four!';\n *     }\n *\t   return n;\n *   })\n *   .catch(err => Observable.of('I', 'II', 'III', 'IV', 'V'))\n *   .subscribe(x => console.log(x));\n *   // 1, 2, 3, I, II, III, IV, V\n *\n * @example <caption>Retries the caught source Observable again in case of error, similar to retry() operator</caption>\n *\n * Observable.of(1, 2, 3, 4, 5)\n *   .map(n => {\n * \t   if (n === 4) {\n * \t     throw 'four!';\n *     }\n * \t   return n;\n *   })\n *   .catch((err, caught) => caught)\n *   .take(30)\n *   .subscribe(x => console.log(x));\n *   // 1, 2, 3, 1, 2, 3, ...\n *\n * @example <caption>Throws a new error when the source Observable throws an error</caption>\n *\n * Observable.of(1, 2, 3, 4, 5)\n *   .map(n => {\n *     if (n == 4) {\n *       throw 'four!';\n *     }\n *     return n;\n *   })\n *   .catch(err => {\n *     throw 'error in source. Details: ' + err;\n *   })\n *   .subscribe(\n *     x => console.log(x),\n *     err => console.log(err)\n *   );\n *   // 1, 2, 3, error in source. Details: four!\n *\n * @param {function} selector a function that takes as arguments `err`, which is the error, and `caught`, which\n *  is the source observable, in case you'd like to \"retry\" that observable by returning it again. Whatever observable\n *  is returned by the `selector` will be used to continue the observable chain.\n * @return {Observable} An observable that originates from either the source or the observable returned by the\n *  catch `selector` function.\n * @name catchError\n */\nfunction catchError(selector) {\n    return function catchErrorOperatorFunction(source) {\n        var operator = new CatchOperator(selector);\n        var caught = source.lift(operator);\n        return (operator.caught = caught);\n    };\n}\nexports.catchError = catchError;\nvar CatchOperator = (function () {\n    function CatchOperator(selector) {\n        this.selector = selector;\n    }\n    CatchOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));\n    };\n    return CatchOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar CatchSubscriber = (function (_super) {\n    __extends(CatchSubscriber, _super);\n    function CatchSubscriber(destination, selector, caught) {\n        _super.call(this, destination);\n        this.selector = selector;\n        this.caught = caught;\n    }\n    // NOTE: overriding `error` instead of `_error` because we don't want\n    // to have this flag this subscriber as `isStopped`. We can mimic the\n    // behavior of the RetrySubscriber (from the `retry` operator), where\n    // we unsubscribe from our source chain, reset our Subscriber flags,\n    // then subscribe to the selector result.\n    CatchSubscriber.prototype.error = function (err) {\n        if (!this.isStopped) {\n            var result = void 0;\n            try {\n                result = this.selector(err, this.caught);\n            }\n            catch (err2) {\n                _super.prototype.error.call(this, err2);\n                return;\n            }\n            this._unsubscribeAndRecycle();\n            this.add(subscribeToResult_1.subscribeToResult(this, result));\n        }\n    };\n    return CatchSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=catchError.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/operators/catchError.js?");

/***/ }),

/***/ "./node_modules/rxjs/operators/combineLatest.js":
/*!******************************************************!*\
  !*** ./node_modules/rxjs/operators/combineLatest.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar ArrayObservable_1 = __webpack_require__(/*! ../observable/ArrayObservable */ \"./node_modules/rxjs/observable/ArrayObservable.js\");\nvar isArray_1 = __webpack_require__(/*! ../util/isArray */ \"./node_modules/rxjs/util/isArray.js\");\nvar OuterSubscriber_1 = __webpack_require__(/*! ../OuterSubscriber */ \"./node_modules/rxjs/OuterSubscriber.js\");\nvar subscribeToResult_1 = __webpack_require__(/*! ../util/subscribeToResult */ \"./node_modules/rxjs/util/subscribeToResult.js\");\nvar none = {};\n/* tslint:enable:max-line-length */\n/**\n * Combines multiple Observables to create an Observable whose values are\n * calculated from the latest values of each of its input Observables.\n *\n * <span class=\"informal\">Whenever any input Observable emits a value, it\n * computes a formula using the latest values from all the inputs, then emits\n * the output of that formula.</span>\n *\n * <img src=\"./img/combineLatest.png\" width=\"100%\">\n *\n * `combineLatest` combines the values from this Observable with values from\n * Observables passed as arguments. This is done by subscribing to each\n * Observable, in order, and collecting an array of each of the most recent\n * values any time any of the input Observables emits, then either taking that\n * array and passing it as arguments to an optional `project` function and\n * emitting the return value of that, or just emitting the array of recent\n * values directly if there is no `project` function.\n *\n * @example <caption>Dynamically calculate the Body-Mass Index from an Observable of weight and one for height</caption>\n * var weight = Rx.Observable.of(70, 72, 76, 79, 75);\n * var height = Rx.Observable.of(1.76, 1.77, 1.78);\n * var bmi = weight.combineLatest(height, (w, h) => w / (h * h));\n * bmi.subscribe(x => console.log('BMI is ' + x));\n *\n * // With output to console:\n * // BMI is 24.212293388429753\n * // BMI is 23.93948099205209\n * // BMI is 23.671253629592222\n *\n * @see {@link combineAll}\n * @see {@link merge}\n * @see {@link withLatestFrom}\n *\n * @param {ObservableInput} other An input Observable to combine with the source\n * Observable. More than one input Observables may be given as argument.\n * @param {function} [project] An optional function to project the values from\n * the combined latest values into a new value on the output Observable.\n * @return {Observable} An Observable of projected values from the most recent\n * values from each input Observable, or an array of the most recent values from\n * each input Observable.\n * @method combineLatest\n * @owner Observable\n */\nfunction combineLatest() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    var project = null;\n    if (typeof observables[observables.length - 1] === 'function') {\n        project = observables.pop();\n    }\n    // if the first and only other argument besides the resultSelector is an array\n    // assume it's been called with `combineLatest([obs1, obs2, obs3], project)`\n    if (observables.length === 1 && isArray_1.isArray(observables[0])) {\n        observables = observables[0].slice();\n    }\n    return function (source) { return source.lift.call(new ArrayObservable_1.ArrayObservable([source].concat(observables)), new CombineLatestOperator(project)); };\n}\nexports.combineLatest = combineLatest;\nvar CombineLatestOperator = (function () {\n    function CombineLatestOperator(project) {\n        this.project = project;\n    }\n    CombineLatestOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new CombineLatestSubscriber(subscriber, this.project));\n    };\n    return CombineLatestOperator;\n}());\nexports.CombineLatestOperator = CombineLatestOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar CombineLatestSubscriber = (function (_super) {\n    __extends(CombineLatestSubscriber, _super);\n    function CombineLatestSubscriber(destination, project) {\n        _super.call(this, destination);\n        this.project = project;\n        this.active = 0;\n        this.values = [];\n        this.observables = [];\n    }\n    CombineLatestSubscriber.prototype._next = function (observable) {\n        this.values.push(none);\n        this.observables.push(observable);\n    };\n    CombineLatestSubscriber.prototype._complete = function () {\n        var observables = this.observables;\n        var len = observables.length;\n        if (len === 0) {\n            this.destination.complete();\n        }\n        else {\n            this.active = len;\n            this.toRespond = len;\n            for (var i = 0; i < len; i++) {\n                var observable = observables[i];\n                this.add(subscribeToResult_1.subscribeToResult(this, observable, observable, i));\n            }\n        }\n    };\n    CombineLatestSubscriber.prototype.notifyComplete = function (unused) {\n        if ((this.active -= 1) === 0) {\n            this.destination.complete();\n        }\n    };\n    CombineLatestSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        var values = this.values;\n        var oldVal = values[outerIndex];\n        var toRespond = !this.toRespond\n            ? 0\n            : oldVal === none ? --this.toRespond : this.toRespond;\n        values[outerIndex] = innerValue;\n        if (toRespond === 0) {\n            if (this.project) {\n                this._tryProject(values);\n            }\n            else {\n                this.destination.next(values.slice());\n            }\n        }\n    };\n    CombineLatestSubscriber.prototype._tryProject = function (values) {\n        var result;\n        try {\n            result = this.project.apply(this, values);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.next(result);\n    };\n    return CombineLatestSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\nexports.CombineLatestSubscriber = CombineLatestSubscriber;\n//# sourceMappingURL=combineLatest.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/operators/combineLatest.js?");

/***/ }),

/***/ "./node_modules/rxjs/operators/concat.js":
/*!***********************************************!*\
  !*** ./node_modules/rxjs/operators/concat.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar concat_1 = __webpack_require__(/*! ../observable/concat */ \"./node_modules/rxjs/observable/concat.js\");\nvar concat_2 = __webpack_require__(/*! ../observable/concat */ \"./node_modules/rxjs/observable/concat.js\");\nexports.concatStatic = concat_2.concat;\n/* tslint:enable:max-line-length */\n/**\n * Creates an output Observable which sequentially emits all values from every\n * given input Observable after the current Observable.\n *\n * <span class=\"informal\">Concatenates multiple Observables together by\n * sequentially emitting their values, one Observable after the other.</span>\n *\n * <img src=\"./img/concat.png\" width=\"100%\">\n *\n * Joins this Observable with multiple other Observables by subscribing to them\n * one at a time, starting with the source, and merging their results into the\n * output Observable. Will wait for each Observable to complete before moving\n * on to the next.\n *\n * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>\n * var timer = Rx.Observable.interval(1000).take(4);\n * var sequence = Rx.Observable.range(1, 10);\n * var result = timer.concat(sequence);\n * result.subscribe(x => console.log(x));\n *\n * // results in:\n * // 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10\n *\n * @example <caption>Concatenate 3 Observables</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var result = timer1.concat(timer2, timer3);\n * result.subscribe(x => console.log(x));\n *\n * // results in the following:\n * // (Prints to console sequentially)\n * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9\n * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5\n * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9\n *\n * @see {@link concatAll}\n * @see {@link concatMap}\n * @see {@link concatMapTo}\n *\n * @param {ObservableInput} other An input Observable to concatenate after the source\n * Observable. More than one input Observables may be given as argument.\n * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each\n * Observable subscription on.\n * @return {Observable} All values of each passed Observable merged into a\n * single Observable, in order, in serial fashion.\n * @method concat\n * @owner Observable\n */\nfunction concat() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    return function (source) { return source.lift.call(concat_1.concat.apply(void 0, [source].concat(observables))); };\n}\nexports.concat = concat;\n//# sourceMappingURL=concat.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/operators/concat.js?");

/***/ }),

/***/ "./node_modules/rxjs/operators/concatAll.js":
/*!**************************************************!*\
  !*** ./node_modules/rxjs/operators/concatAll.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar mergeAll_1 = __webpack_require__(/*! ./mergeAll */ \"./node_modules/rxjs/operators/mergeAll.js\");\n/**\n * Converts a higher-order Observable into a first-order Observable by\n * concatenating the inner Observables in order.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables by putting one\n * inner Observable after the other.</span>\n *\n * <img src=\"./img/concatAll.png\" width=\"100%\">\n *\n * Joins every Observable emitted by the source (a higher-order Observable), in\n * a serial fashion. It subscribes to each inner Observable only after the\n * previous inner Observable has completed, and merges all of their values into\n * the returned observable.\n *\n * __Warning:__ If the source Observable emits Observables quickly and\n * endlessly, and the inner Observables it emits generally complete slower than\n * the source emits, you can run into memory issues as the incoming Observables\n * collect in an unbounded buffer.\n *\n * Note: `concatAll` is equivalent to `mergeAll` with concurrency parameter set\n * to `1`.\n *\n * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var higherOrder = clicks.map(ev => Rx.Observable.interval(1000).take(4));\n * var firstOrder = higherOrder.concatAll();\n * firstOrder.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // (results are not concurrent)\n * // For every click on the \"document\" it will emit values 0 to 3 spaced\n * // on a 1000ms interval\n * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3\n *\n * @see {@link combineAll}\n * @see {@link concat}\n * @see {@link concatMap}\n * @see {@link concatMapTo}\n * @see {@link exhaust}\n * @see {@link mergeAll}\n * @see {@link switch}\n * @see {@link zipAll}\n *\n * @return {Observable} An Observable emitting values from all the inner\n * Observables concatenated.\n * @method concatAll\n * @owner Observable\n */\nfunction concatAll() {\n    return mergeAll_1.mergeAll(1);\n}\nexports.concatAll = concatAll;\n//# sourceMappingURL=concatAll.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/operators/concatAll.js?");

/***/ }),

/***/ "./node_modules/rxjs/operators/concatMap.js":
/*!**************************************************!*\
  !*** ./node_modules/rxjs/operators/concatMap.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar mergeMap_1 = __webpack_require__(/*! ./mergeMap */ \"./node_modules/rxjs/operators/mergeMap.js\");\n/* tslint:enable:max-line-length */\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable, in a serialized fashion waiting for each one to complete before\n * merging the next.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link concatAll}.</span>\n *\n * <img src=\"./img/concatMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. Each new inner Observable is\n * concatenated with the previous inner Observable.\n *\n * __Warning:__ if source values arrive endlessly and faster than their\n * corresponding inner Observables can complete, it will result in memory issues\n * as inner Observables amass in an unbounded buffer waiting for their turn to\n * be subscribed to.\n *\n * Note: `concatMap` is equivalent to `mergeMap` with concurrency parameter set\n * to `1`.\n *\n * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.concatMap(ev => Rx.Observable.interval(1000).take(4));\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // (results are not concurrent)\n * // For every click on the \"document\" it will emit values 0 to 3 spaced\n * // on a 1000ms interval\n * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3\n *\n * @see {@link concat}\n * @see {@link concatAll}\n * @see {@link concatMapTo}\n * @see {@link exhaustMap}\n * @see {@link mergeMap}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An Observable that emits the result of applying the\n * projection function (and the optional `resultSelector`) to each item emitted\n * by the source Observable and taking values from each projected inner\n * Observable sequentially.\n * @method concatMap\n * @owner Observable\n */\nfunction concatMap(project, resultSelector) {\n    return mergeMap_1.mergeMap(project, resultSelector, 1);\n}\nexports.concatMap = concatMap;\n//# sourceMappingURL=concatMap.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/operators/concatMap.js?");

/***/ }),

/***/ "./node_modules/rxjs/operators/debounceTime.js":
/*!*****************************************************!*\
  !*** ./node_modules/rxjs/operators/debounceTime.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(/*! ../Subscriber */ \"./node_modules/rxjs/Subscriber.js\");\nvar async_1 = __webpack_require__(/*! ../scheduler/async */ \"./node_modules/rxjs/scheduler/async.js\");\n/**\n * Emits a value from the source Observable only after a particular time span\n * has passed without another source emission.\n *\n * <span class=\"informal\">It's like {@link delay}, but passes only the most\n * recent value from each burst of emissions.</span>\n *\n * <img src=\"./img/debounceTime.png\" width=\"100%\">\n *\n * `debounceTime` delays values emitted by the source Observable, but drops\n * previous pending delayed emissions if a new value arrives on the source\n * Observable. This operator keeps track of the most recent value from the\n * source Observable, and emits that only when `dueTime` enough time has passed\n * without any other value appearing on the source Observable. If a new value\n * appears before `dueTime` silence occurs, the previous value will be dropped\n * and will not be emitted on the output Observable.\n *\n * This is a rate-limiting operator, because it is impossible for more than one\n * value to be emitted in any time window of duration `dueTime`, but it is also\n * a delay-like operator since output emissions do not occur at the same time as\n * they did on the source Observable. Optionally takes a {@link IScheduler} for\n * managing timers.\n *\n * @example <caption>Emit the most recent click after a burst of clicks</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.debounceTime(1000);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link auditTime}\n * @see {@link debounce}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttleTime}\n *\n * @param {number} dueTime The timeout duration in milliseconds (or the time\n * unit determined internally by the optional `scheduler`) for the window of\n * time required to wait for emission silence before emitting the most recent\n * source value.\n * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n * managing the timers that handle the timeout for each value.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by the specified `dueTime`, and may drop some values if they occur\n * too frequently.\n * @method debounceTime\n * @owner Observable\n */\nfunction debounceTime(dueTime, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    return function (source) { return source.lift(new DebounceTimeOperator(dueTime, scheduler)); };\n}\nexports.debounceTime = debounceTime;\nvar DebounceTimeOperator = (function () {\n    function DebounceTimeOperator(dueTime, scheduler) {\n        this.dueTime = dueTime;\n        this.scheduler = scheduler;\n    }\n    DebounceTimeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));\n    };\n    return DebounceTimeOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DebounceTimeSubscriber = (function (_super) {\n    __extends(DebounceTimeSubscriber, _super);\n    function DebounceTimeSubscriber(destination, dueTime, scheduler) {\n        _super.call(this, destination);\n        this.dueTime = dueTime;\n        this.scheduler = scheduler;\n        this.debouncedSubscription = null;\n        this.lastValue = null;\n        this.hasValue = false;\n    }\n    DebounceTimeSubscriber.prototype._next = function (value) {\n        this.clearDebounce();\n        this.lastValue = value;\n        this.hasValue = true;\n        this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));\n    };\n    DebounceTimeSubscriber.prototype._complete = function () {\n        this.debouncedNext();\n        this.destination.complete();\n    };\n    DebounceTimeSubscriber.prototype.debouncedNext = function () {\n        this.clearDebounce();\n        if (this.hasValue) {\n            this.destination.next(this.lastValue);\n            this.lastValue = null;\n            this.hasValue = false;\n        }\n    };\n    DebounceTimeSubscriber.prototype.clearDebounce = function () {\n        var debouncedSubscription = this.debouncedSubscription;\n        if (debouncedSubscription !== null) {\n            this.remove(debouncedSubscription);\n            debouncedSubscription.unsubscribe();\n            this.debouncedSubscription = null;\n        }\n    };\n    return DebounceTimeSubscriber;\n}(Subscriber_1.Subscriber));\nfunction dispatchNext(subscriber) {\n    subscriber.debouncedNext();\n}\n//# sourceMappingURL=debounceTime.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/operators/debounceTime.js?");

/***/ }),

/***/ "./node_modules/rxjs/operators/distinctUntilChanged.js":
/*!*************************************************************!*\
  !*** ./node_modules/rxjs/operators/distinctUntilChanged.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(/*! ../Subscriber */ \"./node_modules/rxjs/Subscriber.js\");\nvar tryCatch_1 = __webpack_require__(/*! ../util/tryCatch */ \"./node_modules/rxjs/util/tryCatch.js\");\nvar errorObject_1 = __webpack_require__(/*! ../util/errorObject */ \"./node_modules/rxjs/util/errorObject.js\");\n/* tslint:enable:max-line-length */\n/**\n * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item.\n *\n * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.\n *\n * If a comparator function is not provided, an equality check is used by default.\n *\n * @example <caption>A simple example with numbers</caption>\n * Observable.of(1, 1, 2, 2, 2, 1, 1, 2, 3, 3, 4)\n *   .distinctUntilChanged()\n *   .subscribe(x => console.log(x)); // 1, 2, 1, 2, 3, 4\n *\n * @example <caption>An example using a compare function</caption>\n * interface Person {\n *    age: number,\n *    name: string\n * }\n *\n * Observable.of<Person>(\n *     { age: 4, name: 'Foo'},\n *     { age: 7, name: 'Bar'},\n *     { age: 5, name: 'Foo'})\n *     { age: 6, name: 'Foo'})\n *     .distinctUntilChanged((p: Person, q: Person) => p.name === q.name)\n *     .subscribe(x => console.log(x));\n *\n * // displays:\n * // { age: 4, name: 'Foo' }\n * // { age: 7, name: 'Bar' }\n * // { age: 5, name: 'Foo' }\n *\n * @see {@link distinct}\n * @see {@link distinctUntilKeyChanged}\n *\n * @param {function} [compare] Optional comparison function called to test if an item is distinct from the previous item in the source.\n * @return {Observable} An Observable that emits items from the source Observable with distinct values.\n * @method distinctUntilChanged\n * @owner Observable\n */\nfunction distinctUntilChanged(compare, keySelector) {\n    return function (source) { return source.lift(new DistinctUntilChangedOperator(compare, keySelector)); };\n}\nexports.distinctUntilChanged = distinctUntilChanged;\nvar DistinctUntilChangedOperator = (function () {\n    function DistinctUntilChangedOperator(compare, keySelector) {\n        this.compare = compare;\n        this.keySelector = keySelector;\n    }\n    DistinctUntilChangedOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));\n    };\n    return DistinctUntilChangedOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DistinctUntilChangedSubscriber = (function (_super) {\n    __extends(DistinctUntilChangedSubscriber, _super);\n    function DistinctUntilChangedSubscriber(destination, compare, keySelector) {\n        _super.call(this, destination);\n        this.keySelector = keySelector;\n        this.hasKey = false;\n        if (typeof compare === 'function') {\n            this.compare = compare;\n        }\n    }\n    DistinctUntilChangedSubscriber.prototype.compare = function (x, y) {\n        return x === y;\n    };\n    DistinctUntilChangedSubscriber.prototype._next = function (value) {\n        var keySelector = this.keySelector;\n        var key = value;\n        if (keySelector) {\n            key = tryCatch_1.tryCatch(this.keySelector)(value);\n            if (key === errorObject_1.errorObject) {\n                return this.destination.error(errorObject_1.errorObject.e);\n            }\n        }\n        var result = false;\n        if (this.hasKey) {\n            result = tryCatch_1.tryCatch(this.compare)(this.key, key);\n            if (result === errorObject_1.errorObject) {\n                return this.destination.error(errorObject_1.errorObject.e);\n            }\n        }\n        else {\n            this.hasKey = true;\n        }\n        if (Boolean(result) === false) {\n            this.key = key;\n            this.destination.next(value);\n        }\n    };\n    return DistinctUntilChangedSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=distinctUntilChanged.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/operators/distinctUntilChanged.js?");

/***/ }),

/***/ "./node_modules/rxjs/operators/exhaustMap.js":
/*!***************************************************!*\
  !*** ./node_modules/rxjs/operators/exhaustMap.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = __webpack_require__(/*! ../OuterSubscriber */ \"./node_modules/rxjs/OuterSubscriber.js\");\nvar subscribeToResult_1 = __webpack_require__(/*! ../util/subscribeToResult */ \"./node_modules/rxjs/util/subscribeToResult.js\");\n/* tslint:enable:max-line-length */\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable only if the previous projected Observable has completed.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link exhaust}.</span>\n *\n * <img src=\"./img/exhaustMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. When it projects a source value to\n * an Observable, the output Observable begins emitting the items emitted by\n * that projected Observable. However, `exhaustMap` ignores every new projected\n * Observable if the previous projected Observable has not yet completed. Once\n * that one completes, it will accept and flatten the next projected Observable\n * and repeat this process.\n *\n * @example <caption>Run a finite timer for each click, only if there is no currently active timer</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.exhaustMap((ev) => Rx.Observable.interval(1000).take(5));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMap}\n * @see {@link exhaust}\n * @see {@link mergeMap}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An Observable containing projected Observables\n * of each item of the source, ignoring projected Observables that start before\n * their preceding Observable has completed.\n * @method exhaustMap\n * @owner Observable\n */\nfunction exhaustMap(project, resultSelector) {\n    return function (source) { return source.lift(new SwitchFirstMapOperator(project, resultSelector)); };\n}\nexports.exhaustMap = exhaustMap;\nvar SwitchFirstMapOperator = (function () {\n    function SwitchFirstMapOperator(project, resultSelector) {\n        this.project = project;\n        this.resultSelector = resultSelector;\n    }\n    SwitchFirstMapOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SwitchFirstMapSubscriber(subscriber, this.project, this.resultSelector));\n    };\n    return SwitchFirstMapOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SwitchFirstMapSubscriber = (function (_super) {\n    __extends(SwitchFirstMapSubscriber, _super);\n    function SwitchFirstMapSubscriber(destination, project, resultSelector) {\n        _super.call(this, destination);\n        this.project = project;\n        this.resultSelector = resultSelector;\n        this.hasSubscription = false;\n        this.hasCompleted = false;\n        this.index = 0;\n    }\n    SwitchFirstMapSubscriber.prototype._next = function (value) {\n        if (!this.hasSubscription) {\n            this.tryNext(value);\n        }\n    };\n    SwitchFirstMapSubscriber.prototype.tryNext = function (value) {\n        var index = this.index++;\n        var destination = this.destination;\n        try {\n            var result = this.project(value, index);\n            this.hasSubscription = true;\n            this.add(subscribeToResult_1.subscribeToResult(this, result, value, index));\n        }\n        catch (err) {\n            destination.error(err);\n        }\n    };\n    SwitchFirstMapSubscriber.prototype._complete = function () {\n        this.hasCompleted = true;\n        if (!this.hasSubscription) {\n            this.destination.complete();\n        }\n    };\n    SwitchFirstMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;\n        if (resultSelector) {\n            this.trySelectResult(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        else {\n            destination.next(innerValue);\n        }\n    };\n    SwitchFirstMapSubscriber.prototype.trySelectResult = function (outerValue, innerValue, outerIndex, innerIndex) {\n        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;\n        try {\n            var result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n            destination.next(result);\n        }\n        catch (err) {\n            destination.error(err);\n        }\n    };\n    SwitchFirstMapSubscriber.prototype.notifyError = function (err) {\n        this.destination.error(err);\n    };\n    SwitchFirstMapSubscriber.prototype.notifyComplete = function (innerSub) {\n        this.remove(innerSub);\n        this.hasSubscription = false;\n        if (this.hasCompleted) {\n            this.destination.complete();\n        }\n    };\n    return SwitchFirstMapSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=exhaustMap.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/operators/exhaustMap.js?");

/***/ }),

/***/ "./node_modules/rxjs/operators/filter.js":
/*!***********************************************!*\
  !*** ./node_modules/rxjs/operators/filter.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(/*! ../Subscriber */ \"./node_modules/rxjs/Subscriber.js\");\n/* tslint:enable:max-line-length */\n/**\n * Filter items emitted by the source Observable by only emitting those that\n * satisfy a specified predicate.\n *\n * <span class=\"informal\">Like\n * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),\n * it only emits a value from the source if it passes a criterion function.</span>\n *\n * <img src=\"./img/filter.png\" width=\"100%\">\n *\n * Similar to the well-known `Array.prototype.filter` method, this operator\n * takes values from the source Observable, passes them through a `predicate`\n * function and only emits those values that yielded `true`.\n *\n * @example <caption>Emit only click events whose target was a DIV element</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var clicksOnDivs = clicks.filter(ev => ev.target.tagName === 'DIV');\n * clicksOnDivs.subscribe(x => console.log(x));\n *\n * @see {@link distinct}\n * @see {@link distinctUntilChanged}\n * @see {@link distinctUntilKeyChanged}\n * @see {@link ignoreElements}\n * @see {@link partition}\n * @see {@link skip}\n *\n * @param {function(value: T, index: number): boolean} predicate A function that\n * evaluates each value emitted by the source Observable. If it returns `true`,\n * the value is emitted, if `false` the value is not passed to the output\n * Observable. The `index` parameter is the number `i` for the i-th source\n * emission that has happened since the subscription, starting from the number\n * `0`.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {Observable} An Observable of values from the source that were\n * allowed by the `predicate` function.\n * @method filter\n * @owner Observable\n */\nfunction filter(predicate, thisArg) {\n    return function filterOperatorFunction(source) {\n        return source.lift(new FilterOperator(predicate, thisArg));\n    };\n}\nexports.filter = filter;\nvar FilterOperator = (function () {\n    function FilterOperator(predicate, thisArg) {\n        this.predicate = predicate;\n        this.thisArg = thisArg;\n    }\n    FilterOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));\n    };\n    return FilterOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar FilterSubscriber = (function (_super) {\n    __extends(FilterSubscriber, _super);\n    function FilterSubscriber(destination, predicate, thisArg) {\n        _super.call(this, destination);\n        this.predicate = predicate;\n        this.thisArg = thisArg;\n        this.count = 0;\n    }\n    // the try catch block below is left specifically for\n    // optimization and perf reasons. a tryCatcher is not necessary here.\n    FilterSubscriber.prototype._next = function (value) {\n        var result;\n        try {\n            result = this.predicate.call(this.thisArg, value, this.count++);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        if (result) {\n            this.destination.next(value);\n        }\n    };\n    return FilterSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=filter.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/operators/filter.js?");

/***/ }),

/***/ "./node_modules/rxjs/operators/finalize.js":
/*!*************************************************!*\
  !*** ./node_modules/rxjs/operators/finalize.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(/*! ../Subscriber */ \"./node_modules/rxjs/Subscriber.js\");\nvar Subscription_1 = __webpack_require__(/*! ../Subscription */ \"./node_modules/rxjs/Subscription.js\");\n/**\n * Returns an Observable that mirrors the source Observable, but will call a specified function when\n * the source terminates on complete or error.\n * @param {function} callback Function to be called when source terminates.\n * @return {Observable} An Observable that mirrors the source, but will call the specified function on termination.\n * @method finally\n * @owner Observable\n */\nfunction finalize(callback) {\n    return function (source) { return source.lift(new FinallyOperator(callback)); };\n}\nexports.finalize = finalize;\nvar FinallyOperator = (function () {\n    function FinallyOperator(callback) {\n        this.callback = callback;\n    }\n    FinallyOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new FinallySubscriber(subscriber, this.callback));\n    };\n    return FinallyOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar FinallySubscriber = (function (_super) {\n    __extends(FinallySubscriber, _super);\n    function FinallySubscriber(destination, callback) {\n        _super.call(this, destination);\n        this.add(new Subscription_1.Subscription(callback));\n    }\n    return FinallySubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=finalize.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/operators/finalize.js?");

/***/ }),

/***/ "./node_modules/rxjs/operators/ignoreElements.js":
/*!*******************************************************!*\
  !*** ./node_modules/rxjs/operators/ignoreElements.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(/*! ../Subscriber */ \"./node_modules/rxjs/Subscriber.js\");\nvar noop_1 = __webpack_require__(/*! ../util/noop */ \"./node_modules/rxjs/util/noop.js\");\n/**\n * Ignores all items emitted by the source Observable and only passes calls of `complete` or `error`.\n *\n * <img src=\"./img/ignoreElements.png\" width=\"100%\">\n *\n * @return {Observable} An empty Observable that only calls `complete`\n * or `error`, based on which one is called by the source Observable.\n * @method ignoreElements\n * @owner Observable\n */\nfunction ignoreElements() {\n    return function ignoreElementsOperatorFunction(source) {\n        return source.lift(new IgnoreElementsOperator());\n    };\n}\nexports.ignoreElements = ignoreElements;\nvar IgnoreElementsOperator = (function () {\n    function IgnoreElementsOperator() {\n    }\n    IgnoreElementsOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new IgnoreElementsSubscriber(subscriber));\n    };\n    return IgnoreElementsOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar IgnoreElementsSubscriber = (function (_super) {\n    __extends(IgnoreElementsSubscriber, _super);\n    function IgnoreElementsSubscriber() {\n        _super.apply(this, arguments);\n    }\n    IgnoreElementsSubscriber.prototype._next = function (unused) {\n        noop_1.noop();\n    };\n    return IgnoreElementsSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=ignoreElements.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/operators/ignoreElements.js?");

/***/ }),

/***/ "./node_modules/rxjs/operators/map.js":
/*!********************************************!*\
  !*** ./node_modules/rxjs/operators/map.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(/*! ../Subscriber */ \"./node_modules/rxjs/Subscriber.js\");\n/**\n * Applies a given `project` function to each value emitted by the source\n * Observable, and emits the resulting values as an Observable.\n *\n * <span class=\"informal\">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),\n * it passes each source value through a transformation function to get\n * corresponding output values.</span>\n *\n * <img src=\"./img/map.png\" width=\"100%\">\n *\n * Similar to the well known `Array.prototype.map` function, this operator\n * applies a projection to each value and emits that projection in the output\n * Observable.\n *\n * @example <caption>Map every click to the clientX position of that click</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var positions = clicks.map(ev => ev.clientX);\n * positions.subscribe(x => console.log(x));\n *\n * @see {@link mapTo}\n * @see {@link pluck}\n *\n * @param {function(value: T, index: number): R} project The function to apply\n * to each `value` emitted by the source Observable. The `index` parameter is\n * the number `i` for the i-th emission that has happened since the\n * subscription, starting from the number `0`.\n * @param {any} [thisArg] An optional argument to define what `this` is in the\n * `project` function.\n * @return {Observable<R>} An Observable that emits the values from the source\n * Observable transformed by the given `project` function.\n * @method map\n * @owner Observable\n */\nfunction map(project, thisArg) {\n    return function mapOperation(source) {\n        if (typeof project !== 'function') {\n            throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');\n        }\n        return source.lift(new MapOperator(project, thisArg));\n    };\n}\nexports.map = map;\nvar MapOperator = (function () {\n    function MapOperator(project, thisArg) {\n        this.project = project;\n        this.thisArg = thisArg;\n    }\n    MapOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));\n    };\n    return MapOperator;\n}());\nexports.MapOperator = MapOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar MapSubscriber = (function (_super) {\n    __extends(MapSubscriber, _super);\n    function MapSubscriber(destination, project, thisArg) {\n        _super.call(this, destination);\n        this.project = project;\n        this.count = 0;\n        this.thisArg = thisArg || this;\n    }\n    // NOTE: This looks unoptimized, but it's actually purposefully NOT\n    // using try/catch optimizations.\n    MapSubscriber.prototype._next = function (value) {\n        var result;\n        try {\n            result = this.project.call(this.thisArg, value, this.count++);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.next(result);\n    };\n    return MapSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=map.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/operators/map.js?");

/***/ }),

/***/ "./node_modules/rxjs/operators/mapTo.js":
/*!**********************************************!*\
  !*** ./node_modules/rxjs/operators/mapTo.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(/*! ../Subscriber */ \"./node_modules/rxjs/Subscriber.js\");\n/**\n * Emits the given constant value on the output Observable every time the source\n * Observable emits a value.\n *\n * <span class=\"informal\">Like {@link map}, but it maps every source value to\n * the same output value every time.</span>\n *\n * <img src=\"./img/mapTo.png\" width=\"100%\">\n *\n * Takes a constant `value` as argument, and emits that whenever the source\n * Observable emits a value. In other words, ignores the actual source value,\n * and simply uses the emission moment to know when to emit the given `value`.\n *\n * @example <caption>Map every click to the string 'Hi'</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var greetings = clicks.mapTo('Hi');\n * greetings.subscribe(x => console.log(x));\n *\n * @see {@link map}\n *\n * @param {any} value The value to map each source value to.\n * @return {Observable} An Observable that emits the given `value` every time\n * the source Observable emits something.\n * @method mapTo\n * @owner Observable\n */\nfunction mapTo(value) {\n    return function (source) { return source.lift(new MapToOperator(value)); };\n}\nexports.mapTo = mapTo;\nvar MapToOperator = (function () {\n    function MapToOperator(value) {\n        this.value = value;\n    }\n    MapToOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new MapToSubscriber(subscriber, this.value));\n    };\n    return MapToOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar MapToSubscriber = (function (_super) {\n    __extends(MapToSubscriber, _super);\n    function MapToSubscriber(destination, value) {\n        _super.call(this, destination);\n        this.value = value;\n    }\n    MapToSubscriber.prototype._next = function (x) {\n        this.destination.next(this.value);\n    };\n    return MapToSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=mapTo.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/operators/mapTo.js?");

/***/ }),

/***/ "./node_modules/rxjs/operators/merge.js":
/*!**********************************************!*\
  !*** ./node_modules/rxjs/operators/merge.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar merge_1 = __webpack_require__(/*! ../observable/merge */ \"./node_modules/rxjs/observable/merge.js\");\nvar merge_2 = __webpack_require__(/*! ../observable/merge */ \"./node_modules/rxjs/observable/merge.js\");\nexports.mergeStatic = merge_2.merge;\n/* tslint:enable:max-line-length */\n/**\n * Creates an output Observable which concurrently emits all values from every\n * given input Observable.\n *\n * <span class=\"informal\">Flattens multiple Observables together by blending\n * their values into one Observable.</span>\n *\n * <img src=\"./img/merge.png\" width=\"100%\">\n *\n * `merge` subscribes to each given input Observable (either the source or an\n * Observable given as argument), and simply forwards (without doing any\n * transformation) all the values from all the input Observables to the output\n * Observable. The output Observable only completes once all input Observables\n * have completed. Any error delivered by an input Observable will be immediately\n * emitted on the output Observable.\n *\n * @example <caption>Merge together two Observables: 1s interval and clicks</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var timer = Rx.Observable.interval(1000);\n * var clicksOrTimer = clicks.merge(timer);\n * clicksOrTimer.subscribe(x => console.log(x));\n *\n * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var concurrent = 2; // the argument\n * var merged = timer1.merge(timer2, timer3, concurrent);\n * merged.subscribe(x => console.log(x));\n *\n * @see {@link mergeAll}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n *\n * @param {ObservableInput} other An input Observable to merge with the source\n * Observable. More than one input Observables may be given as argument.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @param {Scheduler} [scheduler=null] The IScheduler to use for managing\n * concurrency of input Observables.\n * @return {Observable} An Observable that emits items that are the result of\n * every input Observable.\n * @method merge\n * @owner Observable\n */\nfunction merge() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    return function (source) { return source.lift.call(merge_1.merge.apply(void 0, [source].concat(observables))); };\n}\nexports.merge = merge;\n//# sourceMappingURL=merge.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/operators/merge.js?");

/***/ }),

/***/ "./node_modules/rxjs/operators/mergeAll.js":
/*!*************************************************!*\
  !*** ./node_modules/rxjs/operators/mergeAll.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar mergeMap_1 = __webpack_require__(/*! ./mergeMap */ \"./node_modules/rxjs/operators/mergeMap.js\");\nvar identity_1 = __webpack_require__(/*! ../util/identity */ \"./node_modules/rxjs/util/identity.js\");\n/**\n * Converts a higher-order Observable into a first-order Observable which\n * concurrently delivers all values that are emitted on the inner Observables.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables.</span>\n *\n * <img src=\"./img/mergeAll.png\" width=\"100%\">\n *\n * `mergeAll` subscribes to an Observable that emits Observables, also known as\n * a higher-order Observable. Each time it observes one of these emitted inner\n * Observables, it subscribes to that and delivers all the values from the\n * inner Observable on the output Observable. The output Observable only\n * completes once all inner Observables have completed. Any error delivered by\n * a inner Observable will be immediately emitted on the output Observable.\n *\n * @example <caption>Spawn a new interval Observable for each click event, and blend their outputs as one Observable</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));\n * var firstOrder = higherOrder.mergeAll();\n * firstOrder.subscribe(x => console.log(x));\n *\n * @example <caption>Count from 0 to 9 every second for each click, but only allow 2 concurrent timers</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(10));\n * var firstOrder = higherOrder.mergeAll(2);\n * firstOrder.subscribe(x => console.log(x));\n *\n * @see {@link combineAll}\n * @see {@link concatAll}\n * @see {@link exhaust}\n * @see {@link merge}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n * @see {@link switch}\n * @see {@link zipAll}\n *\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of inner\n * Observables being subscribed to concurrently.\n * @return {Observable} An Observable that emits values coming from all the\n * inner Observables emitted by the source Observable.\n * @method mergeAll\n * @owner Observable\n */\nfunction mergeAll(concurrent) {\n    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n    return mergeMap_1.mergeMap(identity_1.identity, null, concurrent);\n}\nexports.mergeAll = mergeAll;\n//# sourceMappingURL=mergeAll.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/operators/mergeAll.js?");

/***/ }),

/***/ "./node_modules/rxjs/operators/mergeMap.js":
/*!*************************************************!*\
  !*** ./node_modules/rxjs/operators/mergeMap.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar subscribeToResult_1 = __webpack_require__(/*! ../util/subscribeToResult */ \"./node_modules/rxjs/util/subscribeToResult.js\");\nvar OuterSubscriber_1 = __webpack_require__(/*! ../OuterSubscriber */ \"./node_modules/rxjs/OuterSubscriber.js\");\n/* tslint:enable:max-line-length */\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link mergeAll}.</span>\n *\n * <img src=\"./img/mergeMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an Observable, and then merging those resulting Observables and\n * emitting the results of this merger.\n *\n * @example <caption>Map and flatten each letter to an Observable ticking every 1 second</caption>\n * var letters = Rx.Observable.of('a', 'b', 'c');\n * var result = letters.mergeMap(x =>\n *   Rx.Observable.interval(1000).map(i => x+i)\n * );\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // a0\n * // b0\n * // c0\n * // a1\n * // b1\n * // c1\n * // continues to list a,b,c with respective ascending integers\n *\n * @see {@link concatMap}\n * @see {@link exhaustMap}\n * @see {@link merge}\n * @see {@link mergeAll}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @return {Observable} An Observable that emits the result of applying the\n * projection function (and the optional `resultSelector`) to each item emitted\n * by the source Observable and merging the results of the Observables obtained\n * from this transformation.\n * @method mergeMap\n * @owner Observable\n */\nfunction mergeMap(project, resultSelector, concurrent) {\n    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n    return function mergeMapOperatorFunction(source) {\n        if (typeof resultSelector === 'number') {\n            concurrent = resultSelector;\n            resultSelector = null;\n        }\n        return source.lift(new MergeMapOperator(project, resultSelector, concurrent));\n    };\n}\nexports.mergeMap = mergeMap;\nvar MergeMapOperator = (function () {\n    function MergeMapOperator(project, resultSelector, concurrent) {\n        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n        this.project = project;\n        this.resultSelector = resultSelector;\n        this.concurrent = concurrent;\n    }\n    MergeMapOperator.prototype.call = function (observer, source) {\n        return source.subscribe(new MergeMapSubscriber(observer, this.project, this.resultSelector, this.concurrent));\n    };\n    return MergeMapOperator;\n}());\nexports.MergeMapOperator = MergeMapOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar MergeMapSubscriber = (function (_super) {\n    __extends(MergeMapSubscriber, _super);\n    function MergeMapSubscriber(destination, project, resultSelector, concurrent) {\n        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n        _super.call(this, destination);\n        this.project = project;\n        this.resultSelector = resultSelector;\n        this.concurrent = concurrent;\n        this.hasCompleted = false;\n        this.buffer = [];\n        this.active = 0;\n        this.index = 0;\n    }\n    MergeMapSubscriber.prototype._next = function (value) {\n        if (this.active < this.concurrent) {\n            this._tryNext(value);\n        }\n        else {\n            this.buffer.push(value);\n        }\n    };\n    MergeMapSubscriber.prototype._tryNext = function (value) {\n        var result;\n        var index = this.index++;\n        try {\n            result = this.project(value, index);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.active++;\n        this._innerSub(result, value, index);\n    };\n    MergeMapSubscriber.prototype._innerSub = function (ish, value, index) {\n        this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));\n    };\n    MergeMapSubscriber.prototype._complete = function () {\n        this.hasCompleted = true;\n        if (this.active === 0 && this.buffer.length === 0) {\n            this.destination.complete();\n        }\n    };\n    MergeMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        if (this.resultSelector) {\n            this._notifyResultSelector(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        else {\n            this.destination.next(innerValue);\n        }\n    };\n    MergeMapSubscriber.prototype._notifyResultSelector = function (outerValue, innerValue, outerIndex, innerIndex) {\n        var result;\n        try {\n            result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.next(result);\n    };\n    MergeMapSubscriber.prototype.notifyComplete = function (innerSub) {\n        var buffer = this.buffer;\n        this.remove(innerSub);\n        this.active--;\n        if (buffer.length > 0) {\n            this._next(buffer.shift());\n        }\n        else if (this.active === 0 && this.hasCompleted) {\n            this.destination.complete();\n        }\n    };\n    return MergeMapSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\nexports.MergeMapSubscriber = MergeMapSubscriber;\n//# sourceMappingURL=mergeMap.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/operators/mergeMap.js?");

/***/ }),

/***/ "./node_modules/rxjs/operators/mergeMapTo.js":
/*!***************************************************!*\
  !*** ./node_modules/rxjs/operators/mergeMapTo.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = __webpack_require__(/*! ../OuterSubscriber */ \"./node_modules/rxjs/OuterSubscriber.js\");\nvar subscribeToResult_1 = __webpack_require__(/*! ../util/subscribeToResult */ \"./node_modules/rxjs/util/subscribeToResult.js\");\n/* tslint:enable:max-line-length */\n/**\n * Projects each source value to the same Observable which is merged multiple\n * times in the output Observable.\n *\n * <span class=\"informal\">It's like {@link mergeMap}, but maps each value always\n * to the same inner Observable.</span>\n *\n * <img src=\"./img/mergeMapTo.png\" width=\"100%\">\n *\n * Maps each source value to the given Observable `innerObservable` regardless\n * of the source value, and then merges those resulting Observables into one\n * single Observable, which is the output Observable.\n *\n * @example <caption>For each click event, start an interval Observable ticking every 1 second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.mergeMapTo(Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMapTo}\n * @see {@link merge}\n * @see {@link mergeAll}\n * @see {@link mergeMap}\n * @see {@link mergeScan}\n * @see {@link switchMapTo}\n *\n * @param {ObservableInput} innerObservable An Observable to replace each value from\n * the source Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @return {Observable} An Observable that emits items from the given\n * `innerObservable` (and optionally transformed through `resultSelector`) every\n * time a value is emitted on the source Observable.\n * @method mergeMapTo\n * @owner Observable\n */\nfunction mergeMapTo(innerObservable, resultSelector, concurrent) {\n    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n    if (typeof resultSelector === 'number') {\n        concurrent = resultSelector;\n        resultSelector = null;\n    }\n    return function (source) { return source.lift(new MergeMapToOperator(innerObservable, resultSelector, concurrent)); };\n}\nexports.mergeMapTo = mergeMapTo;\n// TODO: Figure out correct signature here: an Operator<Observable<T>, R>\n//       needs to implement call(observer: Subscriber<R>): Subscriber<Observable<T>>\nvar MergeMapToOperator = (function () {\n    function MergeMapToOperator(ish, resultSelector, concurrent) {\n        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n        this.ish = ish;\n        this.resultSelector = resultSelector;\n        this.concurrent = concurrent;\n    }\n    MergeMapToOperator.prototype.call = function (observer, source) {\n        return source.subscribe(new MergeMapToSubscriber(observer, this.ish, this.resultSelector, this.concurrent));\n    };\n    return MergeMapToOperator;\n}());\nexports.MergeMapToOperator = MergeMapToOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar MergeMapToSubscriber = (function (_super) {\n    __extends(MergeMapToSubscriber, _super);\n    function MergeMapToSubscriber(destination, ish, resultSelector, concurrent) {\n        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n        _super.call(this, destination);\n        this.ish = ish;\n        this.resultSelector = resultSelector;\n        this.concurrent = concurrent;\n        this.hasCompleted = false;\n        this.buffer = [];\n        this.active = 0;\n        this.index = 0;\n    }\n    MergeMapToSubscriber.prototype._next = function (value) {\n        if (this.active < this.concurrent) {\n            var resultSelector = this.resultSelector;\n            var index = this.index++;\n            var ish = this.ish;\n            var destination = this.destination;\n            this.active++;\n            this._innerSub(ish, destination, resultSelector, value, index);\n        }\n        else {\n            this.buffer.push(value);\n        }\n    };\n    MergeMapToSubscriber.prototype._innerSub = function (ish, destination, resultSelector, value, index) {\n        this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));\n    };\n    MergeMapToSubscriber.prototype._complete = function () {\n        this.hasCompleted = true;\n        if (this.active === 0 && this.buffer.length === 0) {\n            this.destination.complete();\n        }\n    };\n    MergeMapToSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;\n        if (resultSelector) {\n            this.trySelectResult(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        else {\n            destination.next(innerValue);\n        }\n    };\n    MergeMapToSubscriber.prototype.trySelectResult = function (outerValue, innerValue, outerIndex, innerIndex) {\n        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;\n        var result;\n        try {\n            result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        catch (err) {\n            destination.error(err);\n            return;\n        }\n        destination.next(result);\n    };\n    MergeMapToSubscriber.prototype.notifyError = function (err) {\n        this.destination.error(err);\n    };\n    MergeMapToSubscriber.prototype.notifyComplete = function (innerSub) {\n        var buffer = this.buffer;\n        this.remove(innerSub);\n        this.active--;\n        if (buffer.length > 0) {\n            this._next(buffer.shift());\n        }\n        else if (this.active === 0 && this.hasCompleted) {\n            this.destination.complete();\n        }\n    };\n    return MergeMapToSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\nexports.MergeMapToSubscriber = MergeMapToSubscriber;\n//# sourceMappingURL=mergeMapTo.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/operators/mergeMapTo.js?");

/***/ }),

/***/ "./node_modules/rxjs/operators/multicast.js":
/*!**************************************************!*\
  !*** ./node_modules/rxjs/operators/multicast.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar ConnectableObservable_1 = __webpack_require__(/*! ../observable/ConnectableObservable */ \"./node_modules/rxjs/observable/ConnectableObservable.js\");\n/* tslint:enable:max-line-length */\n/**\n * Returns an Observable that emits the results of invoking a specified selector on items\n * emitted by a ConnectableObservable that shares a single subscription to the underlying stream.\n *\n * <img src=\"./img/multicast.png\" width=\"100%\">\n *\n * @param {Function|Subject} subjectOrSubjectFactory - Factory function to create an intermediate subject through\n * which the source sequence's elements will be multicast to the selector function\n * or Subject to push source elements into.\n * @param {Function} [selector] - Optional selector function that can use the multicasted source stream\n * as many times as needed, without causing multiple subscriptions to the source stream.\n * Subscribers to the given source will receive all notifications of the source from the\n * time of the subscription forward.\n * @return {Observable} An Observable that emits the results of invoking the selector\n * on the items emitted by a `ConnectableObservable` that shares a single subscription to\n * the underlying stream.\n * @method multicast\n * @owner Observable\n */\nfunction multicast(subjectOrSubjectFactory, selector) {\n    return function multicastOperatorFunction(source) {\n        var subjectFactory;\n        if (typeof subjectOrSubjectFactory === 'function') {\n            subjectFactory = subjectOrSubjectFactory;\n        }\n        else {\n            subjectFactory = function subjectFactory() {\n                return subjectOrSubjectFactory;\n            };\n        }\n        if (typeof selector === 'function') {\n            return source.lift(new MulticastOperator(subjectFactory, selector));\n        }\n        var connectable = Object.create(source, ConnectableObservable_1.connectableObservableDescriptor);\n        connectable.source = source;\n        connectable.subjectFactory = subjectFactory;\n        return connectable;\n    };\n}\nexports.multicast = multicast;\nvar MulticastOperator = (function () {\n    function MulticastOperator(subjectFactory, selector) {\n        this.subjectFactory = subjectFactory;\n        this.selector = selector;\n    }\n    MulticastOperator.prototype.call = function (subscriber, source) {\n        var selector = this.selector;\n        var subject = this.subjectFactory();\n        var subscription = selector(subject).subscribe(subscriber);\n        subscription.add(source.subscribe(subject));\n        return subscription;\n    };\n    return MulticastOperator;\n}());\nexports.MulticastOperator = MulticastOperator;\n//# sourceMappingURL=multicast.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/operators/multicast.js?");

/***/ }),

/***/ "./node_modules/rxjs/operators/observeOn.js":
/*!**************************************************!*\
  !*** ./node_modules/rxjs/operators/observeOn.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(/*! ../Subscriber */ \"./node_modules/rxjs/Subscriber.js\");\nvar Notification_1 = __webpack_require__(/*! ../Notification */ \"./node_modules/rxjs/Notification.js\");\n/**\n *\n * Re-emits all notifications from source Observable with specified scheduler.\n *\n * <span class=\"informal\">Ensure a specific scheduler is used, from outside of an Observable.</span>\n *\n * `observeOn` is an operator that accepts a scheduler as a first parameter, which will be used to reschedule\n * notifications emitted by the source Observable. It might be useful, if you do not have control over\n * internal scheduler of a given Observable, but want to control when its values are emitted nevertheless.\n *\n * Returned Observable emits the same notifications (nexted values, complete and error events) as the source Observable,\n * but rescheduled with provided scheduler. Note that this doesn't mean that source Observables internal\n * scheduler will be replaced in any way. Original scheduler still will be used, but when the source Observable emits\n * notification, it will be immediately scheduled again - this time with scheduler passed to `observeOn`.\n * An anti-pattern would be calling `observeOn` on Observable that emits lots of values synchronously, to split\n * that emissions into asynchronous chunks. For this to happen, scheduler would have to be passed into the source\n * Observable directly (usually into the operator that creates it). `observeOn` simply delays notifications a\n * little bit more, to ensure that they are emitted at expected moments.\n *\n * As a matter of fact, `observeOn` accepts second parameter, which specifies in milliseconds with what delay notifications\n * will be emitted. The main difference between {@link delay} operator and `observeOn` is that `observeOn`\n * will delay all notifications - including error notifications - while `delay` will pass through error\n * from source Observable immediately when it is emitted. In general it is highly recommended to use `delay` operator\n * for any kind of delaying of values in the stream, while using `observeOn` to specify which scheduler should be used\n * for notification emissions in general.\n *\n * @example <caption>Ensure values in subscribe are called just before browser repaint.</caption>\n * const intervals = Rx.Observable.interval(10); // Intervals are scheduled\n *                                               // with async scheduler by default...\n *\n * intervals\n * .observeOn(Rx.Scheduler.animationFrame)       // ...but we will observe on animationFrame\n * .subscribe(val => {                           // scheduler to ensure smooth animation.\n *   someDiv.style.height = val + 'px';\n * });\n *\n * @see {@link delay}\n *\n * @param {IScheduler} scheduler Scheduler that will be used to reschedule notifications from source Observable.\n * @param {number} [delay] Number of milliseconds that states with what delay every notification should be rescheduled.\n * @return {Observable<T>} Observable that emits the same notifications as the source Observable,\n * but with provided scheduler.\n *\n * @method observeOn\n * @owner Observable\n */\nfunction observeOn(scheduler, delay) {\n    if (delay === void 0) { delay = 0; }\n    return function observeOnOperatorFunction(source) {\n        return source.lift(new ObserveOnOperator(scheduler, delay));\n    };\n}\nexports.observeOn = observeOn;\nvar ObserveOnOperator = (function () {\n    function ObserveOnOperator(scheduler, delay) {\n        if (delay === void 0) { delay = 0; }\n        this.scheduler = scheduler;\n        this.delay = delay;\n    }\n    ObserveOnOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));\n    };\n    return ObserveOnOperator;\n}());\nexports.ObserveOnOperator = ObserveOnOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ObserveOnSubscriber = (function (_super) {\n    __extends(ObserveOnSubscriber, _super);\n    function ObserveOnSubscriber(destination, scheduler, delay) {\n        if (delay === void 0) { delay = 0; }\n        _super.call(this, destination);\n        this.scheduler = scheduler;\n        this.delay = delay;\n    }\n    ObserveOnSubscriber.dispatch = function (arg) {\n        var notification = arg.notification, destination = arg.destination;\n        notification.observe(destination);\n        this.unsubscribe();\n    };\n    ObserveOnSubscriber.prototype.scheduleMessage = function (notification) {\n        this.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));\n    };\n    ObserveOnSubscriber.prototype._next = function (value) {\n        this.scheduleMessage(Notification_1.Notification.createNext(value));\n    };\n    ObserveOnSubscriber.prototype._error = function (err) {\n        this.scheduleMessage(Notification_1.Notification.createError(err));\n    };\n    ObserveOnSubscriber.prototype._complete = function () {\n        this.scheduleMessage(Notification_1.Notification.createComplete());\n    };\n    return ObserveOnSubscriber;\n}(Subscriber_1.Subscriber));\nexports.ObserveOnSubscriber = ObserveOnSubscriber;\nvar ObserveOnMessage = (function () {\n    function ObserveOnMessage(notification, destination) {\n        this.notification = notification;\n        this.destination = destination;\n    }\n    return ObserveOnMessage;\n}());\nexports.ObserveOnMessage = ObserveOnMessage;\n//# sourceMappingURL=observeOn.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/operators/observeOn.js?");

/***/ }),

/***/ "./node_modules/rxjs/operators/pairwise.js":
/*!*************************************************!*\
  !*** ./node_modules/rxjs/operators/pairwise.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(/*! ../Subscriber */ \"./node_modules/rxjs/Subscriber.js\");\n/**\n * Groups pairs of consecutive emissions together and emits them as an array of\n * two values.\n *\n * <span class=\"informal\">Puts the current value and previous value together as\n * an array, and emits that.</span>\n *\n * <img src=\"./img/pairwise.png\" width=\"100%\">\n *\n * The Nth emission from the source Observable will cause the output Observable\n * to emit an array [(N-1)th, Nth] of the previous and the current value, as a\n * pair. For this reason, `pairwise` emits on the second and subsequent\n * emissions from the source Observable, but not on the first emission, because\n * there is no previous value in that case.\n *\n * @example <caption>On every click (starting from the second), emit the relative distance to the previous click</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var pairs = clicks.pairwise();\n * var distance = pairs.map(pair => {\n *   var x0 = pair[0].clientX;\n *   var y0 = pair[0].clientY;\n *   var x1 = pair[1].clientX;\n *   var y1 = pair[1].clientY;\n *   return Math.sqrt(Math.pow(x0 - x1, 2) + Math.pow(y0 - y1, 2));\n * });\n * distance.subscribe(x => console.log(x));\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n *\n * @return {Observable<Array<T>>} An Observable of pairs (as arrays) of\n * consecutive values from the source Observable.\n * @method pairwise\n * @owner Observable\n */\nfunction pairwise() {\n    return function (source) { return source.lift(new PairwiseOperator()); };\n}\nexports.pairwise = pairwise;\nvar PairwiseOperator = (function () {\n    function PairwiseOperator() {\n    }\n    PairwiseOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new PairwiseSubscriber(subscriber));\n    };\n    return PairwiseOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar PairwiseSubscriber = (function (_super) {\n    __extends(PairwiseSubscriber, _super);\n    function PairwiseSubscriber(destination) {\n        _super.call(this, destination);\n        this.hasPrev = false;\n    }\n    PairwiseSubscriber.prototype._next = function (value) {\n        if (this.hasPrev) {\n            this.destination.next([this.prev, value]);\n        }\n        else {\n            this.hasPrev = true;\n        }\n        this.prev = value;\n    };\n    return PairwiseSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=pairwise.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/operators/pairwise.js?");

/***/ }),

/***/ "./node_modules/rxjs/operators/publish.js":
/*!************************************************!*\
  !*** ./node_modules/rxjs/operators/publish.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Subject_1 = __webpack_require__(/*! ../Subject */ \"./node_modules/rxjs/Subject.js\");\nvar multicast_1 = __webpack_require__(/*! ./multicast */ \"./node_modules/rxjs/operators/multicast.js\");\n/* tslint:enable:max-line-length */\n/**\n * Returns a ConnectableObservable, which is a variety of Observable that waits until its connect method is called\n * before it begins emitting items to those Observers that have subscribed to it.\n *\n * <img src=\"./img/publish.png\" width=\"100%\">\n *\n * @param {Function} [selector] - Optional selector function which can use the multicasted source sequence as many times\n * as needed, without causing multiple subscriptions to the source sequence.\n * Subscribers to the given source will receive all notifications of the source from the time of the subscription on.\n * @return A ConnectableObservable that upon connection causes the source Observable to emit items to its Observers.\n * @method publish\n * @owner Observable\n */\nfunction publish(selector) {\n    return selector ?\n        multicast_1.multicast(function () { return new Subject_1.Subject(); }, selector) :\n        multicast_1.multicast(new Subject_1.Subject());\n}\nexports.publish = publish;\n//# sourceMappingURL=publish.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/operators/publish.js?");

/***/ }),

/***/ "./node_modules/rxjs/operators/refCount.js":
/*!*************************************************!*\
  !*** ./node_modules/rxjs/operators/refCount.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(/*! ../Subscriber */ \"./node_modules/rxjs/Subscriber.js\");\nfunction refCount() {\n    return function refCountOperatorFunction(source) {\n        return source.lift(new RefCountOperator(source));\n    };\n}\nexports.refCount = refCount;\nvar RefCountOperator = (function () {\n    function RefCountOperator(connectable) {\n        this.connectable = connectable;\n    }\n    RefCountOperator.prototype.call = function (subscriber, source) {\n        var connectable = this.connectable;\n        connectable._refCount++;\n        var refCounter = new RefCountSubscriber(subscriber, connectable);\n        var subscription = source.subscribe(refCounter);\n        if (!refCounter.closed) {\n            refCounter.connection = connectable.connect();\n        }\n        return subscription;\n    };\n    return RefCountOperator;\n}());\nvar RefCountSubscriber = (function (_super) {\n    __extends(RefCountSubscriber, _super);\n    function RefCountSubscriber(destination, connectable) {\n        _super.call(this, destination);\n        this.connectable = connectable;\n    }\n    RefCountSubscriber.prototype._unsubscribe = function () {\n        var connectable = this.connectable;\n        if (!connectable) {\n            this.connection = null;\n            return;\n        }\n        this.connectable = null;\n        var refCount = connectable._refCount;\n        if (refCount <= 0) {\n            this.connection = null;\n            return;\n        }\n        connectable._refCount = refCount - 1;\n        if (refCount > 1) {\n            this.connection = null;\n            return;\n        }\n        ///\n        // Compare the local RefCountSubscriber's connection Subscription to the\n        // connection Subscription on the shared ConnectableObservable. In cases\n        // where the ConnectableObservable source synchronously emits values, and\n        // the RefCountSubscriber's downstream Observers synchronously unsubscribe,\n        // execution continues to here before the RefCountOperator has a chance to\n        // supply the RefCountSubscriber with the shared connection Subscription.\n        // For example:\n        // ```\n        // Observable.range(0, 10)\n        //   .publish()\n        //   .refCount()\n        //   .take(5)\n        //   .subscribe();\n        // ```\n        // In order to account for this case, RefCountSubscriber should only dispose\n        // the ConnectableObservable's shared connection Subscription if the\n        // connection Subscription exists, *and* either:\n        //   a. RefCountSubscriber doesn't have a reference to the shared connection\n        //      Subscription yet, or,\n        //   b. RefCountSubscriber's connection Subscription reference is identical\n        //      to the shared connection Subscription\n        ///\n        var connection = this.connection;\n        var sharedConnection = connectable._connection;\n        this.connection = null;\n        if (sharedConnection && (!connection || sharedConnection === connection)) {\n            sharedConnection.unsubscribe();\n        }\n    };\n    return RefCountSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=refCount.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/operators/refCount.js?");

/***/ }),

/***/ "./node_modules/rxjs/operators/scan.js":
/*!*********************************************!*\
  !*** ./node_modules/rxjs/operators/scan.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(/*! ../Subscriber */ \"./node_modules/rxjs/Subscriber.js\");\n/* tslint:enable:max-line-length */\n/**\n * Applies an accumulator function over the source Observable, and returns each\n * intermediate result, with an optional seed value.\n *\n * <span class=\"informal\">It's like {@link reduce}, but emits the current\n * accumulation whenever the source emits a value.</span>\n *\n * <img src=\"./img/scan.png\" width=\"100%\">\n *\n * Combines together all values emitted on the source, using an accumulator\n * function that knows how to join a new source value into the accumulation from\n * the past. Is similar to {@link reduce}, but emits the intermediate\n * accumulations.\n *\n * Returns an Observable that applies a specified `accumulator` function to each\n * item emitted by the source Observable. If a `seed` value is specified, then\n * that value will be used as the initial value for the accumulator. If no seed\n * value is specified, the first item of the source is used as the seed.\n *\n * @example <caption>Count the number of click events</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var ones = clicks.mapTo(1);\n * var seed = 0;\n * var count = ones.scan((acc, one) => acc + one, seed);\n * count.subscribe(x => console.log(x));\n *\n * @see {@link expand}\n * @see {@link mergeScan}\n * @see {@link reduce}\n *\n * @param {function(acc: R, value: T, index: number): R} accumulator\n * The accumulator function called on each source value.\n * @param {T|R} [seed] The initial accumulation value.\n * @return {Observable<R>} An observable of the accumulated values.\n * @method scan\n * @owner Observable\n */\nfunction scan(accumulator, seed) {\n    var hasSeed = false;\n    // providing a seed of `undefined` *should* be valid and trigger\n    // hasSeed! so don't use `seed !== undefined` checks!\n    // For this reason, we have to check it here at the original call site\n    // otherwise inside Operator/Subscriber we won't know if `undefined`\n    // means they didn't provide anything or if they literally provided `undefined`\n    if (arguments.length >= 2) {\n        hasSeed = true;\n    }\n    return function scanOperatorFunction(source) {\n        return source.lift(new ScanOperator(accumulator, seed, hasSeed));\n    };\n}\nexports.scan = scan;\nvar ScanOperator = (function () {\n    function ScanOperator(accumulator, seed, hasSeed) {\n        if (hasSeed === void 0) { hasSeed = false; }\n        this.accumulator = accumulator;\n        this.seed = seed;\n        this.hasSeed = hasSeed;\n    }\n    ScanOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new ScanSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));\n    };\n    return ScanOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ScanSubscriber = (function (_super) {\n    __extends(ScanSubscriber, _super);\n    function ScanSubscriber(destination, accumulator, _seed, hasSeed) {\n        _super.call(this, destination);\n        this.accumulator = accumulator;\n        this._seed = _seed;\n        this.hasSeed = hasSeed;\n        this.index = 0;\n    }\n    Object.defineProperty(ScanSubscriber.prototype, \"seed\", {\n        get: function () {\n            return this._seed;\n        },\n        set: function (value) {\n            this.hasSeed = true;\n            this._seed = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ScanSubscriber.prototype._next = function (value) {\n        if (!this.hasSeed) {\n            this.seed = value;\n            this.destination.next(value);\n        }\n        else {\n            return this._tryNext(value);\n        }\n    };\n    ScanSubscriber.prototype._tryNext = function (value) {\n        var index = this.index++;\n        var result;\n        try {\n            result = this.accumulator(this.seed, value, index);\n        }\n        catch (err) {\n            this.destination.error(err);\n        }\n        this.seed = result;\n        this.destination.next(result);\n    };\n    return ScanSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=scan.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/operators/scan.js?");

/***/ }),

/***/ "./node_modules/rxjs/operators/share.js":
/*!**********************************************!*\
  !*** ./node_modules/rxjs/operators/share.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar multicast_1 = __webpack_require__(/*! ./multicast */ \"./node_modules/rxjs/operators/multicast.js\");\nvar refCount_1 = __webpack_require__(/*! ./refCount */ \"./node_modules/rxjs/operators/refCount.js\");\nvar Subject_1 = __webpack_require__(/*! ../Subject */ \"./node_modules/rxjs/Subject.js\");\nfunction shareSubjectFactory() {\n    return new Subject_1.Subject();\n}\n/**\n * Returns a new Observable that multicasts (shares) the original Observable. As long as there is at least one\n * Subscriber this Observable will be subscribed and emitting data. When all subscribers have unsubscribed it will\n * unsubscribe from the source Observable. Because the Observable is multicasting it makes the stream `hot`.\n * This is an alias for .multicast(() => new Subject()).refCount().\n *\n * <img src=\"./img/share.png\" width=\"100%\">\n *\n * @return {Observable<T>} An Observable that upon connection causes the source Observable to emit items to its Observers.\n * @method share\n * @owner Observable\n */\nfunction share() {\n    return function (source) { return refCount_1.refCount()(multicast_1.multicast(shareSubjectFactory)(source)); };\n}\nexports.share = share;\n;\n//# sourceMappingURL=share.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/operators/share.js?");

/***/ }),

/***/ "./node_modules/rxjs/operators/skip.js":
/*!*********************************************!*\
  !*** ./node_modules/rxjs/operators/skip.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(/*! ../Subscriber */ \"./node_modules/rxjs/Subscriber.js\");\n/**\n * Returns an Observable that skips the first `count` items emitted by the source Observable.\n *\n * <img src=\"./img/skip.png\" width=\"100%\">\n *\n * @param {Number} count - The number of times, items emitted by source Observable should be skipped.\n * @return {Observable} An Observable that skips values emitted by the source Observable.\n *\n * @method skip\n * @owner Observable\n */\nfunction skip(count) {\n    return function (source) { return source.lift(new SkipOperator(count)); };\n}\nexports.skip = skip;\nvar SkipOperator = (function () {\n    function SkipOperator(total) {\n        this.total = total;\n    }\n    SkipOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SkipSubscriber(subscriber, this.total));\n    };\n    return SkipOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SkipSubscriber = (function (_super) {\n    __extends(SkipSubscriber, _super);\n    function SkipSubscriber(destination, total) {\n        _super.call(this, destination);\n        this.total = total;\n        this.count = 0;\n    }\n    SkipSubscriber.prototype._next = function (x) {\n        if (++this.count > this.total) {\n            this.destination.next(x);\n        }\n    };\n    return SkipSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=skip.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/operators/skip.js?");

/***/ }),

/***/ "./node_modules/rxjs/operators/skipUntil.js":
/*!**************************************************!*\
  !*** ./node_modules/rxjs/operators/skipUntil.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = __webpack_require__(/*! ../OuterSubscriber */ \"./node_modules/rxjs/OuterSubscriber.js\");\nvar subscribeToResult_1 = __webpack_require__(/*! ../util/subscribeToResult */ \"./node_modules/rxjs/util/subscribeToResult.js\");\n/**\n * Returns an Observable that skips items emitted by the source Observable until a second Observable emits an item.\n *\n * <img src=\"./img/skipUntil.png\" width=\"100%\">\n *\n * @param {Observable} notifier - The second Observable that has to emit an item before the source Observable's elements begin to\n * be mirrored by the resulting Observable.\n * @return {Observable<T>} An Observable that skips items from the source Observable until the second Observable emits\n * an item, then emits the remaining items.\n * @method skipUntil\n * @owner Observable\n */\nfunction skipUntil(notifier) {\n    return function (source) { return source.lift(new SkipUntilOperator(notifier)); };\n}\nexports.skipUntil = skipUntil;\nvar SkipUntilOperator = (function () {\n    function SkipUntilOperator(notifier) {\n        this.notifier = notifier;\n    }\n    SkipUntilOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SkipUntilSubscriber(subscriber, this.notifier));\n    };\n    return SkipUntilOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SkipUntilSubscriber = (function (_super) {\n    __extends(SkipUntilSubscriber, _super);\n    function SkipUntilSubscriber(destination, notifier) {\n        _super.call(this, destination);\n        this.hasValue = false;\n        this.isInnerStopped = false;\n        this.add(subscribeToResult_1.subscribeToResult(this, notifier));\n    }\n    SkipUntilSubscriber.prototype._next = function (value) {\n        if (this.hasValue) {\n            _super.prototype._next.call(this, value);\n        }\n    };\n    SkipUntilSubscriber.prototype._complete = function () {\n        if (this.isInnerStopped) {\n            _super.prototype._complete.call(this);\n        }\n        else {\n            this.unsubscribe();\n        }\n    };\n    SkipUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.hasValue = true;\n    };\n    SkipUntilSubscriber.prototype.notifyComplete = function () {\n        this.isInnerStopped = true;\n        if (this.isStopped) {\n            _super.prototype._complete.call(this);\n        }\n    };\n    return SkipUntilSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=skipUntil.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/operators/skipUntil.js?");

/***/ }),

/***/ "./node_modules/rxjs/operators/skipWhile.js":
/*!**************************************************!*\
  !*** ./node_modules/rxjs/operators/skipWhile.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(/*! ../Subscriber */ \"./node_modules/rxjs/Subscriber.js\");\n/**\n * Returns an Observable that skips all items emitted by the source Observable as long as a specified condition holds\n * true, but emits all further source items as soon as the condition becomes false.\n *\n * <img src=\"./img/skipWhile.png\" width=\"100%\">\n *\n * @param {Function} predicate - A function to test each item emitted from the source Observable.\n * @return {Observable<T>} An Observable that begins emitting items emitted by the source Observable when the\n * specified predicate becomes false.\n * @method skipWhile\n * @owner Observable\n */\nfunction skipWhile(predicate) {\n    return function (source) { return source.lift(new SkipWhileOperator(predicate)); };\n}\nexports.skipWhile = skipWhile;\nvar SkipWhileOperator = (function () {\n    function SkipWhileOperator(predicate) {\n        this.predicate = predicate;\n    }\n    SkipWhileOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SkipWhileSubscriber(subscriber, this.predicate));\n    };\n    return SkipWhileOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SkipWhileSubscriber = (function (_super) {\n    __extends(SkipWhileSubscriber, _super);\n    function SkipWhileSubscriber(destination, predicate) {\n        _super.call(this, destination);\n        this.predicate = predicate;\n        this.skipping = true;\n        this.index = 0;\n    }\n    SkipWhileSubscriber.prototype._next = function (value) {\n        var destination = this.destination;\n        if (this.skipping) {\n            this.tryCallPredicate(value);\n        }\n        if (!this.skipping) {\n            destination.next(value);\n        }\n    };\n    SkipWhileSubscriber.prototype.tryCallPredicate = function (value) {\n        try {\n            var result = this.predicate(value, this.index++);\n            this.skipping = Boolean(result);\n        }\n        catch (err) {\n            this.destination.error(err);\n        }\n    };\n    return SkipWhileSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=skipWhile.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/operators/skipWhile.js?");

/***/ }),

/***/ "./node_modules/rxjs/operators/startWith.js":
/*!**************************************************!*\
  !*** ./node_modules/rxjs/operators/startWith.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar ArrayObservable_1 = __webpack_require__(/*! ../observable/ArrayObservable */ \"./node_modules/rxjs/observable/ArrayObservable.js\");\nvar ScalarObservable_1 = __webpack_require__(/*! ../observable/ScalarObservable */ \"./node_modules/rxjs/observable/ScalarObservable.js\");\nvar EmptyObservable_1 = __webpack_require__(/*! ../observable/EmptyObservable */ \"./node_modules/rxjs/observable/EmptyObservable.js\");\nvar concat_1 = __webpack_require__(/*! ../observable/concat */ \"./node_modules/rxjs/observable/concat.js\");\nvar isScheduler_1 = __webpack_require__(/*! ../util/isScheduler */ \"./node_modules/rxjs/util/isScheduler.js\");\n/* tslint:enable:max-line-length */\n/**\n * Returns an Observable that emits the items you specify as arguments before it begins to emit\n * items emitted by the source Observable.\n *\n * <img src=\"./img/startWith.png\" width=\"100%\">\n *\n * @param {...T} values - Items you want the modified Observable to emit first.\n * @param {Scheduler} [scheduler] - A {@link IScheduler} to use for scheduling\n * the emissions of the `next` notifications.\n * @return {Observable} An Observable that emits the items in the specified Iterable and then emits the items\n * emitted by the source Observable.\n * @method startWith\n * @owner Observable\n */\nfunction startWith() {\n    var array = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        array[_i - 0] = arguments[_i];\n    }\n    return function (source) {\n        var scheduler = array[array.length - 1];\n        if (isScheduler_1.isScheduler(scheduler)) {\n            array.pop();\n        }\n        else {\n            scheduler = null;\n        }\n        var len = array.length;\n        if (len === 1) {\n            return concat_1.concat(new ScalarObservable_1.ScalarObservable(array[0], scheduler), source);\n        }\n        else if (len > 1) {\n            return concat_1.concat(new ArrayObservable_1.ArrayObservable(array, scheduler), source);\n        }\n        else {\n            return concat_1.concat(new EmptyObservable_1.EmptyObservable(scheduler), source);\n        }\n    };\n}\nexports.startWith = startWith;\n//# sourceMappingURL=startWith.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/operators/startWith.js?");

/***/ }),

/***/ "./node_modules/rxjs/operators/switchMap.js":
/*!**************************************************!*\
  !*** ./node_modules/rxjs/operators/switchMap.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = __webpack_require__(/*! ../OuterSubscriber */ \"./node_modules/rxjs/OuterSubscriber.js\");\nvar subscribeToResult_1 = __webpack_require__(/*! ../util/subscribeToResult */ \"./node_modules/rxjs/util/subscribeToResult.js\");\n/* tslint:enable:max-line-length */\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable, emitting values only from the most recently projected Observable.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link switch}.</span>\n *\n * <img src=\"./img/switchMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. Each time it observes one of these\n * inner Observables, the output Observable begins emitting the items emitted by\n * that inner Observable. When a new inner Observable is emitted, `switchMap`\n * stops emitting items from the earlier-emitted inner Observable and begins\n * emitting items from the new one. It continues to behave like this for\n * subsequent inner Observables.\n *\n * @example <caption>Rerun an interval Observable on every click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.switchMap((ev) => Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMap}\n * @see {@link exhaustMap}\n * @see {@link mergeMap}\n * @see {@link switch}\n * @see {@link switchMapTo}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An Observable that emits the result of applying the\n * projection function (and the optional `resultSelector`) to each item emitted\n * by the source Observable and taking only the values from the most recently\n * projected inner Observable.\n * @method switchMap\n * @owner Observable\n */\nfunction switchMap(project, resultSelector) {\n    return function switchMapOperatorFunction(source) {\n        return source.lift(new SwitchMapOperator(project, resultSelector));\n    };\n}\nexports.switchMap = switchMap;\nvar SwitchMapOperator = (function () {\n    function SwitchMapOperator(project, resultSelector) {\n        this.project = project;\n        this.resultSelector = resultSelector;\n    }\n    SwitchMapOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SwitchMapSubscriber(subscriber, this.project, this.resultSelector));\n    };\n    return SwitchMapOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SwitchMapSubscriber = (function (_super) {\n    __extends(SwitchMapSubscriber, _super);\n    function SwitchMapSubscriber(destination, project, resultSelector) {\n        _super.call(this, destination);\n        this.project = project;\n        this.resultSelector = resultSelector;\n        this.index = 0;\n    }\n    SwitchMapSubscriber.prototype._next = function (value) {\n        var result;\n        var index = this.index++;\n        try {\n            result = this.project(value, index);\n        }\n        catch (error) {\n            this.destination.error(error);\n            return;\n        }\n        this._innerSub(result, value, index);\n    };\n    SwitchMapSubscriber.prototype._innerSub = function (result, value, index) {\n        var innerSubscription = this.innerSubscription;\n        if (innerSubscription) {\n            innerSubscription.unsubscribe();\n        }\n        this.add(this.innerSubscription = subscribeToResult_1.subscribeToResult(this, result, value, index));\n    };\n    SwitchMapSubscriber.prototype._complete = function () {\n        var innerSubscription = this.innerSubscription;\n        if (!innerSubscription || innerSubscription.closed) {\n            _super.prototype._complete.call(this);\n        }\n    };\n    SwitchMapSubscriber.prototype._unsubscribe = function () {\n        this.innerSubscription = null;\n    };\n    SwitchMapSubscriber.prototype.notifyComplete = function (innerSub) {\n        this.remove(innerSub);\n        this.innerSubscription = null;\n        if (this.isStopped) {\n            _super.prototype._complete.call(this);\n        }\n    };\n    SwitchMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        if (this.resultSelector) {\n            this._tryNotifyNext(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        else {\n            this.destination.next(innerValue);\n        }\n    };\n    SwitchMapSubscriber.prototype._tryNotifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {\n        var result;\n        try {\n            result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.next(result);\n    };\n    return SwitchMapSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=switchMap.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/operators/switchMap.js?");

/***/ }),

/***/ "./node_modules/rxjs/operators/switchMapTo.js":
/*!****************************************************!*\
  !*** ./node_modules/rxjs/operators/switchMapTo.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = __webpack_require__(/*! ../OuterSubscriber */ \"./node_modules/rxjs/OuterSubscriber.js\");\nvar subscribeToResult_1 = __webpack_require__(/*! ../util/subscribeToResult */ \"./node_modules/rxjs/util/subscribeToResult.js\");\n/* tslint:enable:max-line-length */\n/**\n * Projects each source value to the same Observable which is flattened multiple\n * times with {@link switch} in the output Observable.\n *\n * <span class=\"informal\">It's like {@link switchMap}, but maps each value\n * always to the same inner Observable.</span>\n *\n * <img src=\"./img/switchMapTo.png\" width=\"100%\">\n *\n * Maps each source value to the given Observable `innerObservable` regardless\n * of the source value, and then flattens those resulting Observables into one\n * single Observable, which is the output Observable. The output Observables\n * emits values only from the most recently emitted instance of\n * `innerObservable`.\n *\n * @example <caption>Rerun an interval Observable on every click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.switchMapTo(Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMapTo}\n * @see {@link switch}\n * @see {@link switchMap}\n * @see {@link mergeMapTo}\n *\n * @param {ObservableInput} innerObservable An Observable to replace each value from\n * the source Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An Observable that emits items from the given\n * `innerObservable` (and optionally transformed through `resultSelector`) every\n * time a value is emitted on the source Observable, and taking only the values\n * from the most recently projected inner Observable.\n * @method switchMapTo\n * @owner Observable\n */\nfunction switchMapTo(innerObservable, resultSelector) {\n    return function (source) { return source.lift(new SwitchMapToOperator(innerObservable, resultSelector)); };\n}\nexports.switchMapTo = switchMapTo;\nvar SwitchMapToOperator = (function () {\n    function SwitchMapToOperator(observable, resultSelector) {\n        this.observable = observable;\n        this.resultSelector = resultSelector;\n    }\n    SwitchMapToOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SwitchMapToSubscriber(subscriber, this.observable, this.resultSelector));\n    };\n    return SwitchMapToOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SwitchMapToSubscriber = (function (_super) {\n    __extends(SwitchMapToSubscriber, _super);\n    function SwitchMapToSubscriber(destination, inner, resultSelector) {\n        _super.call(this, destination);\n        this.inner = inner;\n        this.resultSelector = resultSelector;\n        this.index = 0;\n    }\n    SwitchMapToSubscriber.prototype._next = function (value) {\n        var innerSubscription = this.innerSubscription;\n        if (innerSubscription) {\n            innerSubscription.unsubscribe();\n        }\n        this.add(this.innerSubscription = subscribeToResult_1.subscribeToResult(this, this.inner, value, this.index++));\n    };\n    SwitchMapToSubscriber.prototype._complete = function () {\n        var innerSubscription = this.innerSubscription;\n        if (!innerSubscription || innerSubscription.closed) {\n            _super.prototype._complete.call(this);\n        }\n    };\n    SwitchMapToSubscriber.prototype._unsubscribe = function () {\n        this.innerSubscription = null;\n    };\n    SwitchMapToSubscriber.prototype.notifyComplete = function (innerSub) {\n        this.remove(innerSub);\n        this.innerSubscription = null;\n        if (this.isStopped) {\n            _super.prototype._complete.call(this);\n        }\n    };\n    SwitchMapToSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;\n        if (resultSelector) {\n            this.tryResultSelector(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        else {\n            destination.next(innerValue);\n        }\n    };\n    SwitchMapToSubscriber.prototype.tryResultSelector = function (outerValue, innerValue, outerIndex, innerIndex) {\n        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;\n        var result;\n        try {\n            result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        catch (err) {\n            destination.error(err);\n            return;\n        }\n        destination.next(result);\n    };\n    return SwitchMapToSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=switchMapTo.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/operators/switchMapTo.js?");

/***/ }),

/***/ "./node_modules/rxjs/operators/take.js":
/*!*********************************************!*\
  !*** ./node_modules/rxjs/operators/take.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(/*! ../Subscriber */ \"./node_modules/rxjs/Subscriber.js\");\nvar ArgumentOutOfRangeError_1 = __webpack_require__(/*! ../util/ArgumentOutOfRangeError */ \"./node_modules/rxjs/util/ArgumentOutOfRangeError.js\");\nvar EmptyObservable_1 = __webpack_require__(/*! ../observable/EmptyObservable */ \"./node_modules/rxjs/observable/EmptyObservable.js\");\n/**\n * Emits only the first `count` values emitted by the source Observable.\n *\n * <span class=\"informal\">Takes the first `count` values from the source, then\n * completes.</span>\n *\n * <img src=\"./img/take.png\" width=\"100%\">\n *\n * `take` returns an Observable that emits only the first `count` values emitted\n * by the source Observable. If the source emits fewer than `count` values then\n * all of its values are emitted. After that, it completes, regardless if the\n * source completes.\n *\n * @example <caption>Take the first 5 seconds of an infinite 1-second interval Observable</caption>\n * var interval = Rx.Observable.interval(1000);\n * var five = interval.take(5);\n * five.subscribe(x => console.log(x));\n *\n * @see {@link takeLast}\n * @see {@link takeUntil}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @throws {ArgumentOutOfRangeError} When using `take(i)`, it delivers an\n * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.\n *\n * @param {number} count The maximum number of `next` values to emit.\n * @return {Observable<T>} An Observable that emits only the first `count`\n * values emitted by the source Observable, or all of the values from the source\n * if the source emits fewer than `count` values.\n * @method take\n * @owner Observable\n */\nfunction take(count) {\n    return function (source) {\n        if (count === 0) {\n            return new EmptyObservable_1.EmptyObservable();\n        }\n        else {\n            return source.lift(new TakeOperator(count));\n        }\n    };\n}\nexports.take = take;\nvar TakeOperator = (function () {\n    function TakeOperator(total) {\n        this.total = total;\n        if (this.total < 0) {\n            throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;\n        }\n    }\n    TakeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new TakeSubscriber(subscriber, this.total));\n    };\n    return TakeOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar TakeSubscriber = (function (_super) {\n    __extends(TakeSubscriber, _super);\n    function TakeSubscriber(destination, total) {\n        _super.call(this, destination);\n        this.total = total;\n        this.count = 0;\n    }\n    TakeSubscriber.prototype._next = function (value) {\n        var total = this.total;\n        var count = ++this.count;\n        if (count <= total) {\n            this.destination.next(value);\n            if (count === total) {\n                this.destination.complete();\n                this.unsubscribe();\n            }\n        }\n    };\n    return TakeSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=take.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/operators/take.js?");

/***/ }),

/***/ "./node_modules/rxjs/operators/takeUntil.js":
/*!**************************************************!*\
  !*** ./node_modules/rxjs/operators/takeUntil.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = __webpack_require__(/*! ../OuterSubscriber */ \"./node_modules/rxjs/OuterSubscriber.js\");\nvar subscribeToResult_1 = __webpack_require__(/*! ../util/subscribeToResult */ \"./node_modules/rxjs/util/subscribeToResult.js\");\n/**\n * Emits the values emitted by the source Observable until a `notifier`\n * Observable emits a value.\n *\n * <span class=\"informal\">Lets values pass until a second Observable,\n * `notifier`, emits something. Then, it completes.</span>\n *\n * <img src=\"./img/takeUntil.png\" width=\"100%\">\n *\n * `takeUntil` subscribes and begins mirroring the source Observable. It also\n * monitors a second Observable, `notifier` that you provide. If the `notifier`\n * emits a value or a complete notification, the output Observable stops\n * mirroring the source Observable and completes.\n *\n * @example <caption>Tick every second until the first click happens</caption>\n * var interval = Rx.Observable.interval(1000);\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = interval.takeUntil(clicks);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link take}\n * @see {@link takeLast}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @param {Observable} notifier The Observable whose first emitted value will\n * cause the output Observable of `takeUntil` to stop emitting values from the\n * source Observable.\n * @return {Observable<T>} An Observable that emits the values from the source\n * Observable until such time as `notifier` emits its first value.\n * @method takeUntil\n * @owner Observable\n */\nfunction takeUntil(notifier) {\n    return function (source) { return source.lift(new TakeUntilOperator(notifier)); };\n}\nexports.takeUntil = takeUntil;\nvar TakeUntilOperator = (function () {\n    function TakeUntilOperator(notifier) {\n        this.notifier = notifier;\n    }\n    TakeUntilOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new TakeUntilSubscriber(subscriber, this.notifier));\n    };\n    return TakeUntilOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar TakeUntilSubscriber = (function (_super) {\n    __extends(TakeUntilSubscriber, _super);\n    function TakeUntilSubscriber(destination, notifier) {\n        _super.call(this, destination);\n        this.notifier = notifier;\n        this.add(subscribeToResult_1.subscribeToResult(this, notifier));\n    }\n    TakeUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.complete();\n    };\n    TakeUntilSubscriber.prototype.notifyComplete = function () {\n        // noop\n    };\n    return TakeUntilSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=takeUntil.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/operators/takeUntil.js?");

/***/ }),

/***/ "./node_modules/rxjs/operators/tap.js":
/*!********************************************!*\
  !*** ./node_modules/rxjs/operators/tap.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(/*! ../Subscriber */ \"./node_modules/rxjs/Subscriber.js\");\n/* tslint:enable:max-line-length */\n/**\n * Perform a side effect for every emission on the source Observable, but return\n * an Observable that is identical to the source.\n *\n * <span class=\"informal\">Intercepts each emission on the source and runs a\n * function, but returns an output which is identical to the source as long as errors don't occur.</span>\n *\n * <img src=\"./img/do.png\" width=\"100%\">\n *\n * Returns a mirrored Observable of the source Observable, but modified so that\n * the provided Observer is called to perform a side effect for every value,\n * error, and completion emitted by the source. Any errors that are thrown in\n * the aforementioned Observer or handlers are safely sent down the error path\n * of the output Observable.\n *\n * This operator is useful for debugging your Observables for the correct values\n * or performing other side effects.\n *\n * Note: this is different to a `subscribe` on the Observable. If the Observable\n * returned by `do` is not subscribed, the side effects specified by the\n * Observer will never happen. `do` therefore simply spies on existing\n * execution, it does not trigger an execution to happen like `subscribe` does.\n *\n * @example <caption>Map every click to the clientX position of that click, while also logging the click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var positions = clicks\n *   .do(ev => console.log(ev))\n *   .map(ev => ev.clientX);\n * positions.subscribe(x => console.log(x));\n *\n * @see {@link map}\n * @see {@link subscribe}\n *\n * @param {Observer|function} [nextOrObserver] A normal Observer object or a\n * callback for `next`.\n * @param {function} [error] Callback for errors in the source.\n * @param {function} [complete] Callback for the completion of the source.\n * @return {Observable} An Observable identical to the source, but runs the\n * specified Observer or callback(s) for each item.\n * @name tap\n */\nfunction tap(nextOrObserver, error, complete) {\n    return function tapOperatorFunction(source) {\n        return source.lift(new DoOperator(nextOrObserver, error, complete));\n    };\n}\nexports.tap = tap;\nvar DoOperator = (function () {\n    function DoOperator(nextOrObserver, error, complete) {\n        this.nextOrObserver = nextOrObserver;\n        this.error = error;\n        this.complete = complete;\n    }\n    DoOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DoSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));\n    };\n    return DoOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DoSubscriber = (function (_super) {\n    __extends(DoSubscriber, _super);\n    function DoSubscriber(destination, nextOrObserver, error, complete) {\n        _super.call(this, destination);\n        var safeSubscriber = new Subscriber_1.Subscriber(nextOrObserver, error, complete);\n        safeSubscriber.syncErrorThrowable = true;\n        this.add(safeSubscriber);\n        this.safeSubscriber = safeSubscriber;\n    }\n    DoSubscriber.prototype._next = function (value) {\n        var safeSubscriber = this.safeSubscriber;\n        safeSubscriber.next(value);\n        if (safeSubscriber.syncErrorThrown) {\n            this.destination.error(safeSubscriber.syncErrorValue);\n        }\n        else {\n            this.destination.next(value);\n        }\n    };\n    DoSubscriber.prototype._error = function (err) {\n        var safeSubscriber = this.safeSubscriber;\n        safeSubscriber.error(err);\n        if (safeSubscriber.syncErrorThrown) {\n            this.destination.error(safeSubscriber.syncErrorValue);\n        }\n        else {\n            this.destination.error(err);\n        }\n    };\n    DoSubscriber.prototype._complete = function () {\n        var safeSubscriber = this.safeSubscriber;\n        safeSubscriber.complete();\n        if (safeSubscriber.syncErrorThrown) {\n            this.destination.error(safeSubscriber.syncErrorValue);\n        }\n        else {\n            this.destination.complete();\n        }\n    };\n    return DoSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=tap.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/operators/tap.js?");

/***/ }),

/***/ "./node_modules/rxjs/operators/timeout.js":
/*!************************************************!*\
  !*** ./node_modules/rxjs/operators/timeout.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar async_1 = __webpack_require__(/*! ../scheduler/async */ \"./node_modules/rxjs/scheduler/async.js\");\nvar isDate_1 = __webpack_require__(/*! ../util/isDate */ \"./node_modules/rxjs/util/isDate.js\");\nvar Subscriber_1 = __webpack_require__(/*! ../Subscriber */ \"./node_modules/rxjs/Subscriber.js\");\nvar TimeoutError_1 = __webpack_require__(/*! ../util/TimeoutError */ \"./node_modules/rxjs/util/TimeoutError.js\");\n/**\n *\n * Errors if Observable does not emit a value in given time span.\n *\n * <span class=\"informal\">Timeouts on Observable that doesn't emit values fast enough.</span>\n *\n * <img src=\"./img/timeout.png\" width=\"100%\">\n *\n * `timeout` operator accepts as an argument either a number or a Date.\n *\n * If number was provided, it returns an Observable that behaves like a source\n * Observable, unless there is a period of time where there is no value emitted.\n * So if you provide `100` as argument and first value comes after 50ms from\n * the moment of subscription, this value will be simply re-emitted by the resulting\n * Observable. If however after that 100ms passes without a second value being emitted,\n * stream will end with an error and source Observable will be unsubscribed.\n * These checks are performed throughout whole lifecycle of Observable - from the moment\n * it was subscribed to, until it completes or errors itself. Thus every value must be\n * emitted within specified period since previous value.\n *\n * If provided argument was Date, returned Observable behaves differently. It throws\n * if Observable did not complete before provided Date. This means that periods between\n * emission of particular values do not matter in this case. If Observable did not complete\n * before provided Date, source Observable will be unsubscribed. Other than that, resulting\n * stream behaves just as source Observable.\n *\n * `timeout` accepts also a Scheduler as a second parameter. It is used to schedule moment (or moments)\n * when returned Observable will check if source stream emitted value or completed.\n *\n * @example <caption>Check if ticks are emitted within certain timespan</caption>\n * const seconds = Rx.Observable.interval(1000);\n *\n * seconds.timeout(1100) // Let's use bigger timespan to be safe,\n *                       // since `interval` might fire a bit later then scheduled.\n * .subscribe(\n *     value => console.log(value), // Will emit numbers just as regular `interval` would.\n *     err => console.log(err) // Will never be called.\n * );\n *\n * seconds.timeout(900).subscribe(\n *     value => console.log(value), // Will never be called.\n *     err => console.log(err) // Will emit error before even first value is emitted,\n *                             // since it did not arrive within 900ms period.\n * );\n *\n * @example <caption>Use Date to check if Observable completed</caption>\n * const seconds = Rx.Observable.interval(1000);\n *\n * seconds.timeout(new Date(\"December 17, 2020 03:24:00\"))\n * .subscribe(\n *     value => console.log(value), // Will emit values as regular `interval` would\n *                                  // until December 17, 2020 at 03:24:00.\n *     err => console.log(err) // On December 17, 2020 at 03:24:00 it will emit an error,\n *                             // since Observable did not complete by then.\n * );\n *\n * @see {@link timeoutWith}\n *\n * @param {number|Date} due Number specifying period within which Observable must emit values\n *                          or Date specifying before when Observable should complete\n * @param {Scheduler} [scheduler] Scheduler controlling when timeout checks occur.\n * @return {Observable<T>} Observable that mirrors behaviour of source, unless timeout checks fail.\n * @method timeout\n * @owner Observable\n */\nfunction timeout(due, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    var absoluteTimeout = isDate_1.isDate(due);\n    var waitFor = absoluteTimeout ? (+due - scheduler.now()) : Math.abs(due);\n    return function (source) { return source.lift(new TimeoutOperator(waitFor, absoluteTimeout, scheduler, new TimeoutError_1.TimeoutError())); };\n}\nexports.timeout = timeout;\nvar TimeoutOperator = (function () {\n    function TimeoutOperator(waitFor, absoluteTimeout, scheduler, errorInstance) {\n        this.waitFor = waitFor;\n        this.absoluteTimeout = absoluteTimeout;\n        this.scheduler = scheduler;\n        this.errorInstance = errorInstance;\n    }\n    TimeoutOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new TimeoutSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.scheduler, this.errorInstance));\n    };\n    return TimeoutOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar TimeoutSubscriber = (function (_super) {\n    __extends(TimeoutSubscriber, _super);\n    function TimeoutSubscriber(destination, absoluteTimeout, waitFor, scheduler, errorInstance) {\n        _super.call(this, destination);\n        this.absoluteTimeout = absoluteTimeout;\n        this.waitFor = waitFor;\n        this.scheduler = scheduler;\n        this.errorInstance = errorInstance;\n        this.action = null;\n        this.scheduleTimeout();\n    }\n    TimeoutSubscriber.dispatchTimeout = function (subscriber) {\n        subscriber.error(subscriber.errorInstance);\n    };\n    TimeoutSubscriber.prototype.scheduleTimeout = function () {\n        var action = this.action;\n        if (action) {\n            // Recycle the action if we've already scheduled one. All the production\n            // Scheduler Actions mutate their state/delay time and return themeselves.\n            // VirtualActions are immutable, so they create and return a clone. In this\n            // case, we need to set the action reference to the most recent VirtualAction,\n            // to ensure that's the one we clone from next time.\n            this.action = action.schedule(this, this.waitFor);\n        }\n        else {\n            this.add(this.action = this.scheduler.schedule(TimeoutSubscriber.dispatchTimeout, this.waitFor, this));\n        }\n    };\n    TimeoutSubscriber.prototype._next = function (value) {\n        if (!this.absoluteTimeout) {\n            this.scheduleTimeout();\n        }\n        _super.prototype._next.call(this, value);\n    };\n    TimeoutSubscriber.prototype._unsubscribe = function () {\n        this.action = null;\n        this.scheduler = null;\n        this.errorInstance = null;\n    };\n    return TimeoutSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=timeout.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/operators/timeout.js?");

/***/ }),

/***/ "./node_modules/rxjs/operators/withLatestFrom.js":
/*!*******************************************************!*\
  !*** ./node_modules/rxjs/operators/withLatestFrom.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = __webpack_require__(/*! ../OuterSubscriber */ \"./node_modules/rxjs/OuterSubscriber.js\");\nvar subscribeToResult_1 = __webpack_require__(/*! ../util/subscribeToResult */ \"./node_modules/rxjs/util/subscribeToResult.js\");\n/* tslint:enable:max-line-length */\n/**\n * Combines the source Observable with other Observables to create an Observable\n * whose values are calculated from the latest values of each, only when the\n * source emits.\n *\n * <span class=\"informal\">Whenever the source Observable emits a value, it\n * computes a formula using that value plus the latest values from other input\n * Observables, then emits the output of that formula.</span>\n *\n * <img src=\"./img/withLatestFrom.png\" width=\"100%\">\n *\n * `withLatestFrom` combines each value from the source Observable (the\n * instance) with the latest values from the other input Observables only when\n * the source emits a value, optionally using a `project` function to determine\n * the value to be emitted on the output Observable. All input Observables must\n * emit at least one value before the output Observable will emit a value.\n *\n * @example <caption>On every click event, emit an array with the latest timer event plus the click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var timer = Rx.Observable.interval(1000);\n * var result = clicks.withLatestFrom(timer);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link combineLatest}\n *\n * @param {ObservableInput} other An input Observable to combine with the source\n * Observable. More than one input Observables may be given as argument.\n * @param {Function} [project] Projection function for combining values\n * together. Receives all values in order of the Observables passed, where the\n * first parameter is a value from the source Observable. (e.g.\n * `a.withLatestFrom(b, c, (a1, b1, c1) => a1 + b1 + c1)`). If this is not\n * passed, arrays will be emitted on the output Observable.\n * @return {Observable} An Observable of projected values from the most recent\n * values from each input Observable, or an array of the most recent values from\n * each input Observable.\n * @method withLatestFrom\n * @owner Observable\n */\nfunction withLatestFrom() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i - 0] = arguments[_i];\n    }\n    return function (source) {\n        var project;\n        if (typeof args[args.length - 1] === 'function') {\n            project = args.pop();\n        }\n        var observables = args;\n        return source.lift(new WithLatestFromOperator(observables, project));\n    };\n}\nexports.withLatestFrom = withLatestFrom;\nvar WithLatestFromOperator = (function () {\n    function WithLatestFromOperator(observables, project) {\n        this.observables = observables;\n        this.project = project;\n    }\n    WithLatestFromOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new WithLatestFromSubscriber(subscriber, this.observables, this.project));\n    };\n    return WithLatestFromOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar WithLatestFromSubscriber = (function (_super) {\n    __extends(WithLatestFromSubscriber, _super);\n    function WithLatestFromSubscriber(destination, observables, project) {\n        _super.call(this, destination);\n        this.observables = observables;\n        this.project = project;\n        this.toRespond = [];\n        var len = observables.length;\n        this.values = new Array(len);\n        for (var i = 0; i < len; i++) {\n            this.toRespond.push(i);\n        }\n        for (var i = 0; i < len; i++) {\n            var observable = observables[i];\n            this.add(subscribeToResult_1.subscribeToResult(this, observable, observable, i));\n        }\n    }\n    WithLatestFromSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.values[outerIndex] = innerValue;\n        var toRespond = this.toRespond;\n        if (toRespond.length > 0) {\n            var found = toRespond.indexOf(outerIndex);\n            if (found !== -1) {\n                toRespond.splice(found, 1);\n            }\n        }\n    };\n    WithLatestFromSubscriber.prototype.notifyComplete = function () {\n        // noop\n    };\n    WithLatestFromSubscriber.prototype._next = function (value) {\n        if (this.toRespond.length === 0) {\n            var args = [value].concat(this.values);\n            if (this.project) {\n                this._tryProject(args);\n            }\n            else {\n                this.destination.next(args);\n            }\n        }\n    };\n    WithLatestFromSubscriber.prototype._tryProject = function (args) {\n        var result;\n        try {\n            result = this.project.apply(this, args);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.next(result);\n    };\n    return WithLatestFromSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=withLatestFrom.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/operators/withLatestFrom.js?");

/***/ }),

/***/ "./node_modules/rxjs/scheduler/Action.js":
/*!***********************************************!*\
  !*** ./node_modules/rxjs/scheduler/Action.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscription_1 = __webpack_require__(/*! ../Subscription */ \"./node_modules/rxjs/Subscription.js\");\n/**\n * A unit of work to be executed in a {@link Scheduler}. An action is typically\n * created from within a Scheduler and an RxJS user does not need to concern\n * themselves about creating and manipulating an Action.\n *\n * ```ts\n * class Action<T> extends Subscription {\n *   new (scheduler: Scheduler, work: (state?: T) => void);\n *   schedule(state?: T, delay: number = 0): Subscription;\n * }\n * ```\n *\n * @class Action<T>\n */\nvar Action = (function (_super) {\n    __extends(Action, _super);\n    function Action(scheduler, work) {\n        _super.call(this);\n    }\n    /**\n     * Schedules this action on its parent Scheduler for execution. May be passed\n     * some context object, `state`. May happen at some point in the future,\n     * according to the `delay` parameter, if specified.\n     * @param {T} [state] Some contextual data that the `work` function uses when\n     * called by the Scheduler.\n     * @param {number} [delay] Time to wait before executing the work, where the\n     * time unit is implicit and defined by the Scheduler.\n     * @return {void}\n     */\n    Action.prototype.schedule = function (state, delay) {\n        if (delay === void 0) { delay = 0; }\n        return this;\n    };\n    return Action;\n}(Subscription_1.Subscription));\nexports.Action = Action;\n//# sourceMappingURL=Action.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/scheduler/Action.js?");

/***/ }),

/***/ "./node_modules/rxjs/scheduler/AsyncAction.js":
/*!****************************************************!*\
  !*** ./node_modules/rxjs/scheduler/AsyncAction.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar root_1 = __webpack_require__(/*! ../util/root */ \"./node_modules/rxjs/util/root.js\");\nvar Action_1 = __webpack_require__(/*! ./Action */ \"./node_modules/rxjs/scheduler/Action.js\");\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar AsyncAction = (function (_super) {\n    __extends(AsyncAction, _super);\n    function AsyncAction(scheduler, work) {\n        _super.call(this, scheduler, work);\n        this.scheduler = scheduler;\n        this.work = work;\n        this.pending = false;\n    }\n    AsyncAction.prototype.schedule = function (state, delay) {\n        if (delay === void 0) { delay = 0; }\n        if (this.closed) {\n            return this;\n        }\n        // Always replace the current state with the new state.\n        this.state = state;\n        // Set the pending flag indicating that this action has been scheduled, or\n        // has recursively rescheduled itself.\n        this.pending = true;\n        var id = this.id;\n        var scheduler = this.scheduler;\n        //\n        // Important implementation note:\n        //\n        // Actions only execute once by default, unless rescheduled from within the\n        // scheduled callback. This allows us to implement single and repeat\n        // actions via the same code path, without adding API surface area, as well\n        // as mimic traditional recursion but across asynchronous boundaries.\n        //\n        // However, JS runtimes and timers distinguish between intervals achieved by\n        // serial `setTimeout` calls vs. a single `setInterval` call. An interval of\n        // serial `setTimeout` calls can be individually delayed, which delays\n        // scheduling the next `setTimeout`, and so on. `setInterval` attempts to\n        // guarantee the interval callback will be invoked more precisely to the\n        // interval period, regardless of load.\n        //\n        // Therefore, we use `setInterval` to schedule single and repeat actions.\n        // If the action reschedules itself with the same delay, the interval is not\n        // canceled. If the action doesn't reschedule, or reschedules with a\n        // different delay, the interval will be canceled after scheduled callback\n        // execution.\n        //\n        if (id != null) {\n            this.id = this.recycleAsyncId(scheduler, id, delay);\n        }\n        this.delay = delay;\n        // If this action has already an async Id, don't request a new one.\n        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);\n        return this;\n    };\n    AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) { delay = 0; }\n        return root_1.root.setInterval(scheduler.flush.bind(scheduler, this), delay);\n    };\n    AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) { delay = 0; }\n        // If this action is rescheduled with the same delay time, don't clear the interval id.\n        if (delay !== null && this.delay === delay && this.pending === false) {\n            return id;\n        }\n        // Otherwise, if the action's delay time is different from the current delay,\n        // or the action has been rescheduled before it's executed, clear the interval id\n        return root_1.root.clearInterval(id) && undefined || undefined;\n    };\n    /**\n     * Immediately executes this action and the `work` it contains.\n     * @return {any}\n     */\n    AsyncAction.prototype.execute = function (state, delay) {\n        if (this.closed) {\n            return new Error('executing a cancelled action');\n        }\n        this.pending = false;\n        var error = this._execute(state, delay);\n        if (error) {\n            return error;\n        }\n        else if (this.pending === false && this.id != null) {\n            // Dequeue if the action didn't reschedule itself. Don't call\n            // unsubscribe(), because the action could reschedule later.\n            // For example:\n            // ```\n            // scheduler.schedule(function doWork(counter) {\n            //   /* ... I'm a busy worker bee ... */\n            //   var originalAction = this;\n            //   /* wait 100ms before rescheduling the action */\n            //   setTimeout(function () {\n            //     originalAction.schedule(counter + 1);\n            //   }, 100);\n            // }, 1000);\n            // ```\n            this.id = this.recycleAsyncId(this.scheduler, this.id, null);\n        }\n    };\n    AsyncAction.prototype._execute = function (state, delay) {\n        var errored = false;\n        var errorValue = undefined;\n        try {\n            this.work(state);\n        }\n        catch (e) {\n            errored = true;\n            errorValue = !!e && e || new Error(e);\n        }\n        if (errored) {\n            this.unsubscribe();\n            return errorValue;\n        }\n    };\n    AsyncAction.prototype._unsubscribe = function () {\n        var id = this.id;\n        var scheduler = this.scheduler;\n        var actions = scheduler.actions;\n        var index = actions.indexOf(this);\n        this.work = null;\n        this.state = null;\n        this.pending = false;\n        this.scheduler = null;\n        if (index !== -1) {\n            actions.splice(index, 1);\n        }\n        if (id != null) {\n            this.id = this.recycleAsyncId(scheduler, id, null);\n        }\n        this.delay = null;\n    };\n    return AsyncAction;\n}(Action_1.Action));\nexports.AsyncAction = AsyncAction;\n//# sourceMappingURL=AsyncAction.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/scheduler/AsyncAction.js?");

/***/ }),

/***/ "./node_modules/rxjs/scheduler/AsyncScheduler.js":
/*!*******************************************************!*\
  !*** ./node_modules/rxjs/scheduler/AsyncScheduler.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Scheduler_1 = __webpack_require__(/*! ../Scheduler */ \"./node_modules/rxjs/Scheduler.js\");\nvar AsyncScheduler = (function (_super) {\n    __extends(AsyncScheduler, _super);\n    function AsyncScheduler() {\n        _super.apply(this, arguments);\n        this.actions = [];\n        /**\n         * A flag to indicate whether the Scheduler is currently executing a batch of\n         * queued actions.\n         * @type {boolean}\n         */\n        this.active = false;\n        /**\n         * An internal ID used to track the latest asynchronous task such as those\n         * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and\n         * others.\n         * @type {any}\n         */\n        this.scheduled = undefined;\n    }\n    AsyncScheduler.prototype.flush = function (action) {\n        var actions = this.actions;\n        if (this.active) {\n            actions.push(action);\n            return;\n        }\n        var error;\n        this.active = true;\n        do {\n            if (error = action.execute(action.state, action.delay)) {\n                break;\n            }\n        } while (action = actions.shift()); // exhaust the scheduler queue\n        this.active = false;\n        if (error) {\n            while (action = actions.shift()) {\n                action.unsubscribe();\n            }\n            throw error;\n        }\n    };\n    return AsyncScheduler;\n}(Scheduler_1.Scheduler));\nexports.AsyncScheduler = AsyncScheduler;\n//# sourceMappingURL=AsyncScheduler.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/scheduler/AsyncScheduler.js?");

/***/ }),

/***/ "./node_modules/rxjs/scheduler/QueueAction.js":
/*!****************************************************!*\
  !*** ./node_modules/rxjs/scheduler/QueueAction.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar AsyncAction_1 = __webpack_require__(/*! ./AsyncAction */ \"./node_modules/rxjs/scheduler/AsyncAction.js\");\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar QueueAction = (function (_super) {\n    __extends(QueueAction, _super);\n    function QueueAction(scheduler, work) {\n        _super.call(this, scheduler, work);\n        this.scheduler = scheduler;\n        this.work = work;\n    }\n    QueueAction.prototype.schedule = function (state, delay) {\n        if (delay === void 0) { delay = 0; }\n        if (delay > 0) {\n            return _super.prototype.schedule.call(this, state, delay);\n        }\n        this.delay = delay;\n        this.state = state;\n        this.scheduler.flush(this);\n        return this;\n    };\n    QueueAction.prototype.execute = function (state, delay) {\n        return (delay > 0 || this.closed) ?\n            _super.prototype.execute.call(this, state, delay) :\n            this._execute(state, delay);\n    };\n    QueueAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) { delay = 0; }\n        // If delay exists and is greater than 0, or if the delay is null (the\n        // action wasn't rescheduled) but was originally scheduled as an async\n        // action, then recycle as an async action.\n        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {\n            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);\n        }\n        // Otherwise flush the scheduler starting with this action.\n        return scheduler.flush(this);\n    };\n    return QueueAction;\n}(AsyncAction_1.AsyncAction));\nexports.QueueAction = QueueAction;\n//# sourceMappingURL=QueueAction.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/scheduler/QueueAction.js?");

/***/ }),

/***/ "./node_modules/rxjs/scheduler/QueueScheduler.js":
/*!*******************************************************!*\
  !*** ./node_modules/rxjs/scheduler/QueueScheduler.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar AsyncScheduler_1 = __webpack_require__(/*! ./AsyncScheduler */ \"./node_modules/rxjs/scheduler/AsyncScheduler.js\");\nvar QueueScheduler = (function (_super) {\n    __extends(QueueScheduler, _super);\n    function QueueScheduler() {\n        _super.apply(this, arguments);\n    }\n    return QueueScheduler;\n}(AsyncScheduler_1.AsyncScheduler));\nexports.QueueScheduler = QueueScheduler;\n//# sourceMappingURL=QueueScheduler.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/scheduler/QueueScheduler.js?");

/***/ }),

/***/ "./node_modules/rxjs/scheduler/async.js":
/*!**********************************************!*\
  !*** ./node_modules/rxjs/scheduler/async.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar AsyncAction_1 = __webpack_require__(/*! ./AsyncAction */ \"./node_modules/rxjs/scheduler/AsyncAction.js\");\nvar AsyncScheduler_1 = __webpack_require__(/*! ./AsyncScheduler */ \"./node_modules/rxjs/scheduler/AsyncScheduler.js\");\n/**\n *\n * Async Scheduler\n *\n * <span class=\"informal\">Schedule task as if you used setTimeout(task, duration)</span>\n *\n * `async` scheduler schedules tasks asynchronously, by putting them on the JavaScript\n * event loop queue. It is best used to delay tasks in time or to schedule tasks repeating\n * in intervals.\n *\n * If you just want to \"defer\" task, that is to perform it right after currently\n * executing synchronous code ends (commonly achieved by `setTimeout(deferredTask, 0)`),\n * better choice will be the {@link asap} scheduler.\n *\n * @example <caption>Use async scheduler to delay task</caption>\n * const task = () => console.log('it works!');\n *\n * Rx.Scheduler.async.schedule(task, 2000);\n *\n * // After 2 seconds logs:\n * // \"it works!\"\n *\n *\n * @example <caption>Use async scheduler to repeat task in intervals</caption>\n * function task(state) {\n *   console.log(state);\n *   this.schedule(state + 1, 1000); // `this` references currently executing Action,\n *                                   // which we reschedule with new state and delay\n * }\n *\n * Rx.Scheduler.async.schedule(task, 3000, 0);\n *\n * // Logs:\n * // 0 after 3s\n * // 1 after 4s\n * // 2 after 5s\n * // 3 after 6s\n *\n * @static true\n * @name async\n * @owner Scheduler\n */\nexports.async = new AsyncScheduler_1.AsyncScheduler(AsyncAction_1.AsyncAction);\n//# sourceMappingURL=async.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/scheduler/async.js?");

/***/ }),

/***/ "./node_modules/rxjs/scheduler/queue.js":
/*!**********************************************!*\
  !*** ./node_modules/rxjs/scheduler/queue.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar QueueAction_1 = __webpack_require__(/*! ./QueueAction */ \"./node_modules/rxjs/scheduler/QueueAction.js\");\nvar QueueScheduler_1 = __webpack_require__(/*! ./QueueScheduler */ \"./node_modules/rxjs/scheduler/QueueScheduler.js\");\n/**\n *\n * Queue Scheduler\n *\n * <span class=\"informal\">Put every next task on a queue, instead of executing it immediately</span>\n *\n * `queue` scheduler, when used with delay, behaves the same as {@link async} scheduler.\n *\n * When used without delay, it schedules given task synchronously - executes it right when\n * it is scheduled. However when called recursively, that is when inside the scheduled task,\n * another task is scheduled with queue scheduler, instead of executing immediately as well,\n * that task will be put on a queue and wait for current one to finish.\n *\n * This means that when you execute task with `queue` scheduler, you are sure it will end\n * before any other task scheduled with that scheduler will start.\n *\n * @examples <caption>Schedule recursively first, then do something</caption>\n *\n * Rx.Scheduler.queue.schedule(() => {\n *   Rx.Scheduler.queue.schedule(() => console.log('second')); // will not happen now, but will be put on a queue\n *\n *   console.log('first');\n * });\n *\n * // Logs:\n * // \"first\"\n * // \"second\"\n *\n *\n * @example <caption>Reschedule itself recursively</caption>\n *\n * Rx.Scheduler.queue.schedule(function(state) {\n *   if (state !== 0) {\n *     console.log('before', state);\n *     this.schedule(state - 1); // `this` references currently executing Action,\n *                               // which we reschedule with new state\n *     console.log('after', state);\n *   }\n * }, 0, 3);\n *\n * // In scheduler that runs recursively, you would expect:\n * // \"before\", 3\n * // \"before\", 2\n * // \"before\", 1\n * // \"after\", 1\n * // \"after\", 2\n * // \"after\", 3\n *\n * // But with queue it logs:\n * // \"before\", 3\n * // \"after\", 3\n * // \"before\", 2\n * // \"after\", 2\n * // \"before\", 1\n * // \"after\", 1\n *\n *\n * @static true\n * @name queue\n * @owner Scheduler\n */\nexports.queue = new QueueScheduler_1.QueueScheduler(QueueAction_1.QueueAction);\n//# sourceMappingURL=queue.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/scheduler/queue.js?");

/***/ }),

/***/ "./node_modules/rxjs/symbol/iterator.js":
/*!**********************************************!*\
  !*** ./node_modules/rxjs/symbol/iterator.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar root_1 = __webpack_require__(/*! ../util/root */ \"./node_modules/rxjs/util/root.js\");\nfunction symbolIteratorPonyfill(root) {\n    var Symbol = root.Symbol;\n    if (typeof Symbol === 'function') {\n        if (!Symbol.iterator) {\n            Symbol.iterator = Symbol('iterator polyfill');\n        }\n        return Symbol.iterator;\n    }\n    else {\n        // [for Mozilla Gecko 27-35:](https://mzl.la/2ewE1zC)\n        var Set_1 = root.Set;\n        if (Set_1 && typeof new Set_1()['@@iterator'] === 'function') {\n            return '@@iterator';\n        }\n        var Map_1 = root.Map;\n        // required for compatability with es6-shim\n        if (Map_1) {\n            var keys = Object.getOwnPropertyNames(Map_1.prototype);\n            for (var i = 0; i < keys.length; ++i) {\n                var key = keys[i];\n                // according to spec, Map.prototype[@@iterator] and Map.orototype.entries must be equal.\n                if (key !== 'entries' && key !== 'size' && Map_1.prototype[key] === Map_1.prototype['entries']) {\n                    return key;\n                }\n            }\n        }\n        return '@@iterator';\n    }\n}\nexports.symbolIteratorPonyfill = symbolIteratorPonyfill;\nexports.iterator = symbolIteratorPonyfill(root_1.root);\n/**\n * @deprecated use iterator instead\n */\nexports.$$iterator = exports.iterator;\n//# sourceMappingURL=iterator.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/symbol/iterator.js?");

/***/ }),

/***/ "./node_modules/rxjs/symbol/observable.js":
/*!************************************************!*\
  !*** ./node_modules/rxjs/symbol/observable.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar root_1 = __webpack_require__(/*! ../util/root */ \"./node_modules/rxjs/util/root.js\");\nfunction getSymbolObservable(context) {\n    var $$observable;\n    var Symbol = context.Symbol;\n    if (typeof Symbol === 'function') {\n        if (Symbol.observable) {\n            $$observable = Symbol.observable;\n        }\n        else {\n            $$observable = Symbol('observable');\n            Symbol.observable = $$observable;\n        }\n    }\n    else {\n        $$observable = '@@observable';\n    }\n    return $$observable;\n}\nexports.getSymbolObservable = getSymbolObservable;\nexports.observable = getSymbolObservable(root_1.root);\n/**\n * @deprecated use observable instead\n */\nexports.$$observable = exports.observable;\n//# sourceMappingURL=observable.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/symbol/observable.js?");

/***/ }),

/***/ "./node_modules/rxjs/symbol/rxSubscriber.js":
/*!**************************************************!*\
  !*** ./node_modules/rxjs/symbol/rxSubscriber.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar root_1 = __webpack_require__(/*! ../util/root */ \"./node_modules/rxjs/util/root.js\");\nvar Symbol = root_1.root.Symbol;\nexports.rxSubscriber = (typeof Symbol === 'function' && typeof Symbol.for === 'function') ?\n    Symbol.for('rxSubscriber') : '@@rxSubscriber';\n/**\n * @deprecated use rxSubscriber instead\n */\nexports.$$rxSubscriber = exports.rxSubscriber;\n//# sourceMappingURL=rxSubscriber.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/symbol/rxSubscriber.js?");

/***/ }),

/***/ "./node_modules/rxjs/util/ArgumentOutOfRangeError.js":
/*!***********************************************************!*\
  !*** ./node_modules/rxjs/util/ArgumentOutOfRangeError.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/**\n * An error thrown when an element was queried at a certain index of an\n * Observable, but no such index or position exists in that sequence.\n *\n * @see {@link elementAt}\n * @see {@link take}\n * @see {@link takeLast}\n *\n * @class ArgumentOutOfRangeError\n */\nvar ArgumentOutOfRangeError = (function (_super) {\n    __extends(ArgumentOutOfRangeError, _super);\n    function ArgumentOutOfRangeError() {\n        var err = _super.call(this, 'argument out of range');\n        this.name = err.name = 'ArgumentOutOfRangeError';\n        this.stack = err.stack;\n        this.message = err.message;\n    }\n    return ArgumentOutOfRangeError;\n}(Error));\nexports.ArgumentOutOfRangeError = ArgumentOutOfRangeError;\n//# sourceMappingURL=ArgumentOutOfRangeError.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/util/ArgumentOutOfRangeError.js?");

/***/ }),

/***/ "./node_modules/rxjs/util/ObjectUnsubscribedError.js":
/*!***********************************************************!*\
  !*** ./node_modules/rxjs/util/ObjectUnsubscribedError.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/**\n * An error thrown when an action is invalid because the object has been\n * unsubscribed.\n *\n * @see {@link Subject}\n * @see {@link BehaviorSubject}\n *\n * @class ObjectUnsubscribedError\n */\nvar ObjectUnsubscribedError = (function (_super) {\n    __extends(ObjectUnsubscribedError, _super);\n    function ObjectUnsubscribedError() {\n        var err = _super.call(this, 'object unsubscribed');\n        this.name = err.name = 'ObjectUnsubscribedError';\n        this.stack = err.stack;\n        this.message = err.message;\n    }\n    return ObjectUnsubscribedError;\n}(Error));\nexports.ObjectUnsubscribedError = ObjectUnsubscribedError;\n//# sourceMappingURL=ObjectUnsubscribedError.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/util/ObjectUnsubscribedError.js?");

/***/ }),

/***/ "./node_modules/rxjs/util/TimeoutError.js":
/*!************************************************!*\
  !*** ./node_modules/rxjs/util/TimeoutError.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/**\n * An error thrown when duetime elapses.\n *\n * @see {@link timeout}\n *\n * @class TimeoutError\n */\nvar TimeoutError = (function (_super) {\n    __extends(TimeoutError, _super);\n    function TimeoutError() {\n        var err = _super.call(this, 'Timeout has occurred');\n        this.name = err.name = 'TimeoutError';\n        this.stack = err.stack;\n        this.message = err.message;\n    }\n    return TimeoutError;\n}(Error));\nexports.TimeoutError = TimeoutError;\n//# sourceMappingURL=TimeoutError.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/util/TimeoutError.js?");

/***/ }),

/***/ "./node_modules/rxjs/util/UnsubscriptionError.js":
/*!*******************************************************!*\
  !*** ./node_modules/rxjs/util/UnsubscriptionError.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/**\n * An error thrown when one or more errors have occurred during the\n * `unsubscribe` of a {@link Subscription}.\n */\nvar UnsubscriptionError = (function (_super) {\n    __extends(UnsubscriptionError, _super);\n    function UnsubscriptionError(errors) {\n        _super.call(this);\n        this.errors = errors;\n        var err = Error.call(this, errors ?\n            errors.length + \" errors occurred during unsubscription:\\n  \" + errors.map(function (err, i) { return ((i + 1) + \") \" + err.toString()); }).join('\\n  ') : '');\n        this.name = err.name = 'UnsubscriptionError';\n        this.stack = err.stack;\n        this.message = err.message;\n    }\n    return UnsubscriptionError;\n}(Error));\nexports.UnsubscriptionError = UnsubscriptionError;\n//# sourceMappingURL=UnsubscriptionError.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/util/UnsubscriptionError.js?");

/***/ }),

/***/ "./node_modules/rxjs/util/errorObject.js":
/*!***********************************************!*\
  !*** ./node_modules/rxjs/util/errorObject.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// typeof any so that it we don't have to cast when comparing a result to the error object\nexports.errorObject = { e: {} };\n//# sourceMappingURL=errorObject.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/util/errorObject.js?");

/***/ }),

/***/ "./node_modules/rxjs/util/identity.js":
/*!********************************************!*\
  !*** ./node_modules/rxjs/util/identity.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nfunction identity(x) {\n    return x;\n}\nexports.identity = identity;\n//# sourceMappingURL=identity.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/util/identity.js?");

/***/ }),

/***/ "./node_modules/rxjs/util/isArray.js":
/*!*******************************************!*\
  !*** ./node_modules/rxjs/util/isArray.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nexports.isArray = Array.isArray || (function (x) { return x && typeof x.length === 'number'; });\n//# sourceMappingURL=isArray.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/util/isArray.js?");

/***/ }),

/***/ "./node_modules/rxjs/util/isArrayLike.js":
/*!***********************************************!*\
  !*** ./node_modules/rxjs/util/isArrayLike.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nexports.isArrayLike = (function (x) { return x && typeof x.length === 'number'; });\n//# sourceMappingURL=isArrayLike.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/util/isArrayLike.js?");

/***/ }),

/***/ "./node_modules/rxjs/util/isDate.js":
/*!******************************************!*\
  !*** ./node_modules/rxjs/util/isDate.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nfunction isDate(value) {\n    return value instanceof Date && !isNaN(+value);\n}\nexports.isDate = isDate;\n//# sourceMappingURL=isDate.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/util/isDate.js?");

/***/ }),

/***/ "./node_modules/rxjs/util/isFunction.js":
/*!**********************************************!*\
  !*** ./node_modules/rxjs/util/isFunction.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nfunction isFunction(x) {\n    return typeof x === 'function';\n}\nexports.isFunction = isFunction;\n//# sourceMappingURL=isFunction.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/util/isFunction.js?");

/***/ }),

/***/ "./node_modules/rxjs/util/isNumeric.js":
/*!*********************************************!*\
  !*** ./node_modules/rxjs/util/isNumeric.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar isArray_1 = __webpack_require__(/*! ../util/isArray */ \"./node_modules/rxjs/util/isArray.js\");\nfunction isNumeric(val) {\n    // parseFloat NaNs numeric-cast false positives (null|true|false|\"\")\n    // ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n    // subtraction forces infinities to NaN\n    // adding 1 corrects loss of precision from parseFloat (#15100)\n    return !isArray_1.isArray(val) && (val - parseFloat(val) + 1) >= 0;\n}\nexports.isNumeric = isNumeric;\n;\n//# sourceMappingURL=isNumeric.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/util/isNumeric.js?");

/***/ }),

/***/ "./node_modules/rxjs/util/isObject.js":
/*!********************************************!*\
  !*** ./node_modules/rxjs/util/isObject.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nfunction isObject(x) {\n    return x != null && typeof x === 'object';\n}\nexports.isObject = isObject;\n//# sourceMappingURL=isObject.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/util/isObject.js?");

/***/ }),

/***/ "./node_modules/rxjs/util/isPromise.js":
/*!*********************************************!*\
  !*** ./node_modules/rxjs/util/isPromise.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nfunction isPromise(value) {\n    return value && typeof value.subscribe !== 'function' && typeof value.then === 'function';\n}\nexports.isPromise = isPromise;\n//# sourceMappingURL=isPromise.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/util/isPromise.js?");

/***/ }),

/***/ "./node_modules/rxjs/util/isScheduler.js":
/*!***********************************************!*\
  !*** ./node_modules/rxjs/util/isScheduler.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nfunction isScheduler(value) {\n    return value && typeof value.schedule === 'function';\n}\nexports.isScheduler = isScheduler;\n//# sourceMappingURL=isScheduler.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/util/isScheduler.js?");

/***/ }),

/***/ "./node_modules/rxjs/util/noop.js":
/*!****************************************!*\
  !*** ./node_modules/rxjs/util/noop.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/* tslint:disable:no-empty */\nfunction noop() { }\nexports.noop = noop;\n//# sourceMappingURL=noop.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/util/noop.js?");

/***/ }),

/***/ "./node_modules/rxjs/util/pipe.js":
/*!****************************************!*\
  !*** ./node_modules/rxjs/util/pipe.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar noop_1 = __webpack_require__(/*! ./noop */ \"./node_modules/rxjs/util/noop.js\");\n/* tslint:enable:max-line-length */\nfunction pipe() {\n    var fns = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        fns[_i - 0] = arguments[_i];\n    }\n    return pipeFromArray(fns);\n}\nexports.pipe = pipe;\n/* @internal */\nfunction pipeFromArray(fns) {\n    if (!fns) {\n        return noop_1.noop;\n    }\n    if (fns.length === 1) {\n        return fns[0];\n    }\n    return function piped(input) {\n        return fns.reduce(function (prev, fn) { return fn(prev); }, input);\n    };\n}\nexports.pipeFromArray = pipeFromArray;\n//# sourceMappingURL=pipe.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/util/pipe.js?");

/***/ }),

/***/ "./node_modules/rxjs/util/root.js":
/*!****************************************!*\
  !*** ./node_modules/rxjs/util/root.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {\n// CommonJS / Node have global context exposed as \"global\" variable.\n// We don't want to include the whole node.d.ts this this compilation unit so we'll just fake\n// the global \"global\" var for now.\nvar __window = typeof window !== 'undefined' && window;\nvar __self = typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' &&\n    self instanceof WorkerGlobalScope && self;\nvar __global = typeof global !== 'undefined' && global;\nvar _root = __window || __global || __self;\nexports.root = _root;\n// Workaround Closure Compiler restriction: The body of a goog.module cannot use throw.\n// This is needed when used with angular/tsickle which inserts a goog.module statement.\n// Wrap in IIFE\n(function () {\n    if (!_root) {\n        throw new Error('RxJS could not find any global context (window, self, global)');\n    }\n})();\n//# sourceMappingURL=root.js.map\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/util/root.js?");

/***/ }),

/***/ "./node_modules/rxjs/util/subscribeToResult.js":
/*!*****************************************************!*\
  !*** ./node_modules/rxjs/util/subscribeToResult.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar root_1 = __webpack_require__(/*! ./root */ \"./node_modules/rxjs/util/root.js\");\nvar isArrayLike_1 = __webpack_require__(/*! ./isArrayLike */ \"./node_modules/rxjs/util/isArrayLike.js\");\nvar isPromise_1 = __webpack_require__(/*! ./isPromise */ \"./node_modules/rxjs/util/isPromise.js\");\nvar isObject_1 = __webpack_require__(/*! ./isObject */ \"./node_modules/rxjs/util/isObject.js\");\nvar Observable_1 = __webpack_require__(/*! ../Observable */ \"./node_modules/rxjs/Observable.js\");\nvar iterator_1 = __webpack_require__(/*! ../symbol/iterator */ \"./node_modules/rxjs/symbol/iterator.js\");\nvar InnerSubscriber_1 = __webpack_require__(/*! ../InnerSubscriber */ \"./node_modules/rxjs/InnerSubscriber.js\");\nvar observable_1 = __webpack_require__(/*! ../symbol/observable */ \"./node_modules/rxjs/symbol/observable.js\");\nfunction subscribeToResult(outerSubscriber, result, outerValue, outerIndex) {\n    var destination = new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex);\n    if (destination.closed) {\n        return null;\n    }\n    if (result instanceof Observable_1.Observable) {\n        if (result._isScalar) {\n            destination.next(result.value);\n            destination.complete();\n            return null;\n        }\n        else {\n            destination.syncErrorThrowable = true;\n            return result.subscribe(destination);\n        }\n    }\n    else if (isArrayLike_1.isArrayLike(result)) {\n        for (var i = 0, len = result.length; i < len && !destination.closed; i++) {\n            destination.next(result[i]);\n        }\n        if (!destination.closed) {\n            destination.complete();\n        }\n    }\n    else if (isPromise_1.isPromise(result)) {\n        result.then(function (value) {\n            if (!destination.closed) {\n                destination.next(value);\n                destination.complete();\n            }\n        }, function (err) { return destination.error(err); })\n            .then(null, function (err) {\n            // Escaping the Promise trap: globally throw unhandled errors\n            root_1.root.setTimeout(function () { throw err; });\n        });\n        return destination;\n    }\n    else if (result && typeof result[iterator_1.iterator] === 'function') {\n        var iterator = result[iterator_1.iterator]();\n        do {\n            var item = iterator.next();\n            if (item.done) {\n                destination.complete();\n                break;\n            }\n            destination.next(item.value);\n            if (destination.closed) {\n                break;\n            }\n        } while (true);\n    }\n    else if (result && typeof result[observable_1.observable] === 'function') {\n        var obs = result[observable_1.observable]();\n        if (typeof obs.subscribe !== 'function') {\n            destination.error(new TypeError('Provided object does not correctly implement Symbol.observable'));\n        }\n        else {\n            return obs.subscribe(new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex));\n        }\n    }\n    else {\n        var value = isObject_1.isObject(result) ? 'an invalid object' : \"'\" + result + \"'\";\n        var msg = (\"You provided \" + value + \" where a stream was expected.\")\n            + ' You can provide an Observable, Promise, Array, or Iterable.';\n        destination.error(new TypeError(msg));\n    }\n    return null;\n}\nexports.subscribeToResult = subscribeToResult;\n//# sourceMappingURL=subscribeToResult.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/util/subscribeToResult.js?");

/***/ }),

/***/ "./node_modules/rxjs/util/toSubscriber.js":
/*!************************************************!*\
  !*** ./node_modules/rxjs/util/toSubscriber.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Subscriber_1 = __webpack_require__(/*! ../Subscriber */ \"./node_modules/rxjs/Subscriber.js\");\nvar rxSubscriber_1 = __webpack_require__(/*! ../symbol/rxSubscriber */ \"./node_modules/rxjs/symbol/rxSubscriber.js\");\nvar Observer_1 = __webpack_require__(/*! ../Observer */ \"./node_modules/rxjs/Observer.js\");\nfunction toSubscriber(nextOrObserver, error, complete) {\n    if (nextOrObserver) {\n        if (nextOrObserver instanceof Subscriber_1.Subscriber) {\n            return nextOrObserver;\n        }\n        if (nextOrObserver[rxSubscriber_1.rxSubscriber]) {\n            return nextOrObserver[rxSubscriber_1.rxSubscriber]();\n        }\n    }\n    if (!nextOrObserver && !error && !complete) {\n        return new Subscriber_1.Subscriber(Observer_1.empty);\n    }\n    return new Subscriber_1.Subscriber(nextOrObserver, error, complete);\n}\nexports.toSubscriber = toSubscriber;\n//# sourceMappingURL=toSubscriber.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/util/toSubscriber.js?");

/***/ }),

/***/ "./node_modules/rxjs/util/tryCatch.js":
/*!********************************************!*\
  !*** ./node_modules/rxjs/util/tryCatch.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar errorObject_1 = __webpack_require__(/*! ./errorObject */ \"./node_modules/rxjs/util/errorObject.js\");\nvar tryCatchTarget;\nfunction tryCatcher() {\n    try {\n        return tryCatchTarget.apply(this, arguments);\n    }\n    catch (e) {\n        errorObject_1.errorObject.e = e;\n        return errorObject_1.errorObject;\n    }\n}\nfunction tryCatch(fn) {\n    tryCatchTarget = fn;\n    return tryCatcher;\n}\nexports.tryCatch = tryCatch;\n;\n//# sourceMappingURL=tryCatch.js.map\n\n//# sourceURL=webpack://RxPlayer/./node_modules/rxjs/util/tryCatch.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\r\n} catch (e) {\r\n\t// This works if the window reference is available\r\n\tif (typeof window === \"object\") g = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n//# sourceURL=webpack://RxPlayer/(webpack)/buildin/global.js?");

/***/ }),

/***/ "./src/compat/constants.ts":
/*!*********************************!*\
  !*** ./src/compat/constants.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar MediaError_1 = __webpack_require__(/*! ../errors/MediaError */ \"./src/errors/MediaError.ts\");\nvar BROWSER_PREFIXES = [\"\", \"webkit\", \"moz\", \"ms\"];\nexports.BROWSER_PREFIXES = BROWSER_PREFIXES;\nvar win = window;\nvar HTMLElement_ = win.HTMLElement;\nexports.HTMLElement_ = HTMLElement_;\nvar VTTCue_ = win.VTTCue || win.TextTrackCue;\nexports.VTTCue_ = VTTCue_;\nvar MediaSource_ = (win.MediaSource ||\n    win.MozMediaSource ||\n    win.WebKitMediaSource ||\n    win.MSMediaSource);\nexports.MediaSource_ = MediaSource_;\nvar MediaKeys_ = (win.MediaKeys ||\n    win.MozMediaKeys ||\n    win.WebKitMediaKeys ||\n    win.MSMediaKeys);\nexports.MediaKeys_ = MediaKeys_;\nif (!MediaKeys_) {\n    var noMediaKeys_1 = function () {\n        throw new MediaError_1.default(\"MEDIA_KEYS_NOT_SUPPORTED\", null, true);\n    };\n    exports.MediaKeys_ = MediaKeys_ = /** @class */ (function () {\n        function class_1() {\n            this.create = noMediaKeys_1;\n            this.createSession = noMediaKeys_1;\n            this.isTypeSupported = noMediaKeys_1;\n            this.setServerCertificate = noMediaKeys_1;\n        }\n        return class_1;\n    }());\n}\n// true for IE / Edge\nvar isIE = (navigator.appName === \"Microsoft Internet Explorer\" ||\n    navigator.appName === \"Netscape\" && /(Trident|Edge)\\//.test(navigator.userAgent));\nexports.isIE = isIE;\nvar isFirefox = (navigator.userAgent.toLowerCase().indexOf(\"firefox\") !== -1);\nexports.isFirefox = isFirefox;\nvar READY_STATES = {\n    HAVE_NOTHING: 0,\n    HAVE_METADATA: 1,\n    HAVE_CURRENT_DATA: 2,\n    HAVE_FUTURE_DATA: 3,\n    HAVE_ENOUGH_DATA: 4,\n};\nexports.READY_STATES = READY_STATES;\n\n\n//# sourceURL=webpack://RxPlayer/./src/compat/constants.ts?");

/***/ }),

/***/ "./src/compat/eme/MediaKeys.ts":
/*!*************************************!*\
  !*** ./src/compat/eme/MediaKeys.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Observable_1 = __webpack_require__(/*! rxjs/Observable */ \"./node_modules/rxjs/Observable.js\");\nvar Subject_1 = __webpack_require__(/*! rxjs/Subject */ \"./node_modules/rxjs/Subject.js\");\nvar bytes_1 = __webpack_require__(/*! ../../utils/bytes */ \"./src/utils/bytes.ts\");\nvar castToObservable_1 = __webpack_require__(/*! ../../utils/castToObservable */ \"./src/utils/castToObservable.ts\");\nvar eventemitter_1 = __webpack_require__(/*! ../../utils/eventemitter */ \"./src/utils/eventemitter.ts\");\nvar constants_1 = __webpack_require__(/*! ../constants */ \"./src/compat/constants.ts\");\nvar events = __webpack_require__(/*! ../events */ \"./src/compat/events.ts\");\nvar keySystemAccess_1 = __webpack_require__(/*! ./keySystemAccess */ \"./src/compat/eme/keySystemAccess.ts\");\nvar requestMediaKeySystemAccess;\nexports.requestMediaKeySystemAccess = requestMediaKeySystemAccess;\n// Default MockMediaKeys implementation\nvar MockMediaKeys = /** @class */ (function () {\n    function class_1() {\n    }\n    class_1.prototype._setVideo = function () {\n        throw new Error(\"MediaKeys is not implemented in your browser\");\n    };\n    class_1.prototype.createSession = function () {\n        throw new Error(\"MediaKeys is not implemented in your browser\");\n    };\n    class_1.prototype.setServerCertificate = function () {\n        throw new Error(\"MediaKeys is not implemented in your browser\");\n    };\n    return class_1;\n}());\nexports.MockMediaKeys = MockMediaKeys;\nif (navigator.requestMediaKeySystemAccess) {\n    exports.requestMediaKeySystemAccess = requestMediaKeySystemAccess = function (a, b) {\n        return castToObservable_1.default(navigator.requestMediaKeySystemAccess(a, b));\n    };\n}\nelse {\n    // Wrap \"MediaKeys.prototype.update\" form an event based system to a\n    // Promise based function.\n    var wrapUpdate_1 = function (memUpdate) {\n        return function (license, sessionId) {\n            var _this = this;\n            return new Promise(function (resolve, reject) {\n                try {\n                    memUpdate.call(_this, license, sessionId);\n                    resolve();\n                }\n                catch (e) {\n                    reject(e);\n                }\n            });\n        };\n    };\n    // This is for Chrome with unprefixed EME api\n    if (HTMLVideoElement.prototype.webkitGenerateKeyRequest) {\n        var WebkitMediaKeySession_1 = /** @class */ (function (_super) {\n            __extends(WebkitMediaKeySession, _super);\n            function WebkitMediaKeySession(video, keySystem) {\n                var _this = _super.call(this) || this;\n                _this._closeSession$ = new Subject_1.Subject();\n                _this._vid = video;\n                _this._key = keySystem;\n                _this.sessionId = \"\";\n                _this.closed = new Promise(function (resolve) {\n                    _this._closeSession$.subscribe(resolve);\n                });\n                _this.keyStatuses = new Map();\n                _this.expiration = NaN;\n                Observable_1.Observable.merge(events.onKeyMessage$(video), events.onKeyAdded$(video), events.onKeyError$(video))\n                    .takeUntil(_this._closeSession$)\n                    .subscribe(function (evt) { return _this.trigger(evt.type, evt); });\n                _this.update = wrapUpdate_1(function (license, sessionId) {\n                    if (_this._key.indexOf(\"clearkey\") >= 0) {\n                        var json = JSON.parse(bytes_1.bytesToStr(license));\n                        var key = bytes_1.strToBytes(atob(json.keys[0].k));\n                        var kid = bytes_1.strToBytes(atob(json.keys[0].kid));\n                        _this._vid.webkitAddKey(_this._key, key, kid, sessionId);\n                    }\n                    else {\n                        _this._vid.webkitAddKey(_this._key, license, null, sessionId);\n                    }\n                    _this.sessionId = sessionId;\n                });\n                return _this;\n            }\n            WebkitMediaKeySession.prototype.generateRequest = function (_initDataType, initData) {\n                var _this = this;\n                return new Promise(function (resolve) {\n                    if (typeof _this._vid.webkitGenerateKeyRequest !== \"function\") {\n                        throw new Error(\"impossible to generate a key request\");\n                    }\n                    _this._vid.webkitGenerateKeyRequest(_this._key, initData);\n                    resolve();\n                });\n            };\n            WebkitMediaKeySession.prototype.close = function () {\n                var _this = this;\n                return new Promise(function (resolve) {\n                    _this._closeSession$.next();\n                    _this._closeSession$.complete();\n                    resolve();\n                });\n            };\n            WebkitMediaKeySession.prototype.load = function () {\n                return Promise.resolve(false);\n            };\n            WebkitMediaKeySession.prototype.remove = function () {\n                return Promise.resolve();\n            };\n            return WebkitMediaKeySession;\n        }(eventemitter_1.default));\n        exports.MockMediaKeys = MockMediaKeys = /** @class */ (function () {\n            function class_2(keySystem) {\n                this.ks_ = keySystem;\n            }\n            class_2.prototype._setVideo = function (vid) {\n                this._vid = vid;\n            };\n            class_2.prototype.createSession = function ( /* sessionType */) {\n                if (!this._vid) {\n                    throw new Error(\"Video not attached to the MediaKeys\");\n                }\n                return new WebkitMediaKeySession_1(this._vid, this.ks_);\n            };\n            class_2.prototype.setServerCertificate = function () {\n                throw new Error(\"Server certificate is not implemented in your browser\");\n            };\n            return class_2;\n        }());\n        var isTypeSupported_1 = function (keyType) {\n            // get any <video> element from the DOM or create one\n            // and try the `canPlayType` method\n            var video = document.querySelector(\"video\") ||\n                document.createElement(\"video\");\n            if (video && video.canPlayType) {\n                return !!video.canPlayType(\"video/mp4\", keyType);\n            }\n            else {\n                return false;\n            }\n        };\n        exports.requestMediaKeySystemAccess = requestMediaKeySystemAccess = function (keyType, keySystemConfigurations) {\n            if (!isTypeSupported_1(keyType)) {\n                return Observable_1.Observable.throw(undefined);\n            }\n            for (var i = 0; i < keySystemConfigurations.length; i++) {\n                var keySystemConfiguration = keySystemConfigurations[i];\n                var videoCapabilities = keySystemConfiguration.videoCapabilities, audioCapabilities = keySystemConfiguration.audioCapabilities, initDataTypes = keySystemConfiguration.initDataTypes, sessionTypes = keySystemConfiguration.sessionTypes, distinctiveIdentifier = keySystemConfiguration.distinctiveIdentifier, persistentState = keySystemConfiguration.persistentState;\n                var supported = true;\n                supported = supported && (!initDataTypes ||\n                    !!initDataTypes.filter(function (initDataType) { return initDataType === \"cenc\"; })[0]);\n                supported = supported && (!sessionTypes ||\n                    sessionTypes\n                        .filter(function (sessionType) { return sessionType === \"temporary\"; })\n                        .length === sessionTypes.length);\n                supported = supported && (distinctiveIdentifier !== \"required\");\n                supported = supported && (persistentState !== \"required\");\n                if (supported) {\n                    var keySystemConfigurationResponse = {\n                        videoCapabilities: videoCapabilities,\n                        audioCapabilities: audioCapabilities,\n                        initDataTypes: [\"cenc\"],\n                        sessionTypes: [\"temporary\"],\n                        // TODO TypesScript bug or what? Check and open an issue\n                        distinctiveIdentifier: \"not-allowed\",\n                        persistentState: \"not-allowed\",\n                    };\n                    return Observable_1.Observable.of(new keySystemAccess_1.default(keyType, new MockMediaKeys(keyType), keySystemConfigurationResponse));\n                }\n            }\n            return Observable_1.Observable.throw(undefined);\n        };\n    }\n    // This is for IE11\n    else if (constants_1.MediaKeys_ &&\n        constants_1.MediaKeys_.prototype &&\n        typeof constants_1.MediaKeys_.prototype.createSession === \"function\" &&\n        typeof constants_1.MediaKeys_.isTypeSupported === \"function\") {\n        // TODO implement MediaKeySession completely\n        var IE11MediaKeySession_1 = /** @class */ (function (_super) {\n            __extends(IE11MediaKeySession, _super);\n            function IE11MediaKeySession(mk) {\n                var _this = _super.call(this) || this;\n                _this.sessionId = \"\";\n                _this.expiration = NaN;\n                _this.keyStatuses = new Map();\n                _this._mk = mk;\n                _this._closeSession$ = new Subject_1.Subject();\n                _this.closed = new Promise(function (resolve) {\n                    _this._closeSession$.subscribe(resolve);\n                });\n                _this.update = wrapUpdate_1(function (license, sessionId) {\n                    if (!_this._ss) {\n                        throw new Error(\"MediaKeySession not set\");\n                    }\n                    _this._ss.update(license, sessionId);\n                    _this.sessionId = sessionId;\n                });\n                return _this;\n            }\n            IE11MediaKeySession.prototype.generateRequest = function (_initDataType, initData) {\n                var _this = this;\n                return new Promise(function (resolve) {\n                    _this._ss = _this._mk.memCreateSession(\"video/mp4\", initData);\n                    Observable_1.Observable.merge(events.onKeyMessage$(_this._ss), events.onKeyAdded$(_this._ss), events.onKeyError$(_this._ss))\n                        .takeUntil(_this._closeSession$)\n                        .subscribe(function (evt) { return _this.trigger(evt.type, evt); });\n                    resolve();\n                });\n            };\n            IE11MediaKeySession.prototype.close = function () {\n                var _this = this;\n                return new Promise(function (resolve) {\n                    if (_this._ss) {\n                        /* tslint:disable no-floating-promises */\n                        _this._ss.close();\n                        /* tslint:enable no-floating-promises */\n                        _this._ss = undefined;\n                    }\n                    _this._closeSession$.next();\n                    _this._closeSession$.complete();\n                    resolve();\n                });\n            };\n            IE11MediaKeySession.prototype.load = function () {\n                return Promise.resolve(false);\n            };\n            IE11MediaKeySession.prototype.remove = function () {\n                return Promise.resolve();\n            };\n            return IE11MediaKeySession;\n        }(eventemitter_1.default));\n        // on IE11, each created session needs to be created on a new\n        // MediaKeys object\n        constants_1.MediaKeys_.prototype.alwaysRenew = true;\n        constants_1.MediaKeys_.prototype.memCreateSession = constants_1.MediaKeys_.prototype.createSession;\n        constants_1.MediaKeys_.prototype.createSession = function () {\n            /* tslint:disable no-invalid-this */\n            return new IE11MediaKeySession_1(this);\n            /* tslint:enable no-invalid-this */\n        };\n        exports.requestMediaKeySystemAccess = requestMediaKeySystemAccess = function (keyType, keySystemConfigurations) {\n            // TODO Why TS Do not understand that isTypeSupported exists here?\n            if (!constants_1.MediaKeys_.isTypeSupported(keyType)) {\n                return Observable_1.Observable.throw(undefined);\n            }\n            for (var i = 0; i < keySystemConfigurations.length; i++) {\n                var keySystemConfiguration = keySystemConfigurations[i];\n                var videoCapabilities = keySystemConfiguration.videoCapabilities, audioCapabilities = keySystemConfiguration.audioCapabilities, initDataTypes = keySystemConfiguration.initDataTypes, distinctiveIdentifier = keySystemConfiguration.distinctiveIdentifier;\n                var supported = true;\n                supported = supported && (!initDataTypes ||\n                    !!initDataTypes.filter(function (idt) { return idt === \"cenc\"; })[0]);\n                supported = supported && (distinctiveIdentifier !== \"required\");\n                if (supported) {\n                    var keySystemConfigurationResponse = {\n                        videoCapabilities: videoCapabilities,\n                        audioCapabilities: audioCapabilities,\n                        initDataTypes: [\"cenc\"],\n                        distinctiveIdentifier: \"not-allowed\",\n                        persistentState: \"required\",\n                        sessionTypes: [\"temporary\", \"persistent-license\"],\n                    };\n                    return Observable_1.Observable.of(new keySystemAccess_1.default(keyType, \n                    // TODO Authorize 1 argument for IE?\n                    new constants_1.MediaKeys_(keyType), keySystemConfigurationResponse));\n                }\n            }\n            return Observable_1.Observable.throw(undefined);\n        };\n    }\n    else {\n        exports.requestMediaKeySystemAccess = requestMediaKeySystemAccess = null;\n    }\n}\n\n\n//# sourceURL=webpack://RxPlayer/./src/compat/eme/MediaKeys.ts?");

/***/ }),

/***/ "./src/compat/eme/index.ts":
/*!*********************************!*\
  !*** ./src/compat/eme/index.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar keySystemAccess_1 = __webpack_require__(/*! ./keySystemAccess */ \"./src/compat/eme/keySystemAccess.ts\");\nexports.KeySystemAccess = keySystemAccess_1.default;\nvar MediaKeys_1 = __webpack_require__(/*! ./MediaKeys */ \"./src/compat/eme/MediaKeys.ts\");\nexports.requestMediaKeySystemAccess = MediaKeys_1.requestMediaKeySystemAccess;\nvar setMediaKeys_1 = __webpack_require__(/*! ./setMediaKeys */ \"./src/compat/eme/setMediaKeys.ts\");\nexports.setMediaKeys = setMediaKeys_1.default;\n\n\n//# sourceURL=webpack://RxPlayer/./src/compat/eme/index.ts?");

/***/ }),

/***/ "./src/compat/eme/keySystemAccess.ts":
/*!*******************************************!*\
  !*** ./src/compat/eme/keySystemAccess.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Simple implementation of the MediaKeySystemAccess EME API.\n *\n * All needed arguments are given to the constructor\n * @class CustomMediaKeySystemAccess\n */\nvar CustomMediaKeySystemAccess = /** @class */ (function () {\n    function CustomMediaKeySystemAccess(_keyType, _mediaKeys, _configuration) {\n        this._keyType = _keyType;\n        this._mediaKeys = _mediaKeys;\n        this._configuration = _configuration;\n    }\n    Object.defineProperty(CustomMediaKeySystemAccess.prototype, \"keySystem\", {\n        get: function () {\n            return this._keyType;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    CustomMediaKeySystemAccess.prototype.createMediaKeys = function () {\n        var _this = this;\n        return new Promise(function (res) { return res(_this._mediaKeys); });\n    };\n    CustomMediaKeySystemAccess.prototype.getConfiguration = function () {\n        return this._configuration;\n    };\n    return CustomMediaKeySystemAccess;\n}());\nexports.default = CustomMediaKeySystemAccess;\n\n\n//# sourceURL=webpack://RxPlayer/./src/compat/eme/keySystemAccess.ts?");

/***/ }),

/***/ "./src/compat/eme/setMediaKeys.ts":
/*!****************************************!*\
  !*** ./src/compat/eme/setMediaKeys.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Observable_1 = __webpack_require__(/*! rxjs/Observable */ \"./node_modules/rxjs/Observable.js\");\nvar castToObservable_1 = __webpack_require__(/*! ../../utils/castToObservable */ \"./src/utils/castToObservable.ts\");\nvar MediaKeys_1 = __webpack_require__(/*! ./MediaKeys */ \"./src/compat/eme/MediaKeys.ts\");\n/**\n * Set the MediaKeys given on the media element.\n * @param {HTMLMediaElement} elt\n * @param {Object} mediaKeys\n * @returns {*}\n */\nfunction _setMediaKeys(elt, mediaKeys) {\n    if (mediaKeys instanceof MediaKeys_1.MockMediaKeys) {\n        return mediaKeys._setVideo(elt);\n    }\n    if (elt.setMediaKeys) {\n        return elt.setMediaKeys(mediaKeys);\n    }\n    if (mediaKeys === null) {\n        return;\n    }\n    if (elt.WebkitSetMediaKeys) {\n        return elt.WebkitSetMediaKeys(mediaKeys);\n    }\n    if (elt.mozSetMediaKeys) {\n        return elt.mozSetMediaKeys(mediaKeys);\n    }\n    if (elt.msSetMediaKeys) {\n        return elt.msSetMediaKeys(mediaKeys);\n    }\n}\n/**\n * Set the given MediaKeys on the given HTMLMediaElement.\n * Emits null when done then complete.\n * @param {HTMLMediaElement} elt\n * @param {Object} mediaKeys\n * @returns {Observable}\n */\nfunction setMediaKeys$(elt, mediaKeys) {\n    return Observable_1.Observable.defer(function () {\n        return castToObservable_1.default(_setMediaKeys(elt, mediaKeys)).mapTo(null);\n    });\n}\nexports.default = setMediaKeys$;\n\n\n//# sourceURL=webpack://RxPlayer/./src/compat/eme/setMediaKeys.ts?");

/***/ }),

/***/ "./src/compat/events.ts":
/*!******************************!*\
  !*** ./src/compat/events.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * This file provides browser-agnostic event listeners under the form of\n * RxJS Observables\n */\nvar Observable_1 = __webpack_require__(/*! rxjs/Observable */ \"./node_modules/rxjs/Observable.js\");\nvar config_1 = __webpack_require__(/*! ../config */ \"./src/config.ts\");\nvar log_1 = __webpack_require__(/*! ../utils/log */ \"./src/utils/log.ts\");\nvar rx_onEvent_1 = __webpack_require__(/*! ../utils/rx-onEvent */ \"./src/utils/rx-onEvent.ts\");\nvar constants_1 = __webpack_require__(/*! ./constants */ \"./src/compat/constants.ts\");\nvar INACTIVITY_DELAY = config_1.default.INACTIVITY_DELAY;\nvar pixelRatio = window.devicePixelRatio || 1;\n/**\n * Find the first supported event from the list given.\n * @param {Element} element\n * @param {string} eventNameSuffix\n * @returns {Boolean}\n */\nfunction isEventSupported(element, eventNameSuffix) {\n    var clone = document.createElement(element.tagName);\n    var eventName = \"on\" + eventNameSuffix;\n    if (eventName in clone) {\n        return true;\n    }\n    else {\n        clone.setAttribute(eventName, \"return;\");\n        return typeof clone[eventName] === \"function\";\n    }\n}\n/**\n * Find the first supported event from the list given.\n * @param {Element} element\n * @param {Array.<string>} eventNames\n * @returns {string}\n */\nfunction findSupportedEvent(element, eventNames) {\n    return eventNames\n        .filter(function (name) { return isEventSupported(element, name); })[0];\n}\nfunction eventPrefixed(eventNames, prefixes) {\n    return eventNames.reduce(function (parent, name) {\n        return parent\n            .concat((prefixes || constants_1.BROWSER_PREFIXES)\n            .map(function (p) { return p + name; }));\n    }, []);\n}\n/**\n * @param {Array.<string>} eventNames\n * @param {Array.<string>} prefixes\n * @returns {Observable}\n */\nfunction compatibleListener(eventNames, prefixes) {\n    var mem;\n    var prefixedEvents = eventPrefixed(eventNames, prefixes);\n    return function (element) {\n        // if the element is a HTMLElement we can detect\n        // the supported event, and memoize it in `mem`\n        if (element instanceof constants_1.HTMLElement_) {\n            if (typeof mem === \"undefined\") {\n                mem = findSupportedEvent(element, prefixedEvents);\n            }\n            if (mem) {\n                return Observable_1.Observable.fromEvent(element, mem);\n            }\n            else {\n                if (true) {\n                    /* tslint:disable:max-line-length */\n                    log_1.default.warn(\"compat: element <\" + element.tagName + \"> does not support any of these events: \" + prefixedEvents.join(\", \")\n                    /* tslint:enable:max-line-length */\n                    );\n                }\n                return Observable_1.Observable.never();\n            }\n        }\n        // otherwise, we need to listen to all the events\n        // and merge them into one observable sequence\n        return rx_onEvent_1.default(element, prefixedEvents);\n    };\n}\n/**\n * Returns an observable:\n *   - emitting true when the visibility of document changes to hidden\n *   - emitting false when the visibility of document changes to visible\n * @returns {Observable}\n */\nfunction visibilityChange() {\n    var prefix;\n    if (document.hidden != null) {\n        prefix = \"\";\n    }\n    else if (document.mozHidden != null) {\n        prefix = \"moz\";\n    }\n    else if (document.msHidden != null) {\n        prefix = \"ms\";\n    }\n    else if (document.webkitHidden != null) {\n        prefix = \"webkit\";\n    }\n    var hidden = prefix ? prefix + \"Hidden\" : \"hidden\";\n    var visibilityChangeEvent = prefix + \"visibilitychange\";\n    return rx_onEvent_1.default(document, visibilityChangeEvent)\n        .map(function () { return document[hidden]; });\n}\nfunction videoSizeChange() {\n    return rx_onEvent_1.default(window, \"resize\");\n}\nvar isVisible = visibilityChange() // emit false when visible\n    .filter(function (x) { return !x; });\n// Emit true if the visibility changed to hidden since 60s\nvar isHidden = visibilityChange()\n    .debounceTime(INACTIVITY_DELAY)\n    .filter(function (x) { return x; });\nvar isInBackground$ = function () { return Observable_1.Observable.merge(isVisible, isHidden)\n    .startWith(false); };\nexports.isInBackground$ = isInBackground$;\nfunction videoWidth$(videoElement) {\n    return Observable_1.Observable.merge(Observable_1.Observable.interval(20000), videoSizeChange().debounceTime(500))\n        .startWith(0) // emit on subscription\n        .map(function () { return videoElement.clientWidth * pixelRatio; })\n        .distinctUntilChanged();\n}\nexports.videoWidth$ = videoWidth$;\nvar onLoadedMetadata$ = compatibleListener([\"loadedmetadata\"]);\nexports.onLoadedMetadata$ = onLoadedMetadata$;\nvar onSeeking$ = compatibleListener([\"seeking\"]);\nexports.onSeeking$ = onSeeking$;\nvar onSeeked$ = compatibleListener([\"seeked\"]);\nexports.onSeeked$ = onSeeked$;\nvar onEnded$ = compatibleListener([\"ended\"]);\nexports.onEnded$ = onEnded$;\nvar onTimeUpdate$ = compatibleListener([\"timeupdate\"]);\nexports.onTimeUpdate$ = onTimeUpdate$;\nvar onFullscreenChange$ = compatibleListener([\"fullscreenchange\", \"FullscreenChange\"], \n// On IE11, fullscreen change events is called MSFullscreenChange\nconstants_1.BROWSER_PREFIXES.concat(\"MS\"));\nexports.onFullscreenChange$ = onFullscreenChange$;\nvar onPlayPause$ = function (videoElement) {\n    return Observable_1.Observable.merge(compatibleListener([\"play\"])(videoElement), compatibleListener([\"pause\"])(videoElement));\n};\nexports.onPlayPause$ = onPlayPause$;\nvar onTextTrackChanges$ = function (textTrackList) {\n    return Observable_1.Observable.merge(compatibleListener([\"addtrack\"])(textTrackList), compatibleListener([\"removetrack\"])(textTrackList));\n};\nexports.onTextTrackChanges$ = onTextTrackChanges$;\nvar onSourceOpen$ = compatibleListener([\"sourceopen\", \"webkitsourceopen\"]);\nexports.onSourceOpen$ = onSourceOpen$;\nvar onEncrypted$ = compatibleListener([\"encrypted\", \"needkey\"]);\nexports.onEncrypted$ = onEncrypted$;\nvar onKeyMessage$ = compatibleListener([\"keymessage\", \"message\"]);\nexports.onKeyMessage$ = onKeyMessage$;\nvar onKeyAdded$ = compatibleListener([\"keyadded\", \"ready\"]);\nexports.onKeyAdded$ = onKeyAdded$;\nvar onKeyError$ = compatibleListener([\"keyerror\", \"error\"]);\nexports.onKeyError$ = onKeyError$;\nvar onKeyStatusesChange$ = compatibleListener([\"keystatuseschange\"]);\nexports.onKeyStatusesChange$ = onKeyStatusesChange$;\n\n\n//# sourceURL=webpack://RxPlayer/./src/compat/events.ts?");

/***/ }),

/***/ "./src/compat/fullscreen.ts":
/*!**********************************!*\
  !*** ./src/compat/fullscreen.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Request fullScreen action on a given element.\n * @paras {HTMLElement} elt\n * rs-detect)\n */\nfunction requestFullscreen(elt) {\n    if (!isFullscreen()) {\n        if (elt.requestFullscreen) {\n            elt.requestFullscreen();\n        }\n        else if (elt.msRequestFullscreen) {\n            elt.msRequestFullscreen();\n        }\n        else if (elt.mozRequestFullScreen) {\n            elt.mozRequestFullScreen();\n        }\n        else if (elt.webkitRequestFullscreen) {\n            // TODO Open issue in TypeScript?\n            elt.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);\n        }\n    }\n}\nexports.requestFullscreen = requestFullscreen;\n/**\n * Exit fullscreen if an element is currently in fullscreen.\n * TODO this exit fullscreen mode even if any element in the document is in\n * fullscreen, is it really what we want?\n */\nfunction exitFullscreen() {\n    if (isFullscreen()) {\n        if (document.exitFullscreen) {\n            document.exitFullscreen();\n        }\n        else if (document.msExitFullscreen) {\n            document.msExitFullscreen();\n        }\n        else if (document.mozCancelFullScreen) {\n            document.mozCancelFullScreen();\n        }\n        else if (document.webkitExitFullscreen) {\n            document.webkitExitFullscreen();\n        }\n    }\n}\nexports.exitFullscreen = exitFullscreen;\n/**\n * Returns true if an element in the document is being displayed in fullscreen\n * mode;\n * otherwise it's false.\n * @returns {boolean}\n */\nfunction isFullscreen() {\n    return !!(document.fullscreenElement ||\n        document.mozFullScreenElement ||\n        document.webkitFullscreenElement ||\n        document.msFullscreenElement);\n}\nexports.isFullscreen = isFullscreen;\n\n\n//# sourceURL=webpack://RxPlayer/./src/compat/fullscreen.ts?");

/***/ }),

/***/ "./src/compat/index.ts":
/*!*****************************!*\
  !*** ./src/compat/index.ts ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Observable_1 = __webpack_require__(/*! rxjs/Observable */ \"./node_modules/rxjs/Observable.js\");\nvar eventemitter_1 = __webpack_require__(/*! ../utils/eventemitter */ \"./src/utils/eventemitter.ts\");\nvar log_1 = __webpack_require__(/*! ../utils/log */ \"./src/utils/log.ts\");\nvar rx_onEvent_1 = __webpack_require__(/*! ../utils/rx-onEvent */ \"./src/utils/rx-onEvent.ts\");\nvar constants_1 = __webpack_require__(/*! ./constants */ \"./src/compat/constants.ts\");\nexports.isFirefox = constants_1.isFirefox;\nexports.isIE = constants_1.isIE;\nexports.MediaSource_ = constants_1.MediaSource_;\nexports.VTTCue_ = constants_1.VTTCue_;\nvar events = __webpack_require__(/*! ./events */ \"./src/compat/events.ts\");\nexports.events = events;\nvar fullscreen_1 = __webpack_require__(/*! ./fullscreen */ \"./src/compat/fullscreen.ts\");\nexports.exitFullscreen = fullscreen_1.exitFullscreen;\nexports.isFullscreen = fullscreen_1.isFullscreen;\nexports.requestFullscreen = fullscreen_1.requestFullscreen;\nvar eme_1 = __webpack_require__(/*! ./eme */ \"./src/compat/eme/index.ts\");\nexports.KeySystemAccess = eme_1.KeySystemAccess;\nexports.requestMediaKeySystemAccess = eme_1.requestMediaKeySystemAccess;\nexports.setMediaKeys = eme_1.setMediaKeys;\n/**\n * Returns true if the given codec is supported by the browser's MediaSource\n * implementation.\n * @returns {Boolean}\n */\nfunction isCodecSupported(codec) {\n    if (!constants_1.MediaSource_) {\n        return false;\n    }\n    if (typeof constants_1.MediaSource_.isTypeSupported === \"function\") {\n        return constants_1.MediaSource_.isTypeSupported(codec);\n    }\n    return true;\n}\nexports.isCodecSupported = isCodecSupported;\n/**\n * Returns true if the browser has the minimum needed EME APIs to decrypt a\n * content.\n * @returns {Boolean}\n */\nfunction hasEMEAPIs() {\n    return typeof eme_1.requestMediaKeySystemAccess === \"function\";\n}\nexports.hasEMEAPIs = hasEMEAPIs;\n/**\n * Returns true if the current target require the media keys to be renewed on\n * each content.\n * @returns {Boolean}\n */\nfunction shouldRenewMediaKeys() {\n    return constants_1.isIE;\n}\nexports.shouldRenewMediaKeys = shouldRenewMediaKeys;\n/**\n * Returns true if the mediakeys associated to a media element should be\n * unset once the content is stopped.\n * Depends on the target.\n * @returns {Boolean}\n */\nfunction shouldUnsetMediaKeys() {\n    return constants_1.isIE;\n}\nexports.shouldUnsetMediaKeys = shouldUnsetMediaKeys;\n/**\n * Wait for the MediaSource's sourceopen event and emit. Emit immediatelly if\n * already received.\n * @param {MediaSource}\n * @returns {Observable}\n */\nfunction onSourceOpen$(mediaSource) {\n    if (mediaSource.readyState === \"open\") {\n        return Observable_1.Observable.of(null);\n    }\n    else {\n        return events.onSourceOpen$(mediaSource).take(1);\n    }\n}\nexports.onSourceOpen$ = onSourceOpen$;\n/**\n * Returns an observable emitting a single time, as soon as a seek is possible\n * (the metatada are loaded).\n * @param {HTMLMediaElement} mediaElement\n * @returns {Observable}\n */\nfunction hasLoadedMetadata(mediaElement) {\n    if (mediaElement.readyState >= constants_1.READY_STATES.HAVE_METADATA) {\n        return Observable_1.Observable.of(undefined);\n    }\n    else {\n        return events.onLoadedMetadata$(mediaElement)\n            .take(1)\n            .mapTo(undefined);\n    }\n}\nexports.hasLoadedMetadata = hasLoadedMetadata;\n/**\n * Returns ane observable emitting a single time, as soon as a play is possible.\n * @param {HTMLMediaElement} mediaElement\n * @returns {Observable}\n */\nfunction canPlay(mediaElement) {\n    if (mediaElement.readyState >= constants_1.READY_STATES.HAVE_ENOUGH_DATA) {\n        return Observable_1.Observable.of(undefined);\n    }\n    else {\n        return rx_onEvent_1.default(mediaElement, \"canplay\")\n            .take(1)\n            .mapTo(undefined);\n    }\n}\nexports.canPlay = canPlay;\n// old WebKit SourceBuffer implementation,\n// where a synchronous append is used instead of appendBuffer\nif (window.WebKitSourceBuffer &&\n    !window.WebKitSourceBuffer.prototype.addEventListener) {\n    var sourceBufferWebkitRef = window.WebKitSourceBuffer;\n    var sourceBufferWebkitProto = sourceBufferWebkitRef.prototype;\n    for (var fnName in eventemitter_1.default.prototype) {\n        if (eventemitter_1.default.prototype.hasOwnProperty(fnName)) {\n            sourceBufferWebkitProto[fnName] = eventemitter_1.default.prototype[fnName];\n        }\n    }\n    sourceBufferWebkitProto._listeners = [];\n    sourceBufferWebkitProto.__emitUpdate =\n        function (eventName, val) {\n            var _this = this;\n            setTimeout(function () {\n                /* tslint:disable no-invalid-this */\n                _this.trigger(eventName, val);\n                _this.updating = false;\n                _this.trigger(\"updateend\");\n                /* tslint:enable no-invalid-this */\n            }, 0);\n        };\n    sourceBufferWebkitProto.appendBuffer =\n        function (data) {\n            /* tslint:disable no-invalid-this */\n            if (this.updating) {\n                throw new Error(\"updating\");\n            }\n            this.trigger(\"updatestart\");\n            this.updating = true;\n            try {\n                this.append(data);\n            }\n            catch (error) {\n                this.__emitUpdate(\"error\", error);\n                return;\n            }\n            this.__emitUpdate(\"update\");\n            /* tslint:enable no-invalid-this */\n        };\n}\n/**\n * Add text track to the given media element.\n * Returns an object with the following properties:\n *   - track {TextTrack}: the added text track\n *   - trackElement {HTMLElement|undefined}: the added <track> element.\n *     undefined if no trackElement was added.\n * @param {HTMLMediaElement} mediaElement\n * @param {Boolean} hidden\n * @returns {Object}\n */\nfunction addTextTrack(mediaElement, hidden) {\n    var track;\n    var trackElement;\n    var kind = \"subtitles\";\n    if (constants_1.isIE) {\n        var tracksLength = mediaElement.textTracks.length;\n        track = tracksLength > 0 ?\n            mediaElement.textTracks[tracksLength - 1] : mediaElement.addTextTrack(kind);\n        track.mode = hidden ? track.HIDDEN : track.SHOWING;\n    }\n    else {\n        // there is no removeTextTrack method... so we need to reuse old\n        // text-tracks objects and clean all its pending cues\n        trackElement = document.createElement(\"track\");\n        mediaElement.appendChild(trackElement);\n        track = trackElement.track;\n        trackElement.kind = kind;\n        track.mode = hidden ? \"hidden\" : \"showing\";\n    }\n    return { track: track, trackElement: trackElement };\n}\nexports.addTextTrack = addTextTrack;\n/**\n * firefox fix: sometimes the stream can be stalled, even if we are in a\n * buffer.\n *\n * TODO This seems to be about an old Firefox version. Delete it?\n * @param {Object} timing\n * @returns {Boolean}\n */\nfunction isPlaybackStuck(time, currentRange, state, isStalled) {\n    var FREEZE_THRESHOLD = 10; // freeze threshold in seconds\n    return (constants_1.isFirefox && isStalled && state === \"timeupdate\" &&\n        !!currentRange && currentRange.end - time > FREEZE_THRESHOLD);\n}\nexports.isPlaybackStuck = isPlaybackStuck;\n/**\n * Clear element's src attribute.\n *\n * On IE11, element.src = \"\" is not sufficient as it\n * does not clear properly the current MediaKey Session.\n * Microsoft recommended to use element.removeAttr(\"src\").\n * @param {HTMLMediaElement} element\n */\nfunction clearElementSrc(element) {\n    element.src = \"\";\n    element.removeAttribute(\"src\");\n}\nexports.clearElementSrc = clearElementSrc;\n/**\n * Set an URL to the element's src.\n * Emit ``undefined`` when done.\n * Unlink src on unsubscription.\n *\n * @param {HTMLMediaElement} mediaElement\n * @param {string} url\n * @returns {Observable}\n */\nfunction setElementSrc$(mediaElement, url) {\n    return Observable_1.Observable.create(function (observer) {\n        log_1.default.info(\"Setting URL to Element\", url, mediaElement);\n        mediaElement.src = url;\n        observer.next(undefined);\n        return function () {\n            clearElementSrc(mediaElement);\n        };\n    });\n}\nexports.setElementSrc$ = setElementSrc$;\n/**\n * Some browsers have a builtin API to know if it's connected at least to a\n * LAN network, at most to the internet.\n *\n * /!\\ This feature can be dangerous as you can both have false positives and\n * false negatives.\n *\n * False positives:\n *   - you can still play local contents (on localhost) if isOffline == true\n *   - on some browsers isOffline might be true even if we're connected to a LAN\n *     or a router (it would mean we're just not able to connect to the\n *     Internet). So we can eventually play LAN contents if isOffline == true\n *\n * False negatives:\n *   - in some cases, we even might have isOffline at false when we do not have\n *     any connection:\n *       - in browsers that do not support the feature\n *       - in browsers running in some virtualization softwares where the\n *         network adapters are always connected.\n *\n * Use with these cases in mind.\n * @returns {Boolean}\n */\nfunction isOffline() {\n    /* tslint:disable no-boolean-literal-compare */\n    return navigator.onLine === false;\n    /* tslint:enable no-boolean-literal-compare */\n}\nexports.isOffline = isOffline;\n/**\n * Creates a cue using the best platform-specific interface available.\n *\n * @param {Number} startTime\n * @param {Number} endTime\n * @param {string} payload\n * @returns {TextTrackCue} or null if the parameters were invalid.\n */\nfunction makeCue(startTime, endTime, payload) {\n    if (!constants_1.VTTCue_) {\n        throw new Error(\"VTT cues not supported in your target\");\n    }\n    if (startTime >= endTime) {\n        // IE/Edge will throw in this case.\n        // See issue #501\n        log_1.default.warn(\"Invalid cue times: \" + startTime + \" - \" + endTime);\n        return null;\n    }\n    return new constants_1.VTTCue_(startTime, endTime, payload);\n}\nexports.makeCue = makeCue;\n\n\n//# sourceURL=webpack://RxPlayer/./src/compat/index.ts?");

/***/ }),

/***/ "./src/config.ts":
/*!***********************!*\
  !*** ./src/config.ts ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = {\n    /**\n     * Volume set on unMute if the volume is set to 0 and either:\n     *   - mute has never been called before\n     *   - mute has last been called while the volume was already set to 0 (either\n     *     via setVolume, or a previous mute call)\n     * @type {Number}\n     */\n    DEFAULT_UNMUTED_VOLUME: 0.1,\n    /**\n     * Can be either:\n     *   - \"native\": Subtitles are all displayed in a <track> element\n     *   - \"html\": Subtitles are all displayed in a <div> separated from the video\n     *     element. Can be useful to display richer TTML subtitles, for example.\n     * @type {Object|null}\n     */\n    // TODO ugly TypeScript workaround. Find better way\n    DEFAULT_TEXT_TRACK_MODE: \"native\",\n    /**\n     * If set to true, video through loadVideo will auto play by default\n     * @type {Boolean}\n     */\n    DEFAULT_AUTO_PLAY: false,\n    /**\n     * If set to false, \"native\" subtitles (in a <track> element) will be hidden\n     * by default.\n     * @type {Boolean}\n     */\n    DEFAULT_SHOW_NATIVE_SUBTITLE: true,\n    /**\n     * Default buffer goal in seconds.\n     * Once enough content has been downloaded to fill the buffer up to\n     * ``current position + DEFAULT_WANTED_BUFFER_AHEAD\", we will stop downloading\n     * content.\n     * @type {Number}\n     */\n    DEFAULT_WANTED_BUFFER_AHEAD: 30,\n    /**\n     * Default max buffer size ahead of the current position in seconds.\n     * The buffer _after_ this limit will be garbage collected.\n     * Set to Infinity for no limit.\n     * @type {Number}\n     */\n    DEFAULT_MAX_BUFFER_AHEAD: Infinity,\n    /*\n     * Default max buffer size ahead of the current position in seconds.\n     * The buffer _before_ this limit will be garbage collected.\n     * Set to Infinity for no limit.\n     * @type {Number}\n     */\n    DEFAULT_MAX_BUFFER_BEHIND: Infinity,\n    /**\n     * Default bitrate ceils initially set as the first content begins.\n     *\n     * If no track is found with a bitrate inferior or equal to the\n     * bitrate there, the one with the lowest bitrate will be taken instead.\n     *\n     * Set to 0 for the lowest bitrate, Infinity for the highest.\n     *\n     * These values are only useful for the first content played, as consecutive\n     * play will always take the last set one.\n     * @type {Object}\n     */\n    DEFAULT_INITIAL_BITRATES: {\n        audio: 0,\n        video: 0,\n        other: 0,\n    },\n    /**\n     * Default bitrate ceil initially set to dictate the maximum bitrate the\n     * ABR manager can automatically switch to.\n     *\n     * If no track is found with a quality inferior or equal to the\n     * bitrate there, the lowest bitrate will be taken instead.\n     *\n     * Set to Infinity to discard any limit in the ABR strategy.\n     * @type {Object}\n     */\n    /* tslint:disable no-object-literal-type-assertion */\n    DEFAULT_MAX_BITRATES: {\n        audio: Infinity,\n        video: Infinity,\n        other: Infinity,\n    },\n    /* tslint:enable no-object-literal-type-assertion */\n    /**\n     * Delay after which, if the page is hidden, the user is considered inactive\n     * on the current video.\n     *\n     * Allow to enforce specific optimizations when the page is not shown.\n     * @see DEFAULT_THROTTLE_WHEN_HIDDEN\n     * @type {Number}\n     */\n    INACTIVITY_DELAY: 60 * 1000,\n    /**\n     * If true, if the player is in a \"hidden\" state for a delay specified by the\n     * INACTIVITY DELAY config property, we throttle automatically to the video\n     * representation with the lowest bitrate.\n     * @type {Boolean}\n     */\n    DEFAULT_THROTTLE_WHEN_HIDDEN: false,\n    /**\n     * If true, the video representations you can switch to in adaptive mode\n     * are limited by the video element's width.\n     *\n     * Basically in that case, we won't switch to a video Representation with\n     * a width higher than the current width of the video HTMLElement.\n     * @type {Boolean}\n     */\n    DEFAULT_LIMIT_VIDEO_WIDTH: false,\n    /**\n     * Default initial live gap considered if no presentation delay has been\n     * suggested, in seconds.\n     * @type {Number}\n     */\n    DEFAULT_LIVE_GAP: 10,\n    /**\n     * Default value for a manifest's suggested presentation delay if not\n     * specified in the manifest.\n     * @type {Object}\n     */\n    DEFAULT_SUGGESTED_PRESENTATION_DELAY: {\n        SMOOTH: 10,\n        DASH: 10,\n    },\n    /**\n     * Maximum time, in seconds, the player should automatically skip when stalled\n     * because of a discontinuity in the downloaded range.\n     * @type {Number}\n     */\n    DISCONTINUITY_THRESHOLD: 1,\n    /**\n     * Ratio used to know if an already loaded segment should be re-buffered.\n     * We re-load the given segment if the current one times that ratio is\n     * inferior to the new one.\n     * @type {Number}\n     */\n    BITRATE_REBUFFERING_RATIO: 1.5,\n    /**\n     * Those are used when a \"QuotaExceededError\" error is received after\n     * appending a new segment in the source buffer.\n     *\n     * This error can arise when the browser's buffer is considered full.\n     * In this case, the player goes into manual garbage collection (GC) mode.\n     * @type {Object}\n     */\n    BUFFER_GC_GAPS: {\n        /**\n         * _Low_ gap (from current position) from which the buffer will be _garbage\n         * collected_ (read removed from the buffer) when a QuotaExceededError is\n         * received.\n         * In seconds.\n         * @type {Number}\n         */\n        CALM: 240,\n        /**\n         * _High_ gap (from current position) from which the buffer will be _garbage\n         * collected_ (read removed from the buffer) when a QuotaExceededError is\n         * received, if the low one does not clean up any buffer.\n         * In seconds.\n         * @type {Number}\n         */\n        BEEFY: 30,\n    },\n    /**\n     * The default number of times a manifest request will be re-performed\n     * when loaded/refreshed if the request finishes on an error which\n     * justify an retry.\n     *\n     * Note that some errors do not use this counter:\n     *   - if the error is not due to the xhr, no retry will be peformed\n     *   - if the error is an HTTP error code, but not a 500-smthg or a 404, no\n     *     retry will be performed.\n     *   - if it has a high chance of being due to the user being offline, a\n     *     separate counter is used (see DEFAULT_MAX_PIPELINES_RETRY_ON_OFFLINE).\n     * @type Number\n     */\n    DEFAULT_MAX_MANIFEST_REQUEST_RETRY: 4,\n    /**\n     * The default number of times a pipeline request will be re-performed when\n     * on error which justify a retry.\n     *\n     * Note that some errors do not use this counter:\n     *   - if the error is not due to the xhr, no retry will be peformed\n     *   - if the error is an HTTP error code, but not a 500-smthg or a 404, no\n     *     retry will be performed.\n     *   - if it has a high chance of being due to the user being offline, a\n     *     separate counter is used (see DEFAULT_MAX_PIPELINES_RETRY_ON_OFFLINE).\n     * @type Number\n     */\n    DEFAULT_MAX_PIPELINES_RETRY_ON_ERROR: 4,\n    /**\n     * Under some circonstances, we're able to tell that the user is offline (see\n     * the compat files).\n     * When this happens, and xhr requests fails due to an error event (you might\n     * still be able to perform xhr offline, e.g. on localhost), you might want to\n     * retry indefinitely or with a higher number of retry than if the error is\n     * due to a CDN problem.\n     *\n     * A capped exponential backoff will still be used (like for an error code).\n     * @type {Number}\n     */\n    DEFAULT_MAX_PIPELINES_RETRY_ON_OFFLINE: Infinity,\n    /**\n     * Initial backoff delay when a segment / manifest download fails, in\n     * milliseconds.\n     *\n     * This delay will then grow exponentally by power of twos (200, 400, 800\n     * etc.)\n     *\n     * Please note that this delay is not exact, as it will be fuzzed.\n     * @type {Number}\n     */\n    INITIAL_BACKOFF_DELAY_BASE: 200,\n    /**\n     * Maximum backoff delay when a segment / manifest download fails, in\n     * milliseconds.\n     *\n     * Please note that this delay is not exact, as it will be fuzzed.\n     * @type {Number}\n     */\n    MAX_BACKOFF_DELAY_BASE: 3000,\n    /**\n     * Minimum interval at which timeupdate events will be \"constructed\". This\n     * variable is for the \"regular\" mediasource strategy (that is, not for the\n     * directfile API.\n     *\n     * Those events are the base of various important mechanisms in the player:\n     *   - set the clock for the buffer.\n     *   - set the clock for the ABR strategy.\n     *   - used to trigger positionUpdate events.\n     *\n     * This common logic is for performance reasons, as we call multiple browser's\n     * APIs which are useful for most of these.\n     *\n     * Keep in mind this is the minimum interval. This logic will also be\n     * triggered when various events of the media element are received.\n     * @type {Number}\n     */\n    SAMPLING_INTERVAL_MEDIASOURCE: 1000,\n    /**\n     * Same than SAMPLING_INTERVAL_MEDIASOURCE but for the directfile API.\n     * @type {Number}\n     */\n    SAMPLING_INTERVAL_NO_MEDIASOURCE: 500,\n    /**\n     * Minimum number of bytes sampled before we trust the estimate.\n     * If we have not sampled much data, our estimate may not be accurate\n     * enough to trust.\n     * If bytesSampled_ is less than minTotalBytes_, we use defaultEstimate_.\n     * This specific value is based on experimentation.\n     * @type {Number}\n     */\n    ABR_MINIMUM_TOTAL_BYTES: 350e3,\n    /**\n     * Minimum number of bytes, under which samples are discarded.\n     * Our models do not include latency information, so connection startup time\n     * (time to first byte) is considered part of the download time.\n     * Because of this, we should ignore very small downloads which would cause\n     * our estimate to be too low.\n     * This specific value is based on experimentation.\n     * @type {Number}\n     */\n    ABR_MINIMUM_CHUNK_SIZE: 16e3,\n    /**\n     * Factor with which is multiplied the bandwidth estimate when the ABR is in\n     * starvation mode.\n     * @type {Number}\n     */\n    ABR_STARVATION_FACTOR: 0.72,\n    /**\n     * Factor with which is multiplied the bandwidth estimate when the ABR is not\n     * in starvation mode.\n     * @type {Number}\n     */\n    ABR_REGULAR_FACTOR: 0.90,\n    /**\n     * If a SourceBuffer has less than ABR_STARVATION_GAP in seconds ahead of the\n     * current position in its buffer, the ABR manager will go into starvation\n     * mode.\n     *\n     * It gets out of starvation mode when the OUT_OF_STARVATION_GAP value is\n     * reached.\n     *\n     * Under this starvation mode:\n     *\n     *   - the bandwidth considered will be a little lower than the one estimated\n     *\n     *   - the time the next important request take will be checked\n     *     multiple times to detect when/if it takes too much time.\n     *     If the request is considered too long, the bitrate will be hastily\n     *     re-calculated from this single request.\n     *\n     * @type {Number}\n     */\n    ABR_STARVATION_GAP: 5,\n    OUT_OF_STARVATION_GAP: 7,\n    /**\n     * Number of seconds ahead in the buffer after which playback will resume when\n     * seeking on an unbuffered part of the stream.\n     * @type {Number}\n     */\n    RESUME_GAP_AFTER_SEEKING: 1.5,\n    /**\n     * Number of seconds ahead in the buffer after which playback will resume when\n     * the player was stalled due to a low readyState.\n     * @type {Number}\n     */\n    RESUME_GAP_AFTER_NOT_ENOUGH_DATA: 0.5,\n    /**\n     * Number of seconds ahead in the buffer after which playback will resume\n     * after the player went through a buffering step.\n     * @type {Number}\n     */\n    RESUME_GAP_AFTER_BUFFERING: 5,\n    /**\n     * Maximum number of seconds in the buffer based on which a \"stalling\"\n     * strategy will be considered:\n     * The player will pause playback to get enough time building a sufficient\n     * buffer. This mostly happen when seeking in an unbuffered part or when\n     * buffering.\n     * @type {Number}\n     */\n    STALL_GAP: 0.5,\n    /**\n     * Maximum difference allowed between a segment _announced_ start (what the\n     * rx-player infers to be the starting time) and its _real_  current starting\n     * time in the source buffer, in seconds, until the segment is considered\n     * \"incomplete\".\n     * Same for the ending time announced and its effective end time in the source\n     * buffer.\n     *\n     * If the difference is bigger than this value, the segment will be considered\n     * incomplete (e.g. considered as partially garbage-collected) and as such\n     * might be re-downloaded.\n     *\n     * Keeping a too high value might lead to incomplete segments being wrongly\n     * considered as complete (and thus not be re-downloaded, this could lead the\n     * player to stall).\n     * Note that in a worst-case scenario this can happen for the end of a segment\n     * and the start of the contiguous segment, leading to a discontinuity two\n     * times this value.\n     *\n     * Keeping a too low value might lead to re-downloading the same segment\n     * multiple times (when the start and end times are badly estimated) as they\n     * will wrongly believed to be partially garbage-collected.\n     *\n     * If a segment has a perfect continuity with a previous/following one in the\n     * source buffer the start/end of it will not be checked. This allows to limit\n     * the number of time this error-prone logic is applied.\n     *\n     * Note that in most cases, the rx-player's start and end times estimations\n     * are __really__ close to what they really are in the sourcebuffer (we\n     * usually have a difference in the order of 10^-7), as time information is\n     * most of the time directly parsed from the media container.\n     *\n     * @type {Number}\n     */\n    MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT: 0.12,\n    /**\n     * The maximum time, in seconds, the real buffered time in the sourcebuffer\n     * can be superior to the time inferred by the rx-player (the \"real\" buffered\n     * start inferior to the inferred start and the \"real\" buffered end superior\n     * to the inferred end).\n     * This limit allows to avoid resizing too much downloaded segments because\n     * no other segment is linked to a buffered part.\n     *\n     * Setting a value too high can lead to parts of the source buffer being\n     * linked to the wrong segments.\n     * Setting a value too low can lead to parts of the source buffer not being\n     * linked to the concerned segment.\n     * @type {Number}\n     */\n    MAX_BUFFERED_DISTANCE: 0.1,\n    /**\n     * Minimum duration in seconds a segment should be into a buffered range to be\n     * considered as part of that range.\n     * Segments which have less than this amount of time \"linked\" to a buffered\n     * range will be deleted.\n     *\n     * Setting a value too low can lead in worst-case scenarios to segments being\n     * wrongly linked to the next or previous range it is truly linked too (if\n     * those ranges are too close).\n     *\n     * Setting a value too high can lead to part of the buffer not being assigned\n     * any segment. It also limits the minimum duration a segment can be.\n     *\n     * TODO As of now, this limits the minimum size a complete segment can be. A\n     * better logic would be to also consider the duration of a segment. Though\n     * this logic could lead to bugs with the current code.\n     * @type {Number}\n     */\n    MINIMUM_SEGMENT_SIZE: 0.2,\n    /**\n     * Maximum interval at which text tracks are refreshed in an \"html\"\n     * textTrackMode.\n     *\n     * The text tracks are also refreshed on various video events, this interval\n     * will only trigger a refresh if none of those events was received during\n     * that timespan.\n     *\n     * Note that if the TextTrack cue did not change between two intervals or\n     * events, the DOM won't be refreshed.\n     * The TextTrack cues structure is also optimized for fast retrieval.\n     * We should thus not have much of a performance impact here if we set a low\n     * interval.\n     *\n     * @type {Number}\n     */\n    MAXIMUM_HTML_TEXT_TRACK_UPDATE_INTERVAL: 50,\n    /**\n     * The Buffer padding is a time offset from the current time that affects\n     * the buffer.\n     *\n     * Basically, from a given time, if the current buffer gap number (time\n     * between the current time and the end of the downloaded buffer) is between\n     * the \"high\" and \"low\" described here (of the corresponding type), we won't\n     * reschedule segments for that range.\n     *\n     * This is to avoid excessive re-buffering.\n     *\n     * Keeping the \"high\"s too low would increase the risk of re-bufferings.\n     *\n     * Keeping the \"high\"s too high would delay visible quality increase.\n     *\n     * @type {Object}\n     */\n    BUFFER_PADDING: {\n        audio: {\n            high: 1,\n            low: 1,\n        },\n        video: {\n            high: 8,\n            low: 2,\n        },\n        other: {\n            high: 1,\n            low: 1,\n        },\n    },\n    /**\n     * Segments of different types are downloaded by steps:\n     *\n     *   - first the audio/video/text Segments which are immediately needed\n     *\n     *   - then once every of those Segments have been downloaded, less-needed\n     *     Segments\n     *\n     *   - then once every of those less-needed Segments have been downloaded,\n     *     even less-needed Segments\n     *\n     *   - etc.\n     *\n     * This stepped download strategy allows to make a better use of network\n     * ressources.\n     *\n     * For example, if more than sufficient audio buffer has been downloaded but\n     * the immediately-needed video Segment is still pending its request, we might\n     * be in a situation of rebuffering.\n     * In that case, a better strategy would be to make sure every network\n     * ressource is allocated for this video Segment before rebuffering happens.\n     *\n     * This is where those steps become useful.\n     *\n     * --\n     *\n     * The numbers defined in this Array describe what the steps are.\n     *\n     * Each number is linked to a distance from the current playing position, in\n     * seconds.\n     * Distances which will be used as limit points, from which a new step is\n     * reached (see example).\n     *\n     * Note: You can set an empty array to deactivate the steps feature (every\n     * Segments have the same priority).\n     *\n     * @example\n     *\n     * let's imagine the following SEGMENT_PRIORITIES_STEPS array:\n     * [5, 11, 17, 25]\n     *\n     * To link each Segments to a corresponding priority (and thus to a specific\n     * step), we have to consider the distance d between the current position and\n     * the start time of the Segment.\n     *\n     * We have in our example 5 groups, which correspond to the following possible\n     * d values:\n     *   1. inferior to 5\n     *   2. between 5 and 11\n     *   3. between 11 and 17\n     *   4. between 17 and 25\n     *   5. superior to 25\n     *\n     * Segments corresponding to a lower-step will need to all be downloaded\n     * before Segments of a newer step begin.\n     *\n     * @type {Array.<Number>}\n     */\n    SEGMENT_PRIORITIES_STEPS: [6, 14],\n    /**\n     * Robustnesses used in the {audio,video}Capabilities of the\n     * MediaKeySystemConfiguration (EME).\n     *\n     * Only used for widevine keysystems.\n     *\n     * Defined in order of importance (first will be tested first etc.)\n     * @type {Array.<string>}\n     */\n    EME_DEFAULT_WIDEVINE_ROBUSTNESSES: [\n        \"HW_SECURE_ALL\",\n        \"HW_SECURE_DECODE\",\n        \"HW_SECURE_CRYPTO\",\n        \"SW_SECURE_DECODE\",\n        \"SW_SECURE_CRYPTO\",\n    ],\n    /**\n     * Link canonical key systems names to their respective reverse domain name,\n     * used in the EME APIs.\n     * This allows to have a simpler API, where users just need to set \"widevine\"\n     * or \"playready\" as a keySystem.\n     * @type {Object}\n     */\n    /* tslint:disable no-object-literal-type-assertion */\n    EME_KEY_SYSTEMS: {\n        clearkey: [\n            \"webkit-org.w3.clearkey\",\n            \"org.w3.clearkey\",\n        ],\n        widevine: [\n            \"com.widevine.alpha\",\n        ],\n        playready: [\n            \"com.microsoft.playready\",\n            \"com.chromecast.playready\",\n            \"com.youtube.playready\",\n        ],\n    },\n    /* tslint:enable no-object-literal-type-assertion */\n    /**\n     * Max simultaneous MediaKeySessions that will be kept as a cache to avoid\n     * doing superfluous license requests.\n     * If this number is reached, any new session creation will close the oldest\n     * one.\n     * @type {Number}\n     */\n    EME_MAX_SIMULTANEOUS_MEDIA_KEY_SESSIONS: 50,\n    /**\n     * The player relies on browser events and properties to update its status to\n     * \"ENDED\".\n     *\n     * Sadly in some cases, like in Chrome 54, this event is never triggered on\n     * some contents probably due to a browser bug.\n     *\n     * This threshold resolves this issue by forcing the status to \"ENDED\" when:\n     *   1. the player is stalling\n     *   2. the absolute difference between current playback time and duration is\n     *      under this value\n     *\n     * If set to null, this workaround is disabled and the player only relies on\n     * browser events.\n     *\n     * @type {Number|null}\n     */\n    FORCED_ENDED_THRESHOLD: 0.001,\n};\n\n\n//# sourceURL=webpack://RxPlayer/./src/config.ts?");

/***/ }),

/***/ "./src/core/abr/bandwidth_estimator.ts":
/*!*********************************************!*\
  !*** ./src/core/abr/bandwidth_estimator.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar config_1 = __webpack_require__(/*! ../../config */ \"./src/config.ts\");\nvar ewma_1 = __webpack_require__(/*! ./ewma */ \"./src/core/abr/ewma.ts\");\nvar FAST_EMA = 2;\nvar SLOW_EMA = 10;\nvar ABR_MINIMUM_TOTAL_BYTES = config_1.default.ABR_MINIMUM_TOTAL_BYTES, ABR_MINIMUM_CHUNK_SIZE = config_1.default.ABR_MINIMUM_CHUNK_SIZE;\n/**\n * Calculate a mean bandwidth based on the bytes downloaded and the amount\n * of time needed to do so.\n *\n * Heavily \"inspired\" from the Shaka-Player's \"ewma bandwidth estimator\".\n * @class BandwidthEstimator\n */\nvar BandwidthEstimator = /** @class */ (function () {\n    function BandwidthEstimator() {\n        /**\n         * A fast-moving average.\n         * @private\n         */\n        this._fast = new ewma_1.default(FAST_EMA);\n        /**\n         * A slow-moving average.\n         * @private\n         */\n        this._slow = new ewma_1.default(SLOW_EMA);\n        /**\n         * Number of bytes sampled.\n         * @private\n         */\n        this._bytesSampled = 0;\n    }\n    /**\n     * Takes a bandwidth sample.\n     * @param {number} durationMs The amount of time, in milliseconds, for a\n     *   particular request.\n     * @param {number} numBytes The total number of bytes transferred in that\n     *   request.\n     */\n    BandwidthEstimator.prototype.addSample = function (durationInMs, numberOfBytes) {\n        if (numberOfBytes < ABR_MINIMUM_CHUNK_SIZE) {\n            return;\n        }\n        var bandwidth = numberOfBytes * 8000 / durationInMs;\n        var weight = durationInMs / 1000;\n        this._bytesSampled += numberOfBytes;\n        this._fast.addSample(weight, bandwidth);\n        this._slow.addSample(weight, bandwidth);\n    };\n    /**\n     * Get estimate of the bandwidth, in bits per seconds.\n     * @returns {Number|undefined}\n     */\n    BandwidthEstimator.prototype.getEstimate = function () {\n        if (this._bytesSampled < ABR_MINIMUM_TOTAL_BYTES) {\n            return undefined;\n        }\n        // Take the minimum of these two estimates.  This should have the effect of\n        // adapting down quickly, but up more slowly.\n        return Math.min(this._fast.getEstimate(), this._slow.getEstimate());\n    };\n    /**\n     * Reset the bandwidth estimation.\n     */\n    BandwidthEstimator.prototype.reset = function () {\n        this._fast = new ewma_1.default(FAST_EMA);\n        this._slow = new ewma_1.default(SLOW_EMA);\n        this._bytesSampled = 0;\n    };\n    return BandwidthEstimator;\n}());\nexports.default = BandwidthEstimator;\n\n\n//# sourceURL=webpack://RxPlayer/./src/core/abr/bandwidth_estimator.ts?");

/***/ }),

/***/ "./src/core/abr/ewma.ts":
/*!******************************!*\
  !*** ./src/core/abr/ewma.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Tweaked implementation of an exponential weighted Moving Average.\n * Heavily \"inspired\" from the shaka-player one (Ewma).\n * @class EWMA\n */\nvar EWMA = /** @class */ (function () {\n    /**\n     * @param {number} halfLife\n     */\n    function EWMA(halfLife) {\n        // (half-life = log(1/2) / log(Decay Factor)\n        this._alpha = Math.exp(Math.log(0.5) / halfLife);\n        this._lastEstimate = 0;\n        this._totalWeight = 0;\n    }\n    /**\n     * @param {number} weight\n     * @param {number} value\n     */\n    EWMA.prototype.addSample = function (weight, value) {\n        var adjAlpha = Math.pow(this._alpha, weight);\n        var newEstimate = value * (1 - adjAlpha) + adjAlpha * this._lastEstimate;\n        if (!isNaN(newEstimate)) {\n            this._lastEstimate = newEstimate;\n            this._totalWeight += weight;\n        }\n    };\n    /**\n     * @returns {number} value\n     */\n    EWMA.prototype.getEstimate = function () {\n        var zeroFactor = 1 - Math.pow(this._alpha, this._totalWeight);\n        return this._lastEstimate / zeroFactor;\n    };\n    return EWMA;\n}());\nexports.default = EWMA;\n\n\n//# sourceURL=webpack://RxPlayer/./src/core/abr/ewma.ts?");

/***/ }),

/***/ "./src/core/abr/filterByBitrate.ts":
/*!*****************************************!*\
  !*** ./src/core/abr/filterByBitrate.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar arrayFindIndex = __webpack_require__(/*! array-find-index */ \"./node_modules/array-find-index/index.js\");\n/**\n * Get only representations lower than a given bitrate.\n * @param {Array.<Object>} representations - The representations array\n * @param {Number} bitrate\n * @returns {Array.<Object>}\n */\nfunction filterByBitrate(representations, bitrate) {\n    var firstSuperiorBitrate = arrayFindIndex(representations, function (r) { return r.bitrate > bitrate; });\n    if (firstSuperiorBitrate === -1) {\n        return representations; // All representations have a lower bitrates.\n    }\n    return representations.slice(0, firstSuperiorBitrate);\n}\nexports.default = filterByBitrate;\n\n\n//# sourceURL=webpack://RxPlayer/./src/core/abr/filterByBitrate.ts?");

/***/ }),

/***/ "./src/core/abr/filterByWidth.ts":
/*!***************************************!*\
  !*** ./src/core/abr/filterByWidth.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar arrayFind = __webpack_require__(/*! array-find */ \"./node_modules/array-find/find.js\");\n/**\n * Filter representations based on their width:\n *   - the highest width considered will be the one linked to the first\n *     representation which has a superior width to the one given.\n * @param {Array.<Object>} representations - The representations array\n * @param {Number} width\n * @returns {Array.<Object>}\n */\nfunction filterByWidth(representations, width) {\n    var sortedRepsByWidth = representations\n        .slice() // clone\n        .sort(function (a, b) { return (a.width || 0) - (b.width || 0); });\n    var repWithMaxWidth = arrayFind(sortedRepsByWidth, function (r) { return (r.width || 0) >= width; });\n    if (repWithMaxWidth) {\n        var maxWidth_1 = repWithMaxWidth.width || 0;\n        return representations.filter(function (r) { return (r.width || 0) <= maxWidth_1; });\n    }\n    return representations;\n}\nexports.default = filterByWidth;\n\n\n//# sourceURL=webpack://RxPlayer/./src/core/abr/filterByWidth.ts?");

/***/ }),

/***/ "./src/core/abr/fromBitrateCeil.ts":
/*!*****************************************!*\
  !*** ./src/core/abr/fromBitrateCeil.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar arrayFindIndex = __webpack_require__(/*! array-find-index */ \"./node_modules/array-find-index/index.js\");\n/**\n * @param {Array.<Representation>} representations - The representations array\n * @param {Number} bitrate\n * @returns {Representation}\n */\nfunction fromBitrateCeil(representations, bitrate) {\n    var tooHighIndex = arrayFindIndex(representations, function (representation) { return representation.bitrate > bitrate; });\n    if (tooHighIndex === -1) {\n        return representations[representations.length - 1];\n    }\n    return representations[tooHighIndex - 1];\n}\nexports.default = fromBitrateCeil;\n\n\n//# sourceURL=webpack://RxPlayer/./src/core/abr/fromBitrateCeil.ts?");

/***/ }),

/***/ "./src/core/abr/index.ts":
/*!*******************************!*\
  !*** ./src/core/abr/index.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Subject_1 = __webpack_require__(/*! rxjs/Subject */ \"./node_modules/rxjs/Subject.js\");\nvar representation_chooser_1 = __webpack_require__(/*! ./representation_chooser */ \"./src/core/abr/representation_chooser.ts\");\nvar defaultChooserOptions = {\n    limitWidth: {},\n    throttle: {},\n    initialBitrates: {},\n    manualBitrates: {},\n    maxAutoBitrates: {},\n};\n/**\n * Create the right RepresentationChooser instance, from the given data.\n * @param {string} type\n * @param {Object} options\n * @returns {RepresentationChooser} - The RepresentationChooser instance\n */\nvar createChooser = function (type, options) {\n    return new representation_chooser_1.default({\n        limitWidth$: options.limitWidth[type],\n        throttle$: options.throttle[type],\n        initialBitrate: options.initialBitrates[type],\n        manualBitrate: options.manualBitrates[type],\n        maxAutoBitrate: options.maxAutoBitrates[type],\n    });\n};\n/**\n * Adaptive BitRate Manager.\n *\n * Select the right representation from the network and buffer infos it\n * receives.\n * @class ABRManager\n */\nvar ABRManager = /** @class */ (function () {\n    /**\n     * @param {Observable} requests$ - Emit requests infos as they begin, progress\n     * and end.\n     * Allows to know if a request take too much time to be finished in\n     * emergency times (e.g. when the user's bandwidth falls very quickly).\n     *\n     * The items emitted are Observables which each emit infos about a SINGLE\n     * request. These infos are under the form of objects with the following keys:\n     *   - type {string}: the buffer type (example: \"video\")\n     *\n     *   - event {string}: Wether the request started, is progressing or has\n     *     ended. Should be either one of these three strings:\n     *       1. \"requestBegin\": The request has just begun.\n     *\n     *       2. \"progress\": Informations about the request progress were received\n     *          (basically the amount of bytes currently received).\n     *\n     *       2. \"requestEnd\": The request just ended (successfully/on error/was\n     *          canceled)\n     *\n     *     Note that it should ALWAYS happen in the following order:\n     *     1 requestBegin -> 0+ progress -> 1 requestEnd\n     *\n     *     Also note that EVERY requestBegin should eventually be followed by a\n     *     requestEnd at some point. If that's not the case, a memory leak\n     *     can happen.\n     *\n     *   - value {Object|undefined}: The value depends on the type of event\n     *     received:\n     *       - for \"requestBegin\" events, it should be an object with the\n     *         following keys:\n     *           - id {number|String}: The id of this particular request.\n     *           - duration {number}: duration, in seconds of the asked segment.\n     *           - time {number}: The start time, in seconds of the asked segment.\n     *           - requestTimestamp {number}: the timestamp at which the request\n     *             was sent, in ms.\n     *\n     *       - for \"progress\" events, it should be an object with the following\n     *         keys:\n     *           - id {number|String}: The id of this particular request.\n     *           - size {number}: amount currently downloaded, in bytes\n     *           - timestamp {number}: timestamp at which the progress event was\n     *             received, in ms\n     *         Those events SHOULD be received in order (that is, in increasing\n     *         order for both size and timestamp).\n     *\n     *       - for \"requestEnd\" events:\n     *           - id {number|String}: The id of this particular request.\n     *\n     * @param {Observable} metrics$ - Emit each times the network downloaded\n     * a new segment for a given buffer type. Allows to obtain informations about\n     * the user's bitrate.\n     *\n     * The items emitted are object with the following keys:\n     *   - type {string}: the buffer type (example: \"video\")\n     *   - value {Object}:\n     *     - duration {number}: duration of the request, in seconds.\n     *     - size {number}: size of the downloaded chunks, in bytes.\n     *\n     * @param {ChooserOption} [options={}]\n     */\n    function ABRManager(requests$, metrics$, options) {\n        if (options === void 0) { options = defaultChooserOptions; }\n        var _this = this;\n        // Subject emitting and completing on dispose.\n        // Used to clean up every created observables.\n        this._dispose$ = new Subject_1.Subject();\n        // Will contain every RepresentationChooser attached to the ABRManager,\n        // by type (\"audio\"/\"video\" etc.)\n        this._choosers = {};\n        // -- OPTIONS --\n        // Will contain options used when (lazily) instantiating a\n        // RepresentationChooser\n        this._chooserInstanceOptions = {\n            initialBitrates: options.initialBitrates || {},\n            manualBitrates: options.manualBitrates || {},\n            maxAutoBitrates: options.maxAutoBitrates || {},\n            throttle: options.throttle || {},\n            limitWidth: options.limitWidth || {},\n        };\n        metrics$\n            .takeUntil(this._dispose$)\n            .subscribe(function (_a) {\n            var type = _a.type, value = _a.value;\n            _this._lazilyCreateChooser(type);\n            var duration = value.duration, size = value.size;\n            // TODO Should we do a single estimate instead of a per-type one?\n            // Test it thoroughly\n            _this._choosers[type].addEstimate(duration, size);\n        });\n        requests$\n            // requests$ emits observables which are subscribed to\n            .mergeMap(function (request$) { return request$; })\n            .takeUntil(this._dispose$)\n            .subscribe(function (request) {\n            var type = request.type, value = request.value;\n            _this._lazilyCreateChooser(type);\n            switch (request.event) {\n                case \"requestBegin\":\n                    // use the id of the segment as in any case, we should only have at\n                    // most one active download for the same segment.\n                    // This might be not optimal if this changes however. The best I think\n                    // for now is to just throw/warn in DEV mode when two pending ids\n                    // are identical\n                    _this._choosers[type].addPendingRequest(value.id, request);\n                    break;\n                case \"requestEnd\":\n                    _this._choosers[type].removePendingRequest(value.id);\n                    break;\n                case \"progress\":\n                    _this._choosers[type].addRequestProgress(value.id, request);\n                    break;\n            }\n        });\n    }\n    /**\n     * Take type and an array of the available representations, spit out an\n     * observable emitting the best representation (given the network/buffer\n     * state).\n     * @param {string} type\n     * @param {Observable<Object>} clock$\n     * @param {Array.<Representation>} [representations=[]]\n     * @returns {Observable}\n     */\n    ABRManager.prototype.get$ = function (type, clock$, representations) {\n        if (representations === void 0) { representations = []; }\n        this._lazilyCreateChooser(type);\n        return this._choosers[type].get$(clock$, representations);\n    };\n    /**\n     * Set manually the bitrate for a given type.\n     *\n     * The given number will act as a ceil.\n     * If no representation is found with the given bitrate, we will consider:\n     *   1. The representation just lower than it\n     *   2. If no representation is found in the previous step, the representation\n     *   with the lowest bitrate.\n     *\n     * @param {string} type\n     * @param {number} bitrate\n     */\n    ABRManager.prototype.setManualBitrate = function (type, bitrate) {\n        var chooser = this._choosers[type];\n        if (!chooser) {\n            // if no chooser yet, store as a chooser option for when it will be\n            // effectively instantiated\n            this._chooserInstanceOptions.initialBitrates[type] = bitrate;\n        }\n        else {\n            chooser.manualBitrate$.next(bitrate);\n        }\n    };\n    /**\n     * Set a maximum bitrate a given type will be able to automatically switch to.\n     * The chooser for the given type can still emit higher bitrates with the\n     * setManualBitrate method.\n     * @param {string} supportedBufferTypes\n     * @param {number} bitrate\n     */\n    ABRManager.prototype.setMaxAutoBitrate = function (type, bitrate) {\n        var chooser = this._choosers[type];\n        if (!chooser) {\n            // if no chooser yet, store as a chooser option for when it will be\n            // effectively instantiated\n            this._chooserInstanceOptions.maxAutoBitrates[type] = bitrate;\n        }\n        else {\n            chooser.maxAutoBitrate$.next(bitrate);\n        }\n    };\n    /**\n     * Returns the set (and active) manual bitrate for the given type.\n     * @param {string} supportedBufferTypes\n     * @returns {number|undefined}\n     */\n    ABRManager.prototype.getManualBitrate = function (type) {\n        var chooser = this._choosers[type];\n        return chooser ?\n            chooser.manualBitrate$.getValue() :\n            this._chooserInstanceOptions.manualBitrates[type];\n    };\n    /**\n     * Returns the set (and active) maximum auto bitrate for the given type.\n     * @param {string} supportedBufferTypes\n     * @returns {number|undefined}\n     */\n    ABRManager.prototype.getMaxAutoBitrate = function (type) {\n        var chooser = this._choosers[type];\n        return chooser ?\n            chooser.maxAutoBitrate$.getValue() :\n            this._chooserInstanceOptions.maxAutoBitrates[type];\n    };\n    /**\n     * Clean every ressources linked to the ABRManager.\n     * The ABRManager is unusable after calling this method.\n     */\n    ABRManager.prototype.dispose = function () {\n        var _this = this;\n        Object.keys(this._choosers).forEach(function (type) {\n            _this._choosers[type].dispose();\n        });\n        this._chooserInstanceOptions = defaultChooserOptions;\n        this._choosers = {};\n        this._dispose$.next();\n        this._dispose$.complete();\n    };\n    /**\n     * If it doesn't exist, create a RepresentationChooser under the\n     * _choosers[bufferType] property.\n     * @param {string} bufferType\n     */\n    ABRManager.prototype._lazilyCreateChooser = function (bufferType) {\n        if (!this._choosers[bufferType]) {\n            this._choosers[bufferType] =\n                createChooser(bufferType, this._chooserInstanceOptions);\n        }\n    };\n    return ABRManager;\n}());\nexports.default = ABRManager;\n\n\n//# sourceURL=webpack://RxPlayer/./src/core/abr/index.ts?");

/***/ }),

/***/ "./src/core/abr/representation_chooser.ts":
/*!************************************************!*\
  !*** ./src/core/abr/representation_chooser.ts ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar objectAssign = __webpack_require__(/*! object-assign */ \"./node_modules/object-assign/index.js\");\nvar BehaviorSubject_1 = __webpack_require__(/*! rxjs/BehaviorSubject */ \"./node_modules/rxjs/BehaviorSubject.js\");\nvar Observable_1 = __webpack_require__(/*! rxjs/Observable */ \"./node_modules/rxjs/Observable.js\");\nvar Subject_1 = __webpack_require__(/*! rxjs/Subject */ \"./node_modules/rxjs/Subject.js\");\nvar config_1 = __webpack_require__(/*! ../../config */ \"./src/config.ts\");\nvar log_1 = __webpack_require__(/*! ../../utils/log */ \"./src/utils/log.ts\");\nvar bandwidth_estimator_1 = __webpack_require__(/*! ./bandwidth_estimator */ \"./src/core/abr/bandwidth_estimator.ts\");\nvar ewma_1 = __webpack_require__(/*! ./ewma */ \"./src/core/abr/ewma.ts\");\nvar filterByBitrate_1 = __webpack_require__(/*! ./filterByBitrate */ \"./src/core/abr/filterByBitrate.ts\");\nvar filterByWidth_1 = __webpack_require__(/*! ./filterByWidth */ \"./src/core/abr/filterByWidth.ts\");\nvar fromBitrateCeil_1 = __webpack_require__(/*! ./fromBitrateCeil */ \"./src/core/abr/fromBitrateCeil.ts\");\nvar ABR_STARVATION_GAP = config_1.default.ABR_STARVATION_GAP, OUT_OF_STARVATION_GAP = config_1.default.OUT_OF_STARVATION_GAP, ABR_STARVATION_FACTOR = config_1.default.ABR_STARVATION_FACTOR, ABR_REGULAR_FACTOR = config_1.default.ABR_REGULAR_FACTOR;\n/**\n * Returns an observable emitting only the representation concerned by the\n * bitrate ceil given.\n * @param {Array.<Representation>} representations\n * @param {number} bitrate\n * @returns {Observable}\n */\nfunction setManualRepresentation(representations, bitrate) {\n    var chosenRepresentation = fromBitrateCeil_1.default(representations, bitrate) ||\n        representations[0];\n    return Observable_1.Observable.of({\n        bitrate: undefined,\n        representation: chosenRepresentation,\n    });\n}\n/**\n * Get the pending request containing the asked segment position.\n * @param {Object} requests\n * @param {number} segmentPosition\n * @returns {IRequestInfo|undefined}\n */\nfunction getConcernedRequest(requests, segmentPosition) {\n    var currentRequestIds = Object.keys(requests);\n    var len = currentRequestIds.length;\n    for (var i = 0; i < len - 1; i++) {\n        var request = requests[currentRequestIds[i]];\n        var chunkTime = request.time, chunkDuration = request.duration;\n        // TODO review this\n        if (Math.abs(segmentPosition - chunkTime) < chunkDuration) {\n            return request;\n        }\n    }\n}\n/**\n * Estimate the __VERY__ recent bandwidth based on a single unfinished request.\n * Useful when the current bandwidth seemed to have fallen quickly.\n *\n * Use progress events if available, set a much more random lower bitrate\n * if no progress events are available.\n *\n * @param {Object} request\n * @param {number} requestTime - Amount of time the request has taken for now,\n * in seconds.\n * @param {number} bitrate - Current bitrate at the time of download\n * @returns {number}\n */\nfunction estimateRequestBandwidth(request, requestTime, bitrate) {\n    var estimate;\n    // try to infer quickly the current bitrate based on the\n    // progress events\n    if (request.progress.length >= 2) {\n        var ewma1 = new ewma_1.default(2);\n        var progress = request.progress;\n        for (var i = 1; i < progress.length; i++) {\n            var bytesDownloaded = progress[i].size - progress[i - 1].size;\n            var timeElapsed = progress[i].timestamp - progress[i - 1].timestamp;\n            var reqBitrate = (bytesDownloaded * 8) / (timeElapsed / 1000);\n            ewma1.addSample(timeElapsed / 1000, reqBitrate);\n        }\n        estimate = ewma1.getEstimate();\n    }\n    // if that fails / no progress event, take a guess\n    if (!estimate && bitrate) {\n        var chunkDuration = request.duration;\n        var chunkSize = chunkDuration * bitrate;\n        // take current duration of request as a base\n        estimate = chunkSize / (requestTime * 5 / 4);\n    }\n    return estimate;\n}\n/**\n * Filter representations given through filters options.\n * @param {Array.<Representation>} representations\n * @param {Object} filters\n * @param {number} [filters.bitrate] - max bitrate authorized (included).\n * @param {number} [filters.width] - max width authorized (included).\n * @returns {Representation[]}\n */\nfunction getFilteredRepresentations(representations, filters) {\n    var _representations = representations;\n    if (filters.bitrate != null) {\n        _representations = filterByBitrate_1.default(_representations, filters.bitrate);\n    }\n    if (filters.width != null) {\n        _representations = filterByWidth_1.default(_representations, filters.width);\n    }\n    return _representations;\n}\n/**\n * Returns true if the request takes too much time relatively to how much we\n * should actually wait.\n * Depends on the chunk duration.\n * @param {number} durationOfRequest - time, in s, since the request has been\n * performed.\n * @param {number} chunkDuration - duration, in s, of a single chunk\n * @returns {Boolean}\n */\nfunction requestTakesTime(durationOfRequest, chunkDuration) {\n    return durationOfRequest > chunkDuration * 1.2 + 1;\n}\n/**\n * Choose the right representation based on multiple parameters given, such as:\n *   - the current user's bandwidth\n *   - the max bitrate authorized\n *   - the size of the video element\n *   - etc.\n *\n * Those parameters can be set through different subjects and methods.\n * The subjects (undocumented here are):\n *\n *   - manualBitrate$ {Subject}: Set the bitrate manually, if no representation\n *     is found with the given bitrate. An immediately inferior one will be\n *     taken instead. If still, none are found, the representation with the\n *     minimum bitrate will be taken.\n *     Set it to a negative value to go into automatic bitrate mode.\n *\n *   - maxBitrate$ {Subject}: Set the maximum automatic bitrate. If the manual\n *     bitrate is not set / set to a negative value, this will be the maximum\n *     switch-able bitrate. If no representation is found inferior or equal to\n *     this bitrate, the representation with the minimum bitrate will be taken.\n *\n * @class RepresentationChooser\n */\nvar RepresentationChooser = /** @class */ (function () {\n    /**\n     * @param {Object} options\n     */\n    function RepresentationChooser(options) {\n        this._dispose$ = new Subject_1.Subject();\n        this.manualBitrate$ = new BehaviorSubject_1.BehaviorSubject(options.manualBitrate != null ?\n            options.manualBitrate : -1);\n        this.maxAutoBitrate$ = new BehaviorSubject_1.BehaviorSubject(options.maxAutoBitrate != null ?\n            options.maxAutoBitrate : Infinity);\n        this.estimator = new bandwidth_estimator_1.default();\n        this._currentRequests = {};\n        this._initialBitrate = options.initialBitrate || 0;\n        this._limitWidth$ = options.limitWidth$;\n        this._throttle$ = options.throttle$;\n    }\n    /**\n     * @param {Observable} clock$\n     * @param {Array.<Object>} representations\n     * @returns {Observable}\n     */\n    RepresentationChooser.prototype.get$ = function (clock$, representations) {\n        var _this = this;\n        if (representations.length < 2) {\n            return Observable_1.Observable.of({\n                bitrate: undefined,\n                representation: representations.length ?\n                    representations[0] : null,\n            })\n                .takeUntil(this._dispose$);\n        }\n        var _a = this, manualBitrate$ = _a.manualBitrate$, maxAutoBitrate$ = _a.maxAutoBitrate$, _initialBitrate = _a._initialBitrate;\n        var _deviceEventsArray = [];\n        if (this._limitWidth$) {\n            _deviceEventsArray.push(this._limitWidth$.map(function (width) { return ({ width: width }); }));\n        }\n        if (this._throttle$) {\n            _deviceEventsArray.push(this._throttle$.map(function (bitrate) { return ({ bitrate: bitrate }); }));\n        }\n        /**\n         * Emit restrictions on the pools of available representations to choose\n         * from.\n         * @type {Observable}\n         */\n        var deviceEvents$ = _deviceEventsArray.length ?\n            Observable_1.Observable.combineLatest.apply(Observable_1.Observable, _deviceEventsArray).map(function (args) { return objectAssign.apply(void 0, [{}].concat(args)); }) : Observable_1.Observable.of({});\n        /**\n         * Store the last client's bitrate generated by our estimation algorithms.\n         * @type {Number|undefined}\n         */\n        var lastEstimatedBitrate;\n        return manualBitrate$.switchMap(function (manualBitrate) {\n            if (manualBitrate >= 0) {\n                // MANUAL mode\n                return setManualRepresentation(representations, manualBitrate);\n            }\n            // AUTO mode\n            var inStarvationMode = false;\n            return Observable_1.Observable.combineLatest(clock$, maxAutoBitrate$, deviceEvents$)\n                .map(function (_a) {\n                var clock = _a[0], maxAutoBitrate = _a[1], deviceEvents = _a[2];\n                var nextBitrate;\n                var bandwidthEstimate;\n                var bufferGap = clock.bufferGap;\n                // Check for starvation == not much left to play\n                if (bufferGap <= ABR_STARVATION_GAP) {\n                    inStarvationMode = true;\n                }\n                else if (inStarvationMode && bufferGap >= OUT_OF_STARVATION_GAP) {\n                    inStarvationMode = false;\n                }\n                // If in starvation mode, check if the request for the next segment\n                // takes too much time relatively to the chunk's duration.\n                // If that's the case, re-calculate the bandwidth urgently based on\n                // this single request.\n                if (inStarvationMode) {\n                    var position = clock.position, bitrate = clock.bitrate;\n                    var nextSegmentPosition = bufferGap + position;\n                    var request = getConcernedRequest(_this._currentRequests, nextSegmentPosition);\n                    if (request) {\n                        var chunkDuration = request.duration, requestTimestamp = request.requestTimestamp;\n                        var now = Date.now();\n                        var requestTimeInSeconds = (now - requestTimestamp) / 1000;\n                        if (chunkDuration &&\n                            requestTakesTime(requestTimeInSeconds, chunkDuration)) {\n                            bandwidthEstimate = estimateRequestBandwidth(request, requestTimeInSeconds, bitrate);\n                            if (bandwidthEstimate != null) {\n                                // Reset all estimations to zero\n                                // Note: this is weird to do this type of \"global\" side effect\n                                // (for this class) in an observable, not too comfortable with\n                                // that.\n                                _this.resetEstimate();\n                                if (bitrate != null) {\n                                    nextBitrate = Math.min(bandwidthEstimate, bitrate, maxAutoBitrate);\n                                }\n                                else {\n                                    nextBitrate = Math.min(bandwidthEstimate, maxAutoBitrate);\n                                }\n                            }\n                        }\n                    }\n                }\n                // if nextBitrate is not yet defined, do the normal estimation\n                if (nextBitrate == null) {\n                    bandwidthEstimate = _this.estimator.getEstimate();\n                    var nextEstimate = void 0;\n                    if (bandwidthEstimate != null) {\n                        nextEstimate = inStarvationMode ?\n                            bandwidthEstimate * ABR_STARVATION_FACTOR :\n                            bandwidthEstimate * ABR_REGULAR_FACTOR;\n                    }\n                    else if (lastEstimatedBitrate != null) {\n                        nextEstimate = inStarvationMode ?\n                            lastEstimatedBitrate * ABR_STARVATION_FACTOR :\n                            lastEstimatedBitrate * ABR_REGULAR_FACTOR;\n                    }\n                    else {\n                        nextEstimate = _initialBitrate;\n                    }\n                    nextBitrate = Math.min(nextEstimate, maxAutoBitrate);\n                }\n                if (clock.speed > 1) {\n                    nextBitrate /= clock.speed;\n                }\n                var _representations = getFilteredRepresentations(representations, deviceEvents);\n                return {\n                    bitrate: bandwidthEstimate,\n                    representation: fromBitrateCeil_1.default(_representations, nextBitrate) ||\n                        representations[0],\n                };\n            }).do(function (_a) {\n                var bitrate = _a.bitrate;\n                if (bitrate != null) {\n                    lastEstimatedBitrate = bitrate;\n                }\n            }).share();\n        });\n    };\n    /**\n     * Add a bandwidth estimate by giving:\n     *   - the duration of the request, in s\n     *   - the size of the request in bytes\n     * @param {number} duration\n     * @param {number} size\n     */\n    RepresentationChooser.prototype.addEstimate = function (duration, size) {\n        if (duration != null && size != null) {\n            this.estimator.addSample(duration, size);\n        }\n    };\n    /**\n     * Reset all the estimates done until now.\n     * Useful when the network situation changed completely.\n     */\n    RepresentationChooser.prototype.resetEstimate = function () {\n        this.estimator.reset();\n    };\n    /**\n     * Add informations about a new pending request.\n     * This can be useful if the network bandwidth drastically changes to infer\n     * a new bandwidth through this single request.\n     * @param {string|number} id\n     * @param {Object} payload\n     */\n    RepresentationChooser.prototype.addPendingRequest = function (id, payload) {\n        if (this._currentRequests[id]) {\n            if (true) {\n                throw new Error(\"ABR: request already added.\");\n            }\n            log_1.default.warn(\"ABR: request already added.\");\n            return;\n        }\n        var _a = payload.value, time = _a.time, duration = _a.duration, requestTimestamp = _a.requestTimestamp;\n        this._currentRequests[id] = {\n            time: time,\n            duration: duration,\n            requestTimestamp: requestTimestamp,\n            progress: [],\n        };\n        this._currentRequests[id].progress = [];\n    };\n    /**\n     * Add progress informations to a pending request.\n     * Progress objects are a key part to calculate the bandwidth from a single\n     * request, in the case the user's bandwidth changes drastically while doing\n     * it.\n     * @param {string|number} id\n     * @param {Object} progress\n     */\n    RepresentationChooser.prototype.addRequestProgress = function (id, progress) {\n        if (!this._currentRequests[id]) {\n            if (true) {\n                throw new Error(\"ABR: progress for a request not added\");\n            }\n            log_1.default.warn(\"ABR: progress for a request not added\");\n            return;\n        }\n        this._currentRequests[id].progress.push(progress.value);\n    };\n    /**\n     * Remove a request previously set as pending through the addPendingRequest\n     * method.\n     * @param {string|number} id\n     */\n    RepresentationChooser.prototype.removePendingRequest = function (id) {\n        if (!this._currentRequests[id]) {\n            if (true) {\n                throw new Error(\"ABR: can't remove unknown request\");\n            }\n            log_1.default.warn(\"ABR: can't remove unknown request\");\n        }\n        delete this._currentRequests[id];\n    };\n    /**\n     * Remove informations about all pending requests.\n     */\n    RepresentationChooser.prototype.resetRequests = function () {\n        this._currentRequests = {};\n    };\n    /**\n     * TODO See if we can avoid this\n     */\n    RepresentationChooser.prototype.dispose = function () {\n        this._dispose$.next();\n        this.manualBitrate$.complete();\n        this.maxAutoBitrate$.complete();\n    };\n    return RepresentationChooser;\n}());\nexports.default = RepresentationChooser;\n\n\n//# sourceURL=webpack://RxPlayer/./src/core/abr/representation_chooser.ts?");

/***/ }),

/***/ "./src/core/api/clock.ts":
/*!*******************************!*\
  !*** ./src/core/api/clock.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * This file defines a global clock for the RxPlayer.\n *\n * Each clock tick also pass informations about the current state of the\n * video element to sub-parts of the player.\n */\nvar objectAssign = __webpack_require__(/*! object-assign */ \"./node_modules/object-assign/index.js\");\nvar Observable_1 = __webpack_require__(/*! rxjs/Observable */ \"./node_modules/rxjs/Observable.js\");\nvar ReplaySubject_1 = __webpack_require__(/*! rxjs/ReplaySubject */ \"./node_modules/rxjs/ReplaySubject.js\");\nvar config_1 = __webpack_require__(/*! ../../config */ \"./src/config.ts\");\nvar ranges_1 = __webpack_require__(/*! ../../utils/ranges */ \"./src/utils/ranges.ts\");\nvar SAMPLING_INTERVAL_MEDIASOURCE = config_1.default.SAMPLING_INTERVAL_MEDIASOURCE, SAMPLING_INTERVAL_NO_MEDIASOURCE = config_1.default.SAMPLING_INTERVAL_NO_MEDIASOURCE, RESUME_GAP_AFTER_SEEKING = config_1.default.RESUME_GAP_AFTER_SEEKING, RESUME_GAP_AFTER_NOT_ENOUGH_DATA = config_1.default.RESUME_GAP_AFTER_NOT_ENOUGH_DATA, RESUME_GAP_AFTER_BUFFERING = config_1.default.RESUME_GAP_AFTER_BUFFERING, STALL_GAP = config_1.default.STALL_GAP;\n/**\n * HTMLMediaElement Events for which timings are calculated and emitted.\n * @type {Array.<string>}\n */\nvar SCANNED_VIDEO_EVENTS = [\n    \"canplay\",\n    \"play\",\n    \"progress\",\n    \"seeking\",\n    \"seeked\",\n    \"loadedmetadata\",\n    \"canplay\",\n    \"ratechange\",\n];\n/**\n * Returns the amount of time in seconds the buffer should have ahead of the\n * current position before resuming playback. Based on the infos of the stall.\n * Waiting time differs between a \"seeking\" stall and a buffering stall.\n * @param {Object|null} stalled\n * @returns {Number}\n */\nfunction getResumeGap(stalled) {\n    if (!stalled) {\n        return 0;\n    }\n    switch (stalled.reason) {\n        case \"seeking\":\n            return RESUME_GAP_AFTER_SEEKING;\n        case \"not-ready\":\n            return RESUME_GAP_AFTER_NOT_ENOUGH_DATA;\n        default:\n            return RESUME_GAP_AFTER_BUFFERING;\n    }\n}\n/**\n * TODO I just don't get it for this one.\n * gap + range.end ??? HELP\n * @param {Number} gap\n * @param {Object} range\n * @param {Number} duration\n * @returns {Boolean}\n */\nfunction isEnding(bufferGap, currentRange, duration) {\n    return currentRange != null &&\n        (duration - (bufferGap + currentRange.end)) <= STALL_GAP;\n}\n/**\n * Generate a basic timings object from the video element and the eventName\n * which triggered the request.\n * @param {HTMLMediaElement} video\n * @param {string} currentState\n * @returns {Object}\n */\nfunction getVideoInfos(video, currentState) {\n    var buffered = video.buffered, currentTime = video.currentTime, duration = video.duration, ended = video.ended, paused = video.paused, playbackRate = video.playbackRate, readyState = video.readyState, seeking = video.seeking;\n    return {\n        bufferGap: ranges_1.getLeftSizeOfRange(buffered, currentTime),\n        buffered: buffered,\n        currentRange: ranges_1.getRange(buffered, currentTime),\n        currentTime: currentTime,\n        duration: duration,\n        ended: ended,\n        paused: paused,\n        playbackRate: playbackRate,\n        readyState: readyState,\n        seeking: seeking,\n        state: currentState,\n    };\n}\n/**\n * Infer stalled status of the video based on:\n *   - the return of the function getVideoInfos\n *   - the previous timings object.\n *\n * @param {Object} prevTimings - Previous timings object. See function to know\n * the different properties needed.\n * @param {Object} currentTimings - Current timings object. This does not need\n * to have every single infos, see function to know which properties are needed.\n * @param {Boolean} withMediaSource - False if the directfile API is used.\n * @returns {Object|null}\n */\nfunction getStalledStatus(prevTimings, currentTimings, withMediaSource) {\n    var currentState = currentTimings.state, currentTime = currentTimings.currentTime, bufferGap = currentTimings.bufferGap, currentRange = currentTimings.currentRange, duration = currentTimings.duration, paused = currentTimings.paused, readyState = currentTimings.readyState, ended = currentTimings.ended;\n    var prevStalled = prevTimings.stalled, prevState = prevTimings.state, prevTime = prevTimings.currentTime;\n    var ending = isEnding(bufferGap, currentRange, duration);\n    var canStall = (readyState >= 1 &&\n        currentState !== \"loadedmetadata\" &&\n        !prevStalled &&\n        !(ending || ended));\n    var shouldStall;\n    var shouldUnstall;\n    if (withMediaSource) {\n        if (canStall &&\n            (bufferGap <= STALL_GAP || bufferGap === Infinity || readyState === 1)) {\n            shouldStall = true;\n        }\n        else if (prevStalled &&\n            readyState > 1 &&\n            bufferGap < Infinity && (bufferGap > getResumeGap(prevStalled) || ending || ended)) {\n            shouldUnstall = true;\n        }\n    }\n    // when using a direct file, the video will stall and unstall on its\n    // own, so we only try to detect when the video timestamp has not changed\n    // between two consecutive timeupdates\n    else {\n        if (canStall &&\n            (!paused && currentState === \"timeupdate\" &&\n                prevState === \"timeupdate\" && currentTime === prevTime ||\n                currentState === \"seeking\" && bufferGap === Infinity)) {\n            shouldStall = true;\n        }\n        else if (prevStalled &&\n            (currentState !== \"seeking\" && currentTime !== prevTime ||\n                currentState === \"canplay\" ||\n                bufferGap < Infinity &&\n                    (bufferGap > getResumeGap(prevStalled) || ending || ended))) {\n            shouldUnstall = true;\n        }\n    }\n    if (shouldStall) {\n        var reason = void 0;\n        if (currentState === \"seeking\" || currentTimings.seeking) {\n            reason = \"seeking\";\n        }\n        else if (readyState === 1) {\n            reason = \"not-ready\";\n        }\n        else {\n            reason = \"buffering\";\n        }\n        return {\n            reason: reason,\n            timestamp: Date.now(),\n        };\n    }\n    else if (shouldUnstall) {\n        return null;\n    }\n    else {\n        return prevStalled;\n    }\n}\n/**\n * Timings observable.\n *\n * This streams samples snapshots of player's current state:\n *   * time position\n *   * playback rate\n *   * current buffered range\n *   * gap with current buffered range ending\n *   * video duration\n *\n * In addition to sampling, this stream also reacts to \"seeking\" and \"play\"\n * events.\n *\n * Observable is shared for performance reason: reduces the number of event\n * listeners and intervals/timeouts but also limit access to <video>\n * properties and gap calculations.\n *\n * The sampling is manual instead of based on \"timeupdate\" to reduce the\n * number of events.\n * @param {HTMLMediaElement} video\n * @param {Object} options\n * @returns {Observable}\n */\nfunction createClock(video, _a) {\n    var withMediaSource = _a.withMediaSource;\n    return Observable_1.Observable.create(function (obs) {\n        var lastTimings = objectAssign(getVideoInfos(video, \"init\"), { stalled: null });\n        /**\n         * Emit timings sample.\n         * Meant to be used as a callback on various async events.\n         * @param {Event} [evt] - The Event which triggered the callback, if one.\n         */\n        function emitSample(evt) {\n            var timingEventType = evt && evt.type || \"timeupdate\";\n            var videoTimings = getVideoInfos(video, timingEventType);\n            var stalledState = getStalledStatus(lastTimings, videoTimings, withMediaSource);\n            // /!\\ Mutate videoTimings\n            lastTimings = objectAssign(videoTimings, { stalled: stalledState });\n            obs.next(lastTimings);\n        }\n        var interval = withMediaSource\n            ? SAMPLING_INTERVAL_MEDIASOURCE\n            : SAMPLING_INTERVAL_NO_MEDIASOURCE;\n        var intervalID = setInterval(emitSample, interval);\n        SCANNED_VIDEO_EVENTS.forEach(function (eventName) {\n            return video.addEventListener(eventName, emitSample);\n        });\n        obs.next(lastTimings);\n        return function () {\n            clearInterval(intervalID);\n            SCANNED_VIDEO_EVENTS.forEach(function (eventName) {\n                return video.removeEventListener(eventName, emitSample);\n            });\n        };\n    })\n        .multicast(function () { return new ReplaySubject_1.ReplaySubject(1); }) // Always emit the last\n        // item on subscription\n        .refCount();\n}\nexports.default = createClock;\n\n\n//# sourceURL=webpack://RxPlayer/./src/core/api/clock.ts?");

/***/ }),

/***/ "./src/core/api/constants.ts":
/*!***********************************!*\
  !*** ./src/core/api/constants.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * This file declares constants useful for every API files.\n */\n/**\n * Player state dictionnary\n * @type {Object}\n */\nexports.PLAYER_STATES = {\n    STOPPED: \"STOPPED\",\n    LOADED: \"LOADED\",\n    LOADING: \"LOADING\",\n    PLAYING: \"PLAYING\",\n    PAUSED: \"PAUSED\",\n    ENDED: \"ENDED\",\n    BUFFERING: \"BUFFERING\",\n    SEEKING: \"SEEKING\",\n};\n\n\n//# sourceURL=webpack://RxPlayer/./src/core/api/constants.ts?");

/***/ }),

/***/ "./src/core/api/get_player_state.ts":
/*!******************************************!*\
  !*** ./src/core/api/get_player_state.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar config_1 = __webpack_require__(/*! ../../config */ \"./src/config.ts\");\nvar constants_1 = __webpack_require__(/*! ./constants */ \"./src/core/api/constants.ts\");\n/**\n * Get state string for a loaded content.\n * @param {HTMLMediaElement} mediaElement\n * @param {boolean} isPlaying - false when the player is paused. true otherwise.\n * @param {Object} stalledStatus - Current stalled state:\n *   - null when not stalled\n *   - an object with a description of the situation if stalled.\n * @returns {string}\n */\nfunction getLoadedContentState(mediaElement, isPlaying, stalledStatus) {\n    if (mediaElement.ended) {\n        return constants_1.PLAYER_STATES.ENDED;\n    }\n    if (stalledStatus) {\n        // TODO This is a TypeScript bug. Try to reproduce it easily and\n        // open an issue:\n        // Basically, putting this line at the top of the file would\n        // trigger a TypeScript error down the line.\n        var FORCED_ENDED_THRESHOLD = config_1.default.FORCED_ENDED_THRESHOLD;\n        // On some old browsers (e.g. Chrome 54), the browser does not\n        // emit an 'ended' event in some conditions. Detect if we\n        // reached the end by comparing the current position and the\n        // duration instead.\n        var gapBetweenDurationAndCurrentTime = Math.abs(mediaElement.duration - mediaElement.currentTime);\n        if (FORCED_ENDED_THRESHOLD != null &&\n            gapBetweenDurationAndCurrentTime < FORCED_ENDED_THRESHOLD) {\n            return constants_1.PLAYER_STATES.ENDED;\n        }\n        return stalledStatus.reason === \"seeking\" ?\n            constants_1.PLAYER_STATES.SEEKING :\n            constants_1.PLAYER_STATES.BUFFERING;\n    }\n    return isPlaying ? constants_1.PLAYER_STATES.PLAYING : constants_1.PLAYER_STATES.PAUSED;\n}\nexports.default = getLoadedContentState;\n\n\n//# sourceURL=webpack://RxPlayer/./src/core/api/get_player_state.ts?");

/***/ }),

/***/ "./src/core/api/index.ts":
/*!*******************************!*\
  !*** ./src/core/api/index.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * This file and directory defines the public API for the RxPlayer.\n *\n * It also starts the different sub-parts of the player on various API calls.\n */\nvar deepEqual = __webpack_require__(/*! deep-equal */ \"./node_modules/deep-equal/index.js\");\nvar BehaviorSubject_1 = __webpack_require__(/*! rxjs/BehaviorSubject */ \"./node_modules/rxjs/BehaviorSubject.js\");\nvar Observable_1 = __webpack_require__(/*! rxjs/Observable */ \"./node_modules/rxjs/Observable.js\");\nvar ReplaySubject_1 = __webpack_require__(/*! rxjs/ReplaySubject */ \"./node_modules/rxjs/ReplaySubject.js\");\nvar Subject_1 = __webpack_require__(/*! rxjs/Subject */ \"./node_modules/rxjs/Subject.js\");\nvar config_1 = __webpack_require__(/*! ../../config */ \"./src/config.ts\");\nvar assert_1 = __webpack_require__(/*! ../../utils/assert */ \"./src/utils/assert.ts\");\nvar eventemitter_1 = __webpack_require__(/*! ../../utils/eventemitter */ \"./src/utils/eventemitter.ts\");\nvar log_1 = __webpack_require__(/*! ../../utils/log */ \"./src/utils/log.ts\");\nvar noop_1 = __webpack_require__(/*! ../../utils/noop */ \"./src/utils/noop.ts\");\nvar ranges_1 = __webpack_require__(/*! ../../utils/ranges */ \"./src/utils/ranges.ts\");\nvar compat_1 = __webpack_require__(/*! ../../compat */ \"./src/compat/index.ts\");\nvar events_1 = __webpack_require__(/*! ../../compat/events */ \"./src/compat/events.ts\");\nvar errors_1 = __webpack_require__(/*! ../../errors */ \"./src/errors/index.ts\");\nvar timings_1 = __webpack_require__(/*! ../../manifest/timings */ \"./src/manifest/timings.ts\");\nvar net_1 = __webpack_require__(/*! ../../net */ \"./src/net/index.ts\");\nvar eme_1 = __webpack_require__(/*! ../eme */ \"./src/core/eme/index.ts\");\nvar stream_1 = __webpack_require__(/*! ../stream */ \"./src/core/stream/index.ts\");\nvar directfile_1 = __webpack_require__(/*! ../stream/directfile */ \"./src/core/stream/directfile.ts\");\nvar clock_1 = __webpack_require__(/*! ./clock */ \"./src/core/api/clock.ts\");\nvar constants_1 = __webpack_require__(/*! ./constants */ \"./src/core/api/constants.ts\");\nvar get_player_state_1 = __webpack_require__(/*! ./get_player_state */ \"./src/core/api/get_player_state.ts\");\nvar language_manager_1 = __webpack_require__(/*! ./language_manager */ \"./src/core/api/language_manager.ts\");\nvar option_parsers_1 = __webpack_require__(/*! ./option_parsers */ \"./src/core/api/option_parsers.ts\");\nvar DEFAULT_UNMUTED_VOLUME = config_1.default.DEFAULT_UNMUTED_VOLUME;\n/**\n * @class Player\n * @extends EventEmitter\n */\nvar Player = /** @class */ (function (_super) {\n    __extends(Player, _super);\n    /**\n     * Note: as the private state from this class can be pretty heavy, every\n     * private properties should be initialized here for better visibility.\n     * @constructor\n     * @param {Object} options\n     * @param {HTMLMediaElement} options.videoElement\n     */\n    function Player(options) {\n        if (options === void 0) { options = {}; }\n        var _this = _super.call(this) || this;\n        var _a = option_parsers_1.parseConstructorOptions(options), initialAudioBitrate = _a.initialAudioBitrate, initialVideoBitrate = _a.initialVideoBitrate, limitVideoWidth = _a.limitVideoWidth, maxAudioBitrate = _a.maxAudioBitrate, maxBufferAhead = _a.maxBufferAhead, maxBufferBehind = _a.maxBufferBehind, maxVideoBitrate = _a.maxVideoBitrate, throttleWhenHidden = _a.throttleWhenHidden, videoElement = _a.videoElement, wantedBufferAhead = _a.wantedBufferAhead, stopAtEnd = _a.stopAtEnd;\n        // Workaround to support Firefox autoplay on FF 42.\n        // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1194624\n        videoElement.preload = \"auto\";\n        _this.version = /*PLAYER_VERSION*/ \"3.4.0\";\n        _this.log = log_1.default;\n        _this.state = \"STOPPED\";\n        _this.videoElement = videoElement;\n        _this._priv_destroy$ = new Subject_1.Subject();\n        events_1.onFullscreenChange$(videoElement)\n            .takeUntil(_this._priv_destroy$)\n            .subscribe(function () { return _this.trigger(\"fullscreenChange\", _this.isFullscreen()); });\n        events_1.onTextTrackChanges$(videoElement.textTracks)\n            .takeUntil(_this._priv_destroy$)\n            .map(function (evt) {\n            var target = evt.target;\n            var arr = [];\n            for (var i = 0; i < target.length; i++) {\n                var textTrack = target[i];\n                arr.push(textTrack);\n            }\n            return arr;\n        })\n            // We can have two consecutive textTrackChanges with the exact same\n            // payload when we perform multiple texttrack operations before the event\n            // loop is freed.\n            // In that case we only want to fire one time the observable.\n            .distinctUntilChanged(function (textTracksA, textTracksB) {\n            if (textTracksA.length !== textTracksB.length) {\n                return false;\n            }\n            for (var i = 0; i < textTracksA.length; i++) {\n                if (textTracksA[i] !== textTracksB[i]) {\n                    return false;\n                }\n            }\n            return true;\n        })\n            .subscribe(function (x) { return _this._priv_onNativeTextTracksNext(x); });\n        _this._priv_playing$ = new ReplaySubject_1.ReplaySubject(1);\n        _this._priv_speed$ = new BehaviorSubject_1.BehaviorSubject(videoElement.playbackRate);\n        _this._priv_stopCurrentContent$ = new Subject_1.Subject();\n        _this._priv_streamLock$ = new BehaviorSubject_1.BehaviorSubject(false);\n        _this._priv_bufferOptions = {\n            wantedBufferAhead$: new BehaviorSubject_1.BehaviorSubject(wantedBufferAhead),\n            maxBufferAhead$: new BehaviorSubject_1.BehaviorSubject(maxBufferAhead),\n            maxBufferBehind$: new BehaviorSubject_1.BehaviorSubject(maxBufferBehind),\n        };\n        _this._priv_bitrateInfos = {\n            lastBitrates: {\n                audio: initialAudioBitrate,\n                video: initialVideoBitrate,\n            },\n            initialMaxAutoBitrates: {\n                audio: maxAudioBitrate,\n                video: maxVideoBitrate,\n            },\n            manualBitrates: {\n                audio: -1,\n                video: -1,\n            },\n        };\n        _this._priv_throttleWhenHidden = throttleWhenHidden;\n        _this._priv_limitVideoWidth = limitVideoWidth;\n        _this._priv_mutedMemory = DEFAULT_UNMUTED_VOLUME;\n        _this._priv_languageManager = null;\n        _this._priv_abrManager = null;\n        _this._priv_currentError = null;\n        _this._priv_contentInfos = null;\n        _this._priv_contentEventsMemory = {\n            period: null,\n            audioTrack: null,\n            textTrack: null,\n            videoBitrate: null,\n            audioBitrate: null,\n            bitrateEstimation: undefined,\n        };\n        _this._priv_stopAtEnd = stopAtEnd;\n        _this._priv_setPlayerState(constants_1.PLAYER_STATES.STOPPED);\n        return _this;\n    }\n    Object.defineProperty(Player, \"ErrorTypes\", {\n        /**\n         * @returns {Object}\n         */\n        get: function () {\n            return errors_1.ErrorTypes;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Player, \"ErrorCodes\", {\n        /**\n         * @returns {Object}\n         */\n        get: function () {\n            return errors_1.ErrorCodes;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Player, \"LogLevel\", {\n        /**\n         * @returns {string} - current log level\n         */\n        get: function () {\n            return log_1.default.getLevel();\n        },\n        /**\n         * @param {string} logLevel - should be either (by verbosity ascending):\n         *   - \"NONE\"\n         *   - \"ERROR\"\n         *   - \"WARNING\"\n         *   - \"INFO\"\n         *   - \"DEBUG\"\n         * Any other value will be translated to \"NONE\".\n         */\n        set: function (logLevel) {\n            log_1.default.setLevel(logLevel);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Stop the player.\n     */\n    Player.prototype.stop = function () {\n        if (this.state !== constants_1.PLAYER_STATES.STOPPED) {\n            this._priv_stopCurrentContent$.next();\n            this._priv_cleanUpCurrentContentState();\n            this._priv_setPlayerState(constants_1.PLAYER_STATES.STOPPED);\n        }\n    };\n    /**\n     * Free the resources used by the player.\n     */\n    Player.prototype.dispose = function () {\n        // free resources linked to the loaded content\n        this.stop();\n        if (this.videoElement) {\n            // free resources used for EME management\n            eme_1.disposeEME(this.videoElement);\n        }\n        // free Observables linked to the Player instance\n        this._priv_destroy$.next();\n        this._priv_destroy$.complete();\n        // Complete all subjects\n        this._priv_stopCurrentContent$.complete();\n        this._priv_playing$.complete();\n        this._priv_speed$.complete();\n        this._priv_streamLock$.complete();\n        this._priv_bufferOptions.wantedBufferAhead$.complete();\n        this._priv_bufferOptions.maxBufferAhead$.complete();\n        this._priv_bufferOptions.maxBufferBehind$.complete();\n        // un-attach video element\n        this.videoElement = null;\n    };\n    /**\n     * Load a new video.\n     * @param {Object} opts\n     * @returns {Observable}\n     * @throws Error - throws if no url is given.\n     * @throws Error - throws if no transport is given and no default transport\n     * has been set.\n     * @throws Error - throws if the asked transport does not exist\n     */\n    Player.prototype.loadVideo = function (opts) {\n        var _this = this;\n        var options = option_parsers_1.parseLoadVideoOptions(opts);\n        log_1.default.info(\"loadvideo\", options);\n        var autoPlay = options.autoPlay, defaultAudioTrack = options.defaultAudioTrack, defaultTextTrack = options.defaultTextTrack, keySystems = options.keySystems, networkConfig = options.networkConfig, startAt = options.startAt, supplementaryImageTracks = options.supplementaryImageTracks, supplementaryTextTracks = options.supplementaryTextTracks, transport = options.transport, transportOptions = options.transportOptions, url = options.url;\n        // Perform multiple checks on the given options\n        if (!this.videoElement) {\n            throw new Error(\"the attached video element is disposed\");\n        }\n        // now that every check has passed, stop previous content\n        // TODO First stop?\n        this.stop();\n        var isDirectFile = transport === \"directfile\";\n        this._priv_currentError = null;\n        this._priv_contentInfos = {\n            url: url,\n            isDirectFile: isDirectFile,\n            thumbnails: null,\n            manifest: null,\n            currentPeriod: null,\n            activeAdaptations: null,\n            activeRepresentations: null,\n            initialAudioTrack: defaultAudioTrack,\n            initialTextTrack: defaultTextTrack,\n        };\n        // inilialize to false\n        this._priv_playing$.next(false);\n        // get every properties used from context for clarity\n        var videoElement = this.videoElement;\n        /**\n         * Global clock used for the whole application.\n         * @type {Observable.<Object>}\n         */\n        var clock$ = clock_1.default(videoElement, {\n            withMediaSource: !isDirectFile,\n        });\n        var closeStream$ = Observable_1.Observable.merge(this._priv_stopCurrentContent$, this._priv_stopAtEnd ? events_1.onEnded$(videoElement) : Observable_1.Observable.empty()).take(1);\n        var stream;\n        if (!isDirectFile) {\n            var transportFn = net_1.default[transport];\n            if (!transportFn) {\n                throw new Error(\"transport \\\"\" + transport + \"\\\" not supported\");\n            }\n            var transportObj = transportFn(transportOptions);\n            /**\n             * Options used by the ABR Manager.\n             * @type {Object}\n             */\n            var adaptiveOptions = {\n                initialBitrates: this._priv_bitrateInfos.lastBitrates,\n                manualBitrates: this._priv_bitrateInfos.manualBitrates,\n                maxAutoBitrates: this._priv_bitrateInfos.initialMaxAutoBitrates,\n                throttle: this._priv_throttleWhenHidden ? {\n                    video: events_1.isInBackground$()\n                        .map(function (isBg) { return isBg ? 0 : Infinity; })\n                        .takeUntil(this._priv_stopCurrentContent$),\n                } : {},\n                limitWidth: this._priv_limitVideoWidth ? {\n                    video: events_1.videoWidth$(videoElement)\n                        .takeUntil(this._priv_stopCurrentContent$),\n                } : {},\n            };\n            /**\n             * Options used by the TextTrack SourceBuffer\n             * @type {Object}\n             */\n            var textTrackOptions = options.textTrackMode === \"native\" ? {\n                textTrackMode: \"native\",\n                hideNativeSubtitle: options.hideNativeSubtitle,\n            } : {\n                textTrackMode: \"html\",\n                textTrackElement: options.textTrackElement,\n            };\n            /**\n             * Stream Observable, through which the content will be launched.\n             * @type {Observable.<Object>}\n             */\n            stream = stream_1.default({\n                adaptiveOptions: adaptiveOptions,\n                autoPlay: autoPlay,\n                bufferOptions: this._priv_bufferOptions,\n                clock$: clock$,\n                keySystems: keySystems,\n                networkConfig: networkConfig,\n                speed$: this._priv_speed$,\n                startAt: startAt,\n                supplementaryImageTracks: supplementaryImageTracks,\n                supplementaryTextTracks: supplementaryTextTracks,\n                textTrackOptions: textTrackOptions,\n                transport: transportObj,\n                url: url,\n                videoElement: videoElement,\n            })\n                .takeUntil(closeStream$)\n                .publish();\n        }\n        else {\n            stream = directfile_1.default({\n                autoPlay: autoPlay,\n                clock$: clock$,\n                keySystems: keySystems,\n                mediaElement: videoElement,\n                speed$: this._priv_speed$,\n                startAt: startAt,\n                url: url,\n            })\n                .takeUntil(closeStream$)\n                .publish();\n        }\n        /**\n         * Emit a truthy value when the player stalls, a falsy value as it unstalls.\n         * TODO Find a way with TS\n         * @type {Observable}\n         */\n        var stalled$ = stream\n            .filter(function (_a) {\n            var type = _a.type;\n            return type === \"stalled\";\n        })\n            .map(function (x) { return x.value; });\n        /**\n         * Emit when the stream is considered \"loaded\".\n         * @type {Observable}\n         */\n        var loaded = stream\n            .filter(function (_a) {\n            var type = _a.type;\n            return type === \"loaded\";\n        })\n            .take(1)\n            .share();\n        /**\n         * Emit when the media element emits an \"ended\" event.\n         * @type {Observable}\n         */\n        var endedEvent$ = events_1.onEnded$(videoElement);\n        /**\n         * Emit when the media element emits a \"seeking\" event.\n         * @type {Observable}\n         */\n        var seekingEvent$ = events_1.onSeeking$(videoElement);\n        /**\n         * Emit the player state as it changes.\n         * TODO only way to call setPlayerState?\n         * @type {Observable.<string>}\n         */\n        var stateChanges$ = loaded.mapTo(constants_1.PLAYER_STATES.LOADED)\n            .concat(Observable_1.Observable.combineLatest(this._priv_playing$, stalled$.startWith(null), endedEvent$.startWith(null), seekingEvent$.startWith(null))\n            .takeUntil(this._priv_stopCurrentContent$)\n            .map(function (_a) {\n            var isPlaying = _a[0], stalledStatus = _a[1];\n            return get_player_state_1.default(videoElement, isPlaying, stalledStatus);\n        })\n            // begin emitting those only when the content start to play\n            .skipUntil(this._priv_playing$.filter(function (isPlaying) { return isPlaying; })))\n            .distinctUntilChanged()\n            .startWith(constants_1.PLAYER_STATES.LOADING);\n        /**\n         * Emit true each time the player goes into a \"play\" state.\n         * @type {Observable.<Boolean>}\n         */\n        var videoPlays$ = events_1.onPlayPause$(videoElement)\n            .map(function (evt) { return evt.type === \"play\"; });\n        var streamDisposable;\n        this._priv_stopCurrentContent$.take(1).subscribe(function () {\n            if (streamDisposable) {\n                streamDisposable.unsubscribe();\n            }\n        });\n        videoPlays$\n            .takeUntil(this._priv_stopCurrentContent$)\n            .subscribe(function (x) { return _this._priv_onPlayPauseNext(x); }, noop_1.default);\n        clock$\n            .takeUntil(this._priv_stopCurrentContent$)\n            .subscribe(function (x) { return _this._priv_triggerTimeChange(x); }, noop_1.default);\n        stateChanges$\n            .takeUntil(this._priv_stopCurrentContent$)\n            .subscribe(function (x) { return _this._priv_setPlayerState(x); }, noop_1.default);\n        stream.subscribe(function (x) { return _this._priv_onStreamNext(x); }, function (err) { return _this._priv_onStreamError(err); }, function () { return _this._priv_onStreamComplete(); });\n        // connect the stream when the lock is inactive\n        this._priv_streamLock$\n            .filter(function (isLocked) { return !isLocked; })\n            .take(1)\n            .takeUntil(this._priv_stopCurrentContent$)\n            .subscribe(function () {\n            streamDisposable = stream.connect();\n        });\n    };\n    /**\n     * Returns fatal error if one for the current content. null otherwise.\n     * @returns {Object|null}\n     */\n    Player.prototype.getError = function () {\n        return this._priv_currentError;\n    };\n    /**\n     * Returns manifest/playlist object.\n     * null if the player is STOPPED.\n     * @returns {Manifest|null}\n     */\n    Player.prototype.getManifest = function () {\n        return this._priv_contentInfos && this._priv_contentInfos.manifest;\n    };\n    /**\n     * Returns adaptations (tracks) for every currently playing type\n     * (audio/video/text...).\n     * @returns {Object|null}\n     */\n    Player.prototype.getCurrentAdaptations = function () {\n        if (!this._priv_contentInfos) {\n            return null;\n        }\n        var _a = this._priv_contentInfos, currentPeriod = _a.currentPeriod, activeAdaptations = _a.activeAdaptations;\n        if (!currentPeriod || !activeAdaptations) {\n            return null;\n        }\n        return activeAdaptations.get(currentPeriod) || null;\n    };\n    /**\n     * Returns representations (qualities) for every currently playing type\n     * (audio/video/text...).\n     * @returns {Object|null}\n     */\n    Player.prototype.getCurrentRepresentations = function () {\n        if (!this._priv_contentInfos) {\n            return null;\n        }\n        var _a = this._priv_contentInfos, currentPeriod = _a.currentPeriod, activeRepresentations = _a.activeRepresentations;\n        if (!currentPeriod || !activeRepresentations) {\n            return null;\n        }\n        return activeRepresentations.get(currentPeriod) || null;\n    };\n    /**\n     * Returns the video DOM element used by the player.\n     * You should not its HTML5 API directly and use the player's method instead,\n     * to ensure a well-behaved player.\n     * @returns {HTMLMediaElement|null}\n     */\n    Player.prototype.getVideoElement = function () {\n        return this.videoElement;\n    };\n    /**\n     * Returns the text-track element used by the player to inject subtitles.\n     * @returns {TextTrack}\n     */\n    Player.prototype.getNativeTextTrack = function () {\n        if (!this.videoElement) {\n            throw new Error(\"Disposed player\");\n        }\n        var videoElement = this.videoElement;\n        var textTracks = videoElement.textTracks;\n        if (textTracks.length > 0) {\n            return videoElement.textTracks[0];\n        }\n        else {\n            return null;\n        }\n    };\n    /**\n     * Returns the player's current state.\n     * @returns {string}\n     */\n    Player.prototype.getPlayerState = function () {\n        return this.state;\n    };\n    /**\n     * Returns true if:\n     *   - a content is loaded\n     *   - the content is a live content\n     * @returns {Boolean}\n     */\n    Player.prototype.isLive = function () {\n        if (!this._priv_contentInfos) {\n            return false;\n        }\n        var _a = this._priv_contentInfos, isDirectFile = _a.isDirectFile, manifest = _a.manifest;\n        if (isDirectFile || !manifest) {\n            return false;\n        }\n        return manifest.isLive;\n    };\n    /**\n     * Returns the url of the content's manifest\n     * @returns {string|undefined}\n     */\n    Player.prototype.getUrl = function () {\n        if (!this._priv_contentInfos) {\n            return undefined;\n        }\n        var _a = this._priv_contentInfos, isDirectFile = _a.isDirectFile, manifest = _a.manifest, url = _a.url;\n        if (isDirectFile) {\n            return url;\n        }\n        if (manifest) {\n            return manifest.getUrl();\n        }\n        return undefined;\n    };\n    /**\n     * Returns the video duration, in seconds.\n     * NaN if no video is playing.\n     * @returns {Number}\n     */\n    Player.prototype.getVideoDuration = function () {\n        if (!this.videoElement) {\n            throw new Error(\"Disposed player\");\n        }\n        return this.videoElement.duration;\n    };\n    /**\n     * Returns in seconds the difference between:\n     *   - the end of the current contiguous loaded range.\n     *   - the current time\n     * @returns {Number}\n     */\n    Player.prototype.getVideoBufferGap = function () {\n        if (!this.videoElement) {\n            throw new Error(\"Disposed player\");\n        }\n        var videoElement = this.videoElement;\n        return ranges_1.getLeftSizeOfRange(videoElement.buffered, videoElement.currentTime);\n    };\n    /**\n     * Returns in seconds the difference between:\n     *   - the end of the current contiguous loaded range.\n     *   - the start of the current contiguous loaded range.\n     * @returns {Number}\n     */\n    Player.prototype.getVideoLoadedTime = function () {\n        if (!this.videoElement) {\n            throw new Error(\"Disposed player\");\n        }\n        var videoElement = this.videoElement;\n        return ranges_1.getSizeOfRange(videoElement.buffered, videoElement.currentTime);\n    };\n    /**\n     * Returns in seconds the difference between:\n     *   - the current time.\n     *   - the start of the current contiguous loaded range.\n     * @returns {Number}\n     */\n    Player.prototype.getVideoPlayedTime = function () {\n        if (!this.videoElement) {\n            throw new Error(\"Disposed player\");\n        }\n        var videoElement = this.videoElement;\n        return ranges_1.getPlayedSizeOfRange(videoElement.buffered, videoElement.currentTime);\n    };\n    /**\n     * Get the current position, in s, in wall-clock time.\n     * That is:\n     *   - for live content, get a timestamp, in s, of the current played content.\n     *   - for static content, returns the position from beginning in s.\n     *\n     * If you do not know if you want to use this method or getPosition:\n     *   - If what you want is to display the current time to the user, use this\n     *     one.\n     *   - If what you want is to interact with the player's API or perform other\n     *     actions (like statistics) with the real player data, use getPosition.\n     *\n     * @returns {Number}\n     */\n    Player.prototype.getWallClockTime = function () {\n        if (!this.videoElement) {\n            throw new Error(\"Disposed player\");\n        }\n        if (!this._priv_contentInfos) {\n            return this.videoElement.currentTime;\n        }\n        var _a = this._priv_contentInfos, isDirectFile = _a.isDirectFile, manifest = _a.manifest;\n        if (isDirectFile) {\n            return this.videoElement.currentTime;\n        }\n        if (manifest) {\n            var currentTime = this.videoElement.currentTime;\n            return this.isLive() ?\n                (+timings_1.toWallClockTime(currentTime, manifest) / 1000) :\n                currentTime;\n        }\n        return 0;\n    };\n    /**\n     * Get the current position, in seconds, of the video element.\n     *\n     * If you do not know if you want to use this method or getWallClockTime:\n     *   - If what you want is to display the current time to the user, use\n     *     getWallClockTime.\n     *   - If what you want is to interact with the player's API or perform other\n     *     actions (like statistics) with the real player data, use this one.\n     *\n     * @returns {Number}\n     */\n    Player.prototype.getPosition = function () {\n        if (!this.videoElement) {\n            throw new Error(\"Disposed player\");\n        }\n        return this.videoElement.currentTime;\n    };\n    /**\n     * Returns the current speed at which the video plays.\n     * @returns {Number}\n     */\n    Player.prototype.getPlaybackRate = function () {\n        return this._priv_speed$.getValue();\n    };\n    /**\n     * @returns {Number}\n     */\n    Player.prototype.getVolume = function () {\n        if (!this.videoElement) {\n            throw new Error(\"Disposed player\");\n        }\n        return this.videoElement.volume;\n    };\n    /**\n     * @returns {Boolean}\n     */\n    Player.prototype.isFullscreen = function () {\n        return compat_1.isFullscreen();\n    };\n    /**\n     * @returns {Array.<Number>}\n     */\n    Player.prototype.getAvailableVideoBitrates = function () {\n        if (!this._priv_contentInfos) {\n            return [];\n        }\n        var _a = this._priv_contentInfos, currentPeriod = _a.currentPeriod, activeAdaptations = _a.activeAdaptations;\n        if (!currentPeriod || !activeAdaptations) {\n            return [];\n        }\n        var adaptations = activeAdaptations.get(currentPeriod);\n        var videoAdaptation = adaptations && adaptations.video;\n        if (!videoAdaptation) {\n            return [];\n        }\n        return videoAdaptation.representations\n            .map(function (_a) {\n            var bitrate = _a.bitrate;\n            return bitrate;\n        });\n    };\n    /**\n     * @returns {Array.<Number>}\n     */\n    Player.prototype.getAvailableAudioBitrates = function () {\n        if (!this._priv_contentInfos) {\n            return [];\n        }\n        var _a = this._priv_contentInfos, currentPeriod = _a.currentPeriod, activeAdaptations = _a.activeAdaptations;\n        if (!currentPeriod || !activeAdaptations) {\n            return [];\n        }\n        var adaptations = activeAdaptations.get(currentPeriod);\n        var audioAdaptation = adaptations && adaptations.audio;\n        if (!audioAdaptation) {\n            return [];\n        }\n        return audioAdaptation.representations\n            .map(function (_a) {\n            var bitrate = _a.bitrate;\n            return bitrate;\n        });\n    };\n    /**\n     * Returns the manual audio bitrate set. -1 if in AUTO mode.\n     * @returns {Number}\n     */\n    Player.prototype.getManualAudioBitrate = function () {\n        return this._priv_bitrateInfos.manualBitrates.audio;\n    };\n    /**\n     * Returns the manual video bitrate set. -1 if in AUTO mode.\n     * @returns {Number}\n     */\n    Player.prototype.getManualVideoBitrate = function () {\n        return this._priv_bitrateInfos.manualBitrates.video;\n    };\n    /**\n     * Returns currently considered bitrate for video segments.\n     * @returns {Number|undefined}\n     */\n    Player.prototype.getVideoBitrate = function () {\n        var representations = this.getCurrentRepresentations();\n        if (!representations || !representations.video) {\n            return undefined;\n        }\n        return representations.video.bitrate;\n    };\n    /**\n     * Returns currently considered bitrate for audio segments.\n     * @returns {Number|undefined}\n     */\n    Player.prototype.getAudioBitrate = function () {\n        var representations = this.getCurrentRepresentations();\n        if (!representations || !representations.audio) {\n            return undefined;\n        }\n        return representations.audio.bitrate;\n    };\n    /**\n     * Returns max wanted video bitrate currently set.\n     * @returns {Number}\n     */\n    Player.prototype.getMaxVideoBitrate = function () {\n        if (!this._priv_abrManager) {\n            return this._priv_bitrateInfos.initialMaxAutoBitrates.video;\n        }\n        return this._priv_abrManager.getMaxAutoBitrate(\"video\");\n    };\n    /**\n     * Returns max wanted audio bitrate currently set.\n     * @returns {Number}\n     */\n    Player.prototype.getMaxAudioBitrate = function () {\n        if (!this._priv_abrManager) {\n            return this._priv_bitrateInfos.initialMaxAutoBitrates.audio;\n        }\n        return this._priv_abrManager.getMaxAutoBitrate(\"audio\");\n    };\n    /**\n     * Play/Resume the current video.\n     */\n    Player.prototype.play = function () {\n        if (!this.videoElement) {\n            throw new Error(\"Disposed player\");\n        }\n        /* tslint:disable no-floating-promises */\n        this.videoElement.play();\n        /* tslint:enable no-floating-promises */\n    };\n    /**\n     * Pause playback of the video.\n     */\n    Player.prototype.pause = function () {\n        if (!this.videoElement) {\n            throw new Error(\"Disposed player\");\n        }\n        this.videoElement.pause();\n    };\n    /**\n     * Update the playback rate of the video.\n     * @param {Number} rate\n     */\n    Player.prototype.setPlaybackRate = function (rate) {\n        this._priv_speed$.next(rate);\n    };\n    /**\n     * Seek to a given absolute position.\n     * @param {Number|Object} time\n     * @returns {Number} - The time the player has seek to\n     */\n    Player.prototype.seekTo = function (time) {\n        if (!this.videoElement) {\n            throw new Error(\"Disposed player\");\n        }\n        if (!this._priv_contentInfos) {\n            throw new Error(\"player: no content loaded\");\n        }\n        var _a = this._priv_contentInfos, isDirectFile = _a.isDirectFile, manifest = _a.manifest;\n        if (!isDirectFile && !manifest) {\n            throw new Error(\"player: the content did not load yet\");\n        }\n        var positionWanted;\n        var typeOf = typeof time;\n        if (typeOf === \"number\") {\n            positionWanted = time;\n        }\n        else if (typeOf === \"object\") {\n            var currentTs = this.videoElement.currentTime;\n            if (time.relative != null) {\n                positionWanted = currentTs + time.relative;\n            }\n            else if (time.position != null) {\n                positionWanted = time.position;\n            }\n            else if (time.wallClockTime != null) {\n                positionWanted = isDirectFile ?\n                    time.wallClockTime :\n                    timings_1.fromWallClockTime(time.wallClockTime * 1000, manifest // is TS or I dumb here?\n                    );\n            }\n            else {\n                throw new Error(\"invalid time object. You must set one of the \" +\n                    \"following properties: \\\"relative\\\", \\\"position\\\" or \" +\n                    \"\\\"wallClockTime\\\"\");\n            }\n        }\n        if (positionWanted === undefined) {\n            throw new Error(\"invalid time given\");\n        }\n        this.videoElement.currentTime = positionWanted;\n        return positionWanted;\n    };\n    Player.prototype.exitFullscreen = function () {\n        compat_1.exitFullscreen();\n    };\n    /**\n     * Set/exit fullScreen.\n     * @param {Boolean} [goFull=true] - if false, exit full screen.\n     */\n    Player.prototype.setFullscreen = function (goFull) {\n        if (goFull === void 0) { goFull = true; }\n        if (!this.videoElement) {\n            throw new Error(\"Disposed player\");\n        }\n        if (goFull) {\n            compat_1.requestFullscreen(this.videoElement);\n        }\n        else {\n            compat_1.exitFullscreen();\n        }\n    };\n    /**\n     * Set the player's volume. From 0 (muted volume) to 1 (maximum volume).\n     * @param {Number}\n     */\n    Player.prototype.setVolume = function (volume) {\n        if (!this.videoElement) {\n            throw new Error(\"Disposed player\");\n        }\n        var videoElement = this.videoElement;\n        if (volume !== videoElement.volume) {\n            videoElement.volume = volume;\n            this.trigger(\"volumeChange\", volume);\n        }\n    };\n    /**\n     * Returns true if the volume is set to 0. false otherwise.\n     * @returns {Boolean}\n     */\n    Player.prototype.isMute = function () {\n        return !this.getVolume();\n    };\n    /**\n     * Set the volume to 0 and save current one for when unmuted.\n     */\n    Player.prototype.mute = function () {\n        this._priv_mutedMemory = this.getVolume();\n        this.setVolume(0);\n    };\n    /**\n     * Set the volume back to when it was when mute was last called.\n     * If the volume was set to 0, set a default volume instead (see config).\n     */\n    Player.prototype.unMute = function () {\n        var vol = this.getVolume();\n        if (vol === 0) {\n            this.setVolume(this._priv_mutedMemory || DEFAULT_UNMUTED_VOLUME);\n        }\n    };\n    /**\n     * Force the video bitrate to a given value. Act as a ceil.\n     * -1 to set it on AUTO Mode\n     * @param {Number} btr\n     */\n    Player.prototype.setVideoBitrate = function (btr) {\n        this._priv_bitrateInfos.manualBitrates.video = btr;\n        if (this._priv_abrManager) {\n            this._priv_abrManager.setManualBitrate(\"video\", btr);\n        }\n    };\n    /**\n     * Force the audio bitrate to a given value. Act as a ceil.\n     * -1 to set it on AUTO Mode\n     * @param {Number} btr\n     */\n    Player.prototype.setAudioBitrate = function (btr) {\n        this._priv_bitrateInfos.manualBitrates.audio = btr;\n        if (this._priv_abrManager) {\n            this._priv_abrManager.setManualBitrate(\"audio\", btr);\n        }\n    };\n    /**\n     * Update the maximum video bitrate the user can switch to.\n     * @param {Number} btr\n     */\n    Player.prototype.setMaxVideoBitrate = function (btr) {\n        // set it for the next content loaded\n        this._priv_bitrateInfos.initialMaxAutoBitrates.video = btr;\n        // set it for the current if one is loaded\n        if (this._priv_abrManager) {\n            this._priv_abrManager.setMaxAutoBitrate(\"video\", btr);\n        }\n    };\n    /**\n     * Update the maximum video bitrate the user can switch to.\n     * @param {Number} btr\n     */\n    Player.prototype.setMaxAudioBitrate = function (btr) {\n        // set it for the next content loaded\n        this._priv_bitrateInfos.initialMaxAutoBitrates.audio = btr;\n        // set it for the current if one is loaded\n        if (this._priv_abrManager) {\n            this._priv_abrManager.setMaxAutoBitrate(\"audio\", btr);\n        }\n    };\n    /**\n     * Set the max buffer size for the buffer behind the current position.\n     * Every buffer data before will be removed.\n     * @param {Number} depthInSeconds\n     */\n    Player.prototype.setMaxBufferBehind = function (depthInSeconds) {\n        this._priv_bufferOptions.maxBufferBehind$.next(depthInSeconds);\n    };\n    /**\n     * Set the max buffer size for the buffer behind the current position.\n     * Every buffer data before will be removed.\n     * @param {Number} depthInSeconds\n     */\n    Player.prototype.setMaxBufferAhead = function (depthInSeconds) {\n        this._priv_bufferOptions.maxBufferAhead$.next(depthInSeconds);\n    };\n    /**\n     * Set the max buffer size for the buffer ahead of the current position.\n     * The player will stop downloading chunks when this size is reached.\n     * @param {Number} sizeInSeconds\n     */\n    Player.prototype.setWantedBufferAhead = function (sizeInSeconds) {\n        this._priv_bufferOptions.wantedBufferAhead$.next(sizeInSeconds);\n    };\n    /**\n     * Returns the max buffer size for the buffer behind the current position.\n     * @returns {Number}\n     */\n    Player.prototype.getMaxBufferBehind = function () {\n        return this._priv_bufferOptions.maxBufferBehind$.getValue();\n    };\n    /**\n     * Returns the max buffer size for the buffer behind the current position.\n     * @returns {Number}\n     */\n    Player.prototype.getMaxBufferAhead = function () {\n        return this._priv_bufferOptions.maxBufferAhead$.getValue();\n    };\n    /**\n     * Returns the max buffer size for the buffer ahead of the current position.\n     * @returns {Number}\n     */\n    Player.prototype.getWantedBufferAhead = function () {\n        return this._priv_bufferOptions.wantedBufferAhead$.getValue();\n    };\n    /**\n     * Returns type of current keysystem (e.g. playready, widevine) if the content\n     * is encrypted. null otherwise.\n     * @returns {string|null}\n     */\n    Player.prototype.getCurrentKeySystem = function () {\n        if (!this.videoElement) {\n            throw new Error(\"Disposed player\");\n        }\n        return eme_1.getCurrentKeySystem(this.videoElement);\n    };\n    /**\n     * Returns every available audio tracks for the current Period.\n     * @returns {Array.<Object>|null}\n     */\n    Player.prototype.getAvailableAudioTracks = function () {\n        if (!this._priv_contentInfos) {\n            return null;\n        }\n        var currentPeriod = this._priv_contentInfos.currentPeriod;\n        if (!this._priv_languageManager || !currentPeriod) {\n            return null;\n        }\n        return this._priv_languageManager.getAvailableAudioTracks(currentPeriod);\n    };\n    /**\n     * Returns every available text tracks for the current Period.\n     * @returns {Array.<Object>|null}\n     */\n    Player.prototype.getAvailableTextTracks = function () {\n        if (!this._priv_contentInfos) {\n            return null;\n        }\n        var currentPeriod = this._priv_contentInfos.currentPeriod;\n        if (!this._priv_languageManager || !currentPeriod) {\n            return null;\n        }\n        return this._priv_languageManager.getAvailableTextTracks(currentPeriod);\n    };\n    /**\n     * Returns currently chosen audio language for the current Period.\n     * @returns {string}\n     */\n    Player.prototype.getAudioTrack = function () {\n        if (!this._priv_contentInfos) {\n            return undefined;\n        }\n        var currentPeriod = this._priv_contentInfos.currentPeriod;\n        if (!this._priv_languageManager || !currentPeriod) {\n            return undefined;\n        }\n        return this._priv_languageManager.getChosenAudioTrack(currentPeriod);\n    };\n    /**\n     * Returns currently chosen subtitle for the current Period.\n     * @returns {string}\n     */\n    Player.prototype.getTextTrack = function () {\n        if (!this._priv_contentInfos) {\n            return undefined;\n        }\n        var currentPeriod = this._priv_contentInfos.currentPeriod;\n        if (!this._priv_languageManager || !currentPeriod) {\n            return undefined;\n        }\n        return this._priv_languageManager.getChosenTextTrack(currentPeriod);\n    };\n    /**\n     * Update the audio language for the current Period.\n     * @param {string} audioId\n     * @throws Error - the current content has no LanguageManager.\n     * @throws Error - the given id is linked to no audio track.\n     */\n    Player.prototype.setAudioTrack = function (audioId) {\n        if (!this._priv_contentInfos) {\n            throw new Error(\"No content loaded\");\n        }\n        var currentPeriod = this._priv_contentInfos.currentPeriod;\n        if (!this._priv_languageManager || !currentPeriod) {\n            throw new Error(\"No compatible content launched.\");\n        }\n        try {\n            this._priv_languageManager.setAudioTrackByID(currentPeriod, audioId);\n        }\n        catch (e) {\n            throw new Error(\"player: unknown audio track\");\n        }\n    };\n    /**\n     * Update the text language for the current Period.\n     * @param {string} sub\n     * @throws Error - the current content has no LanguageManager.\n     * @throws Error - the given id is linked to no text track.\n     */\n    Player.prototype.setTextTrack = function (textId) {\n        if (!this._priv_contentInfos) {\n            throw new Error(\"No content loaded\");\n        }\n        var currentPeriod = this._priv_contentInfos.currentPeriod;\n        if (!this._priv_languageManager || !currentPeriod) {\n            throw new Error(\"No compatible content launched.\");\n        }\n        try {\n            this._priv_languageManager.setTextTrackByID(currentPeriod, textId);\n        }\n        catch (e) {\n            throw new Error(\"player: unknown text track\");\n        }\n    };\n    /**\n     * Disable subtitles for the current content.\n     */\n    Player.prototype.disableTextTrack = function () {\n        if (!this._priv_contentInfos) {\n            return;\n        }\n        var currentPeriod = this._priv_contentInfos.currentPeriod;\n        if (!this._priv_languageManager || !currentPeriod) {\n            return;\n        }\n        return this._priv_languageManager.disableTextTrack(currentPeriod);\n    };\n    /**\n     * @returns {Array.<Object>|null}\n     */\n    Player.prototype.getImageTrackData = function () {\n        return this._priv_contentInfos && this._priv_contentInfos.thumbnails;\n    };\n    /**\n     * Get minimum seek-able position.\n     * @returns {number}\n     */\n    Player.prototype.getMinimumPosition = function () {\n        if (!this._priv_contentInfos) {\n            return null;\n        }\n        if (this._priv_contentInfos.isDirectFile) {\n            return 0;\n        }\n        var manifest = this._priv_contentInfos.manifest;\n        if (manifest) {\n            return timings_1.getMinimumBufferPosition(manifest);\n        }\n        return null;\n    };\n    /**\n     * Get maximum seek-able position.\n     * @returns {number}\n     */\n    Player.prototype.getMaximumPosition = function () {\n        if (!this._priv_contentInfos) {\n            return null;\n        }\n        var _a = this._priv_contentInfos, isDirectFile = _a.isDirectFile, manifest = _a.manifest;\n        if (isDirectFile) {\n            if (!this.videoElement) {\n                throw new Error(\"Disposed player\");\n            }\n            return this.videoElement.duration;\n        }\n        if (manifest) {\n            return timings_1.getMaximumBufferPosition(manifest);\n        }\n        return null;\n    };\n    /**\n     * Reset all state properties relative to a playing content.\n     */\n    Player.prototype._priv_cleanUpCurrentContentState = function () {\n        var _this = this;\n        // lock creation of new streams while cleaning up is pending\n        this._priv_streamLock$.next(true);\n        this._priv_contentInfos = null;\n        this._priv_languageManager = null;\n        if (this._priv_abrManager) {\n            this._priv_abrManager.dispose();\n            this._priv_abrManager = null;\n        }\n        this._priv_contentEventsMemory = {\n            period: null,\n            audioTrack: null,\n            textTrack: null,\n            videoBitrate: null,\n            audioBitrate: null,\n            bitrateEstimation: undefined,\n        };\n        // EME cleaning\n        var freeUpStreamLock = function () {\n            _this._priv_streamLock$.next(false);\n        };\n        if (this.videoElement) {\n            eme_1.clearEMESession(this.videoElement)\n                .catch(function () { return Observable_1.Observable.empty(); })\n                .subscribe(noop_1.default, freeUpStreamLock, freeUpStreamLock);\n        }\n        else {\n            freeUpStreamLock();\n        }\n    };\n    Player.prototype._priv_triggerContentEvent = function (type, value) {\n        var prev = this._priv_contentEventsMemory[type];\n        if (!deepEqual(prev, value)) {\n            this._priv_contentEventsMemory[type] = value;\n            // SAD\n            this.trigger(type + \"Change\", value);\n        }\n    };\n    /**\n     * Triggered each time the Stream Observable emits.\n     *\n     * React to various events.\n     *\n     * @param {Object} streamInfos - payload emitted\n     */\n    Player.prototype._priv_onStreamNext = function (streamInfos) {\n        switch (streamInfos.type) {\n            case \"activePeriodChanged\":\n                this._priv_onActivePeriodChanged(streamInfos.value);\n                break;\n            case \"periodBufferReady\":\n                this._priv_onPeriodBufferReady(streamInfos.value);\n                break;\n            case \"periodBufferCleared\":\n                this._priv_onPeriodBufferCleared(streamInfos.value);\n                break;\n            case \"representationChange\":\n                this._priv_onRepresentationChange(streamInfos.value);\n                break;\n            case \"adaptationChange\":\n                this._priv_onAdaptationChange(streamInfos.value);\n                break;\n            case \"manifestUpdate\":\n                this._priv_onManifestUpdate(streamInfos.value);\n                break;\n            case \"bitrateEstimationChange\":\n                this._priv_onBitrateEstimationChange(streamInfos.value);\n                break;\n            case \"manifestReady\":\n                this._priv_onManifestReady(streamInfos.value);\n                break;\n            case \"warning\":\n                this._priv_onStreamWarning(streamInfos.value);\n                break;\n            case \"added-segment\":\n                if (!this._priv_contentInfos) {\n                    log_1.default.error(\"Added segment while no content is loaded\");\n                    return;\n                }\n                // Manage image tracks\n                // TODO Better way? Perhaps linked to an ImageSourceBuffer\n                // implementation\n                var _a = streamInfos.value, bufferType = _a.bufferType, segmentData = _a.segmentData;\n                if (bufferType === \"image\") {\n                    if (segmentData != null && segmentData.type === \"bif\") {\n                        var imageData = segmentData.data;\n                        // TODO merge multiple data from the same track together\n                        this._priv_contentInfos.thumbnails = imageData;\n                        this.trigger(\"imageTrackUpdate\", {\n                            data: this._priv_contentInfos.thumbnails,\n                        });\n                    }\n                }\n        }\n    };\n    /**\n     * Triggered when the Stream throws (fatal errors).\n     *\n     * Clean-up ressources and signal that the content has stopped on error.\n     *\n     * @param {Error} error\n     */\n    Player.prototype._priv_onStreamError = function (error) {\n        this._priv_stopCurrentContent$.next();\n        this._priv_cleanUpCurrentContentState();\n        this._priv_currentError = error;\n        this._priv_setPlayerState(constants_1.PLAYER_STATES.STOPPED);\n        // TODO This condition is here because the eventual callback called when the\n        // player state is updated can launch a new content, thus the error will not\n        // be here anymore, in which case triggering the \"error\" event is unwanted.\n        // This is very ugly though, and we should probable have a better solution\n        if (this._priv_currentError === error) {\n            this.trigger(\"error\", error);\n        }\n    };\n    /**\n     * Triggered when the Stream instance ends.\n     *\n     * Clean-up ressources and signal that the content has ended.\n     */\n    Player.prototype._priv_onStreamComplete = function () {\n        this._priv_stopCurrentContent$.next();\n        this._priv_cleanUpCurrentContentState();\n        this._priv_setPlayerState(constants_1.PLAYER_STATES.ENDED);\n    };\n    /**\n     * Triggered when the Stream emits a warning.\n     *\n     * Trigger the right Player event.\n     * @param {Object} streamInfos\n     */\n    Player.prototype._priv_onStreamWarning = function (error) {\n        this.trigger(\"warning\", error);\n    };\n    /**\n     * Triggered when the stream starts.\n     *\n     * Initialize various private properties and emit initial event.\n     *\n     * @param {Object} value\n     * @param {Manifest} value.manifest - The Manifest instance\n     * @param {Object} value.abrManager - ABR manager which can be used to select\n     * the wanted bandwidth.\n     */\n    Player.prototype._priv_onManifestReady = function (value) {\n        if (!this._priv_contentInfos) {\n            log_1.default.error(\"The manifest is loaded but no content is.\");\n            return;\n        }\n        var manifest = value.manifest, abrManager = value.abrManager;\n        this._priv_contentInfos.manifest = manifest;\n        this._priv_abrManager = abrManager;\n        var _a = this._priv_contentInfos, initialAudioTrack = _a.initialAudioTrack, initialTextTrack = _a.initialTextTrack;\n        this._priv_languageManager = new language_manager_1.default({\n            preferredAudioTracks: initialAudioTrack === undefined ?\n                undefined : [initialAudioTrack],\n            preferredTextTracks: initialTextTrack === undefined ?\n                undefined : [initialTextTrack],\n        });\n        this.trigger(\"manifestChange\", manifest);\n    };\n    /**\n     * Triggered each times the current Period Changed.\n     *\n     * Store and emit initial state for the Period.\n     *\n     * @param {Object} value\n     * @param {Period} value.period\n     */\n    Player.prototype._priv_onActivePeriodChanged = function (_a) {\n        var period = _a.period;\n        if (!this._priv_contentInfos) {\n            log_1.default.error(\"The active period changed but no content is loaded\");\n            return;\n        }\n        this._priv_contentInfos.currentPeriod = period;\n        this._priv_triggerContentEvent(\"period\", period);\n        // Emit intial events for the Period\n        if (this._priv_languageManager) {\n            var audioTrack = this._priv_languageManager.getChosenAudioTrack(period);\n            var textTrack = this._priv_languageManager.getChosenTextTrack(period);\n            this._priv_triggerContentEvent(\"audioTrack\", audioTrack);\n            this._priv_triggerContentEvent(\"textTrack\", textTrack);\n        }\n        else {\n            this._priv_triggerContentEvent(\"audioTrack\", null);\n            this._priv_triggerContentEvent(\"textTrack\", null);\n        }\n        var activeAudioRepresentations = this.getCurrentRepresentations();\n        if (activeAudioRepresentations && activeAudioRepresentations.audio != null) {\n            var bitrate = activeAudioRepresentations.audio.bitrate;\n            this._priv_triggerContentEvent(\"audioBitrate\", bitrate != null ? bitrate : -1);\n        }\n        else {\n            this._priv_triggerContentEvent(\"audioBitrate\", null);\n        }\n        var activeVideoRepresentations = this.getCurrentRepresentations();\n        if (activeVideoRepresentations && activeVideoRepresentations.video != null) {\n            var bitrate = activeVideoRepresentations.video.bitrate;\n            this._priv_triggerContentEvent(\"videoBitrate\", bitrate != null ? bitrate : -1);\n        }\n        else {\n            this._priv_triggerContentEvent(\"videoBitrate\", null);\n        }\n    };\n    /**\n     * Triggered each times the Stream \"prepares\" a new Period, and\n     * needs the API to send it its chosen Adaptation.\n     *\n     * Choose the right Adaptation for the Period and emit it.\n     *\n     * @param {Object} value\n     * @param {string} value.type\n     * @param {Period} value.period\n     * @param {Subject} value.adaptation$\n     */\n    Player.prototype._priv_onPeriodBufferReady = function (value) {\n        var type = value.type, period = value.period, adaptation$ = value.adaptation$;\n        switch (type) {\n            case \"audio\":\n                if (!this._priv_languageManager) {\n                    log_1.default.error(\"LanguageManager not instanciated for a new \" + type + \" period\");\n                    adaptation$.next(null);\n                }\n                else {\n                    this._priv_languageManager.addPeriod(type, period, adaptation$);\n                    this._priv_languageManager.setInitialAudioTrack(period);\n                }\n                break;\n            case \"text\":\n                if (!this._priv_languageManager) {\n                    log_1.default.error(\"LanguageManager not instanciated for a new \" + type + \" period\");\n                    adaptation$.next(null);\n                }\n                else {\n                    this._priv_languageManager.addPeriod(type, period, adaptation$);\n                    this._priv_languageManager.setInitialTextTrack(period);\n                }\n                break;\n            default:\n                var adaptations = period.adaptations[type];\n                if (adaptations && adaptations.length) {\n                    adaptation$.next(adaptations[0]);\n                }\n                else {\n                    adaptation$.next(null);\n                }\n                break;\n        }\n    };\n    /**\n     * Triggered each times the Stream \"removes\" a Period.\n     *\n     * Update the LanguageManager to remove the corresponding Period.\n     *\n     * @param {Object} value\n     * @param {Period} value.period\n     */\n    Player.prototype._priv_onPeriodBufferCleared = function (value) {\n        var type = value.type, period = value.period;\n        if (type === \"audio\" || type === \"text\") {\n            if (this._priv_languageManager) {\n                this._priv_languageManager.removePeriod(type, period);\n            }\n        }\n    };\n    /**\n     * Triggered each times the Manifest is updated.\n     *\n     * Update the LanguageManager and emit events.\n     *\n     * @param {Object} value\n     * @param {Manifest} value.manifest\n     */\n    Player.prototype._priv_onManifestUpdate = function (value) {\n        if (!this._priv_contentInfos) {\n            log_1.default.error(\"The manifest is updated but no content is loaded.\");\n            return;\n        }\n        var manifest = value.manifest;\n        this._priv_contentInfos.manifest = manifest;\n        // Update the languages chosen if it changed\n        if (this._priv_languageManager) {\n            this._priv_languageManager.update();\n        }\n        this.trigger(\"manifestUpdate\", manifest);\n    };\n    /**\n     * Triggered each times a new Adaptation is considered by the Stream.\n     *\n     * Store given Adaptation and emit it if from the current Period.\n     *\n     * @param {Object} value\n     * @param {string} value.type\n     * @param {Period} value.period\n     * @param {Adaptation} value.adaptation\n     */\n    Player.prototype._priv_onAdaptationChange = function (_a) {\n        var type = _a.type, adaptation = _a.adaptation, period = _a.period;\n        if (!this._priv_contentInfos) {\n            log_1.default.error(\"The adaptations changed but no content is loaded\");\n            return;\n        }\n        // lazily create this._priv_contentInfos.activeAdaptations\n        if (!this._priv_contentInfos.activeAdaptations) {\n            this._priv_contentInfos.activeAdaptations = new Map();\n        }\n        var _b = this._priv_contentInfos, activeAdaptations = _b.activeAdaptations, currentPeriod = _b.currentPeriod;\n        var activePeriodAdaptations = activeAdaptations.get(period);\n        if (!activePeriodAdaptations) {\n            activeAdaptations.set(period, (_c = {}, _c[type] = adaptation, _c));\n        }\n        else {\n            activePeriodAdaptations[type] = adaptation;\n        }\n        if (this._priv_languageManager &&\n            period != null && period === currentPeriod) {\n            if (type === \"audio\") {\n                var audioTrack = this._priv_languageManager\n                    .getChosenAudioTrack(currentPeriod);\n                this._priv_triggerContentEvent(\"audioTrack\", audioTrack);\n            }\n            else if (type === \"text\") {\n                var textTrack = this._priv_languageManager\n                    .getChosenTextTrack(currentPeriod);\n                this._priv_triggerContentEvent(\"textTrack\", textTrack);\n            }\n        }\n        var _c;\n    };\n    /**\n     * Triggered each times a new Representation is considered by the Stream.\n     *\n     * Store given Representation and emit it if from the current Period.\n     *\n     * @param {Object} obj\n     * @param {string} obj.type\n     * @param {Object} obj.representation\n     */\n    Player.prototype._priv_onRepresentationChange = function (_a) {\n        var type = _a.type, period = _a.period, representation = _a.representation;\n        if (!this._priv_contentInfos) {\n            log_1.default.error(\"The representations changed but no content is loaded\");\n            return;\n        }\n        // lazily create this._priv_contentInfos.activeRepresentations\n        if (!this._priv_contentInfos.activeRepresentations) {\n            this._priv_contentInfos.activeRepresentations = new Map();\n        }\n        var _b = this._priv_contentInfos, activeRepresentations = _b.activeRepresentations, currentPeriod = _b.currentPeriod;\n        var activePeriodRepresentations = activeRepresentations.get(period);\n        if (!activePeriodRepresentations) {\n            activeRepresentations.set(period, (_c = {}, _c[type] = representation, _c));\n        }\n        else {\n            activePeriodRepresentations[type] = representation;\n        }\n        var bitrate = representation && representation.bitrate;\n        if (bitrate != null) {\n            this._priv_bitrateInfos.lastBitrates[type] = bitrate;\n        }\n        if (period != null && currentPeriod === period) {\n            if (type === \"video\") {\n                this._priv_triggerContentEvent(\"videoBitrate\", bitrate != null ? bitrate : -1);\n            }\n            else if (type === \"audio\") {\n                this._priv_triggerContentEvent(\"audioBitrate\", bitrate != null ? bitrate : -1);\n            }\n        }\n        var _c;\n    };\n    /**\n     * Triggered each time a bitrate estimate is calculated.\n     *\n     * Emit it.\n     *\n     * @param {Object} value\n     * @param {string} value.type\n     * @param {number|undefined} value.bitrate\n     */\n    Player.prototype._priv_onBitrateEstimationChange = function (_a) {\n        var type = _a.type, bitrate = _a.bitrate;\n        if (true) {\n            assert_1.default(type != null);\n            assert_1.default(bitrate != null);\n        }\n        this._priv_triggerContentEvent(\"bitrateEstimation\", { type: type, bitrate: bitrate });\n    };\n    /**\n     * Triggered each time the videoElement alternates between play and pause.\n     *\n     * Emit the info through the right Subject.\n     *\n     * @param {Boolean} isPlaying\n     */\n    Player.prototype._priv_onPlayPauseNext = function (isPlaying) {\n        if (!this.videoElement) {\n            throw new Error(\"Disposed player\");\n        }\n        this._priv_playing$.next(isPlaying);\n    };\n    /**\n     * Triggered each time a textTrack is added to the video DOM Element.\n     *\n     * Trigger the right Player Event.\n     *\n     * @param {Array.<TextTrackElement} tracks\n     */\n    Player.prototype._priv_onNativeTextTracksNext = function (tracks) {\n        this.trigger(\"nativeTextTracksChange\", tracks);\n    };\n    /**\n     * Triggered each time the player state updates.\n     *\n     * Trigger the right Player Event.\n     *\n     * @param {string} newState\n     */\n    Player.prototype._priv_setPlayerState = function (newState) {\n        if (this.state !== newState) {\n            this.state = newState;\n            log_1.default.info(\"playerStateChange\", newState);\n            this.trigger(\"playerStateChange\", newState);\n        }\n    };\n    /**\n     * Triggered each time a new clock tick object is emitted.\n     *\n     * Trigger the right Player Event\n     *\n     * @param {Object} clockTick\n     */\n    Player.prototype._priv_triggerTimeChange = function (clockTick) {\n        if (!this._priv_contentInfos) {\n            log_1.default.warn(\"Cannot perform time update: no content loaded.\");\n            return;\n        }\n        var _a = this._priv_contentInfos, isDirectFile = _a.isDirectFile, manifest = _a.manifest;\n        if ((!isDirectFile && !manifest) || !clockTick) {\n            return;\n        }\n        var positionData = {\n            position: clockTick.currentTime,\n            duration: clockTick.duration,\n            playbackRate: clockTick.playbackRate,\n            // TODO fix higher up?\n            bufferGap: isFinite(clockTick.bufferGap) ? clockTick.bufferGap : 0,\n        };\n        if (manifest &&\n            manifest.isLive &&\n            clockTick.currentTime > 0) {\n            positionData.wallClockTime =\n                timings_1.toWallClockTime(clockTick.currentTime, manifest)\n                    .getTime() / 1000;\n            positionData.liveGap =\n                timings_1.getMaximumBufferPosition(manifest) - clockTick.currentTime;\n        }\n        this.trigger(\"positionUpdate\", positionData);\n    };\n    return Player;\n}(eventemitter_1.default));\nexports.default = Player;\n\n\n//# sourceURL=webpack://RxPlayer/./src/core/api/index.ts?");

/***/ }),

/***/ "./src/core/api/language_manager.ts":
/*!******************************************!*\
  !*** ./src/core/api/language_manager.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * This file is used to abstract the notion of text and audio language-switching\n * for an easier API management.\n */\nvar arrayFind = __webpack_require__(/*! array-find */ \"./node_modules/array-find/find.js\");\nvar array_includes_1 = __webpack_require__(/*! ../../utils/array-includes */ \"./src/utils/array-includes.ts\");\nvar log_1 = __webpack_require__(/*! ../../utils/log */ \"./src/utils/log.ts\");\nvar sorted_list_1 = __webpack_require__(/*! ../../utils/sorted_list */ \"./src/utils/sorted_list.ts\");\n/**\n * Manage audio and text tracks for all active periods.\n *\n * Most methods here allow to interact with the first chronologically added\n * Period.\n *\n * Languages for subsequent periods are also chosen accordingly.\n * @class LanguageManager\n */\nvar LanguageManager = /** @class */ (function () {\n    /**\n     * @param {Object} defaults\n     * @param {Array.<Object>} defaults.preferredAudioTracks\n     * @param {Array.<Object>} defaults.preferredTextTracks\n     */\n    function LanguageManager(defaults) {\n        if (defaults === void 0) { defaults = {}; }\n        var preferredAudioTracks = defaults.preferredAudioTracks, preferredTextTracks = defaults.preferredTextTracks;\n        this._periods = new sorted_list_1.default(function (a, b) { return a.period.start - b.period.start; });\n        this._audioChoiceMemory = new WeakMap();\n        this._textChoiceMemory = new WeakMap();\n        this._preferredAudioTracks = preferredAudioTracks || [];\n        this._preferredTextTracks = preferredTextTracks || [];\n    }\n    /**\n     * Add Subject to choose Adaptation for new \"audio\" or \"text\" Period.\n     * @param {string} bufferType\n     * @param {Period} period\n     * @param {Subject} adaptations\n     */\n    LanguageManager.prototype.addPeriod = function (bufferType, period, adaptation$) {\n        var periodItem = getPeriodItem(this._periods, period);\n        if (periodItem != null) {\n            if (periodItem[bufferType] != null) {\n                log_1.default.warn(\"LanguageManager: \" + bufferType + \" already added for period\", period);\n                return;\n            }\n            else {\n                periodItem[bufferType] = {\n                    adaptations: period.adaptations[bufferType] || [],\n                    adaptation$: adaptation$,\n                };\n            }\n        }\n        else {\n            this._periods.add((_a = {\n                    period: period\n                },\n                _a[bufferType] = {\n                    adaptations: period.adaptations[bufferType] || [],\n                    adaptation$: adaptation$,\n                },\n                _a));\n        }\n        var _a;\n    };\n    /**\n     * Remove Subject to choose an \"audio\" or \"text\" Adaptation for a Period.\n     * @param {string} bufferType\n     * @param {Period} period\n     */\n    LanguageManager.prototype.removePeriod = function (bufferType, period) {\n        var periodIndex = findPeriodIndex(this._periods, period);\n        if (periodIndex == null) {\n            log_1.default.warn(\"LanguageManager: \" + bufferType + \" not found for period\", period);\n            return;\n        }\n        var periodItem = this._periods.get(periodIndex);\n        if (periodItem[bufferType] == null) {\n            log_1.default.warn(\"LanguageManager: \" + bufferType + \" already removed for period\", period);\n            return;\n        }\n        delete periodItem[bufferType];\n        if (periodItem.audio == null && periodItem.text == null) {\n            this._periods.removeFirst(periodItem);\n        }\n    };\n    /**\n     * Update the choice of all added Periods based on:\n     *   1. What was the last chosen adaptation\n     *   2. If not found, the preferences\n     */\n    LanguageManager.prototype.update = function () {\n        this._updateAudioTrackChoices();\n        this._updateTextTrackChoices();\n    };\n    /**\n     * Emit initial audio Adaptation through the given Subject based on:\n     *   - the preferred audio tracks\n     *   - the last choice for this period, if one\n     * @param {Period} period\n     *\n     * @throws Error - Throws if the period given has not been added\n     */\n    LanguageManager.prototype.setInitialAudioTrack = function (period) {\n        var periodItem = getPeriodItem(this._periods, period);\n        var audioInfos = periodItem && periodItem.audio;\n        if (!audioInfos || !periodItem) {\n            throw new Error(\"LanguageManager: Given Period not found.\");\n        }\n        var preferredAudioTracks = this._preferredAudioTracks;\n        var audioAdaptations = period.adaptations.audio || [];\n        var chosenAudioAdaptation = this._audioChoiceMemory.get(period);\n        if (chosenAudioAdaptation === undefined ||\n            !array_includes_1.default(audioAdaptations, chosenAudioAdaptation)) {\n            var optimalAdaptation = findFirstOptimalAudioAdaptation(audioAdaptations, preferredAudioTracks);\n            this._audioChoiceMemory.set(period, optimalAdaptation);\n            audioInfos.adaptation$.next(optimalAdaptation);\n        }\n        else {\n            audioInfos.adaptation$.next(chosenAudioAdaptation);\n        }\n    };\n    /**\n     * Emit initial text Adaptation through the given Subject based on:\n     *   - the preferred text tracks\n     *   - the last choice for this period, if one\n     * @param {Period} period\n     *\n     * @throws Error - Throws if the period given has not been added\n     */\n    LanguageManager.prototype.setInitialTextTrack = function (period) {\n        var periodItem = getPeriodItem(this._periods, period);\n        var textInfos = periodItem && periodItem.text;\n        if (!textInfos || !periodItem) {\n            throw new Error(\"LanguageManager: Given Period not found.\");\n        }\n        var preferredTextTracks = this._preferredTextTracks;\n        var textAdaptations = period.adaptations.text || [];\n        var chosenTextAdaptation = this._textChoiceMemory.get(period);\n        if (chosenTextAdaptation === undefined ||\n            !array_includes_1.default(textAdaptations, chosenTextAdaptation)) {\n            var optimalAdaptation = findFirstOptimalTextAdaptation(textAdaptations, preferredTextTracks);\n            this._textChoiceMemory.set(period, optimalAdaptation);\n            textInfos.adaptation$.next(optimalAdaptation);\n        }\n        else {\n            textInfos.adaptation$.next(chosenTextAdaptation);\n        }\n    };\n    /**\n     * Set audio track based on the ID of its adaptation for a given added Period.\n     *\n     * @param {Period} period - The concerned Period.\n     * @param {string} wantedId - adaptation id of the wanted track\n     *\n     * @throws Error - Throws if the period given has not been added\n     * @throws Error - Throws if the given id is not found in any audio adaptation\n     * of the given Period.\n     */\n    LanguageManager.prototype.setAudioTrackByID = function (period, wantedId) {\n        var periodItem = getPeriodItem(this._periods, period);\n        var audioInfos = periodItem && periodItem.audio;\n        if (!audioInfos) {\n            throw new Error(\"LanguageManager: Given Period not found.\");\n        }\n        var wantedAdaptation = arrayFind(audioInfos.adaptations, function (_a) {\n            var id = _a.id;\n            return id === wantedId;\n        });\n        if (wantedAdaptation === undefined) {\n            throw new Error(\"Audio Track not found.\");\n        }\n        var chosenAudioAdaptation = this._audioChoiceMemory.get(period);\n        if (chosenAudioAdaptation === wantedAdaptation) {\n            return;\n        }\n        this._audioChoiceMemory.set(period, wantedAdaptation);\n        audioInfos.adaptation$.next(wantedAdaptation);\n    };\n    /**\n     * Set text track based on the ID of its adaptation for a given added Period.\n     *\n     * @param {Period} period - The concerned Period.\n     * @param {string} wantedId - adaptation id of the wanted track\n     *\n     * @throws Error - Throws if the period given has not been added\n     * @throws Error - Throws if the given id is not found in any text adaptation\n     * of the given Period.\n     */\n    LanguageManager.prototype.setTextTrackByID = function (period, wantedId) {\n        var periodItem = getPeriodItem(this._periods, period);\n        var textInfos = periodItem && periodItem.text;\n        if (!textInfos) {\n            throw new Error(\"LanguageManager: Given Period not found.\");\n        }\n        var wantedAdaptation = arrayFind(textInfos.adaptations, function (_a) {\n            var id = _a.id;\n            return id === wantedId;\n        });\n        if (wantedAdaptation === undefined) {\n            throw new Error(\"Text Track not found.\");\n        }\n        var chosenTextAdaptation = this._textChoiceMemory.get(period);\n        if (chosenTextAdaptation === wantedAdaptation) {\n            return;\n        }\n        this._textChoiceMemory.set(period, wantedAdaptation);\n        textInfos.adaptation$.next(wantedAdaptation);\n    };\n    /**\n     * Disable the given audio track for a given Period.\n     *\n     * @param {Period} period - The concerned Period.\n     *\n     * @throws Error - Throws if the period given has not been added\n     */\n    LanguageManager.prototype.disableAudioTrack = function (period) {\n        var periodItem = getPeriodItem(this._periods, period);\n        var audioInfos = periodItem && periodItem.audio;\n        if (!audioInfos) {\n            throw new Error(\"LanguageManager: Given Period not found.\");\n        }\n        var chosenAudioAdaptation = this._audioChoiceMemory.get(period);\n        if (chosenAudioAdaptation === null) {\n            return;\n        }\n        this._audioChoiceMemory.set(period, null);\n        audioInfos.adaptation$.next(null);\n    };\n    /**\n     * Disable the current text track for a given period.\n     *\n     * @param {Period} period - The concerned Period.\n     *\n     * @throws Error - Throws if the period given has not been added\n     */\n    LanguageManager.prototype.disableTextTrack = function (period) {\n        var periodItem = getPeriodItem(this._periods, period);\n        var textInfos = periodItem && periodItem.text;\n        if (!textInfos) {\n            throw new Error(\"LanguageManager: Given Period not found.\");\n        }\n        var chosenTextAdaptation = this._textChoiceMemory.get(period);\n        if (chosenTextAdaptation === null) {\n            return;\n        }\n        this._textChoiceMemory.set(period, null);\n        textInfos.adaptation$.next(null);\n    };\n    /**\n     * Returns an object describing the chosen audio track for the given audio\n     * Period.\n     *\n     * Returns null is the the current audio track is disabled or not\n     * set yet.\n     *\n     * @param {Period} period\n     * @returns {Object|null}\n     */\n    LanguageManager.prototype.getChosenAudioTrack = function (period) {\n        var periodItem = getPeriodItem(this._periods, period);\n        var audioInfos = periodItem && periodItem.audio;\n        if (audioInfos == null) {\n            return null;\n        }\n        var chosenAudioAdaptation = this._audioChoiceMemory.get(period);\n        if (!chosenAudioAdaptation) {\n            return null;\n        }\n        return {\n            language: chosenAudioAdaptation.language || \"\",\n            normalized: chosenAudioAdaptation.normalizedLanguage || \"\",\n            audioDescription: !!chosenAudioAdaptation.isAudioDescription,\n            id: chosenAudioAdaptation.id,\n        };\n    };\n    /**\n     * Returns an object describing the chosen text track for the given text\n     * Period.\n     *\n     * Returns null is the the current text track is disabled or not\n     * set yet.\n     *\n     * @param {Period} period\n     * @returns {Object|null}\n     */\n    LanguageManager.prototype.getChosenTextTrack = function (period) {\n        var periodItem = getPeriodItem(this._periods, period);\n        var textInfos = periodItem && periodItem.text;\n        if (textInfos == null) {\n            return null;\n        }\n        var chosenTextAdaptation = this._textChoiceMemory.get(period);\n        if (!chosenTextAdaptation) {\n            return null;\n        }\n        return {\n            language: chosenTextAdaptation.language || \"\",\n            normalized: chosenTextAdaptation.normalizedLanguage || \"\",\n            closedCaption: !!chosenTextAdaptation.isClosedCaption,\n            id: chosenTextAdaptation.id,\n        };\n    };\n    /**\n     * Returns all available audio tracks for a given Period, as an array of\n     * objects.\n     *\n     * @returns {Array.<Object>}\n     */\n    LanguageManager.prototype.getAvailableAudioTracks = function (period) {\n        var periodItem = getPeriodItem(this._periods, period);\n        var audioInfos = periodItem && periodItem.audio;\n        if (audioInfos == null) {\n            return [];\n        }\n        var chosenAudioAdaptation = this._audioChoiceMemory.get(period);\n        var currentId = chosenAudioAdaptation && chosenAudioAdaptation.id;\n        return audioInfos.adaptations\n            .map(function (adaptation) { return ({\n            language: adaptation.language || \"\",\n            normalized: adaptation.normalizedLanguage || \"\",\n            audioDescription: !!adaptation.isAudioDescription,\n            id: adaptation.id,\n            active: currentId == null ? false : currentId === adaptation.id,\n        }); });\n    };\n    /**\n     * Returns all available text tracks for a given Period, as an array of\n     * objects.\n     *\n     * @param {Period} period\n     * @returns {Array.<Object>}\n     */\n    LanguageManager.prototype.getAvailableTextTracks = function (period) {\n        var periodItem = getPeriodItem(this._periods, period);\n        var textInfos = periodItem && periodItem.text;\n        if (textInfos == null) {\n            return [];\n        }\n        var chosenTextAdaptation = this._textChoiceMemory.get(period);\n        var currentId = chosenTextAdaptation && chosenTextAdaptation.id;\n        return textInfos.adaptations\n            .map(function (adaptation) { return ({\n            language: adaptation.language || \"\",\n            normalized: adaptation.normalizedLanguage || \"\",\n            closedCaption: !!adaptation.isClosedCaption,\n            id: adaptation.id,\n            active: currentId == null ? false : currentId === adaptation.id,\n        }); });\n    };\n    LanguageManager.prototype._updateAudioTrackChoices = function () {\n        var _this = this;\n        var preferredAudioTracks = this._preferredAudioTracks;\n        var recursiveUpdateAudioTrack = function (index) {\n            if (index >= _this._periods.length()) {\n                // we did all audio Buffers, exit\n                return;\n            }\n            var periodItem = _this._periods.get(index);\n            if (periodItem.audio == null) {\n                // No audio Buffer for this period, check next one\n                recursiveUpdateAudioTrack(index + 1);\n                return;\n            }\n            var period = periodItem.period, audioItem = periodItem.audio;\n            var audioAdaptations = period.adaptations.audio || [];\n            var chosenAudioAdaptation = _this._audioChoiceMemory.get(period);\n            if (chosenAudioAdaptation === null ||\n                (chosenAudioAdaptation !== undefined &&\n                    array_includes_1.default(audioAdaptations, chosenAudioAdaptation))) {\n                // Already best audio for this Buffer, check next one\n                recursiveUpdateAudioTrack(index + 1);\n                return;\n            }\n            var optimalAdaptation = findFirstOptimalAudioAdaptation(audioAdaptations, preferredAudioTracks);\n            _this._audioChoiceMemory.set(period, optimalAdaptation);\n            audioItem.adaptation$.next(optimalAdaptation);\n            // previous \"next\" call could have changed everything, start over\n            recursiveUpdateAudioTrack(0);\n        };\n        recursiveUpdateAudioTrack(0);\n    };\n    LanguageManager.prototype._updateTextTrackChoices = function () {\n        var _this = this;\n        var preferredTextTracks = this._preferredTextTracks;\n        var recursiveUpdateTextTrack = function (index) {\n            if (index >= _this._periods.length()) {\n                // we did all text Buffers, exit\n                return;\n            }\n            var periodItem = _this._periods.get(index);\n            if (periodItem.text == null) {\n                // No text Buffer for this period, check next one\n                recursiveUpdateTextTrack(index + 1);\n                return;\n            }\n            var period = periodItem.period, textItem = periodItem.text;\n            var textAdaptations = period.adaptations.text || [];\n            var chosenTextAdaptation = _this._textChoiceMemory.get(period);\n            if (chosenTextAdaptation === null ||\n                (chosenTextAdaptation !== undefined &&\n                    array_includes_1.default(textAdaptations, chosenTextAdaptation))) {\n                // Already best text for this Buffer, check next one\n                recursiveUpdateTextTrack(index + 1);\n                return;\n            }\n            var optimalAdaptation = findFirstOptimalTextAdaptation(textAdaptations, preferredTextTracks);\n            _this._textChoiceMemory.set(period, optimalAdaptation);\n            textItem.adaptation$.next(optimalAdaptation);\n            // previous \"next\" call could have changed everything, start over\n            recursiveUpdateTextTrack(0);\n        };\n        recursiveUpdateTextTrack(0);\n    };\n    return LanguageManager;\n}());\nexports.default = LanguageManager;\n// /**\n//  * Returns true if the given audio adaptation is an optimal choice for a period\n//  * given:\n//  *\n//  *   - the list of audio adaptations in the period\n//  *\n//  *   - an array of preferred audio configurations sorted from the most preferred\n//  *     to the least preferred.\n//  *\n//  * @param {Adaptation|null} adaptation\n//  * @param {Array.<Adaptation>} audioAdaptations\n//  * @param {Array.<Object>} preferredAudioTracks\n//  * @returns {Boolean}\n//  */\n// function isAudioAdaptationOptimal(\n//   adaptation : Adaptation|null,\n//   audioAdaptations : Adaptation[],\n//   preferredAudioTracks : IAudioTrackPreference[]\n// ) : boolean {\n//   if (!audioAdaptations.length) {\n//     return adaptation === null;\n//   }\n//   for (let i = 0; i < preferredAudioTracks.length; i++) {\n//     const preferredAudioTrack = preferredAudioTracks[i];\n//     if (preferredAudioTrack === null) {\n//       return adaptation === null;\n//     }\n//     const foundAdaptation = arrayFind(audioAdaptations, (audioAdaptation) =>\n//       audioAdaptation.normalizedLanguage === preferredAudioTrack.normalized &&\n//       !!audioAdaptation.isAudioDescription === preferredAudioTrack.audioDescription\n//     );\n//     if (foundAdaptation !== undefined) {\n//       if (adaptation === null) {\n//         return false;\n//       }\n//       return (\n//         (foundAdaptation.normalizedLanguage || \"\") ===\n//         (adaptation.normalizedLanguage || \"\")\n//       ) && !!foundAdaptation.isAudioDescription === !!adaptation.isAudioDescription;\n//     }\n//   }\n//   return true; // no optimal adaptation, just return true\n// }\n/**\n * Find an optimal audio adaptation given their list and the array of preferred\n * audio tracks sorted from the most preferred to the least preferred.\n *\n * null if the most optimal audio adaptation is no audio adaptation.\n * @param {Array.<Adaptation>} audioAdaptations\n * @returns {Adaptation|null}\n */\nfunction findFirstOptimalAudioAdaptation(audioAdaptations, preferredAudioTracks) {\n    if (!audioAdaptations.length) {\n        return null;\n    }\n    var _loop_1 = function (i) {\n        var preferredAudioTrack = preferredAudioTracks[i];\n        if (preferredAudioTrack === null) {\n            return { value: null };\n        }\n        var foundAdaptation = arrayFind(audioAdaptations, function (audioAdaptation) {\n            return (audioAdaptation.normalizedLanguage || \"\") === preferredAudioTrack.normalized &&\n                !!audioAdaptation.isAudioDescription === preferredAudioTrack.audioDescription;\n        });\n        if (foundAdaptation !== undefined) {\n            return { value: foundAdaptation };\n        }\n    };\n    for (var i = 0; i < preferredAudioTracks.length; i++) {\n        var state_1 = _loop_1(i);\n        if (typeof state_1 === \"object\")\n            return state_1.value;\n    }\n    // no optimal adaptation, just return the first one\n    return audioAdaptations[0];\n}\n// /**\n//  * Returns true if the given text adaptation is an optimal choice for a period\n//  * given:\n//  *\n//  *   - the list of text adaptations in the period\n//  *\n//  *   - an array of preferred text configurations sorted from the most preferred\n//  *     to the least preferred.\n//  *\n//  * @param {Adaptation|null} adaptation\n//  * @param {Array.<Adaptation>} audioAdaptations\n//  * @param {Array.<Object>} preferredAudioTracks\n//  * @returns {Boolean}\n//  */\n// function isTextAdaptationOptimal(\n//   adaptation : Adaptation|null,\n//   textAdaptations : Adaptation[],\n//   preferredTextTracks : ITextTrackPreference[]\n// ) : boolean {\n//   if (!textAdaptations.length) {\n//     return adaptation === null;\n//   }\n//   for (let i = 0; i < preferredTextTracks.length; i++) {\n//     const preferredTextTrack = preferredTextTracks[i];\n//     if (preferredTextTrack === null) {\n//       return adaptation === null;\n//     }\n//     const foundAdaptation = arrayFind(textAdaptations, (textAdaptation) =>\n//       (textAdaptation.normalizedLanguage || \"\") === preferredTextTrack.normalized &&\n//       !!textAdaptation.isClosedCaption === preferredTextTrack.closedCaption\n//     );\n//     if (foundAdaptation !== undefined) {\n//       if (adaptation === null) {\n//         return false;\n//       }\n//       return (\n//         (foundAdaptation.normalizedLanguage || \"\") ===\n//         (adaptation.normalizedLanguage || \"\")\n//       ) && !!foundAdaptation.isClosedCaption === !!adaptation.isClosedCaption;\n//     }\n//   }\n//   return adaptation === null;\n// }\n/**\n * Find an optimal text adaptation given their list and the array of preferred\n * text tracks sorted from the most preferred to the least preferred.\n *\n * null if the most optimal text adaptation is no text adaptation.\n * @param {Array.<Adaptation>} audioAdaptations\n * @returns {Adaptation|null}\n */\nfunction findFirstOptimalTextAdaptation(textAdaptations, preferredTextTracks) {\n    if (!textAdaptations.length) {\n        return null;\n    }\n    var _loop_2 = function (i) {\n        var preferredTextTrack = preferredTextTracks[i];\n        if (preferredTextTrack === null) {\n            return { value: null };\n        }\n        var foundAdaptation = arrayFind(textAdaptations, function (textAdaptation) {\n            return (textAdaptation.normalizedLanguage || \"\") === preferredTextTrack.normalized &&\n                !!textAdaptation.isClosedCaption === preferredTextTrack.closedCaption;\n        });\n        if (foundAdaptation !== undefined) {\n            return { value: foundAdaptation };\n        }\n    };\n    for (var i = 0; i < preferredTextTracks.length; i++) {\n        var state_2 = _loop_2(i);\n        if (typeof state_2 === \"object\")\n            return state_2.value;\n    }\n    // no optimal adaptation\n    return null;\n}\nfunction findPeriodIndex(periods, period) {\n    for (var i = 0; i < periods.length(); i++) {\n        var periodI = periods.get(i);\n        if (periodI.period.id === period.id) {\n            return i;\n        }\n    }\n}\nfunction getPeriodItem(periods, period) {\n    for (var i = 0; i < periods.length(); i++) {\n        var periodI = periods.get(i);\n        if (periodI.period.id === period.id) {\n            return periodI;\n        }\n    }\n}\n\n\n//# sourceURL=webpack://RxPlayer/./src/core/api/language_manager.ts?");

/***/ }),

/***/ "./src/core/api/option_parsers.ts":
/*!****************************************!*\
  !*** ./src/core/api/option_parsers.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * This file exports various helpers to parse options given to various APIs,\n * throw if something is wrong, and return a normalized option object.\n */\nvar objectAssign = __webpack_require__(/*! object-assign */ \"./node_modules/object-assign/index.js\");\nvar config_1 = __webpack_require__(/*! ../../config */ \"./src/config.ts\");\nvar languages_1 = __webpack_require__(/*! ../../utils/languages */ \"./src/utils/languages/index.ts\");\nvar log_1 = __webpack_require__(/*! ../../utils/log */ \"./src/utils/log.ts\");\nvar DEFAULT_AUTO_PLAY = config_1.default.DEFAULT_AUTO_PLAY, DEFAULT_INITIAL_BITRATES = config_1.default.DEFAULT_INITIAL_BITRATES, DEFAULT_LIMIT_VIDEO_WIDTH = config_1.default.DEFAULT_LIMIT_VIDEO_WIDTH, DEFAULT_MAX_BITRATES = config_1.default.DEFAULT_MAX_BITRATES, DEFAULT_MAX_BUFFER_AHEAD = config_1.default.DEFAULT_MAX_BUFFER_AHEAD, DEFAULT_MAX_BUFFER_BEHIND = config_1.default.DEFAULT_MAX_BUFFER_BEHIND, DEFAULT_SHOW_NATIVE_SUBTITLE = config_1.default.DEFAULT_SHOW_NATIVE_SUBTITLE, DEFAULT_TEXT_TRACK_MODE = config_1.default.DEFAULT_TEXT_TRACK_MODE, DEFAULT_THROTTLE_WHEN_HIDDEN = config_1.default.DEFAULT_THROTTLE_WHEN_HIDDEN, DEFAULT_WANTED_BUFFER_AHEAD = config_1.default.DEFAULT_WANTED_BUFFER_AHEAD;\n/**\n * Parse options given to the API constructor and set default options as found\n * in the config.\n *\n * Do not mutate anything, only cross the given options and sane default options\n * (most coming from the config).\n * @param {Object} [options={}]\n * @returns {Object}\n */\nfunction parseConstructorOptions(options) {\n    var maxBufferAhead;\n    var maxBufferBehind;\n    var wantedBufferAhead;\n    var limitVideoWidth;\n    var throttleWhenHidden;\n    var videoElement;\n    var initialVideoBitrate;\n    var initialAudioBitrate;\n    var maxAudioBitrate;\n    var maxVideoBitrate;\n    var stopAtEnd;\n    if (options.maxBufferAhead == null) {\n        maxBufferAhead = DEFAULT_MAX_BUFFER_AHEAD;\n    }\n    else {\n        maxBufferAhead = Number(options.maxBufferAhead);\n        if (isNaN(maxBufferAhead)) {\n            throw new Error(\"Invalid maxBufferAhead parameter. Should be a number.\");\n        }\n    }\n    if (options.maxBufferBehind == null) {\n        maxBufferBehind = DEFAULT_MAX_BUFFER_BEHIND;\n    }\n    else {\n        maxBufferBehind = Number(options.maxBufferBehind);\n        if (isNaN(maxBufferBehind)) {\n            throw new Error(\"Invalid maxBufferBehind parameter. Should be a number.\");\n        }\n    }\n    if (options.wantedBufferAhead == null) {\n        wantedBufferAhead = DEFAULT_WANTED_BUFFER_AHEAD;\n    }\n    else {\n        wantedBufferAhead = Number(options.wantedBufferAhead);\n        if (isNaN(wantedBufferAhead)) {\n            /* tslint:disable:max-line-length */\n            throw new Error(\"Invalid wantedBufferAhead parameter. Should be a number.\");\n            /* tslint:enable:max-line-length */\n        }\n    }\n    limitVideoWidth = options.limitVideoWidth == null ?\n        DEFAULT_LIMIT_VIDEO_WIDTH : !!options.limitVideoWidth;\n    throttleWhenHidden = options.throttleWhenHidden == null ?\n        DEFAULT_THROTTLE_WHEN_HIDDEN : !!options.throttleWhenHidden;\n    if (options.videoElement == null) {\n        videoElement = document.createElement(\"video\");\n    }\n    else if (options.videoElement instanceof HTMLMediaElement) {\n        videoElement = options.videoElement;\n    }\n    else {\n        /* tslint:disable:max-line-length */\n        throw new Error(\"Invalid videoElement parameter. Should be a HTMLMediaElement.\");\n        /* tslint:enable:max-line-length */\n    }\n    if (options.initialVideoBitrate == null) {\n        initialVideoBitrate = DEFAULT_INITIAL_BITRATES.video;\n    }\n    else {\n        initialVideoBitrate = Number(options.initialVideoBitrate);\n        if (isNaN(initialVideoBitrate)) {\n            /* tslint:disable:max-line-length */\n            throw new Error(\"Invalid initialVideoBitrate parameter. Should be a number.\");\n            /* tslint:enable:max-line-length */\n        }\n    }\n    if (options.initialAudioBitrate == null) {\n        initialAudioBitrate = DEFAULT_INITIAL_BITRATES.audio;\n    }\n    else {\n        initialAudioBitrate = Number(options.initialAudioBitrate);\n        if (isNaN(initialAudioBitrate)) {\n            /* tslint:disable:max-line-length */\n            throw new Error(\"Invalid initialAudioBitrate parameter. Should be a number.\");\n            /* tslint:enable:max-line-length */\n        }\n    }\n    if (options.maxVideoBitrate == null) {\n        maxVideoBitrate = DEFAULT_MAX_BITRATES.video;\n    }\n    else {\n        maxVideoBitrate = Number(options.maxVideoBitrate);\n        if (isNaN(maxVideoBitrate)) {\n            throw new Error(\"Invalid maxVideoBitrate parameter. Should be a number.\");\n        }\n    }\n    if (options.maxAudioBitrate == null) {\n        maxAudioBitrate = DEFAULT_MAX_BITRATES.audio;\n    }\n    else {\n        maxAudioBitrate = Number(options.maxAudioBitrate);\n        if (isNaN(maxAudioBitrate)) {\n            throw new Error(\"Invalid maxAudioBitrate parameter. Should be a number.\");\n        }\n    }\n    if (options.stopAtEnd == null) {\n        stopAtEnd = true;\n    }\n    else if (typeof options.stopAtEnd === \"boolean\") {\n        stopAtEnd = options.stopAtEnd;\n    }\n    else {\n        throw new Error(\"Invalid stopAtEnd parameter. Should be a boolean.\");\n    }\n    return {\n        maxBufferAhead: maxBufferAhead,\n        maxBufferBehind: maxBufferBehind,\n        limitVideoWidth: limitVideoWidth,\n        videoElement: videoElement,\n        wantedBufferAhead: wantedBufferAhead,\n        throttleWhenHidden: throttleWhenHidden,\n        initialAudioBitrate: initialAudioBitrate,\n        initialVideoBitrate: initialVideoBitrate,\n        maxAudioBitrate: maxAudioBitrate,\n        maxVideoBitrate: maxVideoBitrate,\n        stopAtEnd: stopAtEnd,\n    };\n}\nexports.parseConstructorOptions = parseConstructorOptions;\n/**\n * Parse options given to loadVideo and set default options as found\n * in the config.\n *\n * Do not mutate anything, only cross the given options and sane default options\n * (most coming from the config).\n *\n * Throws if any mandatory option is not set.\n * @param {Object} [options={}]\n * @param {Object} ctx - The player context, needed for some default values.\n * @returns {Object}\n */\nfunction parseLoadVideoOptions(options) {\n    var url;\n    var transport;\n    var autoPlay;\n    var keySystems;\n    var transportOptions;\n    var supplementaryTextTracks;\n    var supplementaryImageTracks;\n    var textTrackMode;\n    var textTrackElement;\n    var defaultAudioTrack;\n    var defaultTextTrack;\n    var hideNativeSubtitle;\n    var startAt;\n    if (!options || options.url == null) {\n        throw new Error(\"No url set on loadVideo\");\n    }\n    else {\n        url = String(options.url);\n    }\n    if (options.transport == null) {\n        throw new Error(\"No transport set on loadVideo\");\n    }\n    else {\n        transport = String(options.transport);\n    }\n    autoPlay = options.autoPlay == null ?\n        DEFAULT_AUTO_PLAY : !!options.autoPlay;\n    if (options.keySystems == null) {\n        keySystems = [];\n    }\n    else {\n        keySystems = Array.isArray(options.keySystems) ?\n            options.keySystems : [options.keySystems];\n        for (var _i = 0, keySystems_1 = keySystems; _i < keySystems_1.length; _i++) {\n            var keySystem = keySystems_1[_i];\n            if (typeof keySystem.type !== \"string\" ||\n                typeof keySystem.getLicense !== \"function\") {\n                throw new Error(\"Invalid key system given: Missing type string or \" +\n                    \"getLicense callback\");\n            }\n        }\n    }\n    transportOptions = options.transportOptions;\n    if (options.supplementaryTextTracks == null) {\n        supplementaryTextTracks = [];\n    }\n    else {\n        supplementaryTextTracks =\n            Array.isArray(options.supplementaryTextTracks) ?\n                options.supplementaryTextTracks : [options.supplementaryTextTracks];\n        for (var _a = 0, supplementaryTextTracks_1 = supplementaryTextTracks; _a < supplementaryTextTracks_1.length; _a++) {\n            var supplementaryTextTrack = supplementaryTextTracks_1[_a];\n            if (typeof supplementaryTextTrack.closedCaption !== \"boolean\") {\n                supplementaryTextTrack.closedCaption = !!supplementaryTextTrack.closedCaption;\n            }\n            if (typeof supplementaryTextTrack.language !== \"string\" ||\n                typeof supplementaryTextTrack.mimeType !== \"string\" ||\n                typeof supplementaryTextTrack.url !== \"string\") {\n                /* tslint:disable:max-line-length */\n                throw new Error(\"Invalid supplementary text track given. Missing either language, mimetype or url\");\n                /* tslint:enable:max-line-length */\n            }\n        }\n    }\n    if (options.supplementaryImageTracks == null) {\n        supplementaryImageTracks = [];\n    }\n    else {\n        supplementaryImageTracks =\n            Array.isArray(options.supplementaryImageTracks) ?\n                options.supplementaryImageTracks : [options.supplementaryImageTracks];\n        for (var _b = 0, supplementaryImageTracks_1 = supplementaryImageTracks; _b < supplementaryImageTracks_1.length; _b++) {\n            var supplementaryImageTrack = supplementaryImageTracks_1[_b];\n            if (typeof supplementaryImageTrack.mimeType !== \"string\" ||\n                typeof supplementaryImageTrack.url !== \"string\") {\n                /* tslint:disable:max-line-length */\n                throw new Error(\"Invalid supplementary image track given. Missing either mimetype or url\");\n                /* tslint:enable:max-line-length */\n            }\n        }\n    }\n    if (options.textTrackMode == null) {\n        textTrackMode = DEFAULT_TEXT_TRACK_MODE;\n    }\n    else {\n        if (options.textTrackMode !== \"native\" && options.textTrackMode !== \"html\") {\n            throw new Error(\"Invalid textTrackMode.\");\n        }\n        textTrackMode = options.textTrackMode;\n    }\n    defaultAudioTrack = languages_1.normalizeAudioTrack(options.defaultAudioTrack);\n    defaultTextTrack = languages_1.normalizeTextTrack(options.defaultTextTrack);\n    hideNativeSubtitle = options.hideNativeSubtitle == null ?\n        !DEFAULT_SHOW_NATIVE_SUBTITLE : !!options.hideNativeSubtitle;\n    if (textTrackMode === \"html\") {\n        // TODO Better way to express that in TypeScript?\n        if (options.textTrackElement == null) {\n            /* tslint:disable:max-line-length */\n            throw new Error(\"You have to provide a textTrackElement in \\\"html\\\" textTrackMode.\");\n            /* tslint:enable:max-line-length */\n        }\n        else if (!(options.textTrackElement instanceof HTMLElement)) {\n            throw new Error(\"textTrackElement should be an HTMLElement.\");\n        }\n        else {\n            textTrackElement = options.textTrackElement;\n        }\n    }\n    else if (options.textTrackElement != null) {\n        /* tslint:disable:max-line-length */\n        log_1.default.warn(\"You have set a textTrackElement without being in an \\\"html\\\" textTrackMode. It will be ignored.\");\n        /* tslint:enable:max-line-length */\n    }\n    if (options.startAt != null) {\n        // TODO Better way to express that in TypeScript?\n        if (options.startAt.wallClockTime\n            instanceof Date) {\n            var wallClockTime = options.startAt\n                .wallClockTime.getTime() / 1000;\n            startAt = objectAssign({}, options.startAt, { wallClockTime: wallClockTime });\n        }\n        else {\n            startAt = options.startAt;\n        }\n    }\n    var networkConfig = options.networkConfig == null ? {} : {\n        manifestRetry: options.networkConfig.manifestRetry,\n        offlineRetry: options.networkConfig.offlineRetry,\n        segmentRetry: options.networkConfig.segmentRetry,\n    };\n    // TODO without cast\n    /* tslint:disable no-object-literal-type-assertion */\n    return {\n        autoPlay: autoPlay,\n        defaultAudioTrack: defaultAudioTrack,\n        defaultTextTrack: defaultTextTrack,\n        hideNativeSubtitle: hideNativeSubtitle,\n        keySystems: keySystems,\n        networkConfig: networkConfig,\n        startAt: startAt,\n        supplementaryImageTracks: supplementaryImageTracks,\n        supplementaryTextTracks: supplementaryTextTracks,\n        textTrackElement: textTrackElement,\n        textTrackMode: textTrackMode,\n        transport: transport,\n        transportOptions: transportOptions,\n        url: url,\n    };\n    /* tslint:enable no-object-literal-type-assertion */\n}\nexports.parseLoadVideoOptions = parseLoadVideoOptions;\n\n\n//# sourceURL=webpack://RxPlayer/./src/core/api/option_parsers.ts?");

/***/ }),

/***/ "./src/core/buffer/append_data.ts":
/*!****************************************!*\
  !*** ./src/core/buffer/append_data.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Observable_1 = __webpack_require__(/*! rxjs/Observable */ \"./node_modules/rxjs/Observable.js\");\nvar errors_1 = __webpack_require__(/*! ../../errors */ \"./src/errors/index.ts\");\nvar force_garbage_collection_1 = __webpack_require__(/*! ./force_garbage_collection */ \"./src/core/buffer/force_garbage_collection.ts\");\n/**\n * Append buffer to the queuedSourceBuffer.\n * If it leads to a QuotaExceededError, try to run our custom range\n * _garbage collector_.\n *\n * @param {Object} queuedSourceBuffer\n * @param {Object|null} initSegmentData\n * @param {Object} segment\n * @param {Object} segmentData\n * @returns {Observable}\n */\nfunction appendDataToSourceBuffer(queuedSourceBuffer, initSegmentData, segment, segmentData) {\n    var append$;\n    if (segment.isInit) {\n        append$ = initSegmentData == null ?\n            Observable_1.Observable.of(undefined) :\n            queuedSourceBuffer.appendBuffer(initSegmentData, null);\n    }\n    else {\n        append$ = segmentData == null ?\n            Observable_1.Observable.of(undefined) :\n            queuedSourceBuffer.appendBuffer(initSegmentData, segmentData);\n    }\n    return append$;\n}\n/**\n * Append buffer to the queuedSourceBuffer.\n * If it leads to a QuotaExceededError, try to run our custom range\n * _garbage collector_.\n *\n * @param {Observable} clock$\n * @param {Object} queuedSourceBuffer\n * @param {Object|null} initSegmentData\n * @param {Object} segment\n * @param {Object} segmentData\n * @returns {Observable}\n */\nfunction appendDataToSourceBufferWithRetries(clock$, queuedSourceBuffer, initSegmentData, segment, segmentData) {\n    var append$ = appendDataToSourceBuffer(queuedSourceBuffer, initSegmentData, segment, segmentData);\n    return append$\n        .catch(function (appendError) {\n        if (!appendError || appendError.name !== \"QuotaExceededError\") {\n            throw new errors_1.MediaError(\"BUFFER_APPEND_ERROR\", appendError, true);\n        }\n        return force_garbage_collection_1.default(clock$, queuedSourceBuffer)\n            .mergeMapTo(append$)\n            .catch(function (forcedGCError) {\n            // (weird Typing either due to TypeScript or RxJS bug)\n            throw new errors_1.MediaError(\"BUFFER_FULL_ERROR\", forcedGCError, true);\n        });\n    });\n}\nexports.default = appendDataToSourceBufferWithRetries;\n\n\n//# sourceURL=webpack://RxPlayer/./src/core/buffer/append_data.ts?");

/***/ }),

/***/ "./src/core/buffer/create_fake_buffer.ts":
/*!***********************************************!*\
  !*** ./src/core/buffer/create_fake_buffer.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Observable_1 = __webpack_require__(/*! rxjs/Observable */ \"./node_modules/rxjs/Observable.js\");\n/**\n * Create empty Buffer Observable, linked to a Period.\n *\n * This observable will never download any segment and just emit a \"full\"\n * event when reaching the end.\n *\n * @param {Observable} bufferClock$\n * @param {Observable} wantedBufferAhead$\n * @param {string} bufferType\n * @param {Object} content\n * @returns {Observable}\n */\nfunction createFakeBuffer(bufferClock$, wantedBufferAhead$, bufferType, content) {\n    var period = content.period;\n    return Observable_1.Observable.combineLatest(bufferClock$, wantedBufferAhead$)\n        .filter(function (_a) {\n        var clockTick = _a[0], wantedBufferAhead = _a[1];\n        return period.end != null && clockTick.currentTime + wantedBufferAhead >= period.end;\n    })\n        .map(function () {\n        return {\n            type: \"full-buffer\",\n            value: { bufferType: bufferType },\n        };\n    });\n}\nexports.default = createFakeBuffer;\n\n\n//# sourceURL=webpack://RxPlayer/./src/core/buffer/create_fake_buffer.ts?");

/***/ }),

/***/ "./src/core/buffer/force_garbage_collection.ts":
/*!*****************************************************!*\
  !*** ./src/core/buffer/force_garbage_collection.ts ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Observable_1 = __webpack_require__(/*! rxjs/Observable */ \"./node_modules/rxjs/Observable.js\");\nvar config_1 = __webpack_require__(/*! ../../config */ \"./src/config.ts\");\nvar log_1 = __webpack_require__(/*! ../../utils/log */ \"./src/utils/log.ts\");\nvar ranges_1 = __webpack_require__(/*! ../../utils/ranges */ \"./src/utils/ranges.ts\");\nvar GC_GAP_CALM = config_1.default.BUFFER_GC_GAPS.CALM;\nvar GC_GAP_BEEFY = config_1.default.BUFFER_GC_GAPS.BEEFY;\n/**\n * Run the garbage collector.\n *\n * Try to clean up buffered ranges from a low gcGap at first.\n * If it does not succeed to clean up space, use a higher gcCap.\n *\n * @param {Observable} timings$\n * @param {QueuedSourceBuffer} bufferingQueue\n * @returns {Observable}\n */\nfunction forceGarbageCollection(timings$, bufferingQueue // The type of buffer has no importance here\n) {\n    // wait for next timing event\n    return timings$.take(1).mergeMap(function (timing) {\n        log_1.default.warn(\"buffer: running garbage collector\");\n        var buffered = bufferingQueue.getBuffered();\n        var cleanedupRanges = selectGCedRanges(timing.currentTime, buffered, GC_GAP_CALM);\n        // more aggressive GC if we could not find any range to clean\n        if (cleanedupRanges.length === 0) {\n            cleanedupRanges =\n                selectGCedRanges(timing.currentTime, buffered, GC_GAP_BEEFY);\n        }\n        log_1.default.debug(\"buffer: gc cleaning\", cleanedupRanges);\n        return Observable_1.Observable.from(cleanedupRanges.map(function (range) { return bufferingQueue.removeBuffer(range); })).concatAll();\n    });\n}\nexports.default = forceGarbageCollection;\n/**\n * Buffer garbage collector algorithm.\n *\n * Tries to free up some part of the ranges that are distant from the current\n * playing time.\n * See: https://w3c.github.io/media-source/#sourcebuffer-prepare-append\n *\n * @param {Number} currentTime\n * @param {TimeRanges} buffered - current buffered ranges\n * @param {Number} gcGap - delta gap from current timestamp from which we\n * should consider cleaning up.\n * @returns {Array.<Range>} - Ranges selected for clean up\n */\nfunction selectGCedRanges(currentTime, buffered, gcGap) {\n    var _a = ranges_1.getInnerAndOuterTimeRanges(buffered, currentTime), innerRange = _a.innerRange, outerRanges = _a.outerRanges;\n    var cleanedupRanges = [];\n    // start by trying to remove all ranges that do not contain the\n    // current time and respect the gcGap\n    // respect the gcGap? FIXME?\n    for (var i = 0; i < outerRanges.length; i++) {\n        var outerRange = outerRanges[i];\n        if (currentTime - gcGap < outerRange.end) {\n            cleanedupRanges.push(outerRange);\n        }\n        else if (currentTime + gcGap > outerRange.start) {\n            cleanedupRanges.push(outerRange);\n        }\n    }\n    // try to clean up some space in the current range\n    if (innerRange) {\n        log_1.default.debug(\"buffer: gc removing part of inner range\", cleanedupRanges);\n        if (currentTime - gcGap > innerRange.start) {\n            cleanedupRanges.push({\n                start: innerRange.start,\n                end: currentTime - gcGap,\n            });\n        }\n        if (currentTime + gcGap < innerRange.end) {\n            cleanedupRanges.push({\n                start: currentTime + gcGap,\n                end: innerRange.end,\n            });\n        }\n    }\n    return cleanedupRanges;\n}\n\n\n//# sourceURL=webpack://RxPlayer/./src/core/buffer/force_garbage_collection.ts?");

/***/ }),

/***/ "./src/core/buffer/get_buffer_paddings.ts":
/*!************************************************!*\
  !*** ./src/core/buffer/get_buffer_paddings.ts ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar config_1 = __webpack_require__(/*! ../../config */ \"./src/config.ts\");\nvar BUFFER_PADDING = config_1.default.BUFFER_PADDING;\n/**\n * Get safety paddings (low and high) for the size of buffer that won't\n * be flushed when switching representation for smooth transitions\n * and avoiding buffer underflows.\n *\n * @param {Object} adaptation\n * @returns {Object}\n */\nfunction getBufferPaddings(adaptation) {\n    switch (adaptation.type) {\n        case \"audio\":\n        case \"video\":\n            return BUFFER_PADDING[adaptation.type];\n        default:\n            return BUFFER_PADDING.other;\n    }\n}\nexports.default = getBufferPaddings;\n\n\n//# sourceURL=webpack://RxPlayer/./src/core/buffer/get_buffer_paddings.ts?");

/***/ }),

/***/ "./src/core/buffer/get_segment_priority.ts":
/*!*************************************************!*\
  !*** ./src/core/buffer/get_segment_priority.ts ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar config_1 = __webpack_require__(/*! ../../config */ \"./src/config.ts\");\nvar SEGMENT_PRIORITIES_STEPS = config_1.default.SEGMENT_PRIORITIES_STEPS;\n/**\n * Calculate the priority number of the Segment, in function of the distance\n * with the current time.\n *\n * The lower is this number, the higher should be the priority of the request.\n *\n * @param {Object} segment\n * @param {Object} clockTick\n * @returns {number}\n */\nfunction getSegmentPriority(segment, clockTick) {\n    var currentTime = clockTick.currentTime + clockTick.timeOffset;\n    var segmentStart = segment.time / segment.timescale;\n    var distance = segmentStart - currentTime;\n    for (var priority = 0; priority < SEGMENT_PRIORITIES_STEPS.length; priority++) {\n        if (distance < SEGMENT_PRIORITIES_STEPS[priority]) {\n            return priority;\n        }\n    }\n    return SEGMENT_PRIORITIES_STEPS.length;\n}\nexports.default = getSegmentPriority;\n\n\n//# sourceURL=webpack://RxPlayer/./src/core/buffer/get_segment_priority.ts?");

/***/ }),

/***/ "./src/core/buffer/get_segments_needed.ts":
/*!************************************************!*\
  !*** ./src/core/buffer/get_segments_needed.ts ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Returns every segments currently wanted.\n *\n * @param {Object} representation - The representation of the chosen\n * adaptation\n * @param {Object} range\n * @param {Object} options\n * @returns {Array.<Object>}\n */\nfunction getSegmentsNeeded(representation, range, options) {\n    var addInitSegment = options.addInitSegment, ignoreRegularSegments = options.ignoreRegularSegments;\n    var initSegment = null;\n    if (addInitSegment) {\n        initSegment = representation.index.getInitSegment();\n    }\n    if (ignoreRegularSegments) {\n        return initSegment ? [initSegment] : [];\n    }\n    var start = range.start, end = range.end;\n    var duration = end - start;\n    // given the current timestamp and the previously calculated time gap and\n    // wanted buffer size, we can retrieve the list of segments to inject in\n    // our pipelines.\n    var mediaSegments = representation.index.getSegments(start, duration);\n    if (initSegment) {\n        mediaSegments.unshift(initSegment);\n    }\n    return mediaSegments;\n}\nexports.default = getSegmentsNeeded;\n\n\n//# sourceURL=webpack://RxPlayer/./src/core/buffer/get_segments_needed.ts?");

/***/ }),

/***/ "./src/core/buffer/get_wanted_range.ts":
/*!*********************************************!*\
  !*** ./src/core/buffer/get_wanted_range.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ranges_1 = __webpack_require__(/*! ../../utils/ranges */ \"./src/utils/ranges.ts\");\n/**\n * Returns the range of segments needed for a particular point in time.\n *\n * @param {Object} hardLimits\n * @param {TimeRanges} buffered\n * @param {Object} timing\n * @param {number} bufferGoal\n * @param {Object} paddings\n * @returns {Object}\n */\nfunction getWantedRange(hardLimits, buffered, timing, bufferGoal, paddings) {\n    var currentTime = timing.currentTime + timing.timeOffset;\n    var limitEnd = timing.liveGap == null ?\n        hardLimits.end :\n        Math.min(hardLimits.end || Infinity, timing.currentTime + timing.liveGap);\n    var boundedLimits = {\n        start: Math.max(hardLimits.start || 0, currentTime),\n        end: limitEnd,\n    };\n    var lowPadding = paddings.low, highPadding = paddings.high;\n    // Difference between the current time and the end of the current range\n    var bufferGap = ranges_1.getLeftSizeOfRange(buffered, currentTime);\n    // the ts padding is the time offset that we want to apply to our current\n    // start in order to calculate the starting point of the list of\n    // segments to inject.\n    var timestampPadding = bufferGap > lowPadding && bufferGap < Infinity ?\n        Math.min(bufferGap, highPadding) : 0;\n    return {\n        start: Math.min(Math.max(currentTime + timestampPadding, boundedLimits.start), boundedLimits.end || Infinity),\n        end: Math.min(Math.max(currentTime + bufferGoal, boundedLimits.start), boundedLimits.end || Infinity),\n    };\n}\nexports.default = getWantedRange;\n\n\n//# sourceURL=webpack://RxPlayer/./src/core/buffer/get_wanted_range.ts?");

/***/ }),

/***/ "./src/core/buffer/index.ts":
/*!**********************************!*\
  !*** ./src/core/buffer/index.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar objectAssign = __webpack_require__(/*! object-assign */ \"./node_modules/object-assign/index.js\");\nvar Observable_1 = __webpack_require__(/*! rxjs/Observable */ \"./node_modules/rxjs/Observable.js\");\nvar errors_1 = __webpack_require__(/*! ../../errors */ \"./src/errors/index.ts\");\nvar log_1 = __webpack_require__(/*! ../../utils/log */ \"./src/utils/log.ts\");\nvar create_fake_buffer_1 = __webpack_require__(/*! ./create_fake_buffer */ \"./src/core/buffer/create_fake_buffer.ts\");\nexports.createFakeBuffer = create_fake_buffer_1.default;\nvar representation_buffer_1 = __webpack_require__(/*! ./representation_buffer */ \"./src/core/buffer/representation_buffer.ts\");\n/**\n * Create Buffers linked to an Adaptation.\n *\n * It will rely on the ABRManager to choose at any time the best Representation\n * for this Adaptation and then run the logic to download and push the\n * corresponding segments in the SourceBuffer.\n *\n * @example\n * ```js\n * const bufferManager = new AdaptationBufferManager(\n *   abrManager,\n *   abrClock$\n * );\n *\n * const buffer$ = bufferManager.createBuffer(\n *  bufferClock$,\n *  queuedSourceBuffer,\n *  segmentBookkeeper,\n *  segmentFetcher,\n *  wantedBufferAhead$,\n *  { manifest, period, adaptation},\n * );\n * ```\n * @class AdaptationBufferManager\n */\nvar AdaptationBufferManager = /** @class */ (function () {\n    /**\n     * @param {ABRManager} abrManager\n     * @param {Observable} abrBaseClock$ - Clock at which the ABR manager will\n     * estimate the right Representation to play.\n     */\n    function AdaptationBufferManager(abrManager, abrBaseClock$) {\n        this._abrManager = abrManager;\n        this._abrBaseClock$ = abrBaseClock$;\n    }\n    /**\n     * Create new Buffer Observable linked to the given Adaptation.\n     *\n     * This Buffer will download and push segments from a single Adaptation,\n     * linked to a single Period.\n     * It will emit various events to report its status to the caller.\n     *\n     * @param {Observable} bufferClock$ - Clock at which the Buffer will check\n     * for segments download\n     * @param {QueuedSourceBuffer} queuedSourceBuffer - QueuedSourceBuffer used\n     * to push segments and know about the current real buffer's health.\n     * @param {SegmentBookkeeper} segmentBookkeeper - Used to synchronize and\n     * retrieve the Segments currently present in the QueuedSourceBuffer\n     * @param {Function} segmentFetcher - Function used to download segments\n     * @param {Observable} wantedBufferAhead$ - Emits the buffer goal\n     * @param {Object} content - Content to download\n     * @returns {Observable}\n     */\n    AdaptationBufferManager.prototype.createBuffer = function (bufferClock$, queuedSourceBuffer, segmentBookkeeper, segmentFetcher, wantedBufferAhead$, content) {\n        var manifest = content.manifest, period = content.period, adaptation = content.adaptation;\n        var abr$ = this._getABRForAdaptation(adaptation);\n        /**\n         * Emit at each bitrate estimate done by the ABRManager\n         * @type {Observable}\n         */\n        var bitrateEstimate$ = abr$\n            .filter(function (_a) {\n            var bitrate = _a.bitrate;\n            return bitrate != null;\n        })\n            .map(function (_a) {\n            var bitrate = _a.bitrate;\n            return {\n                type: \"bitrateEstimationChange\",\n                value: {\n                    type: adaptation.type,\n                    bitrate: bitrate,\n                },\n            };\n        });\n        /**\n         * Emit the chosen representation each time it changes.\n         * @type {Observable}\n         */\n        var representation$ = abr$\n            .map(function (abr) { return abr.representation; })\n            .distinctUntilChanged(function (a, b) {\n            return !a || !b || (a.bitrate === b.bitrate && a.id === b.id);\n        });\n        /**\n         * Emit each times the RepresentationBuffer should be re-initialized:\n         *   - Each time the Representation change\n         *   - Each time the user seek\n         * @type {Observable}\n         */\n        var shouldSwitchRepresentationBuffer$ = representation$\n            .distinctUntilChanged(function (oldRepresentation, newRepresentation) {\n            return oldRepresentation.id === newRepresentation.id;\n        });\n        /**\n         * @type {Observable}\n         */\n        var buffer$ = shouldSwitchRepresentationBuffer$\n            .switchMap(function (representation) {\n            return Observable_1.Observable.of({\n                type: \"representationChange\",\n                value: {\n                    type: adaptation.type,\n                    period: period,\n                    representation: representation,\n                },\n            }).concat(createRepresentationBuffer(representation));\n        });\n        return Observable_1.Observable.merge(buffer$, bitrateEstimate$);\n        /**\n         * Create and returns a new RepresentationBuffer Observable, linked to the\n         * given Representation.\n         * @param {Representation} representation\n         * @returns {Observable}\n         */\n        function createRepresentationBuffer(representation) {\n            log_1.default.info(\"changing representation\", adaptation.type, representation);\n            return representation_buffer_1.default({\n                clock$: bufferClock$,\n                content: {\n                    representation: representation,\n                    adaptation: adaptation,\n                    period: period,\n                    manifest: manifest,\n                },\n                queuedSourceBuffer: queuedSourceBuffer,\n                segmentBookkeeper: segmentBookkeeper,\n                segmentFetcher: segmentFetcher,\n                wantedBufferAhead$: wantedBufferAhead$,\n            })\n                .catch(function (error) {\n                // TODO only for smooth/to Delete?\n                // TODO Do it in the stream?\n                // for live adaptations, handle 412 errors as precondition-\n                // failed errors, ie: we are requesting for segments before they\n                // exist\n                // (In case of smooth streaming, 412 errors are requests that are\n                // performed to early).\n                if (!manifest.isLive ||\n                    error.type !== errors_1.ErrorTypes.NETWORK_ERROR ||\n                    !error.isHttpError(412)) {\n                    throw error;\n                }\n                manifest.updateLiveGap(1); // go back 1s for now\n                log_1.default.warn(\"precondition failed\", manifest.presentationLiveGap);\n                return Observable_1.Observable.timer(2000)\n                    .mergeMap(function () { return createRepresentationBuffer(representation); });\n            });\n        }\n    };\n    /**\n     * Returns ABR Observable.\n     * @param {Object} adaptation\n     * @returns {Observable}\n     */\n    AdaptationBufferManager.prototype._getABRForAdaptation = function (adaptation) {\n        var representations = adaptation.representations;\n        /**\n         * Keep track of the current representation to add informations to the\n         * ABR clock.\n         * TODO isn't that a little bit ugly?\n         * @type {Object|null}\n         */\n        var currentRepresentation = null;\n        var abrClock$ = this._abrBaseClock$\n            .map(function (tick) {\n            var bitrate;\n            var lastIndexPosition;\n            if (currentRepresentation) {\n                bitrate = currentRepresentation.bitrate;\n                if (currentRepresentation.index) {\n                    lastIndexPosition =\n                        currentRepresentation.index.getLastPosition();\n                }\n            }\n            return objectAssign({\n                bitrate: bitrate,\n                lastIndexPosition: lastIndexPosition,\n            }, tick);\n        });\n        return this._abrManager.get$(adaptation.type, abrClock$, representations)\n            .do(function (_a) {\n            var representation = _a.representation;\n            currentRepresentation = representation;\n        });\n    };\n    return AdaptationBufferManager;\n}());\nexports.default = AdaptationBufferManager;\n\n\n//# sourceURL=webpack://RxPlayer/./src/core/buffer/index.ts?");

/***/ }),

/***/ "./src/core/buffer/representation_buffer.ts":
/*!**************************************************!*\
  !*** ./src/core/buffer/representation_buffer.ts ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar objectAssign = __webpack_require__(/*! object-assign */ \"./node_modules/object-assign/index.js\");\nvar Observable_1 = __webpack_require__(/*! rxjs/Observable */ \"./node_modules/rxjs/Observable.js\");\nvar ReplaySubject_1 = __webpack_require__(/*! rxjs/ReplaySubject */ \"./node_modules/rxjs/ReplaySubject.js\");\nvar log_1 = __webpack_require__(/*! ../../utils/log */ \"./src/utils/log.ts\");\nvar simple_set_1 = __webpack_require__(/*! ../../utils/simple_set */ \"./src/utils/simple_set.ts\");\nvar append_data_1 = __webpack_require__(/*! ./append_data */ \"./src/core/buffer/append_data.ts\");\nvar get_buffer_paddings_1 = __webpack_require__(/*! ./get_buffer_paddings */ \"./src/core/buffer/get_buffer_paddings.ts\");\nvar get_segment_priority_1 = __webpack_require__(/*! ./get_segment_priority */ \"./src/core/buffer/get_segment_priority.ts\");\nvar get_segments_needed_1 = __webpack_require__(/*! ./get_segments_needed */ \"./src/core/buffer/get_segments_needed.ts\");\nvar get_wanted_range_1 = __webpack_require__(/*! ./get_wanted_range */ \"./src/core/buffer/get_wanted_range.ts\");\nvar segment_filter_1 = __webpack_require__(/*! ./segment_filter */ \"./src/core/buffer/segment_filter.ts\");\n/**\n * Build up buffer for a single Representation.\n *\n * Download and push segments linked to the given Representation according\n * to what is already in the SourceBuffer and where the playback currently is.\n *\n * Multiple RepresentationBuffer observables can be ran on the same\n * SourceBuffer.\n * This allows for example smooth transitions between multiple periods.\n *\n * @param {Object} opt\n * @returns {Observable}\n */\nfunction RepresentationBuffer(_a) {\n    var clock$ = _a.clock$, // emit current playback informations\n    content = _a.content, // all informations about the content we want to play\n    queuedSourceBuffer = _a.queuedSourceBuffer, // allows to interact with the SourceBuffer\n    segmentBookkeeper = _a.segmentBookkeeper, // keep track of what segments already are in the SourceBuffer\n    segmentFetcher = _a.segmentFetcher, // allows to download new segments\n    wantedBufferAhead$ = _a.wantedBufferAhead$;\n    // unwrap components of the content\n    var manifest = content.manifest, period = content.period, adaptation = content.adaptation, representation = content.representation;\n    var bufferType = adaptation.type;\n    /**\n     * Compute paddings, then used to calculate the wanted range of Segments\n     * wanted.\n     * @type {Object}\n     */\n    var paddings = get_buffer_paddings_1.default(adaptation);\n    /**\n     * Saved initSegment state for this representation.\n     * null when no initialization segment has been downloaded yet.\n     * @type {Object}\n     */\n    var initSegmentObject = null;\n    /**\n     * Subject to start/restart a Buffer Queue.\n     * @type {Subject}\n     */\n    var startQueue$ = new ReplaySubject_1.ReplaySubject(1);\n    /**\n     * Segments queued for download in the BufferQueue.\n     * @type {Array.<Object>}\n     */\n    var downloadQueue = [];\n    /**\n     * Keep track of the informations about the pending Segment request.\n     * null if no request is pending.\n     * @type {Object|null}\n     */\n    var currentSegmentRequest = null;\n    /**\n     * Keep track of downloaded segments currently awaiting to be appended to the\n     * SourceBuffer.\n     *\n     * This is to avoid scheduling another download for that segment.\n     * The ID of each segment (segment.id) is thus added before each append and\n     * removed after it.\n     * @type {Object}\n     */\n    var sourceBufferWaitingQueue = new simple_set_1.default();\n    /**\n     * Request every Segment in the ``downloadQueue`` on subscription.\n     * Emit the data of a segment when a request succeeded.\n     * @returns {Observable}\n     */\n    function requestSegments() {\n        var requestNextSegment$ = Observable_1.Observable.defer(function () {\n            var currentNeededSegment = downloadQueue.shift();\n            if (currentNeededSegment == null) {\n                // queue is finished...\n                currentSegmentRequest = null;\n                return Observable_1.Observable.empty();\n            }\n            var segment = currentNeededSegment.segment, priority = currentNeededSegment.priority;\n            var initSegmentInfos = initSegmentObject && initSegmentObject.segmentInfos;\n            var request$ = segmentFetcher.createRequest({\n                adaptation: adaptation,\n                init: initSegmentInfos || undefined,\n                manifest: manifest,\n                period: period,\n                representation: representation,\n                segment: segment,\n            }, priority);\n            currentSegmentRequest = { segment: segment, priority: priority, request$: request$ };\n            return request$\n                .map(function (args) { return objectAssign({ segment: segment }, args); })\n                .concat(requestNextSegment$);\n        });\n        return requestNextSegment$\n            .finally(function () {\n            currentSegmentRequest = null;\n        });\n    }\n    /**\n     * Append the given segment to the SourceBuffer.\n     * Emit the right event when it succeeds.\n     * @param {Object} data\n     * @returns {Observable}\n     */\n    function appendSegment(data) {\n        return Observable_1.Observable.defer(function () {\n            var segment = data.segment;\n            var segmentInfos = data.parsed.segmentInfos;\n            var segmentData = data.parsed.segmentData;\n            if (segment.isInit) {\n                initSegmentObject = { segmentData: segmentData, segmentInfos: segmentInfos };\n            }\n            if (segmentData == null) {\n                // no segmentData to add here (for example, a text init segment)\n                // just complete directly without appending anything\n                return Observable_1.Observable.empty();\n            }\n            var initSegmentData = initSegmentObject && initSegmentObject.segmentData;\n            var append$ = append_data_1.default(clock$, queuedSourceBuffer, initSegmentData, segment, segmentData);\n            sourceBufferWaitingQueue.add(segment.id);\n            return append$\n                .mapTo({\n                type: \"added-segment\",\n                value: {\n                    bufferType: bufferType,\n                    segment: segment,\n                    segmentData: segmentData,\n                },\n            })\n                .do(function () {\n                if (segment.isInit) {\n                    return;\n                }\n                var _a = segmentInfos ? segmentInfos : segment, time = _a.time, duration = _a.duration, timescale = _a.timescale;\n                // current segment timings informations are used to update\n                // bufferedRanges informations\n                segmentBookkeeper.insert(period, adaptation, representation, segment, time / timescale, // start\n                duration != null ?\n                    (time + duration) / timescale : undefined // end\n                );\n            })\n                .finally(function () {\n                sourceBufferWaitingQueue.remove(segment.id);\n            });\n        });\n    }\n    /**\n     * Perform a check-up of the current status of the RepresentationBuffer:\n     *   - synchronize the SegmentBookkeeper with the current buffered\n     *   - checks if the manifest should be refreshed\n     *   - checks if a discontinuity is encountered\n     *   - check if segments need to be downloaded\n     *   - Emit a description of the current state of the buffer\n     *\n     * @param {Array} arr\n     * @returns {Object}\n     */\n    function getBufferStatus(_a) {\n        var timing = _a[0], bufferGoal = _a[1];\n        var buffered = queuedSourceBuffer.getBuffered();\n        var neededRange = get_wanted_range_1.default(period, buffered, timing, bufferGoal, paddings);\n        var discontinuity = getCurrentDiscontinuity(content, timing);\n        var shouldRefreshManifest = shouldRefreshManifestForRange(content, neededRange);\n        // /!\\ Side effect to the SegmentBookkeeper\n        segmentBookkeeper.synchronizeBuffered(buffered);\n        var neededSegments = get_segments_needed_1.default(representation, neededRange, {\n            addInitSegment: initSegmentObject == null,\n            ignoreRegularSegments: timing.readyState === 0,\n        })\n            .filter(function (segment) {\n            return segment_filter_1.default(segment, content, segmentBookkeeper, neededRange, sourceBufferWaitingQueue);\n        })\n            .map(function (segment) { return ({\n            priority: get_segment_priority_1.default(segment, timing),\n            segment: segment,\n        }); });\n        var state;\n        if (!neededSegments.length) {\n            state = period.end != null && neededRange.end >= period.end ?\n                { type: \"full-buffer\", value: undefined } :\n                { type: \"idle-buffer\", value: undefined };\n        }\n        else {\n            state = {\n                type: \"need-segments\",\n                value: { neededSegments: neededSegments },\n            };\n        }\n        return {\n            discontinuity: discontinuity,\n            shouldRefreshManifest: shouldRefreshManifest,\n            state: state,\n        };\n    }\n    /**\n     * Exploit the status given by ``getBufferStatus``:\n     *   - emit needed actions\n     *   - mutates the downloadQueue\n     *   - start/restart the current BufferQueue\n     *   - emit the state of the Buffer\n     * @param {Object} status\n     * @returns {Observable}\n     */\n    function handleBufferStatus(status) {\n        var discontinuity = status.discontinuity, shouldRefreshManifest = status.shouldRefreshManifest, state = status.state;\n        var neededActions = getNeededActions(bufferType, discontinuity, shouldRefreshManifest);\n        var downloadQueueState = updateQueueFromInternalState(state);\n        return downloadQueueState.type === \"idle-buffer\" ? Observable_1.Observable.of.apply(Observable_1.Observable, neededActions) :\n            Observable_1.Observable.of.apply(Observable_1.Observable, neededActions).concat(Observable_1.Observable.of(downloadQueueState));\n    }\n    /**\n     * Update the downloadQueue and start/restart the queue depending on the\n     * internalState and the current RepresentationBuffer's data.\n     *\n     * Returns the new state of the Downloading Queue.\n     *\n     * @param {Object} state\n     * @returns {Object}\n     */\n    function updateQueueFromInternalState(state) {\n        if (state.type !== \"need-segments\" || !state.value.neededSegments.length) {\n            if (currentSegmentRequest) {\n                log_1.default.debug(\"interrupting segment request.\");\n            }\n            downloadQueue = [];\n            startQueue$.next(undefined); // (re-)start with an empty queue\n            return state.type === \"full-buffer\" ? {\n                type: \"full-buffer\",\n                value: { bufferType: bufferType },\n            } : {\n                type: \"idle-buffer\",\n                value: { bufferType: bufferType },\n            };\n        }\n        var neededSegments = state.value.neededSegments;\n        var mostNeededSegment = neededSegments[0];\n        if (!currentSegmentRequest) {\n            log_1.default.debug(\"starting downloading queue\", adaptation.type);\n            downloadQueue = neededSegments;\n            startQueue$.next(undefined); // restart the queue\n        }\n        else if (currentSegmentRequest.segment.id !== mostNeededSegment.segment.id) {\n            log_1.default.debug(\"canceling old downloading queue and starting a new one\", adaptation.type);\n            downloadQueue = neededSegments;\n            startQueue$.next(undefined); // restart the queue\n        }\n        else if (currentSegmentRequest.priority !== mostNeededSegment.priority) {\n            log_1.default.debug(\"updating pending request priority\", adaptation.type);\n            segmentFetcher.updatePriority(currentSegmentRequest.request$, mostNeededSegment.priority);\n        }\n        else {\n            log_1.default.debug(\"updating downloading queue\", adaptation.type);\n            // Update the previous queue to be all needed segments but the first one,\n            // for which a request is already pending\n            var newQueue = neededSegments\n                .slice() // clone previous\n                .splice(1, neededSegments.length); // remove first element\n            // (pending request)\n            downloadQueue = newQueue;\n        }\n        return {\n            type: \"active-buffer\",\n            value: { bufferType: bufferType },\n        };\n    }\n    /**\n     * State Checker:\n     *   - indicates when the manifest should be refreshed\n     *   - indicates if a discontinuity is encountered\n     *   - emit state updates\n     *   - update the downloadQueue\n     *   - start/restart the BufferQueue\n     * @type {Observable}\n     */\n    var bufferState$ = Observable_1.Observable.combineLatest(clock$, wantedBufferAhead$)\n        .map(getBufferStatus)\n        .mergeMap(handleBufferStatus);\n    /**\n     * Buffer Queue:\n     *   - download segment\n     *   - append them to the SourceBuffer\n     * @type {Observable}\n     */\n    var bufferQueue$ = startQueue$\n        .switchMap(requestSegments)\n        .mergeMap(appendSegment);\n    return Observable_1.Observable.merge(bufferState$, bufferQueue$)\n        .share();\n}\nexports.default = RepresentationBuffer;\n/**\n * Emit the current discontinuity encountered.\n * Inferior or equal to 0 if no discontinuity is currently happening.\n * @param {Object} content\n * @param {Object} timing\n * @returns {number}\n */\nfunction getCurrentDiscontinuity(_a, timing) {\n    var manifest = _a.manifest, representation = _a.representation;\n    return !timing.stalled || !manifest.isLive ?\n        -1 : representation.index.checkDiscontinuity(timing.currentTime);\n}\n/**\n * Returns true if the current Manifest needs to be downloaded.\n * @param {Object} content\n * @param {Object} segmentBookkeeper\n * @param {Object} wantedRange\n * @returns {Boolean}\n */\nfunction shouldRefreshManifestForRange(_a, wantedRange) {\n    var representation = _a.representation;\n    var start = wantedRange.start, end = wantedRange.end;\n    return representation.index.shouldRefresh(start, end);\n}\n/**\n * @param {number} discontinuity\n * @param {boolean} shouldRefreshManifest\n * @returns {Array.<Object>}\n */\nfunction getNeededActions(bufferType, discontinuity, shouldRefreshManifest) {\n    var neededActions = [];\n    if (discontinuity > 1) {\n        neededActions.push({\n            type: \"discontinuity-encountered\",\n            value: {\n                nextTime: discontinuity + 1,\n                bufferType: bufferType,\n            },\n        });\n    }\n    if (shouldRefreshManifest) {\n        neededActions.push({\n            type: \"needs-manifest-refresh\",\n            value: { bufferType: bufferType },\n        });\n    }\n    return neededActions;\n}\n\n\n//# sourceURL=webpack://RxPlayer/./src/core/buffer/representation_buffer.ts?");

/***/ }),

/***/ "./src/core/buffer/segment_filter.ts":
/*!*******************************************!*\
  !*** ./src/core/buffer/segment_filter.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar config_1 = __webpack_require__(/*! ../../config */ \"./src/config.ts\");\nvar BITRATE_REBUFFERING_RATIO = config_1.default.BITRATE_REBUFFERING_RATIO, MINIMUM_SEGMENT_SIZE = config_1.default.MINIMUM_SEGMENT_SIZE;\n/**\n * Returns true if the given Segment should be downloaded.\n * false otherwise.\n *\n * @param {Object} segment\n * @param {Object} content - The content the Segment depends on.\n * @param {Object} segmentBookkeeper\n * @param {Object} wantedRange\n * @param {Object} segmentIDsToIgnore\n * @returns {boolean}\n */\nfunction shouldDownloadSegment(segment, content, segmentBookkeeper, wantedRange, segmentIDsToIgnore) {\n    var period = content.period, adaptation = content.adaptation, representation = content.representation;\n    var shouldIgnore = segmentIDsToIgnore.test(segment.id);\n    if (shouldIgnore) {\n        return false;\n    }\n    // segment without time info are usually init segments or some\n    // kind of metadata segment that we never filter out\n    if (segment.isInit || segment.time < 0) {\n        return true;\n    }\n    var time = segment.time, duration = segment.duration, timescale = segment.timescale;\n    if (!duration) {\n        return true;\n    }\n    if (duration / timescale < MINIMUM_SEGMENT_SIZE) {\n        return false;\n    }\n    var currentSegment = segmentBookkeeper.hasPlayableSegment(wantedRange, { time: time, duration: duration, timescale: timescale });\n    if (!currentSegment) {\n        return true;\n    }\n    if (currentSegment.infos.period.id !== period.id ||\n        currentSegment.infos.adaptation.id !== adaptation.id) {\n        return true;\n    }\n    // only re-load comparatively-poor bitrates for the same adaptation.\n    var bitrateCeil = currentSegment.infos.representation.bitrate *\n        BITRATE_REBUFFERING_RATIO;\n    return representation.bitrate > bitrateCeil;\n}\nexports.default = shouldDownloadSegment;\n\n\n//# sourceURL=webpack://RxPlayer/./src/core/buffer/segment_filter.ts?");

/***/ }),

/***/ "./src/core/eme/attach_media_keys.ts":
/*!*******************************************!*\
  !*** ./src/core/eme/attach_media_keys.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Observable_1 = __webpack_require__(/*! rxjs/Observable */ \"./node_modules/rxjs/Observable.js\");\nvar compat_1 = __webpack_require__(/*! ../../compat */ \"./src/compat/index.ts\");\nvar log_1 = __webpack_require__(/*! ../../utils/log */ \"./src/utils/log.ts\");\n/**\n * Set the MediaKeys object on the HTMLMediaElement if it is not already on the\n * element.\n * If a MediaKeys was already set on it, dispose of it before setting the new\n * one.\n *\n * /!\\ Mutates heavily currentMediaKeysInfos\n * @param {Object} mediaKeysInfos\n * @param {HTMLMediaElement} mediaElement\n * @param {Object} currentMediaKeysInfos\n * @returns {Observable}\n */\nfunction attachMediaKeys(mediaKeysInfos, mediaElement, currentMediaKeysInfos) {\n    return Observable_1.Observable.defer(function () {\n        var previousState = currentMediaKeysInfos.getState(mediaElement);\n        var keySystemOptions = mediaKeysInfos.keySystemOptions, mediaKeySystemAccess = mediaKeysInfos.mediaKeySystemAccess, mediaKeys = mediaKeysInfos.mediaKeys, sessionsStore = mediaKeysInfos.sessionsStore;\n        currentMediaKeysInfos.setState(mediaElement, {\n            keySystemOptions: keySystemOptions,\n            mediaKeySystemAccess: mediaKeySystemAccess,\n            mediaKeys: mediaKeys,\n            sessionsStore: sessionsStore,\n        });\n        return (previousState && previousState.sessionsStore !== sessionsStore ?\n            previousState.sessionsStore.closeAllSessions() :\n            Observable_1.Observable.of(null)).mergeMap(function () {\n            if (mediaElement.mediaKeys === mediaKeys) {\n                return Observable_1.Observable.of(null);\n            }\n            log_1.default.debug(\"eme: set mediakeys\");\n            return compat_1.setMediaKeys(mediaElement, mediaKeys);\n        });\n    });\n}\nexports.default = attachMediaKeys;\n\n\n//# sourceURL=webpack://RxPlayer/./src/core/eme/attach_media_keys.ts?");

/***/ }),

/***/ "./src/core/eme/create_session.ts":
/*!****************************************!*\
  !*** ./src/core/eme/create_session.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Observable_1 = __webpack_require__(/*! rxjs/Observable */ \"./node_modules/rxjs/Observable.js\");\nvar array_includes_1 = __webpack_require__(/*! ../../utils/array-includes */ \"./src/utils/array-includes.ts\");\nvar assert_1 = __webpack_require__(/*! ../../utils/assert */ \"./src/utils/assert.ts\");\nvar castToObservable_1 = __webpack_require__(/*! ../../utils/castToObservable */ \"./src/utils/castToObservable.ts\");\nvar log_1 = __webpack_require__(/*! ../../utils/log */ \"./src/utils/log.ts\");\nvar is_session_usable_1 = __webpack_require__(/*! ./utils/is_session_usable */ \"./src/core/eme/utils/is_session_usable.ts\");\n/**\n * If session creating fails, retry once session creation/loading.\n * Emit true, if it has succeeded to load, false if there is no data for the\n * given sessionId.\n * @param {string} sessionId\n * @param {MediaKeySession} session\n * @returns {Observable}\n */\nfunction loadPersistentSession(sessionId, session) {\n    return Observable_1.Observable.defer(function () {\n        log_1.default.debug(\"eme: load persisted session\", sessionId);\n        return castToObservable_1.default(session.load(sessionId));\n    });\n}\n/**\n * Create a new Session on the given MediaKeys, corresponding to the given\n * initializationData.\n * If session creating fails, remove the oldest MediaKeySession loaded and\n * retry.\n *\n * /!\\ This only creates new sessions.\n * It will fail if sessionsStore already has a MediaKeySession with\n * the given initializationData.\n * @param {Uint8Array} initData\n * @param {string} initDataType\n * @param {Object} mediaKeysInfos\n * @returns {Observable}\n */\nfunction createSession(initData, initDataType, mediaKeysInfos) {\n    return Observable_1.Observable.defer(function () {\n        var keySystemOptions = mediaKeysInfos.keySystemOptions, mediaKeySystemAccess = mediaKeysInfos.mediaKeySystemAccess, sessionsStore = mediaKeysInfos.sessionsStore, sessionStorage = mediaKeysInfos.sessionStorage;\n        var mksConfig = mediaKeySystemAccess.getConfiguration();\n        var sessionTypes = mksConfig.sessionTypes;\n        var hasPersistence = (sessionTypes && array_includes_1.default(sessionTypes, \"persistent-license\"));\n        var sessionType = hasPersistence &&\n            sessionStorage &&\n            keySystemOptions.persistentLicense ?\n            \"persistent-license\" : \"temporary\";\n        log_1.default.debug(\"eme: create a new \" + sessionType + \" session\");\n        var session = sessionsStore.createSession(initData, initDataType, sessionType);\n        // Re-check for Dumb typescript\n        if (!hasPersistence || !sessionStorage || !keySystemOptions.persistentLicense) {\n            if (true) {\n                assert_1.default(sessionType === \"temporary\");\n            }\n            return Observable_1.Observable.of({\n                type: \"created-session\",\n                value: { mediaKeySession: session, sessionType: sessionType },\n            });\n        }\n        if (true) {\n            assert_1.default(sessionType === \"persistent-license\");\n        }\n        var storedEntry = sessionStorage.get(initData, initDataType);\n        if (!storedEntry) {\n            return Observable_1.Observable.of({\n                type: \"created-session\",\n                value: { mediaKeySession: session, sessionType: sessionType },\n            });\n        }\n        /**\n         * Helper function to close and restart the current persistent session\n         * considered, and re-create it from scratch.\n         * @returns {Observable}\n         */\n        var recreatePersistentSession = function () {\n            log_1.default.info(\"eme: removing previous persistent session.\");\n            if (sessionStorage.get(initData, initDataType) !== null) {\n                sessionStorage.delete(initData, initDataType);\n            }\n            return sessionsStore.closeSession(session)\n                .map(function () {\n                var newSession = sessionsStore.createSession(initData, initDataType, sessionType);\n                return {\n                    type: \"created-session\",\n                    value: { mediaKeySession: newSession, sessionType: sessionType },\n                };\n            });\n        };\n        return loadPersistentSession(storedEntry.sessionId, session)\n            .mergeMap(function (hasLoadedSession) {\n            if (!hasLoadedSession) {\n                log_1.default.warn(\"eme: no data stored for the loaded session\");\n                sessionStorage.delete(initData, initDataType);\n                return Observable_1.Observable.of({\n                    type: \"created-session\",\n                    value: { mediaKeySession: session, sessionType: sessionType },\n                });\n            }\n            if (hasLoadedSession && is_session_usable_1.default(session)) {\n                sessionStorage.add(initData, initDataType, session);\n                log_1.default.info(\"eme: succeeded to load persistent session.\");\n                return Observable_1.Observable.of({\n                    type: \"loaded-persistent-session\",\n                    value: { mediaKeySession: session, sessionType: sessionType },\n                });\n            }\n            // Unusable persistent session: recreate a new session from scratch.\n            log_1.default.warn(\"eme: previous persistent session not usable anymore.\");\n            return recreatePersistentSession();\n        })\n            .catch(function () {\n            log_1.default.warn(\"eme: unable to load persistent session.\");\n            return recreatePersistentSession();\n        });\n    });\n}\nexports.default = createSession;\n\n\n//# sourceURL=webpack://RxPlayer/./src/core/eme/create_session.ts?");

/***/ }),

/***/ "./src/core/eme/dispose_media_keys.ts":
/*!********************************************!*\
  !*** ./src/core/eme/dispose_media_keys.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Observable_1 = __webpack_require__(/*! rxjs/Observable */ \"./node_modules/rxjs/Observable.js\");\nvar compat_1 = __webpack_require__(/*! ../../compat */ \"./src/compat/index.ts\");\n/**\n * @param {Object} mediaKeysInfos\n * @returns {Observable}\n */\nfunction disposeMediaKeys(mediaElement, mediaKeysInfos) {\n    return Observable_1.Observable.defer(function () {\n        var currentState = mediaKeysInfos.getState(mediaElement);\n        if (!currentState) {\n            return Observable_1.Observable.of(null);\n        }\n        var sessionsStore = currentState.sessionsStore;\n        mediaKeysInfos.clearState(mediaElement);\n        return sessionsStore.closeAllSessions()\n            .mergeMapTo(compat_1.setMediaKeys(mediaElement, null));\n    });\n}\nexports.default = disposeMediaKeys;\n\n\n//# sourceURL=webpack://RxPlayer/./src/core/eme/dispose_media_keys.ts?");

/***/ }),

/***/ "./src/core/eme/find_key_system.ts":
/*!*****************************************!*\
  !*** ./src/core/eme/find_key_system.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Observable_1 = __webpack_require__(/*! rxjs/Observable */ \"./node_modules/rxjs/Observable.js\");\nvar compat_1 = __webpack_require__(/*! ../../compat */ \"./src/compat/index.ts\");\nvar config_1 = __webpack_require__(/*! ../../config */ \"./src/config.ts\");\nvar errors_1 = __webpack_require__(/*! ../../errors */ \"./src/errors/index.ts\");\nvar array_includes_1 = __webpack_require__(/*! ../../utils/array-includes */ \"./src/utils/array-includes.ts\");\nvar log_1 = __webpack_require__(/*! ../../utils/log */ \"./src/utils/log.ts\");\nvar EME_DEFAULT_WIDEVINE_ROBUSTNESSES = config_1.default.EME_DEFAULT_WIDEVINE_ROBUSTNESSES, EME_KEY_SYSTEMS = config_1.default.EME_KEY_SYSTEMS;\n/**\n * @param {Array.<Object>} keySystems\n * @param {Object} currentMediaKeysInfos\n * @returns {null|Object}\n */\nfunction checkCachedMediaKeySystemAccess(keySystems, currentKeySystemAccess, currentKeySystemOptions) {\n    var mksConfiguration = currentKeySystemAccess.getConfiguration();\n    // NOTE(pierre): alwaysRenew flag is used for IE11 which require the\n    // creation of a new MydiaKeys instance for each session creation\n    if (compat_1.shouldRenewMediaKeys() || !mksConfiguration) {\n        return null;\n    }\n    var firstCompatibleOption = keySystems.filter(function (ks) {\n        // XXX TODO Do it with MediaKeySystemAccess.prototype.keySystem instead\n        if (ks.type !== currentKeySystemOptions.type) {\n            return false;\n        }\n        if (ks.persistentLicense &&\n            mksConfiguration.persistentState !== \"required\") {\n            return false;\n        }\n        if (ks.distinctiveIdentifierRequired &&\n            mksConfiguration.distinctiveIdentifier !== \"required\") {\n            return false;\n        }\n        return true;\n    })[0];\n    if (firstCompatibleOption) {\n        return {\n            keySystemOptions: firstCompatibleOption,\n            keySystemAccess: currentKeySystemAccess,\n        };\n    }\n    return null;\n}\n/**\n * Find key system canonical name from key system type.\n * @param {string} ksType - Obtained via inversion\n * @returns {string|undefined} - Either the canonical name, or undefined.\n */\nfunction findKeySystemCanonicalName(ksType) {\n    for (var _i = 0, _a = Object.keys(EME_KEY_SYSTEMS); _i < _a.length; _i++) {\n        var ksName = _a[_i];\n        if (array_includes_1.default(EME_KEY_SYSTEMS[ksName], ksType)) {\n            return ksName;\n        }\n    }\n    return undefined;\n}\n/**\n * Build configuration for the requestMediaKeySystemAccess EME API, based\n * on the current keySystem object.\n * @param {string} [ksName] - Generic name for the key system. e.g. \"clearkey\",\n * \"widevine\", \"playready\". Can be used to make exceptions depending on it.\n * @param {Object} keySystem\n * @returns {Array.<Object>} - Configuration to give to the\n * requestMediaKeySystemAccess API.\n */\nfunction buildKeySystemConfigurations(ksName, keySystem) {\n    var sessionTypes = [\"temporary\"];\n    var persistentState = \"optional\";\n    var distinctiveIdentifier = \"optional\";\n    if (keySystem.persistentLicense) {\n        persistentState = \"required\";\n        sessionTypes.push(\"persistent-license\");\n    }\n    if (keySystem.persistentStateRequired) {\n        persistentState = \"required\";\n    }\n    if (keySystem.distinctiveIdentifierRequired) {\n        distinctiveIdentifier = \"required\";\n    }\n    // Set robustness, in order of consideration:\n    //   1. the user specified its own robustnesses\n    //   2. a \"widevine\" key system is used, in that case set the default widevine\n    //      robustnesses as defined in the config\n    //   3. set an undefined robustness\n    var videoRobustnesses = keySystem.videoRobustnesses ||\n        (ksName === \"widevine\" ? EME_DEFAULT_WIDEVINE_ROBUSTNESSES : []);\n    var audioRobustnesses = keySystem.audioRobustnesses ||\n        (ksName === \"widevine\" ? EME_DEFAULT_WIDEVINE_ROBUSTNESSES : []);\n    if (!videoRobustnesses.length) {\n        videoRobustnesses.push(undefined);\n    }\n    if (!audioRobustnesses.length) {\n        audioRobustnesses.push(undefined);\n    }\n    // From the W3 EME spec, we have to provide videoCapabilities and\n    // audioCapabilities.\n    // These capabilities must specify a codec (even though your stream can use\n    // a completely different codec afterward).\n    // It is also strongly recommended to specify the required security\n    // robustness. As we do not want to forbide any security level, we specify\n    // every existing security level from highest to lowest so that the best\n    // security level is selected.\n    // More details here:\n    // https://storage.googleapis.com/wvdocs/Chrome_EME_Changes_and_Best_Practices.pdf\n    // https://www.w3.org/TR/encrypted-media/#get-supported-configuration-and-consent\n    var videoCapabilities = videoRobustnesses.map(function (robustness) { return ({\n        contentType: \"video/mp4;codecs=\\\"avc1.4d401e\\\"\",\n        robustness: robustness,\n    }); });\n    var audioCapabilities = audioRobustnesses.map(function (robustness) { return ({\n        contentType: \"audio/mp4;codecs=\\\"mp4a.40.2\\\"\",\n        robustness: robustness,\n    }); });\n    // TODO Re-test with a set contentType but an undefined robustness on the\n    // STBs on which this problem was found.\n    //\n    // add another with no {audio,video}Capabilities for some legacy browsers.\n    // As of today's spec, this should return NotSupported but the first\n    // candidate configuration should be good, so we should have no downside\n    // doing that.\n    // initDataTypes: [\"cenc\"],\n    // videoCapabilities: undefined,\n    // audioCapabilities: undefined,\n    // distinctiveIdentifier,\n    // persistentState,\n    // sessionTypes,\n    return [{\n            initDataTypes: [\"cenc\"],\n            videoCapabilities: videoCapabilities,\n            audioCapabilities: audioCapabilities,\n            distinctiveIdentifier: distinctiveIdentifier,\n            persistentState: persistentState,\n            sessionTypes: sessionTypes,\n        }];\n}\n/**\n * Try to find a compatible key system from the keySystems array given.\n *\n * Returns an Observable which, when subscribed to, will request a\n * MediaKeySystemAccess based on the various keySystems provided. This\n * Observable will:\n *   - emit the MediaKeySystemAccess and the keySystems as an object, when\n *     found. The object is under this form:\n *     {\n *       keySystemAccess {MediaKeySystemAccess}\n *       keySystem {Object}\n *     }\n *   - complete immediately after emitting.\n *   - throw if no  compatible key system has been found.\n *\n * @param {Array.<Object>} keySystems - The keySystems you want to test.\n * @param {Object} currentMediaKeysInfos\n * @returns {Observable}\n */\nfunction getMediaKeySystemAccess(mediaElement, keySystemsConfigs, currentMediaKeysInfos) {\n    return Observable_1.Observable.defer(function () {\n        var currentState = currentMediaKeysInfos.getState(mediaElement);\n        if (currentState) {\n            // Fast way to find a compatible keySystem if the currently loaded\n            // one as exactly the same compatibility options.\n            var cachedKeySystemAccess = checkCachedMediaKeySystemAccess(keySystemsConfigs, currentState.mediaKeySystemAccess, currentState.keySystemOptions);\n            if (cachedKeySystemAccess) {\n                log_1.default.debug(\"eme: found cached compatible keySystem\", cachedKeySystemAccess);\n                return Observable_1.Observable.of({\n                    type: \"reuse-media-key-system-access\",\n                    value: {\n                        mediaKeySystemAccess: cachedKeySystemAccess.keySystemAccess,\n                        options: cachedKeySystemAccess.keySystemOptions,\n                    },\n                });\n            }\n        }\n        /**\n         * Array of set keySystems for this content.\n         * Each item of this array is an object containing the following keys:\n         *   - keyName {string}: keySystem canonical name (e.g. \"widevine\")\n         *   - keyType {string}: keySystem type (e.g. \"com.widevine.alpha\")\n         *   - keySystem {Object}: the original keySystem object\n         * @type {Array.<Object>}\n         */\n        var keySystemsType = keySystemsConfigs.reduce(function (arr, keySystemOptions) {\n            var ksType;\n            if (EME_KEY_SYSTEMS[keySystemOptions.type]) {\n                ksType = EME_KEY_SYSTEMS[keySystemOptions.type].map(function (keyType) {\n                    var keyName = keySystemOptions.type;\n                    return { keyName: keyName, keyType: keyType, keySystemOptions: keySystemOptions };\n                });\n            }\n            else {\n                var keyName = findKeySystemCanonicalName(keySystemOptions.type) || \"\";\n                var keyType = keySystemOptions.type;\n                ksType = [{ keyName: keyName, keyType: keyType, keySystemOptions: keySystemOptions }];\n            }\n            return arr.concat(ksType);\n        }, []);\n        return Observable_1.Observable.create(function (obs) {\n            var disposed = false;\n            var sub;\n            /**\n             * Test the key system as defined in keySystemsType[index].\n             * @param {Number} index\n             */\n            function testKeySystem(index) {\n                // completely quit the loop if unsubscribed\n                if (disposed) {\n                    return;\n                }\n                // if we iterated over the whole keySystemsType Array, quit on error\n                if (index >= keySystemsType.length) {\n                    obs.error(new errors_1.EncryptedMediaError(\"INCOMPATIBLE_KEYSYSTEMS\", null, true));\n                    return;\n                }\n                var _a = keySystemsType[index], keyName = _a.keyName, keyType = _a.keyType, keySystemOptions = _a.keySystemOptions;\n                var keySystemConfigurations = buildKeySystemConfigurations(keyName, keySystemOptions);\n                log_1.default.debug(\"eme: request keysystem access \" + keyType + \",\" +\n                    (index + 1 + \" of \" + keySystemsType.length), keySystemConfigurations);\n                if (compat_1.requestMediaKeySystemAccess == null) {\n                    throw new Error(\"requestMediaKeySystemAccess is not implemented in your browser.\");\n                }\n                sub = compat_1.requestMediaKeySystemAccess(keyType, keySystemConfigurations)\n                    .subscribe(function (keySystemAccess) {\n                    log_1.default.info(\"eme: found compatible keysystem\", keyType, keySystemConfigurations);\n                    obs.next({\n                        type: \"create-media-key-system-access\",\n                        value: {\n                            options: keySystemOptions,\n                            mediaKeySystemAccess: keySystemAccess,\n                        },\n                    });\n                    obs.complete();\n                }, function () {\n                    log_1.default.debug(\"eme: rejected access to keysystem\", keyType, keySystemConfigurations);\n                    sub = null;\n                    testKeySystem(index + 1);\n                });\n            }\n            testKeySystem(0);\n            return function () {\n                disposed = true;\n                if (sub) {\n                    sub.unsubscribe();\n                }\n            };\n        });\n    });\n}\nexports.default = getMediaKeySystemAccess;\n\n\n//# sourceURL=webpack://RxPlayer/./src/core/eme/find_key_system.ts?");

/***/ }),

/***/ "./src/core/eme/generate_key_request.ts":
/*!**********************************************!*\
  !*** ./src/core/eme/generate_key_request.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Observable_1 = __webpack_require__(/*! rxjs/Observable */ \"./node_modules/rxjs/Observable.js\");\nvar errors_1 = __webpack_require__(/*! ../../errors */ \"./src/errors/index.ts\");\nvar castToObservable_1 = __webpack_require__(/*! ../../utils/castToObservable */ \"./src/utils/castToObservable.ts\");\n/**\n * Generate a request from session.\n * @param {MediaKeySession} session\n * @param {Uint8Array} initData\n * @param {string} initDataType\n * @param {string} sessionType\n * @returns {Observable}\n */\nfunction generateKeyRequest(session, initData, initDataType) {\n    return Observable_1.Observable.defer(function () {\n        return castToObservable_1.default(session.generateRequest(initDataType, initData))\n            .catch(function (error) {\n            throw new errors_1.EncryptedMediaError(\"KEY_GENERATE_REQUEST_ERROR\", error, false);\n        })\n            .mapTo(null);\n    });\n}\nexports.default = generateKeyRequest;\n\n\n//# sourceURL=webpack://RxPlayer/./src/core/eme/generate_key_request.ts?");

/***/ }),

/***/ "./src/core/eme/get_media_keys.ts":
/*!****************************************!*\
  !*** ./src/core/eme/get_media_keys.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Observable_1 = __webpack_require__(/*! rxjs/Observable */ \"./node_modules/rxjs/Observable.js\");\nvar errors_1 = __webpack_require__(/*! ../../errors */ \"./src/errors/index.ts\");\nvar castToObservable_1 = __webpack_require__(/*! ../../utils/castToObservable */ \"./src/utils/castToObservable.ts\");\nvar log_1 = __webpack_require__(/*! ../../utils/log */ \"./src/utils/log.ts\");\nvar find_key_system_1 = __webpack_require__(/*! ./find_key_system */ \"./src/core/eme/find_key_system.ts\");\nvar set_server_certificate_1 = __webpack_require__(/*! ./set_server_certificate */ \"./src/core/eme/set_server_certificate.ts\");\nvar open_sessions_store_1 = __webpack_require__(/*! ./utils/open_sessions_store */ \"./src/core/eme/utils/open_sessions_store.ts\");\nvar persisted_session_store_1 = __webpack_require__(/*! ./utils/persisted_session_store */ \"./src/core/eme/utils/persisted_session_store.ts\");\n/**\n * @param {Object} keySystemOptions\n * @returns {Object|null}\n * @throws {EncryptedMediaError}\n */\nfunction createSessionStorage(keySystemOptions) {\n    if (!keySystemOptions.persistentLicense) {\n        return null;\n    }\n    var licenseStorage = keySystemOptions.licenseStorage;\n    if (!licenseStorage) {\n        var error = new Error(\"no license storage found for persistent license.\");\n        throw new errors_1.EncryptedMediaError(\"INVALID_KEY_SYSTEM\", error, true);\n    }\n    log_1.default.info(\"set the given license storage\");\n    return new persisted_session_store_1.default(licenseStorage);\n}\nfunction getMediaKeysInfos(mediaElement, keySystemsConfigs, currentMediaKeysInfos, errorStream) {\n    return find_key_system_1.default(mediaElement, keySystemsConfigs, currentMediaKeysInfos)\n        .mergeMap(function (evt) {\n        var _a = evt.value, options = _a.options, mediaKeySystemAccess = _a.mediaKeySystemAccess;\n        var currentState = currentMediaKeysInfos.getState(mediaElement);\n        var mediaKeys$;\n        if (currentState != null && evt.type === \"reuse-media-key-system-access\") {\n            var mediaKeys = currentState.mediaKeys, sessionsStore = currentState.sessionsStore;\n            mediaKeys$ = Observable_1.Observable.of({ mediaKeys: mediaKeys, sessionsStore: sessionsStore });\n        }\n        else {\n            mediaKeys$ = castToObservable_1.default(mediaKeySystemAccess.createMediaKeys())\n                .map(function (mediaKeys) { return ({\n                mediaKeys: mediaKeys,\n                sessionsStore: new open_sessions_store_1.default(mediaKeys),\n            }); });\n        }\n        return mediaKeys$\n            .mergeMap(function (_a) {\n            var mediaKeys = _a.mediaKeys, sessionsStore = _a.sessionsStore;\n            var serverCertificate = options.serverCertificate;\n            return (serverCertificate != null ?\n                set_server_certificate_1.default(mediaKeys, serverCertificate, errorStream) :\n                Observable_1.Observable.of(null)).mapTo({\n                mediaKeySystemAccess: mediaKeySystemAccess,\n                keySystemOptions: options,\n                mediaKeys: mediaKeys,\n                sessionsStore: sessionsStore,\n                sessionStorage: createSessionStorage(options),\n            });\n        });\n    });\n}\nexports.default = getMediaKeysInfos;\n\n\n//# sourceURL=webpack://RxPlayer/./src/core/eme/get_media_keys.ts?");

/***/ }),

/***/ "./src/core/eme/handle_encrypted_event.ts":
/*!************************************************!*\
  !*** ./src/core/eme/handle_encrypted_event.ts ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Observable_1 = __webpack_require__(/*! rxjs/Observable */ \"./node_modules/rxjs/Observable.js\");\nvar config_1 = __webpack_require__(/*! ../../config */ \"./src/config.ts\");\nvar errors_1 = __webpack_require__(/*! ../../errors */ \"./src/errors/index.ts\");\nvar log_1 = __webpack_require__(/*! ../../utils/log */ \"./src/utils/log.ts\");\nvar create_session_1 = __webpack_require__(/*! ./create_session */ \"./src/core/eme/create_session.ts\");\nvar is_session_usable_1 = __webpack_require__(/*! ./utils/is_session_usable */ \"./src/core/eme/utils/is_session_usable.ts\");\nvar MAX_SESSIONS = config_1.default.EME_MAX_SIMULTANEOUS_MEDIA_KEY_SESSIONS;\n/**\n * Handle MediaEncryptedEvents sent by a HTMLMediaElement:\n * Either create a session, skip the event if it is already handled or\n * recuperate a previous session and returns it.\n * @param {Event} encryptedEvent\n * @param {Object} handledInitData\n * @param {Object} mediaKeysInfos\n * @returns {Observable}\n */\nfunction handleEncryptedEvent(encryptedEvent, handledInitData, mediaKeysInfos) {\n    return Observable_1.Observable.defer(function () {\n        var initDataType = encryptedEvent.initDataType, initData = encryptedEvent.initData;\n        if (initData == null) {\n            var error = new Error(\"no init data found on media encrypted event.\");\n            throw new errors_1.EncryptedMediaError(\"INVALID_ENCRYPTED_EVENT\", error, true);\n        }\n        var initDataBytes = new Uint8Array(initData);\n        if (handledInitData.has(initDataBytes, initDataType)) {\n            log_1.default.debug(\"init data already received. Skipping it.\");\n            return Observable_1.Observable.empty(); // Already handled, quit\n        }\n        handledInitData.add(initDataBytes, initDataType);\n        // possible previous loaded session with the same initialization data\n        var previousLoadedSession = null;\n        var sessionsStore = mediaKeysInfos.sessionsStore;\n        var entry = sessionsStore.get(initDataBytes, initDataType);\n        if (entry != null) {\n            previousLoadedSession = entry.session;\n            if (is_session_usable_1.default(previousLoadedSession)) {\n                log_1.default.debug(\"eme: reuse loaded session\", previousLoadedSession.sessionId);\n                return Observable_1.Observable.of({\n                    type: \"loaded-open-session\",\n                    value: {\n                        mediaKeySession: previousLoadedSession,\n                        sessionType: entry.sessionType,\n                        initData: initDataBytes,\n                        initDataType: initDataType,\n                    },\n                });\n            }\n            else if (mediaKeysInfos.sessionStorage) {\n                mediaKeysInfos.sessionStorage.delete(new Uint8Array(initData), initDataType);\n            }\n        }\n        return (previousLoadedSession ?\n            sessionsStore.closeSession(previousLoadedSession) :\n            Observable_1.Observable.of(null)).mergeMap(function () {\n            var cleaningOldSessions$ = [];\n            var entries = sessionsStore.getAll().slice();\n            if (MAX_SESSIONS > 0 && MAX_SESSIONS <= entries.length) {\n                for (var i = 0; i < (MAX_SESSIONS - entries.length + 1); i++) {\n                    cleaningOldSessions$.push(sessionsStore.closeSession(entries[i].session));\n                }\n            }\n            return Observable_1.Observable.merge.apply(Observable_1.Observable, cleaningOldSessions$).ignoreElements()\n                .concat(create_session_1.default(initDataBytes, initDataType, mediaKeysInfos)\n                .map(function (evt) { return ({\n                type: evt.type,\n                value: {\n                    mediaKeySession: evt.value.mediaKeySession,\n                    sessionType: evt.value.sessionType,\n                    initData: initDataBytes,\n                    initDataType: initDataType,\n                },\n            }); }));\n        });\n    });\n}\nexports.default = handleEncryptedEvent;\n\n\n//# sourceURL=webpack://RxPlayer/./src/core/eme/handle_encrypted_event.ts?");

/***/ }),

/***/ "./src/core/eme/handle_session_events.ts":
/*!***********************************************!*\
  !*** ./src/core/eme/handle_session_events.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Observable_1 = __webpack_require__(/*! rxjs/Observable */ \"./node_modules/rxjs/Observable.js\");\nvar TimeoutError_1 = __webpack_require__(/*! rxjs/util/TimeoutError */ \"./node_modules/rxjs/util/TimeoutError.js\");\nvar events_1 = __webpack_require__(/*! ../../compat/events */ \"./src/compat/events.ts\");\nvar errors_1 = __webpack_require__(/*! ../../errors */ \"./src/errors/index.ts\");\nvar castToObservable_1 = __webpack_require__(/*! ../../utils/castToObservable */ \"./src/utils/castToObservable.ts\");\nvar log_1 = __webpack_require__(/*! ../../utils/log */ \"./src/utils/log.ts\");\nvar retry_1 = __webpack_require__(/*! ../../utils/retry */ \"./src/utils/retry.ts\");\nvar rx_tryCatch_1 = __webpack_require__(/*! ../../utils/rx-tryCatch */ \"./src/utils/rx-tryCatch.ts\");\nvar types_1 = __webpack_require__(/*! ./types */ \"./src/core/eme/types.ts\");\n/**\n * listen to \"message\" events from session containing a challenge\n * blob and map them to licenses using the getLicense method from\n * selected keySystem.\n * @param {MediaKeySession} session\n * @param {Object} keySystem\n * @param {Subject} errorStream\n * @returns {Observable}\n */\nfunction handleSessionEvents(session, keySystem, errorStream) {\n    log_1.default.debug(\"eme: handle message events\", session);\n    /**\n     * @param {Error|Object} error\n     * @param {Boolean} fatal\n     * @returns {Error|Object}\n     */\n    function licenseErrorSelector(error, fatal) {\n        if (errors_1.isKnownError(error)) {\n            if (error.type === errors_1.ErrorTypes.ENCRYPTED_MEDIA_ERROR) {\n                error.fatal = fatal;\n                return error;\n            }\n        }\n        return new errors_1.EncryptedMediaError(\"KEY_LOAD_ERROR\", error, fatal);\n    }\n    var getLicenseRetryOptions = {\n        totalRetry: 2,\n        retryDelay: 200,\n        errorSelector: function (error) { return licenseErrorSelector(error, true); },\n        onRetry: function (error) { return errorStream.next(licenseErrorSelector(error, false)); },\n    };\n    var keyErrors = events_1.onKeyError$(session)\n        .map(function (error) {\n        throw new errors_1.EncryptedMediaError(\"KEY_ERROR\", error, true);\n    });\n    var keyStatusesChanges = events_1.onKeyStatusesChange$(session).mergeMap(function (keyStatusesEvent) {\n        log_1.default.debug(\"eme: keystatuseschange event\", session, keyStatusesEvent);\n        // find out possible errors associated with this event\n        session.keyStatuses.forEach(function (keyStatus, keyId) {\n            // Hack present because the order of the arguments has changed in spec\n            // and is not the same between some versions of Edge and Chrome.\n            if (types_1.KEY_STATUS_ERRORS[keyId]) {\n                throw new errors_1.EncryptedMediaError(\"KEY_STATUS_CHANGE_ERROR\", keyId, true);\n            }\n            else if (types_1.KEY_STATUS_ERRORS[keyStatus]) {\n                throw new errors_1.EncryptedMediaError(\"KEY_STATUS_CHANGE_ERROR\", keyStatus, true);\n            }\n        });\n        var handledKeyStatusesChange$ = rx_tryCatch_1.default(function () {\n            return keySystem && keySystem.onKeyStatusesChange ?\n                castToObservable_1.default(keySystem.onKeyStatusesChange(keyStatusesEvent, session)) : Observable_1.Observable.empty();\n        });\n        return handledKeyStatusesChange$\n            .catch(function (error) {\n            throw new errors_1.EncryptedMediaError(\"KEY_STATUS_CHANGE_ERROR\", error, true);\n        })\n            .map(function (licenseObject) {\n            return {\n                type: \"key-status-change\",\n                value: {\n                    license: licenseObject,\n                },\n            };\n        });\n    });\n    var keyMessages$ = events_1.onKeyMessage$(session).mergeMap(function (messageEvent) {\n        var message = new Uint8Array(messageEvent.message);\n        var messageType = messageEvent.messageType || \"license-request\";\n        log_1.default.debug(\"eme: event message type \" + messageType, session, messageEvent);\n        var getLicense$ = Observable_1.Observable.defer(function () {\n            var getLicense = keySystem.getLicense(message, messageType);\n            return castToObservable_1.default(getLicense)\n                .timeout(10 * 1000)\n                .catch(function (error) {\n                throw error instanceof TimeoutError_1.TimeoutError ?\n                    new errors_1.EncryptedMediaError(\"KEY_LOAD_TIMEOUT\", null, false) :\n                    error;\n            });\n        });\n        return retry_1.retryObsWithBackoff(getLicense$, getLicenseRetryOptions)\n            .map(function (license) {\n            return {\n                type: messageType,\n                value: {\n                    license: license,\n                },\n            };\n        });\n    });\n    var sessionUpdates = Observable_1.Observable.merge(keyMessages$, keyStatusesChanges)\n        .concatMap(function (evt) {\n        log_1.default.debug(\"eme: update session\", evt);\n        var license = evt.value.license;\n        return castToObservable_1.default(session.update(license))\n            .catch(function (error) {\n            throw new errors_1.EncryptedMediaError(\"KEY_UPDATE_ERROR\", error, true);\n        })\n            .mapTo({\n            type: evt.type,\n            value: {\n                session: session,\n                license: license,\n            },\n        });\n    });\n    var sessionEvents = Observable_1.Observable.merge(sessionUpdates, keyErrors);\n    if (session.closed) {\n        return sessionEvents\n            .takeUntil(castToObservable_1.default(session.closed));\n    }\n    else {\n        return sessionEvents;\n    }\n}\nexports.default = handleSessionEvents;\n\n\n//# sourceURL=webpack://RxPlayer/./src/core/eme/handle_session_events.ts?");

/***/ }),

/***/ "./src/core/eme/index.ts":
/*!*******************************!*\
  !*** ./src/core/eme/index.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Observable_1 = __webpack_require__(/*! rxjs/Observable */ \"./node_modules/rxjs/Observable.js\");\nvar _1 = __webpack_require__(/*! ../../compat/ */ \"./src/compat/index.ts\");\nvar events_1 = __webpack_require__(/*! ../../compat/events */ \"./src/compat/events.ts\");\nvar errors_1 = __webpack_require__(/*! ../../errors */ \"./src/errors/index.ts\");\nvar assert_1 = __webpack_require__(/*! ../../utils/assert */ \"./src/utils/assert.ts\");\nvar log_1 = __webpack_require__(/*! ../../utils/log */ \"./src/utils/log.ts\");\nvar noop_1 = __webpack_require__(/*! ../../utils/noop */ \"./src/utils/noop.ts\");\nvar attach_media_keys_1 = __webpack_require__(/*! ./attach_media_keys */ \"./src/core/eme/attach_media_keys.ts\");\nvar dispose_media_keys_1 = __webpack_require__(/*! ./dispose_media_keys */ \"./src/core/eme/dispose_media_keys.ts\");\nvar generate_key_request_1 = __webpack_require__(/*! ./generate_key_request */ \"./src/core/eme/generate_key_request.ts\");\nvar get_media_keys_1 = __webpack_require__(/*! ./get_media_keys */ \"./src/core/eme/get_media_keys.ts\");\nvar handle_encrypted_event_1 = __webpack_require__(/*! ./handle_encrypted_event */ \"./src/core/eme/handle_encrypted_event.ts\");\nvar handle_session_events_1 = __webpack_require__(/*! ./handle_session_events */ \"./src/core/eme/handle_session_events.ts\");\nvar media_keys_infos_store_1 = __webpack_require__(/*! ./media_keys_infos_store */ \"./src/core/eme/media_keys_infos_store.ts\");\nvar init_data_store_1 = __webpack_require__(/*! ./utils/init_data_store */ \"./src/core/eme/utils/init_data_store.ts\");\nvar attachedMediaKeysInfos = new media_keys_infos_store_1.default();\n/**\n * Clear EME ressources that should be cleared when the current content stops\n * its playback.\n * @returns {Observable}\n */\nfunction clearEMESession(mediaElement) {\n    return Observable_1.Observable.defer(function () {\n        if (_1.shouldUnsetMediaKeys()) {\n            return dispose_media_keys_1.default(mediaElement, attachedMediaKeysInfos)\n                .ignoreElements();\n        }\n        var currentState = attachedMediaKeysInfos.getState(mediaElement);\n        if (currentState && currentState.keySystemOptions.closeSessionsOnStop) {\n            return currentState.sessionsStore.closeAllSessions()\n                .ignoreElements();\n        }\n        return Observable_1.Observable.empty();\n    });\n}\nexports.clearEMESession = clearEMESession;\n/**\n * EME abstraction and event handler used to communicate with the Content-\n * Description-Module (CDM).\n *\n * The EME handler can be given one or multiple systems and will choose the\n * appropriate one supported by the user's browser.\n * @param {HTMLMediaElement} mediaElement\n * @param {Array.<Object>} keySystems\n * @param {Subject} errorStream\n * @returns {Observable}\n */\nfunction createEME(mediaElement, keySystemsConfigs, errorStream) {\n    if (true) {\n        keySystemsConfigs.forEach(function (config) { return assert_1.assertInterface(config, {\n            getLicense: \"function\",\n            type: \"string\",\n        }, \"keySystem\"); });\n    }\n    // Keep track of all initialization data handled here.\n    // This is to avoid handling multiple times the same encrypted events.\n    var handledInitData = new init_data_store_1.default();\n    return Observable_1.Observable.combineLatest(events_1.onEncrypted$(mediaElement), get_media_keys_1.default(mediaElement, keySystemsConfigs, attachedMediaKeysInfos, errorStream))\n        .mergeMap(function (_a, i) {\n        var encryptedEvent = _a[0], mediaKeysInfos = _a[1];\n        return Observable_1.Observable.merge(\n        // create a new MediaKeySession if needed\n        handle_encrypted_event_1.default(encryptedEvent, handledInitData, mediaKeysInfos)\n            .map(function (evt) { return ({\n            type: evt.type,\n            value: {\n                initData: evt.value.initData,\n                initDataType: evt.value.initDataType,\n                mediaKeySession: evt.value.mediaKeySession,\n                sessionType: evt.value.sessionType,\n                keySystemOptions: mediaKeysInfos.keySystemOptions,\n                sessionStorage: mediaKeysInfos.sessionStorage,\n            },\n        }); }), \n        // attach MediaKeys if we're handling the first event\n        i === 0 ?\n            attach_media_keys_1.default(mediaKeysInfos, mediaElement, attachedMediaKeysInfos)\n                .ignoreElements() :\n            Observable_1.Observable.empty());\n    })\n        .mergeMap(function (handledEncryptedEvent) {\n        var _a = handledEncryptedEvent.value, initData = _a.initData, initDataType = _a.initDataType, mediaKeySession = _a.mediaKeySession, sessionType = _a.sessionType, keySystemOptions = _a.keySystemOptions, sessionStorage = _a.sessionStorage;\n        return Observable_1.Observable.merge(handle_session_events_1.default(mediaKeySession, keySystemOptions, errorStream), \n        // only perform generate request on new sessions\n        handledEncryptedEvent.type === \"created-session\" ?\n            generate_key_request_1.default(mediaKeySession, initData, initDataType)\n                .do(function () {\n                if (sessionType === \"persistent-license\" && sessionStorage != null) {\n                    sessionStorage.add(initData, initDataType, mediaKeySession);\n                }\n            }) :\n            Observable_1.Observable.empty()).ignoreElements();\n    });\n}\n/**\n * Free up all ressources taken by the EME management.\n */\nfunction disposeEME(mediaElement) {\n    dispose_media_keys_1.default(mediaElement, attachedMediaKeysInfos).subscribe(noop_1.default);\n}\nexports.disposeEME = disposeEME;\n/**\n * Returns the name of the current key system used.\n * @returns {string}\n */\nfunction getCurrentKeySystem(mediaElement) {\n    var currentState = attachedMediaKeysInfos.getState(mediaElement);\n    return currentState && currentState.keySystemOptions.type;\n}\nexports.getCurrentKeySystem = getCurrentKeySystem;\n/**\n * Perform EME management if needed.\n * @param {HTMLMediaElement} mediaElement\n * @param {Array.<Object>} keySystems\n * @param {Subject} errorStream\n * @returns {Observable}\n */\nfunction EMEManager(mediaElement, keySystems, errorStream) {\n    if (keySystems && keySystems.length) {\n        if (!_1.hasEMEAPIs()) {\n            return events_1.onEncrypted$(mediaElement).map(function () {\n                log_1.default.error(\"eme: encrypted event but no EME API available\");\n                throw new errors_1.EncryptedMediaError(\"MEDIA_IS_ENCRYPTED_ERROR\", null, true);\n            });\n        }\n        return createEME(mediaElement, keySystems, errorStream);\n    }\n    else {\n        return events_1.onEncrypted$(mediaElement).map(function () {\n            log_1.default.error(\"eme: ciphered media and no keySystem passed\");\n            throw new errors_1.EncryptedMediaError(\"MEDIA_IS_ENCRYPTED_ERROR\", null, true);\n        });\n    }\n}\nexports.default = EMEManager;\n\n\n//# sourceURL=webpack://RxPlayer/./src/core/eme/index.ts?");

/***/ }),

/***/ "./src/core/eme/media_keys_infos_store.ts":
/*!************************************************!*\
  !*** ./src/core/eme/media_keys_infos_store.ts ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Store the MediaKeys infos attached to a media element.\n * @class MediaKeysInfosStore\n */\nvar MediaKeysInfosStore = /** @class */ (function () {\n    function MediaKeysInfosStore() {\n        this._state = new WeakMap();\n    }\n    MediaKeysInfosStore.prototype.setState = function (mediaElement, state) {\n        this._state.set(mediaElement, state);\n    };\n    MediaKeysInfosStore.prototype.getState = function (mediaElement) {\n        return this._state.get(mediaElement) || null;\n    };\n    MediaKeysInfosStore.prototype.clearState = function (mediaElement) {\n        this._state.set(mediaElement, null);\n    };\n    return MediaKeysInfosStore;\n}());\nexports.default = MediaKeysInfosStore;\n\n\n//# sourceURL=webpack://RxPlayer/./src/core/eme/media_keys_infos_store.ts?");

/***/ }),

/***/ "./src/core/eme/set_server_certificate.ts":
/*!************************************************!*\
  !*** ./src/core/eme/set_server_certificate.ts ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Observable_1 = __webpack_require__(/*! rxjs/Observable */ \"./node_modules/rxjs/Observable.js\");\nvar errors_1 = __webpack_require__(/*! ../../errors */ \"./src/errors/index.ts\");\nvar castToObservable_1 = __webpack_require__(/*! ../../utils/castToObservable */ \"./src/utils/castToObservable.ts\");\n/**\n * Call the setServerCertificate API with the given certificate.\n * Complete when worked, throw when failed.\n *\n * TODO Manage success?\n * From the spec:\n *   - setServerCertificate resolves with true if everything worked\n *   - it resolves with false if the CDM does not support server\n *     certificates.\n *\n * @param {MediaKeys} mediaKeys\n * @param {ArrayBuffer} serverCertificate\n * @returns {Observable}\n */\nfunction setServerCertificate(mediaKeys, serverCertificate) {\n    return Observable_1.Observable.defer(function () {\n        return castToObservable_1.default(mediaKeys.setServerCertificate(serverCertificate)).catch(function (error) {\n            throw new errors_1.EncryptedMediaError(\"LICENSE_SERVER_CERTIFICATE_ERROR\", error, true);\n        });\n    }).mapTo(null);\n}\nexports.setServerCertificate = setServerCertificate;\n/**\n * Call the setCertificate API. If it fails just emit the error through the\n * errorStream and complete.\n * @param {MediaKeys} mediaKeys\n * @param {ArrayBuffer} serverCertificate\n * @returns {Observable}\n */\nfunction trySettingServerCertificate(mediaKeys, serverCertificate, errorStream) {\n    return typeof mediaKeys.setServerCertificate === \"function\" ?\n        setServerCertificate(mediaKeys, serverCertificate)\n            .catch(function (error) {\n            error.fatal = false;\n            errorStream.next(error);\n            return Observable_1.Observable.of(null);\n        }) : Observable_1.Observable.of(null);\n}\nexports.default = trySettingServerCertificate;\nexports.trySettingServerCertificate = trySettingServerCertificate;\n\n\n//# sourceURL=webpack://RxPlayer/./src/core/eme/set_server_certificate.ts?");

/***/ }),

/***/ "./src/core/eme/types.ts":
/*!*******************************!*\
  !*** ./src/core/eme/types.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// Keys are the different key statuses possible.\n// Values are ``true`` if such key status defines an error\n/* tslint:disable no-object-literal-type-assertion */\nexports.KEY_STATUS_ERRORS = {\n    expired: true,\n    \"internal-error\": true,\n};\n/* tslint:enable no-object-literal-type-assertion */\n\n\n//# sourceURL=webpack://RxPlayer/./src/core/eme/types.ts?");

/***/ }),

/***/ "./src/core/eme/utils/hash_buffer.ts":
/*!*******************************************!*\
  !*** ./src/core/eme/utils/hash_buffer.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Convert given buffer to a 32bit integer hash\n * @param {Array|TypedArray} buffer\n * @returns {Number}\n */\nfunction hashBuffer(buffer) {\n    var hash = 0;\n    var char;\n    for (var i = 0; i < buffer.length; i++) {\n        char = buffer[i];\n        hash = ((hash << 5) - hash) + char;\n        hash = hash & hash; // Convert to 32bit integer\n    }\n    return hash;\n}\nexports.default = hashBuffer;\n\n\n//# sourceURL=webpack://RxPlayer/./src/core/eme/utils/hash_buffer.ts?");

/***/ }),

/***/ "./src/core/eme/utils/init_data_store.ts":
/*!***********************************************!*\
  !*** ./src/core/eme/utils/init_data_store.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar array_includes_1 = __webpack_require__(/*! ../../../utils/array-includes */ \"./src/utils/array-includes.ts\");\nvar hash_buffer_1 = __webpack_require__(/*! ./hash_buffer */ \"./src/core/eme/utils/hash_buffer.ts\");\n/**\n * Memorize initialization data with straightforward methods.\n * @class InitDataStore\n */\nvar InitDataStore = /** @class */ (function () {\n    function InitDataStore() {\n        this._data = {};\n    }\n    /**\n     * Returns true if this instance has the given initData stored.\n     * @param {Uint8Array} initData\n     * @param {string} initDataType\n     * @returns {boolean}\n     */\n    InitDataStore.prototype.has = function (initData, initDataType) {\n        if (!this._data[initDataType]) {\n            return false;\n        }\n        return array_includes_1.default(this._data[initDataType], hash_buffer_1.default(initData));\n    };\n    /**\n     * Add initialization data to this memory.\n     * @param {Uint8Array} initData\n     * @param {string} initDataType\n     */\n    InitDataStore.prototype.add = function (initData, initDataType) {\n        if (this.has(initData, initDataType)) {\n            return;\n        }\n        if (!this._data[initDataType]) {\n            this._data[initDataType] = [];\n        }\n        this._data[initDataType].push(hash_buffer_1.default(initData));\n    };\n    /**\n     * Remove the initialization data from this memory.\n     * Returns true if this instance had the given initData stored.\n     * @param {Uint8Array} initData\n     * @param {string} initDataType\n     * @returns {boolean}\n     */\n    InitDataStore.prototype.remove = function (initData, initDataType) {\n        if (!this._data[initDataType]) {\n            return false;\n        }\n        var arr = this._data[initDataType];\n        var indexOf = arr.indexOf(hash_buffer_1.default(initData));\n        if (indexOf >= 0) {\n            arr.splice(indexOf, 1);\n            return true;\n        }\n        return false;\n    };\n    return InitDataStore;\n}());\nexports.default = InitDataStore;\n\n\n//# sourceURL=webpack://RxPlayer/./src/core/eme/utils/init_data_store.ts?");

/***/ }),

/***/ "./src/core/eme/utils/is_session_usable.ts":
/*!*************************************************!*\
  !*** ./src/core/eme/utils/is_session_usable.ts ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar array_includes_1 = __webpack_require__(/*! ../../../utils/array-includes */ \"./src/utils/array-includes.ts\");\nvar log_1 = __webpack_require__(/*! ../../../utils/log */ \"./src/utils/log.ts\");\n/**\n * If all key statuses attached to session are valid (either not\n * \"expired\" or \"internal-error\"), return true.\n * If not, return false.\n * @param {Uint8Array} initData\n * @param {MediaKeySession} loadedSession\n * @returns {MediaKeySession}\n */\nfunction isSessionUsable(loadedSession) {\n    if (loadedSession.sessionId === \"\") {\n        return false;\n    }\n    var keyStatusesMap = loadedSession.keyStatuses;\n    var keyStatuses = [];\n    keyStatusesMap.forEach(function (keyStatus) {\n        keyStatuses.push(keyStatus);\n    });\n    if (keyStatuses.length > 0 &&\n        (!array_includes_1.default(keyStatuses, \"expired\") &&\n            !array_includes_1.default(keyStatuses, \"internal-error\"))) {\n        log_1.default.debug(\"eme: reuse loaded session\", loadedSession.sessionId);\n        return true;\n    }\n    return false;\n}\nexports.default = isSessionUsable;\n\n\n//# sourceURL=webpack://RxPlayer/./src/core/eme/utils/is_session_usable.ts?");

/***/ }),

/***/ "./src/core/eme/utils/open_sessions_store.ts":
/*!***************************************************!*\
  !*** ./src/core/eme/utils/open_sessions_store.ts ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar arrayFind = __webpack_require__(/*! array-find */ \"./node_modules/array-find/find.js\");\nvar Observable_1 = __webpack_require__(/*! rxjs/Observable */ \"./node_modules/rxjs/Observable.js\");\nvar errors_1 = __webpack_require__(/*! ../../../errors */ \"./src/errors/index.ts\");\nvar castToObservable_1 = __webpack_require__(/*! ../../../utils/castToObservable */ \"./src/utils/castToObservable.ts\");\nvar log_1 = __webpack_require__(/*! ../../../utils/log */ \"./src/utils/log.ts\");\nvar hash_buffer_1 = __webpack_require__(/*! ./hash_buffer */ \"./src/core/eme/utils/hash_buffer.ts\");\n/**\n * Create and store MediaKeySessions linked to a single MediaKeys\n * instance.\n *\n * Keep track of sessionTypes and of the initialization data each\n * MediaKeySession is created for.\n * @class MediaKeySessionsStore\n */\nvar MediaKeySessionsStore = /** @class */ (function () {\n    function MediaKeySessionsStore(mediaKeys) {\n        this._mediaKeys = mediaKeys;\n        this._entries = [];\n    }\n    /**\n     * @returns {Array.<Object>}\n     */\n    MediaKeySessionsStore.prototype.getAll = function () {\n        return this._entries.map(function (entry) { return ({\n            session: entry.session,\n            sessionType: entry.sessionType,\n        }); });\n    };\n    /**\n     * Returns an entry in this cache with the initData and initDataType given.\n     * null if no such session is stored.\n     *\n     * @param {Uint8Array} initData\n     * @param {string} initDataType\n     * @returns {Object|null}\n     */\n    MediaKeySessionsStore.prototype.get = function (initData, initDataType) {\n        var initDataHash = hash_buffer_1.default(initData);\n        var foundEntry = arrayFind(this._entries, function (entry) { return (entry.initData === initDataHash &&\n            entry.initDataType === initDataType); });\n        if (foundEntry) {\n            var session = foundEntry.session, sessionType = foundEntry.sessionType;\n            return { session: session, sessionType: sessionType };\n        }\n        return null;\n    };\n    /**\n     * @param {Uint8Array} initData\n     * @param {string} initDataType\n     * @param {string} sessionType\n     * @returns {MediaKeySession}\n     * @throws {EncryptedMediaError}\n     */\n    MediaKeySessionsStore.prototype.createSession = function (initData, initDataType, sessionType) {\n        var _this = this;\n        if (this.get(initData, initDataType)) {\n            var error = new Error(\"This initialization data was already stored.\");\n            throw new errors_1.EncryptedMediaError(\"MULTIPLE_SESSIONS_SAME_INIT_DATA\", error, true);\n        }\n        var session = this._mediaKeys /* TS bug */.createSession(sessionType);\n        var entry = {\n            session: session,\n            sessionType: sessionType,\n            initData: hash_buffer_1.default(initData),\n            initDataType: initDataType,\n        };\n        if (session.closed !== null) {\n            session.closed\n                .then(function () {\n                _this._delete(session);\n            })\n                .catch(function (e) {\n                log_1.default.warn(\"session.closed rejected: \" + e);\n            });\n        }\n        log_1.default.debug(\"eme-mem-store: add session\", entry);\n        this._entries.push(entry);\n        return session;\n    };\n    /**\n     * Close a MediaKeySession stored here and remove its entry in the store.\n     * @param {MediaKeySession} session_\n     * @returns {Observable}\n     */\n    MediaKeySessionsStore.prototype.closeSession = function (session_) {\n        var _this = this;\n        return Observable_1.Observable.defer(function () {\n            var session = _this._delete(session_);\n            if (session == null) {\n                return Observable_1.Observable.of(null);\n            }\n            log_1.default.debug(\"eme-mem-store: close session\", session);\n            return castToObservable_1.default(session.close())\n                .mapTo(null)\n                .catch(function () {\n                return Observable_1.Observable.of(null);\n            });\n        });\n    };\n    /**\n     * Close all sessions in this store.\n     * Emit null when done\n     * @returns {Observable}\n     */\n    MediaKeySessionsStore.prototype.closeAllSessions = function () {\n        var _this = this;\n        return Observable_1.Observable.defer(function () {\n            var disposed = _this._entries.map(function (e) { return _this.closeSession(e.session); });\n            _this._entries = [];\n            return Observable_1.Observable.merge.apply(Observable_1.Observable, disposed).ignoreElements()\n                .concat(Observable_1.Observable.of(null));\n        });\n    };\n    /**\n     * Remove a MediaKeySession from the Cache, without closing it.\n     * Returns the entry if found, null otherwise.\n     * @param {MediaKeySession} session_\n     * @returns {MediaKeySession|null}\n     */\n    MediaKeySessionsStore.prototype._delete = function (session_) {\n        var entry = arrayFind(this._entries, function (e) { return e.session === session_; });\n        if (!entry) {\n            return null;\n        }\n        var session = entry.session;\n        log_1.default.debug(\"eme-mem-store: delete session\", entry);\n        var idx = this._entries.indexOf(entry);\n        this._entries.splice(idx, 1);\n        return session;\n    };\n    return MediaKeySessionsStore;\n}());\nexports.default = MediaKeySessionsStore;\n\n\n//# sourceURL=webpack://RxPlayer/./src/core/eme/utils/open_sessions_store.ts?");

/***/ }),

/***/ "./src/core/eme/utils/persisted_session_store.ts":
/*!*******************************************************!*\
  !*** ./src/core/eme/utils/persisted_session_store.ts ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar arrayFind = __webpack_require__(/*! array-find */ \"./node_modules/array-find/find.js\");\nvar assert_1 = __webpack_require__(/*! ../../../utils/assert */ \"./src/utils/assert.ts\");\nvar log_1 = __webpack_require__(/*! ../../../utils/log */ \"./src/utils/log.ts\");\nvar hash_buffer_1 = __webpack_require__(/*! ./hash_buffer */ \"./src/core/eme/utils/hash_buffer.ts\");\nfunction checkStorage(storage) {\n    assert_1.default(storage != null, \"no licenseStorage given for keySystem with persistentLicense\");\n    assert_1.assertInterface(storage, { save: \"function\", load: \"function\" }, \"licenseStorage\");\n}\n/**\n * Set representing persisted licenses. Depends on a simple local-\n * storage implementation with a `save`/`load` synchronous interface\n * to persist informations on persisted sessions.\n *\n * This set is used only for a cdm/keysystem with license persistency\n * supported.\n * @class PersistedSessionsStore\n */\nvar PersistedSessionsStore = /** @class */ (function () {\n    /**\n     * @param {Object} storage\n     */\n    function PersistedSessionsStore(storage) {\n        checkStorage(storage);\n        this._entries = [];\n        this._storage = storage;\n        try {\n            this._entries = this._storage.load();\n            assert_1.default(Array.isArray(this._entries));\n        }\n        catch (e) {\n            log_1.default.warn(\"eme-persitent-store: could not get entries from license storage\", e);\n            this.dispose();\n        }\n    }\n    /**\n     * Retrieve entry (sessionId + initData) based on its initData.\n     * @param {Uint8Array}  initData\n     * @param {string} initDataType\n     * @returns {Object|null}\n     */\n    PersistedSessionsStore.prototype.get = function (initData, initDataType) {\n        var hash = hash_buffer_1.default(initData);\n        var entry = arrayFind(this._entries, function (e) {\n            return e.initData === hash &&\n                e.initDataType === initDataType;\n        });\n        return entry || null;\n    };\n    /**\n     * Add a new entry in the storage.\n     * @param {Uint8Array}  initData\n     * @param {string} initDataType\n     * @param {MediaKeySession} session\n     */\n    PersistedSessionsStore.prototype.add = function (initData, initDataType, session) {\n        var sessionId = session && session.sessionId;\n        if (!sessionId) {\n            return;\n        }\n        var currentEntry = this.get(initData, initDataType);\n        if (currentEntry && currentEntry.sessionId === sessionId) {\n            return;\n        }\n        else if (currentEntry) { // currentEntry has a different sessionId\n            this.delete(initData, initDataType);\n        }\n        log_1.default.info(\"eme-persitent-store: add new session\", sessionId, session);\n        this._entries.push({\n            sessionId: sessionId,\n            initData: hash_buffer_1.default(initData),\n            initDataType: initDataType,\n        });\n        this._save();\n    };\n    /**\n     * Delete entry (sessionId + initData) based on its initData.\n     * @param {Uint8Array}  initData\n     * @param {string} initDataType\n     */\n    PersistedSessionsStore.prototype.delete = function (initData, initDataType) {\n        var hash = hash_buffer_1.default(initData);\n        var entry = arrayFind(this._entries, function (e) {\n            return e.initData === hash &&\n                e.initDataType === initDataType;\n        });\n        if (entry) {\n            log_1.default.warn(\"eme-persitent-store: delete session from store\", entry);\n            var idx = this._entries.indexOf(entry);\n            this._entries.splice(idx, 1);\n            this._save();\n        }\n    };\n    /**\n     * Delete all saved entries.\n     */\n    PersistedSessionsStore.prototype.dispose = function () {\n        this._entries = [];\n        this._save();\n    };\n    /**\n     * Use the given storage to store the current entries.\n     */\n    PersistedSessionsStore.prototype._save = function () {\n        try {\n            this._storage.save(this._entries);\n        }\n        catch (e) {\n            log_1.default.warn(\"eme-persitent-store: could not save licenses in localStorage\");\n        }\n    };\n    return PersistedSessionsStore;\n}());\nexports.default = PersistedSessionsStore;\n\n\n//# sourceURL=webpack://RxPlayer/./src/core/eme/utils/persisted_session_store.ts?");

/***/ }),

/***/ "./src/core/pipelines/backoff.ts":
/*!***************************************!*\
  !*** ./src/core/pipelines/backoff.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Observable_1 = __webpack_require__(/*! rxjs/Observable */ \"./node_modules/rxjs/Observable.js\");\nvar compat_1 = __webpack_require__(/*! ../../compat */ \"./src/compat/index.ts\");\nvar errors_1 = __webpack_require__(/*! ../../errors */ \"./src/errors/index.ts\");\nvar backoff_1 = __webpack_require__(/*! ../../utils/backoff */ \"./src/utils/backoff.ts\");\n/**\n * Called on a pipeline's loader error.\n * Returns whether the loader request should be retried.\n * @param {Error} error\n * @returns {Boolean}\n */\nfunction shouldRetry(error) {\n    if (!(error instanceof errors_1.RequestError)) {\n        return false;\n    }\n    if (error.type === errors_1.RequestErrorTypes.ERROR_HTTP_CODE) {\n        return error.status >= 500 || error.status === 404;\n    }\n    return (error.type === errors_1.RequestErrorTypes.TIMEOUT ||\n        error.type === errors_1.RequestErrorTypes.ERROR_EVENT);\n}\nfunction isOfflineRequestError(error) {\n    return error.type === errors_1.RequestErrorTypes.ERROR_EVENT && compat_1.isOffline();\n}\n/**\n * Specific exponential backoff algorithm used for segments/manifest\n * downloading.\n *\n * The specificty here in comparaison to a \"regular\" backoff algorithm is\n * the separation between type of errors:\n *   - \"offline\" errors\n *   - other xhr errors\n * Both have their own counters which are resetted if the error type changes.\n * @param {Observable}\n * @param {Object} options\n * @param {Number} options.baseDelay - First delay set when and if:\n *   - the first observable throws\n *   - any observable throws an error which has a type different than the last\n *     one.\n * @param {Number} options.maxDelay - Maximum delay considered for the backoff.\n * Note that this delay is not exact as it will be \"fuzzed\".\n * @param {Number} options.maxRetryRegular - Maximum number of retry for\n * \"regular\" errors. That is, errors that are most likely due to the CDN.\n * @param {Number} options.maxRetryOffline - Maximum number of retry for\n * \"offline\" errors. That is, errors that are most likely due to the user being\n * offline.\n * @param {Function} [options.onRetry] - callback to call as an observable\n * throws. Will be called with two arguments:\n *   - The error thrown by the observable.\n *   - The counter for the current error type.\n * @returns {Observable}\n */\nfunction downloadingBackoff(obs$, options) {\n    var baseDelay = options.baseDelay, maxDelay = options.maxDelay, maxRetryRegular = options.maxRetryRegular, maxRetryOffline = options.maxRetryOffline, onRetry = options.onRetry;\n    var retryCount = 0;\n    var ERROR_TYPES = {\n        NONE: 0,\n        REGULAR: 1,\n        OFFLINE: 2,\n    };\n    var lastError = ERROR_TYPES.NONE;\n    return obs$.catch(function (error, source) {\n        if (!shouldRetry(error)) {\n            throw error;\n        }\n        var currentError = error instanceof errors_1.RequestError &&\n            isOfflineRequestError(error) ? ERROR_TYPES.OFFLINE : ERROR_TYPES.REGULAR;\n        var maxRetry = currentError === ERROR_TYPES.OFFLINE ?\n            maxRetryOffline : maxRetryRegular;\n        if (currentError !== lastError) {\n            retryCount = 0;\n            lastError = currentError;\n        }\n        if (++retryCount > maxRetry) {\n            throw error;\n        }\n        if (onRetry) {\n            onRetry(error, retryCount);\n        }\n        var delay = Math.min(baseDelay * Math.pow(2, retryCount - 1), maxDelay);\n        var fuzzedDelay = backoff_1.getFuzzedDelay(delay);\n        return Observable_1.Observable.timer(fuzzedDelay)\n            .mergeMap(function () { return source; });\n    });\n}\nexports.default = downloadingBackoff;\n\n\n//# sourceURL=webpack://RxPlayer/./src/core/pipelines/backoff.ts?");

/***/ }),

/***/ "./src/core/pipelines/core_pipeline.ts":
/*!*********************************************!*\
  !*** ./src/core/pipelines/core_pipeline.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar objectAssign = __webpack_require__(/*! object-assign */ \"./node_modules/object-assign/index.js\");\nvar Observable_1 = __webpack_require__(/*! rxjs/Observable */ \"./node_modules/rxjs/Observable.js\");\nvar Subject_1 = __webpack_require__(/*! rxjs/Subject */ \"./node_modules/rxjs/Subject.js\");\nvar config_1 = __webpack_require__(/*! ../../config */ \"./src/config.ts\");\nvar errors_1 = __webpack_require__(/*! ../../errors */ \"./src/errors/index.ts\");\nvar castToObservable_1 = __webpack_require__(/*! ../../utils/castToObservable */ \"./src/utils/castToObservable.ts\");\nvar rx_tryCatch_1 = __webpack_require__(/*! ../../utils/rx-tryCatch */ \"./src/utils/rx-tryCatch.ts\");\nvar backoff_1 = __webpack_require__(/*! ./backoff */ \"./src/core/pipelines/backoff.ts\");\nvar MAX_BACKOFF_DELAY_BASE = config_1.default.MAX_BACKOFF_DELAY_BASE, INITIAL_BACKOFF_DELAY_BASE = config_1.default.INITIAL_BACKOFF_DELAY_BASE;\n/**\n * Generate a new error from the infos given.\n * Also attach the pipeline type (audio/manifest...) to the _pipelineType_\n * property of the returned error.\n * @param {string} code\n * @param {Error} error\n * @param {Boolean} [fatal=true] - Whether the error is fatal to the content's\n * playback.\n * @returns {Error}\n */\nfunction errorSelector(code, error, fatal) {\n    if (fatal === void 0) { fatal = true; }\n    if (!errors_1.isKnownError(error)) {\n        if (error instanceof errors_1.RequestError) {\n            return new errors_1.NetworkError(code, error, fatal);\n        }\n        return new errors_1.OtherError(code, error, fatal);\n    }\n    return error;\n}\n/**\n * TODO All that any casting is ugly\n *\n * Returns function allowing to download the wanted transport object through\n * the resolver -> loader -> parser pipeline.\n *\n * (A transport object can be for example: the manifest, audio and video\n * segments, text, images...)\n *\n * The function returned takes the initial data in arguments and returns an\n * Observable which will emit:\n *\n *   - each time a request begins (type \"request\").\n *     This is not emitted if the value is retrieved from a local js cache.\n *     This one emit the payload as a value.\n *\n *   - as the request progresses (type \"progress\").\n *\n *   - each time a request ends (type \"metrics\").\n *     This one contains informations about the metrics of the request.\n *\n *   - each time a minor request error is encountered (type \"error\").\n *     With the error as a value.\n *\n *   - Lastly, with the obtained data (type \"data\" or \"cache).\n *\n *\n * Each of these but \"error\" can be emitted at most one time.\n *\n * This observable will throw if, following the options given, the request and\n * possible retry all failed.\n *\n * This observable will complete after emitting the data.\n *\n * @param {Object} transportObject\n * @param {Object} options\n * @returns {Function}\n *\n * Type parameters:\n *   T: Argument given to the Net's loader\n *   U: ResponseType of the request\n *   V: Response given by the Net's parser\n */\nfunction createPipeline(transportPipeline, options) {\n    var cache = options.cache, maxRetry = options.maxRetry, maxRetryOffline = options.maxRetryOffline;\n    var loader = transportPipeline.loader, parser = transportPipeline.parser;\n    // TODO Remove the resolver completely\n    var resolver = transportPipeline.resolver != null ?\n        transportPipeline.resolver : Observable_1.Observable.of.bind(Observable_1.Observable);\n    /**\n     * Subject that will emit non-fatal errors.\n     */\n    var retryErrorSubject = new Subject_1.Subject();\n    /**\n     * Backoff options given to the backoff retry done with the loader function.\n     * @see retryWithBackoff\n     */\n    var backoffOptions = {\n        baseDelay: INITIAL_BACKOFF_DELAY_BASE,\n        maxDelay: MAX_BACKOFF_DELAY_BASE,\n        maxRetryRegular: maxRetry,\n        maxRetryOffline: maxRetryOffline,\n        onRetry: function (error) {\n            retryErrorSubject\n                .next(errorSelector(\"PIPELINE_LOAD_ERROR\", error, false));\n        },\n    };\n    /**\n     * Call the transport's resolver - if it exists - with the given data.\n     *\n     * Throws with the right error if it fails.\n     * @param {Object} resolverArgument\n     * @returns {Observable}\n     */\n    function callResolver(resolverArgument) {\n        return rx_tryCatch_1.default(resolver, resolverArgument)\n            .catch(function (error) {\n            throw errorSelector(\"PIPELINE_RESOLVE_ERROR\", error);\n        });\n    }\n    /**\n     * Load wanted data:\n     *   - get it from cache if present\n     *   - call the transport loader - with an exponential backoff - if not\n     *\n     * @param {Object} loaderArgument - Input given to the loader\n     */\n    function loadData(loaderArgument) {\n        /**\n         * Call the Pipeline's loader with an exponential Backoff.\n         * @returns {Observable}\n         */\n        function startLoaderWithBackoff() {\n            var request$ = backoff_1.default(rx_tryCatch_1.default(loader, loaderArgument), backoffOptions)\n                .catch(function (error) {\n                throw errorSelector(\"PIPELINE_LOAD_ERROR\", error);\n            })\n                .do(function (arg) {\n                if (arg.type === \"response\" && cache) {\n                    cache.add(loaderArgument, arg.value);\n                }\n            });\n            return Observable_1.Observable.of({\n                type: \"request\",\n                value: loaderArgument,\n            }).concat(request$);\n        }\n        var dataFromCache = cache ? cache.get(loaderArgument) : null;\n        if (dataFromCache != null) {\n            return castToObservable_1.default(dataFromCache)\n                .map(function (response) {\n                return {\n                    type: \"cache\",\n                    value: response,\n                };\n            })\n                .catch(startLoaderWithBackoff);\n        }\n        return startLoaderWithBackoff();\n    }\n    /**\n     * Call the transport's parser with the given data.\n     *\n     * Throws with the right error if it fails.\n     * @param {Object} parserArgument\n     * @returns {Observable}\n     */\n    function callParser(parserArgument) {\n        return rx_tryCatch_1.default(parser, parserArgument)\n            .catch(function (error) {\n            throw errorSelector(\"PIPELINE_PARSING_ERROR\", error);\n        });\n    }\n    return function startPipeline(pipelineInputData) {\n        var pipeline$ = callResolver(pipelineInputData)\n            .mergeMap(function (resolverResponse) {\n            return loadData(resolverResponse)\n                .mergeMap(function (arg) {\n                // \"cache\": data taken from cache by the pipeline\n                // \"data\": the data is available but no request has been done\n                // \"response\": data received through a request\n                switch (arg.type) {\n                    case \"cache\":\n                    case \"data\":\n                    case \"response\":\n                        var loaderResponse = arg.value;\n                        var loadedDataInfos_1 = objectAssign({ response: loaderResponse }, resolverResponse);\n                        // add metrics if a request was made\n                        var metrics = arg.type === \"response\" ?\n                            Observable_1.Observable.of({\n                                type: \"metrics\",\n                                value: {\n                                    size: arg.value.size,\n                                    duration: arg.value.duration,\n                                },\n                            }) : Observable_1.Observable.empty();\n                        return metrics\n                            .concat(callParser(loadedDataInfos_1)\n                            .map(function (parserResponse) {\n                            return {\n                                type: \"data\",\n                                value: objectAssign({\n                                    parsed: parserResponse,\n                                }, loadedDataInfos_1),\n                            };\n                        }));\n                    default:\n                        return Observable_1.Observable.of(arg);\n                }\n            });\n        })\n            .finally(function () { retryErrorSubject.complete(); });\n        var retryError$ = retryErrorSubject\n            .map(function (error) { return ({\n            type: \"error\",\n            value: error,\n        }); });\n        return Observable_1.Observable.merge(pipeline$, retryError$);\n    };\n}\nexports.default = createPipeline;\n\n\n//# sourceURL=webpack://RxPlayer/./src/core/pipelines/core_pipeline.ts?");

/***/ }),

/***/ "./src/core/pipelines/index.ts":
/*!*************************************!*\
  !*** ./src/core/pipelines/index.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar manifest_1 = __webpack_require__(/*! ./manifest */ \"./src/core/pipelines/manifest/index.ts\");\nexports.createManifestPipeline = manifest_1.default;\nvar segment_1 = __webpack_require__(/*! ./segment */ \"./src/core/pipelines/segment/index.ts\");\nexports.SegmentPipelinesManager = segment_1.default;\n\n\n//# sourceURL=webpack://RxPlayer/./src/core/pipelines/index.ts?");

/***/ }),

/***/ "./src/core/pipelines/manifest/index.ts":
/*!**********************************************!*\
  !*** ./src/core/pipelines/manifest/index.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar factory_1 = __webpack_require__(/*! ../../../manifest/factory */ \"./src/manifest/factory.ts\");\nvar core_pipeline_1 = __webpack_require__(/*! ../core_pipeline */ \"./src/core/pipelines/core_pipeline.ts\");\n/**\n * Create function allowing to easily fetch and parse the manifest from its URL.\n *\n * @example\n * ```js\n * const manifestPipeline = createManifestPipeline(transport, warning$);\n * manifestPipeline(manifestURL)\n *  .subscribe(manifest => console.log(\"Manifest:\", manifest));\n * ```\n *\n * @param {Object} transport\n * @param {Subject} warning$\n * @param {Array.<Object>} [supplementaryTextTracks=[]]\n * @param {Array.<Object>} [supplementaryImageTrack=[]]\n * @returns {Function}\n */\nfunction createManifestPipeline(transport, pipelineOptions, warning$, supplementaryTextTracks, supplementaryImageTracks) {\n    if (supplementaryTextTracks === void 0) { supplementaryTextTracks = []; }\n    if (supplementaryImageTracks === void 0) { supplementaryImageTracks = []; }\n    return function fetchManifest(url) {\n        var manifest$ = core_pipeline_1.default(transport.manifest, pipelineOptions)({ url: url });\n        return manifest$\n            .do(function (arg) {\n            if (arg.type === \"error\") {\n                warning$.next(arg.value);\n            }\n        })\n            .filter(function (arg) {\n            return arg.type === \"data\" || arg.type === \"cache\";\n        })\n            .map(function (_a) {\n            var value = _a.value;\n            return factory_1.default(value.parsed.manifest, supplementaryTextTracks, supplementaryImageTracks, warning$);\n        })\n            .share();\n    };\n}\nexports.default = createManifestPipeline;\n\n\n//# sourceURL=webpack://RxPlayer/./src/core/pipelines/manifest/index.ts?");

/***/ }),

/***/ "./src/core/pipelines/segment/index.ts":
/*!*********************************************!*\
  !*** ./src/core/pipelines/segment/index.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar prioritized_segment_fetcher_1 = __webpack_require__(/*! ./prioritized_segment_fetcher */ \"./src/core/pipelines/segment/prioritized_segment_fetcher.ts\");\nvar prioritizer_1 = __webpack_require__(/*! ./prioritizer */ \"./src/core/pipelines/segment/prioritizer.ts\");\nvar segment_fetcher_1 = __webpack_require__(/*! ./segment_fetcher */ \"./src/core/pipelines/segment/segment_fetcher.ts\");\n/**\n * Interact with the networking pipelines to download segments and dispatch\n * the related events to the right subjects.\n *\n * @class SegmentPipelinesManager\n *\n * @example\n * ```js\n * const requests$ = new Subject();\n * const metrics$ = new Subject();\n * const warnings$ = new Subject();\n *\n * // 1 - create the manager\n * const segmentPipelinesManager =\n *   new SegmentPipelinesManager(transport, requests$, metrics$, warnings$);\n *\n * // Note:\n * // You can create an ABRManager with the same requests$ and metrics$ subjects.\n * // It will then be informed of when the SegmentPipelinesManager downloads\n * // segments and with which metrics.\n * // The format of those events is kept the same for ease of use.\n * const abrManager = new ABRManager(requests$, metrics$);\n *\n * // 2 - create a new pipeline with its own options\n * const pipeline = segmentPipelinesManager.createPipeline(\"audio\", {\n *   maxRetry: Infinity,\n *   maxRetryOffline: Infinity,\n * });\n *\n * // 3 - request a content with a given priority\n * pipeline.createRequest(myContent, 1)\n *   .subscribe((res) => console.log(\"audio segment downloaded:\", res));\n * ```\n */\nvar SegmentPipelinesManager = /** @class */ (function () {\n    /**\n     * @param {Object} transport\n     * @param {Subject} requestsInfos$\n     * @param {Subject} metrics$\n     * @param {Subject} warning\n     */\n    function SegmentPipelinesManager(transport, requestsInfos$, metrics$, warning) {\n        this._transport = transport;\n        this._metrics$ = metrics$;\n        this._requestsInfos$ = requestsInfos$;\n        this._warning$ = warning;\n        this._prioritizer = new prioritizer_1.default();\n    }\n    /**\n     * @param {string} bufferType\n     * @param {Object} options\n     * @returns {Function}\n     */\n    SegmentPipelinesManager.prototype.createPipeline = function (bufferType, options) {\n        var segmentFetcher = segment_fetcher_1.default(bufferType, this._transport, this._metrics$, this._requestsInfos$, this._warning$, options);\n        return prioritized_segment_fetcher_1.default(this._prioritizer, segmentFetcher);\n    };\n    return SegmentPipelinesManager;\n}());\nexports.default = SegmentPipelinesManager;\n\n\n//# sourceURL=webpack://RxPlayer/./src/core/pipelines/segment/index.ts?");

/***/ }),

/***/ "./src/core/pipelines/segment/prioritized_segment_fetcher.ts":
/*!*******************************************************************!*\
  !*** ./src/core/pipelines/segment/prioritized_segment_fetcher.ts ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * This function basically put in relation:\n *   - a SegmentFetcher, which will be used to perform the segment request\n *   - a prioritizer, which will handle the priority of a segment request\n *\n * and returns functions to fetch segments with a given priority.\n * @returns {Object}\n */\nfunction applyPrioritizerToSegmentFetcher(prioritizer, fetcher) {\n    return {\n        /**\n         * Create a Segment request with a given priority.\n         * @param {Object} content - content to request\n         * @param {Number} priority - priority at which the content should be\n         * requested.\n         * @returns {Observable}\n         */\n        createRequest: function (content, priority) {\n            if (priority === void 0) { priority = 0; }\n            return prioritizer.create(fetcher(content), priority);\n        },\n        /**\n         * Update the priority of a pending request, created through createRequest.\n         * @param {Observable} observable - the corresponding request\n         * @param {Number} priority\n         */\n        updatePriority: function (observable, priority) {\n            prioritizer.updatePriority(observable, priority);\n        },\n    };\n}\nexports.default = applyPrioritizerToSegmentFetcher;\n\n\n//# sourceURL=webpack://RxPlayer/./src/core/pipelines/segment/prioritized_segment_fetcher.ts?");

/***/ }),

/***/ "./src/core/pipelines/segment/prioritizer.ts":
/*!***************************************************!*\
  !*** ./src/core/pipelines/segment/prioritizer.ts ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar arrayFind = __webpack_require__(/*! array-find */ \"./node_modules/array-find/find.js\");\nvar Observable_1 = __webpack_require__(/*! rxjs/Observable */ \"./node_modules/rxjs/Observable.js\");\nvar Subject_1 = __webpack_require__(/*! rxjs/Subject */ \"./node_modules/rxjs/Subject.js\");\n/**\n * Create Observables which can be priorized between one another.\n *\n * With this class, you can create Observables with linked priority numbers.\n * The lower this number is, the more priority the resulting Observable will\n * have.\n *\n * Such Observable will then basically wait for pending Observables with more\n * priority to finish before \"starting\".\n *\n * You can also update the priority of an already-created Observable.\n * This will only have an effect if the Observable is currently \"waiting\" for\n * its turn (started observable won't be canceled if their priority were\n * lowered).\n *\n * ```js\n * const prioritizer = new ObservablePrioritizer();\n *\n * const observable1 = Observable.of(1);\n * const observable2 = Observable.of(2);\n * const observable3 = Observable.of(3);\n * const observable4 = Observable.of(4);\n * const observable5 = Observable.of(5);\n *\n * const pObservable1 = prioritizer.create(observable1, 4);\n * const pObservable2 = prioritizer.create(observable2, 2);\n * const pObservable3 = prioritizer.create(observable3, 1);\n * const pObservable4 = prioritizer.create(observable4, 3);\n * const pObservable5 = prioritizer.create(observable5, 2);\n *\n * // start every Observables at the same time\n * Observable.merge(\n *   pObservable1,\n *   pObservable2,\n *   pObservable3,\n *   pObservable4,\n *   pObservable5\n * ).subscribe((i) => {\n *   // To spice things up, update pObservable1 priority to go before\n *   // pObservable4\n *   if (i === 5) { // if pObservable5 is currently emitting\n *     prioritizer.updatePriority(pObservable1, 1);\n *   }\n *   console.log(i);\n * });\n *\n * // Result:\n * // 3\n * // 2\n * // 5\n * // 1\n * // 4\n *\n * // Note: here \"1\" goes before \"4\" only because the former's priority has been\n * // updated before the latter was started.\n * // It would be the other way around if not.\n * ```\n *\n * @class ObservablePrioritizer\n */\nvar ObservablePrioritizer = /** @class */ (function () {\n    function ObservablePrioritizer() {\n        this._pendingPriority = null;\n        this._numberOfPendingObservables = 0;\n        this._queue = [];\n    }\n    /**\n     * Create a priorized Observable from a base Observable.\n     *\n     * When subscribed to, this Observable will have its priority compared to\n     * all the already-running Observables created from this class.\n     * Only if this number is inferior or equal to the priority of the\n     * currently-running Observables will it be immediately started.\n     * In the opposite case, we will wait for higher-priority Observables to\n     * finish before starting it.\n     *\n     * Note that while this Observable is waiting for its turn, it is possible\n     * to update its property through the updatePriority method, by providing\n     * the Observable returned by this function and its new priority number.\n     *\n     * @param {Observable} obs\n     * @param {number} priority\n     * @returns {Observable}\n     */\n    ObservablePrioritizer.prototype.create = function (obs, priority) {\n        var _this = this;\n        return Observable_1.Observable.defer(function () {\n            if (_this._pendingPriority == null || _this._pendingPriority >= priority) {\n                // Update the priority and start immediately the Observable\n                _this._pendingPriority = priority;\n                return _this._startObservable(obs);\n            }\n            else {\n                var trigger = new Subject_1.Subject();\n                _this._queue.push({\n                    observable: obs,\n                    priority: priority,\n                    trigger: trigger,\n                });\n                return trigger\n                    .mergeMap(function () { return _this._startObservable(obs); });\n            }\n        });\n    };\n    /**\n     * Update the priority of an Observable created through the create method.\n     *\n     * Note that this will only have an effect on Observable which are not yet\n     * started.\n     * This means it will only have an effect on:\n     *   - unsubscribed Observables\n     *   - Observables waiting for Observables with an higher priority to\n     *     finish\n     *\n     * @param {Observable} obs\n     * @param {number} priority\n     */\n    ObservablePrioritizer.prototype.updatePriority = function (obs, priority) {\n        var queueElement = arrayFind(this._queue, function (elt) { return elt.observable === obs; });\n        if (!queueElement) {\n            return;\n        }\n        queueElement.priority = priority;\n    };\n    ObservablePrioritizer.prototype._startObservable = function (obs) {\n        var _this = this;\n        var onObservableFinish = function () {\n            _this._numberOfPendingObservables--;\n            if (_this._numberOfPendingObservables > 0) {\n                // still waiting for Observables to finish\n                return;\n            }\n            _this._pendingPriority = null;\n            if (_this._queue.length === 0) {\n                return;\n            }\n            _this._pendingPriority = _this._queue\n                .reduce(function (acc, elt) {\n                return acc == null || acc > elt.priority ?\n                    elt.priority : acc;\n            }, null);\n            for (var i = 0; i < _this._queue.length; i++) {\n                var elt = _this._queue[i];\n                if (elt.priority === _this._pendingPriority) {\n                    _this._queue.splice(i, 1);\n                    i--;\n                    elt.trigger.next();\n                    elt.trigger.complete();\n                }\n            }\n        };\n        this._numberOfPendingObservables++;\n        return obs\n            .finally(onObservableFinish);\n    };\n    return ObservablePrioritizer;\n}());\nexports.default = ObservablePrioritizer;\n\n\n//# sourceURL=webpack://RxPlayer/./src/core/pipelines/segment/prioritizer.ts?");

/***/ }),

/***/ "./src/core/pipelines/segment/segment_fetcher.ts":
/*!*******************************************************!*\
  !*** ./src/core/pipelines/segment/segment_fetcher.ts ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar objectAssign = __webpack_require__(/*! object-assign */ \"./node_modules/object-assign/index.js\");\nvar Subject_1 = __webpack_require__(/*! rxjs/Subject */ \"./node_modules/rxjs/Subject.js\");\nvar id_1 = __webpack_require__(/*! ../../../utils/id */ \"./src/utils/id.ts\");\nvar core_pipeline_1 = __webpack_require__(/*! ../core_pipeline */ \"./src/core/pipelines/core_pipeline.ts\");\n/**\n * Create a function which will fetch segments.\n *\n * This function will:\n *   - only emit the resulting data\n *   - dispatch the other infos through the right subjects.\n *\n * @param {string} bufferType\n * @param {Object} transport\n * @param {Subject} network$ - Subject through which network metrics will be\n * sent, for the ABR.\n * @param {Subject} requests$ - Subject through which requests infos will be\n * sent, for the ABR.\n * @param {Subject} warning$ - Subject through which minor requests error will\n * be sent.\n * @param {Object} options\n * @returns {Function}\n */\nfunction createSegmentFetcher(bufferType, transport, network$, requests$, warning$, options) {\n    var basePipeline$ = core_pipeline_1.default(transport[bufferType], options);\n    var request$;\n    var id;\n    /**\n     * Process a pipeline observable to adapt it to the Stream way:\n     *   - use the network$ subject for network metrics (bandwitdh mesure)\n     *   - use the requests subject for network requests and their progress\n     *   - use the warning$ subject for retries' error messages\n     *   - only emit the data\n     * @param {string} pipelineType\n     * @param {Observable} pipeline$\n     * @returns {Observable}\n     */\n    return function fetchSegment(content) {\n        return basePipeline$(content)\n            .do(function (arg) {\n            switch (arg.type) {\n                case \"error\":\n                    warning$.next(objectAssign(arg.value, { pipelineType: bufferType }));\n                    break;\n                case \"metrics\": {\n                    var value = arg.value;\n                    var size = value.size, duration = value.duration; // unwrapping for TS\n                    // format it for ABR Handling\n                    if (size != null && duration != null) {\n                        network$.next({\n                            type: bufferType,\n                            value: {\n                                size: size,\n                                duration: duration,\n                            },\n                        });\n                    }\n                    break;\n                }\n                case \"request\": {\n                    var value = arg.value;\n                    // format it for ABR Handling\n                    var segment = value && value.segment;\n                    if (segment != null && segment.duration != null) {\n                        request$ = new Subject_1.Subject();\n                        requests$.next(request$);\n                        var duration = segment.duration / segment.timescale;\n                        var time = segment.time / segment.timescale;\n                        id = id_1.default();\n                        request$.next({\n                            type: bufferType,\n                            event: \"requestBegin\",\n                            value: {\n                                duration: duration,\n                                time: time,\n                                requestTimestamp: Date.now(),\n                                id: id,\n                            },\n                        });\n                    }\n                    break;\n                }\n                case \"progress\": {\n                    var value = arg.value;\n                    if (value.totalSize != null &&\n                        value.size < value.totalSize &&\n                        id != null &&\n                        request$ != null) {\n                        request$.next({\n                            type: bufferType,\n                            event: \"progress\",\n                            value: {\n                                duration: value.duration,\n                                size: value.size,\n                                totalSize: value.totalSize,\n                                timestamp: Date.now(),\n                                id: id,\n                            },\n                        });\n                    }\n                    break;\n                }\n            }\n        })\n            .filter(function (arg) {\n            return arg.type === \"data\" || arg.type === \"cache\";\n        })\n            // take only value from data/cache events\n            .map(function (_a) {\n            var value = _a.value;\n            return value;\n        })\n            .finally(function () {\n            if (request$ != null) {\n                if (id != null) {\n                    request$.next({\n                        type: bufferType,\n                        event: \"requestEnd\",\n                        value: { id: id },\n                    });\n                }\n                request$.complete();\n            }\n        })\n            .share(); // avoid multiple side effects if multiple subs\n    };\n}\nexports.default = createSegmentFetcher;\n\n\n//# sourceURL=webpack://RxPlayer/./src/core/pipelines/segment/segment_fetcher.ts?");

/***/ }),

/***/ "./src/core/source_buffers/abstract_source_buffer.ts":
/*!***********************************************************!*\
  !*** ./src/core/source_buffers/abstract_source_buffer.ts ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Observable_1 = __webpack_require__(/*! rxjs/Observable */ \"./node_modules/rxjs/Observable.js\");\nvar assert_1 = __webpack_require__(/*! ../../utils/assert */ \"./src/utils/assert.ts\");\nvar eventemitter_1 = __webpack_require__(/*! ../../utils/eventemitter */ \"./src/utils/eventemitter.ts\");\nvar rx_tryCatch_1 = __webpack_require__(/*! ../../utils/rx-tryCatch */ \"./src/utils/rx-tryCatch.ts\");\nvar time_ranges_1 = __webpack_require__(/*! ./time_ranges */ \"./src/core/source_buffers/time_ranges.ts\");\n/**\n * Abstract class for a custom SourceBuffer implementation.\n * @class AbstractSourceBuffer\n * @extends EventEmitter\n */\nvar AbstractSourceBuffer = /** @class */ (function (_super) {\n    __extends(AbstractSourceBuffer, _super);\n    function AbstractSourceBuffer() {\n        var _this = _super.call(this) || this;\n        _this.updating = false;\n        _this.readyState = \"opened\";\n        _this.buffered = new time_ranges_1.default();\n        return _this;\n    }\n    /**\n     * Mimic the SourceBuffer _appendBuffer_ method: Append segment.\n     * @param {*} data\n     */\n    AbstractSourceBuffer.prototype.appendBuffer = function (data) {\n        var _this = this;\n        this._lock(function () { return _this._append(data); });\n    };\n    /**\n     * Mimic the SourceBuffer _remove_ method: remove segment.\n     * @param {Number} from\n     * @param {Number} to\n     */\n    AbstractSourceBuffer.prototype.remove = function (from, to) {\n        var _this = this;\n        this._lock(function () { return _this._remove(from, to); });\n    };\n    /**\n     * Mimic the SourceBuffer _abort_ method.\n     */\n    AbstractSourceBuffer.prototype.abort = function () {\n        this.remove(0, Infinity);\n        this.updating = false;\n        this.readyState = \"closed\";\n        this._abort();\n    };\n    /**\n     * Active a lock, execute the given function, unlock when finished (on\n     * nextTick).\n     * Throws if multiple lock are active at the same time.\n     * Also triggers the right events on start, error and end\n     * @param {Function} func\n     */\n    AbstractSourceBuffer.prototype._lock = function (func) {\n        var _this = this;\n        assert_1.default(!this.updating, \"updating\");\n        this.updating = true;\n        this.trigger(\"updatestart\", undefined);\n        var result = rx_tryCatch_1.default(function () {\n            func();\n            return Observable_1.Observable.of(undefined);\n        });\n        result.subscribe(function () { return setTimeout(function () { _this._unlock(\"update\"); }, 0); }, function (e) { return setTimeout(function () { _this._unlock(\"error\", e); }, 0); });\n    };\n    /**\n     * Free the lock and trigger the right events.\n     * @param {string} eventName\n     * @param {*} value - value sent with the given event.\n     */\n    AbstractSourceBuffer.prototype._unlock = function (eventName, value) {\n        this.updating = false;\n        this.trigger(eventName, value);\n        this.trigger(\"updateend\", undefined);\n    };\n    return AbstractSourceBuffer;\n}(eventemitter_1.default));\nexports.default = AbstractSourceBuffer;\n\n\n//# sourceURL=webpack://RxPlayer/./src/core/source_buffers/abstract_source_buffer.ts?");

/***/ }),

/***/ "./src/core/source_buffers/image/index.ts":
/*!************************************************!*\
  !*** ./src/core/source_buffers/image/index.ts ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar abstract_source_buffer_1 = __webpack_require__(/*! ../abstract_source_buffer */ \"./src/core/source_buffers/abstract_source_buffer.ts\");\n// TODO\nvar ImageSourceBuffer = /** @class */ (function (_super) {\n    __extends(ImageSourceBuffer, _super);\n    function ImageSourceBuffer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @param {Object} data\n     */\n    ImageSourceBuffer.prototype._append = function (data) {\n        var start = data.start, end = data.end, timescale = data.timescale;\n        this.buffered.insert(start / timescale, end == null ? Number.MAX_VALUE : end / timescale);\n    };\n    // TODO\n    /* tslint:disable no-empty */\n    ImageSourceBuffer.prototype._remove = function () { };\n    /* tslint:enable no-empty */\n    // TODO\n    /* tslint:disable no-empty */\n    ImageSourceBuffer.prototype._abort = function () { };\n    return ImageSourceBuffer;\n}(abstract_source_buffer_1.default));\nexports.default = ImageSourceBuffer;\n\n\n//# sourceURL=webpack://RxPlayer/./src/core/source_buffers/image/index.ts?");

/***/ }),

/***/ "./src/core/source_buffers/index.ts":
/*!******************************************!*\
  !*** ./src/core/source_buffers/index.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar MediaError_1 = __webpack_require__(/*! ../../errors/MediaError */ \"./src/errors/MediaError.ts\");\nvar log_1 = __webpack_require__(/*! ../../utils/log */ \"./src/utils/log.ts\");\nvar image_1 = __webpack_require__(/*! ./image */ \"./src/core/source_buffers/image/index.ts\");\nvar queued_source_buffer_1 = __webpack_require__(/*! ./queued_source_buffer */ \"./src/core/source_buffers/queued_source_buffer.ts\");\nexports.QueuedSourceBuffer = queued_source_buffer_1.default;\nvar text_1 = __webpack_require__(/*! ./text */ \"./src/core/source_buffers/text/index.ts\");\n// Array of every SourceBuffer types managed here\nexports.BUFFER_TYPES = [\"audio\", \"video\", \"text\", \"image\"];\n/**\n * Allows to easily create and dispose SourceBuffers.\n *\n * Only one source buffer per type is allowed at the same time:\n *\n *   - source buffers for native types (which depends on the native\n *     SourceBuffer implementation), are reused if one is re-created.\n *\n *   - source buffers for custom types are aborted each time a new one of the\n *     same type is created.\n *\n * The returned SourceBuffer is actually a QueuedSourceBuffer instance which\n * wrap a SourceBuffer implementation to queue all its actions.\n *\n * @class SourceBufferManager\n */\nvar SourceBufferManager = /** @class */ (function () {\n    /**\n     * @param {HTMLMediaElement} videoElement\n     * @param {MediaSource} mediaSource\n     * @constructor\n     */\n    function SourceBufferManager(videoElement, mediaSource) {\n        this._videoElement = videoElement;\n        this._mediaSource = mediaSource;\n        this._initializedNativeSourceBuffers = {};\n        this._initializedCustomSourceBuffers = {};\n    }\n    /**\n     * Returns true if the source buffer is \"native\" (has to be attached to the\n     * mediaSource at the beginning of the stream.\n     * @static\n     * @param {string} bufferType\n     * @returns {Boolean}\n     */\n    SourceBufferManager.isNative = function (bufferType) {\n        return shouldHaveNativeSourceBuffer(bufferType);\n    };\n    /**\n     * Returns true if a SourceBuffer with the type given has been created with\n     * this instance of the SourceBufferManager.\n     * @param {string} bufferType\n     * @returns {Boolean}\n     */\n    SourceBufferManager.prototype.has = function (bufferType) {\n        if (shouldHaveNativeSourceBuffer(bufferType)) {\n            return !!this._initializedNativeSourceBuffers[bufferType];\n        }\n        return !!this._initializedCustomSourceBuffers[bufferType];\n    };\n    /**\n     * Returns the created QueuedSourceBuffer for the given type.\n     * Throws if no QueuedSourceBuffer were created for the given type.\n     *\n     * @param {string} bufferType\n     * @returns {QueuedSourceBuffer}\n     */\n    SourceBufferManager.prototype.get = function (bufferType) {\n        if (shouldHaveNativeSourceBuffer(bufferType)) {\n            var sourceBufferInfos = this._initializedNativeSourceBuffers[bufferType];\n            if (!sourceBufferInfos) {\n                throw new Error(\"SourceBufferManager: no \" + bufferType + \" initialized yet\");\n            }\n            return sourceBufferInfos.sourceBuffer;\n        }\n        else {\n            var sourceBufferInfos = this._initializedCustomSourceBuffers[bufferType];\n            if (!sourceBufferInfos) {\n                throw new Error(\"SourceBufferManager: no \" + bufferType + \" initialized yet\");\n            }\n            return sourceBufferInfos.sourceBuffer;\n        }\n    };\n    /**\n     * Creates a new QueuedSourceBuffer for the given buffer type.\n     * Reuse an already created one if a QueuedSourceBuffer for the given type\n     * already exists. TODO Throw or abort old one instead?\n     * @param {string} bufferType\n     * @param {string} codec\n     * @param {Object} [options={}]\n     * @returns {QueuedSourceBuffer}\n     */\n    SourceBufferManager.prototype.createSourceBuffer = function (bufferType, codec, options) {\n        if (options === void 0) { options = {}; }\n        if (shouldHaveNativeSourceBuffer(bufferType)) {\n            var memorizedSourceBuffer = this._initializedNativeSourceBuffers[bufferType];\n            if (memorizedSourceBuffer) {\n                if (memorizedSourceBuffer.codec !== codec) {\n                    log_1.default.warn(\"reusing native SourceBuffer with codec\", memorizedSourceBuffer.codec, \"for codec\", codec);\n                }\n                else {\n                    log_1.default.info(\"reusing native SourceBuffer with codec\", codec);\n                }\n                return memorizedSourceBuffer.sourceBuffer;\n            }\n            log_1.default.info(\"adding native SourceBuffer with codec\", codec);\n            var nativeSourceBuffer = createNativeQueuedSourceBuffer(this._mediaSource, codec);\n            this._initializedNativeSourceBuffers[bufferType] = {\n                codec: codec,\n                sourceBuffer: nativeSourceBuffer,\n            };\n            return nativeSourceBuffer;\n        }\n        var memorizedCustomSourceBuffer = this\n            ._initializedCustomSourceBuffers[bufferType];\n        if (memorizedCustomSourceBuffer) {\n            log_1.default.info(\"reusing a previous custom SourceBuffer for the type\", bufferType);\n            return memorizedCustomSourceBuffer.sourceBuffer;\n        }\n        if (bufferType === \"text\") {\n            log_1.default.info(\"creating a new text SourceBuffer with codec\", codec);\n            var sourceBuffer = options.textTrackMode === \"html\" ?\n                new text_1.HTMLTextSourceBuffer(this._videoElement, options.textTrackElement) :\n                new text_1.NativeTextSourceBuffer(this._videoElement, options.hideNativeSubtitle);\n            var queuedSourceBuffer = new queued_source_buffer_1.default(sourceBuffer);\n            this._initializedCustomSourceBuffers.text = {\n                codec: codec,\n                sourceBuffer: queuedSourceBuffer,\n            };\n            return queuedSourceBuffer;\n        }\n        else if (bufferType === \"image\") {\n            log_1.default.info(\"creating a new image SourceBuffer with codec\", codec);\n            var sourceBuffer = new image_1.default();\n            var queuedSourceBuffer = new queued_source_buffer_1.default(sourceBuffer);\n            this._initializedCustomSourceBuffers.image = {\n                codec: codec,\n                sourceBuffer: queuedSourceBuffer,\n            };\n            return queuedSourceBuffer;\n        }\n        log_1.default.error(\"unknown buffer type:\", bufferType);\n        throw new MediaError_1.default(\"BUFFER_TYPE_UNKNOWN\", null, true);\n    };\n    /**\n     * Dispose of the active SourceBuffer for the given type.\n     * @param {string} bufferType\n     */\n    SourceBufferManager.prototype.disposeSourceBuffer = function (bufferType) {\n        if (shouldHaveNativeSourceBuffer(bufferType)) {\n            var memorizedNativeSourceBuffer = this\n                ._initializedNativeSourceBuffers[bufferType];\n            if (memorizedNativeSourceBuffer == null) {\n                return;\n            }\n            log_1.default.info(\"aborting native source buffer\", bufferType);\n            if (this._mediaSource.readyState === \"open\") {\n                try {\n                    memorizedNativeSourceBuffer.sourceBuffer.abort();\n                }\n                catch (e) {\n                    log_1.default.warn(\"failed to abort a SourceBuffer:\", e);\n                }\n            }\n            delete this._initializedNativeSourceBuffers[bufferType];\n            return;\n        }\n        else if (bufferType === \"text\" || bufferType === \"image\") {\n            var memorizedSourceBuffer = this\n                ._initializedCustomSourceBuffers[bufferType];\n            if (memorizedSourceBuffer == null) {\n                return;\n            }\n            log_1.default.info(\"aborting custom source buffer\", bufferType);\n            try {\n                memorizedSourceBuffer.sourceBuffer.abort();\n            }\n            catch (e) {\n                log_1.default.warn(\"failed to abort a SourceBuffer:\", e);\n            }\n            delete this._initializedCustomSourceBuffers[bufferType];\n            return;\n        }\n        log_1.default.error(\"cannot dispose an unknown buffer type\", bufferType);\n    };\n    /**\n     * Dispose of all QueuedSourceBuffer created on this SourceBufferManager.\n     */\n    SourceBufferManager.prototype.disposeAll = function () {\n        var _this = this;\n        exports.BUFFER_TYPES.forEach(function (bufferType) {\n            if (_this.has(bufferType)) {\n                _this.disposeSourceBuffer(bufferType);\n            }\n        });\n    };\n    return SourceBufferManager;\n}());\nexports.default = SourceBufferManager;\n/**\n * Adds a SourceBuffer to the MediaSource.\n * @param {MediaSource} mediaSource\n * @param {string} codec\n * @returns {SourceBuffer}\n */\nfunction createNativeQueuedSourceBuffer(mediaSource, codec) {\n    var sourceBuffer = mediaSource.addSourceBuffer(codec);\n    return new queued_source_buffer_1.default(sourceBuffer);\n}\n/**\n * Returns true if the given buffeType is a native buffer, false otherwise.\n * \"Native\" source buffers are directly added to the MediaSource.\n * @param {string} bufferType\n * @returns {Boolean}\n */\nfunction shouldHaveNativeSourceBuffer(bufferType) {\n    return bufferType === \"audio\" || bufferType === \"video\";\n}\n\n\n//# sourceURL=webpack://RxPlayer/./src/core/source_buffers/index.ts?");

/***/ }),

/***/ "./src/core/source_buffers/queued_source_buffer.ts":
/*!*********************************************************!*\
  !*** ./src/core/source_buffers/queued_source_buffer.ts ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Observable_1 = __webpack_require__(/*! rxjs/Observable */ \"./node_modules/rxjs/Observable.js\");\nvar Subject_1 = __webpack_require__(/*! rxjs/Subject */ \"./node_modules/rxjs/Subject.js\");\nvar log_1 = __webpack_require__(/*! ../../utils/log */ \"./src/utils/log.ts\");\nvar SourceBufferAction;\n(function (SourceBufferAction) {\n    SourceBufferAction[SourceBufferAction[\"Append\"] = 0] = \"Append\";\n    SourceBufferAction[SourceBufferAction[\"Remove\"] = 1] = \"Remove\";\n})(SourceBufferAction || (SourceBufferAction = {}));\n/**\n * Wrap a SourceBuffer and append/remove segments in it in a queue.\n *\n * Wait for the previous buffer action to be finished (updateend event) to\n * perform the next in the queue.\n *\n * To work correctly, only a single QueuedSourceBuffer per SourceBuffer should\n * be created.\n *\n * @class QueuedSourceBuffer\n */\nvar QueuedSourceBuffer = /** @class */ (function () {\n    /**\n     * @constructor\n     * @param {SourceBuffer} sourceBuffer\n     */\n    function QueuedSourceBuffer(sourceBuffer) {\n        this._buffer = sourceBuffer;\n        this._queue = [];\n        this._flushing = null;\n        this._lastInitSegment = null;\n        this.__onUpdate = this._onUpdate.bind(this);\n        this.__onError = this._onError.bind(this);\n        this.__flush = this._flush.bind(this);\n        this._buffer.addEventListener(\"update\", this.__onUpdate);\n        this._buffer.addEventListener(\"error\", this.__onError);\n        this._buffer.addEventListener(\"updateend\", this.__flush);\n    }\n    /**\n     * Append media segment to the attached SourceBuffer, in a FIFO queue.\n     *\n     * Depending on the type of data appended, this might need an associated\n     * initialization segment.\n     *\n     * Such initialization segment will be pushed in the SourceBuffer if the\n     * last segment pushed was associated to another initialization segment.\n     * This detection is entirely reference-based so make sure that the same\n     * initSegment argument given share the same reference.\n     *\n     * You can deactivate the usage of initialization segment by setting the\n     * initSegment argument to null.\n     *\n     * You can also only push an initialization segment by setting the segment\n     * argument to null.\n     * @param {*|null} initSegment\n     * @param {*|null} segment\n     * @returns {Observable}\n     */\n    QueuedSourceBuffer.prototype.appendBuffer = function (initSegment, segment) {\n        var _this = this;\n        return Observable_1.Observable.defer(function () {\n            return _this._queueAction({\n                type: SourceBufferAction.Append,\n                segment: segment,\n                initSegment: initSegment,\n            });\n        });\n    };\n    /**\n     * Remove data from the attached SourceBuffer, in a FIFO queue.\n     * @param {Object} range\n     * @param {Number} range.start - start position, in seconds\n     * @param {Number} range.end - end position, in seconds\n     * @returns {Observable}\n     */\n    QueuedSourceBuffer.prototype.removeBuffer = function (_a) {\n        var _this = this;\n        var start = _a.start, end = _a.end;\n        return Observable_1.Observable.defer(function () {\n            return _this._queueAction({\n                type: SourceBufferAction.Remove,\n                start: start,\n                end: end,\n            });\n        });\n    };\n    /**\n     * Abort the linked SourceBuffer and dispose of the ressources used by this\n     * QueuedSourceBuffer.\n     *\n     * /!\\ You won't be able to use the QueuedSourceBuffer after calling this\n     * function.\n     * @private\n     */\n    QueuedSourceBuffer.prototype.abort = function () {\n        this.dispose();\n        this._buffer.abort();\n    };\n    /**\n     * Returns the currently buffered data, in a TimeRanges object.\n     * @returns {TimeRanges}\n     */\n    QueuedSourceBuffer.prototype.getBuffered = function () {\n        return this._buffer.buffered;\n    };\n    /**\n     * Free up ressources used by this class.\n     *\n     * /!\\ You won't be able to use the QueuedSourceBuffer after calling this\n     * function.\n     */\n    QueuedSourceBuffer.prototype.dispose = function () {\n        this._buffer.removeEventListener(\"update\", this.__onUpdate);\n        this._buffer.removeEventListener(\"error\", this.__onError);\n        this._buffer.removeEventListener(\"updateend\", this.__flush);\n        this._queue.length = 0;\n        this._flushing = null;\n    };\n    /**\n     * Callback used for the 'update' event, as a segment has been added/removed.\n     *\n     * Emit and complete the corresponding subject to inform the action caller\n     * of completion.\n     *\n     * @private\n     */\n    QueuedSourceBuffer.prototype._onUpdate = function () {\n        if (this._flushing) {\n            this._flushing.next(undefined);\n            this._flushing.complete();\n            this._flushing = null;\n        }\n    };\n    /**\n     * Callback used for the 'error' event from the SourceBuffer.\n     *\n     * Emit the error through the corresponding subject to inform the action\n     * caller.\n     *\n     * @private\n     * @param {Error} error\n     */\n    QueuedSourceBuffer.prototype._onError = function (error) {\n        if (this._flushing) {\n            this._flushing.error(error);\n            this._flushing = null;\n        }\n    };\n    /**\n     * Queue a new action.\n     * Begin flushing if no action were previously in the queue.\n     * @private\n     * @param {Object} action\n     * @returns {Subject} - Can be used to follow the buffer action advancement.\n     */\n    QueuedSourceBuffer.prototype._queueAction = function (action) {\n        var shouldFlush = !this._queue.length;\n        var subject = new Subject_1.Subject();\n        if (action.type === SourceBufferAction.Append) {\n            var segment = action.segment, initSegment = action.initSegment;\n            if (initSegment === null && segment === null) {\n                log_1.default.warn(\"QueuedSourceBuffer: no segment appended.\");\n                return Observable_1.Observable.of(undefined);\n            }\n            if (initSegment === null) {\n                this._queue.unshift({\n                    type: SourceBufferAction.Append,\n                    args: segment,\n                    // case\n                    subject: subject,\n                });\n            }\n            else if (segment === null) {\n                if (this._lastInitSegment === initSegment) {\n                    return Observable_1.Observable.of(undefined);\n                }\n                this._queue.unshift({\n                    type: SourceBufferAction.Append,\n                    args: initSegment,\n                    subject: subject,\n                });\n            }\n            else {\n                if (this._lastInitSegment !== initSegment) {\n                    this._queue.unshift({\n                        type: SourceBufferAction.Append,\n                        args: initSegment,\n                        subject: null,\n                    });\n                }\n                this._queue.unshift({\n                    type: SourceBufferAction.Append,\n                    args: segment,\n                    subject: subject,\n                });\n            }\n            this._lastInitSegment = initSegment;\n        }\n        else if (action.type === SourceBufferAction.Remove) {\n            this._queue.unshift({\n                type: SourceBufferAction.Remove,\n                args: {\n                    start: action.start,\n                    end: action.end,\n                },\n                subject: subject,\n            });\n        }\n        else {\n            throw new Error(\"QueuedSourceBuffer: unrecognized action\");\n        }\n        if (shouldFlush) {\n            this._flush();\n        }\n        return subject.mapTo(undefined);\n    };\n    /**\n     * Perform next queued action if one and none are pending.\n     * @private\n     */\n    QueuedSourceBuffer.prototype._flush = function () {\n        if (this._flushing || this._queue.length === 0 || this._buffer.updating) {\n            return;\n        }\n        // TODO TypeScrypt do not get the previous length check? Find solution /\n        // open issue\n        var queueElement = this._queue.pop();\n        this._flushing = queueElement.subject;\n        try {\n            switch (queueElement.type) {\n                case SourceBufferAction.Append:\n                    log_1.default.debug(\"pushing data to source buffer\", queueElement.args);\n                    this._buffer.appendBuffer(queueElement.args);\n                    break;\n                case SourceBufferAction.Remove:\n                    var _a = queueElement.args, start = _a.start, end = _a.end;\n                    log_1.default.debug(\"removing data from source buffer\", start, end);\n                    this._buffer.remove(start, end);\n                    break;\n            }\n        }\n        catch (e) {\n            this._onError(e);\n        }\n    };\n    return QueuedSourceBuffer;\n}());\nexports.default = QueuedSourceBuffer;\n\n\n//# sourceURL=webpack://RxPlayer/./src/core/source_buffers/queued_source_buffer.ts?");

/***/ }),

/***/ "./src/core/source_buffers/text/html/buffer_manager.ts":
/*!*************************************************************!*\
  !*** ./src/core/source_buffers/text/html/buffer_manager.ts ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar assert_1 = __webpack_require__(/*! ../../../../utils/assert */ \"./src/utils/assert.ts\");\n/**\n * Maximum time difference, in seconds, between two text segment's start times\n * and/or end times for them to be considered the same in the custom text's\n * source buffer used for the \"html\" textTrackMode.\n *\n * For example for two segments s1 and s2 which have a start time respectively\n * of st1 and st2 and end time of et1 and et2:\n *   - if both the absolute difference between st1 and st2 AND the one between\n *     et1 and et2 is inferior or equal to the MAX_DELTA_BUFFER_TIME, s1 and s2\n *     are considered to target the exact same time. As a consequence, if s2 is\n *     added after s1 in the source buffer, s1 will be completely replaced by\n *     it and vice-versa.\n *   - if only one of the two (absolute difference between st1 and st2 OR et1\n *     and et2) is inferior to the MAX_DELTA_BUFFER_TIME then the last added\n *     is not completely considered the same. It WILL still replace - either\n *     partially or completely (depending on the sign of the other difference) -\n *     the previously added segment.\n *   - if both differences are strictly superior to the MAX_DELTA_BUFFER_TIME,\n *     then they are not considered to have the same start nor the same end.\n *     They can still overlap however, and MIGHT thus still replace partially\n *     or completely each other.\n *\n * Setting a value too low might lead to two segments targeting the same time,\n * both being present in the source buffer. In worst case scenarios, this could\n * lead to indicate that an unwanted text track is still here (theorically\n * though, this is a case that should never happen for reasons that might be too\n * long to explain here).\n *\n * Setting a value too high might lead to two segments targeting different times\n * to be wrongly believed to target the same time. In worst case scenarios, this\n * could lead to wanted text tracks being removed.\n * @type Number\n */\nvar MAX_DELTA_BUFFER_TIME = 0.2;\n/**\n * @see MAX_DELTA_BUFFER_TIME\n * @param {Number} a\n * @param {Number} b\n * @returns {Boolean}\n */\nfunction areNearlyEqual(a, b) {\n    return Math.abs(a - b) <= MAX_DELTA_BUFFER_TIME;\n}\n/**\n * Get all cues strictly before the given time.\n * @param {Object} cues\n * @param {Number} time\n * @returns {Array.<Object>}\n */\nfunction getCuesBefore(cues, time) {\n    for (var i = 0; i < cues.length; i++) {\n        var cue = cues[i];\n        if (time < cue.end) {\n            if (time >= cue.start) {\n                return cues.slice(0, i);\n            }\n            return cues.slice(0, i + 1);\n        }\n    }\n    return cues.slice();\n}\n/**\n * Get all cues strictly after the given time.\n * @param {Object} cues\n * @param {Number} time\n * @returns {Array.<Object>}\n */\nfunction getCuesAfter(cues, time) {\n    for (var i = 0; i < cues.length; i++) {\n        var cue = cues[i];\n        if (time < cue.end) {\n            if (time >= cue.start) {\n                return cues.slice(i + 1, cues.length);\n            }\n            return cues.slice(i, cues.length);\n        }\n    }\n    return [];\n}\n/**\n * @param {Object} cuesInfos\n * @param {Number} start\n * @param {Number} end\n * @returns {Array.<Object>}\n */\nfunction removeCuesInfosBetween(cuesInfos, start, end) {\n    var end1 = Math.max(cuesInfos.start, start);\n    var cuesInfos1 = {\n        start: cuesInfos.start,\n        end: end1,\n        cues: getCuesBefore(cuesInfos.cues, start),\n    };\n    var start2 = Math.min(end, cuesInfos.end);\n    var cuesInfos2 = {\n        start: start2,\n        end: cuesInfos.end,\n        cues: getCuesAfter(cuesInfos.cues, end),\n    };\n    return [cuesInfos1, cuesInfos2];\n}\n/**\n * Manage the buffer of the HTML text Sourcebuffer.\n * Allows to add, remove and recuperate cues at given times.\n * @class TextBufferManager\n */\nvar TextBufferManager = /** @class */ (function () {\n    function TextBufferManager() {\n        this._cuesBuffer = [];\n    }\n    /**\n     * Get corresponding cue for the given time.\n     * A cue is an object with three properties:\n     *   - start {Number}: start time for which the cue should be displayed.\n     *   - end {Number}: end time for which the cue should be displayed.\n     *   - element {HTMLElement}: The cue to diplay\n     *\n     * We do not mutate individual cue here.\n     * That is, if the ``get`` method returns the same cue's reference than a\n     * previous ``get`` call, its properties are guaranteed to have the exact same\n     * values than before, if you did not mutate it on your side.\n     * The inverse is true, if the values are the same than before, the reference\n     * will stay the same (this is useful to easily check if the DOM should be\n     * updated, for example).\n     *\n     * @param {Number} time\n     * @returns {HTMLElement|undefined} - The cue to display\n     */\n    TextBufferManager.prototype.get = function (time) {\n        var cuesBuffer = this._cuesBuffer;\n        // begins at the end as most of the time the player will ask for the last\n        // CuesGroup\n        for (var i = cuesBuffer.length - 1; i >= 0; i--) {\n            var cues = cuesBuffer[i].cues;\n            for (var j = cues.length - 1; j >= 0; j--) {\n                var cue = cues[j];\n                if (time >= cue.start) {\n                    if (time < cue.end) {\n                        return cue;\n                    }\n                    else {\n                        return undefined;\n                    }\n                }\n            }\n        }\n        return undefined;\n    };\n    /**\n     * Remove cue from a certain range of time.\n     * @param {Number} from\n     * @param {Number} to\n     */\n    TextBufferManager.prototype.remove = function (from, _to) {\n        if (true) {\n            assert_1.default(from >= 0);\n            assert_1.default(_to >= 0);\n            assert_1.default(_to > from);\n        }\n        var to = Math.max(from, _to);\n        var cuesBuffer = this._cuesBuffer;\n        var len = cuesBuffer.length;\n        for (var i = 0; i < len; i++) {\n            if (cuesBuffer[i].end > from) {\n                var startCuesInfos = cuesBuffer[i];\n                if (startCuesInfos.start >= to) {\n                    // our cue is strictly after this interval, we have nothing to do\n                    return;\n                }\n                // ``to`` is within this segment\n                if (startCuesInfos.end >= to) {\n                    var _a = removeCuesInfosBetween(startCuesInfos, from, to), cuesInfos1 = _a[0], cuesInfos2 = _a[1];\n                    this._cuesBuffer[i] = cuesInfos1;\n                    cuesBuffer.splice(i + 1, 0, cuesInfos2);\n                    return;\n                }\n                // Else remove the part of the segment after ``from``, and the concerned\n                // segments after that\n                startCuesInfos.cues = getCuesBefore(startCuesInfos.cues, from);\n                startCuesInfos.end = Math.max(from, startCuesInfos.start);\n                for (var j = i + 1; j < len; j++) {\n                    var endCuesInfos = cuesBuffer[i];\n                    if (to <= endCuesInfos.end) {\n                        // remove all cues from the start to this one non-included\n                        cuesBuffer.splice(i + 1, j - (i + 1));\n                        // if ``to`` is in the middle of the last segment\n                        if (to > endCuesInfos.start) {\n                            endCuesInfos.cues = getCuesAfter(endCuesInfos.cues, to);\n                            endCuesInfos.start = to;\n                        }\n                        return;\n                    }\n                }\n                cuesBuffer.splice(i + 1, cuesBuffer.length - (i + 1));\n                return;\n            }\n        }\n    };\n    /**\n     * Insert new cues in our text buffer.\n     * cues is an array of objects with three properties:\n     *   - start {Number}: start time for which the cue should be displayed.\n     *   - end {Number}: end time for which the cue should be displayed.\n     *   - element {HTMLElement}: The cue to diplay\n     *\n     * @param {Array.<Object>} cues - CuesGroups, array of objects with the\n     * following properties:\n     *   - start {Number}: the time at which the cue will start to be displayed\n     *   - end {Number}: the time at which the cue will end to be displayed\n     *   - cue {HTMLElement}: The cue\n     * @param {Number} start - Start time at which the CuesGroup applies.\n     * This is different than the start of the first cue to display in it, this\n     * has more to do with the time at which the _text segment_ starts.\n     * @param {Number} end - End time at which the CuesGroup applies.\n     * This is different than the end of the last cue to display in it, this\n     * has more to do with the time at which the _text segment_ ends.\n     *\n     * TODO add securities to ensure that:\n     *   - the start of a CuesGroup is inferior or equal to the start of the first\n     *     cue in it\n     *   - the end of a CuesGroup is superior or equal to the end of the last\n     *     cue in it\n     * If those requirements are not met, we could delete some cues when adding\n     * a CuesGroup before/after. Find a solution.\n     */\n    TextBufferManager.prototype.insert = function (cues, start, end) {\n        var cuesBuffer = this._cuesBuffer;\n        var cuesInfosToInsert = { start: start, end: end, cues: cues };\n        for (var i = 0; i < cuesBuffer.length; i++) {\n            var cuesInfos = cuesBuffer[i];\n            if (start < cuesInfos.end) {\n                if (areNearlyEqual(start, cuesInfos.start)) {\n                    if (areNearlyEqual(end, cuesInfos.end)) {\n                        // exact same segment\n                        //   ours:            |AAAAA|\n                        //   the current one: |BBBBB|\n                        //   Result:          |AAAAA|\n                        // Which means:\n                        //   1. replace the current cue with ours\n                        cuesBuffer[i] = cuesInfosToInsert;\n                        return;\n                    }\n                    else if (end < cuesInfos.end) {\n                        // our cue overlaps with the current one:\n                        //   ours:            |AAAAA|\n                        //   the current one: |BBBBBBBB|\n                        //   Result:          |AAAAABBB|\n                        // Which means:\n                        //   1. remove some cues at the start of the current one\n                        //   2. update start of current one\n                        //   3. add ours before the current one\n                        cuesInfos.cues = getCuesAfter(cuesInfos.cues, end);\n                        cuesInfos.start = end;\n                        cuesBuffer.splice(i, 0, cuesInfosToInsert);\n                        return;\n                    }\n                    // our cue goes beyond the current one:\n                    //   ours:            |AAAAAAA|\n                    //   the current one: |BBBB|\n                    //   Result:          |AAAAAAA|\n                    // Here we have to delete any cuesInfos which end before ours end,\n                    // and see about the following one.\n                    do {\n                        cuesBuffer.splice(i, 1);\n                        cuesInfos = cuesBuffer[i];\n                    } while (cuesInfos && end > cuesInfos.end);\n                    if (!cuesInfos || // There is no cue here\n                        areNearlyEqual(end, cuesInfos.end) // this cue has the same end\n                    ) {\n                        // put in place\n                        cuesBuffer[i] = cuesInfosToInsert;\n                        return;\n                    }\n                    // else -> end < cuesInfos.end (overlapping case)\n                    //   ours:            |AAAAA|\n                    //   the current one: |BBBBBBBB|\n                    //   Result:          |AAAAABBB|\n                    cuesInfos.cues = getCuesAfter(cuesInfos.cues, end);\n                    cuesInfos.start = end;\n                    cuesBuffer.splice(i, 0, cuesInfosToInsert);\n                    return;\n                }\n                else if (start < cuesInfos.start) {\n                    if (end < cuesInfos.start) {\n                        // our cue goes strictly before the current one:\n                        //   ours:            |AAAAAAA|\n                        //   the current one:           |BBBB|\n                        //   Result:          |AAAAAAA| |BBBB|\n                        // Which means:\n                        //   - add ours before the current one\n                        cuesBuffer.splice(i, 0, cuesInfosToInsert);\n                        return;\n                    }\n                    else if (areNearlyEqual(end, cuesInfos.start)) {\n                        // our cue goes just before the current one:\n                        //   ours:            |AAAAAAA|\n                        //   the current one:         |BBBB|\n                        //   Result:          |AAAAAAA|BBBB|\n                        // Which means:\n                        //   - update start time of the current one to be sure\n                        //   - add ours before the current one\n                        cuesInfos.start = end;\n                        cuesBuffer.splice(i, 0, cuesInfosToInsert);\n                        return;\n                    }\n                    // our cue overlaps the current one:\n                    //   ours:            |AAAAAAA|\n                    //   the current one:     |BBBBB|\n                    //   Result:          |AAAAAAABB|\n                    // Which means:\n                    //   1. remove some cues at the start of the current one\n                    //   2. update start of current one\n                    //   3. add ours before the current one\n                    cuesInfos.cues = getCuesAfter(cuesInfos.cues, end);\n                    cuesInfos.start = end;\n                    cuesBuffer.splice(i, 0, cuesInfosToInsert);\n                    return;\n                }\n                // else -> start > cuesInfos.start\n                if (end > cuesInfos.end || areNearlyEqual(end, cuesInfos.end)) {\n                    // our cue overlaps the current one:\n                    //   ours:              |AAAAAA|\n                    //   the current one: |BBBBB|\n                    //   Result:          |BBAAAAAA|\n                    //   - or -\n                    //   ours:              |AAAA|\n                    //   the current one: |BBBBBB|\n                    //   Result:          |BBAAAA|\n                    // Which means:\n                    //   1. remove some cues at the end of the current one\n                    //   2. update end of current one\n                    //   3. add ours after current one\n                    cuesInfos.cues = getCuesBefore(cuesInfos.cues, start);\n                    cuesInfos.end = start;\n                    cuesBuffer.splice(i + 1, 0, cuesInfosToInsert);\n                    return;\n                }\n                // else -> end < cuesInfos.end\n                // our cue is in the current one:\n                //   ours:              |AAA|\n                //   the current one: |BBBBBBB|\n                //   Result:          |BBAAABB|\n                // Which means:\n                //   1. split current one in two parts based on our cue.\n                //   2. insert our cue into it.\n                var _a = removeCuesInfosBetween(cuesInfos, start, end), cuesInfos1 = _a[0], cuesInfos2 = _a[1];\n                this._cuesBuffer[i] = cuesInfos1;\n                cuesBuffer.splice(i + 1, 0, cuesInfosToInsert);\n                cuesBuffer.splice(i + 2, 0, cuesInfos2);\n                return;\n            }\n        }\n        // no cues group has the end after our current start.\n        // These cues should be the last one\n        cuesBuffer.push(cuesInfosToInsert);\n    };\n    return TextBufferManager;\n}());\nexports.default = TextBufferManager;\n\n\n//# sourceURL=webpack://RxPlayer/./src/core/source_buffers/text/html/buffer_manager.ts?");

/***/ }),

/***/ "./src/core/source_buffers/text/html/index.ts":
/*!****************************************************!*\
  !*** ./src/core/source_buffers/text/html/index.ts ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Observable_1 = __webpack_require__(/*! rxjs/Observable */ \"./node_modules/rxjs/Observable.js\");\nvar Subject_1 = __webpack_require__(/*! rxjs/Subject */ \"./node_modules/rxjs/Subject.js\");\nvar events_1 = __webpack_require__(/*! ../../../../compat/events */ \"./src/compat/events.ts\");\nvar config_1 = __webpack_require__(/*! ../../../../config */ \"./src/config.ts\");\nvar log_1 = __webpack_require__(/*! ../../../../utils/log */ \"./src/utils/log.ts\");\nvar abstract_source_buffer_1 = __webpack_require__(/*! ../../abstract_source_buffer */ \"./src/core/source_buffers/abstract_source_buffer.ts\");\nvar buffer_manager_1 = __webpack_require__(/*! ./buffer_manager */ \"./src/core/source_buffers/text/html/buffer_manager.ts\");\nvar parsers_1 = __webpack_require__(/*! ./parsers */ \"./src/core/source_buffers/text/html/parsers.ts\");\nvar MAXIMUM_HTML_TEXT_TRACK_UPDATE_INTERVAL = config_1.default.MAXIMUM_HTML_TEXT_TRACK_UPDATE_INTERVAL;\n/**\n * Generate the clock at which TextTrack HTML Cues should be refreshed.\n * @param {HTMLMediaElement} videoElement\n * @returns {Observable}\n */\nfunction generateClock(videoElement) {\n    var seeking$ = events_1.onSeeking$(videoElement);\n    var seeked$ = events_1.onSeeked$(videoElement);\n    var ended$ = events_1.onEnded$(videoElement);\n    var manualRefresh$ = Observable_1.Observable.merge(seeked$, ended$);\n    var autoRefresh$ = Observable_1.Observable\n        .interval(MAXIMUM_HTML_TEXT_TRACK_UPDATE_INTERVAL)\n        .startWith(null);\n    // TODO Better way to express that\n    return manualRefresh$\n        .startWith(null)\n        .switchMapTo(autoRefresh$.mapTo(true)\n        .takeUntil(seeking$)\n        .concat(Observable_1.Observable.of(false)));\n}\n/**\n * @param {Element} element\n * @param {Element|null} [child]\n */\nfunction safelyRemoveChild(element, child) {\n    if (child) {\n        try {\n            element.removeChild(child);\n        }\n        catch (e) {\n            log_1.default.warn(\"Can't remove text track: not in the element.\");\n        }\n    }\n}\n/**\n * Source buffer to display TextTracks in the given HTML element.\n * @class HTMLTextTrackSourceBuffer\n */\nvar HTMLTextTrackSourceBuffer = /** @class */ (function (_super) {\n    __extends(HTMLTextTrackSourceBuffer, _super);\n    /**\n     * @param {HTMLMediaElement} videoElement\n     * @param {HTMLElement} textTrackElement\n     */\n    function HTMLTextTrackSourceBuffer(videoElement, textTrackElement) {\n        var _this = this;\n        log_1.default.debug(\"creating html text track source buffer\");\n        _this = _super.call(this) || this;\n        _this._videoElement = videoElement;\n        _this._textTrackElement = textTrackElement;\n        _this._destroy$ = new Subject_1.Subject();\n        _this._buffer = new buffer_manager_1.default();\n        _this._currentElement = null;\n        generateClock(_this._videoElement)\n            .takeUntil(_this._destroy$)\n            .subscribe(function (shouldDisplay) {\n            if (!shouldDisplay) {\n                safelyRemoveChild(textTrackElement, _this._currentElement);\n                _this._currentElement = null;\n                return;\n            }\n            // to spread the time error, we divide the regular chosen interval.\n            // As the clock is also based on real video events, we cannot just\n            // divide by two the regular interval.\n            var time = Math.max(_this._videoElement.currentTime -\n                MAXIMUM_HTML_TEXT_TRACK_UPDATE_INTERVAL / 2000, 0);\n            var cue = _this._buffer.get(time);\n            if (!cue) {\n                safelyRemoveChild(textTrackElement, _this._currentElement);\n                _this._currentElement = null;\n                return;\n            }\n            else if (_this._currentElement === cue.element) {\n                return;\n            }\n            safelyRemoveChild(textTrackElement, _this._currentElement);\n            _this._currentElement = cue.element;\n            textTrackElement.appendChild(_this._currentElement);\n        });\n        return _this;\n    }\n    /**\n     * Append text tracks.\n     * @param {Object} data\n     * @param {string} data.type\n     * @param {string} data.data\n     * @param {string} data.language\n     * @param {Number} data.timescale\n     * @param {Number} data.start\n     * @param {Number} data.timeOffset\n     * @param {Number|undefined} data.end\n     */\n    HTMLTextTrackSourceBuffer.prototype._append = function (data) {\n        log_1.default.debug(\"appending new html text tracks\", data);\n        var timescale = data.timescale, // timescale for the start and end\n        timescaledStart = data.start, // exact beginning to which the track applies\n        timescaledEnd = data.end, // exact end to which the track applies\n        dataString = data.data, // text track content. Should be a string\n        type = data.type, // type of texttracks (e.g. \"ttml\" or \"vtt\")\n        language = data.language, // language the texttrack is in\n        timeOffset = data.timeOffset;\n        if (timescaledEnd && timescaledEnd - timescaledStart <= 0) {\n            // this is accepted for error resilience, just skip that case.\n            /* tslint:disable:max-line-length */\n            log_1.default.warn(\"Invalid text track appended: the start time is inferior or equal to the end time.\");\n            /* tslint:enable:max-line-length */\n            return;\n        }\n        var startTime = timescaledStart / timescale;\n        var endTime = timescaledEnd != null ?\n            timescaledEnd / timescale : undefined;\n        var cues = parsers_1.default(type, dataString, timeOffset, language);\n        var start = startTime;\n        var end = endTime != null ? endTime : cues[cues.length - 1].end;\n        this._buffer.insert(cues, start, end);\n        this.buffered.insert(start, end);\n    };\n    /**\n     * @param {Number} from\n     * @param {Number} to\n     */\n    HTMLTextTrackSourceBuffer.prototype._remove = function (from, to) {\n        log_1.default.debug(\"removing html text track data\", from, to);\n        this._buffer.remove(from, to);\n        this.buffered.remove(from, to);\n    };\n    /**\n     * Free up ressources from this sourceBuffer\n     */\n    HTMLTextTrackSourceBuffer.prototype._abort = function () {\n        log_1.default.debug(\"aborting html text track source buffer\");\n        this._destroy$.next();\n        this._destroy$.complete();\n        safelyRemoveChild(this._textTrackElement, this._currentElement);\n    };\n    return HTMLTextTrackSourceBuffer;\n}(abstract_source_buffer_1.default));\nexports.default = HTMLTextTrackSourceBuffer;\n\n\n//# sourceURL=webpack://RxPlayer/./src/core/source_buffers/text/html/index.ts?");

/***/ }),

/***/ "./src/core/source_buffers/text/html/parsers.ts":
/*!******************************************************!*\
  !*** ./src/core/source_buffers/text/html/parsers.ts ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar log_1 = __webpack_require__(/*! ../../../../utils/log */ \"./src/utils/log.ts\");\nvar htmlParsers = {};\n/* tslint:disable no-var-requires */\nif (true) {\n    htmlParsers.sami =\n        __webpack_require__(/*! ../../../../parsers/texttracks/sami/html.ts */ \"./src/parsers/texttracks/sami/html.ts\").default;\n}\nif (true) {\n    htmlParsers.ttml =\n        __webpack_require__(/*! ../../../../parsers/texttracks/ttml/html/index.ts */ \"./src/parsers/texttracks/ttml/html/index.ts\").default;\n}\nif (true) {\n    htmlParsers.srt =\n        __webpack_require__(/*! ../../../../parsers/texttracks/srt/html.ts */ \"./src/parsers/texttracks/srt/html.ts\").default;\n}\nif (true) {\n    htmlParsers.vtt =\n        __webpack_require__(/*! ../../../../parsers/texttracks/webvtt/html/index.ts */ \"./src/parsers/texttracks/webvtt/html/index.ts\").default;\n}\n/* tslint:enable no-var-requires */\n/**\n * @param {string} type\n * @param {string} data\n * @param {Number} timeOffset\n * @param {string} [language]\n * @returns {Array.<Object>}\n * @throws Error - Throw if no parser is found for the given type\n */\nfunction parseTextTrackToElements(type, data, timeOffset, language) {\n    log_1.default.debug(\"finding parser for html text tracks:\", type);\n    var parser = htmlParsers[type];\n    if (!parser) {\n        throw new Error(\"no parser found for the given text track\");\n    }\n    log_1.default.debug(\"parser found, parsing...\");\n    var parsed = parser(data, timeOffset, language);\n    log_1.default.debug(\"parsed successfully!\", parsed);\n    return parsed;\n}\nexports.default = parseTextTrackToElements;\n\n\n//# sourceURL=webpack://RxPlayer/./src/core/source_buffers/text/html/parsers.ts?");

/***/ }),

/***/ "./src/core/source_buffers/text/index.ts":
/*!***********************************************!*\
  !*** ./src/core/source_buffers/text/index.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// Feature switching the HTML TextTrack implementation\nvar HAS_HTML_MODE = true ||\n    true ||\n    true ||\n    true;\nvar HAS_NATIVE_MODE = true ||\n    true ||\n    true ||\n    true;\n/* tslint:disable no-var-requires */\nvar HTMLTextSourceBuffer = HAS_HTML_MODE ?\n    __webpack_require__(/*! ./html/index.ts */ \"./src/core/source_buffers/text/html/index.ts\").default :\n    function () {\n        throw new Error(\"Cannot display HTML subtitles: feature not activated.\");\n    };\nexports.HTMLTextSourceBuffer = HTMLTextSourceBuffer;\nvar NativeTextSourceBuffer = HAS_NATIVE_MODE ?\n    __webpack_require__(/*! ./native/index.ts */ \"./src/core/source_buffers/text/native/index.ts\").default :\n    function () {\n        throw new Error(\"Cannot display native subtitles: feature not activated.\");\n    };\nexports.NativeTextSourceBuffer = NativeTextSourceBuffer;\n\n\n//# sourceURL=webpack://RxPlayer/./src/core/source_buffers/text/index.ts?");

/***/ }),

/***/ "./src/core/source_buffers/text/native/index.ts":
/*!******************************************************!*\
  !*** ./src/core/source_buffers/text/native/index.ts ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar compat_1 = __webpack_require__(/*! ../../../../compat */ \"./src/compat/index.ts\");\nvar log_1 = __webpack_require__(/*! ../../../../utils/log */ \"./src/utils/log.ts\");\nvar abstract_source_buffer_1 = __webpack_require__(/*! ../../abstract_source_buffer */ \"./src/core/source_buffers/abstract_source_buffer.ts\");\nvar parsers_1 = __webpack_require__(/*! ./parsers */ \"./src/core/source_buffers/text/native/parsers.ts\");\n/**\n * Source buffer to display TextTracks in a <track> element, in the given\n * video element.\n * @class NativeTextTrackSourceBuffer\n * @extends AbstractSourceBuffer\n */\nvar NativeTextTrackSourceBuffer = /** @class */ (function (_super) {\n    __extends(NativeTextTrackSourceBuffer, _super);\n    /**\n     * @param {HTMLMediaElement} videoElement\n     * @param {Boolean} hideNativeSubtitle\n     */\n    function NativeTextTrackSourceBuffer(videoElement, hideNativeSubtitle) {\n        var _this = this;\n        log_1.default.debug(\"creating native text track source buffer\");\n        _this = _super.call(this) || this;\n        var _a = compat_1.addTextTrack(videoElement, hideNativeSubtitle), track = _a.track, trackElement = _a.trackElement;\n        _this._videoElement = videoElement;\n        _this._track = track;\n        _this._trackElement = trackElement;\n        return _this;\n    }\n    /**\n     * Append text tracks.\n     * @param {Object} data\n     * @param {string} data.data\n     * @param {string} data.language\n     * @param {Number} data.timescale\n     * @param {Number} data.start\n     * @param {Number} data.timeOffset\n     * @param {Number|undefined} data.end\n     */\n    NativeTextTrackSourceBuffer.prototype._append = function (data) {\n        log_1.default.debug(\"appending new native text tracks\", data);\n        var timescale = data.timescale, // timescale for the start and end\n        timescaledStart = data.start, // exact beginning to which the track applies\n        timescaledEnd = data.end, // exact end to which the track applies\n        dataString = data.data, // text track content. Should be a string\n        type = data.type, // type of texttracks (e.g. \"ttml\" or \"vtt\")\n        language = data.language, // language the texttrack is in\n        timeOffset = data.timeOffset;\n        if (timescaledEnd != null && timescaledEnd - timescaledStart <= 0) {\n            // this is accepted for error resilience, just skip that case.\n            log_1.default.warn(\"Invalid subtitles appended\");\n            return;\n        }\n        var startTime = timescaledStart / timescale;\n        var endTime = timescaledEnd != null ?\n            timescaledEnd / timescale : undefined;\n        var cues = parsers_1.default(type, dataString, timeOffset, language);\n        if (cues.length > 0) {\n            var firstCue = cues[0];\n            // NOTE(compat): cleanup all current cues if the newly added\n            // ones are in the past. this is supposed to fix an issue on\n            // IE/Edge.\n            var currentCues = this._track.cues;\n            if (currentCues.length > 0) {\n                if (firstCue.startTime < currentCues[currentCues.length - 1].startTime) {\n                    this._remove(firstCue.startTime, +Infinity);\n                }\n            }\n            for (var i = 0; i < cues.length; i++) {\n                this._track.addCue(cues[i]);\n            }\n            this.buffered.insert(startTime, endTime != null ? endTime : cues[cues.length - 1].endTime);\n        }\n        else if (endTime != null) {\n            this.buffered.insert(startTime, endTime);\n        }\n    };\n    /**\n     * @param {Number} from\n     * @param {Number} to\n     */\n    NativeTextTrackSourceBuffer.prototype._remove = function (from, to) {\n        log_1.default.debug(\"removing native text track data\", from, to);\n        var track = this._track;\n        var cues = track.cues;\n        for (var i = cues.length - 1; i >= 0; i--) {\n            var cue = cues[i];\n            var startTime = cue.startTime, endTime = cue.endTime;\n            if (startTime >= from && startTime <= to && endTime <= to) {\n                track.removeCue(cue);\n            }\n        }\n        this.buffered.remove(from, to);\n    };\n    NativeTextTrackSourceBuffer.prototype._abort = function () {\n        log_1.default.debug(\"aborting native text track source buffer\");\n        var _a = this, _trackElement = _a._trackElement, _videoElement = _a._videoElement;\n        if (_trackElement && _videoElement &&\n            _videoElement.hasChildNodes()) {\n            try {\n                _videoElement.removeChild(_trackElement);\n            }\n            catch (e) {\n                log_1.default.warn(\"Can't remove track element from the video\");\n            }\n        }\n        if (this._track) {\n            this._track.mode = \"disabled\";\n        }\n        if (this._trackElement) {\n            this._trackElement.innerHTML = \"\";\n        }\n    };\n    return NativeTextTrackSourceBuffer;\n}(abstract_source_buffer_1.default));\nexports.default = NativeTextTrackSourceBuffer;\n\n\n//# sourceURL=webpack://RxPlayer/./src/core/source_buffers/text/native/index.ts?");

/***/ }),

/***/ "./src/core/source_buffers/text/native/parsers.ts":
/*!********************************************************!*\
  !*** ./src/core/source_buffers/text/native/parsers.ts ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar log_1 = __webpack_require__(/*! ../../../../utils/log */ \"./src/utils/log.ts\");\nvar nativeParsers = {};\n/* tslint:disable no-var-requires */\nif (true) {\n    nativeParsers.vtt =\n        __webpack_require__(/*! ../../../../parsers/texttracks/webvtt/native.ts */ \"./src/parsers/texttracks/webvtt/native.ts\").default;\n}\nif (true) {\n    nativeParsers.ttml =\n        __webpack_require__(/*! ../../../../parsers/texttracks/ttml/native/index.ts */ \"./src/parsers/texttracks/ttml/native/index.ts\").default;\n}\nif (true) {\n    nativeParsers.sami =\n        __webpack_require__(/*! ../../../../parsers/texttracks/sami/native.ts */ \"./src/parsers/texttracks/sami/native.ts\").default;\n}\nif (true) {\n    nativeParsers.srt =\n        __webpack_require__(/*! ../../../../parsers/texttracks/srt/native.ts */ \"./src/parsers/texttracks/srt/native.ts\").default;\n}\n/* tslint:enable no-var-requires */\n/**\n * @param {string} type\n * @param {string} data\n * @param {Number} timeOffset\n * @param {string} [language]\n * @returns {Array.<VTTCue>}\n * @throws Error - Throw if no parser is found for the given type\n */\nfunction parseTextTrackToCues(type, data, timeOffset, language) {\n    log_1.default.debug(\"finding parser for native text tracks:\", type);\n    var parser = nativeParsers[type];\n    if (!parser) {\n        throw new Error(\"no parser found for the given text track\");\n    }\n    log_1.default.debug(\"parser found, parsing...\");\n    var parsed = parser(data, timeOffset, language);\n    log_1.default.debug(\"parsed successfully!\", parsed);\n    return parsed;\n}\nexports.default = parseTextTrackToCues;\n\n\n//# sourceURL=webpack://RxPlayer/./src/core/source_buffers/text/native/parsers.ts?");

/***/ }),

/***/ "./src/core/source_buffers/time_ranges.ts":
/*!************************************************!*\
  !*** ./src/core/source_buffers/time_ranges.ts ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar assert_1 = __webpack_require__(/*! ../../utils/assert */ \"./src/utils/assert.ts\");\nvar ranges_1 = __webpack_require__(/*! ../../utils/ranges */ \"./src/utils/ranges.ts\");\n/**\n * Simulate TimeRanges as returned by SourceBuffer.prototype.buffered.\n * Add an \"insert\" and \"remove\" methods to manually update it.\n * @class ManualTimeRanges\n */\nvar ManualTimeRanges = /** @class */ (function () {\n    function ManualTimeRanges() {\n        this._ranges = [];\n        this.length = 0;\n    }\n    ManualTimeRanges.prototype.insert = function (start, end) {\n        if (true) {\n            assert_1.default(start >= 0, \"invalid start time\");\n            assert_1.default(end - start > 0, \"invalid end time\");\n        }\n        ranges_1.insertInto(this._ranges, { start: start, end: end });\n        this.length = this._ranges.length;\n    };\n    ManualTimeRanges.prototype.remove = function (start, end) {\n        if (true) {\n            assert_1.default(start >= 0, \"invalid start time\");\n            assert_1.default(end - start > 0, \"invalid end time\");\n        }\n        var rangesToIntersect = [];\n        if (start > 0) {\n            rangesToIntersect.push({ start: 0, end: start });\n        }\n        if (end < Infinity) {\n            rangesToIntersect.push({ start: end, end: Infinity });\n        }\n        ranges_1.keepRangeIntersection(this._ranges, rangesToIntersect);\n        this.length = this._ranges.length;\n    };\n    ManualTimeRanges.prototype.start = function (index) {\n        if (index >= this._ranges.length) {\n            throw new Error(\"INDEX_SIZE_ERROR\");\n        }\n        return this._ranges[index].start;\n    };\n    ManualTimeRanges.prototype.end = function (index) {\n        if (index >= this._ranges.length) {\n            throw new Error(\"INDEX_SIZE_ERROR\");\n        }\n        return this._ranges[index].end;\n    };\n    return ManualTimeRanges;\n}());\nexports.default = ManualTimeRanges;\n\n\n//# sourceURL=webpack://RxPlayer/./src/core/source_buffers/time_ranges.ts?");

/***/ }),

/***/ "./src/core/stream/active_period_emitter.ts":
/*!**************************************************!*\
  !*** ./src/core/stream/active_period_emitter.ts ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * This file helps to keep track of the currently active Periods.\n * That is, Periods for which at least a single Buffer is currently active.\n *\n * It also keep track of the currently active period:\n * The first chronological period for which all types of buffers are active.\n */\nvar Observable_1 = __webpack_require__(/*! rxjs/Observable */ \"./node_modules/rxjs/Observable.js\");\nvar log_1 = __webpack_require__(/*! ../../utils/log */ \"./src/utils/log.ts\");\nvar sorted_list_1 = __webpack_require__(/*! ../../utils/sorted_list */ \"./src/utils/sorted_list.ts\");\nvar source_buffers_1 = __webpack_require__(/*! ../source_buffers */ \"./src/core/source_buffers/index.ts\");\n/**\n * Emit the active Period each times it changes.\n *\n * The active Period is the first Period (in chronological order) which has\n * a PeriodBuffer for every defined BUFFER_TYPES.\n *\n * Emit null if no Period has PeriodBuffers for all types.\n *\n * @example\n * For 4 BUFFER_TYPES: \"AUDIO\", \"VIDEO\", \"TEXT\" and \"IMAGE\":\n * ```\n *                     +-------------+\n *         Period 1    | Period 2    | Period 3\n * AUDIO   |=========| | |===      | |\n * VIDEO               | |=====    | |\n * TEXT    |(NO TEXT)| | |(NO TEXT)| | |====    |\n * IMAGE   |=========| | |=        | |\n *                     +-------------+\n *\n * The active Period here is Period 2 as Period 1 has no video PeriodBuffer.\n *\n * If we are missing a or multiple PeriodBuffers in the first chronological\n * Period, like that is the case here, it generally means that we are\n * currently switching between Periods.\n *\n * For here we are surely switching from Period 1 to Period 2 beginning by the\n * video PeriodBuffer. As every PeriodBuffer is ready for Period 2, we can\n * already inform that it is the current Period.\n * ```\n *\n * @param {Observable} addPeriodBuffer$ - Emit PeriodBuffer informations when\n * one is added.\n * @param {Observable} removePeriodBuffer$ - Emit PeriodBuffer informations when\n * one is removed.\n * @returns {Observable}\n */\nfunction ActivePeriodEmitter(addPeriodBuffer$, removePeriodBuffer$) {\n    var periodsList = new sorted_list_1.default(function (a, b) { return a.period.start - b.period.start; });\n    var onItemAdd$ = addPeriodBuffer$\n        .do(function (_a) {\n        var period = _a.period, type = _a.type;\n        // add or update the periodItem\n        var periodItem = periodsList.find(function (p) { return p.period === period; });\n        if (!periodItem) {\n            periodItem = {\n                period: period,\n                buffers: new Set(),\n            };\n            periodsList.add(periodItem);\n        }\n        if (periodItem.buffers.has(type)) {\n            log_1.default.warn(\"Buffer type \" + type + \" already added to the period\");\n        }\n        periodItem.buffers.add(type);\n    });\n    var onItemRemove$ = removePeriodBuffer$\n        .do(function (_a) {\n        var period = _a.period, type = _a.type;\n        if (!periodsList || periodsList.length() === 0) {\n            log_1.default.error(\"ActivePeriodStore: cannot remove, no period is active.\");\n            return;\n        }\n        var periodItem = periodsList.find(function (p) { return p.period === period; });\n        if (!periodItem) {\n            log_1.default.error(\"ActivePeriodStore: cannot remove, unknown period.\");\n            return;\n        }\n        periodItem.buffers.delete(type);\n        if (!periodItem.buffers.size) {\n            periodsList.removeFirst(periodItem);\n        }\n    });\n    return Observable_1.Observable.merge(onItemAdd$, onItemRemove$)\n        .map(function () {\n        var head = periodsList.head();\n        if (!head) {\n            return null;\n        }\n        var periodItem = periodsList.find(function (p) { return isBufferListFull(p.buffers); });\n        return periodItem != null ? periodItem.period : null;\n    }).distinctUntilChanged();\n}\nexports.default = ActivePeriodEmitter;\n/**\n * Returns true if the set of given buffer types is complete (has all possible\n * types).\n * @param {Set} bufferList\n * @returns {Boolean}\n */\nfunction isBufferListFull(bufferList) {\n    return bufferList.size >= source_buffers_1.BUFFER_TYPES.length;\n}\n\n\n//# sourceURL=webpack://RxPlayer/./src/core/stream/active_period_emitter.ts?");

/***/ }),

/***/ "./src/core/stream/buffers_handler.ts":
/*!********************************************!*\
  !*** ./src/core/stream/buffers_handler.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Observable_1 = __webpack_require__(/*! rxjs/Observable */ \"./node_modules/rxjs/Observable.js\");\nvar ReplaySubject_1 = __webpack_require__(/*! rxjs/ReplaySubject */ \"./node_modules/rxjs/ReplaySubject.js\");\nvar Subject_1 = __webpack_require__(/*! rxjs/Subject */ \"./node_modules/rxjs/Subject.js\");\nvar config_1 = __webpack_require__(/*! ../../config */ \"./src/config.ts\");\nvar errors_1 = __webpack_require__(/*! ../../errors */ \"./src/errors/index.ts\");\nvar array_includes_1 = __webpack_require__(/*! ../../utils/array-includes */ \"./src/utils/array-includes.ts\");\nvar initialization_segment_cache_1 = __webpack_require__(/*! ../../utils/initialization_segment_cache */ \"./src/utils/initialization_segment_cache.ts\");\nvar log_1 = __webpack_require__(/*! ../../utils/log */ \"./src/utils/log.ts\");\nvar sorted_list_1 = __webpack_require__(/*! ../../utils/sorted_list */ \"./src/utils/sorted_list.ts\");\nvar buffer_1 = __webpack_require__(/*! ../buffer */ \"./src/core/buffer/index.ts\");\nvar source_buffers_1 = __webpack_require__(/*! ../source_buffers */ \"./src/core/source_buffers/index.ts\");\nvar active_period_emitter_1 = __webpack_require__(/*! ./active_period_emitter */ \"./src/core/stream/active_period_emitter.ts\");\nvar stream_events_1 = __webpack_require__(/*! ./stream_events */ \"./src/core/stream/stream_events.ts\");\n/**\n * Create and manage the various Buffer Observables needed for the content to\n * stream:\n *\n *   - Create or dispose SourceBuffers depending on the chosen adaptations.\n *\n *   - Concatenate Buffers for adaptation from separate Periods at the right\n *     time, to allow smooth transitions between periods.\n *\n *   - Emit events as Period or Adaptations change or as new Period are\n *     prepared.\n *\n * Here multiple buffers can be created at the same time to allow smooth\n * transitions between periods.\n * To do this, we dynamically create or destroy buffers as they are needed.\n *\n * @param {Object} content\n * @param {Manifest} content.manifest\n * @param {Period} content.period - The first period to play in the content\n * @param {Observable} clock$ - Emit current informations about the content\n * being played. Also regulate the frequencies of the time the Buffer check\n * for new its status / new segments.\n * @param {BufferManager} bufferManager - Will be used to create new\n * AdaptationBuffers at will\n * @param {SourceBufferManager} sourceBufferManager - Will be used to lazily\n * create SourceBuffer instances associated with the current content.\n * @param {SegmentPipelinesManager} segmentPipelinesManager - Used to download\n * segments.\n * @param {WeakMapMemory} segmentBookkeeper - Allow to easily retrieve\n * or create a unique SegmentBookkeeper per SourceBuffer\n * @param {WeakMapMemory} garbageCollectors - Allows to easily create a\n * unique Garbage Collector per SourceBuffer\n * @param {Object} options\n * @param {Subject} errorStream - Subject to emit minor errors\n * @returns {Observable}\n *\n * TODO Special case for image Buffer, where we want data for EVERY active\n * periods.\n *\n * TODO Special garbage collection for text and image buffers, as we want to\n * clean it for potentially very long sessions.\n */\nfunction BuffersHandler(content, clock$, wantedBufferAhead$, bufferManager, sourceBufferManager, segmentPipelinesManager, segmentBookkeepers, garbageCollectors, options, errorStream) {\n    var manifest = content.manifest;\n    var firstPeriod = content.period;\n    // Initialize all native source buffers from the first period at the same\n    // time.\n    // We cannot lazily create native sourcebuffers since the spec does not\n    // allow adding them during playback.\n    //\n    // From https://w3c.github.io/media-source/#methods\n    //    For example, a user agent may throw a QuotaExceededError\n    //    exception if the media element has reached the HAVE_METADATA\n    //    readyState. This can occur if the user agent's media engine\n    //    does not support adding more tracks during playback.\n    createNativeSourceBuffersForPeriod(sourceBufferManager, firstPeriod);\n    var addPeriodBuffer$ = new Subject_1.Subject();\n    var removePeriodBuffer$ = new Subject_1.Subject();\n    /**\n     * Every PeriodBuffers for every possible types\n     * @type {Array.<Observable>}\n     */\n    var buffersArray = source_buffers_1.BUFFER_TYPES\n        .map(function (bufferType) {\n        return manageEveryBuffers(bufferType, firstPeriod)\n            .do(function (evt) {\n            if (evt.type === \"periodBufferReady\") {\n                addPeriodBuffer$.next(evt.value);\n            }\n            else if (evt.type === \"periodBufferCleared\") {\n                removePeriodBuffer$.next(evt.value);\n            }\n        }).share();\n    });\n    /**\n     * Emits the active Period every time it changes\n     * @type {Observable}\n     */\n    var activePeriod$ = active_period_emitter_1.default(addPeriodBuffer$, removePeriodBuffer$)\n        .filter(function (period) { return !!period; });\n    /**\n     * Emits the activePeriodChanged events every time the active Period changes.\n     * @type {Observable}\n     */\n    var activePeriodChanged$ = activePeriod$\n        .do(function (period) {\n        log_1.default.info(\"new active period\", period);\n    })\n        .map(function (period) { return stream_events_1.default.activePeriodChanged(period); });\n    /**\n     * Emits an \"end-of-stream\" event once every PeriodBuffer are complete.\n     * @type {Observable}\n     */\n    var streamHasEnded$ = buffersAreComplete$.apply(void 0, buffersArray).mapTo(stream_events_1.default.endOfStream());\n    return Observable_1.Observable.merge.apply(Observable_1.Observable, [activePeriodChanged$].concat(buffersArray, [streamHasEnded$]));\n    /**\n     * Manage creation and removal of Buffers for every Periods.\n     *\n     * Works by creating consecutive buffers through the\n     * manageConsecutivePeriodBuffers function, and restarting it when the clock\n     * goes out of the bounds of these buffers.\n     * @param {string} bufferType - e.g. \"audio\" or \"video\"\n     * @param {Period} basePeriod - Initial Period downloaded.\n     * @returns {Observable}\n     */\n    function manageEveryBuffers(bufferType, basePeriod) {\n        /**\n         * Keep a PeriodList for cases such as seeking ahead/before the\n         * buffers already created.\n         * When that happens, interrupt the previous buffers and create one back\n         * from the new initial period.\n         * @type {ConsecutivePeriodList}\n         */\n        var periodList = new sorted_list_1.default(function (a, b) { return a.start - b.start; });\n        /**\n         * Returns true if the given time is either:\n         *   - less than the start of the chronologically first Period\n         *   - more than the end of the chronologically last Period\n         * @param {number} time\n         * @returns {boolean}\n         */\n        function isOutOfPeriodList(time) {\n            var head = periodList.head();\n            var last = periodList.last();\n            if (head == null || last == null) { // if no period\n                return true;\n            }\n            return head.start > time ||\n                (last.end || Infinity) < time;\n        }\n        /**\n         * Destroy the current set of consecutive buffers.\n         * Used when the clocks goes out of the bounds of those, e.g. when the user\n         * seeks.\n         * We can then re-create consecutive buffers, from the new point in time.\n         * @type {Subject}\n         */\n        var destroyCurrentBuffers = new Subject_1.Subject();\n        var restartBuffers$ = clock$\n            .filter(function (_a) {\n            var currentTime = _a.currentTime, timeOffset = _a.timeOffset;\n            if (!manifest.getPeriodForTime(timeOffset + currentTime)) {\n                // TODO Manage out-of-manifest situations\n                return false;\n            }\n            return isOutOfPeriodList(timeOffset + currentTime);\n        })\n            .take(1)\n            .do(function (_a) {\n            var currentTime = _a.currentTime, timeOffset = _a.timeOffset;\n            log_1.default.info(\"Current position out of the bounds of the active periods,\" +\n                \"re-creating buffers.\", bufferType, currentTime + timeOffset);\n            destroyCurrentBuffers.next();\n        })\n            .mergeMap(function (_a) {\n            var currentTime = _a.currentTime, timeOffset = _a.timeOffset;\n            var newInitialPeriod = manifest.getPeriodForTime(currentTime + timeOffset);\n            if (newInitialPeriod == null) {\n                throw new errors_1.MediaError(\"MEDIA_TIME_NOT_FOUND\", null, true);\n            }\n            else {\n                // Note: For this to work, manageEveryBuffers should always emit the\n                // \"periodBufferReady\" event for the new InitialPeriod synchronously\n                return manageEveryBuffers(bufferType, newInitialPeriod);\n            }\n        });\n        var currentBuffers$ = manageConsecutivePeriodBuffers(bufferType, basePeriod, destroyCurrentBuffers).do(function (message) {\n            if (message.type === \"periodBufferReady\") {\n                periodList.add(message.value.period);\n            }\n            else if (message.type === \"periodBufferCleared\") {\n                periodList.removeFirst(message.value.period);\n            }\n        }).share(); // as always, with side-effects\n        return Observable_1.Observable.merge(currentBuffers$, restartBuffers$);\n    }\n    /**\n     * Manage creation and removal of Buffers for consecutive Periods.\n     *\n     * This function is called recursively for each successive Periods as needed.\n     *\n     * This function does not guarantee creation/destruction of the right Buffers\n     * when the user seeks or rewind in the content.\n     * It only manages regular playback, another layer should be used to manage\n     * those cases.\n     *\n     * You can know about buffers creation and destruction respectively through\n     * the \"periodBufferReady\" and \"periodBufferCleared\" events.\n     *\n     * The \"periodBufferReady\" related to the given period should be sent synchronously\n     * on subscription.\n     * Further \"periodBufferReady\" for further Periods should be sent each time the\n     * Buffer for the previous Buffer is full.\n     *\n     * Buffers for each Period are cleared (\"periodBufferCleared\" event) either:\n     *   - when it has finished to play (currentTime is after it)\n     *   - when one of the older Buffers becomes active again, in which case the\n     *     Buffers coming after will be cleared from the newest to the oldest.\n     *   - when the destroy$ observable emits, in which case every created Buffer\n     *     here will be cleared from the newest to the oldest.\n     *\n     * TODO The code here can surely be greatly simplified.\n     * @param {string} bufferType - e.g. \"audio\" or \"video\"\n     * @param {Period} basePeriod - Initial Period downloaded.\n     * @param {Observable} destroy$ - Emit when/if all created Buffer from this\n     * point should be destroyed.\n     * @returns {Observable}\n     */\n    function manageConsecutivePeriodBuffers(bufferType, basePeriod, destroy$) {\n        log_1.default.info(\"creating new Buffer for\", bufferType, basePeriod);\n        /**\n         * Emits the chosen adaptation for the current type.\n         * @type {ReplaySubject}\n         */\n        var adaptation$ = new ReplaySubject_1.ReplaySubject(1);\n        /**\n         * Emits the Period of the next Period Buffer when it can be created.\n         * @type {Subject}\n         */\n        var createNextPeriodBuffer$ = new Subject_1.Subject();\n        /**\n         * Emits when the Buffers for the next Periods should be destroyed, if\n         * created.\n         * @type {Subject}\n         */\n        var destroyNextBuffers$ = new Subject_1.Subject();\n        /**\n         * Emits when the current position goes over the end of the current buffer.\n         * @type {Subject}\n         */\n        var endOfCurrentBuffer$ = clock$\n            .filter(function (_a) {\n            var currentTime = _a.currentTime, timeOffset = _a.timeOffset;\n            return !!basePeriod.end && (currentTime + timeOffset) >= basePeriod.end;\n        });\n        /**\n         * Create Period Buffer for the next Period.\n         * @type {Observable}\n         */\n        var nextPeriodBuffer$ = createNextPeriodBuffer$\n            .exhaustMap(function (nextPeriod) {\n            return manageConsecutivePeriodBuffers(bufferType, nextPeriod, destroyNextBuffers$);\n        });\n        /**\n         * Allows to destroy each created Buffer, from the newest to the oldest,\n         * once destroy$ emits.\n         * @type {Observable}\n         */\n        var destroyAll$ = destroy$\n            .take(1)\n            .do(function () {\n            // first complete createNextBuffer$ to allow completion of the\n            // nextPeriodBuffer$ observable once every further Buffers have been\n            // cleared.\n            createNextPeriodBuffer$.complete();\n            // emit destruction signal to the next Buffer first\n            destroyNextBuffers$.next();\n            destroyNextBuffers$.complete(); // we do not need it anymore\n        }).share(); // share side-effects\n        /**\n         * Will emit when the current buffer should be destroyed.\n         * @type {Observable}\n         */\n        var killCurrentBuffer$ = Observable_1.Observable.merge(endOfCurrentBuffer$, destroyAll$);\n        var periodBuffer$ = createPeriodBuffer(bufferType, basePeriod, adaptation$)\n            .mergeMap(function (evt) {\n            var type = evt.type;\n            if (type === \"full-buffer\") {\n                /**\n                 * The Period coming just after the current one.\n                 * @type {Period|undefined}\n                 */\n                var nextPeriod = manifest.getPeriodAfter(basePeriod);\n                if (nextPeriod == null) {\n                    // no more period, emits  event\n                    return Observable_1.Observable.of(stream_events_1.default.bufferComplete(bufferType));\n                }\n                else {\n                    // current buffer is full, create the next one if not\n                    createNextPeriodBuffer$.next(nextPeriod);\n                }\n            }\n            else if (type === \"active-buffer\") {\n                // current buffer is active, destroy next buffer if created\n                destroyNextBuffers$.next();\n            }\n            return Observable_1.Observable.of(evt);\n        })\n            .share();\n        /**\n         * Buffer for the current Period.\n         * @type {Observable}\n         */\n        var currentBuffer$ = Observable_1.Observable.of(stream_events_1.default.periodBufferReady(bufferType, basePeriod, adaptation$))\n            .concat(periodBuffer$)\n            .takeUntil(killCurrentBuffer$)\n            .concat(Observable_1.Observable.of(stream_events_1.default.periodBufferCleared(bufferType, basePeriod))\n            .do(function () {\n            log_1.default.info(\"destroying buffer for\", bufferType, basePeriod);\n        }));\n        return Observable_1.Observable.merge(currentBuffer$, nextPeriodBuffer$, destroyAll$.ignoreElements());\n    }\n    /**\n     * Create single PeriodBuffer Observable:\n     *   - Lazily create (or reuse) a SourceBuffer for the given type.\n     *   - Create a Buffer linked to an Adaptation each time it changes, to\n     *     download and append the corresponding Segments in the SourceBuffer.\n     *   - Announce when the Buffer is full or is awaiting new Segments through\n     *     events\n     *\n     * /!\\ This Observable has multiple side-effects (creation of SourceBuffers,\n     * downloading and appending of Segments etc.) on subscription.\n     *\n     * @param {string} bufferType\n     * @param {Period} period - The period concerned\n     * @param {Observable} adaptation$ - Emit the chosen adaptation.\n     * Emit null to deactivate a type of adaptation\n     * @returns {Observable}\n     */\n    function createPeriodBuffer(bufferType, period, adaptation$) {\n        return adaptation$.switchMap(function (adaptation) {\n            if (adaptation == null) {\n                log_1.default.info(\"set no \" + bufferType + \" Adaptation\", period);\n                var cleanBuffer$ = void 0;\n                if (sourceBufferManager.has(bufferType)) {\n                    log_1.default.info(\"clearing previous \" + bufferType + \" SourceBuffer\");\n                    var _queuedSourceBuffer = sourceBufferManager.get(bufferType);\n                    cleanBuffer$ = _queuedSourceBuffer\n                        .removeBuffer({ start: period.start, end: period.end || Infinity })\n                        .mapTo(null);\n                }\n                else {\n                    cleanBuffer$ = Observable_1.Observable.of(null);\n                }\n                return cleanBuffer$\n                    .mapTo(stream_events_1.default.adaptationChange(bufferType, null, period))\n                    .concat(buffer_1.createFakeBuffer(clock$, wantedBufferAhead$, bufferType, { manifest: manifest, period: period }));\n            }\n            log_1.default.info(\"updating \" + bufferType + \" adaptation\", adaptation, period);\n            // 1 - create or reuse the SourceBuffer\n            var queuedSourceBuffer;\n            if (sourceBufferManager.has(bufferType)) {\n                log_1.default.info(\"reusing a previous SourceBuffer for the type\", bufferType);\n                queuedSourceBuffer = sourceBufferManager.get(bufferType);\n            }\n            else {\n                var codec = getFirstDeclaredMimeType(adaptation);\n                var sourceBufferOptions = bufferType === \"text\" ?\n                    options.textTrackOptions : undefined;\n                queuedSourceBuffer = sourceBufferManager\n                    .createSourceBuffer(bufferType, codec, sourceBufferOptions);\n            }\n            // 2 - create or reuse the associated BufferGarbageCollector and\n            // SegmentBookkeeper\n            var bufferGarbageCollector$ = garbageCollectors.get(queuedSourceBuffer);\n            var segmentBookkeeper = segmentBookkeepers.get(queuedSourceBuffer);\n            // TODO Clean previous QueuedSourceBuffer for previous content in the period\n            // // 3 - Clean possible content from a precedent adaptation in this period\n            // // (take the clock into account to avoid removing \"now\" for native sourceBuffers)\n            // // like:\n            // return clock$.pluck(\"currentTime\").take(1).mergeMap(currentTime => {\n            // })\n            // 3 - create the pipeline\n            var pipelineOptions = getPipelineOptions(bufferType, options.maxRetry, options.maxRetryOffline);\n            var pipeline = segmentPipelinesManager\n                .createPipeline(bufferType, pipelineOptions);\n            // 4 - create the Buffer\n            var adaptationBuffer$ = bufferManager.createBuffer(clock$, queuedSourceBuffer, segmentBookkeeper, pipeline, wantedBufferAhead$, { manifest: manifest, period: period, adaptation: adaptation }).catch(function (error) {\n                // non native buffer should not impact the stability of the\n                // player. ie: if a text buffer sends an error, we want to\n                // continue streaming without any subtitles\n                if (!source_buffers_1.default.isNative(bufferType)) {\n                    log_1.default.error(\"custom buffer: \", bufferType, \"has crashed. Aborting it.\", error);\n                    sourceBufferManager.disposeSourceBuffer(bufferType);\n                    errorStream.next(error);\n                    return buffer_1.createFakeBuffer(clock$, wantedBufferAhead$, bufferType, { manifest: manifest, period: period });\n                }\n                log_1.default.error(\"native buffer: \", bufferType, \"has crashed. Stopping playback.\", error);\n                throw error; // else, throw\n            });\n            // 5 - Return the buffer and send right events\n            return Observable_1.Observable\n                .of(stream_events_1.default.adaptationChange(bufferType, adaptation, period))\n                .concat(Observable_1.Observable.merge(adaptationBuffer$, bufferGarbageCollector$));\n        });\n    }\n}\nexports.default = BuffersHandler;\n/**\n * @param {string} bufferType\n * @param {number} retry\n * @param {number} offlineRetry\n * @returns {Object} - Options to give to the Pipeline\n */\nfunction getPipelineOptions(bufferType, retry, offlineRetry) {\n    var cache = array_includes_1.default([\"audio\", \"video\"], bufferType) ?\n        new initialization_segment_cache_1.default() : undefined;\n    var maxRetry;\n    var maxRetryOffline;\n    if (bufferType === \"image\") {\n        maxRetry = 0; // Deactivate BIF fetching if it fails\n    }\n    else {\n        maxRetry = retry != null ?\n            retry : config_1.default.DEFAULT_MAX_PIPELINES_RETRY_ON_ERROR;\n    }\n    maxRetryOffline = offlineRetry != null ?\n        offlineRetry : config_1.default.DEFAULT_MAX_PIPELINES_RETRY_ON_OFFLINE;\n    return {\n        cache: cache,\n        maxRetry: maxRetry,\n        maxRetryOffline: maxRetryOffline,\n    };\n}\n/**\n * Returns an Observable which emits ``undefined`` and complete when all\n * buffers given are _complete_.\n *\n * A PeriodBuffer for a given type is considered _complete_ when both of these\n * conditions are true:\n *   - it is the last PeriodBuffer in the content for the given type\n *   - it has finished downloading segments (it is _full_)\n *\n * Simply put a _complete_ PeriodBuffer for a given type means that every\n * segments needed for this Buffer have been downloaded.\n *\n * When the Observable returned here emits, every Buffer are finished.\n * @param {...Observable} buffers\n * @returns {Observable}\n */\nfunction buffersAreComplete$() {\n    var buffers = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        buffers[_i] = arguments[_i];\n    }\n    /**\n     * Array of Observables linked to the Array of Buffers which emit:\n     *   - true when the corresponding buffer is considered _complete_.\n     *   - false when the corresponding buffer is considered _active_.\n     * @type {Array.<Observable>}\n     */\n    var isCompleteArray = buffers\n        .map(function (buffer) {\n        return buffer\n            .filter(function (evt) {\n            return evt.type === \"complete-buffer\" || evt.type === \"active-buffer\";\n        })\n            .map(function (evt) { return evt.type === \"complete-buffer\"; })\n            .startWith(false)\n            .distinctUntilChanged();\n    });\n    return Observable_1.Observable.combineLatest.apply(Observable_1.Observable, isCompleteArray).filter(function (areComplete) {\n        return areComplete.every(function (isComplete) { return isComplete; });\n    })\n        .mapTo(undefined);\n}\n/**\n * Get mimetype string of the first representation declared in the given\n * adaptation.\n * @param {Adaptation} adaptation\n * @returns {string}\n */\nfunction getFirstDeclaredMimeType(adaptation) {\n    var representations = adaptation.representations;\n    return (representations[0] && representations[0].getMimeTypeString()) || \"\";\n}\n/**\n * Create all native SourceBuffers needed for a given Period.\n *\n * Native Buffers have the particulary to need to be created at the beginning of\n * the content.\n * Custom source buffers (entirely managed in JS) can generally be created and\n * disposed at will during the lifecycle of the content.\n * @param {SourceBufferManager} sourceBufferManager\n * @param {Period} period\n */\nfunction createNativeSourceBuffersForPeriod(sourceBufferManager, period) {\n    Object.keys(period.adaptations).forEach(function (bufferType) {\n        if (source_buffers_1.default.isNative(bufferType)) {\n            var adaptations = period.adaptations[bufferType] || [];\n            var representations = adaptations ?\n                adaptations[0].representations : [];\n            if (representations.length) {\n                var codec = representations[0].getMimeTypeString();\n                sourceBufferManager.createSourceBuffer(bufferType, codec);\n            }\n        }\n    });\n}\n\n\n//# sourceURL=webpack://RxPlayer/./src/core/stream/buffers_handler.ts?");

/***/ }),

/***/ "./src/core/stream/clock.ts":
/*!**********************************!*\
  !*** ./src/core/stream/clock.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar objectAssign = __webpack_require__(/*! object-assign */ \"./node_modules/object-assign/index.js\");\nvar Observable_1 = __webpack_require__(/*! rxjs/Observable */ \"./node_modules/rxjs/Observable.js\");\nvar timings_1 = __webpack_require__(/*! ../../manifest/timings */ \"./src/manifest/timings.ts\");\n/**\n * Create clock$ and seekings$ Observables:\n *   - clock$ is the given clock$ observable with added informations.\n *   - seekings$ emits each time the player go in a seeking state.\n * @param {Object} manifest\n * @param {Observable} streamClock$\n * @param {Observable} initialSeek$\n * @param {Number} startTime\n * @returns {Object}\n */\nfunction createBufferClock(manifest, streamClock$, initialSeek$, startTime) {\n    /**\n     * Time offset is an offset to add to the timing's current time to have\n     * the \"real\" position.\n     * For now, this is seen when the video has not yet seeked to its initial\n     * position, the currentTime will most probably be 0 where the effective\n     * starting position will be _startTime_.\n     * Thus we initially set a timeOffset equal to startTime.\n     * @type {Number}\n     */\n    var timeOffset = startTime;\n    var updateTimeOffset$ = initialSeek$\n        .take(1)\n        .do(function () {\n        timeOffset = 0; // (initial seek performed)\n    })\n        .ignoreElements();\n    var clock$ = streamClock$\n        .map(function (timing) {\n        return objectAssign({\n            liveGap: manifest.isLive ?\n                timings_1.getMaximumBufferPosition(manifest) - timing.currentTime :\n                Infinity,\n            timeOffset: timeOffset,\n        }, timing);\n    });\n    return Observable_1.Observable.merge(clock$, updateTimeOffset$);\n}\nexports.default = createBufferClock;\n\n\n//# sourceURL=webpack://RxPlayer/./src/core/stream/clock.ts?");

/***/ }),

/***/ "./src/core/stream/create_media_source.ts":
/*!************************************************!*\
  !*** ./src/core/stream/create_media_source.ts ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Observable_1 = __webpack_require__(/*! rxjs/Observable */ \"./node_modules/rxjs/Observable.js\");\nvar compat_1 = __webpack_require__(/*! ../../compat */ \"./src/compat/index.ts\");\nvar MediaError_1 = __webpack_require__(/*! ../../errors/MediaError */ \"./src/errors/MediaError.ts\");\nvar log_1 = __webpack_require__(/*! ../../utils/log */ \"./src/utils/log.ts\");\n/**\n * Side effect that set the media duration in the mediaSource.\n *\n * @param {MediaSource} mediaSource\n * @param {number} duration\n */\nfunction setDurationToMediaSource(mediaSource, duration) {\n    var newDuration = duration === Infinity ?\n        Number.MAX_VALUE : duration;\n    if (mediaSource.duration !== newDuration) {\n        log_1.default.info(\"set duration\", mediaSource.duration);\n        mediaSource.duration = newDuration;\n    }\n}\nexports.setDurationToMediaSource = setDurationToMediaSource;\n/**\n * Dispose of ressources taken by the MediaSource:\n *   - Clear the MediaSource' SourceBuffers\n *   - Clear the video's src (stop the video)\n *   - Revoke MediaSource' URL\n * @param {HTMLMediaElement} video\n * @param {MediaSource|null} mediaSource\n * @param {string|null} mediaSourceURL\n */\nfunction resetMediaSource(video, mediaSource, mediaSourceURL) {\n    if (mediaSource && mediaSource.readyState !== \"closed\") {\n        var readyState = mediaSource.readyState, sourceBuffers = mediaSource.sourceBuffers;\n        for (var i = sourceBuffers.length - 1; i >= 0; i--) {\n            var sourceBuffer = sourceBuffers[i];\n            try {\n                if (readyState === \"open\") {\n                    log_1.default.info(\"removing SourceBuffer from mediaSource\", sourceBuffer);\n                    sourceBuffer.abort();\n                }\n                mediaSource.removeSourceBuffer(sourceBuffer);\n            }\n            catch (e) {\n                log_1.default.warn(\"error while disposing SourceBuffer\", e);\n            }\n        }\n        if (sourceBuffers.length) {\n            log_1.default.warn(\"not all SourceBuffers could have been removed.\");\n        }\n    }\n    compat_1.clearElementSrc(video);\n    if (mediaSourceURL) {\n        try {\n            log_1.default.debug(\"revoking previous URL\");\n            URL.revokeObjectURL(mediaSourceURL);\n        }\n        catch (e) {\n            log_1.default.warn(\"error while revoking the media source URL\", e);\n        }\n    }\n}\nexports.resetMediaSource = resetMediaSource;\n/**\n * Create, on subscription, a MediaSource instance and attach it to the given\n * video element's src attribute.\n *\n * Returns an Observable which emits the MediaSource when created and attached\n * to the video element.\n * This Observable never completes. It can throw if MediaSource is not\n * available in the current environment.\n *\n * On unsubscription, the video.src is cleaned, MediaSource sourceBuffers and\n * customBuffers are aborted and some minor cleaning is done.\n *\n * @param {HTMLMediaElement} video\n * @returns {Observable}\n */\nfunction createMediaSource(video) {\n    return Observable_1.Observable.create(function (observer) {\n        if (!compat_1.MediaSource_) {\n            throw new MediaError_1.default(\"MEDIA_SOURCE_NOT_SUPPORTED\", null, true);\n        }\n        // make sure the media has been correctly reset\n        resetMediaSource(video, null, video.src || null);\n        log_1.default.info(\"creating MediaSource\");\n        var mediaSource = new compat_1.MediaSource_();\n        var objectURL = URL.createObjectURL(mediaSource);\n        log_1.default.info(\"attaching MediaSource URL to video element\", objectURL);\n        video.src = objectURL;\n        observer.next(mediaSource);\n        return function () {\n            resetMediaSource(video, mediaSource, objectURL);\n        };\n    });\n}\nexports.default = createMediaSource;\n\n\n//# sourceURL=webpack://RxPlayer/./src/core/stream/create_media_source.ts?");

/***/ }),

/***/ "./src/core/stream/directfile.ts":
/*!***************************************!*\
  !*** ./src/core/stream/directfile.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Observable_1 = __webpack_require__(/*! rxjs/Observable */ \"./node_modules/rxjs/Observable.js\");\nvar Subject_1 = __webpack_require__(/*! rxjs/Subject */ \"./node_modules/rxjs/Subject.js\");\nvar compat_1 = __webpack_require__(/*! ../../compat */ \"./src/compat/index.ts\");\nvar log_1 = __webpack_require__(/*! ../../utils/log */ \"./src/utils/log.ts\");\nvar eme_1 = __webpack_require__(/*! ../eme */ \"./src/core/eme/index.ts\");\nvar media_error_handler_1 = __webpack_require__(/*! ./media_error_handler */ \"./src/core/stream/media_error_handler.ts\");\nvar speed_manager_1 = __webpack_require__(/*! ./speed_manager */ \"./src/core/stream/speed_manager.ts\");\nvar stalling_manager_1 = __webpack_require__(/*! ./stalling_manager */ \"./src/core/stream/stalling_manager.ts\");\nvar stream_events_1 = __webpack_require__(/*! ./stream_events */ \"./src/core/stream/stream_events.ts\");\nvar video_events_1 = __webpack_require__(/*! ./video_events */ \"./src/core/stream/video_events.ts\");\n/**\n * @param {HTMLMediaElement} mediaElement\n * @returns {number}\n */\nfunction getDirectFileInitialTime(mediaElement, startAt) {\n    if (!startAt) {\n        return 0;\n    }\n    if (startAt.position != null) {\n        return startAt.position;\n    }\n    else if (startAt.wallClockTime != null) {\n        return startAt.wallClockTime;\n    }\n    else if (startAt.fromFirstPosition != null) {\n        return startAt.fromFirstPosition;\n    }\n    var duration = mediaElement.duration;\n    if (!duration || !isFinite(duration)) {\n        log_1.default.warn(\"startAt.fromLastPosition set but no known duration, \" +\n            \"beginning at 0.\");\n        return 0;\n    }\n    if (startAt.fromLastPosition) {\n        return Math.max(0, duration + startAt.fromLastPosition);\n    }\n    else if (startAt.percentage != null) {\n        var percentage = startAt.percentage;\n        if (percentage >= 100) {\n            return duration;\n        }\n        else if (percentage <= 0) {\n            return 0;\n        }\n        var ratio = +percentage / 100;\n        return duration * ratio;\n    }\n    return 0;\n}\n/**\n * Initialize stream playback by merging all Observables that are required to\n * make the system cooperate.\n * @param {MediaSource} mediaSource\n * @returns {Observable}\n */\nfunction StreamDirectFile(_a) {\n    var autoPlay = _a.autoPlay, clock$ = _a.clock$, keySystems = _a.keySystems, mediaElement = _a.mediaElement, speed$ = _a.speed$, startAt = _a.startAt, url = _a.url;\n    /**\n     * Observable through which all warning events will be sent.\n     * @type {Subject}\n     */\n    var warning$ = new Subject_1.Subject();\n    var warningEvents$ = warning$.map(stream_events_1.default.warning);\n    compat_1.clearElementSrc(mediaElement);\n    log_1.default.debug(\"calculating initial time\");\n    var initialTime = function () {\n        return getDirectFileInitialTime(mediaElement, startAt);\n    };\n    log_1.default.debug(\"initial time calculated:\", initialTime);\n    var _b = video_events_1.default(mediaElement, initialTime, autoPlay), initialSeek$ = _b.initialSeek$, loadAndPlay$ = _b.loadAndPlay$;\n    /**\n     * Create EME Manager, an observable which will manage every EME-related\n     * issue.\n     * @type {Observable}\n     */\n    var emeManager$ = eme_1.default(mediaElement, keySystems, warning$);\n    /**\n     * Translate errors coming from the video element into RxPlayer errors\n     * through a throwing Observable.\n     * @type {Observable}\n     */\n    var mediaErrorHandler$ = media_error_handler_1.default(mediaElement);\n    /**\n     * Create Speed Manager, an observable which will set the speed set by the\n     * user on the video element while pausing a little longer while the buffer\n     * is stalled.\n     * @type {Observable}\n     */\n    var speedManager$ = speed_manager_1.default(mediaElement, speed$, clock$, {\n        pauseWhenStalled: true,\n    }).map(stream_events_1.default.speedChanged);\n    /**\n     * Create Stalling Manager, an observable which will try to get out of\n     * various infinite stalling issues\n     * @type {Observable}\n     */\n    var stallingManager$ = stalling_manager_1.default(mediaElement, clock$)\n        .map(stream_events_1.default.stalled);\n    var loadedEvent$ = loadAndPlay$\n        .mapTo(stream_events_1.default.loaded());\n    var linkURL$ = compat_1.setElementSrc$(mediaElement, url)\n        .ignoreElements();\n    var mutedInitialSeek$ = initialSeek$\n        .ignoreElements();\n    var directFile$ = Observable_1.Observable.merge(loadedEvent$, mutedInitialSeek$, emeManager$, // TODO RxJS do something weird here\n    mediaErrorHandler$, // TODO RxJS do something weird here\n    speedManager$, stallingManager$, linkURL$);\n    return Observable_1.Observable.merge(directFile$, warningEvents$);\n}\nexports.default = StreamDirectFile;\n\n\n//# sourceURL=webpack://RxPlayer/./src/core/stream/directfile.ts?");

/***/ }),

/***/ "./src/core/stream/end_of_stream.ts":
/*!******************************************!*\
  !*** ./src/core/stream/end_of_stream.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar retry_1 = __webpack_require__(/*! ../../utils/retry */ \"./src/utils/retry.ts\");\n/**\n * @param {MediaSource} mediaSource\n */\nfunction triggerEndOfStream(mediaSource) {\n    mediaSource.endOfStream();\n}\n/**\n * Try to call endOfStream on the mediaSource multiple times.\n * @param {MediaSource} mediaSource\n * @returns {Observable}\n */\nfunction triggerEndOfStreamWithRetries(mediaSource) {\n    var retryOptions = {\n        totalRetry: 10,\n        retryDelay: 100,\n        shouldRetry: function () { return mediaSource.readyState !== \"ended\"; },\n    };\n    return retry_1.retryFuncWithBackoff(function () { return triggerEndOfStream(mediaSource); }, retryOptions)\n        .ignoreElements();\n}\nexports.default = triggerEndOfStreamWithRetries;\n\n\n//# sourceURL=webpack://RxPlayer/./src/core/stream/end_of_stream.ts?");

/***/ }),

/***/ "./src/core/stream/garbage_collector.ts":
/*!**********************************************!*\
  !*** ./src/core/stream/garbage_collector.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Observable_1 = __webpack_require__(/*! rxjs/Observable */ \"./node_modules/rxjs/Observable.js\");\nvar log_1 = __webpack_require__(/*! ../../utils/log */ \"./src/utils/log.ts\");\nvar ranges_1 = __webpack_require__(/*! ../../utils/ranges */ \"./src/utils/ranges.ts\");\n/**\n * Perform cleaning of the buffer according to the values set by the user\n * at each clock tick and each times the maxBufferBehind/maxBufferAhead values\n * change.\n *\n * @param {Object} opt\n * @returns {Observable}\n */\nfunction BufferGarbageCollector(_a) {\n    var queuedSourceBuffer = _a.queuedSourceBuffer, clock$ = _a.clock$, maxBufferBehind$ = _a.maxBufferBehind$, maxBufferAhead$ = _a.maxBufferAhead$;\n    return Observable_1.Observable.combineLatest(clock$, maxBufferBehind$, maxBufferAhead$)\n        .mergeMap(function (_a) {\n        var currentTime = _a[0], maxBufferBehind = _a[1], maxBufferAhead = _a[2];\n        return clearBuffer(queuedSourceBuffer, currentTime, maxBufferBehind, maxBufferAhead);\n    });\n}\nexports.default = BufferGarbageCollector;\n/**\n * Remove buffer from the browser's memory based on the user's\n * maxBufferAhead / maxBufferBehind settings.\n *\n * Normally, the browser garbage-collect automatically old-added chunks of\n * buffer date when memory is scarce. However, you might want to control\n * the size of memory allocated. This function takes the current position\n * and a \"depth\" behind and ahead wanted for the buffer, in seconds.\n *\n * Anything older than the depth will be removed from the buffer.\n * @param {QueuedSourceBuffer} qSourceBuffer\n * @param {Number} position - The current position\n * @param {Number} maxBufferBehind\n * @param {Number} maxBufferAhead\n * @returns {Observable}\n */\nfunction clearBuffer(qSourceBuffer, position, maxBufferBehind, maxBufferAhead) {\n    if (!isFinite(maxBufferBehind) && !isFinite(maxBufferAhead)) {\n        return Observable_1.Observable.empty();\n    }\n    var cleanedupRanges = [];\n    var _a = ranges_1.getInnerAndOuterTimeRanges(qSourceBuffer.getBuffered(), position), innerRange = _a.innerRange, outerRanges = _a.outerRanges;\n    var collectBufferBehind = function () {\n        if (!isFinite(maxBufferBehind)) {\n            return;\n        }\n        // begin from the oldest\n        for (var i = 0; i < outerRanges.length; i++) {\n            var outerRange = outerRanges[i];\n            if (position - maxBufferBehind >= outerRange.end) {\n                cleanedupRanges.push(outerRange);\n            }\n            else if (position >= outerRange.end &&\n                position - maxBufferBehind > outerRange.start &&\n                position - maxBufferBehind < outerRange.end) {\n                cleanedupRanges.push({\n                    start: outerRange.start,\n                    end: position - maxBufferBehind,\n                });\n            }\n        }\n        if (innerRange) {\n            if (position - maxBufferBehind > innerRange.start) {\n                cleanedupRanges.push({\n                    start: innerRange.start,\n                    end: position - maxBufferBehind,\n                });\n            }\n        }\n    };\n    var collectBufferAhead = function () {\n        if (!isFinite(maxBufferAhead)) {\n            return;\n        }\n        // begin from the oldest\n        for (var i = 0; i < outerRanges.length; i++) {\n            var outerRange = outerRanges[i];\n            if (position + maxBufferAhead <= outerRange.start) {\n                cleanedupRanges.push(outerRange);\n            }\n            else if (position <= outerRange.start &&\n                position + maxBufferAhead < outerRange.end &&\n                position + maxBufferAhead > outerRange.start) {\n                cleanedupRanges.push({\n                    start: position + maxBufferAhead,\n                    end: outerRange.end,\n                });\n            }\n        }\n        if (innerRange) {\n            if (position + maxBufferAhead < innerRange.end) {\n                cleanedupRanges.push({\n                    start: position + maxBufferAhead,\n                    end: innerRange.end,\n                });\n            }\n        }\n    };\n    collectBufferBehind();\n    collectBufferAhead();\n    var clean$ = Observable_1.Observable.from(cleanedupRanges.map(function (range) {\n        log_1.default.debug(\"cleaning range from source buffer\", range);\n        return qSourceBuffer.removeBuffer(range);\n    }))\n        .concatAll()\n        .ignoreElements();\n    return clean$; // ignoreElements == the Observerable never emits\n}\n\n\n//# sourceURL=webpack://RxPlayer/./src/core/stream/garbage_collector.ts?");

/***/ }),

/***/ "./src/core/stream/get_initial_time.ts":
/*!*********************************************!*\
  !*** ./src/core/stream/get_initial_time.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar config_1 = __webpack_require__(/*! ../../config */ \"./src/config.ts\");\nvar timings_1 = __webpack_require__(/*! ../../manifest/timings */ \"./src/manifest/timings.ts\");\nvar DEFAULT_LIVE_GAP = config_1.default.DEFAULT_LIVE_GAP;\n/**\n * Returns the calculated initial time for the stream described by the given\n * manifest:\n *   1. if a start time is defined by user, calculate video starting time from\n *      the manifest informations\n *   2. else if the video is live, use the live edge and suggested delays from\n *      it\n *   3. else returns the minimum time announced in the manifest\n *\n * @param {Manifest} manifest\n * @param {Object} startAt\n * @returns {Number}\n */\nfunction getInitialTime(manifest, startAt) {\n    if (startAt) {\n        var _a = timings_1.getBufferLimits(manifest), min = _a[0], max = _a[1];\n        if (startAt.position != null) {\n            return Math.max(Math.min(startAt.position, max), min);\n        }\n        else if (startAt.wallClockTime != null) {\n            var position = manifest.isLive ?\n                startAt.wallClockTime - (manifest.availabilityStartTime || 0) :\n                startAt.wallClockTime;\n            return Math.max(Math.min(position, max), min);\n        }\n        else if (startAt.fromFirstPosition != null) {\n            var fromFirstPosition = startAt.fromFirstPosition;\n            return fromFirstPosition <= 0 ?\n                min : Math.min(min + fromFirstPosition, max);\n        }\n        else if (startAt.fromLastPosition != null) {\n            var fromLastPosition = startAt.fromLastPosition;\n            return fromLastPosition >= 0 ?\n                max : Math.max(min, max + fromLastPosition);\n        }\n        else if (startAt.percentage != null) {\n            var percentage = startAt.percentage;\n            if (percentage > 100) {\n                return max;\n            }\n            else if (percentage < 0) {\n                return min;\n            }\n            var ratio = +percentage / 100;\n            var extent = max - min;\n            return min + extent * ratio;\n        }\n    }\n    if (manifest.isLive) {\n        var sgp = manifest.suggestedPresentationDelay;\n        return timings_1.getMaximumBufferPosition(manifest) -\n            (sgp == null ? DEFAULT_LIVE_GAP : sgp);\n    }\n    return timings_1.getMinimumBufferPosition(manifest);\n}\nexports.default = getInitialTime;\n\n\n//# sourceURL=webpack://RxPlayer/./src/core/stream/get_initial_time.ts?");

/***/ }),

/***/ "./src/core/stream/index.ts":
/*!**********************************!*\
  !*** ./src/core/stream/index.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Observable_1 = __webpack_require__(/*! rxjs/Observable */ \"./node_modules/rxjs/Observable.js\");\nvar Subject_1 = __webpack_require__(/*! rxjs/Subject */ \"./node_modules/rxjs/Subject.js\");\nvar config_1 = __webpack_require__(/*! ../../config */ \"./src/config.ts\");\nvar log_1 = __webpack_require__(/*! ../../utils/log */ \"./src/utils/log.ts\");\nvar rx_throttle_1 = __webpack_require__(/*! ../../utils/rx-throttle */ \"./src/utils/rx-throttle.ts\");\nvar weak_map_memory_1 = __webpack_require__(/*! ../../utils/weak_map_memory */ \"./src/utils/weak_map_memory.ts\");\nvar events_1 = __webpack_require__(/*! ../../compat/events */ \"./src/compat/events.ts\");\nvar errors_1 = __webpack_require__(/*! ../../errors */ \"./src/errors/index.ts\");\nvar abr_1 = __webpack_require__(/*! ../abr */ \"./src/core/abr/index.ts\");\nvar buffer_1 = __webpack_require__(/*! ../buffer */ \"./src/core/buffer/index.ts\");\nvar eme_1 = __webpack_require__(/*! ../eme */ \"./src/core/eme/index.ts\");\nvar pipelines_1 = __webpack_require__(/*! ../pipelines */ \"./src/core/pipelines/index.ts\");\nvar source_buffers_1 = __webpack_require__(/*! ../source_buffers */ \"./src/core/source_buffers/index.ts\");\nvar buffers_handler_1 = __webpack_require__(/*! ./buffers_handler */ \"./src/core/stream/buffers_handler.ts\");\nvar clock_1 = __webpack_require__(/*! ./clock */ \"./src/core/stream/clock.ts\");\nvar create_media_source_1 = __webpack_require__(/*! ./create_media_source */ \"./src/core/stream/create_media_source.ts\");\nvar end_of_stream_1 = __webpack_require__(/*! ./end_of_stream */ \"./src/core/stream/end_of_stream.ts\");\nvar garbage_collector_1 = __webpack_require__(/*! ./garbage_collector */ \"./src/core/stream/garbage_collector.ts\");\nvar get_initial_time_1 = __webpack_require__(/*! ./get_initial_time */ \"./src/core/stream/get_initial_time.ts\");\nvar live_events_handler_1 = __webpack_require__(/*! ./live_events_handler */ \"./src/core/stream/live_events_handler.ts\");\nvar media_error_handler_1 = __webpack_require__(/*! ./media_error_handler */ \"./src/core/stream/media_error_handler.ts\");\nvar segment_bookkeeper_1 = __webpack_require__(/*! ./segment_bookkeeper */ \"./src/core/stream/segment_bookkeeper.ts\");\nexports.SegmentBookkeeper = segment_bookkeeper_1.default;\nvar speed_manager_1 = __webpack_require__(/*! ./speed_manager */ \"./src/core/stream/speed_manager.ts\");\nvar stalling_manager_1 = __webpack_require__(/*! ./stalling_manager */ \"./src/core/stream/stalling_manager.ts\");\nvar stream_events_1 = __webpack_require__(/*! ./stream_events */ \"./src/core/stream/stream_events.ts\");\nvar video_events_1 = __webpack_require__(/*! ./video_events */ \"./src/core/stream/video_events.ts\");\nfunction getManifestPipelineOptions(networkConfig) {\n    return {\n        maxRetry: networkConfig.manifestRetry != null ?\n            networkConfig.manifestRetry : config_1.default.DEFAULT_MAX_MANIFEST_REQUEST_RETRY,\n        maxRetryOffline: networkConfig.offlineRetry != null ?\n            networkConfig.offlineRetry : config_1.default.DEFAULT_MAX_PIPELINES_RETRY_ON_ERROR,\n    };\n}\n/**\n * Central part of the player. Play a given stream described by the given\n * manifest with given options.\n *\n * On subscription:\n *  - Creates the MediaSource and attached sourceBuffers instances.\n *  - download the content's manifest\n *  - Perform EME management if needed\n *  - get Buffers for each active adaptations.\n *  - give choice of the adaptation to the caller (e.g. to choose a language)\n *  - returns Observable emitting notifications about the stream lifecycle.\n *\n * @param {Object} args\n * @returns {Observable}\n */\nfunction Stream(_a) {\n    var adaptiveOptions = _a.adaptiveOptions, autoPlay = _a.autoPlay, bufferOptions = _a.bufferOptions, clock$ = _a.clock$, keySystems = _a.keySystems, networkConfig = _a.networkConfig, speed$ = _a.speed$, startAt = _a.startAt, supplementaryImageTracks = _a.supplementaryImageTracks, // eventual manually added images\n    supplementaryTextTracks = _a.supplementaryTextTracks, // eventual manually added subtitles\n    textTrackOptions = _a.textTrackOptions, transport = _a.transport, url = _a.url, videoElement = _a.videoElement;\n    var wantedBufferAhead$ = bufferOptions.wantedBufferAhead$, maxBufferAhead$ = bufferOptions.maxBufferAhead$, maxBufferBehind$ = bufferOptions.maxBufferBehind$;\n    /**\n     * Observable through which all warning events will be sent.\n     * @type {Subject}\n     */\n    var warning$ = new Subject_1.Subject();\n    /**\n     * Fetch and parse the manifest from the URL given.\n     * Throttled to avoid doing multiple simultaneous requests.\n     * @param {string} url - the manifest url\n     * @returns {Observable} - the parsed manifest\n     */\n    var fetchManifest = rx_throttle_1.default(pipelines_1.createManifestPipeline(transport, getManifestPipelineOptions(networkConfig), warning$, supplementaryTextTracks, supplementaryImageTracks));\n    /**\n     * Keep track of a unique BufferGarbageCollector created per\n     * QueuedSourceBuffer.\n     * @type {WeakMapMemory}\n     */\n    var garbageCollectors = new weak_map_memory_1.default(function (qSourceBuffer) {\n        return garbage_collector_1.default({\n            queuedSourceBuffer: qSourceBuffer,\n            clock$: clock$.map(function (tick) { return tick.currentTime; }),\n            maxBufferBehind$: maxBufferBehind$,\n            maxBufferAhead$: maxBufferAhead$,\n        });\n    });\n    /**\n     * Keep track of a unique segmentBookkeeper created per\n     * QueuedSourceBuffer.\n     * @type {WeakMapMemory}\n     */\n    var segmentBookkeepers = new weak_map_memory_1.default(function () {\n        return new segment_bookkeeper_1.default();\n    });\n    /**\n     * Start the whole Stream.\n     * @type {Observable}\n     */\n    var stream$ = create_media_source_1.default(videoElement)\n        .mergeMap(function (mediaSource) {\n        return Observable_1.Observable.combineLatest(fetchManifest(url), events_1.onSourceOpen$(mediaSource).take(1)).mergeMap(function (_a) {\n            var manifest = _a[0];\n            return initializeStream(mediaSource, manifest);\n        });\n    });\n    var warningEvents$ = warning$.map(stream_events_1.default.warning);\n    return Observable_1.Observable.merge(stream$, warningEvents$);\n    /**\n     * Initialize stream playback by merging all observable that are required to\n     * make the system cooperate.\n     * @param {MediaSource} mediaSource\n     * @param {Object} manifest\n     * @returns {Observable}\n     */\n    function initializeStream(mediaSource, manifest) {\n        create_media_source_1.setDurationToMediaSource(mediaSource, manifest.getDuration());\n        log_1.default.debug(\"calculating initial time\");\n        var initialTime = get_initial_time_1.default(manifest, startAt);\n        log_1.default.debug(\"initial time calculated:\", initialTime);\n        var firstPeriodToPlay = manifest.getPeriodForTime(initialTime);\n        if (firstPeriodToPlay == null) {\n            throw new errors_1.MediaError(\"MEDIA_STARTING_TIME_NOT_FOUND\", null, true);\n        }\n        var _a = video_events_1.default(videoElement, initialTime, autoPlay), initialSeek$ = _a.initialSeek$, loadAndPlay$ = _a.loadAndPlay$;\n        var bufferClock$ = clock_1.default(manifest, clock$, initialSeek$, initialTime);\n        /**\n         * Subject through which network metrics will be sent by the segment\n         * pipelines to the ABR manager.\n         * @type {Subject}\n         */\n        var network$ = new Subject_1.Subject();\n        /**\n         * Subject through which each request progression will be sent by the\n         * segment pipelines to the ABR manager.\n         * @type {Subject}\n         */\n        var requestsInfos$ = new Subject_1.Subject();\n        /**\n         * Creates pipelines for downloading segments.\n         * @type {SegmentPipelinesManager}\n         */\n        var segmentPipelinesManager = new pipelines_1.SegmentPipelinesManager(transport, requestsInfos$, network$, warning$);\n        /**\n         * Create ABR Manager, which will choose the right \"Representation\" for a\n         * given \"Adaptation\".\n         * @type {ABRManager}\n         */\n        var abrManager = new abr_1.default(requestsInfos$, network$, adaptiveOptions);\n        /**\n         * Clock needed by the BufferManager\n         * @type {Observable}\n         */\n        var abrClock$ = Observable_1.Observable.combineLatest(clock$, speed$)\n            .map(function (_a) {\n            var tick = _a[0], speed = _a[1];\n            return {\n                bufferGap: tick.bufferGap,\n                duration: tick.duration,\n                isLive: manifest.isLive,\n                position: tick.currentTime,\n                speed: speed,\n            };\n        });\n        /**\n         * Creates BufferManager allowing to easily create a Buffer linked to any\n         * Adaptation from the current content.\n         * @type {BufferManager}\n         */\n        var bufferManager = new buffer_1.default(abrManager, abrClock$);\n        /**\n         * Creates SourceBufferManager allowing to create and keep track of a single\n         * SourceBuffer per type.\n         * @type {SourceBufferManager}\n         */\n        var sourceBufferManager = new source_buffers_1.default(videoElement, mediaSource);\n        /**\n         * Creates Observable which will manage every Buffer for the given Content.\n         * @type {Observable}\n         */\n        var handledBuffers$ = buffers_handler_1.default({ manifest: manifest, period: firstPeriodToPlay }, // content\n        bufferClock$, wantedBufferAhead$, bufferManager, sourceBufferManager, segmentPipelinesManager, segmentBookkeepers, garbageCollectors, {\n            maxRetry: networkConfig.segmentRetry,\n            maxRetryOffline: networkConfig.offlineRetry,\n            textTrackOptions: textTrackOptions,\n        }, warning$).mergeMap(function onBuffersHandlerEvent(evt) {\n            if (evt.type === \"end-of-stream\") {\n                log_1.default.info(\"Triggering end of stream.\");\n                return end_of_stream_1.default(mediaSource);\n            }\n            return Observable_1.Observable.of(evt);\n        });\n        /**\n         * Add management of events linked to live Playback.\n         * @type {Observable}\n         */\n        var buffers$ = (manifest.isLive ?\n            handledBuffers$\n                .mergeMap(live_events_handler_1.default(videoElement, manifest, fetchManifest)) :\n            handledBuffers$);\n        /**\n         * Create EME Manager, an observable which will manage every EME-related\n         * issue.\n         * @type {Observable}\n         */\n        var emeManager$ = eme_1.default(videoElement, keySystems, warning$);\n        /**\n         * Translate errors coming from the video element into RxPlayer errors\n         * through a throwing Observable.\n         * @type {Observable}\n         */\n        var mediaErrorHandler$ = media_error_handler_1.default(videoElement);\n        /**\n         * Create Speed Manager, an observable which will set the speed set by the\n         * user on the video element while pausing a little longer while the buffer\n         * is stalled.\n         * @type {Observable}\n         */\n        var speedManager$ = speed_manager_1.default(videoElement, speed$, clock$, {\n            pauseWhenStalled: true,\n        }).map(stream_events_1.default.speedChanged);\n        /**\n         * Create Stalling Manager, an observable which will try to get out of\n         * various infinite stalling issues\n         * @type {Observable}\n         */\n        var stallingManager$ = stalling_manager_1.default(videoElement, clock$)\n            .map(stream_events_1.default.stalled);\n        // Single lifecycle events\n        var manifestReadyEvent$ = Observable_1.Observable\n            .of(stream_events_1.default.manifestReady(abrManager, manifest));\n        var loadedEvent$ = loadAndPlay$.mapTo(stream_events_1.default.loaded());\n        return Observable_1.Observable.merge(manifestReadyEvent$, loadedEvent$, buffers$, emeManager$, // TODO RxJS Bug?\n        mediaErrorHandler$, // TODO RxJS Bug?\n        speedManager$, stallingManager$).finally(function () {\n            // clean-up every created SourceBuffers\n            sourceBufferManager.disposeAll();\n        });\n    }\n}\nexports.default = Stream;\n\n\n//# sourceURL=webpack://RxPlayer/./src/core/stream/index.ts?");

/***/ }),

/***/ "./src/core/stream/live_events_handler.ts":
/*!************************************************!*\
  !*** ./src/core/stream/live_events_handler.ts ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Observable_1 = __webpack_require__(/*! rxjs/Observable */ \"./node_modules/rxjs/Observable.js\");\nvar log_1 = __webpack_require__(/*! ../../utils/log */ \"./src/utils/log.ts\");\nvar source_buffers_1 = __webpack_require__(/*! ../source_buffers */ \"./src/core/source_buffers/index.ts\");\nvar stream_events_1 = __webpack_require__(/*! ./stream_events */ \"./src/core/stream/stream_events.ts\");\n/**\n * Re-fetch the manifest and merge it with the previous version.\n *\n * /!\\ Mutates the given manifest\n * @param {Object} manifest\n * @returns {Observable}\n */\nfunction refreshManifest(manifestPipeline, currentManifest) {\n    var refreshURL = currentManifest.getUrl();\n    if (!refreshURL) {\n        log_1.default.warn(\"Cannot refresh the manifest: no url\");\n        return Observable_1.Observable.empty();\n    }\n    return manifestPipeline(refreshURL)\n        .do(function (parsed) {\n        currentManifest.update(parsed);\n    })\n        .share() // share the previous side effect\n        .mapTo(stream_events_1.default.manifestUpdate(currentManifest));\n}\n/**\n * Create handler for Buffer events happening only in live contexts.\n * @param {HTMLMediaElement} videoElement\n * @param {Object} manifest\n * @param {Function} fetchManifest\n * @returns {Function}\n */\nfunction liveEventsHandler(videoElement, manifest, fetchManifest) {\n    /**\n     * Handle individual stream events\n     * @param {string} message\n     * @returns {Observable}\n     */\n    return function handleLiveEvents(message) {\n        switch (message.type) {\n            case \"discontinuity-encountered\":\n                if (source_buffers_1.default.isNative(message.value.bufferType)) {\n                    log_1.default.warn(\"explicit discontinuity seek\", message.value.nextTime);\n                    videoElement.currentTime = message.value.nextTime;\n                }\n                break;\n            case \"needs-manifest-refresh\":\n                log_1.default.debug(\"needs manifest to be refreshed\");\n                // out-of-index messages require a complete reloading of the\n                // manifest to refresh the current index\n                return refreshManifest(fetchManifest, manifest);\n        }\n        return Observable_1.Observable.of(message);\n    };\n}\nexports.default = liveEventsHandler;\n\n\n//# sourceURL=webpack://RxPlayer/./src/core/stream/live_events_handler.ts?");

/***/ }),

/***/ "./src/core/stream/media_error_handler.ts":
/*!************************************************!*\
  !*** ./src/core/stream/media_error_handler.ts ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar MediaError_1 = __webpack_require__(/*! ../../errors/MediaError */ \"./src/errors/MediaError.ts\");\nvar log_1 = __webpack_require__(/*! ../../utils/log */ \"./src/utils/log.ts\");\nvar rx_onEvent_1 = __webpack_require__(/*! ../../utils/rx-onEvent */ \"./src/utils/rx-onEvent.ts\");\n/**\n * Returns an observable which throws the right MediaError as soon an \"error\"\n * event is received through the videoElement.\n * @see MediaError\n * @returns {Observable}\n */\nfunction createMediaErrorHandler(videoElement) {\n    return rx_onEvent_1.default(videoElement, \"error\").mergeMap(function () {\n        var errorCode = videoElement.error && videoElement.error.code;\n        var errorDetail;\n        switch (errorCode) {\n            case 1:\n                errorDetail = \"MEDIA_ERR_ABORTED\";\n                break;\n            case 2:\n                errorDetail = \"MEDIA_ERR_NETWORK\";\n                break;\n            case 3:\n                errorDetail = \"MEDIA_ERR_DECODE\";\n                break;\n            case 4:\n                errorDetail = \"MEDIA_ERR_SRC_NOT_SUPPORTED\";\n                break;\n            default:\n                errorDetail = \"MEDIA_ERR_UNKNOWN\";\n                break;\n        }\n        log_1.default.error(\"stream: video element MEDIA_ERR(\" + errorDetail + \")\");\n        throw new MediaError_1.default(errorDetail, null, true);\n    });\n}\nexports.default = createMediaErrorHandler;\n\n\n//# sourceURL=webpack://RxPlayer/./src/core/stream/media_error_handler.ts?");

/***/ }),

/***/ "./src/core/stream/segment_bookkeeper.ts":
/*!***********************************************!*\
  !*** ./src/core/stream/segment_bookkeeper.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar config_1 = __webpack_require__(/*! ../../config */ \"./src/config.ts\");\nvar log_1 = __webpack_require__(/*! ../../utils/log */ \"./src/utils/log.ts\");\nvar ranges_1 = __webpack_require__(/*! ../../utils/ranges */ \"./src/utils/ranges.ts\");\nvar takeFirstSet_1 = __webpack_require__(/*! ../../utils/takeFirstSet */ \"./src/utils/takeFirstSet.ts\");\nvar MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT = config_1.default.MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT, MAX_BUFFERED_DISTANCE = config_1.default.MAX_BUFFERED_DISTANCE, MINIMUM_SEGMENT_SIZE = config_1.default.MINIMUM_SEGMENT_SIZE;\n/**\n * Keep track of every segment downloaded and currently in the browser's memory.\n *\n * The main point of this class is to know which CDN segments are already\n * pushed to the SourceBuffer, at which bitrate, and which have been\n * garbage-collected since by the browser (and thus should be re-downloaded).\n * @class SegmentBookkeeper\n */\nvar SegmentBookkeeper = /** @class */ (function () {\n    function SegmentBookkeeper() {\n        /**\n         * The inventory keep track of all the segments which should be currently\n         * in the browser's memory.\n         * This array contains objects, each being related to a single downloaded\n         * segment which is at least partially added in a source buffer.\n         * @type {Array.<Object>}\n         */\n        this.inventory = [];\n    }\n    /**\n     * Infer each segment's bufferedStart and bufferedEnd from the TimeRanges\n     * given (coming from the source buffer).\n     * @param {TimeRanges}\n     *\n     * TODO implement management of segments whose end is not known\n     */\n    SegmentBookkeeper.prototype.synchronizeBuffered = function (buffered) {\n        var inventory = this.inventory;\n        var ranges = ranges_1.convertToRanges(buffered);\n        /**\n         * Current inventory index considered.\n         * @type {Number}\n         */\n        var inventoryIndex = 0;\n        /**\n         * Current segmentInfos considered\n         * @type {Object}\n         */\n        var thisSegment = inventory[0];\n        var rangesLength = ranges.length;\n        for (var i = 0; i < rangesLength; i++) {\n            if (thisSegment == null) {\n                // If thisSegment is not set, it means that we arrived at the end of\n                // our inventory.\n                // This TimeRange do not link to any segment and neither will any\n                // subsequent one.\n                // (It may be linked to another adaptation, for example)\n                return;\n            }\n            var _a = ranges[i], rangeStart = _a.start, rangeEnd = _a.end;\n            // if current TimeRange is too small to contain a segment, go to next one\n            if (rangeEnd - rangeStart < MINIMUM_SEGMENT_SIZE) {\n                continue;\n            }\n            /**\n             * Inventory index of the last segment not contained in the current range.\n             * Will be used to know how many segments have been garbage collected.\n             * @type {Number}\n             */\n            var indexBefore = inventoryIndex;\n            // Find the first segment either within this TimeRange or past it:\n            // skip until first segment with at least MINIMUM_SEGMENT_SIZE past the\n            // start of that range.\n            while (thisSegment &&\n                // TODO better way to indicate to typescript that all is well here\n                (takeFirstSet_1.default(thisSegment.bufferedEnd, thisSegment.end)\n                    - rangeStart)\n                    < MINIMUM_SEGMENT_SIZE) {\n                thisSegment = inventory[++inventoryIndex];\n            }\n            /**\n             * Contains the end of the last garbage-collected segment before\n             * thisSegment.\n             * Might be useful to infer later the bufferedStart of thisSegment.\n             *\n             * -1 if no segment have been garbage-collected before thisSegment.\n             * @type {Number}\n             */\n            var lastDeletedSegmentEnd = -1;\n            // remove garbage-collected segments\n            // (not in that TimeRange nor in the previous one)\n            var numberOfSegmentToDelete = inventoryIndex - indexBefore;\n            if (numberOfSegmentToDelete > 0) {\n                // last garbage-collected segment\n                var lastDeletedSegment = inventory[indexBefore + numberOfSegmentToDelete - 1];\n                // TODO better way to indicate to typescript that all is well here\n                lastDeletedSegmentEnd = takeFirstSet_1.default(lastDeletedSegment.bufferedEnd, lastDeletedSegment.end);\n                // mutate inventory\n                inventory.splice(indexBefore, numberOfSegmentToDelete);\n                inventoryIndex = indexBefore;\n            }\n            // if no segment is left for that range (or any other one), quit\n            if (thisSegment == null) {\n                return;\n            }\n            // Infer the bufferedStart for this segment, and the bufferedStart and\n            // bufferedEnd for the following segments included in that range.\n            //\n            // If the current segment is actually completely outside that range (it\n            // is contained in one of the next one), skip that part.\n            if (rangeEnd -\n                // TODO better way to indicate to typescript that all is well here\n                takeFirstSet_1.default(thisSegment.bufferedStart, thisSegment.start)\n                >= MINIMUM_SEGMENT_SIZE) {\n                // set the bufferedStart of the first segment in that range\n                if (thisSegment.bufferedStart != null &&\n                    thisSegment.bufferedStart < rangeStart) {\n                    // the segment appears to have been partially garbage collected:\n                    // Update bufferedStart\n                    thisSegment.bufferedStart = rangeStart;\n                }\n                else if (thisSegment.bufferedStart == null) {\n                    if (lastDeletedSegmentEnd !== -1 &&\n                        lastDeletedSegmentEnd > rangeStart &&\n                        thisSegment.start - lastDeletedSegmentEnd <= MAX_BUFFERED_DISTANCE) {\n                        thisSegment.bufferedStart = lastDeletedSegmentEnd;\n                    }\n                    else if (thisSegment.start - rangeStart <= MAX_BUFFERED_DISTANCE) {\n                        thisSegment.bufferedStart = rangeStart;\n                    }\n                    else {\n                        thisSegment.bufferedStart = thisSegment.start;\n                    }\n                }\n                thisSegment = inventory[++inventoryIndex];\n                // Make contiguous until first segment outside that range\n                // (i.e until the start of the next segment can not constitute a segment\n                // in that range == less than MINIMUM_SEGMENT_SIZE into that range)\n                while (thisSegment &&\n                    (rangeEnd -\n                        // TODO better way to indicate to typescript that all is well here\n                        takeFirstSet_1.default(thisSegment.bufferedStart, thisSegment.start))\n                        >= MINIMUM_SEGMENT_SIZE) {\n                    var prevSegment = inventory[inventoryIndex - 1];\n                    // those segments are contiguous, we have no way to infer their real\n                    // end\n                    if (prevSegment.bufferedEnd == null) {\n                        prevSegment.bufferedEnd = prevSegment.end;\n                    }\n                    thisSegment.bufferedStart = prevSegment.bufferedEnd;\n                    thisSegment = inventory[++inventoryIndex];\n                }\n            }\n            // update the bufferedEnd of the last segment in that range\n            var lastSegmentInRange = inventory[inventoryIndex - 1];\n            if (lastSegmentInRange) {\n                if (lastSegmentInRange.bufferedEnd != null &&\n                    lastSegmentInRange.bufferedEnd > rangeEnd) {\n                    // the segment appears to have been partially garbage collected:\n                    // Update bufferedEnd\n                    lastSegmentInRange.bufferedEnd = rangeEnd;\n                }\n                else if (lastSegmentInRange.bufferedEnd == null) {\n                    lastSegmentInRange.bufferedEnd =\n                        rangeEnd - lastSegmentInRange.end <= MAX_BUFFERED_DISTANCE ?\n                            rangeEnd : lastSegmentInRange.end;\n                }\n            }\n        }\n        // if we still have segments left, they are not affiliated to any range.\n        // They might have been garbage collected, delete them from here.\n        if (thisSegment) {\n            inventory.splice(inventoryIndex, inventory.length - inventoryIndex);\n        }\n    };\n    /**\n     * Add a new segment in the inventory.\n     *\n     * Note: As new segments can \"replace\" partially or completely old ones, we\n     * have to perform a complex logic and might update previously added segments.\n     *\n     * @param {Object} segment\n     * @param {Number} start - start time of the segment, in seconds\n     * @param {Number|undefined} end - end time of the segment, in seconds. Can\n     * be undefined in some rare cases\n     * @param {Number} bitrate - bitrate of the representation the segment is in\n     */\n    SegmentBookkeeper.prototype.insert = function (period, adaptation, representation, segment, start, end) {\n        // TODO (*very* low-priority) manage segments whose end is unknown (rare but\n        // could eventually happen).\n        // This should be properly managed in this method, but it is not in some\n        // other methods of this class, so I decided to not one of those to the\n        // inventory by security\n        if (end == null) {\n            if (true) {\n                throw new Error(\"SegmentBookkeeper: ending time of the segment not defined\");\n            }\n            // This leads to excessive re-downloads of segment without an ending time.\n            log_1.default.warn(\"SegmentBookkeeper: ending time of the segment not defined\");\n            return;\n        }\n        var inventory = this.inventory;\n        // infer start and end from the segment data\n        // /!\\ Can be a little different than their real start/end time in the\n        // sourcebuffer.\n        // const start = segment.time / segment.timescale;\n        // const end = (segment.time + segment.duration) / segment.timescale;\n        var newSegment = {\n            start: start,\n            end: end,\n            bufferedStart: undefined,\n            bufferedEnd: undefined,\n            infos: {\n                segment: segment,\n                period: period,\n                adaptation: adaptation,\n                representation: representation,\n            },\n        };\n        // begin by the end as in most use cases this will be faster\n        for (var i = inventory.length - 1; i >= 0; i--) {\n            var segmentI = inventory[i];\n            if ((segmentI.start /* - SEGMENT_EPSILON */) <= start) {\n                if ((segmentI.end /* - SEGMENT_EPSILON */) <= start) {\n                    // our segment is after, push it after this one\n                    //\n                    // Case 1:\n                    //   segmentI     : |------|\n                    //   newSegment   :        |------|\n                    //\n                    // Case 2:\n                    //   segmentI     : |------|\n                    //   newSegment   :          |------|\n                    this.inventory.splice(i + 1, 0, newSegment);\n                    return;\n                }\n                else { // /!\\ also goes here if end is undefined\n                    if (segmentI.start >= (start /* - SEGMENT_EPSILON */)) {\n                        // In those cases, replace\n                        // Case 1:\n                        //  segmentI     : |-------|\n                        //  newSegment   : |-------|\n                        //\n                        // Case 2:\n                        //  segmentI     : |-------|\n                        //  newSegment   : |----------|\n                        //\n                        // Case 3:\n                        //  segmentI     : |-------|\n                        //  newSegment   : |???*\n                        //\n                        // Case 4:\n                        //  segmentI     : |???*\n                        //  newSegment   : |------|\n                        //\n                        // Case 5:\n                        //  segmentI     : |???*\n                        //  newSegment   : |???*\n                        //\n                        // *|??? - unknown end\n                        this.inventory.splice(i, 1, newSegment);\n                        return;\n                    }\n                    else {\n                        // our segment has a \"complex\" relation with this one,\n                        // update the old one end and add this one after it.\n                        //\n                        // Case 1:\n                        //  segmentI     : |-------|\n                        //  newSegment   :    |------|\n                        //\n                        // Case 2:\n                        //  segmentI     : |-------|\n                        //  newSegment   :    |----|\n                        //\n                        // Case 3:\n                        //  segmentI     : |-------|\n                        //  newSegment   :    |???*\n                        //\n                        // Case 4:\n                        //  segmentI     : |???*\n                        //  newSegment   :    |----|\n                        //\n                        // Case 5:\n                        //  segmentI     : |???*\n                        //  newSegment   :    |???*\n                        //\n                        // *|??? - unknown end\n                        // (if segment's end is not known yet, it could perfectly\n                        // end before the one we're adding now)\n                        if (segmentI.end != null) {\n                            segmentI.end = start;\n                        }\n                        this.inventory.splice(i + 1, 0, newSegment);\n                        return;\n                    }\n                }\n            }\n        }\n        // if we got here, we are the first segment\n        // check bounds of the previous first segment\n        var firstSegment = this.inventory[0];\n        if (!firstSegment) { // we do not have any segment yet\n            this.inventory.push(newSegment);\n            return;\n        }\n        if (end == null) {\n            if (firstSegment.start === start) {\n                // same beginning, unknown end, just replace\n                // Case 1:\n                //  firstSegment : |-------|\n                //  newSegment   : |???*\n                //\n                // Case 2:\n                //  firstSegment : |???*\n                //  newSegment   : |???*\n                //\n                // *|??? - unknown end\n                this.inventory.splice(0, 1, newSegment);\n            }\n            else {\n                // our segment begins before this one, push at the beginning\n                // Case 1:\n                // firstSegment :   |-------|\n                // newSegment   : |???*\n                //\n                // Case 2:\n                // firstSegment :   |???*\n                // newSegment   : |???*\n                //\n                // *|??? - unknown end\n                this.inventory.splice(0, 0, newSegment);\n            }\n            return;\n        }\n        if (firstSegment.start >= end) {\n            // our segment is before, put it before\n            // Case 1:\n            //  firstSegment :      |----|\n            //  newSegment   : |----|\n            //\n            // Case 2:\n            //  firstSegment :        |----|\n            //  newSegment   : |----|\n            //\n            // Case 3:\n            //  firstSegment :        |???*\n            //  newSegment   : |----|\n            //\n            // Case 4:\n            //  firstSegment :      |???*\n            //  newSegment   : |----|\n            //\n            // *|??? - unknown end\n            this.inventory.splice(0, 0, newSegment);\n        }\n        else if ((firstSegment.end /* - SEGMENT_EPSILON */) <= end) {\n            // Our segment is bigger, replace the first\n            // Case 1:\n            //  firstSegment :   |---|\n            //  newSegment   : |-------|\n            //\n            // Case 2:\n            //  firstSegment :   |-----|\n            //  newSegment   : |-------|\n            this.inventory.splice(0, 1, newSegment);\n        }\n        else {\n            // our segment has a \"complex\" relation with the first one,\n            // update the old one start and add this one before it.\n            // Case 1:\n            //  firstSegment :    |------|\n            //  newSegment   : |------|\n            //\n            // Case 2:\n            // firstSegment :   |???*\n            // newSegment   : |-----|\n            //\n            // *|??? - unknown end\n            firstSegment.start = end;\n            this.inventory.splice(0, 0, newSegment);\n        }\n    };\n    /**\n     * Returns segment infos for a segment corresponding to the given time,\n     * duration and timescale.\n     *\n     * Returns null if either:\n     *   - no segment can be linked exactly to the given time/duration\n     *   - a segment is linked to this information, but is currently considered\n     *     \"incomplete\" to be playable, in the sourceBuffer. We check if all\n     *     needed data for playback (from wanted range) is loaded.\n     *\n     * The main purpose of this method is to know if the segment asked should be\n     * downloaded (or re-downloaded).\n     *\n     * /!\\ Make sure that this class is synchronized with the sourceBuffer\n     * (see addBufferedInfos method of the same class) before calling this method,\n     * as it depends on it to categorize \"incomplete\" from \"complete\" segments.\n     *\n     * @param {Object} wantedRange\n     * @param {Number} time\n     * @param {Number} duration\n     * @param {Number} timescale\n     * @returns {Object|null}\n     */\n    SegmentBookkeeper.prototype.hasPlayableSegment = function (wantedRange, segmentInfos) {\n        var time = segmentInfos.time, duration = segmentInfos.duration, timescale = segmentInfos.timescale;\n        var inventory = this.inventory;\n        for (var i = inventory.length - 1; i >= 0; i--) {\n            var currentSegmentI = inventory[i];\n            var prevSegmentI = inventory[i - 1];\n            var nextSegmentI = inventory[i + 1];\n            var segment = currentSegmentI.infos.segment;\n            var _time = time;\n            var _duration = duration;\n            if (segment.timescale !== timescale) {\n                // Note: we could get rounding errors here\n                _time = (time * segment.timescale) / timescale;\n                _duration = (duration * segment.timescale) / timescale;\n            }\n            if (segment.time === _time && segment.duration === _duration) {\n                // false negatives are better than false positives here.\n                // When impossible to know, say the segment is not complete\n                if (hasEnoughInfos(currentSegmentI, prevSegmentI, nextSegmentI)) {\n                    if (hasWantedRange(wantedRange, currentSegmentI, prevSegmentI, nextSegmentI)) {\n                        return currentSegmentI;\n                    }\n                }\n            }\n        }\n        return null;\n        // -- Helpers\n        /*\n         * Check if segment can be evaluated.\n         * @param {Object} currentSegmentI\n         * @param {Object} prevSegmentI\n         * @param {Object} nextSegmentI\n         * @returns {Boolean}\n         */\n        function hasEnoughInfos(currentSegmentI, prevSegmentI, nextSegmentI) {\n            if ((prevSegmentI && prevSegmentI.bufferedEnd == null) ||\n                currentSegmentI.bufferedStart == null) {\n                return false;\n            }\n            if ((nextSegmentI && nextSegmentI.bufferedStart == null) ||\n                currentSegmentI.bufferedEnd == null) {\n                return false;\n            }\n            return true;\n        }\n        /* Returns true if the segment given can be played for the wanted range.\n         * @param {Object} _wantedRange\n         * @param {Object} currentSegmentI\n         * @param {Object} prevSegmentI\n         * @param {Object} nextSegmentI\n         * @returns {Boolean}\n         */\n        function hasWantedRange(_wantedRange, currentSegmentI, prevSegmentI, nextSegmentI) {\n            if (!prevSegmentI ||\n                prevSegmentI.bufferedEnd == null ||\n                currentSegmentI.bufferedStart == null ||\n                prevSegmentI.bufferedEnd < currentSegmentI.bufferedStart) {\n                if (currentSegmentI.bufferedStart == null) {\n                    return false;\n                }\n                var timeDiff = currentSegmentI.bufferedStart - currentSegmentI.start;\n                if (_wantedRange.start > currentSegmentI.start) {\n                    var wantedDiff = currentSegmentI.bufferedStart - _wantedRange.start;\n                    if (wantedDiff > 0 && timeDiff\n                        > MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT) {\n                        log_1.default.debug(\"The wanted segment has been garbage collected\", currentSegmentI);\n                        return false;\n                    }\n                }\n                else {\n                    if (timeDiff > MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT) {\n                        log_1.default.debug(\"The wanted segment has been garbage collected\", currentSegmentI);\n                        return false;\n                    }\n                }\n            }\n            if (currentSegmentI.end === null) {\n                return false;\n            }\n            else if (!nextSegmentI ||\n                nextSegmentI.bufferedStart == null ||\n                currentSegmentI.bufferedEnd == null ||\n                nextSegmentI.bufferedStart > currentSegmentI.bufferedEnd) {\n                if (currentSegmentI.bufferedEnd == null) {\n                    return false;\n                }\n                var timeDiff = currentSegmentI.end - currentSegmentI.bufferedEnd;\n                if (_wantedRange.end < currentSegmentI.end) {\n                    var wantedDiff = _wantedRange.end - currentSegmentI.bufferedEnd;\n                    if (wantedDiff > 0 && timeDiff\n                        > MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT) {\n                        log_1.default.debug(\"The wanted segment has been garbage collected\", currentSegmentI);\n                        return false;\n                    }\n                }\n                else {\n                    if (timeDiff > MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT) {\n                        log_1.default.debug(\"The wanted segment has been garbage collected\", currentSegmentI);\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n    };\n    /**\n     * Empty the current inventory\n     */\n    SegmentBookkeeper.prototype.reset = function () {\n        this.inventory = [];\n    };\n    return SegmentBookkeeper;\n}());\nexports.default = SegmentBookkeeper;\n\n\n//# sourceURL=webpack://RxPlayer/./src/core/stream/segment_bookkeeper.ts?");

/***/ }),

/***/ "./src/core/stream/speed_manager.ts":
/*!******************************************!*\
  !*** ./src/core/stream/speed_manager.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Observable_1 = __webpack_require__(/*! rxjs/Observable */ \"./node_modules/rxjs/Observable.js\");\nvar log_1 = __webpack_require__(/*! ../../utils/log */ \"./src/utils/log.ts\");\n/**\n * Manage playback speed.\n * Set playback rate set by the user, pause playback when the player appear to\n * stall and restore the speed once it appears to un-stall.\n *\n * @param {HTMLMediaElement} videoElement\n * @param {Observable} speed$ - emit speed set by the user\n * @param {Observable} clock$\n * @param {Object} options\n * @param {Boolean} [options.pauseWhenStalled=true] - true if the player\n * stalling should lead to a pause until it un-stalls.\n * @returns {Observable}\n */\nvar speedManager = function (videoElement, speed$, clock$, _a) {\n    var _b = _a.pauseWhenStalled, pauseWhenStalled = _b === void 0 ? true : _b;\n    var forcePause$;\n    if (!pauseWhenStalled) {\n        forcePause$ = Observable_1.Observable.of(false);\n    }\n    else {\n        forcePause$ = clock$\n            .pairwise()\n            .map(function (_a) {\n            var prevTiming = _a[0], timing = _a[1];\n            var isStalled = timing.stalled;\n            var wasStalled = prevTiming.stalled;\n            if (!wasStalled !== !isStalled || // xor\n                (wasStalled && isStalled && wasStalled.reason !== isStalled.reason)) {\n                return !wasStalled;\n            }\n        })\n            .filter(function (val) { return val != null; })\n            // TODO2smart4TypeScript. Find better solution eventually\n            .startWith(false);\n    }\n    return forcePause$\n        .switchMap(function (shouldForcePause) {\n        if (shouldForcePause) {\n            return Observable_1.Observable.defer(function () {\n                log_1.default.info(\"pause playback to build buffer\");\n                videoElement.playbackRate = 0;\n                return Observable_1.Observable.of(0);\n            });\n        }\n        return speed$\n            .do(function (speed) {\n            log_1.default.info(\"resume playback speed\", speed);\n            videoElement.playbackRate = speed;\n        });\n    });\n};\nexports.default = speedManager;\n\n\n//# sourceURL=webpack://RxPlayer/./src/core/stream/speed_manager.ts?");

/***/ }),

/***/ "./src/core/stream/stalling_manager.ts":
/*!*********************************************!*\
  !*** ./src/core/stream/stalling_manager.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar compat_1 = __webpack_require__(/*! ../../compat */ \"./src/compat/index.ts\");\nvar config_1 = __webpack_require__(/*! ../../config */ \"./src/config.ts\");\nvar log_1 = __webpack_require__(/*! ../../utils/log */ \"./src/utils/log.ts\");\nvar ranges_1 = __webpack_require__(/*! ../../utils/ranges */ \"./src/utils/ranges.ts\");\nvar DISCONTINUITY_THRESHOLD = config_1.default.DISCONTINUITY_THRESHOLD;\n/**\n * Receive \"stalling\" events from the clock, try to get out of it, and re-emit\n * them for the player if the stalling status changed.\n * @param {HTMLMediaElement} videoElement\n * @param {Observable} timings$\n * @returns {Observable}\n */\nfunction StallingManager(videoElement, timings$) {\n    return timings$\n        .do(function (timing) {\n        if (!timing.stalled) {\n            return;\n        }\n        // Perform various checks to try to get out of the stalled state:\n        //   1. is it a browser bug? -> force seek at the same current time\n        //   2. is it a short discontinuity? -> Seek at the beginning of the\n        //                                      next range\n        var buffered = timing.buffered, currentTime = timing.currentTime;\n        var nextRangeGap = ranges_1.getNextRangeGap(buffered, currentTime);\n        // Discontinuity check in case we are close a buffer but still\n        // calculate a stalled state. This is useful for some\n        // implementation that might drop an injected segment, or in\n        // case of small discontinuity in the stream.\n        if (compat_1.isPlaybackStuck(timing.currentTime, timing.currentRange, timing.state, !!timing.stalled)) {\n            log_1.default.warn(\"after freeze seek\", currentTime, timing.currentRange);\n            videoElement.currentTime = currentTime;\n        }\n        else if (nextRangeGap < DISCONTINUITY_THRESHOLD) {\n            var seekTo = (currentTime + nextRangeGap + 1 / 60);\n            log_1.default.warn(\"discontinuity seek\", currentTime, nextRangeGap, seekTo);\n            videoElement.currentTime = seekTo;\n        }\n    })\n        .share()\n        .map(function (timing) { return timing.stalled; })\n        .distinctUntilChanged(function (wasStalled, isStalled) {\n        return !wasStalled && !isStalled ||\n            (!!wasStalled && !!isStalled && wasStalled.reason === isStalled.reason);\n    });\n}\nexports.default = StallingManager;\n\n\n//# sourceURL=webpack://RxPlayer/./src/core/stream/stalling_manager.ts?");

/***/ }),

/***/ "./src/core/stream/stream_events.ts":
/*!******************************************!*\
  !*** ./src/core/stream/stream_events.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction adaptationChange(bufferType, adaptation, period) {\n    return {\n        type: \"adaptationChange\",\n        value: {\n            type: bufferType,\n            adaptation: adaptation,\n            period: period,\n        },\n    };\n}\nfunction loaded() {\n    return {\n        type: \"loaded\",\n        value: true,\n    };\n}\nfunction stalled(stalling) {\n    return {\n        type: \"stalled\",\n        value: stalling,\n    };\n}\nfunction manifestReady(abrManager, manifest) {\n    return {\n        type: \"manifestReady\",\n        value: {\n            abrManager: abrManager,\n            manifest: manifest,\n        },\n    };\n}\nfunction manifestUpdate(manifest) {\n    return {\n        type: \"manifestUpdate\",\n        value: {\n            manifest: manifest,\n        },\n    };\n}\nfunction speedChanged(speed) {\n    return {\n        type: \"speed\",\n        value: speed,\n    };\n}\nfunction activePeriodChanged(period) {\n    return {\n        type: \"activePeriodChanged\",\n        value: {\n            period: period,\n        },\n    };\n}\nfunction nullRepresentation(type, period) {\n    return {\n        type: \"representationChange\",\n        value: {\n            type: type,\n            representation: null,\n            period: period,\n        },\n    };\n}\nfunction periodBufferReady(type, period, adaptation$) {\n    return {\n        type: \"periodBufferReady\",\n        value: {\n            type: type,\n            period: period,\n            adaptation$: adaptation$,\n        },\n    };\n}\nfunction periodBufferCleared(type, period) {\n    return {\n        type: \"periodBufferCleared\",\n        value: {\n            type: type,\n            period: period,\n        },\n    };\n}\nfunction warning(value) {\n    return {\n        type: \"warning\",\n        value: value,\n    };\n}\nfunction endOfStream() {\n    return {\n        type: \"end-of-stream\",\n        value: undefined,\n    };\n}\nfunction bufferComplete(bufferType) {\n    return {\n        type: \"complete-buffer\",\n        value: {\n            type: bufferType,\n        },\n    };\n}\nvar STREAM_EVENTS = {\n    activePeriodChanged: activePeriodChanged,\n    adaptationChange: adaptationChange,\n    bufferComplete: bufferComplete,\n    endOfStream: endOfStream,\n    loaded: loaded,\n    manifestReady: manifestReady,\n    manifestUpdate: manifestUpdate,\n    nullRepresentation: nullRepresentation,\n    periodBufferCleared: periodBufferCleared,\n    periodBufferReady: periodBufferReady,\n    speedChanged: speedChanged,\n    stalled: stalled,\n    warning: warning,\n};\nexports.default = STREAM_EVENTS;\n\n\n//# sourceURL=webpack://RxPlayer/./src/core/stream/stream_events.ts?");

/***/ }),

/***/ "./src/core/stream/video_events.ts":
/*!*****************************************!*\
  !*** ./src/core/stream/video_events.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Observable_1 = __webpack_require__(/*! rxjs/Observable */ \"./node_modules/rxjs/Observable.js\");\nvar compat_1 = __webpack_require__(/*! ../../compat */ \"./src/compat/index.ts\");\nvar log_1 = __webpack_require__(/*! ../../utils/log */ \"./src/utils/log.ts\");\n/**\n * Set the initial time given as soon as possible on the video element.\n * Emit \"null\" when done.\n * @param {HMTLMediaElement} videoElement\n * @param {number|Function} startTime\n * @returns {Observable}\n */\nfunction doInitialSeek(videoElement, startTime) {\n    return compat_1.hasLoadedMetadata(videoElement)\n        .do(function () {\n        log_1.default.info(\"set initial time\", startTime);\n        // reset playbackRate to 1 in case we were at 0 (from a stalled\n        // retry for instance)\n        videoElement.playbackRate = 1;\n        videoElement.currentTime = typeof startTime === \"function\" ?\n            startTime() : startTime;\n    })\n        .share();\n}\n/**\n * @param {HTMLMediaElement} videoElement\n * @param {boolean} autoPlay\n * @returns {Observable}\n */\nfunction handleCanPlay(videoElement, autoPlay) {\n    return compat_1.canPlay(videoElement)\n        .do(function () {\n        log_1.default.info(\"canplay event\");\n        if (autoPlay) {\n            /* tslint:disable no-floating-promises */\n            videoElement.play();\n            /* tslint:enable no-floating-promises */\n        }\n    })\n        .share();\n}\n/**\n * @param {HTMLMediaElement} videoElement\n * @param {number|Function} startTime\n * @param {boolean} autoPlay\n * @returns {object}\n */\nfunction handleVideoEvents(videoElement, startTime, autoPlay) {\n    var initialSeek$ = doInitialSeek(videoElement, startTime);\n    var hasHandledCanPlay$ = handleCanPlay(videoElement, autoPlay);\n    var loadAndPlay$ = Observable_1.Observable\n        .combineLatest(initialSeek$, hasHandledCanPlay$)\n        .take(1)\n        .mapTo(undefined);\n    return {\n        initialSeek$: initialSeek$,\n        loadAndPlay$: loadAndPlay$,\n    };\n}\nexports.default = handleVideoEvents;\n\n\n//# sourceURL=webpack://RxPlayer/./src/core/stream/video_events.ts?");

/***/ }),

/***/ "./src/errors/AssertionError.ts":
/*!**************************************!*\
  !*** ./src/errors/AssertionError.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Error due to an abnormal assertion fails.\n *\n * @class AssertionError\n * @extends Error\n */\nvar AssertionError = /** @class */ (function (_super) {\n    __extends(AssertionError, _super);\n    function AssertionError(message) {\n        var _this = _super.call(this) || this;\n        // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class\n        Object.setPrototypeOf(_this, AssertionError.prototype);\n        _this.name = \"AssertionError\";\n        _this.message = message;\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(_this, AssertionError);\n        }\n        return _this;\n    }\n    return AssertionError;\n}(Error));\nexports.default = AssertionError;\n\n\n//# sourceURL=webpack://RxPlayer/./src/errors/AssertionError.ts?");

/***/ }),

/***/ "./src/errors/EncryptedMediaError.ts":
/*!*******************************************!*\
  !*** ./src/errors/EncryptedMediaError.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar constants_1 = __webpack_require__(/*! ./constants */ \"./src/errors/constants.ts\");\nvar errorMessage_1 = __webpack_require__(/*! ./errorMessage */ \"./src/errors/errorMessage.ts\");\n/**\n * Error linked to the encryption of the media.\n *\n * @class EncryptedMediaError\n * @extends Error\n */\nvar EncryptedMediaError = /** @class */ (function (_super) {\n    __extends(EncryptedMediaError, _super);\n    function EncryptedMediaError(code, reason, fatal) {\n        var _this = _super.call(this) || this;\n        // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class\n        Object.setPrototypeOf(_this, EncryptedMediaError.prototype);\n        _this.name = \"EncryptedMediaError\";\n        _this.type = constants_1.ErrorTypes.ENCRYPTED_MEDIA_ERROR;\n        _this.reason = reason;\n        _this.code = constants_1.ErrorCodes.hasOwnProperty(code) ?\n            constants_1.ErrorCodes[code] : \"\";\n        _this.fatal = !!fatal;\n        _this.message = errorMessage_1.default(_this.name, _this.code, _this.reason);\n        return _this;\n    }\n    return EncryptedMediaError;\n}(Error));\nexports.default = EncryptedMediaError;\n\n\n//# sourceURL=webpack://RxPlayer/./src/errors/EncryptedMediaError.ts?");

/***/ }),

/***/ "./src/errors/IndexError.ts":
/*!**********************************!*\
  !*** ./src/errors/IndexError.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar constants_1 = __webpack_require__(/*! ./constants */ \"./src/errors/constants.ts\");\nvar errorMessage_1 = __webpack_require__(/*! ./errorMessage */ \"./src/errors/errorMessage.ts\");\n/**\n * Error linked to the Index part of the Manifest.\n *\n * TODO Rename ManifestError or something?\n *\n * @class IndexError\n * @extends Error\n */\nvar IndexError = /** @class */ (function (_super) {\n    __extends(IndexError, _super);\n    function IndexError(code, fatal) {\n        var _this = _super.call(this) || this;\n        // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class\n        Object.setPrototypeOf(_this, IndexError.prototype);\n        _this.name = \"IndexError\";\n        _this.type = constants_1.ErrorTypes.INDEX_ERROR;\n        _this.reason = null;\n        _this.code = constants_1.ErrorCodes.hasOwnProperty(code) ?\n            constants_1.ErrorCodes[code] : \"\";\n        _this.fatal = !!fatal;\n        _this.message = errorMessage_1.default(_this.name, _this.code, null);\n        return _this;\n    }\n    return IndexError;\n}(Error));\nexports.default = IndexError;\n\n\n//# sourceURL=webpack://RxPlayer/./src/errors/IndexError.ts?");

/***/ }),

/***/ "./src/errors/MediaError.ts":
/*!**********************************!*\
  !*** ./src/errors/MediaError.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar constants_1 = __webpack_require__(/*! ./constants */ \"./src/errors/constants.ts\");\nvar errorMessage_1 = __webpack_require__(/*! ./errorMessage */ \"./src/errors/errorMessage.ts\");\n/**\n * Error linked to the media Playback.\n *\n * @class MediaError\n * @extends Error\n */\nvar MediaError = /** @class */ (function (_super) {\n    __extends(MediaError, _super);\n    function MediaError(code, reason, fatal) {\n        var _this = _super.call(this) || this;\n        // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class\n        Object.setPrototypeOf(_this, MediaError.prototype);\n        _this.name = \"MediaError\";\n        _this.type = constants_1.ErrorTypes.MEDIA_ERROR;\n        _this.reason = reason;\n        _this.code = constants_1.ErrorCodes.hasOwnProperty(code) ?\n            constants_1.ErrorCodes[code] : \"\";\n        _this.fatal = !!fatal;\n        _this.message = errorMessage_1.default(_this.name, _this.code, _this.reason);\n        return _this;\n    }\n    return MediaError;\n}(Error));\nexports.default = MediaError;\n\n\n//# sourceURL=webpack://RxPlayer/./src/errors/MediaError.ts?");

/***/ }),

/***/ "./src/errors/NetworkError.ts":
/*!************************************!*\
  !*** ./src/errors/NetworkError.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar constants_1 = __webpack_require__(/*! ./constants */ \"./src/errors/constants.ts\");\nvar errorMessage_1 = __webpack_require__(/*! ./errorMessage */ \"./src/errors/errorMessage.ts\");\n/**\n * Error linked to network interactions (requests).\n *\n * @class NetworkError\n * @extends Error\n */\nvar NetworkError = /** @class */ (function (_super) {\n    __extends(NetworkError, _super);\n    function NetworkError(code, requestError, fatal) {\n        var _this = _super.call(this) || this;\n        // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class\n        Object.setPrototypeOf(_this, NetworkError.prototype);\n        _this.name = \"NetworkError\";\n        _this.type = constants_1.ErrorTypes.NETWORK_ERROR;\n        _this.xhr = requestError.xhr;\n        _this.url = requestError.url;\n        _this.status = requestError.status;\n        _this.errorType = requestError.type;\n        _this.reason = requestError;\n        _this.code = constants_1.ErrorCodes.hasOwnProperty(code) ?\n            constants_1.ErrorCodes[code] : \"\";\n        _this.fatal = !!fatal;\n        _this.message = errorMessage_1.default(_this.name, _this.code, _this.reason);\n        return _this;\n    }\n    /**\n     * Returns true if the NetworkError is due to the given http error code\n     * @param {number} httpErrorCode\n     * @returns {Boolean}\n     */\n    NetworkError.prototype.isHttpError = function (httpErrorCode) {\n        return (this.errorType === constants_1.RequestErrorTypes.ERROR_HTTP_CODE &&\n            this.status === httpErrorCode);\n    };\n    return NetworkError;\n}(Error));\nexports.default = NetworkError;\n\n\n//# sourceURL=webpack://RxPlayer/./src/errors/NetworkError.ts?");

/***/ }),

/***/ "./src/errors/OtherError.ts":
/*!**********************************!*\
  !*** ./src/errors/OtherError.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// TODO https://stackoverflow.com/questions/41102060/typescript-extending-error-class\nvar constants_1 = __webpack_require__(/*! ./constants */ \"./src/errors/constants.ts\");\nvar errorMessage_1 = __webpack_require__(/*! ./errorMessage */ \"./src/errors/errorMessage.ts\");\n/**\n * @class OtherError\n * @extends Error\n */\nvar OtherError = /** @class */ (function (_super) {\n    __extends(OtherError, _super);\n    function OtherError(code, reason, fatal) {\n        var _this = _super.call(this) || this;\n        // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class\n        Object.setPrototypeOf(_this, OtherError.prototype);\n        _this.name = \"OtherError\";\n        _this.type = constants_1.ErrorTypes.OTHER_ERROR;\n        _this.reason = reason;\n        _this.code = constants_1.ErrorCodes.hasOwnProperty(code) ?\n            constants_1.ErrorCodes[code] : \"\";\n        _this.fatal = !!fatal;\n        _this.message = errorMessage_1.default(_this.name, _this.code, _this.reason);\n        return _this;\n    }\n    return OtherError;\n}(Error));\nexports.default = OtherError;\n\n\n//# sourceURL=webpack://RxPlayer/./src/errors/OtherError.ts?");

/***/ }),

/***/ "./src/errors/RequestError.ts":
/*!************************************!*\
  !*** ./src/errors/RequestError.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Errors linked to the XHR implentation done in the RxPlayer.\n *\n * @class RequestError\n * @extends Error\n */\nvar RequestError = /** @class */ (function (_super) {\n    __extends(RequestError, _super);\n    function RequestError(xhr, url, type) {\n        var _this = _super.call(this) || this;\n        // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class\n        Object.setPrototypeOf(_this, RequestError.prototype);\n        _this.name = \"RequestError\";\n        _this.url = url;\n        _this.xhr = xhr;\n        _this.status = xhr.status;\n        _this.type = type;\n        _this.message = type;\n        return _this;\n    }\n    return RequestError;\n}(Error));\nexports.default = RequestError;\n\n\n//# sourceURL=webpack://RxPlayer/./src/errors/RequestError.ts?");

/***/ }),

/***/ "./src/errors/constants.ts":
/*!*********************************!*\
  !*** ./src/errors/constants.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ErrorTypes = {\n    NETWORK_ERROR: \"NETWORK_ERROR\",\n    MEDIA_ERROR: \"MEDIA_ERROR\",\n    ENCRYPTED_MEDIA_ERROR: \"ENCRYPTED_MEDIA_ERROR\",\n    INDEX_ERROR: \"INDEX_ERROR\",\n    OTHER_ERROR: \"OTHER_ERROR\",\n};\nexports.ErrorTypes = ErrorTypes;\nvar RequestErrorTypes = {\n    TIMEOUT: \"TIMEOUT\",\n    ERROR_EVENT: \"ERROR_EVENT\",\n    ERROR_HTTP_CODE: \"ERROR_HTTP_CODE\",\n    PARSE_ERROR: \"PARSE_ERROR\",\n};\nexports.RequestErrorTypes = RequestErrorTypes;\nvar ErrorCodes = {\n    PIPELINE_RESOLVE_ERROR: \"PIPELINE_RESOLVE_ERROR\",\n    PIPELINE_LOAD_ERROR: \"PIPELINE_LOAD_ERROR\",\n    PIPELINE_PARSING_ERROR: \"PIPELINE_PARSING_ERROR\",\n    MANIFEST_PARSE_ERROR: \"MANIFEST_PARSE_ERROR\",\n    MANIFEST_INCOMPATIBLE_CODECS_ERROR: \"MANIFEST_INCOMPATIBLE_CODECS_ERROR\",\n    MANIFEST_UNSUPPORTED_ADAPTATION_TYPE: \"MANIFEST_UNSUPPORTED_ADAPTATION_TYPE\",\n    UNAVAILABLE_MEDIA_SOURCE: \"UNAVAILABLE_MEDIA_SOURCE\",\n    MEDIA_STARTING_TIME_NOT_FOUND: \"MEDIA_STARTING_TIME_NOT_FOUND\",\n    MEDIA_TIME_NOT_FOUND: \"MEDIA_TIME_NOT_FOUND\",\n    MEDIA_IS_ENCRYPTED_ERROR: \"MEDIA_IS_ENCRYPTED_ERROR\",\n    KEY_ERROR: \"KEY_ERROR\",\n    KEY_STATUS_CHANGE_ERROR: \"KEY_STATUS_CHANGE_ERROR\",\n    KEY_UPDATE_ERROR: \"KEY_UPDATE_ERROR\",\n    KEY_LOAD_ERROR: \"KEY_LOAD_ERROR\",\n    KEY_LOAD_TIMEOUT: \"KEY_LOAD_TIMEOUT\",\n    KEY_GENERATE_REQUEST_ERROR: \"KEY_GENERATE_REQUEST_ERROR\",\n    INCOMPATIBLE_KEYSYSTEMS: \"INCOMPATIBLE_KEYSYSTEMS\",\n    LICENSE_SERVER_CERTIFICATE_ERROR: \"LICENSE_SERVER_CERTIFICATE_ERROR\",\n    BUFFER_APPEND_ERROR: \"BUFFER_APPEND_ERROR\",\n    BUFFER_FULL_ERROR: \"BUFFER_FULL_ERROR\",\n    BUFFER_TYPE_UNKNOWN: \"BUFFER_TYPE_UNKNOWN\",\n    MEDIA_ERR_ABORTED: \"MEDIA_ERR_ABORTED\",\n    MEDIA_ERR_NETWORK: \"MEDIA_ERR_NETWORK\",\n    MEDIA_ERR_DECODE: \"MEDIA_ERR_DECODE\",\n    MEDIA_ERR_SRC_NOT_SUPPORTED: \"MEDIA_ERR_SRC_NOT_SUPPORTED\",\n    MEDIA_ERR_UNKNOWN: \"MEDIA_ERR_UNKNOWN\",\n    MEDIA_SOURCE_NOT_SUPPORTED: \"MEDIA_SOURCE_NOT_SUPPORTED\",\n    MEDIA_KEYS_NOT_SUPPORTED: \"MEDIA_KEYS_NOT_SUPPORTED\",\n    OUT_OF_INDEX_ERROR: \"OUT_OF_INDEX_ERROR\",\n    UNKNOWN_INDEX: \"UNKNOWN_INDEX\",\n    UNKNOWN_ERROR: \"UNKNOWN_ERROR\",\n};\nexports.ErrorCodes = ErrorCodes;\n\n\n//# sourceURL=webpack://RxPlayer/./src/errors/constants.ts?");

/***/ }),

/***/ "./src/errors/errorMessage.ts":
/*!************************************!*\
  !*** ./src/errors/errorMessage.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Generate a normalized error message.\n * @param {string} name\n * @param {string} code\n * @param {Error|string} [reason]\n * @returns {string}\n */\nfunction errorMessage(name, code, reason) {\n    if (reason == null) {\n        return name + \" (\" + code + \")\";\n    }\n    else if (typeof reason === \"string\") {\n        return name + \" (\" + code + \") \" + reason;\n    }\n    else {\n        var message = reason instanceof Event ? reason.type : reason.message;\n        return name + \" (\" + code + \") \" + message;\n    }\n}\nexports.default = errorMessage;\n\n\n//# sourceURL=webpack://RxPlayer/./src/errors/errorMessage.ts?");

/***/ }),

/***/ "./src/errors/index.ts":
/*!*****************************!*\
  !*** ./src/errors/index.ts ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar constants_1 = __webpack_require__(/*! ./constants */ \"./src/errors/constants.ts\");\nexports.ErrorCodes = constants_1.ErrorCodes;\nexports.ErrorTypes = constants_1.ErrorTypes;\nexports.RequestErrorTypes = constants_1.RequestErrorTypes;\n// Custom Errors\nvar EncryptedMediaError_1 = __webpack_require__(/*! ./EncryptedMediaError */ \"./src/errors/EncryptedMediaError.ts\");\nexports.EncryptedMediaError = EncryptedMediaError_1.default;\nvar IndexError_1 = __webpack_require__(/*! ./IndexError */ \"./src/errors/IndexError.ts\");\nexports.IndexError = IndexError_1.default;\nvar MediaError_1 = __webpack_require__(/*! ./MediaError */ \"./src/errors/MediaError.ts\");\nexports.MediaError = MediaError_1.default;\nvar OtherError_1 = __webpack_require__(/*! ./OtherError */ \"./src/errors/OtherError.ts\");\nexports.OtherError = OtherError_1.default;\nvar NetworkError_1 = __webpack_require__(/*! ./NetworkError */ \"./src/errors/NetworkError.ts\");\nexports.NetworkError = NetworkError_1.default;\n// Error used for XHRs\nvar RequestError_1 = __webpack_require__(/*! ./RequestError */ \"./src/errors/RequestError.ts\");\nexports.RequestError = RequestError_1.default;\n/**\n * Whether the error given is a CustomError.\n * @param {Error} error\n * @returns {Boolean}\n */\nfunction isKnownError(error) {\n    return (!!error &&\n        !!error.type &&\n        Object.keys(constants_1.ErrorTypes).indexOf(error.type) >= 0);\n}\nexports.isKnownError = isKnownError;\n\n\n//# sourceURL=webpack://RxPlayer/./src/errors/index.ts?");

/***/ }),

/***/ "./src/exports.ts":
/*!************************!*\
  !*** ./src/exports.ts ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// ugly webpack workaround to export require-style\n/* tslint:disable no-var-requires */\nmodule.exports = __webpack_require__(/*! ./index.ts */ \"./src/index.ts\").default;\n/* tslint:enable no-var-requires */\n\n\n//# sourceURL=webpack://RxPlayer/./src/exports.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__webpack_require__(/*! rxjs/add/observable/combineLatest */ \"./node_modules/rxjs/add/observable/combineLatest.js\");\n__webpack_require__(/*! rxjs/add/observable/defer */ \"./node_modules/rxjs/add/observable/defer.js\");\n__webpack_require__(/*! rxjs/add/observable/empty */ \"./node_modules/rxjs/add/observable/empty.js\");\n__webpack_require__(/*! rxjs/add/observable/from */ \"./node_modules/rxjs/add/observable/from.js\");\n__webpack_require__(/*! rxjs/add/observable/fromEvent */ \"./node_modules/rxjs/add/observable/fromEvent.js\");\n__webpack_require__(/*! rxjs/add/observable/fromPromise */ \"./node_modules/rxjs/add/observable/fromPromise.js\");\n__webpack_require__(/*! rxjs/add/observable/interval */ \"./node_modules/rxjs/add/observable/interval.js\");\n__webpack_require__(/*! rxjs/add/observable/merge */ \"./node_modules/rxjs/add/observable/merge.js\");\n__webpack_require__(/*! rxjs/add/observable/never */ \"./node_modules/rxjs/add/observable/never.js\");\n__webpack_require__(/*! rxjs/add/observable/of */ \"./node_modules/rxjs/add/observable/of.js\");\n__webpack_require__(/*! rxjs/add/observable/throw */ \"./node_modules/rxjs/add/observable/throw.js\");\n__webpack_require__(/*! rxjs/add/observable/timer */ \"./node_modules/rxjs/add/observable/timer.js\");\n__webpack_require__(/*! rxjs/add/operator/catch */ \"./node_modules/rxjs/add/operator/catch.js\");\n__webpack_require__(/*! rxjs/add/operator/concat */ \"./node_modules/rxjs/add/operator/concat.js\");\n__webpack_require__(/*! rxjs/add/operator/concatAll */ \"./node_modules/rxjs/add/operator/concatAll.js\");\n__webpack_require__(/*! rxjs/add/operator/concatMap */ \"./node_modules/rxjs/add/operator/concatMap.js\");\n__webpack_require__(/*! rxjs/add/operator/debounceTime */ \"./node_modules/rxjs/add/operator/debounceTime.js\");\n__webpack_require__(/*! rxjs/add/operator/distinctUntilChanged */ \"./node_modules/rxjs/add/operator/distinctUntilChanged.js\");\n__webpack_require__(/*! rxjs/add/operator/do */ \"./node_modules/rxjs/add/operator/do.js\");\n__webpack_require__(/*! rxjs/add/operator/exhaustMap */ \"./node_modules/rxjs/add/operator/exhaustMap.js\");\n__webpack_require__(/*! rxjs/add/operator/filter */ \"./node_modules/rxjs/add/operator/filter.js\");\n__webpack_require__(/*! rxjs/add/operator/finally */ \"./node_modules/rxjs/add/operator/finally.js\");\n__webpack_require__(/*! rxjs/add/operator/ignoreElements */ \"./node_modules/rxjs/add/operator/ignoreElements.js\");\n__webpack_require__(/*! rxjs/add/operator/map */ \"./node_modules/rxjs/add/operator/map.js\");\n__webpack_require__(/*! rxjs/add/operator/mapTo */ \"./node_modules/rxjs/add/operator/mapTo.js\");\n__webpack_require__(/*! rxjs/add/operator/merge */ \"./node_modules/rxjs/add/operator/merge.js\");\n__webpack_require__(/*! rxjs/add/operator/mergeMap */ \"./node_modules/rxjs/add/operator/mergeMap.js\");\n__webpack_require__(/*! rxjs/add/operator/mergeMapTo */ \"./node_modules/rxjs/add/operator/mergeMapTo.js\");\n__webpack_require__(/*! rxjs/add/operator/multicast */ \"./node_modules/rxjs/add/operator/multicast.js\");\n__webpack_require__(/*! rxjs/add/operator/pairwise */ \"./node_modules/rxjs/add/operator/pairwise.js\");\n__webpack_require__(/*! rxjs/add/operator/publish */ \"./node_modules/rxjs/add/operator/publish.js\");\n__webpack_require__(/*! rxjs/add/operator/scan */ \"./node_modules/rxjs/add/operator/scan.js\");\n__webpack_require__(/*! rxjs/add/operator/share */ \"./node_modules/rxjs/add/operator/share.js\");\n__webpack_require__(/*! rxjs/add/operator/skip */ \"./node_modules/rxjs/add/operator/skip.js\");\n__webpack_require__(/*! rxjs/add/operator/skipUntil */ \"./node_modules/rxjs/add/operator/skipUntil.js\");\n__webpack_require__(/*! rxjs/add/operator/skipWhile */ \"./node_modules/rxjs/add/operator/skipWhile.js\");\n__webpack_require__(/*! rxjs/add/operator/startWith */ \"./node_modules/rxjs/add/operator/startWith.js\");\n__webpack_require__(/*! rxjs/add/operator/switchMap */ \"./node_modules/rxjs/add/operator/switchMap.js\");\n__webpack_require__(/*! rxjs/add/operator/switchMapTo */ \"./node_modules/rxjs/add/operator/switchMapTo.js\");\n__webpack_require__(/*! rxjs/add/operator/take */ \"./node_modules/rxjs/add/operator/take.js\");\n__webpack_require__(/*! rxjs/add/operator/takeUntil */ \"./node_modules/rxjs/add/operator/takeUntil.js\");\n__webpack_require__(/*! rxjs/add/operator/timeout */ \"./node_modules/rxjs/add/operator/timeout.js\");\n__webpack_require__(/*! rxjs/add/operator/withLatestFrom */ \"./node_modules/rxjs/add/operator/withLatestFrom.js\");\nvar log_1 = __webpack_require__(/*! ./utils/log */ \"./src/utils/log.ts\");\nvar api_1 = __webpack_require__(/*! ./core/api */ \"./src/core/api/index.ts\");\nif (true) {\n    log_1.default.setLevel(\"INFO\");\n}\nexports.default = api_1.default;\n\n\n//# sourceURL=webpack://RxPlayer/./src/index.ts?");

/***/ }),

/***/ "./src/manifest/adaptation.ts":
/*!************************************!*\
  !*** ./src/manifest/adaptation.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar arrayFind = __webpack_require__(/*! array-find */ \"./node_modules/array-find/find.js\");\nvar objectAssign = __webpack_require__(/*! object-assign */ \"./node_modules/object-assign/index.js\");\nvar id_1 = __webpack_require__(/*! ../utils/id */ \"./src/utils/id.ts\");\nvar representation_1 = __webpack_require__(/*! ./representation */ \"./src/manifest/representation.ts\");\n/**\n * Normalized Adaptation structure.\n * @class Adaptation\n */\nvar Adaptation = /** @class */ (function () {\n    /**\n     * @constructor\n     */\n    function Adaptation(args) {\n        var _this = this;\n        var nId = id_1.default();\n        this.id = args.id == null ? nId : \"\" + args.id;\n        this.type = args.type;\n        this.representations = Array.isArray(args.representations) ?\n            args.representations\n                .map(function (r) { return new representation_1.default(objectAssign({ rootId: _this.id }, r)); })\n                .sort(function (a, b) { return a.bitrate - b.bitrate; }) : [];\n        if (args.language != null) {\n            this.language = args.language;\n        }\n        if (args.normalizedLanguage != null) {\n            this.normalizedLanguage = args.normalizedLanguage;\n        }\n        if (args.closedCaption != null) {\n            this.isClosedCaption = args.closedCaption;\n        }\n        if (args.audioDescription != null) {\n            this.isAudioDescription = args.audioDescription;\n        }\n        // TODO move to DASH's Segment private infos\n        if (args.contentProtection != null) {\n            this.contentProtection = args.contentProtection;\n        }\n        // for manuallyAdded adaptations (not in the manifest)\n        this.manuallyAdded = !!args.manuallyAdded;\n    }\n    /**\n     * @returns {Array.<Number>}\n     */\n    Adaptation.prototype.getAvailableBitrates = function () {\n        return this.representations\n            .map(function (r) { return r.bitrate; });\n    };\n    /**\n     * @param {Number|string} wantedId\n     * @returns {Representation}\n     */\n    Adaptation.prototype.getRepresentation = function (wantedId) {\n        return arrayFind(this.representations, function (_a) {\n            var id = _a.id;\n            return wantedId === id;\n        });\n    };\n    /**\n     * @param {Number} bitrate\n     * @returns {Representations[]|null}\n     */\n    Adaptation.prototype.getRepresentationsForBitrate = function (bitrate) {\n        return this.representations.filter(function (r) { return r.bitrate === bitrate; }) || null;\n    };\n    return Adaptation;\n}());\nexports.default = Adaptation;\n\n\n//# sourceURL=webpack://RxPlayer/./src/manifest/adaptation.ts?");

/***/ }),

/***/ "./src/manifest/factory.ts":
/*!*********************************!*\
  !*** ./src/manifest/factory.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar compat_1 = __webpack_require__(/*! ../compat */ \"./src/compat/index.ts\");\nvar errors_1 = __webpack_require__(/*! ../errors */ \"./src/errors/index.ts\");\nvar log_1 = __webpack_require__(/*! ../utils/log */ \"./src/utils/log.ts\");\nvar index_1 = __webpack_require__(/*! ./index */ \"./src/manifest/index.ts\");\nvar SUPPORTED_ADAPTATIONS_TYPE = [\"audio\", \"video\", \"text\", \"image\"];\n/**\n * Run multiple checks before creating the Manifest:\n *   - filter out unsupported adaptation types\n *   - filter out adaptations without representations\n *   - filter out representations with an unsupported codec\n *   - check that every periods have at least one adaptation left\n *   - check that every adaptations have at least one representation left\n *\n * Then create a manifest and:\n *   - add supplementary text tracks\n *   - add supplementary image tracks\n *\n * @param {Object} manifest - the parsed manifest\n * @param {Array.<Object>|Object} externalTextTracks - Will be added to the\n * manifest as an adaptation.\n * @param {Array.<Object>|Object} externalImageTracks - Will be added to the\n * manifest as an adaptation.\n * @returns {Object}\n */\nfunction createManifest(manifestObject, externalTextTracks, externalImageTracks, warning$) {\n    manifestObject.periods = (manifestObject.periods).map(function (period) {\n        period.adaptations = checkAdaptations(period.adaptations, warning$);\n        return period;\n    });\n    // TODO Better way than this \"as\"\n    var manifest = new index_1.default(manifestObject);\n    manifest.addSupplementaryTextAdaptations(externalTextTracks);\n    manifest.addSupplementaryImageAdaptations(externalImageTracks);\n    return manifest;\n}\nexports.default = createManifest;\n/**\n * Performs multiple checks on adaptations from a single period (things not\n * check-able by TypeScript itself like length of arrays).\n * Also filter unsupported codecs and unsupported adaptations types.\n * Throws if something is wrong.\n *\n * @param {Array.<Object>} initialAdaptations\n * @returns {Array.<Object>}\n */\nfunction checkAdaptations(initialAdaptations, warning$) {\n    var adaptations = initialAdaptations\n        // 1. filter out adaptations from unsupported types\n        .filter(function (adaptation) {\n        if (SUPPORTED_ADAPTATIONS_TYPE.indexOf(adaptation.type) < 0) {\n            log_1.default.info(\"not supported adaptation type\", adaptation.type);\n            var error = new errors_1.MediaError(\"MANIFEST_UNSUPPORTED_ADAPTATION_TYPE\", null, false);\n            warning$.next(error);\n            return false;\n        }\n        else {\n            return true;\n        }\n    })\n        .map(function (adaptation) {\n        if (adaptation.representations.length) {\n            // 2. Filter from codecs and throw if none supported\n            adaptation.representations = filterSupportedRepresentations(adaptation.type, adaptation.representations);\n            if (adaptation.representations.length === 0) {\n                log_1.default.warn(\"Incompatible codecs for adaptation\", adaptation);\n                var error = new errors_1.MediaError(\"MANIFEST_INCOMPATIBLE_CODECS_ERROR\", null, false);\n                warning$.next(error);\n            }\n        }\n        return adaptation;\n    })\n        // 3. filter those without representations\n        .filter(function (_a) {\n        var representations = _a.representations;\n        return representations.length;\n    });\n    // 4. throw if no adaptation\n    if (adaptations.length === 0) {\n        throw new errors_1.MediaError(\"MANIFEST_PARSE_ERROR\", null, true);\n    }\n    return adaptations;\n}\n/**\n * @param {string} adaptationType\n * @param {Array.<Object>} representations\n * @returns {Array.<Object>}\n */\nfunction filterSupportedRepresentations(adaptationType, representations) {\n    if (adaptationType === \"audio\" || adaptationType === \"video\") {\n        return representations\n            .filter(function (representation) {\n            return compat_1.isCodecSupported(getCodec(representation));\n        });\n    }\n    // TODO for the other types\n    return representations;\n    /**\n     * Construct the codec string from given codecs and mimetype.\n     * @param {Object} representation\n     * @returns {string}\n     */\n    function getCodec(representation) {\n        var _a = representation.codecs, codecs = _a === void 0 ? \"\" : _a, _b = representation.mimeType, mimeType = _b === void 0 ? \"\" : _b;\n        return mimeType + \";codecs=\\\"\" + codecs + \"\\\"\";\n    }\n}\n\n\n//# sourceURL=webpack://RxPlayer/./src/manifest/factory.ts?");

/***/ }),

/***/ "./src/manifest/index.ts":
/*!*******************************!*\
  !*** ./src/manifest/index.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar arrayFind = __webpack_require__(/*! array-find */ \"./node_modules/array-find/find.js\");\nvar assert_1 = __webpack_require__(/*! ../utils/assert */ \"./src/utils/assert.ts\");\nvar id_1 = __webpack_require__(/*! ../utils/id */ \"./src/utils/id.ts\");\nvar languages_1 = __webpack_require__(/*! ../utils/languages */ \"./src/utils/languages/index.ts\");\nvar log_1 = __webpack_require__(/*! ../utils/log */ \"./src/utils/log.ts\");\nvar adaptation_1 = __webpack_require__(/*! ./adaptation */ \"./src/manifest/adaptation.ts\");\nexports.Adaptation = adaptation_1.default;\nvar period_1 = __webpack_require__(/*! ./period */ \"./src/manifest/period.ts\");\nexports.Period = period_1.default;\nvar representation_1 = __webpack_require__(/*! ./representation */ \"./src/manifest/representation.ts\");\nexports.Representation = representation_1.default;\nvar representation_index_1 = __webpack_require__(/*! ./representation_index */ \"./src/manifest/representation_index/index.ts\");\n/**\n * Normalized Manifest structure.\n * @class Manifest\n */\nvar Manifest = /** @class */ (function () {\n    /**\n     * @constructor\n     * @param {Object} args\n     */\n    function Manifest(args) {\n        var nId = id_1.default();\n        this.id = args.id == null ? nId : \"\" + args.id;\n        this.transport = args.transportType || \"\";\n        // TODO Real period management\n        this.periods = args.periods.map(function (period) {\n            return new period_1.default(period);\n        });\n        /**\n         * @deprecated TODO It is here to ensure compatibility with the way the\n         * v3.x.x manages adaptations at the Manifest level\n         */\n        this.adaptations = (this.periods[0] && this.periods[0].adaptations) || [];\n        this.minimumTime = args.minimumTime;\n        this.isLive = args.type === \"dynamic\";\n        this.uris = args.uris;\n        this.suggestedPresentationDelay = args.suggestedPresentationDelay;\n        this.availabilityStartTime = args.availabilityStartTime;\n        this.presentationLiveGap = args.presentationLiveGap;\n        this.timeShiftBufferDepth = args.timeShiftBufferDepth;\n        // --------- private data\n        this._duration = args.duration;\n        if (true && this.isLive) {\n            assert_1.default(this.suggestedPresentationDelay != null);\n            assert_1.default(this.availabilityStartTime != null);\n            assert_1.default(this.presentationLiveGap != null);\n            assert_1.default(this.timeShiftBufferDepth != null);\n        }\n    }\n    /**\n     * Add supplementary image Adaptation(s) to the manifest.\n     * @param {Object|Array.<Object>} imageTracks\n     */\n    Manifest.prototype.addSupplementaryImageAdaptations = function (imageTracks) {\n        var _imageTracks = Array.isArray(imageTracks) ? imageTracks : [imageTracks];\n        var newImageTracks = _imageTracks.map(function (_a) {\n            var mimeType = _a.mimeType, url = _a.url;\n            var adaptationID = \"gen-image-ada-\" + id_1.default();\n            var representationID = \"gen-image-rep-\" + id_1.default();\n            return new adaptation_1.default({\n                id: adaptationID,\n                type: \"image\",\n                manuallyAdded: true,\n                representations: [{\n                        baseURL: url,\n                        bitrate: 0,\n                        id: representationID,\n                        mimeType: mimeType,\n                        index: new representation_index_1.StaticRepresentationIndex(),\n                    }],\n            });\n        });\n        if (newImageTracks.length) {\n            this.adaptations.image = this.adaptations.image ?\n                this.adaptations.image.concat(newImageTracks) : newImageTracks;\n        }\n    };\n    /**\n     * Add supplementary text Adaptation(s) to the manifest.\n     * @param {Object|Array.<Object>} textTracks\n     */\n    Manifest.prototype.addSupplementaryTextAdaptations = function (textTracks) {\n        var _textTracks = Array.isArray(textTracks) ? textTracks : [textTracks];\n        var newTextAdaptations = _textTracks.reduce(function (allSubs, _a) {\n            var mimeType = _a.mimeType, codecs = _a.codecs, url = _a.url, language = _a.language, languages = _a.languages, closedCaption = _a.closedCaption;\n            var langsToMapOn = language ? [language] : languages || [];\n            return allSubs.concat(langsToMapOn.map(function (_language) {\n                var adaptationID = \"gen-text-ada-\" + id_1.default();\n                var representationID = \"gen-text-rep-\" + id_1.default();\n                return new adaptation_1.default({\n                    id: adaptationID,\n                    type: \"text\",\n                    language: _language,\n                    normalizedLanguage: languages_1.normalize(_language),\n                    closedCaption: closedCaption,\n                    manuallyAdded: true,\n                    representations: [{\n                            baseURL: url,\n                            bitrate: 0,\n                            id: representationID,\n                            mimeType: mimeType,\n                            codecs: codecs,\n                            index: new representation_index_1.StaticRepresentationIndex(),\n                        }],\n                });\n            }));\n        }, []);\n        if (newTextAdaptations.length) {\n            this.adaptations.text = this.adaptations.text ?\n                this.adaptations.text.concat(newTextAdaptations) : newTextAdaptations;\n        }\n    };\n    /**\n     * Returns Period encountered at the given time.\n     * Returns undefined if there is no Period exactly at the given time.\n     * @param {number} time\n     * @returns {Period|undefined}\n     */\n    Manifest.prototype.getPeriodForTime = function (time) {\n        return arrayFind(this.periods, function (period) {\n            return time >= period.start &&\n                (period.end == null || period.end > time);\n        });\n    };\n    /**\n     * Returns period coming just after a given period.\n     * Returns undefined if not found.\n     * @param {Period} period\n     * @returns {Period|null}\n     */\n    Manifest.prototype.getPeriodAfter = function (period) {\n        var endOfPeriod = period.end;\n        if (endOfPeriod == null) {\n            return null;\n        }\n        return arrayFind(this.periods, function (_period) {\n            return _period.end == null || endOfPeriod < _period.end;\n        }) || null;\n    };\n    /**\n     * @returns {Number}\n     */\n    Manifest.prototype.getDuration = function () {\n        return this._duration;\n    };\n    /**\n     * @returns {string|undefined}\n     */\n    Manifest.prototype.getUrl = function () {\n        return this.uris[0];\n    };\n    /**\n     * TODO log deprecation\n     * @deprecated only returns adaptations for the first period\n     * @returns {Array.<Object>}\n     */\n    Manifest.prototype.getAdaptations = function () {\n        var firstPeriod = this.periods[0];\n        if (!firstPeriod) {\n            return [];\n        }\n        var adaptationsByType = firstPeriod.adaptations;\n        var adaptationsList = [];\n        for (var adaptationType in adaptationsByType) {\n            if (adaptationsByType.hasOwnProperty(adaptationType)) {\n                var adaptations = adaptationsByType[adaptationType];\n                adaptationsList.push.apply(adaptationsList, adaptations);\n            }\n        }\n        return adaptationsList;\n    };\n    /**\n     * TODO log deprecation\n     * @deprecated only returns adaptations for the first period\n     * @returns {Array.<Object>}\n     */\n    Manifest.prototype.getAdaptationsForType = function (adaptationType) {\n        var firstPeriod = this.periods[0];\n        if (!firstPeriod) {\n            return [];\n        }\n        return firstPeriod.adaptations[adaptationType] || [];\n    };\n    /**\n     * TODO log deprecation\n     * @deprecated only returns adaptations for the first period\n     * @returns {Array.<Object>}\n     */\n    Manifest.prototype.getAdaptation = function (wantedId) {\n        /* tslint:disable:deprecation */\n        return arrayFind(this.getAdaptations(), function (_a) {\n            var id = _a.id;\n            return wantedId === id;\n        });\n        /* tslint:enable:deprecation */\n    };\n    /**\n     * @param {number} delta\n     */\n    Manifest.prototype.updateLiveGap = function (delta) {\n        if (this.isLive) {\n            if (this.presentationLiveGap) {\n                this.presentationLiveGap += delta;\n            }\n            else {\n                this.presentationLiveGap = delta;\n            }\n        }\n    };\n    /**\n     * Update the current manifest properties\n     * @param {Object} Manifest\n     */\n    Manifest.prototype.update = function (newManifest) {\n        this._duration = newManifest.getDuration();\n        this.timeShiftBufferDepth = newManifest.timeShiftBufferDepth;\n        this.availabilityStartTime = newManifest.availabilityStartTime;\n        this.suggestedPresentationDelay = newManifest.suggestedPresentationDelay;\n        this.uris = newManifest.uris;\n        var oldPeriods = this.periods;\n        var newPeriods = newManifest.periods;\n        var _loop_1 = function (i) {\n            var oldPeriod = oldPeriods[i];\n            var newPeriod = arrayFind(newPeriods, function (a) { return a.id === oldPeriod.id; });\n            if (!newPeriod) {\n                log_1.default.info(\"Period \" + oldPeriod.id + \" not found after update. Removing.\");\n                oldPeriods.splice(i, 1);\n                i--;\n            }\n            else {\n                oldPeriod.start = newPeriod.start;\n                oldPeriod.end = newPeriod.end;\n                oldPeriod.duration = newPeriod.duration;\n                var oldAdaptations = oldPeriod.getAdaptations();\n                var newAdaptations = newPeriod.getAdaptations();\n                var _loop_2 = function (j) {\n                    var oldAdaptation = oldAdaptations[j];\n                    var newAdaptation = arrayFind(newAdaptations, function (a) { return a.id === oldAdaptation.id; });\n                    if (!newAdaptation) {\n                        log_1.default.warn(\"manifest: adaptation \\\"\" + oldAdaptations[j].id + \"\\\" not found when merging.\");\n                    }\n                    else {\n                        var oldRepresentations = oldAdaptations[j].representations;\n                        var newRepresentations = newAdaptation.representations;\n                        var _loop_3 = function (k) {\n                            var oldRepresentation = oldRepresentations[k];\n                            var newRepresentation = arrayFind(newRepresentations, function (r) { return r.id === oldRepresentation.id; });\n                            if (!newRepresentation) {\n                                /* tslint:disable:max-line-length */\n                                log_1.default.warn(\"manifest: representation \\\"\" + oldRepresentations[k].id + \"\\\" not found when merging.\");\n                                /* tslint:enable:max-line-length */\n                            }\n                            else {\n                                oldRepresentation.baseURL = newRepresentation.baseURL;\n                                oldRepresentations[k].index._update(newRepresentation.index);\n                            }\n                        };\n                        for (var k = 0; k < oldRepresentations.length; k++) {\n                            _loop_3(k);\n                        }\n                    }\n                };\n                for (var j = 0; j < oldAdaptations.length; j++) {\n                    _loop_2(j);\n                }\n            }\n            out_i_1 = i;\n        };\n        var out_i_1;\n        for (var i = 0; i < oldPeriods.length; i++) {\n            _loop_1(i);\n            i = out_i_1;\n        }\n        // adding - perhaps - new Period[s]\n        if (newPeriods.length > oldPeriods.length) {\n            var lastOldPeriod = oldPeriods[oldPeriods.length - 1];\n            if (lastOldPeriod) {\n                for (var i = 0; i < newPeriods.length - 1; i++) {\n                    var newPeriod = newPeriods[i];\n                    if (newPeriod.start > lastOldPeriod.start) {\n                        log_1.default.info(\"Adding new period \" + newPeriod.id);\n                        this.periods.push(newPeriod);\n                    }\n                }\n            }\n            else {\n                for (var i = 0; i < newPeriods.length - 1; i++) {\n                    var newPeriod = newPeriods[i];\n                    log_1.default.info(\"Adding new period \" + newPeriod.id);\n                    this.periods.push(newPeriod);\n                }\n            }\n        }\n    };\n    return Manifest;\n}());\nexports.default = Manifest;\n\n\n//# sourceURL=webpack://RxPlayer/./src/manifest/index.ts?");

/***/ }),

/***/ "./src/manifest/period.ts":
/*!********************************!*\
  !*** ./src/manifest/period.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar arrayFind = __webpack_require__(/*! array-find */ \"./node_modules/array-find/find.js\");\nvar id_1 = __webpack_require__(/*! ../utils/id */ \"./src/utils/id.ts\");\nvar languages_1 = __webpack_require__(/*! ../utils/languages */ \"./src/utils/languages/index.ts\");\nvar adaptation_1 = __webpack_require__(/*! ./adaptation */ \"./src/manifest/adaptation.ts\");\nvar representation_index_1 = __webpack_require__(/*! ./representation_index */ \"./src/manifest/representation_index/index.ts\");\n/**\n * @param {Array.<Object>} adaptations\n * @returns {Object}\n */\nfunction createManifestAdaptations(adaptations) {\n    return adaptations.reduce(function (acc, adaptation) {\n        var type = adaptation.type, representations = adaptation.representations;\n        if (!representations.length) {\n            return acc;\n        }\n        if (!acc[type]) {\n            acc[type] = [];\n        }\n        acc[type].push(new adaptation_1.default(adaptation));\n        return acc;\n    }, {});\n}\nvar Period = /** @class */ (function () {\n    /**\n     * @constructor\n     * @param {Object} args\n     */\n    function Period(args) {\n        this.id = args.id;\n        this.adaptations = createManifestAdaptations(args.adaptations);\n        this.duration = args.duration;\n        this.start = args.start;\n        if (this.duration != null && this.start != null) {\n            this.end = this.start + this.duration;\n        }\n    }\n    /**\n     * Add supplementary image Adaptation(s) to the manifest.\n     * @param {Object|Array.<Object>} imageTracks\n     */\n    Period.prototype.addSupplementaryImageAdaptations = function (imageTracks) {\n        var _imageTracks = Array.isArray(imageTracks) ? imageTracks : [imageTracks];\n        var newImageTracks = _imageTracks.map(function (_a) {\n            var mimeType = _a.mimeType, url = _a.url;\n            var adaptationID = \"gen-image-ada-\" + id_1.default();\n            var representationID = \"gen-image-rep-\" + id_1.default();\n            return new adaptation_1.default({\n                id: adaptationID,\n                type: \"image\",\n                manuallyAdded: true,\n                representations: [{\n                        baseURL: url,\n                        bitrate: 0,\n                        id: representationID,\n                        mimeType: mimeType,\n                        index: new representation_index_1.StaticRepresentationIndex(),\n                    }],\n            });\n        });\n        if (newImageTracks.length) {\n            this.adaptations.image = this.adaptations.image ?\n                this.adaptations.image.concat(newImageTracks) : newImageTracks;\n        }\n    };\n    /**\n     * Add supplementary text Adaptation(s) to the manifest.\n     * @param {Object|Array.<Object>} textTracks\n     */\n    Period.prototype.addSupplementaryTextAdaptations = function (textTracks) {\n        var _textTracks = Array.isArray(textTracks) ? textTracks : [textTracks];\n        var newTextAdaptations = _textTracks.reduce(function (allSubs, _a) {\n            var mimeType = _a.mimeType, codecs = _a.codecs, url = _a.url, language = _a.language, languages = _a.languages, closedCaption = _a.closedCaption;\n            var langsToMapOn = language ? [language] : languages || [];\n            return allSubs.concat(langsToMapOn.map(function (_language) {\n                var adaptationID = \"gen-text-ada-\" + id_1.default();\n                var representationID = \"gen-text-rep-\" + id_1.default();\n                return new adaptation_1.default({\n                    id: adaptationID,\n                    type: \"text\",\n                    language: _language,\n                    normalizedLanguage: languages_1.normalize(_language),\n                    closedCaption: closedCaption,\n                    manuallyAdded: true,\n                    representations: [{\n                            baseURL: url,\n                            bitrate: 0,\n                            id: representationID,\n                            mimeType: mimeType,\n                            codecs: codecs,\n                            index: new representation_index_1.StaticRepresentationIndex(),\n                        }],\n                });\n            }));\n        }, []);\n        if (newTextAdaptations.length) {\n            this.adaptations.text = this.adaptations.text ?\n                this.adaptations.text.concat(newTextAdaptations) : newTextAdaptations;\n        }\n    };\n    /**\n     * @returns {Array.<Object>}\n     */\n    Period.prototype.getAdaptations = function () {\n        var adaptationsByType = this.adaptations;\n        if (!adaptationsByType) {\n            return [];\n        }\n        var adaptationsList = [];\n        for (var adaptationType in adaptationsByType) {\n            if (adaptationsByType.hasOwnProperty(adaptationType)) {\n                var adaptations = adaptationsByType[adaptationType];\n                adaptationsList.push.apply(adaptationsList, adaptations);\n            }\n        }\n        return adaptationsList;\n    };\n    Period.prototype.getAdaptationsForType = function (adaptationType) {\n        var adaptations = this.adaptations[adaptationType];\n        return adaptations || [];\n    };\n    Period.prototype.getAdaptation = function (wantedId) {\n        return arrayFind(this.getAdaptations(), function (_a) {\n            var id = _a.id;\n            return wantedId === id;\n        });\n    };\n    return Period;\n}());\nexports.default = Period;\n\n\n//# sourceURL=webpack://RxPlayer/./src/manifest/period.ts?");

/***/ }),

/***/ "./src/manifest/representation.ts":
/*!****************************************!*\
  !*** ./src/manifest/representation.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar id_1 = __webpack_require__(/*! ../utils/id */ \"./src/utils/id.ts\");\n/**\n * Normalized Representation structure.\n * @class Representation\n */\nvar Representation = /** @class */ (function () {\n    /**\n     * @constructor\n     * @param {Object} [args={}]\n     * @param {string|Number} [args.id]\n     * @param {Number} args.bitrate\n     * @param {string} args.codecs\n     * @param {Number} args.height\n     * @param {Number} args.width\n     * @param {string} args.mimeType\n     * @param {Object} args.index\n     */\n    function Representation(args) {\n        var nId = id_1.default();\n        this.id = (args.id == null ? nId : args.id);\n        this.bitrate = args.bitrate;\n        this.codec = args.codecs;\n        if (args.height != null) {\n            this.height = args.height;\n        }\n        if (args.width != null) {\n            this.width = args.width;\n        }\n        if (args.mimeType != null) {\n            this.mimeType = args.mimeType;\n        }\n        this.index = args.index;\n        this.baseURL = args.baseURL;\n    }\n    Representation.prototype.getMimeTypeString = function () {\n        return this.mimeType + \";codecs=\\\"\" + this.codec + \"\\\"\";\n    };\n    return Representation;\n}());\nexports.default = Representation;\n\n\n//# sourceURL=webpack://RxPlayer/./src/manifest/representation.ts?");

/***/ }),

/***/ "./src/manifest/representation_index/index.ts":
/*!****************************************************!*\
  !*** ./src/manifest/representation_index/index.ts ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar static_1 = __webpack_require__(/*! ./static */ \"./src/manifest/representation_index/static.ts\");\nexports.StaticRepresentationIndex = static_1.default;\n\n\n//# sourceURL=webpack://RxPlayer/./src/manifest/representation_index/index.ts?");

/***/ }),

/***/ "./src/manifest/representation_index/static.ts":
/*!*****************************************************!*\
  !*** ./src/manifest/representation_index/static.ts ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar log_1 = __webpack_require__(/*! ../../utils/log */ \"./src/utils/log.ts\");\n/**\n * Simple RepresentationIndex implementation for static files.\n * @class StaticRepresentationIndex\n */\nvar StaticRepresentationIndex = /** @class */ (function () {\n    function StaticRepresentationIndex() {\n    }\n    /**\n     * @returns {Object}\n     */\n    StaticRepresentationIndex.prototype.getInitSegment = function () {\n        return null;\n    };\n    /**\n     * Returns the only Segment available here.\n     * @returns {Array.<Object>}\n     */\n    StaticRepresentationIndex.prototype.getSegments = function () {\n        return [{\n                id: \"0\",\n                isInit: false,\n                number: 0,\n                time: 0,\n                duration: Number.MAX_VALUE,\n                timescale: 1,\n            }];\n    };\n    /**\n     * Returns first position in index.\n     * @returns {undefined}\n     */\n    StaticRepresentationIndex.prototype.getFirstPosition = function () {\n        // TODO tslint bug? Document.\n        /* tslint:disable return-undefined */\n        return undefined;\n        /* tslint:enable return-undefined */\n    };\n    /**\n     * Returns last position in index.\n     * @returns {undefined}\n     */\n    StaticRepresentationIndex.prototype.getLastPosition = function () {\n        // TODO tslint bug? Document.\n        /* tslint:disable return-undefined */\n        return undefined;\n        /* tslint:enable return-undefined */\n    };\n    /**\n     * Returns true if, based on the arguments, the index should be refreshed.\n     * @returns {Boolean}\n     */\n    StaticRepresentationIndex.prototype.shouldRefresh = function () {\n        return false;\n    };\n    /**\n     * @returns {Number}\n     */\n    StaticRepresentationIndex.prototype.checkDiscontinuity = function () {\n        return -1;\n    };\n    /**\n     * @returns {Array}\n     */\n    StaticRepresentationIndex.prototype._addSegments = function () {\n        if (true) {\n            log_1.default.warn(\"Tried add Segments to a static RepresentationIndex\");\n        }\n    };\n    StaticRepresentationIndex.prototype._update = function () {\n        log_1.default.warn(\"Tried to update a static RepresentationIndex\");\n    };\n    return StaticRepresentationIndex;\n}());\nexports.default = StaticRepresentationIndex;\n\n\n//# sourceURL=webpack://RxPlayer/./src/manifest/representation_index/static.ts?");

/***/ }),

/***/ "./src/manifest/timings.ts":
/*!*********************************!*\
  !*** ./src/manifest/timings.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction toWallClockTime(position, manifest) {\n    return new Date((position + (manifest.availabilityStartTime || 0)) * 1000);\n}\nexports.toWallClockTime = toWallClockTime;\n/**\n * TODO This function should have more of a seekTo kind of name\n * ``fromWallClockTime`` should probably just do:\n * ```js\n * (timeInSeconds, manifest) => {\n *   return timeInSeconds - manifest.availabilityStartTime;\n * };\n * ```\n * It should be the exact opposite of ``toWallClockTime``\n */\nfunction fromWallClockTime(timeInMs, manifest) {\n    return normalizeWallClockTime(timeInMs, manifest) / 1000\n        - (manifest.availabilityStartTime || 0);\n}\nexports.fromWallClockTime = fromWallClockTime;\n/**\n * TODO This function should have more of a seekTo kind of name\n */\nfunction normalizeWallClockTime(_time, manifest) {\n    if (!manifest.isLive) {\n        return +_time;\n    }\n    var spd = manifest.suggestedPresentationDelay || 0;\n    var plg = manifest.presentationLiveGap || 0;\n    var tsbd = manifest.timeShiftBufferDepth || 0;\n    var timeInMs = typeof _time === \"number\" ?\n        _time : +_time;\n    var now = Date.now();\n    var max = now - (plg + spd) * 1000;\n    var min = now - (tsbd) * 1000;\n    return Math.max(Math.min(timeInMs, max), min);\n}\nfunction getMinimumBufferPosition(manifest) {\n    // we have to know both the min and the max to be sure\n    var min = getBufferLimits(manifest)[0];\n    return min;\n}\nexports.getMinimumBufferPosition = getMinimumBufferPosition;\n/**\n * Get maximum position to which we should be able to construct a buffer.\n * @param {Manifest} manifest\n * @returns {Number}\n */\nfunction getMaximumBufferPosition(manifest) {\n    if (!manifest.isLive) {\n        return manifest.getDuration();\n    }\n    var ast = manifest.availabilityStartTime || 0;\n    var plg = manifest.presentationLiveGap || 0;\n    var now = Date.now() / 1000;\n    return now - ast - plg;\n}\nexports.getMaximumBufferPosition = getMaximumBufferPosition;\nfunction getBufferLimits(manifest) {\n    // TODO use RTT for the manifest request + 3 or something\n    var BUFFER_DEPTH_SECURITY = 5;\n    if (!manifest.isLive) {\n        return [manifest.minimumTime || 0, manifest.getDuration()];\n    }\n    var ast = manifest.availabilityStartTime || 0;\n    var plg = manifest.presentationLiveGap || 0;\n    var tsbd = manifest.timeShiftBufferDepth || 0;\n    var now = Date.now() / 1000;\n    var max = now - ast - plg;\n    return [\n        Math.min(max, Math.max(manifest.minimumTime != null ? manifest.minimumTime : 0, max - tsbd + BUFFER_DEPTH_SECURITY)),\n        max,\n    ];\n}\nexports.getBufferLimits = getBufferLimits;\n\n\n//# sourceURL=webpack://RxPlayer/./src/manifest/timings.ts?");

/***/ }),

/***/ "./src/net/dash/index.ts":
/*!*******************************!*\
  !*** ./src/net/dash/index.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Observable_1 = __webpack_require__(/*! rxjs/Observable */ \"./node_modules/rxjs/Observable.js\");\nvar isobmff_1 = __webpack_require__(/*! ../../parsers/containers/isobmff */ \"./src/parsers/containers/isobmff/index.ts\");\nvar bif_1 = __webpack_require__(/*! ../../parsers/images/bif */ \"./src/parsers/images/bif.ts\");\nvar request_1 = __webpack_require__(/*! ../../utils/request */ \"./src/utils/request/index.ts\");\nvar url_1 = __webpack_require__(/*! ../../utils/url */ \"./src/utils/url.ts\");\nvar manifest_loader_1 = __webpack_require__(/*! ../utils/manifest_loader */ \"./src/net/utils/manifest_loader.ts\");\nvar isobmff_timing_infos_1 = __webpack_require__(/*! ./isobmff_timing_infos */ \"./src/net/dash/isobmff_timing_infos.ts\");\nvar manifest_1 = __webpack_require__(/*! ./manifest */ \"./src/net/dash/manifest/index.ts\");\nvar segment_loader_1 = __webpack_require__(/*! ./segment_loader */ \"./src/net/dash/segment_loader.ts\");\nvar texttracks_1 = __webpack_require__(/*! ./texttracks */ \"./src/net/dash/texttracks.ts\");\nvar utils_1 = __webpack_require__(/*! ./utils */ \"./src/net/dash/utils.ts\");\n/**\n * Returns pipelines used for DASH streaming.\n * @param {Object} options\n * implementation. Used for each generated http request.\n * @param {Function} [options.contentProtectionParser] - Optional parser for the\n * manifest's content Protection.\n * @returns {Object}\n */\nfunction default_1(options) {\n    if (options === void 0) { options = {}; }\n    var manifestLoader = manifest_loader_1.default({\n        customManifestLoader: options.manifestLoader,\n    });\n    var segmentLoader = segment_loader_1.default(options.segmentLoader);\n    // const { contentProtectionParser } = options;\n    var manifestPipeline = {\n        loader: function (_a) {\n            var url = _a.url;\n            return manifestLoader(url);\n        },\n        parser: function (_a) {\n            var response = _a.response, url = _a.url;\n            var data = typeof response.responseData === \"string\" ?\n                new DOMParser().parseFromString(response.responseData, \"text/xml\") :\n                response.responseData;\n            return Observable_1.Observable.of({\n                manifest: manifest_1.default(data, url /*, contentProtectionParser*/),\n                url: response.url,\n            });\n        },\n    };\n    var segmentPipeline = {\n        loader: function (_a) {\n            var adaptation = _a.adaptation, init = _a.init, manifest = _a.manifest, period = _a.period, representation = _a.representation, segment = _a.segment;\n            return segmentLoader({\n                adaptation: adaptation,\n                init: init,\n                manifest: manifest,\n                period: period,\n                representation: representation,\n                segment: segment,\n            });\n        },\n        parser: function (_a) {\n            var segment = _a.segment, representation = _a.representation, response = _a.response, init = _a.init;\n            var segmentData = response.responseData instanceof Uint8Array ?\n                response.responseData :\n                new Uint8Array(response.responseData);\n            var indexRange = segment.indexRange;\n            var sidxSegments = isobmff_1.parseSidx(segmentData, indexRange ? indexRange[0] : 0);\n            if (!segment.isInit) {\n                return Observable_1.Observable.of({\n                    segmentData: segmentData,\n                    segmentInfos: isobmff_timing_infos_1.default(segment, segmentData, sidxSegments, init),\n                });\n            }\n            if (sidxSegments) {\n                var nextSegments = sidxSegments;\n                utils_1.addNextSegments(representation, nextSegments);\n            }\n            var timescale = isobmff_1.getMDHDTimescale(segmentData);\n            return Observable_1.Observable.of({\n                segmentData: segmentData,\n                segmentInfos: timescale > 0 ? { time: -1, duration: 0, timescale: timescale } : null,\n            });\n        },\n    };\n    var textTrackPipeline = {\n        loader: texttracks_1.loader,\n        parser: texttracks_1.parser,\n    };\n    var imageTrackPipeline = {\n        loader: function (_a) {\n            var segment = _a.segment, representation = _a.representation;\n            if (segment.isInit) {\n                // image do not need an init segment. Passthrough directly to the parser\n                return Observable_1.Observable.of({\n                    type: \"data\",\n                    value: { responseData: null },\n                });\n            }\n            var media = segment.media;\n            var path = media ? utils_1.replaceTokens(media, segment, representation) : \"\";\n            var url = url_1.resolveURL(representation.baseURL, path);\n            return request_1.default({ url: url, responseType: \"arraybuffer\" });\n        },\n        parser: function (_a) {\n            var response = _a.response, segment = _a.segment;\n            var responseData = response.responseData;\n            if (responseData === null) {\n                return Observable_1.Observable.of({\n                    segmentData: null,\n                    segmentInfos: segment.timescale > 0 ? {\n                        duration: segment.isInit ? 0 : segment.duration,\n                        time: segment.isInit ? -1 : segment.time,\n                        timescale: segment.timescale,\n                    } : null,\n                });\n            }\n            var bifObject = bif_1.default(new Uint8Array(responseData));\n            var data = bifObject.thumbs;\n            return Observable_1.Observable.of({\n                segmentData: {\n                    data: data,\n                    start: 0,\n                    end: Number.MAX_VALUE,\n                    timescale: 1,\n                    timeOffset: 0,\n                    type: \"bif\",\n                },\n                segmentInfos: {\n                    time: 0,\n                    duration: Number.MAX_VALUE,\n                    timescale: bifObject.timescale,\n                },\n            });\n        },\n    };\n    return {\n        manifest: manifestPipeline,\n        audio: segmentPipeline,\n        video: segmentPipeline,\n        text: textTrackPipeline,\n        image: imageTrackPipeline,\n    };\n}\nexports.default = default_1;\n\n\n//# sourceURL=webpack://RxPlayer/./src/net/dash/index.ts?");

/***/ }),

/***/ "./src/net/dash/isobmff_timing_infos.ts":
/*!**********************************************!*\
  !*** ./src/net/dash/isobmff_timing_infos.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar assert_1 = __webpack_require__(/*! ../../utils/assert */ \"./src/utils/assert.ts\");\nvar isobmff_1 = __webpack_require__(/*! ../../parsers/containers/isobmff */ \"./src/parsers/containers/isobmff/index.ts\");\n/**\n * Get precize start and duration of a segment from ISOBMFF.\n *   1. get start from tfdt\n *   2. get duration from trun\n *   3. if at least one is missing, get both informations from sidx\n *   4. As a fallback take segment infos.\n * @param {Object} segment\n * @param {UInt8Array} buffer - The entire isobmff container\n * @param {Array.<Object>} [sidxSegments=[]] - Segments from sidx. Here\n * pre-parsed for performance reasons as it is usually available when\n * this function is called.\n * @param {Object} initInfos\n * @returns {Object}\n */\nfunction getISOBMFFTimingInfos(segment, buffer, sidxSegments, initInfos) {\n    var _sidxSegments = sidxSegments || [];\n    var startTime;\n    var duration;\n    var decodeTime = isobmff_1.parseTfdt(buffer);\n    var trunDuration = isobmff_1.getDurationFromTrun(buffer);\n    var timescale = initInfos && initInfos.timescale ?\n        initInfos.timescale : segment.timescale;\n    // we could always make a mistake when reading a container.\n    // If the estimate is too far from what the segment seems to imply, take\n    // the segment infos instead.\n    var maxDecodeTimeDelta;\n    // Scaled start time and duration as announced in the segment data\n    var segmentDuration;\n    var segmentStart;\n    if (timescale === segment.timescale) {\n        maxDecodeTimeDelta = Math.min(timescale * 0.9, segment.duration != null ? segment.duration / 4 : 0.25);\n        segmentStart = segment.time;\n        segmentDuration = segment.duration;\n    }\n    else {\n        maxDecodeTimeDelta = Math.min(timescale * 0.9, segment.duration != null ?\n            ((segment.duration / segment.timescale) * timescale) / 4 : 0.25);\n        segmentStart = ((segment.time || 0) / segment.timescale) * timescale;\n        segmentDuration = segment.duration != null ?\n            (segment.duration / segment.timescale) * timescale : undefined;\n    }\n    if (decodeTime >= 0) {\n        startTime = decodeTime;\n    }\n    if (trunDuration >= 0 &&\n        (segmentDuration == null ||\n            Math.abs(trunDuration - segmentDuration) <= maxDecodeTimeDelta)) {\n        duration = trunDuration;\n    }\n    if (startTime == null) {\n        var sidxStart = _sidxSegments[0].time;\n        if (sidxStart >= 0) {\n            var sidxTimescale = _sidxSegments[0].timescale;\n            startTime = sidxTimescale != null && sidxTimescale !== timescale ?\n                (sidxStart / sidxTimescale) * timescale : sidxStart;\n        }\n        else {\n            startTime = segmentStart;\n        }\n    }\n    if (duration == null) {\n        if (_sidxSegments.length) {\n            var sidxDuration = _sidxSegments.reduce(function (a, b) { return a + (b.duration || 0); }, 0);\n            duration = sidxDuration >= 0 ? sidxDuration : segmentDuration;\n        }\n        else {\n            duration = segmentDuration;\n        }\n    }\n    if (true) {\n        assert_1.default(startTime != null);\n        assert_1.default(duration != null);\n    }\n    return {\n        timescale: timescale,\n        time: startTime || 0,\n        duration: duration || 0,\n    };\n}\nexports.default = getISOBMFFTimingInfos;\n\n\n//# sourceURL=webpack://RxPlayer/./src/net/dash/isobmff_timing_infos.ts?");

/***/ }),

/***/ "./src/net/dash/manifest/helpers.ts":
/*!******************************************!*\
  !*** ./src/net/dash/manifest/helpers.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// XML-Schema\n/* tslint:disable:max-line-length */\n// <http://standards.iso.org/ittf/PubliclyAvailableStandards/MPEG-DASH_schema_files/DASH-MPD.xsd>\n/* tslint:enable:max-line-length */\nvar assert_1 = __webpack_require__(/*! ../../../utils/assert */ \"./src/utils/assert.ts\");\nvar iso8601Duration = /^P(([\\d.]*)Y)?(([\\d.]*)M)?(([\\d.]*)D)?T?(([\\d.]*)H)?(([\\d.]*)M)?(([\\d.]*)S)?/;\nvar rangeRe = /([0-9]+)-([0-9]+)/;\nvar frameRateRe = /([0-9]+)(\\/([0-9]+))?/;\n/**\n * Parse MPD string attributes.\n * @param {string} str\n * @returns {string} - the same string\n */\nfunction parseString(str) {\n    return str;\n}\nexports.parseString = parseString;\n/**\n * Parse MPD boolean attributes.\n * @param {string}\n * @returns {Boolean}\n */\nfunction parseBoolean(str) {\n    return str === \"true\";\n}\nexports.parseBoolean = parseBoolean;\n/**\n * Parse some MPD attributes.\n * @param {string}\n * @returns {Boolean|Number}\n */\nfunction parseIntOrBoolean(str) {\n    if (str === \"true\") {\n        return true;\n    }\n    if (str === \"false\") {\n        return false;\n    }\n    return parseInt(str, 10);\n}\nexports.parseIntOrBoolean = parseIntOrBoolean;\n/**\n * Parse MPD date attributes.\n * @param {string}\n * @returns {Date}\n */\nfunction parseDateTime(str) {\n    return new Date(Date.parse(str)).getTime() / 1000;\n}\nexports.parseDateTime = parseDateTime;\n/**\n * Parse MPD ISO8601 duration attributes into seconds.\n * @param {string}\n * @returns {Number}\n */\nfunction parseDuration(date) {\n    if (!date) {\n        return 0;\n    }\n    var match = iso8601Duration.exec(date);\n    assert_1.default(!!match, date + \" is not a valid ISO8601 duration\");\n    return (parseFloat(match[2] || \"0\") * 365 * 24 * 60 * 60 +\n        parseFloat(match[4] || \"0\") * 30 * 24 * 60 * 60 + // not precise +\n        parseFloat(match[6] || \"0\") * 24 * 60 * 60 +\n        parseFloat(match[8] || \"0\") * 60 * 60 +\n        parseFloat(match[10] || \"0\") * 60 +\n        parseFloat(match[12] || \"0\"));\n}\nexports.parseDuration = parseDuration;\n/**\n * Parse MPD frame rate attributes.\n * -1 if the frameRate could not be parsed,\n * @param {string} str\n * @returns {Number}\n */\nfunction parseFrameRate(str) {\n    var match = frameRateRe.exec(str);\n    if (!match) {\n        return -1;\n    }\n    var nom = parseInt(match[1], 10) || 0;\n    var den = parseInt(match[2], 10) || 0;\n    return den > 0\n        ? nom / den\n        : nom;\n}\nexports.parseFrameRate = parseFrameRate;\n/**\n * Parse MPD ratio attributes.\n * @param {string} str\n * @returns {string}\n */\nfunction parseRatio(str) {\n    return str;\n}\nexports.parseRatio = parseRatio;\n/**\n * Parse MPD byterange attributes into arrays of two elements: the start and\n * the end.\n * @param {string} str\n * @returns {Array.<Number>}\n */\nfunction parseByteRange(str) {\n    var match = rangeRe.exec(str);\n    if (!match) {\n        return null;\n    }\n    else {\n        return [+match[1], +match[2]];\n    }\n}\nexports.parseByteRange = parseByteRange;\n/**\n * Detect if the accessibility given defines an adaptation for the visually\n * impaired.\n * Based on DVB Document A168 (DVB-DASH).\n * @param {Object} accessibility\n * @returns {Boolean}\n */\nfunction isVisuallyImpaired(accessibility) {\n    if (!accessibility) {\n        return false;\n    }\n    return (accessibility.schemeIdUri === \"urn:tva:metadata:cs:AudioPurposeCS:2007\" &&\n        accessibility.value === \"1\");\n}\nexports.isVisuallyImpaired = isVisuallyImpaired;\n/**\n * Detect if the accessibility given defines an adaptation for the hard of\n * hearing.\n * Based on DVB Document A168 (DVB-DASH).\n * @param {Object} accessibility\n * @returns {Boolean}\n */\nfunction isHardOfHearing(accessibility) {\n    if (!accessibility) {\n        return false;\n    }\n    return (accessibility.schemeIdUri === \"urn:tva:metadata:cs:AudioPurposeCS:2007\" &&\n        accessibility.value === \"2\");\n}\nexports.isHardOfHearing = isHardOfHearing;\n/**\n * @param {Element} root\n * @returns {Object}\n */\nfunction parseScheme(root) {\n    var schemeIdUri;\n    var value;\n    for (var i = 0; i < root.attributes.length; i++) {\n        var attribute = root.attributes[i];\n        switch (attribute.name) {\n            case \"schemeIdUri\":\n                schemeIdUri = attribute.value;\n                break;\n            case \"value\":\n                value = attribute.value;\n                break;\n        }\n    }\n    return {\n        schemeIdUri: schemeIdUri,\n        value: value,\n    };\n}\nexports.parseScheme = parseScheme;\n\n\n//# sourceURL=webpack://RxPlayer/./src/net/dash/manifest/helpers.ts?");

/***/ }),

/***/ "./src/net/dash/manifest/index.ts":
/*!****************************************!*\
  !*** ./src/net/dash/manifest/index.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar node_parsers_1 = __webpack_require__(/*! ./node_parsers */ \"./src/net/dash/manifest/node_parsers/index.ts\");\n/**\n * @param {Document} manifest - Original manifest as returned by the server\n * @param {Function} [contentProtectionParser]\n * @returns {Object} - parsed manifest\n */\nfunction parseFromDocument(document, uri /*,*/\n// contentProtectionParser?: IContentProtectionParser\n) {\n    var root = document.documentElement;\n    if (!root || root.nodeName !== \"MPD\") {\n        throw new Error(\"document root should be MPD\");\n    }\n    return node_parsers_1.default(root, uri /*, contentProtectionParser*/);\n}\nexports.default = parseFromDocument;\n\n\n//# sourceURL=webpack://RxPlayer/./src/net/dash/manifest/index.ts?");

/***/ }),

/***/ "./src/net/dash/manifest/indexes/base.ts":
/*!***********************************************!*\
  !*** ./src/net/dash/manifest/indexes/base.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar helpers_1 = __webpack_require__(/*! ./helpers */ \"./src/net/dash/manifest/indexes/helpers.ts\");\n/**\n * Add a new segment to the index.\n *\n * /!\\ Mutate the given index\n * @param {Object} index\n * @param {Object} segmentInfos\n * @param {Number} segmentInfos.timescale\n * @param {Number} segmentInfos.duration\n * @param {Number} segmentInfos.count\n * @param {*} segmentInfos.range - TODO check type\n * @returns {Boolean} - true if the segment has been added\n */\nfunction _addSegmentInfos(index, segmentInfos) {\n    if (segmentInfos.timescale !== index.timescale) {\n        var timescale = index.timescale;\n        index.timeline.push({\n            ts: (segmentInfos.time / segmentInfos.timescale) * timescale,\n            d: (segmentInfos.duration / segmentInfos.timescale) * timescale,\n            r: segmentInfos.count || 0,\n            range: segmentInfos.range,\n        });\n    }\n    else {\n        index.timeline.push({\n            ts: segmentInfos.time,\n            d: segmentInfos.duration,\n            r: segmentInfos.count || 0,\n            range: segmentInfos.range,\n        });\n    }\n    return true;\n}\n/**\n * Provide helpers for SegmentBase-based indexes.\n * @type {Object}\n * TODO weird that everything is inherited from Timeline...\n * Reimplement from scratch\n */\nvar BaseRepresentationIndex = /** @class */ (function () {\n    /**\n     * @param {Object} index\n     */\n    function BaseRepresentationIndex(index, periodStart) {\n        if (index.presentationTimeOffset == null) {\n            index.presentationTimeOffset = periodStart * index.timescale;\n        }\n        this._index = index;\n    }\n    /**\n     * Construct init Segment.\n     * @returns {Object}\n     */\n    BaseRepresentationIndex.prototype.getInitSegment = function () {\n        return helpers_1.getInitSegment(this._index);\n    };\n    /**\n     * @param {Number} _up\n     * @param {Number} _to\n     * @returns {Array.<Object>}\n     */\n    BaseRepresentationIndex.prototype.getSegments = function (_up, _to) {\n        return helpers_1.getSegmentsFromTimeline(this._index, _up, _to);\n    };\n    /**\n     * Returns false as no Segment-Base based index should need to be refreshed.\n     * @returns {Boolean}\n     */\n    BaseRepresentationIndex.prototype.shouldRefresh = function () {\n        return false;\n    };\n    /**\n     * Returns first position in index.\n     * @returns {Number|undefined}\n     */\n    BaseRepresentationIndex.prototype.getFirstPosition = function () {\n        var index = this._index;\n        if (!index.timeline.length) {\n            return undefined;\n        }\n        return index.timeline[0].ts / index.timescale;\n    };\n    /**\n     * Returns last position in index.\n     * @returns {Number|undefined}\n     */\n    BaseRepresentationIndex.prototype.getLastPosition = function () {\n        var index = this._index;\n        if (!index.timeline.length) {\n            return undefined;\n        }\n        var lastTimelineElement = index.timeline[index.timeline.length - 1];\n        return (helpers_1.getTimelineRangeEnd(lastTimelineElement) / index.timescale);\n    };\n    /**\n     * We do not check for discontinuity in SegmentBase-based indexes.\n     * @returns {Number}\n     */\n    BaseRepresentationIndex.prototype.checkDiscontinuity = function () {\n        return -1;\n    };\n    /**\n     * @param {Array.<Object>}\n     * @returns {Array.<Object>}\n     */\n    BaseRepresentationIndex.prototype._addSegments = function (nextSegments) {\n        for (var i = 0; i < nextSegments.length; i++) {\n            _addSegmentInfos(this._index, nextSegments[i]);\n        }\n    };\n    /**\n     * @param {Object}\n     */\n    BaseRepresentationIndex.prototype._update = function (newIndex /* TODO @ index refacto */) {\n        this._index = newIndex._index;\n    };\n    return BaseRepresentationIndex;\n}());\nexports.default = BaseRepresentationIndex;\n\n\n//# sourceURL=webpack://RxPlayer/./src/net/dash/manifest/indexes/base.ts?");

/***/ }),

/***/ "./src/net/dash/manifest/indexes/helpers.ts":
/*!**************************************************!*\
  !*** ./src/net/dash/manifest/indexes/helpers.ts ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Calculate the number of times a segment repeat based on the next segment.\n * @param {Object} seg\n * @param {Object} nextSeg\n * @returns {Number}\n */\nfunction calculateRepeat(seg, nextSeg) {\n    var rep = seg.r || 0;\n    // A negative value of the @r attribute of the S element indicates\n    // that the duration indicated in @d attribute repeats until the\n    // start of the next S element, the end of the Period or until the\n    // next MPD update.\n    if (rep < 0) {\n        var repEnd = nextSeg ? nextSeg.ts : Infinity;\n        rep = Math.ceil((repEnd - seg.ts) / seg.d) - 1;\n    }\n    return rep;\n}\n/**\n * Convert second-based start time and duration to the timescale of the\n * manifest's index.\n * @param {Object} index\n * @param {Number} ts\n * @param {Number} duration\n * @returns {Object} - Object with two properties:\n *   - up {Number}: timescaled timestamp of the beginning time\n *   - to {Number}: timescaled timestamp of the end time (start time + duration)\n */\nfunction normalizeRange(index, // TODO\nts, duration) {\n    var pto = index.presentationTimeOffset || 0;\n    var timescale = index.timescale || 1;\n    return {\n        up: (ts) * timescale - pto,\n        to: (ts + duration) * timescale - pto,\n    };\n}\nexports.normalizeRange = normalizeRange;\n/**\n * Get start of the given index range, timescaled.\n * @param {Object} range\n * @param {Number} range.ts - the range's start time\n * @param {Number} range.d - the range's duration\n * @param {Number} range.r - the range's count. 0 for a single element, 1 for\n * 2 elements etc.\n * @returns {Number} - absolute start time of the range\n */\nfunction getTimelineRangeStart(_a) {\n    var ts = _a.ts, d = _a.d, r = _a.r;\n    return d === -1 ? ts : ts + r * d;\n}\nexports.getTimelineRangeStart = getTimelineRangeStart;\n/**\n * Get end of the given index range, timescaled.\n * @param {Object} range\n * @param {Number} range.ts - the range's start time\n * @param {Number} range.d - the range's duration\n * @param {Number} range.r - the range's count. 0 for a single element, 1 for\n * 2 elements etc.\n * @returns {Number} - absolute end time of the range\n */\nfunction getTimelineRangeEnd(_a) {\n    var ts = _a.ts, d = _a.d, r = _a.r;\n    return d === -1 ? ts : ts + (r + 1) * d;\n}\nexports.getTimelineRangeEnd = getTimelineRangeEnd;\n/**\n * Construct init segment for the given index.\n * @param {Object} index\n * @param {Number} index.timescale\n * @param {Object} [index.initialization={}]\n * @param {Array.<Number>|null} [index.initialization.range=null]\n * @param {Array.<Number>|null} [index.initialization.indexRange=null]\n * @param {string} [index.initialization.media]\n * @returns {Object}\n */\nfunction getInitSegment(index) {\n    var _a = index.initialization, initialization = _a === void 0 ? {} : _a;\n    return {\n        id: \"init\",\n        isInit: true,\n        time: 0,\n        range: initialization.range || undefined,\n        indexRange: index.indexRange || undefined,\n        media: initialization.media,\n        timescale: index.timescale,\n    };\n}\nexports.getInitSegment = getInitSegment;\n/**\n * @param {Number} ts\n * @param {Number} up\n * @param {Number} duration\n * @returns {Number}\n */\nfunction getSegmentNumber(ts, up, duration) {\n    var diff = up - ts;\n    if (diff > 0) {\n        return Math.floor(diff / duration);\n    }\n    else {\n        return 0;\n    }\n}\nfunction getSegmentsFromTimeline(index, _up, _to) {\n    var _a = normalizeRange(index, _up, _to), up = _a.up, to = _a.to;\n    var timeline = index.timeline, timescale = index.timescale, media = index.media, startNumber = index.startNumber;\n    var currentNumber = startNumber != null ? startNumber : undefined;\n    var segments = [];\n    var timelineLength = timeline.length;\n    // TODO(pierre): use @maxSegmentDuration if possible\n    var maxEncounteredDuration = (timeline.length && timeline[0].d) || 0;\n    for (var i = 0; i < timelineLength; i++) {\n        var segmentRange = timeline[i];\n        var d = segmentRange.d, ts = segmentRange.ts, range = segmentRange.range;\n        maxEncounteredDuration = Math.max(maxEncounteredDuration, d);\n        // live-added segments have @d attribute equals to -1\n        if (d < 0) {\n            // TODO what? May be to play it safe and avoid adding segments which are\n            // not completely generated\n            if (ts + maxEncounteredDuration < to) {\n                var segment = {\n                    id: \"\" + ts,\n                    time: ts,\n                    isInit: false,\n                    range: range,\n                    duration: undefined,\n                    timescale: timescale,\n                    media: media,\n                    number: currentNumber != null ? currentNumber : undefined,\n                };\n                segments.push(segment);\n            }\n            return segments;\n        }\n        var repeat = calculateRepeat(segmentRange, timeline[i + 1]);\n        var segmentNumberInCurrentRange = getSegmentNumber(ts, up, d);\n        var segmentTime = ts + segmentNumberInCurrentRange * d;\n        while (segmentTime < to && segmentNumberInCurrentRange <= repeat) {\n            var segment = {\n                id: \"\" + segmentTime,\n                time: segmentTime,\n                isInit: false,\n                range: range,\n                duration: d,\n                timescale: timescale,\n                media: media,\n                number: currentNumber != null ?\n                    currentNumber + segmentNumberInCurrentRange : undefined,\n            };\n            segments.push(segment);\n            // update segment number and segment time for the next segment\n            segmentNumberInCurrentRange++;\n            segmentTime = ts + segmentNumberInCurrentRange * d;\n        }\n        if (segmentTime >= to) {\n            // we reached ``to``, we're done\n            return segments;\n        }\n        if (currentNumber != null) {\n            currentNumber += repeat + 1;\n        }\n    }\n    return segments;\n}\nexports.getSegmentsFromTimeline = getSegmentsFromTimeline;\n\n\n//# sourceURL=webpack://RxPlayer/./src/net/dash/manifest/indexes/helpers.ts?");

/***/ }),

/***/ "./src/net/dash/manifest/indexes/list.ts":
/*!***********************************************!*\
  !*** ./src/net/dash/manifest/indexes/list.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar log_1 = __webpack_require__(/*! ../../../../utils/log */ \"./src/utils/log.ts\");\nvar helpers_1 = __webpack_require__(/*! ./helpers */ \"./src/net/dash/manifest/indexes/helpers.ts\");\n/**\n * Provide helpers for SegmentList-based DASH indexes.\n * @type {Object}\n */\nvar ListRepresentationIndex = /** @class */ (function () {\n    /**\n     * @param {Object} index\n     */\n    function ListRepresentationIndex(index, periodStart) {\n        if (index.presentationTimeOffset == null) {\n            index.presentationTimeOffset = periodStart * index.timescale;\n        }\n        this._index = index;\n    }\n    /**\n     * Construct init Segment.\n     * @returns {Object}\n     */\n    ListRepresentationIndex.prototype.getInitSegment = function () {\n        return helpers_1.getInitSegment(this._index);\n    };\n    /**\n     * @param {Number} _up\n     * @param {Number} _to\n     * @returns {Array.<Object>}\n     */\n    ListRepresentationIndex.prototype.getSegments = function (_up, _to) {\n        var index = this._index;\n        var _a = helpers_1.normalizeRange(index, _up, _to), up = _a.up, to = _a.to;\n        var duration = index.duration, list = index.list, timescale = index.timescale;\n        var length = Math.min(list.length - 1, Math.floor(to / duration));\n        var segments = [];\n        var i = Math.floor(up / duration);\n        while (i <= length) {\n            var range = list[i].mediaRange;\n            var media = list[i].media;\n            var args = {\n                id: \"\" + i,\n                time: i * duration,\n                isInit: false,\n                range: range,\n                duration: duration,\n                timescale: timescale,\n                media: media,\n            };\n            segments.push(args);\n            i++;\n        }\n        return segments;\n    };\n    /**\n     * Returns true if, based on the arguments, the index should be refreshed.\n     * (If we should re-fetch the manifest)\n     * @param {Number} up\n     * @param {Number} to\n     * @returns {Boolean}\n     */\n    ListRepresentationIndex.prototype.shouldRefresh = function (_up, to) {\n        var _a = this._index, timescale = _a.timescale, duration = _a.duration, list = _a.list, _b = _a.presentationTimeOffset, presentationTimeOffset = _b === void 0 ? 0 : _b;\n        var scaledTo = to * timescale - presentationTimeOffset;\n        var i = Math.floor(scaledTo / duration);\n        return !(i >= 0 && i < list.length);\n    };\n    /**\n     * Returns first position in index.\n     * @returns {Number}\n     */\n    ListRepresentationIndex.prototype.getFirstPosition = function () {\n        return 0;\n    };\n    /**\n     * Returns last position in index.\n     * @returns {Number}\n     */\n    ListRepresentationIndex.prototype.getLastPosition = function () {\n        var index = this._index;\n        var duration = index.duration, list = index.list;\n        return (list.length * duration) / index.timescale;\n    };\n    /**\n     * We do not check for discontinuity in SegmentList-based indexes.\n     * @returns {Number}\n     */\n    ListRepresentationIndex.prototype.checkDiscontinuity = function () {\n        return -1;\n    };\n    /**\n     * @param {Object}\n     */\n    ListRepresentationIndex.prototype._update = function (newIndex) {\n        this._index = newIndex._index;\n    };\n    /**\n     * We do not have to add new segments to SegmentList-based indexes.\n     * @returns {Array}\n     */\n    ListRepresentationIndex.prototype._addSegments = function () {\n        if (true) {\n            log_1.default.warn(\"Tried to add Segments to a list RepresentationIndex\");\n        }\n    };\n    return ListRepresentationIndex;\n}());\nexports.default = ListRepresentationIndex;\n\n\n//# sourceURL=webpack://RxPlayer/./src/net/dash/manifest/indexes/list.ts?");

/***/ }),

/***/ "./src/net/dash/manifest/indexes/template.ts":
/*!***************************************************!*\
  !*** ./src/net/dash/manifest/indexes/template.ts ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar log_1 = __webpack_require__(/*! ../../../../utils/log */ \"./src/utils/log.ts\");\nvar helpers_1 = __webpack_require__(/*! ./helpers */ \"./src/net/dash/manifest/indexes/helpers.ts\");\nvar TemplateRepresentationIndex = /** @class */ (function () {\n    /**\n     * @param {Object} index\n     */\n    function TemplateRepresentationIndex(index, periodStart) {\n        if (index.presentationTimeOffset == null) {\n            index.presentationTimeOffset = periodStart * index.timescale;\n        }\n        this._index = index;\n    }\n    /**\n     * Construct init Segment.\n     * @returns {Object}\n     */\n    TemplateRepresentationIndex.prototype.getInitSegment = function () {\n        return helpers_1.getInitSegment(this._index);\n    };\n    /**\n     * @param {Number} _up\n     * @param {Number} _to\n     * @returns {Array.<Object>}\n     */\n    TemplateRepresentationIndex.prototype.getSegments = function (_up, _to) {\n        var index = this._index;\n        var _a = helpers_1.normalizeRange(index, _up, _to), up = _a.up, to = _a.to;\n        if (to <= up) {\n            return [];\n        }\n        var duration = index.duration, startNumber = index.startNumber, timescale = index.timescale, media = index.media, presentationTimeOffset = index.presentationTimeOffset;\n        var segments = [];\n        for (var baseTime = up; baseTime <= to; baseTime += duration) {\n            var number = Math.floor(baseTime / duration) +\n                (startNumber == null ? 1 : startNumber);\n            var time = (number -\n                (startNumber == null ? 1 : startNumber)) * duration + (presentationTimeOffset || 0);\n            var args = {\n                id: \"\" + number,\n                number: number,\n                time: time,\n                isInit: false,\n                duration: duration,\n                timescale: timescale,\n                media: media,\n            };\n            segments.push(args);\n        }\n        return segments;\n    };\n    /**\n     * Returns first position in index.\n     * @returns {undefined}\n     */\n    TemplateRepresentationIndex.prototype.getFirstPosition = function () {\n        // TODO tslint bug? Document.\n        /* tslint:disable return-undefined */\n        return undefined;\n        /* tslint:enable return-undefined */\n    };\n    /**\n     * Returns last position in index.\n     * @returns {undefined}\n     */\n    TemplateRepresentationIndex.prototype.getLastPosition = function () {\n        // TODO tslint bug? Document.\n        /* tslint:disable return-undefined */\n        return undefined;\n        /* tslint:enable return-undefined */\n    };\n    /**\n     * Returns true if, based on the arguments, the index should be refreshed.\n     * We never have to refresh a SegmentTemplate-based manifest.\n     * @returns {Boolean}\n     */\n    TemplateRepresentationIndex.prototype.shouldRefresh = function () {\n        return false;\n    };\n    /**\n     * We cannot check for discontinuity in SegmentTemplate-based indexes.\n     * @returns {Number}\n     */\n    TemplateRepresentationIndex.prototype.checkDiscontinuity = function () {\n        return -1;\n    };\n    /**\n     * We do not have to add new segments to SegmentList-based indexes.\n     * @returns {Array}\n     */\n    TemplateRepresentationIndex.prototype._addSegments = function () {\n        if (true) {\n            log_1.default.warn(\"Tried to add Segments to a template RepresentationIndex\");\n        }\n    };\n    /**\n     * @param {Object}\n     */\n    TemplateRepresentationIndex.prototype._update = function (newIndex /* TODO @ index refacto */) {\n        this._index = newIndex._index;\n    };\n    return TemplateRepresentationIndex;\n}());\nexports.default = TemplateRepresentationIndex;\n\n\n//# sourceURL=webpack://RxPlayer/./src/net/dash/manifest/indexes/template.ts?");

/***/ }),

/***/ "./src/net/dash/manifest/indexes/timeline.ts":
/*!***************************************************!*\
  !*** ./src/net/dash/manifest/indexes/timeline.ts ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar helpers_1 = __webpack_require__(/*! ./helpers */ \"./src/net/dash/manifest/indexes/helpers.ts\");\n/**\n * Get index of the segment containing the given timescaled timestamp.\n * @param {Object} index\n * @param {Number} ts\n * @returns {Number}\n */\nfunction getSegmentIndex(index, ts) {\n    var timeline = index.timeline;\n    var low = 0;\n    var high = timeline.length;\n    while (low < high) {\n        var mid = (low + high) >>> 1;\n        if (timeline[mid].ts < ts) {\n            low = mid + 1;\n        }\n        else {\n            high = mid;\n        }\n    }\n    return (low > 0)\n        ? low - 1\n        : low;\n}\n/**\n * Add a new segment to the index.\n *\n * /!\\ Mutate the given index\n * @param {Object} index\n * @param {Object} newSegment\n * @param {Number} newSegment.timescale\n * @param {Number} newSegment.time\n * @param {Number} newSegment.duration\n * @param {Object} currentSegment\n * @param {Number} currentSegment.timescale\n * @param {Number} currentSegment.time\n * @returns {Boolean} - true if the segment has been added\n */\nfunction _addSegmentInfos(index, newSegment, currentSegment) {\n    var timeline = index.timeline, timescale = index.timescale;\n    var timelineLength = timeline.length;\n    var last = timeline[timelineLength - 1];\n    var scaledNewSegment = newSegment.timescale === timescale ? {\n        time: newSegment.time,\n        duration: newSegment.duration,\n    } : {\n        time: (newSegment.time / newSegment.timescale) * timescale,\n        duration: (newSegment.duration / newSegment.timescale) * timescale,\n    };\n    var scaledCurrentTime;\n    if (currentSegment && currentSegment.timescale) {\n        scaledCurrentTime = currentSegment.timescale === timescale ?\n            currentSegment.time :\n            (currentSegment.time / currentSegment.timescale) * timescale;\n    }\n    // in some circumstances, the new segment informations are only\n    // duration informations that we can use to deduct the ts of the\n    // next segment. this is the case where the new segment are\n    // associated to a current segment and have the same ts\n    var shouldDeductNextSegment = scaledCurrentTime != null &&\n        (scaledNewSegment.time === scaledCurrentTime);\n    if (shouldDeductNextSegment) {\n        var newSegmentTs = scaledNewSegment.time + scaledNewSegment.duration;\n        var lastSegmentTs = (last.ts + last.d * last.r);\n        var tsDiff = newSegmentTs - lastSegmentTs;\n        if (tsDiff <= 0) { // same segment / behind the last\n            return false;\n        }\n        // try to use the compact notation with @r attribute on the last\n        // to elements of the timeline if we find out they have the same\n        // duration\n        if (last.d === -1) {\n            var prev = timeline[timelineLength - 2];\n            if (prev && prev.d === tsDiff) {\n                prev.r++;\n                timeline.pop();\n            }\n            else {\n                last.d = tsDiff;\n            }\n        }\n        index.timeline.push({\n            d: -1,\n            ts: newSegmentTs,\n            r: 0,\n        });\n        return true;\n    }\n    // if the given timing has a timestamp after the timeline end we\n    // just need to push a new element in the timeline, or increase\n    // the @r attribute of the last element.\n    else if (scaledNewSegment.time >= helpers_1.getTimelineRangeEnd(last)) {\n        if (last.d === scaledNewSegment.duration) {\n            last.r++;\n        }\n        else {\n            index.timeline.push({\n                d: scaledNewSegment.duration,\n                ts: scaledNewSegment.time,\n                r: 0,\n            });\n        }\n        return true;\n    }\n    return false;\n}\nvar TimelineRepresentationIndex = /** @class */ (function () {\n    /**\n     * @param {Object} index\n     */\n    function TimelineRepresentationIndex(index, periodStart) {\n        if (index.presentationTimeOffset == null) {\n            index.presentationTimeOffset = periodStart * index.timescale;\n        }\n        this._index = index;\n    }\n    /**\n     * Construct init Segment.\n     * @returns {Object}\n     */\n    TimelineRepresentationIndex.prototype.getInitSegment = function () {\n        return helpers_1.getInitSegment(this._index);\n    };\n    /**\n     * @param {Number} _up\n     * @param {Number} _to\n     * @returns {Array.<Object>}\n     */\n    TimelineRepresentationIndex.prototype.getSegments = function (_up, _to) {\n        return helpers_1.getSegmentsFromTimeline(this._index, _up, _to);\n    };\n    /**\n     * Returns true if, based on the arguments, the index should be refreshed.\n     * @param {Number} _up\n     * @param {Number} _to\n     * @returns {Boolean}\n     */\n    TimelineRepresentationIndex.prototype.shouldRefresh = function (_up, to) {\n        var _a = this._index, timeline = _a.timeline, timescale = _a.timescale, _b = _a.presentationTimeOffset, presentationTimeOffset = _b === void 0 ? 0 : _b;\n        var scaledTo = to * timescale - presentationTimeOffset;\n        var last = timeline[timeline.length - 1];\n        if (!last) {\n            return false;\n        }\n        if (last.d < 0) {\n            last = { ts: last.ts, d: 0, r: last.r };\n        }\n        return !(scaledTo <= helpers_1.getTimelineRangeEnd(last));\n    };\n    /**\n     * Returns first position in index.\n     * @returns {Number|undefined}\n     */\n    TimelineRepresentationIndex.prototype.getFirstPosition = function () {\n        var index = this._index;\n        if (!index.timeline.length) {\n            return undefined;\n        }\n        return index.timeline[0].ts / index.timescale;\n    };\n    /**\n     * Returns last position in index.\n     * @returns {Number|undefined}\n     */\n    TimelineRepresentationIndex.prototype.getLastPosition = function () {\n        var index = this._index;\n        if (!index.timeline.length) {\n            return undefined;\n        }\n        var lastTimelineElement = index.timeline[index.timeline.length - 1];\n        return (helpers_1.getTimelineRangeEnd(lastTimelineElement) / index.timescale);\n    };\n    /**\n     * Checks if the time given is in a discontinuity. That is:\n     *   - We're on the upper bound of the current range (end of the range - time\n     *     is inferior to the timescale)\n     *   - The next range starts after the end of the current range.\n     * @param {Number} _time\n     * @returns {Number} - If a discontinuity is present, this is the Starting ts\n     * for the next (discontinuited) range. If not this is equal to -1.\n     */\n    TimelineRepresentationIndex.prototype.checkDiscontinuity = function (_time) {\n        var _a = this._index, timeline = _a.timeline, _b = _a.timescale, timescale = _b === void 0 ? 1 : _b;\n        var time = _time * timescale;\n        if (time <= 0) {\n            return -1;\n        }\n        var segmentIndex = getSegmentIndex(this._index, time);\n        if (segmentIndex < 0 || segmentIndex >= timeline.length - 1) {\n            return -1;\n        }\n        var range = timeline[segmentIndex];\n        if (range.d === -1) {\n            return -1;\n        }\n        var rangeUp = range.ts;\n        var rangeTo = helpers_1.getTimelineRangeEnd(range);\n        var nextRange = timeline[segmentIndex + 1];\n        // when we are actually inside the found range and this range has\n        // an explicit discontinuity with the next one\n        if (rangeTo !== nextRange.ts &&\n            time >= rangeUp &&\n            time <= rangeTo &&\n            (rangeTo - time) < timescale) {\n            return nextRange.ts / timescale;\n        }\n        return -1;\n    };\n    /**\n     * @param {Object}\n     */\n    TimelineRepresentationIndex.prototype._update = function (newIndex /* TODO @ index refacto */) {\n        this._index = newIndex._index;\n    };\n    /**\n     * We do not have to add new segments to SegmentList-based indexes.\n     * @param {Array.<Object>}\n     * @param {Object}\n     * @returns {Array}\n     */\n    TimelineRepresentationIndex.prototype._addSegments = function (nextSegments, currentSegment) {\n        for (var i = 0; i < nextSegments.length; i++) {\n            _addSegmentInfos(this._index, nextSegments[i], currentSegment);\n        }\n    };\n    return TimelineRepresentationIndex;\n}());\nexports.default = TimelineRepresentationIndex;\n\n\n//# sourceURL=webpack://RxPlayer/./src/net/dash/manifest/indexes/timeline.ts?");

/***/ }),

/***/ "./src/net/dash/manifest/node_parsers/AdaptationSet.ts":
/*!*************************************************************!*\
  !*** ./src/net/dash/manifest/node_parsers/AdaptationSet.ts ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar log_1 = __webpack_require__(/*! ../../../../utils/log */ \"./src/utils/log.ts\");\nvar helpers_1 = __webpack_require__(/*! ../helpers */ \"./src/net/dash/manifest/helpers.ts\");\nvar ContentComponent_1 = __webpack_require__(/*! ./ContentComponent */ \"./src/net/dash/manifest/node_parsers/ContentComponent.ts\");\nvar ContentProtection_1 = __webpack_require__(/*! ./ContentProtection */ \"./src/net/dash/manifest/node_parsers/ContentProtection.ts\");\nvar Representation_1 = __webpack_require__(/*! ./Representation */ \"./src/net/dash/manifest/node_parsers/Representation.ts\");\nvar SegmentBase_1 = __webpack_require__(/*! ./SegmentBase */ \"./src/net/dash/manifest/node_parsers/SegmentBase.ts\");\nvar SegmentList_1 = __webpack_require__(/*! ./SegmentList */ \"./src/net/dash/manifest/node_parsers/SegmentList.ts\");\nvar SegmentTemplate_1 = __webpack_require__(/*! ./SegmentTemplate */ \"./src/net/dash/manifest/node_parsers/SegmentTemplate.ts\");\nfunction parseAdaptationSetChildren(adaptationSetChildren) {\n    var children = {\n        baseURL: \"\",\n        representations: [],\n    };\n    for (var i = 0; i < adaptationSetChildren.length; i++) {\n        if (adaptationSetChildren[i].nodeType === Node.ELEMENT_NODE) {\n            var currentElement = adaptationSetChildren[i];\n            switch (currentElement.nodeName) {\n                case \"Accessibility\":\n                    children.accessibility = helpers_1.parseScheme(currentElement);\n                    break;\n                case \"BaseURL\":\n                    children.baseURL = currentElement.textContent || \"\";\n                    break;\n                case \"ContentComponent\":\n                    children.contentComponent = ContentComponent_1.default(currentElement);\n                    break;\n                case \"Representation\":\n                    var representation = Representation_1.createRepresentationIntermediateRepresentation(currentElement);\n                    children.representations.push(representation);\n                    break;\n                case \"Role\":\n                    children.role = helpers_1.parseScheme(currentElement);\n                    break;\n                case \"SegmentBase\":\n                    children.segmentBase = SegmentBase_1.default(currentElement);\n                    break;\n                case \"SegmentList\":\n                    children.segmentList = SegmentList_1.default(currentElement);\n                    break;\n                case \"SegmentTemplate\":\n                    children.segmentTemplate = SegmentTemplate_1.default(currentElement);\n                    break;\n                case \"ContentProtection\":\n                    children.contentProtection = ContentProtection_1.default(currentElement);\n                    break;\n                // case \"Rating\":\n                //   children.rating = currentElement;\n                //   break;\n                // case \"Viewpoint\":\n                //   children.viewpoint = currentElement;\n                //   break;\n            }\n        }\n    }\n    return children;\n}\nfunction parseAdaptationSetAttributes(root) {\n    var parsedAdaptation = {};\n    for (var i = 0; i < root.attributes.length; i++) {\n        var attribute = root.attributes[i];\n        switch (attribute.name) {\n            case \"id\":\n                parsedAdaptation.id = attribute.value;\n                break;\n            case \"group\":\n                {\n                    var group = parseInt(attribute.value, 10);\n                    if (isNaN(group)) {\n                        log_1.default.warn(\"DASH: invalid group (\\\"\" + attribute.value + \"\\\")\");\n                    }\n                    else {\n                        parsedAdaptation.group = group;\n                    }\n                }\n                break;\n            case \"lang\":\n                parsedAdaptation.language = attribute.value;\n                break;\n            case \"contentType\":\n                parsedAdaptation.contentType = attribute.value;\n                break;\n            case \"par\":\n                parsedAdaptation.par = attribute.value;\n                break;\n            case \"minBandwidth\":\n                {\n                    var minBitrate = parseInt(attribute.value, 10);\n                    if (isNaN(minBitrate)) {\n                        log_1.default.warn(\"DASH: invalid minBandwidth (\\\"\" + attribute.value + \"\\\")\");\n                    }\n                    else {\n                        parsedAdaptation.minBitrate = minBitrate;\n                    }\n                }\n                break;\n            case \"maxBandwidth\":\n                {\n                    var maxBitrate = parseInt(attribute.value, 10);\n                    if (isNaN(maxBitrate)) {\n                        log_1.default.warn(\"DASH: invalid maxBandwidth (\\\"\" + attribute.value + \"\\\")\");\n                    }\n                    else {\n                        parsedAdaptation.maxBitrate = maxBitrate;\n                    }\n                }\n                break;\n            case \"minWidth\":\n                {\n                    var minWidth = parseInt(attribute.value, 10);\n                    if (isNaN(minWidth)) {\n                        log_1.default.warn(\"DASH: invalid minWidth (\\\"\" + attribute.value + \"\\\")\");\n                    }\n                    else {\n                        parsedAdaptation.minWidth = minWidth;\n                    }\n                }\n                break;\n            case \"maxWidth\":\n                {\n                    var maxWidth = parseInt(attribute.value, 10);\n                    if (isNaN(maxWidth)) {\n                        log_1.default.warn(\"DASH: invalid maxWidth (\\\"\" + attribute.value + \"\\\")\");\n                    }\n                    else {\n                        parsedAdaptation.maxWidth = maxWidth;\n                    }\n                }\n                break;\n            case \"minHeight\":\n                {\n                    var minHeight = parseInt(attribute.value, 10);\n                    if (isNaN(minHeight)) {\n                        log_1.default.warn(\"DASH: invalid minHeight (\\\"\" + attribute.value + \"\\\")\");\n                    }\n                    else {\n                        parsedAdaptation.minHeight = minHeight;\n                    }\n                }\n                break;\n            case \"maxHeight\":\n                {\n                    var maxHeight = parseInt(attribute.value, 10);\n                    if (isNaN(maxHeight)) {\n                        log_1.default.warn(\"DASH: invalid maxHeight (\\\"\" + attribute.value + \"\\\")\");\n                    }\n                    else {\n                        parsedAdaptation.maxHeight = maxHeight;\n                    }\n                }\n                break;\n            case \"minFrameRate\":\n                {\n                    var minFrameRate = helpers_1.parseFrameRate(attribute.value);\n                    if (isNaN(minFrameRate)) {\n                        log_1.default.warn(\"DASH: invalid minFrameRate (\\\"\" + attribute.value + \"\\\")\");\n                    }\n                    else {\n                        parsedAdaptation.minFrameRate = minFrameRate;\n                    }\n                }\n                break;\n            case \"maxFrameRate\":\n                {\n                    var maxFrameRate = helpers_1.parseFrameRate(attribute.value);\n                    if (isNaN(maxFrameRate)) {\n                        log_1.default.warn(\"DASH: invalid maxFrameRate (\\\"\" + attribute.value + \"\\\")\");\n                    }\n                    else {\n                        parsedAdaptation.maxFrameRate = maxFrameRate;\n                    }\n                }\n                break;\n            case \"segmentAlignment\":\n                {\n                    var segmentAlignment = helpers_1.parseIntOrBoolean(attribute.value);\n                    if (typeof segmentAlignment === \"number\" && isNaN(segmentAlignment)) {\n                        log_1.default.warn(\"DASH: invalid segmentAlignment (\\\"\" + attribute.value + \"\\\")\");\n                    }\n                    else {\n                        parsedAdaptation.segmentAlignment = segmentAlignment;\n                    }\n                }\n                break;\n            case \"subsegmentAlignment\":\n                {\n                    var subsegmentAlignment = helpers_1.parseIntOrBoolean(attribute.value);\n                    if (typeof subsegmentAlignment === \"number\" && isNaN(subsegmentAlignment)) {\n                        log_1.default.warn(\"DASH: invalid subsegmentAlignment (\\\"\" + attribute.value + \"\\\")\");\n                    }\n                    else {\n                        parsedAdaptation.subsegmentAlignment = subsegmentAlignment;\n                    }\n                }\n                break;\n            case \"bitstreamSwitching\":\n                parsedAdaptation.bitstreamSwitching = helpers_1.parseBoolean(attribute.value);\n                break;\n            case \"audioSamplingRate\":\n                parsedAdaptation.audioSamplingRate = attribute.value;\n                break;\n            case \"codecs\":\n                parsedAdaptation.codecs = attribute.value;\n                break;\n            case \"codingDependency\":\n                parsedAdaptation.codingDependency = helpers_1.parseBoolean(attribute.value);\n                break;\n            case \"frameRate\":\n                {\n                    var frameRate = helpers_1.parseFrameRate(attribute.value);\n                    if (isNaN(frameRate)) {\n                        log_1.default.warn(\"DASH: invalid frameRate (\\\"\" + attribute.value + \"\\\")\");\n                    }\n                    else {\n                        parsedAdaptation.frameRate = frameRate;\n                    }\n                }\n                break;\n            case \"height\":\n                {\n                    var height = parseInt(attribute.value, 10);\n                    if (isNaN(height)) {\n                        log_1.default.warn(\"DASH: invalid height (\\\"\" + attribute.value + \"\\\")\");\n                    }\n                    else {\n                        parsedAdaptation.height = height;\n                    }\n                }\n                break;\n            case \"maxPlayoutRate\":\n                {\n                    var maxPlayoutRate = parseFloat(attribute.value);\n                    if (isNaN(maxPlayoutRate)) {\n                        log_1.default.warn(\"DASH: invalid maxPlayoutRate (\\\"\" + attribute.value + \"\\\")\");\n                    }\n                    else {\n                        parsedAdaptation.maxPlayoutRate = maxPlayoutRate;\n                    }\n                }\n                break;\n            case \"maximumSAPPeriod\":\n                {\n                    var maximumSAPPeriod = parseFloat(attribute.value);\n                    if (isNaN(maximumSAPPeriod)) {\n                        log_1.default.warn(\"DASH: invalid maximumSAPPeriod (\\\"\" + attribute.value + \"\\\")\");\n                    }\n                    else {\n                        parsedAdaptation.maximumSAPPeriod = maximumSAPPeriod;\n                    }\n                }\n                break;\n            case \"mimeType\":\n                parsedAdaptation.mimeType = attribute.value;\n                break;\n            case \"profiles\":\n                parsedAdaptation.profiles = attribute.value;\n                break;\n            case \"segmentProfiles\":\n                parsedAdaptation.segmentProfiles = attribute.value;\n                break;\n            case \"width\":\n                {\n                    var width = parseInt(attribute.value, 10);\n                    if (isNaN(width)) {\n                        log_1.default.warn(\"DASH: invalid width (\\\"\" + attribute.value + \"\\\")\");\n                    }\n                    else {\n                        parsedAdaptation.width = width;\n                    }\n                }\n                break;\n        }\n    }\n    return parsedAdaptation;\n}\nfunction createAdaptationSetIntermediateRepresentation(adaptationSetElement) {\n    return {\n        children: parseAdaptationSetChildren(adaptationSetElement.childNodes),\n        attributes: parseAdaptationSetAttributes(adaptationSetElement),\n    };\n}\nexports.createAdaptationSetIntermediateRepresentation = createAdaptationSetIntermediateRepresentation;\n\n\n//# sourceURL=webpack://RxPlayer/./src/net/dash/manifest/node_parsers/AdaptationSet.ts?");

/***/ }),

/***/ "./src/net/dash/manifest/node_parsers/ContentComponent.ts":
/*!****************************************************************!*\
  !*** ./src/net/dash/manifest/node_parsers/ContentComponent.ts ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar helpers_1 = __webpack_require__(/*! ../helpers */ \"./src/net/dash/manifest/helpers.ts\");\n/**\n * Parse a \"ContentComponent\" Element in a DASH MPD.\n * @param {Element} root\n * @returns {Object}\n */\nfunction parseContentComponent(root) {\n    var ret = {};\n    for (var i = 0; i < root.attributes.length; i++) {\n        var attribute = root.attributes[i];\n        switch (attribute.name) {\n            case \"id\":\n                ret.id = attribute.value;\n                break;\n            case \"lang\":\n                ret.language = attribute.value;\n                break;\n            case \"contentType\":\n                ret.contentType = attribute.value;\n                break;\n            case \"par\":\n                ret.par = helpers_1.parseRatio(attribute.value);\n                break;\n        }\n    }\n    return ret;\n}\nexports.default = parseContentComponent;\n\n\n//# sourceURL=webpack://RxPlayer/./src/net/dash/manifest/node_parsers/ContentComponent.ts?");

/***/ }),

/***/ "./src/net/dash/manifest/node_parsers/ContentProtection.ts":
/*!*****************************************************************!*\
  !*** ./src/net/dash/manifest/node_parsers/ContentProtection.ts ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar helpers_1 = __webpack_require__(/*! ../helpers */ \"./src/net/dash/manifest/helpers.ts\");\n/**\n * Parse the \"ContentProtection\" node of a MPD.\n * @param {Element} root\n * @param {Function} [contentProtectionParser]\n * @returns {Object}\n */\nfunction parseContentProtection(root) {\n    return helpers_1.parseScheme(root);\n}\nexports.default = parseContentProtection;\n\n\n//# sourceURL=webpack://RxPlayer/./src/net/dash/manifest/node_parsers/ContentProtection.ts?");

/***/ }),

/***/ "./src/net/dash/manifest/node_parsers/Initialization.ts":
/*!**************************************************************!*\
  !*** ./src/net/dash/manifest/node_parsers/Initialization.ts ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar log_1 = __webpack_require__(/*! ../../../../utils/log */ \"./src/utils/log.ts\");\nvar helpers_1 = __webpack_require__(/*! ../helpers */ \"./src/net/dash/manifest/helpers.ts\");\n/**\n * @param {Element} root\n * @returns {Object}\n */\nfunction parseInitialization(root) {\n    var parsedInitialization = {};\n    for (var i = 0; i < root.attributes.length; i++) {\n        var attribute = root.attributes[i];\n        switch (attribute.name) {\n            case \"range\":\n                {\n                    var range = helpers_1.parseByteRange(attribute.value) || undefined;\n                    if (!range) {\n                        log_1.default.warn(\"DASH: invalid range (\\\"\" + attribute.value + \"\\\")\");\n                    }\n                    else {\n                        parsedInitialization.range = range;\n                    }\n                }\n                break;\n            case \"sourceURL\":\n                parsedInitialization.media = attribute.value;\n                break;\n        }\n    }\n    return parsedInitialization;\n}\nexports.default = parseInitialization;\n\n\n//# sourceURL=webpack://RxPlayer/./src/net/dash/manifest/node_parsers/Initialization.ts?");

/***/ }),

/***/ "./src/net/dash/manifest/node_parsers/MPD.ts":
/*!***************************************************!*\
  !*** ./src/net/dash/manifest/node_parsers/MPD.ts ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar helpers_1 = __webpack_require__(/*! ../helpers */ \"./src/net/dash/manifest/helpers.ts\");\nvar Period_1 = __webpack_require__(/*! ./Period */ \"./src/net/dash/manifest/node_parsers/Period.ts\");\n/**\n * Parse children of the MPD's root into a simple object.\n * @param {NodeList} mpdChildren\n * @returns {Object}\n */\nfunction parseMPDChildren(mpdChildren) {\n    var baseURL = \"\";\n    var locations = [];\n    var periods = [];\n    for (var i = 0; i < mpdChildren.length; i++) {\n        if (mpdChildren[i].nodeType === Node.ELEMENT_NODE) {\n            var currentNode = mpdChildren[i];\n            switch (currentNode.nodeName) {\n                case \"BaseURL\":\n                    baseURL = currentNode.textContent || \"\";\n                    break;\n                case \"Location\":\n                    locations.push(currentNode.textContent || \"\");\n                    break;\n                case \"Period\":\n                    var period = Period_1.createPeriodIntermediateRepresentation(currentNode);\n                    periods.push(period);\n                    break;\n            }\n        }\n    }\n    return { baseURL: baseURL, locations: locations, periods: periods };\n}\n/**\n * @param {Element} root\n * @returns {Object}\n */\nfunction parseMPDAttributes(root) {\n    var res = {};\n    for (var i = 0; i < root.attributes.length; i++) {\n        var attribute = root.attributes[i];\n        switch (attribute.name) {\n            case \"id\":\n                res.id = attribute.value;\n                break;\n            case \"profiles\":\n                res.profiles = attribute.value;\n                break;\n            case \"type\":\n                res.type = attribute.value;\n                break;\n            case \"availabilityStartTime\":\n                res.availabilityStartTime = +helpers_1.parseDateTime(attribute.value);\n                break;\n            case \"availabilityEndTime\":\n                res.availabilityEndTime = +helpers_1.parseDateTime(attribute.value);\n                break;\n            case \"publishTime\":\n                res.publishTime = +helpers_1.parseDateTime(attribute.value);\n                break;\n            case \"mediaPresentationDuration\":\n                res.duration = helpers_1.parseDuration(attribute.value);\n                break;\n            case \"minimumUpdatePeriod\":\n                res.minimumUpdatePeriod = helpers_1.parseDuration(attribute.value);\n                break;\n            case \"minBufferTime\":\n                res.minBufferTime = helpers_1.parseDuration(attribute.value);\n                break;\n            case \"timeShiftBufferDepth\":\n                res.timeShiftBufferDepth = helpers_1.parseDuration(attribute.value);\n                break;\n            case \"suggestedPresentationDelay\":\n                res.suggestedPresentationDelay = helpers_1.parseDuration(attribute.value);\n                break;\n            case \"maxSegmentDuration\":\n                res.maxSegmentDuration = helpers_1.parseDuration(attribute.value);\n                break;\n            case \"maxSubsegmentDuration\":\n                res.maxSubsegmentDuration = helpers_1.parseDuration(attribute.value);\n                break;\n        }\n    }\n    return res;\n}\nfunction createMPDIntermediateRepresentation(root) {\n    return {\n        children: parseMPDChildren(root.childNodes),\n        attributes: parseMPDAttributes(root),\n    };\n}\nexports.createMPDIntermediateRepresentation = createMPDIntermediateRepresentation;\n\n\n//# sourceURL=webpack://RxPlayer/./src/net/dash/manifest/node_parsers/MPD.ts?");

/***/ }),

/***/ "./src/net/dash/manifest/node_parsers/Period.ts":
/*!******************************************************!*\
  !*** ./src/net/dash/manifest/node_parsers/Period.ts ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar log_1 = __webpack_require__(/*! ../../../../utils/log */ \"./src/utils/log.ts\");\nvar helpers_1 = __webpack_require__(/*! ../helpers */ \"./src/net/dash/manifest/helpers.ts\");\nvar AdaptationSet_1 = __webpack_require__(/*! ./AdaptationSet */ \"./src/net/dash/manifest/node_parsers/AdaptationSet.ts\");\n/**\n * @param {NodeList} periodChildren\n * @returns {Object}\n */\nfunction parsePeriodChildren(periodChildren) {\n    var baseURL = \"\";\n    var adaptations = [];\n    for (var i = 0; i < periodChildren.length; i++) {\n        if (periodChildren[i].nodeType === Node.ELEMENT_NODE) {\n            var currentElement = periodChildren[i];\n            switch (currentElement.nodeName) {\n                case \"BaseURL\":\n                    baseURL = currentElement.textContent || \"\";\n                    break;\n                case \"AdaptationSet\":\n                    var adaptation = AdaptationSet_1.createAdaptationSetIntermediateRepresentation(currentElement);\n                    adaptations.push(adaptation);\n                    break;\n            }\n        }\n    }\n    return { baseURL: baseURL, adaptations: adaptations };\n}\n/**\n * @param {Element} periodElement\n * @returns {Object}\n */\nfunction parsePeriodAttributes(periodElement) {\n    var res = {};\n    for (var i = 0; i < periodElement.attributes.length; i++) {\n        var attribute = periodElement.attributes[i];\n        switch (attribute.name) {\n            case \"id\":\n                res.id = attribute.value;\n                break;\n            case \"start\":\n                {\n                    var tempStart = helpers_1.parseDuration(attribute.value);\n                    if (!isNaN(tempStart)) {\n                        res.start = tempStart;\n                    }\n                    else {\n                        log_1.default.warn(\"DASH: Unrecognized start in the mpd:\", attribute.value);\n                    }\n                }\n                break;\n            case \"duration\":\n                {\n                    var tempDuration = helpers_1.parseDuration(attribute.value);\n                    if (!isNaN(tempDuration)) {\n                        res.duration = tempDuration;\n                    }\n                    else {\n                        log_1.default.warn(\"DASH: Unrecognized duration in the mpd:\", attribute.value);\n                    }\n                }\n                break;\n            case \"bitstreamSwitching\":\n                res.bitstreamSwitching = helpers_1.parseBoolean(attribute.value);\n                break;\n        }\n    }\n    return res;\n}\nfunction createPeriodIntermediateRepresentation(periodElement) {\n    return {\n        children: parsePeriodChildren(periodElement.childNodes),\n        attributes: parsePeriodAttributes(periodElement),\n    };\n}\nexports.createPeriodIntermediateRepresentation = createPeriodIntermediateRepresentation;\n\n\n//# sourceURL=webpack://RxPlayer/./src/net/dash/manifest/node_parsers/Period.ts?");

/***/ }),

/***/ "./src/net/dash/manifest/node_parsers/Representation.ts":
/*!**************************************************************!*\
  !*** ./src/net/dash/manifest/node_parsers/Representation.ts ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar log_1 = __webpack_require__(/*! ../../../../utils/log */ \"./src/utils/log.ts\");\nvar helpers_1 = __webpack_require__(/*! ../helpers */ \"./src/net/dash/manifest/helpers.ts\");\nvar SegmentBase_1 = __webpack_require__(/*! ./SegmentBase */ \"./src/net/dash/manifest/node_parsers/SegmentBase.ts\");\nvar SegmentList_1 = __webpack_require__(/*! ./SegmentList */ \"./src/net/dash/manifest/node_parsers/SegmentList.ts\");\nvar SegmentTemplate_1 = __webpack_require__(/*! ./SegmentTemplate */ \"./src/net/dash/manifest/node_parsers/SegmentTemplate.ts\");\n/**\n * @param {NodeList} representationChildren\n * @returns {Object}\n */\nfunction parseRepresentationChildren(representationChildren) {\n    var children = {\n        baseURL: \"\",\n    };\n    for (var i = 0; i < representationChildren.length; i++) {\n        if (representationChildren[i].nodeType === Node.ELEMENT_NODE) {\n            var currentElement = representationChildren[i];\n            switch (currentElement.nodeName) {\n                case \"BaseURL\":\n                    children.baseURL = currentElement.textContent || \"\";\n                    break;\n                case \"SegmentBase\":\n                    children.segmentBase = SegmentBase_1.default(currentElement);\n                    break;\n                case \"SegmentList\":\n                    children.segmentList = SegmentList_1.default(currentElement);\n                    break;\n                case \"SegmentTemplate\":\n                    children.segmentTemplate = SegmentTemplate_1.default(currentElement);\n                    break;\n            }\n        }\n    }\n    return children;\n}\n/**\n * @param {Element} representationElement\n * @returns {Object}\n */\nfunction parseRepresentationAttributes(representationElement) {\n    var attributes = {};\n    for (var i = 0; i < representationElement.attributes.length; i++) {\n        var attribute = representationElement.attributes[i];\n        switch (attribute.name) {\n            case \"audioSamplingRate\":\n                attributes.audioSamplingRate = attribute.value;\n                break;\n            case \"bandwidth\":\n                {\n                    var bitrate = parseInt(attribute.value, 10);\n                    if (isNaN(bitrate)) {\n                        log_1.default.warn(\"DASH: invalid bandwidth (\\\"\" + attribute.value + \"\\\")\");\n                    }\n                    else {\n                        attributes.bitrate = bitrate;\n                    }\n                }\n                break;\n            case \"codecs\":\n                attributes.codecs = attribute.value;\n                break;\n            case \"codingDependency\":\n                attributes.codingDependency = helpers_1.parseBoolean(attribute.value);\n                break;\n            case \"frameRate\":\n                {\n                    var frameRate = helpers_1.parseFrameRate(attribute.value);\n                    if (isNaN(frameRate)) {\n                        log_1.default.warn(\"DASH: invalid frameRate (\\\"\" + attribute.value + \"\\\")\");\n                    }\n                    else {\n                        attributes.frameRate = frameRate;\n                    }\n                }\n                break;\n            case \"height\":\n                {\n                    var height = parseInt(attribute.value, 10);\n                    if (isNaN(height)) {\n                        log_1.default.warn(\"DASH: invalid height (\\\"\" + attribute.value + \"\\\")\");\n                    }\n                    else {\n                        attributes.height = height;\n                    }\n                }\n                break;\n            case \"id\":\n                attributes.id = attribute.value;\n                break;\n            case \"maxPlayoutRate\":\n                {\n                    var maxPlayoutRate = parseFloat(attribute.value);\n                    if (isNaN(maxPlayoutRate)) {\n                        log_1.default.warn(\"DASH: invalid maxPlayoutRate (\\\"\" + attribute.value + \"\\\")\");\n                    }\n                    else {\n                        attributes.maxPlayoutRate = maxPlayoutRate;\n                    }\n                }\n                break;\n            case \"maximumSAPPeriod\":\n                {\n                    var maximumSAPPeriod = parseFloat(attribute.value);\n                    if (isNaN(maximumSAPPeriod)) {\n                        log_1.default.warn(\"DASH: invalid maximumSAPPeriod (\\\"\" + attribute.value + \"\\\")\");\n                    }\n                    else {\n                        attributes.maximumSAPPeriod = maximumSAPPeriod;\n                    }\n                }\n                break;\n            case \"mimeType\":\n                attributes.mimeType = attribute.value;\n                break;\n            case \"profiles\":\n                attributes.profiles = attribute.value;\n                break;\n            case \"qualityRanking\":\n                {\n                    var qualityRanking = parseInt(attribute.value, 10);\n                    if (isNaN(qualityRanking)) {\n                        log_1.default.warn(\"DASH: invalid qualityRanking (\\\"\" + attribute.value + \"\\\")\");\n                    }\n                    else {\n                        attributes.qualityRanking = qualityRanking;\n                    }\n                }\n                break;\n            case \"segmentProfiles\":\n                attributes.segmentProfiles = attribute.value;\n                break;\n            case \"width\":\n                {\n                    var width = parseInt(attribute.value, 10);\n                    if (isNaN(width)) {\n                        log_1.default.warn(\"DASH: invalid width (\\\"\" + attribute.value + \"\\\")\");\n                    }\n                    else {\n                        attributes.width = width;\n                    }\n                }\n                break;\n        }\n    }\n    return attributes;\n}\nfunction createRepresentationIntermediateRepresentation(representationElement) {\n    return {\n        children: parseRepresentationChildren(representationElement.childNodes),\n        attributes: parseRepresentationAttributes(representationElement),\n    };\n}\nexports.createRepresentationIntermediateRepresentation = createRepresentationIntermediateRepresentation;\n\n\n//# sourceURL=webpack://RxPlayer/./src/net/dash/manifest/node_parsers/Representation.ts?");

/***/ }),

/***/ "./src/net/dash/manifest/node_parsers/S.ts":
/*!*************************************************!*\
  !*** ./src/net/dash/manifest/node_parsers/S.ts ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar log_1 = __webpack_require__(/*! ../../../../utils/log */ \"./src/utils/log.ts\");\n/**\n * @param {Element} root\n * @returns {Object}\n */\nfunction parseS(root, previousS) {\n    var ts;\n    var d;\n    var r;\n    for (var j = 0; j < root.attributes.length; j++) {\n        var attribute = root.attributes[j];\n        switch (attribute.name) {\n            case \"t\":\n                ts = parseInt(attribute.value, 10);\n                break;\n            case \"d\":\n                d = parseInt(attribute.value, 10);\n                break;\n            case \"r\":\n                r = parseInt(attribute.value, 10);\n                break;\n        }\n    }\n    if (ts == null && previousS && previousS.d != null) {\n        ts = previousS.ts + (previousS.d * (previousS.r + 1));\n    }\n    if ((ts != null && !isNaN(ts)) &&\n        (d == null || !isNaN(d)) &&\n        (r == null || !isNaN(r))) {\n        return {\n            ts: ts,\n            d: d,\n            r: r || 0,\n        };\n    }\n    else {\n        log_1.default.warn(\"DASH: A \\\"S\\\" Element could not have been parsed.\");\n    }\n}\nexports.default = parseS;\n\n\n//# sourceURL=webpack://RxPlayer/./src/net/dash/manifest/node_parsers/S.ts?");

/***/ }),

/***/ "./src/net/dash/manifest/node_parsers/SegmentBase.ts":
/*!***********************************************************!*\
  !*** ./src/net/dash/manifest/node_parsers/SegmentBase.ts ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar objectAssign = __webpack_require__(/*! object-assign */ \"./node_modules/object-assign/index.js\");\nvar log_1 = __webpack_require__(/*! ../../../../utils/log */ \"./src/utils/log.ts\");\nvar helpers_1 = __webpack_require__(/*! ../helpers */ \"./src/net/dash/manifest/helpers.ts\");\nvar Initialization_1 = __webpack_require__(/*! ./Initialization */ \"./src/net/dash/manifest/node_parsers/Initialization.ts\");\n/**\n * TODO Only for SegmentBase not for other types\n * @param {Element} root\n * @returns {Object}\n */\nfunction parseSegmentBase(root) {\n    var attributes = {};\n    var segmentBaseChildren = root.childNodes;\n    for (var i = 0; i < segmentBaseChildren.length; i++) {\n        if (segmentBaseChildren[i].nodeType === Node.ELEMENT_NODE) {\n            var currentNode = segmentBaseChildren[i];\n            if (currentNode.nodeName === \"Initialization\") {\n                attributes.initialization = Initialization_1.default(currentNode);\n            }\n        }\n    }\n    for (var i = 0; i < root.attributes.length; i++) {\n        var attribute = root.attributes[i];\n        switch (attribute.name) {\n            case \"timescale\":\n                {\n                    var _timescale = parseInt(attribute.value, 10);\n                    if (isNaN(_timescale)) {\n                        log_1.default.warn(\"DASH: invalid timescale (\\\"\" + attribute.value + \"\\\")\");\n                    }\n                    else {\n                        attributes.timescale = _timescale;\n                    }\n                }\n                break;\n            case \"timeShiftBufferDepth\":\n                {\n                    var timeShiftBufferDepth = helpers_1.parseDuration(attribute.value);\n                    if (isNaN(timeShiftBufferDepth)) {\n                        log_1.default.warn(\"DASH: invalid timeShiftBufferDepth (\\\"\" + attribute.value + \"\\\")\");\n                    }\n                    else {\n                        attributes.timeShiftBufferDepth = timeShiftBufferDepth;\n                    }\n                }\n                break;\n            case \"presentationTimeOffset\":\n                {\n                    var _presentationTimeOffset = parseFloat(attribute.value);\n                    if (isNaN(_presentationTimeOffset)) {\n                        log_1.default.warn(\"DASH: invalid presentationTimeOffset (\\\"\" + attribute.value + \"\\\")\");\n                    }\n                    else {\n                        attributes.presentationTimeOffset = _presentationTimeOffset;\n                    }\n                }\n                break;\n            case \"indexRange\":\n                attributes.indexRange = helpers_1.parseByteRange(attribute.value) || undefined;\n                break;\n            case \"indexRangeExact\":\n                attributes.indexRangeExact = helpers_1.parseBoolean(attribute.value);\n                break;\n            case \"availabilityTimeOffset\":\n                {\n                    var availabilityTimeOffset = parseFloat(attribute.value);\n                    if (isNaN(availabilityTimeOffset)) {\n                        log_1.default.warn(\"DASH: invalid availabilityTimeOffset (\\\"\" + attribute.value + \"\\\")\");\n                    }\n                    else {\n                        attributes.availabilityTimeOffset = availabilityTimeOffset;\n                    }\n                }\n                break;\n            case \"availabilityTimeComplete\":\n                attributes.availabilityTimeComplete = helpers_1.parseBoolean(attribute.value);\n                break;\n            case \"duration\":\n                {\n                    var duration = parseInt(attribute.value, 10);\n                    if (isNaN(duration)) {\n                        log_1.default.warn(\"DASH: invalid duration (\\\"\" + attribute.value + \"\\\")\");\n                    }\n                    else {\n                        attributes.duration = duration;\n                    }\n                }\n                break;\n            case \"startNumber\":\n                {\n                    var startNumber = parseInt(attribute.value, 10);\n                    if (isNaN(startNumber)) {\n                        log_1.default.warn(\"DASH: invalid startNumber (\\\"\" + attribute.value + \"\\\")\");\n                    }\n                    else {\n                        attributes.startNumber = startNumber;\n                    }\n                }\n                break;\n        }\n    }\n    var timescale = attributes.timescale == null ? 1 : attributes.timescale;\n    var indexRangeExact = !!attributes.indexRangeExact;\n    var availabilityTimeComplete = attributes.availabilityTimeComplete == null ?\n        true : attributes.availabilityTimeComplete;\n    return objectAssign(attributes, {\n        availabilityTimeComplete: availabilityTimeComplete,\n        indexRangeExact: indexRangeExact,\n        timeline: [],\n        timescale: timescale,\n    });\n}\nexports.default = parseSegmentBase;\n\n\n//# sourceURL=webpack://RxPlayer/./src/net/dash/manifest/node_parsers/SegmentBase.ts?");

/***/ }),

/***/ "./src/net/dash/manifest/node_parsers/SegmentList.ts":
/*!***********************************************************!*\
  !*** ./src/net/dash/manifest/node_parsers/SegmentList.ts ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar objectAssign = __webpack_require__(/*! object-assign */ \"./node_modules/object-assign/index.js\");\nvar SegmentBase_1 = __webpack_require__(/*! ./SegmentBase */ \"./src/net/dash/manifest/node_parsers/SegmentBase.ts\");\nvar SegmentURL_1 = __webpack_require__(/*! ./SegmentURL */ \"./src/net/dash/manifest/node_parsers/SegmentURL.ts\");\n/**\n * @param {Element} root\n * @returns {Object}\n */\nfunction parseSegmentList(root) {\n    var base = SegmentBase_1.default(root);\n    var list = [];\n    var segmentListChildren = root.childNodes;\n    for (var i = 0; i < segmentListChildren.length; i++) {\n        if (segmentListChildren[i].nodeType === Node.ELEMENT_NODE) {\n            var currentNode = segmentListChildren[i];\n            if (currentNode.nodeName === \"SegmentURL\") {\n                var segmentURL = SegmentURL_1.default(currentNode);\n                list.push(segmentURL);\n            }\n        }\n    }\n    var baseDuration = base.duration;\n    if (baseDuration == null) {\n        throw new Error(\"Invalid SegmentList: no duration\");\n    }\n    return objectAssign(base, {\n        list: list,\n        duration: baseDuration,\n    });\n}\nexports.default = parseSegmentList;\n\n\n//# sourceURL=webpack://RxPlayer/./src/net/dash/manifest/node_parsers/SegmentList.ts?");

/***/ }),

/***/ "./src/net/dash/manifest/node_parsers/SegmentTemplate.ts":
/*!***************************************************************!*\
  !*** ./src/net/dash/manifest/node_parsers/SegmentTemplate.ts ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar objectAssign = __webpack_require__(/*! object-assign */ \"./node_modules/object-assign/index.js\");\nvar helpers_1 = __webpack_require__(/*! ../helpers */ \"./src/net/dash/manifest/helpers.ts\");\nvar SegmentBase_1 = __webpack_require__(/*! ./SegmentBase */ \"./src/net/dash/manifest/node_parsers/SegmentBase.ts\");\nvar SegmentTimeline_1 = __webpack_require__(/*! ./SegmentTimeline */ \"./src/net/dash/manifest/node_parsers/SegmentTimeline.ts\");\n/**\n * Parse initialization attribute found in segment Template to\n * correspond to the initialization found in a regular segmentBase.\n * @param {string} attrValue\n * @returns {Object}\n */\nfunction parseInitializationAttribute(attrValue) {\n    return { media: attrValue };\n}\n/**\n * @param {Element} root\n * @returns {Object}\n */\nfunction parseSegmentTemplate(root) {\n    var base = SegmentBase_1.default(root);\n    var ret;\n    var index;\n    var media;\n    var bitstreamSwitching;\n    var timeline;\n    for (var i = 0; i < root.childNodes.length; i++) {\n        if (root.childNodes[i].nodeType === Node.ELEMENT_NODE) {\n            var currentNode = root.childNodes[i];\n            if (currentNode.nodeName === \"SegmentTimeline\") {\n                timeline = SegmentTimeline_1.default(currentNode);\n            }\n        }\n    }\n    for (var i = 0; i < root.attributes.length; i++) {\n        var attribute = root.attributes[i];\n        switch (attribute.nodeName) {\n            case \"initialization\":\n                if (base.initialization == null) {\n                    base.initialization = parseInitializationAttribute(attribute.value);\n                }\n                break;\n            case \"index\":\n                index = attribute.value;\n                break;\n            case \"media\":\n                media = attribute.value;\n                break;\n            case \"bitstreamSwitching\":\n                bitstreamSwitching = helpers_1.parseBoolean(attribute.value);\n                break;\n        }\n    }\n    if (timeline != null) {\n        ret = objectAssign({}, base, {\n            indexType: \"timeline\",\n            timeline: timeline,\n        });\n    }\n    else {\n        var segmentDuration = base.duration;\n        if (segmentDuration == null) {\n            throw new Error(\"Invalid SegmentTemplate: no duration\");\n        }\n        ret = objectAssign({}, base, {\n            indexType: \"template\",\n            duration: segmentDuration,\n        });\n    }\n    if (index != null) {\n        ret.index = index;\n    }\n    if (media != null) {\n        ret.media = media;\n    }\n    if (bitstreamSwitching != null) {\n        ret.bitstreamSwitching = bitstreamSwitching;\n    }\n    return ret;\n}\nexports.default = parseSegmentTemplate;\n\n\n//# sourceURL=webpack://RxPlayer/./src/net/dash/manifest/node_parsers/SegmentTemplate.ts?");

/***/ }),

/***/ "./src/net/dash/manifest/node_parsers/SegmentTimeline.ts":
/*!***************************************************************!*\
  !*** ./src/net/dash/manifest/node_parsers/SegmentTimeline.ts ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar S_1 = __webpack_require__(/*! ./S */ \"./src/net/dash/manifest/node_parsers/S.ts\");\n/**\n * @param {Element} root\n * @returns {Array.<Object>}\n */\nfunction parseSegmentTimeline(root) {\n    var timeline = [];\n    var timelineChildren = root.childNodes;\n    for (var i = 0; i < timelineChildren.length; i++) {\n        if (timelineChildren[i].nodeType === Node.ELEMENT_NODE) {\n            var currentElement = timelineChildren[i];\n            if (currentElement.nodeName === \"S\") {\n                var s = S_1.default(currentElement, timeline[timeline.length - 1] || null);\n                if (s) {\n                    timeline.push(s);\n                }\n            }\n        }\n    }\n    return timeline;\n}\nexports.default = parseSegmentTimeline;\n\n\n//# sourceURL=webpack://RxPlayer/./src/net/dash/manifest/node_parsers/SegmentTimeline.ts?");

/***/ }),

/***/ "./src/net/dash/manifest/node_parsers/SegmentURL.ts":
/*!**********************************************************!*\
  !*** ./src/net/dash/manifest/node_parsers/SegmentURL.ts ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar log_1 = __webpack_require__(/*! ../../../../utils/log */ \"./src/utils/log.ts\");\nvar helpers_1 = __webpack_require__(/*! ../helpers */ \"./src/net/dash/manifest/helpers.ts\");\n/**\n * @param {Element} root\n * @returns {Object}\n */\nfunction parseSegmentURL(root) {\n    var parsedSegmentURL = {};\n    for (var i = 0; i < root.attributes.length; i++) {\n        var attribute = root.attributes[i];\n        switch (attribute.name) {\n            case \"media\":\n                parsedSegmentURL.media = attribute.value;\n                break;\n            case \"indexRange\":\n                {\n                    var indexRange = helpers_1.parseByteRange(attribute.value) || undefined;\n                    if (!indexRange) {\n                        log_1.default.warn(\"DASH: invalid indexRange (\\\"\" + attribute.value + \"\\\")\");\n                    }\n                    else {\n                        parsedSegmentURL.indexRange = indexRange;\n                    }\n                }\n                break;\n            case \"index\":\n                parsedSegmentURL.index = attribute.value;\n                break;\n            case \"mediaRange\":\n                {\n                    var mediaRange = helpers_1.parseByteRange(attribute.value) || undefined;\n                    if (!mediaRange) {\n                        log_1.default.warn(\"DASH: invalid mediaRange (\\\"\" + attribute.value + \"\\\")\");\n                    }\n                    else {\n                        parsedSegmentURL.mediaRange = mediaRange;\n                    }\n                }\n                break;\n        }\n    }\n    return parsedSegmentURL;\n}\nexports.default = parseSegmentURL;\n\n\n//# sourceURL=webpack://RxPlayer/./src/net/dash/manifest/node_parsers/SegmentURL.ts?");

/***/ }),

/***/ "./src/net/dash/manifest/node_parsers/index.ts":
/*!*****************************************************!*\
  !*** ./src/net/dash/manifest/node_parsers/index.ts ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar config_1 = __webpack_require__(/*! ../../../../config */ \"./src/config.ts\");\nvar array_includes_1 = __webpack_require__(/*! ../../../../utils/array-includes */ \"./src/utils/array-includes.ts\");\nvar id_1 = __webpack_require__(/*! ../../../../utils/id */ \"./src/utils/id.ts\");\nvar languages_1 = __webpack_require__(/*! ../../../../utils/languages */ \"./src/utils/languages/index.ts\");\nvar log_1 = __webpack_require__(/*! ../../../../utils/log */ \"./src/utils/log.ts\");\nvar url_1 = __webpack_require__(/*! ../../../../utils/url */ \"./src/utils/url.ts\");\nvar helpers_1 = __webpack_require__(/*! ../helpers */ \"./src/net/dash/manifest/helpers.ts\");\nvar base_1 = __webpack_require__(/*! ../indexes/base */ \"./src/net/dash/manifest/indexes/base.ts\");\nvar list_1 = __webpack_require__(/*! ../indexes/list */ \"./src/net/dash/manifest/indexes/list.ts\");\nvar template_1 = __webpack_require__(/*! ../indexes/template */ \"./src/net/dash/manifest/indexes/template.ts\");\nvar timeline_1 = __webpack_require__(/*! ../indexes/timeline */ \"./src/net/dash/manifest/indexes/timeline.ts\");\nvar MPD_1 = __webpack_require__(/*! ./MPD */ \"./src/net/dash/manifest/node_parsers/MPD.ts\");\nvar KNOWN_ADAPTATION_TYPES = [\"audio\", \"video\", \"text\", \"image\"];\nvar SUPPORTED_TEXT_TYPES = [\"subtitle\", \"caption\"];\n/**\n * Infers the type of adaptation from codec and mimetypes found in it.\n *\n * This follows the guidelines defined by the DASH-IF IOP:\n *   - one adaptation set contains a single media type\n *   - The order of verifications are:\n *       1. mimeType\n *       2. Role\n *       3. codec\n *\n * Note: This is based on DASH-IF-IOP-v4.0 with some more freedom.\n * @param {Object} adaptation\n * @returns {string} - \"audio\"|\"video\"|\"text\"|\"image\"|\"metadata\"|\"unknown\"\n */\nfunction inferAdaptationType(adaptationMimeType, representationMimeTypes, adaptationCodecs, representationCodecs, adaptationRole) {\n    function fromMimeType(mimeType, role) {\n        var topLevel = mimeType.split(\"/\")[0];\n        if (array_includes_1.default(KNOWN_ADAPTATION_TYPES, topLevel)) {\n            return topLevel;\n        }\n        if (mimeType === \"application/bif\") {\n            return \"image\";\n        }\n        if (mimeType === \"application/ttml+xml\") {\n            return \"text\";\n        }\n        // manage DASH-IF mp4-embedded subtitles and metadata\n        if (mimeType === \"application/mp4\") {\n            if (role) {\n                if (role.schemeIdUri === \"urn:mpeg:dash:role:2011\" &&\n                    array_includes_1.default(SUPPORTED_TEXT_TYPES, role.value)) {\n                    return \"text\";\n                }\n            }\n            return \"metadata\";\n        }\n    }\n    function fromCodecs(codecs) {\n        switch (codecs.substr(0, 3)) {\n            case \"avc\":\n            case \"hev\":\n            case \"hvc\":\n            case \"vp8\":\n            case \"vp9\":\n            case \"av1\":\n                return \"video\";\n            case \"vtt\":\n                return \"text\";\n            case \"bif\":\n                return \"image\";\n        }\n        switch (codecs.substr(0, 4)) {\n            case \"mp4a\":\n                return \"audio\";\n            case \"wvtt\":\n            case \"stpp\":\n                return \"text\";\n        }\n    }\n    if (adaptationMimeType != null) {\n        var typeFromMimeType = fromMimeType(adaptationMimeType, adaptationRole);\n        if (typeFromMimeType != null) {\n            return typeFromMimeType;\n        }\n    }\n    if (adaptationCodecs != null) {\n        var typeFromCodecs = fromCodecs(adaptationCodecs);\n        if (typeFromCodecs != null) {\n            return typeFromCodecs;\n        }\n    }\n    for (var i = 0; i < representationMimeTypes.length; i++) {\n        var representationMimeType = representationMimeTypes[i];\n        if (representationMimeType != null) {\n            var typeFromMimeType = fromMimeType(representationMimeType, adaptationRole);\n            if (typeFromMimeType != null) {\n                return typeFromMimeType;\n            }\n        }\n    }\n    for (var i = 0; i < representationCodecs.length; i++) {\n        var codecs = representationCodecs[i];\n        if (codecs != null) {\n            var typeFromMimeType = fromCodecs(codecs);\n            if (typeFromMimeType != null) {\n                return typeFromMimeType;\n            }\n        }\n    }\n    return \"unknown\";\n}\n/**\n * Returns \"last time of reference\" from the adaptation given, considering a\n * live content.\n * Undefined if a time could not be found.\n *\n * We consider the earliest last time from every representations in the given\n * adaptation.\n *\n * This is done to calculate a liveGap which is valid for the whole manifest,\n * even in weird ones.\n * @param {Object} adaptation\n * @returns {Number|undefined}\n */\nvar getLastLiveTimeReference = function (adaptation) {\n    // Here's how we do, for each possibility:\n    //  1. only the adaptation has an index (no representation has):\n    //    - returns the index last time reference\n    //\n    //  2. every representations have an index:\n    //    - returns minimum for every representations\n    //\n    //  3. not all representations have an index but the adaptation has\n    //    - returns minimum between all representations and the adaptation\n    //\n    //  4. no index for 1+ representation(s) and no adaptation index:\n    //    - returns undefined\n    //\n    //  5. Invalid index found somewhere:\n    //    - returns undefined\n    if (!adaptation) {\n        return undefined;\n    }\n    var representations = adaptation.representations || [];\n    var lastLiveTimeReferences = representations\n        .map(function (representation) {\n        var lastPosition = representation.index.getLastPosition();\n        return lastPosition != null ? lastPosition - 10 : undefined; // TODO\n    });\n    if (lastLiveTimeReferences.some(function (x) { return x == null; })) {\n        return undefined;\n    }\n    var representationsMin = Math.min.apply(Math, lastLiveTimeReferences);\n    if (isNaN(representationsMin)) {\n        return undefined;\n    }\n    return representationsMin;\n};\nfunction parseManifest(root, uri\n// contentProtectionParser?: IContentProtectionParser\n) {\n    // Transform whole MPD into a parsed JS object representation\n    var _a = MPD_1.createMPDIntermediateRepresentation(root), rootChildren = _a.children, rootAttributes = _a.attributes;\n    var mpdRootURL = url_1.resolveURL(url_1.normalizeBaseURL(uri), rootChildren.baseURL);\n    var parsedPeriods = [];\n    var _loop_1 = function (i) {\n        var period = rootChildren.periods[i];\n        // 1. Construct partial URL for contents\n        var periodRootURL = url_1.resolveURL(mpdRootURL, period.children.baseURL);\n        // 2. Generate ID\n        var periodID = void 0;\n        if (period.attributes.id == null) {\n            log_1.default.warn(\"DASH: No usable id found in the Period. Generating one.\");\n            periodID = \"gen-dash-period-\" + id_1.default();\n        }\n        else {\n            periodID = period.attributes.id;\n        }\n        // 3. Find the start of the Period (required)\n        var periodStart;\n        if (period.attributes.start != null) {\n            periodStart = period.attributes.start;\n        }\n        else {\n            if (i === 0) {\n                periodStart = (rootAttributes.type === \"static\" ||\n                    rootAttributes.availabilityStartTime == null) ? 0 : rootAttributes.availabilityStartTime;\n            }\n            else {\n                var prevPeriod = parsedPeriods[i - 1];\n                if (prevPeriod.duration != null) {\n                    periodStart = prevPeriod.start + prevPeriod.duration;\n                }\n                else {\n                    throw new Error(\"Not enough informations on the periods: cannot find start.\");\n                }\n            }\n        }\n        var periodDuration = void 0;\n        if (period.attributes.duration != null) {\n            periodDuration = period.attributes.duration;\n        }\n        else {\n            var nextPeriod = parsedPeriods[i + 1];\n            if (nextPeriod && nextPeriod.start != null) {\n                periodDuration = nextPeriod.start - periodStart;\n            }\n            else if (i === 0 &&\n                rootAttributes.duration &&\n                !nextPeriod) {\n                periodDuration = rootAttributes.duration;\n            }\n        }\n        // 4. Construct underlying adaptations\n        var adaptations = period.children.adaptations.map(function (adaptation) {\n            var adaptationRootURL = url_1.resolveURL(periodRootURL, adaptation.children.baseURL);\n            var adaptationChildren = adaptation.children;\n            // 4-1. Find Index\n            var adaptationIndex;\n            if (adaptationChildren.segmentBase != null) {\n                adaptationIndex = new base_1.default(adaptationChildren.segmentBase, periodStart);\n            }\n            else if (adaptationChildren.segmentList != null) {\n                adaptationIndex = new list_1.default(adaptationChildren.segmentList, periodStart);\n            }\n            else if (adaptationChildren.segmentTemplate != null) {\n                var template = adaptationChildren.segmentTemplate;\n                template.presentationTimeOffset = periodStart * template.timescale;\n                adaptationIndex = template.indexType === \"timeline\" ?\n                    // TODO Find a way with the optional 'd'\n                    new timeline_1.default(template, periodStart) :\n                    new template_1.default(template, periodStart);\n            }\n            else {\n                adaptationIndex = new template_1.default({\n                    duration: Number.MAX_VALUE,\n                    timescale: 1,\n                    startNumber: 0,\n                }, periodStart);\n            }\n            // 4-2. Construct Representations\n            var representations = adaptation.children\n                .representations.map(function (representation) {\n                var representationURL = url_1.resolveURL(adaptationRootURL, representation.children.baseURL);\n                // 4-2-1. Find bitrate\n                var representationBitrate;\n                if (representation.attributes.bitrate == null) {\n                    log_1.default.warn(\"DASH: No usable bitrate found in the Representation.\");\n                    representationBitrate = 0;\n                }\n                else {\n                    representationBitrate = representation.attributes.bitrate;\n                }\n                // 4-2-2. Find Index\n                var representationIndex;\n                if (representation.children.segmentBase != null) {\n                    representationIndex = new base_1.default(representation.children.segmentBase, periodStart);\n                }\n                else if (representation.children.segmentList != null) {\n                    representationIndex = new list_1.default(representation.children.segmentList, periodStart);\n                }\n                else if (representation.children.segmentTemplate != null) {\n                    var template = representation.children.segmentTemplate;\n                    representationIndex = template.indexType === \"timeline\" ?\n                        // TODO Find a way with the optional 'd'\n                        new timeline_1.default(template, periodStart) :\n                        new template_1.default(template, periodStart);\n                }\n                else {\n                    representationIndex = adaptationIndex;\n                }\n                // 4-2-3. Set ID\n                var representationID = representation.attributes.id != null ?\n                    representation.attributes.id :\n                    (representation.attributes.bitrate +\n                        (representation.attributes.height != null ?\n                            (\"-\" + representation.attributes.height) : \"\") +\n                        (representation.attributes.width != null ?\n                            (\"-\" + representation.attributes.width) : \"\") +\n                        (representation.attributes.mimeType != null ?\n                            (\"-\" + representation.attributes.mimeType) : \"\") +\n                        (representation.attributes.codecs != null ?\n                            (\"-\" + representation.attributes.codecs) : \"\"));\n                // 4-2-4. Construct Representation Base\n                var parsedRepresentation = {\n                    bitrate: representationBitrate,\n                    index: representationIndex,\n                    id: representationID,\n                    baseURL: representationURL,\n                };\n                // 4-2-5. Add optional attributes\n                var codecs;\n                if (representation.attributes.codecs != null) {\n                    codecs = representation.attributes.codecs;\n                }\n                else if (adaptation.attributes.codecs != null) {\n                    codecs = adaptation.attributes.codecs;\n                }\n                if (codecs != null) {\n                    codecs = codecs === \"mp4a.40.02\" ? \"mp4a.40.2\" : codecs;\n                    parsedRepresentation.codecs = codecs;\n                }\n                if (representation.attributes.audioSamplingRate != null) {\n                    parsedRepresentation.audioSamplingRate =\n                        representation.attributes.audioSamplingRate;\n                }\n                else if (adaptation.attributes.audioSamplingRate != null) {\n                    parsedRepresentation.audioSamplingRate =\n                        adaptation.attributes.audioSamplingRate;\n                }\n                if (representation.attributes.codingDependency != null) {\n                    parsedRepresentation.codingDependency =\n                        representation.attributes.codingDependency;\n                }\n                else if (adaptation.attributes.codingDependency != null) {\n                    parsedRepresentation.codingDependency =\n                        adaptation.attributes.codingDependency;\n                }\n                if (representation.attributes.frameRate != null) {\n                    parsedRepresentation.frameRate =\n                        representation.attributes.frameRate;\n                }\n                else if (adaptation.attributes.frameRate != null) {\n                    parsedRepresentation.frameRate =\n                        adaptation.attributes.frameRate;\n                }\n                if (representation.attributes.height != null) {\n                    parsedRepresentation.height =\n                        representation.attributes.height;\n                }\n                else if (adaptation.attributes.height != null) {\n                    parsedRepresentation.height =\n                        adaptation.attributes.height;\n                }\n                if (representation.attributes.maxPlayoutRate != null) {\n                    parsedRepresentation.maxPlayoutRate =\n                        representation.attributes.maxPlayoutRate;\n                }\n                else if (adaptation.attributes.maxPlayoutRate != null) {\n                    parsedRepresentation.maxPlayoutRate =\n                        adaptation.attributes.maxPlayoutRate;\n                }\n                if (representation.attributes.maximumSAPPeriod != null) {\n                    parsedRepresentation.maximumSAPPeriod =\n                        representation.attributes.maximumSAPPeriod;\n                }\n                else if (adaptation.attributes.maximumSAPPeriod != null) {\n                    parsedRepresentation.maximumSAPPeriod =\n                        adaptation.attributes.maximumSAPPeriod;\n                }\n                if (representation.attributes.mimeType != null) {\n                    parsedRepresentation.mimeType =\n                        representation.attributes.mimeType;\n                }\n                else if (adaptation.attributes.mimeType != null) {\n                    parsedRepresentation.mimeType =\n                        adaptation.attributes.mimeType;\n                }\n                if (representation.attributes.profiles != null) {\n                    parsedRepresentation.profiles =\n                        representation.attributes.profiles;\n                }\n                else if (adaptation.attributes.profiles != null) {\n                    parsedRepresentation.profiles =\n                        adaptation.attributes.profiles;\n                }\n                if (representation.attributes.qualityRanking != null) {\n                    parsedRepresentation.qualityRanking =\n                        representation.attributes.qualityRanking;\n                }\n                if (representation.attributes.segmentProfiles != null) {\n                    parsedRepresentation.segmentProfiles =\n                        representation.attributes.segmentProfiles;\n                }\n                else if (adaptation.attributes.segmentProfiles != null) {\n                    parsedRepresentation.segmentProfiles =\n                        adaptation.attributes.segmentProfiles;\n                }\n                if (representation.attributes.width != null) {\n                    parsedRepresentation.width =\n                        representation.attributes.width;\n                }\n                else if (adaptation.attributes.width != null) {\n                    parsedRepresentation.width =\n                        adaptation.attributes.width;\n                }\n                return parsedRepresentation;\n            });\n            var adaptationMimeType = adaptation.attributes.mimeType;\n            var adaptationCodecs = adaptation.attributes.codecs;\n            var representationMimeTypes = representations\n                .map(function (r) { return r.mimeType; })\n                .filter(function (mimeType) { return mimeType != null; });\n            var representationCodecs = representations\n                .map(function (r) { return r.codecs; })\n                .filter(function (codecs) { return codecs != null; });\n            var type = inferAdaptationType(adaptationMimeType || null, representationMimeTypes, adaptationCodecs || null, representationCodecs, adaptationChildren.role || null);\n            var closedCaption;\n            var audioDescription;\n            if (type === \"text\" &&\n                adaptationChildren.accessibility &&\n                helpers_1.isHardOfHearing(adaptationChildren.accessibility)) {\n                closedCaption = true;\n            }\n            if (type === \"audio\" &&\n                adaptationChildren.accessibility &&\n                helpers_1.isVisuallyImpaired(adaptationChildren.accessibility)) {\n                audioDescription = true;\n            }\n            var adaptationID;\n            if (adaptation.attributes.id != null) {\n                adaptationID = adaptation.attributes.id;\n            }\n            else {\n                var idString = type;\n                if (adaptation.attributes.language) {\n                    idString += \"-\" + adaptation.attributes.language;\n                }\n                if (closedCaption) {\n                    idString += \"-cc\";\n                }\n                if (audioDescription) {\n                    idString += \"-ad\";\n                }\n                if (adaptation.attributes.contentType) {\n                    idString += \"-\" + adaptation.attributes.contentType;\n                }\n                if (adaptation.attributes.codecs) {\n                    idString += \"-\" + adaptation.attributes.codecs;\n                }\n                if (adaptation.attributes.mimeType) {\n                    idString += \"-\" + adaptation.attributes.mimeType;\n                }\n                if (adaptation.attributes.frameRate) {\n                    idString += \"-\" + adaptation.attributes.frameRate;\n                }\n                if (idString.length === type.length) {\n                    idString += representations.length ?\n                        (\"-\" + representations[0].id) : \"-empty\";\n                }\n                adaptationID = \"adaptation-\" + idString;\n            }\n            var parsedAdaptationSet = {\n                id: adaptationID,\n                representations: representations,\n                type: type,\n            };\n            if (adaptation.attributes.language != null) {\n                parsedAdaptationSet.language = adaptation.attributes.language;\n                parsedAdaptationSet.normalizedLanguage =\n                    languages_1.normalize(adaptation.attributes.language);\n            }\n            if (closedCaption != null) {\n                parsedAdaptationSet.closedCaption = closedCaption;\n            }\n            if (audioDescription != null) {\n                parsedAdaptationSet.audioDescription = audioDescription;\n            }\n            return parsedAdaptationSet;\n        });\n        var parsedPeriod = {\n            id: periodID,\n            start: periodStart,\n            duration: periodDuration,\n            adaptations: adaptations,\n        };\n        if (period.attributes.bitstreamSwitching != null) {\n            parsedPeriod.bitstreamSwitching = period.attributes.bitstreamSwitching;\n        }\n        parsedPeriods.push(parsedPeriod);\n    };\n    for (var i = 0; i < rootChildren.periods.length; i++) {\n        _loop_1(i);\n    }\n    var parsedMPD = {\n        availabilityStartTime: (rootAttributes.type === \"static\" ||\n            rootAttributes.availabilityStartTime == null) ? 0 : rootAttributes.availabilityStartTime,\n        duration: rootAttributes.duration == null ? Infinity : rootAttributes.duration,\n        id: rootAttributes.id != null ?\n            rootAttributes.id : \"gen-dash-manifest-\" + id_1.default(),\n        periods: parsedPeriods,\n        transportType: \"dash\",\n        type: rootAttributes.type || \"static\",\n        uris: [uri].concat(rootChildren.locations),\n        suggestedPresentationDelay: rootAttributes.suggestedPresentationDelay != null ?\n            rootAttributes.suggestedPresentationDelay :\n            config_1.default.DEFAULT_SUGGESTED_PRESENTATION_DELAY.DASH,\n    };\n    // -- add optional fields --\n    if (rootAttributes.profiles != null) {\n        parsedMPD.profiles = rootAttributes.profiles;\n    }\n    if (rootAttributes.type !== \"static\" && rootAttributes.availabilityEndTime != null) {\n        parsedMPD.availabilityEndTime = rootAttributes.availabilityEndTime;\n    }\n    if (rootAttributes.publishTime != null) {\n        parsedMPD.publishTime = rootAttributes.publishTime;\n    }\n    if (rootAttributes.duration != null) {\n        parsedMPD.duration = rootAttributes.duration;\n    }\n    if (rootAttributes.minimumUpdatePeriod != null) {\n        parsedMPD.minimumUpdatePeriod = rootAttributes.minimumUpdatePeriod;\n    }\n    if (rootAttributes.minBufferTime != null) {\n        parsedMPD.minBufferTime = rootAttributes.minBufferTime;\n    }\n    if (rootAttributes.timeShiftBufferDepth != null) {\n        parsedMPD.timeShiftBufferDepth = rootAttributes.timeShiftBufferDepth;\n    }\n    if (rootAttributes.maxSegmentDuration != null) {\n        parsedMPD.maxSegmentDuration = rootAttributes.maxSegmentDuration;\n    }\n    if (rootAttributes.maxSubsegmentDuration != null) {\n        parsedMPD.maxSubsegmentDuration = rootAttributes.maxSubsegmentDuration;\n    }\n    if (parsedMPD.type === \"dynamic\") {\n        var lastPeriodAdaptations = parsedMPD.periods[parsedMPD.periods.length - 1].adaptations;\n        var firstVideoAdaptationFromLastPeriod = lastPeriodAdaptations\n            .filter(function (a) { return a.type === \"video\"; })[0];\n        var lastRef = getLastLiveTimeReference(firstVideoAdaptationFromLastPeriod);\n        parsedMPD.presentationLiveGap = lastRef != null ?\n            Date.now() / 1000 - (lastRef + parsedMPD.availabilityStartTime) : 10;\n    }\n    return parsedMPD;\n}\nexports.default = parseManifest;\n\n\n//# sourceURL=webpack://RxPlayer/./src/net/dash/manifest/node_parsers/index.ts?");

/***/ }),

/***/ "./src/net/dash/segment_loader.ts":
/*!****************************************!*\
  !*** ./src/net/dash/segment_loader.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Observable_1 = __webpack_require__(/*! rxjs/Observable */ \"./node_modules/rxjs/Observable.js\");\nvar url_1 = __webpack_require__(/*! ../../utils/url */ \"./src/utils/url.ts\");\nvar request_1 = __webpack_require__(/*! ../../utils/request */ \"./src/utils/request/index.ts\");\nvar utils_1 = __webpack_require__(/*! ./utils */ \"./src/net/dash/utils.ts\");\n/**\n * Segment loader triggered if there was no custom-defined one in the API.\n * @param {Object} opt\n * @param {string} opt.url\n * @param {Segment} opt.segment\n * @returns {Observable}\n */\nfunction regularSegmentLoader(_a) {\n    var url = _a.url, segment = _a.segment;\n    var range = segment.range, indexRange = segment.indexRange;\n    // fire a single time contiguous init and index ranges.\n    if (range && indexRange &&\n        range[1] === indexRange[0] - 1) {\n        return request_1.default({\n            url: url,\n            responseType: \"arraybuffer\",\n            headers: {\n                Range: utils_1.byteRange([range[0], indexRange[1]]),\n            },\n        });\n    }\n    var mediaHeaders = range ?\n        { Range: utils_1.byteRange(range) } : null;\n    var mediaOrInitRequest = request_1.default({\n        url: url,\n        responseType: \"arraybuffer\",\n        headers: mediaHeaders,\n    });\n    // If init segment has indexRange metadata, we need to fetch\n    // both the initialization data and the index metadata. We do\n    // this in parallel and send the both blobs into the pipeline.\n    if (indexRange) {\n        var indexRequest = request_1.default({\n            url: url,\n            responseType: \"arraybuffer\",\n            headers: { Range: utils_1.byteRange(indexRange) },\n        });\n        return Observable_1.Observable.merge(mediaOrInitRequest, indexRequest);\n    }\n    else {\n        return mediaOrInitRequest;\n    }\n}\n/**\n * Generate a segment loader for the application\n * @param {Function} [customSegmentLoader]\n * @returns {Function}\n */\nvar segmentPreLoader = function (customSegmentLoader) { return function (_a) {\n    var adaptation = _a.adaptation, manifest = _a.manifest, period = _a.period, representation = _a.representation, segment = _a.segment;\n    var media = segment.media, range = segment.range, indexRange = segment.indexRange, isInit = segment.isInit;\n    // init segment without initialization media/range/indexRange:\n    // we do nothing on the network\n    if (isInit && !(media || range || indexRange)) {\n        return Observable_1.Observable.empty();\n    }\n    // construct url for the segment\n    var path = media ? utils_1.replaceTokens(media, segment, representation) : \"\";\n    var url = url_1.resolveURL(representation.baseURL, path);\n    var args = {\n        adaptation: adaptation,\n        manifest: manifest,\n        period: period,\n        representation: representation,\n        segment: segment,\n        transport: \"dash\",\n        url: url,\n    };\n    if (!customSegmentLoader) {\n        return regularSegmentLoader(args);\n    }\n    return Observable_1.Observable.create(function (obs) {\n        var hasFinished = false;\n        var hasFallbacked = false;\n        /**\n         * Callback triggered when the custom segment loader has a response.\n         * @param {Object} args\n         * @param {*} args.data - The segment data\n         * @param {Number} args.size - The segment size\n         * @param {Number} args.duration - The duration of the request, in ms\n         */\n        var resolve = function (_args) {\n            if (!hasFallbacked) {\n                hasFinished = true;\n                obs.next({\n                    type: \"response\",\n                    value: {\n                        responseData: _args.data,\n                        size: _args.size,\n                        duration: _args.duration,\n                    },\n                });\n                obs.complete();\n            }\n        };\n        /**\n         * Callback triggered when the custom segment loader fails\n         * @param {*} [err={}] - The corresponding error encountered\n         */\n        var reject = function (err) {\n            if (err === void 0) { err = {}; }\n            if (!hasFallbacked) {\n                hasFinished = true;\n                obs.error(err);\n            }\n        };\n        /**\n         * Callback triggered when the custom segment loader wants to fallback to\n         * the \"regular\" implementation\n         */\n        var fallback = function () {\n            hasFallbacked = true;\n            regularSegmentLoader(args).subscribe(obs);\n        };\n        var callbacks = { reject: reject, resolve: resolve, fallback: fallback };\n        var abort = customSegmentLoader(args, callbacks);\n        return function () {\n            if (!hasFinished && !hasFallbacked && typeof abort === \"function\") {\n                abort();\n            }\n        };\n    });\n}; };\nexports.default = segmentPreLoader;\n\n\n//# sourceURL=webpack://RxPlayer/./src/net/dash/segment_loader.ts?");

/***/ }),

/***/ "./src/net/dash/texttracks.ts":
/*!************************************!*\
  !*** ./src/net/dash/texttracks.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar objectAssign = __webpack_require__(/*! object-assign */ \"./node_modules/object-assign/index.js\");\nvar Observable_1 = __webpack_require__(/*! rxjs/Observable */ \"./node_modules/rxjs/Observable.js\");\nvar assert_1 = __webpack_require__(/*! ../../utils/assert */ \"./src/utils/assert.ts\");\nvar strings_1 = __webpack_require__(/*! ../../utils/strings */ \"./src/utils/strings.ts\");\nvar url_1 = __webpack_require__(/*! ../../utils/url */ \"./src/utils/url.ts\");\nvar isobmff_1 = __webpack_require__(/*! ../../parsers/containers/isobmff */ \"./src/parsers/containers/isobmff/index.ts\");\nvar request_1 = __webpack_require__(/*! ../../utils/request */ \"./src/utils/request/index.ts\");\nvar isobmff_timing_infos_1 = __webpack_require__(/*! ./isobmff_timing_infos */ \"./src/net/dash/isobmff_timing_infos.ts\");\nvar utils_1 = __webpack_require__(/*! ./utils */ \"./src/net/dash/utils.ts\");\n/**\n * Perform requests for \"text\" segments\n * @param {Object} infos\n * @returns {Observable.<Object>}\n */\nfunction TextTrackLoader(_a) {\n    var segment = _a.segment, representation = _a.representation;\n    var media = segment.media, range = segment.range, indexRange = segment.indexRange, isInit = segment.isInit;\n    // ArrayBuffer when in mp4 to parse isobmff manually, text otherwise\n    var responseType = utils_1.isMP4EmbeddedTrack(representation) ? \"arraybuffer\" : \"text\";\n    // init segment without initialization media/range/indexRange:\n    // we do nothing on the network\n    if (isInit && !(media || range || indexRange)) {\n        return Observable_1.Observable.of({\n            type: \"data\",\n            value: { responseData: null },\n        });\n    }\n    var path = media ? utils_1.replaceTokens(media, segment, representation) : \"\";\n    var mediaUrl = url_1.resolveURL(representation.baseURL, path);\n    // fire a single time for contiguous init and index ranges\n    if (range && indexRange && range[1] === indexRange[0] - 1) {\n        return request_1.default({\n            url: mediaUrl,\n            responseType: responseType,\n            headers: {\n                Range: utils_1.byteRange([range[0], indexRange[1]]),\n            },\n        });\n    }\n    var mediaRequest = request_1.default({\n        url: mediaUrl,\n        responseType: responseType,\n        headers: range ? {\n            Range: utils_1.byteRange(range),\n        } : null,\n    });\n    if (!indexRange) {\n        return mediaRequest;\n    }\n    // If init segment has indexRange metadata, we need to fetch\n    // both the initialization data and the index metadata. We do\n    // this in parallel and send the both blobs into the pipeline.\n    // TODO Find a solution for calling only one time the parser\n    var indexRequest = request_1.default({\n        url: mediaUrl,\n        responseType: responseType,\n        headers: {\n            Range: utils_1.byteRange(indexRange),\n        },\n    });\n    return Observable_1.Observable.merge(mediaRequest, indexRequest);\n}\nexports.loader = TextTrackLoader;\n/**\n * Parse TextTrack data.\n * @param {Object} infos\n * @returns {Observable.<Object>}\n */\nfunction TextTrackParser(_a) {\n    var response = _a.response, segment = _a.segment, adaptation = _a.adaptation, representation = _a.representation, init = _a.init;\n    var language = adaptation.language;\n    var isInit = segment.isInit, indexRange = segment.indexRange;\n    if (response.responseData == null) {\n        return Observable_1.Observable.of({\n            segmentData: null,\n            segmentInfos: segment.timescale > 0 ? {\n                duration: segment.isInit ? 0 : segment.duration,\n                time: segment.isInit ? -1 : segment.time,\n                timescale: segment.timescale,\n            } : null,\n        });\n    }\n    var responseData;\n    var nextSegments;\n    var segmentInfos;\n    var segmentData;\n    var isMP4 = utils_1.isMP4EmbeddedTrack(representation);\n    if (isMP4) {\n        assert_1.default(response.responseData instanceof ArrayBuffer);\n        responseData = new Uint8Array(response.responseData);\n        var sidxSegments = isobmff_1.parseSidx(responseData, indexRange ? indexRange[0] : 0);\n        if (sidxSegments) {\n            nextSegments = sidxSegments;\n        }\n        segmentInfos = isInit ?\n            { time: -1, duration: 0, timescale: segment.timescale } :\n            isobmff_timing_infos_1.default(segment, responseData, sidxSegments, init);\n    }\n    else { // if not MP4\n        assert_1.default(typeof response.responseData === \"string\");\n        responseData = response.responseData;\n        if (isInit) {\n            segmentInfos = { time: -1, duration: 0, timescale: segment.timescale };\n        }\n        else {\n            segmentInfos = {\n                time: segment.time || 0,\n                duration: segment.duration,\n                timescale: segment.timescale,\n            };\n        }\n    }\n    if (isInit) {\n        if (isMP4) {\n            var timescale = isobmff_1.getMDHDTimescale(responseData);\n            if (timescale > 0) {\n                segmentInfos = {\n                    time: -1,\n                    duration: 0,\n                    timescale: timescale,\n                };\n            }\n        }\n        segmentData = null;\n    }\n    else { // if not init\n        assert_1.default(segmentInfos != null);\n        var segmentDataBase = {\n            start: segmentInfos.time,\n            end: segmentInfos.time + (segmentInfos.duration || 0),\n            language: language,\n            timescale: segmentInfos.timescale,\n            timeOffset: 0,\n        };\n        if (isMP4) {\n            var _b = representation.codec, codec = _b === void 0 ? \"\" : _b;\n            var type = void 0;\n            switch (codec.toLowerCase()) {\n                case \"stpp\": // stpp === TTML in MP4\n                    type = \"ttml\";\n                    break;\n                case \"wvtt\": // wvtt === WebVTT in MP4\n                    type = \"vtt\";\n            }\n            if (!type) {\n                throw new Error(\"The codec used for the subtitle is not managed yet.\");\n            }\n            segmentData = objectAssign({\n                data: strings_1.stringFromUTF8(isobmff_1.getMDAT(responseData)),\n                type: type,\n            }, { timescale: 1 }, segmentDataBase);\n        }\n        else { // not MP4: check for plain text subtitles\n            var type = void 0;\n            var _c = representation.mimeType, mimeType = _c === void 0 ? \"\" : _c;\n            switch (representation.mimeType) {\n                case \"application/ttml+xml\":\n                    type = \"ttml\";\n                    break;\n                case \"application/x-sami\":\n                case \"application/smil\":\n                    type = \"sami\";\n                    break;\n                case \"text/vtt\":\n                    type = \"vtt\";\n            }\n            if (!type) {\n                var _d = representation.codec, codec = _d === void 0 ? \"\" : _d;\n                var codeLC = codec.toLowerCase();\n                if (codeLC === \"srt\") {\n                    type = \"srt\";\n                }\n                else {\n                    throw new Error(\"could not find a text-track parser for the type \" + mimeType);\n                }\n            }\n            segmentData = objectAssign({\n                data: responseData,\n                type: type,\n            }, { timescale: 1 }, segmentDataBase);\n        }\n    }\n    if (nextSegments) {\n        utils_1.addNextSegments(representation, nextSegments, segmentInfos);\n    }\n    return Observable_1.Observable.of({ segmentData: segmentData, segmentInfos: segmentInfos });\n}\nexports.parser = TextTrackParser;\n\n\n//# sourceURL=webpack://RxPlayer/./src/net/dash/texttracks.ts?");

/***/ }),

/***/ "./src/net/dash/utils.ts":
/*!*******************************!*\
  !*** ./src/net/dash/utils.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @param {Object} adaptation\n * @param {Object} dlSegment\n * @param {Object} nextSegments\n */\nfunction addNextSegments(representation, nextSegments, currentSegment) {\n    representation.index._addSegments(nextSegments, currentSegment);\n}\nexports.addNextSegments = addNextSegments;\n/**\n * Pad with 0 in the left of the given n argument to reach l length\n * @param {Number|string} n\n * @param {Number} l\n * @returns {string}\n */\nfunction pad(n, l) {\n    var nToString = n.toString();\n    if (nToString.length >= l) {\n        return nToString;\n    }\n    var arr = new Array(l + 1).join(\"0\") + nToString;\n    return arr.slice(-l);\n}\nexports.pad = pad;\n/**\n * Add formatting when asked in a token (add padding to numbers).\n * @param {string|Number} replacer - the token value\n * @returns {Function} - @see replaceTokens\n */\nfunction processFormatedToken(replacer) {\n    return function (_match, _format, widthStr) {\n        var width = widthStr ? parseInt(widthStr, 10) : 1;\n        return pad(\"\" + replacer, width);\n    };\n}\nexports.processFormatedToken = processFormatedToken;\n/**\n * Replace \"tokens\" written in a given path (e.g. $Time$) by the corresponding\n * infos, taken from the given segment.\n * @param {string} path\n * @param {Object} segment\n * @param {Representation} representation\n * @returns {string}\n *\n * @throws Error - Throws if we do not have enough data to construct the URL\n */\nfunction replaceTokens(path, segment, representation) {\n    if (path.indexOf(\"$\") === -1) {\n        return path;\n    }\n    else {\n        return path\n            .replace(/\\$\\$/g, \"$\")\n            .replace(/\\$RepresentationID\\$/g, String(representation.id))\n            .replace(/\\$Bandwidth(|\\%0(\\d+)d)\\$/g, processFormatedToken(representation.bitrate))\n            .replace(/\\$Number(|\\%0(\\d+)d)\\$/g, function (_x, _y, widthStr) {\n            if (segment.number == null) {\n                throw new Error(\"Segment number not defined in a $Number$ scheme\");\n            }\n            return processFormatedToken(segment.number)(_x, _y, widthStr);\n        })\n            .replace(/\\$Time(|\\%0(\\d+)d)\\$/g, function (_x, _y, widthStr) {\n            if (segment.time == null) {\n                throw new Error(\"Segment time not defined in a $Time$ scheme\");\n            }\n            return processFormatedToken(segment.time)(_x, _y, widthStr);\n        });\n    }\n}\nexports.replaceTokens = replaceTokens;\n/**\n * Returns true if the given texttrack segment represents a textrack embedded\n * in a mp4 file.\n * @param {Representation} representation\n * @returns {Boolean}\n */\nfunction isMP4EmbeddedTrack(representation) {\n    return representation.mimeType === \"application/mp4\";\n}\nexports.isMP4EmbeddedTrack = isMP4EmbeddedTrack;\n/**\n * Returns text-formatted byteRange (`bytes=$start-$end?)`\n * @param {Array.<string|Number>}\n * @returns {string}\n */\nfunction byteRange(_a) {\n    var start = _a[0], end = _a[1];\n    if (!end || end === Infinity) {\n        return \"bytes=\" + (+start) + \"-\";\n    }\n    else {\n        return \"bytes=\" + (+start) + \"-\" + (+end);\n    }\n}\nexports.byteRange = byteRange;\n\n\n//# sourceURL=webpack://RxPlayer/./src/net/dash/utils.ts?");

/***/ }),

/***/ "./src/net/index.ts":
/*!**************************!*\
  !*** ./src/net/index.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar exported = {};\n/* tslint:disable no-var-requires */\nif (true) {\n    exported.smooth = __webpack_require__(/*! ./smooth/index.ts */ \"./src/net/smooth/index.ts\").default;\n}\nif (true) {\n    exported.dash = __webpack_require__(/*! ./dash/index.ts */ \"./src/net/dash/index.ts\").default;\n}\nexports.default = exported;\n\n\n//# sourceURL=webpack://RxPlayer/./src/net/index.ts?");

/***/ }),

/***/ "./src/net/smooth/index.ts":
/*!*********************************!*\
  !*** ./src/net/smooth/index.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Observable_1 = __webpack_require__(/*! rxjs/Observable */ \"./node_modules/rxjs/Observable.js\");\nvar bif_1 = __webpack_require__(/*! ../../parsers/images/bif */ \"./src/parsers/images/bif.ts\");\nvar assert_1 = __webpack_require__(/*! ../../utils/assert */ \"./src/utils/assert.ts\");\nvar request_1 = __webpack_require__(/*! ../../utils/request */ \"./src/utils/request/index.ts\");\nvar strings_1 = __webpack_require__(/*! ../../utils/strings */ \"./src/utils/strings.ts\");\nvar url_1 = __webpack_require__(/*! ../../utils/url */ \"./src/utils/url.ts\");\nvar manifest_loader_1 = __webpack_require__(/*! ../utils/manifest_loader */ \"./src/net/utils/manifest_loader.ts\");\nvar isobmff_timings_infos_1 = __webpack_require__(/*! ./isobmff_timings_infos */ \"./src/net/smooth/isobmff_timings_infos.ts\");\nvar manifest_1 = __webpack_require__(/*! ./manifest */ \"./src/net/smooth/manifest/index.ts\");\nvar mp4_1 = __webpack_require__(/*! ./mp4 */ \"./src/net/smooth/mp4.ts\");\nvar segment_loader_1 = __webpack_require__(/*! ./segment_loader */ \"./src/net/smooth/segment_loader.ts\");\nvar utils_1 = __webpack_require__(/*! ./utils */ \"./src/net/smooth/utils.ts\");\nvar patchSegment = mp4_1.default.patchSegment, getMdat = mp4_1.default.getMdat;\nvar WSX_REG = /\\.wsx?(\\?token=\\S+)?/;\n/**\n * @param {Object} adaptation\n * @param {Object} dlSegment\n * @param {Object} nextSegments\n */\nfunction addNextSegments(adaptation, nextSegments, dlSegment) {\n    var representations = adaptation.representations;\n    for (var i = 0; i < representations.length; i++) {\n        var representation = representations[i];\n        representation.index._addSegments(nextSegments, dlSegment);\n    }\n}\nfunction default_1(options) {\n    if (options === void 0) { options = {}; }\n    var smoothManifestParser = manifest_1.default(options);\n    var segmentLoader = segment_loader_1.default(options.segmentLoader);\n    var manifestLoaderOptions = {\n        customManifestLoader: options.manifestLoader,\n        ignoreProgressEvents: true,\n    };\n    var manifestLoader = manifest_loader_1.default(manifestLoaderOptions);\n    var manifestPipeline = {\n        resolver: function (_a) {\n            var url = _a.url;\n            var resolving;\n            var token = utils_1.extractToken(url);\n            // TODO Remove WSX logic\n            if (WSX_REG.test(url)) {\n                resolving = request_1.default({\n                    url: utils_1.replaceToken(url, \"\"),\n                    responseType: \"document\",\n                    ignoreProgressEvents: true,\n                })\n                    .map(function (_a) {\n                    var value = _a.value;\n                    var extractedURL = utils_1.extractISML(value.responseData);\n                    if (!extractedURL) {\n                        throw new Error(\"Invalid ISML\");\n                    }\n                    return extractedURL;\n                });\n            }\n            else {\n                resolving = Observable_1.Observable.of(url);\n            }\n            return resolving\n                .map(function (_url) { return ({ url: utils_1.replaceToken(utils_1.resolveManifest(_url), token) }); });\n        },\n        loader: function (_a) {\n            var url = _a.url;\n            return manifestLoader(url);\n        },\n        parser: function (_a) {\n            var response = _a.response, url = _a.url;\n            var data = typeof response.responseData === \"string\" ?\n                new DOMParser().parseFromString(response.responseData, \"text/xml\") :\n                response.responseData;\n            var manifest = smoothManifestParser(data, url);\n            return Observable_1.Observable.of({\n                manifest: manifest,\n                url: response.url,\n            });\n        },\n    };\n    var segmentPipeline = {\n        loader: function (_a) {\n            var adaptation = _a.adaptation, init = _a.init, manifest = _a.manifest, period = _a.period, representation = _a.representation, segment = _a.segment;\n            return segmentLoader({\n                adaptation: adaptation,\n                init: init,\n                manifest: manifest,\n                period: period,\n                representation: representation,\n                segment: segment,\n            });\n        },\n        parser: function (_a) {\n            var segment = _a.segment, response = _a.response, adaptation = _a.adaptation, manifest = _a.manifest;\n            var responseData = response.responseData;\n            if (segment.isInit) {\n                // smooth init segments are crafted by hand. Their timescale is the one\n                // from the manifest.\n                var initSegmentInfos = {\n                    timescale: segment.timescale,\n                    time: -1,\n                    duration: 0,\n                };\n                return Observable_1.Observable.of({\n                    segmentData: responseData,\n                    segmentInfos: initSegmentInfos,\n                });\n            }\n            if (true) {\n                assert_1.default(responseData instanceof ArrayBuffer);\n            }\n            var responseBuffer = new Uint8Array(responseData);\n            var _b = isobmff_timings_infos_1.default(responseBuffer, segment, manifest.isLive), nextSegments = _b.nextSegments, segmentInfos = _b.segmentInfos;\n            var segmentData = patchSegment(responseBuffer, segmentInfos.time);\n            if (nextSegments) {\n                addNextSegments(adaptation, nextSegments, segmentInfos);\n            }\n            return Observable_1.Observable.of({ segmentData: segmentData, segmentInfos: segmentInfos });\n        },\n    };\n    var textTrackPipeline = {\n        loader: function (_a) {\n            var segment = _a.segment, representation = _a.representation;\n            if (segment.isInit) {\n                return Observable_1.Observable.of({\n                    type: \"data\",\n                    value: { responseData: null },\n                });\n            }\n            // ArrayBuffer when in mp4 to parse isobmff manually, text otherwise\n            var responseType = isMP4EmbeddedTrack(representation) ? \"arraybuffer\" : \"text\";\n            var base = url_1.resolveURL(representation.baseURL);\n            var url = utils_1.buildSegmentURL(base, representation, segment);\n            return request_1.default({ url: url, responseType: responseType });\n        },\n        parser: function (_a) {\n            var response = _a.response, segment = _a.segment, representation = _a.representation, adaptation = _a.adaptation, manifest = _a.manifest;\n            var language = adaptation.language;\n            var _b = representation.mimeType, mimeType = _b === void 0 ? \"\" : _b, _c = representation.codec, codec = _c === void 0 ? \"\" : _c;\n            if (true) {\n                if (segment.isInit) {\n                    assert_1.default(response.responseData === null);\n                }\n                else {\n                    assert_1.default(typeof response.responseData === \"string\" ||\n                        response.responseData instanceof ArrayBuffer);\n                }\n            }\n            var responseData = response.responseData;\n            if (responseData === null) {\n                return Observable_1.Observable.of({\n                    segmentData: null,\n                    segmentInfos: segment.timescale > 0 ? {\n                        duration: segment.isInit ? 0 : segment.duration,\n                        time: segment.isInit ? -1 : segment.time,\n                        timescale: segment.timescale,\n                    } : null,\n                });\n            }\n            var parsedResponse;\n            var nextSegments;\n            var segmentInfos = null;\n            var isMP4 = mimeType.indexOf(\"mp4\") >= 0;\n            // segmentData components\n            var _sdStart;\n            var _sdEnd;\n            var _sdTimescale;\n            var _sdData;\n            var _sdType;\n            if (isMP4) {\n                if (true) {\n                    assert_1.default(responseData instanceof ArrayBuffer);\n                }\n                parsedResponse = new Uint8Array(responseData);\n                var timings = isobmff_timings_infos_1.default(parsedResponse, segment, manifest.isLive);\n                nextSegments = timings.nextSegments;\n                segmentInfos = timings.segmentInfos;\n                _sdStart = segmentInfos.time;\n                _sdEnd = segmentInfos.duration != null ?\n                    segmentInfos.time + segmentInfos.duration : undefined;\n                if (true) {\n                    assert_1.default(typeof segmentInfos.timescale === \"number\");\n                }\n                _sdTimescale = segmentInfos.timescale;\n            }\n            else {\n                if (true) {\n                    assert_1.default(typeof responseData === \"string\");\n                }\n                parsedResponse = responseData;\n                var segmentTime = segment.time || 0;\n                // vod is simple WebVTT or TTML text\n                _sdStart = segmentTime;\n                _sdEnd = segment.duration != null ?\n                    segmentTime + segment.duration : undefined;\n                _sdTimescale = segment.timescale;\n            }\n            if (isMP4) {\n                var lcCodec = codec.toLowerCase();\n                if (mimeType === \"application/ttml+xml+mp4\" || lcCodec === \"stpp\") {\n                    _sdType = \"ttml\";\n                }\n                else if (lcCodec === \"wvtt\") {\n                    _sdType = \"vtt\";\n                }\n                else {\n                    throw new Error(\"could not find a text-track parser for the type \" + mimeType);\n                }\n                var mdat = getMdat(parsedResponse);\n                _sdData = strings_1.stringFromUTF8(mdat);\n            }\n            else {\n                switch (mimeType) {\n                    case \"application/x-sami\":\n                    case \"application/smil\": // TODO SMIL should be its own format, no?\n                        _sdType = \"sami\";\n                        break;\n                    case \"application/ttml+xml\":\n                        _sdType = \"ttml\";\n                        break;\n                    case \"text/vtt\":\n                        _sdType = \"vtt\";\n                        break;\n                }\n                if (!_sdType) {\n                    var lcCodec = codec.toLowerCase();\n                    if (lcCodec === \"srt\") {\n                        _sdType = \"srt\";\n                    }\n                    else {\n                        throw new Error(\"could not find a text-track parser for the type \" + mimeType);\n                    }\n                }\n                _sdData = responseData;\n            }\n            if (segmentInfos != null && nextSegments) {\n                addNextSegments(adaptation, nextSegments, segmentInfos);\n            }\n            return Observable_1.Observable.of({\n                segmentData: {\n                    type: _sdType,\n                    data: _sdData,\n                    language: language,\n                    timescale: _sdTimescale,\n                    start: _sdStart,\n                    end: _sdEnd,\n                    timeOffset: _sdStart / _sdTimescale,\n                },\n                segmentInfos: segmentInfos,\n            });\n        },\n    };\n    var imageTrackPipeline = {\n        loader: function (_a) {\n            var segment = _a.segment, representation = _a.representation;\n            if (segment.isInit) {\n                // image do not need an init segment. Passthrough directly to the parser\n                return Observable_1.Observable.of({\n                    type: \"data\",\n                    value: { responseData: null },\n                });\n            }\n            var baseURL = url_1.resolveURL(representation.baseURL);\n            var url = utils_1.buildSegmentURL(baseURL, representation, segment);\n            return request_1.default({ url: url, responseType: \"arraybuffer\" });\n        },\n        parser: function (_a) {\n            var response = _a.response, segment = _a.segment;\n            var responseData = response.responseData;\n            if (responseData === null) {\n                return Observable_1.Observable.of({\n                    segmentData: null,\n                    segmentInfos: segment.timescale > 0 ? {\n                        duration: segment.isInit ? 0 : segment.duration,\n                        time: segment.isInit ? -1 : segment.time,\n                        timescale: segment.timescale,\n                    } : null,\n                });\n            }\n            var bifObject = bif_1.default(new Uint8Array(responseData));\n            var data = bifObject.thumbs;\n            return Observable_1.Observable.of({\n                segmentData: {\n                    data: data,\n                    start: 0,\n                    end: Number.MAX_VALUE,\n                    timescale: 1,\n                    timeOffset: 0,\n                    type: \"bif\",\n                },\n                segmentInfos: {\n                    time: 0,\n                    duration: Number.MAX_VALUE,\n                    timescale: bifObject.timescale,\n                },\n            });\n        },\n    };\n    return {\n        manifest: manifestPipeline,\n        audio: segmentPipeline,\n        video: segmentPipeline,\n        text: textTrackPipeline,\n        image: imageTrackPipeline,\n    };\n}\nexports.default = default_1;\n/**\n * Returns true if the given texttrack segment represents a textrack embedded\n * in a mp4 file.\n * @param {Representation} representation\n * @returns {Boolean}\n */\nfunction isMP4EmbeddedTrack(representation) {\n    return !!representation.mimeType && representation.mimeType.indexOf(\"mp4\") >= 0;\n}\n\n\n//# sourceURL=webpack://RxPlayer/./src/net/smooth/index.ts?");

/***/ }),

/***/ "./src/net/smooth/isobmff_timings_infos.ts":
/*!*************************************************!*\
  !*** ./src/net/smooth/isobmff_timings_infos.ts ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar log_1 = __webpack_require__(/*! ../../utils/log */ \"./src/utils/log.ts\");\nvar isobmff_1 = __webpack_require__(/*! ../../parsers/containers/isobmff */ \"./src/parsers/containers/isobmff/index.ts\");\nvar mp4_1 = __webpack_require__(/*! ./mp4 */ \"./src/net/smooth/mp4.ts\");\nvar getTraf = mp4_1.default.getTraf, parseTfrf = mp4_1.default.parseTfrf, parseTfxd = mp4_1.default.parseTfxd;\nfunction extractTimingsInfos(responseData, segment, isLive) {\n    var nextSegments = [];\n    var segmentInfos;\n    var tfxdSegment;\n    var tfrfSegments;\n    if (isLive) {\n        var traf = getTraf(responseData);\n        if (traf) {\n            tfrfSegments = parseTfrf(traf);\n            tfxdSegment = parseTfxd(traf);\n        }\n        else {\n            log_1.default.warn(\"smooth: could not find traf atom\");\n        }\n    }\n    if (!tfxdSegment) {\n        // we could always make a mistake when reading a container.\n        // If the estimate is too far from what the segment seems to imply, take\n        // the segment infos instead.\n        var maxDecodeTimeDelta = Math.min(segment.timescale * 0.9, segment.duration != null ? segment.duration / 4 : 0.25);\n        var trunDuration = isobmff_1.getDurationFromTrun(responseData);\n        if (trunDuration >= 0 && (segment.duration == null ||\n            Math.abs(trunDuration - segment.duration) <= maxDecodeTimeDelta)) {\n            segmentInfos = {\n                time: segment.time,\n                duration: trunDuration,\n                timescale: segment.timescale,\n            };\n        }\n        else {\n            segmentInfos = {\n                time: segment.time,\n                duration: segment.duration,\n                timescale: segment.timescale,\n            };\n        }\n    }\n    else {\n        segmentInfos = {\n            time: tfxdSegment.time,\n            duration: tfxdSegment.duration,\n            timescale: segment.timescale,\n        };\n    }\n    if (tfrfSegments) {\n        for (var i = 0; i < tfrfSegments.length; i++) {\n            nextSegments.push({\n                time: tfrfSegments[i].time,\n                duration: tfrfSegments[i].duration,\n                timescale: segment.timescale,\n            });\n        }\n    }\n    return { nextSegments: nextSegments, segmentInfos: segmentInfos };\n}\nexports.default = extractTimingsInfos;\n\n\n//# sourceURL=webpack://RxPlayer/./src/net/smooth/isobmff_timings_infos.ts?");

/***/ }),

/***/ "./src/net/smooth/manifest/index.ts":
/*!******************************************!*\
  !*** ./src/net/smooth/manifest/index.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar config_1 = __webpack_require__(/*! ../../../config */ \"./src/config.ts\");\nvar array_includes_1 = __webpack_require__(/*! ../../../utils/array-includes */ \"./src/utils/array-includes.ts\");\nvar assert_1 = __webpack_require__(/*! ../../../utils/assert */ \"./src/utils/assert.ts\");\nvar bytes_1 = __webpack_require__(/*! ../../../utils/bytes */ \"./src/utils/bytes.ts\");\nvar id_1 = __webpack_require__(/*! ../../../utils/id */ \"./src/utils/id.ts\");\nvar languages_1 = __webpack_require__(/*! ../../../utils/languages */ \"./src/utils/languages/index.ts\");\nvar log_1 = __webpack_require__(/*! ../../../utils/log */ \"./src/utils/log.ts\");\nvar url_1 = __webpack_require__(/*! ../../../utils/url */ \"./src/utils/url.ts\");\nvar representationIndex_1 = __webpack_require__(/*! ./representationIndex */ \"./src/net/smooth/manifest/representationIndex.ts\");\nvar DEFAULT_MIME_TYPES = {\n    audio: \"audio/mp4\",\n    video: \"video/mp4\",\n    text: \"application/ttml+xml\",\n};\nvar DEFAULT_CODECS = {\n    audio: \"mp4a.40.2\",\n    video: \"avc1.4D401E\",\n};\nvar MIME_TYPES = {\n    AACL: \"audio/mp4\",\n    AVC1: \"video/mp4\",\n    H264: \"video/mp4\",\n    TTML: \"application/ttml+xml+mp4\",\n};\n/**\n * @param {string} codecPrivateData\n * @returns {string}\n */\nfunction extractVideoCodecs(codecPrivateData) {\n    // we can extract codes only if fourCC is on of \"H264\", \"X264\", \"DAVC\", \"AVC1\"\n    var _a = /00000001\\d7([0-9a-fA-F]{6})/\n        .exec(codecPrivateData) || [], _b = _a[1], avcProfile = _b === void 0 ? \"\" : _b;\n    return avcProfile && \"avc1.\" + avcProfile;\n}\n/**\n * @param {string} fourCC\n * @param {string} codecPrivateData\n * @returns {string}\n */\nfunction extractAudioCodecs(fourCC, codecPrivateData) {\n    var mpProfile;\n    if (fourCC === \"AACH\") {\n        mpProfile = 5; // High Efficiency AAC Profile\n    }\n    else {\n        mpProfile = codecPrivateData ?\n            (parseInt(codecPrivateData.substr(0, 2), 16) & 0xF8) >> 3 : 2;\n    }\n    return mpProfile ? (\"mp4a.40.\" + mpProfile) : \"\";\n}\n/**\n * @param {*} parseBoolean\n * @returns {Boolean}\n */\nfunction parseBoolean(val) {\n    if (typeof val === \"boolean\") {\n        return val;\n    }\n    else if (typeof val === \"string\") {\n        return val.toUpperCase() === \"TRUE\";\n    }\n    else {\n        return false;\n    }\n}\n/**\n * @param {Uint8Array} keyIdBytes\n * @returns {Array.<Object>}\n */\nfunction getKeySystems(keyIdBytes) {\n    return [\n        {\n            // Widevine\n            systemId: \"edef8ba9-79d6-4ace-a3c8-27dcd51d21ed\",\n            privateData: bytes_1.concat([0x08, 0x01, 0x12, 0x10], keyIdBytes),\n        },\n    ];\n}\n/**\n * @param {Object} [parserOptions={}]\n */\nfunction createSmoothStreamingParser(parserOptions) {\n    if (parserOptions === void 0) { parserOptions = {}; }\n    var SUGGESTED_PERSENTATION_DELAY = parserOptions.suggestedPresentationDelay == null ?\n        config_1.default.DEFAULT_SUGGESTED_PRESENTATION_DELAY.SMOOTH :\n        parserOptions.suggestedPresentationDelay;\n    var REFERENCE_DATE_TIME = parserOptions.referenceDateTime ||\n        Date.UTC(1970, 0, 1, 0, 0, 0, 0) / 1000;\n    var MIN_REPRESENTATION_BITRATE = parserOptions.minRepresentationBitrate ||\n        190000;\n    var keySystems = parserOptions.keySystems || getKeySystems;\n    /**\n     * @param {Uint8Array} buf\n     * @returns {string}\n     */\n    function getHexKeyId(buf) {\n        var len = bytes_1.le2toi(buf, 8);\n        var xml = bytes_1.bytesToUTF16Str(buf.subarray(10, len + 10));\n        var doc = new DOMParser().parseFromString(xml, \"application/xml\");\n        var kidElement = doc.querySelector(\"KID\");\n        if (!kidElement) {\n            throw new Error(\"invalid XML\");\n        }\n        var kid = kidElement.textContent || \"\";\n        return bytes_1.guidToUuid(atob(kid)).toLowerCase();\n    }\n    /**\n     * Reduce implementation for the children of the given element.\n     * TODO better typings\n     * @param {Element} root\n     * @param {Function} fn\n     * @param {*} init\n     * @returns {*}\n     */\n    function reduceChildren(root, fn, init) {\n        var node = root.firstElementChild;\n        var r = init;\n        while (node) {\n            r = fn(r, node.nodeName, node);\n            node = node.nextElementSibling;\n        }\n        return r;\n    }\n    /**\n     * @param {Element} root\n     * @returns {Object}\n     */\n    function parseProtection(root) {\n        var header = root.firstElementChild;\n        assert_1.default(header.nodeName === \"ProtectionHeader\", \"Protection should have ProtectionHeader child\");\n        var privateData = bytes_1.strToBytes(atob(header.textContent || \"\"));\n        var keyId = getHexKeyId(privateData);\n        var keyIdBytes = bytes_1.hexToBytes(keyId);\n        // remove possible braces\n        var systemId = (header.getAttribute(\"SystemID\") || \"\").toLowerCase()\n            .replace(/\\{|\\}/g, \"\");\n        return {\n            keyId: keyId,\n            keySystems: [\n                {\n                    systemId: systemId,\n                    privateData: privateData,\n                },\n            ].concat(keySystems(keyIdBytes)),\n        };\n    }\n    /**\n     * @param {Element} node\n     * @param {Array.<Object>} timeline\n     * @returns {Array.<Object>}\n     */\n    function parseC(node, timeline) {\n        var len = timeline.length;\n        var prev = len > 0 ?\n            timeline[len - 1] : { d: 0, ts: 0, r: 0 };\n        var dAttr = node.getAttribute(\"d\");\n        var tAttr = node.getAttribute(\"t\");\n        var rAttr = node.getAttribute(\"r\");\n        // in smooth streaming format,\n        // r refers to number of same duration\n        // chunks, not repetitions (defers from DASH)\n        var r = rAttr ? +rAttr - 1 : 0;\n        var t = tAttr ? +tAttr : undefined;\n        var d = dAttr ? +dAttr : undefined;\n        if (len > 0 && !prev.d) {\n            if (true) {\n                assert_1.default(typeof t === \"number\");\n            }\n            prev.d = t != null ? t - prev.ts : 0;\n            timeline[len - 1] = prev; // TODO might not be needed\n        }\n        // if same segment than the last one, repeat the previous one\n        if (len > 0 && d === prev.d && t == null) {\n            prev.r += (r || 0) + 1;\n        }\n        else {\n            if (true) {\n                assert_1.default(t != null || prev.d != null);\n            }\n            var ts = (t == null)\n                ? prev.ts + (prev.d || 0) * (prev.r + 1)\n                : t;\n            timeline.push({ d: d, ts: ts, r: r });\n        }\n        return timeline;\n    }\n    /**\n     * @param {Element} q\n     * @param {string} type\n     * @return {Object}\n     */\n    function parseQualityLevel(q, type) {\n        /**\n         * @param {string} name\n         * @returns {string|undefined}\n         */\n        function getAttribute(name) {\n            var attr = q.getAttribute(name);\n            return attr == null ? undefined : attr;\n        }\n        switch (type) {\n            case \"audio\": {\n                var audiotag = getAttribute(\"AudioTag\");\n                var bitrate = getAttribute(\"Bitrate\");\n                var bitsPerSample = getAttribute(\"BitsPerSample\");\n                var channels = getAttribute(\"Channels\");\n                var codecPrivateData = getAttribute(\"CodecPrivateData\");\n                var fourCC = getAttribute(\"FourCC\");\n                var packetSize = getAttribute(\"PacketSize\");\n                var samplingRate = getAttribute(\"SamplingRate\");\n                return {\n                    audiotag: audiotag !== undefined ? parseInt(audiotag, 10) : audiotag,\n                    bitrate: bitrate ? parseInt(bitrate, 10) || 0 : 0,\n                    bitsPerSample: bitsPerSample !== undefined ?\n                        parseInt(bitsPerSample, 10) : bitsPerSample,\n                    channels: channels !== undefined ? parseInt(channels, 10) : channels,\n                    codecPrivateData: codecPrivateData || \"\",\n                    mimeType: fourCC !== undefined ? MIME_TYPES[fourCC] : fourCC,\n                    packetSize: packetSize !== undefined ?\n                        parseInt(packetSize, 10) : packetSize,\n                    samplingRate: samplingRate !== undefined ?\n                        parseInt(samplingRate, 10) : samplingRate,\n                };\n            }\n            case \"video\": {\n                var bitrate = getAttribute(\"Bitrate\");\n                var codecPrivateData = getAttribute(\"CodecPrivateData\");\n                var fourCC = getAttribute(\"FourCC\");\n                var width = getAttribute(\"MaxWidth\");\n                var height = getAttribute(\"MaxHeight\");\n                return {\n                    bitrate: bitrate ? parseInt(bitrate, 10) || 0 : 0,\n                    mimeType: fourCC !== undefined ? MIME_TYPES[fourCC] : fourCC,\n                    codecPrivateData: codecPrivateData || \"\",\n                    codecs: extractVideoCodecs(codecPrivateData || \"\"),\n                    width: width !== undefined ? parseInt(width, 10) : undefined,\n                    height: height !== undefined ? parseInt(height, 10) : undefined,\n                };\n            }\n            case \"text\": {\n                var bitrate = getAttribute(\"Bitrate\");\n                var codecPrivateData = getAttribute(\"CodecPrivateData\");\n                var fourCC = getAttribute(\"FourCC\");\n                return {\n                    bitrate: bitrate ? parseInt(bitrate, 10) || 0 : 0,\n                    mimeType: fourCC !== undefined ? MIME_TYPES[fourCC] : fourCC,\n                    codecPrivateData: codecPrivateData || \"\",\n                };\n            }\n            default:\n                throw new Error(\"Unrecognized StreamIndex type: \" + type);\n        }\n    }\n    /**\n     * Parse the adaptations (<StreamIndex>) tree containing\n     * representations (<QualityLevels>) and timestamp indexes (<c>).\n     * Indexes can be quite huge, and this function needs to\n     * to be optimized.\n     * @param {Element} root\n     * @param {string} rootURL\n     * @param {Number} timescale\n     * @returns {Object}\n     */\n    function parseAdaptation(root, rootURL, timescale, protection) {\n        var _timescale = root.hasAttribute(\"Timescale\") ?\n            +(root.getAttribute(\"Timescale\") || 0) : timescale;\n        var adaptationType = root.getAttribute(\"Type\");\n        if (adaptationType == null) {\n            throw new Error(\"StreamIndex without type.\");\n        }\n        var subType = root.getAttribute(\"Subtype\");\n        var name = root.getAttribute(\"Name\");\n        var language = root.getAttribute(\"Language\");\n        var normalizedLanguage = language == null ?\n            language : languages_1.normalize(language);\n        var baseURL = root.getAttribute(\"Url\") || \"\";\n        if (true) {\n            assert_1.default(baseURL !== \"\");\n        }\n        var _a = reduceChildren(root, function (res, _name, node) {\n            switch (_name) {\n                case \"QualityLevel\":\n                    var rep = parseQualityLevel(node, adaptationType);\n                    if (adaptationType === \"audio\") {\n                        var fourCC = node.getAttribute(\"FourCC\") || \"\";\n                        rep.codecs = extractAudioCodecs(fourCC, rep.codecPrivateData);\n                    }\n                    // filter out video representations with small bitrates\n                    if (adaptationType !== \"video\" || rep.bitrate > MIN_REPRESENTATION_BITRATE) {\n                        res.representations.push(rep);\n                    }\n                    break;\n                case \"c\":\n                    res.index.timeline = parseC(node, res.index.timeline);\n                    break;\n            }\n            return res;\n        }, {\n            representations: [],\n            index: {\n                timeline: [],\n                timescale: _timescale,\n                initialization: {},\n            },\n        }), representations = _a.representations, index = _a.index;\n        // we assume that all representations have the same\n        // codec and mimeType\n        assert_1.default(representations.length !== 0, \"adaptation should have at least one representation\");\n        var id = adaptationType + (language ? (\"_\" + language) : \"\");\n        // apply default properties\n        representations.forEach(function (representation) {\n            representation.baseURL = url_1.resolveURL(rootURL, baseURL);\n            representation.mimeType =\n                representation.mimeType || DEFAULT_MIME_TYPES[adaptationType];\n            representation.codecs = representation.codecs || DEFAULT_CODECS[adaptationType];\n            representation.id = id + \"_\" + adaptationType + \"-\" +\n                representation.mimeType + \"-\" +\n                representation.codecs + \"-\" + representation.bitrate;\n            var initSegmentInfos = {\n                bitsPerSample: representation.bitsPerSample,\n                channels: representation.channels,\n                codecPrivateData: representation.codecPrivateData,\n                packetSize: representation.packetSize,\n                samplingRate: representation.samplingRate,\n                protection: protection,\n            };\n            representation.index = new representationIndex_1.default(index, initSegmentInfos);\n        });\n        // TODO(pierre): real ad-insert support\n        if (subType === \"ADVT\") {\n            return null;\n        }\n        var parsedAdaptation = {\n            id: id,\n            type: adaptationType,\n            representations: representations,\n            name: name == null ? undefined : name,\n            language: language == null ?\n                undefined : language,\n            normalizedLanguage: normalizedLanguage == null ?\n                undefined : normalizedLanguage,\n        };\n        if (adaptationType === \"text\" && subType === \"DESC\") {\n            parsedAdaptation.closedCaption = true;\n        }\n        return parsedAdaptation;\n    }\n    function parseFromDocument(doc, url) {\n        var rootURL = url_1.normalizeBaseURL(url);\n        var root = doc.documentElement;\n        assert_1.default(root.nodeName === \"SmoothStreamingMedia\", \"document root should be SmoothStreamingMedia\");\n        assert_1.default(/^[2]-[0-2]$/\n            .test(root.getAttribute(\"MajorVersion\") + \"-\" + root.getAttribute(\"MinorVersion\")), \"Version should be 2.0, 2.1 or 2.2\");\n        var timescale = +(root.getAttribute(\"Timescale\") || 10000000);\n        var _a = reduceChildren(root, function (res, name, node) {\n            switch (name) {\n                case \"Protection\": {\n                    res.protection = parseProtection(node);\n                    break;\n                }\n                case \"StreamIndex\":\n                    res.adaptationNodes.push(node);\n                    break;\n            }\n            return res;\n        }, {\n            adaptationNodes: [],\n        }), protection = _a.protection, adaptationNodes = _a.adaptationNodes;\n        var adaptations = adaptationNodes.map(function (node) {\n            return parseAdaptation(node, rootURL, timescale, protection);\n        }).filter(function (adaptation) { return !!adaptation; });\n        var suggestedPresentationDelay;\n        var presentationLiveGap;\n        var timeShiftBufferDepth;\n        var availabilityStartTime;\n        var duration;\n        var firstVideoAdaptation = adaptations.filter(function (a) { return a.type === \"video\"; })[0];\n        var firstAudioAdaptation = adaptations.filter(function (a) { return a.type === \"audio\"; })[0];\n        var firstTimeReference;\n        var lastTimeReference;\n        if (firstVideoAdaptation || firstAudioAdaptation) {\n            var firstTimeReferences = [];\n            var lastTimeReferences = [];\n            if (firstVideoAdaptation) {\n                var firstVideoRepresentation = firstVideoAdaptation.representations[0];\n                if (firstVideoRepresentation) {\n                    var firstVideoTimeReference = firstVideoRepresentation.index.getFirstPosition();\n                    var lastVideoTimeReference = firstVideoRepresentation.index.getLastPosition();\n                    if (firstVideoTimeReference != null) {\n                        firstTimeReferences.push(firstVideoTimeReference);\n                    }\n                    if (lastVideoTimeReference != null) {\n                        lastTimeReferences.push(lastVideoTimeReference);\n                    }\n                }\n            }\n            if (firstAudioAdaptation) {\n                var firstAudioRepresentation = firstAudioAdaptation.representations[0];\n                if (firstAudioRepresentation) {\n                    var firstAudioTimeReference = firstAudioRepresentation.index.getFirstPosition();\n                    var lastAudioTimeReference = firstAudioRepresentation.index.getLastPosition();\n                    if (firstAudioTimeReference != null) {\n                        firstTimeReferences.push(firstAudioTimeReference);\n                    }\n                    if (lastAudioTimeReference != null) {\n                        lastTimeReferences.push(lastAudioTimeReference);\n                    }\n                }\n            }\n            if (firstTimeReferences.length) {\n                firstTimeReference = Math.max.apply(Math, firstTimeReferences);\n            }\n            if (lastTimeReferences.length) {\n                lastTimeReference = Math.max.apply(Math, lastTimeReferences);\n            }\n        }\n        var isLive = parseBoolean(root.getAttribute(\"IsLive\"));\n        if (isLive) {\n            suggestedPresentationDelay = SUGGESTED_PERSENTATION_DELAY;\n            timeShiftBufferDepth =\n                +(root.getAttribute(\"DVRWindowLength\") || 0) / timescale;\n            availabilityStartTime = REFERENCE_DATE_TIME;\n            presentationLiveGap = Date.now() / 1000 -\n                (lastTimeReference != null ?\n                    (lastTimeReference + availabilityStartTime) : 10);\n            var manifestDuration = root.getAttribute(\"Duration\");\n            duration = (manifestDuration != null && +manifestDuration !== 0) ?\n                (+manifestDuration / timescale) : Infinity;\n        }\n        else {\n            // if non-live and first time reference different than 0. Add first time reference\n            // to duration\n            var manifestDuration = root.getAttribute(\"Duration\");\n            if (manifestDuration != null && +manifestDuration !== 0) {\n                duration = lastTimeReference == null ?\n                    (+manifestDuration + (firstTimeReference || 0)) / timescale :\n                    lastTimeReference;\n            }\n            else {\n                duration = Infinity;\n            }\n        }\n        var minimumTime = firstTimeReference != null ?\n            firstTimeReference / timescale : undefined;\n        var manifest = {\n            id: \"gen-smooth-manifest-\" + id_1.default(),\n            availabilityStartTime: availabilityStartTime || 0,\n            duration: duration,\n            presentationLiveGap: presentationLiveGap,\n            suggestedPresentationDelay: suggestedPresentationDelay,\n            timeShiftBufferDepth: timeShiftBufferDepth,\n            transportType: \"smooth\",\n            type: isLive ? \"dynamic\" : \"static\",\n            uris: [url],\n            minimumTime: minimumTime,\n            periods: [{\n                    id: \"gen-smooth-period-0\",\n                    duration: duration,\n                    adaptations: adaptations,\n                    start: 0,\n                }],\n        };\n        checkManifestIDs(manifest);\n        return manifest;\n    }\n    return parseFromDocument;\n}\n/**\n * Ensure that no two adaptations have the same ID and that no two\n * representations from a same adaptation neither.\n *\n * Log and mutate their ID if not until this is verified.\n *\n * @param {Object} manifest\n */\nfunction checkManifestIDs(manifest) {\n    manifest.periods.forEach(function (_a) {\n        var adaptations = _a.adaptations;\n        var adaptationIDs = [];\n        adaptations.forEach(function (adaptation) {\n            var adaptationID = adaptation.id;\n            if (array_includes_1.default(adaptationIDs, adaptationID)) {\n                log_1.default.warn(\"Smooth: Two adaptations with the same ID found. Updating.\", adaptationID);\n                var newID = adaptationID + \"-\";\n                adaptation.id = newID;\n                checkManifestIDs(manifest);\n                adaptationIDs.push(newID);\n            }\n            else {\n                adaptationIDs.push(adaptationID);\n            }\n            var representationIDs = [];\n            adaptation.representations.forEach(function (representation) {\n                var representationID = representation.id;\n                if (array_includes_1.default(representationIDs, representationID)) {\n                    log_1.default.warn(\"Smooth: Two representations with the same ID found. Updating.\", representationID);\n                    var newID = representationID + \"-\";\n                    representation.id = newID;\n                    checkManifestIDs(manifest);\n                    representationIDs.push(newID);\n                }\n                else {\n                    representationIDs.push(representationID);\n                }\n            });\n        });\n    });\n}\nexports.default = createSmoothStreamingParser;\n\n\n//# sourceURL=webpack://RxPlayer/./src/net/smooth/manifest/index.ts?");

/***/ }),

/***/ "./src/net/smooth/manifest/representationIndex.ts":
/*!********************************************************!*\
  !*** ./src/net/smooth/manifest/representationIndex.ts ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Add a new segment to the index.\n *\n * /!\\ Mutate the given index\n * @param {Object} index\n * @param {Object} newSegment\n * @param {Number} newSegment.timescale\n * @param {Number} newSegment.time\n * @param {Number} newSegment.duration\n * @param {Object} currentSegment\n * @param {Number} currentSegment.timescale\n * @param {Number} currentSegment.time\n * @returns {Boolean} - true if the segment has been added\n */\nfunction _addSegmentInfos(index, newSegment, currentSegment) {\n    var timeline = index.timeline, timescale = index.timescale;\n    var timelineLength = timeline.length;\n    var last = timeline[timelineLength - 1];\n    var scaledNewSegment = newSegment.timescale === timescale ? {\n        time: newSegment.time,\n        duration: newSegment.duration,\n    } : {\n        time: (newSegment.time / newSegment.timescale) * timescale,\n        duration: (newSegment.duration / newSegment.timescale) * timescale,\n    };\n    var scaledCurrentTime;\n    if (currentSegment && currentSegment.timescale) {\n        scaledCurrentTime = currentSegment.timescale === timescale ?\n            currentSegment.time :\n            (currentSegment.time / currentSegment.timescale) * timescale;\n    }\n    // in some circumstances, the new segment informations are only\n    // duration informations that we can use to deduct the ts of the\n    // next segment. this is the case where the new segment are\n    // associated to a current segment and have the same ts\n    var shouldDeductNextSegment = scaledCurrentTime != null &&\n        (scaledNewSegment.time === scaledCurrentTime);\n    if (shouldDeductNextSegment) {\n        var newSegmentTs = scaledNewSegment.time + scaledNewSegment.duration;\n        var lastSegmentTs = (last.ts + (last.d || 0) * last.r);\n        var tsDiff = newSegmentTs - lastSegmentTs;\n        if (tsDiff <= 0) { // same segment / behind the last\n            return false;\n        }\n        // try to use the compact notation with @r attribute on the last\n        // to elements of the timeline if we find out they have the same\n        // duration\n        if (last.d === -1) {\n            var prev = timeline[timelineLength - 2];\n            if (prev && prev.d === tsDiff) {\n                prev.r++;\n                timeline.pop();\n            }\n            else {\n                last.d = tsDiff;\n            }\n        }\n        index.timeline.push({\n            d: -1,\n            ts: newSegmentTs,\n            r: 0,\n        });\n        return true;\n    }\n    // if the given timing has a timestamp after the timeline end we\n    // just need to push a new element in the timeline, or increase\n    // the @r attribute of the last element.\n    else if (scaledNewSegment.time >= getTimelineRangeEnd(last)) {\n        if (last.d === scaledNewSegment.duration) {\n            last.r++;\n        }\n        else {\n            index.timeline.push({\n                d: scaledNewSegment.duration,\n                ts: scaledNewSegment.time,\n                r: 0,\n            });\n        }\n        return true;\n    }\n    return false;\n}\n/**\n * Get index of the segment containing the given timescaled timestamp.\n * @param {Object} index\n * @param {Number} ts\n * @returns {Number}\n */\nfunction getSegmentIndex(index, ts) {\n    var timeline = index.timeline;\n    var low = 0;\n    var high = timeline.length;\n    while (low < high) {\n        var mid = (low + high) >>> 1;\n        if (timeline[mid].ts < ts) {\n            low = mid + 1;\n        }\n        else {\n            high = mid;\n        }\n    }\n    return (low > 0)\n        ? low - 1\n        : low;\n}\n/**\n * @param {Number} ts\n * @param {Number} up\n * @param {Number} duration\n * @returns {Number}\n */\nfunction getSegmentNumber(ts, up, duration) {\n    if (!duration) {\n        return 0;\n    }\n    var diff = up - ts;\n    if (diff > 0) {\n        return Math.floor(diff / duration);\n    }\n    else {\n        return 0;\n    }\n}\n/**\n * Get end of the given index range, timescaled.\n * @param {Object} range\n * @param {Number} range.ts - the range's start time\n * @param {Number} range.d - the range's duration\n * @param {Number} range.r - the range's count. 0 for a single element, 1 for\n * 2 elements etc.\n * @returns {Number} - absolute end time of the range\n */\nfunction getTimelineRangeEnd(_a) {\n    var ts = _a.ts, d = _a.d, r = _a.r;\n    return (d == null || d === -1) ? ts : ts + (r + 1) * d;\n}\n// interface ISmoothIndex {\n//   presentationTimeOffset? : number;\n//   timescale : number;\n//   media? : string;\n//   timeline : IIndexSegment[];\n//   startNumber? : number;\n// }\n/**\n * Convert second-based start time and duration to the timescale of the\n * manifest's index.\n * @param {Object} index\n * @param {Number} ts\n * @param {Number} duration\n * @returns {Object} - Object with two properties:\n *   - up {Number}: timescaled timestamp of the beginning time\n *   - to {Number}: timescaled timestamp of the end time (start time + duration)\n */\nfunction normalizeRange(index, // TODO\nts, duration) {\n    var pto = index.presentationTimeOffset || 0;\n    var timescale = index.timescale || 1;\n    return {\n        up: (ts) * timescale - pto,\n        to: (ts + duration) * timescale - pto,\n    };\n}\n/**\n * Calculate the number of times a segment repeat based on the next segment.\n * @param {Object} segment\n * @param {Number} segment.ts - beginning timescaled timestamp\n * @param {Number} segment.d - timescaled duration of the segment\n * @param {Object} nextSegment\n * @param {Number} nextSegment.ts\n * @returns {Number}\n */\nfunction calculateRepeat(segment, nextSegment) {\n    var repeatCount = segment.r || 0;\n    // A negative value of the @r attribute of the S element indicates\n    // that the duration indicated in @d attribute repeats until the\n    // start of the next S element, the end of the Period or until the\n    // next MPD update.\n    // TODO Also for SMOOTH????\n    if (segment.d != null && repeatCount < 0) {\n        var repeatEnd = nextSegment ? nextSegment.ts : Infinity;\n        repeatCount = Math.ceil((repeatEnd - segment.ts) / segment.d) - 1;\n    }\n    return repeatCount;\n}\n/**\n * RepresentationIndex implementation for Smooth Manifests.\n *\n * Allows to interact with the index to create new Segments.\n *\n * @class SmoothRepresentationIndex\n */\nvar SmoothRepresentationIndex = /** @class */ (function () {\n    // private _index : {\n    //   timeline : IHSSManifestSegment[];\n    //   timescale : number;\n    // }; // TODO\n    function SmoothRepresentationIndex(index, infos) {\n        this._index = index;\n        this._bitsPerSample = infos.bitsPerSample;\n        this._channels = infos.channels;\n        this._codecPrivateData = infos.codecPrivateData;\n        this._packetSize = infos.packetSize;\n        this._samplingRate = infos.samplingRate;\n        this._protection = infos.protection;\n    }\n    /**\n     * Construct init Segment compatible with a Smooth Manifest.\n     * @returns {Object}\n     */\n    SmoothRepresentationIndex.prototype.getInitSegment = function () {\n        var index = this._index;\n        return {\n            id: \"init\",\n            isInit: true,\n            time: 0,\n            timescale: index.timescale,\n            privateInfos: {\n                type: \"smooth-init\",\n                bitsPerSample: this._bitsPerSample,\n                channels: this._channels,\n                codecPrivateData: this._codecPrivateData,\n                packetSize: this._packetSize,\n                samplingRate: this._samplingRate,\n                protection: this._protection,\n            },\n        };\n    };\n    /**\n     * Generate a list of Segments for a particular period of time.\n     *\n     * @param {Number} _up\n     * @param {Number} _to\n     * @returns {Array.<Object>}\n     */\n    SmoothRepresentationIndex.prototype.getSegments = function (_up, _to) {\n        var index = this._index;\n        var _a = normalizeRange(index, _up, _to), up = _a.up, to = _a.to;\n        var timeline = index.timeline, timescale = index.timescale;\n        var currentNumber;\n        var segments = [];\n        var timelineLength = timeline.length;\n        // TODO(pierre): use @maxSegmentDuration if possible\n        var maxEncounteredDuration = (timeline.length && timeline[0].d) || 0;\n        for (var i = 0; i < timelineLength; i++) {\n            var segmentRange = timeline[i];\n            var d = segmentRange.d, ts = segmentRange.ts;\n            maxEncounteredDuration = Math.max(maxEncounteredDuration, d || 0);\n            // live-added segments have @d attribute equals to -1\n            if (d != null && d < 0) {\n                // TODO what? May be to play it safe and avoid adding segments which are\n                // not completely generated\n                if (ts + maxEncounteredDuration < to) {\n                    var segment = {\n                        id: \"\" + ts,\n                        time: ts,\n                        isInit: false,\n                        timescale: timescale,\n                        number: currentNumber != null ? currentNumber : undefined,\n                    };\n                    segments.push(segment);\n                }\n                return segments;\n            }\n            var repeat = calculateRepeat(segmentRange, timeline[i + 1]);\n            var segmentNumberInCurrentRange = getSegmentNumber(ts, up, d);\n            var segmentTime = ts + segmentNumberInCurrentRange * (d == null ? 0 : d);\n            while (segmentTime < to && segmentNumberInCurrentRange <= repeat) {\n                var segment = {\n                    id: \"\" + segmentTime,\n                    time: segmentTime,\n                    isInit: false,\n                    duration: d,\n                    timescale: timescale,\n                    number: currentNumber != null ?\n                        currentNumber + segmentNumberInCurrentRange : undefined,\n                };\n                segments.push(segment);\n                // update segment number and segment time for the next segment\n                segmentNumberInCurrentRange++;\n                segmentTime = ts + segmentNumberInCurrentRange * d;\n            }\n            if (segmentTime >= to) {\n                // we reached ``to``, we're done\n                return segments;\n            }\n            if (currentNumber != null) {\n                currentNumber += repeat + 1;\n            }\n        }\n        return segments;\n    };\n    /**\n     * Returns true if, based on the arguments, the index should be refreshed.\n     * (If we should re-fetch the manifest)\n     * @param {Number} from\n     * @param {Number} to\n     * @returns {Boolean}\n     */\n    SmoothRepresentationIndex.prototype.shouldRefresh = function (up, to) {\n        var _a = this._index, timeline = _a.timeline, timescale = _a.timescale;\n        var lastSegmentInCurrentTimeline = timeline[timeline.length - 1];\n        if (!lastSegmentInCurrentTimeline) {\n            return false;\n        }\n        var repeat = lastSegmentInCurrentTimeline.r || 0;\n        var endOfLastSegmentInCurrentTimeline = lastSegmentInCurrentTimeline.ts + (repeat + 1) * lastSegmentInCurrentTimeline.d;\n        if (to * timescale < endOfLastSegmentInCurrentTimeline) {\n            return false;\n        }\n        if (up * timescale >= endOfLastSegmentInCurrentTimeline) {\n            return true;\n        }\n        // ----\n        var startOfLastSegmentInCurrentTimeline = lastSegmentInCurrentTimeline.ts + repeat * lastSegmentInCurrentTimeline.d;\n        return up > startOfLastSegmentInCurrentTimeline;\n    };\n    /**\n     * Returns first position in the index.\n     *\n     * @param {Object} index\n     * @returns {Number}\n     */\n    SmoothRepresentationIndex.prototype.getFirstPosition = function () {\n        var index = this._index;\n        if (!index.timeline.length) {\n            return undefined;\n        }\n        return index.timeline[0].ts / index.timescale;\n    };\n    /**\n     * Returns last position in the index.\n     * @param {Object} index\n     * @returns {Number}\n     */\n    SmoothRepresentationIndex.prototype.getLastPosition = function () {\n        var index = this._index;\n        if (!index.timeline.length) {\n            return undefined;\n        }\n        var lastTimelineElement = index.timeline[index.timeline.length - 1];\n        return (getTimelineRangeEnd(lastTimelineElement) / index.timescale);\n    };\n    /**\n     * Checks if the time given is in a discontinuity. That is:\n     *   - We're on the upper bound of the current range (end of the range - time\n     *     is inferior to the timescale)\n     *   - The next range starts after the end of the current range.\n     *\n     * @param {Number} _time\n     * @returns {Number} - If a discontinuity is present, this is the Starting ts\n     * for the next (discontinuited) range. If not this is equal to -1.\n     */\n    SmoothRepresentationIndex.prototype.checkDiscontinuity = function (_time) {\n        var index = this._index;\n        var timeline = index.timeline, _a = index.timescale, timescale = _a === void 0 ? 1 : _a;\n        var time = _time * timescale;\n        if (time <= 0) {\n            return -1;\n        }\n        var segmentIndex = getSegmentIndex(index, time);\n        if (segmentIndex < 0 || segmentIndex >= timeline.length - 1) {\n            return -1;\n        }\n        var range = timeline[segmentIndex];\n        if (range.d === -1) {\n            return -1;\n        }\n        var rangeUp = range.ts;\n        var rangeTo = getTimelineRangeEnd(range);\n        var nextRange = timeline[segmentIndex + 1];\n        // when we are actually inside the found range and this range has\n        // an explicit discontinuity with the next one\n        if (rangeTo !== nextRange.ts &&\n            time >= rangeUp &&\n            time <= rangeTo &&\n            (rangeTo - time) < timescale) {\n            return nextRange.ts / timescale;\n        }\n        return -1;\n    };\n    SmoothRepresentationIndex.prototype._update = function (newIndex) {\n        this._index = newIndex._index;\n    };\n    SmoothRepresentationIndex.prototype._addSegments = function (nextSegments, currentSegment) {\n        for (var i = 0; i < nextSegments.length; i++) {\n            _addSegmentInfos(this._index, nextSegments[i], currentSegment);\n        }\n    };\n    return SmoothRepresentationIndex;\n}());\nexports.default = SmoothRepresentationIndex;\n\n\n//# sourceURL=webpack://RxPlayer/./src/net/smooth/manifest/representationIndex.ts?");

/***/ }),

/***/ "./src/net/smooth/mp4.ts":
/*!*******************************!*\
  !*** ./src/net/smooth/mp4.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar compat_1 = __webpack_require__(/*! ../../compat */ \"./src/compat/index.ts\");\nvar isobmff_1 = __webpack_require__(/*! ../../parsers/containers/isobmff */ \"./src/parsers/containers/isobmff/index.ts\");\nvar assert_1 = __webpack_require__(/*! ../../utils/assert */ \"./src/utils/assert.ts\");\nvar bytes_1 = __webpack_require__(/*! ../../utils/bytes */ \"./src/utils/bytes.ts\");\n/**\n * Sampling frequencies defined in MPEG-4 Audio.\n * @type {Array.<Number>}\n */\nvar SAMPLING_FREQUENCIES = [\n    96000,\n    88200,\n    64000,\n    48000,\n    44100,\n    32000,\n    24000,\n    22050,\n    16000,\n    12000,\n    11025,\n    8000,\n    7350,\n];\n/**\n * Speed up string to bytes conversion by memorizing the result\n *\n * The keys here are ISOBMFF box names. The values are the corresponding\n * bytes conversion for putting as an ISOBMFF boxes.\n *\n * Used by the boxName method.\n * @type {Object}\n */\nvar boxNamesMem = {};\n/**\n * Convert the string name of an ISOBMFF box into the corresponding bytes.\n * Has a memorization mechanism to speed-up if you want to translate the\n * same string multiple times.\n * @param {string} str\n * @returns {Uint8Array}\n */\nfunction boxName(str) {\n    if (boxNamesMem[str]) {\n        return boxNamesMem[str];\n    }\n    var nameInBytes = bytes_1.strToBytes(str);\n    boxNamesMem[str] = nameInBytes;\n    return nameInBytes;\n}\n/**\n * Create a new ISOBMFF \"box\" with the given name.\n * @param {string} name - name of the box you want to create, must always\n * be 4 characters (uuid boxes not supported)\n * @param {Uint8Array} buff - content of the box\n * @returns {Uint8Array} - The entire ISOBMFF box (length+name+content)\n */\nfunction Atom(name, buff) {\n    if (true) {\n        assert_1.default(name.length === 4);\n    }\n    var len = buff.length + 8;\n    return bytes_1.concat(bytes_1.itobe4(len), boxName(name), buff);\n}\n/**\n * @param {Uint8Array} buf\n * @param {Number} id1\n * @param {Number} id2\n * @param {Number} id3\n * @param {Number} id4\n * @returns {Uint8Array|undefined}\n */\nfunction readUuid(buf, id1, id2, id3, id4) {\n    var l = buf.length;\n    var i = 0;\n    var len;\n    while (i < l) {\n        len = bytes_1.be4toi(buf, i);\n        if (bytes_1.be4toi(buf, i + 4) === 0x75756964 /* === \"uuid\" */ &&\n            bytes_1.be4toi(buf, i + 8) === id1 &&\n            bytes_1.be4toi(buf, i + 12) === id2 &&\n            bytes_1.be4toi(buf, i + 16) === id3 &&\n            bytes_1.be4toi(buf, i + 20) === id4) {\n            return buf.subarray(i + 24, i + len);\n        }\n        i += len;\n    }\n}\nvar atoms = {\n    /**\n     * @param {string} name\n     * @param {Array.<Uint8Array>} children\n     * @returns {Uint8Array}\n     */\n    mult: function (name, children) {\n        return Atom(name, bytes_1.concat.apply(null, children));\n    },\n    /**\n     * @param {string} name - \"avc1\" or \"encv\"\n     * @param {Number} drefIdx - shall be 1\n     * @param {Number} width\n     * @param {Number} height\n     * @param {Number} hRes - horizontal resolution, eg 72\n     * @param {Number} vRes - horizontal resolution, eg 72\n     * @param {string} encDepth\n     * @param {Number} colorDepth - eg 24\n     * @param {Uint8Array} avcc - Uint8Array representing the avcC atom\n     * @param {Uint8Array} [sinf] - Uint8Array representing the sinf atom,\n     * only if name == \"encv\"\n     * @returns {Uint8Array}\n     */\n    avc1encv: function (name, drefIdx, width, height, hRes, vRes, encName, colorDepth, avcc, sinf) {\n        if (true) {\n            assert_1.default(name === \"avc1\" || name === \"encv\", \"should be avc1 or encv atom\");\n            assert_1.default(name !== \"encv\" || sinf instanceof Uint8Array);\n        }\n        return Atom(name, bytes_1.concat(6, // 6 bytes reserved\n        bytes_1.itobe2(drefIdx), 16, // drefIdx + QuickTime reserved, zeroes\n        bytes_1.itobe2(width), // size 2 w\n        bytes_1.itobe2(height), // size 2 h\n        bytes_1.itobe2(hRes), 2, // reso 4 h\n        bytes_1.itobe2(vRes), 2 + 4, // reso 4 v + QuickTime reserved, zeroes\n        [0, 1, encName.length], // frame count (default 1)\n        bytes_1.strToBytes(encName), // 1byte len + encoder name str\n        (31 - encName.length), // + padding\n        bytes_1.itobe2(colorDepth), // color depth\n        [0xFF, 0xFF], // reserved ones\n        avcc, // avcc atom,\n        name === \"encv\" ? sinf || [] : []));\n    },\n    /**\n     * @param {Uint8Array} sps\n     * @param {Uint8Array} pps\n     * @param {Number} nalLen - NAL Unit length: 1, 2 or 4 bytes\n     * eg: avcc(0x4d, 0x40, 0x0d, 4, 0xe1, \"674d400d96560c0efcb80a70505050a0\",\n     * 1, \"68ef3880\")\n     * @returns {Uint8Array}\n     */\n    avcc: function (sps, pps, nalLen) {\n        var nal = (nalLen === 2) ?\n            0x1 : (nalLen === 4) ?\n            0x3 : 0x0;\n        // Deduce AVC Profile from SPS\n        var h264Profile = sps[1];\n        var h264CompatibleProfile = sps[2];\n        var h264Level = sps[3];\n        return Atom(\"avcC\", bytes_1.concat([\n            1,\n            h264Profile,\n            h264CompatibleProfile,\n            h264Level,\n            (0x3F << 2 | nal),\n            (0xE0 | 1),\n        ], bytes_1.itobe2(sps.length), sps, [1], bytes_1.itobe2(pps.length), pps));\n    },\n    /**\n     * @param {url} Uint8Array\n     * @returns {Uint8Array}\n     */\n    dref: function (url) {\n        // only one description here... FIXME\n        return Atom(\"dref\", bytes_1.concat(7, [1], url));\n    },\n    /**\n     * @param {Number} stream\n     * @param {string} codecPrivateData - hex string\n     * eg: esds(1, 98800, \"1190\")\n     * @returns {Uint8Array}\n     */\n    esds: function (stream, codecPrivateData) {\n        return Atom(\"esds\", bytes_1.concat(4, [0x03, 0x19], bytes_1.itobe2(stream), [0x00, 0x04, 0x11, 0x40, 0x15], 11, [0x05, 0x02], bytes_1.hexToBytes(codecPrivateData), [0x06, 0x01, 0x02]));\n    },\n    /**\n     * @param {string} dataFormat - four letters (eg \"avc1\")\n     * @returns {Uint8Array}\n     */\n    frma: function (dataFormat) {\n        if (true) {\n            assert_1.default(dataFormat.length === 4, \"wrong data format length\");\n        }\n        return Atom(\"frma\", bytes_1.strToBytes(dataFormat));\n    },\n    /**\n     * @param {Number} length\n     * @returns {Uint8Array}\n     */\n    free: function (length) {\n        return Atom(\"free\", new Uint8Array(length - 8));\n    },\n    /**\n     * @param {string} majorBrand\n     * @param {Array.<string>} brands\n     * @returns {Uint8Array}\n     */\n    ftyp: function (majorBrand, brands) {\n        return Atom(\"ftyp\", bytes_1.concat.apply(null, [\n            bytes_1.strToBytes(majorBrand),\n            [0, 0, 0, 1],\n        ].concat(brands.map(bytes_1.strToBytes))));\n    },\n    /**\n     * @param {string} type - \"video\" or \"audio\"\n     * @returns {Uint8Array}\n     */\n    hdlr: function (type) {\n        var name;\n        var handlerName;\n        switch (type) {\n            case \"video\":\n                name = \"vide\";\n                handlerName = \"VideoHandler\";\n                break;\n            case \"audio\":\n                name = \"soun\";\n                handlerName = \"SoundHandler\";\n                break;\n            default:\n                name = \"hint\";\n                handlerName = \"\";\n                break;\n        }\n        return Atom(\"hdlr\", bytes_1.concat(8, bytes_1.strToBytes(name), 12, bytes_1.strToBytes(handlerName), 1 // handler name is C-style string (0 terminated)\n        ));\n    },\n    /**\n     * @param {number} timescale\n     * @returns {Uint8Array}\n     */\n    mdhd: function (timescale) {\n        return Atom(\"mdhd\", bytes_1.concat(12, bytes_1.itobe4(timescale), 8));\n    },\n    /**\n     * @param {Uint8Array} mfhd\n     * @param {Uint8Array} traf\n     * @returns {Uint8Array}\n     */\n    moof: function (mfhd, traf) {\n        return atoms.mult(\"moof\", [mfhd, traf]);\n    },\n    /**\n     * @param {string} name - \"mp4a\" or \"enca\"\n     * @param {Number} drefIdx\n     * @param {Number} channelsCount\n     * @param {Number} sampleSize\n     * @param {Number} packetSize\n     * @param {Number} sampleRate\n     * @param {Uint8Array} esds - Uint8Array representing the esds atom\n     * @param {Uint8Array} [sinf] - Uint8Array representing the sinf atom,\n     * only if name == \"enca\"\n     * @returns {Uint8Array}\n     */\n    mp4aenca: function (name, drefIdx, channelsCount, sampleSize, packetSize, sampleRate, esds, sinf) {\n        if (true) {\n            assert_1.default(name !== \"enca\" || sinf instanceof Uint8Array);\n        }\n        return Atom(name, bytes_1.concat(6, bytes_1.itobe2(drefIdx), 8, bytes_1.itobe2(channelsCount), bytes_1.itobe2(sampleSize), 2, bytes_1.itobe2(packetSize), bytes_1.itobe2(sampleRate), 2, esds, (name === \"enca\") ? sinf || [] : []));\n    },\n    /**\n     * @param {Number} timescale\n     * @param {Number} trackId\n     * @returns {Uint8Array}\n     */\n    mvhd: function (timescale, trackId) {\n        return Atom(\"mvhd\", bytes_1.concat(12, bytes_1.itobe4(timescale), 4, [0, 1], 2, // we assume rate = 1;\n        [1, 0], 10, // we assume volume = 100%;\n        [0, 1], 14, // default matrix\n        [0, 1], 14, // default matrix\n        [64, 0, 0, 0], 26, bytes_1.itobe2(trackId + 1) // next trackId (=trackId + 1);\n        ));\n    },\n    /**\n     * @param {string} systemId - Hex string representing the CDM, 16 bytes.\n     * @param {Uint8Array} [privateData=[]] - Data associated to protection\n     * specific system.\n     * @param {[]Uint8Array} keyIds - List of key ids contained in the PSSH\n     * @returns {Uint8Array}\n     */\n    pssh: function (systemId, privateData, keyIds) {\n        if (privateData === void 0) { privateData = new Uint8Array(0); }\n        if (keyIds === void 0) { keyIds = new Uint8Array(0); }\n        var _systemId = systemId.replace(/-/g, \"\");\n        assert_1.default(_systemId.length === 32, \"wrong system id length\");\n        var version;\n        var kidList;\n        var kidCount = keyIds.length;\n        if (kidCount > 0) {\n            version = 1;\n            kidList = bytes_1.concat.apply(void 0, [bytes_1.itobe4(kidCount)].concat(keyIds));\n        }\n        else {\n            version = 0;\n            kidList = [];\n        }\n        return Atom(\"pssh\", bytes_1.concat([version, 0, 0, 0], bytes_1.hexToBytes(_systemId), kidList, bytes_1.itobe4(privateData.length), privateData));\n    },\n    /**\n     * @param {Uint8Array} mfhd\n     * @param {Uint8Array} tfhd\n     * @param {Uint8Array} tfdt\n     * @param {Uint8Array} trun\n     * @returns {Uint8Array}\n     */\n    saio: function (mfhd, tfhd, tfdt, trun) {\n        return Atom(\"saio\", bytes_1.concat(4, [0, 0, 0, 1], // ??\n        bytes_1.itobe4(mfhd.length +\n            tfhd.length +\n            tfdt.length +\n            trun.length +\n            8 + 8 + 8 + 8)));\n    },\n    /**\n     * @param {Uint8Array} sencData - including 8 bytes flags and entries count\n     * @returns {Uint8Array}\n     */\n    saiz: function (senc) {\n        if (senc.length === 0) {\n            return Atom(\"saiz\", new Uint8Array(0));\n        }\n        var flags = bytes_1.be4toi(senc, 0);\n        var entries = bytes_1.be4toi(senc, 4);\n        var arr = new Uint8Array(entries + 9);\n        arr.set(bytes_1.itobe4(entries), 5);\n        var i = 9;\n        var j = 8;\n        var pairsCnt;\n        var pairsLen;\n        while (j < senc.length) {\n            j += 8; // assuming IV is 8 bytes TODO handle 16 bytes IV\n            // if we have extradata for each entry\n            if ((flags & 0x2) === 0x2) {\n                pairsLen = 2;\n                pairsCnt = bytes_1.be2toi(senc, j);\n                j += (pairsCnt * 6) + 2;\n            }\n            else {\n                pairsCnt = 0;\n                pairsLen = 0;\n            }\n            arr[i] = pairsCnt * 6 + 8 + pairsLen;\n            i++;\n        }\n        return Atom(\"saiz\", arr);\n    },\n    /**\n     * @param {string} schemeType - four letters (eg \"cenc\" for Common Encryption)\n     * @param {Number} schemeVersion - eg 65536\n     * @returns {Uint8Array}\n     */\n    schm: function (schemeType, schemeVersion) {\n        if (true) {\n            assert_1.default(schemeType.length === 4, \"wrong scheme type length\");\n        }\n        return Atom(\"schm\", bytes_1.concat(4, bytes_1.strToBytes(schemeType), bytes_1.itobe4(schemeVersion)));\n    },\n    /**\n     * @param {Uint8Array} buf\n     * @returns {Uint8Array}\n     */\n    senc: function (buf) {\n        return Atom(\"senc\", buf);\n    },\n    /**\n     * @returns {Uint8Array}\n     */\n    smhd: function () {\n        return Atom(\"smhd\", new Uint8Array(8));\n    },\n    /**\n     * @param {Array.<Uint8Array>} representations - arrays of Uint8Array,\n     * typically [avc1] or [encv, avc1]\n     * @returns {Uint8Array}\n     */\n    stsd: function (reps) {\n        // only one description here... FIXME\n        var arrBase = [7, [reps.length]];\n        return Atom(\"stsd\", bytes_1.concat.apply(void 0, arrBase.concat(reps)));\n    },\n    /**\n     * @param {Number} width\n     * @param {Number} height\n     * @param {Number} trackId\n     * @returns {Uint8Array}\n     */\n    tkhd: function (width, height, trackId) {\n        return Atom(\"tkhd\", bytes_1.concat(bytes_1.itobe4(1 + 2 + 4), 8, // we assume track is enabled,\n        // in media and in preview.\n        bytes_1.itobe4(trackId), 20, // we assume trackId = 1;\n        [1, 0, 0, 0], // we assume volume = 100%;\n        [0, 1, 0, 0], 12, // default matrix\n        [0, 1, 0, 0], 12, // default matrix\n        [64, 0, 0, 0], // ??\n        bytes_1.itobe2(width), 2, // width (TODO handle fixed)\n        bytes_1.itobe2(height), 2 // height (TODO handle fixed)\n        ));\n    },\n    /**\n     * @param {Number} trackId\n     * @returns {Uint8Array}\n     */\n    trex: function (trackId) {\n        // default sample desc idx = 1\n        return Atom(\"trex\", bytes_1.concat(4, bytes_1.itobe4(trackId), [0, 0, 0, 1], 12));\n    },\n    /**\n     * @param {Number} decodeTime\n     * @returns {Uint8Array}\n     */\n    tfdt: function (decodeTime) {\n        return Atom(\"tfdt\", bytes_1.concat([1, 0, 0, 0], bytes_1.itobe8(decodeTime)));\n    },\n    /**\n     * @param {Number} algId - eg 1\n     * @param {Number} ivSize - eg 8\n     * @param {string} keyId - Hex KID 93789920e8d6520098577df8f2dd5546\n     * @returns {Uint8Array}\n     */\n    tenc: function (algId, ivSize, keyId) {\n        if (true) {\n            assert_1.default(keyId.length === 32, \"wrong default KID length\");\n        }\n        return Atom(\"tenc\", bytes_1.concat(6, [algId, ivSize], bytes_1.hexToBytes(keyId)));\n    },\n    /**\n     * @param {Uint8Array} tfhd\n     * @param {Uint8Array} tfdt\n     * @param {Uint8Array} trun\n     * @param {Uint8Array} senc\n     * @param {Uint8Array} mfhd\n     * @returns {Uint8Array}\n     */\n    traf: function (tfhd, tfdt, trun, mfhd, senc) {\n        var trafs = [tfhd, tfdt, trun];\n        if (senc) {\n            trafs.push(atoms.senc(senc), atoms.saiz(senc), atoms.saio(mfhd, tfhd, tfdt, trun));\n        }\n        return atoms.mult(\"traf\", trafs);\n    },\n    /**\n     * @param {Uint8Array} oldtrun\n     * @returns {Uint8Array}\n     */\n    trun: function (oldtrun) {\n        var headersLast = oldtrun[11];\n        var hasDataOffset = headersLast & 0x01;\n        if (hasDataOffset) {\n            return oldtrun;\n        }\n        // If no dataoffset is present, we change the headers and add one\n        var trun = new Uint8Array(oldtrun.length + 4);\n        trun.set(bytes_1.itobe4(oldtrun.length + 4), 0);\n        trun.set(oldtrun.subarray(4, 16), 4); // name + (version + headers) +\n        // samplecount\n        trun[11] = trun[11] | 0x01; // add data offset header info\n        trun.set([0, 0, 0, 0], 16); // data offset\n        trun.set(oldtrun.subarray(16, oldtrun.length), 20);\n        return trun;\n    },\n    /**\n     * @returns {Uint8Array}\n     */\n    vmhd: function () {\n        var arr = new Uint8Array(12);\n        arr[3] = 1; // QuickTime...\n        return Atom(\"vmhd\", arr);\n    },\n};\nvar reads = {\n    /**\n     * Extract senc data (derived from UUID MS Atom)\n     * @param {Uint8Array} traf\n     * @returns {Uint8Array|undefined}\n     */\n    senc: function (traf) {\n        return readUuid(traf, 0xA2394F52, 0x5A9B4F14, 0xA2446C42, 0x7C648DF4);\n    },\n    /**\n     * Extract tfxd data (derived from UUID MS Atom)\n     * @param {Uint8Array} traf\n     * @returns {Uint8Array|undefined}\n     */\n    tfxd: function (traf) {\n        return readUuid(traf, 0x6D1D9B05, 0x42D544E6, 0x80E2141D, 0xAFF757B2);\n    },\n    /**\n     * Extract tfrf data (derived from UUID MS Atom)\n     * @param {Uint8Array} traf\n     * @returns {Uint8Array|undefined}\n     */\n    tfrf: function (traf) {\n        return readUuid(traf, 0xD4807EF2, 0XCA394695, 0X8E5426CB, 0X9E46A79F);\n    },\n};\n/**\n * Return AAC ES Header (hexstr form)\n *\n * @param {Number} type\n *          1 = AAC Main\n *          2 = AAC LC\n *          cf http://wiki.multimedia.cx/index.php?title=MPEG-4_Audio\n * @param {Number} frequency\n * @param {Number} chans (1 or 2)\n * @returns {string}\n */\nfunction aacesHeader(type, frequency, chans) {\n    var freq = SAMPLING_FREQUENCIES.indexOf(frequency);\n    if (true) {\n        assert_1.default(freq >= 0, \"non supported frequency\"); // TODO : handle Idx = 15...\n    }\n    var val;\n    val = (type & 0x3F) << 0x4;\n    val = (val | (freq & 0x1F)) << 0x4;\n    val = (val | (chans & 0x1F)) << 0x3;\n    return bytes_1.bytesToHex(bytes_1.itobe2(val));\n}\n/**\n * @param {Uint8Array} mvhd\n * @param {Uint8Array} mvex\n * @param {Uint8Array} trak\n * @param {Object} pssList\n * @returns {Array.<Uint8Array>}\n */\nfunction moovChildren(mvhd, mvex, trak, pssList) {\n    var moov = [mvhd, mvex, trak];\n    pssList.forEach(function (pss) {\n        var pssh = atoms.pssh(pss.systemId, pss.privateData, pss.keyIds);\n        moov.push(pssh);\n    });\n    return moov;\n}\n/**\n * /!\\ Mutates given segment\n * @param {Uint8Array} segment\n * @param {Number} trunoffset\n * @param {Number} dataoffset\n */\nfunction patchTrunDataOffset(segment, trunoffset, dataOffset) {\n    // patch trun dataoffset with new moof atom size\n    segment.set(bytes_1.itobe4(dataOffset), trunoffset + 16);\n}\n/**\n * @param {Uint8Array} segment\n * @param {Uint8Array} newmoof\n * @param {Uint8Array} oldmoof\n * @param {Number} trunoffset\n * @returns {Uint8Array}\n */\nfunction createNewSegment(segment, newmoof, oldmoof, trunoffset) {\n    var segmentlen = segment.length;\n    var newmooflen = newmoof.length;\n    var oldmooflen = oldmoof.length;\n    var mdat = segment.subarray(oldmooflen, segmentlen);\n    var newSegment = new Uint8Array(newmooflen + (segmentlen - oldmooflen));\n    newSegment.set(newmoof, 0);\n    newSegment.set(mdat, newmooflen);\n    patchTrunDataOffset(newSegment, trunoffset, newmoof.length + 8);\n    return newSegment;\n}\n/**\n * /!\\ Mutates given segment\n * @param {Uint8Array} segment\n * @param {Uint8Array} newmoof\n * @param {Uint8Array} oldmoof\n * @param {Number} trunoffset\n * @returns {Uint8Array}\n */\nfunction patchSegmentInPlace(segment, newmoof, oldmoof, trunoffset) {\n    var free = oldmoof.length - newmoof.length;\n    segment.set(newmoof, 0);\n    segment.set(atoms.free(free), newmoof.length);\n    patchTrunDataOffset(segment, trunoffset, newmoof.length + 8 + free);\n    return segment;\n}\n/**\n * @param {Number} timescale\n * @param {string} type\n * @param {Uint8Array} stsd\n * @param {Uint8Array} mhd\n * @param {Number} width\n * @param {Number} height\n * @param {Array.<Object>} pssList - List of dict, example:\n * {systemId: \"DEADBEEF\", codecPrivateData: \"DEAFBEEF}\n * @returns {Uint8Array}\n */\nfunction createInitSegment(timescale, type, stsd, mhd, width, height, pssList) {\n    var stbl = atoms.mult(\"stbl\", [\n        stsd,\n        Atom(\"stts\", new Uint8Array(0x08)),\n        Atom(\"stsc\", new Uint8Array(0x08)),\n        Atom(\"stsz\", new Uint8Array(0x0c)),\n        Atom(\"stco\", new Uint8Array(0x08)),\n    ]);\n    var url = Atom(\"url \", new Uint8Array([0, 0, 0, 1]));\n    var dref = atoms.dref(url);\n    var dinf = atoms.mult(\"dinf\", [dref]);\n    var minf = atoms.mult(\"minf\", [mhd, dinf, stbl]);\n    var hdlr = atoms.hdlr(type);\n    var mdhd = atoms.mdhd(timescale); // this one is really important\n    var mdia = atoms.mult(\"mdia\", [mdhd, hdlr, minf]);\n    var tkhd = atoms.tkhd(width, height, 1);\n    var trak = atoms.mult(\"trak\", [tkhd, mdia]);\n    var trex = atoms.trex(1);\n    var mvex = atoms.mult(\"mvex\", [trex]);\n    var mvhd = atoms.mvhd(timescale, 1); // in fact, we don't give a sh** about\n    // this value :O\n    var moov = atoms.mult(\"moov\", moovChildren(mvhd, mvex, trak, pssList));\n    var ftyp = atoms.ftyp(\"isom\", [\"isom\", \"iso2\", \"iso6\", \"avc1\", \"dash\"]);\n    return bytes_1.concat(ftyp, moov);\n}\n// TODO\nexports.default = {\n    getMdat: isobmff_1.getMDAT,\n    getTraf: isobmff_1.getTRAF,\n    /**\n     * @param {Uint8Array} traf\n     * @returns {Array.<Object>}\n     */\n    parseTfrf: function (traf) {\n        var tfrf = reads.tfrf(traf);\n        if (!tfrf) {\n            return [];\n        }\n        var frags = [];\n        var version = tfrf[0];\n        var fragCount = tfrf[4];\n        for (var i = 0; i < fragCount; i++) {\n            var duration = void 0;\n            var time = void 0;\n            if (version === 1) {\n                time = bytes_1.be8toi(tfrf, i * 16 + 5);\n                duration = bytes_1.be8toi(tfrf, i * 16 + 5 + 8);\n            }\n            else {\n                time = bytes_1.be4toi(tfrf, i * 8 + 5);\n                duration = bytes_1.be4toi(tfrf, i * 8 + 5 + 4);\n            }\n            frags.push({\n                time: time,\n                duration: duration,\n            });\n        }\n        return frags;\n    },\n    /**\n     * @param {Uint8Array} traf\n     * @returns {Object|undefined}\n     */\n    parseTfxd: function (traf) {\n        var tfxd = reads.tfxd(traf);\n        if (tfxd) {\n            return {\n                duration: bytes_1.be8toi(tfxd, 12),\n                time: bytes_1.be8toi(tfxd, 4),\n            };\n        }\n    },\n    /**\n     * Return full video Init segment as Uint8Array\n     * @param {Number} timescale - lowest number, this one will be set into mdhd\n     * *10000 in mvhd, e.g. 1000\n     * @param {Number} width\n     * @param {Number} height\n     * @param {Number} hRes\n     * @param {Number} vRes\n     * @param {Number} nalLength (1, 2 or 4)\n     * @param {string} codecPrivateData\n     * @param {string} keyId - hex string representing the key Id,\n     * 32 chars. eg. a800dbed49c12c4cb8e0b25643844b9b\n     * @param {Array.<Object>} [pssList] - List of dict, example:\n     * {systemId: \"DEADBEEF\", codecPrivateData: \"DEAFBEEF}\n     * @returns {Uint8Array}\n     */\n    createVideoInitSegment: function (timescale, width, height, hRes, vRes, nalLength, codecPrivateData, keyId, pssList) {\n        var _pssList = pssList || [];\n        var _a = codecPrivateData.split(\"00000001\"), spsHex = _a[1], ppsHex = _a[2];\n        var sps = bytes_1.hexToBytes(spsHex);\n        var pps = bytes_1.hexToBytes(ppsHex);\n        // TODO NAL length is forced to 4\n        var avcc = atoms.avcc(sps, pps, nalLength);\n        var stsd;\n        if (!_pssList.length || keyId == null) {\n            var avc1 = atoms.avc1encv(\"avc1\", // name\n            1, // drefIdx\n            width, height, hRes, vRes, \"AVC Coding\", // encName\n            24, // color depth\n            avcc);\n            stsd = atoms.stsd([avc1]);\n        }\n        else {\n            var tenc = atoms.tenc(1, 8, keyId);\n            var schi = atoms.mult(\"schi\", [tenc]);\n            var schm = atoms.schm(\"cenc\", 65536);\n            var frma = atoms.frma(\"avc1\");\n            var sinf = atoms.mult(\"sinf\", [frma, schm, schi]);\n            var encv = atoms.avc1encv(\"encv\", 1, width, height, hRes, vRes, \"AVC Coding\", 24, avcc, sinf);\n            stsd = atoms.stsd([encv]);\n        }\n        return createInitSegment(timescale, \"video\", stsd, atoms.vmhd(), width, height, _pssList);\n    },\n    /**\n     * Return full audio Init segment as Uint8Array\n     * @param {Number} timescale\n     * @param {Number} channelsCount\n     * @param {Number} sampleSize\n     * @param {Number} packetSize\n     * @param {Number} sampleRate\n     * @param {string} codecPrivateData\n     * @param {string} keyId - hex string representing the key Id, 32 chars.\n     * eg. a800dbed49c12c4cb8e0b25643844b9b\n     * @param {Array.<Object>} [pssList] - List of dict, example:\n     * {systemId: \"DEADBEEF\", codecPrivateData: \"DEAFBEEF\"}\n     * @returns {Uint8Array}\n     */\n    createAudioInitSegment: function (timescale, channelsCount, sampleSize, packetSize, sampleRate, codecPrivateData, keyId, pssList) {\n        var _pssList = pssList || [];\n        var _codecPrivateData = codecPrivateData || aacesHeader(2, sampleRate, channelsCount);\n        var esds = atoms.esds(1, _codecPrivateData);\n        var stsd;\n        if (!_pssList.length || keyId == null) {\n            var mp4a = atoms.mp4aenca(\"mp4a\", 1, channelsCount, sampleSize, packetSize, sampleRate, esds);\n            stsd = atoms.stsd([mp4a]);\n        }\n        else {\n            var tenc = atoms.tenc(1, 8, keyId);\n            var schi = atoms.mult(\"schi\", [tenc]);\n            var schm = atoms.schm(\"cenc\", 65536);\n            var frma = atoms.frma(\"mp4a\");\n            var sinf = atoms.mult(\"sinf\", [frma, schm, schi]);\n            var enca = atoms.mp4aenca(\"enca\", 1, channelsCount, sampleSize, packetSize, sampleRate, esds, sinf);\n            stsd = atoms.stsd([enca]);\n        }\n        return createInitSegment(timescale, \"audio\", stsd, atoms.smhd(), 0, 0, _pssList);\n    },\n    /**\n     * Add decodeTime info in a segment (tfdt box)\n     * @param {Uint8Array} segment\n     * @param {Number} decodeTime\n     * @return {Uint8Array}\n     */\n    patchSegment: function (segment, decodeTime) {\n        if (true) {\n            // TODO handle segments with styp/free...\n            var name_1 = bytes_1.bytesToStr(segment.subarray(4, 8));\n            assert_1.default(name_1 === \"moof\");\n        }\n        var oldmoof = segment.subarray(0, bytes_1.be4toi(segment, 0));\n        var newtfdt = atoms.tfdt(decodeTime);\n        // reads [moof[mfhd|traf[tfhd|trun|..]]]\n        var tfdtlen = newtfdt.length;\n        var mfhdlen = bytes_1.be4toi(oldmoof, 8);\n        var traflen = bytes_1.be4toi(oldmoof, mfhdlen + 8);\n        var tfhdlen = bytes_1.be4toi(oldmoof, mfhdlen + 8 + 8);\n        var trunlen = bytes_1.be4toi(oldmoof, mfhdlen + 8 + 8 + tfhdlen);\n        var oldmfhd = oldmoof.subarray(8, mfhdlen + 8);\n        var oldtraf = oldmoof\n            .subarray(mfhdlen + 8 + 8, mfhdlen + 8 + 8 + traflen - 8);\n        var oldtfhd = oldtraf.subarray(0, tfhdlen);\n        var oldtrun = oldtraf.subarray(tfhdlen, tfhdlen + trunlen);\n        // force trackId=1 since trackIds are not always reliable...\n        oldtfhd.set([0, 0, 0, 1], 12);\n        // TODO fallback?\n        var oldsenc = reads.senc(oldtraf);\n        // writes [moof[mfhd|traf[tfhd|tfdt|trun|senc|saiz|saio]]]\n        var newtrun = atoms.trun(oldtrun);\n        var newtraf = atoms.traf(oldtfhd, newtfdt, newtrun, oldmfhd, oldsenc);\n        var newmoof = atoms.moof(oldmfhd, newtraf);\n        var trunoffset = mfhdlen + 8 + 8 + tfhdlen + tfdtlen;\n        // TODO(pierre): fix patchSegmentInPlace to work with IE11. Maybe\n        // try to put free atom inside traf children\n        if (compat_1.isIE) {\n            return createNewSegment(segment, newmoof, oldmoof, trunoffset);\n        }\n        else {\n            if (oldmoof.length - newmoof.length >= 8 /* minimum \"free\" atom size */) {\n                return patchSegmentInPlace(segment, newmoof, oldmoof, trunoffset);\n            }\n            else {\n                return createNewSegment(segment, newmoof, oldmoof, trunoffset);\n            }\n        }\n    },\n};\n\n\n//# sourceURL=webpack://RxPlayer/./src/net/smooth/mp4.ts?");

/***/ }),

/***/ "./src/net/smooth/segment_loader.ts":
/*!******************************************!*\
  !*** ./src/net/smooth/segment_loader.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Observable_1 = __webpack_require__(/*! rxjs/Observable */ \"./node_modules/rxjs/Observable.js\");\nvar assert_1 = __webpack_require__(/*! ../../utils/assert */ \"./src/utils/assert.ts\");\nvar request_1 = __webpack_require__(/*! ../../utils/request */ \"./src/utils/request/index.ts\");\nvar url_1 = __webpack_require__(/*! ../../utils/url */ \"./src/utils/url.ts\");\nvar mp4_1 = __webpack_require__(/*! ./mp4 */ \"./src/net/smooth/mp4.ts\");\nvar utils_1 = __webpack_require__(/*! ./utils */ \"./src/net/smooth/utils.ts\");\nvar createVideoInitSegment = mp4_1.default.createVideoInitSegment, createAudioInitSegment = mp4_1.default.createAudioInitSegment;\n/**\n * Segment loader triggered if there was no custom-defined one in the API.\n * @param {Object} opt\n * @param {string} opt.url\n * @param {Segment} opt.segment\n * @returns {Observable}\n */\nfunction regularSegmentLoader(_a) {\n    var url = _a.url, segment = _a.segment;\n    var headers;\n    var range = segment.range;\n    if (range) {\n        headers = {\n            Range: utils_1.byteRange(range),\n        };\n    }\n    return request_1.default({\n        url: url,\n        responseType: \"arraybuffer\",\n        headers: headers,\n    });\n}\n/**\n * Defines the url for the request, load the right loader (custom/default\n * one).\n */\nvar generateSegmentLoader = function (customSegmentLoader) { return function (_a) {\n    var segment = _a.segment, representation = _a.representation, adaptation = _a.adaptation, period = _a.period, manifest = _a.manifest, init = _a.init;\n    if (segment.isInit) {\n        if (!segment.privateInfos || segment.privateInfos.type !== \"smooth-init\") {\n            throw new Error(\"Smooth: Invalid segment format\");\n        }\n        var responseData = void 0;\n        var privateInfos = segment.privateInfos;\n        var protection = privateInfos.protection;\n        switch (adaptation.type) {\n            case \"video\":\n                responseData = createVideoInitSegment(segment.timescale, representation.width || 0, representation.height || 0, 72, 72, 4, // vRes, hRes, nal\n                privateInfos.codecPrivateData, protection && protection.keyId, // keyId\n                protection && protection.keySystems // pssList\n                );\n                break;\n            case \"audio\":\n                responseData = createAudioInitSegment(segment.timescale, privateInfos.channels || 0, privateInfos.bitsPerSample || 0, privateInfos.packetSize || 0, privateInfos.samplingRate || 0, privateInfos.codecPrivateData, protection && protection.keyId, // keyId\n                protection && protection.keySystems // pssList\n                );\n                break;\n            default:\n                if (true) {\n                    assert_1.default(false, \"responseData should have been set\");\n                }\n                responseData = new Uint8Array(0);\n        }\n        return Observable_1.Observable.of({\n            type: \"data\",\n            value: { responseData: responseData },\n        });\n    }\n    else {\n        var url = utils_1.buildSegmentURL(url_1.resolveURL(representation.baseURL), representation, segment);\n        var args_1 = {\n            adaptation: adaptation,\n            init: init,\n            manifest: manifest,\n            period: period,\n            representation: representation,\n            segment: segment,\n            transport: \"smooth\",\n            url: url,\n        };\n        if (!customSegmentLoader) {\n            return regularSegmentLoader(args_1);\n        }\n        return Observable_1.Observable.create(function (obs) {\n            var hasFinished = false;\n            var hasFallbacked = false;\n            var resolve = function (_args) {\n                if (!hasFallbacked) {\n                    hasFinished = true;\n                    obs.next({\n                        type: \"response\",\n                        value: {\n                            responseData: _args.data,\n                            size: _args.size,\n                            duration: _args.duration,\n                        },\n                    });\n                    obs.complete();\n                }\n            };\n            var reject = function (err) {\n                if (err === void 0) { err = {}; }\n                if (!hasFallbacked) {\n                    hasFinished = true;\n                    obs.error(err);\n                }\n            };\n            var fallback = function () {\n                hasFallbacked = true;\n                regularSegmentLoader(args_1).subscribe(obs);\n            };\n            var callbacks = { reject: reject, resolve: resolve, fallback: fallback };\n            var abort = customSegmentLoader(args_1, callbacks);\n            return function () {\n                if (!hasFinished && !hasFallbacked && typeof abort === \"function\") {\n                    abort();\n                }\n            };\n        });\n    }\n}; };\nexports.default = generateSegmentLoader;\n\n\n//# sourceURL=webpack://RxPlayer/./src/net/smooth/segment_loader.ts?");

/***/ }),

/***/ "./src/net/smooth/utils.ts":
/*!*********************************!*\
  !*** ./src/net/smooth/utils.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ISM_REG = /\\.(isml?)(\\?token=\\S+)?$/;\nvar TOKEN_REG = /\\?token=(\\S+)/;\nfunction byteRange(_a) {\n    var start = _a[0], end = _a[1];\n    if (!end || end === Infinity) {\n        return \"bytes=\" + (+start) + \"-\";\n    }\n    else {\n        return \"bytes=\" + (+start) + \"-\" + (+end);\n    }\n}\nexports.byteRange = byteRange;\n/**\n * TODO Remove this logic completely from the player\n * @returns {string|null}\n */\nfunction extractISML(doc) {\n    return doc.getElementsByTagName(\"media\")[0].getAttribute(\"src\");\n}\nexports.extractISML = extractISML;\n/**\n * Returns string corresponding to the token contained in the url's querystring.\n * Empty string if no token is found.\n * @param {string} url\n * @returns {string}\n */\nfunction extractToken(url) {\n    var tokenMatch = url.match(TOKEN_REG);\n    return (tokenMatch && tokenMatch[1]) || \"\";\n}\nexports.extractToken = extractToken;\n/**\n * Replace/Remove token from the url's querystring\n * @param {string} url\n * @param {string} [token]\n * @returns {string}\n */\nfunction replaceToken(url, token) {\n    if (token) {\n        return url.replace(TOKEN_REG, \"?token=\" + token);\n    }\n    else {\n        return url.replace(TOKEN_REG, \"\");\n    }\n}\nexports.replaceToken = replaceToken;\n/**\n * @param {string} url\n * @returns {string}\n */\nfunction resolveManifest(url) {\n    var ismMatch = url.match(ISM_REG);\n    if (ismMatch) {\n        return url.replace(ismMatch[1], ismMatch[1] + \"/manifest\");\n    }\n    else {\n        return url;\n    }\n}\nexports.resolveManifest = resolveManifest;\n/**\n * @param {string} url\n * @param {Representation} representation\n * @param {Object} segment\n * @returns {string}\n */\nfunction buildSegmentURL(url, representation, segment) {\n    return url\n        .replace(/\\{bitrate\\}/g, String(representation.bitrate))\n        .replace(/\\{start time\\}/g, String(segment.time));\n}\nexports.buildSegmentURL = buildSegmentURL;\n\n\n//# sourceURL=webpack://RxPlayer/./src/net/smooth/utils.ts?");

/***/ }),

/***/ "./src/net/utils/manifest_loader.ts":
/*!******************************************!*\
  !*** ./src/net/utils/manifest_loader.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Observable_1 = __webpack_require__(/*! rxjs/Observable */ \"./node_modules/rxjs/Observable.js\");\nvar request_1 = __webpack_require__(/*! ../../utils/request */ \"./src/utils/request/index.ts\");\n/**\n * Manifest loader triggered if there was no custom-defined one in the API.\n * @param {string} url\n */\nfunction regularManifestLoader(url, ignoreProgressEvents) {\n    return request_1.default({\n        url: url,\n        responseType: \"document\",\n        ignoreProgressEvents: ignoreProgressEvents,\n    });\n}\n/**\n * Generate a manifest loader for the application\n * @param {Function} [customManifestLoader]\n * @returns {Function}\n */\nvar manifestPreLoader = function (options) { return function (url) {\n    var customManifestLoader = options.customManifestLoader, ignoreProgressEvents = options.ignoreProgressEvents;\n    if (!customManifestLoader) {\n        return regularManifestLoader(url, ignoreProgressEvents);\n    }\n    return Observable_1.Observable.create(function (obs) {\n        var hasFinished = false;\n        var hasFallbacked = false;\n        /**\n         * Callback triggered when the custom manifest loader has a response.\n         * @param {Object} args\n         * @param {*} args.data - The manifest data\n         * @param {Number} args.size - The manifest size\n         * @param {Number} args.duration - The duration of the request, in ms\n         */\n        var resolve = function (_args) {\n            if (!hasFallbacked) {\n                hasFinished = true;\n                obs.next({\n                    type: \"response\",\n                    value: {\n                        responseData: _args.data,\n                        size: _args.size,\n                        duration: _args.duration,\n                    },\n                });\n                obs.complete();\n            }\n        };\n        /**\n         * Callback triggered when the custom manifest loader fails\n         * @param {*} [err={}] - The corresponding error encountered\n         */\n        var reject = function (err) {\n            if (err === void 0) { err = {}; }\n            if (!hasFallbacked) {\n                hasFinished = true;\n                obs.error(err);\n            }\n        };\n        /**\n         * Callback triggered when the custom manifest loader wants to fallback to\n         * the \"regular\" implementation\n         */\n        var fallback = function () {\n            hasFallbacked = true;\n            regularManifestLoader(url).subscribe(obs);\n        };\n        var callbacks = { reject: reject, resolve: resolve, fallback: fallback };\n        var abort = customManifestLoader(url, callbacks);\n        return function () {\n            if (!hasFinished && !hasFallbacked && typeof abort === \"function\") {\n                abort();\n            }\n        };\n    });\n}; };\nexports.default = manifestPreLoader;\n\n\n//# sourceURL=webpack://RxPlayer/./src/net/utils/manifest_loader.ts?");

/***/ }),

/***/ "./src/parsers/containers/isobmff/index.ts":
/*!*************************************************!*\
  !*** ./src/parsers/containers/isobmff/index.ts ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar assert_1 = __webpack_require__(/*! ../../../utils/assert */ \"./src/utils/assert.ts\");\nvar bytes_1 = __webpack_require__(/*! ../../../utils/bytes */ \"./src/utils/bytes.ts\");\nvar read_1 = __webpack_require__(/*! ./read */ \"./src/parsers/containers/isobmff/read.ts\");\nexports.getMDAT = read_1.getMDAT;\nexports.getMDIA = read_1.getMDIA;\nexports.getTRAF = read_1.getTRAF;\n/**\n * Find the right atom (box) in an isobmff file from its hexa-encoded name.\n * @param {Uint8Array} buf - the isobmff structure\n * @param {Number} atomName - the 'name' of the box (e.g. 'sidx' or 'moov'),\n * hexa encoded\n * @returns {Number} - offset where the corresponding box is (starting with its\n * size), 0 if not found.\n */\nfunction findAtom(buf, atomName) {\n    var l = buf.length;\n    var i = 0;\n    var name;\n    var size = 0;\n    while (i + 8 < l) {\n        size = bytes_1.be4toi(buf, i);\n        name = bytes_1.be4toi(buf, i + 4);\n        assert_1.default(size > 0, \"out of range size\");\n        if (name === atomName) {\n            break;\n        }\n        else {\n            i += size;\n        }\n    }\n    if (i >= l) {\n        return -1;\n    }\n    assert_1.default(i + size <= l, \"atom out of range\");\n    return i;\n}\n/**\n * Parse the sidx part (segment index) of the isobmff.\n * Returns null if not found.\n *\n * @param {Uint8Array} buf\n * @param {Number} initialOffset\n * @returns {Object|null} {Array.<Object>} - Informations about each subsegment.\n * Contains those keys:\n *   - time {Number}: starting _presentation time_ for the subsegment,\n *     timescaled\n *   - duration {Number}: duration of the subsegment, timescaled\n *   - timescale {Number}: the timescale in which the time and duration are set\n *   - count {Number}: always at 0\n *   - range {Array.<Number>}: first and last bytes in the media file\n *     from the anchor point (first byte after the sidx box) for the\n *     concerned subsegment.\n */\nfunction parseSidx(buf, initialOffset) {\n    var index = findAtom(buf, 0x73696478 /* \"sidx\" */);\n    if (index === -1) {\n        return null;\n    }\n    var offset = initialOffset;\n    var size = bytes_1.be4toi(buf, index);\n    var pos = index + /* size */ 4 + /* name */ 4;\n    /* version(8) */\n    /* flags(24) */\n    /* reference_ID(32); */\n    /* timescale(32); */\n    var version = buf[pos];\n    pos += 4 + 4;\n    var timescale = bytes_1.be4toi(buf, pos);\n    pos += 4;\n    /* earliest_presentation_time(32 / 64) */\n    /* first_offset(32 / 64) */\n    var time;\n    if (version === 0) {\n        time = bytes_1.be4toi(buf, pos);\n        pos += 4;\n        offset += bytes_1.be4toi(buf, pos) + size;\n        pos += 4;\n    }\n    else if (version === 1) {\n        time = bytes_1.be8toi(buf, pos);\n        pos += 8;\n        offset += bytes_1.be8toi(buf, pos) + size;\n        pos += 8;\n    }\n    else {\n        return null;\n    }\n    var segments = [];\n    /* reserved(16) */\n    /* reference_count(16) */\n    pos += 2;\n    var count = bytes_1.be2toi(buf, pos);\n    pos += 2;\n    while (--count >= 0) {\n        /* reference_type(1) */\n        /* reference_size(31) */\n        /* segment_duration(32) */\n        /* sap..(32) */\n        var refChunk = bytes_1.be4toi(buf, pos);\n        pos += 4;\n        var refType = (refChunk & 0x80000000) >>> 31;\n        var refSize = (refChunk & 0x7fffffff);\n        // when set to 1 indicates that the reference is to a sidx, else to media\n        if (refType === 1) {\n            throw new Error(\"not implemented\");\n        }\n        var d = bytes_1.be4toi(buf, pos);\n        pos += 4;\n        // let sapChunk = be4toi(buf, pos + 8);\n        pos += 4;\n        // TODO(pierre): handle sap\n        // let startsWithSap = (sapChunk & 0x80000000) >>> 31;\n        // let sapType = (sapChunk & 0x70000000) >>> 28;\n        // let sapDelta = sapChunk & 0x0FFFFFFF;\n        segments.push({\n            time: time,\n            duration: d,\n            count: 0,\n            timescale: timescale,\n            range: [offset, offset + refSize - 1],\n        });\n        time += d;\n        offset += refSize;\n    }\n    return segments;\n}\nexports.parseSidx = parseSidx;\n/**\n * Parse track Fragment Decode Time to get a precize initial time for this\n * segment (in the media timescale).\n * Stops at the first tfdt encountered from the beginning of the file.\n * Returns this time. -1 if not found.\n * @param {Uint8Array} buffer\n * @returns {Number}\n */\nfunction parseTfdt(buffer) {\n    var traf = read_1.getTRAF(buffer);\n    if (!traf) {\n        return -1;\n    }\n    var index = findAtom(traf, 0x74666474 /* tfdt */);\n    if (index === -1) {\n        return -1;\n    }\n    var pos = index + /* size */ 4 + /* name */ 4;\n    var version = traf[pos];\n    pos += 4;\n    if (version > 1) {\n        return -1;\n    }\n    return version ? bytes_1.be8toi(traf, pos) : bytes_1.be4toi(traf, pos);\n}\nexports.parseTfdt = parseTfdt;\nfunction getDefaultDurationFromTFHDInTRAF(traf) {\n    var index = findAtom(traf, 0x74666864 /* tfhd */);\n    if (index === -1) {\n        return -1;\n    }\n    var pos = index + /* size */ 4 + /* name */ 4 + /* version */ 1;\n    var flags = bytes_1.be3toi(traf, pos);\n    var hasBaseDataOffset = flags & 0x000001;\n    var hasSampleDescriptionIndex = flags & 0x000002;\n    var hasDefaultSampleDuration = flags & 0x000008;\n    if (!hasDefaultSampleDuration) {\n        return -1;\n    }\n    pos += 4;\n    if (hasBaseDataOffset) {\n        pos += 8;\n    }\n    if (hasSampleDescriptionIndex) {\n        pos += 4;\n    }\n    var defaultDuration = bytes_1.be4toi(traf, pos);\n    return defaultDuration;\n}\nfunction getDurationFromTrun(buffer) {\n    var traf = read_1.getTRAF(buffer);\n    if (!traf) {\n        return -1;\n    }\n    var index = findAtom(traf, 0x7472756e /* tfdt */);\n    if (index === -1) {\n        return -1;\n    }\n    var pos = index + /* size */ 4 + /* name */ 4;\n    var version = traf[pos];\n    pos += 1;\n    if (version > 1) {\n        return -1;\n    }\n    var flags = bytes_1.be3toi(traf, pos);\n    pos += 3;\n    var hasSampleDuration = flags & 0x000100;\n    var defaultDuration = 0;\n    if (!hasSampleDuration) {\n        defaultDuration = getDefaultDurationFromTFHDInTRAF(traf);\n        if (defaultDuration >= 0) {\n            return defaultDuration;\n        }\n        return -1;\n    }\n    var hasDataOffset = flags & 0x000001;\n    var hasFirstSampleFlags = flags & 0x000004;\n    var hasSampleSize = flags & 0x000200;\n    var hasSampleFlags = flags & 0x000400;\n    var hasSampleCompositionOffset = flags & 0x000800;\n    var sampleCounts = bytes_1.be4toi(traf, pos);\n    pos += 4;\n    if (hasDataOffset) {\n        pos += 4;\n    }\n    if (hasFirstSampleFlags) {\n        pos += 4;\n    }\n    var i = sampleCounts;\n    var duration = 0;\n    while (i--) {\n        if (hasSampleDuration) {\n            duration += bytes_1.be4toi(traf, pos);\n            pos += 4;\n        }\n        else {\n            duration += defaultDuration;\n        }\n        if (hasSampleSize) {\n            pos += 4;\n        }\n        if (hasSampleFlags) {\n            pos += 4;\n        }\n        if (hasSampleCompositionOffset) {\n            pos += 4;\n        }\n    }\n    return duration;\n}\nexports.getDurationFromTrun = getDurationFromTrun;\n/**\n * Get various informations from a movie header box. Found in init segments.\n * null if not found or not parsed.\n *\n * This timescale is the default timescale used for segments.\n * @param {Uint8Array} buffer\n * @returns {Number}\n */\nfunction getMDHDTimescale(buffer) {\n    var mdia = read_1.getMDIA(buffer);\n    if (!mdia) {\n        return -1;\n    }\n    var index = findAtom(mdia, 0x6d646864 /* \"mdhd\" */);\n    if (index === -1) {\n        return -1;\n    }\n    var pos = index + /* size */ 4 + /* name */ 4;\n    var version = mdia[pos];\n    pos += 4;\n    if (version === 1) {\n        pos += 16;\n        return bytes_1.be4toi(mdia, pos);\n    }\n    else if (version === 0) {\n        pos += 8;\n        return bytes_1.be4toi(mdia, pos);\n    }\n    else {\n        return -1;\n    }\n}\nexports.getMDHDTimescale = getMDHDTimescale;\n/**\n * Create a new _Atom_ (isobmff box).\n * @param {string} name - The box name (e.g. sidx, moov, pssh etc.)\n * @param {Uint8Array} buff - The box's content\n */\nfunction Atom(name, buff) {\n    var len = buff.length + 8;\n    return bytes_1.concat(bytes_1.itobe4(len), bytes_1.strToBytes(name), buff);\n}\n/**\n * Returns a PSSH Atom from a systemId and private data.\n * @param {Object} args\n * @returns {Uint8Array}\n */\nfunction createPssh(_a) {\n    var systemId = _a.systemId, privateData = _a.privateData;\n    var _systemId = systemId.replace(/-/g, \"\");\n    assert_1.default(_systemId.length === 32);\n    return Atom(\"pssh\", bytes_1.concat(4, // 4 initial zeroed bytes\n    bytes_1.hexToBytes(_systemId), bytes_1.itobe4(privateData.length), privateData));\n}\n/**\n * Update ISOBMFF given to add a \"pssh\" box in the \"moov\" box for every content\n * protection in the pssList array given.\n * @param {Uint8Array} buf - the ISOBMFF file\n * @param {Array.<Object>} pssList - The content protections under the form of\n * objects containing two properties:\n *   - systemId {string}: The uuid code. Should only contain 32 hexadecimal\n *     numbers and hyphens\n *   - privateData {*}: private data associated.\n * @returns {Uint8Array} - The new ISOBMFF generated.\n */\nfunction patchPssh(buf, pssList) {\n    if (!pssList || !pssList.length) {\n        return buf;\n    }\n    var pos = findAtom(buf, 0x6d6f6f76 /* = \"moov\" */);\n    if (pos === -1) {\n        return buf;\n    }\n    var size = bytes_1.be4toi(buf, pos); // size of the \"moov\" box\n    var moov = buf.subarray(pos, pos + size);\n    var moovArr = [moov];\n    for (var i = 0; i < pssList.length; i++) {\n        moovArr.push(createPssh(pssList[i]));\n    }\n    var newmoov = bytes_1.concat.apply(void 0, moovArr);\n    newmoov.set(bytes_1.itobe4(newmoov.length), 0); // overwrite \"moov\" length\n    return bytes_1.concat(buf.subarray(0, pos), newmoov, buf.subarray(pos + size));\n}\nexports.patchPssh = patchPssh;\n\n\n//# sourceURL=webpack://RxPlayer/./src/parsers/containers/isobmff/index.ts?");

/***/ }),

/***/ "./src/parsers/containers/isobmff/read.ts":
/*!************************************************!*\
  !*** ./src/parsers/containers/isobmff/read.ts ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar assert_1 = __webpack_require__(/*! ../../../utils/assert */ \"./src/utils/assert.ts\");\nvar bytes_1 = __webpack_require__(/*! ../../../utils/bytes */ \"./src/utils/bytes.ts\");\n/**\n * @param {Uint8Array} buf - the isobmff structure\n * @param {Number} boxName - the 'name' of the box (e.g. 'sidx' or 'moov'),\n * hexa encoded\n * @returns {UInt8Array|null}\n */\nfunction getBox(buf, boxName) {\n    var l = buf.length;\n    var i = 0;\n    var name;\n    var size = 0;\n    while (i + 8 < l) {\n        size = bytes_1.be4toi(buf, i);\n        name = bytes_1.be4toi(buf, i + 4);\n        assert_1.default(size > 0, \"out of range size\");\n        if (name === boxName) {\n            break;\n        }\n        else {\n            i += size;\n        }\n    }\n    if (i < l) {\n        return buf.subarray(i + 8, i + size);\n    }\n    else {\n        return null;\n    }\n}\n/**\n * Returns TRAF Box from the whole ISOBMFF File.\n * Returns null if not found.\n * @param {Uint8Array} buffer\n * @returns {Uint8Array|null}\n */\nfunction getTRAF(buffer) {\n    var moof = getBox(buffer, 0x6d6f6f66 /* moof */);\n    if (!moof) {\n        return null;\n    }\n    return getBox(moof, 0x74726166 /* traf */);\n}\nexports.getTRAF = getTRAF;\n/**\n * Returns MDAT Box from the whole ISOBMFF File.\n * Returns null if not found.\n * @param {Uint8Array} buffer\n * @returns {Uint8Array|null}\n */\nfunction getMDAT(buf) {\n    return getBox(buf, 0x6D646174 /* \"mdat\" */);\n}\nexports.getMDAT = getMDAT;\n/**\n * Returns MDIA Box from the whole ISOBMFF File.\n * Returns null if not found.\n * @param {Uint8Array} buffer\n * @returns {Uint8Array|null}\n */\nfunction getMDIA(buf) {\n    var moov = getBox(buf, 0x6d6f6f76 /* moov */);\n    if (!moov) {\n        return null;\n    }\n    var trak = getBox(moov, 0x7472616b /* \"trak\" */);\n    if (!trak) {\n        return null;\n    }\n    return getBox(trak, 0x6d646961 /* \"mdia\" */);\n}\nexports.getMDIA = getMDIA;\n\n\n//# sourceURL=webpack://RxPlayer/./src/parsers/containers/isobmff/read.ts?");

/***/ }),

/***/ "./src/parsers/images/bif.ts":
/*!***********************************!*\
  !*** ./src/parsers/images/bif.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar bytes_1 = __webpack_require__(/*! ../../utils/bytes */ \"./src/utils/bytes.ts\");\n/**\n * @param {UInt8Array} buf\n * @returns {Object}\n */\nfunction parseBif(buf) {\n    var pos = 0;\n    var length = buf.length;\n    var fileFormat = bytes_1.bytesToStr(buf.subarray(pos, pos + 8));\n    pos += 8;\n    var minorVersion = buf[pos];\n    pos += 1;\n    var majorVersion = buf[pos];\n    pos += 1;\n    var patchVersion = buf[pos];\n    pos += 1;\n    var increVersion = buf[pos];\n    pos += 1;\n    var version = [minorVersion, majorVersion, patchVersion, increVersion].join(\".\");\n    var imageCount = buf[pos] + bytes_1.le4toi(buf, pos + 1);\n    pos += 4;\n    var timescale = bytes_1.le4toi(buf, pos);\n    pos += 4;\n    var format = bytes_1.bytesToStr(buf.subarray(pos, pos + 4));\n    pos += 4;\n    var width = bytes_1.le2toi(buf, pos);\n    pos += 2;\n    var height = bytes_1.le2toi(buf, pos);\n    pos += 2;\n    var aspectRatio = [buf[pos], buf[pos + 1]].join(\":\");\n    pos += 2;\n    var isVod = buf[pos] === 1;\n    pos += 1;\n    // bytes 0x1F to 0x40 is unused data for now\n    pos = 0x40;\n    var thumbs = [];\n    var currentImage;\n    var currentTs = 0;\n    if (!imageCount) {\n        throw new Error(\"bif: no images to parse\");\n    }\n    while (pos < length) {\n        var currentImageIndex = bytes_1.le4toi(buf, pos);\n        pos += 4;\n        var currentImageOffset = bytes_1.le4toi(buf, pos);\n        pos += 4;\n        if (currentImage) {\n            var index = currentImage.index;\n            var duration = timescale;\n            var ts = currentTs;\n            var data = buf.subarray(currentImage.offset, currentImageOffset);\n            thumbs.push({ index: index, duration: duration, ts: ts, data: data });\n            currentTs += timescale;\n        }\n        if (currentImageIndex === 0xffffffff) {\n            break;\n        }\n        currentImage = {\n            index: currentImageIndex,\n            offset: currentImageOffset,\n        };\n    }\n    return {\n        fileFormat: fileFormat,\n        version: version,\n        imageCount: imageCount,\n        timescale: timescale,\n        format: format,\n        width: width,\n        height: height,\n        aspectRatio: aspectRatio,\n        isVod: isVod,\n        thumbs: thumbs,\n    };\n}\nexports.default = parseBif;\n\n\n//# sourceURL=webpack://RxPlayer/./src/parsers/images/bif.ts?");

/***/ }),

/***/ "./src/parsers/texttracks/sami/html.ts":
/*!*********************************************!*\
  !*** ./src/parsers/texttracks/sami/html.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// __VERY__ simple SAMI parser, based on ugly-but-working REGEXP:\n//   - the text, start and end times are correctly parsed.\n//   - only text for the given language is parsed.\n//   - only the CSS style associated to the P element is set.\n//   - we should be safe for any XSS.\n// The language indicated to the parser should be present in the CSS and the\n// corresponding Class should be on the P elements. If we fail to find the\n// language in a \"lang\" property of a CSS class, the parser will throw.\nvar assert_1 = __webpack_require__(/*! ../../../utils/assert */ \"./src/utils/assert.ts\");\nvar HTML_ENTITIES = /&#([0-9]+);/g;\nvar BR = /<br>/gi;\nvar STYLE = /<style[^>]*>([\\s\\S]*?)<\\/style[^>]*>/i;\nvar PARAG = /\\s*<p class=([^>]+)>(.*)/i;\nvar START = /<sync[^>]+?start=\"?([0-9]*)\"?[^0-9]/i;\n/**\n * Returns classnames for every languages.\n * @param {string} str\n * @returns {Object}\n */\nfunction getClassNameByLang(str) {\n    var ruleRe = /\\.(\\S+)\\s*{([^}]*)}/gi;\n    var langs = {};\n    var m;\n    while ((m = ruleRe.exec(str))) {\n        var name_1 = m[1];\n        var lang = getCSSProperty(m[2], \"lang\");\n        if (name_1 != null && lang != null) {\n            langs[lang] = name_1;\n        }\n    }\n    return langs;\n}\n/**\n * Returns the rules defined for the P element.\n * Empty string if not found.\n * @param {string} str - The entire styling part.\n * @returns {string}\n */\nfunction getPCSSRules(str) {\n    var pRuleRegex = /p\\s*{([^}]*)}/gi;\n    var rule = pRuleRegex.exec(str);\n    if (!rule) {\n        return \"\";\n    }\n    return rule[1];\n}\n/**\n * @param {string} str - entire CSS rule\n * @param {string} name - name of the property\n * @returns {string|null} - value of the property. Null if not found.\n */\nfunction getCSSProperty(str, name) {\n    var matches = str.match(new RegExp(\"\\\\s*\" + name + \":\\\\s*(\\\\S+);\", \"i\"));\n    return matches ? matches[1] : null;\n}\n/**\n * @param {string} text\n * @returns {string}\n */\nfunction decodeEntities(text) {\n    return text\n        .replace(HTML_ENTITIES, function (_, $1) { return String.fromCharCode($1); });\n}\n/**\n * Because sami is not really html... we have to use\n * some kind of regular expressions to parse it...\n * the cthulhu way :)\n * The specification being quite clunky, this parser\n * may not work for every sami input.\n *\n * @param {string} smi\n * @param {Number} timeOffset\n * @param {string} lang\n */\nfunction parseSami(smi, timeOffset, lang) {\n    var syncOpen = /<sync[ >]/ig;\n    var syncClose = /<sync[ >]|<\\/body>/ig;\n    var subs = [];\n    var styleMatches = smi.match(STYLE);\n    var css = styleMatches ? styleMatches[1] : \"\";\n    var up;\n    var to;\n    // XXX TODO FIXME Is that wanted?\n    // previously written as let to = SyncClose.exec(smi); but never used\n    syncClose.exec(smi);\n    var langs = getClassNameByLang(css);\n    var pCSS = getPCSSRules(css);\n    var klass = langs[lang];\n    assert_1.default(!!klass, \"sami: could not find lang \" + lang + \" in CSS\");\n    for (;;) {\n        up = syncOpen.exec(smi);\n        to = syncClose.exec(smi);\n        if (!up && !to) {\n            break;\n        }\n        if (!up || !to || up.index >= to.index) {\n            throw new Error(\"parse error\");\n        }\n        var str = smi.slice(up.index, to.index);\n        var tim = str.match(START);\n        if (!tim) {\n            throw new Error(\"parse error (sync time attribute)\");\n        }\n        var start = +tim[1];\n        if (isNaN(start)) {\n            throw new Error(\"parse error (sync time attribute NaN)\");\n        }\n        appendToSubs(str.split(\"\\n\"), start / 1000);\n    }\n    return subs;\n    function appendToSubs(lines, start) {\n        var i = lines.length;\n        while (--i >= 0) {\n            var paragraphInfos = lines[i].match(PARAG);\n            if (!paragraphInfos) {\n                continue;\n            }\n            var className = paragraphInfos[1], txt = paragraphInfos[2];\n            if (klass !== className) {\n                continue;\n            }\n            if (txt === \"&nbsp;\") {\n                subs[subs.length - 1].end = start;\n            }\n            else {\n                var wrapperEl = document.createElement(\"DIV\");\n                wrapperEl.className = \"rxp-texttrack-region\";\n                var divEl = document.createElement(\"DIV\");\n                divEl.className = \"rxp-texttrack-div\";\n                divEl.style.position = \"absolute\";\n                divEl.style.bottom = \"0\";\n                divEl.style.width = \"100%\";\n                divEl.style.color = \"#fff\";\n                divEl.style.textShadow = \"-1px -1px 0 #000,\" +\n                    \"1px -1px 0 #000,\" +\n                    \"-1px 1px 0 #000,\" +\n                    \"1px 1px 0 #000\";\n                var pEl = document.createElement(\"div\");\n                pEl.className = \"rxp-texttrack-p\";\n                if (pCSS) {\n                    pEl.style.cssText = pCSS;\n                }\n                var textEls = txt.split(BR);\n                for (var j = 0; j < textEls.length; j++) {\n                    if (j) {\n                        pEl.appendChild(document.createElement(\"BR\"));\n                    }\n                    var spanEl = document.createElement(\"SPAN\");\n                    spanEl.className = \"rxp-texttrack-span\";\n                    spanEl.textContent = decodeEntities(textEls[j]);\n                    pEl.appendChild(spanEl);\n                }\n                divEl.appendChild(pEl);\n                wrapperEl.appendChild(divEl);\n                subs.push({\n                    element: wrapperEl,\n                    start: start + timeOffset,\n                    end: -1,\n                });\n            }\n        }\n    }\n}\nexports.default = parseSami;\n\n\n//# sourceURL=webpack://RxPlayer/./src/parsers/texttracks/sami/html.ts?");

/***/ }),

/***/ "./src/parsers/texttracks/sami/native.ts":
/*!***********************************************!*\
  !*** ./src/parsers/texttracks/sami/native.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar compat_1 = __webpack_require__(/*! ../../../compat */ \"./src/compat/index.ts\");\nvar assert_1 = __webpack_require__(/*! ../../../utils/assert */ \"./src/utils/assert.ts\");\nvar HTML_ENTITIES = /&#([0-9]+);/g;\nvar BR = /<br>/gi;\nvar STYLE = /<style[^>]*>([\\s\\S]*?)<\\/style[^>]*>/i;\nvar PARAG = /\\s*<p class=([^>]+)>(.*)/i;\nvar START = /<sync[^>]+?start=\"?([0-9]*)\"?[^0-9]/i;\n/**\n * Creates an array of VTTCue/TextTrackCue from a given array of cue objects.\n * @param {Array.<Object>} cuesArray - Objects containing the start, end and\n * text.\n * @returns {Array.<VTTCue>}\n */\nfunction createCuesFromArray(cuesArray) {\n    var nativeCues = [];\n    for (var i = 0; i < cuesArray.length; i++) {\n        var _a = cuesArray[i], start = _a.start, end = _a.end, text = _a.text;\n        if (text && end != null) {\n            var cue = compat_1.makeCue(start, end, text);\n            if (cue != null) {\n                nativeCues.push(cue);\n            }\n        }\n    }\n    return nativeCues;\n}\n/**\n * Returns classnames for every languages.\n * @param {string} str\n * @returns {Object}\n */\nfunction getClassNameByLang(str) {\n    var ruleRe = /\\.(\\S+)\\s*{([^}]*)}/gi;\n    var langs = {};\n    var m;\n    while ((m = ruleRe.exec(str))) {\n        var name_1 = m[1];\n        var lang = getCSSProperty(m[2], \"lang\");\n        if (name_1 != null && lang != null) {\n            langs[lang] = name_1;\n        }\n    }\n    return langs;\n}\n/**\n * @param {string} str - entire CSS rule\n * @param {string} name - name of the property\n * @returns {string|null} - value of the property. Null if not found.\n */\nfunction getCSSProperty(str, name) {\n    var matches = str.match(new RegExp(\"\\\\s*\" + name + \":\\\\s*(\\\\S+);\", \"i\"));\n    return matches ? matches[1] : null;\n}\n/**\n * Decode HMTL formatting into a string.\n * @param {string} text\n * @returns {string}\n */\nfunction decodeEntities(text) {\n    return text\n        .replace(BR, \"\\n\")\n        .replace(HTML_ENTITIES, function (_, $1) { return String.fromCharCode($1); });\n}\n/**\n * Because sami is not really html... we have to use\n * some kind of regular expressions to parse it...\n * the cthulhu way :)\n * The specification being quite clunky, this parser\n * may not work for every sami input.\n *\n * @param {string} smi\n * @param {Number} timeOffset\n * @param {string} lang\n * @returns {Array.<VTTCue|TextTrackCue>}\n */\nfunction parseSami(smi, timeOffset, lang) {\n    var syncOpen = /<sync[ >]/ig;\n    var syncClose = /<sync[ >]|<\\/body>/ig;\n    var subs = [];\n    var styleMatches = smi.match(STYLE);\n    var css = styleMatches ? styleMatches[1] : \"\";\n    var up;\n    var to;\n    // XXX TODO FIXME Is that wanted?\n    // previously written as let to = SyncClose.exec(smi); but never used\n    syncClose.exec(smi);\n    var langs = getClassNameByLang(css);\n    var klass = langs[lang];\n    assert_1.default(!!klass, \"sami: could not find lang \" + lang + \" in CSS\");\n    for (;;) {\n        up = syncOpen.exec(smi);\n        to = syncClose.exec(smi);\n        if (!up && !to) {\n            break;\n        }\n        if (!up || !to || up.index >= to.index) {\n            throw new Error(\"parse error\");\n        }\n        var str = smi.slice(up.index, to.index);\n        var tim = str.match(START);\n        if (!tim) {\n            throw new Error(\"parse error (sync time attribute)\");\n        }\n        var start = +tim[1];\n        if (isNaN(start)) {\n            throw new Error(\"parse error (sync time attribute NaN)\");\n        }\n        appendToSubs(str.split(\"\\n\"), start / 1000);\n    }\n    return createCuesFromArray(subs);\n    function appendToSubs(lines, start) {\n        var i = lines.length;\n        var m;\n        while (--i >= 0) {\n            m = lines[i].match(PARAG);\n            if (!m) {\n                continue;\n            }\n            var kl = m[1], txt = m[2];\n            if (klass !== kl) {\n                continue;\n            }\n            if (txt === \"&nbsp;\") {\n                subs[subs.length - 1].end = start;\n            }\n            else {\n                subs.push({\n                    text: decodeEntities(txt),\n                    start: start + timeOffset,\n                });\n            }\n        }\n    }\n}\nexports.default = parseSami;\n\n\n//# sourceURL=webpack://RxPlayer/./src/parsers/texttracks/sami/native.ts?");

/***/ }),

/***/ "./src/parsers/texttracks/srt/html.ts":
/*!********************************************!*\
  !*** ./src/parsers/texttracks/srt/html.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// Parse SRT subtitles into HTML.\n// Done for fun. Understand <b>, <i>, <u> and <font color=\"#ff0000\" /> type\n// of tags.\nvar parseTimestamp_1 = __webpack_require__(/*! ./parseTimestamp */ \"./src/parsers/texttracks/srt/parseTimestamp.ts\");\n/**\n * @param {string} srtStr\n * @param {Number} timeOffset\n * @returns {Array.<Object>}\n */\nfunction parseSRTStringToHTML(srtStr, timeOffset) {\n    // Even if srt only authorize CRLF, we will also take LF or CR as line\n    // terminators for resilience\n    var lines = srtStr.split(/\\r\\n|\\n|\\r/);\n    var cueBlocks = [];\n    for (var i = 0; i < lines.length; i++) {\n        if (lines[i]) {\n            var startingI = i;\n            i++;\n            while (lines[i]) {\n                i++;\n            }\n            cueBlocks.push(lines.slice(startingI, i));\n        }\n    }\n    var cues = [];\n    for (var i = 0; i < cueBlocks.length; i++) {\n        var cue = parseCue(cueBlocks[i], timeOffset);\n        if (cue) {\n            cues.push(cue);\n        }\n    }\n    return cues;\n}\nexports.default = parseSRTStringToHTML;\n/**\n * @param {Array.<string>} cueLines\n * @param {Number} timeOffset\n * @returns {Object|null}\n */\nfunction parseCue(cueLines, timeOffset) {\n    var _a = cueLines[1].split(\" --> \"), startString = _a[0], endString = _a[1];\n    var payloadLines = cueLines.slice(2, cueLines.length);\n    if (!startString || !endString || !payloadLines.length) {\n        return null;\n    }\n    var start = parseTimestamp_1.default(startString);\n    var end = parseTimestamp_1.default(endString);\n    if (start == null || end == null) {\n        return null;\n    }\n    var pEl = document.createElement(\"div\");\n    pEl.className = \"rxp-texttrack-p\";\n    pEl.style.fontSize = \"28px\";\n    pEl.style.position = \"absolute\";\n    pEl.style.bottom = \"5%\";\n    pEl.style.width = \"100%\";\n    pEl.style.textAlign = \"center\";\n    pEl.style.color = \"#fff\";\n    pEl.style.textShadow = \"-1px -1px 2px #000,\" +\n        \"1px -1px 2px #000,\" +\n        \"-1px 1px 2px #000,\" +\n        \"1px 1px 2px #000\";\n    for (var i = 0; i < payloadLines.length; i++) {\n        if (i) {\n            pEl.appendChild(document.createElement(\"br\"));\n        }\n        var span = generateSpansFromSRTText(payloadLines[i]);\n        pEl.appendChild(span);\n    }\n    return {\n        start: start + timeOffset,\n        end: end + timeOffset,\n        element: pEl,\n    };\n}\n/**\n * Take a single srt line and convert it into a span with the right style while\n * avoiding XSS.\n * What we do is set a whitelist of authorized tags, and recreate the\n * corresponding tag from scratch.\n * Supported tags:\n *   - <b>: make content bold\n *   - <i>: make content italic\n *   - <u>: draw underline on content\n *   - <font color=\"x\">: add color x to the content\n * @param {string} text\n * @returns {HTMLElement}\n */\nfunction generateSpansFromSRTText(text) {\n    var secureDiv = document.createElement(\"div\");\n    secureDiv.innerHTML = text;\n    var _loop = function (node) {\n        var childNodes = node.childNodes;\n        var span = document.createElement(\"span\");\n        span.className = \"rxp-texttrack-span\";\n        for (var i = 0; i < childNodes.length; i++) {\n            var currentNode = childNodes[i];\n            if (currentNode.nodeName === \"#text\") {\n                span.innerHTML += currentNode.textContent;\n            }\n            else if (currentNode.nodeName === \"B\") {\n                var spanChild = _loop(currentNode);\n                spanChild.style.fontWeight = \"bold\";\n                span.appendChild(spanChild);\n            }\n            else if (currentNode.nodeName === \"I\") {\n                var spanChild = _loop(currentNode);\n                spanChild.style.fontStyle = \"italic\";\n                span.appendChild(spanChild);\n            }\n            else if (currentNode.nodeName === \"U\") {\n                var spanChild = _loop(currentNode);\n                spanChild.style.textDecoration = \"underline\";\n                span.appendChild(spanChild);\n            }\n            else if (currentNode.nodeName === \"FONT\" &&\n                currentNode.color != null) {\n                // TODO loop through attributes to find color?\n                var spanChild = _loop(currentNode);\n                spanChild.style.color = currentNode.color;\n                span.appendChild(spanChild);\n            }\n            else {\n                var spanChild = _loop(currentNode);\n                span.appendChild(spanChild);\n            }\n        }\n        return span;\n    };\n    return _loop(secureDiv);\n}\n\n\n//# sourceURL=webpack://RxPlayer/./src/parsers/texttracks/srt/html.ts?");

/***/ }),

/***/ "./src/parsers/texttracks/srt/native.ts":
/*!**********************************************!*\
  !*** ./src/parsers/texttracks/srt/native.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// srt to VTTCue parser, Done for fun.\n// Heavily inspired from the WebVTT implementation\nvar index_1 = __webpack_require__(/*! ../../../compat/index */ \"./src/compat/index.ts\");\nvar parseTimestamp_1 = __webpack_require__(/*! ./parseTimestamp */ \"./src/parsers/texttracks/srt/parseTimestamp.ts\");\n/**\n * Parse whole srt file into an array of cues, to be inserted in a video's\n * TrackElement.\n * @param {string} srtStr\n * @param {Number} timeOffset\n * @returns {Array.<VTTCue|TextTrackCue>}\n */\nfunction parseSRTStringToVTTCues(srtStr, timeOffset) {\n    // Even if srt only authorize CRLF, we will also take LF or CR as line\n    // terminators for resilience\n    var lines = srtStr.split(/\\r\\n|\\n|\\r/);\n    var cueBlocks = [];\n    for (var i = 0; i < lines.length; i++) {\n        if (lines[i]) {\n            var startingI = i;\n            i++;\n            while (lines[i]) {\n                i++;\n            }\n            cueBlocks.push(lines.slice(startingI, i));\n        }\n    }\n    var cues = [];\n    for (var i = 0; i < cueBlocks.length; i++) {\n        var cue = parseCue(cueBlocks[i], timeOffset);\n        if (cue) {\n            cues.push(cue);\n        }\n    }\n    return cues;\n}\nexports.default = parseSRTStringToVTTCues;\n/**\n * Parse cue block into a cue.\n * @param {Array.<string>} cueLines\n * @param {Number} timeOffset\n * @returns {TextTrackCue|VTTCue|null}\n */\nfunction parseCue(cueLines, timeOffset) {\n    var _a = cueLines[1].split(\" --> \"), startString = _a[0], endString = _a[1];\n    var payloadLines = cueLines.slice(2, cueLines.length);\n    if (!startString || !endString || !payloadLines.length) {\n        return null;\n    }\n    var start = parseTimestamp_1.default(startString);\n    var end = parseTimestamp_1.default(endString);\n    if (start == null || end == null) {\n        return null;\n    }\n    var payload = payloadLines.join(\"\\n\");\n    return index_1.makeCue(start + timeOffset, end + timeOffset, payload);\n}\n\n\n//# sourceURL=webpack://RxPlayer/./src/parsers/texttracks/srt/native.ts?");

/***/ }),

/***/ "./src/parsers/texttracks/srt/parseTimestamp.ts":
/*!******************************************************!*\
  !*** ./src/parsers/texttracks/srt/parseTimestamp.ts ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Parse a single srt timestamp into seconds\n * @param {string} timestampString\n * @returns {Number|undefined}\n */\nfunction parseTimestamp(timestampString) {\n    var splittedTS = timestampString.split(\":\");\n    if (splittedTS[2]) {\n        var hours = parseInt(splittedTS[0], 10);\n        var minutes = parseInt(splittedTS[1], 10);\n        var seconds = parseFloat(splittedTS[2].replace(\",\", \".\"));\n        if (isNaN(hours) || isNaN(minutes) || isNaN(seconds)) {\n            return undefined;\n        }\n        return hours * 60 * 60 + minutes * 60 + seconds;\n    }\n}\nexports.default = parseTimestamp;\n\n\n//# sourceURL=webpack://RxPlayer/./src/parsers/texttracks/srt/parseTimestamp.ts?");

/***/ }),

/***/ "./src/parsers/texttracks/ttml/getParameters.ts":
/*!******************************************************!*\
  !*** ./src/parsers/texttracks/ttml/getParameters.ts ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Returns global parameters from a TTML Document\n * TODO Missing parameters.\n * @param {Element} tt - <tt> node\n * @throws Error - Throws if the spacing style is invalid.\n * @returns {Object} params\n * @returns {Number} params.frameRate\n * @returns {Number} params.subFrameRate\n * @returns {Number} params.tickRate\n * @returns {string} params.spaceStyle\n */\nfunction getParameters(tt) {\n    var parsedFrameRate = tt.getAttribute(\"ttp:frameRate\");\n    var parsedSubFrameRate = tt.getAttribute(\"ttp:subFramRate\");\n    var parsedTickRate = tt.getAttribute(\"ttp:tickRate\");\n    var parsedFrameRateMultiplier = tt.getAttribute(\"ttp:frameRateMultiplier\");\n    var parsedSpaceStyle = tt.getAttribute(\"xml:space\");\n    if (parsedSpaceStyle && parsedSpaceStyle !== \"default\" &&\n        parsedSpaceStyle !== \"preserve\") {\n        throw new Error(\"Invalid spacing style\");\n    }\n    var nbFrameRate = Number(parsedFrameRate) || 30;\n    var nbSubFrameRate = Number(parsedSubFrameRate) || 1;\n    var nbTickRate = Number(parsedTickRate) || 0;\n    var tickRate = nbTickRate;\n    var frameRate = nbFrameRate;\n    var subFrameRate = nbSubFrameRate != null ? nbSubFrameRate : 1;\n    // TypeScript too dumdum here :/\n    var spaceStyle = (parsedSpaceStyle || \"default\");\n    if (nbTickRate === 0) {\n        tickRate = parsedFrameRate ? nbFrameRate * nbSubFrameRate : 1;\n    }\n    if (parsedFrameRateMultiplier) {\n        var multiplierResults = /^(\\d+) (\\d+)$/g.exec(parsedFrameRateMultiplier);\n        if (multiplierResults) {\n            var numerator = Number(multiplierResults[1]);\n            var denominator = Number(multiplierResults[2]);\n            var multiplierNum = numerator / denominator;\n            frameRate = nbFrameRate * multiplierNum;\n        }\n    }\n    return {\n        tickRate: tickRate,\n        frameRate: frameRate,\n        subFrameRate: subFrameRate,\n        spaceStyle: spaceStyle,\n    };\n}\nexports.default = getParameters;\n\n\n//# sourceURL=webpack://RxPlayer/./src/parsers/texttracks/ttml/getParameters.ts?");

/***/ }),

/***/ "./src/parsers/texttracks/ttml/getParentElementsByTagName.ts":
/*!*******************************************************************!*\
  !*** ./src/parsers/texttracks/ttml/getParentElementsByTagName.ts ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Returns the parent elements which have the given tagName, by order of\n * closeness relative to our element.\n * @param {Element|Node} element\n * @param {string} tagName\n * @returns {Array.<Element>}\n */\nfunction getParentElementsByTagName(element, tagName) {\n    if (!(element.parentNode instanceof Element)) {\n        return [];\n    }\n    function constructArray(_element) {\n        var elements = [];\n        if (_element.tagName.toLowerCase() === tagName.toLowerCase()) {\n            elements.push(_element);\n        }\n        var parentNode = _element.parentNode;\n        if (parentNode instanceof Element) {\n            elements.push.apply(elements, constructArray(parentNode));\n        }\n        return elements;\n    }\n    return constructArray(element.parentNode);\n}\nexports.default = getParentElementsByTagName;\n\n\n//# sourceURL=webpack://RxPlayer/./src/parsers/texttracks/ttml/getParentElementsByTagName.ts?");

/***/ }),

/***/ "./src/parsers/texttracks/ttml/getTimeDelimiters.ts":
/*!**********************************************************!*\
  !*** ./src/parsers/texttracks/ttml/getTimeDelimiters.ts ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar time_parsing_1 = __webpack_require__(/*! ./time_parsing */ \"./src/parsers/texttracks/ttml/time_parsing.ts\");\n/**\n * Get start and end time of an element.\n * @param {Element} element\n * @param {Object} ttParams\n * @returns {Object}\n */\nfunction getTimeDelimiters(element, ttParams) {\n    var beginAttr = element.getAttribute(\"begin\");\n    var durationAttr = element.getAttribute(\"dur\");\n    var endAttr = element.getAttribute(\"end\");\n    var start = beginAttr ? time_parsing_1.default(beginAttr, ttParams) : null;\n    var duration = durationAttr ? time_parsing_1.default(durationAttr, ttParams) : null;\n    var parsedEnd = endAttr ? time_parsing_1.default(endAttr, ttParams) : null;\n    if (start == null || (parsedEnd == null && duration == null)) {\n        throw new Error(\"Invalid text cue\");\n    }\n    // TODO Huh? Is TypeScript that dumb here?\n    var end = parsedEnd == null ?\n        start + duration : parsedEnd;\n    return { start: start, end: end };\n}\nexports.default = getTimeDelimiters;\n\n\n//# sourceURL=webpack://RxPlayer/./src/parsers/texttracks/ttml/getTimeDelimiters.ts?");

/***/ }),

/***/ "./src/parsers/texttracks/ttml/html/constants.ts":
/*!*******************************************************!*\
  !*** ./src/parsers/texttracks/ttml/html/constants.ts ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.STYLE_ATTRIBUTES = [\n    \"backgroundColor\",\n    \"color\",\n    \"direction\",\n    \"display\",\n    \"displayAlign\",\n    \"extent\",\n    \"fontFamily\",\n    \"fontSize\",\n    \"fontStyle\",\n    \"fontWeight\",\n    \"lineHeight\",\n    \"opacity\",\n    \"origin\",\n    \"overflow\",\n    \"padding\",\n    \"textAlign\",\n    \"textDecoration\",\n    \"textOutline\",\n    \"unicodeBidi\",\n    \"visibility\",\n    \"wrapOption\",\n    \"writingMode\",\n];\n\n\n//# sourceURL=webpack://RxPlayer/./src/parsers/texttracks/ttml/html/constants.ts?");

/***/ }),

/***/ "./src/parsers/texttracks/ttml/html/createElement.ts":
/*!***********************************************************!*\
  !*** ./src/parsers/texttracks/ttml/html/createElement.ts ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar objectAssign = __webpack_require__(/*! object-assign */ \"./node_modules/object-assign/index.js\");\nvar getParentElementsByTagName_1 = __webpack_require__(/*! ../getParentElementsByTagName */ \"./src/parsers/texttracks/ttml/getParentElementsByTagName.ts\");\nvar regexps_1 = __webpack_require__(/*! ../regexps */ \"./src/parsers/texttracks/ttml/regexps.ts\");\nvar style_1 = __webpack_require__(/*! ../style */ \"./src/parsers/texttracks/ttml/style.ts\");\n// import getAttributeInElements from \"../getAttributeInElements\";\n// Styling which can be applied to <span> from any level upper.\n// Added here as an optimization\nvar SPAN_LEVEL_ATTRIBUTES = [\n    \"color\",\n    \"direction\",\n    \"display\",\n    \"fontFamily\",\n    \"fontSize\",\n    \"fontStyle\",\n    \"fontWeight\",\n    \"textDecoration\",\n    \"textOutline\",\n    \"unicodeBidi\",\n    \"visibility\",\n    \"wrapOption\",\n];\n/**\n * Translate a color indicated in TTML-style to a CSS-style color.\n * @param {string} color\n * @returns {string} color\n */\nfunction ttmlColorToCSSColor(color) {\n    // TODO check all possible color fomats\n    var regRes;\n    regRes = regexps_1.REGXP_8_HEX_COLOR.exec(color);\n    if (regRes != null) {\n        return \"rgba(\" +\n            parseInt(regRes[1], 16) + \",\" +\n            parseInt(regRes[2], 16) + \",\" +\n            parseInt(regRes[3], 16) + \",\" +\n            parseInt(regRes[4], 16) / 255 + \")\";\n    }\n    regRes = regexps_1.REGXP_4_HEX_COLOR.exec(color);\n    if (regRes != null) {\n        return \"rgba(\" +\n            parseInt(regRes[1] + regRes[1], 16) + \",\" +\n            parseInt(regRes[2] + regRes[2], 16) + \",\" +\n            parseInt(regRes[3] + regRes[3], 16) + \",\" +\n            parseInt(regRes[4] + regRes[4], 16) / 255 + \")\";\n    }\n    return color;\n}\n/**\n * Try to replicate the textOutline TTML style property into CSS.\n *\n * We mock it throught the text-shadow property, translating the TTML thickness\n * into blur radius and the blur-radius into... nothing.\n *\n * @param {string} color\n * @param {string|number} thickness\n * @returns {string}\n */\nfunction generateCSSTextOutline(color, thickness) {\n    return \"-1px -1px \" + thickness + \" \" + color + \",\" +\n        (\"1px -1px \" + thickness + \" \" + color + \",\") +\n        (\"-1px 1px \" + thickness + \" \" + color + \",\") +\n        (\"1px 1px \" + thickness + \" \" + color);\n}\n// TODO\n// tts:showBackground (applies to region)\n// tts:zIndex (applies to region)\n/**\n * Apply style set for a singular text span of the current cue.\n * @param {HTMLElement} element - The text span\n * @param {Object} style - The style to apply\n */\nfunction applyTextStyle(element, style) {\n    // applies to span\n    var color = style.color;\n    if (color) {\n        element.style.color = ttmlColorToCSSColor(color);\n    }\n    // applies to body, div, p, region, span\n    var backgroundColor = style.backgroundColor;\n    if (backgroundColor) {\n        element.style.backgroundColor = ttmlColorToCSSColor(backgroundColor);\n    }\n    // applies to span\n    var wrapOption = style.wrapOption;\n    if (wrapOption && wrapOption === \"noWrap\") {\n        element.style.whiteSpace = \"nowrap\";\n    }\n    // applies to span\n    var textOutline = style.textOutline;\n    if (textOutline) {\n        var outlineData = textOutline.trim().replace(/\\s+/g, \" \").split(\" \");\n        var len = outlineData.length;\n        if (len === 3) {\n            var outlineColor = ttmlColorToCSSColor(outlineData[0]);\n            var thickness = outlineData[1];\n            element.style.textShadow =\n                generateCSSTextOutline(outlineColor, thickness);\n        }\n        else if (color && len === 1) {\n            var thickness = outlineData[0];\n            element.style.textShadow = generateCSSTextOutline(color, thickness);\n        }\n        else if (len === 2) {\n            var isFirstArgAColor = /^[#A-Z]/i.test(outlineData[0]);\n            var isFirstArgANumber = /^[0-9]/.test(outlineData[0]);\n            // XOR-ing to be sure we get what we have\n            if (isFirstArgAColor !== isFirstArgANumber) {\n                if (isFirstArgAColor) {\n                    var outlineColor = ttmlColorToCSSColor(outlineData[0]);\n                    var thickness = outlineData[1];\n                    element.style.textShadow =\n                        generateCSSTextOutline(outlineColor, thickness);\n                }\n                else if (color) {\n                    var thickness = outlineData[0];\n                    element.style.textShadow = generateCSSTextOutline(color, thickness);\n                }\n            }\n        }\n    }\n    // applies to span\n    var textDecoration = style.textDecoration;\n    if (textDecoration) {\n        switch (textDecoration) {\n            case \"noUnderline\":\n            case \"noLineThrough\":\n            case \"noOverline\":\n                element.style.textDecoration = \"none\";\n                break;\n            case \"lineThrough\":\n                element.style.textDecoration = \"line-through\";\n                break;\n            default:\n                element.style.textDecoration = textDecoration;\n                break;\n        }\n    }\n    // applies to span\n    var fontFamily = style.fontFamily;\n    if (fontFamily) {\n        switch (fontFamily) {\n            case \"proportionalSansSerif\":\n                element.style.fontFamily =\n                    \"Arial, Helvetica, Liberation Sans, sans-serif\";\n                break;\n            // TODO monospace or sans-serif or font with both?\n            case \"monospaceSansSerif\":\n            case \"sansSerif\":\n                element.style.fontFamily = \"sans-serif\";\n                break;\n            case \"monospaceSerif\":\n            case \"default\":\n                element.style.fontFamily = \"Courier New, Liberation Mono, monospace\";\n                break;\n            // TODO font with both?\n            case \"proportionalSerif\":\n                element.style.fontFamily = \"serif\";\n                break;\n            default:\n                element.style.fontFamily = fontFamily;\n        }\n    }\n    // applies to span\n    var fontStyle = style.fontStyle;\n    if (fontStyle) {\n        element.style.fontStyle = fontStyle;\n    }\n    // applies to span\n    var fontWeight = style.fontWeight;\n    if (fontWeight) {\n        element.style.fontWeight = fontWeight;\n    }\n    // applies to span\n    var fontSize = style.fontSize;\n    if (fontSize) {\n        // TODO Check if formats are always really 1:1\n        element.style.fontSize = fontSize;\n    }\n    // applies to p, span\n    var direction = style.direction;\n    if (direction) {\n        element.style.direction = direction;\n    }\n    // applies to p, span\n    var unicodeBidi = style.unicodeBidi;\n    if (unicodeBidi) {\n        switch (unicodeBidi) {\n            case \"bidiOverride\":\n                element.style.unicodeBidi = \"bidi-override\";\n                break;\n            case \"embed\":\n                element.style.unicodeBidi = \"embed\";\n                break;\n            default:\n                element.style.unicodeBidi = \"normal\";\n        }\n    }\n    // applies to body, div, p, region, span\n    var visibility = style.visibility;\n    if (visibility) {\n        element.style.visibility = visibility;\n    }\n    // applies to body, div, p, region, span\n    var display = style.display;\n    if (display === \"none\") {\n        element.style.display = \"none\";\n    }\n}\n/**\n * Apply style for the general text track div.\n * @param {HTMLElement} element - The <div> the style will be applied on.\n * @param {Object} style - The general style object of the paragraph.\n */\nfunction applyGeneralStyle(element, style) {\n    // applies to tt, region\n    var extent = style.extent;\n    if (extent) {\n        var results = regexps_1.REGXP_PERCENT_VALUES.exec(extent);\n        if (results != null) {\n            element.style.width = results[1] + \"%\";\n            element.style.height = results[2] + \"%\";\n        }\n    }\n    // applies to region\n    var writingMode = style.writingMode;\n    if (writingMode) {\n        // TODO\n    }\n    // applies to region\n    var overflow = style.overflow;\n    element.style.overflow = overflow || \"hidden\";\n    // applies to region\n    var padding = style.padding;\n    if (padding) {\n        element.style.padding = padding;\n    }\n    // applies to region\n    var origin = style.origin;\n    if (origin) {\n        var resultsPercent = regexps_1.REGXP_PERCENT_VALUES.exec(origin);\n        if (resultsPercent != null) {\n            element.style.position = \"relative\";\n            element.style.left = resultsPercent[1] + \"%\";\n            element.style.top = resultsPercent[2] + \"%\";\n        }\n        else {\n            // TODO also px\n        }\n    }\n    // applies to region\n    var displayAlign = style.displayAlign;\n    element.style.display = \"flex\";\n    element.style.flexDirection = \"column\";\n    if (displayAlign) {\n        switch (displayAlign) {\n            case \"before\":\n                element.style.justifyContent = \"flex-start\";\n                break;\n            case \"center\":\n                element.style.justifyContent = \"center\";\n                break;\n            case \"after\":\n                element.style.justifyContent = \"flex-end\";\n                break;\n        }\n    }\n    // applies to region\n    var opacity = style.opacity;\n    if (opacity) {\n        element.style.opacity = opacity;\n    }\n    // applies to body, div, p, region, span\n    var visibility = style.visibility;\n    if (visibility) {\n        element.style.visibility = visibility;\n    }\n    // applies to body, div, p, region, span\n    var display = style.display;\n    if (display === \"none\") {\n        element.style.display = \"none\";\n    }\n}\n/**\n * Apply style set for a <p> element\n * @param {HTMLElement} element - The <p> element\n * @param {Object} style - The general style object of the paragraph.\n */\nfunction applyPStyle(element, style) {\n    // applies to body, div, p, region, span\n    var paragraphBackgroundColor = style.backgroundColor;\n    if (paragraphBackgroundColor) {\n        element.style.backgroundColor =\n            ttmlColorToCSSColor(paragraphBackgroundColor);\n    }\n    // applies to p\n    var lineHeight = style.lineHeight;\n    if (lineHeight) {\n        element.style.lineHeight = lineHeight;\n    }\n    // applies to p\n    var textAlign = style.textAlign;\n    if (textAlign) {\n        switch (textAlign) {\n            case \"center\":\n                element.style.textAlign = \"center\";\n                break;\n            case \"left\":\n            case \"start\":\n                // TODO check what start means (difference with left, writing direction?)\n                element.style.textAlign = \"left\";\n                break;\n            case \"right\":\n            case \"end\":\n                // TODO check what end means (difference with right, writing direction?)\n                element.style.textAlign = \"right\";\n                break;\n        }\n    }\n}\n/**\n * Creates span of text for the given #text element, with the right style.\n *\n * TODO create text elements as string? Might help performances.\n * @param {Element} el - the #text element, which text content should be\n * displayed\n * @param {Object} style - the style object for the given text\n * @param {Array.<Element>} spans - <span> tags which contain the element. In\n * order of closeness (from the closest to the least one)\n * @param {Element|null} p - <p> tag which contain the element.\n * @param {Array.<Element>} divs - <div> tags which contain the element. In\n * order of closeness (from the closest to the least one)\n * @param {Element|null} body - <body> tag which contain the element.\n * @param {Array.<Object>} regions - Every <region> tag which can apply to\n * this element.\n * @param {Array.<Object>} styles - Every <style> tag which can apply to\n * this element.\n * @param {Boolean} shouldTrimWhiteSpaceParam - True if the space should be\n * trimmed by default. From the <tt> xml:space parameter.\n * @returns {HTMLElement}\n */\nfunction createTextElement(el, style, shouldTrimWhiteSpaceParam) {\n    var textElement = document.createElement(\"span\");\n    var textContent = el.textContent || \"\";\n    var shouldTrimWhiteSpace = shouldTrimWhiteSpaceParam;\n    // TODO Also parse it from parent elements\n    // const spaceAttr = getAttributeInElements(\"xml:space\", [\n    //   ...spans, p, ...divs, body,\n    // ]);\n    // const shouldTrimWhiteSpace = spaceAttr ?\n    //   spaceAttr === \"default\" : shouldTrimWhiteSpaceParam;\n    if (shouldTrimWhiteSpace) {\n        // 1. Trim leading and trailing whitespace.\n        // 2. Collapse multiple spaces into one.\n        var trimmed = textContent.trim();\n        trimmed = trimmed.replace(/\\s+/g, \" \");\n        textContent = trimmed;\n    }\n    textElement.innerHTML = textContent;\n    textElement.className = \"rxp-texttrack-span\";\n    applyTextStyle(textElement, style);\n    return textElement;\n}\n/**\n * Generate every text elements to display in a given paragraph.\n * @param {Element} paragraph - The <p> tag.\n * @param {Array.<Object>} regions\n * @param {Array.<Object>} styles\n * @param {Object} paragraphStyle - The general style object of the paragraph.\n * @param {Boolean} shouldTrimWhiteSpace\n * @returns {Array.<HTMLElement>}\n */\nfunction generateTextContent(paragraph, regions, styles, paragraphStyle, shouldTrimWhiteSpace) {\n    /**\n     * Recursive function, taking a node in argument and returning the\n     * corresponding array of HTMLElement in order.\n     * @param {Node} node - the node in question\n     * @param {Object} style - the current state of the style for the node.\n     * /!\\ The style object can be mutated, provide a copy of it.\n     * @param {Array.<Element>} spans - The spans parent of this node.\n     * @returns {Array.<HTMLElement>}\n     */\n    function loop(node, style, spans) {\n        var childNodes = node.childNodes;\n        var elements = [];\n        for (var i = 0; i < childNodes.length; i++) {\n            var currentNode = childNodes[i];\n            if (currentNode.nodeName === \"#text\") {\n                var backgroundColor = style_1.getStylingAttributes([\"backgroundColor\"], spans, styles, regions).backgroundColor;\n                if (backgroundColor) {\n                    style.backgroundColor = backgroundColor;\n                }\n                else {\n                    delete style.backgroundColor;\n                }\n                var el = createTextElement(currentNode, style, shouldTrimWhiteSpace);\n                elements.push(el);\n            }\n            else if (currentNode.nodeName === \"br\") {\n                var br = document.createElement(\"BR\");\n                elements.push(br);\n            }\n            else if (currentNode.nodeName === \"span\" &&\n                currentNode.childNodes.length > 0) {\n                // compute the new applyable style\n                var newStyle = objectAssign({}, style, style_1.getStylingAttributes(SPAN_LEVEL_ATTRIBUTES, [currentNode], styles, regions));\n                elements.push.apply(elements, loop(currentNode, newStyle, [currentNode].concat(spans)));\n            }\n        }\n        return elements;\n    }\n    return loop(paragraph, objectAssign({}, paragraphStyle), []);\n}\n/**\n * @param {Element} paragraph\n * @param {Element} body\n * @param {Array.<Object>} regions\n * @param {Array.<Object>} styles\n * @param {Object} styles\n * @param {Boolean} shouldTrimWhiteSpace\n * @returns {HTMLElement}\n */\nfunction createElement(paragraph, body, regions, styles, paragraphStyle, shouldTrimWhiteSpace) {\n    var divs = getParentElementsByTagName_1.default(paragraph, \"div\");\n    var parentElement = document.createElement(\"DIV\");\n    parentElement.className = \"rxp-texttrack-region\";\n    applyGeneralStyle(parentElement, paragraphStyle);\n    if (body) {\n        // applies to body, div, p, region, span\n        var bodyBackgroundColor = style_1.getStylingAttributes([\"backgroundColor\"], divs.concat([body]), styles, regions).bodyBackgroundColor;\n        if (bodyBackgroundColor) {\n            parentElement.style.backgroundColor =\n                ttmlColorToCSSColor(bodyBackgroundColor);\n        }\n    }\n    var pElement = document.createElement(\"p\");\n    pElement.className = \"rxp-texttrack-p\";\n    applyPStyle(pElement, paragraphStyle);\n    var textContent = generateTextContent(paragraph, regions, styles, paragraphStyle, shouldTrimWhiteSpace);\n    for (var i = 0; i < textContent.length; i++) {\n        pElement.appendChild(textContent[i]);\n    }\n    // NOTE:\n    // The following code is for the inclusion of div elements. This has no\n    // advantage for now, and might only with future evolutions.\n    // (This is only an indication of what the base of the code could look like).\n    // if (divs.length) {\n    //   let container = parentElement;\n    //   for (let i = divs.length - 1; i >= 0; i--) {\n    //     // TODO manage style at div level?\n    //     // They are: visibility, display and backgroundColor\n    //     // All these do not have any difference if applied to the <p> element\n    //     // instead of the div.\n    //     // The advantage might only be for multiple <p> elements dispatched\n    //     // in multiple div Which we do not manage anyway for now.\n    //     const divEl = document.createElement(\"DIV\");\n    //     divEl.className = \"rxp-texttrack-div\";\n    //     container.appendChild(divEl);\n    //     container = divEl;\n    //   }\n    //   container.appendChild(pElement);\n    //   parentElement.appendChild(container);\n    // } else {\n    //   parentElement.appendChild(pElement);\n    // }\n    parentElement.appendChild(pElement);\n    return parentElement;\n}\nexports.default = createElement;\n\n\n//# sourceURL=webpack://RxPlayer/./src/parsers/texttracks/ttml/html/createElement.ts?");

/***/ }),

/***/ "./src/parsers/texttracks/ttml/html/index.ts":
/*!***************************************************!*\
  !*** ./src/parsers/texttracks/ttml/html/index.ts ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar arrayFind = __webpack_require__(/*! array-find */ \"./node_modules/array-find/find.js\");\nvar objectAssign = __webpack_require__(/*! object-assign */ \"./node_modules/object-assign/index.js\");\nvar getParameters_1 = __webpack_require__(/*! ../getParameters */ \"./src/parsers/texttracks/ttml/getParameters.ts\");\nvar getParentElementsByTagName_1 = __webpack_require__(/*! ../getParentElementsByTagName */ \"./src/parsers/texttracks/ttml/getParentElementsByTagName.ts\");\nvar nodes_1 = __webpack_require__(/*! ../nodes */ \"./src/parsers/texttracks/ttml/nodes.ts\");\nvar style_1 = __webpack_require__(/*! ../style */ \"./src/parsers/texttracks/ttml/style.ts\");\nvar constants_1 = __webpack_require__(/*! ./constants */ \"./src/parsers/texttracks/ttml/html/constants.ts\");\nvar parseCue_1 = __webpack_require__(/*! ./parseCue */ \"./src/parsers/texttracks/ttml/html/parseCue.ts\");\n/**\n * Create array of objects which should represent the given TTML text track.\n * These objects have the following structure\n *   - start {Number}: start time, in seconds, at which the cue should\n *     be displayed\n *   - end {Number}: end time, in seconds, at which the cue should\n *     be displayed\n *   - element {HTMLElement}: <div> element representing the cue, with the\n *     right style. This div should then be appended to an element having\n *     the exact size of the wanted region the text track provide cues for.\n *\n * TODO TTML parsing is still pretty heavy on the CPU.\n * Optimizations have been done, principally to avoid using too much XML APIs,\n * but we can still do better.\n * @param {string} str\n * @param {Number} timeOffset\n * @returns {Array.<Object>}\n */\nfunction parseTTMLStringToDIV(str, timeOffset) {\n    var ret = [];\n    var xml = new DOMParser().parseFromString(str, \"text/xml\");\n    if (xml) {\n        var tts = xml.getElementsByTagName(\"tt\");\n        var tt = tts[0];\n        if (!tt) {\n            throw new Error(\"invalid XML\");\n        }\n        var body = nodes_1.getBodyNode(tt);\n        var styleNodes = nodes_1.getStyleNodes(tt);\n        var regionNodes = nodes_1.getRegionNodes(tt);\n        var textNodes = nodes_1.getTextNodes(tt);\n        var params = getParameters_1.default(tt);\n        // construct styles array based on the xml as an optimization\n        var styles = [];\n        for (var i = 0; i <= styleNodes.length - 1; i++) {\n            var styleNode = styleNodes[i];\n            if (styleNode instanceof Element) {\n                var styleID = styleNode.getAttribute(\"xml:id\");\n                if (styleID !== null) {\n                    // TODO styles referencing other styles\n                    styles.push({\n                        id: styleID,\n                        style: style_1.getStylingFromElement(styleNode),\n                    });\n                }\n            }\n        }\n        // construct regions array based on the xml as an optimization\n        var regions = [];\n        var _loop_1 = function (i) {\n            var regionNode = regionNodes[i];\n            if (regionNode instanceof Element) {\n                var regionID = regionNode.getAttribute(\"xml:id\");\n                if (regionID !== null) {\n                    var regionStyle = style_1.getStylingFromElement(regionNode);\n                    var associatedStyle_1 = regionNode.getAttribute(\"style\");\n                    if (associatedStyle_1) {\n                        var style = arrayFind(styles, function (x) { return x.id === associatedStyle_1; });\n                        if (style) {\n                            regionStyle = objectAssign({}, style.style, regionStyle);\n                        }\n                    }\n                    regions.push({\n                        id: regionID,\n                        style: regionStyle,\n                    });\n                }\n            }\n        };\n        for (var i = 0; i <= regionNodes.length - 1; i++) {\n            _loop_1(i);\n        }\n        // Computing the style takes a lot of ressources.\n        // To avoid too much re-computation, let's compute the body style right\n        // now and do the rest progressively.\n        // TODO Compute corresponding CSS style here (as soon as we now the TTML\n        // style) to speed up the process even\n        // more.\n        var bodyStyle = body !== null ?\n            style_1.getStylingAttributes(constants_1.STYLE_ATTRIBUTES, [body], styles, regions) :\n            style_1.getStylingAttributes(constants_1.STYLE_ATTRIBUTES, [], styles, regions);\n        for (var i = 0; i < textNodes.length; i++) {\n            var paragraph = textNodes[i];\n            if (paragraph instanceof Element) {\n                var divs = getParentElementsByTagName_1.default(paragraph, \"div\");\n                var paragraphStyle = objectAssign({}, bodyStyle, style_1.getStylingAttributes(constants_1.STYLE_ATTRIBUTES, [paragraph].concat(divs), styles, regions));\n                var cue = parseCue_1.default(paragraph, timeOffset, styles, regions, body, paragraphStyle, params);\n                if (cue) {\n                    ret.push(cue);\n                }\n            }\n        }\n    }\n    return ret;\n}\nexports.default = parseTTMLStringToDIV;\n\n\n//# sourceURL=webpack://RxPlayer/./src/parsers/texttracks/ttml/html/index.ts?");

/***/ }),

/***/ "./src/parsers/texttracks/ttml/html/parseCue.ts":
/*!******************************************************!*\
  !*** ./src/parsers/texttracks/ttml/html/parseCue.ts ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar getTimeDelimiters_1 = __webpack_require__(/*! ../getTimeDelimiters */ \"./src/parsers/texttracks/ttml/getTimeDelimiters.ts\");\nvar createElement_1 = __webpack_require__(/*! ./createElement */ \"./src/parsers/texttracks/ttml/html/createElement.ts\");\n/**\n * @param {Element} paragraph\n * @param {Number} offset\n * @param {Array.<Object>} styles\n * @param {Array.<Object>} regions\n * @param {Element} body\n * @param {Object} styleBase\n * @param {Object} ttParams\n * @returns {Object|null}\n */\nfunction parseCue(paragraph, offset, styles, regions, body, styleBase, ttParams) {\n    // Disregard empty elements:\n    // TTML allows for empty elements like <div></div>.\n    // If paragraph has neither time attributes, nor\n    // non-whitespace text, don't try to make a cue out of it.\n    if (!paragraph.hasAttribute(\"begin\") && !paragraph.hasAttribute(\"end\") &&\n        /^\\s*$/.test(paragraph.textContent || \"\")) {\n        return null;\n    }\n    var _a = getTimeDelimiters_1.default(paragraph, ttParams), start = _a.start, end = _a.end;\n    var element = createElement_1.default(paragraph, body, regions, styles, styleBase, ttParams.spaceStyle === \"default\");\n    return {\n        start: start + offset,\n        end: end + offset,\n        element: element,\n    };\n}\nexports.default = parseCue;\n\n\n//# sourceURL=webpack://RxPlayer/./src/parsers/texttracks/ttml/html/parseCue.ts?");

/***/ }),

/***/ "./src/parsers/texttracks/ttml/native/index.ts":
/*!*****************************************************!*\
  !*** ./src/parsers/texttracks/ttml/native/index.ts ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar arrayFind = __webpack_require__(/*! array-find */ \"./node_modules/array-find/find.js\");\nvar objectAssign = __webpack_require__(/*! object-assign */ \"./node_modules/object-assign/index.js\");\nvar compat_1 = __webpack_require__(/*! ../../../../compat */ \"./src/compat/index.ts\");\nvar getParameters_1 = __webpack_require__(/*! ../getParameters */ \"./src/parsers/texttracks/ttml/getParameters.ts\");\nvar getParentElementsByTagName_1 = __webpack_require__(/*! ../getParentElementsByTagName */ \"./src/parsers/texttracks/ttml/getParentElementsByTagName.ts\");\nvar getTimeDelimiters_1 = __webpack_require__(/*! ../getTimeDelimiters */ \"./src/parsers/texttracks/ttml/getTimeDelimiters.ts\");\nvar nodes_1 = __webpack_require__(/*! ../nodes */ \"./src/parsers/texttracks/ttml/nodes.ts\");\nvar regexps_1 = __webpack_require__(/*! ../regexps */ \"./src/parsers/texttracks/ttml/regexps.ts\");\nvar style_1 = __webpack_require__(/*! ../style */ \"./src/parsers/texttracks/ttml/style.ts\");\n/**\n * Style attributes currently used.\n */\nvar WANTED_STYLE_ATTRIBUTES = [\n    \"extent\",\n    \"writingMode\",\n    \"origin\",\n    \"align\",\n];\n/**\n * @type {Object}\n */\nvar TEXT_ALIGN_TO_LIGN_ALIGN = {\n    left: \"start\",\n    center: \"center\",\n    right: \"end\",\n    start: \"start\",\n    end: \"end\",\n};\n/**\n * @type {Object}\n */\nvar TEXT_ALIGN_TO_POSITION_ALIGN = {\n    left: \"line-left\",\n    center: \"center\",\n    right: \"line-right\",\n};\n/**\n * @param {string} str\n * @param {Number} timeOffset\n * @returns {Array.<VTTCue|TextTrackCue>}\n */\nfunction parseTTMLStringToVTT(str, timeOffset) {\n    var ret = [];\n    var xml = new DOMParser().parseFromString(str, \"text/xml\");\n    if (xml) {\n        var tts = xml.getElementsByTagName(\"tt\");\n        var tt = tts[0];\n        if (!tt) {\n            throw new Error(\"invalid XML\");\n        }\n        var body = nodes_1.getBodyNode(tt);\n        var styleNodes = nodes_1.getStyleNodes(tt);\n        var regionNodes = nodes_1.getRegionNodes(tt);\n        var textNodes = nodes_1.getTextNodes(tt);\n        var params = getParameters_1.default(tt);\n        // construct styles array based on the xml as an optimization\n        var styles = [];\n        for (var i = 0; i <= styleNodes.length - 1; i++) {\n            // TODO styles referencing other styles\n            var styleNode = styleNodes[i];\n            if (styleNode instanceof Element) {\n                var styleID = styleNode.getAttribute(\"xml:id\");\n                if (styleID != null) {\n                    styles.push({\n                        id: styleID,\n                        style: style_1.getStylingFromElement(styleNode),\n                    });\n                }\n            }\n        }\n        // construct regions array based on the xml as an optimization\n        var regions = [];\n        var _loop_1 = function (i) {\n            var regionNode = regionNodes[i];\n            if (regionNode instanceof Element) {\n                var regionID = regionNode.getAttribute(\"xml:id\");\n                if (regionID != null) {\n                    var regionStyle = style_1.getStylingFromElement(regionNode);\n                    var associatedStyle_1 = regionNode.getAttribute(\"style\");\n                    if (associatedStyle_1) {\n                        var style = arrayFind(styles, function (x) { return x.id === associatedStyle_1; });\n                        if (style) {\n                            regionStyle = objectAssign({}, style.style, regionStyle);\n                        }\n                    }\n                    regions.push({\n                        id: regionID,\n                        style: regionStyle,\n                    });\n                }\n            }\n        };\n        for (var i = 0; i <= regionNodes.length - 1; i++) {\n            _loop_1(i);\n        }\n        // Computing the style takes a lot of ressources.\n        // To avoid too much re-computation, let's compute the body style right\n        // now and do the rest progressively.\n        var bodyStyle = body ?\n            style_1.getStylingAttributes(WANTED_STYLE_ATTRIBUTES, [body], styles, regions) :\n            style_1.getStylingAttributes(WANTED_STYLE_ATTRIBUTES, [], styles, regions);\n        for (var i = 0; i < textNodes.length; i++) {\n            var paragraph = textNodes[i];\n            if (paragraph instanceof Element) {\n                var divs = getParentElementsByTagName_1.default(paragraph, \"div\");\n                var paragraphStyle = objectAssign({}, bodyStyle, style_1.getStylingAttributes(WANTED_STYLE_ATTRIBUTES, [paragraph].concat(divs), styles, regions));\n                var cue = parseCue(paragraph, timeOffset, styles, regions, paragraphStyle, params);\n                if (cue) {\n                    ret.push(cue);\n                }\n            }\n        }\n    }\n    return ret;\n}\n/**\n * Parses an Element into a TextTrackCue or VTTCue.\n * /!\\ Mutates the given cueElement Element\n * @param {Element} paragraph\n * @param {Number} offset\n * @param {Array.<Object>} styles\n * @param {Array.<Object>} regions\n * @param {Object} paragraphStyle\n * @param {Object} params\n * @returns {TextTrackCue|null}\n */\nfunction parseCue(paragraph, offset, _styles, _regions, paragraphStyle, params) {\n    // Disregard empty elements:\n    // TTML allows for empty elements like <div></div>.\n    // If paragraph has neither time attributes, nor\n    // non-whitespace text, don't try to make a cue out of it.\n    if (!paragraph.hasAttribute(\"begin\") && !paragraph.hasAttribute(\"end\") &&\n        /^\\s*$/.test(paragraph.textContent || \"\")) {\n        return null;\n    }\n    var _a = getTimeDelimiters_1.default(paragraph, params), start = _a.start, end = _a.end;\n    var text = generateTextContent(paragraph, params.spaceStyle === \"default\");\n    var cue = compat_1.makeCue(start + offset, end + offset, text);\n    if (!cue) {\n        return null;\n    }\n    if (cue instanceof VTTCue) {\n        addStyle(cue, paragraphStyle);\n    }\n    return cue;\n}\n/**\n * Generate text to display for a given paragraph.\n * @param {Element} paragraph - The <p> tag.\n * @param {Boolean} shouldTrimWhiteSpace\n * @returns {string}\n */\nfunction generateTextContent(paragraph, shouldTrimWhiteSpace) {\n    /**\n     * Recursive function, taking a node in argument and returning the\n     * corresponding string.\n     * @param {Node} node - the node in question\n     * @returns {string}\n     */\n    function loop(node) {\n        var childNodes = node.childNodes;\n        var text = \"\";\n        for (var i = 0; i < childNodes.length; i++) {\n            var currentNode = childNodes[i];\n            if (currentNode.nodeName === \"#text\") {\n                var textContent = currentNode.textContent || \"\";\n                // TODO Also parse it from parent elements\n                // const spaceAttr = getAttribute(\"xml:space\", [\n                //   ...spans, p, ...divs, body,\n                // ]);\n                // const shouldTrimWhiteSpace = spaceAttr ?\n                //   spaceAttr === \"default\" : shouldTrimWhiteSpaceParam;\n                if (shouldTrimWhiteSpace) {\n                    // 1. Trim leading and trailing whitespace.\n                    // 2. Collapse multiple spaces into one.\n                    var trimmed = textContent.trim();\n                    trimmed = trimmed.replace(/\\s+/g, \" \");\n                    textContent = trimmed;\n                }\n                text += textContent;\n            }\n            else if (currentNode.nodeName === \"br\") {\n                text += \"\\n\";\n            }\n            else if (currentNode.nodeName === \"span\" &&\n                currentNode.childNodes.length > 0) {\n                text += loop(currentNode);\n            }\n        }\n        return text;\n    }\n    return loop(paragraph);\n}\n/**\n * Adds applicable style properties to a cue.\n * /!\\ Mutates cue argument.\n * @param {VTTCue} cue\n * @param {Object} style\n */\nfunction addStyle(cue, style) {\n    var extent = style.extent;\n    if (extent) {\n        var results = regexps_1.REGXP_PERCENT_VALUES.exec(extent);\n        if (results != null) {\n            // Use width value of the extent attribute for size.\n            // Height value is ignored.\n            cue.size = Number(results[1]);\n        }\n    }\n    var writingMode = style.writingMode;\n    // let isVerticalText = true;\n    switch (writingMode) {\n        case \"tb\":\n        case \"tblr\":\n            cue.vertical = \"lr\";\n            break;\n        case \"tbrl\":\n            cue.vertical = \"rl\";\n            break;\n        default:\n            // isVerticalText = false;\n            break;\n    }\n    var origin = style.origin;\n    if (origin) {\n        var results = regexps_1.REGXP_PERCENT_VALUES.exec(origin);\n        if (results != null) {\n            // for vertical text use first coordinate of tts:origin\n            // to represent line of the cue and second - for position.\n            // Otherwise (horizontal), use them the other way around.\n            // if (isVerticalText) {\n            // TODO check and uncomment\n            // cue.position = Number(results[2]);\n            // cue.line = Number(results[1]);\n            // } else {\n            // TODO check and uncomment\n            // cue.position = Number(results[1]);\n            // cue.line = Number(results[2]);\n            // }\n            // A boolean indicating whether the line is an integer\n            // number of lines (using the line dimensions of the first\n            // line of the cue), or whether it is a percentage of the\n            // dimension of the video. The flag is set to true when lines\n            // are counted, and false otherwise.\n            // TODO check and uncomment\n            // cue.snapToLines = false;\n        }\n    }\n    var align = style.align;\n    if (align) {\n        cue.align = align;\n        if (align === \"center\") {\n            if (cue.align !== \"center\") {\n                // Workaround for a Chrome bug http://crbug.com/663797\n                // Chrome does not support align = \"center\"\n                cue.align = \"middle\";\n            }\n            cue.position = \"auto\";\n        }\n        cue.positionAlign = TEXT_ALIGN_TO_POSITION_ALIGN[align] || \"\";\n        cue.lineAlign = TEXT_ALIGN_TO_LIGN_ALIGN[align] || \"\";\n    }\n}\nexports.default = parseTTMLStringToVTT;\n\n\n//# sourceURL=webpack://RxPlayer/./src/parsers/texttracks/ttml/native/index.ts?");

/***/ }),

/***/ "./src/parsers/texttracks/ttml/nodes.ts":
/*!**********************************************!*\
  !*** ./src/parsers/texttracks/ttml/nodes.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @param {Element} tt\n * @returns {Element}\n */\nfunction getBodyNode(tt) {\n    return tt.getElementsByTagName(\"body\")[0];\n}\nexports.getBodyNode = getBodyNode;\n/**\n * @param {Element} tt - <tt> node\n * @returns {Array.<Element>}\n */\nfunction getStyleNodes(tt) {\n    return tt.getElementsByTagName(\"style\");\n}\nexports.getStyleNodes = getStyleNodes;\n/**\n * @param {Element} tt - <tt> node\n * @returns {Array.<Element>}\n */\nfunction getRegionNodes(tt) {\n    return tt.getElementsByTagName(\"region\");\n}\nexports.getRegionNodes = getRegionNodes;\n/**\n * @param {Element} tt - <tt> node\n * @returns {Array.<Element>}\n */\nfunction getTextNodes(tt) {\n    return tt.getElementsByTagName(\"p\");\n}\nexports.getTextNodes = getTextNodes;\n\n\n//# sourceURL=webpack://RxPlayer/./src/parsers/texttracks/ttml/nodes.ts?");

/***/ }),

/***/ "./src/parsers/texttracks/ttml/regexps.ts":
/*!************************************************!*\
  !*** ./src/parsers/texttracks/ttml/regexps.ts ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @type {RegExp}\n * @example 00:00:40:07 (7 frames) or 00:00:40:07.1 (7 frames, 1 subframe)\n */\nvar REGXP_TIME_COLON_FRAMES = /^(\\d{2,}):(\\d{2}):(\\d{2}):(\\d{2})\\.?(\\d+)?$/;\nexports.REGXP_TIME_COLON_FRAMES = REGXP_TIME_COLON_FRAMES;\n/**\n * @type {RegExp}\n * @example 00:00:40:07 (7 frames) or 00:00:40:07.1 (7 frames, 1 subframe)\n */\nvar REGXP_TIME_COLON = /^(?:(\\d{2,}):)?(\\d{2}):(\\d{2})$/;\nexports.REGXP_TIME_COLON = REGXP_TIME_COLON;\n/**\n * @type {RegExp}\n * @example 01:02:43.0345555 or 02:43.03\n */\nvar REGXP_TIME_COLON_MS = /^(?:(\\d{2,}):)?(\\d{2}):(\\d{2}\\.\\d{2,})$/;\nexports.REGXP_TIME_COLON_MS = REGXP_TIME_COLON_MS;\n/**\n * @type {RegExp}\n * @example 75f or 75.5f\n */\nvar REGXP_TIME_FRAMES = /^(\\d*\\.?\\d*)f$/;\nexports.REGXP_TIME_FRAMES = REGXP_TIME_FRAMES;\n/**\n * @type {RegExp}\n * @example 50t or 50.5t\n */\nvar REGXP_TIME_TICK = /^(\\d*\\.?\\d*)t$/;\nexports.REGXP_TIME_TICK = REGXP_TIME_TICK;\n/**\n * @type {RegExp}\n * @example 3.45h, 3m or 4.20s\n */\nvar REGXP_TIME_HMS = /^(?:(\\d*\\.?\\d*)h)?(?:(\\d*\\.?\\d*)m)?(?:(\\d*\\.?\\d*)s)?(?:(\\d*\\.?\\d*)ms)?$/;\nexports.REGXP_TIME_HMS = REGXP_TIME_HMS;\n/**\n * @type {RegExp}\n * @example 50% 10%\n */\nvar REGXP_PERCENT_VALUES = /^(\\d{1,2}|100)% (\\d{1,2}|100)%$/;\nexports.REGXP_PERCENT_VALUES = REGXP_PERCENT_VALUES;\nvar REGXP_8_HEX_COLOR = /^#([0-9A-f]{2})([0-9A-f]{2})([0-9A-f]{2})([0-9A-f]{2})$/;\nexports.REGXP_8_HEX_COLOR = REGXP_8_HEX_COLOR;\nvar REGXP_4_HEX_COLOR = /^#([0-9A-f])([0-9A-f])([0-9A-f])([0-9A-f])$/;\nexports.REGXP_4_HEX_COLOR = REGXP_4_HEX_COLOR;\n\n\n//# sourceURL=webpack://RxPlayer/./src/parsers/texttracks/ttml/regexps.ts?");

/***/ }),

/***/ "./src/parsers/texttracks/ttml/style.ts":
/*!**********************************************!*\
  !*** ./src/parsers/texttracks/ttml/style.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar arrayFind = __webpack_require__(/*! array-find */ \"./node_modules/array-find/find.js\");\nvar array_includes_1 = __webpack_require__(/*! ../../../utils/array-includes */ \"./src/utils/array-includes.ts\");\nvar starts_with_1 = __webpack_require__(/*! ../../../utils/starts-with */ \"./src/utils/starts-with.ts\");\n/**\n * Retrieve the attributes given in arguments in the given nodes and their\n * associated style(s)/region.\n * The first notion of the attribute encountered will be taken (by looping\n * through the given nodes in order).\n *\n * TODO manage IDREFS (plural) for styles and regions, that is, multiple one\n * @param {Array.<string>} attributes\n * @param {Array.<Node>} nodes\n * @param {Array.<Object>} styles\n * @param {Array.<Object>} regions\n * @returns {Object}\n */\nfunction getStylingAttributes(attributes, nodes, styles, regions) {\n    var currentStyle = {};\n    var leftAttributes = attributes.slice();\n    var _loop_1 = function (i) {\n        var node = nodes[i];\n        if (node) {\n            var styleID_1;\n            var regionID_1;\n            // 1. the style is directly set on a \"tts:\" attribute\n            if (node.nodeType === Node.ELEMENT_NODE) {\n                var element = node;\n                for (var j = 0; j <= element.attributes.length - 1; j++) {\n                    var attribute = element.attributes[j];\n                    var name_1 = attribute.name;\n                    if (name_1 === \"style\") {\n                        styleID_1 = attribute.value;\n                    }\n                    else if (name_1 === \"region\") {\n                        regionID_1 = attribute.value;\n                    }\n                    else {\n                        var nameWithoutTTS = name_1.substr(4);\n                        if (array_includes_1.default(leftAttributes, nameWithoutTTS)) {\n                            currentStyle[nameWithoutTTS] = attribute.value;\n                            leftAttributes.splice(j, 1);\n                            if (!leftAttributes.length) {\n                                return { value: currentStyle };\n                            }\n                        }\n                    }\n                }\n            }\n            // 2. the style is referenced on a \"style\" attribute\n            if (styleID_1) {\n                var style = arrayFind(styles, function (x) { return x.id === styleID_1; });\n                if (style) {\n                    for (var j = 0; j <= leftAttributes.length - 1; j++) {\n                        var attribute = leftAttributes[j];\n                        if (!currentStyle[attribute]) {\n                            if (style.style[attribute]) {\n                                currentStyle[attribute] = style.style[attribute];\n                                leftAttributes.splice(j, 1);\n                                if (!leftAttributes.length) {\n                                    return { value: currentStyle };\n                                }\n                                j--;\n                            }\n                        }\n                    }\n                }\n            }\n            // 3. the node reference a region (which can have a value for the\n            //    corresponding style)\n            if (regionID_1) {\n                var region = arrayFind(regions, function (x) {\n                    return x.id === regionID_1;\n                });\n                if (region) {\n                    for (var j = 0; j <= leftAttributes.length - 1; j++) {\n                        var attribute = leftAttributes[j];\n                        if (!currentStyle[attribute]) {\n                            if (region.style[attribute]) {\n                                currentStyle[attribute] = region.style[attribute];\n                                leftAttributes.splice(j, 1);\n                                if (!leftAttributes.length) {\n                                    return { value: currentStyle };\n                                }\n                                j--;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    };\n    for (var i = 0; i <= nodes.length - 1; i++) {\n        var state_1 = _loop_1(i);\n        if (typeof state_1 === \"object\")\n            return state_1.value;\n    }\n    return currentStyle;\n}\nexports.getStylingAttributes = getStylingAttributes;\n/**\n * Returns the styling directly linked to an element.\n * @param {Node} node\n * @returns {Object}\n */\nfunction getStylingFromElement(node) {\n    if (node.nodeType !== Node.ELEMENT_NODE) {\n        return {};\n    }\n    var element = node;\n    var currentStyle = {};\n    for (var i = 0; i <= element.attributes.length - 1; i++) {\n        var styleAttribute = element.attributes[i];\n        if (starts_with_1.default(styleAttribute.name, \"tts\")) {\n            var nameWithoutTTS = styleAttribute.name.substr(4);\n            currentStyle[nameWithoutTTS] = styleAttribute.value;\n        }\n    }\n    return currentStyle;\n}\nexports.getStylingFromElement = getStylingFromElement;\n\n\n//# sourceURL=webpack://RxPlayer/./src/parsers/texttracks/ttml/style.ts?");

/***/ }),

/***/ "./src/parsers/texttracks/ttml/time_parsing.ts":
/*!*****************************************************!*\
  !*** ./src/parsers/texttracks/ttml/time_parsing.ts ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar regexps_1 = __webpack_require__(/*! ./regexps */ \"./src/parsers/texttracks/ttml/regexps.ts\");\n/**\n * Parses a TTML time into seconds.\n * @param {string} text\n * @param {Object} ttParams\n * @returns {Number|undefined}\n */\nfunction parseTime(text, ttParams) {\n    if (regexps_1.REGXP_TIME_COLON_FRAMES.test(text)) {\n        return parseColonTimeWithFrames(ttParams, text);\n    }\n    else if (regexps_1.REGXP_TIME_COLON.test(text)) {\n        return parseTimeFromRegExp(regexps_1.REGXP_TIME_COLON, text);\n    }\n    else if (regexps_1.REGXP_TIME_COLON_MS.test(text)) {\n        return parseTimeFromRegExp(regexps_1.REGXP_TIME_COLON_MS, text);\n    }\n    else if (regexps_1.REGXP_TIME_FRAMES.test(text)) {\n        return parseFramesTime(ttParams, text);\n    }\n    else if (regexps_1.REGXP_TIME_TICK.test(text)) {\n        return parseTickTime(ttParams, text);\n    }\n    else if (regexps_1.REGXP_TIME_HMS.test(text)) {\n        return parseTimeFromRegExp(regexps_1.REGXP_TIME_HMS, text);\n    }\n}\n/**\n * Parses a TTML time in frame format\n * @param {Object} ttParams\n * @param {string} text\n * @returns {Number}\n */\nfunction parseFramesTime(ttParams, text) {\n    // 75f or 75.5f\n    // (We cast as we're sure the regexp is respected here)\n    var results = regexps_1.REGXP_TIME_FRAMES.exec(text);\n    var frames = Number(results[1]);\n    return frames / ttParams.frameRate;\n}\n/**\n * Parses a TTML time in tick format\n * @param {Object} ttParams\n * @param {string} text\n * @returns {Number}\n */\nfunction parseTickTime(ttParams, text) {\n    // 50t or 50.5t\n    // (We cast as we're sure the regexp is respected here)\n    var results = regexps_1.REGXP_TIME_TICK.exec(text);\n    var ticks = Number(results[1]);\n    return ticks / ttParams.tickRate;\n}\n/**\n * Parses a TTML colon formatted time containing frames\n * @param {Object} ttParams\n * @param {string} text\n * @returns {Number}\n */\nfunction parseColonTimeWithFrames(ttParams, text) {\n    // 01:02:43:07 (\"07\" is frames) or 01:02:43:07.1 (subframes)\n    // (We cast as we're sure the regexp is respected here)\n    var results = regexps_1.REGXP_TIME_COLON_FRAMES.exec(text);\n    var hours = Number(results[1]);\n    var minutes = Number(results[2]);\n    var seconds = Number(results[3]);\n    var frames = Number(results[4]);\n    var subframes = Number(results[5]) || 0;\n    frames += subframes / ttParams.subFrameRate;\n    seconds += frames / ttParams.frameRate;\n    return seconds + (minutes * 60) + (hours * 3600);\n}\n/**\n * Parses a TTML time with a given regex. Expects regex to be some\n * sort of a time-matcher to match hours, minutes, seconds and milliseconds\n *\n * @param {RegExp} regex\n * @param {string} text\n * @returns {number|null}\n */\nfunction parseTimeFromRegExp(regex, text) {\n    var results = regex.exec(text);\n    if (results === null || results[0] === \"\") {\n        return null;\n    }\n    // This capture is optional, but will still be in the array as undefined,\n    // default to 0.\n    var hours = Number(results[1]) || 0;\n    var minutes = Number(results[2]) || 0;\n    var seconds = Number(results[3]) || 0;\n    var miliseconds = Number(results[4]) || 0;\n    return (miliseconds / 1000) + seconds + (minutes * 60) + (hours * 3600);\n}\nexports.default = parseTime;\n\n\n//# sourceURL=webpack://RxPlayer/./src/parsers/texttracks/ttml/time_parsing.ts?");

/***/ }),

/***/ "./src/parsers/texttracks/webvtt/html/formatCueLineToHTML.ts":
/*!*******************************************************************!*\
  !*** ./src/parsers/texttracks/webvtt/html/formatCueLineToHTML.ts ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar array_includes_1 = __webpack_require__(/*! ../../../../utils/array-includes */ \"./src/utils/array-includes.ts\");\n/**\n * Format WebVTT tags and classes into usual HTML.\n * <b *> => <b>\n * <u *> => <u>\n * <i *> => <i>\n * <c.class *> => <c.class>\n * Style is inserted if associated to tag or class.\n * @param {string} text\n * @param {Array.<Object>} styleElements\n * @returns {Array.<Node>}\n */\nfunction formatCueLineToHTML(text, styleElements) {\n    var HTMLTags = [\"u\", \"i\", \"b\"];\n    var webVTTTags = [\"u\", \"i\", \"b\", \"c\", \"#text\"];\n    var styleClasses = styleElements.map(function (styleElement) { return styleElement.className; });\n    var filtered = text\n        // Remove timestamp tags\n        .replace(/<[0-9]{2}:[0-9]{2}.[0-9]{3}>/, \"\")\n        // Remove tag content or attributes (e.g. <b dfgfdg> => <b>)\n        .replace(/<([u,i,b,c])(\\..*?)?(?: .*?)?>(.*?)<\\/\\1>/g, \"<$1$2>$3</$1$2>\");\n    var parser = new DOMParser();\n    var parsedWebVTT = parser.parseFromString(filtered, \"text/html\");\n    var nodes = parsedWebVTT.body.childNodes;\n    /**\n     * Apply styles to specifig tag in children nodes.\n     * (e.g. If class \"b\" has style, then : <b style=\"content\">\n     * )\n     * Change class tags into span with associated style, or text*\n     * First it was: <c.class>...</c>. Then <class></class>.\n     * Finally <span style=\"content\"></span> or text.\n     * @param {Array.<Node>} childNodes\n     * @returns {Array.<Node>}\n     */\n    function parseNode(nodeToParse) {\n        var parsedNodeArray = [];\n        for (var i = 0; i < nodeToParse.length; i++) {\n            parsedNodeArray[i] = createStyleElement(nodeToParse[i]);\n        }\n        /**\n         * Construct an HTMLElement/TextNode representing the given node and apply\n         * the right styling on it.\n         * @param {Node} baseNode\n         * @returns {Node}\n         */\n        function createStyleElement(baseNode) {\n            var mainTag = baseNode.nodeName.toLowerCase().split(\".\")[0];\n            var nodeWithStyle;\n            if (array_includes_1.default(webVTTTags, mainTag)) { // If element accepted\n                if (mainTag === \"#text\") {\n                    nodeWithStyle = document.createTextNode(baseNode.wholeText);\n                }\n                else {\n                    var nodeClasses = baseNode.nodeName.toLowerCase().split(\".\");\n                    var classIndexes_1 = [];\n                    nodeClasses.forEach(function (nodeClass) {\n                        if (styleClasses.indexOf(nodeClass) !== -1) {\n                            classIndexes_1.push(styleClasses.indexOf(nodeClass));\n                        }\n                    });\n                    if (classIndexes_1.length !== 0) { // If style must be applied\n                        var attr_1 = document.createAttribute(\"style\");\n                        classIndexes_1.forEach(function (index) {\n                            attr_1.value += styleElements[index].styleContent;\n                        });\n                        var nameClass = array_includes_1.default(HTMLTags, mainTag) ? mainTag : \"span\";\n                        nodeWithStyle = document.createElement(nameClass);\n                        nodeWithStyle.setAttributeNode(attr_1);\n                    }\n                    else { // If style mustn't be applied. Rebuild element with tag name\n                        var elementTag = !array_includes_1.default(HTMLTags, mainTag) ? \"span\" : mainTag;\n                        nodeWithStyle = document.createElement(elementTag);\n                    }\n                    for (var j = 0; j < baseNode.childNodes.length; j++) {\n                        nodeWithStyle.appendChild(createStyleElement(baseNode.childNodes[j]));\n                    }\n                }\n            }\n            else {\n                nodeWithStyle = document.createElement(\"span\");\n                for (var j = 0; j < baseNode.childNodes.length; j++) {\n                    nodeWithStyle.appendChild(createStyleElement(baseNode.childNodes[j]));\n                }\n            }\n            return nodeWithStyle;\n        }\n        return parsedNodeArray;\n    }\n    return parseNode(nodes);\n}\nexports.default = formatCueLineToHTML;\n\n\n//# sourceURL=webpack://RxPlayer/./src/parsers/texttracks/webvtt/html/formatCueLineToHTML.ts?");

/***/ }),

/***/ "./src/parsers/texttracks/webvtt/html/index.ts":
/*!*****************************************************!*\
  !*** ./src/parsers/texttracks/webvtt/html/index.ts ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar log_1 = __webpack_require__(/*! ../../../../utils/log */ \"./src/utils/log.ts\");\nvar formatCueLineToHTML_1 = __webpack_require__(/*! ./formatCueLineToHTML */ \"./src/parsers/texttracks/webvtt/html/formatCueLineToHTML.ts\");\nvar parseStyleBlock_1 = __webpack_require__(/*! ./parseStyleBlock */ \"./src/parsers/texttracks/webvtt/html/parseStyleBlock.ts\");\nvar parseTimeCode_1 = __webpack_require__(/*! ./parseTimeCode */ \"./src/parsers/texttracks/webvtt/html/parseTimeCode.ts\");\nvar utils_1 = __webpack_require__(/*! ./utils */ \"./src/parsers/texttracks/webvtt/html/utils.ts\");\n/**\n * Parse WebVTT from text. Returns an array with:\n * - start : start of current cue, in seconds\n * - end : end of current cue, in seconds\n * - content : HTML formatted cue.\n *\n * Global style is parsed and applied to div element.\n * Specific style is parsed and applied to class element.\n *\n * @param {string} text\n * @param {Number} timeOffset\n * @return {Array.<Object>}\n * @throws Error - Throws if the given WebVTT string is invalid.\n */\nfunction parseWebVTT(text, timeOffset) {\n    var newLineChar = /\\r\\n|\\n|\\r/g;\n    var linified = text.split(newLineChar);\n    var cuesArray = [];\n    var styleElements = [];\n    if (!linified[0].match(/^WEBVTT( |\\t|\\n|\\r|$)/)) {\n        throw new Error(\"Can't parse WebVTT: Invalid File.\");\n    }\n    var firstLineAfterHeader = utils_1.getFirstLineAfterHeader(linified);\n    for (var i = firstLineAfterHeader; i < linified.length; i++) {\n        if (utils_1.isStartOfStyleBlock(linified[i])) {\n            var startOfStyleBlock = i;\n            i++;\n            // continue incrementing i until either:\n            //   - empty line\n            //   - end of file\n            while (linified[i]) {\n                i++;\n            }\n            var styleBlock = linified.slice(startOfStyleBlock, i);\n            var parsedStyles = parseStyleBlock_1.default(styleBlock);\n            styleElements.push.apply(styleElements, parsedStyles);\n        }\n    }\n    // Parse cues, format and apply style.\n    for (var i = firstLineAfterHeader; i < linified.length; i++) {\n        if (!(linified[i].length === 0)) {\n            if (utils_1.isStartOfCueBlock(linified[i])) {\n                var startOfCueBlock = i;\n                i++;\n                // continue incrementing i until either:\n                //   - empty line\n                //   - end of file\n                while (linified[i]) {\n                    i++;\n                }\n                var cueBlock = linified.slice(startOfCueBlock, i);\n                var cue = parseCue(cueBlock, timeOffset, styleElements);\n                if (cue) {\n                    cuesArray.push(cue);\n                }\n            }\n            else {\n                while (linified[i]) {\n                    i++;\n                }\n            }\n        }\n    }\n    return cuesArray;\n}\nexports.default = parseWebVTT;\n/**\n * Parse cue block into an object with the following properties:\n *   - start {number}: start time at which the cue should be displayed\n *   - end {number}: end time at which the cue should be displayed\n *   - element {HTMLElement}: the cue text, translated into an HTMLElement\n *\n * Returns undefined if the cue block could not be parsed.\n * @param {Array.<string>} cueBlock\n * @param {Number} timeOffset\n * @param {Array.<Object>} styleElements\n * @returns {Object|undefined}\n */\nfunction parseCue(cueBlock, timeOffset, styleElements) {\n    var region = document.createElement(\"div\");\n    var regionAttr = document.createAttribute(\"style\");\n    var index = 0;\n    regionAttr.value =\n        \"width:100%;\" +\n            \"height:100%;\" +\n            \"display:flex;\" +\n            \"flex-direction:column;\" +\n            \"justify-content:flex-end;\" +\n            \"align-items:center;\";\n    region.setAttributeNode(regionAttr);\n    // Get Header. It may be a class name associated with cue.\n    var header = cueBlock[index];\n    index++;\n    // Get time ranges.\n    var timeCodes = cueBlock[index];\n    var range = parseTimeCode_1.default(timeCodes);\n    if (!range || range.start === undefined || range.end === undefined) {\n        log_1.default.warn(\"VTT: Invalid cue, the timecode line could not be parsed.\");\n        return undefined; // cancel if we do not find the start or end of this cue\n    }\n    index++;\n    // Get content, format and apply style.\n    var pElement = document.createElement(\"p\");\n    var pAttr = document.createAttribute(\"style\");\n    pAttr.value = \"text-align:center\";\n    pElement.setAttributeNode(pAttr);\n    var spanElement = document.createElement(\"span\");\n    var attr = document.createAttribute(\"style\");\n    // set color and background-color default values, as indicated in:\n    // https://www.w3.org/TR/webvtt1/#applying-css-properties\n    attr.value =\n        \"background-color:rgba(0,0,0,0.8);\" +\n            \"color:white;\";\n    spanElement.setAttributeNode(attr);\n    var styles = styleElements\n        .filter(function (styleElement) {\n        return (styleElement.className === header && !styleElement.isGlobalStyle) ||\n            styleElement.isGlobalStyle;\n    }).map(function (styleElement) { return styleElement.styleContent; });\n    if (styles) {\n        attr.value += styles.join();\n        spanElement.setAttributeNode(attr);\n    }\n    while (cueBlock[index]) {\n        if (spanElement.childNodes.length !== 0) {\n            spanElement.appendChild(document.createElement(\"br\"));\n        }\n        formatCueLineToHTML_1.default(cueBlock[index], styleElements)\n            .forEach(function (child) {\n            spanElement.appendChild(child);\n        });\n        index++;\n    }\n    region.appendChild(pElement);\n    pElement.appendChild(spanElement);\n    return {\n        start: range.start + timeOffset,\n        end: range.end + timeOffset,\n        element: region,\n    };\n}\n\n\n//# sourceURL=webpack://RxPlayer/./src/parsers/texttracks/webvtt/html/index.ts?");

/***/ }),

/***/ "./src/parsers/texttracks/webvtt/html/parseStyleBlock.ts":
/*!***************************************************************!*\
  !*** ./src/parsers/texttracks/webvtt/html/parseStyleBlock.ts ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n *\n * Parse style element from WebVTT.\n * @param {Array.<string>} styleBlock\n * @return {Array.<Object>} styleElements\n */\nfunction parseStyleBlock(styleBlock) {\n    var styleElements = [];\n    var index = 1;\n    var classNames = [];\n    if (styleBlock[index].match(/::cue {/)) {\n        classNames.push({ isGlobalStyle: true });\n        index++;\n    }\n    else {\n        var cueClassLine = void 0;\n        while (cueClassLine = styleBlock[index].match(/::cue\\(\\.?(.*?)\\)(?:,| {)/)) {\n            classNames.push({\n                className: cueClassLine[1],\n                isGlobalStyle: false,\n            });\n            index++;\n        }\n    }\n    var styleContent = \"\";\n    while (!(styleBlock[index].match(/}/)\n        || styleBlock[index].length === 0)) {\n        styleContent += styleBlock[index];\n        index++;\n    }\n    classNames.forEach(function (name) {\n        styleElements.push({\n            className: name.className,\n            isGlobalStyle: name.isGlobalStyle,\n            styleContent: styleContent.replace(/\\s/g, \"\"),\n        });\n    });\n    return styleElements;\n}\nexports.default = parseStyleBlock;\n\n\n//# sourceURL=webpack://RxPlayer/./src/parsers/texttracks/webvtt/html/parseStyleBlock.ts?");

/***/ }),

/***/ "./src/parsers/texttracks/webvtt/html/parseTimeCode.ts":
/*!*************************************************************!*\
  !*** ./src/parsers/texttracks/webvtt/html/parseTimeCode.ts ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar parseTimestamp_1 = __webpack_require__(/*! ../parseTimestamp */ \"./src/parsers/texttracks/webvtt/parseTimestamp.ts\");\n/**\n * Parse the VTT timecode line given and construct an object with two\n * properties:\n *   - start {Number|undefined}: the corresponding start time in seconds\n *   - end {Number|undefined}: the corresponding end time in seconds\n * @example\n * ```js\n * parseTimeCode(\"00:02:30 --> 00:03:00\");\n * // -> {\n * //      start: 150,\n * //      end: 180,\n * //    }\n * ```\n * @param {string} text\n * @returns {Object|undefined}\n */\nfunction parseTimeCode(text) {\n    var tsRegex = \"((?:[0-9]{2}\\:)?[0-9]{2}:[0-9]{2}.[0-9]{2,3})\";\n    var startEndRegex = tsRegex + \"(?:\\ |\\t)-->(?:\\ |\\t)\" + tsRegex;\n    var ranges = text.match(startEndRegex);\n    if (ranges && ranges.length >= 3) {\n        var start = parseTimestamp_1.default(ranges[1]);\n        var end = parseTimestamp_1.default(ranges[2]);\n        return { start: start, end: end };\n    }\n}\nexports.default = parseTimeCode;\n\n\n//# sourceURL=webpack://RxPlayer/./src/parsers/texttracks/webvtt/html/parseTimeCode.ts?");

/***/ }),

/***/ "./src/parsers/texttracks/webvtt/html/utils.ts":
/*!*****************************************************!*\
  !*** ./src/parsers/texttracks/webvtt/html/utils.ts ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Returns first line after the WEBVTT header.\n * That is, the line after the first blank line after the first line!\n * @param {Array.<string>} linified\n * @returns {Number}\n */\nfunction getFirstLineAfterHeader(linified) {\n    var i = 0;\n    while (i < linified.length) {\n        if (linified[i] === \"\") {\n            return i + 1;\n        }\n        i++;\n    }\n    return i;\n}\nexports.getFirstLineAfterHeader = getFirstLineAfterHeader;\n/**\n * Returns true if the given line looks like the beginning of a Style block.\n * @param {string} text\n * @returns {Boolean}\n */\nfunction isStartOfStyleBlock(text) {\n    return /^STYLE( .*)?$/g.test(text);\n}\nexports.isStartOfStyleBlock = isStartOfStyleBlock;\n/**\n * Returns true if the given line looks like the beginning of a comment block.\n * @param {string} text\n * @returns {Boolean}\n */\nfunction isStartOfNoteBlock(text) {\n    return /^NOTE( .*)?$/g.test(text);\n}\nexports.isStartOfNoteBlock = isStartOfNoteBlock;\n/**\n * Returns true if the given line looks like the beginning of a region block.\n * @param {string} text\n * @returns {Boolean}\n */\nfunction isStartOfRegionBlock(text) {\n    return /^REGION( .*)?$/g.test(text);\n}\nexports.isStartOfRegionBlock = isStartOfRegionBlock;\n/**\n * Returns true if the given line looks like the beginning of a cue block.\n * @param {string} text\n * @returns {Boolean}\n */\nfunction isStartOfCueBlock(text) {\n    return (!isStartOfNoteBlock(text) &&\n        !isStartOfStyleBlock(text) &&\n        !isStartOfRegionBlock(text)) &&\n        text.length !== 0;\n}\nexports.isStartOfCueBlock = isStartOfCueBlock;\n\n\n//# sourceURL=webpack://RxPlayer/./src/parsers/texttracks/webvtt/html/utils.ts?");

/***/ }),

/***/ "./src/parsers/texttracks/webvtt/native.ts":
/*!*************************************************!*\
  !*** ./src/parsers/texttracks/webvtt/native.ts ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar array_includes_1 = __webpack_require__(/*! ../../../utils/array-includes */ \"./src/utils/array-includes.ts\");\nvar index_1 = __webpack_require__(/*! ../../../compat/index */ \"./src/compat/index.ts\");\n// Simple VTT to VTTCue parser:\n// Just parse cues and associated settings.\n// Does not take into consideration STYLE and REGION blocks.\n/**\n * Parse whole WEBVTT file into an array of cues, to be inserted in a video's\n * TrackElement.\n * @param {string} vttStr\n * @param {Number} timeOffset\n * @returns {Array.<VTTCue|TextTrackCue>}\n */\nfunction parseVTTStringToVTTCues(vttStr, timeOffset) {\n    // WEBVTT authorize CRLF, LF or CR as line terminators\n    var lines = vttStr.split(/\\r\\n|\\n|\\r/);\n    if (!(/^WEBVTT($| |\\t)/.test(lines[0]))) {\n        throw new Error(\"Can't parse WebVTT: Invalid file.\");\n    }\n    var cueBlocks = [];\n    for (var i = 1; i < lines.length; i++) {\n        if (isStartOfCueBlock(lines[i])) {\n            var startingI = i;\n            i++;\n            // continue incrementing i until either:\n            //   - empty line\n            //   - end\n            while (lines[i]) {\n                i++;\n            }\n            cueBlocks.push(lines.slice(startingI, i));\n        }\n        else if (lines[i]) {\n            // continue incrementing i until either:\n            //   - empty line\n            //   - end\n            while (lines[i]) {\n                i++;\n            }\n        }\n    }\n    var cues = [];\n    for (var i = 0; i < cueBlocks.length; i++) {\n        var cue = parseCue(cueBlocks[i], timeOffset);\n        if (cue) {\n            cues.push(cue);\n        }\n    }\n    return cues;\n}\nexports.default = parseVTTStringToVTTCues;\n/**\n * Returns true if the line given looks like the beginning of a cue.\n * You should provide to this function only lines following \"empty\" lines.\n * @param {string} line\n * @returns {Boolean}\n */\nfunction isStartOfCueBlock(line) {\n    // checked cases:\n    //   - empty lines\n    //   - start of a comment\n    //   - start of a region\n    //   - start of a style\n    // Anything else should be a cue. TODO re-check with the spec\n    if (!line || /^(NOTE)|(REGION)|(STYLE)($| |\\t)/.test(line)) {\n        return false;\n    }\n    return true;\n}\n/**\n * Parse cue block into a cue.\n * @param {Array.<string>} cueLines\n * @param {Number} timeOffset\n * @returns {TextTrackCue|VTTCue}\n */\nfunction parseCue(cueLines, timeOffset) {\n    var timingRegexp = /-->/;\n    var timeString;\n    var payloadLines;\n    if (!timingRegexp.test(cueLines[0])) {\n        if (!timingRegexp.test(cueLines[1])) {\n            // not a cue\n            return null;\n        }\n        timeString = cueLines[1];\n        payloadLines = cueLines.slice(2, cueLines.length);\n    }\n    else {\n        timeString = cueLines[0];\n        payloadLines = cueLines.slice(1, cueLines.length);\n    }\n    var timeAndSettings = parseTimeAndSettings(timeString);\n    if (!timeAndSettings) {\n        return null;\n    }\n    var start = timeAndSettings.start, end = timeAndSettings.end, settings = timeAndSettings.settings;\n    var payload = payloadLines.join(\"\\n\");\n    var cue = index_1.makeCue(start + timeOffset, end + timeOffset, payload);\n    if (cue && cue instanceof VTTCue) {\n        setSettingsOnCue(settings, cue);\n    }\n    return cue;\n}\n/**\n * Parse a single WEBVTT timestamp into seconds\n * @param {string} timestampString\n * @returns {Number}\n */\nfunction parseTimestamp(timestampString) {\n    var splittedTS = timestampString.split(\":\");\n    if (splittedTS.length === 3) {\n        var hours = parseInt(splittedTS[0], 10);\n        var minutes = parseInt(splittedTS[1], 10);\n        var seconds = parseFloat(splittedTS[2]);\n        if (isNaN(hours) || isNaN(minutes) || isNaN(seconds)) {\n            return undefined;\n        }\n        return hours * 60 * 60 + minutes * 60 + seconds;\n    }\n    else if (splittedTS.length === 2) {\n        var minutes = parseInt(splittedTS[0], 10);\n        var seconds = parseFloat(splittedTS[1]);\n        if (isNaN(minutes) || isNaN(seconds)) {\n            return undefined;\n        }\n        return minutes * 60 + seconds;\n    }\n}\n/**\n * Parse the settings part of a cue, into key-value object.\n * @param {string} settingsString\n * @returns {Object}\n */\nfunction parseSettings(settingsString) {\n    var splittedSettings = settingsString.split(/ |\\t/);\n    return splittedSettings.reduce(function (acc, setting) {\n        var splittedSetting = setting.split(\":\");\n        if (splittedSetting.length === 2) {\n            acc[splittedSetting[0]] = splittedSetting[1];\n        }\n        return acc;\n    }, {});\n}\n/**\n * Parse the line containing the timestamp and settings in a cue.\n * The returned object has the following properties:\n *   - start {Number}: start of the cue, in seconds\n *   - end {Number}: end of the cue, in seconds\n *   - settings {Object}: settings for the cue as a key-value object.\n * @param {string} timeString\n * @returns {Object|null}\n */\nfunction parseTimeAndSettings(timeString) {\n    /*\n     * RegExp for the timestamps + settings line.\n     *\n     * Capture groups:\n     *   1 -> start timestamp\n     *   2 -> end timestamp\n     *   3 - settings\n     * @type {RegExp}\n     */\n    var lineRegex = /^([\\d:.]+)[ |\\t]+-->[ |\\t]+([\\d:.]+)[ |\\t]*(.*)$/;\n    var matches = timeString.match(lineRegex);\n    if (!matches) {\n        return null;\n    }\n    var start = parseTimestamp(matches[1]);\n    var end = parseTimestamp(matches[2]);\n    if (start == null || end == null) {\n        return null;\n    }\n    var settings = parseSettings(matches[3]);\n    return {\n        start: start,\n        end: end,\n        settings: settings,\n    };\n}\n/**\n * Add the corresponding settings on the given cue.\n * /!\\ Mutates the cue given.\n * @param {Object} settings - settings for the cue, as a key-value object.\n * @param {VTTCue|TextTrackCue} cue\n */\nfunction setSettingsOnCue(settings, cue) {\n    if (settings.vertical &&\n        (settings.vertical === \"rl\" || settings.vertical === \"lr\")) {\n        cue.vertical = settings.vertical;\n    }\n    if (settings.line) {\n        /**\n         * Capture groups:\n         *   1 -> percentage position\n         *   2 -> optional decimals from percentage position\n         *   3 -> optional follow-up of the string indicating alignment value\n         *   4 -> alignment value\n         * @type {RegExp}\n         */\n        var percentagePosition = /^(\\d+(\\.\\d+)?)%(,([a-z]+))?/;\n        var percentageMatches = settings.line.match(percentagePosition);\n        if (percentageMatches) {\n            cue.line = percentageMatches[1];\n            cue.snapToLines = false;\n            if (array_includes_1.default([\"start\", \"center\", \"end\"], percentageMatches[4])) {\n                cue.lineAlign = percentageMatches[4];\n            }\n        }\n        else {\n            /**\n             * Capture groups:\n             *   1 -> line number\n             *   2 -> optional follow-up of the string indicating alignment value\n             *   3 -> alignment value\n             * @type {RegExp}\n             */\n            var linePosition = /^(-?\\d+)(,([a-z]+))?/;\n            var lineMatches = settings.line.match(linePosition);\n            if (lineMatches) {\n                cue.line = lineMatches[1];\n                cue.snapToLines = true;\n                if (array_includes_1.default([\"start\", \"center\", \"end\"], lineMatches[3])) {\n                    cue.lineAlign = lineMatches[3];\n                }\n            }\n        }\n    }\n    if (settings.position) {\n        var positionRegex = /^([\\d\\.]+)%(?:,(line-left|line-right|center))?$/;\n        var positionArr = positionRegex.exec(settings.position);\n        if (positionArr && positionArr.length >= 2) {\n            var position = parseInt(positionArr[1], 10);\n            if (!isNaN(position)) {\n                cue.position = position;\n                if (positionArr[2] != null) {\n                    cue.positionAlign = positionArr[2];\n                }\n            }\n        }\n    }\n    if (settings.size) {\n        cue.size = settings.size;\n    }\n    if (settings.align &&\n        array_includes_1.default([\"start\", \"center\", \"end\", \"left\"], settings.align)) {\n        cue.align = settings.align;\n    }\n}\n\n\n//# sourceURL=webpack://RxPlayer/./src/parsers/texttracks/webvtt/native.ts?");

/***/ }),

/***/ "./src/parsers/texttracks/webvtt/parseTimestamp.ts":
/*!*********************************************************!*\
  !*** ./src/parsers/texttracks/webvtt/parseTimestamp.ts ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Parse a single webvtt timestamp into seconds\n * @param {string} timestampString\n * @returns {Number|undefined}\n */\nfunction parseTimestamp(timestampString) {\n    var splittedTS = timestampString.split(\":\").reverse();\n    if (splittedTS[2] || splittedTS[1]) {\n        var hours = splittedTS[2] ? parseInt(splittedTS[2], 10) : 0;\n        var minutes = parseInt(splittedTS[1], 10);\n        var seconds = parseFloat(splittedTS[0].replace(\",\", \".\"));\n        if (isNaN(hours) || isNaN(minutes) || isNaN(seconds)) {\n            return undefined;\n        }\n        return hours * 60 * 60 + minutes * 60 + seconds;\n    }\n}\nexports.default = parseTimestamp;\n\n\n//# sourceURL=webpack://RxPlayer/./src/parsers/texttracks/webvtt/parseTimestamp.ts?");

/***/ }),

/***/ "./src/utils/array-includes.ts":
/*!*************************************!*\
  !*** ./src/utils/array-includes.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Array.prototype.includes ponyfill.\n * Returns ``true`` if the given array ``arr`` contains the element\n * ``searchElement``. false ``otherwise``.\n *\n * Inspired from MDN polyfill, but ponyfilled instead\n *\n * @example\n * ```js\n * arrayIncludes([1, 2, 3], 3);\n * // => true\n *\n * arrayIncludes([1, 2, 3], 7);\n * // => false\n *\n * const obj = { a: 4 };\n * arrayIncludes([obj, { b: 7 }, { a: 3 }, obj);\n * // => true\n *\n * // does not perform deep equality\n * arrayIncludes([{ a: 4 }, { b: 7 }, { a: 3 }, { a: 4 });\n * // => false\n *\n * // the third argument state the starting index. 0 if not set.\n *\n * arrayIncludes([1, 2, 3], 2, 1);\n * // => true\n *\n * arrayIncludes([1, 2, 3], 2, 2);\n * // => false\n * ```\n *\n * @param {Array} arr\n * @param {*} searchElement\n * @param {number} [fromIndex]\n * @returns {boolean}\n */\nfunction arrayIncludes(arr, searchElement, fromIndex) {\n    /* tslint:disable no-unbound-method */\n    if (typeof Array.prototype.includes === \"function\") {\n        /* tslint:enable no-unbound-method */\n        return arr.includes(searchElement, fromIndex);\n    }\n    var len = arr.length >>> 0;\n    if (len === 0) {\n        return false;\n    }\n    var n = fromIndex | 0;\n    var k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);\n    var areTheSame = function (x, y) {\n        return x === y ||\n            // Viva las JavaScriptas!\n            (typeof x === \"number\" && typeof y === \"number\"\n                && isNaN(x) && isNaN(y));\n    };\n    while (k < len) {\n        if (areTheSame(arr[k], searchElement)) {\n            return true;\n        }\n        k++;\n    }\n    return false;\n}\nexports.default = arrayIncludes;\n\n\n//# sourceURL=webpack://RxPlayer/./src/utils/array-includes.ts?");

/***/ }),

/***/ "./src/utils/assert.ts":
/*!*****************************!*\
  !*** ./src/utils/assert.ts ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar AssertionError_1 = __webpack_require__(/*! ../errors/AssertionError */ \"./src/errors/AssertionError.ts\");\n/**\n * Throw an AssertionError if the given assertion is false.\n * @param {boolean} assertion\n * @param {string} message - Optional message property for the AssertionError.\n * @throws AssertionError - Throws if the assertion given is false\n */\nfunction assert(assertion, message) {\n    if (!assertion) {\n        throw new AssertionError_1.default(message || \"invalid assertion\");\n    }\n}\nexports.default = assert;\n/**\n * Throws if the given Object does not respect the interface.\n * @param {Object} o\n * @param {Object} iface - Contains the checked keynames of o and link them\n * to their types (obtained through the typeof operator).\n * @param {string} [name=\"object\"] - name of the _interface_\n * @throws AssertionError - The argument o given is not an object\n * @throws AssertionError - The _interface_ is not respected.\n */\nfunction assertInterface(o, iface, name) {\n    if (name === void 0) { name = \"object\"; }\n    assert(o != null, name + \" should be an object\");\n    for (var k in iface) {\n        if (iface.hasOwnProperty(k)) {\n            /* tslint:disable:max-line-length */\n            assert(typeof o[k] === iface[k], name + \" should have property \" + k + \" as a \" + iface[k]);\n            /* tslint:enable:max-line-length */\n        }\n    }\n}\nexports.assertInterface = assertInterface;\n\n\n//# sourceURL=webpack://RxPlayer/./src/utils/assert.ts?");

/***/ }),

/***/ "./src/utils/backoff.ts":
/*!******************************!*\
  !*** ./src/utils/backoff.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar FUZZ_FACTOR = 0.3;\n/**\n * Perform \"fuzzing\" on the delay given.\n * @param {Number} retryDelay\n * @returns {Number}\n */\nfunction getFuzzedDelay(retryDelay) {\n    var fuzzingFactor = ((Math.random() * 2) - 1) * FUZZ_FACTOR;\n    return retryDelay * (fuzzingFactor + 1.0); // Max 1.3 Min 0.7\n}\nexports.getFuzzedDelay = getFuzzedDelay;\n/**\n * Calculate a \"backed off\" fuzzed delay.\n * That is, a delay augmented depending on the current retry count.\n * @param {Number} retryDelay\n * @param {Number} [retryCount=1]\n * @returns {Number}\n */\nfunction getBackedoffDelay(retryDelay, retryCount) {\n    if (retryCount === void 0) { retryCount = 1; }\n    return getFuzzedDelay(retryDelay * Math.pow(2, retryCount - 1));\n}\nexports.getBackedoffDelay = getBackedoffDelay;\n\n\n//# sourceURL=webpack://RxPlayer/./src/utils/backoff.ts?");

/***/ }),

/***/ "./src/utils/bytes.ts":
/*!****************************!*\
  !*** ./src/utils/bytes.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar assert_1 = __webpack_require__(/*! ./assert */ \"./src/utils/assert.ts\");\n/**\n * Returns Uint8Array from UTF16 string.\n * /!\\ Take only the first byte from each UTF16 code.\n * @param {string} str\n * @returns {Uint8Array}\n */\nfunction strToBytes(str) {\n    var len = str.length;\n    var arr = new Uint8Array(len);\n    for (var i = 0; i < len; i++) {\n        arr[i] = str.charCodeAt(i) & 0xFF;\n    }\n    return arr;\n}\nexports.strToBytes = strToBytes;\n/**\n * construct string from unicode values.\n * /!\\ does not support non-UCS-2 values\n * @param {Uint8Array} bytes\n * @returns {string}\n */\nfunction bytesToStr(bytes) {\n    return String.fromCharCode.apply(null, bytes);\n}\nexports.bytesToStr = bytesToStr;\n/**\n * construct string from unicode values.\n * Only use every other byte for each UTF-16 character.\n * /!\\ does not support non-UCS-2 values\n * @param {Uint8Array} bytes\n * @returns {string}\n */\nfunction bytesToUTF16Str(bytes) {\n    var str = \"\";\n    var len = bytes.length;\n    for (var i = 0; i < len; i += 2) {\n        str += String.fromCharCode(bytes[i]);\n    }\n    return str;\n}\nexports.bytesToUTF16Str = bytesToUTF16Str;\n/**\n * Convert hex codes in a string form into the corresponding bytes.\n * @param {string} str\n * @returns {Uint8Array}\n * @throws TypeError - str.length is odd\n */\nfunction hexToBytes(str) {\n    var len = str.length;\n    var arr = new Uint8Array(len / 2);\n    for (var i = 0, j = 0; i < len; i += 2, j++) {\n        arr[j] = parseInt(str.substr(i, 2), 16) & 0xFF;\n    }\n    return arr;\n}\nexports.hexToBytes = hexToBytes;\n/**\n * Convert bytes into the corresponding hex string, with the possibility\n * to add a separator.\n * @param {Uint8Array} bytes\n * @param {string} [sep=\"\"] - separator. Separate each two hex character.\n * @returns {string}\n */\nfunction bytesToHex(bytes, sep) {\n    if (sep === void 0) { sep = \"\"; }\n    var hex = \"\";\n    for (var i = 0; i < bytes.byteLength; i++) {\n        hex += (bytes[i] >>> 4).toString(16);\n        hex += (bytes[i] & 0xF).toString(16);\n        if (sep.length && i < bytes.byteLength - 1) {\n            hex += sep;\n        }\n    }\n    return hex;\n}\nexports.bytesToHex = bytesToHex;\n/**\n * Returns a Uint8Array from the arguments given, in order:\n *   - if the next argument given is a number N set the N next bytes to 0.\n *   - else set the next bytes to the argument given.\n * @param {...(Number|Uint8Array)} args\n * @returns {Uint8Array}\n */\nfunction concat() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    var l = args.length;\n    var i = -1;\n    var len = 0;\n    var arg;\n    while (++i < l) {\n        arg = args[i];\n        len += (typeof arg === \"number\") ? arg : arg.length;\n    }\n    var arr = new Uint8Array(len);\n    var offset = 0;\n    i = -1;\n    while (++i < l) {\n        arg = args[i];\n        if (typeof arg === \"number\") {\n            offset += arg;\n        }\n        else if (arg.length > 0) {\n            arr.set(arg, offset);\n            offset += arg.length;\n        }\n    }\n    return arr;\n}\nexports.concat = concat;\n/**\n * Translate groups of 2 big-endian bytes to Integer (from 0 up to 65535).\n * @param {Uint8Array} bytes\n * @param {Number} offset - The offset (from the start of the given array)\n * @returns {Number}\n */\nfunction be2toi(bytes, offset) {\n    return ((bytes[offset + 0] << 8) +\n        (bytes[offset + 1] << 0));\n}\nexports.be2toi = be2toi;\n/**\n * Translate groups of 3 big-endian bytes to Integer.\n * @param {Uint8Array} bytes\n * @param {Number} offset - The offset (from the start of the given array)\n * @returns {Number}\n */\nfunction be3toi(bytes, offset) {\n    return ((bytes[offset + 0] * 0x0010000) +\n        (bytes[offset + 1] * 0x0000100) +\n        (bytes[offset + 2]));\n}\nexports.be3toi = be3toi;\n/**\n * Translate groups of 4 big-endian bytes to Integer.\n * @param {Uint8Array} bytes\n * @param {Number} offset - The offset (from the start of the given array)\n * @returns {Number}\n */\nfunction be4toi(bytes, offset) {\n    return ((bytes[offset + 0] * 0x1000000) +\n        (bytes[offset + 1] * 0x0010000) +\n        (bytes[offset + 2] * 0x0000100) +\n        (bytes[offset + 3]));\n}\nexports.be4toi = be4toi;\n/**\n * Translate groups of 8 big-endian bytes to Integer.\n * @param {Uint8Array} bytes\n * @param {Number} offset - The offset (from the start of the given array)\n * @returns {Number}\n */\nfunction be8toi(bytes, offset) {\n    return (((bytes[offset + 0] * 0x1000000) +\n        (bytes[offset + 1] * 0x0010000) +\n        (bytes[offset + 2] * 0x0000100) +\n        (bytes[offset + 3])) * 0x100000000 +\n        (bytes[offset + 4] * 0x1000000) +\n        (bytes[offset + 5] * 0x0010000) +\n        (bytes[offset + 6] * 0x0000100) +\n        (bytes[offset + 7]));\n}\nexports.be8toi = be8toi;\n/**\n * Translate Integer (from 0 up to 65535) to a Uint8Array of length 2 of\n * the corresponding big-endian bytes.\n * @param {Number} num\n * @returns {Uint8Array}\n */\nfunction itobe2(num) {\n    return new Uint8Array([\n        (num >>> 8) & 0xFF,\n        (num) & 0xFF,\n    ]);\n}\nexports.itobe2 = itobe2;\n/**\n * Translate Integer to a Uint8Array of length 4 of the corresponding big-endian\n * bytes.\n * @param {Number} num\n * @returns {Uint8Array}\n */\nfunction itobe4(num) {\n    return new Uint8Array([\n        (num >>> 24) & 0xFF,\n        (num >>> 16) & 0xFF,\n        (num >>> 8) & 0xFF,\n        (num) & 0xFF,\n    ]);\n}\nexports.itobe4 = itobe4;\n/**\n * Translate Integer to a Uint8Array of length 8 of the corresponding big-endian\n * bytes.\n * /!\\ If the top-most bytes are set, this might go over MAX_SAFE_INTEGER, thus\n * leading to a \"bad\" value.\n * @param {Number} num\n * @returns {Uint8Array}\n */\nfunction itobe8(num) {\n    var l = (num % 0x100000000);\n    var h = (num - l) / 0x100000000;\n    return new Uint8Array([\n        (h >>> 24) & 0xFF,\n        (h >>> 16) & 0xFF,\n        (h >>> 8) & 0xFF,\n        (h) & 0xFF,\n        (l >>> 24) & 0xFF,\n        (l >>> 16) & 0xFF,\n        (l >>> 8) & 0xFF,\n        (l) & 0xFF,\n    ]);\n}\nexports.itobe8 = itobe8;\n/**\n * Translate groups of 2 little-endian bytes to Integer (from 0 up to 65535).\n * @param {Uint8Array} bytes\n * @param {Number} offset - The offset (from the start of the given array)\n * @returns {Number}\n */\nfunction le2toi(bytes, offset) {\n    return ((bytes[offset + 0] << 0) +\n        (bytes[offset + 1] << 8));\n}\nexports.le2toi = le2toi;\n/**\n * Translate groups of 4 little-endian bytes to Integer.\n * @param {Uint8Array} bytes\n * @param {Number} offset - The offset (from the start of the given array)\n * @returns {Number}\n */\nfunction le4toi(bytes, offset) {\n    return ((bytes[offset + 0]) +\n        (bytes[offset + 1] * 0x0000100) +\n        (bytes[offset + 2] * 0x0010000) +\n        (bytes[offset + 3] * 0x1000000));\n}\nexports.le4toi = le4toi;\n/**\n * Translate groups of 8 little-endian bytes to Integer.\n * @param {Uint8Array} bytes\n * @param {Number} offset - The offset (from the start of the given array)\n * @returns {Number}\n */\nfunction le8toi(bytes, offset) {\n    return ((bytes[offset + 0]) +\n        (bytes[offset + 1] * 0x0000100) +\n        (bytes[offset + 2] * 0x0010000) +\n        (bytes[offset + 3] * 0x1000000) +\n        ((bytes[offset + 4]) +\n            (bytes[offset + 5] * 0x0000100) +\n            (bytes[offset + 6] * 0x0010000) +\n            (bytes[offset + 7] * 0x1000000)) * 0x100000000);\n}\nexports.le8toi = le8toi;\n/**\n * Translate Integer (from 0 up to 65535) to a Uint8Array of length 2 of\n * the corresponding little-endian bytes.\n * @param {Number} num\n * @returns {Uint8Array}\n */\nfunction itole2(num) {\n    return new Uint8Array([\n        (num) & 0xFF,\n        (num >>> 8) & 0xFF,\n    ]);\n}\nexports.itole2 = itole2;\n/**\n * Translate Integer to a Uint8Array of length 4 of the corresponding\n * little-endian bytes.\n * @param {Number} num\n * @returns {Uint8Array}\n */\nfunction itole4(num) {\n    return new Uint8Array([\n        (num) & 0xFF,\n        (num >>> 8) & 0xFF,\n        (num >>> 16) & 0xFF,\n        (num >>> 24) & 0xFF,\n    ]);\n}\nexports.itole4 = itole4;\n/**\n * Translate Integer to a Uint8Array of length 8 of the corresponding\n * little-endian bytes.\n * @param {Number} num\n * @returns {Uint8Array}\n */\nfunction itole8(num) {\n    var l = (num % 0x100000000);\n    var h = (num - l) / 0x100000000;\n    return new Uint8Array([\n        (h) & 0xFF,\n        (h >>> 8) & 0xFF,\n        (h >>> 16) & 0xFF,\n        (h >>> 24) & 0xFF,\n        (l) & 0xFF,\n        (l >>> 8) & 0xFF,\n        (l >>> 16) & 0xFF,\n        (l >>> 24) & 0xFF,\n    ]);\n}\nexports.itole8 = itole8;\n/**\n * @param {string} uuid\n * @returns {string}\n * @throws AssertionError - The uuid length is not 16\n */\nfunction guidToUuid(uuid) {\n    assert_1.default(uuid.length === 16, \"UUID length should be 16\");\n    var buf = strToBytes(uuid);\n    var p1A = buf[0];\n    var p1B = buf[1];\n    var p1C = buf[2];\n    var p1D = buf[3];\n    var p2A = buf[4];\n    var p2B = buf[5];\n    var p3A = buf[6];\n    var p3B = buf[7];\n    var p4 = buf.subarray(8, 10);\n    var p5 = buf.subarray(10, 16);\n    var ord = new Uint8Array(16);\n    ord[0] = p1D;\n    ord[1] = p1C;\n    ord[2] = p1B;\n    ord[3] = p1A; // swap32 BE -> LE\n    ord[4] = p2B;\n    ord[5] = p2A; // swap16 BE -> LE\n    ord[6] = p3B;\n    ord[7] = p3A; // swap16 BE -> LE\n    ord.set(p4, 8);\n    ord.set(p5, 10);\n    return bytesToHex(ord);\n}\nexports.guidToUuid = guidToUuid;\n/**\n * Creates a base-64 encoded ASCII string from a string of binary data, with\n * possible trailing equal sign(s) stripped.\n * @param {string}\n * @returns {string}\n */\nfunction toBase64URL(str) {\n    return btoa(str).replace(/\\=+$/, \"\");\n}\nexports.toBase64URL = toBase64URL;\n\n\n//# sourceURL=webpack://RxPlayer/./src/utils/bytes.ts?");

/***/ }),

/***/ "./src/utils/castToObservable.ts":
/*!***************************************!*\
  !*** ./src/utils/castToObservable.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Observable_1 = __webpack_require__(/*! rxjs/Observable */ \"./node_modules/rxjs/Observable.js\");\n__webpack_require__(/*! rxjs/add/observable/fromPromise */ \"./node_modules/rxjs/add/observable/fromPromise.js\");\nfunction castToObservable(value) {\n    if (value instanceof Observable_1.Observable) {\n        return value;\n    }\n    if (value && typeof value.subscribe === \"function\") {\n        var valObsLike_1 = value;\n        return new Observable_1.Observable(function (obs) {\n            var sub = valObsLike_1.subscribe(function (val) { obs.next(val); }, function (err) { obs.error(err); }, function () { obs.complete(); });\n            return function () {\n                if (sub && sub.dispose) {\n                    sub.dispose();\n                }\n                else if (sub && sub.unsubscribe) {\n                    sub.unsubscribe();\n                }\n            };\n        });\n    }\n    if (value && typeof value.then === \"function\") {\n        return Observable_1.Observable.fromPromise(value);\n    }\n    return Observable_1.Observable.of(value);\n}\nexports.default = castToObservable;\n\n\n//# sourceURL=webpack://RxPlayer/./src/utils/castToObservable.ts?");

/***/ }),

/***/ "./src/utils/eventemitter.ts":
/*!***********************************!*\
  !*** ./src/utils/eventemitter.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar log_1 = __webpack_require__(/*! ./log */ \"./src/utils/log.ts\");\nvar EventEmitter = /** @class */ (function () {\n    function EventEmitter() {\n        this._listeners = {};\n    }\n    /**\n     * Register a new callback for an event.\n     *\n     * @param {string} evt - The event to register a callback to\n     * @param {Function} fn - The callback to call as that event is triggered.\n     * The callback will take as argument the eventual payload of the event\n     * (single argument).\n     */\n    EventEmitter.prototype.addEventListener = function (evt, fn) {\n        var listeners = this._listeners[evt];\n        if (!listeners) {\n            this._listeners[evt] = [fn];\n        }\n        else {\n            listeners.push(fn);\n        }\n    };\n    /**\n     * Unregister callbacks linked to events.\n     * @param {string} [evt] - The event for which the callback[s] should be\n     * unregistered. Set it to null or undefined to remove all callbacks\n     * currently registered (for any event).\n     * @param {Function} [fn] - The callback to unregister. If set to null\n     * or undefined while the evt argument is set, all callbacks linked to that\n     * event will be unregistered.\n     */\n    EventEmitter.prototype.removeEventListener = function (evt, fn) {\n        if (evt == null) {\n            this._listeners = {};\n            return;\n        }\n        var listeners = this._listeners[evt];\n        if (!listeners) {\n            return;\n        }\n        if (fn == null) {\n            delete this._listeners[evt];\n            return;\n        }\n        var index = listeners.indexOf(fn);\n        if (~index) {\n            listeners.splice(index, 1);\n        }\n        if (!listeners.length) {\n            delete this._listeners[evt];\n        }\n    };\n    /**\n     * Trigger every registered callbacks for a given event\n     * @param {string} evt - The event to trigger\n     * @param {*} arg - The eventual payload for that event. All triggered\n     * callbacks will recieve this payload as argument.\n     */\n    EventEmitter.prototype.trigger = function (evt, arg) {\n        var listeners = this._listeners[evt];\n        if (!listeners) {\n            return;\n        }\n        listeners.slice().forEach(function (listener) {\n            try {\n                listener(arg);\n            }\n            catch (e) {\n                log_1.default.error(e, e.stack);\n            }\n        });\n    };\n    return EventEmitter;\n}());\nexports.default = EventEmitter;\n\n\n//# sourceURL=webpack://RxPlayer/./src/utils/eventemitter.ts?");

/***/ }),

/***/ "./src/utils/id.ts":
/*!*************************!*\
  !*** ./src/utils/id.ts ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _lastId = 0;\n/**\n * @returns {string}\n */\nfunction generateNewId() {\n    var newId = 0;\n    if (_lastId < Number.MAX_VALUE) {\n        newId = _lastId + 1;\n    }\n    _lastId = newId;\n    return \"\" + newId;\n}\nexports.default = generateNewId;\n\n\n//# sourceURL=webpack://RxPlayer/./src/utils/id.ts?");

/***/ }),

/***/ "./src/utils/initialization_segment_cache.ts":
/*!***************************************************!*\
  !*** ./src/utils/initialization_segment_cache.ts ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Caching object used to cache initialization segments.\n * This allow to have a faster representation switch and faster seeking.\n */\nvar InitializationSegmentCache = /** @class */ (function () {\n    function InitializationSegmentCache() {\n        this._cache = new WeakMap();\n    }\n    /**\n     * @param {Object} obj\n     * @param {Object} obj.representation\n     * @param {Object} obj.segment\n     * @param {*} response\n     */\n    InitializationSegmentCache.prototype.add = function (_a, response) {\n        var representation = _a.representation, segment = _a.segment;\n        if (segment.isInit) {\n            this._cache.set(representation, response);\n        }\n    };\n    /**\n     * @param {Object} obj\n     * @param {Object} obj.segment\n     * @returns {*} response\n     * TODO just add segment directly, not in an object?\n     */\n    InitializationSegmentCache.prototype.get = function (_a) {\n        var representation = _a.representation, segment = _a.segment;\n        if (segment.isInit) {\n            var value = this._cache.get(representation);\n            if (value != null) {\n                return value;\n            }\n        }\n        return null;\n    };\n    return InitializationSegmentCache;\n}());\nexports.default = InitializationSegmentCache;\n\n\n//# sourceURL=webpack://RxPlayer/./src/utils/initialization_segment_cache.ts?");

/***/ }),

/***/ "./src/utils/languages/ISO_639-1_to_ISO_639-3.ts":
/*!*******************************************************!*\
  !*** ./src/utils/languages/ISO_639-1_to_ISO_639-3.ts ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Translate ISO 639-1 language codes into ISO 639-3 ones.\n */\nvar ISO_MAP_1_TO_3 = {\n    aa: \"aar\",\n    ab: \"abk\",\n    ae: \"ave\",\n    af: \"afr\",\n    ak: \"aka\",\n    am: \"amh\",\n    an: \"arg\",\n    ar: \"ara\",\n    as: \"asm\",\n    av: \"ava\",\n    ay: \"aym\",\n    az: \"aze\",\n    ba: \"bak\",\n    be: \"bel\",\n    bg: \"bul\",\n    bi: \"bis\",\n    bm: \"bam\",\n    bn: \"ben\",\n    bo: \"bod\",\n    br: \"bre\",\n    bs: \"bos\",\n    ca: \"cat\",\n    ce: \"che\",\n    ch: \"cha\",\n    co: \"cos\",\n    cr: \"cre\",\n    cs: \"ces\",\n    cu: \"chu\",\n    // Old Slavonic, Old Bulgarian\n    cv: \"chv\",\n    cy: \"cym\",\n    da: \"dan\",\n    de: \"deu\",\n    dv: \"div\",\n    dz: \"dzo\",\n    ee: \"ewe\",\n    el: \"ell\",\n    en: \"eng\",\n    eo: \"epo\",\n    es: \"spa\",\n    et: \"est\",\n    eu: \"eus\",\n    fa: \"fas\",\n    ff: \"ful\",\n    fi: \"fin\",\n    fj: \"fij\",\n    fo: \"fao\",\n    fr: \"fra\",\n    fy: \"fry\",\n    ga: \"gle\",\n    gd: \"gla\",\n    gl: \"glg\",\n    gn: \"grn\",\n    gu: \"guj\",\n    gv: \"glv\",\n    ha: \"hau\",\n    he: \"heb\",\n    hi: \"hin\",\n    ho: \"hmo\",\n    hr: \"hrv\",\n    ht: \"hat\",\n    hu: \"hun\",\n    hy: \"hye\",\n    hz: \"her\",\n    ia: \"ina\",\n    id: \"ind\",\n    ie: \"ile\",\n    ig: \"ibo\",\n    ii: \"iii\",\n    ik: \"ipk\",\n    io: \"ido\",\n    is: \"isl\",\n    it: \"ita\",\n    iu: \"iku\",\n    ja: \"jpn\",\n    jv: \"jav\",\n    ka: \"kat\",\n    kg: \"kon\",\n    ki: \"kik\",\n    kj: \"kua\",\n    kk: \"kaz\",\n    kl: \"kal\",\n    km: \"khm\",\n    kn: \"kan\",\n    ko: \"kor\",\n    kr: \"kau\",\n    ks: \"kas\",\n    ku: \"kur\",\n    kv: \"kom\",\n    kw: \"cor\",\n    ky: \"kir\",\n    la: \"lat\",\n    lb: \"ltz\",\n    lg: \"lug\",\n    li: \"lim\",\n    ln: \"lin\",\n    lo: \"lao\",\n    lt: \"lit\",\n    lu: \"lub\",\n    lv: \"lav\",\n    mg: \"mlg\",\n    mh: \"mah\",\n    mi: \"mri\",\n    mk: \"mkd\",\n    ml: \"mal\",\n    mn: \"mon\",\n    mr: \"mar\",\n    ms: \"msa\",\n    mt: \"mlt\",\n    my: \"mya\",\n    na: \"nau\",\n    nb: \"nob\",\n    nd: \"nde\",\n    ne: \"nep\",\n    ng: \"ndo\",\n    nl: \"nld\",\n    nn: \"nno\",\n    no: \"nor\",\n    nr: \"nbl\",\n    nv: \"nav\",\n    ny: \"nya\",\n    oc: \"oci\",\n    oj: \"oji\",\n    om: \"orm\",\n    or: \"ori\",\n    os: \"oss\",\n    pa: \"pan\",\n    pi: \"pli\",\n    pl: \"pol\",\n    ps: \"pus\",\n    pt: \"por\",\n    qu: \"que\",\n    rm: \"roh\",\n    rn: \"run\",\n    ro: \"ron\",\n    ru: \"rus\",\n    rw: \"kin\",\n    sa: \"san\",\n    sc: \"srd\",\n    sd: \"snd\",\n    se: \"sme\",\n    sg: \"sag\",\n    si: \"sin\",\n    sk: \"slk\",\n    sl: \"slv\",\n    sm: \"smo\",\n    sn: \"sna\",\n    so: \"som\",\n    sq: \"sqi\",\n    sr: \"srp\",\n    ss: \"ssw\",\n    st: \"sot\",\n    su: \"sun\",\n    sv: \"swe\",\n    sw: \"swa\",\n    ta: \"tam\",\n    te: \"tel\",\n    tg: \"tgk\",\n    th: \"tha\",\n    ti: \"tir\",\n    tk: \"tuk\",\n    tl: \"tgl\",\n    tn: \"tsn\",\n    to: \"ton\",\n    tr: \"tur\",\n    ts: \"tso\",\n    tt: \"tat\",\n    tw: \"twi\",\n    ty: \"tah\",\n    ug: \"uig\",\n    uk: \"ukr\",\n    ur: \"urd\",\n    uz: \"uzb\",\n    ve: \"ven\",\n    vi: \"vie\",\n    vo: \"vol\",\n    wa: \"wln\",\n    wo: \"wol\",\n    xh: \"xho\",\n    yi: \"yid\",\n    yo: \"yor\",\n    za: \"zha\",\n    zh: \"zho\",\n    zu: \"zul\",\n};\nexports.default = ISO_MAP_1_TO_3;\n\n\n//# sourceURL=webpack://RxPlayer/./src/utils/languages/ISO_639-1_to_ISO_639-3.ts?");

/***/ }),

/***/ "./src/utils/languages/ISO_639-2_to_ISO_639-3.ts":
/*!*******************************************************!*\
  !*** ./src/utils/languages/ISO_639-2_to_ISO_639-3.ts ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Translate ISO 639-2 synonyms to their ISO 639-3 counterparts.\n */\nvar ISO_MAP_2_TO_3 = {\n    alb: \"sqi\",\n    arm: \"hye\",\n    baq: \"eus\",\n    bur: \"mya\",\n    chi: \"zho\",\n    cze: \"ces\",\n    dut: \"nld\",\n    fre: \"fra\",\n    geo: \"kat\",\n    ger: \"deu\",\n    gre: \"ell\",\n    ice: \"isl\",\n    mac: \"mkd\",\n    mao: \"mri\",\n    may: \"msa\",\n    per: \"fas\",\n    slo: \"slk\",\n    rum: \"ron\",\n    tib: \"bod\",\n    wel: \"cym\",\n};\nexports.default = ISO_MAP_2_TO_3;\n\n\n//# sourceURL=webpack://RxPlayer/./src/utils/languages/ISO_639-2_to_ISO_639-3.ts?");

/***/ }),

/***/ "./src/utils/languages/index.ts":
/*!**************************************!*\
  !*** ./src/utils/languages/index.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ISO_639_1_to_ISO_639_3_1 = __webpack_require__(/*! ./ISO_639-1_to_ISO_639-3 */ \"./src/utils/languages/ISO_639-1_to_ISO_639-3.ts\");\nvar ISO_639_2_to_ISO_639_3_1 = __webpack_require__(/*! ./ISO_639-2_to_ISO_639-3 */ \"./src/utils/languages/ISO_639-2_to_ISO_639-3.ts\");\n/**\n * Normalize language given.\n * Basically:\n *   - converts it to lowercase.\n *   - normalize \"base\" (what is before the possible first \"-\") to an ISO639-3\n *     compatible string.\n * @param {string} _language\n * @returns {string}\n */\nfunction normalize(_language) {\n    if (_language == null || _language === \"\") {\n        return \"\";\n    }\n    var fields = (\"\" + _language).toLowerCase().split(\"-\");\n    var base = fields[0];\n    var normalizedBase = normalizeBase(base);\n    if (normalizedBase) {\n        fields[0] = normalizedBase;\n    }\n    return fields.join(\"-\");\n}\nexports.normalize = normalize;\n/**\n * Normalize language into an ISO639-3 format.\n * @param {string} base\n * @returns {string}\n */\nfunction normalizeBase(base) {\n    var result;\n    switch (base.length) {\n        case 2:\n            result = ISO_639_1_to_ISO_639_3_1.default[base];\n            break;\n        case 3:\n            result = ISO_639_2_to_ISO_639_3_1.default[base];\n            break;\n    }\n    return result || base;\n}\n/**\n * Normalize text track from a user given input into an object\n * with three properties:\n *   - language {string}: The language the user gave us\n *   - normalized {string}: An attempt to normalize the language into an\n *     ISO 639-3 code\n *   - closedCaption {Boolean}: Whether the track is a closed caption track\n * @param {Object|string} _language\n * @returns {Object|null|undefined}\n */\nfunction normalizeTextTrack(_language) {\n    if (_language != null) {\n        var language = void 0;\n        var closedCaption = void 0;\n        if (typeof _language === \"string\") {\n            language = _language;\n            closedCaption = false;\n        }\n        else {\n            language = _language.language;\n            closedCaption = !!_language.closedCaption;\n        }\n        return {\n            language: language,\n            closedCaption: closedCaption,\n            normalized: normalize(language),\n        };\n    }\n    return _language;\n}\nexports.normalizeTextTrack = normalizeTextTrack;\n/**\n * Normalize audio track from a user given input into an object\n * with three properties:\n *   - language {string}: The language the user gave us\n *   - normalized {string}: An attempt to normalize the language into an\n *     ISO 639-3 code\n *   - audioDescription {Boolean}: Whether the track is a closed caption track\n * @param {Object|string} _language\n * @returns {Object|null|undefined}\n */\nfunction normalizeAudioTrack(_language) {\n    if (_language != null) {\n        var language = void 0;\n        var audioDescription = void 0;\n        if (typeof _language === \"string\") {\n            language = _language;\n            audioDescription = false;\n        }\n        else {\n            language = _language.language;\n            audioDescription = !!_language.audioDescription;\n        }\n        return {\n            language: language,\n            audioDescription: audioDescription,\n            normalized: normalize(language),\n        };\n    }\n    return _language;\n}\nexports.normalizeAudioTrack = normalizeAudioTrack;\n\n\n//# sourceURL=webpack://RxPlayer/./src/utils/languages/index.ts?");

/***/ }),

/***/ "./src/utils/log.ts":
/*!**************************!*\
  !*** ./src/utils/log.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar noop_1 = __webpack_require__(/*! ./noop */ \"./src/utils/noop.ts\");\nvar LEVELS = {\n    NONE: 0,\n    ERROR: 1,\n    WARNING: 2,\n    INFO: 3,\n    DEBUG: 4,\n};\nvar currentLevel = Object.keys(LEVELS)[0];\nvar logger = {\n    LEVELS: Object.keys(LEVELS),\n    error: noop_1.default,\n    warn: noop_1.default,\n    info: noop_1.default,\n    debug: noop_1.default,\n    setLevel: function (levelStr) {\n        var level;\n        var foundLevel = LEVELS[levelStr];\n        if (foundLevel) {\n            level = foundLevel;\n            currentLevel = levelStr;\n        }\n        else { // either 0 or not found\n            level = 0;\n            currentLevel = \"NONE\";\n        }\n        /* tslint:disable no-invalid-this */\n        this.error = (level >= LEVELS.ERROR) ?\n            console.error.bind(console) : noop_1.default;\n        this.warn = (level >= LEVELS.WARNING) ?\n            console.warn.bind(console) : noop_1.default;\n        this.info = (level >= LEVELS.INFO) ?\n            console.info.bind(console) : noop_1.default;\n        this.debug = (level >= LEVELS.DEBUG) ?\n            console.log.bind(console) : noop_1.default;\n        /* tslint:enable no-invalid-this */\n    },\n    getLevel: function () {\n        return currentLevel;\n    },\n};\nexports.default = logger;\n\n\n//# sourceURL=webpack://RxPlayer/./src/utils/log.ts?");

/***/ }),

/***/ "./src/utils/noop.ts":
/*!***************************!*\
  !*** ./src/utils/noop.ts ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Do nothing, well.\n */\n/* tslint:disable:no-empty */\nfunction default_1() { }\nexports.default = default_1;\n/* tslint:enable:no-empty */\n\n\n//# sourceURL=webpack://RxPlayer/./src/utils/noop.ts?");

/***/ }),

/***/ "./src/utils/ranges.ts":
/*!*****************************!*\
  !*** ./src/utils/ranges.ts ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * This file contains functions helping with TimeRanges management.\n *\n * For simplicity/performance reasons, many of those work with a simplified\n * \"Range\" object, which is an object with two keys:\n *   - start {Number}\n *   - end {Number}\n *\n * Those two corresponds to what is returned by the start and end methods of a\n * TimeRanges Object.\n *\n * You can convert from TimeRanges to Range object(s) with the getRange/\n * convertToRanges methods.\n */\n// Factor for rounding errors\nvar EPSILON = 1 / 60;\n/**\n * @param {number} start\n * @param {number} end\n * @returns {Object}\n */\nfunction createRange(start, end) {\n    return { start: start, end: end };\n}\nexports.createRange = createRange;\n/**\n * Check equality with a tolerance of EPSILON.\n * Used for various functions with this sort of tolerance regarding the\n * start/end of contiguous ranges.\n * @param {Number} a\n * @param {Number} b\n * @returns {Boolean}\n */\nfunction nearlyEqual(a, b) {\n    return Math.abs(a - b) < EPSILON;\n}\n/**\n * Construct a new range which will have, as start/end, the min/max\n * of both the range given, and the given bitrate.\n * @param {Object} range1\n * @param {Object} range2\n * @returns {Object}\n */\nfunction createRangeUnion(range1, range2) {\n    var start = Math.min(range1.start, range2.start);\n    var end = Math.max(range1.end, range2.end);\n    return { start: start, end: end };\n}\n/**\n * Clean array ranges from \"empty\" ranges.\n * That is, range objects which have their start equal to their end.\n * /!\\ Mutate the array of ranges.\n * @param {Array<Object>} ranges\n * @returns {Array<Object>}\n */\nfunction removeEmptyRanges(ranges) {\n    for (var index = 0; index < ranges.length; index++) {\n        var range = ranges[index];\n        if (range.start === range.end) {\n            ranges.splice(index++, 1);\n        }\n    }\n    return ranges;\n}\nexports.removeEmptyRanges = removeEmptyRanges;\n/**\n * /!\\ Mutate the array of ranges.\n * @param {Array<Object>} ranges\n * @returns {Array<Object>}\n */\nfunction mergeContiguousRanges(ranges) {\n    for (var index = 1; index < ranges.length; index++) {\n        var prevRange = ranges[index - 1];\n        var currRange = ranges[index];\n        if (areRangesNearlyContiguous(prevRange, currRange)) {\n            var unionRange = createRangeUnion(prevRange, currRange);\n            ranges.splice(--index, 2, unionRange);\n        }\n    }\n    return ranges;\n}\nexports.mergeContiguousRanges = mergeContiguousRanges;\n/**\n * True if range1 is considered _after_ range2.\n * @param {Object} range1\n * @param {Object} range2\n * @returns {Boolean}\n */\nfunction isAfter(range1, range2) {\n    return range1.start >= range2.end;\n}\nexports.isAfter = isAfter;\n/**\n * True if range1 is considered _before_ range2.\n * @param {Object} range1\n * @param {Object} range2\n * @returns {Boolean}\n */\nfunction isBefore(range1, range2) {\n    return range1.end <= range2.start;\n}\nexports.isBefore = isBefore;\n/**\n * Returns true if the time given can be considered as part of the given range.\n * @param {Object} range1\n * @param {Number} Time\n * @returns {Boolean}\n */\nfunction isTimeInRange(_a, time) {\n    var start = _a.start, end = _a.end;\n    return start <= time && time < end;\n}\nexports.isTimeInRange = isTimeInRange;\n/**\n * Returns true if the two ranges given are overlapping.\n * @param {Object} range1\n * @param {Object} range2\n * @returns {Boolean}\n */\nfunction areRangesOverlapping(range1, range2) {\n    return isTimeInRange(range1, range2.start) ||\n        range1.start < range2.end && range2.end < range1.end ||\n        isTimeInRange(range2, range1.start);\n}\n/**\n * Returns true if the two ranges given can be considered contiguous.\n * @param {Object} range1\n * @param {Object} range2\n * @returns {Boolean}\n */\nfunction areRangesNearlyContiguous(range1, range2) {\n    return nearlyEqual(range2.start, range1.end) ||\n        nearlyEqual(range2.end, range1.start);\n}\n/**\n * Convert from a TimeRanges object to an array of Ranges.\n * @param {TimeRanges} timeRanges\n * @returns {Array.<Object>}\n */\nfunction convertToRanges(timeRanges) {\n    var ranges = [];\n    for (var i = 0; i < timeRanges.length; i++) {\n        ranges.push({\n            start: timeRanges.start(i),\n            end: timeRanges.end(i),\n        });\n    }\n    return ranges;\n}\nexports.convertToRanges = convertToRanges;\n/**\n * Get range object of a specific time in a TimeRanges object.\n * @param {TimeRanges} timeRanges\n * @returns {Object}\n */\nfunction getRange(timeRanges, time) {\n    for (var i = timeRanges.length - 1; i >= 0; i--) {\n        var start = timeRanges.start(i);\n        if (time >= start) {\n            var end = timeRanges.end(i);\n            if (time < end) {\n                return {\n                    start: start,\n                    end: end,\n                };\n            }\n        }\n    }\n    return null;\n}\nexports.getRange = getRange;\n/**\n * Get gap from a specific time until the start of the next Range.\n * @param {TimeRanges} timeRanges\n * @param {Number} time\n * @returns {Number}\n */\nfunction getNextRangeGap(timeRanges, time) {\n    var len = timeRanges.length;\n    for (var i = 0; i < len; i++) {\n        var start = timeRanges.start(i);\n        if (time < start) {\n            return start - time;\n        }\n    }\n    return Infinity;\n}\nexports.getNextRangeGap = getNextRangeGap;\n/**\n * @param {TimeRanges} timeRanges\n * @param {Number} time\n * @returns {Object} - Object with two properties:\n *   - outerRanges {Array.<Object>}: every ranges which does not contain the\n *     given time.\n *   - innerRange {Object|null}: the range which contain the given time.\n */\nfunction getInnerAndOuterTimeRanges(timeRanges, time) {\n    var innerRange = null;\n    var outerRanges = [];\n    for (var i = 0; i < timeRanges.length; i++) {\n        var start = timeRanges.start(i);\n        var end = timeRanges.end(i);\n        if (time < start || time >= end) {\n            outerRanges.push({ start: start, end: end });\n        }\n        else {\n            innerRange = { start: start, end: end };\n        }\n    }\n    return { outerRanges: outerRanges, innerRange: innerRange };\n}\nexports.getInnerAndOuterTimeRanges = getInnerAndOuterTimeRanges;\n/**\n * Get \"size\" (difference between end and start) of the range containing the\n * given time. 0 if the range is not found.\n * @param {TimeRanges} timeRanges\n * @param {Number} currentTime\n * @returns {Number}\n */\nfunction getSizeOfRange(timeRanges, currentTime) {\n    var range = getRange(timeRanges, currentTime);\n    return range\n        ? range.end - range.start\n        : 0;\n}\nexports.getSizeOfRange = getSizeOfRange;\n/**\n * Get \"currently played\" (difference between time given and start) of the\n * range containing the given time. 0 if the range is not found.\n * @param {TimeRanges} timeRanges\n * @param {Number} currentTime\n * @returns {Number}\n */\nfunction getPlayedSizeOfRange(timeRanges, currentTime) {\n    var range = getRange(timeRanges, currentTime);\n    return range\n        ? currentTime - range.start\n        : 0;\n}\nexports.getPlayedSizeOfRange = getPlayedSizeOfRange;\n/**\n * Get \"left to play\" (difference between end and time given) of the range\n * containing the given time. Infinity if the range is not found.\n * @param {TimeRanges} timeRanges\n * @param {Number} currentTime\n * @returns {Number}\n */\nfunction getLeftSizeOfRange(timeRanges, currentTime) {\n    var range = getRange(timeRanges, currentTime);\n    return range\n        ? range.end - currentTime\n        : Infinity;\n}\nexports.getLeftSizeOfRange = getLeftSizeOfRange;\n/**\n * Insert a range object into an array of ranges objects, at the right place.\n * /!\\ Mutate the array of ranges.\n * @param {Array.<Object>} ranges\n * @param {Object} rangeToAddArg\n * @returns {Array.<Object>}\n */\nfunction insertInto(ranges, rangeToAddArg) {\n    if (rangeToAddArg.start === rangeToAddArg.end) {\n        return ranges;\n    }\n    var rangeToAdd = rangeToAddArg;\n    // For each present range check if we need to:\n    // - In case we are overlapping or contiguous:\n    //   - if added range has the same bitrate as the overlapped or\n    //     contiguous one, we can merge themcurrentRange\n    //   - if added range has a different bitrate we need to insert it\n    //     in place\n    // - Need to insert in place, we we are completely, not overlapping\n    //   and not contiguous in between two ranges.\n    var index = 0;\n    for (; index < ranges.length; index++) {\n        var range = ranges[index];\n        var overlapping = areRangesOverlapping(rangeToAdd, range);\n        var contiguous = areRangesNearlyContiguous(rangeToAdd, range);\n        // We assume ranges are ordered and two ranges can not be\n        // completely overlapping.\n        if (overlapping || contiguous) {\n            rangeToAdd = createRangeUnion(rangeToAdd, range);\n            ranges.splice(index--, 1);\n        }\n        else {\n            // Check the case for which there is no more to do\n            if (index === 0) {\n                if (isBefore(rangeToAdd, ranges[0])) {\n                    // First index, and we are completely before that range (and\n                    // not contiguous, nor overlapping). We just need to be\n                    // inserted here.\n                    break;\n                }\n            }\n            else {\n                if (isBefore(ranges[index - 1], rangeToAdd)\n                    && isBefore(rangeToAdd, range)) {\n                    // We are exactly after the current previous range, and\n                    // before the current range, while not overlapping with none\n                    // of them. Insert here.\n                    break;\n                }\n            }\n        }\n    }\n    // Now that we are sure we don't overlap with any range, just add it.\n    ranges.splice(index, 0, rangeToAdd);\n    return mergeContiguousRanges(removeEmptyRanges(ranges));\n}\nexports.insertInto = insertInto;\n/**\n * Returns range, from a range objects array overlapping with a range given\n * in argument. null if none is found.\n * @param {Object} range\n * @param {Array.<Object>} ranges\n * @returns {Object|null}\n */\nfunction findOverlappingRange(range, ranges) {\n    for (var i = 0; i < ranges.length; i++) {\n        if (areRangesOverlapping(range, ranges[i])) {\n            return ranges[i];\n        }\n    }\n    return null;\n}\n/**\n * Returns only the intersection between the two ranges, from the first\n * ranges argument given.\n * /!\\ Mutates the ranges1 array given\n * @param {Array.<Range>} ranges1\n * @param {Array.<Range>} ranges2\n * @returns {Array.<Range>}\n */\nfunction keepRangeIntersection(ranges1, ranges2) {\n    for (var i = 0; i < ranges1.length; i++) {\n        var range = ranges1[i];\n        var overlappingRange = findOverlappingRange(range, ranges2);\n        if (!overlappingRange) {\n            ranges1.splice(i--, 1);\n        }\n        else if (overlappingRange.start > range.start) {\n            range.start = overlappingRange.start;\n        }\n        else if (overlappingRange.end < range.end) {\n            range.end = overlappingRange.end;\n        }\n    }\n    return ranges1;\n}\nexports.keepRangeIntersection = keepRangeIntersection;\n\n\n//# sourceURL=webpack://RxPlayer/./src/utils/ranges.ts?");

/***/ }),

/***/ "./src/utils/request/index.ts":
/*!************************************!*\
  !*** ./src/utils/request/index.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Observable_1 = __webpack_require__(/*! rxjs/Observable */ \"./node_modules/rxjs/Observable.js\");\nvar errors_1 = __webpack_require__(/*! ../../errors */ \"./src/errors/index.ts\");\nvar DEFAULT_RESPONSE_TYPE = \"json\";\nvar DEFAULT_REQUEST_TIMEOUT = 30 * 1000; // TODO move to config?\nfunction toJSONForIE(data) {\n    try {\n        return JSON.parse(data);\n    }\n    catch (e) {\n        return null;\n    }\n}\nfunction request(options) {\n    var requestOptions = {\n        url: options.url,\n        body: options.body,\n        headers: options.headers,\n        method: options.method == null ?\n            \"GET\" : options.method,\n        responseType: options.responseType == null ?\n            DEFAULT_RESPONSE_TYPE : options.responseType,\n        timeout: options.timeout == null ?\n            DEFAULT_REQUEST_TIMEOUT : options.timeout,\n    };\n    return Observable_1.Observable.create(function (obs) {\n        var url = requestOptions.url, headers = requestOptions.headers, method = requestOptions.method, responseType = requestOptions.responseType, timeout = requestOptions.timeout, body = requestOptions.body;\n        var xhr = new XMLHttpRequest();\n        xhr.open(method, url, true);\n        if (timeout >= 0) {\n            xhr.timeout = timeout;\n        }\n        xhr.responseType = responseType;\n        if (xhr.responseType === \"document\") {\n            xhr.overrideMimeType(\"text/xml\");\n        }\n        if (headers) {\n            var _headers = headers;\n            for (var key in _headers) {\n                if (_headers.hasOwnProperty(key)) {\n                    xhr.setRequestHeader(key, _headers[key]);\n                }\n            }\n        }\n        var sentTime = Date.now();\n        xhr.onerror = function onXHRError() {\n            var errorCode = errors_1.RequestErrorTypes.ERROR_EVENT;\n            obs.error(new errors_1.RequestError(xhr, url, errorCode));\n        };\n        xhr.ontimeout = function onXHRTimeout() {\n            var errorCode = errors_1.RequestErrorTypes.TIMEOUT;\n            obs.error(new errors_1.RequestError(xhr, url, errorCode));\n        };\n        if (!options.ignoreProgressEvents) {\n            xhr.onprogress = function onXHRProgress(event) {\n                var currentTime = Date.now();\n                obs.next({\n                    type: \"progress\",\n                    value: {\n                        url: url,\n                        duration: currentTime - sentTime,\n                        sentTime: sentTime,\n                        currentTime: currentTime,\n                        size: event.loaded,\n                        totalSize: event.total,\n                    },\n                });\n            };\n        }\n        // XXX TODO:\n        // Waiting for https://github.com/Microsoft/TypeScript/issues/19830\n        xhr.onload = function onXHRLoad(event) {\n            if (xhr.readyState === 4) {\n                if (xhr.status >= 200 && xhr.status < 300) {\n                    var receivedTime = Date.now();\n                    var totalSize = event.total;\n                    var status_1 = xhr.status;\n                    var loadedResponseType = xhr.responseType;\n                    var _url = xhr.responseURL || url;\n                    var responseData = void 0;\n                    if (loadedResponseType === \"json\") {\n                        // IE bug where response is string with responseType json\n                        responseData = xhr.response !== \"string\" ?\n                            xhr.response : toJSONForIE(xhr.responseText);\n                    }\n                    else {\n                        responseData = xhr.response;\n                    }\n                    if (responseData == null) {\n                        var errorCode = errors_1.RequestErrorTypes.PARSE_ERROR;\n                        obs.error(new errors_1.RequestError(xhr, _url, errorCode));\n                        return;\n                    }\n                    obs.next({\n                        type: \"response\",\n                        value: {\n                            status: status_1,\n                            url: _url,\n                            responseType: loadedResponseType,\n                            sentTime: sentTime,\n                            receivedTime: receivedTime,\n                            duration: receivedTime - sentTime,\n                            size: totalSize,\n                            responseData: responseData,\n                        },\n                    });\n                    obs.complete();\n                }\n                else {\n                    var errorCode = errors_1.RequestErrorTypes.ERROR_HTTP_CODE;\n                    obs.error(new errors_1.RequestError(xhr, url, errorCode));\n                }\n            }\n        };\n        if (body !== undefined) {\n            xhr.send(body);\n        }\n        else {\n            xhr.send();\n        }\n        return function () {\n            if (xhr && xhr.readyState !== 4) {\n                xhr.abort();\n            }\n        };\n    });\n}\nexports.default = request;\n\n\n//# sourceURL=webpack://RxPlayer/./src/utils/request/index.ts?");

/***/ }),

/***/ "./src/utils/retry.ts":
/*!****************************!*\
  !*** ./src/utils/retry.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Observable_1 = __webpack_require__(/*! rxjs/Observable */ \"./node_modules/rxjs/Observable.js\");\nvar backoff_1 = __webpack_require__(/*! ./backoff */ \"./src/utils/backoff.ts\");\n/**\n * Simple debounce implementation.\n * @param {Function} fn\n * @param {Number} delay - delay in ms\n * @returns {Function}\n */\nfunction debounce(fn, delay) {\n    var timer = 0;\n    return function () {\n        if (timer) {\n            clearTimeout(timer);\n        }\n        timer = window.setTimeout(fn, delay);\n    };\n}\n/**\n * Retry the given observable (if it triggers an error) with an exponential\n * backoff.\n * The backoff behavior can be tweaked through the options given.\n *\n * @param {Observable} obs$\n * @param {Object} options\n * @param {Number} options.retryDelay - The initial delay, in ms.\n * This delay will be fuzzed to fall under the range +-30% each time a new retry\n * is done.\n * Then, this delay will be multiplied by 2^(n-1), n being the counter of retry\n * we performed (beginning at 1 for the first retry).\n * @param {Number} options.totalRetry - The amount of time we should retry. 0\n * means no retry, 1 means a single retry, Infinity means infinite retry etc.\n * If the observable still fails after this number of retry, the error will\n * be throwed through this observable.\n * @param {Number} [options.resetDelay] - Delay in ms since a retry after which\n * the counter of retry will be reset if the observable wasn't retried a new\n * time. 0 / undefined means no delay will be applied.\n * @param {Function} [options.shouldRetry] - Function which will receive the\n * observable error each time it fails, and should return a boolean. If this\n * boolean is false, the error will be directly thrown (without anymore retry).\n * @param {Function} [options.onRetry] - Function which will be triggered at\n * each retry. Will receive two arguments:\n *   1. The observable error\n *   2. The current retry count, beginning at 1 for the first retry\n * @param {Function} [options.errorSelector] - If and when the observable will\n * definitely throw (without retrying), this function will be called with two\n * arguments:\n *   1. The observable error\n *   2. The final retry count, beginning at 1 for the first retry\n * The returned value will be what will be thrown by the observable.\n * @returns {Observable}\n * TODO Take errorSelector out. Should probably be entirely managed in the\n * calling code via a catch (much simpler to use and to understand).\n */\nfunction retryObsWithBackoff(obs$, options) {\n    var retryDelay = options.retryDelay, totalRetry = options.totalRetry, shouldRetry = options.shouldRetry, resetDelay = options.resetDelay, errorSelector = options.errorSelector, onRetry = options.onRetry;\n    var retryCount = 0;\n    var debounceRetryCount;\n    if (resetDelay != null && resetDelay > 0) {\n        debounceRetryCount = debounce(function () { retryCount = 0; }, resetDelay);\n    }\n    return obs$.catch(function (error, source) {\n        var wantRetry = !shouldRetry || shouldRetry(error);\n        if (!wantRetry || retryCount++ >= totalRetry) {\n            if (errorSelector) {\n                throw errorSelector(error, retryCount);\n            }\n            else {\n                throw error;\n            }\n        }\n        if (onRetry) {\n            onRetry(error, retryCount);\n        }\n        var fuzzedDelay = backoff_1.getBackedoffDelay(retryDelay, retryCount);\n        return Observable_1.Observable.timer(fuzzedDelay).mergeMap(function () {\n            if (debounceRetryCount) {\n                debounceRetryCount();\n            }\n            return source;\n        });\n    });\n}\nexports.retryObsWithBackoff = retryObsWithBackoff;\n/**\n * Retry the given function (if it triggers an error) with an exponential\n * backoff.\n * The backoff behavior can be tweaked through the options given.\n *\n * @param {Number} options.retryDelay - The initial delay, in ms.\n * This delay will be fuzzed to fall under the range +-30% each time a new retry\n * is done.\n * Then, this delay will be multiplied by 2^(n-1), n being the counter of retry\n * we performed (beginning at 1 for the first retry).\n * @param {Number} options.totalRetry - The amount of time we should retry. 0\n * means no retry, 1 means a single retry, Infinity means infinite retry etc.\n * If the observable still fails after this number of retry, the error will\n * be throwed through this observable.\n * @param {Number} [options.resetDelay] - Delay in ms since a retry after which\n * the counter of retry will be reset if the observable wasn't retried a new\n * time. 0 / undefined means no delay will be applied.\n * @param {Function} [options.shouldRetry] - Function which will receive the\n * observable error each time it fails, and should return a boolean. If this\n * boolean is false, the error will be directly thrown (without anymore retry).\n * @param {Function} [options.onRetry] - Function which will be triggered at\n * each retry. Will receive two arguments:\n *   1. The observable error\n *   2. The current retry count, beginning at 1 for the first retry\n * @param {Function} [options.errorSelector] - If and when the observable will\n * definitely throw (without retrying), this function will be called with two\n * arguments:\n *   1. The observable error\n *   2. The final retry count, beginning at 1 for the first retry\n * The returned value will be what will be thrown by the observable.\n * @returns {Observable}\n * TODO Take errorSelector out. Should probably be entirely managed in the\n * calling code via a catch (much simpler to use and to understand).\n */\nfunction retryFuncWithBackoff(func, options) {\n    var retryDelay = options.retryDelay, totalRetry = options.totalRetry, shouldRetry = options.shouldRetry, resetDelay = options.resetDelay, errorSelector = options.errorSelector, onRetry = options.onRetry;\n    var retryCount = 0;\n    var debounceRetryCount;\n    if (resetDelay != null && resetDelay > 0) {\n        debounceRetryCount = debounce(function () { retryCount = 0; }, resetDelay);\n    }\n    function doRetry() {\n        var func$ = Observable_1.Observable.create(function (obs) {\n            obs.next(func());\n            obs.complete();\n        });\n        return func$.catch(function (error) {\n            var wantRetry = !shouldRetry || shouldRetry(error);\n            if (!wantRetry || retryCount++ >= totalRetry) {\n                if (errorSelector) {\n                    throw errorSelector(error, retryCount);\n                }\n                else {\n                    throw error;\n                }\n            }\n            if (onRetry) {\n                onRetry(error, retryCount);\n            }\n            var fuzzedDelay = backoff_1.getBackedoffDelay(retryDelay, retryCount);\n            return Observable_1.Observable\n                .timer(fuzzedDelay)\n                .mergeMap(function () {\n                if (debounceRetryCount) {\n                    debounceRetryCount();\n                }\n                return doRetry();\n            });\n        });\n    }\n    return doRetry();\n}\nexports.retryFuncWithBackoff = retryFuncWithBackoff;\n/**\n * Same than retryObsWithBackoff, only with a function returning an observable\n * instead of an observable.\n * @param {Function} fn - Function returning an Observable which\n * will (well, might) be retried.\n * @param {Object} options\n * @param {Number} options.retryDelay\n * @param {Number} options.totalRetry\n * @param {Number} [options.resetDelay]\n * @param {Function} [options.shouldRetry]\n * @param {Function} [options.errorSelector]\n * @param {Function} [options.onRetry]\n * @returns {Function} - take in argument fn's arguments, returns\n * an Observable.\n */\nfunction retryableFuncWithBackoff(fn, options) {\n    var retryDelay = options.retryDelay, totalRetry = options.totalRetry, shouldRetry = options.shouldRetry, resetDelay = options.resetDelay, errorSelector = options.errorSelector, onRetry = options.onRetry;\n    var retryCount = 0;\n    var debounceRetryCount;\n    if (resetDelay != null && resetDelay > 0) {\n        debounceRetryCount = debounce(function () { retryCount = 0; }, resetDelay);\n    }\n    return function doRetry() {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        return fn.apply(void 0, args).catch(function (error) {\n            var wantRetry = !shouldRetry || shouldRetry(error);\n            if (!wantRetry || retryCount++ >= totalRetry) {\n                if (errorSelector) {\n                    throw errorSelector(error, retryCount);\n                }\n                else {\n                    throw error;\n                }\n            }\n            if (onRetry) {\n                onRetry(error, retryCount);\n            }\n            var fuzzedDelay = backoff_1.getBackedoffDelay(retryDelay, retryCount);\n            return Observable_1.Observable.timer(fuzzedDelay).mergeMap(function () {\n                if (debounceRetryCount) {\n                    debounceRetryCount();\n                }\n                return doRetry.apply(void 0, args);\n            });\n        });\n    };\n}\nexports.retryableFuncWithBackoff = retryableFuncWithBackoff;\n\n\n//# sourceURL=webpack://RxPlayer/./src/utils/retry.ts?");

/***/ }),

/***/ "./src/utils/rx-onEvent.ts":
/*!*********************************!*\
  !*** ./src/utils/rx-onEvent.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Observable_1 = __webpack_require__(/*! rxjs/Observable */ \"./node_modules/rxjs/Observable.js\");\nvar eventemitter_1 = __webpack_require__(/*! ./eventemitter */ \"./src/utils/eventemitter.ts\");\n/**\n * Returns a fromEvent on the given element for the given event(s).\n * @param {Element|Document|Window}\n * @param {Array.<string>|string}\n * @returns {Observable}\n */\nfunction onEvent(elt, evts) {\n    if (Array.isArray(evts)) {\n        var eventsArray = evts.map(function (evt) { return onEvent(elt, evt); });\n        return Observable_1.Observable.merge.apply(Observable_1.Observable, eventsArray);\n    }\n    else if (elt instanceof eventemitter_1.default) {\n        return Observable_1.Observable.create(function (obs) {\n            var listener = function (payload) {\n                obs.next(payload);\n            };\n            elt.addEventListener(evts, listener);\n            return function () {\n                elt.removeEventListener(evts, listener);\n            };\n        });\n    }\n    else {\n        return Observable_1.Observable.fromEvent(elt, evts);\n    }\n}\nexports.default = onEvent;\n\n\n//# sourceURL=webpack://RxPlayer/./src/utils/rx-onEvent.ts?");

/***/ }),

/***/ "./src/utils/rx-throttle.ts":
/*!**********************************!*\
  !*** ./src/utils/rx-throttle.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Observable_1 = __webpack_require__(/*! rxjs/Observable */ \"./node_modules/rxjs/Observable.js\");\nvar castToObservable_1 = __webpack_require__(/*! ./castToObservable */ \"./src/utils/castToObservable.ts\");\nvar noop_1 = __webpack_require__(/*! ./noop */ \"./src/utils/noop.ts\");\n/**\n * Throttle an asynchronous function (returning an Observable or Promise) to\n * drop calls done before a previous one has finished or failed.\n *\n * @example\n * ```js\n * const fn = (time) => Observable.timer(time);\n * const throttled = throttle(fn);\n *\n * const Obs1 = throttled(2000); // -> call fn(2000) and returns its Observable\n * const Obs2 = throttled(1000); // -> won't do anything, Obs2 is an empty\n *                               //    observable (it directly completes)\n * setTimeout(() => {\n *   const Obs3 = throttled(1000); // -> will call fn(1000)\n * }, 2001);\n * ```\n *\n * @param {Function} func\n * @returns {Function} - Function taking in argument the arguments you want\n * to give your function, and returning an Observable.\n *\n * TODO Add typings from castToObservable?\n */\nfunction throttle(func) {\n    var isPending = false;\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        if (isPending) {\n            return Observable_1.Observable.empty();\n        }\n        isPending = true;\n        return castToObservable_1.default(func.apply(void 0, args))\n            .do(noop_1.default, function () { return isPending = false; }, function () { return isPending = false; });\n    };\n}\nexports.default = throttle;\n\n\n//# sourceURL=webpack://RxPlayer/./src/utils/rx-throttle.ts?");

/***/ }),

/***/ "./src/utils/rx-tryCatch.ts":
/*!**********************************!*\
  !*** ./src/utils/rx-tryCatch.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Observable_1 = __webpack_require__(/*! rxjs/Observable */ \"./node_modules/rxjs/Observable.js\");\n/**\n * @param {Function} func - A function you want to execute\n * @param {*} args - The function's argument\n * @returns {*} - If it fails, returns a throwing Observable, else the\n * function's result (which should be, in most cases, an Observable).\n */\nfunction tryCatch(func, args) {\n    try {\n        return func(args);\n    }\n    catch (e) {\n        return Observable_1.Observable.throw(e);\n    }\n}\nexports.default = tryCatch;\n\n\n//# sourceURL=webpack://RxPlayer/./src/utils/rx-tryCatch.ts?");

/***/ }),

/***/ "./src/utils/simple_set.ts":
/*!*********************************!*\
  !*** ./src/utils/simple_set.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Simple hash-based set.\n * @class SimpleSet\n */\nvar SimpleSet = /** @class */ (function () {\n    function SimpleSet() {\n        this._hashes = {};\n    }\n    /**\n     * Add a new hash entry in the set.\n     * Do not have any effect on already-added hashes\n     * @param {string|number}\n     */\n    SimpleSet.prototype.add = function (x) {\n        this._hashes[x] = true;\n    };\n    /**\n     * Remove an hash entry from the set.\n     * Do not have any effect on already-removed or inexistant hashes\n     * @param {string|number}\n     */\n    SimpleSet.prototype.remove = function (x) {\n        delete this._hashes[x];\n    };\n    /**\n     * Test if the given hash has an entry in the set.\n     * @param {string|number}\n     * @returns {boolean}\n     */\n    SimpleSet.prototype.test = function (x) {\n        return !!this._hashes[x];\n    };\n    /**\n     * Returns true if there's currently no hash in this set.\n     * @returns {boolean}\n     */\n    SimpleSet.prototype.isEmpty = function () {\n        return !Object.keys(this._hashes).length;\n    };\n    return SimpleSet;\n}());\nexports.default = SimpleSet;\n\n\n//# sourceURL=webpack://RxPlayer/./src/utils/simple_set.ts?");

/***/ }),

/***/ "./src/utils/sorted_list.ts":
/*!**********************************!*\
  !*** ./src/utils/sorted_list.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar arrayFind = __webpack_require__(/*! array-find */ \"./node_modules/array-find/find.js\");\nvar array_includes_1 = __webpack_require__(/*! ./array-includes */ \"./src/utils/array-includes.ts\");\n/**\n * Creates an Array automatically sorted with the sorting function given to the\n * constructor when the add method is called.\n *\n * @example\n * ```js\n * const sortedList = new SortedList((a, b) => a.start - b.start);\n * const element1 = { start: 20 };\n * const element2 = { start: 10 };\n * const element3 = { start: 15 };\n *\n * sortedList.add(element1, element2);\n * console.log(sortedList.unwrap());\n * // -> [{ start: 10 }, { start : 20 }]\n *\n * sortedList.add(element3);\n * console.log(sortedList.unwrap());\n * // -> [{ start: 10 }, { start : 15 }, { start: 20 }]\n *\n * sortedList.removeFirst(element2);\n * // -> [{ start: 10 }, { start: 15 }]\n * ```\n * @class SortedList\n */\nvar SortedList = /** @class */ (function () {\n    /**\n     * @param {Function} sortingFunction\n     */\n    function SortedList(sortingFunction) {\n        this._array = [];\n        this._sortingFn = sortingFunction;\n    }\n    /**\n     * Returns the nth element. Throws if the index does not exist.\n     *\n     * /!\\ The returned Element shares the same reference with what is used\n     * internally, any mutation on your part can lead to an un-sorted SortedList.\n     * You can still re-force the sorting to happen by calling forceSort.\n     * @throws Error - Throws if the given index is negative or superior to the\n     * array's length.\n     * @param {number} index\n     * @returns {*}\n     */\n    SortedList.prototype.get = function (index) {\n        if (index < 0 || index >= this._array.length) {\n            throw new Error(\"Invalid index.\");\n        }\n        return this._array[index];\n    };\n    /**\n     * Returns this list as a JS array.\n     *\n     * /!\\ The returned Array shares the same reference with what is used\n     * internally, any mutation on your part can lead to an un-sorted SortedList.\n     * You can still re-force the sorting to happen by calling forceSort.\n     * @returns {Array.<*>}\n     */\n    SortedList.prototype.unwrap = function () {\n        return this._array;\n    };\n    /**\n     * Find the first element corresponding to the given predicate.\n     *\n     * /!\\ The returned element shares the same reference with what is used\n     * internally, any mutation on your part can lead to an un-sorted SortedList.\n     * You can still re-force the sorting to happen by calling forceSort.\n     * @param {Function} fn\n     * @returns {*}\n     */\n    SortedList.prototype.find = function (fn) {\n        return arrayFind(this._array, fn);\n    };\n    /**\n     * Returns the index of the given element in the list.\n     * -1 if not found.\n     * @param {*} element\n     * @returns {number}\n     */\n    SortedList.prototype.indexOf = function (element) {\n        return this._array.indexOf(element);\n    };\n    /**\n     * Returns true if the List contains the given element.\n     * @param {*} element\n     * @returns {Boolean}\n     */\n    SortedList.prototype.has = function (element) {\n        return array_includes_1.default(this._array, element);\n    };\n    /**\n     * Returns the current length of the list.\n     * @returns {number}\n     */\n    SortedList.prototype.length = function () {\n        return this._array.length;\n    };\n    /**\n     * Add a new element to the List at the right place for the List to stay\n     * sorted.\n     *\n     * /!\\ The added Element will share the same reference than the given\n     * argument, any mutation on your part can lead to an un-sorted SortedList.\n     * You can still re-force the sorting to happen by calling forceSort.\n     * @param {...*} elements\n     */\n    SortedList.prototype.add = function () {\n        var elements = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            elements[_i] = arguments[_i];\n        }\n        elements.sort(this._sortingFn);\n        var j = 0;\n        for (var i = 0; i < elements.length; i++) {\n            var element = elements[i];\n            var inserted = false;\n            while (!inserted && j < this._array.length) {\n                if (this._sortingFn(element, this._array[j]) < 0) {\n                    this._array.splice(j, 0, element);\n                    inserted = true;\n                }\n                else {\n                    j++;\n                }\n            }\n            if (!inserted) {\n                this._array.push(element);\n            }\n        }\n    };\n    /**\n     * Remove the first occurence of the given element.\n     * Returns the index of the removed element. Undefined if not found.\n     * @returns {number|undefined}\n     */\n    SortedList.prototype.removeFirst = function (element) {\n        var indexOf = this._array.indexOf(element);\n        if (indexOf >= 0) {\n            this._array.splice(indexOf, 1);\n            return indexOf;\n        }\n    };\n    /**\n     * Returns the first element.\n     *\n     * /!\\ The returned Element shares the same reference with what is used\n     * internally, any mutation on your part can lead to an un-sorted SortedList.\n     * You can still re-force the sorting to happen by calling forceSort.\n     * @returns {*}\n     */\n    SortedList.prototype.head = function () {\n        return this._array[0];\n    };\n    /**\n     * Returns the last element.\n     *\n     * /!\\ The returned Element shares the same reference with what is used\n     * internally, any mutation on your part can lead to an un-sorted SortedList.\n     * You can still re-force the sorting to happen by calling forceSort.\n     * @returns {*}\n     */\n    SortedList.prototype.last = function () {\n        return this._array[this._array.length - 1];\n    };\n    /**\n     * Remove the first element.\n     * Returns the element removed or undefined if no element were removed.\n     * @returns {*}\n     */\n    SortedList.prototype.shift = function () {\n        return this._array.shift();\n    };\n    /**\n     * Remove the last element.\n     * Returns the element removed or undefined if no element were removed.\n     * @returns {*}\n     */\n    SortedList.prototype.pop = function () {\n        return this._array.pop();\n    };\n    /**\n     * Returns true if the given element is before the whole list when sorted.\n     * As in, it would be the first element is pushed to the sortedList.\n     * @param {*} element\n     * @returns {boolean}\n     */\n    SortedList.prototype.isBefore = function (element) {\n        if (!this._array.length) {\n            return true;\n        }\n        return this._sortingFn(element, this._array[0]) < 0;\n    };\n    /**\n     * Returns true if the given element is after the whole list when sorted.\n     * As in, it would be the last element is pushed to the sortedList.\n     * @param {*} element\n     * @returns {boolean}\n     */\n    SortedList.prototype.isAfter = function (element) {\n        if (!this._array.length) {\n            return true;\n        }\n        return this._sortingFn(element, this._array[this._array.length - 1]) >= 0;\n    };\n    /**\n     * Returns true if the wrapped Array is well-sorted.\n     *\n     * You might want to call this function to know if a mutation you've done\n     * yourself impacted the order of elements.\n     * You can then call the forceSort function to sort the list manually.\n     *\n     * @example\n     * ```js\n     * const sortedList = new SortedList((a, b) => a.start - b.start);\n     * const element1 = { start: 20 };\n     * const element2 = { start: 10 };\n     *\n     * sortedList.add(element1, element2);\n     * console.log(sortedList.unwrap()); // -> [{ start: 10 }, { start : 20 }]\n     * console.log(sortedList.checkSort()); // -> true\n     *\n     * element2.start = 5; // Mutation impacting the order of elements\n     * console.log(sortedList.unwrap()); // -> [{ start: 10 }, { start : 5 }]\n     * console.log(sortedList.checkSort()); // -> false\n     *\n     * sortedList.forceSort();\n     * console.log(sortedList.unwrap()); // -> [{ start: 5 }, { start : 10 }]\n     * console.log(sortedList.checkSort()); // -> true\n     * ```\n     * @returns {Boolean}\n     */\n    SortedList.prototype.checkSort = function () {\n        for (var i = 0; i < this._array.length - 1; i++) {\n            if (this._sortingFn(this._array[i], this._array[i + 1]) > 0) {\n                return false;\n            }\n        }\n        return true;\n    };\n    /**\n     * Force the array to be sorted.\n     *\n     * You might want to call this function when you're unsure that a mutation\n     * you've done yourself impacted the order of the elements in the list.\n     */\n    SortedList.prototype.forceSort = function () {\n        this._array.sort(this._sortingFn);\n    };\n    return SortedList;\n}());\nexports.default = SortedList;\n\n\n//# sourceURL=webpack://RxPlayer/./src/utils/sorted_list.ts?");

/***/ }),

/***/ "./src/utils/starts-with.ts":
/*!**********************************!*\
  !*** ./src/utils/starts-with.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * String.prototype.startsWith ponyfill.\n * Indicates Whether a string starts with another substring.\n *\n * Inspired from MDN polyfill, but ponyfilled instead.\n * @param {string} completeString\n * @param {string} searchString\n * @param {number} [position]\n * @returns {boolean}\n */\nfunction startsWith(completeString, searchString, position) {\n    /* tslint:disable no-unbound-method */\n    if (typeof String.prototype.startsWith === \"function\") {\n        /* tslint:enable no-unbound-method */\n        return completeString.startsWith(searchString, position);\n    }\n    return completeString\n        .substr(position || 0, searchString.length) === searchString;\n}\nexports.default = startsWith;\n\n\n//# sourceURL=webpack://RxPlayer/./src/utils/starts-with.ts?");

/***/ }),

/***/ "./src/utils/strings.ts":
/*!******************************!*\
  !*** ./src/utils/strings.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Creates a new string from the given array of char codes.\n *\n * @param {Uint8Array} args\n * @returns {string}\n */\nfunction stringFromCharCode(args) {\n    var max = 16000;\n    var ret = \"\";\n    for (var i = 0; i < args.length; i += max) {\n        var subArray = args.subarray(i, i + max);\n        ret += String.fromCharCode.apply(null, subArray);\n    }\n    return ret;\n}\nexports.stringFromCharCode = stringFromCharCode;\n/**\n * Creates a string from the given buffer as UTF-8 encoding.\n * @param {BufferSource} [data]\n * @returns {string}\n * @throws {Error}\n * @export\n */\nfunction stringFromUTF8(data) {\n    if (!data) {\n        return \"\";\n    }\n    var uint8 = new Uint8Array(data);\n    // If present, strip off the UTF-8 BOM.\n    if (uint8[0] === 0xef && uint8[1] === 0xbb && uint8[2] === 0xbf) {\n        uint8 = uint8.subarray(3);\n    }\n    // http://stackoverflow.com/a/13691499\n    var utf8 = stringFromCharCode(uint8);\n    // This converts each character in the string to an escape sequence.  If the\n    // character is in the ASCII range, it is not converted; otherwise it is\n    // converted to a URI escape sequence.\n    // Example: \"\\x67\\x35\\xe3\\x82\\xac\" -> \"g#%E3%82%AC\"\n    // TODO \"escape\" is deprecated, provide a ponyfill?\n    var escaped = escape(utf8);\n    // Decode the escaped sequence.  This will interpret UTF-8 sequences into the\n    // correct character.\n    // Example: \"g#%E3%82%AC\" -> \"g#€\"\n    return decodeURIComponent(escaped);\n}\nexports.stringFromUTF8 = stringFromUTF8;\n\n\n//# sourceURL=webpack://RxPlayer/./src/utils/strings.ts?");

/***/ }),

/***/ "./src/utils/takeFirstSet.ts":
/*!***********************************!*\
  !*** ./src/utils/takeFirstSet.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Returns the first argument given different from undefined or null.\n * @param {...*} args\n * @returns {*}\n */\nfunction takeFirstSet() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    var i = 0;\n    var len = args.length;\n    while (i < len) {\n        if (args[i] != null) {\n            return args[i];\n        }\n        i++;\n    }\n}\nexports.default = takeFirstSet;\n\n\n//# sourceURL=webpack://RxPlayer/./src/utils/takeFirstSet.ts?");

/***/ }),

/***/ "./src/utils/url.ts":
/*!**************************!*\
  !*** ./src/utils/url.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Scheme part of an url (e.g. \"http://\").\n */\nvar schemeRe = /^(?:[a-z]+:)?\\/\\//i;\n/**\n * Captures \"/../\" or \"/./\".\n */\nvar selfDirRe = /\\/\\.{1,2}\\//;\n/**\n * Resolve self directory and previous directory references to obtain a\n * \"normalized\" url.\n * @example \"https://foo.bar/baz/booz/../biz\" => \"https://foo.bar/baz/biz\"\n * @param {string} url\n * @returns {string}\n */\nfunction _normalizeUrl(url) {\n    // fast path if no ./ or ../ are present in the url\n    if (!selfDirRe.test(url)) {\n        return url;\n    }\n    var newUrl = [];\n    var oldUrl = url.split(\"/\");\n    for (var i = 0, l = oldUrl.length; i < l; i++) {\n        if (oldUrl[i] === \"..\") {\n            newUrl.pop();\n        }\n        else if (oldUrl[i] === \".\") {\n            continue;\n        }\n        else {\n            newUrl.push(oldUrl[i]);\n        }\n    }\n    return newUrl.join(\"/\");\n}\n/**\n * Construct an url from the arguments given.\n * Basically:\n *   - The last arguments that contains a scheme (e.g. \"http://\") is the base\n *     of the url.\n *   - every subsequent string arguments are concatened to it.\n * @param {...string|undefined} args\n * @returns {string}\n */\nfunction resolveURL() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    var len = args.length;\n    if (len === 0) {\n        return \"\";\n    }\n    var base = \"\";\n    for (var i = 0; i < len; i++) {\n        var part = args[i];\n        if (typeof part !== \"string\" || part === \"\") {\n            continue;\n        }\n        if (schemeRe.test(part)) {\n            base = part;\n        }\n        else {\n            // trim if begins with \"/\"\n            if (part[0] === \"/\") {\n                part = part.substr(1);\n            }\n            // trim if ends with \"/\"\n            if (base[base.length - 1] === \"/\") {\n                base = base.substr(0, base.length - 1);\n            }\n            base = base + \"/\" + part;\n        }\n    }\n    return _normalizeUrl(base);\n}\nexports.resolveURL = resolveURL;\n/**\n * Remove string after the last '/'.\n * @param {string} url\n * @returns {string}\n */\nfunction normalizeBaseURL(url) {\n    var slash = url.lastIndexOf(\"/\");\n    if (slash >= 0) {\n        return url.substring(0, slash + 1);\n    }\n    else {\n        return url;\n    }\n}\nexports.normalizeBaseURL = normalizeBaseURL;\n\n\n//# sourceURL=webpack://RxPlayer/./src/utils/url.ts?");

/***/ }),

/***/ "./src/utils/weak_map_memory.ts":
/*!**************************************!*\
  !*** ./src/utils/weak_map_memory.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Memoize Function results linked to an object, through a WeakMap.\n *\n * @example\n * ```js\n * // Initialize the WeakMapMemory with its logic:\n * const memory = new WeakMapMemory(arg => {\n *   console.log(\"side-effect\");\n *   return [arg.a, arg.b];\n * });\n *\n * const obj = { a: 1, b: 2 };\n *\n * // first time obj is given: call the function, save the result and return it:\n * const arr1 = memory.get(obj);\n * // >  \"side-effect\"\n * // <- [1, 2]\n *\n * // nth time obj is given, returns the saved result without calling the\n * // function:\n * const arr2 = memory.get(obj);\n * // <- [1, 2]\n *\n * // both of these use the same object, so the result is also the exact same\n * // one\n * console.log(arr1 === arr2); // => true\n *\n * // /!\\ with a new object however:\n * const obj2 = { a: 1, b: 2 };\n *\n * const arr3 = memory.get(obj2);\n * // >  \"side-effect\"\n * // <- [1, 2]\n *\n * console.log(arr1 === arr3); // => false\n * ```\n * @class WeakMapMemory\n */\nvar WeakMapMemory = /** @class */ (function () {\n    function WeakMapMemory(fn) {\n        this._weakMap = new WeakMap();\n        this._fn = fn;\n    }\n    WeakMapMemory.prototype.get = function (obj) {\n        var fromMemory = this._weakMap.get(obj);\n        if (!fromMemory) {\n            var newElement = this._fn(obj);\n            this._weakMap.set(obj, newElement);\n            return newElement;\n        }\n        else {\n            return fromMemory;\n        }\n    };\n    WeakMapMemory.prototype.destroy = function (obj) {\n        this._weakMap.delete(obj);\n    };\n    return WeakMapMemory;\n}());\nexports.default = WeakMapMemory;\n\n\n//# sourceURL=webpack://RxPlayer/./src/utils/weak_map_memory.ts?");

/***/ })

/******/ });
});