(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["RxPlayer"] = factory();
	else
		root["RxPlayer"] = factory();
})(self, function() {
return /******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 9770:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   j: function() { return /* binding */ MediaSource_; },
/* harmony export */   t: function() { return /* binding */ READY_STATES; }
/* harmony export */ });
/* harmony import */ var _utils_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6787);
/* harmony import */ var _is_node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2186);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var win = _is_node__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A ? undefined : window;
/** MediaSource implementation, including vendored implementations. */
var MediaSource_ = win === undefined ? undefined : !(0,_utils_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(win.MediaSource) ? win.MediaSource : !(0,_utils_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(win.MozMediaSource) ? win.MozMediaSource : !(0,_utils_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(win.WebKitMediaSource) ? win.WebKitMediaSource : win.MSMediaSource;
/** List an HTMLMediaElement's possible values for its readyState property. */
var READY_STATES = {
  HAVE_NOTHING: 0,
  HAVE_METADATA: 1,
  HAVE_CURRENT_DATA: 2,
  HAVE_FUTURE_DATA: 3,
  HAVE_ENOUGH_DATA: 4
};


/***/ }),

/***/ 443:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A7: function() { return /* binding */ isPlayStation5; },
/* harmony export */   Fr: function() { return /* binding */ isSafariDesktop; },
/* harmony export */   NV: function() { return /* binding */ isPhilipsNetTv; },
/* harmony export */   P5: function() { return /* binding */ isPanasonic; },
/* harmony export */   Pb: function() { return /* binding */ isSamsungBrowser; },
/* harmony export */   ZN: function() { return /* binding */ isTizen; },
/* harmony export */   dX: function() { return /* binding */ isSafariMobile; },
/* harmony export */   gm: function() { return /* binding */ isFirefox; },
/* harmony export */   h$: function() { return /* binding */ isIEOrEdge; },
/* harmony export */   hF: function() { return /* binding */ isWebOs; },
/* harmony export */   lw: function() { return /* binding */ isIE11; },
/* harmony export */   op: function() { return /* binding */ isEdgeChromium; },
/* harmony export */   qe: function() { return /* binding */ isXbox; },
/* harmony export */   x1: function() { return /* binding */ isA1KStb40xx; }
/* harmony export */ });
/* unused harmony exports isWebOs2021, isWebOs2022 */
/* harmony import */ var _is_node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2186);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** Edge Chromium, regardless of the device */
var isEdgeChromium = false;
/** IE11, regardless of the device */
var isIE11 = false;
/** IE11 or Edge __Legacy__ (not Edge Chromium), regardless of the device */
var isIEOrEdge = false;
/** Firefox, regardless of the device */
var isFirefox = false;
/** `true` on Safari on a PC platform (i.e. not iPhone / iPad etc.) */
var isSafariDesktop = false;
/** `true` on Safari on an iPhone, iPad & iPod platform */
var isSafariMobile = false;
/** Samsung's own browser application */
var isSamsungBrowser = false;
/** `true` on devices where Tizen is the OS (e.g. Samsung TVs). */
var isTizen = false;
/** `true` on devices where WebOS is the OS (e.g. LG TVs). */
var isWebOs = false;
/** `true` specifically for WebOS 2021 version. */
var isWebOs2021 = false;
/** `true` specifically for WebOS 2022 version. */
var isWebOs2022 = false;
/** `true` for Panasonic devices. */
var isPanasonic = false;
/** `true` we're relying on Philips's NetTv browser. */
var isPhilipsNetTv = false;
/** `true` for the PlayStation 5 game console. */
var isPlayStation5 = false;
/** `true` for the Xbox game consoles. */
var isXbox = false;
/** `true` for specific A1 STB: KSTB 40xx from Kaon Media. */
var isA1KStb40xx = false;
(function findCurrentBrowser() {
  var _a, _b, _c;
  if (_is_node__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A) {
    return;
  }
  // 1 - Find out browser between IE/Edge Legacy/Edge Chromium/Firefox/Safari
  if (typeof window.MSInputMethodContext !== "undefined" && typeof document.documentMode !== "undefined") {
    isIE11 = true;
    isIEOrEdge = true;
  } else if (navigator.appName === "Microsoft Internet Explorer" || navigator.appName === "Netscape" && /(Trident|Edge)\//.test(navigator.userAgent)) {
    isIEOrEdge = true;
  } else if (navigator.userAgent.toLowerCase().indexOf("edg/") !== -1) {
    isEdgeChromium = true;
  } else if (navigator.userAgent.toLowerCase().indexOf("firefox") !== -1) {
    isFirefox = true;
  } else if (typeof navigator.platform === "string" && /iPad|iPhone|iPod/.test(navigator.platform)) {
    isSafariMobile = true;
  } else if (
  // the following statement check if the window.safari contains the method
  // "pushNotification", this condition is not met when using web app from the dock
  // on macOS, this is why we also check userAgent.
  Object.prototype.toString.call(window.HTMLElement).indexOf("Constructor") >= 0 || ((_b = (_a = window.safari) === null || _a === void 0 ? void 0 : _a.pushNotification) === null || _b === void 0 ? void 0 : _b.toString()) === "[object SafariRemoteNotification]" ||
  // browsers are lying: Chrome reports both as Chrome and Safari in user
  // agent string, So to detect Safari we have to check for the Safari string
  // and the absence of the Chrome string
  // eslint-disable-next-line max-len
  // @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Browser_detection_using_the_user_agent#which_part_of_the_user_agent_contains_the_information_you_are_looking_for
  /Safari\/(\d+)/.test(navigator.userAgent) &&
  // Safari should contain Version/ in userAgent
  /Version\/(\d+)/.test(navigator.userAgent) && ((_c = navigator.vendor) === null || _c === void 0 ? void 0 : _c.indexOf("Apple")) !== -1 && !/Chrome\/(\d+)/.test(navigator.userAgent) && !/Chromium\/(\d+)/.test(navigator.userAgent)) {
    isSafariDesktop = true;
  }
  // 2 - Find out specific device/platform information
  // Samsung browser e.g. on Android
  if (/SamsungBrowser/.test(navigator.userAgent)) {
    isSamsungBrowser = true;
  }
  if (navigator.userAgent.indexOf("PlayStation 5") !== -1) {
    isPlayStation5 = true;
  } else if (/Tizen/.test(navigator.userAgent)) {
    isTizen = true;
    // Inspired form: http://webostv.developer.lge.com/discover/specifications/web-engine/
    // Note: even that page doesn't correspond to what we've actually seen in the
    // wild
  } else if (/[Ww]eb[O0]S/.test(navigator.userAgent)) {
    isWebOs = true;
    if (/[Ww]eb[O0]S.TV-2022/.test(navigator.userAgent) || /[Cc]hr[o0]me\/87/.test(navigator.userAgent)) {
      isWebOs2022 = true;
    } else if (/[Ww]eb[O0]S.TV-2021/.test(navigator.userAgent) || /[Cc]hr[o0]me\/79/.test(navigator.userAgent)) {
      isWebOs2021 = true;
    }
  } else if (navigator.userAgent.indexOf("NETTV") !== -1 && navigator.userAgent.indexOf("Philips") !== -1) {
    isPhilipsNetTv = true;
  } else if (/[Pp]anasonic/.test(navigator.userAgent)) {
    isPanasonic = true;
  } else if (navigator.userAgent.indexOf("Xbox") !== -1) {
    isXbox = true;
  } else if (navigator.userAgent.indexOf("Model/a1-kstb40xx")) {
    isA1KStb40xx = true;
  }
})();


/***/ }),

/***/ 3116:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: function() { return /* binding */ clearElementSrc; }
/* harmony export */ });
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9477);
/* harmony import */ var _utils_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6787);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Clear element's src attribute.
 * @param {HTMLMediaElement} element
 */
function clearElementSrc(element) {
  // On some browsers, we first have to make sure the textTracks elements are
  // both disabled and removed from the DOM.
  // If we do not do that, we may be left with displayed text tracks on the
  // screen, even if the track elements are properly removed, due to browser
  // issues.
  // Bug seen on Firefox (I forgot which version) and Chrome 96.
  var textTracks = element.textTracks;
  if (!(0,_utils_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(textTracks)) {
    for (var i = 0; i < textTracks.length; i++) {
      textTracks[i].mode = "disabled";
    }
    if (element.hasChildNodes()) {
      var childNodes = element.childNodes;
      for (var j = childNodes.length - 1; j >= 0; j--) {
        if (childNodes[j].nodeName === "track") {
          try {
            element.removeChild(childNodes[j]);
          } catch (err) {
            _log__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.warn("Compat: Could not remove text track child from element.");
          }
        }
      }
    }
  }
  element.src = "";
  // On IE11, element.src = "" is not sufficient as it
  // does not clear properly the current MediaKey Session.
  // Microsoft recommended to use element.removeAttr("src").
  element.removeAttribute("src");
}

/***/ }),

/***/ 5121:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ah: function() { return /* binding */ onTextTrackAdded; },
/* harmony export */   Bi: function() { return /* binding */ onSeeked; },
/* harmony export */   G1: function() { return /* binding */ onSourceBufferUpdate; },
/* harmony export */   HQ: function() { return /* binding */ onKeyError; },
/* harmony export */   ID: function() { return /* binding */ onSeeking; },
/* harmony export */   R5: function() { return /* binding */ onKeyAdded; },
/* harmony export */   Sb: function() { return /* binding */ getPageActivityRef; },
/* harmony export */   VS: function() { return /* binding */ onKeyStatusesChange; },
/* harmony export */   Vb: function() { return /* binding */ getVideoWidthRef; },
/* harmony export */   XC: function() { return /* binding */ onSourceClose; },
/* harmony export */   Z1: function() { return /* binding */ onSourceEnded; },
/* harmony export */   bF: function() { return /* binding */ onSourceOpen; },
/* harmony export */   c_: function() { return /* binding */ onTextTrackRemoved; },
/* harmony export */   g9: function() { return /* binding */ onEnded; },
/* harmony export */   jf: function() { return /* binding */ createCompatibleEventListener; },
/* harmony export */   ng: function() { return /* binding */ getVideoVisibilityRef; },
/* harmony export */   o8: function() { return /* binding */ getPictureOnPictureStateRef; },
/* harmony export */   qF: function() { return /* binding */ onKeyMessage; },
/* harmony export */   rR: function() { return /* binding */ onFullscreenChange; },
/* harmony export */   yS: function() { return /* binding */ onRemoveSourceBuffers; }
/* harmony export */ });
/* unused harmony exports addEventListener, onLoadedMetadata, onTimeUpdate */
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(5151);
/* harmony import */ var _utils_is_non_empty_string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2384);
/* harmony import */ var _utils_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(6787);
/* harmony import */ var _utils_noop__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(8060);
/* harmony import */ var _utils_reference__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(8315);
/* harmony import */ var _is_node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2186);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */







var BROWSER_PREFIXES = ["", "webkit", "moz", "ms"];
var pixelRatio = _is_node__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A || window.devicePixelRatio == null || window.devicePixelRatio === 0 ? 1 : window.devicePixelRatio;
/**
 * Find the first supported event from the list given.
 * @param {HTMLElement} element
 * @param {string} eventNameSuffix
 * @returns {Boolean}
 */
function isEventSupported(element, eventNameSuffix) {
  var clone = document.createElement(element.tagName);
  var eventName = "on" + eventNameSuffix;
  if (eventName in clone) {
    return true;
  } else {
    clone.setAttribute(eventName, "return;");
    return typeof clone[eventName] === "function";
  }
}
/**
 * Find the first supported event from the list given.
 * @param {HTMLElement} element
 * @param {Array.<string>} eventNames
 * @returns {string|undefined}
 */
function findSupportedEvent(element, eventNames) {
  return eventNames.filter(function (name) {
    return isEventSupported(element, name);
  })[0];
}
/**
 * @param {Array.<string>} eventNames
 * @param {Array.<string>|undefined} prefixes
 * @returns {Array.<string>}
 */
function eventPrefixed(eventNames, prefixes) {
  return eventNames.reduce(function (parent, name) {
    return parent.concat((prefixes === undefined ? BROWSER_PREFIXES : prefixes).map(function (p) {
      return p + name;
    }));
  }, []);
}
function createCompatibleEventListener(eventNames, prefixes) {
  var mem;
  var prefixedEvents = eventPrefixed(eventNames, prefixes);
  return function (element, listener, cancelSignal) {
    if (cancelSignal.isCancelled()) {
      return;
    }
    // if the element is a HTMLElement we can detect
    // the supported event, and memoize it in `mem`
    if (element instanceof HTMLElement) {
      if (typeof mem === "undefined") {
        mem = findSupportedEvent(element, prefixedEvents);
      }
      if ((0,_utils_is_non_empty_string__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(mem)) {
        element.addEventListener(mem, listener);
        cancelSignal.register(function () {
          if (mem !== undefined) {
            element.removeEventListener(mem, listener);
          }
        });
      } else {
        if (false) {}
        return;
      }
    }
    prefixedEvents.forEach(function (eventName) {
      var hasSetOnFn = false;
      if (typeof element.addEventListener === "function") {
        element.addEventListener(eventName, listener);
      } else {
        hasSetOnFn = true;
        /* eslint-disable @typescript-eslint/no-unsafe-member-access */
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        element["on" + eventName] = listener;
        /* eslint-enable @typescript-eslint/no-unsafe-member-access */
      }
      cancelSignal.register(function () {
        if (typeof element.removeEventListener === "function") {
          element.removeEventListener(eventName, listener);
        }
        if (hasSetOnFn) {
          /* eslint-disable @typescript-eslint/no-unsafe-member-access */
          /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
          delete element["on" + eventName];
          /* eslint-enable @typescript-eslint/no-unsafe-member-access */
        }
      });
    });
  };
}
/**
 * Returns a reference:
 *   - set to `true` when the document is visible
 *   - set to `false` when the document is hidden
 * @param {Object} stopListening - `CancellationSignal` allowing to free the
 * ressources allocated to update this value.
 * @returns {Object}
 */
function getDocumentVisibilityRef(stopListening) {
  var prefix;
  var doc = document;
  if (doc.hidden != null) {
    prefix = "";
  } else if (doc.mozHidden != null) {
    prefix = "moz";
  } else if (doc.msHidden != null) {
    prefix = "ms";
  } else if (doc.webkitHidden != null) {
    prefix = "webkit";
  }
  var hidden = (0,_utils_is_non_empty_string__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(prefix) ? prefix + "Hidden" : "hidden";
  var visibilityChangeEvent = (0,_utils_is_non_empty_string__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(prefix) ? prefix + "visibilitychange" : "visibilitychange";
  var isHidden = document[hidden];
  var ref = new _utils_reference__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A(!isHidden, stopListening);
  addEventListener(document, visibilityChangeEvent, function () {
    var isVisible = !document[hidden];
    ref.setValueIfChanged(isVisible);
  }, stopListening);
  return ref;
}
/**
 * Returns a reference:
 *   - Set to `true` when the current page is considered visible and active.
 *   - Set to `false` otherwise.
 * @param {Object} stopListening - `CancellationSignal` allowing to free the
 * resources allocated to update this value.
 * @returns {Object}
 */
function getPageActivityRef(stopListening) {
  var isDocVisibleRef = getDocumentVisibilityRef(stopListening);
  var currentTimeout;
  var ref = new _utils_reference__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A(true, stopListening);
  stopListening.register(function () {
    clearTimeout(currentTimeout);
    currentTimeout = undefined;
  });
  isDocVisibleRef.onUpdate(function onDocVisibilityChange(isVisible) {
    clearTimeout(currentTimeout); // clear potential previous timeout
    currentTimeout = undefined;
    if (!isVisible) {
      var _config$getCurrent = _config__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A.getCurrent(),
        INACTIVITY_DELAY = _config$getCurrent.INACTIVITY_DELAY;
      currentTimeout = window.setTimeout(function () {
        ref.setValueIfChanged(false);
      }, INACTIVITY_DELAY);
    }
    ref.setValueIfChanged(true);
  }, {
    clearSignal: stopListening,
    emitCurrentValue: true
  });
  return ref;
}
/**
 * Get video width from Picture-in-Picture window
 * @param {HTMLMediaElement} mediaElement
 * @param {Object} pipWindow
 * @returns {number}
 */
function getVideoWidthFromPIPWindow(mediaElement, pipWindow) {
  var width = pipWindow.width,
    height = pipWindow.height;
  var videoRatio = mediaElement.clientHeight / mediaElement.clientWidth;
  var calcWidth = height / videoRatio;
  return Math.min(width, calcWidth);
}
/**
 * Emit when video enters and leaves Picture-In-Picture mode.
 * @param {HTMLMediaElement} elt
 * @param {Object} stopListening
 * @returns {Object}
 */
function getPictureOnPictureStateRef(elt, stopListening) {
  var mediaElement = elt;
  if (mediaElement.webkitSupportsPresentationMode === true && typeof mediaElement.webkitSetPresentationMode === "function") {
    var isWebKitPIPEnabled = mediaElement.webkitPresentationMode === "picture-in-picture";
    var _ref = new _utils_reference__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A({
      isEnabled: isWebKitPIPEnabled,
      pipWindow: null
    }, stopListening);
    addEventListener(mediaElement, "webkitpresentationmodechanged", function () {
      var isEnabled = mediaElement.webkitPresentationMode === "picture-in-picture";
      _ref.setValue({
        isEnabled: isEnabled,
        pipWindow: null
      });
    }, stopListening);
    return _ref;
  }
  var isPIPEnabled = document.pictureInPictureElement === mediaElement;
  var ref = new _utils_reference__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A({
    isEnabled: isPIPEnabled,
    pipWindow: null
  }, stopListening);
  addEventListener(mediaElement, "enterpictureinpicture", function (evt) {
    var _a;
    ref.setValue({
      isEnabled: true,
      pipWindow: (_a = evt.pictureInPictureWindow) !== null && _a !== void 0 ? _a : null
    });
  }, stopListening);
  addEventListener(mediaElement, "leavepictureinpicture", function () {
    ref.setValue({
      isEnabled: false,
      pipWindow: null
    });
  }, stopListening);
  return ref;
}
/**
 * Returns a reference:
 *   - Set to `true` when video is considered as visible (the page is visible
 *     and/or the Picture-In-Picture is activated).
 *   - Set to `false` otherwise.
 * @param {Object} pipStatus
 * @param {Object} stopListening - `CancellationSignal` allowing to free the
 * resources reserved to listen to video visibility change.
 * @returns {Object}
 */
function getVideoVisibilityRef(pipStatus, stopListening) {
  var isDocVisibleRef = getDocumentVisibilityRef(stopListening);
  var currentTimeout;
  var ref = new _utils_reference__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A(true, stopListening);
  stopListening.register(function () {
    clearTimeout(currentTimeout);
    currentTimeout = undefined;
  });
  isDocVisibleRef.onUpdate(checkCurrentVisibility, {
    clearSignal: stopListening
  });
  pipStatus.onUpdate(checkCurrentVisibility, {
    clearSignal: stopListening
  });
  checkCurrentVisibility();
  return ref;
  function checkCurrentVisibility() {
    clearTimeout(currentTimeout);
    currentTimeout = undefined;
    if (pipStatus.getValue().isEnabled || isDocVisibleRef.getValue()) {
      ref.setValueIfChanged(true);
    } else {
      var _config$getCurrent2 = _config__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A.getCurrent(),
        INACTIVITY_DELAY = _config$getCurrent2.INACTIVITY_DELAY;
      currentTimeout = window.setTimeout(function () {
        ref.setValueIfChanged(false);
      }, INACTIVITY_DELAY);
    }
  }
}
/**
 * Get video width from HTML video element, or video estimated dimensions
 * when Picture-in-Picture is activated.
 * @param {HTMLMediaElement} mediaElement
 * @param {Object} pipStatusRef
 * @param {Object} stopListening
 * @returns {Object}
 */
function getVideoWidthRef(mediaElement, pipStatusRef, stopListening) {
  var ref = new _utils_reference__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A(mediaElement.clientWidth * pixelRatio, stopListening);
  var _clearPreviousEventListener = _utils_noop__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A;
  pipStatusRef.onUpdate(checkVideoWidth, {
    clearSignal: stopListening
  });
  addEventListener(window, "resize", checkVideoWidth, stopListening);
  var interval = window.setInterval(checkVideoWidth, 20000);
  checkVideoWidth();
  stopListening.register(function stopUpdatingVideoWidthRef() {
    _clearPreviousEventListener();
    clearInterval(interval);
  });
  return ref;
  function checkVideoWidth() {
    _clearPreviousEventListener();
    var pipStatus = pipStatusRef.getValue();
    if (!pipStatus.isEnabled) {
      ref.setValueIfChanged(mediaElement.clientWidth * pixelRatio);
    } else if (!(0,_utils_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A)(pipStatus.pipWindow)) {
      var pipWindow = pipStatus.pipWindow;
      var firstWidth = getVideoWidthFromPIPWindow(mediaElement, pipWindow);
      var onPipResize = function onPipResize() {
        ref.setValueIfChanged(getVideoWidthFromPIPWindow(mediaElement, pipWindow) * pixelRatio);
      };
      pipWindow.addEventListener("resize", onPipResize);
      _clearPreviousEventListener = function clearPreviousEventListener() {
        pipWindow.removeEventListener("resize", onPipResize);
        _clearPreviousEventListener = _utils_noop__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A;
      };
      ref.setValueIfChanged(firstWidth * pixelRatio);
    } else {
      ref.setValueIfChanged(Infinity);
    }
  }
}
/**
 * @param {HTMLMediaElement} mediaElement
 */
var onLoadedMetadata = createCompatibleEventListener(["loadedmetadata"]);
/**
 * @param {HTMLMediaElement} mediaElement
 */
var onTimeUpdate = createCompatibleEventListener(["timeupdate"]);
/**
 * @param {HTMLElement} element
 */
var onFullscreenChange = createCompatibleEventListener(["fullscreenchange", "FullscreenChange"],
// On IE11, fullscreen change events is called MSFullscreenChange
BROWSER_PREFIXES.concat("MS"));
/**
 * @param {TextTrackList} textTrackList
 */
var onTextTrackAdded = createCompatibleEventListener(["addtrack"]);
/**
 * @param {TextTrackList} textTrackList
 */
var onTextTrackRemoved = createCompatibleEventListener(["removetrack"]);
/**
 * @param {MediaSource} mediaSource
 * @param {Function} listener
 * @param {Object} cancelSignal
 */
var onSourceOpen = createCompatibleEventListener(["sourceopen", "webkitsourceopen"]);
/**
 * @param {MediaSource} mediaSource
 * @param {Function} listener
 * @param {Object} cancelSignal
 */
var onSourceClose = createCompatibleEventListener(["sourceclose", "webkitsourceclose"]);
/**
 * @param {MediaSource} mediaSource
 * @param {Function} listener
 * @param {Object} cancelSignal
 */
var onSourceEnded = createCompatibleEventListener(["sourceended", "webkitsourceended"]);
/**
 * @param {MediaSource} mediaSource
 * @param {Function} listener
 * @param {Object} cancelSignal
 */
var onSourceBufferUpdate = createCompatibleEventListener(["update"]);
/**
 * @param {SourceBufferList} sourceBuffers
 * @param {Function} listener
 * @param {Object} cancelSignal
 */
var onRemoveSourceBuffers = createCompatibleEventListener(["removesourcebuffer"]);
/**
 * @param {MediaKeySession} mediaKeySession
 */
var onKeyMessage = createCompatibleEventListener(["keymessage", "message"]);
/**
 * @param {MediaKeySession} mediaKeySession
 */
var onKeyAdded = createCompatibleEventListener(["keyadded", "ready"]);
/**
 * @param {MediaKeySession} mediaKeySession
 */
var onKeyError = createCompatibleEventListener(["keyerror", "error"]);
/**
 * @param {MediaKeySession} mediaKeySession
 */
var onKeyStatusesChange = createCompatibleEventListener(["keystatuseschange"]);
/**
 * @param {HTMLMediaElement} mediaElement
 */
var onSeeking = createCompatibleEventListener(["seeking"]);
/**
 * @param {HTMLMediaElement} mediaElement
 */
var onSeeked = createCompatibleEventListener(["seeked"]);
/**
 * @param {HTMLMediaElement} mediaElement
 */
var onEnded = createCompatibleEventListener(["ended"]);
/**
 * Utilitary function allowing to add an event listener and remove it
 * automatically once the given `CancellationSignal` emits.
 * @param {EventTarget} elt - The element on which should be attached the event
 * listener.
 * @param {string} evt - The event you wish to listen to
 * @param {Function} listener - The listener function
 * @param {Object} stopListening - Removes the event listener once this signal
 * emits
 */
function addEventListener(elt, evt, listener, stopListening) {
  elt.addEventListener(evt, listener);
  stopListening.register(function () {
    elt.removeEventListener(evt, listener);
  });
}


/***/ }),

/***/ 2186:
/***/ (function(__unused_webpack_module, __webpack_exports__) {

"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var isNode = typeof window === "undefined";
/* harmony default export */ __webpack_exports__.A = (isNode);

/***/ }),

/***/ 7913:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _browser_detection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(443);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * On some devices (right now only seen on Tizen), seeking through the
 * `currentTime` property can lead to the browser re-seeking once the
 * segments have been loaded to improve seeking performances (for
 * example, by seeking right to an intra video frame).
 *
 * This can lead to conflicts with the RxPlayer code.
 *
 * This boolean is only `true` on the devices where this behavior has been
 * observed.
 */
var isSeekingApproximate = _browser_detection__WEBPACK_IMPORTED_MODULE_0__/* .isTizen */ .ZN;
/* harmony default export */ __webpack_exports__.A = (isSeekingApproximate);

/***/ }),

/***/ 7402:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: function() { return /* binding */ isVTTCue; }
/* harmony export */ });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Returns true if the given cue is an instance of a VTTCue.
 * @param {*} cue
 * @returns {boolean}
 */
function isVTTCue(cue) {
  /* eslint-disable @typescript-eslint/no-unsafe-member-access */
  return typeof window.VTTCue === "function" && cue instanceof window.VTTCue;
  /* eslint-enable @typescript-eslint/no-unsafe-member-access */
}

/***/ }),

/***/ 8068:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: function() { return /* binding */ makeCue; }
/* harmony export */ });
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9477);
/* harmony import */ var _utils_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6787);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Creates a cue using the best platform-specific interface available.
 *
 * @param {Number} startTime
 * @param {Number} endTime
 * @param {string} payload
 * @returns {VTTCue|TextTrackCue|null} Text track cue or null if the parameters
 * were invalid.
 */
function makeCue(startTime, endTime, payload) {
  if (startTime >= endTime) {
    // IE/Edge will throw in this case.
    // See issue #501
    _log__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.warn("Compat: Invalid cue times: " + startTime + " - " + endTime);
    return null;
  }
  if ((0,_utils_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(window.VTTCue)) {
    if ((0,_utils_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(window.TextTrackCue)) {
      throw new Error("VTT cues not supported in your target");
    }
    return new TextTrackCue(startTime, endTime, payload);
  } else {
    return new VTTCue(startTime, endTime, payload);
  }
}

/***/ }),

/***/ 2097:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: function() { return /* binding */ shouldValidateMetadata; }
/* harmony export */ });
/* harmony import */ var _browser_detection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(443);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns true if the metadata received after a "loadedmetadata" event has
 * to be validated in the current browser (which means that we do not trust
 * this event on these browsers).
 * @returns {boolean}
 */
function shouldValidateMetadata() {
  return _browser_detection__WEBPACK_IMPORTED_MODULE_0__/* .isSamsungBrowser */ .Pb;
}

/***/ }),

/***/ 5151:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: function() { return /* binding */ config; }
});

;// CONCATENATED MODULE: ./src/default_config.ts
/**
 * Configuration file for the whole player.
 * Feel free to tweak those values if you know what you're doing.
 *
 * Please not that you will need to re-build the whole project to take these
 * modifications into account.
 *
 * @type {Object}
 */
var DEFAULT_CONFIG = {
  /**
   * Volume set on unMute if the volume is set to 0 and either:
   *   - mute has never been called before
   *   - mute has last been called while the volume was already set to 0 (either
   *     via setVolume, or a previous mute call)
   * @type {Number}
   */
  DEFAULT_UNMUTED_VOLUME: 0.1,
  /**
   * Default time interval after which a request will timeout, in ms.
   * @type {Number}
   */
  DEFAULT_REQUEST_TIMEOUT: 30 * 1000,
  /**
   * Can be either:
   *   - "native": Subtitles are all displayed in a <track> element
   *   - "html": Subtitles are all displayed in a <div> separated from the video
   *     element. Can be useful to display richer TTML subtitles, for example.
   * @type {Object|null}
   */
  DEFAULT_TEXT_TRACK_MODE: "native",
  /**
   * Strategy to adopt when manually setting the current bitrate.
   * Can be either:
   *   - "seamless": transitions are very smooth but not immediate.
   *   - "direct": the quality switch happens immediately but to achieve that,
   *     the player will need to set a new MediaSource on the media element in
   *     some cases. This often leads to a black screen + unavailable APIs
   *     during a short moment.
   * @type {string}
   */
  DEFAULT_MANUAL_BITRATE_SWITCHING_MODE: "seamless",
  /**
   * Default behavior for the `enableFastSwitching` loadVideo options.
   *
   * Fast-switching allows to provide quicker transitions from lower quality
   * segments to higher quality segments but might be badly supported on some
   * devices.
   * When enabled, the RxPlayer might replace segments of a lower-quality
   * (with a lower bitrate) with segments of a higher quality (with a higher
   * bitrate). This allows to have a fast transition when network conditions
   * improve.
   * When disabled, segments of a lower-quality will not be replaced.
   */
  DEFAULT_ENABLE_FAST_SWITCHING: true,
  /**
   * Strategy to adopt when manually switching of audio adaptation.
   * Can be either:
   *    - "seamless": transitions are smooth but could be not immediate.
   *    - "direct": that strategy will perform a very small seek that result
   *    most of the time by a flush of the current buffered data, by doing
   *    that we allow quicker transition between audio track, but we could
   *    see appear a RELOADING or a SEEKING state.
   */
  DEFAULT_AUDIO_TRACK_SWITCHING_MODE: "seamless",
  /**
   * In some cases after switching the current track or bitrate, the RxPlayer
   * could be led to go into the `"RELOADING"` state, which corresponds to
   * visually a black screen (with nothing audible) before restarting playback.
   *
   * We could want to seek back some milliseconds when doing that.
   * For example, when switching the current audio track, it might make sense
   * to restart some time before, so the beginning of the sentence can be heard
   * again in the new language.
   *
   * This config property allows to set the relative position the RxPlayer will
   * seek to after reloading, in seconds.
   *
   * For example: a value of `-0.7` means that will seek back 700 milliseconds
   * when reloading due to a track or bitrate switch with necessitated a
   * reloading.
   */
  DELTA_POSITION_AFTER_RELOAD: {
    /** Relative position when switching the bitrate */
    bitrateSwitch: -0.1,
    /**
     * Relative position when switching the track.
     *
     * From tests, I noticed that seeking back was only really "pleasant" when
     * switching the audio track.
     *
     * E.g. switching the video track often means changing the camera angle or
     * even totally changing what is being seen and rely much less on temporal
     * context than when an audio track is switched.
     * As such, I decided to only set a sensible seek-back behavior when
     * switching the audio track, and only a minimal one (to still ensure
     * nothing was missed) for video.
     *
     * "Other" mainly concern text track, where seeking back could even be
     * annoying, so that behavior has been disabled in that case.
     */
    trackSwitch: {
      audio: -0.7,
      video: -0.1,
      other: 0
    }
  },
  /**
   * Behavior of the RxPlayer when encountering a whole other codec on a already
   * existing audio or video SourceBuffer.
   *
   * Can be either:
   *
   *    - "continue": Segments linked to the new codec will continue to be
   *      pushed to that same SourceBuffer. The RxPlayer will still try to call
   *      the `changeType` API on the SourceBuffer before pushing those
   *      segments but continue even if this call failed.
   *
   *    - "reload": Every time a new incompatible codec is encountered on a
   *      given SourceBuffer, we will reload the MediaSource.
   */
  DEFAULT_CODEC_SWITCHING_BEHAVIOR: "continue",
  /**
   * If set to true, video through loadVideo will auto play by default
   * @type {Boolean}
   */
  DEFAULT_AUTO_PLAY: false,
  /**
   * If set to false, "native" subtitles (in a <track> element) will be hidden
   * by default.
   * @type {Boolean}
   */
  DEFAULT_SHOW_NATIVE_SUBTITLE: true,
  /**
   * If set to true, the player will by default stop immediately and unload the
   * content on reaching the end of the media.
   *
   * If set to false, it will not unload nor stop by default, leaving the user
   * free to seek in the already-loaded content.
   *
   * Set to `true` for legacy reasons.
   * @type {Boolean}
   */
  DEFAULT_STOP_AT_END: true,
  /**
   * Default buffer goal in seconds.
   * Once enough content has been downloaded to fill the buffer up to
   * ``current position + DEFAULT_WANTED_BUFFER_AHEAD", we will stop downloading
   * content.
   * @type {Number}
   */
  DEFAULT_WANTED_BUFFER_AHEAD: 30,
  /**
   * Default max buffer size ahead of the current position in seconds.
   * The buffer _after_ this limit will be garbage collected.
   * Set to Infinity for no limit.
   * @type {Number}
   */
  DEFAULT_MAX_BUFFER_AHEAD: Infinity,
  /**
   * Default max buffer size ahead of the current position in seconds.
   * The buffer _before_ this limit will be garbage collected.
   * Set to Infinity for no limit.
   * @type {Number}
   */
  DEFAULT_MAX_BUFFER_BEHIND: Infinity,
  /**
   * Default video buffer memory limit in kilobytes.
   * Once enough video content has been downloaded to fill the buffer up to
   * DEFAULT_MAX_VIDEO_BUFFER_SIZE , we will stop downloading
   * content.
   * @type {Number}
   */
  DEFAULT_MAX_VIDEO_BUFFER_SIZE: Infinity,
  /* eslint-disable @typescript-eslint/consistent-type-assertions */
  /**
   * Maximum possible buffer ahead for each type of buffer, to avoid too much
   * memory usage when playing for a long time.
   * Equal to Infinity if not defined here.
   * @type {Object}
   */
  MAXIMUM_MAX_BUFFER_AHEAD: {
    text: 5 * 60 * 60
  },
  /* eslint-enable @typescript-eslint/consistent-type-assertions */
  /* eslint-disable @typescript-eslint/consistent-type-assertions */
  /**
   * Minimum possible buffer ahead for each type of buffer, to avoid Garbage
   * Collecting too much data when it would have adverse effects.
   * Equal to `0` if not defined here.
   * @type {Object}
   */
  MINIMUM_MAX_BUFFER_AHEAD: {
    // Text segments are both much lighter on resources and might
    // actually be much larger than other types of segments in terms
    // of duration. Let's make an exception here by authorizing a
    // larger text buffer ahead, to avoid unnecesarily reloading the
    // same text track.
    text: 2 * 60
  },
  /* eslint-enable @typescript-eslint/consistent-type-assertions */
  /* eslint-disable @typescript-eslint/consistent-type-assertions */
  /**
   * Maximum possible buffer behind for each type of buffer, to avoid too much
   * memory usage when playing for a long time.
   * Equal to Infinity if not defined here.
   * @type {Object}
   */
  MAXIMUM_MAX_BUFFER_BEHIND: {
    text: 5 * 60 * 60
  },
  /* eslint-enable @typescript-eslint/consistent-type-assertions */
  /**
   * Default bitrate ceils initially set as the first content begins.
   *
   * If no track is found with a bitrate inferior or equal to the
   * bitrate there, the one with the lowest bitrate will be taken instead.
   *
   * Set to 0 for the lowest bitrate, Infinity for the highest.
   *
   * These values are only useful for the first content played, as consecutive
   * play will always take the last set one.
   * @type {Object}
   */
  DEFAULT_INITIAL_BITRATES: {
    audio: 0,
    // only "audio" segments
    video: 0,
    // only "video" segments
    other: 0 // tracks which are not audio/video (text images).
    // Though those are generally at a single bitrate, so no adaptive
    // mechanism is triggered for them.
  },
  /* eslint-disable @typescript-eslint/consistent-type-assertions */
  /**
   * Default bitrate floor initially set to dictate the minimum bitrate the
   * adaptive logic can automatically switch to.
   *
   * If no track is found with a quality superior or equal to the
   * bitrate there, the lowest bitrate will be taken instead.
   *
   * Set to Infinity to discard any limit in the ABR strategy.
   * @type {Object}
   */
  DEFAULT_MIN_BITRATES: {
    audio: 0,
    // only "audio" segments
    video: 0,
    // only "video" segments
    other: 0 // tracks which are not audio/video
    // Though those are generally at a single bitrate, so no
    // adaptive mechanism is triggered for them.
  },
  /* eslint-enable @typescript-eslint/consistent-type-assertions */
  /* eslint-disable @typescript-eslint/consistent-type-assertions */
  /**
   * Default bitrate ceil initially set to dictate the maximum bitrate the
   * adaptive logic can automatically switch to.
   *
   * If no track is found with a quality inferior or equal to the
   * bitrate there, the lowest bitrate will be taken instead.
   *
   * Set to Infinity to discard any limit in the ABR strategy.
   * @type {Object}
   */
  DEFAULT_MAX_BITRATES: {
    audio: Infinity,
    // only "audio" segments
    video: Infinity,
    // only "video" segments
    other: Infinity // tracks which are not audio/video
    // Though those are generally at a single bitrate, so no
    // adaptive mechanism is triggered for them.
  },
  /* eslint-enable @typescript-eslint/consistent-type-assertions */
  /**
   * Delay after which, if the page is hidden, the user is considered inactive
   * on the current video.
   *
   * Allow to enforce specific optimizations when the page is not shown.
   * @see DEFAULT_THROTTLE_WHEN_HIDDEN
   * @type {Number}
   */
  INACTIVITY_DELAY: 60 * 1000,
  /**
   * If true, if the player is in a "hidden" state for a delay specified by the
   * INACTIVITY DELAY config property, we throttle automatically to the video
   * representation with the lowest bitrate.
   * @type {Boolean}
   */
  DEFAULT_THROTTLE_WHEN_HIDDEN: false,
  /**
   * If true, if the video is considered in a "hidden" state for a delay specified by
   * the INACTIVITY DELAY config property, we throttle automatically to the video
   * representation with the lowest bitrate.
   * @type {Boolean}
   */
  DEFAULT_THROTTLE_VIDEO_BITRATE_WHEN_HIDDEN: false,
  /**
   * If true, the video representations you can switch to in adaptive mode
   * are limited by the video element's width.
   *
   * Basically in that case, we won't switch to a video Representation with
   * a width higher than the current width of the video HTMLElement.
   * @type {Boolean}
   */
  DEFAULT_LIMIT_VIDEO_WIDTH: false,
  /**
   * Default initial live gap considered if no presentation delay has been
   * suggested, in seconds.
   * @type {Number}
   */
  DEFAULT_LIVE_GAP: {
    DEFAULT: 10,
    LOW_LATENCY: 3.5
  },
  /**
   * Maximum time, in seconds, the player should automatically skip when stalled
   * because of a current hole in the buffer.
   * Bear in mind that this might seek over not-yet-downloaded/pushed segments.
   * @type {Number}
   */
  BUFFER_DISCONTINUITY_THRESHOLD: 0.2,
  /**
   * When encountering small discontinuities, the RxPlayer may want, in specific
   * conditions, ignore those and let the browser seek over them iself (this
   * allows for example to avoid conflicts when both the browser and the
   * RxPlayer want to seek at a different position, sometimes leading to a
   * seeking loop).
   * In this case, we however still want to seek it ourselves if the browser
   * doesn't take the opportunity soon enough.
   *
   * This value specifies a delay after which a discontinuity ignored by the
   * RxPlayer is finally considered.
   * We want to maintain high enough to be sure the browser will not seek yet
   * small enough so this (arguably rare) situation won't lead to too much
   * waiting time.
   */
  FORCE_DISCONTINUITY_SEEK_DELAY: 5000,
  /**
   * Ratio used to know if an already loaded segment should be re-buffered.
   * We re-load the given segment if the current one times that ratio is
   * inferior to the new one.
   * @type {Number}
   */
  BITRATE_REBUFFERING_RATIO: 1.5,
  /**
   * Those are used when a "QuotaExceededError" error is received after
   * appending a new segment in the SourceBuffer.
   *
   * This error can arise when the browser's buffer is considered full.
   * In this case, the player goes into manual garbage collection (GC) mode.
   * @type {Object}
   */
  BUFFER_GC_GAPS: {
    /**
     * _Low_ gap (from current position) from which the buffer will be _garbage
     * collected_ (read removed from the buffer) when a QuotaExceededError is
     * received.
     * In seconds.
     * @type {Number}
     */
    CALM: 240,
    /**
     * _High_ gap (from current position) from which the buffer will be _garbage
     * collected_ (read removed from the buffer) when a QuotaExceededError is
     * received, if the low one does not clean up any buffer.
     * In seconds.
     * @type {Number}
     */
    BEEFY: 30
  },
  /**
   * The default number of times a manifest request will be re-performed
   * when loaded/refreshed if the request finishes on an error which
   * justify an retry.
   *
   * Note that some errors do not use this counter:
   *   - if the error is not due to the xhr, no retry will be peformed
   *   - if the error is an HTTP error code, but not a 500-smthg or a 404, no
   *     retry will be performed.
   *   - if it has a high chance of being due to the user being offline, a
   *     separate counter is used (see DEFAULT_MAX_REQUESTS_RETRY_ON_OFFLINE).
   * @type Number
   */
  DEFAULT_MAX_MANIFEST_REQUEST_RETRY: 4,
  /**
   * Default delay, in seconds, during which a CDN will be "downgraded".
   *
   * For example in case of media content being available on multiple CDNs, the
   * RxPlayer may decide that a CDN is less reliable (for example, it returned a
   * server error) and should thus be avoided, at least for some time
   *
   * This value is the amount of time this CDN will be "less considered" than the
   * alternatives.
   */
  DEFAULT_CDN_DOWNGRADE_TIME: 60,
  /**
   * The default number of times a segment request will be re-performed when
   * on error which justify a retry.
   *
   * Note that some errors do not use this counter:
   *   - if the error is not due to the xhr, no retry will be peformed
   *   - if the error is an HTTP error code, but not a 500-smthg or a 404, no
   *     retry will be performed.
   *   - if it has a high chance of being due to the user being offline, a
   *     separate counter is used (see DEFAULT_MAX_REQUESTS_RETRY_ON_OFFLINE).
   * @type Number
   */
  DEFAULT_MAX_REQUESTS_RETRY_ON_ERROR: 4,
  /**
   * Under some circonstances, we're able to tell that the user is offline (see
   * the compat files).
   * When this happens, and xhr requests fails due to an error event (you might
   * still be able to perform xhr offline, e.g. on localhost), you might want to
   * retry indefinitely or with a higher number of retry than if the error is
   * due to a CDN problem.
   *
   * A capped exponential backoff will still be used (like for an error code).
   * @type {Number}
   */
  DEFAULT_MAX_REQUESTS_RETRY_ON_OFFLINE: Infinity,
  /**
   * Initial backoff delay when a segment / manifest download fails, in
   * milliseconds.
   *
   * This delay will then grow exponentally by power of twos (200, 400, 800
   * etc.)
   *
   * Please note that this delay is not exact, as it will be fuzzed.
   * @type {Number}
   */
  INITIAL_BACKOFF_DELAY_BASE: {
    REGULAR: 200,
    LOW_LATENCY: 50
  },
  /**
   * Maximum backoff delay when a segment / manifest download fails, in
   * milliseconds.
   *
   * Please note that this delay is not exact, as it will be fuzzed.
   * @type {Number}
   */
  MAX_BACKOFF_DELAY_BASE: {
    REGULAR: 3000,
    LOW_LATENCY: 1000
  },
  /**
   * Minimum interval at which playback information samples will be taken. This
   * variable is for the "regular" mediasource strategy (that is, not for the
   * directfile API.
   *
   * At each of these interval, various different modules in the RxPlayer will
   * run based on the information communicated.
   *
   * Keep in mind this is the minimum interval. This logic will also be
   * triggered when various events of the media element are received.
   * @type {Number}
   */
  SAMPLING_INTERVAL_MEDIASOURCE: 1000,
  /**
   * Same than SAMPLING_INTERVAL_MEDIASOURCE but for lowLatency mode.
   * @type {Number}
   */
  SAMPLING_INTERVAL_LOW_LATENCY: 250,
  /**
   * Same than SAMPLING_INTERVAL_MEDIASOURCE but for the directfile API.
   * @type {Number}
   */
  SAMPLING_INTERVAL_NO_MEDIASOURCE: 500,
  /**
   * Amount of buffer to have ahead of the current position before we may
   * consider buffer-based adaptive estimates, in seconds.
   *
   * For example setting it to `10` means that we need to have ten seconds of
   * buffer ahead of the current position before relying on buffer-based
   * adaptive estimates.
   *
   * To avoid getting in-and-out of the buffer-based logic all the time, it
   * should be set higher than `ABR_EXIT_BUFFER_BASED_ALGO`.
   */
  ABR_ENTER_BUFFER_BASED_ALGO: 10,
  /**
   * Below this amount of buffer ahead of the current position, in seconds, we
   * will stop using buffer-based estimate in our adaptive logic to select a
   * quality.
   *
   * For example setting it to `5` means that if we have less than 5 seconds of
   * buffer ahead of the current position, we should stop relying on
   * buffer-based estimates to choose a quality.
   *
   * To avoid getting in-and-out of the buffer-based logic all the time, it
   * should be set lower than `ABR_ENTER_BUFFER_BASED_ALGO`.
   */
  ABR_EXIT_BUFFER_BASED_ALGO: 5,
  /**
   * Minimum number of bytes sampled before we trust the estimate.
   * If we have not sampled much data, our estimate may not be accurate
   * enough to trust.
   * If the total of bytes sampled is less than this value, we use a
   * default estimate.
   * This specific value is based on experimentations.
   * @type {Number}
   */
  ABR_MINIMUM_TOTAL_BYTES: 150e3,
  /**
   * Minimum number of bytes, under which samples are discarded.
   * Our models do not include latency information, so connection startup time
   * (time to first byte) is considered part of the download time.
   * Because of this, we should ignore very small downloads which would cause
   * our estimate to be too low.
   * This specific value is based on experimentation.
   * @type {Number}
   */
  ABR_MINIMUM_CHUNK_SIZE: 16e3,
  /**
   * Factor with which is multiplied the bandwidth estimate when the ABR is in
   * starvation mode.
   * @type {Object}
   */
  ABR_STARVATION_FACTOR: {
    DEFAULT: 0.72,
    LOW_LATENCY: 0.72
  },
  /**
   * Factor with which is multiplied the bandwidth estimate when the ABR is not
   * in starvation mode.
   * @type {Object}
   */
  ABR_REGULAR_FACTOR: {
    DEFAULT: 0.72,
    LOW_LATENCY: 0.72
  },
  /**
   * If a media buffer has less than ABR_STARVATION_GAP in seconds ahead of the
   * current position in its buffer, the adaptive logic will go into starvation
   * mode.
   *
   * It gets out of starvation mode when the OUT_OF_STARVATION_GAP value is
   * reached.
   *
   * Under this starvation mode:
   *
   *   - the bandwidth considered will be a little lower than the one estimated
   *
   *   - the time the next important request take will be checked
   *     multiple times to detect when/if it takes too much time.
   *     If the request is considered too long, the bitrate will be hastily
   *     re-calculated from this single request.
   *
   * @type {Object}
   */
  ABR_STARVATION_GAP: {
    DEFAULT: 5,
    LOW_LATENCY: 5
  },
  OUT_OF_STARVATION_GAP: {
    DEFAULT: 7,
    LOW_LATENCY: 7
  },
  /**
   * This is a security to avoid going into starvation mode when the content is
   * ending (@see ABR_STARVATION_GAP).
   * Basically, we subtract that value from the global duration of the content
   * and we never enter "starvation mode" if the currently available buffer
   * (which equals to the current position + the available buffer ahead of it)
   * is equal or higher than this value.
   * @type {Number}
   */
  ABR_STARVATION_DURATION_DELTA: 0.1,
  /**
   * Half-life, in seconds for a fastly-evolving exponential weighted moving
   * average.
   * The lower it is, the faster the ABR logic will react to the bandwidth
   * falling quickly.
   * Should be kept to a lower number than ABR_SLOW_EMA for coherency reasons.
   * @type {Number}
   */
  ABR_FAST_EMA: 2,
  /**
   * Half-life, in seconds for a slowly-evolving exponential weighted moving
   * average.
   * The lower it is, the faster the ABR logic is going to react to recent
   * bandwidth variation, on the higher and on the lower side.
   * Should be kept to a higher number than ABR_FAST_EMA for coherency reasons.
   * @type {Number}
   */
  ABR_SLOW_EMA: 10,
  /**
   * Number of seconds ahead in the buffer after which playback will resume when
   * seeking on an unbuffered part of the content.
   * @type {Number}
   */
  RESUME_GAP_AFTER_SEEKING: {
    DEFAULT: 1.5,
    LOW_LATENCY: 0.5
  },
  /**
   * Number of seconds ahead in the buffer after which playback will resume when
   * the player was rebuffering due to a low readyState.
   * @type {Number}
   */
  RESUME_GAP_AFTER_NOT_ENOUGH_DATA: {
    DEFAULT: 0.5,
    LOW_LATENCY: 0.5
  },
  /**
   * Number of seconds ahead in the buffer after which playback will resume
   * after the player went through a buffering step.
   * @type {Number}
   */
  RESUME_GAP_AFTER_BUFFERING: {
    DEFAULT: 5,
    LOW_LATENCY: 0.5
  },
  /**
   * Maximum number of seconds in the buffer based on which a "rebuffering"
   * strategy will be considered:
   * The player will pause playback to get enough time building a sufficient
   * buffer. This mostly happen when seeking in an unbuffered part or when not
   * enough buffer is ahead of the current position.
   * @type {Number}
   */
  REBUFFERING_GAP: {
    DEFAULT: 0.5,
    LOW_LATENCY: 0.2
  },
  /**
   * Amount of time (in seconds) with data ahead of the current position, at
   * which we always consider the browser to be able to play.
   *
   * If the media element has this amount of data in advance or more but
   * playback cannot begin, the player will consider it "freezing".
   */
  MINIMUM_BUFFER_AMOUNT_BEFORE_FREEZING: 2,
  /**
   * A media whose position inexplicably does not increment despite playing is
   * called as "freezing" in the RxPlayer.
   *
   * If the media is still "freezing" after waiting for `UNFREEZING_SEEK_DELAY`
   * milliseconds, the RxPlayer will try to un-freeze the situation by interacting
   * with the media element.
   *
   * Those interactions can be costly in time before playback continue, so it
   * should be set at a sufficiently high value to avoid false positives.
   */
  UNFREEZING_SEEK_DELAY: 6000,
  /**
   * A media whose position inexplicably does not increment despite playing is
   * called as "freezing" in the RxPlayer.
   *
   * A small freezing interval may be normal as the browser may take time before
   * playing, e.g. after a seek.
   *
   * If the media is still "freezing" after waiting for `FREEZING_STALLED_DELAY`
   * milliseconds, the RxPlayer will emit a BUFFERING state through its API to
   * notify that the player cannot currently advance.
   */
  FREEZING_STALLED_DELAY: 600,
  /**
   * A media whose position inexplicably does not increment despite playing is
   * called as "freezing" in the RxPlayer.
   *
   * If the media is frozen for a sufficiently large time
   * (@see UNFREEZING_SEEK_DELAY), the RxPlayer will perform a seek corresponding
   * to its current position plus `UNFREEZING_DELTA_POSITION` seconds.
   *
   * This should be kept short enough as the goal is just to un-freeze lower-level
   * buffers.
   */
  UNFREEZING_DELTA_POSITION: 0.001,
  /**
   * The RxPlayer has a recurring logic which will synchronize the browser's
   * buffers' buffered time ranges with its internal representation in the
   * RxPlayer to then rely on that internal representation to determine where
   * segments are technically present in the browser's buffer.
   *
   * We found out that when inserting a new segment to the buffer, the browser
   * may actually take time before actually considering the full segment in its
   * advertised buffered time ranges.
   *
   * This value thus set an amount of milliseconds we might want to wait before
   * being sure that the buffered time ranges should have considered a segment
   * that has been pushed.
   */
  SEGMENT_SYNCHRONIZATION_DELAY: 1500,
  /**
   * The `SEGMENT_SYNCHRONIZATION_DELAY` defined in this same configuration
   * object only needs to be used if it appears that the current buffered
   * time ranges do not reflect the full data of a pushed segment yet.
   *
   * The `MISSING_DATA_TRIGGER_SYNC_DELAY` value thus allows to define a
   * minimum time difference in seconds between what's buffered and what the
   * segment's ranges should have been, from which we might consider that we may
   * want to wait the `SEGMENT_SYNCHRONIZATION_DELAY` before trusting the buffered
   * time ranges for that segment.
   * If what's missing from that segment is however less than that value in
   * seconds, we can begin to trust the reported buffered time ranges.
   *
   * Should generally be inferior to `MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT`.
   */
  MISSING_DATA_TRIGGER_SYNC_DELAY: 0.1,
  /**
   * Maximum authorized difference between what we calculated to be the
   * beginning or end of the segment in a media buffer and what we
   * actually are noticing now.
   *
   * If the segment seems to have removed more than this size in seconds, we
   * will infer that the segment has been garbage collected and we might try to
   * re-download it.
   * @type {Number}
   */
  MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT: 0.15,
  /**
   * The maximum authorized difference, in seconds, between the real buffered
   * time of a given chunk and what the segment information of the Manifest
   * tells us.
   *
   * Setting a value too high can lead to parts of the media buffer being
   * linked to the wrong segments and to segments wrongly believed to be still
   * complete (instead of garbage collected).
   *
   * Setting a value too low can lead to parts of the media buffer not being
   * linked to the concerned segment and to segments wrongly believed to be
   * partly garbage collected (instead of complete segments).
   * @type {Number}
   */
  MAX_MANIFEST_BUFFERED_START_END_DIFFERENCE: 0.4,
  /**
   * The maximum authorized difference, in seconds, between the duration a
   * segment should have according to the Manifest and the actual duration it
   * seems to have once pushed to the media buffer.
   *
   * Setting a value too high can lead to parts of the media buffer being
   * linked to the wrong segments and to segments wrongly believed to be still
   * complete (instead of garbage collected).
   *
   * Setting a value too low can lead to parts of the media buffer not being
   * linked to the concerned segment and to segments wrongly believed to be
   * partly garbage collected (instead of complete segments). This last point
   * could lead to unnecessary segment re-downloading.
   * @type {Number}
   */
  MAX_MANIFEST_BUFFERED_DURATION_DIFFERENCE: 0.3,
  /**
   * Minimum duration in seconds a segment should be into a buffered range to be
   * considered as part of that range.
   * Segments which have less than this amount of time "linked" to a buffered
   * range will be deleted.
   *
   * Setting a value too low can lead in worst-case scenarios to segments being
   * wrongly linked to the next or previous range it is truly linked too (if
   * those ranges are too close).
   *
   * Setting a value too high can lead to part of the buffer not being assigned
   * any segment. It also limits the minimum duration a segment can be.
   *
   * TODO As of now, this limits the minimum size a complete segment can be. A
   * better logic would be to also consider the duration of a segment. Though
   * this logic could lead to bugs with the current code.
   * @type {Number}
   */
  MINIMUM_SEGMENT_SIZE: 0.005,
  /**
   * Append windows allow to filter media data from segments if they are outside
   * a given limit.
   * Coded frames with presentation timestamp within this range are allowed to
   * be appended to the media buffer while coded frames outside this range are
   * filtered out.
   *
   * Those are often set to be the start and end of the "Period" the segment is
   * in.
   * However, we noticed that some browsers were too aggressive when the exact
   * limits were set: more data than needed was removed, often leading to
   * discontinuities.
   *
   * Those securities are added to the set windows (substracted from the window
   * start and added to the window end) to avoid those problems.
   * @type {Object}
   */
  APPEND_WINDOW_SECURITIES: {
    START: 0.2,
    END: 0.1
  },
  /**
   * Maximum interval at which text tracks are refreshed in an "html"
   * textTrackMode.
   *
   * The text tracks are also refreshed on various video events, this interval
   * will only trigger a refresh if none of those events was received during
   * that timespan.
   *
   * Note that if the TextTrack cue did not change between two intervals or
   * events, the DOM won't be refreshed.
   * The TextTrack cues structure is also optimized for fast retrieval.
   * We should thus not have much of a performance impact here if we set a low
   * interval.
   *
   * @type {Number}
   */
  MAXIMUM_HTML_TEXT_TRACK_UPDATE_INTERVAL: 50,
  /**
   * On browsers with no ResizeObserver API, this will be the interval in
   * milliseconds at which we should check if the text track element has
   * changed its size, and updates proportional text-track data accordingly
   * (like a proportional font-size).
   *
   * This is only used:
   *   - in an "html" textTrackMode
   *   - when some styling is proportional in the text track data
   *
   * Putting a value too low will render faster but might use to much proc time.
   * Putting a value too high might provoke a re-render too late after the user
   * changed the element's size (e.g. when going to fullscreen mode).
   *
   * @type {Number}
   */
  TEXT_TRACK_SIZE_CHECKS_INTERVAL: 250,
  /**
   * The Buffer padding is a time offset from the current time that affects
   * the buffer.
   *
   * Basically, from a given time, if the current buffer gap number (time
   * between the current time and the end of the downloaded buffer) is above
   * the padding described here (of the corresponding type), we won't
   * reschedule segments for that range.
   *
   * This is to avoid excessive re-buffering.
   *
   * Keeping the padding too low would increase the risk of re-bufferings.
   *
   * Keeping the padding too high would delay visible quality increase.
   *
   * @type {Object}
   */
  BUFFER_PADDING: {
    audio: 1,
    // only "audio" segments
    video: 3,
    // only "video" segments
    other: 1 // tracks which are not audio/video (text images).
  },
  /**
   * Segments of different types are downloaded by steps:
   *
   *   - first the audio/video/text Segments which are immediately needed
   *
   *   - then once every of those Segments have been downloaded, less-needed
   *     Segments
   *
   *   - then once every of those less-needed Segments have been downloaded,
   *     even less-needed Segments
   *
   *   - etc.
   *
   * This stepped download strategy allows to make a better use of network
   * ressources.
   *
   * For example, if more than sufficient audio buffer has been downloaded but
   * the immediately-needed video Segment is still pending its request, we might
   * be in a situation of rebuffering.
   * In that case, a better strategy would be to make sure every network
   * ressource is allocated for this video Segment before rebuffering happens.
   *
   * This is where those steps become useful.
   *
   * --
   *
   * The numbers defined in this Array describe what the steps are.
   *
   * Each number is linked to a distance from the current playing position, in
   * seconds.
   * Distances which will be used as limit points, from which a new step is
   * reached (see example).
   *
   * In the RxPlayer's code, each step is then translated in to a priority
   * number.
   * The lower is that number, the lower is the step and the lower is the step,
   * the higher is the priority.
   *
   * Note: You can set an empty array to deactivate the steps feature (every
   * Segments have the same priority).
   *
   * @example
   *
   * let's imagine the following SEGMENT_PRIORITIES_STEPS array:
   * [5, 11, 17, 25]
   *
   * To link each Segments to a corresponding priority number (and thus to a
   * specific step), we have to consider the distance between the current
   * position and the start time of the Segment.
   *
   * We have in our example 5 groups, which correspond to the following possible
   * distances:
   *   1. inferior to 5 => first step (priority number = 0)
   *   2. between 5 and 11 => second step (priority number = 1)
   *   3. between 11 and 17 => third step (priority number = 2)
   *   4. between 17 and 25 => fourth step (priority number = 3)
   *   5. superior to 25 => fifth step (priority number = 4)
   *
   * Segments corresponding to a lower-step will need to all be downloaded
   * before Segments of a newer step begin.
   *
   * @type {Array.<Number>}
   */
  SEGMENT_PRIORITIES_STEPS: [2,
  // 1st Step (priority number = 0):  < 2
  4,
  // 2nd Step (priority number = 1):  2-4
  8,
  // 3rd Step (priority number = 2):  4-8
  12,
  // 4th Step (priority number = 3):  8-12
  18,
  // 5th Step (priority number = 4):  12-18
  25],
  // 6th Step (priority number = 5):  18-25
  // 7th Step (priority number = 6):  >= 25
  /**
   * Some segment requests are said to be "high priority".
   *
   * Requests in that category once done will cancel any segment request that
   * has a low priority number (see `SEGMENT_PRIORITIES_STEPS`) - meaning a
   * priority number equal to `MIN_CANCELABLE_PRIORITY` or more.
   *
   * Enter here the last priority number that is considered high priority
   * (beginning by the first step, which has the priority number `0`).
   * @type {number}
   */
  MAX_HIGH_PRIORITY_LEVEL: 1,
  // priority number 1 and lower is high priority
  /**
   * Enter here the first priority step (see `SEGMENT_PRIORITIES_STEPS`) that
   * will be considered as low priority.
   *
   * Segment requests with a low priority will be cancelled if a high priority
   * segment request (see MAX_HIGH_PRIORITY_LEVEL) is scheduled while they are
   * pending.
   *
   * This number should be strictly superior to the value indicated in
   * `MAX_HIGH_PRIORITY_LEVEL`.
   * @type {number}
   */
  MIN_CANCELABLE_PRIORITY: 3,
  // priority number 3 onward can be cancelled
  /**
   * Codecs used in the videoCapabilities of the MediaKeySystemConfiguration
   * (DRM).
   *
   * Defined in order of importance (first will be tested first etc.)
   * @type {Array.<string>}
   */
  EME_DEFAULT_VIDEO_CODECS: ['video/mp4;codecs="avc1.4d401e"', 'video/mp4;codecs="avc1.42e01e"', 'video/webm;codecs="vp8"'],
  /**
   * Codecs used in the audioCapabilities of the MediaKeySystemConfiguration
   * (DRM).
   *
   * Defined in order of importance (first will be tested first etc.)
   * @type {Array.<string>}
   */
  EME_DEFAULT_AUDIO_CODECS: ['audio/mp4;codecs="mp4a.40.2"', "audio/webm;codecs=opus"],
  /**
   * Robustnesses used in the {audio,video}Capabilities of the
   * MediaKeySystemConfiguration (DRM).
   *
   * Only used for widevine keysystems.
   *
   * Defined in order of importance (first will be tested first etc.)
   * @type {Array.<string>}
   */
  EME_DEFAULT_WIDEVINE_ROBUSTNESSES: ["HW_SECURE_ALL", "HW_SECURE_DECODE", "HW_SECURE_CRYPTO", "SW_SECURE_DECODE", "SW_SECURE_CRYPTO"],
  /**
   * Robustnesses used in the {audio,video}Capabilities of the
   * MediaKeySystemConfiguration (DRM).
   *
   * Only used for "com.microsoft.playready.recommendation" key system.
   *
   * Defined in order of importance (first will be tested first etc.)
   * @type {Array.<string>}
   */
  EME_DEFAULT_PLAYREADY_ROBUSTNESSES: ["3000", "2000"],
  /**
   * Link canonical key systems names to their respective reverse domain name,
   * used in the EME APIs.
   * This allows to have a simpler API, where users just need to set "widevine"
   * or "playready" as a keySystem.
   * @type {Object}
   */
  /* eslint-disable @typescript-eslint/consistent-type-assertions */
  EME_KEY_SYSTEMS: {
    clearkey: ["webkit-org.w3.clearkey", "org.w3.clearkey"],
    widevine: ["com.widevine.alpha"],
    playready: ["com.microsoft.playready.recommendation", "com.microsoft.playready", "com.chromecast.playready", "com.youtube.playready"],
    fairplay: ["com.apple.fps.1_0"]
  },
  /* eslint-enable @typescript-eslint/consistent-type-assertions */
  /**
   * The Manifest parsing logic has a notion of "unsafeMode" which allows to
   * speed-up this process a lot with a small risk of de-synchronization with
   * what actually is on the server.
   * Because using that mode is risky, and can lead to all sort of problems, we
   * regularly should fall back to a regular "safe" parsing every once in a
   * while.
   * This value defines how many consecutive time maximum the "unsafeMode"
   * parsing can be done.
   */
  MAX_CONSECUTIVE_MANIFEST_PARSING_IN_UNSAFE_MODE: 10,
  /**
   * Minimum time spent parsing the Manifest before we can authorize parsing
   * it in an "unsafeMode", to speed-up the process with a little risk.
   * Please note that this parsing time also sometimes includes idle time such
   * as when the parser is waiting for a request to finish.
   */
  MIN_MANIFEST_PARSING_TIME_TO_ENTER_UNSAFE_MODE: 200,
  /**
   * Minimum amount of <S> elements in a DASH MPD's <SegmentTimeline> element
   * necessary to begin parsing the current SegmentTimeline element in an
   * unsafe manner (meaning: with risks of de-synchronization).
   * This is only done when the "unsafeMode" parsing mode is enabled.
   */
  MIN_DASH_S_ELEMENTS_TO_PARSE_UNSAFELY: 300,
  /**
   * When we detect that the local Manifest might be out-of-sync with the
   * server's one, we schedule a Manifest refresh.
   * However, as this "unsynchronization" is only a theory and as we do not want
   * to send too many Manifest requests, we keep a delay between the last
   * Manifest refresh done and that one.
   * This value indicates which delay we want. Note that the Manifest could
   * still be refreshed before this delay for other reasons.
   * @type {Number}
   */
  OUT_OF_SYNC_MANIFEST_REFRESH_DELAY: 3000,
  /**
   * When a partial Manifest update (that is an update with a partial sub-set
   * of the Manifest) fails, we will perform an update with the whole Manifest
   * instead.
   * To not overload the client - as parsing a Manifest can be resource heavy -
   * we set a minimum delay to wait before doing the corresponding request.
   * @type {Number}
   */
  FAILED_PARTIAL_UPDATE_MANIFEST_REFRESH_DELAY: 3000,
  /**
   * DASH Manifest based on a SegmentTimeline should normally have an
   * MPD@minimumUpdatePeriod attribute which should be sufficient to
   * know when to refresh it.
   * However, there is a specific case, for when it is equal to 0.
   * As of DASH-IF IOP (valid in v4.3), when a DASH's MPD set a
   * MPD@minimumUpdatePeriod to `0`, a client should not refresh the MPD
   * unless told to do so through inband events, in the stream.
   * In reality however, we found it to not always be the case (even with
   * DASH-IF own streams) and moreover to not always be the best thing to do.
   * We prefer to refresh in average at a regular interval when we do not have
   * this information.
   * /!\ This value is expressed in seconds.
   */
  DASH_FALLBACK_LIFETIME_WHEN_MINIMUM_UPDATE_PERIOD_EQUAL_0: 3,
  /**
   * Default value for the maximum number of simultaneous MediaKeySessions that
   * will be kept in a cache (linked to the MediaKeys instance) to avoid doing
   * superfluous license requests.
   *
   * If this number is reached, any new session creation will close the oldest
   * one.
   * Another value can be configured through the API, in which case this default
   * will be overwritten.
   * @type {Number}
   */
  EME_DEFAULT_MAX_SIMULTANEOUS_MEDIA_KEY_SESSIONS: 15,
  /**
   * When playing contents with a persistent license, we will usually store some
   * information related to that MediaKeySession, to be able to play it at a
   * later time.
   *
   * Those information are removed once a MediaKeySession is not considered
   * as "usable" anymore. But to know that, the RxPlayer has to load it.
   *
   * But the RxPlayer does not re-load every persisted MediaKeySession every
   * time to check each one of them one by one, as this would not be a
   * performant thing to do.
   *
   * So this is only done when and if the corresponding content is encountered
   * again and only if it contains the same initialization data.
   *
   * We have to consider that those "information" contain binary data which can
   * be of arbitrary length. Size taken by an array of them can relatively
   * rapidly take a lot of space in JS memory.
   *
   * So to avoid this storage to take too much space (would it be in the chosen
   * browser's storage or in JS memory), we now set a higher bound for the
   * amount of MediaKeySession information that can be stored at the same time.
   *
   * I set the value of 1000 here, as it seems big enough to not be considered a
   * problem (though it can become one, when contents have a lot of keys per
   * content), and still low enough so it should not cause much problem (my
   * method to choose that number was to work with power of 10s and choosing the
   * amount which seemed the most sensible one).
   *
   * This wasn't battle-tested however.
   */
  EME_MAX_STORED_PERSISTENT_SESSION_INFORMATION: 1000,
  /**
   * After loading a persistent MediaKeySession, the RxPlayer needs to ensure
   * that its keys still allow to decrypt a content.
   *
   * However on some browsers, the `keyStatuses` property that we used to check
   * the keys' satuses linked to that session can be empty for some time after
   * the loading operation is done.
   *
   * This value allows to configure a delay in milliseconds that will be the
   * maximum time we will wait after a persistent session is loaded.
   * If after that time, the `keyStatuses` property is still empty, we will
   * consider that session as not usable.
   */
  EME_WAITING_DELAY_LOADED_SESSION_EMPTY_KEYSTATUSES: 100,
  /**
   * The player relies on browser events and properties to update its status to
   * "ENDED".
   *
   * Sadly in some cases, like in Chrome 54, this event is never triggered on
   * some contents probably due to a browser bug.
   *
   * This threshold resolves this issue by forcing the status to "ENDED" when:
   *   1. the player is stalling
   *   2. the absolute difference between current playback time and duration is
   *      under this value
   *
   * If set to null, this workaround is disabled and the player only relies on
   * browser events.
   *
   * @type {Number|null}
   */
  FORCED_ENDED_THRESHOLD: 0.0008,
  /**
   * Maximum duration from the current position we will let in the buffer when
   * switching an Adaptation of a given type.
   *
   * For example, if we have ``text: { before: 1, after: 4 }``, it means that
   * when switching subtitles, we will let 1 second before and 4 second after
   * the current position in the previous language (until the new segments
   * overwrite it).
   * This is to allow smooth transitions and avoid de-synchronization that
   * can happen when removing the content being decoded.
   * @type {Object}
   */
  ADAPTATION_SWITCH_BUFFER_PADDINGS: {
    video: {
      before: 5,
      after: 5
    },
    audio: {
      before: 2,
      after: 2.5
    },
    text: {
      before: 0,
      after: 0
    },
    // not managed natively, so no problem here
    image: {
      before: 0,
      after: 0
    } // not managed natively, so no problem here
  },
  /**
   * Interval, in milliseconds, at which we should manually flush
   * SourceBuffers.
   * Some browsers (happened with firefox 66) sometimes "forget" to send us
   * `update` or `updateend` events.
   * In that case, we're completely unable to continue the queue here and
   * stay locked in a waiting state.
   * This interval is here to check at regular intervals if the underlying
   * SourceBuffer is currently updating.
   * @type {Number}
   */
  SOURCE_BUFFER_FLUSHING_INTERVAL: 500,
  /**
   * Any already-pushed segment starting before or at the current position +
   * CONTENT_REPLACEMENT_PADDING won't be replaced by new segments.
   *
   * This allows to avoid overwriting segments that are currently being decoded
   * as we encountered many decoding issues when doing so.
   * @type {Number} - in seconds
   */
  CONTENT_REPLACEMENT_PADDING: 1.2,
  /**
   * For video and audio segments, determines two thresholds below which :
   * - The segment is considered as loaded from cache
   * - The segment may be loaded from cache depending on the previous request
   */
  CACHE_LOAD_DURATION_THRESHOLDS: {
    video: 50,
    audio: 10
  },
  /** Interval we will use to poll for checking if an event shall be emitted */
  STREAM_EVENT_EMITTER_POLL_INTERVAL: 250,
  /**
   * In Javascript, numbers are encoded in a way that a floating number may be
   * represented internally with a rounding error. When multiplying times in
   * seconds by the timescale, we've encoutered cases were the rounding error
   * was amplified by a factor which is about the timescale.
   * Example :
   * (192797480.641122).toFixed(20) = 192797480.64112201333045959473
   * (error is 0.0000000133...)
   * 192797480.641122 * 10000000 = 1927974806411220.2 (error is 0.2)
   * 192797480.641122 * 10000000 * 4 = 7711899225644881 (error is 1)
   * The error is much more significant here, once the timescale has been
   * applied.
   * Thus, we consider that our max tolerable rounding error is 1ms.
   * It is much more than max rounding errors when seen into practice,
   * and not significant from the media loss perspective.
   */
  DEFAULT_MAXIMUM_TIME_ROUNDING_ERROR: 1 / 1000,
  /**
   * RxPlayer's media buffers have a linked history registering recent events
   * that happened on those.
   * The reason is to implement various heuristics in case of weird browser
   * behavior.
   *
   * The `BUFFERED_HISTORY_RETENTION_TIME` is the minimum age an entry of
   * that history can have before being removed from the history.
   */
  BUFFERED_HISTORY_RETENTION_TIME: 60000,
  /**
   * RxPlayer's media buffers have a linked history registering recent events
   * that happened on those.
   * The reason is to implement various heuristics in case of weird browser
   * behavior.
   *
   * The `BUFFERED_HISTORY_RETENTION_TIME` is the maximum number of entries
   * there can be in that history.
   */
  BUFFERED_HISTORY_MAXIMUM_ENTRIES: 200,
  /**
   * Minimum buffer in seconds ahead relative to current time
   * we should be able to download, even in cases of saturated memory.
   */
  MIN_BUFFER_AHEAD: 5,
  /**
   * Distance in seconds behind the current position
   * the player will free up to in the case we agressively free up memory
   * It is set to avoid playback issues
   */
  UPTO_CURRENT_POSITION_CLEANUP: 5
};
/* harmony default export */ var default_config = (DEFAULT_CONFIG);
// EXTERNAL MODULE: ./src/utils/object_assign.ts
var object_assign = __webpack_require__(8935);
;// CONCATENATED MODULE: ./src/utils/deep_merge.ts

/**
 * Check if an item is an object
 * @param item
 * @returns {boolean}
 */
function isObject(item) {
  return item !== null && item !== undefined && !Array.isArray(item) && typeof item === "object";
}
/**
 * Deeply merge nested objects
 * @param target
 * @param sources
 * @returns output : merged object
 */
function deepMerge(target) {
  for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    sources[_key - 1] = arguments[_key];
  }
  if (sources.length === 0) {
    return target;
  }
  var source = sources.shift();
  if (isObject(target) && isObject(source)) {
    for (var key in source) {
      if (isObject(source[key])) {
        var newTarget = target[key];
        if (newTarget === undefined) {
          newTarget = {};
          target[key] = newTarget;
        }
        deepMerge(newTarget, source[key]);
      } else {
        var _objectAssign;
        (0,object_assign/* default */.A)(target, (_objectAssign = {}, _objectAssign[key] = source[key], _objectAssign));
      }
    }
  }
  return deepMerge.apply(void 0, [target].concat(sources));
}
;// CONCATENATED MODULE: ./src/config.ts


var ConfigHandler = /*#__PURE__*/function () {
  function ConfigHandler() {
    this._config = default_config;
  }
  var _proto = ConfigHandler.prototype;
  _proto.update = function update(config) {
    var newConfig = deepMerge(this._config, config);
    this._config = newConfig;
  };
  _proto.getCurrent = function getCurrent() {
    return this._config;
  };
  return ConfigHandler;
}();
var configHandler = new ConfigHandler();
/* harmony default export */ var config = (configHandler);

/***/ }),

/***/ 3568:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: function() { return /* binding */ MediaElementTrackChoiceManager; }
});

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js
var inheritsLoose = __webpack_require__(7387);
// EXTERNAL MODULE: ./src/compat/browser_detection.ts
var browser_detection = __webpack_require__(443);
;// CONCATENATED MODULE: ./src/compat/enable_audio_track.ts

/**
 * Enable the audio track at the given index while disabling all others in the
 * `audioTracks` array.
 *
 * Returns false if the given index is not found in the `audioTracks` array.
 * @param {array.<audioTrack>} audioTracks
 * @param {number} indexToEnable
 * @returns {boolean}
 */
function enableAudioTrack(audioTracks, indexToEnable) {
  // Seen on Safari MacOS only (2022-02-14), not disabling ALL audio tracks
  // first (even the wanted one), can lead to the media not playing.
  for (var i = 0; i < audioTracks.length; i++) {
    // However, Tizen just plays no audio if it is disabled then enabled
    // synchronously (2022-10-12)
    if (!browser_detection/* isTizen */.ZN || i !== indexToEnable) {
      audioTracks[i].enabled = false;
    }
  }
  if (indexToEnable < 0 || indexToEnable >= audioTracks.length) {
    return false;
  }
  audioTracks[indexToEnable].enabled = true;
  return true;
}
// EXTERNAL MODULE: ./src/utils/event_emitter.ts
var event_emitter = __webpack_require__(79);
// EXTERNAL MODULE: ./src/utils/languages/index.ts
var languages = __webpack_require__(8202);
;// CONCATENATED MODULE: ./src/core/api/tracks_management/media_element_track_choice_manager.ts

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */



/**
 * Check if track array is different from an other one
 * @param {Array.<Object>} oldTrackArray
 * @param {Array.<Object>} newTrackArray
 * @returns {boolean}
 */
function areTrackArraysDifferent(oldTrackArray, newTrackArray) {
  var _a;
  if (newTrackArray.length !== oldTrackArray.length) {
    return true;
  }
  for (var i = 0; i < newTrackArray.length; i++) {
    if (newTrackArray[i].nativeTrack !== ((_a = oldTrackArray[i]) === null || _a === void 0 ? void 0 : _a.nativeTrack)) {
      return true;
    }
  }
  return false;
}
/**
 * Create audio tracks from native audio tracks.
 * @param {AudioTrackList} audioTracks
 * @returns {Array.<Object>}
 */
function createAudioTracks(audioTracks) {
  var _a;
  var newAudioTracks = [];
  var languagesOccurences = {};
  for (var i = 0; i < audioTracks.length; i++) {
    var audioTrack = audioTracks[i];
    var language = audioTrack.language === "" ? "nolang" : audioTrack.language;
    var occurences = (_a = languagesOccurences[language]) !== null && _a !== void 0 ? _a : 1;
    var id = "gen_audio_" + language + "_" + occurences.toString();
    languagesOccurences[language] = occurences + 1;
    var track = {
      language: audioTrack.language,
      id: id,
      normalized: (0,languages/* default */.Ay)(audioTrack.language),
      audioDescription: audioTrack.kind === "descriptions" ||
      // Safari seem to prefer the non-standard singular
      // version, funnily enough
      audioTrack.kind === "description",
      representations: []
    };
    newAudioTracks.push({
      track: track,
      nativeTrack: audioTrack
    });
  }
  return newAudioTracks;
}
/**
 * Create text tracks from native text tracks.
 * @param {TextTrackList} textTracks
 * @returns {Array.<Object>}
 */
function createTextTracks(textTracks) {
  var _a;
  var newTextTracks = [];
  var languagesOccurences = {};
  for (var i = 0; i < textTracks.length; i++) {
    var textTrack = textTracks[i];
    var language = textTrack.language === "" ? "nolang" : textTrack.language;
    var occurences = (_a = languagesOccurences[language]) !== null && _a !== void 0 ? _a : 1;
    var id = "gen_text_" + language + "_" + occurences.toString();
    languagesOccurences[language] = occurences + 1;
    // Safari seems to be indicating that the subtitles track is a forced
    // subtitles track by setting the `kind` attribute to `"forced"`.
    // As of now (2023-04-04), this is not standard.
    // @see https://github.com/whatwg/html/issues/4472
    var forced = textTrack.kind === "forced" ? true : undefined;
    var track = {
      language: textTrack.language,
      forced: forced,
      label: textTrack.label,
      id: id,
      normalized: (0,languages/* default */.Ay)(textTrack.language),
      closedCaption: textTrack.kind === "captions"
    };
    newTextTracks.push({
      track: track,
      nativeTrack: textTrack
    });
  }
  return newTextTracks;
}
/**
 * Create video tracks from native video tracks.
 * @param {VideoTrackList} videoTracks
 * @returns {Array.<Object>}
 */
function createVideoTracks(videoTracks) {
  var _a;
  var newVideoTracks = [];
  var languagesOccurences = {};
  for (var i = 0; i < videoTracks.length; i++) {
    var videoTrack = videoTracks[i];
    var language = videoTrack.language === "" ? "nolang" : videoTrack.language;
    var occurences = (_a = languagesOccurences[language]) !== null && _a !== void 0 ? _a : 1;
    var id = "gen_video_" + language + "_" + occurences.toString();
    languagesOccurences[language] = occurences + 1;
    newVideoTracks.push({
      track: {
        id: id,
        representations: []
      },
      nativeTrack: videoTrack
    });
  }
  return newVideoTracks;
}
/**
 * Manage video, audio and text tracks for current direct file content.
 * @class MediaElementTrackChoiceManager
 */
var MediaElementTrackChoiceManager = /*#__PURE__*/function (_EventEmitter) {
  function MediaElementTrackChoiceManager(mediaElement) {
    var _this;
    var _a, _b, _c;
    _this = _EventEmitter.call(this) || this;
    _this._preferredAudioTracks = [];
    _this._preferredTextTracks = [];
    _this._preferredVideoTracks = [];
    // TODO In practice, the audio/video/text tracks API are not always implemented on
    // the media element, although Typescript HTMLMediaElement types tend to mean
    // that can't be undefined.
    _this._nativeAudioTracks = mediaElement.audioTracks;
    _this._nativeVideoTracks = mediaElement.videoTracks;
    _this._nativeTextTracks = mediaElement.textTracks;
    _this._audioTracks = _this._nativeAudioTracks !== undefined ? createAudioTracks(_this._nativeAudioTracks) : [];
    _this._videoTracks = _this._nativeVideoTracks !== undefined ? createVideoTracks(_this._nativeVideoTracks) : [];
    _this._textTracks = _this._nativeTextTracks !== undefined ? createTextTracks(_this._nativeTextTracks) : [];
    _this._lastEmittedNativeAudioTrack = (_a = _this._getPrivateChosenAudioTrack()) === null || _a === void 0 ? void 0 : _a.nativeTrack;
    _this._lastEmittedNativeVideoTrack = (_b = _this._getPrivateChosenVideoTrack()) === null || _b === void 0 ? void 0 : _b.nativeTrack;
    _this._lastEmittedNativeTextTrack = (_c = _this._getPrivateChosenTextTrack()) === null || _c === void 0 ? void 0 : _c.nativeTrack;
    _this._handleNativeTracksCallbacks();
    return _this;
  }
  /**
   * Set the list of preferred audio tracks, in preference order.
   * @param {Array.<Object>} preferredAudioTracks
   * @param {boolean} shouldApply - `true` if those preferences should be
   * applied on the currently loaded Period. `false` if it should only
   * be applied to new content.
   */
  (0,inheritsLoose/* default */.A)(MediaElementTrackChoiceManager, _EventEmitter);
  var _proto = MediaElementTrackChoiceManager.prototype;
  _proto.setPreferredAudioTracks = function setPreferredAudioTracks(preferredAudioTracks, shouldApply) {
    this._preferredAudioTracks = preferredAudioTracks;
    if (shouldApply) {
      this._applyAudioPreferences();
    }
  }
  /**
   * Set the list of preferred text tracks, in preference order.
   * @param {Array.<Object>} preferredTextTracks
   * @param {boolean} shouldApply - `true` if those preferences should be
   * applied on the currently loaded Period. `false` if it should only
   * be applied to new content.
   */;
  _proto.setPreferredTextTracks = function setPreferredTextTracks(preferredTextTracks, shouldApply) {
    this._preferredTextTracks = preferredTextTracks;
    if (shouldApply) {
      this._applyTextPreferences();
    }
  }
  /**
   * Set the list of preferred video tracks, in preference order.
   * @param {Array.<Object>} preferredVideoTracks
   * @param {boolean} shouldApply - `true` if those preferences should be
   * applied on the currently loaded Period. `false` if it should only
   * be applied to new content.
   */;
  _proto.setPreferredVideoTracks = function setPreferredVideoTracks(preferredVideoTracks, shouldApply) {
    this._preferredVideoTracks = preferredVideoTracks;
    if (shouldApply) {
      this._applyVideoPreferences();
    }
  }
  /**
   * Update the currently active audio track by setting the wanted audio track's
   * ID property.
   * Throws if the wanted audio track is not found.
   * @param {string|number|undefined} id
   */;
  _proto.setAudioTrackById = function setAudioTrackById(id) {
    for (var i = 0; i < this._audioTracks.length; i++) {
      var _this$_audioTracks$i = this._audioTracks[i],
        track = _this$_audioTracks$i.track,
        nativeTrack = _this$_audioTracks$i.nativeTrack;
      if (track.id === id) {
        this._enableAudioTrackFromIndex(i);
        this._audioTrackLockedOn = nativeTrack;
        return;
      }
    }
    throw new Error("Audio track not found.");
  }
  /**
   * Disable the currently-active text track, if one.
   */;
  _proto.disableTextTrack = function disableTextTrack() {
    disableTextTracks(this._textTracks);
    this._textTrackLockedOn = null;
  }
  /**
   * Update the currently active text track by setting the wanted text track's
   * ID property.
   * Throws if the wanted text track is not found.
   * @param {string|number|undefined} id
   */;
  _proto.setTextTrackById = function setTextTrackById(id) {
    var hasSetTrack = false;
    for (var i = 0; i < this._textTracks.length; i++) {
      var _this$_textTracks$i = this._textTracks[i],
        track = _this$_textTracks$i.track,
        nativeTrack = _this$_textTracks$i.nativeTrack;
      if (track.id === id) {
        nativeTrack.mode = "showing";
        hasSetTrack = true;
        this._textTrackLockedOn = nativeTrack;
      } else if (nativeTrack.mode === "showing" || nativeTrack.mode === "hidden") {
        nativeTrack.mode = "disabled";
      }
    }
    if (!hasSetTrack) {
      throw new Error("Text track not found.");
    }
  }
  /**
   * Disable the currently-active video track, if one.
   */;
  _proto.disableVideoTrack = function disableVideoTrack() {
    disableVideoTracks(this._videoTracks);
    this._videoTrackLockedOn = null;
  }
  /**
   * Update the currently active video track by setting the wanted video track's
   * ID property.
   * Throws if the wanted video track is not found.
   * @param {string|number|undefined} id
   */;
  _proto.setVideoTrackById = function setVideoTrackById(id) {
    for (var i = 0; i < this._videoTracks.length; i++) {
      var _this$_videoTracks$i = this._videoTracks[i],
        track = _this$_videoTracks$i.track,
        nativeTrack = _this$_videoTracks$i.nativeTrack;
      if (track.id === id) {
        nativeTrack.selected = true;
        this._videoTrackLockedOn = nativeTrack;
        return;
      }
    }
    throw new Error("Video track not found.");
  }
  /**
   * Returns the currently active audio track.
   * Returns `null` if no audio track is active.
   * Returns `undefined` if we cannot know which audio track is active.
   * @returns {Object|null|undefined}
   */;
  _proto.getChosenAudioTrack = function getChosenAudioTrack() {
    var chosenPrivateAudioTrack = this._getPrivateChosenAudioTrack();
    if (chosenPrivateAudioTrack != null) {
      return chosenPrivateAudioTrack.track;
    }
    return chosenPrivateAudioTrack;
  }
  /**
   * Returns the currently active text track.
   * Returns `null` if no text track is active.
   * Returns `undefined` if we cannot know which text track is active.
   * @returns {Object|null|undefined}
   */;
  _proto.getChosenTextTrack = function getChosenTextTrack() {
    var chosenPrivateTextTrack = this._getPrivateChosenTextTrack();
    if (chosenPrivateTextTrack != null) {
      return chosenPrivateTextTrack.track;
    }
    return chosenPrivateTextTrack;
  }
  /**
   * Returns the currently active video track.
   * Returns `null` if no video track is active.
   * Returns `undefined` if we cannot know which video track is active.
   * @returns {Object|null|undefined}
   */;
  _proto.getChosenVideoTrack = function getChosenVideoTrack() {
    var chosenPrivateVideoTrack = this._getPrivateChosenVideoTrack();
    if (chosenPrivateVideoTrack != null) {
      return chosenPrivateVideoTrack.track;
    }
    return chosenPrivateVideoTrack;
  }
  /**
   * Returns a description of every available audio tracks.
   * @returns {Array.<Object>}
   */;
  _proto.getAvailableAudioTracks = function getAvailableAudioTracks() {
    return this._audioTracks.map(function (_ref) {
      var track = _ref.track,
        nativeTrack = _ref.nativeTrack;
      return {
        id: track.id,
        language: track.language,
        normalized: track.normalized,
        audioDescription: track.audioDescription,
        active: nativeTrack.enabled,
        representations: track.representations
      };
    });
  }
  /**
   * Returns a description of every available text tracks.
   * @returns {Array.<Object>}
   */;
  _proto.getAvailableTextTracks = function getAvailableTextTracks() {
    return this._textTracks.map(function (_ref2) {
      var track = _ref2.track,
        nativeTrack = _ref2.nativeTrack;
      return {
        id: track.id,
        label: track.label,
        forced: track.forced,
        language: track.language,
        normalized: track.normalized,
        closedCaption: track.closedCaption,
        active: nativeTrack.mode === "showing"
      };
    });
  }
  /**
   * Returns a description of every available video tracks.
   * @returns {Array.<Object>}
   */;
  _proto.getAvailableVideoTracks = function getAvailableVideoTracks() {
    return this._videoTracks.map(function (_ref3) {
      var track = _ref3.track,
        nativeTrack = _ref3.nativeTrack;
      return {
        id: track.id,
        representations: track.representations,
        active: nativeTrack.selected
      };
    });
  }
  /**
   * Free the resources used by the MediaElementTrackChoiceManager.
   */;
  _proto.dispose = function dispose() {
    if (this._nativeVideoTracks !== undefined) {
      this._nativeVideoTracks.onchange = null;
      this._nativeVideoTracks.onaddtrack = null;
      this._nativeVideoTracks.onremovetrack = null;
    }
    if (this._nativeAudioTracks !== undefined) {
      this._nativeAudioTracks.onchange = null;
      this._nativeAudioTracks.onaddtrack = null;
      this._nativeAudioTracks.onremovetrack = null;
    }
    if (this._nativeTextTracks !== undefined) {
      this._nativeTextTracks.onchange = null;
      this._nativeTextTracks.onaddtrack = null;
      this._nativeTextTracks.onremovetrack = null;
    }
    this.removeEventListener();
  }
  /**
   * Get information about the currently chosen audio track.
   * `undefined` if we cannot know it.
   * `null` if no audio track is chosen.
   * @returns {Object|undefined|null}
   */;
  _proto._getPrivateChosenAudioTrack = function _getPrivateChosenAudioTrack() {
    if (this._nativeAudioTracks === undefined) {
      return undefined;
    }
    for (var i = 0; i < this._audioTracks.length; i++) {
      var audioTrack = this._audioTracks[i];
      if (audioTrack.nativeTrack.enabled) {
        return audioTrack;
      }
    }
    return null;
  }
  /**
   * Get information about the currently chosen video track.
   * `undefined` if we cannot know it.
   * `null` if no video track is chosen.
   * @returns {Object|undefined|null}
   */;
  _proto._getPrivateChosenVideoTrack = function _getPrivateChosenVideoTrack() {
    if (this._nativeVideoTracks === undefined) {
      return undefined;
    }
    for (var i = 0; i < this._videoTracks.length; i++) {
      var videoTrack = this._videoTracks[i];
      if (videoTrack.nativeTrack.selected) {
        return videoTrack;
      }
    }
    return null;
  }
  /**
   * Get information about the currently chosen text track.
   * `undefined` if we cannot know it.
   * `null` if no text track is chosen.
   * @returns {Object|undefined|null}
   */;
  _proto._getPrivateChosenTextTrack = function _getPrivateChosenTextTrack() {
    if (this._nativeTextTracks === undefined) {
      return undefined;
    }
    for (var i = 0; i < this._textTracks.length; i++) {
      var textTrack = this._textTracks[i];
      if (textTrack.nativeTrack.mode === "showing") {
        return textTrack;
      }
    }
    return null;
  }
  /**
   * Iterate over every available audio tracks on the media element and either:
   *   - if the last manually set audio track is found, set that one.
   *   - if not, set the most preferred one
   *   - if we still do not find an optimal track, let the one chosen by default
   */;
  _proto._setOptimalAudioTrack = function _setOptimalAudioTrack() {
    // First check if the last set track is available, set it if that's the case
    if (this._audioTrackLockedOn !== undefined) {
      for (var i = 0; i < this._audioTracks.length; i++) {
        var nativeTrack = this._audioTracks[i].nativeTrack;
        if (nativeTrack === this._audioTrackLockedOn) {
          this._enableAudioTrackFromIndex(i);
          return;
        }
      }
    }
    this._applyAudioPreferences();
  }
  /**
   * Try to find a track corresponding to the audio track preferences:
   *   - if found, set it as the active track
   *   - if not found, let the chosen audio track by default
   */;
  _proto._applyAudioPreferences = function _applyAudioPreferences() {
    // Re-set the last manually set audio track
    this._audioTrackLockedOn = undefined;
    var preferredAudioTracks = this._preferredAudioTracks;
    for (var i = 0; i < preferredAudioTracks.length; i++) {
      var track = preferredAudioTracks[i];
      if (track !== null && track.language !== undefined) {
        var normalized = (0,languages/* default */.Ay)(track.language);
        for (var j = 0; j < this._audioTracks.length; j++) {
          var audioTrack = this._audioTracks[j];
          if (audioTrack.track.normalized === normalized && audioTrack.track.audioDescription === track.audioDescription) {
            this._enableAudioTrackFromIndex(j);
            return;
          }
        }
      }
    }
    // else just let the default one instead
  }
  /**
   * Iterate over every available text tracks on the media element and either:
   *   - if the last manually set text track is found, set that one.
   *   - if not, set the most preferred one
   *   - if we still do not find an optimal track, just disable it.
   */;
  _proto._setOptimalTextTrack = function _setOptimalTextTrack() {
    // First check if the last set track is available, set it if that's the case
    if (this._textTrackLockedOn === null) {
      disableTextTracks(this._textTracks);
      return;
    } else if (this._textTrackLockedOn !== undefined) {
      for (var i = 0; i < this._textTracks.length; i++) {
        var nativeTrack = this._textTracks[i].nativeTrack;
        if (nativeTrack === this._textTrackLockedOn) {
          // disable the rest
          disableAllTextTracksBut(this._textTracks, nativeTrack);
          if (nativeTrack.mode !== "showing") {
            nativeTrack.mode = "showing";
          }
          return;
        }
      }
    }
    // Else set the preferred one
    this._applyTextPreferences();
  }
  /**
   * Try to find a track corresponding to the text track preferences:
   *   - if found, set it as the active track
   *   - if not found, let the chosen text track by default
   */;
  _proto._applyTextPreferences = function _applyTextPreferences() {
    // Re-set the last manually set audio track
    this._textTrackLockedOn = undefined;
    var preferredTextTracks = this._preferredTextTracks;
    for (var i = 0; i < preferredTextTracks.length; i++) {
      var track = preferredTextTracks[i];
      if (track === null) {
        disableTextTracks(this._textTracks);
        return;
      }
      var normalized = (0,languages/* default */.Ay)(track.language);
      for (var j = 0; j < this._textTracks.length; j++) {
        var textTrack = this._textTracks[j];
        if (textTrack.track.normalized === normalized && textTrack.track.closedCaption === track.closedCaption) {
          // disable the rest
          disableAllTextTracksBut(this._textTracks, textTrack.nativeTrack);
          if (textTrack.nativeTrack.mode !== "showing") {
            textTrack.nativeTrack.mode = "showing";
          }
          return;
        }
      }
    }
    // Else just disable text tracks
    disableTextTracks(this._textTracks);
  }
  /**
   * Iterate over every available video tracks on the media element and either:
   *   - if the last manually set video track is found, set that one.
   *   - if not, set the most preferred one
   *   - if we still do not find an optimal track, let the one chosen by default
   */;
  _proto._setOptimalVideoTrack = function _setOptimalVideoTrack() {
    // 1. first check if the last set track is available, set it if that's the case
    if (this._videoTrackLockedOn === null) {
      disableVideoTracks(this._videoTracks);
      return;
    } else if (this._videoTrackLockedOn !== undefined) {
      for (var i = 0; i < this._videoTracks.length; i++) {
        var nativeTrack = this._videoTracks[i].nativeTrack;
        if (nativeTrack === this._videoTrackLockedOn) {
          nativeTrack.selected = true;
          return;
        }
      }
    }
    // Else set the preferred one
    this._applyVideoPreferences();
  }
  /**
   * Try to find a track corresponding to the text track preferences:
   *   - if found, set it as the active track
   *   - if not found, let the chosen text track by default
   */;
  _proto._applyVideoPreferences = function _applyVideoPreferences() {
    // Re-set the last manually set video track
    this._videoTrackLockedOn = undefined;
    // NOTE: As we cannot access either codec information or sign interpretation
    // information easily about the different codecs. It is the same case than
    // if we had only tracks where those were set to undefined.
    // Based on that, we should disable the video track as long as one of the
    // set preferrence is "no video track" (i.e. `null`) as this is the only
    // constraint that we know we can respect.
    // Else, just chose the first track.
    var preferredVideoTracks = this._preferredVideoTracks;
    var hasNullPreference = preferredVideoTracks.some(function (p) {
      return p === null;
    });
    if (hasNullPreference) {
      disableVideoTracks(this._videoTracks);
    }
    // else just let the default one instead
  }
  /**
   * Monitor native tracks add, remove and change callback and trigger the
   * change events.
   */;
  _proto._handleNativeTracksCallbacks = function _handleNativeTracksCallbacks() {
    var _this2 = this;
    if (this._nativeAudioTracks !== undefined) {
      this._nativeAudioTracks.onaddtrack = function () {
        var _a, _b;
        if (_this2._nativeAudioTracks !== undefined) {
          var newAudioTracks = createAudioTracks(_this2._nativeAudioTracks);
          if (areTrackArraysDifferent(_this2._audioTracks, newAudioTracks)) {
            _this2._audioTracks = newAudioTracks;
            _this2._setOptimalAudioTrack();
            _this2.trigger("availableAudioTracksChange", _this2.getAvailableAudioTracks());
            var chosenAudioTrack = _this2._getPrivateChosenAudioTrack();
            if ((chosenAudioTrack === null || chosenAudioTrack === void 0 ? void 0 : chosenAudioTrack.nativeTrack) !== _this2._lastEmittedNativeAudioTrack) {
              _this2.trigger("audioTrackChange", (_a = chosenAudioTrack === null || chosenAudioTrack === void 0 ? void 0 : chosenAudioTrack.track) !== null && _a !== void 0 ? _a : null);
              _this2._lastEmittedNativeAudioTrack = (_b = chosenAudioTrack === null || chosenAudioTrack === void 0 ? void 0 : chosenAudioTrack.nativeTrack) !== null && _b !== void 0 ? _b : null;
            }
          }
        }
      };
      this._nativeAudioTracks.onremovetrack = function () {
        var _a, _b;
        if (_this2._nativeAudioTracks !== undefined) {
          var newAudioTracks = createAudioTracks(_this2._nativeAudioTracks);
          if (areTrackArraysDifferent(_this2._audioTracks, newAudioTracks)) {
            _this2._audioTracks = newAudioTracks;
            _this2.trigger("availableAudioTracksChange", _this2.getAvailableAudioTracks());
            var chosenAudioTrack = _this2._getPrivateChosenAudioTrack();
            if ((chosenAudioTrack === null || chosenAudioTrack === void 0 ? void 0 : chosenAudioTrack.nativeTrack) !== _this2._lastEmittedNativeAudioTrack) {
              _this2.trigger("audioTrackChange", (_a = chosenAudioTrack === null || chosenAudioTrack === void 0 ? void 0 : chosenAudioTrack.track) !== null && _a !== void 0 ? _a : null);
              _this2._lastEmittedNativeAudioTrack = (_b = chosenAudioTrack === null || chosenAudioTrack === void 0 ? void 0 : chosenAudioTrack.nativeTrack) !== null && _b !== void 0 ? _b : null;
            }
          }
        }
      };
      this._nativeAudioTracks.onchange = function () {
        if (_this2._audioTracks !== undefined) {
          for (var i = 0; i < _this2._audioTracks.length; i++) {
            var _this2$_audioTracks$i = _this2._audioTracks[i],
              track = _this2$_audioTracks$i.track,
              nativeTrack = _this2$_audioTracks$i.nativeTrack;
            if (nativeTrack.enabled) {
              if (nativeTrack !== _this2._lastEmittedNativeAudioTrack) {
                _this2.trigger("audioTrackChange", track);
                _this2._lastEmittedNativeAudioTrack = nativeTrack;
              }
              return;
            }
          }
        }
        if (_this2._lastEmittedNativeAudioTrack !== null) {
          _this2.trigger("audioTrackChange", null);
          _this2._lastEmittedNativeAudioTrack = null;
        }
        return;
      };
    }
    if (this._nativeTextTracks !== undefined) {
      this._nativeTextTracks.onaddtrack = function () {
        var _a, _b;
        if (_this2._nativeTextTracks !== undefined) {
          var newTextTracks = createTextTracks(_this2._nativeTextTracks);
          if (areTrackArraysDifferent(_this2._textTracks, newTextTracks)) {
            _this2._textTracks = newTextTracks;
            _this2._setOptimalTextTrack();
            _this2.trigger("availableTextTracksChange", _this2.getAvailableTextTracks());
            var chosenTextTrack = _this2._getPrivateChosenTextTrack();
            if ((chosenTextTrack === null || chosenTextTrack === void 0 ? void 0 : chosenTextTrack.nativeTrack) !== _this2._lastEmittedNativeTextTrack) {
              _this2.trigger("textTrackChange", (_a = chosenTextTrack === null || chosenTextTrack === void 0 ? void 0 : chosenTextTrack.track) !== null && _a !== void 0 ? _a : null);
              _this2._lastEmittedNativeTextTrack = (_b = chosenTextTrack === null || chosenTextTrack === void 0 ? void 0 : chosenTextTrack.nativeTrack) !== null && _b !== void 0 ? _b : null;
            }
          }
        }
      };
      this._nativeTextTracks.onremovetrack = function () {
        var _a, _b;
        if (_this2._nativeTextTracks !== undefined) {
          var newTextTracks = createTextTracks(_this2._nativeTextTracks);
          if (areTrackArraysDifferent(_this2._textTracks, newTextTracks)) {
            _this2._textTracks = newTextTracks;
            _this2._setOptimalTextTrack();
            _this2.trigger("availableTextTracksChange", _this2.getAvailableTextTracks());
            var chosenTextTrack = _this2._getPrivateChosenTextTrack();
            if ((chosenTextTrack === null || chosenTextTrack === void 0 ? void 0 : chosenTextTrack.nativeTrack) !== _this2._lastEmittedNativeTextTrack) {
              _this2.trigger("textTrackChange", (_a = chosenTextTrack === null || chosenTextTrack === void 0 ? void 0 : chosenTextTrack.track) !== null && _a !== void 0 ? _a : null);
              _this2._lastEmittedNativeTextTrack = (_b = chosenTextTrack === null || chosenTextTrack === void 0 ? void 0 : chosenTextTrack.nativeTrack) !== null && _b !== void 0 ? _b : null;
            }
          }
        }
      };
      this._nativeTextTracks.onchange = function () {
        if (_this2._textTracks !== undefined) {
          for (var i = 0; i < _this2._textTracks.length; i++) {
            var _this2$_textTracks$i = _this2._textTracks[i],
              track = _this2$_textTracks$i.track,
              nativeTrack = _this2$_textTracks$i.nativeTrack;
            if (nativeTrack.mode === "showing") {
              if (nativeTrack !== _this2._lastEmittedNativeTextTrack) {
                _this2.trigger("textTrackChange", track);
                _this2._lastEmittedNativeTextTrack = nativeTrack;
              }
              return;
            }
          }
        }
        if (_this2._lastEmittedNativeTextTrack !== null) {
          _this2.trigger("textTrackChange", null);
          _this2._lastEmittedNativeTextTrack = null;
        }
        return;
      };
    }
    if (this._nativeVideoTracks !== undefined) {
      this._nativeVideoTracks.onaddtrack = function () {
        var _a, _b;
        if (_this2._nativeVideoTracks !== undefined) {
          var newVideoTracks = createVideoTracks(_this2._nativeVideoTracks);
          if (areTrackArraysDifferent(_this2._videoTracks, newVideoTracks)) {
            _this2._videoTracks = newVideoTracks;
            _this2._setOptimalVideoTrack();
            _this2.trigger("availableVideoTracksChange", _this2.getAvailableVideoTracks());
            var chosenVideoTrack = _this2._getPrivateChosenVideoTrack();
            if ((chosenVideoTrack === null || chosenVideoTrack === void 0 ? void 0 : chosenVideoTrack.nativeTrack) !== _this2._lastEmittedNativeVideoTrack) {
              _this2.trigger("videoTrackChange", (_a = chosenVideoTrack === null || chosenVideoTrack === void 0 ? void 0 : chosenVideoTrack.track) !== null && _a !== void 0 ? _a : null);
              _this2._lastEmittedNativeVideoTrack = (_b = chosenVideoTrack === null || chosenVideoTrack === void 0 ? void 0 : chosenVideoTrack.nativeTrack) !== null && _b !== void 0 ? _b : null;
            }
          }
        }
      };
      this._nativeVideoTracks.onremovetrack = function () {
        var _a, _b;
        if (_this2._nativeVideoTracks !== undefined) {
          var newVideoTracks = createVideoTracks(_this2._nativeVideoTracks);
          if (areTrackArraysDifferent(_this2._videoTracks, newVideoTracks)) {
            _this2._videoTracks = newVideoTracks;
            _this2._setOptimalVideoTrack();
            _this2.trigger("availableVideoTracksChange", _this2.getAvailableVideoTracks());
            var chosenVideoTrack = _this2._getPrivateChosenVideoTrack();
            if ((chosenVideoTrack === null || chosenVideoTrack === void 0 ? void 0 : chosenVideoTrack.nativeTrack) !== _this2._lastEmittedNativeVideoTrack) {
              _this2.trigger("videoTrackChange", (_a = chosenVideoTrack === null || chosenVideoTrack === void 0 ? void 0 : chosenVideoTrack.track) !== null && _a !== void 0 ? _a : null);
              _this2._lastEmittedNativeVideoTrack = (_b = chosenVideoTrack === null || chosenVideoTrack === void 0 ? void 0 : chosenVideoTrack.nativeTrack) !== null && _b !== void 0 ? _b : null;
            }
          }
        }
      };
      this._nativeVideoTracks.onchange = function () {
        if (_this2._videoTracks !== undefined) {
          for (var i = 0; i < _this2._videoTracks.length; i++) {
            var _this2$_videoTracks$i = _this2._videoTracks[i],
              track = _this2$_videoTracks$i.track,
              nativeTrack = _this2$_videoTracks$i.nativeTrack;
            if (nativeTrack.selected) {
              if (nativeTrack !== _this2._lastEmittedNativeVideoTrack) {
                _this2.trigger("videoTrackChange", track);
                _this2._lastEmittedNativeVideoTrack = nativeTrack;
              }
              return;
            }
          }
        }
        if (_this2._lastEmittedNativeVideoTrack !== null) {
          _this2.trigger("videoTrackChange", null);
          _this2._lastEmittedNativeVideoTrack = null;
        }
        return;
      };
    }
  }
  /**
   * Enable an audio track (and disable all others), based on its index in the
   * `this._audioTracks` array.
   * @param {number} index}
   */;
  _proto._enableAudioTrackFromIndex = function _enableAudioTrackFromIndex(index) {
    enableAudioTrack(this._audioTracks.map(function (_ref4) {
      var nativeTrack = _ref4.nativeTrack;
      return nativeTrack;
    }), index);
  };
  return MediaElementTrackChoiceManager;
}(event_emitter/* default */.A);
/**
 * Disable all text track elements in the given array from showing.
 * @param {Array.<Object>} textTracks
 */

function disableTextTracks(textTracks) {
  for (var i = 0; i < textTracks.length; i++) {
    var nativeTrack = textTracks[i].nativeTrack;
    nativeTrack.mode = "disabled";
  }
}
/**
 * Disable all text track elements in the given array from showing but one which
 * should stay in the same state it was before.
 * @param {Array.<Object>} textTracks
 * @param {TextTrack} track
 */
function disableAllTextTracksBut(textTracks, track) {
  for (var i = 0; i < textTracks.length; i++) {
    var nativeTrack = textTracks[i].nativeTrack;
    if (nativeTrack !== track && (nativeTrack.mode === "showing" || nativeTrack.mode === "hidden")) {
      nativeTrack.mode = "disabled";
    }
  }
}
/**
 * Disable all video track elements in the given array from showing.
 * Note that browser need to support that use case, which they often do not.
 * @param {Array.<Object>} videoTracks
 */
function disableVideoTracks(videoTracks) {
  for (var i = 0; i < videoTracks.length; i++) {
    var nativeTrack = videoTracks[i].nativeTrack;
    nativeTrack.selected = false;
  }
}

/***/ }),

/***/ 5283:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: function() { return /* binding */ getKeySystemConfiguration; },
/* harmony export */   c: function() { return /* binding */ getCurrentKeySystem; }
/* harmony export */ });
/* harmony import */ var _utils_media_keys_infos_store__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7365);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns the name of the current key system used as well as its configuration,
 * as reported by the `MediaKeySystemAccess` itself.
 * @param {HTMLMediaElement} mediaElement
 * @returns {Array|null}
 */
function getKeySystemConfiguration(mediaElement) {
  var currentState = _utils_media_keys_infos_store__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.getState(mediaElement);
  if (currentState === null) {
    return null;
  }
  return [currentState.mediaKeySystemAccess.keySystem, currentState.mediaKeySystemAccess.getConfiguration()];
}
/**
 * Returns the name of the current key system used, as originally indicated by
 * the user.
 * @deprecated
 * @param {HTMLMediaElement} mediaElement
 * @returns {string|null}
 */
function getCurrentKeySystem(mediaElement) {
  var currentState = _utils_media_keys_infos_store__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.getState(mediaElement);
  return currentState == null ? null : currentState.keySystemOptions.type;
}

/***/ }),

/***/ 6699:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Ay: function() { return /* binding */ decrypt; }
});

// UNUSED EXPORTS: ContentDecryptorState, clearOnStop, disposeDecryptionResources, getCurrentKeySystem, getKeySystemConfiguration

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js
var asyncToGenerator = __webpack_require__(467);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js
var inheritsLoose = __webpack_require__(7387);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/regenerator/index.js
var regenerator = __webpack_require__(4756);
var regenerator_default = /*#__PURE__*/__webpack_require__.n(regenerator);
// EXTERNAL MODULE: ./src/errors/media_error.ts
var media_error = __webpack_require__(5575);
// EXTERNAL MODULE: ./src/utils/assert.ts
var assert = __webpack_require__(7994);
// EXTERNAL MODULE: ./src/utils/is_null_or_undefined.ts
var is_null_or_undefined = __webpack_require__(6787);
// EXTERNAL MODULE: ./src/utils/object_assign.ts
var object_assign = __webpack_require__(8935);
// EXTERNAL MODULE: ./src/compat/browser_detection.ts
var browser_detection = __webpack_require__(443);
// EXTERNAL MODULE: ./src/compat/event_listeners.ts
var event_listeners = __webpack_require__(5121);
// EXTERNAL MODULE: ./src/compat/is_node.ts
var is_node = __webpack_require__(2186);
;// CONCATENATED MODULE: ./src/compat/eme/custom_media_keys/webkit_media_keys_constructor.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var WebKitMediaKeysConstructor;
if (!is_node/* default */.A) {
  /* eslint-disable @typescript-eslint/no-unsafe-assignment */
  /* eslint-disable @typescript-eslint/no-unsafe-member-access */
  var _window = window,
    WebKitMediaKeys = _window.WebKitMediaKeys;
  if (WebKitMediaKeys !== undefined && typeof WebKitMediaKeys.isTypeSupported === "function" && typeof WebKitMediaKeys.prototype.createSession === "function" && typeof HTMLMediaElement.prototype.webkitSetMediaKeys === "function") {
    WebKitMediaKeysConstructor = WebKitMediaKeys;
  }
  /* eslint-enable @typescript-eslint/no-unsafe-assignment */
  /* eslint-enable @typescript-eslint/no-unsafe-member-access */
}

;// CONCATENATED MODULE: ./src/compat/should_favour_custom_safari_EME.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * On Safari 12.1, it seems that since fairplay CDM implementation
 * within the browser is not standard with EME w3c current spec, the
 * requestMediaKeySystemAccess API doesn't resolve positively, even
 * if the drm (fairplay in most cases) is supported.
 * @returns {boolean}
 */
function shouldFavourCustomSafariEME() {
  return (browser_detection/* isSafariDesktop */.Fr || browser_detection/* isSafariMobile */.dX) && WebKitMediaKeysConstructor !== undefined;
}
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/createClass.js + 3 modules
var createClass = __webpack_require__(2212);
;// CONCATENATED MODULE: ./src/compat/eme/custom_key_system_access.ts

/**
 * Simple implementation of the MediaKeySystemAccess EME API.
 *
 * All needed arguments are given to the constructor
 * @class CustomMediaKeySystemAccess
 */
var CustomMediaKeySystemAccess = /*#__PURE__*/function () {
  /**
   * @param {string} _keyType - type of key system (e.g. "widevine" or
   * "com.widevine.alpha").
   * @param {Object} _mediaKeys - MediaKeys implementation
   * @param {Object} _configuration - Configuration accepted for this
   * MediaKeySystemAccess.
   */
  function CustomMediaKeySystemAccess(_keyType, _mediaKeys, _configuration) {
    this._keyType = _keyType;
    this._mediaKeys = _mediaKeys;
    this._configuration = _configuration;
  }
  /**
   * @returns {string} - current key system type (e.g. "widevine" or
   * "com.widevine.alpha").
   */
  var _proto = CustomMediaKeySystemAccess.prototype;
  /**
   * @returns {Promise.<Object>} - Promise wrapping the MediaKeys for this
   * MediaKeySystemAccess. Never rejects.
   */
  _proto.createMediaKeys = function createMediaKeys() {
    var _this = this;
    return new Promise(function (res) {
      return res(_this._mediaKeys);
    });
  }
  /**
   * @returns {Object} - Configuration accepted for this MediaKeySystemAccess.
   */;
  _proto.getConfiguration = function getConfiguration() {
    return this._configuration;
  };
  return (0,createClass/* default */.A)(CustomMediaKeySystemAccess, [{
    key: "keySystem",
    get: function get() {
      return this._keyType;
    }
  }]);
}();

;// CONCATENATED MODULE: ./src/compat/eme/custom_media_keys/ms_media_keys_constructor.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var MSMediaKeysConstructor;
if (!is_node/* default */.A) {
  var ms_media_keys_constructor_window = window,
    MSMediaKeys = ms_media_keys_constructor_window.MSMediaKeys;
  if (MSMediaKeys !== undefined && MSMediaKeys.prototype !== undefined && typeof MSMediaKeys.isTypeSupported === "function" && /* eslint-disable @typescript-eslint/no-unsafe-member-access */
  typeof MSMediaKeys.prototype.createSession === "function"
  /* eslint-enable @typescript-eslint/no-unsafe-member-access */) {
    MSMediaKeysConstructor = MSMediaKeys;
  }
}

// EXTERNAL MODULE: ./src/utils/event_emitter.ts
var event_emitter = __webpack_require__(79);
// EXTERNAL MODULE: ./src/utils/task_canceller.ts
var task_canceller = __webpack_require__(2507);
;// CONCATENATED MODULE: ./src/utils/wrapInPromise.ts
/**
 * Force function output to be wrapped in a Promise instance, which also rejects
 * if the function call threw.
 * @param {Function} val
 * @returns {Promise}
 */
function wrapInPromise(val) {
  try {
    var ret = val();
    if (typeof ret === "object" && ret !== null && typeof ret.then === "function") {
      return ret;
    } else {
      return Promise.resolve(ret);
    }
  } catch (err) {
    return Promise.reject(err);
  }
}
;// CONCATENATED MODULE: ./src/compat/eme/custom_media_keys/ie11_media_keys.ts


/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





var IE11MediaKeySession = /*#__PURE__*/function (_EventEmitter) {
  function IE11MediaKeySession(mk) {
    var _this;
    _this = _EventEmitter.call(this) || this;
    _this.expiration = NaN;
    _this.keyStatuses = new Map();
    _this._mk = mk;
    _this._sessionClosingCanceller = new task_canceller/* default */.Ay();
    _this.closed = new Promise(function (resolve) {
      _this._sessionClosingCanceller.signal.register(function () {
        return resolve();
      });
    });
    _this.update = function (license) {
      return new Promise(function (resolve, reject) {
        if (_this._ss === undefined) {
          return reject("MediaKeySession not set.");
        }
        try {
          resolve(_this._ss.update(license, ""));
        } catch (err) {
          reject(err);
        }
      });
    };
    return _this;
  }
  (0,inheritsLoose/* default */.A)(IE11MediaKeySession, _EventEmitter);
  var _proto = IE11MediaKeySession.prototype;
  _proto.generateRequest = function generateRequest(_initDataType, initData) {
    var _this2 = this;
    return new Promise(function (resolve) {
      var initDataU8 = initData instanceof Uint8Array ? initData : initData instanceof ArrayBuffer ? new Uint8Array(initData) : new Uint8Array(initData.buffer);
      _this2._ss = _this2._mk.createSession("video/mp4", initDataU8);
      event_listeners/* onKeyMessage */.qF(_this2._ss, function (evt) {
        var _a;
        _this2.trigger((_a = evt.type) !== null && _a !== void 0 ? _a : "message", evt);
      }, _this2._sessionClosingCanceller.signal);
      event_listeners/* onKeyAdded */.R5(_this2._ss, function (evt) {
        var _a;
        _this2.trigger((_a = evt.type) !== null && _a !== void 0 ? _a : "keyadded", evt);
      }, _this2._sessionClosingCanceller.signal);
      event_listeners/* onKeyError */.HQ(_this2._ss, function (evt) {
        var _a;
        _this2.trigger((_a = evt.type) !== null && _a !== void 0 ? _a : "keyerror", evt);
      }, _this2._sessionClosingCanceller.signal);
      resolve();
    });
  };
  _proto.close = function close() {
    var _this3 = this;
    return new Promise(function (resolve) {
      if (_this3._ss != null) {
        _this3._ss.close();
        _this3._ss = undefined;
      }
      _this3._sessionClosingCanceller.cancel();
      resolve();
    });
  };
  _proto.load = function load() {
    return Promise.resolve(false);
  };
  _proto.remove = function remove() {
    return Promise.resolve();
  };
  return (0,createClass/* default */.A)(IE11MediaKeySession, [{
    key: "sessionId",
    get: function get() {
      var _a, _b;
      return (_b = (_a = this._ss) === null || _a === void 0 ? void 0 : _a.sessionId) !== null && _b !== void 0 ? _b : "";
    }
  }]);
}(event_emitter/* default */.A);
var IE11CustomMediaKeys = /*#__PURE__*/function () {
  function IE11CustomMediaKeys(keyType) {
    if (MSMediaKeysConstructor === undefined) {
      throw new Error("No MSMediaKeys API.");
    }
    this._mediaKeys = new MSMediaKeysConstructor(keyType);
  }
  var _proto2 = IE11CustomMediaKeys.prototype;
  _proto2._setVideo = function _setVideo(videoElement) {
    var _this4 = this;
    return wrapInPromise(function () {
      _this4._videoElement = videoElement;
      if (_this4._videoElement.msSetMediaKeys !== undefined) {
        _this4._videoElement.msSetMediaKeys(_this4._mediaKeys);
      }
    });
  };
  _proto2.createSession = function createSession( /* sessionType */
  ) {
    if (this._videoElement === undefined || this._mediaKeys === undefined) {
      throw new Error("Video not attached to the MediaKeys");
    }
    return new IE11MediaKeySession(this._mediaKeys);
  };
  _proto2.setServerCertificate = function setServerCertificate() {
    throw new Error("Server certificate is not implemented in your browser");
  };
  return IE11CustomMediaKeys;
}();
function getIE11MediaKeysCallbacks() {
  var isTypeSupported = function isTypeSupported(keySystem, type) {
    if (MSMediaKeysConstructor === undefined) {
      throw new Error("No MSMediaKeys API.");
    }
    if (type !== undefined) {
      return MSMediaKeysConstructor.isTypeSupported(keySystem, type);
    }
    return MSMediaKeysConstructor.isTypeSupported(keySystem);
  };
  var createCustomMediaKeys = function createCustomMediaKeys(keyType) {
    return new IE11CustomMediaKeys(keyType);
  };
  var setMediaKeys = function setMediaKeys(elt, mediaKeys) {
    if (mediaKeys === null) {
      // msSetMediaKeys only accepts native MSMediaKeys as argument.
      // Calling it with null or undefined will raise an exception.
      // There is no way to unset the mediakeys in that case, so return here.
      return Promise.resolve(undefined);
    }
    if (!(mediaKeys instanceof IE11CustomMediaKeys)) {
      throw new Error("Custom setMediaKeys is supposed to be called " + "with IE11 custom MediaKeys.");
    }
    return mediaKeys._setVideo(elt);
  };
  return {
    isTypeSupported: isTypeSupported,
    createCustomMediaKeys: createCustomMediaKeys,
    setMediaKeys: setMediaKeys
  };
}

;// CONCATENATED MODULE: ./src/compat/eme/custom_media_keys/moz_media_keys_constructor.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var MozMediaKeysConstructor;
if (!is_node/* default */.A) {
  var moz_media_keys_constructor_window = window,
    MozMediaKeys = moz_media_keys_constructor_window.MozMediaKeys;
  if (MozMediaKeys !== undefined && MozMediaKeys.prototype !== undefined && typeof MozMediaKeys.isTypeSupported === "function" && /* eslint-disable @typescript-eslint/no-unsafe-member-access */
  typeof MozMediaKeys.prototype.createSession === "function"
  /* eslint-enable @typescript-eslint/no-unsafe-member-access */) {
    MozMediaKeysConstructor = MozMediaKeys;
  }
}

function getMozMediaKeysCallbacks() {
  var isTypeSupported = function isTypeSupported(keySystem, type) {
    if (MozMediaKeysConstructor === undefined) {
      throw new Error("No MozMediaKeys API.");
    }
    if (type !== undefined) {
      return MozMediaKeysConstructor.isTypeSupported(keySystem, type);
    }
    return MozMediaKeysConstructor.isTypeSupported(keySystem);
  };
  var createCustomMediaKeys = function createCustomMediaKeys(keyType) {
    if (MozMediaKeysConstructor === undefined) {
      throw new Error("No MozMediaKeys API.");
    }
    return new MozMediaKeysConstructor(keyType);
  };
  var setMediaKeys = function setMediaKeys(mediaElement, mediaKeys) {
    return wrapInPromise(function () {
      var elt = mediaElement;
      if (elt.mozSetMediaKeys === undefined || typeof elt.mozSetMediaKeys !== "function") {
        throw new Error("Can't set video on MozMediaKeys.");
      }
      return elt.mozSetMediaKeys(mediaKeys);
    });
  };
  return {
    isTypeSupported: isTypeSupported,
    createCustomMediaKeys: createCustomMediaKeys,
    setMediaKeys: setMediaKeys
  };
}
// EXTERNAL MODULE: ./src/utils/base64.ts
var utils_base64 = __webpack_require__(603);
// EXTERNAL MODULE: ./src/utils/noop.ts
var noop = __webpack_require__(8060);
// EXTERNAL MODULE: ./src/utils/string_parsing.ts
var string_parsing = __webpack_require__(4670);
;// CONCATENATED MODULE: ./src/compat/eme/custom_media_keys/old_webkit_media_keys.ts

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * Returns true if the given media element has old webkit methods
 * corresponding to the IOldWebkitHTMLMediaElement interface.
 * @param {HTMLMediaElement} element
 * @returns {Boolean}
 */
function isOldWebkitMediaElement(element) {
  return typeof element.webkitGenerateKeyRequest === "function";
}
/**
 * MediaKeySession implementation for older versions of WebKit relying on APIs
 * such as `webkitGenerateKeyRequest` `webkitAddKey` to be called on the
 * HTMLMediaElement.
 * @class OldWebkitMediaKeySession
 */
var OldWebkitMediaKeySession = /*#__PURE__*/function (_EventEmitter) {
  function OldWebkitMediaKeySession(mediaElement, keySystem) {
    var _this;
    _this = _EventEmitter.call(this) || this;
    _this._vid = mediaElement;
    _this._key = keySystem;
    _this.sessionId = "";
    _this._closeSession = noop/* default */.A; // Just here to make TypeScript happy
    _this.keyStatuses = new Map();
    _this.expiration = NaN;
    var onSessionRelatedEvent = function onSessionRelatedEvent(evt) {
      _this.trigger(evt.type, evt);
    };
    _this.closed = new Promise(function (resolve) {
      _this._closeSession = function () {
        ["keymessage", "message", "keyadded", "ready", "keyerror", "error"].forEach(function (evt) {
          mediaElement.removeEventListener(evt, onSessionRelatedEvent);
          mediaElement.removeEventListener("webkit" + evt, onSessionRelatedEvent);
        });
        resolve();
      };
    });
    ["keymessage", "message", "keyadded", "ready", "keyerror", "error"].forEach(function (evt) {
      mediaElement.addEventListener(evt, onSessionRelatedEvent);
      mediaElement.addEventListener("webkit" + evt, onSessionRelatedEvent);
    });
    return _this;
  }
  (0,inheritsLoose/* default */.A)(OldWebkitMediaKeySession, _EventEmitter);
  var _proto = OldWebkitMediaKeySession.prototype;
  _proto.update = function update(license) {
    var _this2 = this;
    return new Promise(function (resolve, reject) {
      try {
        if (_this2._key.indexOf("clearkey") >= 0) {
          var licenseTypedArray = license instanceof ArrayBuffer ? new Uint8Array(license) : license;
          /* eslint-disable @typescript-eslint/no-unsafe-member-access */
          /* eslint-disable @typescript-eslint/no-unsafe-argument */
          /* eslint-disable @typescript-eslint/no-unsafe-assignment */
          var json = JSON.parse((0,string_parsing/* utf8ToStr */.Es)(licenseTypedArray));
          var key = (0,utils_base64/* base64ToBytes */.K)(json.keys[0].k);
          var kid = (0,utils_base64/* base64ToBytes */.K)(json.keys[0].kid);
          /* eslint-enable @typescript-eslint/no-unsafe-member-access */
          /* eslint-enable @typescript-eslint/no-unsafe-argument */
          /* eslint-enable @typescript-eslint/no-unsafe-assignment */
          resolve(_this2._vid.webkitAddKey(_this2._key, key, kid, /* sessionId */""));
        } else {
          resolve(_this2._vid.webkitAddKey(_this2._key, license, null, /* sessionId */""));
        }
      } catch (err) {
        reject(err);
      }
    });
  };
  _proto.generateRequest = function generateRequest(_initDataType, initData) {
    var _this3 = this;
    return new Promise(function (resolve) {
      _this3._vid.webkitGenerateKeyRequest(_this3._key, initData);
      resolve();
    });
  };
  _proto.close = function close() {
    var _this4 = this;
    return new Promise(function (resolve) {
      _this4._closeSession();
      resolve();
    });
  }
  /**
   * Load a Persistent MediaKeySession.
   * Do nothing here because this implementation doesn't handle them.
   * @returns {Promise.<boolean>}
   */;
  _proto.load = function load() {
    // Not implemented. Always return false as in "no session with that id".
    return Promise.resolve(false);
  };
  _proto.remove = function remove() {
    return Promise.resolve();
  };
  return OldWebkitMediaKeySession;
}(event_emitter/* default */.A);
var OldWebKitCustomMediaKeys = /*#__PURE__*/function () {
  function OldWebKitCustomMediaKeys(keySystem) {
    this._keySystem = keySystem;
  }
  var _proto2 = OldWebKitCustomMediaKeys.prototype;
  _proto2._setVideo = function _setVideo(videoElement) {
    var _this5 = this;
    return wrapInPromise(function () {
      if (!isOldWebkitMediaElement(videoElement)) {
        throw new Error("Video not attached to the MediaKeys");
      }
      _this5._videoElement = videoElement;
    });
  };
  _proto2.createSession = function createSession( /* sessionType */
  ) {
    if (this._videoElement == null) {
      throw new Error("Video not attached to the MediaKeys");
    }
    return new OldWebkitMediaKeySession(this._videoElement, this._keySystem);
  };
  _proto2.setServerCertificate = function setServerCertificate() {
    throw new Error("Server certificate is not implemented in your browser");
  };
  return OldWebKitCustomMediaKeys;
}();
function getOldWebKitMediaKeysCallbacks() {
  var isTypeSupported = function isTypeSupported(keyType) {
    // get any <video> element from the DOM or create one
    // and try the `canPlayType` method
    var videoElement = document.querySelector("video");
    if (videoElement == null) {
      videoElement = document.createElement("video");
    }
    if (videoElement != null && typeof videoElement.canPlayType === "function") {
      return !!videoElement.canPlayType("video/mp4", keyType);
    } else {
      return false;
    }
  };
  var createCustomMediaKeys = function createCustomMediaKeys(keyType) {
    return new OldWebKitCustomMediaKeys(keyType);
  };
  var setMediaKeys = function setMediaKeys(elt, mediaKeys) {
    if (mediaKeys === null) {
      return Promise.resolve(undefined);
    }
    if (!(mediaKeys instanceof OldWebKitCustomMediaKeys)) {
      throw new Error("Custom setMediaKeys is supposed to be called " + "with old webkit custom MediaKeys.");
    }
    return mediaKeys._setVideo(elt);
  };
  return {
    isTypeSupported: isTypeSupported,
    createCustomMediaKeys: createCustomMediaKeys,
    setMediaKeys: setMediaKeys
  };
}
// EXTERNAL MODULE: ./src/utils/starts_with.ts
var starts_with = __webpack_require__(9828);
// EXTERNAL MODULE: ./src/utils/byte_parsing.ts
var byte_parsing = __webpack_require__(5553);
;// CONCATENATED MODULE: ./src/compat/eme/get_webkit_fairplay_initdata.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Create formatted fairplay initdata for WebKit createSession.
 * Layout is :
 * [initData][4 byte: idLength][idLength byte: id]
 * [4 byte:certLength][certLength byte: cert]
 * @param {Uint8Array} initData
 * @param {Uint8Array} serverCertificate
 * @returns {Uint8Array}
 */
function getWebKitFairPlayInitData(initDataBytes, serverCertificateBytes) {
  var initData = initDataBytes instanceof Uint8Array ? initDataBytes : new Uint8Array(initDataBytes);
  var serverCertificate = serverCertificateBytes instanceof Uint8Array ? serverCertificateBytes : new Uint8Array(serverCertificateBytes);
  var length = (0,byte_parsing/* le4toi */.eR)(initData, 0);
  if (length + 4 !== initData.length) {
    throw new Error("Unsupported WebKit initData.");
  }
  var initDataUri = (0,string_parsing/* utf16LEToStr */.Yg)(initData);
  var skdIndexInInitData = initDataUri.indexOf("skd://");
  var contentIdStr = skdIndexInInitData > -1 ? initDataUri.substring(skdIndexInInitData + 6) : initDataUri;
  var id = (0,string_parsing/* strToUtf16LE */.kY)(contentIdStr);
  var offset = 0;
  var res = new Uint8Array(initData.byteLength + /* id length */4 + id.byteLength + /* certificate length */4 + serverCertificate.byteLength);
  res.set(initData);
  offset += initData.length;
  res.set((0,byte_parsing/* itole4 */.Wz)(id.byteLength), offset);
  offset += 4;
  res.set(id, offset);
  offset += id.byteLength;
  res.set((0,byte_parsing/* itole4 */.Wz)(serverCertificate.byteLength), offset);
  offset += 4;
  res.set(serverCertificate, offset);
  return res;
}
;// CONCATENATED MODULE: ./src/compat/eme/custom_media_keys/webkit_media_keys.ts


/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






/**
 * Check if keyType is for fairplay DRM
 * @param {string} keyType
 * @returns {boolean}
 */
function isFairplayKeyType(keyType) {
  return (0,starts_with/* default */.A)(keyType, "com.apple.fps");
}
/**
 * Set media keys on video element using native HTMLMediaElement
 * setMediaKeys from WebKit.
 * @param {HTMLMediaElement} videoElement
 * @param {Object|null} mediaKeys
 * @returns {Promise}
 */
function setWebKitMediaKeys(videoElement, mediaKeys) {
  var elt = videoElement;
  return wrapInPromise(function () {
    if (elt.webkitSetMediaKeys === undefined) {
      throw new Error("No webKitMediaKeys API.");
    }
    elt.webkitSetMediaKeys(mediaKeys);
  });
}
/**
 * On Safari browsers (>= 9), there are specific webkit prefixed APIs for cyphered
 * content playback. Standard EME APIs are therefore available since Safari 12.1, but they
 * don't allow to play fairplay cyphered content.
 *
 * This class implements a standard EME API polyfill that wraps webkit prefixed Safari
 * EME custom APIs.
 */
var WebkitMediaKeySession = /*#__PURE__*/function (_EventEmitter) {
  /**
   * @param {HTMLMediaElement} mediaElement
   * @param {string} keyType
   * @param {Uint8Array | undefined} serverCertificate
   */
  function WebkitMediaKeySession(mediaElement, keyType, serverCertificate) {
    var _this;
    _this = _EventEmitter.call(this) || this;
    _this._serverCertificate = serverCertificate;
    _this._videoElement = mediaElement;
    _this._keyType = keyType;
    _this._unbindSession = noop/* default */.A;
    _this._closeSession = noop/* default */.A; // Just here to make TypeScript happy
    _this.closed = new Promise(function (resolve) {
      _this._closeSession = resolve;
    });
    _this.keyStatuses = new Map();
    _this.expiration = NaN;
    return _this;
  }
  (0,inheritsLoose/* default */.A)(WebkitMediaKeySession, _EventEmitter);
  var _proto = WebkitMediaKeySession.prototype;
  _proto.update = function update(license) {
    var _this2 = this;
    return new Promise(function (resolve, reject) {
      /* eslint-disable @typescript-eslint/no-unsafe-member-access */
      if (_this2._nativeSession === undefined || _this2._nativeSession.update === undefined || typeof _this2._nativeSession.update !== "function") {
        return reject("Unavailable WebKit key session.");
      }
      try {
        var uInt8Arraylicense;
        if (license instanceof ArrayBuffer) {
          uInt8Arraylicense = new Uint8Array(license);
        } else if (license instanceof Uint8Array) {
          uInt8Arraylicense = license;
        } else {
          uInt8Arraylicense = new Uint8Array(license.buffer);
        }
        /* eslint-disable @typescript-eslint/no-unsafe-member-access */
        // eslint-disable-next-line @typescript-eslint/no-unsafe-call
        resolve(_this2._nativeSession.update(uInt8Arraylicense));
        /* eslint-enable @typescript-eslint/no-unsafe-member-access */
      } catch (err) {
        reject(err);
      }
      /* eslint-enable @typescript-eslint/no-unsafe-member-access */
    });
  };
  _proto.generateRequest = function generateRequest(_initDataType, initData) {
    var _this3 = this;
    return new Promise(function (resolve) {
      var _a;
      var elt = _this3._videoElement;
      if (((_a = elt.webkitKeys) === null || _a === void 0 ? void 0 : _a.createSession) === undefined) {
        throw new Error("No WebKitMediaKeys API.");
      }
      var formattedInitData;
      if (isFairplayKeyType(_this3._keyType)) {
        if (_this3._serverCertificate === undefined) {
          throw new Error("A server certificate is needed for creating fairplay session.");
        }
        formattedInitData = getWebKitFairPlayInitData(initData, _this3._serverCertificate);
      } else {
        formattedInitData = initData;
      }
      var keySession = elt.webkitKeys.createSession("video/mp4", formattedInitData);
      if (keySession === undefined || keySession === null) {
        throw new Error("Impossible to get the key sessions");
      }
      _this3._listenEvent(keySession);
      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
      _this3._nativeSession = keySession;
      resolve();
    });
  };
  _proto.close = function close() {
    var _this4 = this;
    return new Promise(function (resolve, reject) {
      _this4._unbindSession();
      _this4._closeSession();
      if (_this4._nativeSession === undefined) {
        reject("No session to close.");
        return;
      }
      /* eslint-disable @typescript-eslint/no-floating-promises */
      _this4._nativeSession.close();
      /* eslint-enable @typescript-eslint/no-floating-promises */
      resolve();
    });
  };
  _proto.load = function load() {
    return Promise.resolve(false);
  };
  _proto.remove = function remove() {
    return Promise.resolve();
  };
  _proto._listenEvent = function _listenEvent(session) {
    var _this5 = this;
    this._unbindSession(); // If previous session was linked
    var onEvent = function onEvent(evt) {
      _this5.trigger(evt.type, evt);
    };
    /* eslint-disable @typescript-eslint/no-unsafe-call */
    /* eslint-disable @typescript-eslint/no-unsafe-member-access */
    /* eslint-disable @typescript-eslint/no-unsafe-return */
    ["keymessage", "message", "keyadded", "ready", "keyerror", "error"].forEach(function (evt) {
      session.addEventListener(evt, onEvent);
      session.addEventListener("webkit" + evt, onEvent);
    });
    this._unbindSession = function () {
      ["keymessage", "message", "keyadded", "ready", "keyerror", "error"].forEach(function (evt) {
        session.removeEventListener(evt, onEvent);
        session.removeEventListener("webkit" + evt, onEvent);
      });
    };
    /* eslint-disable @typescript-eslint/no-unsafe-return */
    /* eslint-disable @typescript-eslint/no-unsafe-member-access */
    /* eslint-enable @typescript-eslint/no-unsafe-call */
  };
  return (0,createClass/* default */.A)(WebkitMediaKeySession, [{
    key: "sessionId",
    get: function get() {
      var _a, _b;
      /* eslint-disable @typescript-eslint/no-unsafe-member-access */
      /* eslint-disable @typescript-eslint/no-unsafe-return */
      return (_b = (_a = this._nativeSession) === null || _a === void 0 ? void 0 : _a.sessionId) !== null && _b !== void 0 ? _b : "";
      /* eslint-enable @typescript-eslint/no-unsafe-member-access */
      /* eslint-enable @typescript-eslint/no-unsafe-return */
    }
  }]);
}(event_emitter/* default */.A);
var WebKitCustomMediaKeys = /*#__PURE__*/function () {
  function WebKitCustomMediaKeys(keyType) {
    if (WebKitMediaKeysConstructor === undefined) {
      throw new Error("No WebKitMediaKeys API.");
    }
    this._keyType = keyType;
    this._mediaKeys = new WebKitMediaKeysConstructor(keyType);
  }
  var _proto2 = WebKitCustomMediaKeys.prototype;
  _proto2._setVideo = function _setVideo(videoElement) {
    this._videoElement = videoElement;
    if (this._videoElement === undefined) {
      throw new Error("Video not attached to the MediaKeys");
    }
    return setWebKitMediaKeys(this._videoElement, this._mediaKeys);
  };
  _proto2.createSession = function createSession( /* sessionType */
  ) {
    if (this._videoElement === undefined || this._mediaKeys === undefined) {
      throw new Error("Video not attached to the MediaKeys");
    }
    return new WebkitMediaKeySession(this._videoElement, this._keyType, this._serverCertificate);
  };
  _proto2.setServerCertificate = function setServerCertificate(serverCertificate) {
    this._serverCertificate = serverCertificate;
    return Promise.resolve();
  };
  return WebKitCustomMediaKeys;
}();
function getWebKitMediaKeysCallbacks() {
  if (WebKitMediaKeysConstructor === undefined) {
    throw new Error("No WebKitMediaKeys API.");
  }
  var isTypeSupported = WebKitMediaKeysConstructor.isTypeSupported;
  var createCustomMediaKeys = function createCustomMediaKeys(keyType) {
    return new WebKitCustomMediaKeys(keyType);
  };
  var setMediaKeys = function setMediaKeys(elt, mediaKeys) {
    if (mediaKeys === null) {
      return setWebKitMediaKeys(elt, mediaKeys);
    }
    if (!(mediaKeys instanceof WebKitCustomMediaKeys)) {
      throw new Error("Custom setMediaKeys is supposed to be called " + "with webkit custom MediaKeys.");
    }
    return mediaKeys._setVideo(elt);
  };
  return {
    isTypeSupported: isTypeSupported,
    createCustomMediaKeys: createCustomMediaKeys,
    setMediaKeys: setMediaKeys
  };
}
;// CONCATENATED MODULE: ./src/compat/eme/eme-api-implementation.ts














/**
 * Automatically detect and set which EME implementation should be used in the
 * current platform.
 *
 * You can call `getEmeApiImplementation` for a different implementation.
 */
var defaultEmeImplementation = getEmeApiImplementation("auto");
/* harmony default export */ var eme_api_implementation = (defaultEmeImplementation);
/**
 * Returns the current EME implementation based on what's present on the device
 * and the given preference.
 * @param {string} preferredApiType - EME API preference
 * (@see IPreferredEmeApiType).
 * @returns {Object}
 */
function getEmeApiImplementation(preferredApiType) {
  var requestMediaKeySystemAccess;
  var onEncrypted;
  var setMediaKeys = defaultSetMediaKeys;
  var implementation;
  if ((preferredApiType === "standard" || preferredApiType === "auto" && !shouldFavourCustomSafariEME()) && (
  // eslint-disable-next-line @typescript-eslint/unbound-method
  is_node/* default */.A || !(0,is_null_or_undefined/* default */.A)(navigator.requestMediaKeySystemAccess))) {
    requestMediaKeySystemAccess = function requestMediaKeySystemAccess() {
      var _navigator;
      return (_navigator = navigator).requestMediaKeySystemAccess.apply(_navigator, arguments);
    };
    onEncrypted = (0,event_listeners/* createCompatibleEventListener */.jf)(["encrypted"]);
    implementation = "standard";
  } else {
    var isTypeSupported;
    var createCustomMediaKeys;
    if (preferredApiType === "webkit" && WebKitMediaKeysConstructor !== undefined) {
      var callbacks = getWebKitMediaKeysCallbacks();
      onEncrypted = createOnEncryptedForWebkit();
      isTypeSupported = callbacks.isTypeSupported;
      createCustomMediaKeys = callbacks.createCustomMediaKeys;
      setMediaKeys = callbacks.setMediaKeys;
      implementation = "webkit";
    } else {
      // This is for Chrome with unprefixed EME api
      if (isOldWebkitMediaElement(HTMLVideoElement.prototype)) {
        onEncrypted = (0,event_listeners/* createCompatibleEventListener */.jf)(["needkey"]);
        var _callbacks = getOldWebKitMediaKeysCallbacks();
        isTypeSupported = _callbacks.isTypeSupported;
        createCustomMediaKeys = _callbacks.createCustomMediaKeys;
        setMediaKeys = _callbacks.setMediaKeys;
        implementation = "older-webkit";
        // This is for WebKit with prefixed EME api
      } else if (WebKitMediaKeysConstructor !== undefined) {
        onEncrypted = createOnEncryptedForWebkit();
        var _callbacks2 = getWebKitMediaKeysCallbacks();
        isTypeSupported = _callbacks2.isTypeSupported;
        createCustomMediaKeys = _callbacks2.createCustomMediaKeys;
        setMediaKeys = _callbacks2.setMediaKeys;
        implementation = "webkit";
      } else if (browser_detection/* isIE11 */.lw && MSMediaKeysConstructor !== undefined) {
        onEncrypted = (0,event_listeners/* createCompatibleEventListener */.jf)(["encrypted", "needkey"]);
        var _callbacks3 = getIE11MediaKeysCallbacks();
        isTypeSupported = _callbacks3.isTypeSupported;
        createCustomMediaKeys = _callbacks3.createCustomMediaKeys;
        setMediaKeys = _callbacks3.setMediaKeys;
        implementation = "ms";
      } else if (MozMediaKeysConstructor !== undefined) {
        onEncrypted = (0,event_listeners/* createCompatibleEventListener */.jf)(["encrypted", "needkey"]);
        var _callbacks4 = getMozMediaKeysCallbacks();
        isTypeSupported = _callbacks4.isTypeSupported;
        createCustomMediaKeys = _callbacks4.createCustomMediaKeys;
        setMediaKeys = _callbacks4.setMediaKeys;
        implementation = "moz";
      } else {
        onEncrypted = (0,event_listeners/* createCompatibleEventListener */.jf)(["encrypted", "needkey"]);
        var MK = window.MediaKeys;
        var checkForStandardMediaKeys = function checkForStandardMediaKeys() {
          if (MK === undefined) {
            throw new media_error/* default */.A("MEDIA_KEYS_NOT_SUPPORTED", "No `MediaKeys` implementation found " + "in the current browser.");
          }
          if (typeof MK.isTypeSupported === "undefined") {
            var message = "This browser seems to be unable to play encrypted " + "contents currently." + "Note: Some browsers do not allow decryption " + "in some situations, like when not using HTTPS.";
            throw new Error(message);
          }
        };
        isTypeSupported = function isTypeSupported(keyType) {
          checkForStandardMediaKeys();
          (0,assert/* default */.h)(typeof MK.isTypeSupported === "function");
          return MK.isTypeSupported(keyType);
        };
        createCustomMediaKeys = function createCustomMediaKeys(keyType) {
          checkForStandardMediaKeys();
          return new MK(keyType);
        };
        implementation = "unknown";
      }
    }
    requestMediaKeySystemAccess = function requestMediaKeySystemAccess(keyType, keySystemConfigurations) {
      if (!isTypeSupported(keyType)) {
        return Promise.reject(new Error("Unsupported key type"));
      }
      for (var i = 0; i < keySystemConfigurations.length; i++) {
        var keySystemConfiguration = keySystemConfigurations[i];
        var videoCapabilities = keySystemConfiguration.videoCapabilities,
          audioCapabilities = keySystemConfiguration.audioCapabilities,
          initDataTypes = keySystemConfiguration.initDataTypes,
          distinctiveIdentifier = keySystemConfiguration.distinctiveIdentifier;
        var supported = true;
        supported = supported && (initDataTypes == null || initDataTypes.some(function (idt) {
          return idt === "cenc";
        }));
        supported = supported && distinctiveIdentifier !== "required";
        if (supported) {
          var keySystemConfigurationResponse = {
            initDataTypes: ["cenc"],
            distinctiveIdentifier: "not-allowed",
            persistentState: "required",
            sessionTypes: ["temporary", "persistent-license"]
          };
          if (videoCapabilities !== undefined) {
            keySystemConfigurationResponse.videoCapabilities = videoCapabilities;
          }
          if (audioCapabilities !== undefined) {
            keySystemConfigurationResponse.audioCapabilities = audioCapabilities;
          }
          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
          var customMediaKeys = createCustomMediaKeys(keyType);
          return Promise.resolve(new CustomMediaKeySystemAccess(keyType, customMediaKeys, keySystemConfigurationResponse));
        }
      }
      return Promise.reject(new Error("Unsupported configuration"));
    };
  }
  return {
    requestMediaKeySystemAccess: requestMediaKeySystemAccess,
    onEncrypted: onEncrypted,
    setMediaKeys: setMediaKeys,
    implementation: implementation
  };
}
/**
 * Create an event listener for the "webkitneedkey" event
 * @returns
 */
function createOnEncryptedForWebkit() {
  var compatibleEventListener = (0,event_listeners/* createCompatibleEventListener */.jf)(["needkey"], undefined /* prefixes */);
  var onEncrypted = function onEncrypted(target, listener, cancelSignal) {
    compatibleEventListener(target, function (event) {
      var patchedEvent = (0,object_assign/* default */.A)(event, {
        forceSessionRecreation: true
      });
      listener(patchedEvent);
    }, cancelSignal);
  };
  return onEncrypted;
}
/**
 * Set the given MediaKeys on the given HTMLMediaElement.
 * Emits null when done then complete.
 * @param {HTMLMediaElement} mediaElement
 * @param {Object} mediaKeys
 * @returns {Promise}
 */
function defaultSetMediaKeys(mediaElement, mediaKeys) {
  try {
    var ret;
    var elt = mediaElement;
    /* eslint-disable @typescript-eslint/unbound-method */
    if (typeof elt.setMediaKeys === "function") {
      ret = elt.setMediaKeys(mediaKeys);
    }
    /* eslint-enable @typescript-eslint/unbound-method */
    // If we get in the following code, it means that no compat case has been
    // found and no standard setMediaKeys API exists. This case is particulary
    // rare. We will try to call each API with native media keys.
    else if (typeof elt.webkitSetMediaKeys === "function") {
      ret = elt.webkitSetMediaKeys(mediaKeys);
    } else if (typeof elt.mozSetMediaKeys === "function") {
      ret = elt.mozSetMediaKeys(mediaKeys);
    } else if (typeof elt.msSetMediaKeys === "function" && mediaKeys !== null) {
      ret = elt.msSetMediaKeys(mediaKeys);
    }
    if (typeof ret === "object" && ret !== null && typeof ret.then === "function") {
      return ret;
    } else {
      return Promise.resolve(ret);
    }
  } catch (err) {
    return Promise.reject(err);
  }
}
;// CONCATENATED MODULE: ./src/compat/eme/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/* harmony default export */ var eme = (eme_api_implementation);

// EXTERNAL MODULE: ./src/log.ts + 1 modules
var log = __webpack_require__(9477);
// EXTERNAL MODULE: ./src/parsers/containers/isobmff/take_pssh_out.ts + 1 modules
var take_pssh_out = __webpack_require__(2948);
// EXTERNAL MODULE: ./src/utils/are_arrays_of_numbers_equal.ts
var are_arrays_of_numbers_equal = __webpack_require__(987);
;// CONCATENATED MODULE: ./src/compat/eme/constants.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


// The way "pssh" will be written in ISOBMFF files
var PSSH_TO_INTEGER = (0,byte_parsing/* be4toi */.mq)((0,string_parsing/* strToUtf8 */.eb)("pssh"), 0);
;// CONCATENATED MODULE: ./src/compat/eme/get_init_data.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






/**
 * Take in input initialization data from an encrypted event and generate the
 * corresponding array of initialization data values from it.
 *
 * At the moment, this function only handles initialization data which have the
 * "cenc" initialization data type.
 * It will just return a single value with an `undefined` `systemId` for all
 * other types of data.
 * @param {Uint8Array} initData - Raw initialization data
 * @returns {Array.<Object>}
 */
function getInitializationDataValues(initData) {
  var result = [];
  var offset = 0;
  while (offset < initData.length) {
    if (initData.length < offset + 8 || (0,byte_parsing/* be4toi */.mq)(initData, offset + 4) !== PSSH_TO_INTEGER) {
      log/* default */.A.warn("Compat: Unrecognized initialization data. Use as is.");
      return [{
        systemId: undefined,
        data: initData
      }];
    }
    var len = (0,byte_parsing/* be4toi */.mq)(new Uint8Array(initData), offset);
    if (offset + len > initData.length) {
      log/* default */.A.warn("Compat: Unrecognized initialization data. Use as is.");
      return [{
        systemId: undefined,
        data: initData
      }];
    }
    var currentPSSH = initData.subarray(offset, offset + len);
    var systemId = (0,take_pssh_out/* getPsshSystemID */.L)(currentPSSH, 8);
    var currentItem = {
      systemId: systemId,
      data: currentPSSH
    };
    if (isPSSHAlreadyEncountered(result, currentItem)) {
      // As we observed on some browsers (IE and Edge), the initialization data on
      // some segments have sometimes duplicated PSSH when sent through an encrypted
      // event (but not when the corresponding segment has been pushed to the
      // SourceBuffer).
      // We prefer filtering them out, to avoid further issues.
      log/* default */.A.warn("Compat: Duplicated PSSH found in initialization data, removing it.");
    } else {
      result.push(currentItem);
    }
    offset += len;
  }
  if (offset !== initData.length) {
    log/* default */.A.warn("Compat: Unrecognized initialization data. Use as is.");
    return [{
      systemId: undefined,
      data: initData
    }];
  }
  return result;
}
/**
 * Returns `true` if the given PSSH has already been stored in the
 * `encounteredPSSHs` cache given.
 * Returns `false` otherwise.
 * @param {Array.<Object>} encounteredPSSHs
 * @param {Uint8Array} pssh
 * @returns {boolean}
 */
function isPSSHAlreadyEncountered(encounteredPSSHs, pssh) {
  for (var i = 0; i < encounteredPSSHs.length; i++) {
    var item = encounteredPSSHs[i];
    if (pssh.systemId === undefined || item.systemId === undefined || pssh.systemId === item.systemId) {
      if ((0,are_arrays_of_numbers_equal/* default */.A)(pssh.data, item.data)) {
        return true;
      }
    }
  }
  return false;
}
/**
 * Take out the two things we need on an encryptedEvent:
 *   - the initialization Data
 *   - the initialization Data type
 *
 * @param {MediaEncryptedEvent} encryptedEvent - Payload received with an
 * "encrypted" event.
 * @returns {Object} - Initialization data and Initialization data type.
 * @throws {EncryptedMediaError} - Throws if no initialization data is
 * encountered in the given event.
 */
function getInitData(encryptedEvent) {
  var initData = encryptedEvent.initData,
    initDataType = encryptedEvent.initDataType,
    forceSessionRecreation = encryptedEvent.forceSessionRecreation;
  if ((0,is_null_or_undefined/* default */.A)(initData)) {
    log/* default */.A.warn("Compat: No init data found on media encrypted event.");
    return null;
  }
  var initDataBytes = new Uint8Array(initData);
  var values = getInitializationDataValues(initDataBytes);
  return {
    type: initDataType,
    values: values,
    forceSessionRecreation: forceSessionRecreation
  };
}
// EXTERNAL MODULE: ./src/config.ts + 2 modules
var config = __webpack_require__(5151);
// EXTERNAL MODULE: ./src/errors/encrypted_media_error.ts
var encrypted_media_error = __webpack_require__(1956);
// EXTERNAL MODULE: ./src/errors/other_error.ts
var other_error = __webpack_require__(1858);
// EXTERNAL MODULE: ./src/utils/array_find.ts
var array_find = __webpack_require__(1729);
// EXTERNAL MODULE: ./src/utils/array_includes.ts
var array_includes = __webpack_require__(4031);
// EXTERNAL MODULE: ./src/core/decrypt/utils/media_keys_infos_store.ts
var media_keys_infos_store = __webpack_require__(7365);
;// CONCATENATED MODULE: ./src/core/decrypt/attach_media_keys.ts


/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Dispose of the MediaKeys instance attached to the given media element, if
 * one.
 * @param {Object} mediaElement
 * @returns {Promise}
 */
function disableMediaKeys(mediaElement) {
  media_keys_infos_store/* default */.A.setState(mediaElement, null);
  return eme.setMediaKeys(mediaElement, null).then(function () {
    log/* default */.A.info("DRM: MediaKeys disabled with success");
  })["catch"](function (err) {
    log/* default */.A.error("DRM: Could not disable MediaKeys", err instanceof Error ? err : "Unknown Error");
  });
}
/**
 * Attach MediaKeys and its associated state to an HTMLMediaElement.
 *
 * /!\ Mutates heavily MediaKeysInfosStore
 * @param {HTMLMediaElement} mediaElement
 * @param {Object} mediaKeysInfos
 * @param {Object} cancelSignal
 * @returns {Promise}
 */
function attachMediaKeys(_x, _x2, _x3) {
  return _attachMediaKeys.apply(this, arguments);
}
function _attachMediaKeys() {
  _attachMediaKeys = (0,asyncToGenerator/* default */.A)( /*#__PURE__*/regenerator_default().mark(function _callee(mediaElement, _ref, cancelSignal) {
    var emeImplementation, keySystemOptions, askedConfiguration, loadedSessionsStore, mediaKeySystemAccess, mediaKeys, previousState, closeAllSessions;
    return regenerator_default().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          emeImplementation = _ref.emeImplementation, keySystemOptions = _ref.keySystemOptions, askedConfiguration = _ref.askedConfiguration, loadedSessionsStore = _ref.loadedSessionsStore, mediaKeySystemAccess = _ref.mediaKeySystemAccess, mediaKeys = _ref.mediaKeys;
          previousState = media_keys_infos_store/* default */.A.getState(mediaElement);
          closeAllSessions = previousState !== null && previousState.loadedSessionsStore !== loadedSessionsStore ? previousState.loadedSessionsStore.closeAllSessions() : Promise.resolve();
          _context.next = 5;
          return closeAllSessions;
        case 5:
          if (!cancelSignal.isCancelled()) {
            _context.next = 7;
            break;
          }
          throw cancelSignal.cancellationError;
        case 7:
          media_keys_infos_store/* default */.A.setState(mediaElement, {
            emeImplementation: emeImplementation,
            keySystemOptions: keySystemOptions,
            mediaKeySystemAccess: mediaKeySystemAccess,
            mediaKeys: mediaKeys,
            loadedSessionsStore: loadedSessionsStore,
            askedConfiguration: askedConfiguration
          });
          if (!(mediaElement.mediaKeys === mediaKeys)) {
            _context.next = 10;
            break;
          }
          return _context.abrupt("return");
        case 10:
          log/* default */.A.info("DRM: Attaching MediaKeys to the media element");
          emeImplementation.setMediaKeys(mediaElement, mediaKeys).then(function () {
            log/* default */.A.info("DRM: MediaKeys attached with success");
          })["catch"](function (err) {
            log/* default */.A.error("DRM: Could not set MediaKeys", err instanceof Error ? err : "Unknown Error");
          });
        case 12:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return _attachMediaKeys.apply(this, arguments);
}
;// CONCATENATED MODULE: ./src/core/decrypt/utils/is_session_usable.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * If all key statuses attached to session are valid (either not
 * "expired" or "internal-error"), return true.
 * If not, return false.
 * @param {MediaKeySession} loadedSession
 * @returns {MediaKeySession}
 */
function isSessionUsable(loadedSession) {
  if (loadedSession.sessionId === "") {
    return false;
  }
  var keyStatusesMap = loadedSession.keyStatuses;
  var keyStatuses = [];
  keyStatusesMap.forEach(function (keyStatus) {
    keyStatuses.push(keyStatus);
  });
  if (keyStatuses.length <= 0) {
    log/* default */.A.debug("DRM: isSessionUsable: MediaKeySession given has an empty keyStatuses", loadedSession.sessionId);
    return false;
  }
  if ((0,array_includes/* default */.A)(keyStatuses, "expired")) {
    log/* default */.A.debug("DRM: isSessionUsable: MediaKeySession given has an expired key", loadedSession.sessionId);
    return false;
  }
  if ((0,array_includes/* default */.A)(keyStatuses, "internal-error")) {
    log/* default */.A.debug("DRM: isSessionUsable: MediaKeySession given has a key with an " + "internal-error", loadedSession.sessionId);
    return false;
  }
  log/* default */.A.debug("DRM: isSessionUsable: MediaKeySession is usable", loadedSession.sessionId);
  return true;
}
;// CONCATENATED MODULE: ./src/core/decrypt/create_session.ts


/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Create a new Session or load a persistent one on the given MediaKeys,
 * according to wanted settings and what is currently stored.
 *
 * If session creating fails, remove the oldest MediaKeySession loaded and
 * retry.
 *
 * /!\ This only creates new sessions.
 * It will fail if loadedSessionsStore already has a MediaKeySession with
 * the given initialization data.
 * @param {Object} stores
 * @param {Object} initData
 * @param {string} wantedSessionType
 * @param {Object} cancelSignal
 * @returns {Promise}
 */
function createSession(stores, initData, wantedSessionType, cancelSignal) {
  var loadedSessionsStore = stores.loadedSessionsStore,
    persistentSessionsStore = stores.persistentSessionsStore;
  if (wantedSessionType === "temporary") {
    return createTemporarySession(loadedSessionsStore, initData);
  } else if (persistentSessionsStore === null) {
    log/* default */.A.warn("DRM: Cannot create persistent MediaKeySession, " + "PersistentSessionsStore not created.");
    return createTemporarySession(loadedSessionsStore, initData);
  }
  return createAndTryToRetrievePersistentSession(loadedSessionsStore, persistentSessionsStore, initData, cancelSignal);
}
/**
 * Create a new temporary MediaKeySession linked to the given initData and
 * initDataType.
 * @param {Object} loadedSessionsStore
 * @param {Object} initData
 * @returns {Promise}
 */
function createTemporarySession(loadedSessionsStore, initData) {
  log/* default */.A.info("DRM: Creating a new temporary session");
  var entry = loadedSessionsStore.createSession(initData, "temporary");
  return Promise.resolve({
    type: "created-session" /* MediaKeySessionLoadingType.Created */,
    value: entry
  });
}
/**
 * Create a persistent MediaKeySession and try to load on it a previous
 * MediaKeySession linked to the same initialization data.
 * @param {Object} loadedSessionsStore
 * @param {Object} persistentSessionsStore
 * @param {Object} initData
 * @param {Object} cancelSignal
 * @returns {Promise}
 */
function createAndTryToRetrievePersistentSession(_x, _x2, _x3, _x4) {
  return _createAndTryToRetrievePersistentSession.apply(this, arguments);
}
function _createAndTryToRetrievePersistentSession() {
  _createAndTryToRetrievePersistentSession = (0,asyncToGenerator/* default */.A)( /*#__PURE__*/regenerator_default().mark(function _callee2(loadedSessionsStore, persistentSessionsStore, initData, cancelSignal) {
    var entry, storedEntry, hasLoadedSession, newEntry, recreatePersistentSession, _recreatePersistentSession;
    return regenerator_default().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          _recreatePersistentSession = function _recreatePersistentSe2() {
            _recreatePersistentSession = (0,asyncToGenerator/* default */.A)( /*#__PURE__*/regenerator_default().mark(function _callee() {
              var persistentEntry, newEntry;
              return regenerator_default().wrap(function _callee$(_context) {
                while (1) switch (_context.prev = _context.next) {
                  case 0:
                    if (!(cancelSignal.cancellationError !== null)) {
                      _context.next = 2;
                      break;
                    }
                    throw cancelSignal.cancellationError;
                  case 2:
                    log/* default */.A.info("DRM: Removing previous persistent session.");
                    persistentEntry = persistentSessionsStore.get(initData);
                    if (persistentEntry !== null) {
                      persistentSessionsStore["delete"](persistentEntry.sessionId);
                    }
                    _context.prev = 5;
                    _context.next = 8;
                    return loadedSessionsStore.closeSession(entry.mediaKeySession);
                  case 8:
                    _context.next = 15;
                    break;
                  case 10:
                    _context.prev = 10;
                    _context.t0 = _context["catch"](5);
                    if (!(entry.mediaKeySession.sessionId !== "")) {
                      _context.next = 14;
                      break;
                    }
                    throw _context.t0;
                  case 14:
                    loadedSessionsStore.removeSessionWithoutClosingIt(entry.mediaKeySession);
                  case 15:
                    if (!(cancelSignal.cancellationError !== null)) {
                      _context.next = 17;
                      break;
                    }
                    throw cancelSignal.cancellationError;
                  case 17:
                    newEntry = loadedSessionsStore.createSession(initData, "persistent-license");
                    return _context.abrupt("return", {
                      type: "created-session" /* MediaKeySessionLoadingType.Created */,
                      value: newEntry
                    });
                  case 19:
                  case "end":
                    return _context.stop();
                }
              }, _callee, null, [[5, 10]]);
            }));
            return _recreatePersistentSession.apply(this, arguments);
          };
          recreatePersistentSession = function _recreatePersistentSe() {
            return _recreatePersistentSession.apply(this, arguments);
          };
          if (!(cancelSignal.cancellationError !== null)) {
            _context2.next = 4;
            break;
          }
          throw cancelSignal.cancellationError;
        case 4:
          log/* default */.A.info("DRM: Creating persistent MediaKeySession");
          entry = loadedSessionsStore.createSession(initData, "persistent-license");
          storedEntry = persistentSessionsStore.getAndReuse(initData);
          if (!(storedEntry === null)) {
            _context2.next = 9;
            break;
          }
          return _context2.abrupt("return", {
            type: "created-session" /* MediaKeySessionLoadingType.Created */,
            value: entry
          });
        case 9:
          _context2.prev = 9;
          _context2.next = 12;
          return loadedSessionsStore.loadPersistentSession(entry.mediaKeySession, storedEntry.sessionId);
        case 12:
          hasLoadedSession = _context2.sent;
          if (hasLoadedSession) {
            _context2.next = 19;
            break;
          }
          log/* default */.A.warn("DRM: No data stored for the loaded session");
          persistentSessionsStore["delete"](storedEntry.sessionId);
          // The EME specification is kind of implicit about it but it seems from my
          // understanding (Paul B.) that a MediaKeySession on wich a `load` attempt
          // did not succeed due to the loaded session not being found by the
          // browser/CDM, should neither be used anymore nor closed.
          // Thus, we're creating another `"persistent-license"` `MediaKeySession`
          // in that specific case.
          loadedSessionsStore.removeSessionWithoutClosingIt(entry.mediaKeySession);
          newEntry = loadedSessionsStore.createSession(initData, "persistent-license");
          return _context2.abrupt("return", {
            type: "created-session" /* MediaKeySessionLoadingType.Created */,
            value: newEntry
          });
        case 19:
          if (!(hasLoadedSession && isSessionUsable(entry.mediaKeySession))) {
            _context2.next = 23;
            break;
          }
          persistentSessionsStore.add(initData, initData.keyIds, entry.mediaKeySession);
          log/* default */.A.info("DRM: Succeeded to load persistent session.");
          return _context2.abrupt("return", {
            type: "loaded-persistent-session" /* MediaKeySessionLoadingType.LoadedPersistentSession */,
            value: entry
          });
        case 23:
          // Unusable persistent session: recreate a new session from scratch.
          log/* default */.A.warn("DRM: Previous persistent session not usable anymore.");
          return _context2.abrupt("return", recreatePersistentSession());
        case 27:
          _context2.prev = 27;
          _context2.t0 = _context2["catch"](9);
          log/* default */.A.warn("DRM: Unable to load persistent session: " + (_context2.t0 instanceof Error ? _context2.t0.toString() : "Unknown Error"));
          return _context2.abrupt("return", recreatePersistentSession());
        case 31:
        case "end":
          return _context2.stop();
      }
    }, _callee2, null, [[9, 27]]);
  }));
  return _createAndTryToRetrievePersistentSession.apply(this, arguments);
}
;// CONCATENATED MODULE: ./src/core/decrypt/utils/clean_old_loaded_sessions.ts


/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Close sessions from the loadedSessionsStore to allow at maximum `limit`
 * stored MediaKeySessions in it.
 *
 * Emit event when a MediaKeySession begin to be closed and another when the
 * MediaKeySession is closed.
 * @param {Object} loadedSessionsStore
 * @returns {Promise}
 */
function cleanOldLoadedSessions(_x, _x2) {
  return _cleanOldLoadedSessions.apply(this, arguments);
}
function _cleanOldLoadedSessions() {
  _cleanOldLoadedSessions = (0,asyncToGenerator/* default */.A)( /*#__PURE__*/regenerator_default().mark(function _callee(loadedSessionsStore, limit) {
    var proms, entries, toDelete, i, entry;
    return regenerator_default().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          if (!(limit < 0 || limit >= loadedSessionsStore.getLength())) {
            _context.next = 2;
            break;
          }
          return _context.abrupt("return");
        case 2:
          log/* default */.A.info("DRM: LSS cache limit exceeded", limit, loadedSessionsStore.getLength());
          proms = [];
          entries = loadedSessionsStore.getAll().slice(); // clone
          toDelete = entries.length - limit;
          for (i = 0; i < toDelete; i++) {
            entry = entries[i];
            proms.push(loadedSessionsStore.closeSession(entry.mediaKeySession));
          }
          _context.next = 9;
          return Promise.all(proms);
        case 9:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return _cleanOldLoadedSessions.apply(this, arguments);
}
;// CONCATENATED MODULE: ./src/core/decrypt/create_or_load_session.ts


/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Handle MediaEncryptedEvents sent by a HTMLMediaElement:
 * Either create a MediaKeySession, recuperate a previous MediaKeySession or
 * load a persistent session.
 *
 * Some previously created MediaKeySession can be closed in this process to
 * respect the maximum limit of concurrent MediaKeySession, as defined by the
 * `EME_MAX_SIMULTANEOUS_MEDIA_KEY_SESSIONS` config property.
 *
 * You can refer to the events emitted to know about the current situation.
 * @param {Object} initializationData
 * @param {Object} stores
 * @param {string} wantedSessionType
 * @param {number} maxSessionCacheSize
 * @param {Object} cancelSignal
 * @returns {Promise}
 */
function createOrLoadSession(_x, _x2, _x3, _x4, _x5) {
  return _createOrLoadSession.apply(this, arguments);
}
function _createOrLoadSession() {
  _createOrLoadSession = (0,asyncToGenerator/* default */.A)( /*#__PURE__*/regenerator_default().mark(function _callee(initializationData, stores, wantedSessionType, maxSessionCacheSize, cancelSignal) {
    var previousLoadedSession, loadedSessionsStore, persistentSessionsStore, entry, evt;
    return regenerator_default().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          /** Store previously-loaded compatible MediaKeySession, if one. */
          previousLoadedSession = null;
          loadedSessionsStore = stores.loadedSessionsStore, persistentSessionsStore = stores.persistentSessionsStore;
          entry = loadedSessionsStore.reuse(initializationData);
          if (!(entry !== null)) {
            _context.next = 11;
            break;
          }
          previousLoadedSession = entry.mediaKeySession;
          if (!isSessionUsable(previousLoadedSession)) {
            _context.next = 10;
            break;
          }
          log/* default */.A.info("DRM: Reuse loaded session", previousLoadedSession.sessionId);
          return _context.abrupt("return", {
            type: "loaded-open-session" /* MediaKeySessionLoadingType.LoadedOpenSession */,
            value: {
              mediaKeySession: previousLoadedSession,
              sessionType: entry.sessionType,
              keySessionRecord: entry.keySessionRecord
            }
          });
        case 10:
          if (persistentSessionsStore !== null) {
            // If the session is not usable anymore, we can also remove it from the
            // PersistentSessionsStore.
            // TODO Are we sure this is always what we want?
            if (entry.mediaKeySession.sessionId !== "") {
              persistentSessionsStore["delete"](entry.mediaKeySession.sessionId);
            }
          }
        case 11:
          if (!(previousLoadedSession !== null)) {
            _context.next = 16;
            break;
          }
          _context.next = 14;
          return loadedSessionsStore.closeSession(previousLoadedSession);
        case 14:
          if (!(cancelSignal.cancellationError !== null)) {
            _context.next = 16;
            break;
          }
          throw cancelSignal.cancellationError;
        case 16:
          _context.next = 18;
          return cleanOldLoadedSessions(loadedSessionsStore,
          // Account for the next session we will be creating
          // Note that `maxSessionCacheSize < 0 has special semantic (no limit)`
          maxSessionCacheSize <= 0 ? maxSessionCacheSize : maxSessionCacheSize - 1);
        case 18:
          if (!(cancelSignal.cancellationError !== null)) {
            _context.next = 20;
            break;
          }
          throw cancelSignal.cancellationError;
        case 20:
          _context.next = 22;
          return createSession(stores, initializationData, wantedSessionType, cancelSignal);
        case 22:
          evt = _context.sent;
          return _context.abrupt("return", {
            type: evt.type,
            value: {
              mediaKeySession: evt.value.mediaKeySession,
              sessionType: evt.value.sessionType,
              keySessionRecord: evt.value.keySessionRecord
            }
          });
        case 24:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return _createOrLoadSession.apply(this, arguments);
}
;// CONCATENATED MODULE: ./src/compat/can_reuse_media_keys.ts

/**
 * Returns `true` if a `MediaKeys` instance (the  `Encrypted Media Extension`
 * concept) can be reused between contents.
 *
 * This should usually be the case but we found rare devices where this would
 * cause problem:
 *   - (2022-11-21): WebOS (LG TVs), for some encrypted contents, just
 *     rebuffered indefinitely when loading a content already-loaded on the
 *     HTMLMediaElement.
 *   - (2024-08-23): Seen on Philips 2024 and 2023 in:
 *     https://github.com/canalplus/rx-player/issues/1464
 *   - (2024-09-04): Another case seen on an "A1" set-top box model made by
 *     Kaonmedia we will call the KSTB40xx.
 *     It may share the problematic with other devices, but we have only seen
 *     the problem on this one for now.
 *
 * @returns {boolean}
 */
function canReuseMediaKeys() {
  return !browser_detection/* isWebOs */.hF && !browser_detection/* isPhilipsNetTv */.NV && !browser_detection/* isPanasonic */.P5 && !browser_detection/* isA1KStb40xx */.x1;
}
;// CONCATENATED MODULE: ./src/compat/should_renew_media_key_system_access.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns true if the current target require the MediaKeySystemAccess to be
 * renewed on each content.
 * @returns {Boolean}
 */
function shouldRenewMediaKeySystemAccess() {
  return browser_detection/* isIE11 */.lw;
}
;// CONCATENATED MODULE: ./src/compat/can_rely_on_request_media_key_system_access.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * This functions tells if the RxPlayer can trust the browser when it has
 * successfully granted the MediaKeySystemAccess with
 * `navigator.requestMediaKeySystemAccess(keySystem)` function, or if it should do
 * some additional testing to confirm that the `keySystem` is supported on the device.
 *
 * This behavior has been experienced on the following device:
 *
 * On a Microsoft Surface with Edge v.124:
 * - Althought `requestMediaKeySystemAccess` resolve correctly with the keySystem
 *   "com.microsoft.playready.recommendation.3000", generating a request with
 *   `generateRequest` throws an error: "NotSupportedError: Failed to execute
 *   'generateRequest' on 'MediaKeySession': Failed to create MF PR CdmSession".
 *   In this particular case, the work-around was to consider
 *   recommendation.3000 as not supported and try another keySystem.
 * @param keySystem - The key system in use.
 * @returns {boolean}
 */
function canRelyOnRequestMediaKeySystemAccess(keySystem) {
  if (browser_detection/* isEdgeChromium */.op && keySystem.indexOf("playready") !== -1) {
    return false;
  }
  return true;
}
;// CONCATENATED MODULE: ./src/compat/generate_init_data.ts


/**
 * The PlayReadyHeader sample that will be used to test if the CDM is supported.
 * The KID does not matter because no content will be played, it's only to check if
 * the CDM is capable of creating a session and generating a request.
 */
var DUMMY_PLAY_READY_HEADER = /* eslint-disable-next-line max-len */
'<WRMHEADER xmlns="http://schemas.microsoft.com/DRM/2007/03/PlayReadyHeader" version="4.0.0.0"><DATA><PROTECTINFO><KEYLEN>16</KEYLEN><ALGID>AESCTR</ALGID></PROTECTINFO><KID>ckB07BNLskeUq0qd83fTbA==</KID><DS_ID>yYIPDBca1kmMfL60IsfgAQ==</DS_ID><CUSTOMATTRIBUTES xmlns=""><encryptionref>312_4024_2018127108</encryptionref></CUSTOMATTRIBUTES><CHECKSUM>U/tsUYRgMzw=</CHECKSUM></DATA></WRMHEADER>';
/**
 * Generate the "cenc" init data for playready from the PlayreadyHeader string.
 * @param {string} playreadyHeader - String representing the PlayreadyHeader XML.
 * @returns {Uint8Array} The init data generated for that PlayreadyHeader.
 * @see https://learn.microsoft.com/en-us/playready/specifications/playready-hea
 * der-specification
 */
function generatePlayReadyInitData(playreadyHeader) {
  var recordValueEncoded = (0,string_parsing/* strToUtf16LE */.kY)(playreadyHeader);
  var recordLength = (0,byte_parsing/* itole2 */.WO)(recordValueEncoded.length);
  // RecordType: 0x0001	Indicates that the record contains a PlayReady Header (PRH).
  var recordType = new Uint8Array([1, 0]);
  var numberOfObjects = new Uint8Array([1, 0]); // 1 PlayReady object
  /* playReadyObjectLength equals = X bytes for record + 2 bytes for record length,
  + 2 bytes for record types + 2 bytes for number of object  */
  var playReadyObjectLength = (0,byte_parsing/* itole4 */.Wz)(recordValueEncoded.length + 6);
  var playReadyObject = (0,byte_parsing/* concat */.xW)(playReadyObjectLength,
  // 4 bytes for the Playready object length
  numberOfObjects,
  // 2 bytes for the number of PlayReady objects
  recordType,
  // 2 bytes for record type
  recordLength,
  // 2 bytes for record length
  recordValueEncoded);
  /**  the systemId is define at https://dashif.org/identifiers/content_protection/ */
  var playreadySystemId = (0,string_parsing/* hexToBytes */.aT)("9a04f07998404286ab92e65be0885f95");
  return generateInitData(playReadyObject, playreadySystemId);
}
/**
 * Generate the "cenc" initData given the data and the systemId to use.
 * Note this will generate an initData for version 0 of pssh.
 * @param data - The data that is contained inside the pssh.
 * @param systemId - The systemId to use.
 * @returns
 */
function generateInitData(data, systemId) {
  var psshBoxName = (0,string_parsing/* strToUtf8 */.eb)("pssh");
  var versionAndFlags = new Uint8Array([0, 0, 0, 0]); // pssh version 0
  var sizeOfData = (0,byte_parsing/* itobe4 */.KS)(data.length);
  var psshSize = (0,byte_parsing/* itobe4 */.KS)(4 /* pssh size */ + 4 /* pssh box */ + 4 /* version and flags */ + 16 /* systemId */ + 4 /* size of data */ + data.length /* data */);
  return (0,byte_parsing/* concat */.xW)(psshSize,
  // 4 bytes for the pssh size
  psshBoxName,
  // 4 bytes for the pssh box
  versionAndFlags,
  // 4 bytes for version and flags
  systemId,
  // 16 bytes for the systemId
  sizeOfData,
  // 4 bytes for the data size
  data);
}
// EXTERNAL MODULE: ./src/utils/flat_map.ts
var flat_map = __webpack_require__(3262);
;// CONCATENATED MODULE: ./src/core/decrypt/find_key_system.ts


/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */











/**
 * @param {Array.<Object>} keySystems
 * @param {Object} askedConfiguration
 * @param {MediaKeySystemAccess} currentKeySystemAccess
 * @param {Object} currentKeySystemOptions
 * @returns {null|Object}
 */
function checkCachedMediaKeySystemAccess(keySystems, askedConfiguration, currentKeySystemAccess, currentKeySystemOptions) {
  var mksConfiguration = currentKeySystemAccess.getConfiguration();
  if (shouldRenewMediaKeySystemAccess() || mksConfiguration == null) {
    return null;
  }
  var firstCompatibleOption = keySystems.filter(function (ks) {
    // TODO Do it with MediaKeySystemAccess.prototype.keySystem instead
    if (ks.type !== currentKeySystemOptions.type) {
      return false;
    }
    if ((ks.persistentLicense === true || ks.persistentStateRequired === true) && mksConfiguration.persistentState !== "required") {
      return false;
    }
    if (ks.distinctiveIdentifierRequired === true && mksConfiguration.distinctiveIdentifier !== "required") {
      return false;
    }
    return true;
  })[0];
  if (firstCompatibleOption != null) {
    return {
      keySystemOptions: firstCompatibleOption,
      keySystemAccess: currentKeySystemAccess,
      askedConfiguration: askedConfiguration
    };
  }
  return null;
}
/**
 * Find key system canonical name from key system type.
 * @param {string} ksType - Obtained via inversion
 * @returns {string|undefined} - Either the canonical name, or undefined.
 */
function findKeySystemCanonicalName(ksType) {
  var _config$getCurrent = config/* default */.A.getCurrent(),
    EME_KEY_SYSTEMS = _config$getCurrent.EME_KEY_SYSTEMS;
  for (var _i = 0, _Object$keys = Object.keys(EME_KEY_SYSTEMS); _i < _Object$keys.length; _i++) {
    var ksName = _Object$keys[_i];
    if ((0,array_includes/* default */.A)(EME_KEY_SYSTEMS[ksName], ksType)) {
      return ksName;
    }
  }
  return undefined;
}
/**
 * Build configuration for the requestMediaKeySystemAccess EME API, based
 * on the current keySystem object.
 * @param {string|undefined} ksName - Generic name for the key system. e.g.
 * "clearkey", "widevine", "playready". Can be used to make exceptions depending
 * on it.
 * @param {string|undefined} ksType - KeySystem complete type (e.g.
 * "com.widevine.alpha").
 * @param {Object} keySystem
 * @returns {Array.<Object>} - Configuration to give to the
 * requestMediaKeySystemAccess API.
 */
function buildKeySystemConfigurations(ksName, ksType, keySystem) {
  var sessionTypes = ["temporary"];
  var persistentState = "optional";
  var distinctiveIdentifier = "optional";
  if (keySystem.persistentLicense === true) {
    persistentState = "required";
    sessionTypes.push("persistent-license");
  }
  if (keySystem.persistentStateRequired === true) {
    persistentState = "required";
  }
  if (keySystem.distinctiveIdentifierRequired === true) {
    distinctiveIdentifier = "required";
  }
  var _config$getCurrent2 = config/* default */.A.getCurrent(),
    EME_DEFAULT_AUDIO_CODECS = _config$getCurrent2.EME_DEFAULT_AUDIO_CODECS,
    EME_DEFAULT_VIDEO_CODECS = _config$getCurrent2.EME_DEFAULT_VIDEO_CODECS,
    EME_DEFAULT_WIDEVINE_ROBUSTNESSES = _config$getCurrent2.EME_DEFAULT_WIDEVINE_ROBUSTNESSES,
    EME_DEFAULT_PLAYREADY_ROBUSTNESSES = _config$getCurrent2.EME_DEFAULT_PLAYREADY_ROBUSTNESSES;
  // Set robustness, in order of consideration:
  //   1. the user specified its own robustnesses
  //   2. a "widevine" key system is used, in that case set the default widevine
  //      robustnesses as defined in the config
  //   3. set an undefined robustness
  var videoRobustnesses;
  if (!(0,is_null_or_undefined/* default */.A)(keySystem.videoRobustnesses)) {
    videoRobustnesses = keySystem.videoRobustnesses;
  } else if (ksName === "widevine") {
    videoRobustnesses = EME_DEFAULT_WIDEVINE_ROBUSTNESSES;
  } else if (ksType === "com.microsoft.playready.recommendation") {
    videoRobustnesses = EME_DEFAULT_PLAYREADY_ROBUSTNESSES;
  } else {
    videoRobustnesses = [];
  }
  var audioRobustnesses;
  if (!(0,is_null_or_undefined/* default */.A)(keySystem.audioRobustnesses)) {
    audioRobustnesses = keySystem.audioRobustnesses;
  } else if (ksName === "widevine") {
    audioRobustnesses = EME_DEFAULT_WIDEVINE_ROBUSTNESSES;
  } else if (ksType === "com.microsoft.playready.recommendation") {
    audioRobustnesses = EME_DEFAULT_PLAYREADY_ROBUSTNESSES;
  } else {
    audioRobustnesses = [];
  }
  if (videoRobustnesses.length === 0) {
    videoRobustnesses.push(undefined);
  }
  if (audioRobustnesses.length === 0) {
    audioRobustnesses.push(undefined);
  }
  // From the W3 EME spec, we have to provide videoCapabilities and
  // audioCapabilities.
  // These capabilities must specify a codec (even though you can use a
  // completely different codec afterward).
  // It is also strongly recommended to specify the required security
  // robustness. As we do not want to forbide any security level, we specify
  // every existing security level from highest to lowest so that the best
  // security level is selected.
  // More details here:
  // https://storage.googleapis.com/wvdocs/Chrome_EME_Changes_and_Best_Practices.pdf
  // https://www.w3.org/TR/encrypted-media/#get-supported-configuration-and-consent
  var videoCapabilities = (0,flat_map/* default */.A)(videoRobustnesses, function (robustness) {
    return EME_DEFAULT_VIDEO_CODECS.map(function (contentType) {
      return robustness === undefined ? {
        contentType: contentType
      } : {
        contentType: contentType,
        robustness: robustness
      };
    });
  });
  var audioCapabilities = (0,flat_map/* default */.A)(audioRobustnesses, function (robustness) {
    return EME_DEFAULT_AUDIO_CODECS.map(function (contentType) {
      return robustness === undefined ? {
        contentType: contentType
      } : {
        contentType: contentType,
        robustness: robustness
      };
    });
  });
  var wantedMediaKeySystemConfiguration = {
    initDataTypes: ["cenc"],
    videoCapabilities: videoCapabilities,
    audioCapabilities: audioCapabilities,
    distinctiveIdentifier: distinctiveIdentifier,
    persistentState: persistentState,
    sessionTypes: sessionTypes
  };
  if (!(0,is_null_or_undefined/* default */.A)(keySystem.audioRobustnesses) || !(0,is_null_or_undefined/* default */.A)(keySystem.videoRobustnesses)) {
    // If the user specifically asked for robustnesses, we don't want to try without them
    return [wantedMediaKeySystemConfiguration];
  }
  return [wantedMediaKeySystemConfiguration,
  // Some legacy implementations have issues with `audioCapabilities` and
  // `videoCapabilities`, so we're including a supplementary
  // `MediaKeySystemConfiguration` without those properties.
  Object.assign(Object.assign({}, wantedMediaKeySystemConfiguration), {
    audioCapabilities: undefined,
    videoCapabilities: undefined
  })];
}
/**
 * Try to find a compatible key system from the keySystems array given.
 *
 * This function will request a MediaKeySystemAccess based on the various
 * keySystems provided.
 *
 * This Promise might either:
 *   - resolves the MediaKeySystemAccess and the keySystems as an object, when
 *     found.
 *   - reject if no compatible key system has been found.
 *
 * @param {HTMLMediaElement} mediaElement
 * @param {Array.<Object>} keySystemsConfigs - The keySystems you want to test.
 * @param {Object} cancelSignal
 * @returns {Promise.<Object>}
 */
function getMediaKeySystemAccess(mediaElement, keySystemsConfigs, cancelSignal) {
  log/* default */.A.info("DRM: Searching for compatible MediaKeySystemAccess");
  var currentState = media_keys_infos_store/* default */.A.getState(mediaElement);
  if (currentState !== null) {
    if (eme.implementation === currentState.emeImplementation.implementation) {
      // Fast way to find a compatible keySystem if the currently loaded
      // one as exactly the same compatibility options.
      var cachedKeySystemAccess = checkCachedMediaKeySystemAccess(keySystemsConfigs, currentState.askedConfiguration, currentState.mediaKeySystemAccess, currentState.keySystemOptions);
      if (cachedKeySystemAccess !== null) {
        log/* default */.A.info("DRM: Found cached compatible keySystem");
        return Promise.resolve({
          type: "reuse-media-key-system-access",
          value: {
            mediaKeySystemAccess: cachedKeySystemAccess.keySystemAccess,
            askedConfiguration: cachedKeySystemAccess.askedConfiguration,
            options: cachedKeySystemAccess.keySystemOptions
          }
        });
      }
    }
  }
  /**
   * Array of set keySystems for this content.
   * Each item of this array is an object containing the following keys:
   *   - keyName {string}: keySystem canonical name (e.g. "widevine")
   *   - keyType {string}: keySystem type (e.g. "com.widevine.alpha")
   *   - keySystem {Object}: the original keySystem object
   * @type {Array.<Object>}
   */
  var keySystemsType = keySystemsConfigs.reduce(function (arr, keySystemOptions) {
    var _config$getCurrent3 = config/* default */.A.getCurrent(),
      EME_KEY_SYSTEMS = _config$getCurrent3.EME_KEY_SYSTEMS;
    var managedRDNs = EME_KEY_SYSTEMS[keySystemOptions.type];
    var ksType;
    if (managedRDNs != null) {
      ksType = managedRDNs.map(function (keyType) {
        var keyName = keySystemOptions.type;
        return {
          keyName: keyName,
          keyType: keyType,
          keySystemOptions: keySystemOptions
        };
      });
    } else {
      var keyName = findKeySystemCanonicalName(keySystemOptions.type);
      var keyType = keySystemOptions.type;
      ksType = [{
        keyName: keyName,
        keyType: keyType,
        keySystemOptions: keySystemOptions
      }];
    }
    return arr.concat(ksType);
  }, []);
  return recursivelyTestKeySystems(0);
  /**
   * Test all key system configuration stored in `keySystemsType` one by one
   * recursively.
   * Returns a Promise which will emit the MediaKeySystemAccess if one was
   * found compatible with one of the configurations or just reject if none
   * were found to be compatible.
   * @param {Number} index - The index in `keySystemsType` to start from.
   * Should be set to `0` when calling directly.
   * @returns {Promise.<Object>}
   */
  function recursivelyTestKeySystems(_x) {
    return _recursivelyTestKeySystems.apply(this, arguments);
  }
  function _recursivelyTestKeySystems() {
    _recursivelyTestKeySystems = (0,asyncToGenerator/* default */.A)( /*#__PURE__*/regenerator_default().mark(function _callee(index) {
      var _keySystemsType$index, keyName, keyType, keySystemOptions, keySystemConfigurations, keySystemAccess, configIdx, keySystemConfiguration;
      return regenerator_default().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            if (!(index >= keySystemsType.length)) {
              _context.next = 2;
              break;
            }
            throw new encrypted_media_error/* default */.A("INCOMPATIBLE_KEYSYSTEMS", "No key system compatible with your wanted " + "configuration has been found in the current " + "browser.");
          case 2:
            if (!(eme.requestMediaKeySystemAccess == null)) {
              _context.next = 4;
              break;
            }
            throw new Error("requestMediaKeySystemAccess is not implemented in your browser.");
          case 4:
            _keySystemsType$index = keySystemsType[index], keyName = _keySystemsType$index.keyName, keyType = _keySystemsType$index.keyType, keySystemOptions = _keySystemsType$index.keySystemOptions;
            keySystemConfigurations = buildKeySystemConfigurations(keyName, keyType, keySystemOptions);
            log/* default */.A.debug("DRM: Request keysystem access " + keyType + "," + (index + 1 + " of " + keySystemsType.length));
            configIdx = 0;
          case 8:
            if (!(configIdx < keySystemConfigurations.length)) {
              _context.next = 26;
              break;
            }
            keySystemConfiguration = keySystemConfigurations[configIdx];
            _context.prev = 10;
            _context.next = 13;
            return testKeySystem(keyType, [keySystemConfiguration]);
          case 13:
            keySystemAccess = _context.sent;
            log/* default */.A.info("DRM: Found compatible keysystem", keyType, index + 1);
            return _context.abrupt("return", {
              type: "create-media-key-system-access",
              value: {
                options: keySystemOptions,
                askedConfiguration: keySystemConfiguration,
                mediaKeySystemAccess: keySystemAccess
              }
            });
          case 18:
            _context.prev = 18;
            _context.t0 = _context["catch"](10);
            log/* default */.A.debug("DRM: Rejected access to keysystem", keyType, index + 1, configIdx);
            if (!(cancelSignal.cancellationError !== null)) {
              _context.next = 23;
              break;
            }
            throw cancelSignal.cancellationError;
          case 23:
            configIdx++;
            _context.next = 8;
            break;
          case 26:
            return _context.abrupt("return", recursivelyTestKeySystems(index + 1));
          case 27:
          case "end":
            return _context.stop();
        }
      }, _callee, null, [[10, 18]]);
    }));
    return _recursivelyTestKeySystems.apply(this, arguments);
  }
}
/**
 * Test a key system configuration, resolves with the MediaKeySystemAccess
 * or reject if the key system is unsupported.
 * @param {string} keyType - The KeySystem string to test
 * (ex: com.microsoft.playready.recommendation)
 * @param {Array.<MediaKeySystemMediaCapability>} keySystemConfigurations -
 * Configurations for this keySystem
 * @returns Promise resolving with the MediaKeySystemAccess. Rejects if unsupported.
 */
function testKeySystem(_x2, _x3) {
  return _testKeySystem.apply(this, arguments);
}
function _testKeySystem() {
  _testKeySystem = (0,asyncToGenerator/* default */.A)( /*#__PURE__*/regenerator_default().mark(function _callee2(keyType, keySystemConfigurations) {
    var keySystemAccess, mediaKeys, session, initData;
    return regenerator_default().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          _context2.next = 2;
          return eme.requestMediaKeySystemAccess(keyType, keySystemConfigurations);
        case 2:
          keySystemAccess = _context2.sent;
          if (canRelyOnRequestMediaKeySystemAccess(keyType)) {
            _context2.next = 18;
            break;
          }
          _context2.prev = 4;
          _context2.next = 7;
          return keySystemAccess.createMediaKeys();
        case 7:
          mediaKeys = _context2.sent;
          session = mediaKeys.createSession();
          initData = generatePlayReadyInitData(DUMMY_PLAY_READY_HEADER);
          _context2.next = 12;
          return session.generateRequest("cenc", initData);
        case 12:
          _context2.next = 18;
          break;
        case 14:
          _context2.prev = 14;
          _context2.t0 = _context2["catch"](4);
          log/* default */.A.debug("DRM: KeySystemAccess was granted but it is not usable");
          throw _context2.t0;
        case 18:
          return _context2.abrupt("return", keySystemAccess);
        case 19:
        case "end":
          return _context2.stop();
      }
    }, _callee2, null, [[4, 14]]);
  }));
  return _testKeySystem.apply(this, arguments);
}
// EXTERNAL MODULE: ./src/parsers/containers/isobmff/get_box.ts
var get_box = __webpack_require__(8797);
;// CONCATENATED MODULE: ./src/compat/eme/generate_key_request.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Modify "initialization data" sent to a `generateKeyRequest` EME call to
 * improve the player's browser compatibility:
 *
 *   1. some browsers/CDM have problems when the CENC PSSH box is the first
 *      encountered PSSH box in the initialization data (for the moment just
 *      Edge was noted with this behavior).
 *      We found however that it works on every browser when the CENC pssh
 *      box(es) is/are the last box(es) encountered.
 *
 *      To that end, we move CENC pssh boxes at the end of the initialization
 *      data in this function.
 *
 *   2. Some poorly encoded/packaged contents communicate both a CENC with a
 *      pssh version of 0 and one with a version of 1. We found out that this is
 *      not always well handled on some devices/browsers (on Edge and some other
 *      embedded devices that shall remain nameless for now!).
 *
 *      Here this function will filter out CENC pssh with a version different to
 *      1 when one(s) with a version of 1 is/are already present.
 *
 * If the initData is unrecognized or if a CENC PSSH is not found, this function
 * throws.
 * @param {Uint8Array} initData - Initialization data you want to patch
 * @returns {Uint8Array} - Initialization data, patched
 */
function patchInitData(initData) {
  log/* default */.A.info("Compat: Trying to move CENC PSSH from init data at the end of it.");
  var foundCencV1 = false;
  var concatenatedCencs = new Uint8Array();
  var resInitData = new Uint8Array();
  var offset = 0;
  while (offset < initData.length) {
    if (initData.length < offset + 8 || (0,byte_parsing/* be4toi */.mq)(initData, offset + 4) !== PSSH_TO_INTEGER) {
      log/* default */.A.warn("Compat: unrecognized initialization data. Cannot patch it.");
      throw new Error("Compat: unrecognized initialization data. Cannot patch it.");
    }
    var len = (0,byte_parsing/* be4toi */.mq)(new Uint8Array(initData), offset);
    if (offset + len > initData.length) {
      log/* default */.A.warn("Compat: unrecognized initialization data. Cannot patch it.");
      throw new Error("Compat: unrecognized initialization data. Cannot patch it.");
    }
    var currentPSSH = initData.subarray(offset, offset + len);
    // yep
    if (initData[offset + 12] === 0x10 && initData[offset + 13] === 0x77 && initData[offset + 14] === 0xef && initData[offset + 15] === 0xec && initData[offset + 16] === 0xc0 && initData[offset + 17] === 0xb2 && initData[offset + 18] === 0x4d && initData[offset + 19] === 0x02 && initData[offset + 20] === 0xac && initData[offset + 21] === 0xe3 && initData[offset + 22] === 0x3c && initData[offset + 23] === 0x1e && initData[offset + 24] === 0x52 && initData[offset + 25] === 0xe2 && initData[offset + 26] === 0xfb && initData[offset + 27] === 0x4b) {
      var cencOffsets = (0,get_box/* getNextBoxOffsets */.fP)(currentPSSH);
      var version = cencOffsets === null ? undefined : currentPSSH[cencOffsets[1]];
      log/* default */.A.info("Compat: CENC PSSH found with version", version);
      if (version === undefined) {
        log/* default */.A.warn("Compat: could not read version of CENC PSSH");
      } else if (foundCencV1 === (version === 1)) {
        // Either `concatenatedCencs` only contains v1 or does not contain any
        concatenatedCencs = (0,byte_parsing/* concat */.xW)(concatenatedCencs, currentPSSH);
      } else if (version === 1) {
        log/* default */.A.warn("Compat: cenc version 1 encountered, " + "removing every other cenc pssh box.");
        concatenatedCencs = currentPSSH;
        foundCencV1 = true;
      } else {
        log/* default */.A.warn("Compat: filtering out cenc pssh box with wrong version", version);
      }
    } else {
      resInitData = (0,byte_parsing/* concat */.xW)(resInitData, currentPSSH);
    }
    offset += len;
  }
  if (offset !== initData.length) {
    log/* default */.A.warn("Compat: unrecognized initialization data. Cannot patch it.");
    throw new Error("Compat: unrecognized initialization data. Cannot patch it.");
  }
  return (0,byte_parsing/* concat */.xW)(resInitData, concatenatedCencs);
}
/**
 * Generate a request from session.
 * @param {MediaKeySession}session - MediaKeySession on which the request will
 * be done.
 * @param {string} initializationDataType - Initialization data type given e.g.
 * by the "encrypted" event for the corresponding request.
 * @param {Uint8Array}initializationData - Initialization data given e.g. by
 * the "encrypted" event for the corresponding request.
 * @returns {Promise} - Emit when done. Errors if fails.
 */
function generateKeyRequest(session, initializationDataType, initializationData) {
  log/* default */.A.debug("Compat: Calling generateRequest on the MediaKeySession");
  var patchedInit;
  try {
    patchedInit = patchInitData(initializationData);
  } catch (_e) {
    patchedInit = initializationData;
  }
  var initDataType = initializationDataType !== null && initializationDataType !== void 0 ? initializationDataType : "";
  return session.generateRequest(initDataType, patchedInit)["catch"](function (error) {
    if (initDataType !== "" || !(error instanceof TypeError)) {
      throw error;
    }
    // On newer EME versions of the specification, the initialization data
    // type given to generateRequest cannot be an empty string (it returns
    // a rejected promise with a TypeError in that case).
    // Retry with a default "cenc" value for initialization data type if
    // we're in that condition.
    log/* default */.A.warn("Compat: error while calling `generateRequest` with an empty " + 'initialization data type. Retrying with a default "cenc" value.', error);
    return session.generateRequest("cenc", patchedInit);
  });
}
;// CONCATENATED MODULE: ./src/compat/eme/load_session.ts


/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var EME_WAITING_DELAY_LOADED_SESSION_EMPTY_KEYSTATUSES = 100;
/**
 * Load a persistent session, based on its `sessionId`, on the given
 * MediaKeySession.
 *
 * Returns a Promise which resolves with:
 *   - `true` if the persistent MediaKeySession was found and loaded
 *   - `false` if no persistent MediaKeySession was found with that `sessionId`.
 *
 * The Promise rejects if anything goes wrong in the process.
 * @param {MediaKeySession} session
 * @param {string} sessionId
 * @returns {Promise.<boolean>}
 */
function loadSession(_x, _x2) {
  return _loadSession.apply(this, arguments);
}
function _loadSession() {
  _loadSession = (0,asyncToGenerator/* default */.A)( /*#__PURE__*/regenerator_default().mark(function _callee(session, sessionId) {
    var isLoaded;
    return regenerator_default().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          log/* default */.A.info("DRM: Load persisted session", sessionId);
          _context.next = 3;
          return session.load(sessionId);
        case 3:
          isLoaded = _context.sent;
          if (!(!isLoaded || session.keyStatuses.size > 0)) {
            _context.next = 6;
            break;
          }
          return _context.abrupt("return", isLoaded);
        case 6:
          return _context.abrupt("return", new Promise(function (resolve) {
            session.addEventListener("keystatuseschange", resolveWithLoadedStatus);
            var timeout = setTimeout(resolveWithLoadedStatus, EME_WAITING_DELAY_LOADED_SESSION_EMPTY_KEYSTATUSES);
            function resolveWithLoadedStatus() {
              cleanUp();
              resolve(isLoaded);
            }
            function cleanUp() {
              clearTimeout(timeout);
              session.removeEventListener("keystatuseschange", resolveWithLoadedStatus);
            }
          }));
        case 7:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return _loadSession.apply(this, arguments);
}
// EXTERNAL MODULE: ./src/utils/cancellable_sleep.ts
var cancellable_sleep = __webpack_require__(2432);
;// CONCATENATED MODULE: ./src/compat/eme/close_session.ts


/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Close the given `MediaKeySession` and returns a Promise resolving when the
 * session is closed.
 * This promise does not reject, even if we're unable to close the
 * `MediaKeySession`.
 *
 * Note that there is a lot of browser issues linked to the impossibility to
 * either close a MediaKeySession or to know if a MediaKeySession was closed.
 * Due to this, the returned Promise might take some time before resolving on
 * some devices.
 * @param {MediaKeySession|Object} session
 * @returns {Promise.<undefined>}
 */
function closeSession(session) {
  var timeoutCanceller = new task_canceller/* default */.Ay();
  return Promise.race([session.close().then(function () {
    timeoutCanceller.cancel();
  }),
  // The `closed` promise may resolve, even if `close()` result has not
  // (seen at some point on Firefox).
  session.closed.then(function () {
    timeoutCanceller.cancel();
  }), waitTimeoutAndCheck()]);
  /**
   * If the session is not closed after 1000ms, try to communicate with the
   * MediaKeySession and check if an error is returned.
   * This is needed because on some browsers with poor EME implementation,
   * knowing when a MediaKeySession is closed is actually a hard task.
   *
   * The returned Promise will never reject.
   * @returns {Promise.<undefined>}
   */
  function waitTimeoutAndCheck() {
    return _waitTimeoutAndCheck.apply(this, arguments);
  }
  /**
   * Try to update `MediaKeySession` and check its error if it failed.
   * If we still don't know whether it closed yet, wait a second
   * timeout then quit.
   *
   * The returned Promise resolves if the `MediaKeySession` seems closed and
   * rejects if we couldn't know or it doesn't.
   * @returns {Promise.<undefined>}
   */
  function _waitTimeoutAndCheck() {
    _waitTimeoutAndCheck = (0,asyncToGenerator/* default */.A)( /*#__PURE__*/regenerator_default().mark(function _callee() {
      var message;
      return regenerator_default().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            _context.prev = 0;
            _context.next = 3;
            return (0,cancellable_sleep/* default */.A)(1000, timeoutCanceller.signal);
          case 3:
            _context.next = 5;
            return tryUpdatingSession();
          case 5:
            _context.next = 13;
            break;
          case 7:
            _context.prev = 7;
            _context.t0 = _context["catch"](0);
            if (!(_context.t0 instanceof task_canceller/* CancellationError */.AL)) {
              _context.next = 11;
              break;
            }
            return _context.abrupt("return");
          case 11:
            message = _context.t0 instanceof Error ? _context.t0.message : "Unknown error made it impossible to close the session";
            log/* default */.A.error("DRM: " + message);
          case 13:
          case "end":
            return _context.stop();
        }
      }, _callee, null, [[0, 7]]);
    }));
    return _waitTimeoutAndCheck.apply(this, arguments);
  }
  function tryUpdatingSession() {
    return _tryUpdatingSession.apply(this, arguments);
  }
  function _tryUpdatingSession() {
    _tryUpdatingSession = (0,asyncToGenerator/* default */.A)( /*#__PURE__*/regenerator_default().mark(function _callee2() {
      return regenerator_default().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            _context2.prev = 0;
            _context2.next = 3;
            return session.update(new Uint8Array(1));
          case 3:
            _context2.next = 13;
            break;
          case 5:
            _context2.prev = 5;
            _context2.t0 = _context2["catch"](0);
            if (!timeoutCanceller.isUsed()) {
              _context2.next = 9;
              break;
            }
            return _context2.abrupt("return");
          case 9:
            if (!(_context2.t0 instanceof Error && _context2.t0.message === "The session is already closed.")) {
              _context2.next = 11;
              break;
            }
            return _context2.abrupt("return");
          case 11:
            _context2.next = 13;
            return (0,cancellable_sleep/* default */.A)(1000, timeoutCanceller.signal);
          case 13:
            if (!timeoutCanceller.isUsed()) {
              _context2.next = 15;
              break;
            }
            return _context2.abrupt("return");
          case 15:
            throw new Error("Compat: Couldn't know if session is closed");
          case 16:
          case "end":
            return _context2.stop();
        }
      }, _callee2, null, [[0, 5]]);
    }));
    return _tryUpdatingSession.apply(this, arguments);
  }
}
;// CONCATENATED MODULE: ./src/core/decrypt/utils/key_id_comparison.ts
function _createForOfIteratorHelperLoose(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (t) return (t = t.call(r)).next.bind(t); if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var o = 0; return function () { return o >= r.length ? { done: !0 } : { done: !1, value: r[o++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns `true` if all key ids in `wantedKeyIds` are present in the
 * `keyIdsArr` array.
 * @param {Array.<Uint8Array>} wantedKeyIds
 * @param {Array.<Uint8Array>} keyIdsArr
 * @returns {boolean}
 */
function areAllKeyIdsContainedIn(wantedKeyIds, keyIdsArr) {
  var _loop = function _loop() {
      var keyId = _step.value;
      var found = keyIdsArr.some(function (k) {
        return (0,are_arrays_of_numbers_equal/* default */.A)(k, keyId);
      });
      if (!found) {
        return {
          v: false
        };
      }
    },
    _ret;
  for (var _iterator = _createForOfIteratorHelperLoose(wantedKeyIds), _step; !(_step = _iterator()).done;) {
    _ret = _loop();
    if (_ret) return _ret.v;
  }
  return true;
}
/**
 * Returns `true` if at least one key id in `wantedKeyIds` is present in the
 * `keyIdsArr` array.
 * @param {Array.<Uint8Array>} wantedKeyIds
 * @param {Array.<Uint8Array>} keyIdsArr
 * @returns {boolean}
 */
function areSomeKeyIdsContainedIn(wantedKeyIds, keyIdsArr) {
  var _loop2 = function _loop2() {
      var keyId = _step2.value;
      var found = keyIdsArr.some(function (k) {
        return (0,are_arrays_of_numbers_equal/* default */.A)(k, keyId);
      });
      if (found) {
        return {
          v: true
        };
      }
    },
    _ret2;
  for (var _iterator2 = _createForOfIteratorHelperLoose(wantedKeyIds), _step2; !(_step2 = _iterator2()).done;) {
    _ret2 = _loop2();
    if (_ret2) return _ret2.v;
  }
  return false;
}
;// CONCATENATED MODULE: ./src/core/decrypt/utils/key_session_record.ts
function key_session_record_createForOfIteratorHelperLoose(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (t) return (t = t.call(r)).next.bind(t); if (Array.isArray(r) || (t = key_session_record_unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var o = 0; return function () { return o >= r.length ? { done: !0 } : { done: !1, value: r[o++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function key_session_record_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return key_session_record_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? key_session_record_arrayLikeToArray(r, a) : void 0; } }
function key_session_record_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Class storing key-related information linked to a created `MediaKeySession`.
 *
 * This class allows to regroup one or multiple key ids and can be linked to a
 * single MediaKeySession so you can know which key that MediaKeySession
 * handles.
 *
 * The main use case behind the complexities of this `KeySessionRecord` is to
 * better handle the `singleLicensePer` RxPlayer option, which allows the
 * recuperation of a license containing multiple keys, even if only one of
 * those keys was asked for (which in turn allows to reduce the number of
 * requests and to improve performance).
 * Here, the `KeySessionRecord` will regroup all those key's id and can be
 * linked to the corresponding MediaKeySession.
 * That way, you can later check if another encrypted content is compatible with
 * that session through the `KeySessionRecord`'s `isCompatibleWith` method.
 *
 * @example
 * ```js
 * const record = new KeySessionRecord(initData);
 *
 * // Create a MediaKeySession linked to that initialization data and fetch the
 * // license
 * // ...
 *
 * // Once the license has been loaded to the MediaKeySession linked to that
 - // initialization data, associate the license's key Ids with the latter.
 * record.associateKeyIds(someKeyIds);
 *
 * // Function called when new initialization data is encountered
 * function onNewInitializationData(newInitializationData) {
 *   if (record.isCompatibleWith(newInitializationData)) {
 *     console.log("This initialization data should already be handled, ignored.");
 *   } else {
 *     console.log("This initialization data is not handled yet.";
 *   }
 * }
 * ```
 * @class KeySessionRecord
 */
var KeySessionRecord = /*#__PURE__*/function () {
  /**
   * Create a new `KeySessionRecord`, linked to its corresponding initialization
   * data,
   * @param {Object} initializationData
   */
  function KeySessionRecord(initializationData) {
    this._initializationData = initializationData;
    this._keyIds = null;
  }
  /**
   * Associate supplementary key ids to this `KeySessionRecord` so it becomes
   * "compatible" to them.
   *
   * After this call, new initialization data linked to subsets of those key
   * ids will be considered compatible  to this `KeySessionRecord` (calls to
   * `isCompatibleWith` with the corresponding initialization data will return
   * `true`).
   * @param {Array.<Uint8Array>} keyIds
   */
  var _proto = KeySessionRecord.prototype;
  _proto.associateKeyIds = function associateKeyIds(keyIds) {
    if (this._keyIds === null) {
      this._keyIds = [];
    }
    var keyIdsArr = Array.from(keyIds);
    for (var _i = 0, _keyIdsArr = keyIdsArr; _i < _keyIdsArr.length; _i++) {
      var keyId = _keyIdsArr[_i];
      if (!this.isAssociatedWithKeyId(keyId)) {
        this._keyIds.push(keyId);
      }
    }
  }
  /**
   * @param {Uint8Array} keyId
   * @returns {boolean}
   */;
  _proto.isAssociatedWithKeyId = function isAssociatedWithKeyId(keyId) {
    if (this._keyIds === null) {
      return false;
    }
    for (var _iterator = key_session_record_createForOfIteratorHelperLoose(this._keyIds), _step; !(_step = _iterator()).done;) {
      var storedKeyId = _step.value;
      if ((0,are_arrays_of_numbers_equal/* default */.A)(storedKeyId, keyId)) {
        return true;
      }
    }
    return false;
  }
  /**
   * @returns {Array.<Uint8Array>}
   */;
  _proto.getAssociatedKeyIds = function getAssociatedKeyIds() {
    if (this._keyIds === null) {
      return [];
    }
    return this._keyIds;
  }
  /**
   * Check if that `KeySessionRecord` is compatible to the initialization data
   * given.
   *
   * If it returns `true`, it means that this `KeySessionRecord` is already
   * linked to that initialization data's key. As such, if that
   * `KeySessionRecord` is already associated to an active MediaKeySession for
   * example, the content linked to that initialization data should already be
   * handled.
   *
   * If it returns `false`, it means that this `KeySessionRecord` has no
   * relation with the given initialization data.
   *
   * @param {Object} initializationData
   * @returns {boolean}
   */;
  _proto.isCompatibleWith = function isCompatibleWith(initializationData) {
    var keyIds = initializationData.keyIds;
    if (keyIds !== undefined && keyIds.length > 0) {
      if (this._keyIds !== null && areAllKeyIdsContainedIn(keyIds, this._keyIds)) {
        return true;
      }
      if (this._initializationData.keyIds !== undefined) {
        return areAllKeyIdsContainedIn(keyIds, this._initializationData.keyIds);
      }
    }
    return this._checkInitializationDataCompatibility(initializationData);
  };
  _proto._checkInitializationDataCompatibility = function _checkInitializationDataCompatibility(initializationData) {
    if (initializationData.keyIds !== undefined && initializationData.keyIds.length > 0 && this._initializationData.keyIds !== undefined) {
      return areAllKeyIdsContainedIn(initializationData.keyIds, this._initializationData.keyIds);
    }
    if (this._initializationData.type !== initializationData.type) {
      return false;
    }
    return this._initializationData.values.isCompatibleWith(initializationData.values);
  };
  return KeySessionRecord;
}();

;// CONCATENATED MODULE: ./src/core/decrypt/utils/loaded_sessions_store.ts


function loaded_sessions_store_createForOfIteratorHelperLoose(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (t) return (t = t.call(r)).next.bind(t); if (Array.isArray(r) || (t = loaded_sessions_store_unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var o = 0; return function () { return o >= r.length ? { done: !0 } : { done: !1, value: r[o++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function loaded_sessions_store_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return loaded_sessions_store_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? loaded_sessions_store_arrayLikeToArray(r, a) : void 0; } }
function loaded_sessions_store_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * Create and store MediaKeySessions linked to a single MediaKeys
 * instance.
 *
 * Keep track of sessionTypes and of the initialization data each
 * MediaKeySession is created for.
 * @class LoadedSessionsStore
 */
var LoadedSessionsStore = /*#__PURE__*/function () {
  /**
   * Create a new LoadedSessionsStore, which will store information about
   * loaded MediaKeySessions on the given MediaKeys instance.
   * @param {MediaKeys} mediaKeys
   */
  function LoadedSessionsStore(mediaKeys) {
    this._mediaKeys = mediaKeys;
    this._storage = [];
  }
  /**
   * Create a new MediaKeySession and store it in this store.
   * @param {Object} initData
   * @param {string} sessionType
   * @returns {Object}
   */
  var _proto = LoadedSessionsStore.prototype;
  _proto.createSession = function createSession(initData, sessionType) {
    var _this = this;
    var keySessionRecord = new KeySessionRecord(initData);
    log/* default */.A.debug("DRM-LSS: calling `createSession`", sessionType);
    var mediaKeySession = this._mediaKeys.createSession(sessionType);
    var entry = {
      mediaKeySession: mediaKeySession,
      sessionType: sessionType,
      keySessionRecord: keySessionRecord,
      isGeneratingRequest: false,
      isLoadingPersistentSession: false,
      closingStatus: {
        type: "none"
      }
    };
    if (!(0,is_null_or_undefined/* default */.A)(mediaKeySession.closed)) {
      mediaKeySession.closed.then(function () {
        log/* default */.A.info("DRM-LSS: session was closed, removing it.", mediaKeySession.sessionId);
        var index = _this.getIndex(keySessionRecord);
        if (index >= 0 && _this._storage[index].mediaKeySession === mediaKeySession) {
          _this._storage.splice(index, 1);
        }
      })["catch"](function (e) {
        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
        log/* default */.A.warn("DRM-LSS: MediaKeySession.closed rejected: " + e);
      });
    }
    this._storage.push(Object.assign({}, entry));
    log/* default */.A.debug("DRM-LSS: MediaKeySession added", entry.sessionType, this._storage.length);
    return entry;
  }
  /**
   * Find a stored entry compatible with the initialization data given and moves
   * this entry at the end of the `LoadedSessionsStore`''s storage, returned by
   * its `getAll` method.
   *
   * This can be used for example to tell when a previously-stored
   * entry is re-used to then be able to implement a caching replacement
   * algorithm based on the least-recently-used values by just evicting the first
   * values returned by `getAll`.
   * @param {Object} initializationData
   * @returns {Object|null}
   */;
  _proto.reuse = function reuse(initializationData) {
    for (var i = this._storage.length - 1; i >= 0; i--) {
      var stored = this._storage[i];
      if (stored.keySessionRecord.isCompatibleWith(initializationData)) {
        this._storage.splice(i, 1);
        this._storage.push(stored);
        log/* default */.A.debug("DRM-LSS: Reusing session:", stored.mediaKeySession.sessionId, stored.sessionType);
        return Object.assign({}, stored);
      }
    }
    return null;
  }
  /**
   * Get `LoadedSessionsStore`'s entry for a given MediaKeySession.
   * Returns `null` if the given MediaKeySession is not stored in the
   * `LoadedSessionsStore`.
   * @param {MediaKeySession} mediaKeySession
   * @returns {Object|null}
   */;
  _proto.getEntryForSession = function getEntryForSession(mediaKeySession) {
    for (var i = this._storage.length - 1; i >= 0; i--) {
      var stored = this._storage[i];
      if (stored.mediaKeySession === mediaKeySession) {
        return Object.assign({}, stored);
      }
    }
    return null;
  }
  /**
   * Generate a license request on the given MediaKeySession, while indicating
   * to the LoadedSessionsStore that a license-request is pending so
   * session-closing orders are properly scheduled after it is done.
   * @param {Object} mediaKeySession
   * @param {string} initializationDataType - Initialization data type given
   * e.g. by the "encrypted" event for the corresponding request.
   * @param {Uint8Array}initializationData - Initialization data given e.g. by
   * the "encrypted" event for the corresponding request.
   * @returns {Promise}
   */;
  _proto.generateLicenseRequest =
  /*#__PURE__*/
  function () {
    var _generateLicenseRequest = (0,asyncToGenerator/* default */.A)( /*#__PURE__*/regenerator_default().mark(function _callee(mediaKeySession, initializationDataType, initializationData) {
      var entry, _iterator, _step, stored;
      return regenerator_default().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            _iterator = loaded_sessions_store_createForOfIteratorHelperLoose(this._storage);
          case 1:
            if ((_step = _iterator()).done) {
              _context.next = 8;
              break;
            }
            stored = _step.value;
            if (!(stored.mediaKeySession === mediaKeySession)) {
              _context.next = 6;
              break;
            }
            entry = stored;
            return _context.abrupt("break", 8);
          case 6:
            _context.next = 1;
            break;
          case 8:
            if (!(entry === undefined)) {
              _context.next = 11;
              break;
            }
            log/* default */.A.error("DRM-LSS: generateRequest error. No MediaKeySession found with " + "the given initData and initDataType");
            return _context.abrupt("return", generateKeyRequest(mediaKeySession, initializationDataType, initializationData));
          case 11:
            entry.isGeneratingRequest = true;
            // Note the `as string` is needed due to TypeScript not understanding that
            // the `closingStatus` might change in the next checks
            if (!(entry.closingStatus.type !== "none")) {
              _context.next = 14;
              break;
            }
            throw new Error("The `MediaKeySession` is being closed.");
          case 14:
            _context.prev = 14;
            _context.next = 17;
            return generateKeyRequest(mediaKeySession, initializationDataType, initializationData);
          case 17:
            _context.next = 26;
            break;
          case 19:
            _context.prev = 19;
            _context.t0 = _context["catch"](14);
            if (!(entry === undefined)) {
              _context.next = 23;
              break;
            }
            throw _context.t0;
          case 23:
            entry.isGeneratingRequest = false;
            if (entry.closingStatus.type === "awaiting") {
              entry.closingStatus.start();
            }
            throw _context.t0;
          case 26:
            if (!(entry === undefined)) {
              _context.next = 28;
              break;
            }
            return _context.abrupt("return", undefined);
          case 28:
            entry.isGeneratingRequest = false;
            if (entry.closingStatus.type === "awaiting") {
              entry.closingStatus.start();
            }
          case 30:
          case "end":
            return _context.stop();
        }
      }, _callee, this, [[14, 19]]);
    }));
    function generateLicenseRequest(_x, _x2, _x3) {
      return _generateLicenseRequest.apply(this, arguments);
    }
    return generateLicenseRequest;
  }()
  /**
   * @param {Object} mediaKeySession
   * @param {string} sessionId
   * @returns {Promise}
   */
  ;
  _proto.loadPersistentSession =
  /*#__PURE__*/
  function () {
    var _loadPersistentSession = (0,asyncToGenerator/* default */.A)( /*#__PURE__*/regenerator_default().mark(function _callee2(mediaKeySession, sessionId) {
      var entry, _iterator2, _step2, stored, ret;
      return regenerator_default().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            _iterator2 = loaded_sessions_store_createForOfIteratorHelperLoose(this._storage);
          case 1:
            if ((_step2 = _iterator2()).done) {
              _context2.next = 8;
              break;
            }
            stored = _step2.value;
            if (!(stored.mediaKeySession === mediaKeySession)) {
              _context2.next = 6;
              break;
            }
            entry = stored;
            return _context2.abrupt("break", 8);
          case 6:
            _context2.next = 1;
            break;
          case 8:
            if (!(entry === undefined)) {
              _context2.next = 11;
              break;
            }
            log/* default */.A.error("DRM-LSS: loadPersistentSession error. No MediaKeySession found with " + "the given initData and initDataType");
            return _context2.abrupt("return", loadSession(mediaKeySession, sessionId));
          case 11:
            entry.isLoadingPersistentSession = true;
            // Note the `as string` is needed due to TypeScript not understanding that
            // the `closingStatus` might change in the next checks
            if (!(entry.closingStatus.type !== "none")) {
              _context2.next = 14;
              break;
            }
            throw new Error("The `MediaKeySession` is being closed.");
          case 14:
            _context2.prev = 14;
            _context2.next = 17;
            return loadSession(mediaKeySession, sessionId);
          case 17:
            ret = _context2.sent;
            _context2.next = 27;
            break;
          case 20:
            _context2.prev = 20;
            _context2.t0 = _context2["catch"](14);
            if (!(entry === undefined)) {
              _context2.next = 24;
              break;
            }
            throw _context2.t0;
          case 24:
            entry.isLoadingPersistentSession = false;
            if (entry.closingStatus.type === "awaiting") {
              entry.closingStatus.start();
            }
            throw _context2.t0;
          case 27:
            if (!(entry === undefined)) {
              _context2.next = 29;
              break;
            }
            return _context2.abrupt("return", ret);
          case 29:
            entry.isLoadingPersistentSession = false;
            if (entry.closingStatus.type === "awaiting") {
              entry.closingStatus.start();
            }
            return _context2.abrupt("return", ret);
          case 32:
          case "end":
            return _context2.stop();
        }
      }, _callee2, this, [[14, 20]]);
    }));
    function loadPersistentSession(_x4, _x5) {
      return _loadPersistentSession.apply(this, arguments);
    }
    return loadPersistentSession;
  }()
  /**
   * Close a MediaKeySession and remove its related stored information from the
   * `LoadedSessionsStore`.
   * Emit when done.
   * @param {Object} mediaKeySession
   * @returns {Promise}
   */
  ;
  _proto.closeSession =
  /*#__PURE__*/
  function () {
    var _closeSession = (0,asyncToGenerator/* default */.A)( /*#__PURE__*/regenerator_default().mark(function _callee3(mediaKeySession) {
      var entry, _iterator3, _step3, stored;
      return regenerator_default().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            _iterator3 = loaded_sessions_store_createForOfIteratorHelperLoose(this._storage);
          case 1:
            if ((_step3 = _iterator3()).done) {
              _context3.next = 8;
              break;
            }
            stored = _step3.value;
            if (!(stored.mediaKeySession === mediaKeySession)) {
              _context3.next = 6;
              break;
            }
            entry = stored;
            return _context3.abrupt("break", 8);
          case 6:
            _context3.next = 1;
            break;
          case 8:
            if (!(entry === undefined)) {
              _context3.next = 11;
              break;
            }
            log/* default */.A.warn("DRM-LSS: No MediaKeySession found with " + "the given initData and initDataType");
            return _context3.abrupt("return", Promise.resolve(false));
          case 11:
            return _context3.abrupt("return", this._closeEntry(entry));
          case 12:
          case "end":
            return _context3.stop();
        }
      }, _callee3, this);
    }));
    function closeSession(_x6) {
      return _closeSession.apply(this, arguments);
    }
    return closeSession;
  }()
  /**
   * Returns the number of stored MediaKeySessions in this LoadedSessionsStore.
   * @returns {number}
   */
  ;
  _proto.getLength = function getLength() {
    return this._storage.length;
  }
  /**
   * Returns information about all stored MediaKeySession, in the order in which
   * the MediaKeySession have been created.
   * @returns {Array.<Object>}
   */;
  _proto.getAll = function getAll() {
    return this._storage;
  }
  /**
   * Close all sessions in this store.
   * Emit `null` when done.
   * @returns {Promise}
   */;
  _proto.closeAllSessions =
  /*#__PURE__*/
  function () {
    var _closeAllSessions = (0,asyncToGenerator/* default */.A)( /*#__PURE__*/regenerator_default().mark(function _callee4() {
      var _this2 = this;
      var allEntries, closingProms;
      return regenerator_default().wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            allEntries = this._storage;
            log/* default */.A.debug("DRM-LSS: Closing all current MediaKeySessions", allEntries.length);
            // re-initialize the storage, so that new interactions with the
            // `LoadedSessionsStore` do not rely on MediaKeySessions we're in the
            // process of removing
            this._storage = [];
            closingProms = allEntries.map(function (entry) {
              return _this2._closeEntry(entry);
            });
            _context4.next = 6;
            return Promise.all(closingProms);
          case 6:
          case "end":
            return _context4.stop();
        }
      }, _callee4, this);
    }));
    function closeAllSessions() {
      return _closeAllSessions.apply(this, arguments);
    }
    return closeAllSessions;
  }()
  /**
   * Find the given `MediaKeySession` in the `LoadedSessionsStore` and removes
   * any reference to it without actually closing it.
   *
   * Returns `true` if the given `mediaKeySession` has been found and removed,
   * `false` otherwise.
   *
   * Note that this may create a `MediaKeySession` leakage in the wrong
   * conditions, cases where this method should be called should be very
   * carefully evaluated.
   * @param {MediaKeySession} mediaKeySession
   * @returns {boolean}
   */
  ;
  _proto.removeSessionWithoutClosingIt = function removeSessionWithoutClosingIt(mediaKeySession) {
    (0,assert/* default */.h)(mediaKeySession.sessionId === "", "Initialized `MediaKeySession`s should always be properly closed");
    for (var i = this._storage.length - 1; i >= 0; i--) {
      var stored = this._storage[i];
      if (stored.mediaKeySession === mediaKeySession) {
        log/* default */.A.debug("DRM-LSS: Removing session without closing it", mediaKeySession.sessionId);
        this._storage.splice(i, 1);
        return true;
      }
    }
    return false;
  }
  /**
   * Get the index of a stored MediaKeySession entry based on its
   * `KeySessionRecord`.
   * Returns -1 if not found.
   * @param {Object} record
   * @returns {number}
   */;
  _proto.getIndex = function getIndex(record) {
    for (var i = 0; i < this._storage.length; i++) {
      var stored = this._storage[i];
      if (stored.keySessionRecord === record) {
        return i;
      }
    }
    return -1;
  }
  /**
   * Prepare the closure of a `MediaKeySession` stored as an entry of the
   * `LoadedSessionsStore`.
   * Allows to postpone the closure action if another MediaKeySession action
   * is already pending.
   * @param {Object} entry
   * @returns {Promise.<boolean>}
   */;
  _proto._closeEntry =
  /*#__PURE__*/
  function () {
    var _closeEntry2 = (0,asyncToGenerator/* default */.A)( /*#__PURE__*/regenerator_default().mark(function _callee5(entry) {
      var mediaKeySession;
      return regenerator_default().wrap(function _callee5$(_context5) {
        while (1) switch (_context5.prev = _context5.next) {
          case 0:
            mediaKeySession = entry.mediaKeySession;
            return _context5.abrupt("return", new Promise(function (resolve, reject) {
              if (entry !== undefined && (entry.isLoadingPersistentSession || entry.isGeneratingRequest)) {
                entry.closingStatus = {
                  type: "awaiting",
                  start: tryClosingEntryAndResolve
                };
              } else {
                tryClosingEntryAndResolve();
              }
              function tryClosingEntryAndResolve() {
                if (entry !== undefined) {
                  entry.closingStatus = {
                    type: "pending"
                  };
                }
                safelyCloseMediaKeySession(mediaKeySession).then(function () {
                  if (entry !== undefined) {
                    entry.closingStatus = {
                      type: "done"
                    };
                  }
                  resolve(true);
                })["catch"](function (err) {
                  if (entry !== undefined) {
                    entry.closingStatus = {
                      type: "failed"
                    };
                  }
                  reject(err);
                });
              }
            }));
          case 2:
          case "end":
            return _context5.stop();
        }
      }, _callee5);
    }));
    function _closeEntry(_x7) {
      return _closeEntry2.apply(this, arguments);
    }
    return _closeEntry;
  }();
  return LoadedSessionsStore;
}();
/**
 * Close a MediaKeySession and just log an error if it fails (while resolving).
 * Emits then complete when done.
 * @param {MediaKeySession} mediaKeySession
 * @returns {Promise}
 */

function safelyCloseMediaKeySession(_x8) {
  return _safelyCloseMediaKeySession.apply(this, arguments);
}
function _safelyCloseMediaKeySession() {
  _safelyCloseMediaKeySession = (0,asyncToGenerator/* default */.A)( /*#__PURE__*/regenerator_default().mark(function _callee6(mediaKeySession) {
    return regenerator_default().wrap(function _callee6$(_context6) {
      while (1) switch (_context6.prev = _context6.next) {
        case 0:
          log/* default */.A.debug("DRM: Trying to close a MediaKeySession", mediaKeySession.sessionId);
          _context6.prev = 1;
          _context6.next = 4;
          return closeSession(mediaKeySession);
        case 4:
          log/* default */.A.debug("DRM: Succeeded to close MediaKeySession");
          return _context6.abrupt("return");
        case 8:
          _context6.prev = 8;
          _context6.t0 = _context6["catch"](1);
          log/* default */.A.error("DRM: Could not close MediaKeySession: " + (_context6.t0 instanceof Error ? _context6.t0.toString() : "Unknown error"));
          return _context6.abrupt("return");
        case 12:
        case "end":
          return _context6.stop();
      }
    }, _callee6, null, [[1, 8]]);
  }));
  return _safelyCloseMediaKeySession.apply(this, arguments);
}
;// CONCATENATED MODULE: ./src/utils/hash_buffer.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Convert given buffer to a 32bit integer hash
 *
 * This algorithm is the same one that Java `String.hashCode()` one which
 * is a fast hashing function adapted to short ASCII strings.
 * This consequently might not be the most adapted to buffers of various length
 * containing a various amount of data but still has the advantage of being
 * fast.
 *
 * As this function is used in persistent MediaKeySession storage, we probably
 * should keep this function somewhere as long as we want to support
 * MediaKeySessions persisted in old versions of the RxPlayer.
 *
 * @param {Array.<number>|TypedArray} buffer
 * @returns {number}
 */
function hashBuffer(buffer) {
  var hash = 0;
  var _char;
  for (var i = 0; i < buffer.length; i++) {
    _char = buffer[i];
    hash = (hash << 5) - hash + _char;
    hash = hash & hash; // Convert to 32bit integer
  }
  return hash;
}
// EXTERNAL MODULE: ./src/utils/is_non_empty_string.ts
var is_non_empty_string = __webpack_require__(2384);
;// CONCATENATED MODULE: ./src/core/decrypt/utils/serializable_bytes.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** Wrap byte-based data and allow serialization of it into base64. */
var SerializableBytes = /*#__PURE__*/function () {
  /**
   * Create a new `SerializableBytes`, wrapping the initialization data
   * given and allowing serialization into base64.
   * @param {Uint8Array}
   */
  function SerializableBytes(initData) {
    this.initData = initData;
  }
  /**
   * Convert it to base64.
   * `toJSON` is specially interpreted by JavaScript engines to be able to rely
   * on it when calling `JSON.stringify` on it or any of its parent objects:
   * https://tc39.es/ecma262/#sec-serializejsonproperty
   * @returns {string}
   */
  var _proto = SerializableBytes.prototype;
  _proto.toJSON = function toJSON() {
    return (0,utils_base64/* bytesToBase64 */.i)(this.initData);
  }
  /**
   * Decode a base64 sequence representing an initialization data back to an
   * Uint8Array.
   * @param {string}
   * @returns {Uint8Array}
   */;
  SerializableBytes.decode = function decode(base64) {
    return (0,utils_base64/* base64ToBytes */.K)(base64);
  };
  return SerializableBytes;
}();

;// CONCATENATED MODULE: ./src/core/decrypt/utils/are_init_values_compatible.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Returns `true` if both values are compatible initialization data, which
 * means that one is completely contained in the other.
 *
 * Both values given should be sorted by systemId the same way.
 * @param {Array.<Object>} stored
 * @param {Array.<Object>} newElts
 * @returns {boolean}
 */
function areInitializationValuesCompatible(stored, newElts) {
  var _a, _b;
  return (_b = (_a = _isAInB(stored, newElts)) !== null && _a !== void 0 ? _a : _isAInB(newElts, stored)) !== null && _b !== void 0 ? _b : false;
}
/**
 * Take two arrays of initialization data values, `a` and `b`, sorted by
 * their `systemId` property in the same order.
 *
 * Returns `true` if `a` is not empty and is completely contained in the `b`
 * array.
 * This is equivalent to: "`a` is contained in `b`".
 *
 * Returns `false` either if `a` is empty or if `b` has different initialization
 * data than it for equivalent system ids.
 * This is equivalent to: "`a` represents different data than `b`".
 *
 * Returns `null` if `a` is not fully contained in `b` but can still be
 * compatible with it.
 * This is equivalent to: "`a` is not contained in `b`, but `b` could be
 * contained in `a`".
 * @param {Array.<Object>} a
 * @param {Array.<Object>} b
 * @returns {boolean}
 */
function _isAInB(a, b) {
  if (a.length === 0) {
    return false;
  }
  if (b.length < a.length) {
    return null;
  }
  var firstAElt = a[0];
  var aIdx = 0;
  var bIdx = 0;
  for (; bIdx < b.length; bIdx++) {
    var bElt = b[bIdx];
    if (bElt.systemId !== firstAElt.systemId) {
      continue;
    }
    if (bElt.hash !== firstAElt.hash) {
      return false;
    }
    var aData = firstAElt.data instanceof Uint8Array ? firstAElt.data : typeof firstAElt.data === "string" ? SerializableBytes.decode(firstAElt.data) : firstAElt.data.initData;
    var bData = bElt.data instanceof Uint8Array ? bElt.data : typeof bElt.data === "string" ? SerializableBytes.decode(bElt.data) : bElt.data.initData;
    if (!(0,are_arrays_of_numbers_equal/* default */.A)(aData, bData)) {
      return false;
    }
    if (b.length - bIdx < a.length) {
      // not enough place to store `a`'s initialization data.
      return null;
    }
    // first `a` value was found. Check if all `a` values are found in `b`
    for (aIdx = 1; aIdx < a.length; aIdx++) {
      var aElt = a[aIdx];
      for (bIdx += 1; bIdx < b.length; bIdx++) {
        var bNewElt = b[bIdx];
        if (aElt.systemId !== bNewElt.systemId) {
          continue;
        }
        if (aElt.hash !== bNewElt.hash) {
          return false;
        }
        var aNewData = aElt.data instanceof Uint8Array ? aElt.data : typeof aElt.data === "string" ? SerializableBytes.decode(aElt.data) : aElt.data.initData;
        var bNewData = bNewElt.data instanceof Uint8Array ? bNewElt.data : typeof bNewElt.data === "string" ? SerializableBytes.decode(bNewElt.data) : bNewElt.data.initData;
        if (!(0,are_arrays_of_numbers_equal/* default */.A)(aNewData, bNewData)) {
          return false;
        }
        break;
      }
      if (aIdx === b.length) {
        // we didn't find `aElt`'s systemId in b
        return null;
      }
    }
    // If we're here, then we've found all `a`'s systemId in `b` and they match
    return true;
  }
  return null; // We didn't find the firstAElt`s systemId in `b`.
}
;// CONCATENATED MODULE: ./src/core/decrypt/utils/persistent_sessions_store.ts
function persistent_sessions_store_createForOfIteratorHelperLoose(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (t) return (t = t.call(r)).next.bind(t); if (Array.isArray(r) || (t = persistent_sessions_store_unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var o = 0; return function () { return o >= r.length ? { done: !0 } : { done: !1, value: r[o++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function persistent_sessions_store_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return persistent_sessions_store_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? persistent_sessions_store_arrayLikeToArray(r, a) : void 0; } }
function persistent_sessions_store_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */









/**
 * Throw if the given storage does not respect the right interface.
 * @param {Object} storage
 */
function checkStorage(storage) {
  (0,assert/* assertInterface */.A)(storage, {
    save: "function",
    load: "function"
  }, "licenseStorage");
}
/**
 * Set representing persisted licenses. Depends on a simple local-
 * storage implementation with a `save`/`load` synchronous interface
 * to persist information on persisted sessions.
 *
 * This set is used only for a cdm/keysystem with license persistency
 * supported.
 * @class PersistentSessionsStore
 */
var PersistentSessionsStore = /*#__PURE__*/function () {
  /**
   * Create a new PersistentSessionsStore.
   * @param {Object} storage
   */
  function PersistentSessionsStore(storage) {
    checkStorage(storage);
    this._entries = [];
    this._storage = storage;
    try {
      var entries = this._storage.load();
      if (!Array.isArray(entries)) {
        entries = [];
      }
      this._entries = entries;
    } catch (e) {
      log/* default */.A.warn("DRM-PSS: Could not get entries from license storage", e instanceof Error ? e : "");
      this.dispose();
    }
  }
  /**
   * Returns the number of stored values.
   * @returns {number}
   */
  var _proto = PersistentSessionsStore.prototype;
  _proto.getLength = function getLength() {
    return this._entries.length;
  }
  /**
   * Returns information about all stored MediaKeySession, in the order in which
   * the MediaKeySession have been created.
   * @returns {Array.<Object>}
   */;
  _proto.getAll = function getAll() {
    return this._entries;
  }
  /**
   * Retrieve an entry based on its initialization data.
   * @param {Object}  initData
   * @param {string|undefined} initDataType
   * @returns {Object|null}
   */;
  _proto.get = function get(initData) {
    var index = this._getIndex(initData);
    return index === -1 ? null : this._entries[index];
  }
  /**
   * Like `get`, but also move the corresponding value at the end of the store
   * (as returned by `getAll`) if found.
   * This can be used for example to tell when a previously-stored value is
   * re-used to then be able to implement a caching replacement algorithm based
   * on the least-recently-used values by just evicting the first values
   * returned by `getAll`.
   * @param {Uint8Array} initData
   * @param {string|undefined} initDataType
   * @returns {*}
   */;
  _proto.getAndReuse = function getAndReuse(initData) {
    var index = this._getIndex(initData);
    if (index === -1) {
      return null;
    }
    var item = this._entries.splice(index, 1)[0];
    this._entries.push(item);
    return item;
  }
  /**
   * Add a new entry in the PersistentSessionsStore.
   * @param {Uint8Array}  initData
   * @param {string|undefined} initDataType
   * @param {MediaKeySession} session
   */;
  _proto.add = function add(initData, keyIds, session) {
    var _a;
    if ((0,is_null_or_undefined/* default */.A)(session) || !(0,is_non_empty_string/* default */.A)(session.sessionId)) {
      log/* default */.A.warn("DRM-PSS: Invalid Persisten Session given.");
      return;
    }
    var sessionId = session.sessionId;
    var currentIndex = this._getIndex(initData);
    if (currentIndex >= 0) {
      var currVersion = keyIds === undefined ? 3 : 4;
      var currentEntry = this._entries[currentIndex];
      var entryVersion = (_a = currentEntry.version) !== null && _a !== void 0 ? _a : -1;
      if (entryVersion >= currVersion && sessionId === currentEntry.sessionId) {
        return;
      }
      log/* default */.A.info("DRM-PSS: Updating session info.", sessionId);
      this._entries.splice(currentIndex, 1);
    } else {
      log/* default */.A.info("DRM-PSS: Add new session", sessionId);
    }
    var storedValues = prepareValuesForStore(initData.values.getFormattedValues());
    if (keyIds === undefined) {
      this._entries.push({
        version: 3,
        sessionId: sessionId,
        values: storedValues,
        initDataType: initData.type
      });
    } else {
      this._entries.push({
        version: 4,
        sessionId: sessionId,
        keyIds: keyIds.map(function (k) {
          return new SerializableBytes(k);
        }),
        values: storedValues,
        initDataType: initData.type
      });
    }
    this._save();
  }
  /**
   * Delete stored MediaKeySession information based on its session id.
   * @param {string} sessionId
   */;
  _proto["delete"] = function _delete(sessionId) {
    var index = -1;
    for (var i = 0; i < this._entries.length; i++) {
      var _entry = this._entries[i];
      if (_entry.sessionId === sessionId) {
        index = i;
        break;
      }
    }
    if (index === -1) {
      log/* default */.A.warn("DRM-PSS: initData to delete not found.");
      return;
    }
    var entry = this._entries[index];
    log/* default */.A.warn("DRM-PSS: Delete session from store", entry.sessionId);
    this._entries.splice(index, 1);
    this._save();
  };
  _proto.deleteOldSessions = function deleteOldSessions(sessionsToDelete) {
    log/* default */.A.info("DRM-PSS: Deleting last " + sessionsToDelete + " sessions.");
    if (sessionsToDelete <= 0) {
      return;
    }
    if (sessionsToDelete <= this._entries.length) {
      this._entries.splice(0, sessionsToDelete);
    } else {
      log/* default */.A.warn("DRM-PSS: Asked to remove more information that it contains", sessionsToDelete, this._entries.length);
      this._entries = [];
    }
    this._save();
  }
  /**
   * Delete all saved entries.
   */;
  _proto.dispose = function dispose() {
    this._entries = [];
    this._save();
  }
  /**
   * Retrieve index of an entry.
   * Returns `-1` if not found.
   * @param {Object} initData
   * @returns {number}
   */;
  _proto._getIndex = function _getIndex(initData) {
    var _this = this;
    // Older versions of the format include a concatenation of all
    // initialization data and its hash.
    // This is only computed lazily, the first time it is needed.
    var lazyConcatenatedData = null;
    function getConcatenatedInitDataInfo() {
      if (lazyConcatenatedData === null) {
        var concatInitData = initData.values.constructRequestData();
        lazyConcatenatedData = {
          initData: concatInitData,
          initDataHash: hashBuffer(concatInitData)
        };
      }
      return lazyConcatenatedData;
    }
    var _loop = function _loop() {
        var entry = _this._entries[i];
        if (entry.initDataType === initData.type) {
          switch (entry.version) {
            case 4:
              if (initData.keyIds !== undefined) {
                var foundCompatible = initData.keyIds.every(function (keyId) {
                  var keyIdB64 = (0,utils_base64/* bytesToBase64 */.i)(keyId);
                  for (var _iterator = persistent_sessions_store_createForOfIteratorHelperLoose(entry.keyIds), _step; !(_step = _iterator()).done;) {
                    var entryKid = _step.value;
                    if (typeof entryKid === "string") {
                      if (keyIdB64 === entryKid) {
                        return true;
                      }
                    } else if ((0,are_arrays_of_numbers_equal/* default */.A)(entryKid.initData, keyId)) {
                      return true;
                    }
                  }
                  return false;
                });
                if (foundCompatible) {
                  return {
                    v: i
                  };
                }
              } else {
                var _formatted = initData.values.getFormattedValues();
                if (areInitializationValuesCompatible(_formatted, entry.values)) {
                  return {
                    v: i
                  };
                }
              }
              break;
            case 3:
              var formatted = initData.values.getFormattedValues();
              if (areInitializationValuesCompatible(formatted, entry.values)) {
                return {
                  v: i
                };
              }
              break;
            case 2:
              {
                var _getConcatenatedInitD = getConcatenatedInitDataInfo(),
                  concatInitData = _getConcatenatedInitD.initData,
                  concatHash = _getConcatenatedInitD.initDataHash;
                if (entry.initDataHash === concatHash) {
                  try {
                    var decodedInitData = typeof entry.initData === "string" ? SerializableBytes.decode(entry.initData) : entry.initData.initData;
                    if ((0,are_arrays_of_numbers_equal/* default */.A)(decodedInitData, concatInitData)) {
                      return {
                        v: i
                      };
                    }
                  } catch (e) {
                    log/* default */.A.warn("DRM-PSS: Could not decode initialization data.", e instanceof Error ? e : "");
                  }
                }
                break;
              }
            case 1:
              {
                var _getConcatenatedInitD2 = getConcatenatedInitDataInfo(),
                  _concatInitData = _getConcatenatedInitD2.initData,
                  _concatHash = _getConcatenatedInitD2.initDataHash;
                if (entry.initDataHash === _concatHash) {
                  if (typeof entry.initData.length === "undefined") {
                    // If length is undefined, it has been linearized. We could still
                    // convert it back to an Uint8Array but this would necessitate some
                    // ugly unreadable logic for a very very minor possibility.
                    // Just consider that it is a match based on the hash.
                    return {
                      v: i
                    };
                  } else if ((0,are_arrays_of_numbers_equal/* default */.A)(entry.initData, _concatInitData)) {
                    return {
                      v: i
                    };
                  }
                }
                break;
              }
            default:
              {
                var _getConcatenatedInitD3 = getConcatenatedInitDataInfo(),
                  _concatHash2 = _getConcatenatedInitD3.initDataHash;
                if (entry.initData === _concatHash2) {
                  return {
                    v: i
                  };
                }
              }
          }
        }
      },
      _ret;
    for (var i = 0; i < this._entries.length; i++) {
      _ret = _loop();
      if (_ret) return _ret.v;
    }
    return -1;
  }
  /**
   * Use the given storage to store the current entries.
   */;
  _proto._save = function _save() {
    try {
      this._storage.save(this._entries);
    } catch (e) {
      log/* default */.A.warn("DRM-PSS: Could not save licenses in localStorage");
    }
  };
  return PersistentSessionsStore;
}();
/**
 * Format given initializationData's values so they are ready to be stored:
 *   - sort them by systemId, so they are faster to compare
 *   - add hash for each initialization data encountered.
 * @param {Array.<Object>} initialValues
 * @returns {Array.<Object>}
 */

function prepareValuesForStore(initialValues) {
  return initialValues.map(function (_ref) {
    var systemId = _ref.systemId,
      data = _ref.data,
      hash = _ref.hash;
    return {
      systemId: systemId,
      hash: hash,
      data: new SerializableBytes(data)
    };
  });
}
;// CONCATENATED MODULE: ./src/core/decrypt/utils/server_certificate_store.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Keep track of server certificate which have been set for a MediaKeys.
 * As it is impossible for a MediaKeys to have his server certificate reset
 * or updated, we consider that once it has been set, it will remain set until
 * the MediaKeys instance is killed.
 *
 * So, a WeakMap helps keeping a trace of which server certificate (identified
 * with a unique hash) is set on a MediaKeys.
 * `null` indicate that we don't know (and not `undefined`, because this is the
 * default value for when a WeakMap has no value for a key) which server
 * certificate is attached to a MediaKeys instance (most likely because related
 * EME APIs failed or had an unexpected behavior).
 */
var serverCertificateHashesMap = new WeakMap();
/** ServerCertificateStore */
/* harmony default export */ var server_certificate_store = ({
  /**
   * Tells the ServerCertificateStore that you begin to call the APIs to set a
   * ServerCertificate on `mediaKeys`.
   *
   * Calling this function is necessary due to how server certificate work
   * currently in EME APIs:
   * Because right now, it is impossible to tell if a MediaKeys instance has an
   * attached ServerCertificate or not when the corresponding API fails or if it
   * never answers, we prefer to announce through this function that the current
   * server certificate attached to this MediaKeys is for now invalid.
   * @param {MediaKeys | Object} mediaKeys
   */
  prepare: function prepare(mediaKeys) {
    serverCertificateHashesMap.set(mediaKeys, null);
  },
  /**
   * Attach a new server certificate to a MediaKeys in the
   * ServerCertificateStore.
   *
   * Only one server certificate should ever be attached to a MediaKeys
   * instance and the `prepare` function should have been called before any
   * action to update the server certificate took place (this function does not
   * enforce either of those behaviors).
   * @param {MediaKeys | Object} mediaKeys
   * @param {ArrayBufferView | BufferSource} serverCertificate
   */
  set: function set(mediaKeys, serverCertificate) {
    var formattedServerCertificate = serverCertificate instanceof Uint8Array ? serverCertificate : new Uint8Array(serverCertificate instanceof ArrayBuffer ? serverCertificate : serverCertificate.buffer);
    var hash = hashBuffer(formattedServerCertificate);
    serverCertificateHashesMap.set(mediaKeys, {
      hash: hash,
      serverCertificate: formattedServerCertificate
    });
  },
  /**
   * Returns `true` if the MediaKeys instance has an attached ServerCertificate.
   * Returns `false` if it doesn't.
   *
   * Returns `undefined` if we cannot know, most likely because related EME APIs
   * failed or had an unexpected behavior.
   * @param {MediaKeys} mediaKeys
   * @returns {Boolean|undefined}
   */
  hasOne: function hasOne(mediaKeys) {
    var currentServerCertificate = serverCertificateHashesMap.get(mediaKeys);
    return currentServerCertificate === undefined ? false : currentServerCertificate === null ? undefined : true;
  },
  /**
   * Returns `true` if the given `mediaKeys` has `serverCertificate` attached to
   * it.
   * Returns `false` either if it doesn't of if we doesn't know if it does.
   * @param {MediaKeys | Object} mediaKeys
   * @param {ArrayBufferView | BufferSource} serverCertificate
   * @returns {boolean}
   */
  has: function has(mediaKeys, serverCertificate) {
    var serverCertificateHash = serverCertificateHashesMap.get(mediaKeys);
    if (serverCertificateHash === undefined || serverCertificateHash === null) {
      return false;
    }
    var oldHash = serverCertificateHash.hash,
      oldServerCertificate = serverCertificateHash.serverCertificate;
    var newServerCertificate = serverCertificate instanceof Uint8Array ? serverCertificate : new Uint8Array(serverCertificate instanceof ArrayBuffer ? serverCertificate : serverCertificate.buffer);
    var newHash = hashBuffer(newServerCertificate);
    if (newHash !== oldHash || oldServerCertificate.length !== newServerCertificate.length) {
      return false;
    }
    for (var i = 0; i < oldServerCertificate.length; i++) {
      if (oldServerCertificate[i] !== newServerCertificate[i]) {
        return false;
      }
    }
    return true;
  }
});
;// CONCATENATED MODULE: ./src/core/decrypt/get_media_keys.ts


/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */









/**
 * @throws {EncryptedMediaError}
 * @param {Object} keySystemOptions
 * @returns {Object|null}
 */
function createPersistentSessionsStorage(keySystemOptions) {
  if (keySystemOptions.persistentLicense !== true) {
    return null;
  }
  var licenseStorage = keySystemOptions.licenseStorage;
  if (licenseStorage == null) {
    throw new encrypted_media_error/* default */.A("INVALID_KEY_SYSTEM", "No license storage found for persistent license.");
  }
  log/* default */.A.debug("DRM: Set the given license storage");
  return new PersistentSessionsStore(licenseStorage);
}
/**
 * Create a MediaKeys instance and associated structures (or just return the
 * current ones if sufficient) based on a wanted configuration.
 * @param {HTMLMediaElement} mediaElement - The HTMLMediaElement on which you
 * will attach the MediaKeys instance.
 * This Element is here only used to check if the current MediaKeys and
 * MediaKeySystemAccess instances are sufficient
 * @param {Array.<Object>} keySystemsConfigs - The key system configuration.
 * Needed to ask the right MediaKeySystemAccess.
 * @param {Object} cancelSignal - CancellationSignal allowing to cancel the
 * creation of the MediaKeys instance while the task is still pending.
 * @returns {Promise.<Object>}
 */
function getMediaKeysInfos(_x, _x2, _x3) {
  return _getMediaKeysInfos.apply(this, arguments);
}
/**
 * Create `MediaKeys` from the `MediaKeySystemAccess` given.
 * Throws the right formatted error if it fails.
 * @param {MediaKeySystemAccess} mediaKeySystemAccess
 * @returns {Promise.<MediaKeys>}
 */
function _getMediaKeysInfos() {
  _getMediaKeysInfos = (0,asyncToGenerator/* default */.A)( /*#__PURE__*/regenerator_default().mark(function _callee(mediaElement, keySystemsConfigs, cancelSignal) {
    var evt, _evt$value, options, mediaKeySystemAccess, askedConfiguration, currentState, persistentSessionsStore, _mediaKeys, _loadedSessionsStore, mediaKeys, loadedSessionsStore;
    return regenerator_default().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return getMediaKeySystemAccess(mediaElement, keySystemsConfigs, cancelSignal);
        case 2:
          evt = _context.sent;
          if (!(cancelSignal.cancellationError !== null)) {
            _context.next = 5;
            break;
          }
          throw cancelSignal.cancellationError;
        case 5:
          _evt$value = evt.value, options = _evt$value.options, mediaKeySystemAccess = _evt$value.mediaKeySystemAccess, askedConfiguration = _evt$value.askedConfiguration;
          currentState = media_keys_infos_store/* default */.A.getState(mediaElement);
          persistentSessionsStore = createPersistentSessionsStorage(options);
          if (!(canReuseMediaKeys() && currentState !== null && evt.type === "reuse-media-key-system-access")) {
            _context.next = 12;
            break;
          }
          _mediaKeys = currentState.mediaKeys, _loadedSessionsStore = currentState.loadedSessionsStore; // We might just rely on the currently attached MediaKeys instance.
          // First check if server certificate parameters are the same than in the
          // current MediaKeys instance. If not, re-create MediaKeys from scratch.
          if (!(server_certificate_store.hasOne(_mediaKeys) === false || !(0,is_null_or_undefined/* default */.A)(options.serverCertificate) && server_certificate_store.has(_mediaKeys, options.serverCertificate))) {
            _context.next = 12;
            break;
          }
          return _context.abrupt("return", {
            mediaKeys: _mediaKeys,
            mediaKeySystemAccess: mediaKeySystemAccess,
            askedConfiguration: askedConfiguration,
            stores: {
              loadedSessionsStore: _loadedSessionsStore,
              persistentSessionsStore: persistentSessionsStore
            },
            options: options
          });
        case 12:
          _context.next = 14;
          return createMediaKeys(mediaKeySystemAccess);
        case 14:
          mediaKeys = _context.sent;
          log/* default */.A.info("DRM: MediaKeys created with success");
          loadedSessionsStore = new LoadedSessionsStore(mediaKeys);
          return _context.abrupt("return", {
            mediaKeys: mediaKeys,
            mediaKeySystemAccess: mediaKeySystemAccess,
            askedConfiguration: askedConfiguration,
            stores: {
              loadedSessionsStore: loadedSessionsStore,
              persistentSessionsStore: persistentSessionsStore
            },
            options: options
          });
        case 18:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return _getMediaKeysInfos.apply(this, arguments);
}
function createMediaKeys(_x4) {
  return _createMediaKeys.apply(this, arguments);
}
function _createMediaKeys() {
  _createMediaKeys = (0,asyncToGenerator/* default */.A)( /*#__PURE__*/regenerator_default().mark(function _callee2(mediaKeySystemAccess) {
    var mediaKeys, message;
    return regenerator_default().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          log/* default */.A.info("DRM: Calling createMediaKeys on the MediaKeySystemAccess");
          _context2.prev = 1;
          _context2.next = 4;
          return mediaKeySystemAccess.createMediaKeys();
        case 4:
          mediaKeys = _context2.sent;
          return _context2.abrupt("return", mediaKeys);
        case 8:
          _context2.prev = 8;
          _context2.t0 = _context2["catch"](1);
          message = _context2.t0 instanceof Error ? _context2.t0.message : "Unknown error when creating MediaKeys.";
          throw new encrypted_media_error/* default */.A("CREATE_MEDIA_KEYS_ERROR", message);
        case 12:
        case "end":
          return _context2.stop();
      }
    }, _callee2, null, [[1, 8]]);
  }));
  return _createMediaKeys.apply(this, arguments);
}
;// CONCATENATED MODULE: ./src/core/decrypt/init_media_keys.ts


/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * Get media keys infos from key system configs then attach media keys to media element.
 * @param {HTMLMediaElement} mediaElement
 * @param {Array.<Object>} keySystemsConfigs
 * @param {Object} cancelSignal
 * @returns {Promise.<Object>}
 */
function initMediaKeys(_x, _x2, _x3) {
  return _initMediaKeys.apply(this, arguments);
}
function _initMediaKeys() {
  _initMediaKeys = (0,asyncToGenerator/* default */.A)( /*#__PURE__*/regenerator_default().mark(function _callee(mediaElement, keySystemsConfigs, cancelSignal) {
    var mediaKeysInfo, mediaKeys, shouldDisableOldMediaKeys;
    return regenerator_default().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return getMediaKeysInfos(mediaElement, keySystemsConfigs, cancelSignal);
        case 2:
          mediaKeysInfo = _context.sent;
          mediaKeys = mediaKeysInfo.mediaKeys;
          shouldDisableOldMediaKeys = mediaElement.mediaKeys !== null && mediaElement.mediaKeys !== undefined && mediaKeys !== mediaElement.mediaKeys;
          if (!shouldDisableOldMediaKeys) {
            _context.next = 13;
            break;
          }
          log/* default */.A.debug("DRM: Disabling old MediaKeys");
          // TODO should we be awaiting always?
          // Should be tested on all devices, we may want to wait for another
          // version to make this important change.
          if (!browser_detection/* isWebOs */.hF) {
            _context.next = 12;
            break;
          }
          _context.next = 10;
          return disableMediaKeys(mediaElement);
        case 10:
          _context.next = 13;
          break;
        case 12:
          disableMediaKeys(mediaElement)["catch"](noop/* default */.A);
        case 13:
          return _context.abrupt("return", mediaKeysInfo);
        case 14:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return _initMediaKeys.apply(this, arguments);
}
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js + 4 modules
var wrapNativeSuper = __webpack_require__(8593);
// EXTERNAL MODULE: ./src/utils/get_fuzzed_delay.ts
var get_fuzzed_delay = __webpack_require__(7021);
// EXTERNAL MODULE: ./src/utils/sleep.ts
var sleep = __webpack_require__(8801);
;// CONCATENATED MODULE: ./src/utils/retry_promise_with_backoff.ts





/**
 * Retry the given Promise (if it rejects) with an exponential
 * backoff.
 * The backoff behavior can be tweaked through the options given.
 *
 * @param {Function} runProm
 * @param {Object} options - Configuration object.
 * This object contains the following properties:
 *
 *   - retryDelay {Number} - The initial delay, in ms.
 *     This delay will be fuzzed to fall under the range +-30% each time a new
 *     retry is done.
 *     Then, this delay will be multiplied by 2^(n-1), n being the counter of
 *     retry we performed (beginning at 1 for the first retry).
 *
 *   - totalRetry {Number} - The amount of time we should retry. 0
 *     means no retry, 1 means a single retry, Infinity means infinite retry
 *     etc.
 *     If the Promise still rejects after this number of retry, the error will
 *     be throwed through the returned Promise.
 *
 *   - shouldRetry {Function|undefined} -  Function which will receive the
 *     error each time it fails, and should return a boolean. If this boolean
 *     is false, the error will be directly thrown (without anymore retry).
 *
 *   - onRetry {Function|undefined} - Function which will be triggered at
 *     each retry. Will receive two arguments:
 *       1. The error
 *       2. The current retry count, beginning at 1 for the first retry
 *
 * @param {Object} cancelSignal
 * @returns {Promise}
 * TODO Take errorSelector out. Should probably be entirely managed in the
 * calling code via a catch (much simpler to use and to understand).
 */
function retryPromiseWithBackoff(runProm, options, cancelSignal) {
  var baseDelay = options.baseDelay,
    maxDelay = options.maxDelay,
    totalRetry = options.totalRetry,
    shouldRetry = options.shouldRetry,
    onRetry = options.onRetry;
  var retryCount = 0;
  return iterate();
  function iterate() {
    return _iterate.apply(this, arguments);
  }
  function _iterate() {
    _iterate = (0,asyncToGenerator/* default */.A)( /*#__PURE__*/regenerator_default().mark(function _callee() {
      var res, delay, _res;
      return regenerator_default().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            if (!(cancelSignal.cancellationError !== null)) {
              _context.next = 2;
              break;
            }
            throw cancelSignal.cancellationError;
          case 2:
            _context.prev = 2;
            _context.next = 5;
            return runProm();
          case 5:
            res = _context.sent;
            return _context.abrupt("return", res);
          case 9:
            _context.prev = 9;
            _context.t0 = _context["catch"](2);
            if (!(cancelSignal.cancellationError !== null)) {
              _context.next = 13;
              break;
            }
            throw cancelSignal.cancellationError;
          case 13:
            if (!(!(0,is_null_or_undefined/* default */.A)(shouldRetry) && !shouldRetry(_context.t0) || retryCount++ >= totalRetry)) {
              _context.next = 15;
              break;
            }
            throw _context.t0;
          case 15:
            if (typeof onRetry === "function") {
              onRetry(_context.t0, retryCount);
            }
            delay = getRetryDelay(baseDelay, retryCount, maxDelay);
            _context.next = 19;
            return (0,sleep/* default */.A)(delay);
          case 19:
            _res = iterate();
            return _context.abrupt("return", _res);
          case 21:
          case "end":
            return _context.stop();
        }
      }, _callee, null, [[2, 9]]);
    }));
    return _iterate.apply(this, arguments);
  }
}
/**
 * Get the delay that should be applied to the following retry, it depends on
 * the base delay and is increaser for with the retry count. The result is
 * ceiled by the maxDelay.
 * @param {number} baseDelay - delay after wich the first request is retried
 * after a failure
 * @param {numbe} retryCount - count of retries
 * @param {number} maxDelay - maximum delay
 * @returns {number} - the delay that should be applied to the following retry
 */
function getRetryDelay(baseDelay, retryCount, maxDelay) {
  var delay = baseDelay * Math.pow(2, retryCount - 1);
  var fuzzedDelay = (0,get_fuzzed_delay/* default */.A)(delay);
  return Math.min(fuzzedDelay, maxDelay);
}
;// CONCATENATED MODULE: ./src/compat/eme/get_uuid_kid_from_keystatus_kid.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Get KID from MediaKeySession keyStatus, and convert it in usual big-endian kid
 * if necessary. On EDGE, Microsoft Playready KID are presented into little-endian GUID.
 * @param {String} keySystem
 * @param {Uint8Array} baseKeyId
 * @returns {Uint8Array}
 */
function getUUIDKIDFromKeyStatusKID(keySystem, baseKeyId) {
  if (keySystem.indexOf("playready") !== -1 && (browser_detection/* isIEOrEdge */.h$ || browser_detection/* isEdgeChromium */.op)) {
    return (0,string_parsing/* guidToUuid */.KZ)(baseKeyId);
  }
  return baseKeyId;
}
// EXTERNAL MODULE: ./src/utils/assert_unreachable.ts + 1 modules
var assert_unreachable = __webpack_require__(2038);
;// CONCATENATED MODULE: ./src/core/decrypt/utils/check_key_statuses.ts


/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* eslint-disable-next-line max-len */





/**
 * Error thrown when the MediaKeySession has to be closed due to a trigger
 * specified by user configuration.
 * Such MediaKeySession should be closed immediately and may be re-created if
 * needed again.
 * @class DecommissionedSessionError
 * @extends Error
 */
var DecommissionedSessionError = /*#__PURE__*/function (_Error) {
  /**
   * Creates a new `DecommissionedSessionError`.
   * @param {Error} reason - Error that led to the decision to close the
   * current MediaKeySession. Should be used for reporting purposes.
   */
  function DecommissionedSessionError(reason) {
    var _this;
    _this = _Error.call(this) || this;
    // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class
    Object.setPrototypeOf(_this, DecommissionedSessionError.prototype);
    _this.reason = reason;
    return _this;
  }
  (0,inheritsLoose/* default */.A)(DecommissionedSessionError, _Error);
  return DecommissionedSessionError;
}( /*#__PURE__*/(0,wrapNativeSuper/* default */.A)(Error));
var KEY_STATUSES = {
  EXPIRED: "expired",
  INTERNAL_ERROR: "internal-error",
  OUTPUT_RESTRICTED: "output-restricted"
};
/**
 * Look at the current key statuses in the sessions and construct the
 * appropriate warnings, whitelisted and blacklisted key ids.
 *
 * Throws if one of the keyID is on an error.
 * @param {MediaKeySession} session - The MediaKeySession from which the keys
 * will be checked.
 * @param {Object} options
 * @param {String} keySystem - The configuration keySystem used for deciphering
 * @returns {Object} - Warnings to send, whitelisted and blacklisted key ids.
 */
function checkKeyStatuses(session, options, keySystem) {
  var _options$fallbackOn = options.fallbackOn,
    fallbackOn = _options$fallbackOn === void 0 ? {} : _options$fallbackOn,
    throwOnLicenseExpiration = options.throwOnLicenseExpiration,
    onKeyExpiration = options.onKeyExpiration;
  var blacklistedKeyIds = [];
  var whitelistedKeyIds = [];
  var badKeyStatuses = [];
  session.keyStatuses.forEach(function (_arg1, _arg2) {
    // Hack present because the order of the arguments has changed in spec
    // and is not the same between some versions of Edge and Chrome.
    var _ref = function () {
        return typeof _arg1 === "string" ? [_arg1, _arg2] : [_arg2, _arg1];
      }(),
      keyStatus = _ref[0],
      keyStatusKeyId = _ref[1];
    var keyId = getUUIDKIDFromKeyStatusKID(keySystem, new Uint8Array(keyStatusKeyId));
    var keyStatusObj = {
      keyId: keyId.buffer,
      keyStatus: keyStatus
    };
    if (log/* default */.A.hasLevel("DEBUG")) {
      log/* default */.A.debug("DRM: key status update (" + (0,string_parsing/* bytesToHex */.My)(keyId) + "): " + keyStatus);
    }
    switch (keyStatus) {
      case KEY_STATUSES.EXPIRED:
        {
          var error = new encrypted_media_error/* default */.A("KEY_STATUS_CHANGE_ERROR", "A decryption key expired (" + (0,string_parsing/* bytesToHex */.My)(keyId) + ")", {
            keyStatuses: [keyStatusObj].concat(badKeyStatuses)
          });
          if (onKeyExpiration === "error" || onKeyExpiration === undefined && throwOnLicenseExpiration === false) {
            throw error;
          }
          switch (onKeyExpiration) {
            case "close-session":
              throw new DecommissionedSessionError(error);
            case "fallback":
              blacklistedKeyIds.push(keyId);
              break;
            default:
              // I weirdly stopped relying on switch-cases here due to some TypeScript
              // issue, not checking properly `case undefined` (bug?)
              if (onKeyExpiration === "continue" || onKeyExpiration === undefined) {
                whitelistedKeyIds.push(keyId);
              } else {
                // Compile-time check throwing when not all possible cases are handled
                (0,assert_unreachable/* default */.A)(onKeyExpiration);
              }
              break;
          }
          badKeyStatuses.push(keyStatusObj);
          break;
        }
      case KEY_STATUSES.INTERNAL_ERROR:
        {
          if (fallbackOn.keyInternalError !== true) {
            throw new encrypted_media_error/* default */.A("KEY_STATUS_CHANGE_ERROR", "A \"" + keyStatus + "\" status has been encountered (" + (0,string_parsing/* bytesToHex */.My)(keyId) + ")", {
              keyStatuses: [keyStatusObj].concat(badKeyStatuses)
            });
          }
          badKeyStatuses.push(keyStatusObj);
          blacklistedKeyIds.push(keyId);
          break;
        }
      case KEY_STATUSES.OUTPUT_RESTRICTED:
        {
          if (fallbackOn.keyOutputRestricted !== true) {
            throw new encrypted_media_error/* default */.A("KEY_STATUS_CHANGE_ERROR", "A \"" + keyStatus + "\" status has been encountered (" + (0,string_parsing/* bytesToHex */.My)(keyId) + ")", {
              keyStatuses: [keyStatusObj].concat(badKeyStatuses)
            });
          }
          badKeyStatuses.push(keyStatusObj);
          blacklistedKeyIds.push(keyId);
          break;
        }
      default:
        whitelistedKeyIds.push(keyId);
        break;
    }
  });
  var warning;
  if (badKeyStatuses.length > 0) {
    warning = new encrypted_media_error/* default */.A("KEY_STATUS_CHANGE_ERROR", "One or several problematic key statuses have been encountered", {
      keyStatuses: badKeyStatuses
    });
  }
  return {
    warning: warning,
    blacklistedKeyIds: blacklistedKeyIds,
    whitelistedKeyIds: whitelistedKeyIds
  };
}
;// CONCATENATED MODULE: ./src/core/decrypt/session_events_listener.ts




/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */








var onKeyError = event_listeners/* onKeyError */.HQ,
  onKeyMessage = event_listeners/* onKeyMessage */.qF,
  onKeyStatusesChange = event_listeners/* onKeyStatusesChange */.VS;
/**
 * Listen to various events from a MediaKeySession and react accordingly
 * depending on the configuration given.
 * @param {MediaKeySession} session - The MediaKeySession concerned.
 * @param {Object} keySystemOptions - The key system options.
 * @param {String} keySystem - The configuration keySystem used for deciphering
 * @param {Object} callbacks
 * @param {Object} cancelSignal
 */
function SessionEventsListener(session, keySystemOptions, keySystem, callbacks, cancelSignal) {
  log/* default */.A.info("DRM: Binding session events", session.sessionId);
  var _keySystemOptions$get = keySystemOptions.getLicenseConfig,
    getLicenseConfig = _keySystemOptions$get === void 0 ? {} : _keySystemOptions$get;
  /** Allows to manually cancel everything the `SessionEventsListener` is doing. */
  var manualCanceller = new task_canceller/* default */.Ay();
  manualCanceller.linkToSignal(cancelSignal);
  if (!(0,is_null_or_undefined/* default */.A)(session.closed)) {
    session.closed.then(function () {
      return manualCanceller.cancel();
    })["catch"](function (err) {
      // Should never happen
      if (cancelSignal.isCancelled()) {
        return;
      }
      manualCanceller.cancel();
      callbacks.onError(err);
    });
  }
  onKeyError(session, function (evt) {
    manualCanceller.cancel();
    callbacks.onError(new encrypted_media_error/* default */.A("KEY_ERROR", evt.type));
  }, manualCanceller.signal);
  onKeyStatusesChange(session, function (keyStatusesEvent) {
    handleKeyStatusesChangeEvent(keyStatusesEvent)["catch"](function (error) {
      if (cancelSignal.isCancelled() || manualCanceller.isUsed() && error instanceof task_canceller/* CancellationSignal */.AK) {
        return;
      }
      manualCanceller.cancel();
      callbacks.onError(error);
    });
  }, manualCanceller.signal);
  onKeyMessage(session, function (evt) {
    var messageEvent = evt;
    var message = new Uint8Array(messageEvent.message);
    var messageType = (0,is_non_empty_string/* default */.A)(messageEvent.messageType) ? messageEvent.messageType : "license-request";
    log/* default */.A.info("DRM: Received message event, type " + messageType, session.sessionId);
    var backoffOptions = getLicenseBackoffOptions(getLicenseConfig.retry);
    retryPromiseWithBackoff(function () {
      return runGetLicense(message, messageType);
    }, backoffOptions, manualCanceller.signal).then(function (licenseObject) {
      if (manualCanceller.isUsed()) {
        return Promise.resolve();
      }
      if ((0,is_null_or_undefined/* default */.A)(licenseObject)) {
        log/* default */.A.info("DRM: No license given, skipping session.update");
      } else {
        try {
          return updateSessionWithMessage(session, licenseObject);
        } catch (err) {
          manualCanceller.cancel();
          callbacks.onError(err);
        }
      }
    })["catch"](function (err) {
      if (manualCanceller.isUsed()) {
        return;
      }
      manualCanceller.cancel();
      var formattedError = formatGetLicenseError(err);
      if (!(0,is_null_or_undefined/* default */.A)(err)) {
        var fallbackOnLastTry = err.fallbackOnLastTry;
        if (fallbackOnLastTry === true) {
          log/* default */.A.warn("DRM: Last `getLicense` attempt failed. " + "Blacklisting the current session.");
          callbacks.onError(new BlacklistedSessionError(formattedError));
          return;
        }
      }
      callbacks.onError(formattedError);
    });
  }, manualCanceller.signal);
  checkAndHandleCurrentKeyStatuses();
  return;
  /**
   * @param {Event} keyStatusesEvent
   * @returns {Promise}
   */
  function handleKeyStatusesChangeEvent(_x) {
    return _handleKeyStatusesChangeEvent.apply(this, arguments);
  }
  /**
   * Check current MediaKeyStatus for each key in the given MediaKeySession and:
   *   - throw if at least one status is a non-recoverable error
   *   - call warning callback for recoverable errors
   *   - call onKeyUpdate callback when the MediaKeyStatus of any key is updated
   */
  function _handleKeyStatusesChangeEvent() {
    _handleKeyStatusesChangeEvent = (0,asyncToGenerator/* default */.A)( /*#__PURE__*/regenerator_default().mark(function _callee2(keyStatusesEvent) {
      var runOnKeyStatusesChangeCallback, _runOnKeyStatusesChangeCallback;
      return regenerator_default().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            _runOnKeyStatusesChangeCallback = function _runOnKeyStatusesChan2() {
              _runOnKeyStatusesChangeCallback = (0,asyncToGenerator/* default */.A)( /*#__PURE__*/regenerator_default().mark(function _callee() {
                var ret, err;
                return regenerator_default().wrap(function _callee$(_context) {
                  while (1) switch (_context.prev = _context.next) {
                    case 0:
                      if (!manualCanceller.isUsed()) {
                        _context.next = 2;
                        break;
                      }
                      return _context.abrupt("return");
                    case 2:
                      if (!(typeof keySystemOptions.onKeyStatusesChange === "function")) {
                        _context.next = 24;
                        break;
                      }
                      _context.prev = 3;
                      _context.next = 6;
                      return keySystemOptions.onKeyStatusesChange(keyStatusesEvent, session);
                    case 6:
                      ret = _context.sent;
                      if (!manualCanceller.isUsed()) {
                        _context.next = 9;
                        break;
                      }
                      return _context.abrupt("return");
                    case 9:
                      _context.next = 18;
                      break;
                    case 11:
                      _context.prev = 11;
                      _context.t0 = _context["catch"](3);
                      if (!cancelSignal.isCancelled()) {
                        _context.next = 15;
                        break;
                      }
                      return _context.abrupt("return");
                    case 15:
                      err = new encrypted_media_error/* default */.A("KEY_STATUS_CHANGE_ERROR", "Unknown `onKeyStatusesChange` error");
                      if (!(0,is_null_or_undefined/* default */.A)(_context.t0) && (0,is_non_empty_string/* default */.A)(_context.t0.message)) {
                        err.message = _context.t0.message;
                      }
                      throw err;
                    case 18:
                      if (!(0,is_null_or_undefined/* default */.A)(ret)) {
                        _context.next = 22;
                        break;
                      }
                      log/* default */.A.info("DRM: No license given, skipping session.update");
                      _context.next = 24;
                      break;
                    case 22:
                      _context.next = 24;
                      return updateSessionWithMessage(session, ret);
                    case 24:
                    case "end":
                      return _context.stop();
                  }
                }, _callee, null, [[3, 11]]);
              }));
              return _runOnKeyStatusesChangeCallback.apply(this, arguments);
            };
            runOnKeyStatusesChangeCallback = function _runOnKeyStatusesChan() {
              return _runOnKeyStatusesChangeCallback.apply(this, arguments);
            };
            log/* default */.A.info("DRM: keystatuseschange event received", session.sessionId);
            _context2.next = 5;
            return Promise.all([runOnKeyStatusesChangeCallback(), Promise.resolve(checkAndHandleCurrentKeyStatuses())]);
          case 5:
          case "end":
            return _context2.stop();
        }
      }, _callee2);
    }));
    return _handleKeyStatusesChangeEvent.apply(this, arguments);
  }
  function checkAndHandleCurrentKeyStatuses() {
    if (manualCanceller.isUsed() || session.keyStatuses.size === 0) {
      return;
    }
    var _checkKeyStatuses = checkKeyStatuses(session, keySystemOptions, keySystem),
      warning = _checkKeyStatuses.warning,
      blacklistedKeyIds = _checkKeyStatuses.blacklistedKeyIds,
      whitelistedKeyIds = _checkKeyStatuses.whitelistedKeyIds;
    if (warning !== undefined) {
      callbacks.onWarning(warning);
      if (manualCanceller.isUsed()) {
        return;
      }
    }
    callbacks.onKeyUpdate({
      whitelistedKeyIds: whitelistedKeyIds,
      blacklistedKeyIds: blacklistedKeyIds
    });
  }
  function runGetLicense(message, messageType) {
    var timeoutId;
    return new Promise(function (res, rej) {
      try {
        log/* default */.A.debug("DRM: Calling `getLicense`", messageType);
        var getLicense = keySystemOptions.getLicense(message, messageType);
        var getLicenseTimeout = (0,is_null_or_undefined/* default */.A)(getLicenseConfig.timeout) ? 10 * 1000 : getLicenseConfig.timeout;
        if (getLicenseTimeout >= 0) {
          timeoutId = setTimeout(function () {
            rej(new GetLicenseTimeoutError("\"getLicense\" timeout exceeded (" + getLicenseTimeout + " ms)"));
          }, getLicenseTimeout);
        }
        Promise.resolve(getLicense).then(clearTimeoutAndResolve, clearTimeoutAndReject);
      } catch (err) {
        clearTimeoutAndReject(err);
      }
      function clearTimeoutAndResolve(data) {
        if (timeoutId !== undefined) {
          clearTimeout(timeoutId);
        }
        res(data);
      }
      function clearTimeoutAndReject(err) {
        if (timeoutId !== undefined) {
          clearTimeout(timeoutId);
        }
        rej(err);
      }
    });
  }
  /**
   * Construct backoff options for the getLicense call.
   * @param {number|undefined} numberOfRetry - Maximum of amount retried.
   * Equal to `2` if not defined.
   * @returns {Object}
   */
  function getLicenseBackoffOptions(numberOfRetry) {
    return {
      totalRetry: numberOfRetry !== null && numberOfRetry !== void 0 ? numberOfRetry : 2,
      baseDelay: 200,
      maxDelay: 3000,
      shouldRetry: function shouldRetry(error) {
        return error instanceof GetLicenseTimeoutError || (0,is_null_or_undefined/* default */.A)(error) || error.noRetry !== true;
      },
      onRetry: function onRetry(error) {
        return callbacks.onWarning(formatGetLicenseError(error));
      }
    };
  }
}
/**
 * Format an error returned by a `getLicense` call to a proper form as defined
 * by the RxPlayer's API.
 * @param {*} error
 * @returns {Error}
 */
function formatGetLicenseError(error) {
  if (error instanceof GetLicenseTimeoutError) {
    return new encrypted_media_error/* default */.A("KEY_LOAD_TIMEOUT", "The license server took too much time to " + "respond.");
  }
  var err = new encrypted_media_error/* default */.A("KEY_LOAD_ERROR", "An error occured when calling `getLicense`.");
  if (!(0,is_null_or_undefined/* default */.A)(error) && (0,is_non_empty_string/* default */.A)(error.message)) {
    err.message = error.message;
  }
  return err;
}
/**
 * Call MediaKeySession.update with the given `message`, if defined.
 * @param {MediaKeySession} session
 * @param {ArrayBuffer|TypedArray|null} message
 * @returns {Promise}
 */
function updateSessionWithMessage(_x2, _x3) {
  return _updateSessionWithMessage.apply(this, arguments);
}
/**
 * Error thrown when the MediaKeySession is blacklisted.
 * Such MediaKeySession should not be re-used but other MediaKeySession for the
 * same content can still be used.
 * @class BlacklistedSessionError
 * @extends Error
 */
function _updateSessionWithMessage() {
  _updateSessionWithMessage = (0,asyncToGenerator/* default */.A)( /*#__PURE__*/regenerator_default().mark(function _callee3(session, message) {
    var reason;
    return regenerator_default().wrap(function _callee3$(_context3) {
      while (1) switch (_context3.prev = _context3.next) {
        case 0:
          log/* default */.A.info("DRM: Updating MediaKeySession with message");
          _context3.prev = 1;
          _context3.next = 4;
          return session.update(message);
        case 4:
          _context3.next = 10;
          break;
        case 6:
          _context3.prev = 6;
          _context3.t0 = _context3["catch"](1);
          reason = _context3.t0 instanceof Error ? _context3.t0.toString() : "`session.update` failed";
          throw new encrypted_media_error/* default */.A("KEY_UPDATE_ERROR", reason);
        case 10:
          log/* default */.A.info("DRM: MediaKeySession update succeeded.");
        case 11:
        case "end":
          return _context3.stop();
      }
    }, _callee3, null, [[1, 6]]);
  }));
  return _updateSessionWithMessage.apply(this, arguments);
}
var BlacklistedSessionError = /*#__PURE__*/function (_Error) {
  function BlacklistedSessionError(sessionError) {
    var _this;
    _this = _Error.call(this, sessionError.message) || this;
    // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class
    Object.setPrototypeOf(_this, BlacklistedSessionError.prototype);
    _this.sessionError = sessionError;
    return _this;
  }
  (0,inheritsLoose/* default */.A)(BlacklistedSessionError, _Error);
  return BlacklistedSessionError;
}( /*#__PURE__*/(0,wrapNativeSuper/* default */.A)(Error));
/**
 * Error thrown when a `getLicense` call timeouts.
 * @class GetLicenseTimeoutError
 * @extends Error
 */
var GetLicenseTimeoutError = /*#__PURE__*/function (_Error2) {
  function GetLicenseTimeoutError(message) {
    var _this2;
    _this2 = _Error2.call(this, message) || this;
    // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class
    Object.setPrototypeOf(_this2, BlacklistedSessionError.prototype);
    _this2.message = message;
    return _this2;
  }
  (0,inheritsLoose/* default */.A)(GetLicenseTimeoutError, _Error2);
  return GetLicenseTimeoutError;
}( /*#__PURE__*/(0,wrapNativeSuper/* default */.A)(Error));
// EXTERNAL MODULE: ./src/errors/is_known_error.ts
var is_known_error = __webpack_require__(4637);
;// CONCATENATED MODULE: ./src/core/decrypt/set_server_certificate.ts


/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Call the setServerCertificate API with the given certificate.
 * Resolves on success, rejects on failure.
 *
 * TODO Handle returned value?
 * From the spec:
 *   - setServerCertificate resolves with true if everything worked
 *   - it resolves with false if the CDM does not support server
 *     certificates.
 *
 * @param {MediaKeys} mediaKeys
 * @param {ArrayBuffer} serverCertificate
 * @returns {Promise}
 */
function setServerCertificate(_x, _x2) {
  return _setServerCertificate.apply(this, arguments);
}
/**
 * Call the setCertificate API. If it fails just emit the error as warning
 * and complete.
 * @param {MediaKeys} mediaKeys
 * @param {ArrayBuffer} serverCertificate
 * @returns {Promise.<Object>}
 */
function _setServerCertificate() {
  _setServerCertificate = (0,asyncToGenerator/* default */.A)( /*#__PURE__*/regenerator_default().mark(function _callee(mediaKeys, serverCertificate) {
    var res, reason;
    return regenerator_default().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          _context.prev = 0;
          _context.next = 3;
          return mediaKeys.setServerCertificate(serverCertificate);
        case 3:
          res = _context.sent;
          return _context.abrupt("return", res);
        case 7:
          _context.prev = 7;
          _context.t0 = _context["catch"](0);
          log/* default */.A.warn("DRM: mediaKeys.setServerCertificate returned an error", _context.t0 instanceof Error ? _context.t0 : "");
          reason = _context.t0 instanceof Error ? _context.t0.toString() : "`setServerCertificate` error";
          throw new encrypted_media_error/* default */.A("LICENSE_SERVER_CERTIFICATE_ERROR", reason);
        case 12:
        case "end":
          return _context.stop();
      }
    }, _callee, null, [[0, 7]]);
  }));
  return _setServerCertificate.apply(this, arguments);
}
function trySettingServerCertificate(_x3, _x4) {
  return _trySettingServerCertificate.apply(this, arguments);
}
function _trySettingServerCertificate() {
  _trySettingServerCertificate = (0,asyncToGenerator/* default */.A)( /*#__PURE__*/regenerator_default().mark(function _callee2(mediaKeys, serverCertificate) {
    var result, formattedErr;
    return regenerator_default().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          if (!(server_certificate_store.hasOne(mediaKeys) === true)) {
            _context2.next = 3;
            break;
          }
          log/* default */.A.info("DRM: The MediaKeys already has a server certificate, skipping...");
          return _context2.abrupt("return", {
            type: "already-has-one"
          });
        case 3:
          if (!(typeof mediaKeys.setServerCertificate !== "function")) {
            _context2.next = 6;
            break;
          }
          log/* default */.A.warn("DRM: Could not set the server certificate." + " mediaKeys.setServerCertificate is not a function");
          return _context2.abrupt("return", {
            type: "method-not-implemented"
          });
        case 6:
          log/* default */.A.info("DRM: Setting server certificate on the MediaKeys");
          // Because of browser errors, or a user action that can lead to interrupting
          // server certificate setting, we might be left in a status where we don't
          // know if we attached the server certificate or not.
          // Calling `prepare` allow to invalidate temporarily that status.
          server_certificate_store.prepare(mediaKeys);
          _context2.prev = 8;
          _context2.next = 11;
          return setServerCertificate(mediaKeys, serverCertificate);
        case 11:
          result = _context2.sent;
          server_certificate_store.set(mediaKeys, serverCertificate);
          return _context2.abrupt("return", {
            type: "success",
            value: result
          });
        case 16:
          _context2.prev = 16;
          _context2.t0 = _context2["catch"](8);
          formattedErr = (0,is_known_error/* default */.A)(_context2.t0) ? _context2.t0 : new encrypted_media_error/* default */.A("LICENSE_SERVER_CERTIFICATE_ERROR", "Unknown error when setting the server certificate.");
          return _context2.abrupt("return", {
            type: "error",
            value: formattedErr
          });
        case 20:
        case "end":
          return _context2.stop();
      }
    }, _callee2, null, [[8, 16]]);
  }));
  return _trySettingServerCertificate.apply(this, arguments);
}

// EXTERNAL MODULE: ./src/core/decrypt/types.ts
var types = __webpack_require__(2137);
;// CONCATENATED MODULE: ./src/core/decrypt/utils/clean_old_stored_persistent_info.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Remove old information from a PersistentSessionsStore so that it respects the
 * given `limit` as a maximum size. This can be used to prevent its size from
 * growing indefinitely.
 *
 * This is needed because our persistent session information storage is
 * un-bounded in size, adding more data will just add more data without removing
 * the old one - which can be valid or invalid.
 *
 * This is problematic for at least two reasons:
 *   - This data is loaded into JS memory which is finite (and which maximum
 *     bounds depends on the user environment).
 *   - The final storage used (as chosen by the application using the RxPlayer)
 *     will in most cases have a maximum storage size.
 */
function cleanOldStoredPersistentInfo(persistentSessionsStore, limit) {
  if (isNaN(limit) || limit < 0 || limit >= persistentSessionsStore.getLength()) {
    return;
  }
  var numberOfPersistentSessions = persistentSessionsStore.getLength();
  var toDelete = numberOfPersistentSessions - limit;
  log/* default */.A.info("DRM: Too many stored persistent sessions, removing some.", numberOfPersistentSessions, toDelete);
  persistentSessionsStore.deleteOldSessions(toDelete);
}
;// CONCATENATED MODULE: ./src/core/decrypt/utils/get_drm_system_id.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @param {string} keySystem
 * @returns {string|undefined}
 */
function getDrmSystemId(keySystem) {
  if ((0,starts_with/* default */.A)(keySystem, "com.microsoft.playready") || keySystem === "com.chromecast.playready" || keySystem === "com.youtube.playready") {
    return "9a04f07998404286ab92e65be0885f95";
  }
  if (keySystem === "com.widevine.alpha") {
    return "edef8ba979d64acea3c827dcd51d21ed";
  }
  if ((0,starts_with/* default */.A)(keySystem, "com.apple.fps")) {
    return "94ce86fb07ff4f43adb893d2fa968ca2";
  }
  if ((0,starts_with/* default */.A)(keySystem, "com.nagra.")) {
    return "adb41c242dbf4a6d958b4457c0d27b95";
  }
  return undefined;
}
;// CONCATENATED MODULE: ./src/core/decrypt/utils/init_data_values_container.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Wrap initialization data values and reformat it so it becomes easier to check
 * compatibility with other `InitDataValuesContainer`.
 * @class InitDataValuesContainer
 */
var InitDataValuesContainer = /*#__PURE__*/function () {
  /**
   * Construct a new `InitDataValuesContainer`.
   * Note that the data is not formatted right away.
   * It is only really formatted lazily the first time we need it.
   *
   * @param {Array.<Object>} initDataValues
   */
  function InitDataValuesContainer(initDataValues) {
    this._innerValues = initDataValues;
    this._lazyFormattedValues = null;
  }
  /**
   * Construct data that should be given to the `generateRequest` EME API.
   * @returns {Uint8Array}
   */
  var _proto = InitDataValuesContainer.prototype;
  _proto.constructRequestData = function constructRequestData() {
    // `generateKeyRequest` awaits a single Uint8Array containing all
    // initialization data.
    return byte_parsing/* concat */.xW.apply(void 0, this._innerValues.map(function (i) {
      return i.data;
    }));
  }
  /**
   * Returns `true` if the given `InitDataValuesContainer` seems to be
   * "compatible" with the one stored in this instance.
   * Returns `false` if not.
   *
   * By "compatible" we mean that it will generate the same key request.
   * @param {InitDataValuesContainer | Object} initDataValues
   * @returns {boolean}
   */;
  _proto.isCompatibleWith = function isCompatibleWith(initDataValues) {
    var formatted = initDataValues instanceof InitDataValuesContainer ? initDataValues.getFormattedValues() : initDataValues;
    return areInitializationValuesCompatible(this.getFormattedValues(), formatted);
  }
  /**
   * Return the stored initialization data values, with added niceties:
   *   - they are sorted always the same way for similar
   *     `InitDataValuesContainer`
   *   - each value is associated to its hash, which is always done with  the
   *     same hashing function than for all other InitDataValuesContainer).
   *
   * The main point being to be able to compare much faster multiple
   * `InitDataValuesContainer`, though that data can also be used in any
   * other way.
   * @returns {Array.<Object>}
   */;
  _proto.getFormattedValues = function getFormattedValues() {
    if (this._lazyFormattedValues === null) {
      this._lazyFormattedValues = formatInitDataValues(this._innerValues);
    }
    return this._lazyFormattedValues;
  };
  return InitDataValuesContainer;
}();
/**
 * Format given initializationData's values so they are faster to compare:
 *   - sort them by systemId
 *   - add hash for each initialization data encountered.
 * @param {Array.<Object>} initialValues
 * @returns {Array.<Object>}
 */

function formatInitDataValues(initialValues) {
  return initialValues.slice().sort(function (a, b) {
    return a.systemId === b.systemId ? 0 : a.systemId === undefined ? 1 : b.systemId === undefined ? -1 : a.systemId < b.systemId ? -1 : 1;
  }).map(function (_ref) {
    var systemId = _ref.systemId,
      data = _ref.data;
    return {
      systemId: systemId,
      data: data,
      hash: hashBuffer(data)
    };
  });
}
;// CONCATENATED MODULE: ./src/core/decrypt/content_decryptor.ts


function content_decryptor_createForOfIteratorHelperLoose(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (t) return (t = t.call(r)).next.bind(t); if (Array.isArray(r) || (t = content_decryptor_unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var o = 0; return function () { return o >= r.length ? { done: !0 } : { done: !1, value: r[o++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function content_decryptor_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return content_decryptor_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? content_decryptor_arrayLikeToArray(r, a) : void 0; } }
function content_decryptor_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






















/**
 * Module communicating with the Content Decryption Module (or CDM) to be able
 * to decrypt contents.
 *
 * The `ContentDecryptor` starts communicating with the CDM, to initialize the
 * key system, as soon as it is created.
 *
 * You can be notified of various events, such as fatal errors, by registering
 * to one of its multiple events (@see IContentDecryptorEvent).
 *
 * @class ContentDecryptor
 */
var ContentDecryptor = /*#__PURE__*/function (_EventEmitter) {
  /**
   * Create a new `ContentDecryptor`, and initialize its decryption capabilities
   * right away.
   * Goes into the `WaitingForAttachment` state once that initialization is
   * done, after which you should call the `attach` method when you're ready for
   * those decryption capabilities to be attached to the HTMLMediaElement.
   *
   * @param {HTMLMediaElement} mediaElement - The MediaElement which will be
   * associated to a MediaKeys object
   * @param {Array.<Object>} ksOptions - key system configuration.
   * The `ContentDecryptor` can be given one or multiple key system
   * configurations. It will choose the appropriate one depending on user
   * settings and browser support.
   */
  function ContentDecryptor(mediaElement, ksOptions) {
    var _this;
    _this = _EventEmitter.call(this) || this;
    log/* default */.A.debug("DRM: Starting ContentDecryptor logic.");
    var canceller = new task_canceller/* default */.Ay();
    _this._currentSessions = [];
    _this._canceller = canceller;
    _this._initDataQueue = [];
    _this._stateData = {
      state: types/* ContentDecryptorState */.R.Initializing,
      isMediaKeysAttached: 0 /* MediaKeyAttachmentStatus.NotAttached */,
      isInitDataQueueLocked: true,
      data: null
    };
    _this.error = null;
    eme.onEncrypted(mediaElement, function (evt) {
      log/* default */.A.debug("DRM: Encrypted event received from media element.");
      var initData = getInitData(evt);
      if (initData !== null) {
        _this.onInitializationData(initData);
      }
    }, canceller.signal);
    initMediaKeys(mediaElement, ksOptions, canceller.signal).then(function (mediaKeysInfo) {
      var options = mediaKeysInfo.options,
        mediaKeySystemAccess = mediaKeysInfo.mediaKeySystemAccess;
      /**
       * String identifying the key system, allowing the rest of the code to
       * only advertise the required initialization data for license requests.
       *
       * Note that we only set this value if retro-compatibility to older
       * persistent logic in the RxPlayer is not important, as the
       * optimizations this property unlocks can break the loading of
       * MediaKeySessions persisted in older RxPlayer's versions.
       */
      var systemId;
      if ((0,is_null_or_undefined/* default */.A)(options.licenseStorage) || options.licenseStorage.disableRetroCompatibility === true) {
        systemId = getDrmSystemId(mediaKeySystemAccess.keySystem);
      }
      _this.systemId = systemId;
      if (_this._stateData.state === types/* ContentDecryptorState */.R.Initializing) {
        _this._stateData = {
          state: types/* ContentDecryptorState */.R.WaitingForAttachment,
          isInitDataQueueLocked: true,
          isMediaKeysAttached: 0 /* MediaKeyAttachmentStatus.NotAttached */,
          data: {
            mediaKeysInfo: mediaKeysInfo,
            mediaElement: mediaElement
          }
        };
        _this.trigger("stateChange", _this._stateData.state);
      }
    })["catch"](function (err) {
      _this._onFatalError(err);
    });
    return _this;
  }
  /**
   * Returns the current state of the ContentDecryptor.
   * @see ContentDecryptorState
   * @returns {Object}
   */
  (0,inheritsLoose/* default */.A)(ContentDecryptor, _EventEmitter);
  /**
   * `true` if the EME API are available on the current platform according to
   * the default EME implementation used.
   * `false` otherwise.
   * @returns {boolean}
   */
  ContentDecryptor.hasEmeApis = function hasEmeApis() {
    return !(0,is_null_or_undefined/* default */.A)(eme.requestMediaKeySystemAccess);
  };
  var _proto = ContentDecryptor.prototype;
  _proto.getState = function getState() {
    return this._stateData.state;
  }
  /**
   * Attach the current decryption capabilities to the HTMLMediaElement.
   * This method should only be called once the `ContentDecryptor` is in the
   * `WaitingForAttachment` state.
   *
   * You might want to first set the HTMLMediaElement's `src` attribute before
   * calling this method, and only push data to it once the `ReadyForContent`
   * state is reached, for compatibility reasons.
   */;
  _proto.attach = function attach() {
    var _this2 = this;
    if (this._stateData.state !== types/* ContentDecryptorState */.R.WaitingForAttachment) {
      throw new Error("`attach` should only be called when " + "in the WaitingForAttachment state");
    } else if (this._stateData.isMediaKeysAttached !== 0 /* MediaKeyAttachmentStatus.NotAttached */) {
      log/* default */.A.warn("DRM: ContentDecryptor's `attach` method called more than once.");
      return;
    }
    var _this$_stateData$data = this._stateData.data,
      mediaElement = _this$_stateData$data.mediaElement,
      mediaKeysInfo = _this$_stateData$data.mediaKeysInfo;
    var options = mediaKeysInfo.options,
      mediaKeys = mediaKeysInfo.mediaKeys,
      mediaKeySystemAccess = mediaKeysInfo.mediaKeySystemAccess,
      stores = mediaKeysInfo.stores,
      askedConfiguration = mediaKeysInfo.askedConfiguration;
    var shouldDisableLock = options.disableMediaKeysAttachmentLock === true;
    if (shouldDisableLock) {
      this._stateData = {
        state: types/* ContentDecryptorState */.R.ReadyForContent,
        isInitDataQueueLocked: true,
        isMediaKeysAttached: 1 /* MediaKeyAttachmentStatus.Pending */,
        data: {
          mediaKeysInfo: mediaKeysInfo,
          mediaElement: mediaElement
        }
      };
      this.trigger("stateChange", this._stateData.state);
      // previous trigger might have lead to disposal
      if (this._isStopped()) {
        return;
      }
    }
    this._stateData.isMediaKeysAttached = 1 /* MediaKeyAttachmentStatus.Pending */;
    var stateToAttach = {
      emeImplementation: eme,
      loadedSessionsStore: stores.loadedSessionsStore,
      mediaKeySystemAccess: mediaKeySystemAccess,
      mediaKeys: mediaKeys,
      askedConfiguration: askedConfiguration,
      keySystemOptions: options
    };
    log/* default */.A.debug("DRM: Attaching current MediaKeys");
    attachMediaKeys(mediaElement, stateToAttach, this._canceller.signal).then( /*#__PURE__*/(0,asyncToGenerator/* default */.A)( /*#__PURE__*/regenerator_default().mark(function _callee() {
      var serverCertificate, resSsc, prevState;
      return regenerator_default().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            _this2._stateData.isMediaKeysAttached = 2 /* MediaKeyAttachmentStatus.Attached */;
            serverCertificate = options.serverCertificate;
            if ((0,is_null_or_undefined/* default */.A)(serverCertificate)) {
              _context.next = 7;
              break;
            }
            _context.next = 5;
            return trySettingServerCertificate(mediaKeys, serverCertificate);
          case 5:
            resSsc = _context.sent;
            if (resSsc.type === "error") {
              _this2.trigger("warning", resSsc.value);
            }
          case 7:
            if (!_this2._isStopped()) {
              _context.next = 9;
              break;
            }
            return _context.abrupt("return");
          case 9:
            prevState = _this2._stateData.state;
            _this2._stateData = {
              state: types/* ContentDecryptorState */.R.ReadyForContent,
              isMediaKeysAttached: 2 /* MediaKeyAttachmentStatus.Attached */,
              isInitDataQueueLocked: false,
              data: {
                mediaKeysData: mediaKeysInfo
              }
            };
            if (prevState !== types/* ContentDecryptorState */.R.ReadyForContent) {
              _this2.trigger("stateChange", types/* ContentDecryptorState */.R.ReadyForContent);
            }
            if (!_this2._isStopped()) {
              _this2._processCurrentInitDataQueue();
            }
          case 13:
          case "end":
            return _context.stop();
        }
      }, _callee);
    })))["catch"](function (err) {
      _this2._onFatalError(err);
    });
  }
  /**
   * Stop this `ContentDecryptor` instance:
   *   - stop listening and reacting to the various event listeners
   *   - abort all operations.
   *
   * Once disposed, a `ContentDecryptor` cannot be used anymore.
   */;
  _proto.dispose = function dispose() {
    this.removeEventListener();
    this._stateData = {
      state: types/* ContentDecryptorState */.R.Disposed,
      isMediaKeysAttached: undefined,
      isInitDataQueueLocked: undefined,
      data: null
    };
    this._canceller.cancel();
    this.trigger("stateChange", this._stateData.state);
  }
  /**
   * Method to call when new protection initialization data is encounted on the
   * content.
   *
   * When called, the `ContentDecryptor` will try to obtain the decryption key
   * if not already obtained.
   *
   * @param {Object} initializationData
   */;
  _proto.onInitializationData = function onInitializationData(initializationData) {
    var _this3 = this;
    if (this._stateData.isInitDataQueueLocked !== false) {
      if (this._isStopped()) {
        throw new Error("ContentDecryptor either disposed or stopped.");
      }
      this._initDataQueue.push(initializationData);
      return;
    }
    var mediaKeysData = this._stateData.data.mediaKeysData;
    var processedInitializationData = Object.assign(Object.assign({}, initializationData), {
      values: new InitDataValuesContainer(initializationData.values)
    });
    this._processInitializationData(processedInitializationData, mediaKeysData)["catch"](function (err) {
      _this3._onFatalError(err);
    });
  }
  /**
   * Async logic run each time new initialization data has to be processed.
   * The promise return may reject, in which case a fatal error should be linked
   * the current `ContentDecryptor`.
   *
   * The Promise's resolution however provides no semantic value.
   * @param {Object} initializationData
   * @returns {Promise.<void>}
   */;
  _proto._processInitializationData =
  /*#__PURE__*/
  function () {
    var _processInitializationData2 = (0,asyncToGenerator/* default */.A)( /*#__PURE__*/regenerator_default().mark(function _callee2(initializationData, mediaKeysData) {
      var _this4 = this;
      var mediaKeySystemAccess, stores, options, firstCreatedSession, keyIds, hexKids, period, createdSessions, periodKeys, _iterator, _step, createdSess, periodKeysArr, _i, _periodKeysArr, kid, _loop, _iterator2, _step2, wantedSessionType, _config$getCurrent, EME_DEFAULT_MAX_SIMULTANEOUS_MEDIA_KEY_SESSIONS, EME_MAX_STORED_PERSISTENT_SESSION_INFORMATION, maxSessionCacheSize, sessionRes, sessionInfo, _sessionRes$value, mediaKeySession, sessionType, isSessionPersisted, requestData, entry, indexInCurrent;
      return regenerator_default().wrap(function _callee2$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            mediaKeySystemAccess = mediaKeysData.mediaKeySystemAccess, stores = mediaKeysData.stores, options = mediaKeysData.options;
            if (!(this._tryToUseAlreadyCreatedSession(initializationData, mediaKeysData) || this._isStopped())) {
              _context3.next = 3;
              break;
            }
            return _context3.abrupt("return");
          case 3:
            if (!(options.singleLicensePer === "content")) {
              _context3.next = 15;
              break;
            }
            firstCreatedSession = (0,array_find/* default */.A)(this._currentSessions, function (x) {
              return x.source === "created-session";
            } /* MediaKeySessionLoadingType.Created */);
            if (!(firstCreatedSession !== undefined)) {
              _context3.next = 13;
              break;
            }
            // We already fetched a `singleLicensePer: "content"` license, yet we
            // could not use the already-created MediaKeySession with it.
            // It means that we'll never handle it and we should thus blacklist it.
            keyIds = initializationData.keyIds;
            if (!(keyIds === undefined)) {
              _context3.next = 10;
              break;
            }
            if (initializationData.content === undefined) {
              log/* default */.A.warn("DRM: Unable to fallback from a non-decipherable quality.");
            } else {
              blackListProtectionData(initializationData.content.manifest, initializationData);
            }
            return _context3.abrupt("return");
          case 10:
            firstCreatedSession.record.associateKeyIds(keyIds);
            if (initializationData.content !== undefined) {
              if (log/* default */.A.hasLevel("DEBUG")) {
                hexKids = keyIds.reduce(function (acc, kid) {
                  return acc + ", " + (0,string_parsing/* bytesToHex */.My)(kid);
                }, "");
                log/* default */.A.debug("DRM: Blacklisting new key ids", hexKids);
              }
              updateDecipherability(initializationData.content.manifest, [], keyIds, []);
            }
            return _context3.abrupt("return");
          case 13:
            _context3.next = 42;
            break;
          case 15:
            if (!(options.singleLicensePer === "periods" && initializationData.content !== undefined)) {
              _context3.next = 42;
              break;
            }
            period = initializationData.content.period;
            createdSessions = this._currentSessions.filter(function (x) {
              return x.source === "created-session";
            } /* MediaKeySessionLoadingType.Created */);
            periodKeys = new Set();
            addKeyIdsFromPeriod(periodKeys, period);
            _iterator = content_decryptor_createForOfIteratorHelperLoose(createdSessions);
          case 21:
            if ((_step = _iterator()).done) {
              _context3.next = 42;
              break;
            }
            createdSess = _step.value;
            periodKeysArr = Array.from(periodKeys);
            _i = 0, _periodKeysArr = periodKeysArr;
          case 25:
            if (!(_i < _periodKeysArr.length)) {
              _context3.next = 40;
              break;
            }
            kid = _periodKeysArr[_i];
            if (!createdSess.record.isAssociatedWithKeyId(kid)) {
              _context3.next = 37;
              break;
            }
            createdSess.record.associateKeyIds(periodKeys.values());
            // Re-loop through the Period's key ids to blacklist ones that are missing
            // from `createdSess`'s `keyStatuses` and to update the content's
            // decipherability.
            _loop = /*#__PURE__*/regenerator_default().mark(function _loop() {
              var innerKid;
              return regenerator_default().wrap(function _loop$(_context2) {
                while (1) switch (_context2.prev = _context2.next) {
                  case 0:
                    innerKid = _step2.value;
                    if (!createdSess.keyStatuses.whitelisted.some(function (k) {
                      return (0,are_arrays_of_numbers_equal/* default */.A)(k, innerKid);
                    }) && !createdSess.keyStatuses.blacklisted.some(function (k) {
                      return (0,are_arrays_of_numbers_equal/* default */.A)(k, innerKid);
                    })) {
                      createdSess.keyStatuses.blacklisted.push(innerKid);
                    }
                  case 2:
                  case "end":
                    return _context2.stop();
                }
              }, _loop);
            });
            _iterator2 = content_decryptor_createForOfIteratorHelperLoose(periodKeysArr);
          case 31:
            if ((_step2 = _iterator2()).done) {
              _context3.next = 35;
              break;
            }
            return _context3.delegateYield(_loop(), "t0", 33);
          case 33:
            _context3.next = 31;
            break;
          case 35:
            updateDecipherability(initializationData.content.manifest, createdSess.keyStatuses.whitelisted, createdSess.keyStatuses.blacklisted, []);
            return _context3.abrupt("return");
          case 37:
            _i++;
            _context3.next = 25;
            break;
          case 40:
            _context3.next = 21;
            break;
          case 42:
            // /!\ Do not forget to unlock when done
            // TODO this is error-prone and can lead to performance issue when loading
            // persistent sessions.
            // Can we find a better strategy?
            this._lockInitDataQueue();
            if (options.persistentLicense !== true) {
              wantedSessionType = "temporary";
            } else if (!canCreatePersistentSession(mediaKeySystemAccess)) {
              log/* default */.A.warn('DRM: Cannot create "persistent-license" session: not supported');
              wantedSessionType = "temporary";
            } else {
              wantedSessionType = "persistent-license";
            }
            _config$getCurrent = config/* default */.A.getCurrent(), EME_DEFAULT_MAX_SIMULTANEOUS_MEDIA_KEY_SESSIONS = _config$getCurrent.EME_DEFAULT_MAX_SIMULTANEOUS_MEDIA_KEY_SESSIONS, EME_MAX_STORED_PERSISTENT_SESSION_INFORMATION = _config$getCurrent.EME_MAX_STORED_PERSISTENT_SESSION_INFORMATION;
            maxSessionCacheSize = typeof options.maxSessionCacheSize === "number" ? options.maxSessionCacheSize : EME_DEFAULT_MAX_SIMULTANEOUS_MEDIA_KEY_SESSIONS;
            _context3.next = 48;
            return createOrLoadSession(initializationData, stores, wantedSessionType, maxSessionCacheSize, this._canceller.signal);
          case 48:
            sessionRes = _context3.sent;
            if (!this._isStopped()) {
              _context3.next = 51;
              break;
            }
            return _context3.abrupt("return");
          case 51:
            sessionInfo = {
              record: sessionRes.value.keySessionRecord,
              source: sessionRes.type,
              keyStatuses: {
                whitelisted: [],
                blacklisted: []
              },
              blacklistedSessionError: null
            };
            this._currentSessions.push(sessionInfo);
            _sessionRes$value = sessionRes.value, mediaKeySession = _sessionRes$value.mediaKeySession, sessionType = _sessionRes$value.sessionType;
            /**
             * We only store persistent sessions once its keys are known.
             * This boolean allows to know if this session has already been
             * persisted or not.
             */
            isSessionPersisted = false;
            SessionEventsListener(mediaKeySession, options, mediaKeySystemAccess.keySystem, {
              onKeyUpdate: function onKeyUpdate(value) {
                var linkedKeys = getKeyIdsLinkedToSession(initializationData, sessionInfo.record, options.singleLicensePer, sessionInfo.source === "created-session" /* MediaKeySessionLoadingType.Created */, value.whitelistedKeyIds, value.blacklistedKeyIds);
                sessionInfo.record.associateKeyIds(linkedKeys.whitelisted);
                sessionInfo.record.associateKeyIds(linkedKeys.blacklisted);
                sessionInfo.keyStatuses = {
                  whitelisted: linkedKeys.whitelisted,
                  blacklisted: linkedKeys.blacklisted
                };
                if (sessionInfo.record.getAssociatedKeyIds().length !== 0 && sessionType === "persistent-license" && stores.persistentSessionsStore !== null && !isSessionPersisted) {
                  var persistentSessionsStore = stores.persistentSessionsStore;
                  cleanOldStoredPersistentInfo(persistentSessionsStore, EME_MAX_STORED_PERSISTENT_SESSION_INFORMATION - 1);
                  persistentSessionsStore.add(initializationData, sessionInfo.record.getAssociatedKeyIds(), mediaKeySession);
                  isSessionPersisted = true;
                }
                if (initializationData.content !== undefined) {
                  updateDecipherability(initializationData.content.manifest, linkedKeys.whitelisted, linkedKeys.blacklisted, []);
                }
                _this4._unlockInitDataQueue();
              },
              onWarning: function onWarning(value) {
                _this4.trigger("warning", value);
              },
              onError: function onError(err) {
                var _a;
                if (err instanceof DecommissionedSessionError) {
                  log/* default */.A.warn("DRM: A session's closing condition has been triggered");
                  _this4._lockInitDataQueue();
                  var indexOf = _this4._currentSessions.indexOf(sessionInfo);
                  if (indexOf >= 0) {
                    _this4._currentSessions.splice(indexOf);
                  }
                  if (initializationData.content !== undefined) {
                    updateDecipherability(initializationData.content.manifest, [], [], sessionInfo.record.getAssociatedKeyIds());
                  }
                  (_a = stores.persistentSessionsStore) === null || _a === void 0 ? void 0 : _a["delete"](mediaKeySession.sessionId);
                  stores.loadedSessionsStore.closeSession(mediaKeySession)["catch"](function (e) {
                    var closeError = e instanceof Error ? e : "unknown error";
                    log/* default */.A.warn("DRM: failed to close expired session", closeError);
                  }).then(function () {
                    return _this4._unlockInitDataQueue();
                  })["catch"](function (retryError) {
                    return _this4._onFatalError(retryError);
                  });
                  if (!_this4._isStopped()) {
                    _this4.trigger("warning", err.reason);
                  }
                  return;
                }
                if (!(err instanceof BlacklistedSessionError)) {
                  _this4._onFatalError(err);
                  return;
                }
                sessionInfo.blacklistedSessionError = err;
                if (initializationData.content !== undefined) {
                  var manifest = initializationData.content.manifest;
                  log/* default */.A.info("DRM: blacklisting Representations based on " + "protection data.");
                  blackListProtectionData(manifest, initializationData);
                }
                _this4._unlockInitDataQueue();
                // TODO warning for blacklisted session?
              }
            }, this._canceller.signal);
            if (options.singleLicensePer === undefined || options.singleLicensePer === "init-data") {
              this._unlockInitDataQueue();
            }
            if (!(sessionRes.type === "created-session" /* MediaKeySessionLoadingType.Created */)) {
              _context3.next = 72;
              break;
            }
            requestData = initializationData.values.constructRequestData();
            _context3.prev = 59;
            _context3.next = 62;
            return stores.loadedSessionsStore.generateLicenseRequest(mediaKeySession, initializationData.type, requestData);
          case 62:
            _context3.next = 72;
            break;
          case 64:
            _context3.prev = 64;
            _context3.t1 = _context3["catch"](59);
            // First check that the error was not due to the MediaKeySession closing
            // or being closed
            entry = stores.loadedSessionsStore.getEntryForSession(mediaKeySession);
            if (!(entry === null || entry.closingStatus.type !== "none")) {
              _context3.next = 71;
              break;
            }
            // MediaKeySession closing/closed: Just remove from handled list and abort.
            indexInCurrent = this._currentSessions.indexOf(sessionInfo);
            if (indexInCurrent >= 0) {
              this._currentSessions.splice(indexInCurrent, 1);
            }
            return _context3.abrupt("return", Promise.resolve());
          case 71:
            throw new encrypted_media_error/* default */.A("KEY_GENERATE_REQUEST_ERROR", _context3.t1 instanceof Error ? _context3.t1.toString() : "Unknown error");
          case 72:
            return _context3.abrupt("return", Promise.resolve());
          case 73:
          case "end":
            return _context3.stop();
        }
      }, _callee2, this, [[59, 64]]);
    }));
    function _processInitializationData(_x, _x2) {
      return _processInitializationData2.apply(this, arguments);
    }
    return _processInitializationData;
  }();
  _proto._tryToUseAlreadyCreatedSession = function _tryToUseAlreadyCreatedSession(initializationData, mediaKeysData) {
    var stores = mediaKeysData.stores,
      options = mediaKeysData.options;
    /**
     * If set, a currently-used key session is already compatible to this
     * initialization data.
     */
    var compatibleSessionInfo = (0,array_find/* default */.A)(this._currentSessions, function (x) {
      return x.record.isCompatibleWith(initializationData);
    });
    if (compatibleSessionInfo === undefined) {
      return false;
    }
    /**
     * On Safari using Directfile, the old EME implementation triggers
     * the "webkitneedkey" event instead of "encrypted". There's an issue in
     * Safari where "webkitneedkey" fires too early before all tracks are added
     * from an HLS playlist.
     * Safari incorrectly assumes some keys are missing for these tracks,
     * leading to repeated "webkitneedkey" events. Because RxPlayer recognizes
     * it already has a session for these keys and ignores the events,
     * the content remains frozen. To resolve this, the session is re-created.
     */
    var forceSessionRecreation = initializationData.forceSessionRecreation;
    if (forceSessionRecreation === true) {
      this.removeSessionForInitData(initializationData, mediaKeysData);
      return false;
    }
    // Check if the compatible session is blacklisted
    var blacklistedSessionError = compatibleSessionInfo.blacklistedSessionError;
    if (!(0,is_null_or_undefined/* default */.A)(blacklistedSessionError)) {
      if (initializationData.type === undefined || initializationData.content === undefined) {
        log/* default */.A.error("DRM: This initialization data has already been blacklisted " + "but the current content is not known.");
        return true;
      } else {
        log/* default */.A.info("DRM: This initialization data has already been blacklisted. " + "Blacklisting the related content.");
        var manifest = initializationData.content.manifest;
        blackListProtectionData(manifest, initializationData);
        return true;
      }
    }
    // Check if the current key id(s) has been blacklisted by this session
    if (initializationData.keyIds !== undefined) {
      /**
       * If set to `true`, the Representation(s) linked to this
       * initialization data's key id should be marked as "not decipherable".
       */
      var isUndecipherable;
      if (options.singleLicensePer === undefined || options.singleLicensePer === "init-data") {
        // Note: In the default "init-data" mode, we only avoid a
        // Representation if the key id was originally explicitely
        // blacklisted (and not e.g. if its key was just not present in
        // the license).
        //
        // This is to enforce v3.x.x retro-compatibility: we cannot
        // fallback from a Representation unless some RxPlayer option
        // documentating this behavior has been set.
        var blacklisted = compatibleSessionInfo.keyStatuses.blacklisted;
        isUndecipherable = areSomeKeyIdsContainedIn(initializationData.keyIds, blacklisted);
      } else {
        // In any other mode, as soon as not all of this initialization
        // data's linked key ids are explicitely whitelisted, we can mark
        // the corresponding Representation as "not decipherable".
        // This is because we've no such retro-compatibility guarantee to
        // make there.
        var whitelisted = compatibleSessionInfo.keyStatuses.whitelisted;
        isUndecipherable = !areAllKeyIdsContainedIn(initializationData.keyIds, whitelisted);
      }
      if (isUndecipherable) {
        if (initializationData.content === undefined) {
          log/* default */.A.error("DRM: Cannot forbid key id, the content is unknown.");
          return true;
        }
        log/* default */.A.info("DRM: Current initialization data is linked to blacklisted keys. " + "Marking Representations as not decipherable");
        updateDecipherability(initializationData.content.manifest, [], initializationData.keyIds, []);
        return true;
      }
    }
    // If we reached here, it means that this initialization data is not
    // blacklisted in any way.
    // Search loaded session and put it on top of the cache if it exists.
    var entry = stores.loadedSessionsStore.reuse(initializationData);
    if (entry !== null) {
      // TODO update decipherability to `true` if not?
      log/* default */.A.debug("DRM: Init data already processed. Skipping it.");
      return true;
    }
    // Session not found in `loadedSessionsStore`, it might have been closed
    // since.
    // Remove from `this._currentSessions` and start again.
    var indexOf = this._currentSessions.indexOf(compatibleSessionInfo);
    if (indexOf === -1) {
      log/* default */.A.error("DRM: Unable to remove processed init data: not found.");
    } else {
      log/* default */.A.debug("DRM: A session from a processed init data is not available " + "anymore. Re-processing it.");
      this._currentSessions.splice(indexOf, 1);
    }
    return false;
  }
  /**
   * Remove the session corresponding to the initData provided, and close it.
   * It does nothing if no session was found for this initData.
   * @param {Object} initData : The initialization data corresponding to the session
   * that need to be removed
   * @param {Object} mediaKeysData : The media keys data
   */;
  _proto.removeSessionForInitData = function removeSessionForInitData(initData, mediaKeysData) {
    var stores = mediaKeysData.stores;
    /** Remove the session and close it from the loadedSessionStore */
    var entry = stores.loadedSessionsStore.reuse(initData);
    if (entry !== null) {
      stores.loadedSessionsStore.closeSession(entry.mediaKeySession)["catch"](function () {
        return log/* default */.A.error("DRM: Cannot close the session from the loaded session store");
      });
    }
    /**
     * If set, a currently-used key session is already compatible to this
     * initialization data.
     */
    var compatibleSessionInfo = (0,array_find/* default */.A)(this._currentSessions, function (x) {
      return x.record.isCompatibleWith(initData);
    });
    if (compatibleSessionInfo === undefined) {
      return;
    }
    /** Remove the session from the currentSessions */
    var indexOf = this._currentSessions.indexOf(compatibleSessionInfo);
    if (indexOf !== -1) {
      log/* default */.A.debug("DRM: A session from a processed init is removed " + "due to forceSessionRecreation policy.");
      this._currentSessions.splice(indexOf, 1);
    }
  }
  /**
   * Callback that should be called if an error that made the current
   * `ContentDecryptor` instance unusable arised.
   * This callbacks takes care of resetting state and sending the right events.
   *
   * Once called, no further actions should be taken.
   *
   * @param {*} err - The error object which describes the issue. Will be
   * formatted and sent in an "error" event.
   */;
  _proto._onFatalError = function _onFatalError(err) {
    if (this._canceller.isUsed()) {
      return;
    }
    var formattedErr = err instanceof Error ? err : new other_error/* default */.A("NONE", "Unknown decryption error");
    this.error = formattedErr;
    this._initDataQueue.length = 0;
    this._stateData = {
      state: types/* ContentDecryptorState */.R.Error,
      isMediaKeysAttached: undefined,
      isInitDataQueueLocked: undefined,
      data: null
    };
    this._canceller.cancel();
    this.trigger("error", formattedErr);
    // The previous trigger might have lead to a disposal of the `ContentDecryptor`.
    if (this._stateData.state === types/* ContentDecryptorState */.R.Error) {
      this.trigger("stateChange", this._stateData.state);
    }
  }
  /**
   * Return `true` if the `ContentDecryptor` has either been disposed or
   * encountered a fatal error which made it stop.
   * @returns {boolean}
   */;
  _proto._isStopped = function _isStopped() {
    return this._stateData.state === types/* ContentDecryptorState */.R.Disposed || this._stateData.state === types/* ContentDecryptorState */.R.Error;
  }
  /**
   * Start processing the next initialization data of the `_initDataQueue` if it
   * isn't lock.
   */;
  _proto._processCurrentInitDataQueue = function _processCurrentInitDataQueue() {
    while (this._stateData.isInitDataQueueLocked === false) {
      var initData = this._initDataQueue.shift();
      if (initData === undefined) {
        return;
      }
      this.onInitializationData(initData);
    }
  }
  /**
   * Lock new initialization data (from the `_initDataQueue`) from being
   * processed until `_unlockInitDataQueue` is called.
   *
   * You may want to call this method when performing operations which may have
   * an impact on the handling of other initialization data.
   */;
  _proto._lockInitDataQueue = function _lockInitDataQueue() {
    if (this._stateData.isInitDataQueueLocked === false) {
      this._stateData.isInitDataQueueLocked = true;
    }
  }
  /**
   * Unlock `_initDataQueue` and start processing the first element.
   *
   * Should have no effect if the `_initDataQueue` was not locked.
   */;
  _proto._unlockInitDataQueue = function _unlockInitDataQueue() {
    if (this._stateData.isMediaKeysAttached !== 2 /* MediaKeyAttachmentStatus.Attached */) {
      log/* default */.A.error("DRM: Trying to unlock in the wrong state");
      return;
    }
    this._stateData.isInitDataQueueLocked = false;
    this._processCurrentInitDataQueue();
  };
  return ContentDecryptor;
}(event_emitter/* default */.A);
/**
 * Returns `true` if the given MediaKeySystemAccess can create
 * "persistent-license" MediaKeySessions.
 * @param {MediaKeySystemAccess} mediaKeySystemAccess
 * @returns {Boolean}
 */

function canCreatePersistentSession(mediaKeySystemAccess) {
  var _mediaKeySystemAccess = mediaKeySystemAccess.getConfiguration(),
    sessionTypes = _mediaKeySystemAccess.sessionTypes;
  return sessionTypes !== undefined && (0,array_includes/* default */.A)(sessionTypes, "persistent-license");
}
/**
 * Change the decipherability of Representations which have their key id in one
 * of the given Arrays:
 *
 *   - Those who have a key id listed in `whitelistedKeyIds` will have their
 *     decipherability updated to `true`
 *
 *   - Those who have a key id listed in `blacklistedKeyIds` will have their
 *     decipherability updated to `false`
 *
 *   - Those who have a key id listed in `delistedKeyIds` will have their
 *     decipherability updated to `undefined`.
 *
 * @param {Object} manifest
 * @param {Array.<Uint8Array>} whitelistedKeyIds
 * @param {Array.<Uint8Array>} blacklistedKeyIds
 * @param {Array.<Uint8Array>} delistedKeyIds
 */
function updateDecipherability(manifest, whitelistedKeyIds, blacklistedKeyIds, delistedKeyIds) {
  manifest.updateRepresentationsDeciperability(function (representation) {
    if (representation.contentProtections === undefined) {
      return representation.decipherable;
    }
    var contentKIDs = representation.contentProtections.keyIds;
    if (contentKIDs !== undefined) {
      for (var _iterator3 = content_decryptor_createForOfIteratorHelperLoose(contentKIDs), _step3; !(_step3 = _iterator3()).done;) {
        var elt = _step3.value;
        for (var _iterator4 = content_decryptor_createForOfIteratorHelperLoose(blacklistedKeyIds), _step4; !(_step4 = _iterator4()).done;) {
          var blacklistedKeyId = _step4.value;
          if ((0,are_arrays_of_numbers_equal/* default */.A)(blacklistedKeyId, elt.keyId)) {
            return false;
          }
        }
        for (var _iterator5 = content_decryptor_createForOfIteratorHelperLoose(whitelistedKeyIds), _step5; !(_step5 = _iterator5()).done;) {
          var whitelistedKeyId = _step5.value;
          if ((0,are_arrays_of_numbers_equal/* default */.A)(whitelistedKeyId, elt.keyId)) {
            return true;
          }
        }
        for (var _iterator6 = content_decryptor_createForOfIteratorHelperLoose(delistedKeyIds), _step6; !(_step6 = _iterator6()).done;) {
          var delistedKeyId = _step6.value;
          if ((0,are_arrays_of_numbers_equal/* default */.A)(delistedKeyId, elt.keyId)) {
            return undefined;
          }
        }
      }
    }
    return representation.decipherable;
  });
}
/**
 * Update decipherability to `false` to any Representation which is linked to
 * the given initialization data.
 * @param {Object} manifest
 * @param {Object} initData
 */
function blackListProtectionData(manifest, initData) {
  manifest.updateRepresentationsDeciperability(function (representation) {
    var _a, _b;
    if (representation.decipherable === false) {
      return false;
    }
    var segmentProtections = (_b = (_a = representation.contentProtections) === null || _a === void 0 ? void 0 : _a.initData) !== null && _b !== void 0 ? _b : [];
    var _loop2 = function _loop2() {
        var protection = _step7.value;
        if (initData.type === undefined || protection.type === initData.type) {
          var containedInitData = initData.values.getFormattedValues().every(function (undecipherableVal) {
            return protection.values.some(function (currVal) {
              return (undecipherableVal.systemId === undefined || currVal.systemId === undecipherableVal.systemId) && (0,are_arrays_of_numbers_equal/* default */.A)(currVal.data, undecipherableVal.data);
            });
          });
          if (containedInitData) {
            return {
              v: false
            };
          }
        }
      },
      _ret;
    for (var _iterator7 = content_decryptor_createForOfIteratorHelperLoose(segmentProtections), _step7; !(_step7 = _iterator7()).done;) {
      _ret = _loop2();
      if (_ret) return _ret.v;
    }
    return representation.decipherable;
  });
}
/**
 * Returns set of all usable and unusable keys - explicit or implicit - that are
 * linked to a `MediaKeySession`.
 *
 * In the RxPlayer, there is a concept of "explicit" key ids, which are key ids
 * found in a license whose status can be known through the `keyStatuses`
 * property from a `MediaKeySession`, and of "implicit" key ids, which are key
 * ids which were expected to be in a fetched license, but apparently weren't.
 *
 * @param {Object} initializationData - Initialization data object used to make
 * the request for the current license.
 * @param {Object} keySessionRecord - The `KeySessionRecord` associated with the
 * session that has been loaded. It might give supplementary information on
 * keys implicitly linked to the license.
 * @param {string|undefined} singleLicensePer - Setting allowing to indicate the
 * scope a given license should have.
 * @param {boolean} isCurrentLicense - If `true` the license has been fetched
 * especially for the current content.
 *
 * Knowing this allows to determine that if decryption keys that should have
 * been referenced in the fetched license (according to the `singleLicensePer`
 * setting) are missing, then the keys surely must have been voluntarly
 * removed from the license.
 *
 * If it is however set to `false`, it means that the license is an older
 * license that might have been linked to another content, thus we cannot make
 * that assumption.
 * @param {Array.<Uint8Array>} usableKeyIds - Key ids that are present in the
 * license and can be used.
 * @param {Array.<Uint8Array>} unusableKeyIds - Key ids that are present in the
 * license yet cannot be used.
 * @returns {Object} - Returns an object with the following properties:
 *   - `whitelisted`: Array of key ids for keys that are known to be usable
 *   - `blacklisted`: Array of key ids for keys that are considered unusable.
 *     The qualities linked to those keys should not be played.
 */
function getKeyIdsLinkedToSession(initializationData, keySessionRecord, singleLicensePer, isCurrentLicense, usableKeyIds, unusableKeyIds) {
  var _a;
  /**
   * Every key id associated with the MediaKeySession, starting with
   * whitelisted ones.
   */
  var associatedKeyIds = [].concat(usableKeyIds, unusableKeyIds);
  // Add all key ids associated to the `KeySessionRecord` yet not in
  // `usableKeyIds` nor in `unusableKeyIds`
  var allKnownKeyIds = keySessionRecord.getAssociatedKeyIds();
  var _loop4 = function _loop4() {
    var kid = _step8.value;
    if (!associatedKeyIds.some(function (ak) {
      return (0,are_arrays_of_numbers_equal/* default */.A)(ak, kid);
    })) {
      if (log/* default */.A.hasLevel("DEBUG")) {
        log/* default */.A.debug("DRM: KeySessionRecord's key missing in the license, blacklisting it", (0,string_parsing/* bytesToHex */.My)(kid));
      }
      associatedKeyIds.push(kid);
    }
  };
  for (var _iterator8 = content_decryptor_createForOfIteratorHelperLoose(allKnownKeyIds), _step8; !(_step8 = _iterator8()).done;) {
    _loop4();
  }
  if (singleLicensePer !== undefined && singleLicensePer !== "init-data") {
    // We want to add the current key ids in the blacklist if it is
    // not already there.
    //
    // We only do that when `singleLicensePer` is set to something
    // else than the default `"init-data"` because this logic:
    //   1. might result in a quality fallback, which is a v3.x.x
    //      breaking change if some APIs (like `singleLicensePer`)
    //      aren't used.
    //   2. Rely on the EME spec regarding key statuses being well
    //      implemented on all supported devices, which we're not
    //      sure yet. Because in any other `singleLicensePer`, we
    //      need a good implementation anyway, it doesn't matter
    //      there.
    var expectedKeyIds = initializationData.keyIds,
      content = initializationData.content;
    if (expectedKeyIds !== undefined) {
      var missingKeyIds = expectedKeyIds.filter(function (expected) {
        return !associatedKeyIds.some(function (k) {
          return (0,are_arrays_of_numbers_equal/* default */.A)(k, expected);
        });
      });
      if (missingKeyIds.length > 0) {
        if (log/* default */.A.hasLevel("DEBUG")) {
          log/* default */.A.debug("DRM: init data keys missing in the license, blacklisting them", missingKeyIds.map(function (m) {
            return (0,string_parsing/* bytesToHex */.My)(m);
          }).join(", "));
        }
        associatedKeyIds.push.apply(associatedKeyIds, missingKeyIds);
      }
    }
    if (isCurrentLicense && content !== undefined) {
      if (singleLicensePer === "content") {
        // Put it in a Set to automatically filter out duplicates (by ref)
        var contentKeys = new Set();
        var manifest = content.manifest;
        for (var _iterator9 = content_decryptor_createForOfIteratorHelperLoose(manifest.periods), _step9; !(_step9 = _iterator9()).done;) {
          var period = _step9.value;
          addKeyIdsFromPeriod(contentKeys, period);
        }
        mergeKeyIdSetIntoArray(contentKeys, associatedKeyIds);
      } else if (singleLicensePer === "periods") {
        var _manifest = content.manifest;
        for (var _iterator10 = content_decryptor_createForOfIteratorHelperLoose(_manifest.periods), _step10; !(_step10 = _iterator10()).done;) {
          var _period = _step10.value;
          var periodKeys = new Set();
          addKeyIdsFromPeriod(periodKeys, _period);
          if (((_a = initializationData.content) === null || _a === void 0 ? void 0 : _a.period.id) === _period.id) {
            mergeKeyIdSetIntoArray(periodKeys, associatedKeyIds);
          } else {
            var periodKeysArr = Array.from(periodKeys);
            var _loop3 = function _loop3() {
              var kid = _periodKeysArr2[_i2];
              var isFound = associatedKeyIds.some(function (k) {
                return (0,are_arrays_of_numbers_equal/* default */.A)(k, kid);
              });
              if (isFound) {
                mergeKeyIdSetIntoArray(periodKeys, associatedKeyIds);
                return 1; // break
              }
            };
            for (var _i2 = 0, _periodKeysArr2 = periodKeysArr; _i2 < _periodKeysArr2.length; _i2++) {
              if (_loop3()) break;
            }
          }
        }
      }
    }
  }
  return {
    whitelisted: usableKeyIds,
    /** associatedKeyIds starts with the whitelisted one. */
    blacklisted: associatedKeyIds.slice(usableKeyIds.length)
  };
}
/**
 * Push all kei ids in the given `set` and add it to the `arr` Array only if it
 * isn't already present in it.
 * @param {Set.<Uint8Array>} set
 * @param {Array.<Uint8Array>} arr
 */
function mergeKeyIdSetIntoArray(set, arr) {
  var setArr = Array.from(set.values());
  var _loop5 = function _loop5() {
    var kid = _setArr[_i3];
    var isFound = arr.some(function (k) {
      return (0,are_arrays_of_numbers_equal/* default */.A)(k, kid);
    });
    if (!isFound) {
      arr.push(kid);
    }
  };
  for (var _i3 = 0, _setArr = setArr; _i3 < _setArr.length; _i3++) {
    _loop5();
  }
}
/**
 * Add to the given `set` all key ids found in the given `Period`.
 * @param {Set.<Uint8Array>} set
 * @param {Object} period
 */
function addKeyIdsFromPeriod(set, period) {
  for (var _iterator11 = content_decryptor_createForOfIteratorHelperLoose(period.getAdaptations()), _step11; !(_step11 = _iterator11()).done;) {
    var adaptation = _step11.value;
    for (var _iterator12 = content_decryptor_createForOfIteratorHelperLoose(adaptation.representations), _step12; !(_step12 = _iterator12()).done;) {
      var representation = _step12.value;
      if (representation.contentProtections !== undefined && representation.contentProtections.keyIds !== undefined) {
        for (var _iterator13 = content_decryptor_createForOfIteratorHelperLoose(representation.contentProtections.keyIds), _step13; !(_step13 = _iterator13()).done;) {
          var kidInf = _step13.value;
          set.add(kidInf.keyId);
        }
      }
    }
  }
}
;// CONCATENATED MODULE: ./src/core/decrypt/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */





/* harmony default export */ var decrypt = (ContentDecryptor);


/***/ }),

/***/ 2137:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   R: function() { return /* binding */ ContentDecryptorState; }
/* harmony export */ });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** Enumeration of the various "state" the `ContentDecryptor` can be in. */
var ContentDecryptorState;
(function (ContentDecryptorState) {
  /**
   * The `ContentDecryptor` is not yet ready to create key sessions and request
   * licenses.
   * This is is the initial state of the ContentDecryptor.
   */
  ContentDecryptorState[ContentDecryptorState["Initializing"] = 0] = "Initializing";
  /**
   * The `ContentDecryptor` has been initialized.
   * You should now called the `attach` method when you want to add decryption
   * capabilities to the HTMLMediaElement. The ContentDecryptor won't go to the
   * `ReadyForContent` state until `attach` is called.
   *
   * For compatibility reasons, this should be done after the HTMLMediaElement's
   * src attribute is set.
   *
   * It is also from when this state is reached that the `ContentDecryptor`'s
   * `systemId` property may be known.
   *
   * This state is always coming after the `Initializing` state.
   */
  ContentDecryptorState[ContentDecryptorState["WaitingForAttachment"] = 1] = "WaitingForAttachment";
  /**
   * Content (encrypted or not) can begin to be pushed on the HTMLMediaElement
   * (this state was needed because some browser quirks sometimes forces us to
   * call EME API before this can be done).
   *
   * This state is always coming after the `WaitingForAttachment` state.
   */
  ContentDecryptorState[ContentDecryptorState["ReadyForContent"] = 2] = "ReadyForContent";
  /**
   * The `ContentDecryptor` has encountered a fatal error and has been stopped.
   * It is now unusable.
   */
  ContentDecryptorState[ContentDecryptorState["Error"] = 3] = "Error";
  /** The `ContentDecryptor` has been disposed of and is now unusable. */
  ContentDecryptorState[ContentDecryptorState["Disposed"] = 4] = "Disposed";
})(ContentDecryptorState || (ContentDecryptorState = {}));

/***/ }),

/***/ 7365:
/***/ (function(__unused_webpack_module, __webpack_exports__) {

"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Store the MediaKeys infos attached to a media element.
var currentMediaState = new WeakMap();
/* harmony default export */ __webpack_exports__.A = ({
  /**
   * Update MediaKeys infos set on a HMTLMediaElement
   * @param {HTMLMediaElement} mediaElement
   * @param {Object} state
   */
  setState: function setState(mediaElement, state) {
    currentMediaState.set(mediaElement, state);
  },
  /**
   * Get MediaKeys infos currently set on a HMTLMediaElement
   * @param {HTMLMediaElement} mediaElement
   * @returns {Object}
   */
  getState: function getState(mediaElement) {
    var currentState = currentMediaState.get(mediaElement);
    return currentState === undefined ? null : currentState;
  },
  /**
   * Remove MediaKeys infos currently set on a HMTLMediaElement
   * @param {HTMLMediaElement} mediaElement
   */
  clearState: function clearState(mediaElement) {
    currentMediaState.set(mediaElement, null);
  }
});

/***/ }),

/***/ 5963:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: function() { return /* binding */ DirectFileContentInitializer; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7387);
/* harmony import */ var _compat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3116);
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(9477);
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(7994);
/* harmony import */ var _utils_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(6787);
/* harmony import */ var _utils_reference__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(8315);
/* harmony import */ var _utils_task_canceller__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2507);
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(4640);
/* harmony import */ var _utils_get_loaded_reference__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(5097);
/* harmony import */ var _utils_initial_seek_and_play__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(107);
/* harmony import */ var _utils_initialize_content_decryption__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(6899);
/* harmony import */ var _utils_rebuffering_controller__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(3137);
/* harmony import */ var _utils_throw_on_media_error__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(8345);

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */












/**
 * `ContentIntializer` which will load contents by putting their URL in the
 * `src` attribute of the given HTMLMediaElement.
 *
 * Because such contents are mainly loaded by the browser, those (called
 * "directfile" contents in the RxPlayer) needs a simpler logic in-JS when
 * compared to a content that relies on the MSE API.
 *
 * @class DirectFileContentInitializer
 */
var DirectFileContentInitializer = /*#__PURE__*/function (_ContentInitializer) {
  /**
   * Creates a new `DirectFileContentInitializer` linked to the given settings.
   * @param {Object} settings
   */
  function DirectFileContentInitializer(settings) {
    var _this;
    _this = _ContentInitializer.call(this) || this;
    _this._settings = settings;
    _this._initCanceller = new _utils_task_canceller__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay();
    return _this;
  }
  /**
   * "Prepare" content so it can later be played by calling `start`.
   */
  (0,_babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(DirectFileContentInitializer, _ContentInitializer);
  var _proto = DirectFileContentInitializer.prototype;
  _proto.prepare = function prepare() {
    return; // Directfile contents do not have any preparation
  }
  /**
   * Start playback of the content linked to this `DirectFileContentInitializer`
   * on the given `HTMLMediaElement` and its associated `PlaybackObserver`.
   * @param {HTMLMediaElement} mediaElement - HTMLMediaElement on which the
   * content will be played.
   * @param {Object} playbackObserver - Object regularly emitting playback
   * information.
   */;
  _proto.start = function start(mediaElement, playbackObserver) {
    var _this2 = this;
    var cancelSignal = this._initCanceller.signal;
    var _this$_settings = this._settings,
      keySystems = _this$_settings.keySystems,
      speed = _this$_settings.speed,
      url = _this$_settings.url;
    (0,_compat__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A)(mediaElement);
    /**
     * Create dummy encryption data emitter, as those are not sent from the
     * RxPlayer for directfile contents.
     */
    var decryptionRef = new _utils_reference__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A(null);
    decryptionRef.finish();
    var drmInitRef = (0,_utils_initialize_content_decryption__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A)(mediaElement, keySystems, decryptionRef, {
      onError: function onError(err) {
        return _this2._onFatalError(err);
      },
      onWarning: function onWarning(err) {
        return _this2.trigger("warning", err);
      }
    }, cancelSignal);
    /** Translate errors coming from the media element into RxPlayer errors. */
    (0,_utils_throw_on_media_error__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A)(mediaElement, function (error) {
      return _this2._onFatalError(error);
    }, cancelSignal);
    /**
     * Class trying to avoid various stalling situations, emitting "stalled"
     * events when it cannot, as well as "unstalled" events when it get out of one.
     */
    var rebufferingController = new _utils_rebuffering_controller__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A(playbackObserver, null, speed);
    rebufferingController.addEventListener("stalled", function (evt) {
      return _this2.trigger("stalled", evt);
    });
    rebufferingController.addEventListener("unstalled", function () {
      return _this2.trigger("unstalled", null);
    });
    rebufferingController.addEventListener("warning", function (err) {
      return _this2.trigger("warning", err);
    });
    cancelSignal.register(function () {
      rebufferingController.destroy();
    });
    rebufferingController.start();
    drmInitRef.onUpdate(function (evt, stopListeningToDrmUpdates) {
      if (evt.initializationState.type === "uninitialized") {
        return; // nothing done yet
      }
      stopListeningToDrmUpdates();
      // Start everything! (Just put the URL in the element's src).
      _log__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .A.info("Setting URL to HTMLMediaElement", url);
      mediaElement.src = url;
      cancelSignal.register(function () {
        _log__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .A.info("Init: Removing directfile src from media element", mediaElement.src);
        (0,_compat__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A)(mediaElement);
      });
      if (evt.initializationState.type === "awaiting-media-link") {
        evt.initializationState.value.isMediaLinked.setValue(true);
        drmInitRef.onUpdate(function (newDrmStatus, stopListeningToDrmUpdatesAgain) {
          if (newDrmStatus.initializationState.type === "initialized") {
            stopListeningToDrmUpdatesAgain();
            _this2._seekAndPlay(mediaElement, playbackObserver);
          }
        }, {
          emitCurrentValue: true,
          clearSignal: cancelSignal
        });
      } else {
        (0,_utils_assert__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .h)(evt.initializationState.type === "initialized");
        _this2._seekAndPlay(mediaElement, playbackObserver);
      }
    }, {
      emitCurrentValue: true,
      clearSignal: cancelSignal
    });
  }
  /**
   * Update URL this `ContentIntializer` depends on.
   * @param {Array.<string>|undefined} _urls
   * @param {boolean} _refreshNow
   */;
  _proto.updateContentUrls = function updateContentUrls(_urls, _refreshNow) {
    throw new Error("Cannot update content URL of directfile contents");
  }
  /**
   * Stop content and free all resources linked to this `ContentIntializer`.
   */;
  _proto.dispose = function dispose() {
    this._initCanceller.cancel();
  }
  /**
   * Logic performed when a fatal error was triggered.
   * @param {*} err - The fatal error in question.
   */;
  _proto._onFatalError = function _onFatalError(err) {
    this._initCanceller.cancel();
    this.trigger("error", err);
  }
  /**
   * Perform the initial seek (to begin playback at an initially-calculated
   * position based on settings) and auto-play if needed when loaded.
   * @param {HTMLMediaElement} mediaElement
   * @param {Object} playbackObserver
   */;
  _proto._seekAndPlay = function _seekAndPlay(mediaElement, playbackObserver) {
    var _this3 = this;
    var cancelSignal = this._initCanceller.signal;
    var _this$_settings2 = this._settings,
      autoPlay = _this$_settings2.autoPlay,
      startAt = _this$_settings2.startAt;
    var initialTime = function initialTime() {
      _log__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .A.debug("Init: Calculating initial time");
      var initTime = getDirectFileInitialTime(mediaElement, startAt);
      _log__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .A.debug("Init: Initial time calculated:", initTime);
      return initTime;
    };
    (0,_utils_initial_seek_and_play__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A)(mediaElement, playbackObserver, initialTime, autoPlay, function (err) {
      return _this3.trigger("warning", err);
    }, true, cancelSignal).autoPlayResult.then(function () {
      return (0,_utils_get_loaded_reference__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .A)(playbackObserver, mediaElement, true, cancelSignal).onUpdate(function (isLoaded, stopListening) {
        if (isLoaded) {
          stopListening();
          _this3.trigger("loaded", {
            segmentBuffersStore: null
          });
        }
      }, {
        emitCurrentValue: true,
        clearSignal: cancelSignal
      });
    })["catch"](function (err) {
      if (!cancelSignal.isCancelled()) {
        _this3._onFatalError(err);
      }
    });
  };
  return DirectFileContentInitializer;
}(_types__WEBPACK_IMPORTED_MODULE_11__/* .ContentInitializer */ .Y);
/**
 * calculate initial time as a position in seconds.
 * @param {HTMLMediaElement} mediaElement
 * @param {Object|undefined} [startAt]
 * @returns {number}
 */

function getDirectFileInitialTime(mediaElement, startAt) {
  if ((0,_utils_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_12__/* ["default"] */ .A)(startAt)) {
    return 0;
  }
  if (!(0,_utils_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_12__/* ["default"] */ .A)(startAt.position)) {
    return startAt.position;
  } else if (startAt.wallClockTime != null) {
    return startAt.wallClockTime;
  } else if (startAt.fromFirstPosition != null) {
    return startAt.fromFirstPosition;
  }
  var duration = mediaElement.duration;
  if (typeof startAt.fromLastPosition === "number") {
    if (!(0,_utils_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_12__/* ["default"] */ .A)(duration) && isFinite(duration)) {
      return Math.max(0, duration + startAt.fromLastPosition);
    }
    if (mediaElement.seekable.length > 0) {
      var lastSegmentEnd = mediaElement.seekable.end(mediaElement.seekable.length - 1);
      if (isFinite(lastSegmentEnd)) {
        return Math.max(0, lastSegmentEnd + startAt.fromLastPosition);
      }
    }
    _log__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .A.warn("Init: startAt.fromLastPosition set but no known duration, " + "it may be too soon to seek");
    return undefined;
  } else if (typeof startAt.fromLivePosition === "number") {
    var livePosition = mediaElement.seekable.length > 0 ? mediaElement.seekable.end(0) : duration;
    if ((0,_utils_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_12__/* ["default"] */ .A)(livePosition)) {
      _log__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .A.warn("Init: startAt.fromLivePosition set but no known live position, " + "beginning at 0.");
      return 0;
    }
    return Math.max(0, livePosition + startAt.fromLivePosition);
  } else if (startAt.percentage != null) {
    if ((0,_utils_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_12__/* ["default"] */ .A)(duration) || !isFinite(duration)) {
      _log__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .A.warn("Init: startAt.percentage set but no known duration, " + "beginning at 0.");
      return 0;
    }
    var percentage = startAt.percentage;
    if (percentage >= 100) {
      return duration;
    } else if (percentage <= 0) {
      return 0;
    }
    var ratio = +percentage / 100;
    return duration * ratio;
  }
  return 0;
}

/***/ }),

/***/ 1737:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: function() { return /* binding */ MediaSourceContentInitializer; }
});

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js
var asyncToGenerator = __webpack_require__(467);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js
var inheritsLoose = __webpack_require__(7387);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/regenerator/index.js
var regenerator = __webpack_require__(4756);
var regenerator_default = /*#__PURE__*/__webpack_require__.n(regenerator);
;// CONCATENATED MODULE: ./src/compat/should_reload_media_source_on_decipherability_update.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Returns true if we have to reload the MediaSource due to an update in the
 * decipherability status of some segments based on the current key sytem.
 *
 * We found that on all Widevine targets tested, a simple seek is sufficient.
 * As widevine clients make a good chunk of users, we can make a difference
 * between them and others as it is for the better.
 * @param {string|undefined} currentKeySystem
 * @returns {Boolean}
 */
function shouldReloadMediaSourceOnDecipherabilityUpdate(currentKeySystem) {
  return currentKeySystem === undefined || currentKeySystem.indexOf("widevine") < 0;
}
// EXTERNAL MODULE: ./src/compat/browser_detection.ts
var browser_detection = __webpack_require__(443);
;// CONCATENATED MODULE: ./src/compat/may_media_element_fail_on_undecipherable_data.ts

/**
 * We noticed that the PlayStation 5 may have the HTMLMediaElement on which the
 * content is played stop on a `MEDIA_ERR_DECODE` error if it encounters
 * encrypted media data whose key is not usable due to policy restrictions (the
 * most usual issue being non-respect of HDCP restrictions).
 *
 * This is not an usual behavior, other platforms just do not attempt to decode
 * the encrypted media data and stall the playback instead (which is a much
 * preferable behavior for us as we have some advanced mechanism to restart
 * playback when this happens).
 *
 * Consequently, we have to specifically consider platforms with that
 * fail-on-undecipherable-data issue, to perform a work-around in that case.
 */
var mayMediaElementFailOnUndecipherableData = browser_detection/* isPlayStation5 */.A7;
/* harmony default export */ var may_media_element_fail_on_undecipherable_data = (mayMediaElementFailOnUndecipherableData);
// EXTERNAL MODULE: ./src/config.ts + 2 modules
var config = __webpack_require__(5151);
// EXTERNAL MODULE: ./src/errors/media_error.ts
var media_error = __webpack_require__(5575);
// EXTERNAL MODULE: ./src/log.ts + 1 modules
var log = __webpack_require__(9477);
// EXTERNAL MODULE: ./src/utils/assert.ts
var assert = __webpack_require__(7994);
// EXTERNAL MODULE: ./src/utils/create_cancellable_promise.ts
var create_cancellable_promise = __webpack_require__(4339);
// EXTERNAL MODULE: ./src/utils/object_assign.ts
var object_assign = __webpack_require__(8935);
// EXTERNAL MODULE: ./src/utils/reference.ts
var reference = __webpack_require__(8315);
// EXTERNAL MODULE: ./src/utils/task_canceller.ts
var task_canceller = __webpack_require__(2507);
// EXTERNAL MODULE: ./src/utils/noop.ts
var noop = __webpack_require__(8060);
// EXTERNAL MODULE: ./src/utils/ranges.ts
var ranges = __webpack_require__(3650);
// EXTERNAL MODULE: ./src/utils/array_find_index.ts
var array_find_index = __webpack_require__(3786);
;// CONCATENATED MODULE: ./src/core/adaptive/utils/get_buffer_levels.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Return "Buffer Levels" which are steps of available buffers from which we
 * are normally able switch safely to the next available bitrate.
 * (Following an algorithm close to BOLA)
 * @param {Array.<number>} bitrates - All available bitrates, __sorted__ in
 * ascending order.
 * @returns {Array.<number>}
 */
function getBufferLevels(bitrates) {
  var logs = bitrates.map(function (b) {
    return Math.log(b / bitrates[0]);
  });
  var utilities = logs.map(function (l) {
    return l - logs[0] + 1;
  }); // normalize
  var gp = (utilities[utilities.length - 1] - 1) / (bitrates.length * 2 + 10);
  var Vp = 1 / gp;
  return bitrates.map(function (_, i) {
    return minBufferLevelForBitrate(i);
  });
  /**
   * Get minimum buffer we should keep ahead to pick this bitrate.
   * @param {number} index
   * @returns {number}
   */
  function minBufferLevelForBitrate(index) {
    if (index === 0) {
      return 0;
    }
    var boundedIndex = Math.min(Math.max(1, index), bitrates.length - 1);
    if (bitrates[boundedIndex] === bitrates[boundedIndex - 1]) {
      return minBufferLevelForBitrate(index - 1);
    }
    return Vp * (gp + (bitrates[boundedIndex] * utilities[boundedIndex - 1] - bitrates[boundedIndex - 1] * utilities[boundedIndex]) / (bitrates[boundedIndex] - bitrates[boundedIndex - 1])) + 4;
  }
}
;// CONCATENATED MODULE: ./src/core/adaptive/buffer_based_chooser.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Minimum amount of time, in milliseconds, during which we are blocked from
 * raising in quality after it had been considered as too high.
 */
var MINIMUM_BLOCK_RAISE_DELAY = 6000;
/**
 * Maximum amount of time, in milliseconds, during which we are blocked from
 * raising in quality after it had been considered as too high.
 */
var MAXIMUM_BLOCK_RAISE_DELAY = 15000;
/**
 * Amount of time, in milliseconds, with which the blocking time in raising
 * the quality will be incremented if the current quality estimate is seen
 * as too unstable.
 */
var RAISE_BLOCKING_DELAY_INCREMENT = 3000;
/**
 * Amount of time, in milliseconds, with which the blocking time in raising
 * the quality will be dcremented if the current quality estimate is seen
 * as relatively stable, until `MINIMUM_BLOCK_RAISE_DELAY` is reached.
 */
var RAISE_BLOCKING_DELAY_DECREMENT = 1000;
/**
 * Amount of time, in milliseconds, after the "raise blocking delay" currently
 * in place (during which it is forbidden to raise up in quality), during which
 * we might want to raise the "raise blocking delay" if the last chosen quality
 * seems unsuitable.
 *
 * For example, let's consider that the current raise blocking delay is at
 * `4000`, or 4 seconds, and that this `STABILITY_CHECK_DELAY` is at `5000`, or
 * 5 seconds.
 * Here it means that if the estimated quality is found to be unsuitable less
 * than 4+5 = 9 seconds after it last was, we will increment the raise blocking
 * delay by `RAISE_BLOCKING_DELAY_INCREMENT` (unless `MAXIMUM_BLOCK_RAISE_DELAY`
 * is reached).
 * Else, if takes more than 9 seconds, the raise blocking delay might be
 * decremented.
 */
var STABILITY_CHECK_DELAY = 9000;
/**
 * Choose a bitrate based on the currently available buffer.
 *
 * This algorithm is based on a deviation of the BOLA algorithm.
 * It is a hybrid solution that also relies on a given bitrate's
 * "maintainability".
 * Each time a chunk is downloaded, from the ratio between the chunk duration
 * and chunk's request time, we can assume that the representation is
 * "maintanable" or not.
 * If so, we may switch to a better quality, or conversely to a worse quality.
 *
 * It also rely on mechanisms to avoid fluctuating too much between qualities.
 *
 * @class BufferBasedChooser
 */
var BufferBasedChooser = /*#__PURE__*/function () {
  /**
   * @param {Array.<number>} bitrates
   */
  function BufferBasedChooser(bitrates) {
    this._levelsMap = getBufferLevels(bitrates).map(function (bl) {
      return bl + 4; // Add some buffer security as it will be used conjointly with
      // other algorithms anyway
    });
    this._bitrates = bitrates;
    this._lastUnsuitableQualityTimestamp = undefined;
    this._blockRaiseDelay = MINIMUM_BLOCK_RAISE_DELAY;
    log/* default */.A.debug("ABR: Steps for buffer based chooser.", this._levelsMap.map(function (l, i) {
      return "bufferLevel: " + l + ", bitrate: " + bitrates[i];
    }).join(" ,"));
  }
  /**
   * @param {Object} playbackObservation
   * @returns {number|undefined}
   */
  var _proto = BufferBasedChooser.prototype;
  _proto.onAddedSegment = function onAddedSegment(playbackObservation) {
    var bufferLevels = this._levelsMap;
    var bitrates = this._bitrates;
    var bufferGap = playbackObservation.bufferGap,
      currentBitrate = playbackObservation.currentBitrate,
      currentScore = playbackObservation.currentScore,
      speed = playbackObservation.speed;
    if (currentBitrate == null) {
      this._currentEstimate = bitrates[0];
      return;
    }
    var currentBitrateIndex = -1;
    for (var i = 0; i < bitrates.length; i++) {
      // There could be bitrate duplicates. Only take the last one to simplify
      var bitrate = bitrates[i];
      if (bitrate === currentBitrate) {
        currentBitrateIndex = i;
      } else if (bitrate > currentBitrate) {
        break;
      }
    }
    if (currentBitrateIndex < 0 || bitrates.length !== bufferLevels.length) {
      log/* default */.A.error("ABR: Current Bitrate not found in the calculated levels");
      this._currentEstimate = bitrates[0];
      return;
    }
    var scaledScore;
    if (currentScore !== undefined) {
      scaledScore = speed === 0 ? currentScore.score : currentScore.score / speed;
    }
    var actualBufferGap = isFinite(bufferGap) ? bufferGap : 0;
    var now = performance.now();
    if (actualBufferGap < bufferLevels[currentBitrateIndex] || scaledScore !== undefined && scaledScore < 1 && (currentScore === null || currentScore === void 0 ? void 0 : currentScore.confidenceLevel) === 1 /* ScoreConfidenceLevel.HIGH */) {
      var timeSincePrev = this._lastUnsuitableQualityTimestamp === undefined ? -1 : now - this._lastUnsuitableQualityTimestamp;
      if (timeSincePrev < this._blockRaiseDelay + STABILITY_CHECK_DELAY) {
        var newDelay = this._blockRaiseDelay + RAISE_BLOCKING_DELAY_INCREMENT;
        this._blockRaiseDelay = Math.min(newDelay, MAXIMUM_BLOCK_RAISE_DELAY);
        log/* default */.A.debug("ABR: Incrementing blocking raise in BufferBasedChooser due " + "to unstable quality", this._blockRaiseDelay);
      } else {
        var _newDelay = this._blockRaiseDelay - RAISE_BLOCKING_DELAY_DECREMENT;
        this._blockRaiseDelay = Math.max(MINIMUM_BLOCK_RAISE_DELAY, _newDelay);
        log/* default */.A.debug("ABR: Lowering quality in BufferBasedChooser", this._blockRaiseDelay);
      }
      this._lastUnsuitableQualityTimestamp = now;
      // Security if multiple bitrates are equal, we now take the first one
      var baseIndex = (0,array_find_index/* default */.A)(bitrates, function (b) {
        return b === currentBitrate;
      });
      for (var _i = baseIndex - 1; _i >= 0; _i--) {
        if (actualBufferGap >= bufferLevels[_i]) {
          this._currentEstimate = bitrates[_i];
          return;
        }
      }
      this._currentEstimate = bitrates[0];
      return;
    }
    if (this._lastUnsuitableQualityTimestamp !== undefined && now - this._lastUnsuitableQualityTimestamp < this._blockRaiseDelay || scaledScore === undefined || scaledScore < 1.15 || (currentScore === null || currentScore === void 0 ? void 0 : currentScore.confidenceLevel) !== 1 /* ScoreConfidenceLevel.HIGH */) {
      this._currentEstimate = currentBitrate;
      return;
    }
    var currentBufferLevel = bufferLevels[currentBitrateIndex];
    var nextIndex = function () {
      for (var _i2 = currentBitrateIndex + 1; _i2 < bufferLevels.length; _i2++) {
        if (bufferLevels[_i2] > currentBufferLevel) {
          return _i2;
        }
      }
    }();
    if (nextIndex !== undefined) {
      var nextBufferLevel = bufferLevels[nextIndex];
      if (bufferGap >= nextBufferLevel) {
        log/* default */.A.debug("ABR: Raising quality in BufferBasedChooser", bitrates[nextIndex]);
        this._currentEstimate = bitrates[nextIndex];
        return;
      }
    }
    this._currentEstimate = currentBitrate;
    return;
  }
  /**
   * Returns the last best Representation's bitrate estimate made by the
   * `BufferBasedChooser` or `undefined` if it has no such guess for now.
   *
   * Might be updated after `onAddedSegment` is called.
   *
   * @returns {number|undefined}
   */;
  _proto.getLastEstimate = function getLastEstimate() {
    return this._currentEstimate;
  };
  return BufferBasedChooser;
}();

// EXTERNAL MODULE: ./src/utils/array_find.ts
var array_find = __webpack_require__(1729);
;// CONCATENATED MODULE: ./src/core/adaptive/utils/ewma.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Tweaked implementation of an exponential weighted Moving Average.
 * @class EWMA
 */
var EWMA = /*#__PURE__*/function () {
  /**
   * @param {number} halfLife
   */
  function EWMA(halfLife) {
    // (half-life = log(1/2) / log(Decay Factor)
    this._alpha = Math.exp(Math.log(0.5) / halfLife);
    this._lastEstimate = 0;
    this._totalWeight = 0;
  }
  /**
   * @param {number} weight
   * @param {number} value
   */
  var _proto = EWMA.prototype;
  _proto.addSample = function addSample(weight, value) {
    var adjAlpha = Math.pow(this._alpha, weight);
    var newEstimate = value * (1 - adjAlpha) + adjAlpha * this._lastEstimate;
    if (!isNaN(newEstimate)) {
      this._lastEstimate = newEstimate;
      this._totalWeight += weight;
    }
  }
  /**
   * @returns {number} value
   */;
  _proto.getEstimate = function getEstimate() {
    var zeroFactor = 1 - Math.pow(this._alpha, this._totalWeight);
    return this._lastEstimate / zeroFactor;
  };
  return EWMA;
}();

;// CONCATENATED MODULE: ./src/core/adaptive/network_analyzer.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Get pending segment request(s) starting with the asked segment position.
 * @param {Object} requests - Every requests pending, in a chronological
 * order in terms of segment time.
 * @param {number} neededPosition
 * @returns {Array.<Object>}
 */
function getConcernedRequests(requests, neededPosition) {
  /** Index of the request for the next needed segment, in `requests`. */
  var nextSegmentIndex = -1;
  for (var i = 0; i < requests.length; i++) {
    var segment = requests[i].content.segment;
    if (segment.duration <= 0) {
      continue;
    }
    var segmentEnd = segment.time + segment.duration;
    if (!segment.complete) {
      if (i === requests.length - 1 && neededPosition - segment.time > -1.2) {
        nextSegmentIndex = i;
        break;
      }
    }
    if (segmentEnd > neededPosition && neededPosition - segment.time > -1.2) {
      nextSegmentIndex = i;
      break;
    }
  }
  if (nextSegmentIndex < 0) {
    // Not found
    return [];
  }
  var nextRequest = requests[nextSegmentIndex];
  var segmentTime = nextRequest.content.segment.time;
  var filteredRequests = [nextRequest];
  // Get the possibly multiple requests for that segment's position
  for (var _i = nextSegmentIndex + 1; _i < requests.length; _i++) {
    if (requests[_i].content.segment.time === segmentTime) {
      filteredRequests.push(requests[_i]);
    } else {
      break;
    }
  }
  return filteredRequests;
}
/**
 * Estimate the __VERY__ recent bandwidth based on a single unfinished request.
 * Useful when the current bandwidth seemed to have fallen quickly.
 *
 * @param {Object} request
 * @returns {number|undefined}
 */
function estimateRequestBandwidth(request) {
  if (request.progress.length < 5) {
    // threshold from which we can consider
    // progress events reliably
    return undefined;
  }
  // try to infer quickly the current bitrate based on the
  // progress events
  var ewma1 = new EWMA(2);
  var progress = request.progress;
  for (var i = 1; i < progress.length; i++) {
    var bytesDownloaded = progress[i].size - progress[i - 1].size;
    var timeElapsed = progress[i].timestamp - progress[i - 1].timestamp;
    var reqBitrate = bytesDownloaded * 8 / (timeElapsed / 1000);
    ewma1.addSample(timeElapsed / 1000, reqBitrate);
  }
  return ewma1.getEstimate();
}
/**
 * Estimate remaining time for a pending request from a progress event.
 * @param {Object} lastProgressEvent
 * @param {number} bandwidthEstimate
 * @returns {number}
 */
function estimateRemainingTime(lastProgressEvent, bandwidthEstimate) {
  var remainingData = (lastProgressEvent.totalSize - lastProgressEvent.size) * 8;
  return Math.max(remainingData / bandwidthEstimate, 0);
}
/**
 * Check if the request for the most needed segment is too slow.
 * If that's the case, re-calculate the bandwidth urgently based on
 * this single request.
 * @param {Object} pendingRequests - Every requests pending, in a chronological
 * order in terms of segment time.
 * @param {Object} playbackInfo - Information on the current playback.
 * @param {Object|null} currentRepresentation - The Representation being
 * presently being loaded.
 * @param {boolean} lowLatencyMode - If `true`, we're playing the content as a
 * low latency content - where requests might be pending when the segment is
 * still encoded.
 * @param {Number} lastEstimatedBitrate - Last bitrate estimate emitted.
 * @returns {Number|undefined}
 */
function estimateStarvationModeBitrate(pendingRequests, playbackInfo, currentRepresentation, lowLatencyMode, lastEstimatedBitrate) {
  if (lowLatencyMode) {
    // TODO Skip only for newer segments?
    return undefined;
  }
  var bufferGap = playbackInfo.bufferGap,
    speed = playbackInfo.speed,
    position = playbackInfo.position;
  var realBufferGap = isFinite(bufferGap) ? bufferGap : 0;
  var nextNeededPosition = position.last + realBufferGap;
  var concernedRequests = getConcernedRequests(pendingRequests, nextNeededPosition);
  if (concernedRequests.length !== 1) {
    // 0  == no request
    // 2+ == too complicated to calculate
    return undefined;
  }
  var concernedRequest = concernedRequests[0];
  var now = performance.now();
  var minimumRequestTime = concernedRequest.content.segment.duration * 1.5;
  minimumRequestTime = Math.min(minimumRequestTime, 3000);
  minimumRequestTime = Math.max(minimumRequestTime, 12000);
  if (now - concernedRequest.requestTimestamp < minimumRequestTime) {
    return undefined;
  }
  var lastProgressEvent = concernedRequest.progress.length > 0 ? concernedRequest.progress[concernedRequest.progress.length - 1] : undefined;
  // first, try to do a quick estimate from progress events
  var bandwidthEstimate = estimateRequestBandwidth(concernedRequest);
  if (lastProgressEvent !== undefined && bandwidthEstimate !== undefined) {
    var remainingTime = estimateRemainingTime(lastProgressEvent, bandwidthEstimate);
    // if the remaining time does seem reliable
    if ((now - lastProgressEvent.timestamp) / 1000 <= remainingTime) {
      // Calculate estimated time spent rebuffering if we continue doing that request.
      var expectedRebufferingTime = remainingTime - realBufferGap / speed;
      if (expectedRebufferingTime > 2500) {
        return bandwidthEstimate;
      }
    }
  }
  if (!concernedRequest.content.segment.complete) {
    return undefined;
  }
  var chunkDuration = concernedRequest.content.segment.duration;
  var requestElapsedTime = (now - concernedRequest.requestTimestamp) / 1000;
  var reasonableElapsedTime = requestElapsedTime <= (chunkDuration * 1.5 + 2) / speed;
  if (currentRepresentation == null || reasonableElapsedTime) {
    return undefined;
  }
  // calculate a reduced bitrate from the current one
  var factor = chunkDuration / requestElapsedTime;
  var reducedBitrate = currentRepresentation.bitrate * Math.min(0.7, factor);
  if (lastEstimatedBitrate === undefined || reducedBitrate < lastEstimatedBitrate) {
    return reducedBitrate;
  }
}
/**
 * Returns true if, based on the current requests, it seems that the ABR should
 * switch immediately if a lower bitrate is more adapted.
 * Returns false if it estimates that you have time before switching to a lower
 * bitrate.
 * @param {Object} playbackInfo - Information on the current playback.
 * @param {Object} requests - Every requests pending, in a chronological
 * order in terms of segment time.
 * @param {boolean} lowLatencyMode - If `true`, we're playing the content as a
 * low latency content, as close to the live edge as possible.
 * @returns {boolean}
 */
function shouldDirectlySwitchToLowBitrate(playbackInfo, requests, lowLatencyMode) {
  if (lowLatencyMode) {
    // TODO only when playing close to the live edge?
    return true;
  }
  var realBufferGap = isFinite(playbackInfo.bufferGap) ? playbackInfo.bufferGap : 0;
  var nextNeededPosition = playbackInfo.position.last + realBufferGap;
  var nextRequest = (0,array_find/* default */.A)(requests, function (_ref) {
    var content = _ref.content;
    return content.segment.duration > 0 && content.segment.time + content.segment.duration > nextNeededPosition;
  });
  if (nextRequest === undefined) {
    return true;
  }
  var now = performance.now();
  var lastProgressEvent = nextRequest.progress.length > 0 ? nextRequest.progress[nextRequest.progress.length - 1] : undefined;
  // first, try to do a quick estimate from progress events
  var bandwidthEstimate = estimateRequestBandwidth(nextRequest);
  if (lastProgressEvent === undefined || bandwidthEstimate === undefined) {
    return true;
  }
  var remainingTime = estimateRemainingTime(lastProgressEvent, bandwidthEstimate);
  if ((now - lastProgressEvent.timestamp) / 1000 > remainingTime * 1.2) {
    return true;
  }
  var expectedRebufferingTime = remainingTime - realBufferGap / playbackInfo.speed;
  return expectedRebufferingTime > -1.5;
}
/**
 * Analyze the current network conditions and give a bandwidth estimate as well
 * as a maximum bitrate a Representation should be.
 * @class NetworkAnalyzer
 */
var NetworkAnalyzer = /*#__PURE__*/function () {
  function NetworkAnalyzer(initialBitrate, lowLatencyMode) {
    var _config$getCurrent = config/* default */.A.getCurrent(),
      ABR_STARVATION_GAP = _config$getCurrent.ABR_STARVATION_GAP,
      OUT_OF_STARVATION_GAP = _config$getCurrent.OUT_OF_STARVATION_GAP,
      ABR_STARVATION_FACTOR = _config$getCurrent.ABR_STARVATION_FACTOR,
      ABR_REGULAR_FACTOR = _config$getCurrent.ABR_REGULAR_FACTOR;
    this._initialBitrate = initialBitrate;
    this._inStarvationMode = false;
    this._lowLatencyMode = lowLatencyMode;
    if (lowLatencyMode) {
      this._config = {
        starvationGap: ABR_STARVATION_GAP.LOW_LATENCY,
        outOfStarvationGap: OUT_OF_STARVATION_GAP.LOW_LATENCY,
        starvationBitrateFactor: ABR_STARVATION_FACTOR.LOW_LATENCY,
        regularBitrateFactor: ABR_REGULAR_FACTOR.LOW_LATENCY
      };
    } else {
      this._config = {
        starvationGap: ABR_STARVATION_GAP.DEFAULT,
        outOfStarvationGap: OUT_OF_STARVATION_GAP.DEFAULT,
        starvationBitrateFactor: ABR_STARVATION_FACTOR.DEFAULT,
        regularBitrateFactor: ABR_REGULAR_FACTOR.DEFAULT
      };
    }
  }
  /**
   * Gives an estimate of the current bandwidth and of the bitrate that should
   * be considered for chosing a `representation`.
   * This estimate is only based on network metrics.
   * @param {Object} playbackInfo - Gives current information about playback.
   * @param {Object} bandwidthEstimator - `BandwidthEstimator` allowing to
   * produce network bandwidth estimates.
   * @param {Object|null} currentRepresentation - The Representation currently
   * chosen.
   * `null` if no Representation has been chosen yet.
   * @param {Array.<Object>} currentRequests - All segment requests by segment's
   * start chronological order
   * @param {number|undefined} lastEstimatedBitrate - Bitrate emitted during the
   * last estimate.
   * @returns {Object}
   */
  var _proto = NetworkAnalyzer.prototype;
  _proto.getBandwidthEstimate = function getBandwidthEstimate(playbackInfo, bandwidthEstimator, currentRepresentation, currentRequests, lastEstimatedBitrate) {
    var newBitrateCeil; // bitrate ceil for the chosen Representation
    var bandwidthEstimate;
    var localConf = this._config;
    var bufferGap = playbackInfo.bufferGap,
      position = playbackInfo.position,
      duration = playbackInfo.duration;
    var realBufferGap = isFinite(bufferGap) ? bufferGap : 0;
    var _config$getCurrent2 = config/* default */.A.getCurrent(),
      ABR_STARVATION_DURATION_DELTA = _config$getCurrent2.ABR_STARVATION_DURATION_DELTA;
    // check if should get in/out of starvation mode
    if (isNaN(duration) || realBufferGap + position.last < duration - ABR_STARVATION_DURATION_DELTA) {
      if (!this._inStarvationMode && realBufferGap <= localConf.starvationGap) {
        log/* default */.A.info("ABR: enter starvation mode.");
        this._inStarvationMode = true;
      } else if (this._inStarvationMode && realBufferGap >= localConf.outOfStarvationGap) {
        log/* default */.A.info("ABR: exit starvation mode.");
        this._inStarvationMode = false;
      }
    } else if (this._inStarvationMode) {
      log/* default */.A.info("ABR: exit starvation mode.");
      this._inStarvationMode = false;
    }
    // If in starvation mode, check if a quick new estimate can be done
    // from the last requests.
    // If so, cancel previous estimates and replace it by the new one
    if (this._inStarvationMode) {
      bandwidthEstimate = estimateStarvationModeBitrate(currentRequests, playbackInfo, currentRepresentation, this._lowLatencyMode, lastEstimatedBitrate);
      if (bandwidthEstimate != null) {
        log/* default */.A.info("ABR: starvation mode emergency estimate:", bandwidthEstimate);
        bandwidthEstimator.reset();
        newBitrateCeil = currentRepresentation == null ? bandwidthEstimate : Math.min(bandwidthEstimate, currentRepresentation.bitrate);
      }
    }
    // if newBitrateCeil is not yet defined, do the normal estimation
    if (newBitrateCeil == null) {
      bandwidthEstimate = bandwidthEstimator.getEstimate();
      if (bandwidthEstimate != null) {
        newBitrateCeil = bandwidthEstimate * (this._inStarvationMode ? localConf.starvationBitrateFactor : localConf.regularBitrateFactor);
      } else if (lastEstimatedBitrate != null) {
        newBitrateCeil = lastEstimatedBitrate * (this._inStarvationMode ? localConf.starvationBitrateFactor : localConf.regularBitrateFactor);
      } else {
        newBitrateCeil = this._initialBitrate;
      }
    }
    if (playbackInfo.speed > 1) {
      newBitrateCeil /= playbackInfo.speed;
    }
    return {
      bandwidthEstimate: bandwidthEstimate,
      bitrateChosen: newBitrateCeil
    };
  }
  /**
   * For a given wanted bitrate, tells if should switch urgently.
   * @param {number} bitrate - The new estimated bitrate.
   * @param {Object|null} currentRepresentation - The Representation being
   * presently being loaded.
   * @param {Array.<Object>} currentRequests - All segment requests by segment's
   * start chronological order
   * @param {Object} playbackInfo - Information on the current playback.
   * @returns {boolean}
   */;
  _proto.isUrgent = function isUrgent(bitrate, currentRepresentation, currentRequests, playbackInfo) {
    if (currentRepresentation === null) {
      return true;
    } else if (bitrate >= currentRepresentation.bitrate) {
      return false;
    }
    return shouldDirectlySwitchToLowBitrate(playbackInfo, currentRequests, this._lowLatencyMode);
  };
  return NetworkAnalyzer;
}();

;// CONCATENATED MODULE: ./src/core/adaptive/guess_based_chooser.ts
function _createForOfIteratorHelperLoose(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (t) return (t = t.call(r)).next.bind(t); if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var o = 0; return function () { return o >= r.length ? { done: !0 } : { done: !1, value: r[o++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Estimate which Representation should be played based on risky "guesses".
 *
 * Basically, this `GuessBasedChooser` will attempt switching to the superior
 * quality when conditions allows this and then check if we're able to maintain
 * this quality. If we're not, it will rollbacks to the previous, maintaninable,
 * guess.
 *
 * The algorithm behind the `GuessBasedChooser` is very risky in terms of
 * rebuffering chances. As such, it should only be used when other approach
 * don't work (e.g.  low-latency contents).
 * @class GuessBasedChooser
 */
var GuessBasedChooser = /*#__PURE__*/function () {
  /**
   * Create a new `GuessBasedChooser`.
   * @param {Object} scoreCalculator
   * @param {Object} prevEstimate
   */
  function GuessBasedChooser(scoreCalculator, prevEstimate) {
    this._scoreCalculator = scoreCalculator;
    this._lastAbrEstimate = prevEstimate;
    this._consecutiveWrongGuesses = 0;
    this._blockGuessesUntil = 0;
    this._lastMaintanableBitrate = null;
  }
  /**
   * Perform a "guess", which basically indicates which Representation should be
   * chosen according to the `GuessBasedChooser`.
   *
   * @param {Array.<Object>} representations - Array of all Representation the
   * GuessBasedChooser can choose from, sorted by bitrate ascending.
   * /!\ It is very important that Representation in that Array are sorted by
   * bitrate ascending for this method to work as intented.
   * @param {Object} observation - Last playback observation performed.
   * @param {Object} currentRepresentation - The Representation currently
   * loading.
   * @param {number} incomingBestBitrate - The bitrate of the Representation
   * chosen by the more optimistic of the other ABR algorithms currently.
   * @param {Array.<Object>} requests - Information on all pending requests.
   * @returns {Object|null} - If a guess is made, return that guess, else
   * returns `null` (in which case you should fallback to another ABR
   * algorithm).
   */
  var _proto = GuessBasedChooser.prototype;
  _proto.getGuess = function getGuess(representations, observation, currentRepresentation, incomingBestBitrate, requests) {
    var bufferGap = observation.bufferGap,
      speed = observation.speed;
    var lastChosenRep = this._lastAbrEstimate.representation;
    if (lastChosenRep === null) {
      return null; // There's nothing to base our guess on
    }
    if (incomingBestBitrate > lastChosenRep.bitrate) {
      // ABR estimates are already superior or equal to the guess
      // we'll be doing here, so no need to guess
      if (this._lastAbrEstimate.algorithmType === 2 /* ABRAlgorithmType.GuessBased */) {
        if (this._lastAbrEstimate.representation !== null) {
          this._lastMaintanableBitrate = this._lastAbrEstimate.representation.bitrate;
        }
        this._consecutiveWrongGuesses = 0;
      }
      return null;
    }
    var scoreData = this._scoreCalculator.getEstimate(currentRepresentation);
    if (this._lastAbrEstimate.algorithmType !== 2 /* ABRAlgorithmType.GuessBased */) {
      if (scoreData === undefined) {
        return null; // not enough information to start guessing
      }
      if (this._canGuessHigher(bufferGap, speed, scoreData)) {
        var nextRepresentation = getNextRepresentation(representations, currentRepresentation);
        if (nextRepresentation !== null) {
          return nextRepresentation;
        }
      }
      return null;
    }
    // If we reached here, we're currently already in guessing mode
    if (this._isLastGuessValidated(lastChosenRep, incomingBestBitrate, scoreData)) {
      log/* default */.A.debug("ABR: Guessed Representation validated", lastChosenRep.bitrate);
      this._lastMaintanableBitrate = lastChosenRep.bitrate;
      this._consecutiveWrongGuesses = 0;
    }
    if (currentRepresentation.id !== lastChosenRep.id) {
      return lastChosenRep;
    }
    var shouldStopGuess = this._shouldStopGuess(currentRepresentation, scoreData, bufferGap, requests);
    if (shouldStopGuess) {
      // Block guesses for a time
      this._consecutiveWrongGuesses++;
      this._blockGuessesUntil = performance.now() + Math.min(this._consecutiveWrongGuesses * 15000, 120000);
      return getPreviousRepresentation(representations, currentRepresentation);
    } else if (scoreData === undefined) {
      return currentRepresentation;
    }
    if (this._canGuessHigher(bufferGap, speed, scoreData)) {
      var _nextRepresentation = getNextRepresentation(representations, currentRepresentation);
      if (_nextRepresentation !== null) {
        return _nextRepresentation;
      }
    }
    return currentRepresentation;
  }
  /**
   * Returns `true` if we've enough confidence on the current situation to make
   * a higher guess.
   * @param {number} bufferGap
   * @param {number} speed
   * @param {Array} scoreData
   * @returns {boolean}
   */;
  _proto._canGuessHigher = function _canGuessHigher(bufferGap, speed, _ref) {
    var score = _ref.score,
      confidenceLevel = _ref.confidenceLevel;
    return isFinite(bufferGap) && bufferGap >= 2.5 && performance.now() > this._blockGuessesUntil && confidenceLevel === 1 /* ScoreConfidenceLevel.HIGH */ && score / speed > 1.01;
  }
  /**
   * Returns `true` if the pending guess of `lastGuess` seems to not
   * be maintainable and as such should be stopped.
   * @param {Object} lastGuess
   * @param {Array} scoreData
   * @param {number} bufferGap
   * @param {Array.<Object>} requests
   * @returns {boolean}
   */;
  _proto._shouldStopGuess = function _shouldStopGuess(lastGuess, scoreData, bufferGap, requests) {
    if (scoreData !== undefined && scoreData.score < 1.01) {
      return true;
    } else if ((scoreData === undefined || scoreData.score < 1.2) && bufferGap < 0.6) {
      return true;
    }
    var guessedRepresentationRequests = requests.filter(function (req) {
      return req.content.representation.id === lastGuess.id;
    });
    var now = performance.now();
    for (var _iterator = _createForOfIteratorHelperLoose(guessedRepresentationRequests), _step; !(_step = _iterator()).done;) {
      var req = _step.value;
      var requestElapsedTime = now - req.requestTimestamp;
      if (req.content.segment.isInit) {
        if (requestElapsedTime > 1000) {
          return true;
        }
      } else if (requestElapsedTime > req.content.segment.duration * 1000 + 200) {
        return true;
      } else {
        var fastBw = estimateRequestBandwidth(req);
        if (fastBw !== undefined && fastBw < lastGuess.bitrate * 0.8) {
          return true;
        }
      }
    }
    return false;
  };
  _proto._isLastGuessValidated = function _isLastGuessValidated(lastGuess, incomingBestBitrate, scoreData) {
    if (scoreData !== undefined && scoreData.confidenceLevel === 1 /* ScoreConfidenceLevel.HIGH */ && scoreData.score > 1.5) {
      return true;
    }
    return incomingBestBitrate >= lastGuess.bitrate && (this._lastMaintanableBitrate === null || this._lastMaintanableBitrate < lastGuess.bitrate);
  };
  return GuessBasedChooser;
}();
/**
 * From the array of Representations given, returns the Representation with a
 * bitrate immediately superior to the current one.
 * Returns `null` if that "next" Representation is not found.
 *
 * /!\ The representations have to be already sorted by bitrate, in ascending
 * order.
 * @param {Array.<Object>} representations - Available representations to choose
 * from, sorted by bitrate in ascending order.
 * @param {Object} currentRepresentation - The Representation currently
 * considered.
 * @returns {Object|null}
 */

function getNextRepresentation(representations, currentRepresentation) {
  var len = representations.length;
  var index = (0,array_find_index/* default */.A)(representations, function (_ref2) {
    var id = _ref2.id;
    return id === currentRepresentation.id;
  });
  if (index < 0) {
    log/* default */.A.error("ABR: Current Representation not found.");
    return null;
  }
  while (++index < len) {
    if (representations[index].bitrate > currentRepresentation.bitrate) {
      return representations[index];
    }
  }
  return null;
}
/**
 * From the array of Representations given, returns the Representation with a
 * bitrate immediately inferior.
 * Returns `null` if that "previous" Representation is not found.
 * @param {Array.<Object>} representations
 * @param {Object} currentRepresentation
 * @returns {Object|null}
 */
function getPreviousRepresentation(representations, currentRepresentation) {
  var index = (0,array_find_index/* default */.A)(representations, function (_ref3) {
    var id = _ref3.id;
    return id === currentRepresentation.id;
  });
  if (index < 0) {
    log/* default */.A.error("ABR: Current Representation not found.");
    return null;
  }
  while (--index >= 0) {
    if (representations[index].bitrate < currentRepresentation.bitrate) {
      return representations[index];
    }
  }
  return null;
}
;// CONCATENATED MODULE: ./src/core/adaptive/utils/bandwidth_estimator.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Calculate a mean bandwidth based on the bytes downloaded and the amount
 * of time needed to do so.
 * @class BandwidthEstimator
 */
var BandwidthEstimator = /*#__PURE__*/function () {
  function BandwidthEstimator() {
    var _config$getCurrent = config/* default */.A.getCurrent(),
      ABR_FAST_EMA = _config$getCurrent.ABR_FAST_EMA,
      ABR_SLOW_EMA = _config$getCurrent.ABR_SLOW_EMA;
    this._fastEWMA = new EWMA(ABR_FAST_EMA);
    this._slowEWMA = new EWMA(ABR_SLOW_EMA);
    this._bytesSampled = 0;
  }
  /**
   * Takes a bandwidth sample.
   * @param {number} durationInMs - The amount of time, in milliseconds, for a
   * particular request.
   * @param {number} numberOfBytes - The total number of bytes transferred in
   * that request.
   */
  var _proto = BandwidthEstimator.prototype;
  _proto.addSample = function addSample(durationInMs, numberOfBytes) {
    var _config$getCurrent2 = config/* default */.A.getCurrent(),
      ABR_MINIMUM_CHUNK_SIZE = _config$getCurrent2.ABR_MINIMUM_CHUNK_SIZE;
    if (numberOfBytes < ABR_MINIMUM_CHUNK_SIZE) {
      return;
    }
    var bandwidth = numberOfBytes * 8000 / durationInMs;
    var weight = durationInMs / 1000;
    this._bytesSampled += numberOfBytes;
    this._fastEWMA.addSample(weight, bandwidth);
    this._slowEWMA.addSample(weight, bandwidth);
  }
  /**
   * Get estimate of the bandwidth, in bits per seconds.
   * @returns {Number|undefined}
   */;
  _proto.getEstimate = function getEstimate() {
    var _config$getCurrent3 = config/* default */.A.getCurrent(),
      ABR_MINIMUM_TOTAL_BYTES = _config$getCurrent3.ABR_MINIMUM_TOTAL_BYTES;
    if (this._bytesSampled < ABR_MINIMUM_TOTAL_BYTES) {
      return undefined;
    }
    // Take the minimum of these two estimates.
    // This should have the effect of adapting down quickly, but up more slowly.
    return Math.min(this._fastEWMA.getEstimate(), this._slowEWMA.getEstimate());
  }
  /** Reset the bandwidth estimation. */;
  _proto.reset = function reset() {
    var _config$getCurrent4 = config/* default */.A.getCurrent(),
      ABR_FAST_EMA = _config$getCurrent4.ABR_FAST_EMA,
      ABR_SLOW_EMA = _config$getCurrent4.ABR_SLOW_EMA;
    this._fastEWMA = new EWMA(ABR_FAST_EMA);
    this._slowEWMA = new EWMA(ABR_SLOW_EMA);
    this._bytesSampled = 0;
  };
  return BandwidthEstimator;
}();

;// CONCATENATED MODULE: ./src/core/adaptive/utils/filter_by_bitrate.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Get only representations lower or equal to a given bitrate.
 * If no representation is lower than the given bitrate, returns an array containing
 * all Representation(s) with the lowest available bitrate.
 * @param {Array.<Object>} representations - All Representations available
 * @param {Number} bitrate
 * @returns {Array.<Object>}
 */
function filterByBitrate(representations, bitrate) {
  if (representations.length === 0) {
    return [];
  }
  representations.sort(function (ra, rb) {
    return ra.bitrate - rb.bitrate;
  });
  var minimumBitrate = representations[0].bitrate;
  var bitrateCeil = Math.max(bitrate, minimumBitrate);
  var firstSuperiorBitrateIndex = (0,array_find_index/* default */.A)(representations, function (representation) {
    return representation.bitrate > bitrateCeil;
  });
  if (firstSuperiorBitrateIndex === -1) {
    return representations; // All representations have lower bitrates.
  }
  return representations.slice(0, firstSuperiorBitrateIndex);
}
;// CONCATENATED MODULE: ./src/core/adaptive/utils/filter_by_width.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Filter representations based on their width:
 *   - the highest width considered will be the one linked to the first
 *     representation which has a superior width to the one given.
 * @param {Array.<Object>} representations - The representations array
 * @param {Number} width
 * @returns {Array.<Object>}
 */
function filterByWidth(representations, width) {
  var sortedRepsByWidth = representations.slice() // clone
  .sort(function (a, b) {
    var _a, _b;
    return ((_a = a.width) !== null && _a !== void 0 ? _a : 0) - ((_b = b.width) !== null && _b !== void 0 ? _b : 0);
  });
  var repWithMaxWidth = (0,array_find/* default */.A)(sortedRepsByWidth, function (representation) {
    return typeof representation.width === "number" && representation.width >= width;
  });
  if (repWithMaxWidth === undefined) {
    return representations;
  }
  var maxWidth = typeof repWithMaxWidth.width === "number" ? repWithMaxWidth.width : 0;
  return representations.filter(function (representation) {
    return typeof representation.width === "number" ? representation.width <= maxWidth : true;
  });
}
;// CONCATENATED MODULE: ./src/core/adaptive/utils/last_estimate_storage.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** Stores the last estimate made by the `RepresentationEstimator`. */
var LastEstimateStorage = /*#__PURE__*/function () {
  function LastEstimateStorage() {
    this.bandwidth = undefined;
    this.representation = null;
    this.algorithmType = 3 /* ABRAlgorithmType.None */;
  }
  /**
   * Update this `LastEstimateStorage` with new values.
   * @param {Object} representation - Estimated Representation.
   * @param {number|undefined} bandwidth - Estimated bandwidth.
   * @param {number} algorithmType - The type of algorithm used to produce that
   * estimate.
   */
  var _proto = LastEstimateStorage.prototype;
  _proto.update = function update(representation, bandwidth, algorithmType) {
    this.representation = representation;
    this.bandwidth = bandwidth;
    this.algorithmType = algorithmType;
  };
  return LastEstimateStorage;
}();

// EXTERNAL MODULE: ./src/utils/object_values.ts
var object_values = __webpack_require__(4324);
;// CONCATENATED MODULE: ./src/core/adaptive/utils/pending_requests_store.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Store information about pending requests, like information about:
 *   - for which segments they are
 *   - how the request's progress goes
 * @class PendingRequestsStore
 */
var PendingRequestsStore = /*#__PURE__*/function () {
  function PendingRequestsStore() {
    this._currentRequests = {};
  }
  /**
   * Add information about a new pending request.
   * @param {Object} payload
   */
  var _proto = PendingRequestsStore.prototype;
  _proto.add = function add(payload) {
    var id = payload.id,
      requestTimestamp = payload.requestTimestamp,
      content = payload.content;
    this._currentRequests[id] = {
      requestTimestamp: requestTimestamp,
      progress: [],
      content: content
    };
  }
  /**
   * Notify of the progress of a currently pending request.
   * @param {Object} progress
   */;
  _proto.addProgress = function addProgress(progress) {
    var request = this._currentRequests[progress.id];
    if (request == null) {
      if (false) {}
      log/* default */.A.warn("ABR: progress for a request not added");
      return;
    }
    request.progress.push(progress);
  }
  /**
   * Remove a request previously set as pending.
   * @param {string} id
   */;
  _proto.remove = function remove(id) {
    if (this._currentRequests[id] == null) {
      if (false) {}
      log/* default */.A.warn("ABR: can't remove unknown request");
    }
    delete this._currentRequests[id];
  }
  /**
   * Returns information about all pending requests, in segment's chronological
   * order.
   * @returns {Array.<Object>}
   */;
  _proto.getRequests = function getRequests() {
    return (0,object_values/* default */.A)(this._currentRequests).filter(function (x) {
      return x != null;
    }).sort(function (reqA, reqB) {
      return reqA.content.segment.time - reqB.content.segment.time;
    });
  };
  return PendingRequestsStore;
}();

;// CONCATENATED MODULE: ./src/core/adaptive/utils/representation_score_calculator.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Calculate the "maintainability score" of a given Representation:
 *   - A score higher than 1 means that the Representation can theorically
 *     be downloaded faster than the duration of the media it represents.
 *     (e.g. a segment representing 4 seconds can be downloaded in less than 4
 *     seconds).
 *   - A score lower or equal to 1 means that the Representation cannot be
 *     downloaded
 *
 * The score follows a simple linear relation to both variables it is based
 * on:
 *   - if n seconds of content can be downloaded in 2*n seconds, the score will
 *     be `0.5`.
 *   - if n seconds of content can be downloaded in n seconds, the score will be
 *     `1`.
 *   - if n seconds of content can be downloaded in n/2 seconds, the score will
 *     be `2`.
 *   - ...
 *
 * The score is mainly here to tell you when your buffer-based guesses are
 * actually higher than the quality you should normally reach.
 *
 * /!\ Please bear in mind that we don't consider the playback rate in those
 * operations.
 * Still, integrating the playback rate a posteriori should not be difficult
 * (e.g. you can just divide the score by that rate).
 *
 * @class RepresentationScoreCalculator
 */
var RepresentationScoreCalculator = /*#__PURE__*/function () {
  function RepresentationScoreCalculator() {
    this._currentRepresentationData = null;
    this._lastRepresentationWithGoodScore = null;
  }
  /**
   * Add new sample data.
   * @param {Representation} representation
   * @param {number} requestDuration - duration taken for doing the request for
   * the whole segment.
   * @param {number} segmentDuration - media duration of the whole segment, in
   * seconds.
   */
  var _proto = RepresentationScoreCalculator.prototype;
  _proto.addSample = function addSample(representation, requestDuration, segmentDuration) {
    var ratio = segmentDuration / requestDuration;
    var currentRep = this._currentRepresentationData;
    var currentEWMA;
    if (currentRep !== null && currentRep.representation.id === representation.id) {
      currentEWMA = currentRep.ewma;
      currentRep.ewma.addSample(requestDuration, ratio);
      currentRep.loadedDuration += segmentDuration;
      currentRep.loadedSegments++;
    } else {
      currentEWMA = new EWMA(5);
      currentEWMA.addSample(requestDuration, ratio);
      this._currentRepresentationData = {
        representation: representation,
        ewma: currentEWMA,
        loadedDuration: segmentDuration,
        loadedSegments: 0
      };
    }
    if (currentEWMA.getEstimate() > 1 && this._lastRepresentationWithGoodScore !== representation) {
      log/* default */.A.debug("ABR: New last stable representation", representation.bitrate);
      this._lastRepresentationWithGoodScore = representation;
    }
  }
  /**
   * Get score estimate for the given Representation.
   * undefined if no estimate is available.
   * @param {Representation} representation
   * @returns {number|undefined}
   */;
  _proto.getEstimate = function getEstimate(representation) {
    if (this._currentRepresentationData === null || this._currentRepresentationData.representation.id !== representation.id) {
      return undefined;
    }
    var _this$_currentReprese = this._currentRepresentationData,
      ewma = _this$_currentReprese.ewma,
      loadedSegments = _this$_currentReprese.loadedSegments,
      loadedDuration = _this$_currentReprese.loadedDuration;
    var estimate = ewma.getEstimate();
    var confidenceLevel = loadedSegments >= 5 && loadedDuration >= 10 ? 1 /* ScoreConfidenceLevel.HIGH */ : 0 /* ScoreConfidenceLevel.LOW */;
    return {
      score: estimate,
      confidenceLevel: confidenceLevel
    };
  }
  /**
   * Returns last Representation which had reached a score superior to 1.
   * This Representation is the last known one which could be maintained.
   * Useful to know if a current guess is higher than what you should
   * normally be able to play.
   * `null` if no Representation ever reach that score.
   * @returns {Representation|null}
   */;
  _proto.getLastStableRepresentation = function getLastStableRepresentation() {
    return this._lastRepresentationWithGoodScore;
  };
  return RepresentationScoreCalculator;
}();

;// CONCATENATED MODULE: ./src/core/adaptive/utils/select_optimal_representation.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * From the given array of Representations (sorted by bitrate order ascending),
 * returns the one corresponding to the given optimal, minimum and maximum
 * bitrates.
 * @param {Array.<Representation>} representations - The representations array,
 * sorted in bitrate ascending order.
 * @param {Number} optimalBitrate - The optimal bitrate the Representation
 * should have under the current condition.
 * @param {Number} minBitrate - The minimum bitrate the chosen Representation
 * should have. We will take the Representation with the maximum bitrate if none
 * is found.
 * @param {Number} maxBitrate - The maximum bitrate the chosen Representation
 * should have. We will take the Representation with the minimum bitrate if none
 * is found.
 * @returns {Representation|undefined}
 */
function selectOptimalRepresentation(representations, optimalBitrate, minBitrate, maxBitrate) {
  var wantedBitrate = optimalBitrate <= minBitrate ? minBitrate : optimalBitrate >= maxBitrate ? maxBitrate : optimalBitrate;
  var firstIndexTooHigh = (0,array_find_index/* default */.A)(representations, function (representation) {
    return representation.bitrate > wantedBitrate;
  });
  if (firstIndexTooHigh === -1) {
    return representations[representations.length - 1];
  } else if (firstIndexTooHigh === 0) {
    return representations[0];
  }
  return representations[firstIndexTooHigh - 1];
}
;// CONCATENATED MODULE: ./src/core/adaptive/adaptive_representation_selector.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
















// Create default shared references
var manualBitrateDefaultRef = new reference/* default */.A(-1);
manualBitrateDefaultRef.finish();
var minAutoBitrateDefaultRef = new reference/* default */.A(0);
minAutoBitrateDefaultRef.finish();
var maxAutoBitrateDefaultRef = new reference/* default */.A(Infinity);
maxAutoBitrateDefaultRef.finish();
var limitWidthDefaultRef = new reference/* default */.A(undefined);
limitWidthDefaultRef.finish();
var throttleBitrateDefaultRef = new reference/* default */.A(Infinity);
throttleBitrateDefaultRef.finish();
/**
 * Select the most adapted Representation according to the network and buffer
 * metrics it receives.
 *
 * @param {Object} options - Initial configuration (see type definition)
 * @returns {Object} - Interface allowing to select a Representation.
 * @see IRepresentationEstimator
 */
function createAdaptiveRepresentationSelector(options) {
  /**
   * Allows to estimate the current network bandwidth.
   * One per active media type.
   */
  var bandwidthEstimators = {};
  var manualBitrates = options.manualBitrates,
    minAutoBitrates = options.minAutoBitrates,
    maxAutoBitrates = options.maxAutoBitrates,
    initialBitrates = options.initialBitrates,
    throttlers = options.throttlers,
    lowLatencyMode = options.lowLatencyMode;
  /**
   * Returns Object emitting Representation estimates as well as callbacks
   * allowing to helping it produce them.
   *
   * @see IRepresentationEstimator
   * @param {Object} context
   * @param {Object} currentRepresentation
   * @param {Object} representations
   * @param {Object} playbackObserver
   * @param {Object} stopAllEstimates
   * @returns {Array.<Object>}
   */
  return function getEstimates(context, currentRepresentation, representations, playbackObserver, stopAllEstimates) {
    var _a, _b, _c, _d, _e, _f, _g;
    var type = context.adaptation.type;
    var bandwidthEstimator = _getBandwidthEstimator(type);
    var manualBitrate = (_a = manualBitrates[type]) !== null && _a !== void 0 ? _a : manualBitrateDefaultRef;
    var minAutoBitrate = (_b = minAutoBitrates[type]) !== null && _b !== void 0 ? _b : minAutoBitrateDefaultRef;
    var maxAutoBitrate = (_c = maxAutoBitrates[type]) !== null && _c !== void 0 ? _c : maxAutoBitrateDefaultRef;
    var initialBitrate = (_d = initialBitrates[type]) !== null && _d !== void 0 ? _d : 0;
    var filters = {
      limitWidth: (_e = throttlers.limitWidth[type]) !== null && _e !== void 0 ? _e : limitWidthDefaultRef,
      throttleBitrate: (_g = (_f = throttlers.throttleBitrate[type]) !== null && _f !== void 0 ? _f : throttlers.throttle[type]) !== null && _g !== void 0 ? _g : throttleBitrateDefaultRef
    };
    return getEstimateReference({
      bandwidthEstimator: bandwidthEstimator,
      context: context,
      currentRepresentation: currentRepresentation,
      filters: filters,
      initialBitrate: initialBitrate,
      manualBitrate: manualBitrate,
      minAutoBitrate: minAutoBitrate,
      maxAutoBitrate: maxAutoBitrate,
      playbackObserver: playbackObserver,
      representations: representations,
      lowLatencyMode: lowLatencyMode
    }, stopAllEstimates);
  };
  /**
   * Returns interface allowing to estimate network throughtput for a given type.
   * @param {string} bufferType
   * @returns {Object}
   */
  function _getBandwidthEstimator(bufferType) {
    var originalBandwidthEstimator = bandwidthEstimators[bufferType];
    if (originalBandwidthEstimator == null) {
      log/* default */.A.debug("ABR: Creating new BandwidthEstimator for ", bufferType);
      var bandwidthEstimator = new BandwidthEstimator();
      bandwidthEstimators[bufferType] = bandwidthEstimator;
      return bandwidthEstimator;
    }
    return originalBandwidthEstimator;
  }
}
/**
 * Estimate regularly the current network bandwidth and the best Representation
 * that can be played according to the current network and playback conditions.
 *
 * `getEstimateReference` only does estimations for a given type (e.g.
 * "audio", "video" etc.) and Period.
 *
 * If estimates for multiple types and/or Periods are needed, you should
 * call `getEstimateReference` as many times.
 *
 * This function returns a tuple:
 *   - the first element being the object through which estimates will be produced
 *   - the second element being callbacks that have to be triggered at various
 *     events to help it doing those estimates.
 *
 * @param {Object} args
 * @param {Object} stopAllEstimates
 * @returns {Array.<Object>}
 */
function getEstimateReference(_ref, stopAllEstimates) {
  var bandwidthEstimator = _ref.bandwidthEstimator,
    context = _ref.context,
    currentRepresentation = _ref.currentRepresentation,
    filters = _ref.filters,
    initialBitrate = _ref.initialBitrate,
    lowLatencyMode = _ref.lowLatencyMode,
    manualBitrate = _ref.manualBitrate,
    maxAutoBitrate = _ref.maxAutoBitrate,
    minAutoBitrate = _ref.minAutoBitrate,
    playbackObserver = _ref.playbackObserver,
    representationsRef = _ref.representations;
  var scoreCalculator = new RepresentationScoreCalculator();
  var networkAnalyzer = new NetworkAnalyzer(initialBitrate !== null && initialBitrate !== void 0 ? initialBitrate : 0, lowLatencyMode);
  var requestsStore = new PendingRequestsStore();
  /**
   * Callback called each time a new segment is pushed, with the information on the
   * new pushed segment.
   */
  var onAddedSegment = noop/* default */.A;
  var callbacks = {
    metrics: onMetric,
    requestBegin: onRequestBegin,
    requestProgress: onRequestProgress,
    requestEnd: onRequestEnd,
    addedSegment: function addedSegment(val) {
      onAddedSegment(val);
    }
  };
  /**
   * `TaskCanceller` allowing to stop producing estimate.
   * This TaskCanceller is used both for restarting estimates with a new
   * configuration and to cancel them altogether.
   */
  var currentEstimatesCanceller = new task_canceller/* default */.Ay();
  currentEstimatesCanceller.linkToSignal(stopAllEstimates);
  // Create `SharedReference` on which estimates will be emitted.
  var estimateRef = createEstimateReference(representationsRef.getValue(), currentEstimatesCanceller.signal);
  representationsRef.onUpdate(restartEstimatesProductionFromCurrentConditions, {
    clearSignal: stopAllEstimates
  });
  return {
    estimates: estimateRef,
    callbacks: callbacks
  };
  function createEstimateReference(representations, innerCancellationSignal) {
    if (representations.length === 0) {
      // No Representation given, return `null` as documented
      return new reference/* default */.A({
        representation: null,
        bitrate: undefined,
        knownStableBitrate: undefined,
        manual: false,
        urgent: true
      });
    }
    if (representations.length === 1) {
      // There's only a single Representation. Just choose it.
      return new reference/* default */.A({
        bitrate: undefined,
        representation: representations[0],
        manual: false,
        urgent: true,
        knownStableBitrate: undefined
      });
    }
    /** If true, Representation estimates based on the buffer health might be used. */
    var allowBufferBasedEstimates = false;
    /**
     * Module calculating the optimal Representation based on the current
     * buffer's health (i.e. whether enough data is buffered, history of
     * buffer size etc.).
     */
    var bufferBasedChooser = new BufferBasedChooser(representations.map(function (r) {
      return r.bitrate;
    }));
    /** Store the previous estimate made here. */
    var prevEstimate = new LastEstimateStorage();
    /**
     * Module calculating the optimal Representation by "guessing it" with a
     * step-by-step algorithm.
     * Only used in very specific scenarios.
     */
    var guessBasedChooser = new GuessBasedChooser(scoreCalculator, prevEstimate);
    // get initial observation for initial estimate
    var lastPlaybackObservation = playbackObserver.getReference().getValue();
    /** Reference through which estimates are emitted. */
    var innerEstimateRef = new reference/* default */.A(getCurrentEstimate());
    // Listen to playback observations
    playbackObserver.listen(function (obs) {
      lastPlaybackObservation = obs;
      updateEstimate();
    }, {
      includeLastObservation: false,
      clearSignal: innerCancellationSignal
    });
    onAddedSegment = function onAddedSegment(val) {
      if (lastPlaybackObservation === null) {
        return;
      }
      var _lastPlaybackObservat = lastPlaybackObservation,
        position = _lastPlaybackObservat.position,
        speed = _lastPlaybackObservat.speed;
      var timeRanges = val.buffered;
      var bufferGap = (0,ranges/* getLeftSizeOfRange */.vK)(timeRanges, position.last);
      var representation = val.content.representation;
      var currentScore = scoreCalculator.getEstimate(representation);
      var currentBitrate = representation.bitrate;
      var observation = {
        bufferGap: bufferGap,
        currentBitrate: currentBitrate,
        currentScore: currentScore,
        speed: speed
      };
      bufferBasedChooser.onAddedSegment(observation);
      updateEstimate();
    };
    innerCancellationSignal.register(function () {
      onAddedSegment = noop/* default */.A;
    });
    manualBitrate.onUpdate(updateEstimate, {
      clearSignal: innerCancellationSignal
    });
    minAutoBitrate.onUpdate(updateEstimate, {
      clearSignal: innerCancellationSignal
    });
    maxAutoBitrate.onUpdate(updateEstimate, {
      clearSignal: innerCancellationSignal
    });
    filters.limitWidth.onUpdate(updateEstimate, {
      clearSignal: innerCancellationSignal
    });
    filters.limitWidth.onUpdate(updateEstimate, {
      clearSignal: innerCancellationSignal
    });
    return innerEstimateRef;
    function updateEstimate() {
      innerEstimateRef.setValue(getCurrentEstimate());
    }
    /** Returns the actual estimate based on all methods and algorithm available. */
    function getCurrentEstimate() {
      var manualBitrateVal = manualBitrate.getValue();
      if (manualBitrateVal >= 0) {
        // A manual bitrate has been set. Just choose Representation according to it.
        var manualRepresentation = selectOptimalRepresentation(representations, manualBitrateVal, 0, Infinity);
        return {
          representation: manualRepresentation,
          bitrate: undefined,
          // Bitrate estimation is deactivated here
          knownStableBitrate: undefined,
          manual: true,
          urgent: true // a manual bitrate switch should happen immediately
        };
      }
      var _lastPlaybackObservat2 = lastPlaybackObservation,
        bufferGap = _lastPlaybackObservat2.bufferGap,
        position = _lastPlaybackObservat2.position,
        maximumPosition = _lastPlaybackObservat2.maximumPosition;
      var widthLimit = filters.limitWidth.getValue();
      var bitrateThrottle = filters.throttleBitrate.getValue();
      var currentRepresentationVal = currentRepresentation.getValue();
      var minAutoBitrateVal = minAutoBitrate.getValue();
      var maxAutoBitrateVal = maxAutoBitrate.getValue();
      var filteredReps = getFilteredRepresentations(representations, widthLimit, bitrateThrottle);
      var requests = requestsStore.getRequests();
      var _networkAnalyzer$getB = networkAnalyzer.getBandwidthEstimate(lastPlaybackObservation, bandwidthEstimator, currentRepresentationVal, requests, prevEstimate.bandwidth),
        bandwidthEstimate = _networkAnalyzer$getB.bandwidthEstimate,
        bitrateChosen = _networkAnalyzer$getB.bitrateChosen;
      var stableRepresentation = scoreCalculator.getLastStableRepresentation();
      var knownStableBitrate = stableRepresentation === null ? undefined : stableRepresentation.bitrate / (lastPlaybackObservation.speed > 0 ? lastPlaybackObservation.speed : 1);
      var _config$getCurrent = config/* default */.A.getCurrent(),
        ABR_ENTER_BUFFER_BASED_ALGO = _config$getCurrent.ABR_ENTER_BUFFER_BASED_ALGO,
        ABR_EXIT_BUFFER_BASED_ALGO = _config$getCurrent.ABR_EXIT_BUFFER_BASED_ALGO;
      if (allowBufferBasedEstimates && bufferGap <= ABR_EXIT_BUFFER_BASED_ALGO) {
        allowBufferBasedEstimates = false;
      } else if (!allowBufferBasedEstimates && isFinite(bufferGap) && bufferGap >= ABR_ENTER_BUFFER_BASED_ALGO) {
        allowBufferBasedEstimates = true;
      }
      /**
       * Representation chosen when considering only [pessimist] bandwidth
       * calculation.
       * This is a safe enough choice but might be lower than what the user
       * could actually profit from.
       */
      var chosenRepFromBandwidth = selectOptimalRepresentation(filteredReps, bitrateChosen, minAutoBitrateVal, maxAutoBitrateVal);
      /**
       * Current optimal Representation's bandwidth choosen by a buffer-based
       * adaptive algorithm.
       */
      var currentBufferBasedEstimate = bufferBasedChooser.getLastEstimate();
      var currentBestBitrate = chosenRepFromBandwidth.bitrate;
      /**
       * Representation chosen when considering the current buffer size.
       * If defined, takes precedence over `chosenRepFromBandwidth`.
       *
       * This is a very safe choice, yet it is very slow and might not be
       * adapted to cases where a buffer cannot be build, such as live contents.
       *
       * `null` if this buffer size mode is not enabled or if we don't have a
       * choice from it yet.
       */
      var chosenRepFromBufferSize = null;
      if (allowBufferBasedEstimates && currentBufferBasedEstimate !== undefined && currentBufferBasedEstimate > currentBestBitrate) {
        chosenRepFromBufferSize = selectOptimalRepresentation(filteredReps, currentBufferBasedEstimate, minAutoBitrateVal, maxAutoBitrateVal);
        currentBestBitrate = chosenRepFromBufferSize.bitrate;
      }
      /**
       * Representation chosen by the more adventurous `GuessBasedChooser`,
       * which iterates through Representations one by one until finding one
       * that cannot be "maintained".
       *
       * If defined, takes precedence over both `chosenRepFromBandwidth` and
       * `chosenRepFromBufferSize`.
       *
       * This is the riskiest choice (in terms of rebuffering chances) but is
       * only enabled when no other solution is adapted (for now, this just
       * applies for low-latency contents when playing close to the live
       * edge).
       *
       * `null` if not enabled or if there's currently no guess.
       */
      var chosenRepFromGuessMode = null;
      if (lowLatencyMode && currentRepresentationVal !== null && context.manifest.isDynamic && maximumPosition - position.last < 40) {
        chosenRepFromGuessMode = guessBasedChooser.getGuess(representations, lastPlaybackObservation, currentRepresentationVal, currentBestBitrate, requests);
      }
      if (chosenRepFromGuessMode !== null && chosenRepFromGuessMode.bitrate > currentBestBitrate) {
        log/* default */.A.debug("ABR: Choosing representation with guess-based estimation.", chosenRepFromGuessMode.bitrate, chosenRepFromGuessMode.id);
        prevEstimate.update(chosenRepFromGuessMode, bandwidthEstimate, 2 /* ABRAlgorithmType.GuessBased */);
        return {
          bitrate: bandwidthEstimate,
          representation: chosenRepFromGuessMode,
          urgent: currentRepresentationVal === null || chosenRepFromGuessMode.bitrate < currentRepresentationVal.bitrate,
          manual: false,
          knownStableBitrate: knownStableBitrate
        };
      } else if (chosenRepFromBufferSize !== null) {
        log/* default */.A.debug("ABR: Choosing representation with buffer-based estimation.", chosenRepFromBufferSize.bitrate, chosenRepFromBufferSize.id);
        prevEstimate.update(chosenRepFromBufferSize, bandwidthEstimate, 0 /* ABRAlgorithmType.BufferBased */);
        return {
          bitrate: bandwidthEstimate,
          representation: chosenRepFromBufferSize,
          urgent: networkAnalyzer.isUrgent(chosenRepFromBufferSize.bitrate, currentRepresentationVal, requests, lastPlaybackObservation),
          manual: false,
          knownStableBitrate: knownStableBitrate
        };
      } else {
        log/* default */.A.debug("ABR: Choosing representation with bandwidth estimation.", chosenRepFromBandwidth.bitrate, chosenRepFromBandwidth.id);
        prevEstimate.update(chosenRepFromBandwidth, bandwidthEstimate, 1 /* ABRAlgorithmType.BandwidthBased */);
        return {
          bitrate: bandwidthEstimate,
          representation: chosenRepFromBandwidth,
          urgent: networkAnalyzer.isUrgent(chosenRepFromBandwidth.bitrate, currentRepresentationVal, requests, lastPlaybackObservation),
          manual: false,
          knownStableBitrate: knownStableBitrate
        };
      }
    }
  }
  /**
   * Stop previous estimate production (if one) and restart it considering new
   * conditions (such as a manual bitrate and/or a new list of Representations).
   */
  function restartEstimatesProductionFromCurrentConditions() {
    var representations = representationsRef.getValue();
    currentEstimatesCanceller.cancel();
    currentEstimatesCanceller = new task_canceller/* default */.Ay();
    currentEstimatesCanceller.linkToSignal(stopAllEstimates);
    var newRef = createEstimateReference(representations, currentEstimatesCanceller.signal);
    newRef.onUpdate(function onNewEstimate(newEstimate) {
      estimateRef.setValue(newEstimate);
    }, {
      clearSignal: currentEstimatesCanceller.signal,
      emitCurrentValue: true
    });
  }
  /**
   * Callback to call when new metrics are available
   * @param {Object} value
   */
  function onMetric(value) {
    var requestDuration = value.requestDuration,
      segmentDuration = value.segmentDuration,
      size = value.size,
      content = value.content;
    // calculate bandwidth
    bandwidthEstimator.addSample(requestDuration, size);
    if (!content.segment.isInit) {
      // calculate "maintainability score"
      var segment = content.segment,
        representation = content.representation;
      if (segmentDuration === undefined && !segment.complete) {
        // We cannot know the real duration of the segment
        return;
      }
      var segDur = segmentDuration !== null && segmentDuration !== void 0 ? segmentDuration : segment.duration;
      scoreCalculator.addSample(representation, requestDuration / 1000, segDur);
    }
  }
  /** Callback called when a new request begins. */
  function onRequestBegin(val) {
    requestsStore.add(val);
  }
  /** Callback called when progress information is known on a pending request. */
  function onRequestProgress(val) {
    requestsStore.addProgress(val);
  }
  /** Callback called when a pending request ends. */
  function onRequestEnd(val) {
    requestsStore.remove(val.id);
  }
}
/**
 * Filter representations given through filters options.
 * @param {Array.<Representation>} representations
 * @param {number | undefined} widthLimit - Filter Object.
 * @returns {Array.<Representation>}
 */
function getFilteredRepresentations(representations, widthLimit, bitrateThrottle) {
  var filteredReps = representations;
  if (bitrateThrottle < Infinity) {
    filteredReps = filterByBitrate(filteredReps, bitrateThrottle);
  }
  if (widthLimit !== undefined) {
    filteredReps = filterByWidth(filteredReps, widthLimit);
  }
  return filteredReps;
}
;// CONCATENATED MODULE: ./src/core/adaptive/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ var adaptive = (createAdaptiveRepresentationSelector);
// EXTERNAL MODULE: ./src/core/decrypt/get_key_system_configuration.ts
var get_key_system_configuration = __webpack_require__(5283);
// EXTERNAL MODULE: ./src/errors/format_error.ts
var format_error = __webpack_require__(874);
// EXTERNAL MODULE: ./src/manifest/index.ts + 6 modules
var manifest = __webpack_require__(8568);
// EXTERNAL MODULE: ./src/utils/event_emitter.ts
var event_emitter = __webpack_require__(79);
// EXTERNAL MODULE: ./src/utils/is_null_or_undefined.ts
var is_null_or_undefined = __webpack_require__(6787);
// EXTERNAL MODULE: ./src/errors/request_error.ts
var request_error = __webpack_require__(3506);
// EXTERNAL MODULE: ./src/errors/network_error.ts
var network_error = __webpack_require__(7941);
;// CONCATENATED MODULE: ./src/core/fetchers/utils/error_selector.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Generate a new error from the infos given.
 * @param {string} code
 * @param {Error} error
 * @returns {Error}
 */
function errorSelector(error) {
  if (error instanceof request_error/* default */.A) {
    return new network_error/* default */.A("PIPELINE_LOAD_ERROR", error);
  }
  return (0,format_error/* default */.A)(error, {
    defaultCode: "PIPELINE_LOAD_ERROR",
    defaultReason: "Unknown error when fetching the Manifest"
  });
}
;// CONCATENATED MODULE: ./src/compat/is_offline.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Some browsers have a builtin API to know if it's connected at least to a
 * LAN network, at most to the internet.
 *
 * /!\ This feature can be dangerous as you can both have false positives and
 * false negatives.
 *
 * False positives:
 *   - you can still play local contents (on localhost) if isOffline == true
 *   - on some browsers isOffline might be true even if we're connected to a LAN
 *     or a router (it would mean we're just not able to connect to the
 *     Internet). So we can eventually play LAN contents if isOffline == true
 *
 * False negatives:
 *   - in some cases, we even might have isOffline at false when we do not have
 *     any connection:
 *       - in browsers that do not support the feature
 *       - in browsers running in some virtualization softwares where the
 *         network adapters are always connected.
 *
 * Use with these cases in mind.
 * @returns {Boolean}
 */
function isOffline() {
  /* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */
  return navigator.onLine === false;
  /* eslint-enable @typescript-eslint/no-unnecessary-boolean-literal-compare */
}
// EXTERNAL MODULE: ./src/errors/error_codes.ts
var error_codes = __webpack_require__(5497);
// EXTERNAL MODULE: ./src/errors/custom_loader_error.ts
var custom_loader_error = __webpack_require__(7004);
// EXTERNAL MODULE: ./src/errors/is_known_error.ts
var is_known_error = __webpack_require__(4637);
// EXTERNAL MODULE: ./src/utils/cancellable_sleep.ts
var cancellable_sleep = __webpack_require__(2432);
// EXTERNAL MODULE: ./src/utils/get_fuzzed_delay.ts
var get_fuzzed_delay = __webpack_require__(7021);
;// CONCATENATED MODULE: ./src/core/fetchers/utils/schedule_request.ts


/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */







/**
 * Called on a loader error.
 * Returns whether the loader request should be retried.
 *
 * TODO the notion of retrying or not could be transport-specific (e.g. 412 are
 * mainly used for Smooth contents) and thus as part of the transport code (e.g.
 * by rejecting with an error always having a `canRetry` property?).
 * Or not, to ponder.
 *
 * @param {Error} error
 * @returns {Boolean} - If true, the request can be retried.
 */
function shouldRetry(error) {
  if (error instanceof request_error/* default */.A) {
    if (error.type === error_codes/* NetworkErrorTypes */.yl.ERROR_HTTP_CODE) {
      return error.status >= 500 || error.status === 404 || error.status === 415 ||
      // some CDN seems to use that code when
      // requesting low-latency segments too much
      // in advance
      error.status === 412;
    }
    return error.type === error_codes/* NetworkErrorTypes */.yl.TIMEOUT || error.type === error_codes/* NetworkErrorTypes */.yl.ERROR_EVENT;
  } else if (error instanceof custom_loader_error/* default */.A) {
    if (typeof error.canRetry === "boolean") {
      return error.canRetry;
    }
    if (error.xhr !== undefined) {
      return error.xhr.status >= 500 || error.xhr.status === 404 || error.xhr.status === 415 ||
      // some CDN seems to use that code when
      // requesting low-latency segments too much
      // in advance
      error.xhr.status === 412;
    }
    return false;
  }
  return (0,is_known_error/* default */.A)(error) && error.code === "INTEGRITY_ERROR";
}
/**
 * Returns true if we're pretty sure that the current error is due to the
 * user being offline.
 * @param {Error} error
 * @returns {Boolean}
 */
function isOfflineRequestError(error) {
  if (error instanceof request_error/* default */.A) {
    return error.type === error_codes/* NetworkErrorTypes */.yl.ERROR_EVENT && isOffline();
  } else if (error instanceof custom_loader_error/* default */.A) {
    return error.isOfflineError;
  }
  return false; // under doubt, return false
}
/**
 * Guess the type of error obtained.
 * @param {*} error
 * @returns {number}
 */
function getRequestErrorType(error) {
  return isOfflineRequestError(error) ? 2 /* REQUEST_ERROR_TYPES.Offline */ : 1 /* REQUEST_ERROR_TYPES.Regular */;
}
/**
 * Specific algorithm used to perform segment and manifest requests.
 *
 * Here how it works:
 *
 *   1. You give it one or multiple of the CDN available for the resource you
 *      want to request (from the most important one to the least important),
 *      a callback doing the request with the chosen CDN in argument, and some
 *      options.
 *
 *   2. it tries to call the request callback with the most prioritized CDN
 *      first:
 *        - if it works as expected, it resolves the returned Promise with that
 *          request's response.
 *        - if it fails, it calls ther `onRetry` callback given with the
 *          corresponding error, un-prioritize that CDN and try with the new
 *          most prioritized CDN.
 *
 *      Each CDN might be retried multiple times, depending on the nature of the
 *      error and the Configuration given.
 *
 *      Multiple retries of the same CDN are done after a delay to avoid
 *      overwhelming it, this is what we call a "backoff". That delay raises
 *      exponentially as multiple consecutive errors are encountered on this
 *      CDN.
 *
 * @param {Array.<string>|null} cdns - The different CDN on which the
 * wanted resource is available. `scheduleRequestWithCdns` will call the
 * `performRequest` callback with the right element from that array if different
 * from `null`.
 *
 * Can be set to `null` when that resource is not reachable through a CDN, in
 * which case the `performRequest` callback may be called with `null`.
 * @param {Object|null} cdnPrioritizer - Interface allowing to give the priority
 * between multiple CDNs.
 * @param {Function} performRequest - Callback implementing the request in
 * itself. Resolving when the resource request succeed and rejecting with the
 * corresponding error when the request failed.
 * @param {Object} options - Configuration allowing to tweak the number on which
 * the algorithm behind `scheduleRequestWithCdns` bases itself.
 * @param {Object} cancellationSignal - CancellationSignal allowing to cancel
 * the logic of `scheduleRequestWithCdns`.
 * To trigger if the resource is not needed anymore.
 * @returns {Promise} - Promise resolving, with the corresponding
 * `performRequest`'s data, when the resource request succeed and rejecting in
 * the following scenarios:
 *   - `scheduleRequestWithCdns` has been cancelled due to `cancellationSignal`
 *     being triggered. In that case a `CancellationError` is thrown.
 *
 *   - The resource request(s) failed and will not be retried anymore.
 */
function scheduleRequestWithCdns(_x, _x2, _x3, _x4, _x5) {
  return _scheduleRequestWithCdns.apply(this, arguments);
}
/**
 * Lightweight version of the request algorithm, this time with only a simple
 * Promise given.
 * @param {Function} performRequest
 * @param {Object} options
 * @returns {Promise}
 */
function _scheduleRequestWithCdns() {
  _scheduleRequestWithCdns = (0,asyncToGenerator/* default */.A)( /*#__PURE__*/regenerator_default().mark(function _callee3(cdns, cdnPrioritizer, performRequest, options, cancellationSignal) {
    var baseDelay, maxDelay, maxRetryRegular, maxRetryOffline, onRetry, missedAttempts, initialCdnToRequest, getCdnToRequest, requestCdn, _requestCdn, retryWithNextCdn, _retryWithNextCdn, waitPotentialBackoffAndRequest, getPrioritaryRequestableCdnFromSortedList;
    return regenerator_default().wrap(function _callee3$(_context3) {
      while (1) switch (_context3.prev = _context3.next) {
        case 0:
          getPrioritaryRequestableCdnFromSortedList = function _getPrioritaryRequest(sortedCdns) {
            var _a;
            if (missedAttempts.size === 0) {
              return sortedCdns[0];
            }
            var now = performance.now();
            return (_a = sortedCdns.filter(function (c) {
              var _a;
              return ((_a = missedAttempts.get(c)) === null || _a === void 0 ? void 0 : _a.isBlacklisted) !== true;
            }).reduce(function (acc, x) {
              var _a;
              var blockedUntil = (_a = missedAttempts.get(x)) === null || _a === void 0 ? void 0 : _a.blockedUntil;
              if (blockedUntil !== undefined && blockedUntil <= now) {
                blockedUntil = undefined;
              }
              if (acc === undefined) {
                return [x, blockedUntil];
              }
              if (blockedUntil === undefined) {
                if (acc[1] === undefined) {
                  return acc;
                }
                return [x, undefined];
              }
              return acc[1] === undefined ? acc : blockedUntil < acc[1] ? [x, blockedUntil] : acc;
            }, undefined)) === null || _a === void 0 ? void 0 : _a[0];
          };
          waitPotentialBackoffAndRequest = function _waitPotentialBackoff(nextWantedCdn, prevRequestError) {
            var nextCdnAttemptObj = missedAttempts.get(nextWantedCdn);
            if (nextCdnAttemptObj === undefined || nextCdnAttemptObj.blockedUntil === undefined) {
              return requestCdn(nextWantedCdn);
            }
            var now = performance.now();
            var blockedFor = nextCdnAttemptObj.blockedUntil - now;
            if (blockedFor <= 0) {
              return requestCdn(nextWantedCdn);
            }
            var canceller = new task_canceller/* default */.Ay();
            var unlinkCanceller = canceller.linkToSignal(cancellationSignal);
            return new Promise(function (res, rej) {
              /* eslint-disable-next-line @typescript-eslint/no-misused-promises */
              cdnPrioritizer === null || cdnPrioritizer === void 0 ? void 0 : cdnPrioritizer.addEventListener("priorityChange", function () {
                var updatedPrioritaryCdn = getCdnToRequest();
                if (cancellationSignal.isCancelled()) {
                  throw cancellationSignal.cancellationError;
                }
                if (updatedPrioritaryCdn === undefined) {
                  return cleanAndReject(prevRequestError);
                }
                if (updatedPrioritaryCdn !== nextWantedCdn) {
                  canceller.cancel();
                  waitPotentialBackoffAndRequest(updatedPrioritaryCdn, prevRequestError).then(cleanAndResolve, cleanAndReject);
                }
              }, canceller.signal);
              (0,cancellable_sleep/* default */.A)(blockedFor, canceller.signal).then(function () {
                return requestCdn(nextWantedCdn).then(cleanAndResolve, cleanAndReject);
              }, noop/* default */.A);
              function cleanAndResolve(response) {
                unlinkCanceller();
                res(response);
              }
              function cleanAndReject(err) {
                unlinkCanceller();
                rej(err);
              }
            });
          };
          _retryWithNextCdn = function _retryWithNextCdn3() {
            _retryWithNextCdn = (0,asyncToGenerator/* default */.A)( /*#__PURE__*/regenerator_default().mark(function _callee2(prevRequestError) {
              var nextCdn;
              return regenerator_default().wrap(function _callee2$(_context2) {
                while (1) switch (_context2.prev = _context2.next) {
                  case 0:
                    nextCdn = getCdnToRequest();
                    if (!cancellationSignal.isCancelled()) {
                      _context2.next = 3;
                      break;
                    }
                    throw cancellationSignal.cancellationError;
                  case 3:
                    if (!(nextCdn === undefined)) {
                      _context2.next = 5;
                      break;
                    }
                    throw prevRequestError;
                  case 5:
                    onRetry(prevRequestError);
                    if (!cancellationSignal.isCancelled()) {
                      _context2.next = 8;
                      break;
                    }
                    throw cancellationSignal.cancellationError;
                  case 8:
                    return _context2.abrupt("return", waitPotentialBackoffAndRequest(nextCdn, prevRequestError));
                  case 9:
                  case "end":
                    return _context2.stop();
                }
              }, _callee2);
            }));
            return _retryWithNextCdn.apply(this, arguments);
          };
          retryWithNextCdn = function _retryWithNextCdn2(_x7) {
            return _retryWithNextCdn.apply(this, arguments);
          };
          _requestCdn = function _requestCdn3() {
            _requestCdn = (0,asyncToGenerator/* default */.A)( /*#__PURE__*/regenerator_default().mark(function _callee(cdn) {
              var res, currentErrorType, missedAttemptsObj, maxRetry, errorCounter, delay, fuzzedDelay;
              return regenerator_default().wrap(function _callee$(_context) {
                while (1) switch (_context.prev = _context.next) {
                  case 0:
                    _context.prev = 0;
                    _context.next = 3;
                    return performRequest(cdn, cancellationSignal);
                  case 3:
                    res = _context.sent;
                    return _context.abrupt("return", res);
                  case 7:
                    _context.prev = 7;
                    _context.t0 = _context["catch"](0);
                    if (!task_canceller/* default */.Ay.isCancellationError(_context.t0)) {
                      _context.next = 11;
                      break;
                    }
                    throw _context.t0;
                  case 11:
                    if (cdn !== null && cdnPrioritizer !== null) {
                      // We failed requesting the resource on this CDN.
                      // Globally give priority to the next CDN through the CdnPrioritizer.
                      cdnPrioritizer.downgradeCdn(cdn);
                    }
                    currentErrorType = getRequestErrorType(_context.t0);
                    missedAttemptsObj = missedAttempts.get(cdn);
                    if (missedAttemptsObj === undefined) {
                      missedAttemptsObj = {
                        errorCounter: 1,
                        lastErrorType: currentErrorType,
                        blockedUntil: undefined,
                        isBlacklisted: false
                      };
                      missedAttempts.set(cdn, missedAttemptsObj);
                    } else {
                      if (currentErrorType !== missedAttemptsObj.lastErrorType) {
                        missedAttemptsObj.errorCounter = 1;
                        missedAttemptsObj.lastErrorType = currentErrorType;
                      } else {
                        missedAttemptsObj.errorCounter++;
                      }
                    }
                    if (shouldRetry(_context.t0)) {
                      _context.next = 19;
                      break;
                    }
                    missedAttemptsObj.blockedUntil = undefined;
                    missedAttemptsObj.isBlacklisted = true;
                    return _context.abrupt("return", retryWithNextCdn(_context.t0));
                  case 19:
                    maxRetry = currentErrorType === 2 /* REQUEST_ERROR_TYPES.Offline */ ? maxRetryOffline : maxRetryRegular;
                    if (missedAttemptsObj.errorCounter > maxRetry) {
                      missedAttemptsObj.blockedUntil = undefined;
                      missedAttemptsObj.isBlacklisted = true;
                    } else {
                      errorCounter = missedAttemptsObj.errorCounter;
                      delay = Math.min(baseDelay * Math.pow(2, errorCounter - 1), maxDelay);
                      fuzzedDelay = (0,get_fuzzed_delay/* default */.A)(delay);
                      missedAttemptsObj.blockedUntil = performance.now() + fuzzedDelay;
                    }
                    return _context.abrupt("return", retryWithNextCdn(_context.t0));
                  case 22:
                  case "end":
                    return _context.stop();
                }
              }, _callee, null, [[0, 7]]);
            }));
            return _requestCdn.apply(this, arguments);
          };
          requestCdn = function _requestCdn2(_x6) {
            return _requestCdn.apply(this, arguments);
          };
          getCdnToRequest = function _getCdnToRequest() {
            if (cdns === null) {
              var nullAttemptObject = missedAttempts.get(null);
              if (nullAttemptObject !== undefined && nullAttemptObject.isBlacklisted) {
                return undefined;
              }
              return null;
            } else if (cdnPrioritizer === null) {
              return getPrioritaryRequestableCdnFromSortedList(cdns);
            } else {
              var prioritized = cdnPrioritizer.getCdnPreferenceForResource(cdns);
              return getPrioritaryRequestableCdnFromSortedList(prioritized);
            }
          };
          if (!(cancellationSignal.cancellationError !== null)) {
            _context3.next = 9;
            break;
          }
          return _context3.abrupt("return", Promise.reject(cancellationSignal.cancellationError));
        case 9:
          baseDelay = options.baseDelay, maxDelay = options.maxDelay, maxRetryRegular = options.maxRetryRegular, maxRetryOffline = options.maxRetryOffline, onRetry = options.onRetry;
          if (cdns !== null && cdns.length === 0) {
            log/* default */.A.warn("Fetchers: no CDN given to `scheduleRequestWithCdns`.");
          }
          missedAttempts = new Map();
          initialCdnToRequest = getCdnToRequest();
          if (!(initialCdnToRequest === undefined)) {
            _context3.next = 15;
            break;
          }
          throw new Error("No CDN to request");
        case 15:
          return _context3.abrupt("return", requestCdn(initialCdnToRequest));
        case 16:
        case "end":
          return _context3.stop();
      }
    }, _callee3);
  }));
  return _scheduleRequestWithCdns.apply(this, arguments);
}
function scheduleRequestPromise(performRequest, options, cancellationSignal) {
  // same than for a single unknown CDN
  return scheduleRequestWithCdns(null, null, performRequest, options, cancellationSignal);
}
;// CONCATENATED MODULE: ./src/core/fetchers/manifest/manifest_fetcher.ts


function manifest_fetcher_createForOfIteratorHelperLoose(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (t) return (t = t.call(r)).next.bind(t); if (Array.isArray(r) || (t = manifest_fetcher_unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var o = 0; return function () { return o >= r.length ? { done: !0 } : { done: !1, value: r[o++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function manifest_fetcher_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return manifest_fetcher_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? manifest_fetcher_arrayLikeToArray(r, a) : void 0; } }
function manifest_fetcher_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */











/**
 * Class allowing to facilitate the task of loading and parsing a Manifest, as
 * well as automatically refreshing it.
 * @class ManifestFetcher
 */
var ManifestFetcher = /*#__PURE__*/function (_EventEmitter) {
  /**
   * Construct a new ManifestFetcher.
   * @param {Array.<string> | undefined} urls - Manifest URLs, will be used when
   * no URL is provided to the `fetch` function.
   * `undefined` if unknown or if a Manifest should be retrieved through other
   * means than an HTTP request.
   * @param {Object} pipelines - Transport pipelines used to perform the
   * Manifest loading and parsing operations.
   * @param {Object} settings - Configure the `ManifestFetcher`.
   */
  function ManifestFetcher(urls, pipelines, settings) {
    var _this;
    _this = _EventEmitter.call(this) || this;
    _this.scheduleManualRefresh = noop/* default */.A;
    _this._manifestUrls = urls;
    _this._pipelines = pipelines.manifest;
    _this._settings = settings;
    _this._canceller = new task_canceller/* default */.Ay();
    _this._isStarted = false;
    _this._isRefreshPending = false;
    _this._consecutiveUnsafeMode = 0;
    _this._prioritizedContentUrl = null;
    return _this;
  }
  /**
   * Free resources and stop refresh mechanism from happening.
   *
   * Once `dispose` has been called. This `ManifestFetcher` cannot be relied on
   * anymore.
   */
  (0,inheritsLoose/* default */.A)(ManifestFetcher, _EventEmitter);
  var _proto = ManifestFetcher.prototype;
  _proto.dispose = function dispose() {
    this._canceller.cancel();
    this.removeEventListener();
  }
  /**
   * Start requesting the Manifest as well as the Manifest refreshing logic, if
   * needed.
   *
   * Once `start` has been called, this mechanism can only be stopped by calling
   * `dispose`.
   */;
  _proto.start = function start() {
    var _this2 = this;
    if (this._isStarted) {
      return;
    }
    this._isStarted = true;
    var manifestProm;
    var initialManifest = this._settings.initialManifest;
    if (initialManifest instanceof manifest/* default */.Ay) {
      manifestProm = Promise.resolve({
        manifest: initialManifest
      });
    } else if (initialManifest !== undefined) {
      manifestProm = this.parse(initialManifest, {
        previousManifest: null,
        unsafeMode: false
      }, undefined);
    } else {
      manifestProm = this._fetchManifest(undefined).then(function (val) {
        return val.parse({
          previousManifest: null,
          unsafeMode: false
        });
      });
    }
    manifestProm.then(function (val) {
      _this2.trigger("manifestReady", val.manifest);
      if (!_this2._canceller.isUsed()) {
        _this2._recursivelyRefreshManifest(val.manifest, val);
      }
    })["catch"](function (err) {
      return _this2._onFatalError(err);
    });
  }
  /**
   * Update URL of the fetched Manifest.
   * @param {Array.<string> | undefined} urls - New Manifest URLs by order of
   * priority or `undefined` if there's now no URL.
   * @param {boolean} refreshNow - If set to `true`, the next Manifest refresh
   * will be triggered immediately.
   */;
  _proto.updateContentUrls = function updateContentUrls(urls, refreshNow) {
    var _a;
    this._prioritizedContentUrl = (_a = urls === null || urls === void 0 ? void 0 : urls[0]) !== null && _a !== void 0 ? _a : undefined;
    if (refreshNow) {
      this.scheduleManualRefresh({
        enablePartialRefresh: false,
        delay: 0,
        canUseUnsafeMode: false
      });
    }
  }
  /**
   * (re-)Load the Manifest.
   * This method does not yet parse it, parsing will then be available through
   * a callback available on the response.
   *
   * You can set an `url` on which that Manifest will be requested.
   * If not set, the regular Manifest url - defined on the `ManifestFetcher`
   * instanciation - will be used instead.
   *
   * @param {string | undefined} url
   * @returns {Promise}
   */;
  _proto._fetchManifest =
  /*#__PURE__*/
  function () {
    var _fetchManifest2 = (0,asyncToGenerator/* default */.A)( /*#__PURE__*/regenerator_default().mark(function _callee(url) {
      var _this3 = this;
      var _a, cancelSignal, settings, pipelines, requestUrl, backoffSettings, loadingPromise, response, callResolverWithRetries, callLoaderWithRetries;
      return regenerator_default().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            callLoaderWithRetries = function _callLoaderWithRetrie(manifestUrl) {
              var loadManifest = pipelines.loadManifest;
              var requestTimeout = (0,is_null_or_undefined/* default */.A)(settings.requestTimeout) ? config/* default */.A.getCurrent().DEFAULT_REQUEST_TIMEOUT : settings.requestTimeout;
              if (requestTimeout < 0) {
                requestTimeout = undefined;
              }
              var callLoader = function callLoader() {
                return loadManifest(manifestUrl, {
                  timeout: requestTimeout
                }, cancelSignal);
              };
              return scheduleRequestPromise(callLoader, backoffSettings, cancelSignal);
            };
            callResolverWithRetries = function _callResolverWithRetr(resolverUrl) {
              var resolveManifestUrl = pipelines.resolveManifestUrl;
              (0,assert/* default */.h)(resolveManifestUrl !== undefined);
              var callResolver = function callResolver() {
                return resolveManifestUrl(resolverUrl, cancelSignal);
              };
              return scheduleRequestPromise(callResolver, backoffSettings, cancelSignal);
            };
            cancelSignal = this._canceller.signal;
            settings = this._settings;
            pipelines = this._pipelines; // TODO Better handle multiple Manifest URLs
            requestUrl = url !== null && url !== void 0 ? url : (_a = this._manifestUrls) === null || _a === void 0 ? void 0 : _a[0];
            backoffSettings = this._getBackoffSetting(function (err) {
              _this3.trigger("warning", errorSelector(err));
            });
            loadingPromise = pipelines.resolveManifestUrl === undefined ? callLoaderWithRetries(requestUrl) : callResolverWithRetries(requestUrl).then(callLoaderWithRetries);
            _context.prev = 8;
            _context.next = 11;
            return loadingPromise;
          case 11:
            response = _context.sent;
            return _context.abrupt("return", {
              parse: function parse(parserOptions) {
                return _this3._parseLoadedManifest(response, parserOptions, requestUrl);
              }
            });
          case 15:
            _context.prev = 15;
            _context.t0 = _context["catch"](8);
            throw errorSelector(_context.t0);
          case 18:
          case "end":
            return _context.stop();
        }
      }, _callee, this, [[8, 15]]);
    }));
    function _fetchManifest(_x) {
      return _fetchManifest2.apply(this, arguments);
    }
    return _fetchManifest;
  }()
  /**
   * Parse an already loaded Manifest.
   *
   * This method should be reserved for Manifests for which no request has been
   * done.
   * In other cases, it's preferable to go through the `fetch` method, so
   * information on the request can be used by the parsing process.
   * @param {*} manifest
   * @param {Object} parserOptions
   * @param {string | undefined} originalUrl
   * @returns {Promise}
   */
  ;
  _proto.parse = function parse(manifest, parserOptions, originalUrl) {
    return this._parseLoadedManifest({
      responseData: manifest,
      size: undefined,
      requestDuration: undefined
    }, parserOptions, originalUrl);
  }
  /**
   * Parse a Manifest.
   *
   * @param {Object} loaded - Information about the loaded Manifest as well as
   * about the corresponding request.
   * @param {Object} parserOptions - Options used when parsing the Manifest.
   * @param {string | undefined} requestUrl
   * @returns {Promise}
   */;
  _proto._parseLoadedManifest =
  /*#__PURE__*/
  function () {
    var _parseLoadedManifest2 = (0,asyncToGenerator/* default */.A)( /*#__PURE__*/regenerator_default().mark(function _callee3(loaded, parserOptions, requestUrl) {
      var _this4 = this;
      var _a, parsingTimeStart, cancelSignal, trigger, sendingTime, receivedTime, backoffSettings, originalUrl, opts, res, _yield$res, manifest, formattedError, scheduleRequest, _scheduleRequest, onWarnings, finish;
      return regenerator_default().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            finish = function _finish(manifest) {
              onWarnings(manifest.contentWarnings);
              var parsingTime = performance.now() - parsingTimeStart;
              log/* default */.A.info("MF: Manifest parsed in " + parsingTime + "ms");
              return {
                manifest: manifest,
                sendingTime: sendingTime,
                receivedTime: receivedTime,
                parsingTime: parsingTime
              };
            };
            onWarnings = function _onWarnings(warnings) {
              for (var _iterator = manifest_fetcher_createForOfIteratorHelperLoose(warnings), _step; !(_step = _iterator()).done;) {
                var warning = _step.value;
                if (cancelSignal.isCancelled()) {
                  return;
                }
                var _formattedError = (0,format_error/* default */.A)(warning, {
                  defaultCode: "PIPELINE_PARSE_ERROR",
                  defaultReason: "Unknown error when parsing the Manifest"
                });
                trigger("warning", _formattedError);
              }
            };
            _scheduleRequest = function _scheduleRequest3() {
              _scheduleRequest = (0,asyncToGenerator/* default */.A)( /*#__PURE__*/regenerator_default().mark(function _callee2(performRequest) {
                var data;
                return regenerator_default().wrap(function _callee2$(_context2) {
                  while (1) switch (_context2.prev = _context2.next) {
                    case 0:
                      _context2.prev = 0;
                      _context2.next = 3;
                      return scheduleRequestPromise(performRequest, backoffSettings, cancelSignal);
                    case 3:
                      data = _context2.sent;
                      return _context2.abrupt("return", data);
                    case 7:
                      _context2.prev = 7;
                      _context2.t0 = _context2["catch"](0);
                      throw errorSelector(_context2.t0);
                    case 10:
                    case "end":
                      return _context2.stop();
                  }
                }, _callee2, null, [[0, 7]]);
              }));
              return _scheduleRequest.apply(this, arguments);
            };
            scheduleRequest = function _scheduleRequest2(_x5) {
              return _scheduleRequest.apply(this, arguments);
            };
            parsingTimeStart = performance.now();
            cancelSignal = this._canceller.signal;
            trigger = this.trigger.bind(this);
            sendingTime = loaded.sendingTime, receivedTime = loaded.receivedTime;
            backoffSettings = this._getBackoffSetting(function (err) {
              _this4.trigger("warning", errorSelector(err));
            });
            originalUrl = requestUrl !== null && requestUrl !== void 0 ? requestUrl : (_a = this._manifestUrls) === null || _a === void 0 ? void 0 : _a[0];
            opts = {
              externalClockOffset: parserOptions.externalClockOffset,
              unsafeMode: parserOptions.unsafeMode,
              previousManifest: parserOptions.previousManifest,
              originalUrl: originalUrl
            };
            _context3.prev = 11;
            res = this._pipelines.parseManifest(loaded, opts, onWarnings, cancelSignal, scheduleRequest);
            if (isPromise(res)) {
              _context3.next = 17;
              break;
            }
            return _context3.abrupt("return", finish(res.manifest));
          case 17:
            _context3.next = 19;
            return res;
          case 19:
            _yield$res = _context3.sent;
            manifest = _yield$res.manifest;
            return _context3.abrupt("return", finish(manifest));
          case 22:
            _context3.next = 28;
            break;
          case 24:
            _context3.prev = 24;
            _context3.t0 = _context3["catch"](11);
            formattedError = (0,format_error/* default */.A)(_context3.t0, {
              defaultCode: "PIPELINE_PARSE_ERROR",
              defaultReason: "Unknown error when parsing the Manifest"
            });
            throw formattedError;
          case 28:
          case "end":
            return _context3.stop();
        }
      }, _callee3, this, [[11, 24]]);
    }));
    function _parseLoadedManifest(_x2, _x3, _x4) {
      return _parseLoadedManifest2.apply(this, arguments);
    }
    return _parseLoadedManifest;
  }()
  /**
   * Construct "backoff settings" that can be used with a range of functions
   * allowing to perform multiple request attempts
   * @param {Function} onRetry
   * @returns {Object}
   */
  ;
  _proto._getBackoffSetting = function _getBackoffSetting(onRetry) {
    var _config$getCurrent = config/* default */.A.getCurrent(),
      DEFAULT_MAX_MANIFEST_REQUEST_RETRY = _config$getCurrent.DEFAULT_MAX_MANIFEST_REQUEST_RETRY,
      DEFAULT_MAX_REQUESTS_RETRY_ON_OFFLINE = _config$getCurrent.DEFAULT_MAX_REQUESTS_RETRY_ON_OFFLINE,
      INITIAL_BACKOFF_DELAY_BASE = _config$getCurrent.INITIAL_BACKOFF_DELAY_BASE,
      MAX_BACKOFF_DELAY_BASE = _config$getCurrent.MAX_BACKOFF_DELAY_BASE;
    var _this$_settings = this._settings,
      lowLatencyMode = _this$_settings.lowLatencyMode,
      ogRegular = _this$_settings.maxRetryRegular,
      ogOffline = _this$_settings.maxRetryOffline;
    var baseDelay = lowLatencyMode ? INITIAL_BACKOFF_DELAY_BASE.LOW_LATENCY : INITIAL_BACKOFF_DELAY_BASE.REGULAR;
    var maxDelay = lowLatencyMode ? MAX_BACKOFF_DELAY_BASE.LOW_LATENCY : MAX_BACKOFF_DELAY_BASE.REGULAR;
    var maxRetryRegular = ogRegular !== null && ogRegular !== void 0 ? ogRegular : DEFAULT_MAX_MANIFEST_REQUEST_RETRY;
    var maxRetryOffline = ogOffline !== null && ogOffline !== void 0 ? ogOffline : DEFAULT_MAX_REQUESTS_RETRY_ON_OFFLINE;
    return {
      onRetry: onRetry,
      baseDelay: baseDelay,
      maxDelay: maxDelay,
      maxRetryRegular: maxRetryRegular,
      maxRetryOffline: maxRetryOffline
    };
  }
  /**
   * Performs Manifest refresh (recursively) when it judges it is time to do so.
   * @param {Object} manifest
   * @param {Object} manifestRequestInfos - Various information linked to the
   * last Manifest loading and parsing operations.
   */;
  _proto._recursivelyRefreshManifest = function _recursivelyRefreshManifest(manifest, _ref) {
    var _this5 = this;
    var sendingTime = _ref.sendingTime,
      parsingTime = _ref.parsingTime,
      updatingTime = _ref.updatingTime;
    var _config$getCurrent2 = config/* default */.A.getCurrent(),
      MAX_CONSECUTIVE_MANIFEST_PARSING_IN_UNSAFE_MODE = _config$getCurrent2.MAX_CONSECUTIVE_MANIFEST_PARSING_IN_UNSAFE_MODE,
      MIN_MANIFEST_PARSING_TIME_TO_ENTER_UNSAFE_MODE = _config$getCurrent2.MIN_MANIFEST_PARSING_TIME_TO_ENTER_UNSAFE_MODE;
    /**
     * Total time taken to fully update the last Manifest, in milliseconds.
     * Note: this time also includes possible requests done by the parsers.
     */
    var totalUpdateTime = parsingTime !== undefined ? parsingTime + (updatingTime !== null && updatingTime !== void 0 ? updatingTime : 0) : undefined;
    /**
     * "unsafeMode" is a mode where we unlock advanced Manifest parsing
     * optimizations with the added risk to lose some information.
     * `unsafeModeEnabled` is set to `true` when the `unsafeMode` is enabled.
     *
     * Only perform parsing in `unsafeMode` when the last full parsing took a
     * lot of time and do not go higher than the maximum consecutive time.
     */
    var unsafeModeEnabled = this._consecutiveUnsafeMode > 0 ? this._consecutiveUnsafeMode < MAX_CONSECUTIVE_MANIFEST_PARSING_IN_UNSAFE_MODE : totalUpdateTime !== undefined ? totalUpdateTime >= MIN_MANIFEST_PARSING_TIME_TO_ENTER_UNSAFE_MODE : false;
    /** Time elapsed since the beginning of the Manifest request, in milliseconds. */
    var timeSinceRequest = sendingTime === undefined ? 0 : performance.now() - sendingTime;
    /** Minimum update delay we should not go below, in milliseconds. */
    var minInterval = Math.max(this._settings.minimumManifestUpdateInterval - timeSinceRequest, 0);
    /**
     * Multiple refresh trigger are scheduled here, but only the first one should
     * be effectively considered.
     * `nextRefreshCanceller` will allow to cancel every other when one is triggered.
     */
    var nextRefreshCanceller = new task_canceller/* default */.Ay();
    nextRefreshCanceller.linkToSignal(this._canceller.signal);
    /* Function to manually schedule a Manifest refresh */
    this.scheduleManualRefresh = function (settings) {
      var enablePartialRefresh = settings.enablePartialRefresh,
        delay = settings.delay,
        canUseUnsafeMode = settings.canUseUnsafeMode;
      var unsafeMode = canUseUnsafeMode && unsafeModeEnabled;
      // The value allows to set a delay relatively to the last Manifest refresh
      // (to avoid asking for it too often).
      var timeSinceLastRefresh = sendingTime === undefined ? 0 : performance.now() - sendingTime;
      var _minInterval = Math.max(_this5._settings.minimumManifestUpdateInterval - timeSinceLastRefresh, 0);
      var timeoutId = setTimeout(function () {
        nextRefreshCanceller.cancel();
        _this5._triggerNextManifestRefresh(manifest, {
          enablePartialRefresh: enablePartialRefresh,
          unsafeMode: unsafeMode
        });
      }, Math.max((delay !== null && delay !== void 0 ? delay : 0) - timeSinceLastRefresh, _minInterval));
      nextRefreshCanceller.signal.register(function () {
        clearTimeout(timeoutId);
      });
    };
    /* Handle Manifest expiration. */
    if (manifest.expired !== null) {
      var timeoutId = setTimeout(function () {
        var _a;
        (_a = manifest.expired) === null || _a === void 0 ? void 0 : _a.then(function () {
          nextRefreshCanceller.cancel();
          _this5._triggerNextManifestRefresh(manifest, {
            enablePartialRefresh: false,
            unsafeMode: unsafeModeEnabled
          });
        }, noop/* default */.A /* `expired` should not reject */);
      }, minInterval);
      nextRefreshCanceller.signal.register(function () {
        clearTimeout(timeoutId);
      });
    }
    /*
     * Trigger Manifest refresh when the Manifest needs to be refreshed
     * according to the Manifest's internal properties (parsing time is also
     * taken into account in this operation to avoid refreshing too often).
     */
    if (manifest.lifetime !== undefined && manifest.lifetime >= 0) {
      /** Regular refresh delay as asked by the Manifest. */
      var regularRefreshDelay = manifest.lifetime * 1000 - timeSinceRequest;
      /** Actually choosen delay to refresh the Manifest. */
      var actualRefreshInterval;
      if (totalUpdateTime === undefined) {
        actualRefreshInterval = regularRefreshDelay;
      } else if (manifest.lifetime < 3 && totalUpdateTime >= 100) {
        // If Manifest update is very frequent and we take time to update it,
        // postpone it.
        actualRefreshInterval = Math.min(Math.max(
        // Take 3 seconds as a default safe value for a base interval.
        3000 - timeSinceRequest,
        // Add update time to the original interval.
        Math.max(regularRefreshDelay, 0) + totalUpdateTime),
        // Limit the postponment's higher bound to a very high value relative
        // to `regularRefreshDelay`.
        // This avoid perpetually postponing a Manifest update when
        // performance seems to have been abysmal one time.
        regularRefreshDelay * 6);
        log/* default */.A.info("MUS: Manifest update rythm is too frequent. Postponing next request.", regularRefreshDelay, actualRefreshInterval);
      } else if (totalUpdateTime >= manifest.lifetime * 1000 / 10) {
        // If Manifest updating time is very long relative to its lifetime,
        // postpone it:
        actualRefreshInterval = Math.min(
        // Just add the update time to the original waiting time
        Math.max(regularRefreshDelay, 0) + totalUpdateTime,
        // Limit the postponment's higher bound to a very high value relative
        // to `regularRefreshDelay`.
        // This avoid perpetually postponing a Manifest update when
        // performance seems to have been abysmal one time.
        regularRefreshDelay * 6);
        log/* default */.A.info("MUS: Manifest took too long to parse. Postponing next request", actualRefreshInterval, actualRefreshInterval);
      } else {
        actualRefreshInterval = regularRefreshDelay;
      }
      var _timeoutId = setTimeout(function () {
        nextRefreshCanceller.cancel();
        _this5._triggerNextManifestRefresh(manifest, {
          enablePartialRefresh: false,
          unsafeMode: unsafeModeEnabled
        });
      }, Math.max(actualRefreshInterval, minInterval));
      nextRefreshCanceller.signal.register(function () {
        clearTimeout(_timeoutId);
      });
    }
  }
  /**
   * Refresh the Manifest, performing a full update if a partial update failed.
   * Also re-call `recursivelyRefreshManifest` to schedule the next refresh
   * trigger.
   * @param {Object} manifest
   * @param {Object} refreshInformation
   */;
  _proto._triggerNextManifestRefresh = function _triggerNextManifestRefresh(manifest, _ref2) {
    var _this6 = this;
    var enablePartialRefresh = _ref2.enablePartialRefresh,
      unsafeMode = _ref2.unsafeMode;
    var manifestUpdateUrl = manifest.updateUrl;
    var fullRefresh;
    var refreshURL;
    if (this._prioritizedContentUrl !== null) {
      fullRefresh = true;
      refreshURL = this._prioritizedContentUrl;
      this._prioritizedContentUrl = null;
    } else {
      fullRefresh = !enablePartialRefresh || manifestUpdateUrl === undefined;
      refreshURL = fullRefresh ? manifest.getUrl() : manifestUpdateUrl;
    }
    var externalClockOffset = manifest.clockOffset;
    if (unsafeMode) {
      this._consecutiveUnsafeMode += 1;
      log/* default */.A.info('Init: Refreshing the Manifest in "unsafeMode" for the ' + String(this._consecutiveUnsafeMode) + " consecutive time.");
    } else if (this._consecutiveUnsafeMode > 0) {
      log/* default */.A.info('Init: Not parsing the Manifest in "unsafeMode" anymore after ' + String(this._consecutiveUnsafeMode) + " consecutive times.");
      this._consecutiveUnsafeMode = 0;
    }
    if (this._isRefreshPending) {
      return;
    }
    this._isRefreshPending = true;
    this._fetchManifest(refreshURL).then(function (res) {
      return res.parse({
        externalClockOffset: externalClockOffset,
        previousManifest: manifest,
        unsafeMode: unsafeMode
      });
    }).then(function (res) {
      _this6._isRefreshPending = false;
      var newManifest = res.manifest,
        newSendingTime = res.sendingTime,
        parsingTime = res.parsingTime;
      var updateTimeStart = performance.now();
      if (fullRefresh) {
        manifest.replace(newManifest);
      } else {
        try {
          manifest.update(newManifest);
        } catch (e) {
          var message = e instanceof Error ? e.message : "unknown error";
          log/* default */.A.warn("MUS: Attempt to update Manifest failed: " + message, "Re-downloading the Manifest fully");
          var _config$getCurrent3 = config/* default */.A.getCurrent(),
            FAILED_PARTIAL_UPDATE_MANIFEST_REFRESH_DELAY = _config$getCurrent3.FAILED_PARTIAL_UPDATE_MANIFEST_REFRESH_DELAY;
          // The value allows to set a delay relatively to the last Manifest refresh
          // (to avoid asking for it too often).
          var timeSinceLastRefresh = newSendingTime === undefined ? 0 : performance.now() - newSendingTime;
          var _minInterval = Math.max(_this6._settings.minimumManifestUpdateInterval - timeSinceLastRefresh, 0);
          var unregisterCanceller = noop/* default */.A;
          var timeoutId = setTimeout(function () {
            unregisterCanceller();
            _this6._triggerNextManifestRefresh(manifest, {
              enablePartialRefresh: false,
              unsafeMode: false
            });
          }, Math.max(FAILED_PARTIAL_UPDATE_MANIFEST_REFRESH_DELAY - timeSinceLastRefresh, _minInterval));
          unregisterCanceller = _this6._canceller.signal.register(function () {
            clearTimeout(timeoutId);
          });
          return;
        }
      }
      var updatingTime = performance.now() - updateTimeStart;
      _this6._recursivelyRefreshManifest(manifest, {
        sendingTime: newSendingTime,
        parsingTime: parsingTime,
        updatingTime: updatingTime
      });
    })["catch"](function (err) {
      _this6._isRefreshPending = false;
      _this6._onFatalError(err);
    });
  };
  _proto._onFatalError = function _onFatalError(err) {
    if (this._canceller.isUsed()) {
      return;
    }
    this.trigger("error", err);
    this.dispose();
  };
  return ManifestFetcher;
}(event_emitter/* default */.A);
/**
 * Returns `true` when the returned value seems to be a Promise instance, as
 * created by the RxPlayer.
 * @param {*} val
 * @returns {boolean}
 */

function isPromise(val) {
  return val instanceof Promise;
}
;// CONCATENATED MODULE: ./src/core/fetchers/manifest/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ var fetchers_manifest = (ManifestFetcher);
;// CONCATENATED MODULE: ./src/core/fetchers/cdn_prioritizer.ts

function cdn_prioritizer_createForOfIteratorHelperLoose(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (t) return (t = t.call(r)).next.bind(t); if (Array.isArray(r) || (t = cdn_prioritizer_unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var o = 0; return function () { return o >= r.length ? { done: !0 } : { done: !1, value: r[o++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function cdn_prioritizer_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return cdn_prioritizer_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? cdn_prioritizer_arrayLikeToArray(r, a) : void 0; } }
function cdn_prioritizer_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Class storing and signaling the priority between multiple CDN available for
 * any given resource.
 *
 * This class was first created to implement the complexities behind
 * Content Steering features, though its handling hasn't been added yet as we
 * wait for its specification to be both standardized and relied on in the wild.
 * In the meantime, it acts as an abstraction for the simple concept of
 * avoiding to request a CDN for any segment when an issue is encountered with
 * one (e.g. HTTP 500 statuses) and several CDN exist for a given resource. It
 * should be noted that this is also one of the planified features of the
 * Content Steering specification.
 *
 * @class CdnPrioritizer
 */
var CdnPrioritizer = /*#__PURE__*/function (_EventEmitter) {
  /**
   * @param {Object} destroySignal
   */
  function CdnPrioritizer(destroySignal) {
    var _this;
    _this = _EventEmitter.call(this) || this;
    _this._downgradedCdnList = {
      metadata: [],
      timeouts: []
    };
    destroySignal.register(function () {
      for (var _iterator = cdn_prioritizer_createForOfIteratorHelperLoose(_this._downgradedCdnList.timeouts), _step; !(_step = _iterator()).done;) {
        var timeout = _step.value;
        clearTimeout(timeout);
      }
      _this._downgradedCdnList = {
        metadata: [],
        timeouts: []
      };
    });
    return _this;
  }
  /**
   * From the list of __ALL__ CDNs available to a resource, return them in the
   * order in which requests should be performed.
   *
   * Note: It is VERY important to include all CDN that are able to reach the
   * wanted resource, even those which will in the end not be used anyway.
   * If some CDN are not communicated, the `CdnPrioritizer` might wrongly
   * consider that the current resource don't have any of the CDN prioritized
   * internally and return other CDN which should have been forbidden if it knew
   * about the other, non-used, ones.
   *
   * @param {Array.<string>} everyCdnForResource - Array of ALL available CDN
   * able to reach the wanted resource - even those which might not be used in
   * the end.
   * @returns {Array.<Object>} - Array of CDN that can be tried to reach the
   * resource, sorted by order of CDN preference, according to the
   * `CdnPrioritizer`'s own list of priorities.
   */
  (0,inheritsLoose/* default */.A)(CdnPrioritizer, _EventEmitter);
  var _proto = CdnPrioritizer.prototype;
  _proto.getCdnPreferenceForResource = function getCdnPreferenceForResource(everyCdnForResource) {
    if (everyCdnForResource.length <= 1) {
      // The huge majority of contents have only one CDN available.
      // Here, prioritizing make no sense.
      return everyCdnForResource;
    }
    return this._innerGetCdnPreferenceForResource(everyCdnForResource);
  }
  /**
   * Limit usage of the CDN for a configured amount of time.
   * Call this method if you encountered an issue with that CDN which leads you
   * to want to prevent its usage currently.
   *
   * Note that the CDN can still be the preferred one if no other CDN exist for
   * a wanted resource.
   * @param {string} metadata
   */;
  _proto.downgradeCdn = function downgradeCdn(metadata) {
    var _this2 = this;
    var indexOf = indexOfMetadata(this._downgradedCdnList.metadata, metadata);
    if (indexOf >= 0) {
      this._removeIndexFromDowngradeList(indexOf);
    }
    var _config$getCurrent = config/* default */.A.getCurrent(),
      DEFAULT_CDN_DOWNGRADE_TIME = _config$getCurrent.DEFAULT_CDN_DOWNGRADE_TIME;
    var downgradeTime = DEFAULT_CDN_DOWNGRADE_TIME;
    this._downgradedCdnList.metadata.push(metadata);
    var timeout = window.setTimeout(function () {
      var newIndex = indexOfMetadata(_this2._downgradedCdnList.metadata, metadata);
      if (newIndex >= 0) {
        _this2._removeIndexFromDowngradeList(newIndex);
      }
      _this2.trigger("priorityChange", null);
    }, downgradeTime);
    this._downgradedCdnList.timeouts.push(timeout);
    this.trigger("priorityChange", null);
  }
  /**
   * From the list of __ALL__ CDNs available to a resource, return them in the
   * order in which requests should be performed.
   *
   * Note: It is VERY important to include all CDN that are able to reach the
   * wanted resource, even those which will in the end not be used anyway.
   * If some CDN are not communicated, the `CdnPrioritizer` might wrongly
   * consider that the current resource don't have any of the CDN prioritized
   * internally and return other CDN which should have been forbidden if it knew
   * about the other, non-used, ones.
   *
   * @param {Array.<string>} everyCdnForResource - Array of ALL available CDN
   * able to reach the wanted resource - even those which might not be used in
   * the end.
   * @returns {Array.<string>} - Array of CDN that can be tried to reach the
   * resource, sorted by order of CDN preference, according to the
   * `CdnPrioritizer`'s own list of priorities.
   */;
  _proto._innerGetCdnPreferenceForResource = function _innerGetCdnPreferenceForResource(everyCdnForResource) {
    var _this3 = this;
    var _everyCdnForResource$ = everyCdnForResource.reduce(function (acc, elt) {
        if (_this3._downgradedCdnList.metadata.some(function (c) {
          return c.id === elt.id && c.baseUrl === elt.baseUrl;
        })) {
          acc[1].push(elt);
        } else {
          acc[0].push(elt);
        }
        return acc;
      }, [[], []]),
      allowedInOrder = _everyCdnForResource$[0],
      downgradedInOrder = _everyCdnForResource$[1];
    return allowedInOrder.concat(downgradedInOrder);
  }
  /**
   * @param {number} index
   */;
  _proto._removeIndexFromDowngradeList = function _removeIndexFromDowngradeList(index) {
    this._downgradedCdnList.metadata.splice(index, 1);
    var oldTimeout = this._downgradedCdnList.timeouts.splice(index, 1);
    clearTimeout(oldTimeout[0]);
  };
  return CdnPrioritizer;
}(event_emitter/* default */.A);
/**
 * Find the index of the given CDN metadata in a CDN metadata array.
 * Returns `-1` if not found.
 * @param {Array.<Object>} arr
 * @param {Object} elt
 * @returns {number}
 */

function indexOfMetadata(arr, elt) {
  if (arr.length === 0) {
    return -1;
  }
  return elt.id !== undefined ? (0,array_find_index/* default */.A)(arr, function (m) {
    return m.id === elt.id;
  }) : (0,array_find_index/* default */.A)(arr, function (m) {
    return m.baseUrl === elt.baseUrl;
  });
}
;// CONCATENATED MODULE: ./src/core/fetchers/segment/prioritized_segment_fetcher.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * This function basically put in relation:
 *   - an `ISegmentFetcher`, which will be used to perform the segment requests
 *   - a `TaskPrioritizer`, which will handle the priority of a segment request
 *
 * and returns functions to fetch segments with a given priority.
 * @param {Object} prioritizer
 * @param {Object} fetcher
 * @returns {Object}
 */
function applyPrioritizerToSegmentFetcher(prioritizer, fetcher) {
  /**
   * Map Promises returned by the `createRequest` method into the actual tasks
   * used by the `TaskPrioritizer`, allowing to update task priorities just by
   * using the Promise.
   */
  var taskHandlers = new WeakMap();
  return {
    /**
     * Create a Segment request with a given priority.
     * @param {Object} content - content to request
     * @param {Number} priority - priority at which the content should be requested.
     * Lower number == higher priority.
     * @param {Object} callbacks
     * @param {Object} cancelSignal
     * @returns {Promise}
     */
    createRequest: function createRequest(content, priority, callbacks, cancelSignal) {
      var givenTask = function givenTask(innerCancelSignal) {
        return fetcher(content, callbacks, innerCancelSignal);
      };
      var ret = prioritizer.create(givenTask, priority, callbacks, cancelSignal);
      taskHandlers.set(ret, givenTask);
      return ret;
    },
    /**
     * Update the priority of a pending request, created through
     * `createRequest`.
     * @param {Promise} task - The Promise returned by `createRequest`.
     * @param {Number} priority - The new priority value.
     */
    updatePriority: function updatePriority(task, priority) {
      var correspondingTask = taskHandlers.get(task);
      if (correspondingTask === undefined) {
        log/* default */.A.warn("Fetchers: Cannot update the priority of a request: task not found.");
        return;
      }
      prioritizer.updatePriority(correspondingTask, priority);
    }
  };
}
// EXTERNAL MODULE: ./src/manifest/utils.ts
var utils = __webpack_require__(7841);
// EXTERNAL MODULE: ./src/utils/array_includes.ts
var array_includes = __webpack_require__(4031);
// EXTERNAL MODULE: ./src/utils/id_generator.ts
var id_generator = __webpack_require__(8795);
;// CONCATENATED MODULE: ./src/utils/initialization_segment_cache.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Caching object used to cache initialization segments.
 * This allow to have a faster representation switch and faster seeking.
 * @class InitializationSegmentCache
 */
var InitializationSegmentCache = /*#__PURE__*/function () {
  function InitializationSegmentCache() {
    this._cache = new WeakMap();
  }
  /**
   * @param {Object} obj
   * @param {*} response
   */
  var _proto = InitializationSegmentCache.prototype;
  _proto.add = function add(_ref, response) {
    var representation = _ref.representation,
      segment = _ref.segment;
    if (segment.isInit) {
      this._cache.set(representation, response);
    }
  }
  /**
   * @param {Object} obj
   * @returns {*} response
   */;
  _proto.get = function get(_ref2) {
    var representation = _ref2.representation,
      segment = _ref2.segment;
    if (segment.isInit) {
      var value = this._cache.get(representation);
      if (value !== undefined) {
        return value;
      }
    }
    return null;
  };
  return InitializationSegmentCache;
}();
/* harmony default export */ var initialization_segment_cache = (InitializationSegmentCache);
;// CONCATENATED MODULE: ./src/core/fetchers/segment/segment_fetcher.ts


/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */












/** Allows to generate a unique identifies for each request. */
var generateRequestID = (0,id_generator/* default */.A)();
/**
 * Create an `ISegmentFetcher` object which will allow to easily fetch and parse
 * segments.
 * An `ISegmentFetcher` also implements a retry mechanism, based on the given
 * `options` argument, which may retry a segment request when it fails.
 *
 * @param {string} bufferType - Type of  buffer concerned (e.g. `"audio"`,
 * `"video"`, `"text" etc.)
 * @param {Object} pipeline - The transport-specific logic allowing to load
 * segments of the given buffer type and transport protocol (e.g. DASH).
 * @param {Object|null} cdnPrioritizer - Abstraction allowing to synchronize,
 * update and keep track of the priorization of the CDN to use to load any given
 * segment, in cases where multiple ones are available.
 *
 * Can be set to `null` in which case a minimal priorization logic will be used
 * instead.
 * @param {Object} lifecycleCallbacks - Callbacks that can be registered to be
 * informed when new requests are made, ended, new metrics are available etc.
 * This should be mainly useful to implement an adaptive logic relying on those
 * metrics and events.
 * @param {Object} options - Various tweaking options allowing to configure the
 * behavior of the returned `ISegmentFetcher`.
 * @returns {Function}
 */
function segment_fetcher_createSegmentFetcher(bufferType, pipeline, cdnPrioritizer, lifecycleCallbacks, options) {
  var requestOptions = {
    timeout: options.requestTimeout < 0 ? undefined : options.requestTimeout
  };
  /**
   * Cache audio and video initialization segments.
   * This allows to avoid doing too many requests for what are usually very
   * small files.
   */
  var cache = (0,array_includes/* default */.A)(["audio", "video"], bufferType) ? new initialization_segment_cache() : undefined;
  var loadSegment = pipeline.loadSegment,
    parseSegment = pipeline.parseSegment;
  /**
   * Fetch a specific segment.
   * @param {Object} content
   * @param {Object} fetcherCallbacks
   * @param {Object} cancellationSignal
   * @returns {Promise}
   */
  return /*#__PURE__*/function () {
    var _fetchSegment = (0,asyncToGenerator/* default */.A)( /*#__PURE__*/regenerator_default().mark(function _callee(content, fetcherCallbacks, cancellationSignal) {
      var _a, _b, _c, segmentIdString, requestId, requestInfo, parsedChunks, segmentDurationAcc, metricsSent, loaderCallbacks, cached, res, loadedData, onCancellation, callLoaderWithUrl, generateParserFunction, onRetry, sendNetworkMetricsIfAvailable;
      return regenerator_default().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            sendNetworkMetricsIfAvailable = function _sendNetworkMetricsIf() {
              var _a;
              if (metricsSent) {
                return;
              }
              if (!(0,is_null_or_undefined/* default */.A)(requestInfo) && requestInfo.size !== undefined && requestInfo.requestDuration !== undefined && parsedChunks.length > 0 && parsedChunks.every(function (isParsed) {
                return isParsed;
              })) {
                metricsSent = true;
                (_a = lifecycleCallbacks.onMetrics) === null || _a === void 0 ? void 0 : _a.call(lifecycleCallbacks, {
                  size: requestInfo.size,
                  requestDuration: requestInfo.requestDuration,
                  content: content,
                  segmentDuration: segmentDurationAcc
                });
              }
            };
            onRetry = function _onRetry(err) {
              fetcherCallbacks.onRetry(errorSelector(err));
            };
            generateParserFunction = function _generateParserFuncti(data, isChunked) {
              parsedChunks.push(false);
              var parsedChunkId = parsedChunks.length - 1;
              return function parse(initTimescale) {
                var loaded = {
                  data: data,
                  isChunked: isChunked
                };
                try {
                  var parsed = parseSegment(loaded, content, initTimescale);
                  if (!parsedChunks[parsedChunkId]) {
                    segmentDurationAcc = segmentDurationAcc !== undefined && parsed.segmentType === "media" && parsed.chunkInfos !== null && parsed.chunkInfos.duration !== undefined ? segmentDurationAcc + parsed.chunkInfos.duration : undefined;
                    parsedChunks[parsedChunkId] = true;
                    sendNetworkMetricsIfAvailable();
                  }
                  return parsed;
                } catch (error) {
                  throw (0,format_error/* default */.A)(error, {
                    defaultCode: "PIPELINE_PARSE_ERROR",
                    defaultReason: "Unknown parsing error"
                  });
                }
              };
            };
            callLoaderWithUrl = function _callLoaderWithUrl(cdnMetadata) {
              return loadSegment(cdnMetadata, content, requestOptions, cancellationSignal, loaderCallbacks);
            };
            onCancellation = function _onCancellation() {
              var _a;
              if (requestInfo !== undefined) {
                return; // Request already terminated
              }
              log/* default */.A.debug("SF: Segment request cancelled", segmentIdString);
              requestInfo = null;
              (_a = lifecycleCallbacks.onRequestEnd) === null || _a === void 0 ? void 0 : _a.call(lifecycleCallbacks, {
                id: requestId
              });
            };
            // used by logs
            segmentIdString = (0,utils/* getLoggableSegmentId */.M)(content);
            requestId = generateRequestID();
            /**
             * If the request succeeded, set to the corresponding
             * `IChunkCompleteInformation` object.
             * For any other completion cases: if the request either failed, was
             * cancelled or just if no request was needed, set to `null`.
             *
             * Stays to `undefined` when the request is still pending.
             */
            /**
             * Array containing one entry per loaded chunk, in chronological order.
             * The boolean indicates if the chunk has been parsed at least once.
             *
             * This is used to know when all loaded chunks have been parsed, which
             * can be useful to e.g. construct metrics about the loaded segment.
             */
            parsedChunks = [];
            /**
             * Addition of the duration of each encountered and parsed chunks.
             * Allows to have an idea of the real duration of the full segment once
             * all chunks have been parsed.
             *
             * `undefined` if at least one of the parsed chunks has unknown duration.
             */
            segmentDurationAcc = 0;
            /** Set to `true` once network metrics have been sent. */
            metricsSent = false;
            loaderCallbacks = {
              /**
               * Callback called when the segment loader has progress information on
               * the request.
               * @param {Object} info
               */
              onProgress: function onProgress(info) {
                var _a;
                if (requestInfo !== undefined) {
                  return; // request already termminated
                }
                if (info.totalSize !== undefined && info.size < info.totalSize) {
                  (_a = lifecycleCallbacks.onProgress) === null || _a === void 0 ? void 0 : _a.call(lifecycleCallbacks, {
                    duration: info.duration,
                    size: info.size,
                    totalSize: info.totalSize,
                    timestamp: performance.now(),
                    id: requestId
                  });
                }
              },
              /**
               * Callback called when the segment is communicated by the loader
               * through decodable sub-segment(s) called chunk(s), with a chunk in
               * argument.
               * @param {*} chunkData
               */
              onNewChunk: function onNewChunk(chunkData) {
                fetcherCallbacks.onChunk(generateParserFunction(chunkData, true));
              }
            }; // Retrieve from cache if it exists
            cached = cache !== undefined ? cache.get(content) : null;
            if (!(cached !== null)) {
              _context.next = 16;
              break;
            }
            log/* default */.A.debug("SF: Found wanted segment in cache", segmentIdString);
            fetcherCallbacks.onChunk(generateParserFunction(cached, false));
            return _context.abrupt("return", Promise.resolve());
          case 16:
            log/* default */.A.debug("SF: Beginning request", segmentIdString);
            (_a = lifecycleCallbacks.onRequestBegin) === null || _a === void 0 ? void 0 : _a.call(lifecycleCallbacks, {
              requestTimestamp: performance.now(),
              id: requestId,
              content: content
            });
            cancellationSignal.register(onCancellation);
            _context.prev = 19;
            _context.next = 22;
            return scheduleRequestWithCdns(content.representation.cdnMetadata, cdnPrioritizer, callLoaderWithUrl, (0,object_assign/* default */.A)({
              onRetry: onRetry
            }, options), cancellationSignal);
          case 22:
            res = _context.sent;
            if (res.resultType === "segment-loaded") {
              loadedData = res.resultData.responseData;
              if (cache !== undefined) {
                cache.add(content, res.resultData.responseData);
              }
              fetcherCallbacks.onChunk(generateParserFunction(loadedData, false));
            } else if (res.resultType === "segment-created") {
              fetcherCallbacks.onChunk(generateParserFunction(res.resultData, false));
            }
            log/* default */.A.debug("SF: Segment request ended with success", segmentIdString);
            fetcherCallbacks.onAllChunksReceived();
            if (res.resultType !== "segment-created") {
              requestInfo = res.resultData;
              sendNetworkMetricsIfAvailable();
            } else {
              requestInfo = null;
            }
            if (!cancellationSignal.isCancelled()) {
              // The current task could have been canceled as a result of one
              // of the previous callbacks call. In that case, we don't want to send
              // a "requestEnd" again as it has already been sent on cancellation.
              (_b = lifecycleCallbacks.onRequestEnd) === null || _b === void 0 ? void 0 : _b.call(lifecycleCallbacks, {
                id: requestId
              });
            }
            cancellationSignal.deregister(onCancellation);
            _context.next = 41;
            break;
          case 31:
            _context.prev = 31;
            _context.t0 = _context["catch"](19);
            cancellationSignal.deregister(onCancellation);
            requestInfo = null;
            if (!(_context.t0 instanceof task_canceller/* CancellationError */.AL)) {
              _context.next = 38;
              break;
            }
            log/* default */.A.debug("SF: Segment request aborted", segmentIdString);
            throw _context.t0;
          case 38:
            log/* default */.A.debug("SF: Segment request failed", segmentIdString);
            (_c = lifecycleCallbacks.onRequestEnd) === null || _c === void 0 ? void 0 : _c.call(lifecycleCallbacks, {
              id: requestId
            });
            throw errorSelector(_context.t0);
          case 41:
          case "end":
            return _context.stop();
        }
      }, _callee, null, [[19, 31]]);
    }));
    function fetchSegment(_x, _x2, _x3) {
      return _fetchSegment.apply(this, arguments);
    }
    return fetchSegment;
  }();
}
/**
 * @param {string} bufferType
 * @param {Object}
 * @returns {Object}
 */
function getSegmentFetcherOptions(bufferType, _ref) {
  var maxRetryRegular = _ref.maxRetryRegular,
    maxRetryOffline = _ref.maxRetryOffline,
    lowLatencyMode = _ref.lowLatencyMode,
    requestTimeout = _ref.requestTimeout;
  var _config$getCurrent = config/* default */.A.getCurrent(),
    DEFAULT_MAX_REQUESTS_RETRY_ON_ERROR = _config$getCurrent.DEFAULT_MAX_REQUESTS_RETRY_ON_ERROR,
    DEFAULT_REQUEST_TIMEOUT = _config$getCurrent.DEFAULT_REQUEST_TIMEOUT,
    DEFAULT_MAX_REQUESTS_RETRY_ON_OFFLINE = _config$getCurrent.DEFAULT_MAX_REQUESTS_RETRY_ON_OFFLINE,
    INITIAL_BACKOFF_DELAY_BASE = _config$getCurrent.INITIAL_BACKOFF_DELAY_BASE,
    MAX_BACKOFF_DELAY_BASE = _config$getCurrent.MAX_BACKOFF_DELAY_BASE;
  return {
    maxRetryRegular: bufferType === "image" ? 0 : maxRetryRegular !== null && maxRetryRegular !== void 0 ? maxRetryRegular : DEFAULT_MAX_REQUESTS_RETRY_ON_ERROR,
    maxRetryOffline: maxRetryOffline !== null && maxRetryOffline !== void 0 ? maxRetryOffline : DEFAULT_MAX_REQUESTS_RETRY_ON_OFFLINE,
    baseDelay: lowLatencyMode ? INITIAL_BACKOFF_DELAY_BASE.LOW_LATENCY : INITIAL_BACKOFF_DELAY_BASE.REGULAR,
    maxDelay: lowLatencyMode ? MAX_BACKOFF_DELAY_BASE.LOW_LATENCY : MAX_BACKOFF_DELAY_BASE.REGULAR,
    requestTimeout: (0,is_null_or_undefined/* default */.A)(requestTimeout) ? DEFAULT_REQUEST_TIMEOUT : requestTimeout
  };
}
;// CONCATENATED MODULE: ./src/core/fetchers/segment/task_prioritizer.ts




var TaskPrioritizer = /*#__PURE__*/function () {
  /**
   * @param {Options} prioritizerOptions
   */
  function TaskPrioritizer(_ref) {
    var prioritySteps = _ref.prioritySteps;
    this._minPendingPriority = null;
    this._waitingQueue = [];
    this._pendingTasks = [];
    this._prioritySteps = prioritySteps;
    if (this._prioritySteps.high >= this._prioritySteps.low) {
      throw new Error("TP: the max high level priority should be given a lower" + "priority number than the min low priority.");
    }
  }
  /**
   * Create a priorized Promise from a base task.
   *
   * This task will immediately have its priority compared to all the
   * already-running ones created from this class.
   *
   * Only if this number is inferior or equal to the priority of the
   * minimum priority number of all currently-running tasks  will it be
   * immediately started.
   * In the opposite case, we will wait for higher-priority tasks to
   * finish before starting it.
   *
   * Note that while this task is waiting for its turn, it is possible
   * to update its property through the updatePriority method, by providing
   * the task again and its new priority number.
   *
   * @param {Function} taskFn
   * @param {number} priority
   * @param {Object} callbacks
   * @param {Object} cancelSignal
   * @returns {Promise}
   */
  var _proto = TaskPrioritizer.prototype;
  _proto.create = function create(taskFn, priority, callbacks, cancelSignal) {
    var _this = this;
    var newTask;
    return (0,create_cancellable_promise/* default */.A)(cancelSignal, function (resolve, reject) {
      /** Function allowing to start the underlying Promise. */
      var trigger = function trigger() {
        if (newTask.hasEnded) {
          return;
        }
        var finishTask = function finishTask() {
          unlinkInterrupter();
          _this._endTask(newTask);
        };
        var onResolve = function onResolve(value) {
          callbacks.beforeEnded();
          finishTask();
          resolve(value);
        };
        var onReject = function onReject(err) {
          finishTask();
          reject(err);
        };
        var interrupter = new task_canceller/* default */.Ay();
        var unlinkInterrupter = interrupter.linkToSignal(cancelSignal);
        newTask.interrupter = interrupter;
        interrupter.signal.register(function () {
          newTask.interrupter = null;
          if (!cancelSignal.isCancelled()) {
            callbacks.beforeInterrupted();
          }
        });
        _this._minPendingPriority = _this._minPendingPriority === null ? newTask.priority : Math.min(_this._minPendingPriority, newTask.priority);
        _this._pendingTasks.push(newTask);
        newTask.taskFn(interrupter.signal).then(onResolve)["catch"](function (err) {
          if (!cancelSignal.isCancelled() && interrupter.isUsed() && err instanceof task_canceller/* CancellationError */.AL) {
            return;
          }
          onReject(err);
        });
      };
      newTask = {
        hasEnded: false,
        priority: priority,
        trigger: trigger,
        taskFn: taskFn,
        interrupter: null
      };
      if (!_this._canBeStartedNow(newTask)) {
        _this._waitingQueue.push(newTask);
      } else {
        // We can start the task right away
        newTask.trigger();
        if (_this._isRunningHighPriorityTasks()) {
          // Note: we want to begin interrupting low-priority tasks just
          // after starting the current one because the interrupting
          // logic can call external code.
          // This would mean re-entrancy, itself meaning that some weird
          // half-state could be reached unless we're very careful.
          // To be sure no harm is done, we put that code at the last
          // possible position.
          _this._interruptCancellableTasks();
        }
      }
      return function () {
        return _this._endTask(newTask);
      };
    });
  };
  _proto._endTask = function _endTask(task) {
    task.hasEnded = true;
    var waitingQueueIndex = _findTaskIndex(task.taskFn, this._waitingQueue);
    if (waitingQueueIndex >= 0) {
      // If it was still waiting for its turn
      this._waitingQueue.splice(waitingQueueIndex, 1);
    } else {
      // remove it from pending queue if in it
      var pendingTasksIndex = _findTaskIndex(task.taskFn, this._pendingTasks);
      if (pendingTasksIndex < 0) {
        return;
      }
      this._pendingTasks.splice(pendingTasksIndex, 1);
      if (this._pendingTasks.length > 0) {
        if (this._minPendingPriority === task.priority) {
          this._minPendingPriority = Math.min.apply(Math, this._pendingTasks.map(function (t) {
            return t.priority;
          }));
        }
      } else {
        this._minPendingPriority = null;
      }
      this._loopThroughWaitingQueue();
    }
  }
  /**
   * Update the priority of a promise given to the TaskPrioritizer.
   * @param {Object} promise
   * @param {number} priority
   */;
  _proto.updatePriority = function updatePriority(promise, priority) {
    var waitingQueueIndex = _findTaskIndex(promise, this._waitingQueue);
    if (waitingQueueIndex >= 0) {
      // If it was still waiting for its turn
      var waitingQueueElt = this._waitingQueue[waitingQueueIndex];
      if (waitingQueueElt.priority === priority) {
        return;
      }
      waitingQueueElt.priority = priority;
      if (!this._canBeStartedNow(waitingQueueElt)) {
        return;
      }
      this._findAndRunWaitingQueueTask(waitingQueueIndex);
      if (this._isRunningHighPriorityTasks()) {
        // Re-check to cancel every "cancellable" pending task
        //
        // Note: We start the task before interrupting cancellable tasks on
        // purpose.
        // Because both `_findAndRunWaitingQueueTask` and
        // `_interruptCancellableTasks` can emit events and thus call external
        // code, we could retrieve ourselves in a very weird state at this point
        //
        // By starting the task first, we ensure that this is manageable:
        // `_getMinPendingPriority()` has already been updated to the right value at
        // the time we reached external code, the priority of the current
        // Task has just been updated, and `_interruptCancellableTasks`
        // will ensure that we're basing ourselves on the last `priority` value
        // each time.
        // Doing it in the reverse order is an order of magnitude more difficult
        // to write and to reason about.
        this._interruptCancellableTasks();
      }
      return;
    }
    var pendingTasksIndex = _findTaskIndex(promise, this._pendingTasks);
    if (pendingTasksIndex < 0) {
      log/* default */.A.warn("TP: request to update the priority of a non-existent task");
      return;
    }
    var task = this._pendingTasks[pendingTasksIndex];
    if (task.priority === priority) {
      return;
    }
    var prevPriority = task.priority;
    task.priority = priority;
    if (this._minPendingPriority === null || priority < this._minPendingPriority) {
      this._minPendingPriority = priority;
    } else if (this._minPendingPriority === prevPriority) {
      // was highest priority
      if (this._pendingTasks.length === 1) {
        this._minPendingPriority = priority;
      } else {
        this._minPendingPriority = Math.min.apply(Math, this._pendingTasks.map(function (t) {
          return t.priority;
        }));
      }
      this._loopThroughWaitingQueue();
    }
    if (this._isRunningHighPriorityTasks()) {
      // Always interrupt cancellable tasks after all other side-effects, to
      // avoid re-entrancy issues
      this._interruptCancellableTasks();
    }
  }
  /**
   * Browse the current waiting queue and start all task in it that needs to be
   * started: start the ones with the lowest priority value below
   * `_minPendingPriority`.
   *
   * Private properties, such as `_minPendingPriority` are updated accordingly
   * while this method is called.
   */;
  _proto._loopThroughWaitingQueue = function _loopThroughWaitingQueue() {
    var minWaitingPriority = this._waitingQueue.reduce(function (acc, elt) {
      return acc === null || acc > elt.priority ? elt.priority : acc;
    }, null);
    if (minWaitingPriority === null || this._minPendingPriority !== null && this._minPendingPriority < minWaitingPriority) {
      return;
    }
    for (var i = 0; i < this._waitingQueue.length; i++) {
      var priorityToCheck = this._minPendingPriority === null ? minWaitingPriority : Math.min(this._minPendingPriority, minWaitingPriority);
      var elt = this._waitingQueue[i];
      if (elt.priority <= priorityToCheck) {
        this._findAndRunWaitingQueueTask(i);
        i--; // previous operation should have removed that element from the
        // the waiting queue
      }
    }
  }
  /**
   * Interrupt and move back to the waiting queue all pending tasks that are
   * low priority (having a higher priority number than
   * `this._prioritySteps.low`).
   */;
  _proto._interruptCancellableTasks = function _interruptCancellableTasks() {
    for (var i = 0; i < this._pendingTasks.length; i++) {
      var pendingObj = this._pendingTasks[i];
      if (pendingObj.priority >= this._prioritySteps.low) {
        this._interruptPendingTask(pendingObj);
        // The previous call could have a lot of potential side-effects.
        // It is safer to re-start the function to not miss any pending
        // task that needs to be cancelled.
        return this._interruptCancellableTasks();
      }
    }
  }
  /**
   * Start task which is at the given index in the waiting queue.
   * The task will be removed from the waiting queue in the process.
   * @param {number} index
   */;
  _proto._findAndRunWaitingQueueTask = function _findAndRunWaitingQueueTask(index) {
    if (index >= this._waitingQueue.length || index < 0) {
      log/* default */.A.warn("TP : Tried to start a non existing task");
      return false;
    }
    var task = this._waitingQueue.splice(index, 1)[0];
    task.trigger();
    return true;
  }
  /**
   * Move back pending task to the waiting queue and interrupt it.
   * @param {object} task
   */;
  _proto._interruptPendingTask = function _interruptPendingTask(task) {
    var _a;
    var pendingTasksIndex = _findTaskIndex(task.taskFn, this._pendingTasks);
    if (pendingTasksIndex < 0) {
      log/* default */.A.warn("TP: Interrupting a non-existent pending task. Aborting...");
      return;
    }
    // Stop task and put it back in the waiting queue
    this._pendingTasks.splice(pendingTasksIndex, 1);
    this._waitingQueue.push(task);
    if (this._pendingTasks.length === 0) {
      this._minPendingPriority = null;
    } else if (this._minPendingPriority === task.priority) {
      this._minPendingPriority = Math.min.apply(Math, this._pendingTasks.map(function (t) {
        return t.priority;
      }));
    }
    (_a = task.interrupter) === null || _a === void 0 ? void 0 : _a.cancel(); // Interrupt at last step because it calls external code
  }
  /**
   * Return `true` if the given task can be started immediately based on its
   * priority.
   * @param {Object} task
   * @returns {boolean}
   */;
  _proto._canBeStartedNow = function _canBeStartedNow(task) {
    return this._minPendingPriority === null || task.priority <= this._minPendingPriority;
  }
  /**
   * Returns `true` if any running task is considered "high priority".
   * returns `false` otherwise.
   * @returns {boolean}
   */;
  _proto._isRunningHighPriorityTasks = function _isRunningHighPriorityTasks() {
    return this._minPendingPriority !== null && this._minPendingPriority <= this._prioritySteps.high;
  };
  return TaskPrioritizer;
}();
/**
 * Simple utils function allowing to find a given task function in the given
 * `queue`.
 *
 * Returns `-1` if `taskFn` is not found.
 * @param {Function} taskFn
 * @param {Array.<Object>} queue
 * @returns {number}
 */

function _findTaskIndex(taskFn, queue) {
  return (0,array_find_index/* default */.A)(queue, function (elt) {
    return elt.taskFn === taskFn;
  });
}
;// CONCATENATED MODULE: ./src/core/fetchers/segment/segment_fetcher_creator.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * Interact with the transport pipelines to download segments with the right
 * priority.
 *
 * @class SegmentFetcherCreator
 */
var SegmentFetcherCreator = /*#__PURE__*/function () {
  /**
   * @param {Object} transport
   */
  function SegmentFetcherCreator(transport, options, cancelSignal) {
    var cdnPrioritizer = new CdnPrioritizer(cancelSignal);
    var _config$getCurrent = config/* default */.A.getCurrent(),
      MIN_CANCELABLE_PRIORITY = _config$getCurrent.MIN_CANCELABLE_PRIORITY,
      MAX_HIGH_PRIORITY_LEVEL = _config$getCurrent.MAX_HIGH_PRIORITY_LEVEL;
    this._transport = transport;
    this._prioritizer = new TaskPrioritizer({
      prioritySteps: {
        high: MAX_HIGH_PRIORITY_LEVEL,
        low: MIN_CANCELABLE_PRIORITY
      }
    });
    this._cdnPrioritizer = cdnPrioritizer;
    this._backoffOptions = options;
  }
  /**
   * Create a segment fetcher, allowing to easily perform segment requests.
   * @param {string} bufferType - The type of buffer concerned (e.g. "audio",
   * "video", etc.)
   * @param {Object} callbacks
   * @returns {Object}
   */
  var _proto = SegmentFetcherCreator.prototype;
  _proto.createSegmentFetcher = function createSegmentFetcher(bufferType, callbacks) {
    var backoffOptions = getSegmentFetcherOptions(bufferType, this._backoffOptions);
    var pipelines = this._transport[bufferType];
    // Types are very complicated here as they are per-type of buffer.
    var segmentFetcher = segment_fetcher_createSegmentFetcher(bufferType, pipelines, this._cdnPrioritizer, callbacks, backoffOptions);
    return applyPrioritizerToSegmentFetcher(this._prioritizer, segmentFetcher);
  };
  return SegmentFetcherCreator;
}();

;// CONCATENATED MODULE: ./src/core/fetchers/segment/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ var segment = (SegmentFetcherCreator);
// EXTERNAL MODULE: ./src/features/index.ts
var features = __webpack_require__(418);
;// CONCATENATED MODULE: ./src/compat/change_source_buffer_type.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * If the changeType MSE API is implemented, update the current codec of the
 * SourceBuffer and return true if it succeeded.
 * In any other cases, return false.
 * @param {Object} sourceBuffer
 * @param {string} codec
 * @returns {boolean}
 */
function tryToChangeSourceBufferType(sourceBuffer, codec) {
  if (typeof sourceBuffer.changeType === "function") {
    try {
      sourceBuffer.changeType(codec);
    } catch (e) {
      log/* default */.A.warn("Could not call 'changeType' on the given SourceBuffer:", e instanceof Error ? e : "");
      return false;
    }
    return true;
  }
  return false;
}
// EXTERNAL MODULE: ./src/utils/assert_unreachable.ts + 1 modules
var assert_unreachable = __webpack_require__(2038);
// EXTERNAL MODULE: ./src/core/segment_buffers/implementations/types.ts + 3 modules
var types = __webpack_require__(7500);
;// CONCATENATED MODULE: ./src/core/segment_buffers/implementations/audio_video/audio_video_segment_buffer.ts

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */










/**
 * Allows to push and remove new segments to a SourceBuffer in a FIFO queue (not
 * doing so can lead to browser Errors) while keeping an inventory of what has
 * been pushed and what is being pushed.
 *
 * To work correctly, only a single AudioVideoSegmentBuffer per SourceBuffer
 * should be created.
 *
 * @class AudioVideoSegmentBuffer
 */
var AudioVideoSegmentBuffer = /*#__PURE__*/function (_SegmentBuffer) {
  /**
   * @constructor
   * @param {string} bufferType
   * @param {string} codec
   * @param {MediaSource} mediaSource
   */
  function AudioVideoSegmentBuffer(bufferType, codec, mediaSource) {
    var _this;
    _this = _SegmentBuffer.call(this) || this;
    log/* default */.A.info("AVSB: calling `mediaSource.addSourceBuffer`", codec);
    var sourceBuffer = mediaSource.addSourceBuffer(codec);
    _this._canceller = new task_canceller/* default */.Ay();
    _this.bufferType = bufferType;
    _this._mediaSource = mediaSource;
    _this._sourceBuffer = sourceBuffer;
    _this._queue = [];
    _this._pendingTask = null;
    _this._lastInitSegmentUniqueId = null;
    _this.codec = codec;
    _this._initSegmentsMap = new Map();
    var onError = _this._onPendingTaskError.bind(_this);
    var reCheck = _this._flush.bind(_this);
    // Some browsers (happened with firefox 66) sometimes "forget" to send us
    // `update` or `updateend` events.
    // In that case, we're completely unable to continue the queue here and
    // stay locked in a waiting state.
    // This interval is here to check at regular intervals if the underlying
    // SourceBuffer is currently updating.
    var _config$getCurrent = config/* default */.A.getCurrent(),
      SOURCE_BUFFER_FLUSHING_INTERVAL = _config$getCurrent.SOURCE_BUFFER_FLUSHING_INTERVAL;
    var intervalId = setInterval(reCheck, SOURCE_BUFFER_FLUSHING_INTERVAL);
    _this._sourceBuffer.addEventListener("error", onError);
    _this._sourceBuffer.addEventListener("updateend", reCheck);
    _this._canceller.signal.register(function () {
      clearInterval(intervalId);
      _this._sourceBuffer.removeEventListener("error", onError);
      _this._sourceBuffer.removeEventListener("updateend", reCheck);
    });
    return _this;
  }
  (0,inheritsLoose/* default */.A)(AudioVideoSegmentBuffer, _SegmentBuffer);
  var _proto = AudioVideoSegmentBuffer.prototype;
  _proto.declareInitSegment = function declareInitSegment(uniqueId, initSegmentData) {
    assertDataIsBufferSource(initSegmentData);
    this._initSegmentsMap.set(uniqueId, initSegmentData);
  };
  _proto.freeInitSegment = function freeInitSegment(uniqueId) {
    this._initSegmentsMap["delete"](uniqueId);
  }
  /**
   * Push a chunk of the media segment given to the attached SourceBuffer, in a
   * FIFO queue.
   *
   * Once all chunks of a single Segment have been given to `pushChunk`, you
   * should call `endOfSegment` to indicate that the whole Segment has been
   * pushed.
   *
   * Depending on the type of data appended, the pushed chunk might rely on an
   * initialization segment, given through the `data.initSegment` property.
   *
   * Such initialization segment will be first pushed to the SourceBuffer if the
   * last pushed segment was associated to another initialization segment.
   * This detection rely on the initialization segment's reference so you need
   * to avoid mutating in-place a initialization segment given to that function
   * (to avoid having two different values which have the same reference).
   *
   * If you don't need any initialization segment to push the wanted chunk, you
   * can just set `data.initSegment` to `null`.
   *
   * You can also only push an initialization segment by setting the
   * `data.chunk` argument to null.
   *
   * @param {Object} infos
   * @param {Object} cancellationSignal
   * @returns {Promise}
   */;
  _proto.pushChunk = function pushChunk(infos, cancellationSignal) {
    assertDataIsBufferSource(infos.data.chunk);
    log/* default */.A.debug("AVSB: receiving order to push data to the SourceBuffer", this.bufferType, (0,utils/* getLoggableSegmentId */.M)(infos.inventoryInfos));
    return this._addToQueue({
      type: types/* SegmentBufferOperation */.B.Push,
      value: infos
    }, cancellationSignal);
  }
  /**
   * Remove buffered data (added to the same FIFO queue than `pushChunk`).
   * @param {number} start - start position, in seconds
   * @param {number} end - end position, in seconds
   * @param {Object} cancellationSignal
   * @returns {Promise}
   */;
  _proto.removeBuffer = function removeBuffer(start, end, cancellationSignal) {
    log/* default */.A.debug("AVSB: receiving order to remove data from the SourceBuffer", this.bufferType, start, end);
    return this._addToQueue({
      type: types/* SegmentBufferOperation */.B.Remove,
      value: {
        start: start,
        end: end
      }
    }, cancellationSignal);
  }
  /**
   * Indicate that every chunks from a Segment has been given to pushChunk so
   * far.
   * This will update our internal Segment inventory accordingly.
   * The returned Promise will resolve once the whole segment has been pushed
   * and this indication is acknowledged.
   * @param {Object} infos
   * @returns {Promise}
   */;
  _proto.endOfSegment = function endOfSegment(infos, cancellationSignal) {
    log/* default */.A.debug("AVSB: receiving order for validating end of segment", this.bufferType, (0,utils/* getLoggableSegmentId */.M)(infos));
    return this._addToQueue({
      type: types/* SegmentBufferOperation */.B.EndOfSegment,
      value: infos
    }, cancellationSignal);
  }
  /**
   * Returns the currently buffered data, in a TimeRanges object.
   * @returns {TimeRanges}
   */;
  _proto.getBufferedRanges = function getBufferedRanges() {
    return this._sourceBuffer.buffered;
  }
  /**
   * Returns the list of every operations that the `AudioVideoSegmentBuffer` is
   * still processing. From the one with the highest priority (like the one
   * being processed)
   * @returns {Array.<Object>}
   */;
  _proto.getPendingOperations = function getPendingOperations() {
    var parseQueuedOperation = function parseQueuedOperation(op) {
      // Had to be written that way for TypeScript
      switch (op.type) {
        case types/* SegmentBufferOperation */.B.Push:
          return {
            type: op.type,
            value: op.value
          };
        case types/* SegmentBufferOperation */.B.Remove:
          return {
            type: op.type,
            value: op.value
          };
        case types/* SegmentBufferOperation */.B.EndOfSegment:
          return {
            type: op.type,
            value: op.value
          };
      }
    };
    var queued = this._queue.map(parseQueuedOperation);
    return this._pendingTask === null ? queued : [parseQueuedOperation(this._pendingTask)].concat(queued);
  }
  /**
   * Dispose of the resources used by this AudioVideoSegmentBuffer.
   *
   * /!\ You won't be able to use the AudioVideoSegmentBuffer after calling this
   * function.
   * @private
   */;
  _proto.dispose = function dispose() {
    this._canceller.cancel();
    if (this._pendingTask !== null) {
      this._pendingTask.reject(new task_canceller/* CancellationError */.AL());
      this._pendingTask = null;
    }
    while (this._queue.length > 0) {
      var nextElement = this._queue.shift();
      if (nextElement !== undefined) {
        nextElement.reject(new task_canceller/* CancellationError */.AL());
      }
    }
    if (this._mediaSource.readyState === "open") {
      try {
        log/* default */.A.debug("AVSB: Calling `abort` on the SourceBuffer");
        this._sourceBuffer.abort();
      } catch (e) {
        log/* default */.A.warn("AVSB: Failed to abort a " + this.bufferType + " SourceBuffer:", e instanceof Error ? e : "");
      }
    }
  }
  /**
   * Called when an error arised that made the current task fail.
   * @param {Event} err
   */;
  _proto._onPendingTaskError = function _onPendingTaskError(err) {
    this._lastInitSegmentUniqueId = null; // initialize init segment as a security
    if (this._pendingTask !== null) {
      var error = err instanceof Error ? err : new Error("An unknown error occured when doing operations " + "on the SourceBuffer");
      var task = this._pendingTask;
      if (task.type === types/* SegmentBufferOperation */.B.Push && task.data.length === 0 && task.inventoryData !== null) {
        this._segmentInventory.insertChunk(task.inventoryData, false, performance.now());
      }
      this._pendingTask = null;
      task.reject(error);
    }
  }
  /**
   * @private
   * @param {Object} operation
   * @param {Object} cancellationSignal
   * @returns {Promise}
   */;
  _proto._addToQueue = function _addToQueue(operation, cancellationSignal) {
    var _this2 = this;
    return (0,create_cancellable_promise/* default */.A)(cancellationSignal, function (resolve, reject) {
      var shouldRestartQueue = _this2._queue.length === 0 && _this2._pendingTask === null;
      var queueItem = (0,object_assign/* default */.A)({
        resolve: resolve,
        reject: reject
      }, operation);
      _this2._queue.push(queueItem);
      if (shouldRestartQueue) {
        _this2._flush();
      }
      return function () {
        // Remove the corresponding element from the AudioVideoSegmentBuffer's
        // queue.
        // If the operation was a pending task, it should still continue to not
        // let the AudioVideoSegmentBuffer in a weird state.
        var index = _this2._queue.indexOf(queueItem);
        if (index >= 0) {
          _this2._queue.splice(index, 1);
        }
        queueItem.resolve = noop/* default */.A;
        queueItem.reject = noop/* default */.A;
      };
    });
  }
  /**
   * Perform next task if one.
   * @private
   */;
  _proto._flush = function _flush() {
    if (this._sourceBuffer.updating) {
      return; // still processing `this._pendingTask`
    }
    if (this._pendingTask !== null) {
      var task = this._pendingTask;
      if (task.type !== types/* SegmentBufferOperation */.B.Push || task.data.length === 0) {
        // If we're here, we've finished processing the task
        switch (task.type) {
          case types/* SegmentBufferOperation */.B.Push:
            if (task.inventoryData !== null) {
              this._segmentInventory.insertChunk(task.inventoryData, true, performance.now());
            }
            break;
          case types/* SegmentBufferOperation */.B.EndOfSegment:
            this._segmentInventory.completeSegment(task.value, this.getBufferedRanges());
            break;
          case types/* SegmentBufferOperation */.B.Remove:
            this.synchronizeInventory();
            break;
          default:
            (0,assert_unreachable/* default */.A)(task);
        }
        var resolve = task.resolve;
        this._pendingTask = null;
        resolve();
        this._flush(); // Go to next item in queue
        return;
      }
    } else {
      // if this._pendingTask is null, go to next item in queue
      var nextItem = this._queue.shift();
      if (nextItem === undefined) {
        return; // we have nothing left to do
      } else if (nextItem.type !== types/* SegmentBufferOperation */.B.Push) {
        this._pendingTask = nextItem;
      } else {
        var itemValue = nextItem.value;
        var dataToPush;
        try {
          dataToPush = this._preparePushOperation(itemValue.data);
        } catch (e) {
          this._pendingTask = (0,object_assign/* default */.A)({
            data: [],
            inventoryData: itemValue.inventoryInfos
          }, nextItem);
          var error = e instanceof Error ? e : new Error("An unknown error occured when preparing a push operation");
          this._lastInitSegmentUniqueId = null; // initialize init segment as a security
          nextItem.reject(error);
          return;
        }
        this._pendingTask = (0,object_assign/* default */.A)({
          data: dataToPush,
          inventoryData: itemValue.inventoryInfos
        }, nextItem);
      }
    }
    try {
      switch (this._pendingTask.type) {
        case types/* SegmentBufferOperation */.B.EndOfSegment:
          // nothing to do, we will just acknowledge the segment.
          log/* default */.A.debug("AVSB: Acknowledging complete segment", (0,utils/* getLoggableSegmentId */.M)(this._pendingTask.value));
          this._flush();
          return;
        case types/* SegmentBufferOperation */.B.Push:
          var segmentData = this._pendingTask.data.shift();
          if (segmentData === undefined) {
            this._flush();
            return;
          }
          log/* default */.A.debug("AVSB: pushing segment", this.bufferType, (0,utils/* getLoggableSegmentId */.M)(this._pendingTask.inventoryData));
          this._sourceBuffer.appendBuffer(segmentData);
          break;
        case types/* SegmentBufferOperation */.B.Remove:
          var _this$_pendingTask$va = this._pendingTask.value,
            start = _this$_pendingTask$va.start,
            end = _this$_pendingTask$va.end;
          log/* default */.A.debug("AVSB: removing data from SourceBuffer", this.bufferType, start, end);
          this._sourceBuffer.remove(start, end);
          break;
        default:
          (0,assert_unreachable/* default */.A)(this._pendingTask);
      }
    } catch (e) {
      this._onPendingTaskError(e);
    }
  }
  /**
   * A push Operation might necessitate to mutate some `SourceBuffer` and/or
   * `AudioVideoSegmentBuffer` properties and also might need to be divided into
   * multiple segments to push (exemple: when first pushing the initialization
   * data before the segment data).
   *
   * This method allows to "prepare" that push operation so that all is left is
   * to push the returned segment data one after the other (from first to last).
   * @param {Object} data
   * @returns {Object}
   */;
  _proto._preparePushOperation = function _preparePushOperation(data) {
    // Push operation with both an init segment and a regular segment might
    // need to be separated into two steps
    var dataToPush = [];
    var codec = data.codec,
      timestampOffset = data.timestampOffset,
      appendWindow = data.appendWindow;
    var hasUpdatedSourceBufferType = false;
    if (codec !== undefined && codec !== this.codec) {
      log/* default */.A.debug("AVSB: updating codec", codec);
      hasUpdatedSourceBufferType = tryToChangeSourceBufferType(this._sourceBuffer, codec);
      if (hasUpdatedSourceBufferType) {
        this.codec = codec;
      } else {
        log/* default */.A.debug("AVSB: could not update codec", codec, this.codec);
      }
    }
    if (this._sourceBuffer.timestampOffset !== timestampOffset) {
      var newTimestampOffset = timestampOffset;
      log/* default */.A.debug("AVSB: updating timestampOffset", this.bufferType, this._sourceBuffer.timestampOffset, newTimestampOffset);
      this._sourceBuffer.timestampOffset = newTimestampOffset;
    }
    if (appendWindow[0] === undefined) {
      if (this._sourceBuffer.appendWindowStart > 0) {
        log/* default */.A.debug("AVSB: re-setting `appendWindowStart` to `0`");
        this._sourceBuffer.appendWindowStart = 0;
      }
    } else if (appendWindow[0] !== this._sourceBuffer.appendWindowStart) {
      if (appendWindow[0] >= this._sourceBuffer.appendWindowEnd) {
        var newTmpEnd = appendWindow[0] + 1;
        log/* default */.A.debug("AVSB: pre-updating `appendWindowEnd`", newTmpEnd);
        this._sourceBuffer.appendWindowEnd = newTmpEnd;
      }
      log/* default */.A.debug("AVSB: setting `appendWindowStart`", appendWindow[0]);
      this._sourceBuffer.appendWindowStart = appendWindow[0];
    }
    if (appendWindow[1] === undefined) {
      if (this._sourceBuffer.appendWindowEnd !== Infinity) {
        log/* default */.A.debug("AVSB: re-setting `appendWindowEnd` to `Infinity`");
        this._sourceBuffer.appendWindowEnd = Infinity;
      }
    } else if (appendWindow[1] !== this._sourceBuffer.appendWindowEnd) {
      log/* default */.A.debug("AVSB: setting `appendWindowEnd`", appendWindow[1]);
      this._sourceBuffer.appendWindowEnd = appendWindow[1];
    }
    if (data.initSegmentUniqueId !== null && (hasUpdatedSourceBufferType || !this._isLastInitSegment(data.initSegmentUniqueId))) {
      // Push initialization segment before the media segment
      var segmentData = this._initSegmentsMap.get(data.initSegmentUniqueId);
      if (segmentData === undefined) {
        throw new Error("Invalid initialization segment uniqueId");
      }
      dataToPush.push(segmentData);
      this._lastInitSegmentUniqueId = data.initSegmentUniqueId;
    }
    if (data.chunk !== null) {
      dataToPush.push(data.chunk);
    }
    return dataToPush;
  }
  /**
   * Return `true` if the given `uniqueId` is the identifier of the last
   * initialization segment pushed to the `AudioVideoSegmentBuffer`.
   * @param {string} uniqueId
   * @returns {boolean}
   */;
  _proto._isLastInitSegment = function _isLastInitSegment(uniqueId) {
    if (this._lastInitSegmentUniqueId === null) {
      return false;
    }
    return this._lastInitSegmentUniqueId === uniqueId;
  };
  return AudioVideoSegmentBuffer;
}(types/* SegmentBuffer */.K);
/**
 * Throw if the given input is not in the expected format.
 * Allows to enforce runtime type-checking as compile-time type-checking here is
 * difficult to enforce.
 * @param {Object} data
 */

function assertDataIsBufferSource(data) {
  if (true) {
    return;
  }
  if (typeof data !== "object" || data !== null && !(data instanceof ArrayBuffer) && !(data.buffer instanceof ArrayBuffer)) {
    throw new Error("Invalid data given to the AudioVideoSegmentBuffer");
  }
}
;// CONCATENATED MODULE: ./src/core/segment_buffers/implementations/audio_video/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ var audio_video = (AudioVideoSegmentBuffer);
;// CONCATENATED MODULE: ./src/core/segment_buffers/segment_buffers_store.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






var POSSIBLE_BUFFER_TYPES = ["audio", "video", "text", "image"];
/**
 * Allows to easily create and dispose SegmentBuffers, which are interfaces to
 * push and remove segments.
 *
 * Only one SegmentBuffer per type is allowed at the same time:
 *
 *   - SegmentBuffers linked to a "native" media buffer (relying on a
 *     SourceBuffer: "audio" and "video" here) are reused if one is
 *     re-created.
 *
 *   - SegmentBuffers for custom types (the other types of media) are aborted
 *     each time a new one of the same type is created.
 *
 * To be able to use a SegmentBuffer linked to a native media buffer, you
 * will first need to create it, but also wait until the other one is either
 * created or explicitely disabled through the `disableSegmentBuffer` method.
 * The Promise returned by `waitForUsableBuffers` will emit when
 * that is the case.
 *
 * @class SegmentBuffersStore
 */
var SegmentBuffersStore = /*#__PURE__*/function () {
  /**
   * @param {HTMLMediaElement} mediaElement
   * @param {MediaSource} mediaSource
   * @constructor
   */
  function SegmentBuffersStore(mediaElement, mediaSource) {
    this._mediaElement = mediaElement;
    this._mediaSource = mediaSource;
    this._initializedSegmentBuffers = {};
    this._onNativeBufferAddedOrDisabled = [];
  }
  /**
   * Get all currently available buffer types.
   * /!\ This list can evolve at runtime depending on feature switching.
   * @returns {Array.<string>}
   */
  /**
   * Returns true if the type is linked to a "native" media buffer (i.e. relying
   * on a SourceBuffer object, native to the browser).
   * Native media buffers needed for the current content must all be created
   * before the content begins to be played and cannot be disposed during
   * playback.
   * @param {string} bufferType
   * @returns {Boolean}
   */
  SegmentBuffersStore.isNative = function isNative(bufferType) {
    return shouldHaveNativeBuffer(bufferType);
  };
  var _proto = SegmentBuffersStore.prototype;
  _proto.getBufferTypes = function getBufferTypes() {
    var bufferTypes = this.getNativeBufferTypes();
    if (features/* default */.A.nativeTextTracksBuffer != null || features/* default */.A.htmlTextTracksBuffer != null) {
      bufferTypes.push("text");
    }
    if (features/* default */.A.imageBuffer != null) {
      bufferTypes.push("image");
    }
    return bufferTypes;
  }
  /**
   * Get all "native" buffer types that should be created before beginning to
   * push contents.
   * @returns {Array.<string>}
   */;
  _proto.getNativeBufferTypes = function getNativeBufferTypes() {
    return this._mediaElement.nodeName === "AUDIO" ? ["audio"] : ["video", "audio"];
  }
  /**
   * Returns the current "status" of the SegmentBuffer linked to the buffer
   * type given.
   *
   * This function will return  an object containing a key named `type` which
   * can be equal to either one of those three value:
   *
   *   - "initialized": A SegmentBuffer has been created for that type.
   *     You will in this case also have a second key, `value`, which will
   *     contain the related SegmentBuffer instance.
   *     Please note that you will need to wait until
   *     `this.waitForUsableBuffers()` has emitted before pushing segment
   *     data to a SegmentBuffer relying on a SourceBuffer.
   *
   *   - "disabled": The SegmentBuffer has been explicitely disabled for this
   *     type.
   *
   *   - "uninitialized": No action has yet been yet for that SegmentBuffer.
   *
   * @param {string} bufferType
   * @returns {Object|null}
   */;
  _proto.getStatus = function getStatus(bufferType) {
    var initializedBuffer = this._initializedSegmentBuffers[bufferType];
    return initializedBuffer === undefined ? {
      type: "uninitialized"
    } : initializedBuffer === null ? {
      type: "disabled"
    } : {
      type: "initialized",
      value: initializedBuffer
    };
  }
  /**
   * Native media buffers (audio and video) needed for playing the current
   * content need to all be created (by creating SegmentBuffers linked to them)
   * before any one can be used.
   *
   * This function will return a Promise resolving when any and all native
   * SourceBuffers can be used.
   *
   * From https://w3c.github.io/media-source/#methods
   *   For example, a user agent may throw a QuotaExceededError
   *   exception if the media element has reached the HAVE_METADATA
   *   readyState. This can occur if the user agent's media engine
   *   does not support adding more tracks during playback.
   * @param {Object} cancelWaitSignal
   * @return {Promise}
   */;
  _proto.waitForUsableBuffers = function waitForUsableBuffers(cancelWaitSignal) {
    var _this = this;
    if (this._areNativeBuffersUsable()) {
      return Promise.resolve();
    }
    return (0,create_cancellable_promise/* default */.A)(cancelWaitSignal, function (res) {
      /* eslint-disable-next-line prefer-const */
      var onAddedOrDisabled;
      var removeCallback = function removeCallback() {
        var indexOf = _this._onNativeBufferAddedOrDisabled.indexOf(onAddedOrDisabled);
        if (indexOf >= 0) {
          _this._onNativeBufferAddedOrDisabled.splice(indexOf, 1);
        }
      };
      onAddedOrDisabled = function onAddedOrDisabled() {
        if (_this._areNativeBuffersUsable()) {
          removeCallback();
          res();
        }
      };
      _this._onNativeBufferAddedOrDisabled.push(onAddedOrDisabled);
      return removeCallback;
    });
  }
  /**
   * Explicitely disable the SegmentBuffer for a given buffer type.
   * A call to this function is needed at least for unused native buffer types
   * (usually "audio" and "video"), to be able to emit through
   * `waitForUsableBuffers` when conditions are met.
   * @param {string}
   */;
  _proto.disableSegmentBuffer = function disableSegmentBuffer(bufferType) {
    var currentValue = this._initializedSegmentBuffers[bufferType];
    if (currentValue === null) {
      log/* default */.A.warn("SBS: The " + bufferType + " SegmentBuffer was already disabled.");
      return;
    }
    if (currentValue !== undefined) {
      throw new Error("Cannot disable an active SegmentBuffer.");
    }
    this._initializedSegmentBuffers[bufferType] = null;
    if (SegmentBuffersStore.isNative(bufferType)) {
      this._onNativeBufferAddedOrDisabled.slice().forEach(function (cb) {
        return cb();
      });
      (0,assert/* default */.h)(this._onNativeBufferAddedOrDisabled.length === 0);
    }
  }
  /**
   * Creates a new SegmentBuffer associated to a type.
   * Reuse an already created one if a SegmentBuffer for the given type
   * already exists.
   *
   * Please note that you will need to wait until `this.waitForUsableBuffers()`
   * has emitted before pushing segment data to a SegmentBuffer of a native
   * type.
   * @param {string} bufferType
   * @param {string} codec
   * @param {Object|undefined} options
   * @returns {Object}
   */;
  _proto.createSegmentBuffer = function createSegmentBuffer(bufferType, codec, options) {
    if (options === void 0) {
      options = {};
    }
    var memorizedSegmentBuffer = this._initializedSegmentBuffers[bufferType];
    if (shouldHaveNativeBuffer(bufferType)) {
      if (memorizedSegmentBuffer != null) {
        if (memorizedSegmentBuffer instanceof audio_video && memorizedSegmentBuffer.codec !== codec) {
          log/* default */.A.warn("SB: Reusing native SegmentBuffer with codec", memorizedSegmentBuffer.codec, "for codec", codec);
        } else {
          log/* default */.A.info("SB: Reusing native SegmentBuffer with codec", codec);
        }
        return memorizedSegmentBuffer;
      }
      log/* default */.A.info("SB: Adding native SegmentBuffer with codec", codec);
      var nativeSegmentBuffer = new audio_video(bufferType, codec, this._mediaSource);
      this._initializedSegmentBuffers[bufferType] = nativeSegmentBuffer;
      this._onNativeBufferAddedOrDisabled.slice().forEach(function (cb) {
        return cb();
      });
      (0,assert/* default */.h)(this._onNativeBufferAddedOrDisabled.length === 0);
      return nativeSegmentBuffer;
    }
    if (memorizedSegmentBuffer != null) {
      log/* default */.A.info("SB: Reusing a previous custom SegmentBuffer for the type", bufferType);
      return memorizedSegmentBuffer;
    }
    var segmentBuffer;
    if (bufferType === "text") {
      log/* default */.A.info("SB: Creating a new text SegmentBuffer");
      if (options.textTrackMode === "html") {
        if (features/* default */.A.htmlTextTracksBuffer == null) {
          throw new Error("HTML Text track feature not activated");
        }
        segmentBuffer = new features/* default */.A.htmlTextTracksBuffer(this._mediaElement, options.textTrackElement);
      } else {
        if (features/* default */.A.nativeTextTracksBuffer == null) {
          throw new Error("Native Text track feature not activated");
        }
        segmentBuffer = new features/* default */.A.nativeTextTracksBuffer(this._mediaElement, options.hideNativeSubtitle === true);
      }
      this._initializedSegmentBuffers.text = segmentBuffer;
      return segmentBuffer;
    } else if (bufferType === "image") {
      if (features/* default */.A.imageBuffer == null) {
        throw new Error("Image buffer feature not activated");
      }
      log/* default */.A.info("SB: Creating a new image SegmentBuffer");
      segmentBuffer = new features/* default */.A.imageBuffer();
      this._initializedSegmentBuffers.image = segmentBuffer;
      return segmentBuffer;
    }
    log/* default */.A.error("SB: Unknown buffer type:", bufferType);
    throw new media_error/* default */.A("BUFFER_TYPE_UNKNOWN", "The player wants to create a SegmentBuffer " + "of an unknown type.");
  }
  /**
   * Dispose of the active SegmentBuffer for the given type.
   * @param {string} bufferType
   */;
  _proto.disposeSegmentBuffer = function disposeSegmentBuffer(bufferType) {
    var memorizedSegmentBuffer = this._initializedSegmentBuffers[bufferType];
    if (memorizedSegmentBuffer == null) {
      log/* default */.A.warn("SB: Trying to dispose a SegmentBuffer that does not exist");
      return;
    }
    log/* default */.A.info("SB: Aborting SegmentBuffer", bufferType);
    memorizedSegmentBuffer.dispose();
    delete this._initializedSegmentBuffers[bufferType];
  }
  /**
   * Dispose of all SegmentBuffer created on this SegmentBuffersStore.
   */;
  _proto.disposeAll = function disposeAll() {
    var _this2 = this;
    POSSIBLE_BUFFER_TYPES.forEach(function (bufferType) {
      if (_this2.getStatus(bufferType).type === "initialized") {
        _this2.disposeSegmentBuffer(bufferType);
      }
    });
  }
  /**
   * Returns `true` when we're ready to push and decode contents to
   * SourceBuffers created by SegmentBuffers of a native buffer type.
   */;
  _proto._areNativeBuffersUsable = function _areNativeBuffersUsable() {
    var _this3 = this;
    var nativeBufferTypes = this.getNativeBufferTypes();
    var hasUnitializedBuffers = nativeBufferTypes.some(function (sbType) {
      return _this3._initializedSegmentBuffers[sbType] === undefined;
    });
    if (hasUnitializedBuffers) {
      // one is not yet initialized/disabled
      return false;
    }
    var areAllDisabled = nativeBufferTypes.every(function (sbType) {
      return _this3._initializedSegmentBuffers[sbType] === null;
    });
    if (areAllDisabled) {
      // they all are disabled: we can't play the content
      return false;
    }
    return true;
  };
  return SegmentBuffersStore;
}();
/**
 * Returns true if the given buffeType has a linked SourceBuffer implementation,
 * false otherwise.
 * SourceBuffers are directly added to the MediaSource.
 * @param {string} bufferType
 * @returns {Boolean}
 */

function shouldHaveNativeBuffer(bufferType) {
  return bufferType === "audio" || bufferType === "video";
}
;// CONCATENATED MODULE: ./src/core/segment_buffers/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/* harmony default export */ var segment_buffers = (SegmentBuffersStore);

// EXTERNAL MODULE: ./node_modules/next-tick/index.js
var next_tick = __webpack_require__(6826);
var next_tick_default = /*#__PURE__*/__webpack_require__.n(next_tick);
// EXTERNAL MODULE: ./src/utils/sorted_list.ts
var sorted_list = __webpack_require__(7296);
;// CONCATENATED MODULE: ./src/utils/weak_map_memory.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Memoize Function results linked to an object, through a WeakMap.
 *
 * @example
 * ```js
 * // Initialize the WeakMapMemory with its logic:
 * const memory = new WeakMapMemory(arg => {
 *   console.log("side-effect");
 *   return [arg.a, arg.b];
 * });
 *
 * const obj = { a: 1, b: 2 };
 *
 * // first time obj is given: call the function, save the result and return it:
 * const arr1 = memory.get(obj);
 * // >  "side-effect"
 * // <- [1, 2]
 *
 * // nth time obj is given, returns the saved result without calling the
 * // function:
 * const arr2 = memory.get(obj);
 * // <- [1, 2]
 *
 * // both of these use the same object, so the result is also the exact same
 * // one
 * console.log(arr1 === arr2); // => true
 *
 * // /!\ with a new object however:
 * const obj2 = { a: 1, b: 2 };
 *
 * const arr3 = memory.get(obj2);
 * // >  "side-effect"
 * // <- [1, 2]
 *
 * console.log(arr1 === arr3); // => false
 * ```
 * @class WeakMapMemory
 */
var WeakMapMemory = /*#__PURE__*/function () {
  /**
   * @param {Function}
   */
  function WeakMapMemory(fn) {
    this._weakMap = new WeakMap();
    this._fn = fn;
  }
  /**
   * @param {Object} obj
   * @returns {*}
   */
  var _proto = WeakMapMemory.prototype;
  _proto.get = function get(obj) {
    var fromMemory = this._weakMap.get(obj);
    if (fromMemory === undefined) {
      var newElement = this._fn(obj);
      this._weakMap.set(obj, newElement);
      return newElement;
    } else {
      return fromMemory;
    }
  }
  /**
   * @param {Object} obj
   */;
  _proto.destroy = function destroy(obj) {
    this._weakMap["delete"](obj);
  };
  return WeakMapMemory;
}();

;// CONCATENATED MODULE: ./src/core/segment_buffers/garbage_collector.ts


/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Perform cleaning of the buffer according to the values set by the user
 * each time `playbackObserver` emits and each times the
 * maxBufferBehind/maxBufferAhead values change.
 *
 * Abort this operation when the `cancellationSignal` emits.
 *
 * @param {Object} opt
 * @param {Object} cancellationSignal
 */
function BufferGarbageCollector(_ref, cancellationSignal) {
  var segmentBuffer = _ref.segmentBuffer,
    playbackObserver = _ref.playbackObserver,
    maxBufferBehind = _ref.maxBufferBehind,
    maxBufferAhead = _ref.maxBufferAhead;
  var lastPosition;
  playbackObserver.listen(function (o) {
    var _a;
    lastPosition = (_a = o.position.pending) !== null && _a !== void 0 ? _a : o.position.last;
    clean();
  }, {
    includeLastObservation: true,
    clearSignal: cancellationSignal
  });
  function clean() {
    clearBuffer(segmentBuffer, lastPosition, maxBufferBehind.getValue(), maxBufferAhead.getValue(), cancellationSignal)["catch"](function (e) {
      var errMsg = e instanceof Error ? e.message : "Unknown error";
      log/* default */.A.error("Could not run BufferGarbageCollector:", errMsg);
    });
  }
  maxBufferBehind.onUpdate(clean, {
    clearSignal: cancellationSignal
  });
  maxBufferAhead.onUpdate(clean, {
    clearSignal: cancellationSignal
  });
  clean();
}
/**
 * Remove buffer from the browser's memory based on the user's
 * maxBufferAhead / maxBufferBehind settings.
 *
 * Normally, the browser garbage-collect automatically old-added chunks of
 * buffer data when memory is scarce. However, you might want to control
 * the size of memory allocated. This function takes the current position
 * and a "depth" behind and ahead wanted for the buffer, in seconds.
 *
 * Anything older than the depth will be removed from the buffer.
 * @param {Object} segmentBuffer
 * @param {Number} position - The current position
 * @param {Number} maxBufferBehind
 * @param {Number} maxBufferAhead
 * @returns {Promise}
 */
function clearBuffer(_x, _x2, _x3, _x4, _x5) {
  return _clearBuffer.apply(this, arguments);
}
function _clearBuffer() {
  _clearBuffer = (0,asyncToGenerator/* default */.A)( /*#__PURE__*/regenerator_default().mark(function _callee(segmentBuffer, position, maxBufferBehind, maxBufferAhead, cancellationSignal) {
    var cleanedupRanges, _getInnerAndOuterTime, innerRange, outerRanges, collectBufferBehind, collectBufferAhead, _i, _cleanedupRanges, range;
    return regenerator_default().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          if (!(!isFinite(maxBufferBehind) && !isFinite(maxBufferAhead))) {
            _context.next = 2;
            break;
          }
          return _context.abrupt("return", Promise.resolve());
        case 2:
          cleanedupRanges = [];
          _getInnerAndOuterTime = (0,ranges/* getInnerAndOuterTimeRanges */.OT)(segmentBuffer.getBufferedRanges(), position), innerRange = _getInnerAndOuterTime.innerRange, outerRanges = _getInnerAndOuterTime.outerRanges;
          collectBufferBehind = function collectBufferBehind() {
            if (!isFinite(maxBufferBehind)) {
              return;
            }
            // begin from the oldest
            for (var i = 0; i < outerRanges.length; i++) {
              var outerRange = outerRanges[i];
              if (position - maxBufferBehind >= outerRange.end) {
                cleanedupRanges.push(outerRange);
              } else if (position >= outerRange.end && position - maxBufferBehind > outerRange.start && position - maxBufferBehind < outerRange.end) {
                cleanedupRanges.push({
                  start: outerRange.start,
                  end: position - maxBufferBehind
                });
              }
            }
            if (innerRange != null) {
              if (position - maxBufferBehind > innerRange.start) {
                cleanedupRanges.push({
                  start: innerRange.start,
                  end: position - maxBufferBehind
                });
              }
            }
          };
          collectBufferAhead = function collectBufferAhead() {
            if (!isFinite(maxBufferAhead)) {
              return;
            }
            // begin from the oldest
            for (var i = 0; i < outerRanges.length; i++) {
              var outerRange = outerRanges[i];
              if (position + maxBufferAhead <= outerRange.start) {
                cleanedupRanges.push(outerRange);
              } else if (position <= outerRange.start && position + maxBufferAhead < outerRange.end && position + maxBufferAhead > outerRange.start) {
                cleanedupRanges.push({
                  start: position + maxBufferAhead,
                  end: outerRange.end
                });
              }
            }
            if (innerRange != null) {
              if (position + maxBufferAhead < innerRange.end) {
                cleanedupRanges.push({
                  start: position + maxBufferAhead,
                  end: innerRange.end
                });
              }
            }
          };
          collectBufferBehind();
          collectBufferAhead();
          _i = 0, _cleanedupRanges = cleanedupRanges;
        case 9:
          if (!(_i < _cleanedupRanges.length)) {
            _context.next = 20;
            break;
          }
          range = _cleanedupRanges[_i];
          if (!(range.start < range.end)) {
            _context.next = 17;
            break;
          }
          log/* default */.A.debug("GC: cleaning range from SegmentBuffer", range.start, range.end);
          if (!(cancellationSignal.cancellationError !== null)) {
            _context.next = 15;
            break;
          }
          throw cancellationSignal.cancellationError;
        case 15:
          _context.next = 17;
          return segmentBuffer.removeBuffer(range.start, range.end, cancellationSignal);
        case 17:
          _i++;
          _context.next = 9;
          break;
        case 20:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return _clearBuffer.apply(this, arguments);
}
;// CONCATENATED MODULE: ./src/core/stream/representation/utils/downloading_queue.ts

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */







/**
 * Class scheduling segment downloads for a single Representation.
 *
 * TODO The request scheduling abstractions might be simplified by integrating
 * the `DownloadingQueue` in the segment fetchers code, instead of having it as
 * an utilis of the `RepresentationStream` like here.
 * @class DownloadingQueue
 */
var DownloadingQueue = /*#__PURE__*/function (_EventEmitter) {
  /**
   * Create a new `DownloadingQueue`.
   *
   * @param {Object} content - The context of the Representation you want to
   * load segments for.
   * @param {Object} downloadQueue - Queue of segments you want to load.
   * @param {Object} segmentFetcher - Interface to facilitate the download of
   * segments.
   * @param {boolean} hasInitSegment - Declare that an initialization segment
   * will need to be downloaded.
   *
   * A `DownloadingQueue` ALWAYS wait for the initialization segment to be
   * loaded and parsed before parsing a media segment.
   *
   * In cases where no initialization segment exist, this would lead to the
   * `DownloadingQueue` waiting indefinitely for it.
   *
   * By setting that value to `false`, you anounce to the `DownloadingQueue`
   * that it should not wait for an initialization segment before parsing a
   * media segment.
   */
  function DownloadingQueue(content, downloadQueue, segmentFetcher, hasInitSegment) {
    var _this;
    _this = _EventEmitter.call(this) || this;
    _this._content = content;
    _this._currentCanceller = null;
    _this._downloadQueue = downloadQueue;
    _this._initSegmentRequest = null;
    _this._mediaSegmentRequest = null;
    _this._segmentFetcher = segmentFetcher;
    _this._initSegmentInfoRef = new reference/* default */.A(undefined);
    _this._mediaSegmentAwaitingInitMetadata = null;
    if (!hasInitSegment) {
      _this._initSegmentInfoRef.setValue(null);
    }
    return _this;
  }
  /**
   * Returns the initialization segment currently being requested.
   * Returns `null` if no initialization segment request is pending.
   * @returns {Object | null}
   */
  (0,inheritsLoose/* default */.A)(DownloadingQueue, _EventEmitter);
  var _proto = DownloadingQueue.prototype;
  _proto.getRequestedInitSegment = function getRequestedInitSegment() {
    return this._initSegmentRequest === null ? null : this._initSegmentRequest.segment;
  }
  /**
   * Returns the media segment currently being requested.
   * Returns `null` if no media segment request is pending.
   * @returns {Object | null}
   */;
  _proto.getRequestedMediaSegment = function getRequestedMediaSegment() {
    return this._mediaSegmentRequest === null ? null : this._mediaSegmentRequest.segment;
  }
  /**
   * Start the current downloading queue, emitting events as it loads and parses
   * initialization and media segments.
   */;
  _proto.start = function start() {
    var _this2 = this;
    if (this._currentCanceller !== null) {
      return;
    }
    this._currentCanceller = new task_canceller/* default */.Ay();
    // Listen for asked media segments
    this._downloadQueue.onUpdate(function (queue) {
      var segmentQueue = queue.segmentQueue;
      if (segmentQueue.length > 0 && segmentQueue[0].segment.id === _this2._mediaSegmentAwaitingInitMetadata) {
        // The most needed segment is still the same one, and there's no need to
        // update its priority as the request already ended, just quit.
        return;
      }
      var currentSegmentRequest = _this2._mediaSegmentRequest;
      if (segmentQueue.length === 0) {
        if (currentSegmentRequest === null) {
          // There's nothing to load but there's already no request pending.
          return;
        }
        log/* default */.A.debug("Stream: no more media segment to request. Cancelling queue.", _this2._content.adaptation.type);
        _this2._restartMediaSegmentDownloadingQueue();
        return;
      } else if (currentSegmentRequest === null) {
        // There's no request although there are needed segments: start requests
        log/* default */.A.debug("Stream: Media segments now need to be requested. Starting queue.", _this2._content.adaptation.type, segmentQueue.length);
        _this2._restartMediaSegmentDownloadingQueue();
        return;
      } else {
        var nextItem = segmentQueue[0];
        if (currentSegmentRequest.segment.id !== nextItem.segment.id) {
          // The most important request if for another segment, request it
          log/* default */.A.debug("Stream: Next media segment changed, cancelling previous", _this2._content.adaptation.type);
          _this2._restartMediaSegmentDownloadingQueue();
          return;
        }
        if (currentSegmentRequest.priority !== nextItem.priority) {
          // The priority of the most important request has changed, update it
          log/* default */.A.debug("Stream: Priority of next media segment changed, updating", _this2._content.adaptation.type, currentSegmentRequest.priority, nextItem.priority);
          _this2._segmentFetcher.updatePriority(currentSegmentRequest.request, nextItem.priority);
        }
        return;
      }
    }, {
      emitCurrentValue: true,
      clearSignal: this._currentCanceller.signal
    });
    // Listen for asked init segment
    this._downloadQueue.onUpdate(function (next) {
      var _a;
      var initSegmentRequest = _this2._initSegmentRequest;
      if (next.initSegment !== null && initSegmentRequest !== null) {
        if (next.initSegment.priority !== initSegmentRequest.priority) {
          _this2._segmentFetcher.updatePriority(initSegmentRequest.request, next.initSegment.priority);
        }
        return;
      } else if (((_a = next.initSegment) === null || _a === void 0 ? void 0 : _a.segment.id) === (initSegmentRequest === null || initSegmentRequest === void 0 ? void 0 : initSegmentRequest.segment.id)) {
        return;
      }
      if (next.initSegment === null) {
        log/* default */.A.debug("Stream: no more init segment to request. Cancelling queue.", _this2._content.adaptation.type);
      }
      _this2._restartInitSegmentDownloadingQueue(next.initSegment);
    }, {
      emitCurrentValue: true,
      clearSignal: this._currentCanceller.signal
    });
  };
  _proto.stop = function stop() {
    var _a;
    (_a = this._currentCanceller) === null || _a === void 0 ? void 0 : _a.cancel();
    this._currentCanceller = null;
  }
  /**
   * Internal logic performing media segment requests.
   */;
  _proto._restartMediaSegmentDownloadingQueue = function _restartMediaSegmentDownloadingQueue() {
    var _this3 = this;
    if (this._mediaSegmentRequest !== null) {
      this._mediaSegmentRequest.canceller.cancel();
    }
    var _this$_downloadQueue$ = this._downloadQueue.getValue(),
      segmentQueue = _this$_downloadQueue$.segmentQueue;
    var currentNeededSegment = segmentQueue[0];
    var recursivelyRequestSegments = function recursivelyRequestSegments(startingSegment) {
      if (_this3._currentCanceller !== null && _this3._currentCanceller.isUsed()) {
        _this3._mediaSegmentRequest = null;
        return;
      }
      if (startingSegment === undefined) {
        _this3._mediaSegmentRequest = null;
        _this3.trigger("emptyQueue", null);
        return;
      }
      var canceller = new task_canceller/* default */.Ay();
      var unlinkCanceller = _this3._currentCanceller === null ? noop/* default */.A : canceller.linkToSignal(_this3._currentCanceller.signal);
      var segment = startingSegment.segment,
        priority = startingSegment.priority;
      var context = (0,object_assign/* default */.A)({
        segment: segment
      }, _this3._content);
      /**
       * If `true` , the current task has either errored, finished, or was
       * cancelled.
       */
      var isComplete = false;
      /**
       * If true, we're currently waiting for the initialization segment to be
       * parsed before parsing a received chunk.
       */
      var isWaitingOnInitSegment = false;
      canceller.signal.register(function () {
        _this3._mediaSegmentRequest = null;
        if (isComplete) {
          return;
        }
        if (_this3._mediaSegmentAwaitingInitMetadata === segment.id) {
          _this3._mediaSegmentAwaitingInitMetadata = null;
        }
        isComplete = true;
        isWaitingOnInitSegment = false;
      });
      var emitChunk = function emitChunk(parsed) {
        (0,assert/* default */.h)(parsed.segmentType === "media", "Should have loaded a media segment.");
        _this3.trigger("parsedMediaSegment", (0,object_assign/* default */.A)({}, parsed, {
          segment: segment
        }));
      };
      var continueToNextSegment = function continueToNextSegment() {
        var lastQueue = _this3._downloadQueue.getValue().segmentQueue;
        if (lastQueue.length === 0) {
          isComplete = true;
          _this3.trigger("emptyQueue", null);
          return;
        } else if (lastQueue[0].segment.id === segment.id) {
          lastQueue.shift();
        }
        isComplete = true;
        recursivelyRequestSegments(lastQueue[0]);
      };
      /** Scheduled actual segment request. */
      var request = _this3._segmentFetcher.createRequest(context, priority, {
        /**
         * Callback called when the request has to be retried.
         * @param {Error} error
         */
        onRetry: function onRetry(error) {
          _this3.trigger("requestRetry", {
            segment: segment,
            error: error
          });
        },
        /**
         * Callback called when the request has to be interrupted and
         * restarted later.
         */
        beforeInterrupted: function beforeInterrupted() {
          log/* default */.A.info("Stream: segment request interrupted temporarly.", segment.id, segment.time);
        },
        /**
         * Callback called when a decodable chunk of the segment is available.
         * @param {Function} parse - Function allowing to parse the segment.
         */
        onChunk: function onChunk(parse) {
          var initTimescale = _this3._initSegmentInfoRef.getValue();
          if (initTimescale !== undefined) {
            emitChunk(parse(initTimescale !== null && initTimescale !== void 0 ? initTimescale : undefined));
          } else {
            isWaitingOnInitSegment = true;
            // We could also technically call `waitUntilDefined` in both cases,
            // but I found it globally clearer to segregate the two cases,
            // especially to always have a meaningful `isWaitingOnInitSegment`
            // boolean which is a very important variable.
            _this3._initSegmentInfoRef.waitUntilDefined(function (actualTimescale) {
              emitChunk(parse(actualTimescale !== null && actualTimescale !== void 0 ? actualTimescale : undefined));
            }, {
              clearSignal: canceller.signal
            });
          }
        },
        /** Callback called after all chunks have been sent. */
        onAllChunksReceived: function onAllChunksReceived() {
          if (!isWaitingOnInitSegment) {
            _this3.trigger("fullyLoadedSegment", segment);
          } else {
            _this3._mediaSegmentAwaitingInitMetadata = segment.id;
            _this3._initSegmentInfoRef.waitUntilDefined(function () {
              _this3._mediaSegmentAwaitingInitMetadata = null;
              isWaitingOnInitSegment = false;
              _this3.trigger("fullyLoadedSegment", segment);
            }, {
              clearSignal: canceller.signal
            });
          }
        },
        /**
         * Callback called right after the request ended but before the next
         * requests are scheduled. It is used to schedule the next segment.
         */
        beforeEnded: function beforeEnded() {
          unlinkCanceller();
          _this3._mediaSegmentRequest = null;
          if (isWaitingOnInitSegment) {
            _this3._initSegmentInfoRef.waitUntilDefined(continueToNextSegment, {
              clearSignal: canceller.signal
            });
          } else {
            continueToNextSegment();
          }
        }
      }, canceller.signal);
      request["catch"](function (error) {
        unlinkCanceller();
        if (!isComplete) {
          isComplete = true;
          _this3.stop();
          _this3.trigger("error", error);
        }
      });
      _this3._mediaSegmentRequest = {
        segment: segment,
        priority: priority,
        request: request,
        canceller: canceller
      };
    };
    recursivelyRequestSegments(currentNeededSegment);
  }
  /**
   * Internal logic performing initialization segment requests.
   * @param {Object} queuedInitSegment
   */;
  _proto._restartInitSegmentDownloadingQueue = function _restartInitSegmentDownloadingQueue(queuedInitSegment) {
    var _this4 = this;
    if (this._currentCanceller !== null && this._currentCanceller.isUsed()) {
      return;
    }
    if (this._initSegmentRequest !== null) {
      this._initSegmentRequest.canceller.cancel();
    }
    if (queuedInitSegment === null) {
      return;
    }
    var canceller = new task_canceller/* default */.Ay();
    var unlinkCanceller = this._currentCanceller === null ? noop/* default */.A : canceller.linkToSignal(this._currentCanceller.signal);
    var segment = queuedInitSegment.segment,
      priority = queuedInitSegment.priority;
    var context = (0,object_assign/* default */.A)({
      segment: segment
    }, this._content);
    /**
     * If `true` , the current task has either errored, finished, or was
     * cancelled.
     */
    var isComplete = false;
    var request = this._segmentFetcher.createRequest(context, priority, {
      onRetry: function onRetry(err) {
        _this4.trigger("requestRetry", {
          segment: segment,
          error: err
        });
      },
      beforeInterrupted: function beforeInterrupted() {
        log/* default */.A.info("Stream: init segment request interrupted temporarly.", segment.id);
      },
      beforeEnded: function beforeEnded() {
        unlinkCanceller();
        _this4._initSegmentRequest = null;
        isComplete = true;
      },
      onChunk: function onChunk(parse) {
        var _a;
        var parsed = parse(undefined);
        (0,assert/* default */.h)(parsed.segmentType === "init", "Should have loaded an init segment.");
        _this4.trigger("parsedInitSegment", (0,object_assign/* default */.A)({}, parsed, {
          segment: segment
        }));
        if (parsed.segmentType === "init") {
          _this4._initSegmentInfoRef.setValue((_a = parsed.initTimescale) !== null && _a !== void 0 ? _a : null);
        }
      },
      onAllChunksReceived: function onAllChunksReceived() {
        _this4.trigger("fullyLoadedSegment", segment);
      }
    }, canceller.signal);
    request["catch"](function (error) {
      unlinkCanceller();
      if (!isComplete) {
        isComplete = true;
        _this4.stop();
        _this4.trigger("error", error);
      }
    });
    canceller.signal.register(function () {
      _this4._initSegmentRequest = null;
      if (isComplete) {
        return;
      }
      isComplete = true;
    });
    this._initSegmentRequest = {
      segment: segment,
      priority: priority,
      request: request,
      canceller: canceller
    };
  };
  return DownloadingQueue;
}(event_emitter/* default */.A);

;// CONCATENATED MODULE: ./src/core/stream/representation/utils/check_for_discontinuity.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Check if there is a soon-to-be-encountered discontinuity in the buffer that
 * won't be filled by any future segment.
 * This function will only check discontinuities for the given `checkedRange`.
 *
 * @param {Object} content - The content we are currently loading.
 * @param {Object} checkedRange - The time range that will be checked for
 * discontinuities.
 * Both `nextSegmentStart` and `bufferedSegments` arguments can only refer to
 * that range.
 * @param {number|null} nextSegmentStart - The start time in seconds of the next
 * not-yet-pushed segment that can be pushed, in the limits of `checkedRange`.
 * This includes segments which have not been loaded or pushed yet, but also
 * segments which might be re-downloaded because currently incomplete in the
 * buffer, the point being to know what is the earliest time in the buffer where
 * a segment might be pushed in the future.
 * `null` if no segment in `checkedRange` will be pushed under current buffer's
 * conditions.
 * @param {boolean} hasFinishedLoading - if `true`, all segments for the current
 * Period have been loaded and none will be loaded in the future under the
 * current buffer's state.
 * @param {Array.<Object>} bufferedSegments - Information about every segments
 * currently in the buffer, in chronological order.
 * Only segments overlapping with the given `checkedRange` will be looked at,
 * though the array given can be larger.
 */
function checkForDiscontinuity(content, checkedRange, nextSegmentStart, hasFinishedLoading, bufferedSegments) {
  var period = content.period,
    adaptation = content.adaptation,
    representation = content.representation;
  // `bufferedSegments` might also contains segments which are before
  // `checkedRange`.
  // Here we want the first one that goes over `checkedRange.start`, to  see
  // if there's a discontinuity at the beginning in the buffer
  var nextBufferedInRangeIdx = getIndexOfFirstChunkInRange(bufferedSegments, checkedRange);
  if (nextBufferedInRangeIdx === null) {
    // There's no segment currently buffered for the current range.
    if (nextSegmentStart === null) {
      // No segment to load in that range
      // Check if we are in a discontinuity at the end of the current Period
      if (hasFinishedLoading && period.end !== undefined && checkedRange.end >= period.end) {
        return {
          start: undefined,
          end: null
        }; // discontinuity to Period's end
      }
      // Check that there is a discontinuity announced in the Manifest there
      var discontinuityEnd = representation.index.checkDiscontinuity(checkedRange.start);
      if (discontinuityEnd !== null) {
        return {
          start: undefined,
          end: discontinuityEnd
        };
      }
    }
    return null;
  }
  var nextBufferedSegment = bufferedSegments[nextBufferedInRangeIdx];
  // Check if there is a hole that won't be filled before `nextSegmentStart`
  if (
  // Next buffered segment starts after the start of the current range
  nextBufferedSegment.bufferedStart !== undefined && nextBufferedSegment.bufferedStart > checkedRange.start && (
  // and no segment will fill in that hole
  nextSegmentStart === null || nextBufferedSegment.infos.segment.end <= nextSegmentStart)) {
    var _discontinuityEnd = nextBufferedSegment.bufferedStart;
    if (!hasFinishedLoading && representation.index.awaitSegmentBetween(checkedRange.start, _discontinuityEnd) !== false) {
      return null;
    }
    log/* default */.A.debug("RS: current discontinuity encountered", adaptation.type, nextBufferedSegment.bufferedStart);
    return {
      start: undefined,
      end: _discontinuityEnd
    };
  }
  // Check if there's a discontinuity BETWEEN segments of the current range
  var nextHoleIdx = getIndexOfFirstDiscontinuityBetweenChunks(bufferedSegments, checkedRange, nextBufferedInRangeIdx + 1);
  // If there was a hole between two consecutives segments, and if this hole
  // comes before the next segment to load, there is a discontinuity (that hole!)
  if (nextHoleIdx !== null) {
    var segmentInfoBeforeHole = bufferedSegments[nextHoleIdx - 1];
    var segmentInfoAfterHole = bufferedSegments[nextHoleIdx];
    if (nextSegmentStart === null || segmentInfoAfterHole.infos.segment.end <= nextSegmentStart) {
      if (!hasFinishedLoading && representation.index.awaitSegmentBetween(segmentInfoBeforeHole.infos.segment.end, segmentInfoAfterHole.infos.segment.time) !== false) {
        return null;
      }
      var start = segmentInfoBeforeHole.bufferedEnd;
      var end = segmentInfoAfterHole.bufferedStart;
      log/* default */.A.debug("RS: future discontinuity encountered", adaptation.type, start, end);
      return {
        start: start,
        end: end
      };
    }
  }
  if (nextSegmentStart === null) {
    // If no hole between segments and no segment to load, check for a
    // discontinuity at the end of the Period
    if (hasFinishedLoading && period.end !== undefined) {
      // Period is finished
      if (checkedRange.end < period.end) {
        // We've not reached the Period's end yet
        return null;
      }
      // Check if the last buffered segment ends before this Period's end
      // In which case there is a discontinuity between those
      var lastBufferedInPeriodIdx = getIndexOfLastChunkInPeriod(bufferedSegments, period.end);
      if (lastBufferedInPeriodIdx !== null) {
        var lastSegment = bufferedSegments[lastBufferedInPeriodIdx];
        if (lastSegment.bufferedEnd !== undefined && lastSegment.bufferedEnd < period.end) {
          log/* default */.A.debug("RS: discontinuity encountered at the end of the current period", adaptation.type, lastSegment.bufferedEnd, period.end);
          return {
            start: lastSegment.bufferedEnd,
            end: null
          };
        }
      }
    }
    // At last, check if we don't have a discontinuity at the end of the current
    // range, announced in the Manifest, that is too big to be detected through
    // the previous checks.
    if (period.end !== undefined && checkedRange.end >= period.end) {
      return null; // The previous checks should have taken care of those
    }
    for (var bufIdx = bufferedSegments.length - 1; bufIdx >= 0; bufIdx--) {
      var bufSeg = bufferedSegments[bufIdx];
      if (bufSeg.bufferedStart === undefined) {
        break;
      }
      if (bufSeg.bufferedStart < checkedRange.end) {
        if (bufSeg.bufferedEnd !== undefined && bufSeg.bufferedEnd < checkedRange.end) {
          var _discontinuityEnd2 = representation.index.checkDiscontinuity(checkedRange.end);
          if (_discontinuityEnd2 !== null) {
            return {
              start: bufSeg.bufferedEnd,
              end: _discontinuityEnd2
            };
          }
        }
        return null;
      }
    }
  }
  return null;
}
/**
 * Returns the index of the first element in `bufferedChunks` that is part of
 * `range` (starts before it ends and ends after it starts).
 *
 * Returns `null` if no element is found in that range or if we cannot know the
 * index of the first element in it.
 * @param {Array.<Object>} bufferedChunks
 * @param {Object} range
 * @returns {number|null}
 */
function getIndexOfFirstChunkInRange(bufferedChunks, range) {
  for (var bufIdx = 0; bufIdx < bufferedChunks.length; bufIdx++) {
    var bufSeg = bufferedChunks[bufIdx];
    if (bufSeg.bufferedStart === undefined || bufSeg.bufferedEnd === undefined || bufSeg.bufferedStart >= range.end) {
      return null;
    }
    if (bufSeg.bufferedEnd > range.start) {
      return bufIdx;
    }
  }
  return null;
}
/**
 * Returns the index of the first element in `bufferedChunks` which is not
 * immediately consecutive to the one before it.
 *
 * `startFromIndex` is the index of the first segment that will be checked with
 * the element coming before it. As such, it has to be superior to 0.
 *
 * If the element at `startFromIndex` comes immediately after the one before it,
 * the element at `startFromIndex + 1` will be checked instead and so on until a
 * segment completely out of `checkedRange` (which starts after it) is detected.
 *
 * If no hole between elements is found, `null` is returned.
 * @param {Array.<Object>} bufferedChunks
 * @param {Object} range
 * @param {number} startFromIndex
 * @returns {number|null}
 */
function getIndexOfFirstDiscontinuityBetweenChunks(bufferedChunks, range, startFromIndex) {
  if (startFromIndex <= 0) {
    log/* default */.A.error("RS: Asked to check a discontinuity before the first chunk.");
    return null;
  }
  for (var bufIdx = startFromIndex; bufIdx < bufferedChunks.length; bufIdx++) {
    var currSegment = bufferedChunks[bufIdx];
    var prevSegment = bufferedChunks[bufIdx - 1];
    // Exit as soon we miss information or when we go further than `checkedRange`
    if (currSegment.bufferedStart === undefined || prevSegment.bufferedEnd === undefined || currSegment.bufferedStart >= range.end) {
      return null;
    }
    // If there is a hole between two consecutive buffered segment
    if (currSegment.bufferedStart - prevSegment.bufferedEnd > 0) {
      return bufIdx;
    }
  }
  return null;
}
/**
 * Returns the index of the last element in `bufferedChunks` that is part of
 * `range` (starts before it ends and ends after it starts).
 *
 * Returns `null` if no element is found in that range or if we cannot know the
 * index of the last element in it.
 * @param {Array.<Object>} bufferedChunks
 * @param {number} periodEnd
 * @returns {number|null}
 */
function getIndexOfLastChunkInPeriod(bufferedChunks, periodEnd) {
  for (var bufIdx = bufferedChunks.length - 1; bufIdx >= 0; bufIdx--) {
    var bufSeg = bufferedChunks[bufIdx];
    if (bufSeg.bufferedStart === undefined) {
      return null;
    }
    if (bufSeg.bufferedStart < periodEnd) {
      return bufIdx;
    }
  }
  return null;
}
;// CONCATENATED MODULE: ./src/core/stream/representation/utils/get_needed_segments.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Return the list of segments that can currently be downloaded to fill holes
 * in the buffer in the given range, including already-pushed segments currently
 * incomplete in the buffer.
 * This list might also include already-loaded segments in a higher bitrate,
 * according to the given configuration.
 * Excludes segment that are already being pushed.
 * @param {Object} args
 * @returns {Array.<Object>}
 */
function getNeededSegments(_ref) {
  var bufferedSegments = _ref.bufferedSegments,
    content = _ref.content,
    currentPlaybackTime = _ref.currentPlaybackTime,
    fastSwitchThreshold = _ref.fastSwitchThreshold,
    getBufferedHistory = _ref.getBufferedHistory,
    neededRange = _ref.neededRange,
    segmentsBeingPushed = _ref.segmentsBeingPushed,
    maxBufferSize = _ref.maxBufferSize;
  var adaptation = content.adaptation,
    representation = content.representation;
  var availableBufferSize = getAvailableBufferSize(bufferedSegments, segmentsBeingPushed, maxBufferSize);
  var availableSegmentsForRange = representation.index.getSegments(neededRange.start, neededRange.end - neededRange.start);
  // Remove from `bufferedSegments` any segments we would prefer to replace:
  //   - segments in the wrong track / bad quality
  //   - garbage-collected segments
  var segmentsToKeep = bufferedSegments.filter(function (bufferedSegment) {
    return !shouldContentBeReplaced(bufferedSegment.infos, content, currentPlaybackTime, fastSwitchThreshold);
  }).filter(function (currentSeg, i, consideredSegments) {
    var prevSeg = i === 0 ? null : consideredSegments[i - 1];
    var nextSeg = i >= consideredSegments.length - 1 ? null : consideredSegments[i + 1];
    var lazySegmentHistory = null;
    if (doesStartSeemGarbageCollected(currentSeg, prevSeg, neededRange.start)) {
      lazySegmentHistory = getBufferedHistory(currentSeg.infos);
      if (shouldReloadSegmentGCedAtTheStart(lazySegmentHistory, currentSeg.bufferedStart)) {
        return false;
      }
      log/* default */.A.debug("Stream: skipping segment gc-ed at the start", currentSeg.start, currentSeg.bufferedStart);
    }
    if (doesEndSeemGarbageCollected(currentSeg, nextSeg, neededRange.end)) {
      lazySegmentHistory = lazySegmentHistory !== null && lazySegmentHistory !== void 0 ? lazySegmentHistory : getBufferedHistory(currentSeg.infos);
      if (shouldReloadSegmentGCedAtTheEnd(lazySegmentHistory, currentSeg.bufferedEnd)) {
        return false;
      }
      log/* default */.A.debug("Stream: skipping segment gc-ed at the end", currentSeg.end, currentSeg.bufferedEnd);
    }
    return true;
  });
  var _config$getCurrent = config/* default */.A.getCurrent(),
    MINIMUM_SEGMENT_SIZE = _config$getCurrent.MINIMUM_SEGMENT_SIZE,
    MIN_BUFFER_AHEAD = _config$getCurrent.MIN_BUFFER_AHEAD;
  var shouldStopLoadingSegments = false;
  /**
   * Epsilon compensating for rounding errors when comparing the start and end
   * time of multiple segments.
   */
  var ROUNDING_ERROR = Math.min(1 / 60, MINIMUM_SEGMENT_SIZE);
  var isBufferFull = false;
  var segmentsOnHold = [];
  var segmentsToLoad = availableSegmentsForRange.filter(function (segment) {
    var contentObject = (0,object_assign/* default */.A)({
      segment: segment
    }, content);
    // First, check that the segment is not already being pushed
    if (segmentsBeingPushed.length > 0) {
      var isAlreadyBeingPushed = segmentsBeingPushed.some(function (pendingSegment) {
        return (0,utils/* areSameContent */.Q)(contentObject, pendingSegment);
      });
      if (isAlreadyBeingPushed) {
        return false;
      }
    }
    var duration = segment.duration,
      time = segment.time,
      end = segment.end;
    if (segment.isInit) {
      return true; // never skip initialization segments
    }
    if (shouldStopLoadingSegments) {
      segmentsOnHold.push(segment);
      return false;
    }
    if (segment.complete && duration < MINIMUM_SEGMENT_SIZE) {
      return false; // too small, don't download
    }
    // Check if the same segment from another Representation is not already
    // being pushed.
    if (segmentsBeingPushed.length > 0) {
      var waitForPushedSegment = segmentsBeingPushed.some(function (pendingSegment) {
        if (pendingSegment.period.id !== content.period.id || pendingSegment.adaptation.id !== content.adaptation.id) {
          return false;
        }
        var oldSegment = pendingSegment.segment;
        if (oldSegment.time - ROUNDING_ERROR > time) {
          return false;
        }
        if (oldSegment.complete) {
          if (oldSegment.end + ROUNDING_ERROR < end) {
            return false;
          }
        } else if (Math.abs(time - oldSegment.time) > time) {
          return false;
        }
        return !shouldContentBeReplaced(pendingSegment, contentObject, currentPlaybackTime, fastSwitchThreshold);
      });
      if (waitForPushedSegment) {
        return false;
      }
    }
    // check if the segment is already downloaded
    for (var i = 0; i < segmentsToKeep.length; i++) {
      var completeSeg = segmentsToKeep[i];
      var areFromSamePeriod = completeSeg.infos.period.id === content.period.id;
      // Check if content are from same period, as there can't be overlapping
      // periods, we should consider a segment as already downloaded if
      // it is from same period (but can be from different adaptation or
      // representation)
      if (completeSeg.status === 1 /* ChunkStatus.FullyLoaded */ && areFromSamePeriod) {
        var completeSegInfos = completeSeg.infos.segment;
        if (time - completeSegInfos.time > -ROUNDING_ERROR) {
          if (completeSegInfos.complete) {
            if (completeSegInfos.end - end > -ROUNDING_ERROR) {
              return false; // Same segment's characteristics: already downloaded
            }
          } else if (Math.abs(time - completeSegInfos.time) < ROUNDING_ERROR) {
            // same start (special case for non-complete segments): already downloaded
            return false;
          }
        }
      }
    }
    var estimatedSegmentSize = duration * content.representation.bitrate; // in bits
    if (availableBufferSize - estimatedSegmentSize < 0) {
      isBufferFull = true;
      if (time > neededRange.start + MIN_BUFFER_AHEAD) {
        shouldStopLoadingSegments = true;
        segmentsOnHold.push(segment);
        return false;
      }
    }
    // check if the browser is not just garbage collecting it
    var segmentHistory = getBufferedHistory(contentObject);
    if (segmentHistory.length > 1) {
      var lastTimeItWasPushed = segmentHistory[segmentHistory.length - 1];
      var beforeLastTimeItWasPushed = segmentHistory[segmentHistory.length - 2];
      if (lastTimeItWasPushed.buffered === null && beforeLastTimeItWasPushed.buffered === null) {
        log/* default */.A.warn("Stream: Segment GCed multiple times in a row, ignoring it.", "If this happens a lot and lead to unpleasant experience, please " + " check your device's available memory. If it's low when this message " + "is emitted, you might want to update the RxPlayer's settings (" + "`maxBufferAhead`, `maxVideoBufferSize` etc.) so less memory is used " + "by regular media data buffering." + adaptation.type, representation.id, segment.time);
        return false;
      }
    }
    // check if there is an hole in place of the segment currently
    for (var _i = 0; _i < segmentsToKeep.length; _i++) {
      var _completeSeg = segmentsToKeep[_i];
      // For the first already-loaded segment, take the first one ending after
      // this one' s start
      if (_completeSeg.end + ROUNDING_ERROR > time) {
        var shouldLoad = _completeSeg.start > time + ROUNDING_ERROR || getLastContiguousSegment(segmentsToKeep, _i).end < end - ROUNDING_ERROR;
        if (shouldLoad) {
          availableBufferSize -= estimatedSegmentSize;
        }
        return shouldLoad;
      }
    }
    availableBufferSize -= estimatedSegmentSize;
    return true;
  });
  return {
    segmentsToLoad: segmentsToLoad,
    segmentsOnHold: segmentsOnHold,
    isBufferFull: isBufferFull
  };
}
/**
 * Compute the estimated available buffer size in memory in kilobytes
 * @param bufferedSegments
 * @param segmentsBeingPushed
 * @param maxVideoBufferSize
 * @returns availableBufferSize in bits
 */
function getAvailableBufferSize(bufferedSegments, segmentsBeingPushed, maxVideoBufferSize) {
  var availableBufferSize = maxVideoBufferSize * 8000; // in bits
  availableBufferSize -= segmentsBeingPushed.reduce(function (size, segment) {
    var bitrate = segment.representation.bitrate;
    // Not taking into account the fact that the segment
    // can still be generated and the duration not fully exact
    var duration = segment.segment.duration;
    return size + bitrate * duration;
  }, 0);
  return bufferedSegments.reduce(function (size, chunk) {
    if (chunk.chunkSize !== undefined) {
      return size - chunk.chunkSize * 8; // in bits
    } else {
      return size;
    }
  }, availableBufferSize);
}
/**
 * From the given array of buffered chunks (`bufferedSegments`) returns the last
 * buffered chunk contiguous with the one at the `startIndex` index given.
 * @param {Array.<Object>}
 * @param {number} startIndex
 * @returns {Object}
 */
function getLastContiguousSegment(bufferedSegments, startIndex) {
  var j = startIndex + 1;
  var _config$getCurrent2 = config/* default */.A.getCurrent(),
    MINIMUM_SEGMENT_SIZE = _config$getCurrent2.MINIMUM_SEGMENT_SIZE;
  /**
   * Epsilon compensating for rounding errors when comparing the start and end
   * time of multiple segments.
   */
  var ROUNDING_ERROR = Math.min(1 / 60, MINIMUM_SEGMENT_SIZE);
  // go through all contiguous segments and take the last one
  while (j < bufferedSegments.length - 1 && bufferedSegments[j - 1].end + ROUNDING_ERROR > bufferedSegments[j].start) {
    j++;
  }
  j--; // index of last contiguous segment
  return bufferedSegments[j];
}
/**
 * Returns `true` if segments linked to the given `oldContent` currently present
 * in the buffer should be replaced by segments coming from `currentContent`.
 * @param {Object} oldContent
 * @param {Object} currentContent
 * @param {number} currentPlaybackTime
 * @param {number} [fastSwitchThreshold]
 * @returns {boolean}
 */
function shouldContentBeReplaced(oldContent, currentContent, currentPlaybackTime, fastSwitchThreshold) {
  var _config$getCurrent3 = config/* default */.A.getCurrent(),
    CONTENT_REPLACEMENT_PADDING = _config$getCurrent3.CONTENT_REPLACEMENT_PADDING;
  if (oldContent.period.id !== currentContent.period.id) {
    return false; // keep segments from another Period by default.
  }
  var segment = oldContent.segment;
  if (segment.time < currentPlaybackTime + CONTENT_REPLACEMENT_PADDING) {
    return false;
  }
  if (oldContent.adaptation.id !== currentContent.adaptation.id) {
    return true; // replace segments from another Adaptation
  }
  return canFastSwitch(oldContent.representation, currentContent.representation, fastSwitchThreshold);
}
/**
 * Returns `true` if segments from the new Representation can replace
 * previously-loaded segments from the old Representation given.
 *
 * This behavior is called "fast-switching".
 * @param {Object} oldSegmentRepresentation
 * @param {Object} newSegmentRepresentation
 * @param {number|undefined} fastSwitchThreshold
 * @returns {boolean}
 */
function canFastSwitch(oldSegmentRepresentation, newSegmentRepresentation, fastSwitchThreshold) {
  var oldContentBitrate = oldSegmentRepresentation.bitrate;
  var _config$getCurrent4 = config/* default */.A.getCurrent(),
    BITRATE_REBUFFERING_RATIO = _config$getCurrent4.BITRATE_REBUFFERING_RATIO;
  if (fastSwitchThreshold === undefined) {
    // only re-load comparatively-poor bitrates for the same Adaptation.
    var bitrateCeil = oldContentBitrate * BITRATE_REBUFFERING_RATIO;
    return newSegmentRepresentation.bitrate > bitrateCeil;
  }
  return oldContentBitrate < fastSwitchThreshold && newSegmentRepresentation.bitrate > oldContentBitrate;
}
/**
 * From buffered segment information, return `true` if the given `currentSeg`
 * might have been garbage collected at the start.
 * Return `false` if the segment is complete at least from `maximumStartTime`.
 * @param {Object} currentSeg - The segment information for the segment in
 * question.
 * @param {Object|null} prevSeg - The segment information for the previous
 * buffered segment, if one (`null` if none).
 * @param {number} maximumStartTime - Only consider the data after that time.
 * If `currentSeg` has only been garbage collected for some data which is before
 * that time, we will return `false`.
 */
function doesStartSeemGarbageCollected(currentSeg, prevSeg, maximumStartTime) {
  var _config$getCurrent5 = config/* default */.A.getCurrent(),
    MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT = _config$getCurrent5.MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT;
  if (currentSeg.bufferedStart === undefined) {
    return false;
  }
  if (prevSeg !== null && prevSeg.bufferedEnd !== undefined && currentSeg.bufferedStart - prevSeg.bufferedEnd < 0.1) {
    return false;
  }
  if (maximumStartTime < currentSeg.bufferedStart && currentSeg.bufferedStart - currentSeg.start > MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT) {
    log/* default */.A.info("Stream: The start of the wanted segment has been garbage collected", currentSeg.start, currentSeg.bufferedStart);
    return true;
  }
  return false;
}
/**
 * From buffered segment information, return `true` if the given `currentSeg`
 * might have been garbage collected at the end.
 * Return `false` if the segment is complete at least until `minimumEndTime`.
 * @param {Object} currentSeg - The segment information for the segment in
 * question.
 * @param {Object|null} nextSeg - The segment information for the next buffered
 * segment, if one (`null` if none).
 * @param {number} minimumEndTime - Only consider the data before that time.
 * If `currentSeg` has only been garbage collected for some data which is after
 * that time, we will return `false`.
 */
function doesEndSeemGarbageCollected(currentSeg, nextSeg, minimumEndTime) {
  var _config$getCurrent6 = config/* default */.A.getCurrent(),
    MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT = _config$getCurrent6.MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT;
  if (currentSeg.bufferedEnd === undefined) {
    return false;
  }
  if (nextSeg !== null && nextSeg.bufferedStart !== undefined && nextSeg.bufferedStart - currentSeg.bufferedEnd < 0.1) {
    return false;
  }
  if (minimumEndTime > currentSeg.bufferedEnd && currentSeg.end - currentSeg.bufferedEnd > MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT) {
    log/* default */.A.info("Stream: The end of the wanted segment has been garbage collected", currentSeg.end, currentSeg.bufferedEnd);
    return true;
  }
  return false;
}
/**
 * Returns `true` if a segment that has been garbage-collected at the start
 * might profit from being re-loaded.
 *
 * Returns `false` if we have a high chance of staying in the same situation
 * after re-loading the segment.
 *
 * This function takes in argument the entries of a SegmentBuffer's history
 * related to the corresponding segment and check if the segment appeared
 * garbage-collected at the start directly after the last few times it was
 * pushed, indicating that the issue might be sourced at a browser issue instead
 * of classical garbage collection.
 *
 * @param {Array.<Object>} segmentEntries
 * @param {number|undefined} currentBufferedStart
 * @returns {boolean}
 */
function shouldReloadSegmentGCedAtTheStart(segmentEntries, currentBufferedStart) {
  var _a, _b;
  if (segmentEntries.length < 2) {
    return true;
  }
  var lastEntry = segmentEntries[segmentEntries.length - 1];
  var lastBufferedStart = (_a = lastEntry.buffered) === null || _a === void 0 ? void 0 : _a.start;
  // If the current segment's buffered start is much higher than what it
  // initially was when we pushed it, the segment has a very high chance of
  // having been truly garbage-collected.
  if (currentBufferedStart !== undefined && lastBufferedStart !== undefined && currentBufferedStart - lastBufferedStart > 0.05) {
    return true;
  }
  var prevEntry = segmentEntries[segmentEntries.length - 2];
  var prevBufferedStart = (_b = prevEntry.buffered) === null || _b === void 0 ? void 0 : _b.start;
  if (prevBufferedStart === undefined || lastBufferedStart === undefined) {
    return true;
  }
  // Compare `bufferedStart` from the last time this segment was pushed
  // (`entry.bufferedStart`) to the previous time it was pushed
  // (`prevSegEntry.bufferedStart`).
  //
  // If in both cases, we notice that their initial `bufferedStart` are close,
  // it means that in recent history the same segment has been accused to be
  // garbage collected two times at roughly the same positions just after being
  // pushed.
  // This is very unlikely and might be linked to either a content or browser
  // issue. In that case, don't try to reload.
  return Math.abs(prevBufferedStart - lastBufferedStart) > 0.01;
}
/**
 * Returns `true` if a segment that has been garbage-collected at the end
 * might profit from being re-loaded.
 *
 * Returns `false` if we have a high chance of staying in the same situation
 * after re-loading the segment.
 *
 * This function takes in argument the entries of a SegmentBuffer's history
 * related to the corresponding segment and check if the segment appeared
 * garbage-collected at the end directly after the last few times it was
 * pushed, indicating that the issue might be sourced at a browser issue instead
 * of classical garbage collection.
 *
 * @param {Array.<Object>} segmentEntries
 * @param {number|undefined} currentBufferedEnd
 * @returns {boolean}
 */
function shouldReloadSegmentGCedAtTheEnd(segmentEntries, currentBufferedEnd) {
  var _a, _b;
  if (segmentEntries.length < 2) {
    return true;
  }
  var lastEntry = segmentEntries[segmentEntries.length - 1];
  var lastBufferedEnd = (_a = lastEntry.buffered) === null || _a === void 0 ? void 0 : _a.end;
  // If the current segment's buffered end is much lower than what it
  // initially was when we pushed it, the segment has a very high chance of
  // having been truly garbage-collected.
  if (currentBufferedEnd !== undefined && lastBufferedEnd !== undefined && lastBufferedEnd - currentBufferedEnd > 0.05) {
    return true;
  }
  var prevEntry = segmentEntries[segmentEntries.length - 2];
  var prevBufferedEnd = (_b = prevEntry.buffered) === null || _b === void 0 ? void 0 : _b.end;
  if (prevBufferedEnd === undefined || lastBufferedEnd === undefined) {
    return true;
  }
  // Compare `bufferedEnd` from the last time this segment was pushed
  // (`entry.bufferedEnd`) to the previous time it was pushed
  // (`prevSegEntry.bufferedEnd`).
  //
  // If in both cases, we notice that their initial `bufferedEnd` are close,
  // it means that in recent history the same segment has been accused to be
  // garbage collected two times at roughly the same positions just after being
  // pushed.
  // This is very unlikely and might be linked to either a content or browser
  // issue. In that case, don't try to reload.
  return Math.abs(prevBufferedEnd - lastBufferedEnd) > 0.01;
}
;// CONCATENATED MODULE: ./src/core/stream/representation/utils/get_segment_priority.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Calculate the priority number for a given segment start time, in function of
 * the distance with the wanted starting timestamp.
 *
 * The lower is this number, the higher should be the priority of the request.
 *
 * Note that a `segmentTime` given behind the current time will always have the
 * highest priority.
 * @param {number} segmentTime
 * @param {Object} wantedStartTimestamp
 * @returns {number}
 */
function getSegmentPriority(segmentTime, wantedStartTimestamp) {
  var distance = segmentTime - wantedStartTimestamp;
  var _config$getCurrent = config/* default */.A.getCurrent(),
    SEGMENT_PRIORITIES_STEPS = _config$getCurrent.SEGMENT_PRIORITIES_STEPS;
  for (var priority = 0; priority < SEGMENT_PRIORITIES_STEPS.length; priority++) {
    if (distance < SEGMENT_PRIORITIES_STEPS[priority]) {
      return priority;
    }
  }
  return SEGMENT_PRIORITIES_STEPS.length;
}
;// CONCATENATED MODULE: ./src/core/stream/representation/utils/get_buffer_status.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * Checks on the current buffered data for the given type and Period
 * and returns what should be done to fill the buffer according to the buffer
 * goal, the Representation chosen, etc.
 * Also emits discontinuities if found, which are parts of the buffer that won't
 * be filled by any segment, even in the future.
 *
 * @param {Object} content
 * @param {number} initialWantedTime
 * @param {Object} playbackObserver
 * @param {number|undefined} fastSwitchThreshold
 * @param {number} bufferGoal
 * @param {number} maxBufferSize
 * @param {Object} segmentBuffer
 * @returns {Object}
 */
function getBufferStatus(content, initialWantedTime, playbackObserver, fastSwitchThreshold, bufferGoal, maxBufferSize, segmentBuffer) {
  segmentBuffer.synchronizeInventory();
  var representation = content.representation;
  var askedStart = playbackObserver.getIsPaused() || playbackObserver.getPlaybackRate() <= 0 ? initialWantedTime - 0.1 : initialWantedTime;
  var neededRange = getRangeOfNeededSegments(content, askedStart, bufferGoal);
  var shouldRefreshManifest = representation.index.shouldRefresh(neededRange.start, neededRange.end);
  /**
   * Every segment awaiting an "EndOfSegment" operation, which indicates that a
   * completely-loaded segment is still being pushed to the SegmentBuffer.
   */
  var segmentsBeingPushed = segmentBuffer.getPendingOperations().filter(function (operation) {
    return operation.type === types/* SegmentBufferOperation */.B.EndOfSegment;
  }).map(function (operation) {
    return operation.value;
  });
  /** Data on every segments buffered around `neededRange`. */
  var bufferedSegments = segmentBuffer.getInventory();
  var currentPlaybackTime = playbackObserver.getCurrentTime();
  /** Callback allowing to retrieve a segment's history in the buffer. */
  var getBufferedHistory = segmentBuffer.getSegmentHistory.bind(segmentBuffer);
  /** List of segments we will need to download. */
  var _getNeededSegments = getNeededSegments({
      content: content,
      bufferedSegments: bufferedSegments,
      currentPlaybackTime: currentPlaybackTime,
      fastSwitchThreshold: fastSwitchThreshold,
      getBufferedHistory: getBufferedHistory,
      neededRange: neededRange,
      segmentsBeingPushed: segmentsBeingPushed,
      maxBufferSize: maxBufferSize
    }),
    segmentsToLoad = _getNeededSegments.segmentsToLoad,
    segmentsOnHold = _getNeededSegments.segmentsOnHold,
    isBufferFull = _getNeededSegments.isBufferFull;
  var prioritizedNeededSegments = segmentsToLoad.map(function (segment) {
    return {
      priority: getSegmentPriority(segment.time, askedStart),
      segment: segment
    };
  });
  /**
   * `true` if the current `RepresentationStream` has loaded all the
   * needed segments for this Representation until the end of the Period.
   */
  var hasFinishedLoading = representation.index.isInitialized() && !representation.index.isStillAwaitingFutureSegments() && neededRange.hasReachedPeriodEnd && prioritizedNeededSegments.length === 0 && segmentsOnHold.length === 0;
  /**
   * Start time in seconds of the next available not-yet pushed segment.
   * `null` if no segment is wanted for the current wanted range.
   */
  var nextSegmentStart = null;
  if (segmentsBeingPushed.length > 0) {
    nextSegmentStart = Math.min.apply(Math, segmentsBeingPushed.map(function (info) {
      return info.segment.time;
    }));
  }
  if (segmentsOnHold.length > 0) {
    nextSegmentStart = nextSegmentStart !== null ? Math.min(nextSegmentStart, segmentsOnHold[0].time) : segmentsOnHold[0].time;
  }
  if (prioritizedNeededSegments.length > 0) {
    nextSegmentStart = nextSegmentStart !== null ? Math.min(nextSegmentStart, prioritizedNeededSegments[0].segment.time) : prioritizedNeededSegments[0].segment.time;
  }
  var imminentDiscontinuity = checkForDiscontinuity(content, neededRange, nextSegmentStart, hasFinishedLoading, bufferedSegments);
  return {
    imminentDiscontinuity: imminentDiscontinuity,
    hasFinishedLoading: hasFinishedLoading,
    neededSegments: prioritizedNeededSegments,
    isBufferFull: isBufferFull,
    shouldRefreshManifest: shouldRefreshManifest
  };
}
/**
 * Returns both the time range of segments that should be loaded (from a
 * starting position to an ending position) and whether the end of the Period is
 * reached by that range.
 * @param {Object} content
 * @param {number} initialWantedTime
 * @param {number} bufferGoal
 * @returns {Object}
 */
function getRangeOfNeededSegments(content, initialWantedTime, bufferGoal) {
  var _a;
  var wantedStartPosition;
  var manifest = content.manifest,
    period = content.period,
    representation = content.representation;
  var lastIndexPosition = representation.index.getLastAvailablePosition();
  var representationIndex = representation.index;
  // There is an exception for when the current initially wanted time is already
  // after the last position with segments AND when we're playing the absolute
  // last Period in the Manifest.
  // In that case, we want to actually request at least the last segment to
  // avoid ending the last Period - and by extension the content - with a
  // segment which isn't the last one.
  if (!(0,is_null_or_undefined/* default */.A)(lastIndexPosition) && segment_buffers.isNative(content.adaptation.type) && initialWantedTime >= lastIndexPosition && representationIndex.isInitialized() && !representationIndex.isStillAwaitingFutureSegments() && isPeriodTheCurrentAndLastOne(manifest, period, initialWantedTime)) {
    wantedStartPosition = lastIndexPosition - 1;
  } else {
    wantedStartPosition = initialWantedTime - 0.1;
  }
  var wantedEndPosition = wantedStartPosition + bufferGoal;
  var hasReachedPeriodEnd;
  if (!representation.index.isInitialized() || representation.index.isStillAwaitingFutureSegments() || period.end === undefined) {
    hasReachedPeriodEnd = false;
  } else if (lastIndexPosition === undefined) {
    // We do not know the end of this index.
    hasReachedPeriodEnd = wantedEndPosition >= period.end;
  } else if (lastIndexPosition === null) {
    // There is no available segment in the index currently.
    hasReachedPeriodEnd = true;
  } else {
    // We have a declared end. Check that our range went until the last
    // position available in the index. If that's the case and we're left
    // with no segments after filtering them, it means we already have
    // downloaded the last segments and have nothing left to do: full.
    hasReachedPeriodEnd = wantedEndPosition >= lastIndexPosition;
  }
  return {
    start: Math.max(wantedStartPosition, period.start),
    end: Math.min(wantedEndPosition, (_a = period.end) !== null && _a !== void 0 ? _a : Infinity),
    hasReachedPeriodEnd: hasReachedPeriodEnd
  };
}
/**
 * Returns `true` if the given Period is both:
 *   - the one being played (the current position is known from `time`)
 *   - the absolute last one in the Manifest (that is, there will never be a
 *     Period after it).
 * @param {Object} manifest
 * @param {Object} period
 * @param {number} time
 * @returns {boolean}
 */
function isPeriodTheCurrentAndLastOne(manifest, period, time) {
  var _a;
  var nextPeriod = manifest.getPeriodAfter(period);
  return period.containsTime(time, nextPeriod) && manifest.isLastPeriodKnown && period.id === ((_a = manifest.periods[manifest.periods.length - 1]) === null || _a === void 0 ? void 0 : _a.id);
}
// EXTERNAL MODULE: ./src/utils/sleep.ts
var sleep = __webpack_require__(8801);
;// CONCATENATED MODULE: ./src/core/stream/representation/utils/force_garbage_collection.ts


function force_garbage_collection_createForOfIteratorHelperLoose(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (t) return (t = t.call(r)).next.bind(t); if (Array.isArray(r) || (t = force_garbage_collection_unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var o = 0; return function () { return o >= r.length ? { done: !0 } : { done: !1, value: r[o++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function force_garbage_collection_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return force_garbage_collection_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? force_garbage_collection_arrayLikeToArray(r, a) : void 0; } }
function force_garbage_collection_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Run the garbage collector.
 *
 * Try to clean up buffered ranges from a low gcGap at first.
 * If it does not succeed to clean up space, use a higher gcCap.
 *
 * @param {number} currentPosition
 * @param {Object} bufferingQueue
 * @param {Object} cancellationSignal
 * @returns {Promise}
 */
function forceGarbageCollection(_x, _x2, _x3) {
  return _forceGarbageCollection.apply(this, arguments);
}
/**
 * Buffer garbage collector algorithm.
 *
 * Tries to free up some part of the ranges that are distant from the current
 * playing time.
 * See: https://w3c.github.io/media-source/#sourcebuffer-prepare-append
 *
 * @param {Number} position
 * @param {TimeRanges} buffered - current buffered ranges
 * @param {Number} gcGap - delta gap from current timestamp from which we
 * should consider cleaning up.
 * @returns {Array.<Object>} - Ranges selected for clean up
 */
function _forceGarbageCollection() {
  _forceGarbageCollection = (0,asyncToGenerator/* default */.A)( /*#__PURE__*/regenerator_default().mark(function _callee(currentPosition, bufferingQueue, cancellationSignal) {
    var GC_GAP_CALM, GC_GAP_BEEFY, buffered, cleanedupRanges, _iterator, _step, range, start, end;
    return regenerator_default().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          GC_GAP_CALM = config/* default */.A.getCurrent().BUFFER_GC_GAPS.CALM;
          GC_GAP_BEEFY = config/* default */.A.getCurrent().BUFFER_GC_GAPS.BEEFY;
          log/* default */.A.warn("Stream: Running garbage collector");
          buffered = bufferingQueue.getBufferedRanges();
          cleanedupRanges = selectGCedRanges(currentPosition, buffered, GC_GAP_CALM); // more aggressive GC if we could not find any range to clean
          if (cleanedupRanges.length === 0) {
            cleanedupRanges = selectGCedRanges(currentPosition, buffered, GC_GAP_BEEFY);
          }
          if (log/* default */.A.hasLevel("DEBUG")) {
            log/* default */.A.debug("Stream: GC cleaning", cleanedupRanges.map(function (_ref2) {
              var start = _ref2.start,
                end = _ref2.end;
              return "start: " + start + " - end " + end;
            }).join(", "));
          }
          _iterator = force_garbage_collection_createForOfIteratorHelperLoose(cleanedupRanges);
        case 8:
          if ((_step = _iterator()).done) {
            _context.next = 16;
            break;
          }
          range = _step.value;
          start = range.start, end = range.end;
          if (!(start < end)) {
            _context.next = 14;
            break;
          }
          _context.next = 14;
          return bufferingQueue.removeBuffer(start, end, cancellationSignal);
        case 14:
          _context.next = 8;
          break;
        case 16:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return _forceGarbageCollection.apply(this, arguments);
}
function selectGCedRanges(position, buffered, gcGap) {
  var _getInnerAndOuterTime = (0,ranges/* getInnerAndOuterTimeRanges */.OT)(buffered, position),
    innerRange = _getInnerAndOuterTime.innerRange,
    outerRanges = _getInnerAndOuterTime.outerRanges;
  var cleanedupRanges = [];
  // start by trying to remove all ranges that do not contain the
  // current time and respect the gcGap
  for (var i = 0; i < outerRanges.length; i++) {
    var outerRange = outerRanges[i];
    if (position - gcGap > outerRange.end || position + gcGap < outerRange.start) {
      cleanedupRanges.push(outerRange);
    }
  }
  // try to clean up some space in the current range
  if (innerRange !== null) {
    if (log/* default */.A.hasLevel("DEBUG")) {
      log/* default */.A.debug("Stream: GC removing part of inner range", cleanedupRanges.map(function (_ref) {
        var start = _ref.start,
          end = _ref.end;
        return "start: " + start + " - end " + end;
      }).join(", "));
    }
    if (position - gcGap > innerRange.start) {
      cleanedupRanges.push({
        start: innerRange.start,
        end: position - gcGap
      });
    }
    if (position + gcGap < innerRange.end) {
      cleanedupRanges.push({
        start: position + gcGap,
        end: innerRange.end
      });
    }
  }
  return cleanedupRanges;
}
;// CONCATENATED MODULE: ./src/core/stream/representation/utils/append_segment_to_buffer.ts


/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * This file allows any Stream to push data to a SegmentBuffer.
 */




/**
 * Append a segment to the given segmentBuffer.
 * If it leads to a QuotaExceededError, try to run our custom range
 * _garbage collector_ then retry.
 * @param {Object} playbackObserver
 * @param {Object} segmentBuffer
 * @param {Object} dataInfos
 * @param {Object} cancellationSignal
 * @returns {Promise}
 */
function appendSegmentToBuffer(_x, _x2, _x3, _x4) {
  return _appendSegmentToBuffer.apply(this, arguments);
}
function _appendSegmentToBuffer() {
  _appendSegmentToBuffer = (0,asyncToGenerator/* default */.A)( /*#__PURE__*/regenerator_default().mark(function _callee(playbackObserver, segmentBuffer, dataInfos, cancellationSignal) {
    var _a, reason, _playbackObserver$get, position, currentPos, _reason;
    return regenerator_default().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          _context.prev = 0;
          _context.next = 3;
          return segmentBuffer.pushChunk(dataInfos, cancellationSignal);
        case 3:
          _context.next = 31;
          break;
        case 5:
          _context.prev = 5;
          _context.t0 = _context["catch"](0);
          if (!(cancellationSignal.isCancelled() && _context.t0 instanceof task_canceller/* CancellationError */.AL)) {
            _context.next = 11;
            break;
          }
          throw _context.t0;
        case 11:
          if (!(!(_context.t0 instanceof Error) || _context.t0.name !== "QuotaExceededError")) {
            _context.next = 14;
            break;
          }
          reason = _context.t0 instanceof Error ? _context.t0.toString() : "An unknown error happened when pushing content";
          throw new media_error/* default */.A("BUFFER_APPEND_ERROR", reason, {
            adaptation: dataInfos.inventoryInfos.adaptation
          });
        case 14:
          _playbackObserver$get = playbackObserver.getReference().getValue(), position = _playbackObserver$get.position;
          currentPos = (_a = position.pending) !== null && _a !== void 0 ? _a : position.last;
          _context.prev = 16;
          _context.next = 19;
          return forceGarbageCollection(currentPos, segmentBuffer, cancellationSignal);
        case 19:
          _context.next = 21;
          return (0,sleep/* default */.A)(200);
        case 21:
          if (!(cancellationSignal.cancellationError !== null)) {
            _context.next = 23;
            break;
          }
          throw cancellationSignal.cancellationError;
        case 23:
          _context.next = 25;
          return segmentBuffer.pushChunk(dataInfos, cancellationSignal);
        case 25:
          _context.next = 31;
          break;
        case 27:
          _context.prev = 27;
          _context.t1 = _context["catch"](16);
          _reason = _context.t1 instanceof Error ? _context.t1.toString() : "Could not clean the buffer";
          throw new media_error/* default */.A("BUFFER_FULL_ERROR", _reason, {
            adaptation: dataInfos.inventoryInfos.adaptation
          });
        case 31:
        case "end":
          return _context.stop();
      }
    }, _callee, null, [[0, 5], [16, 27]]);
  }));
  return _appendSegmentToBuffer.apply(this, arguments);
}
;// CONCATENATED MODULE: ./src/core/stream/representation/utils/push_init_segment.ts


/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Push the initialization segment to the SegmentBuffer.
 * @param {Object} args
 * @param {Object} cancelSignal
 * @returns {Promise}
 */
function pushInitSegment(_x, _x2) {
  return _pushInitSegment.apply(this, arguments);
}
function _pushInitSegment() {
  _pushInitSegment = (0,asyncToGenerator/* default */.A)( /*#__PURE__*/regenerator_default().mark(function _callee(_ref, cancelSignal) {
    var playbackObserver, content, initSegmentUniqueId, segment, segmentData, segmentBuffer, codec, data, inventoryInfos, buffered;
    return regenerator_default().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          playbackObserver = _ref.playbackObserver, content = _ref.content, initSegmentUniqueId = _ref.initSegmentUniqueId, segment = _ref.segment, segmentData = _ref.segmentData, segmentBuffer = _ref.segmentBuffer;
          if (!(cancelSignal.cancellationError !== null)) {
            _context.next = 3;
            break;
          }
          throw cancelSignal.cancellationError;
        case 3:
          codec = content.representation.getMimeTypeString();
          data = {
            initSegmentUniqueId: initSegmentUniqueId,
            chunk: null,
            timestampOffset: 0,
            appendWindow: [undefined, undefined],
            codec: codec
          };
          inventoryInfos = (0,object_assign/* default */.A)({
            segment: segment,
            chunkSize: undefined,
            start: 0,
            end: 0
          }, content);
          _context.next = 8;
          return appendSegmentToBuffer(playbackObserver, segmentBuffer, {
            data: data,
            inventoryInfos: inventoryInfos
          }, cancelSignal);
        case 8:
          buffered = segmentBuffer.getBufferedRanges();
          return _context.abrupt("return", {
            content: content,
            segment: segment,
            buffered: buffered,
            segmentData: segmentData
          });
        case 10:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return _pushInitSegment.apply(this, arguments);
}
;// CONCATENATED MODULE: ./src/core/stream/representation/utils/push_media_segment.ts


/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Push a given media segment (non-init segment) to a SegmentBuffer.
 * @param {Object} args
 * @param {Object} cancelSignal
 * @returns {Promise}
 */
function pushMediaSegment(_x, _x2) {
  return _pushMediaSegment.apply(this, arguments);
}
function _pushMediaSegment() {
  _pushMediaSegment = (0,asyncToGenerator/* default */.A)( /*#__PURE__*/regenerator_default().mark(function _callee(_ref, cancelSignal) {
    var playbackObserver, content, initSegmentUniqueId, parsedSegment, segment, segmentBuffer, _a, _b, chunkData, chunkInfos, chunkOffset, chunkSize, appendWindow, codec, _config$getCurrent, APPEND_WINDOW_SECURITIES, safeAppendWindow, data, estimatedStart, estimatedDuration, estimatedEnd, inventoryInfos, buffered;
    return regenerator_default().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          playbackObserver = _ref.playbackObserver, content = _ref.content, initSegmentUniqueId = _ref.initSegmentUniqueId, parsedSegment = _ref.parsedSegment, segment = _ref.segment, segmentBuffer = _ref.segmentBuffer;
          if (!(parsedSegment.chunkData === null)) {
            _context.next = 3;
            break;
          }
          return _context.abrupt("return", null);
        case 3:
          if (!(cancelSignal.cancellationError !== null)) {
            _context.next = 5;
            break;
          }
          throw cancelSignal.cancellationError;
        case 5:
          chunkData = parsedSegment.chunkData, chunkInfos = parsedSegment.chunkInfos, chunkOffset = parsedSegment.chunkOffset, chunkSize = parsedSegment.chunkSize, appendWindow = parsedSegment.appendWindow;
          codec = content.representation.getMimeTypeString();
          _config$getCurrent = config/* default */.A.getCurrent(), APPEND_WINDOW_SECURITIES = _config$getCurrent.APPEND_WINDOW_SECURITIES; // Cutting exactly at the start or end of the appendWindow can lead to
          // cases of infinite rebuffering due to how browser handle such windows.
          // To work-around that, we add a small offset before and after those.
          safeAppendWindow = [appendWindow[0] !== undefined ? Math.max(0, appendWindow[0] - APPEND_WINDOW_SECURITIES.START) : undefined, appendWindow[1] !== undefined ? appendWindow[1] + APPEND_WINDOW_SECURITIES.END : undefined];
          data = {
            initSegmentUniqueId: initSegmentUniqueId,
            chunk: chunkData,
            timestampOffset: chunkOffset,
            appendWindow: safeAppendWindow,
            codec: codec
          };
          estimatedStart = (_a = chunkInfos === null || chunkInfos === void 0 ? void 0 : chunkInfos.time) !== null && _a !== void 0 ? _a : segment.time;
          estimatedDuration = (_b = chunkInfos === null || chunkInfos === void 0 ? void 0 : chunkInfos.duration) !== null && _b !== void 0 ? _b : segment.duration;
          estimatedEnd = estimatedStart + estimatedDuration;
          if (safeAppendWindow[0] !== undefined) {
            estimatedStart = Math.max(estimatedStart, safeAppendWindow[0]);
          }
          if (safeAppendWindow[1] !== undefined) {
            estimatedEnd = Math.min(estimatedEnd, safeAppendWindow[1]);
          }
          inventoryInfos = (0,object_assign/* default */.A)({
            segment: segment,
            chunkSize: chunkSize,
            start: estimatedStart,
            end: estimatedEnd
          }, content);
          _context.next = 18;
          return appendSegmentToBuffer(playbackObserver, segmentBuffer, {
            data: data,
            inventoryInfos: inventoryInfos
          }, cancelSignal);
        case 18:
          buffered = segmentBuffer.getBufferedRanges();
          return _context.abrupt("return", {
            content: content,
            segment: segment,
            buffered: buffered,
            segmentData: chunkData
          });
        case 20:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return _pushMediaSegment.apply(this, arguments);
}
;// CONCATENATED MODULE: ./src/core/stream/representation/representation_stream.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * This file allows to create RepresentationStreams.
 *
 * A RepresentationStream downloads and push segment for a single
 * Representation (e.g. a single video stream of a given quality).
 * It chooses which segments should be downloaded according to the current
 * position and what is currently buffered.
 */










/**
 * Perform the logic to load the right segments for the given Representation and
 * push them to the given `SegmentBuffer`.
 *
 * In essence, this is the entry point of the core streaming logic of the
 * RxPlayer, the one actually responsible for finding which are the current
 * right segments to load, loading them, and pushing them so they can be decoded.
 *
 * Multiple RepresentationStream can run on the same SegmentBuffer.
 * This allows for example smooth transitions between multiple periods.
 *
 * @param {Object} args - Various arguments allowing to know which segments to
 * load, loading them and pushing them.
 * You can check the corresponding type for more information.
 * @param {Object} callbacks - The `RepresentationStream` relies on a system of
 * callbacks that it will call on various events.
 *
 * Depending on the event, the caller may be supposed to perform actions to
 * react upon some of them.
 *
 * This approach is taken instead of a more classical EventEmitter pattern to:
 *   - Allow callbacks to be called synchronously after the
 *     `RepresentationStream` is called.
 *   - Simplify bubbling events up, by just passing through callbacks
 *   - Force the caller to explicitely handle or not the different events.
 *
 * Callbacks may start being called immediately after the `RepresentationStream`
 * call and may be called until either the `parentCancelSignal` argument is
 * triggered, until the `terminating` callback has been triggered AND all loaded
 * segments have been pushed, or until the `error` callback is called, whichever
 * comes first.
 * @param {Object} parentCancelSignal - `CancellationSignal` allowing, when
 * triggered, to immediately stop all operations the `RepresentationStream` is
 * doing.
 */
function RepresentationStream(_ref, callbacks, parentCancelSignal) {
  var content = _ref.content,
    options = _ref.options,
    playbackObserver = _ref.playbackObserver,
    segmentBuffer = _ref.segmentBuffer,
    segmentFetcher = _ref.segmentFetcher,
    terminate = _ref.terminate;
  var period = content.period,
    adaptation = content.adaptation,
    representation = content.representation;
  var bufferGoal = options.bufferGoal,
    maxBufferSize = options.maxBufferSize,
    drmSystemId = options.drmSystemId,
    fastSwitchThreshold = options.fastSwitchThreshold;
  var bufferType = adaptation.type;
  /** `TaskCanceller` stopping ALL operations performed by the `RepresentationStream` */
  var globalCanceller = new task_canceller/* default */.Ay();
  globalCanceller.linkToSignal(parentCancelSignal);
  /**
   * `TaskCanceller` allowing to only stop segment loading and checking operations.
   * This allows to stop only tasks linked to network resource usage, which is
   * often a limited resource, while still letting buffer operations to finish.
   */
  var segmentsLoadingCanceller = new task_canceller/* default */.Ay();
  segmentsLoadingCanceller.linkToSignal(globalCanceller.signal);
  /** Saved initialization segment state for this representation. */
  var initSegmentState = {
    segment: representation.index.getInitSegment(),
    uniqueId: null,
    isLoaded: false
  };
  globalCanceller.signal.register(function () {
    // Free initialization segment if one has been declared
    if (initSegmentState.uniqueId !== null) {
      segmentBuffer.freeInitSegment(initSegmentState.uniqueId);
    }
  });
  /** Emit the last scheduled downloading queue for segments. */
  var lastSegmentQueue = new reference/* default */.A({
    initSegment: null,
    segmentQueue: []
  }, segmentsLoadingCanceller.signal);
  /** If `true`, the current Representation has a linked initialization segment. */
  var hasInitSegment = initSegmentState.segment !== null;
  if (!hasInitSegment) {
    initSegmentState.isLoaded = true;
  }
  /**
   * `true` if the event notifying about encryption data has already been
   * constructed.
   * Allows to avoid sending multiple times protection events.
   */
  var hasSentEncryptionData = false;
  // If the DRM system id is already known, and if we already have encryption data
  // for it, we may not need to wait until the initialization segment is loaded to
  // signal required protection data, thus performing License negotiations sooner
  if (drmSystemId !== undefined) {
    var encryptionData = representation.getEncryptionData(drmSystemId);
    // If some key ids are not known yet, it may be safer to wait for this initialization
    // segment to be loaded first
    if (encryptionData.length > 0 && encryptionData.every(function (e) {
      return e.keyIds !== undefined;
    })) {
      hasSentEncryptionData = true;
      callbacks.encryptionDataEncountered(encryptionData.map(function (d) {
        return (0,object_assign/* default */.A)({
          content: content
        }, d);
      }));
      if (globalCanceller.isUsed()) {
        return; // previous callback has stopped everything by side-effect
      }
    }
  }
  /** Will load every segments in `lastSegmentQueue` */
  var downloadingQueue = new DownloadingQueue(content, lastSegmentQueue, segmentFetcher, hasInitSegment);
  downloadingQueue.addEventListener("error", function (err) {
    if (segmentsLoadingCanceller.signal.isCancelled()) {
      return; // ignore post requests-cancellation loading-related errors,
    }
    globalCanceller.cancel(); // Stop every operations
    callbacks.error(err);
  });
  downloadingQueue.addEventListener("parsedInitSegment", onParsedChunk);
  downloadingQueue.addEventListener("parsedMediaSegment", onParsedChunk);
  downloadingQueue.addEventListener("emptyQueue", checkStatus);
  downloadingQueue.addEventListener("requestRetry", function (payload) {
    callbacks.warning(payload.error);
    if (segmentsLoadingCanceller.signal.isCancelled()) {
      return; // If the previous callback led to loading operations being stopped, skip
    }
    var retriedSegment = payload.segment;
    var index = representation.index;
    if (index.isSegmentStillAvailable(retriedSegment) === false) {
      checkStatus();
    } else if (index.canBeOutOfSyncError(payload.error, retriedSegment)) {
      callbacks.manifestMightBeOufOfSync();
    }
  });
  downloadingQueue.addEventListener("fullyLoadedSegment", function (segment) {
    segmentBuffer.endOfSegment((0,object_assign/* default */.A)({
      segment: segment
    }, content), globalCanceller.signal)["catch"](onFatalBufferError);
  });
  downloadingQueue.start();
  segmentsLoadingCanceller.signal.register(function () {
    downloadingQueue.removeEventListener();
    downloadingQueue.stop();
  });
  playbackObserver.listen(checkStatus, {
    includeLastObservation: false,
    clearSignal: segmentsLoadingCanceller.signal
  });
  content.manifest.addEventListener("manifestUpdate", checkStatus, segmentsLoadingCanceller.signal);
  bufferGoal.onUpdate(checkStatus, {
    emitCurrentValue: false,
    clearSignal: segmentsLoadingCanceller.signal
  });
  maxBufferSize.onUpdate(checkStatus, {
    emitCurrentValue: false,
    clearSignal: segmentsLoadingCanceller.signal
  });
  terminate.onUpdate(checkStatus, {
    emitCurrentValue: false,
    clearSignal: segmentsLoadingCanceller.signal
  });
  checkStatus();
  return;
  /**
   * Produce a buffer status update synchronously on call, update the list
   * of current segments to update and check various buffer and manifest related
   * issues at the current time, calling the right callbacks if necessary.
   */
  function checkStatus() {
    var _a, _b;
    if (segmentsLoadingCanceller.isUsed()) {
      return; // Stop all buffer status checking if load operations are stopped
    }
    var observation = playbackObserver.getReference().getValue();
    var initialWantedTime = (_a = observation.position.pending) !== null && _a !== void 0 ? _a : observation.position.last;
    var status = getBufferStatus(content, initialWantedTime, playbackObserver, fastSwitchThreshold.getValue(), bufferGoal.getValue(), maxBufferSize.getValue(), segmentBuffer);
    var neededSegments = status.neededSegments;
    var neededInitSegment = null;
    // Add initialization segment if required
    if (!representation.index.isInitialized()) {
      if (initSegmentState.segment === null) {
        log/* default */.A.warn("Stream: Uninitialized index without an initialization segment");
      } else if (initSegmentState.isLoaded) {
        log/* default */.A.warn("Stream: Uninitialized index with an already loaded " + "initialization segment");
      } else {
        var wantedStart = (_b = observation.position.pending) !== null && _b !== void 0 ? _b : observation.position.last;
        neededInitSegment = {
          segment: initSegmentState.segment,
          priority: getSegmentPriority(period.start, wantedStart)
        };
      }
    } else if (neededSegments.length > 0 && !initSegmentState.isLoaded && initSegmentState.segment !== null) {
      var initSegmentPriority = neededSegments[0].priority;
      neededInitSegment = {
        segment: initSegmentState.segment,
        priority: initSegmentPriority
      };
    }
    var terminateVal = terminate.getValue();
    if (terminateVal === null) {
      lastSegmentQueue.setValue({
        initSegment: neededInitSegment,
        segmentQueue: neededSegments
      });
    } else if (terminateVal.urgent) {
      log/* default */.A.debug("Stream: Urgent switch, terminate now.", bufferType);
      lastSegmentQueue.setValue({
        initSegment: null,
        segmentQueue: []
      });
      lastSegmentQueue.finish();
      segmentsLoadingCanceller.cancel();
      callbacks.terminating();
      return;
    } else {
      // Non-urgent termination wanted:
      // End the download of the current media segment if pending and
      // terminate once either that request is finished or another segment
      // is wanted instead, whichever comes first.
      var mostNeededSegment = neededSegments[0];
      var initSegmentRequest = downloadingQueue.getRequestedInitSegment();
      var currentSegmentRequest = downloadingQueue.getRequestedMediaSegment();
      var nextQueue = currentSegmentRequest === null || mostNeededSegment === undefined || currentSegmentRequest.id !== mostNeededSegment.segment.id ? [] : [mostNeededSegment];
      var nextInit = initSegmentRequest === null ? null : neededInitSegment;
      lastSegmentQueue.setValue({
        initSegment: nextInit,
        segmentQueue: nextQueue
      });
      if (nextQueue.length === 0 && nextInit === null) {
        log/* default */.A.debug("Stream: No request left, terminate", bufferType);
        lastSegmentQueue.finish();
        segmentsLoadingCanceller.cancel();
        callbacks.terminating();
        return;
      }
    }
    callbacks.streamStatusUpdate({
      period: period,
      position: observation.position.last,
      bufferType: bufferType,
      imminentDiscontinuity: status.imminentDiscontinuity,
      isEmptyStream: false,
      hasFinishedLoading: status.hasFinishedLoading,
      neededSegments: status.neededSegments
    });
    if (segmentsLoadingCanceller.signal.isCancelled()) {
      return; // previous callback has stopped loading operations by side-effect
    }
    var _config$getCurrent = config/* default */.A.getCurrent(),
      UPTO_CURRENT_POSITION_CLEANUP = _config$getCurrent.UPTO_CURRENT_POSITION_CLEANUP;
    if (status.isBufferFull) {
      var gcedPosition = Math.max(0, initialWantedTime - UPTO_CURRENT_POSITION_CLEANUP);
      if (gcedPosition > 0) {
        segmentBuffer.removeBuffer(0, gcedPosition, globalCanceller.signal)["catch"](onFatalBufferError);
      }
    }
    if (status.shouldRefreshManifest) {
      callbacks.needsManifestRefresh();
    }
  }
  /**
   * Process a chunk that has just been parsed by pushing it to the
   * SegmentBuffer and emitting the right events.
   * @param {Object} evt
   */
  function onParsedChunk(evt) {
    if (globalCanceller.isUsed()) {
      // We should not do anything with segments if the `RepresentationStream`
      // is not running anymore.
      return;
    }
    if (evt.segmentType === "init") {
      initSegmentState.isLoaded = true;
      // Now that the initialization segment has been parsed - which may have
      // included encryption information - take care of the encryption event
      // if not already done.
      if (!hasSentEncryptionData) {
        var allEncryptionData = representation.getAllEncryptionData();
        if (allEncryptionData.length > 0) {
          callbacks.encryptionDataEncountered(allEncryptionData.map(function (p) {
            return (0,object_assign/* default */.A)({
              content: content
            }, p);
          }));
          if (globalCanceller.isUsed()) {
            return; // previous callback has stopped everything by side-effect
          }
        }
      }
      if (evt.initializationData !== null) {
        var initSegmentUniqueId = representation.uniqueId;
        initSegmentState.uniqueId = initSegmentUniqueId;
        segmentBuffer.declareInitSegment(initSegmentUniqueId, evt.initializationData);
        pushInitSegment({
          playbackObserver: playbackObserver,
          content: content,
          initSegmentUniqueId: initSegmentUniqueId,
          segment: evt.segment,
          segmentData: evt.initializationData,
          segmentBuffer: segmentBuffer
        }, globalCanceller.signal).then(function (result) {
          if (result !== null) {
            callbacks.addedSegment(result);
          }
        })["catch"](onFatalBufferError);
      }
      // Sometimes the segment list is only known once the initialization segment
      // is parsed. Thus we immediately re-check if there's new segments to load.
      checkStatus();
    } else {
      var inbandEvents = evt.inbandEvents,
        needsManifestRefresh = evt.needsManifestRefresh,
        protectionDataUpdate = evt.protectionDataUpdate;
      // TODO better handle use cases like key rotation by not always grouping
      // every protection data together? To check.
      if (!hasSentEncryptionData && protectionDataUpdate) {
        var _allEncryptionData = representation.getAllEncryptionData();
        if (_allEncryptionData.length > 0) {
          callbacks.encryptionDataEncountered(_allEncryptionData.map(function (p) {
            return (0,object_assign/* default */.A)({
              content: content
            }, p);
          }));
          if (globalCanceller.isUsed()) {
            return; // previous callback has stopped everything by side-effect
          }
        }
      }
      if (needsManifestRefresh === true) {
        callbacks.needsManifestRefresh();
        if (globalCanceller.isUsed()) {
          return; // previous callback has stopped everything by side-effect
        }
      }
      if (inbandEvents !== undefined && inbandEvents.length > 0) {
        callbacks.inbandEvent(inbandEvents);
        if (globalCanceller.isUsed()) {
          return; // previous callback has stopped everything by side-effect
        }
      }
      var _initSegmentUniqueId = initSegmentState.uniqueId;
      pushMediaSegment({
        playbackObserver: playbackObserver,
        content: content,
        initSegmentUniqueId: _initSegmentUniqueId,
        parsedSegment: evt,
        segment: evt.segment,
        segmentBuffer: segmentBuffer
      }, globalCanceller.signal).then(function (result) {
        if (result !== null) {
          callbacks.addedSegment(result);
        }
      })["catch"](onFatalBufferError);
    }
  }
  /**
   * Handle Buffer-related fatal errors by cancelling everything the
   * `RepresentationStream` is doing and calling the error callback with the
   * corresponding error.
   * @param {*} err
   */
  function onFatalBufferError(err) {
    if (globalCanceller.isUsed() && err instanceof task_canceller/* CancellationError */.AL) {
      // The error is linked to cancellation AND we explicitely cancelled buffer
      // operations.
      // We can thus ignore it, it is very unlikely to lead to true buffer issues.
      return;
    }
    globalCanceller.cancel();
    callbacks.error(err);
  }
}
;// CONCATENATED MODULE: ./src/core/stream/representation/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/* harmony default export */ var stream_representation = (RepresentationStream);
;// CONCATENATED MODULE: ./src/core/stream/adaptation/utils/create_representation_estimator.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Produce estimates to know which Representation should be played.
 * @param {Object} content - The Manifest, Period and Adaptation wanted.
 * @param {Object} representationEstimator - `IRepresentationEstimator` which
 * will produce Representation estimates.
 * @param {Object} currentRepresentation - Reference emitting the
 * currently-loaded Representation.
 * @param {Object} playbackObserver - Allows to observe the current playback
 * conditions.
 * @param {Function} onFatalError - Callback called when a fatal error was
 * thrown. Once this callback is called, no estimate will be produced.
 * @param {Object} cancellationSignal - `CancellationSignal` allowing to abort
 * the production of estimates (and clean-up all linked resources).
 * @returns {Object} - Returns an object with the following properties:
 *   - `estimateRef`: Reference emitting the last estimate
 *   - `abrCallbacks`: Callbacks allowing to report back network and playback
 *     activities to improve the estimates given.
 */
function getRepresentationEstimate(content, representationEstimator, currentRepresentation, playbackObserver, onFatalError, cancellationSignal) {
  var manifest = content.manifest,
    adaptation = content.adaptation;
  var representations = new reference/* default */.A([], cancellationSignal);
  updateRepresentationsReference();
  manifest.addEventListener("decipherabilityUpdate", updateRepresentationsReference);
  var unregisterCleanUp = cancellationSignal.register(cleanUp);
  var _representationEstima = representationEstimator(content, currentRepresentation, representations, playbackObserver, cancellationSignal),
    estimateRef = _representationEstima.estimates,
    abrCallbacks = _representationEstima.callbacks;
  return {
    abrCallbacks: abrCallbacks,
    estimateRef: estimateRef
  };
  function updateRepresentationsReference() {
    /** Representations for which a `RepresentationStream` can be created. */
    var newRepr = adaptation.getPlayableRepresentations();
    if (newRepr.length === 0) {
      var noRepErr = new media_error/* default */.A("NO_PLAYABLE_REPRESENTATION", "No Representation in the chosen " + adaptation.type + " Adaptation can be played", {
        adaptation: adaptation
      });
      cleanUp();
      onFatalError(noRepErr);
      return;
    }
    var prevRepr = representations.getValue();
    if (prevRepr.length === newRepr.length) {
      if (prevRepr.every(function (r, idx) {
        return r.id === newRepr[idx].id;
      })) {
        return;
      }
    }
    representations.setValue(newRepr);
  }
  /** Clean-up all resources taken here. */
  function cleanUp() {
    manifest.removeEventListener("decipherabilityUpdate", updateRepresentationsReference);
    // check to protect against the case where it is not yet defined.
    if (typeof unregisterCleanUp !== "undefined") {
      unregisterCleanUp();
    }
  }
}
;// CONCATENATED MODULE: ./src/core/stream/adaptation/adaptation_stream.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */











/**
 * Create new `AdaptationStream` whose task will be to download the media data
 * for a given Adaptation (i.e. "track").
 *
 * It will rely on the IRepresentationEstimator to choose at any time the
 * best Representation for this Adaptation and then run the logic to download
 * and push the corresponding segments in the SegmentBuffer.
 *
 * @param {Object} args - Various arguments allowing the `AdaptationStream` to
 * determine which Representation to choose and which segments to load from it.
 * You can check the corresponding type for more information.
 * @param {Object} callbacks - The `AdaptationStream` relies on a system of
 * callbacks that it will call on various events.
 *
 * Depending on the event, the caller may be supposed to perform actions to
 * react upon some of them.
 *
 * This approach is taken instead of a more classical EventEmitter pattern to:
 *   - Allow callbacks to be called synchronously after the
 *     `AdaptationStream` is called.
 *   - Simplify bubbling events up, by just passing through callbacks
 *   - Force the caller to explicitely handle or not the different events.
 *
 * Callbacks may start being called immediately after the `AdaptationStream`
 * call and may be called until either the `parentCancelSignal` argument is
 * triggered, or until the `error` callback is called, whichever comes first.
 * @param {Object} parentCancelSignal - `CancellationSignal` allowing, when
 * triggered, to immediately stop all operations the `AdaptationStream` is
 * doing.
 */
function AdaptationStream(_ref, callbacks, parentCancelSignal) {
  var playbackObserver = _ref.playbackObserver,
    content = _ref.content,
    options = _ref.options,
    representationEstimator = _ref.representationEstimator,
    segmentBuffer = _ref.segmentBuffer,
    segmentFetcherCreator = _ref.segmentFetcherCreator,
    wantedBufferAhead = _ref.wantedBufferAhead,
    maxVideoBufferSize = _ref.maxVideoBufferSize;
  var directManualBitrateSwitching = options.manualBitrateSwitchingMode === "direct";
  var manifest = content.manifest,
    period = content.period,
    adaptation = content.adaptation;
  /** Allows to cancel everything the `AdaptationStream` is doing. */
  var adapStreamCanceller = new task_canceller/* default */.Ay();
  adapStreamCanceller.linkToSignal(parentCancelSignal);
  /**
   * The buffer goal ratio base itself on the value given by `wantedBufferAhead`
   * to determine a more dynamic buffer goal for a given Representation.
   *
   * It can help in cases such as : the current browser has issues with
   * buffering and tells us that we should try to bufferize less data :
   * https://developers.google.com/web/updates/2017/10/quotaexceedederror
   */
  var bufferGoalRatioMap = new Map();
  /**
   * Emit the currently chosen `Representation`.
   * `null` if no Representation is chosen for now.
   */
  var currentRepresentation = new reference/* default */.A(null, adapStreamCanceller.signal);
  var _createRepresentation = getRepresentationEstimate(content, representationEstimator, currentRepresentation, playbackObserver, function (err) {
      adapStreamCanceller.cancel();
      callbacks.error(err);
    }, adapStreamCanceller.signal),
    estimateRef = _createRepresentation.estimateRef,
    abrCallbacks = _createRepresentation.abrCallbacks;
  /** Allows the `RepresentationStream` to easily fetch media segments. */
  var segmentFetcher = segmentFetcherCreator.createSegmentFetcher(adaptation.type, /* eslint-disable @typescript-eslint/unbound-method */
  {
    onRequestBegin: abrCallbacks.requestBegin,
    onRequestEnd: abrCallbacks.requestEnd,
    onProgress: abrCallbacks.requestProgress,
    onMetrics: abrCallbacks.metrics
  });
  /* eslint-enable @typescript-eslint/unbound-method */
  /** Stores the last emitted bitrate. */
  var previousBitrate;
  /** Emit at each bitrate estimate done by the IRepresentationEstimator. */
  estimateRef.onUpdate(function (_ref2) {
    var bitrate = _ref2.bitrate;
    if (bitrate === undefined) {
      return;
    }
    if (bitrate === previousBitrate) {
      return;
    }
    previousBitrate = bitrate;
    log/* default */.A.debug("Stream: new " + adaptation.type + " bitrate estimate", bitrate);
    callbacks.bitrateEstimationChange({
      type: adaptation.type,
      bitrate: bitrate
    });
  }, {
    emitCurrentValue: true,
    clearSignal: adapStreamCanceller.signal
  });
  recursivelyCreateRepresentationStreams(true);
  /**
   * Create `RepresentationStream`s starting with the Representation of the last
   * estimate performed.
   * Each time a new estimate is made, this function will create a new
   * `RepresentationStream` corresponding to that new estimate.
   * @param {boolean} isFirstEstimate - Whether this is the first time we're
   * creating a `RepresentationStream` in the corresponding `AdaptationStream`.
   * This is important because manual quality switches might need a full reload
   * of the MediaSource _except_ if we are talking about the first quality chosen.
   */
  function recursivelyCreateRepresentationStreams(isFirstEstimate) {
    /**
     * `TaskCanceller` triggered when the current `RepresentationStream` is
     * terminating and as such the next one might be immediately created
     * recursively.
     */
    var repStreamTerminatingCanceller = new task_canceller/* default */.Ay();
    repStreamTerminatingCanceller.linkToSignal(adapStreamCanceller.signal);
    var _estimateRef$getValue = estimateRef.getValue(),
      representation = _estimateRef$getValue.representation,
      manual = _estimateRef$getValue.manual;
    if (representation === null) {
      return;
    }
    // A manual bitrate switch might need an immediate feedback.
    // To do that properly, we need to reload the MediaSource
    if (directManualBitrateSwitching && manual && !isFirstEstimate) {
      var _config$getCurrent = config/* default */.A.getCurrent(),
        DELTA_POSITION_AFTER_RELOAD = _config$getCurrent.DELTA_POSITION_AFTER_RELOAD;
      // We begin by scheduling a micro-task to reduce the possibility of race
      // conditions where the inner logic would be called synchronously before
      // the next observation (which may reflect very different playback conditions)
      // is actually received.
      return next_tick_default()(function () {
        if (repStreamTerminatingCanceller.isUsed()) {
          return;
        }
        var _estimateRef$getValue2 = estimateRef.getValue(),
          newManual = _estimateRef$getValue2.manual;
        if (!newManual) {
          return;
        }
        var timeOffset = DELTA_POSITION_AFTER_RELOAD.bitrateSwitch;
        return callbacks.waitingMediaSourceReload({
          bufferType: adaptation.type,
          period: period,
          timeOffset: timeOffset,
          stayInPeriod: true
        });
      });
    }
    /**
     * Emit when the current RepresentationStream should be terminated to make
     * place for a new one (e.g. when switching quality).
     */
    var terminateCurrentStream = new reference/* default */.A(null, repStreamTerminatingCanceller.signal);
    /** Allows to stop listening to estimateRef on the following line. */
    estimateRef.onUpdate(function (estimate) {
      if (estimate.representation === null || estimate.representation.id === representation.id) {
        return;
      }
      if (estimate.urgent) {
        log/* default */.A.info("Stream: urgent Representation switch", adaptation.type);
        return terminateCurrentStream.setValue({
          urgent: true
        });
      } else {
        log/* default */.A.info("Stream: slow Representation switch", adaptation.type);
        return terminateCurrentStream.setValue({
          urgent: false
        });
      }
    }, {
      clearSignal: repStreamTerminatingCanceller.signal,
      emitCurrentValue: true
    });
    /**
     * "Fast-switching" is a behavior allowing to replace low-quality segments
     * (i.e. with a low bitrate) with higher-quality segments (higher bitrate) in
     * the buffer.
     * This threshold defines a bitrate from which "fast-switching" is disabled.
     * For example with a fastSwitchThreshold set to `100`, segments with a
     * bitrate of `90` can be replaced. But segments with a bitrate of `100`
     * onward won't be replaced by higher quality segments.
     * Set to `undefined` to indicate that there's no threshold (anything can be
     * replaced by higher-quality segments).
     */
    var fastSwitchThreshold = new reference/* default */.A(0);
    if (options.enableFastSwitching) {
      estimateRef.onUpdate(function (estimate) {
        fastSwitchThreshold.setValueIfChanged(estimate === null || estimate === void 0 ? void 0 : estimate.knownStableBitrate);
      }, {
        clearSignal: repStreamTerminatingCanceller.signal,
        emitCurrentValue: true
      });
    }
    var repInfo = {
      type: adaptation.type,
      period: period,
      representation: representation
    };
    currentRepresentation.setValue(representation);
    if (adapStreamCanceller.isUsed()) {
      return; // previous callback has stopped everything by side-effect
    }
    callbacks.representationChange(repInfo);
    if (adapStreamCanceller.isUsed()) {
      return; // previous callback has stopped everything by side-effect
    }
    var representationStreamCallbacks = {
      streamStatusUpdate: callbacks.streamStatusUpdate,
      encryptionDataEncountered: callbacks.encryptionDataEncountered,
      manifestMightBeOufOfSync: callbacks.manifestMightBeOufOfSync,
      needsManifestRefresh: callbacks.needsManifestRefresh,
      inbandEvent: callbacks.inbandEvent,
      warning: callbacks.warning,
      error: function error(err) {
        if (task_canceller/* default */.Ay.isCancellationError(err) && adapStreamCanceller.isUsed()) {
          return;
        }
        adapStreamCanceller.cancel();
        callbacks.error(err);
      },
      addedSegment: function addedSegment(segmentInfo) {
        abrCallbacks.addedSegment(segmentInfo);
        if (adapStreamCanceller.isUsed()) {
          return;
        }
        callbacks.addedSegment(segmentInfo);
      },
      terminating: function terminating() {
        if (repStreamTerminatingCanceller.isUsed()) {
          return; // Already handled
        }
        repStreamTerminatingCanceller.cancel();
        return recursivelyCreateRepresentationStreams(false);
      }
    };
    createRepresentationStream(representation, terminateCurrentStream, fastSwitchThreshold, representationStreamCallbacks);
  }
  /**
   * Create and returns a new `RepresentationStream`, linked to the
   * given Representation.
   * @param {Object} representation
   * @param {Object} terminateCurrentStream
   * @param {Object} fastSwitchThreshold
   * @param {Object} representationStreamCallbacks
   */
  function createRepresentationStream(representation, terminateCurrentStream, fastSwitchThreshold, representationStreamCallbacks) {
    /**
     * `TaskCanceller` triggered when the `RepresentationStream` calls its
     * `terminating` callback.
     */
    var terminatingRepStreamCanceller = new task_canceller/* default */.Ay();
    terminatingRepStreamCanceller.linkToSignal(adapStreamCanceller.signal);
    var bufferGoal = (0,reference/* createMappedReference */.D)(wantedBufferAhead, function (prev) {
      return getBufferGoal(representation, prev);
    }, terminatingRepStreamCanceller.signal);
    var maxBufferSize = adaptation.type === "video" ? maxVideoBufferSize : new reference/* default */.A(Infinity);
    log/* default */.A.info("Stream: changing representation", adaptation.type, representation.id, representation.bitrate);
    var updatedCallbacks = (0,object_assign/* default */.A)({}, representationStreamCallbacks, {
      error: function error(err) {
        var _a;
        var formattedError = (0,format_error/* default */.A)(err, {
          defaultCode: "NONE",
          defaultReason: "Unknown `RepresentationStream` error"
        });
        if (formattedError.code !== "BUFFER_FULL_ERROR") {
          representationStreamCallbacks.error(err);
        } else {
          var wba = wantedBufferAhead.getValue();
          var lastBufferGoalRatio = (_a = bufferGoalRatioMap.get(representation.id)) !== null && _a !== void 0 ? _a : 1;
          // 70%, 49%, 34.3%, 24%, 16.81%, 11.76%, 8.24% and 5.76%
          var newBufferGoalRatio = lastBufferGoalRatio * 0.7;
          bufferGoalRatioMap.set(representation.id, newBufferGoalRatio);
          if (newBufferGoalRatio <= 0.05 || getBufferGoal(representation, wba) <= 2) {
            representationStreamCallbacks.error(formattedError);
            return;
          }
          // We wait 4 seconds to let the situation evolve by itself before
          // retrying loading segments with a lower buffer goal
          (0,cancellable_sleep/* default */.A)(4000, adapStreamCanceller.signal).then(function () {
            return createRepresentationStream(representation, terminateCurrentStream, fastSwitchThreshold, representationStreamCallbacks);
          })["catch"](noop/* default */.A);
        }
      },
      terminating: function terminating() {
        terminatingRepStreamCanceller.cancel();
        representationStreamCallbacks.terminating();
      }
    });
    stream_representation({
      playbackObserver: playbackObserver,
      content: {
        representation: representation,
        adaptation: adaptation,
        period: period,
        manifest: manifest
      },
      segmentBuffer: segmentBuffer,
      segmentFetcher: segmentFetcher,
      terminate: terminateCurrentStream,
      options: {
        bufferGoal: bufferGoal,
        maxBufferSize: maxBufferSize,
        drmSystemId: options.drmSystemId,
        fastSwitchThreshold: fastSwitchThreshold
      }
    }, updatedCallbacks, adapStreamCanceller.signal);
  }
  /**
   * Returns how much media data should be pre-buffered for this
   * `Representation`, according to the `wantedBufferAhead` setting and previous
   * issues encountered with that `Representation`.
   * @param {Object} representation - The `Representation` you want to buffer.
   * @param {number} wba - The value of `wantedBufferAhead` set by the user.
   * @returns {number}
   */
  function getBufferGoal(representation, wba) {
    var oldBufferGoalRatio = bufferGoalRatioMap.get(representation.id);
    var bufferGoalRatio = oldBufferGoalRatio !== undefined ? oldBufferGoalRatio : 1;
    if (oldBufferGoalRatio === undefined) {
      bufferGoalRatioMap.set(representation.id, bufferGoalRatio);
    }
    if (bufferGoalRatio < 1 && wba === Infinity) {
      // When `wba` is equal to `Infinity`, dividing it will still make it equal
      // to `Infinity`. To make the `bufferGoalRatio` still have an effect, we
      // just starts from a `wba` set to the high value of 5 minutes.
      return 5 * 60 * 1000 * bufferGoalRatio;
    }
    return wba * bufferGoalRatio;
  }
}
;// CONCATENATED MODULE: ./src/core/stream/adaptation/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/* harmony default export */ var stream_adaptation = (AdaptationStream);
// EXTERNAL MODULE: ./src/utils/starts_with.ts
var starts_with = __webpack_require__(9828);
;// CONCATENATED MODULE: ./src/utils/are_codecs_compatible.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * This function is a shortcut that helps differentiate two codecs
 * of the form "audio/mp4;codecs=\"av1.40.2\"".
 *
 * @param codecA
 * @param codecB
 * @returns A boolean that tell whether or not those two codecs provided are even.
 */
function areCodecsCompatible(a, b) {
  var _a$split = a.split(";"),
    mimeTypeA = _a$split[0],
    propsA = _a$split.slice(1);
  var _b$split = b.split(";"),
    mimeTypeB = _b$split[0],
    propsB = _b$split.slice(1);
  if (mimeTypeA !== mimeTypeB) {
    return false;
  }
  var codecsA = (0,array_find/* default */.A)(propsA, function (prop) {
    return (0,starts_with/* default */.A)(prop, "codecs=");
  });
  var codecsB = (0,array_find/* default */.A)(propsB, function (prop) {
    return (0,starts_with/* default */.A)(prop, "codecs=");
  });
  if (codecsA === undefined || codecsB === undefined) {
    return false;
  }
  var codecA = codecsA.substring(7);
  var codecB = codecsB.substring(7);
  var initialPartA = codecA.split(".")[0];
  initialPartA = initialPartA === "hev1" ? "hvc1" : initialPartA;
  var initialPartB = codecB.split(".")[0];
  initialPartB = initialPartB === "hev1" ? "hvc1" : initialPartB;
  if (initialPartA !== initialPartB) {
    return false;
  }
  return true;
}
/* harmony default export */ var are_codecs_compatible = (areCodecsCompatible);
;// CONCATENATED MODULE: ./src/core/stream/period/utils/get_adaptation_switch_strategy.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Find out what to do when switching Adaptation, based on the current
 * situation.
 * @param {Object} segmentBuffer
 * @param {Object} period
 * @param {Object} adaptation
 * @param {Object} playbackInfo
 * @returns {Object}
 */
function getAdaptationSwitchStrategy(segmentBuffer, period, adaptation, playbackInfo, options) {
  if (segmentBuffer.codec !== undefined && options.onCodecSwitch === "reload" && !hasCompatibleCodec(adaptation, segmentBuffer.codec)) {
    return {
      type: "needs-reload",
      value: undefined
    };
  }
  var buffered = segmentBuffer.getBufferedRanges();
  if (buffered.length === 0) {
    return {
      type: "continue",
      value: undefined
    };
  }
  var bufferedRanges = (0,ranges/* convertToRanges */.Nn)(buffered);
  var start = period.start;
  var end = period.end == null ? Infinity : period.end;
  var intersection = (0,ranges/* keepRangeIntersection */.aW)(bufferedRanges, [{
    start: start,
    end: end
  }]);
  if (intersection.length === 0) {
    return {
      type: "continue",
      value: undefined
    };
  }
  segmentBuffer.synchronizeInventory();
  var inventory = segmentBuffer.getInventory();
  // Continue if we have no other Adaptation buffered in the current Period
  if (!inventory.some(function (buf) {
    return buf.infos.period.id === period.id && buf.infos.adaptation.id !== adaptation.id;
  })) {
    return {
      type: "continue",
      value: undefined
    };
  }
  /** Data already in the right Adaptation */
  var adaptationInBuffer = getBufferedRangesFromAdaptation(inventory, period, adaptation);
  /**
   * Data different from the wanted Adaptation in the Period's range.
   * /!\ Could contain some data at the end of the previous Period or at the
   * beginning of the next one.
   */
  var unwantedRange = (0,ranges/* excludeFromRanges */.bo)(intersection, adaptationInBuffer);
  if (unwantedRange.length === 0) {
    return {
      type: "continue",
      value: undefined
    };
  }
  var currentTime = playbackInfo.currentTime;
  var audioTrackSwitchingMode = options.audioTrackSwitchingMode;
  var hasReloadSwitchingMode = adaptation.type === "video" || adaptation.type === "audio" && audioTrackSwitchingMode === "reload";
  if (hasReloadSwitchingMode &&
  // We're playing the current Period
  (0,ranges/* isTimeInRange */.gV)({
    start: start,
    end: end
  }, currentTime) && (
  // There is data for the current position or the codecs are differents
  playbackInfo.readyState > 1 || !adaptation.getPlayableRepresentations().some(function (rep) {
    var _a;
    return are_codecs_compatible(rep.getMimeTypeString(), (_a = segmentBuffer.codec) !== null && _a !== void 0 ? _a : "");
  })) &&
  // We're not playing the current wanted video Adaptation
  !(0,ranges/* isTimeInRanges */.Hh)(adaptationInBuffer, currentTime)) {
    return {
      type: "needs-reload",
      value: undefined
    };
  }
  // From here, clean-up data from the previous Adaptation, if one
  var shouldFlush = adaptation.type === "audio" && audioTrackSwitchingMode === "direct";
  var rangesToExclude = [];
  // First, we don't want to accidentally remove some segments from the previous
  // Period (which overlap a little with this one)
  /** Last segment before one for the current period. */
  var lastSegmentBefore = getLastSegmentBeforePeriod(inventory, period);
  if (lastSegmentBefore !== null && (lastSegmentBefore.bufferedEnd === undefined || period.start - lastSegmentBefore.bufferedEnd < 1)) {
    // Close to Period's start
    // Exclude data close to the period's start to avoid cleaning
    // to much
    rangesToExclude.push({
      start: 0,
      end: period.start + 1
    });
  }
  // Next, exclude data around current position to avoid decoding issues
  var bufferType = adaptation.type;
  var _config$getCurrent = config/* default */.A.getCurrent(),
    ADAPTATION_SWITCH_BUFFER_PADDINGS = _config$getCurrent.ADAPTATION_SWITCH_BUFFER_PADDINGS;
  /** Ranges that won't be cleaned from the current buffer. */
  var paddingBefore = ADAPTATION_SWITCH_BUFFER_PADDINGS[bufferType].before;
  if (paddingBefore == null) {
    paddingBefore = 0;
  }
  var paddingAfter = ADAPTATION_SWITCH_BUFFER_PADDINGS[bufferType].after;
  if (paddingAfter == null) {
    paddingAfter = 0;
  }
  if (!shouldFlush) {
    rangesToExclude.push({
      start: currentTime - paddingBefore,
      end: currentTime + paddingAfter
    });
  }
  // Now remove possible small range from the end if there is a segment from the
  // next Period
  if (period.end !== undefined) {
    /** first segment after for the current period. */
    var firstSegmentAfter = getFirstSegmentAfterPeriod(inventory, period);
    if (firstSegmentAfter !== null && (firstSegmentAfter.bufferedStart === undefined || firstSegmentAfter.bufferedStart - period.end < 1)) {
      // Close to Period's end
      rangesToExclude.push({
        start: period.end - 1,
        end: Number.MAX_VALUE
      });
    }
  }
  var toRemove = (0,ranges/* excludeFromRanges */.bo)(unwantedRange, rangesToExclude);
  if (toRemove.length === 0) {
    return {
      type: "continue",
      value: undefined
    };
  }
  return shouldFlush ? {
    type: "flush-buffer",
    value: toRemove
  } : {
    type: "clean-buffer",
    value: toRemove
  };
}
/**
 * Returns `true` if at least one codec of the Representations in the given
 * Adaptation has a codec compatible with the given SegmentBuffer's codec.
 * @param {Object} adaptation
 * @param {string} segmentBufferCodec
 * @returns {boolean}
 */
function hasCompatibleCodec(adaptation, segmentBufferCodec) {
  return adaptation.getPlayableRepresentations().some(function (rep) {
    return are_codecs_compatible(rep.getMimeTypeString(), segmentBufferCodec);
  });
}
/**
 * Returns buffered ranges of what we know correspond to the given `adaptation`
 * in the SegmentBuffer.
 * @param {Object} segmentBuffer
 * @param {Object} period
 * @param {Object} adaptation
 * @returns {Array.<Object>}
 */
function getBufferedRangesFromAdaptation(inventory, period, adaptation) {
  return inventory.reduce(function (acc, chunk) {
    if (chunk.infos.period.id !== period.id || chunk.infos.adaptation.id !== adaptation.id) {
      return acc;
    }
    var bufferedStart = chunk.bufferedStart,
      bufferedEnd = chunk.bufferedEnd;
    if (bufferedStart === undefined || bufferedEnd === undefined) {
      return acc;
    }
    acc.push({
      start: bufferedStart,
      end: bufferedEnd
    });
    return acc;
  }, []);
}
/**
 * Returns the last segment in the `inventory` which is linked to a Period
 * before `period`.
 * @param {Array.<Object>} inventory
 * @param {Object} period
 * @returns {Object|null}
 */
function getLastSegmentBeforePeriod(inventory, period) {
  for (var i = 0; i < inventory.length; i++) {
    if (inventory[i].infos.period.start >= period.start) {
      if (i > 0) {
        return inventory[i - 1];
      }
      return null;
    }
  }
  return inventory.length > 0 ? inventory[inventory.length - 1] : null;
}
/**
 * Returns the first segment in the `inventory` which is linked to a Period
 * after `period`.
 * @param {Array.<Object>} inventory
 * @param {Object} period
 * @returns {Object|null}
 */
function getFirstSegmentAfterPeriod(inventory, period) {
  for (var i = 0; i < inventory.length; i++) {
    if (inventory[i].infos.period.start > period.start) {
      return inventory[i];
    }
  }
  return null;
}
;// CONCATENATED MODULE: ./src/core/stream/period/period_stream.ts


function period_stream_createForOfIteratorHelperLoose(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (t) return (t = t.call(r)).next.bind(t); if (Array.isArray(r) || (t = period_stream_unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var o = 0; return function () { return o >= r.length ? { done: !0 } : { done: !1, value: r[o++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function period_stream_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return period_stream_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? period_stream_arrayLikeToArray(r, a) : void 0; } }
function period_stream_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */











/**
 * Create a single PeriodStream:
 *   - Lazily create (or reuse) a SegmentBuffer for the given type.
 *   - Create a Stream linked to an Adaptation each time it changes, to
 *     download and append the corresponding segments to the SegmentBuffer.
 *   - Announce when the Stream is full or is awaiting new Segments through
 *     events
 *
 * @param {Object} args - Various arguments allowing the `PeriodStream` to
 * determine which Adaptation and which Representation to choose, as well as
 * which segments to load from it.
 * You can check the corresponding type for more information.
 * @param {Object} callbacks - The `PeriodStream` relies on a system of
 * callbacks that it will call on various events.
 *
 * Depending on the event, the caller may be supposed to perform actions to
 * react upon some of them.
 *
 * This approach is taken instead of a more classical EventEmitter pattern to:
 *   - Allow callbacks to be called synchronously after the
 *     `AdaptationStream` is called.
 *   - Simplify bubbling events up, by just passing through callbacks
 *   - Force the caller to explicitely handle or not the different events.
 *
 * Callbacks may start being called immediately after the `AdaptationStream`
 * call and may be called until either the `parentCancelSignal` argument is
 * triggered, or until the `error` callback is called, whichever comes first.
 * @param {Object} parentCancelSignal - `CancellationSignal` allowing, when
 * triggered, to immediately stop all operations the `PeriodStream` is
 * doing.
 */
function PeriodStream(_ref, callbacks, parentCancelSignal) {
  var bufferType = _ref.bufferType,
    content = _ref.content,
    garbageCollectors = _ref.garbageCollectors,
    playbackObserver = _ref.playbackObserver,
    representationEstimator = _ref.representationEstimator,
    segmentFetcherCreator = _ref.segmentFetcherCreator,
    segmentBuffersStore = _ref.segmentBuffersStore,
    options = _ref.options,
    wantedBufferAhead = _ref.wantedBufferAhead,
    maxVideoBufferSize = _ref.maxVideoBufferSize;
  var period = content.period;
  /**
   * Emits the chosen Adaptation for the current type.
   * `null` when no Adaptation is chosen (e.g. no subtitles)
   * `undefined` at the beginning (it can be ignored.).
   */
  var adaptationRef = new reference/* default */.A(undefined, parentCancelSignal);
  callbacks.periodStreamReady({
    type: bufferType,
    period: period,
    adaptationRef: adaptationRef
  });
  if (parentCancelSignal.isCancelled()) {
    return;
  }
  var currentStreamCanceller;
  var isFirstAdaptationSwitch = true;
  adaptationRef.onUpdate(function (adaptation) {
    // As an IIFE to profit from async/await while respecting onUpdate's signature
    (0,asyncToGenerator/* default */.A)( /*#__PURE__*/regenerator_default().mark(function _callee() {
      var _a, streamCanceller, segmentBufferStatus, periodEnd, _config$getCurrent, DELTA_POSITION_AFTER_RELOAD, relativePosAfterSwitch, readyState, segmentBuffer, playbackInfos, strategy, _iterator, _step, _step$value, start, end;
      return regenerator_default().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            if (!(adaptation === undefined)) {
              _context.next = 2;
              break;
            }
            return _context.abrupt("return");
          case 2:
            streamCanceller = new task_canceller/* default */.Ay();
            streamCanceller.linkToSignal(parentCancelSignal);
            currentStreamCanceller === null || currentStreamCanceller === void 0 ? void 0 : currentStreamCanceller.cancel(); // Cancel oreviously created stream if one
            currentStreamCanceller = streamCanceller;
            if (!(adaptation === null)) {
              _context.next = 34;
              break;
            }
            // Current type is disabled for that Period
            log/* default */.A.info("Stream: Set no " + bufferType + " Adaptation. P:", period.start);
            segmentBufferStatus = segmentBuffersStore.getStatus(bufferType);
            if (!(segmentBufferStatus.type === "initialized")) {
              _context.next = 26;
              break;
            }
            log/* default */.A.info("Stream: Clearing previous " + bufferType + " SegmentBuffer");
            if (!segment_buffers.isNative(bufferType)) {
              _context.next = 15;
              break;
            }
            return _context.abrupt("return", askForMediaSourceReload(0, true, streamCanceller.signal));
          case 15:
            periodEnd = (_a = period.end) !== null && _a !== void 0 ? _a : Infinity;
            if (!(period.start > periodEnd)) {
              _context.next = 20;
              break;
            }
            log/* default */.A.warn("Stream: Can't free buffer: period's start is after its end");
            _context.next = 24;
            break;
          case 20:
            _context.next = 22;
            return segmentBufferStatus.value.removeBuffer(period.start, periodEnd, streamCanceller.signal);
          case 22:
            if (!streamCanceller.isUsed()) {
              _context.next = 24;
              break;
            }
            return _context.abrupt("return");
          case 24:
            _context.next = 30;
            break;
          case 26:
            if (!(segmentBufferStatus.type === "uninitialized")) {
              _context.next = 30;
              break;
            }
            segmentBuffersStore.disableSegmentBuffer(bufferType);
            if (!streamCanceller.isUsed()) {
              _context.next = 30;
              break;
            }
            return _context.abrupt("return");
          case 30:
            callbacks.adaptationChange({
              type: bufferType,
              adaptation: null,
              period: period
            });
            if (!streamCanceller.isUsed()) {
              _context.next = 33;
              break;
            }
            return _context.abrupt("return");
          case 33:
            return _context.abrupt("return", createEmptyAdaptationStream(playbackObserver, wantedBufferAhead, bufferType, {
              period: period
            }, callbacks, streamCanceller.signal));
          case 34:
            /**
             * If this is not the first Adaptation choice, we might want to apply a
             * delta to the current position so we can re-play back some media in the
             * new Adaptation to give some context back.
             * This value contains this relative position, in seconds.
             * @see askForMediaSourceReload
             */
            _config$getCurrent = config/* default */.A.getCurrent(), DELTA_POSITION_AFTER_RELOAD = _config$getCurrent.DELTA_POSITION_AFTER_RELOAD;
            relativePosAfterSwitch = isFirstAdaptationSwitch ? 0 : bufferType === "audio" ? DELTA_POSITION_AFTER_RELOAD.trackSwitch.audio : bufferType === "video" ? DELTA_POSITION_AFTER_RELOAD.trackSwitch.video : DELTA_POSITION_AFTER_RELOAD.trackSwitch.other;
            isFirstAdaptationSwitch = false;
            if (!(segment_buffers.isNative(bufferType) && segmentBuffersStore.getStatus(bufferType).type === "disabled")) {
              _context.next = 39;
              break;
            }
            return _context.abrupt("return", askForMediaSourceReload(relativePosAfterSwitch, true, streamCanceller.signal));
          case 39:
            log/* default */.A.info("Stream: Updating " + bufferType + " adaptation", "A: " + adaptation.id, "P: " + period.start);
            callbacks.adaptationChange({
              type: bufferType,
              adaptation: adaptation,
              period: period
            });
            if (!streamCanceller.isUsed()) {
              _context.next = 43;
              break;
            }
            return _context.abrupt("return");
          case 43:
            readyState = playbackObserver.getReadyState();
            segmentBuffer = createOrReuseSegmentBuffer(segmentBuffersStore, bufferType, adaptation, options);
            playbackInfos = {
              currentTime: playbackObserver.getCurrentTime(),
              readyState: readyState
            };
            strategy = getAdaptationSwitchStrategy(segmentBuffer, period, adaptation, playbackInfos, options);
            if (!(strategy.type === "needs-reload")) {
              _context.next = 49;
              break;
            }
            return _context.abrupt("return", askForMediaSourceReload(relativePosAfterSwitch, true, streamCanceller.signal));
          case 49:
            _context.next = 51;
            return segmentBuffersStore.waitForUsableBuffers(streamCanceller.signal);
          case 51:
            if (!streamCanceller.isUsed()) {
              _context.next = 53;
              break;
            }
            return _context.abrupt("return");
          case 53:
            if (!(strategy.type === "flush-buffer" || strategy.type === "clean-buffer")) {
              _context.next = 67;
              break;
            }
            _iterator = period_stream_createForOfIteratorHelperLoose(strategy.value);
          case 55:
            if ((_step = _iterator()).done) {
              _context.next = 63;
              break;
            }
            _step$value = _step.value, start = _step$value.start, end = _step$value.end;
            _context.next = 59;
            return segmentBuffer.removeBuffer(start, end, streamCanceller.signal);
          case 59:
            if (!streamCanceller.isUsed()) {
              _context.next = 61;
              break;
            }
            return _context.abrupt("return");
          case 61:
            _context.next = 55;
            break;
          case 63:
            if (!(strategy.type === "flush-buffer")) {
              _context.next = 67;
              break;
            }
            callbacks.needsBufferFlush();
            if (!streamCanceller.isUsed()) {
              _context.next = 67;
              break;
            }
            return _context.abrupt("return");
          case 67:
            garbageCollectors.get(segmentBuffer)(streamCanceller.signal);
            createAdaptationStream(adaptation, segmentBuffer, streamCanceller.signal);
          case 69:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }))()["catch"](function (err) {
      if (err instanceof task_canceller/* CancellationError */.AL) {
        return;
      }
      currentStreamCanceller === null || currentStreamCanceller === void 0 ? void 0 : currentStreamCanceller.cancel();
      callbacks.error(err);
    });
  }, {
    clearSignal: parentCancelSignal,
    emitCurrentValue: true
  });
  /**
   * @param {Object} adaptation
   * @param {Object} segmentBuffer
   * @param {Object} cancelSignal
   */
  function createAdaptationStream(adaptation, segmentBuffer, cancelSignal) {
    var manifest = content.manifest;
    var adaptationPlaybackObserver = createAdaptationStreamPlaybackObserver(playbackObserver, segmentBuffer);
    stream_adaptation({
      content: {
        manifest: manifest,
        period: period,
        adaptation: adaptation
      },
      options: options,
      playbackObserver: adaptationPlaybackObserver,
      representationEstimator: representationEstimator,
      segmentBuffer: segmentBuffer,
      segmentFetcherCreator: segmentFetcherCreator,
      wantedBufferAhead: wantedBufferAhead,
      maxVideoBufferSize: maxVideoBufferSize
    }, Object.assign(Object.assign({}, callbacks), {
      error: onAdaptationStreamError
    }), cancelSignal);
    function onAdaptationStreamError(error) {
      // Stream linked to a non-native media buffer should not impact the
      // stability of the player. ie: if a text buffer sends an error, we want
      // to continue playing without any subtitles
      if (!segment_buffers.isNative(bufferType)) {
        log/* default */.A.error("Stream: " + bufferType + " Stream crashed. Aborting it.", error instanceof Error ? error : "");
        segmentBuffersStore.disposeSegmentBuffer(bufferType);
        var formattedError = (0,format_error/* default */.A)(error, {
          defaultCode: "NONE",
          defaultReason: "Unknown `AdaptationStream` error"
        });
        callbacks.warning(formattedError);
        if (cancelSignal.isCancelled()) {
          return; // Previous callback cancelled the Stream by side-effect
        }
        return createEmptyAdaptationStream(playbackObserver, wantedBufferAhead, bufferType, {
          period: period
        }, callbacks, cancelSignal);
      }
      log/* default */.A.error("Stream: " + bufferType + " Stream crashed. Stopping playback.", error instanceof Error ? error : "");
      callbacks.error(error);
    }
  }
  /**
   * Regularly ask to reload the MediaSource on each playback observation
   * performed by the playback observer.
   *
   * @param {number} timeOffset - Relative position, compared to the current
   * playhead, at which we should restart playback after reloading.
   * For example `-2` will reload 2 seconds before the current position.
   * @param {boolean} stayInPeriod - If `true`, we will control that the position
   * we reload at, after applying `timeOffset`, is still part of the Period
   * `period`.
   *
   * If it isn't we will re-calculate that reloaded position to be:
   *   - either the Period's start if the calculated position is before the
   *     Period's start.
   *   - either the Period'end start if the calculated position is after the
   *     Period's end.
   * @param {Object} cancelSignal
   */
  function askForMediaSourceReload(timeOffset, stayInPeriod, cancelSignal) {
    // We begin by scheduling a micro-task to reduce the possibility of race
    // conditions where `askForMediaSourceReload` would be called synchronously before
    // the next observation (which may reflect very different playback conditions)
    // is actually received.
    // It can happen when `askForMediaSourceReload` is called as a side-effect of
    // the same event that triggers the playback observation to be emitted.
    next_tick_default()(function () {
      playbackObserver.listen(function () {
        callbacks.waitingMediaSourceReload({
          bufferType: bufferType,
          period: period,
          timeOffset: timeOffset,
          stayInPeriod: stayInPeriod
        });
      }, {
        includeLastObservation: true,
        clearSignal: cancelSignal
      });
    });
  }
}
/**
 * @param {string} bufferType
 * @param {Object} adaptation
 * @returns {Object}
 */
function createOrReuseSegmentBuffer(segmentBuffersStore, bufferType, adaptation, options) {
  var segmentBufferStatus = segmentBuffersStore.getStatus(bufferType);
  if (segmentBufferStatus.type === "initialized") {
    log/* default */.A.info("Stream: Reusing a previous SegmentBuffer for the type", bufferType);
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    return segmentBufferStatus.value;
  }
  var codec = getFirstDeclaredMimeType(adaptation);
  var sbOptions = bufferType === "text" ? options.textTrackOptions : undefined;
  // eslint-disable-next-line @typescript-eslint/no-unsafe-return
  return segmentBuffersStore.createSegmentBuffer(bufferType, codec, sbOptions);
}
/**
 * Get mime-type string of the first representation declared in the given
 * adaptation.
 * @param {Adaptation} adaptation
 * @returns {string}
 */
function getFirstDeclaredMimeType(adaptation) {
  var representations = adaptation.getPlayableRepresentations();
  if (representations.length === 0) {
    var noRepErr = new media_error/* default */.A("NO_PLAYABLE_REPRESENTATION", "No Representation in the chosen " + adaptation.type + " Adaptation can be played", {
      adaptation: adaptation
    });
    throw noRepErr;
  }
  return representations[0].getMimeTypeString();
}
/**
 * Create AdaptationStream's version of a playback observer.
 * @param {Object} initialPlaybackObserver
 * @param {Object} segmentBuffer
 * @returns {Object}
 */
function createAdaptationStreamPlaybackObserver(initialPlaybackObserver, segmentBuffer) {
  return initialPlaybackObserver.deriveReadOnlyObserver(function transform(observationRef, cancellationSignal) {
    var newRef = new reference/* default */.A(constructAdaptationStreamPlaybackObservation(), cancellationSignal);
    observationRef.onUpdate(emitAdaptationStreamPlaybackObservation, {
      clearSignal: cancellationSignal,
      emitCurrentValue: false
    });
    return newRef;
    function constructAdaptationStreamPlaybackObservation() {
      var baseObservation = observationRef.getValue();
      var buffered = segmentBuffer.getBufferedRanges();
      var bufferGap = (0,ranges/* getLeftSizeOfRange */.vK)(buffered, baseObservation.position.last);
      return (0,object_assign/* default */.A)({}, baseObservation, {
        bufferGap: bufferGap
      });
    }
    function emitAdaptationStreamPlaybackObservation() {
      newRef.setValue(constructAdaptationStreamPlaybackObservation());
    }
  });
}
/**
 * Create empty AdaptationStream, linked to a Period.
 * This AdaptationStream will never download any segment and just emit a "full"
 * event when reaching the end.
 * @param {Object} playbackObserver
 * @param {Object} wantedBufferAhead
 * @param {string} bufferType
 * @param {Object} content
 * @param {Object} callbacks
 * @param {Object} cancelSignal
 */
function createEmptyAdaptationStream(playbackObserver, wantedBufferAhead, bufferType, content, callbacks, cancelSignal) {
  var period = content.period;
  var hasFinishedLoading = false;
  wantedBufferAhead.onUpdate(sendStatus, {
    emitCurrentValue: false,
    clearSignal: cancelSignal
  });
  playbackObserver.listen(sendStatus, {
    includeLastObservation: false,
    clearSignal: cancelSignal
  });
  sendStatus();
  function sendStatus() {
    var observation = playbackObserver.getReference().getValue();
    var wba = wantedBufferAhead.getValue();
    var position = observation.position.last;
    if (period.end !== undefined && position + wba >= period.end) {
      log/* default */.A.debug('Stream: full "empty" AdaptationStream', bufferType);
      hasFinishedLoading = true;
    }
    callbacks.streamStatusUpdate({
      period: period,
      bufferType: bufferType,
      position: position,
      imminentDiscontinuity: null,
      isEmptyStream: true,
      hasFinishedLoading: hasFinishedLoading,
      neededSegments: []
    });
  }
}
;// CONCATENATED MODULE: ./src/core/stream/period/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/* harmony default export */ var period = (PeriodStream);
;// CONCATENATED MODULE: ./src/core/stream/orchestrator/get_time_ranges_for_content.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns the buffered ranges which hold the given content.
 * Returns the whole buffered ranges if some of it is unknown.
 * @param {Object} segmentBuffer
 * @param {Array.<Object>} contents
 * @returns {Array.<Object>}
 */
function getTimeRangesForContent(segmentBuffer, contents) {
  if (contents.length === 0) {
    return [];
  }
  segmentBuffer.synchronizeInventory();
  var accumulator = [];
  var inventory = segmentBuffer.getInventory();
  var _loop = function _loop() {
      var chunk = inventory[i];
      var hasContent = contents.some(function (content) {
        return chunk.infos.period.id === content.period.id && chunk.infos.adaptation.id === content.adaptation.id && chunk.infos.representation.id === content.representation.id;
      });
      if (hasContent) {
        var bufferedStart = chunk.bufferedStart,
          bufferedEnd = chunk.bufferedEnd;
        if (bufferedStart === undefined || bufferedEnd === undefined) {
          log/* default */.A.warn("SO: No buffered start or end found from a segment.");
          return {
            v: [{
              start: 0,
              end: Number.MAX_VALUE
            }]
          };
        }
        var previousLastElement = accumulator[accumulator.length - 1];
        if (previousLastElement !== undefined && previousLastElement.end === bufferedStart) {
          previousLastElement.end = bufferedEnd;
        } else {
          accumulator.push({
            start: bufferedStart,
            end: bufferedEnd
          });
        }
      }
    },
    _ret;
  for (var i = 0; i < inventory.length; i++) {
    _ret = _loop();
    if (_ret) return _ret.v;
  }
  return accumulator;
}
;// CONCATENATED MODULE: ./src/core/stream/orchestrator/stream_orchestrator.ts


function stream_orchestrator_createForOfIteratorHelperLoose(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (t) return (t = t.call(r)).next.bind(t); if (Array.isArray(r) || (t = stream_orchestrator_unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var o = 0; return function () { return o >= r.length ? { done: !0 } : { done: !1, value: r[o++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function stream_orchestrator_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return stream_orchestrator_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? stream_orchestrator_arrayLikeToArray(r, a) : void 0; } }
function stream_orchestrator_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */











/**
 * Create and manage the various "Streams" needed for the content to
 * play:
 *
 *   - Create or dispose SegmentBuffers depending on the chosen Adaptations.
 *
 *   - Push the right segments to those SegmentBuffers depending on the user's
 *     preferences, the current position, the bandwidth, the decryption
 *     conditions...
 *
 *   - Concatenate Streams for adaptation from separate Periods at the right
 *     time, to allow smooth transitions between periods.
 *
 *   - Call various callbacks to notify of its health and issues
 *
 * @param {Object} content
 * @param {Object} playbackObserver - Emit position information
 * @param {Object} representationEstimator - Emit bitrate estimates and best
 * Representation to play.
 * @param {Object} segmentBuffersStore - Will be used to lazily create
 * SegmentBuffer instances associated with the current content.
 * @param {Object} segmentFetcherCreator - Allow to download segments.
 * @param {Object} options
 * @param {Object} callbacks - The `StreamOrchestrator` relies on a system of
 * callbacks that it will call on various events.
 *
 * Depending on the event, the caller may be supposed to perform actions to
 * react upon some of them.
 *
 * This approach is taken instead of a more classical EventEmitter pattern to:
 *   - Allow callbacks to be called synchronously after the
 *     `StreamOrchestrator` is called.
 *   - Simplify bubbling events up, by just passing through callbacks
 *   - Force the caller to explicitely handle or not the different events.
 *
 * Callbacks may start being called immediately after the `StreamOrchestrator`
 * call and may be called until either the `parentCancelSignal` argument is
 * triggered, or until the `error` callback is called, whichever comes first.
 * @param {Object} orchestratorCancelSignal - `CancellationSignal` allowing,
 * when triggered, to immediately stop all operations the `PeriodStream` is
 * doing.
 */
function StreamOrchestrator(content, playbackObserver, representationEstimator, segmentBuffersStore, segmentFetcherCreator, options, callbacks, orchestratorCancelSignal) {
  var manifest = content.manifest,
    initialPeriod = content.initialPeriod;
  var maxBufferAhead = options.maxBufferAhead,
    maxBufferBehind = options.maxBufferBehind,
    wantedBufferAhead = options.wantedBufferAhead,
    maxVideoBufferSize = options.maxVideoBufferSize;
  var _config$getCurrent = config/* default */.A.getCurrent(),
    MINIMUM_MAX_BUFFER_AHEAD = _config$getCurrent.MINIMUM_MAX_BUFFER_AHEAD,
    MAXIMUM_MAX_BUFFER_AHEAD = _config$getCurrent.MAXIMUM_MAX_BUFFER_AHEAD,
    MAXIMUM_MAX_BUFFER_BEHIND = _config$getCurrent.MAXIMUM_MAX_BUFFER_BEHIND;
  // Keep track of a unique BufferGarbageCollector created per
  // SegmentBuffer.
  var garbageCollectors = new WeakMapMemory(function (segmentBuffer) {
    var _a, _b;
    var bufferType = segmentBuffer.bufferType;
    var defaultMaxBehind = (_a = MAXIMUM_MAX_BUFFER_BEHIND[bufferType]) !== null && _a !== void 0 ? _a : Infinity;
    var maxAheadHigherBound = (_b = MAXIMUM_MAX_BUFFER_AHEAD[bufferType]) !== null && _b !== void 0 ? _b : Infinity;
    return function (gcCancelSignal) {
      BufferGarbageCollector({
        segmentBuffer: segmentBuffer,
        playbackObserver: playbackObserver,
        maxBufferBehind: (0,reference/* createMappedReference */.D)(maxBufferBehind, function (val) {
          return Math.min(val, defaultMaxBehind);
        }, gcCancelSignal),
        maxBufferAhead: (0,reference/* createMappedReference */.D)(maxBufferAhead, function (val) {
          var _a;
          var lowerBound = Math.max(val, (_a = MINIMUM_MAX_BUFFER_AHEAD[bufferType]) !== null && _a !== void 0 ? _a : 0);
          return Math.min(lowerBound, maxAheadHigherBound);
        }, gcCancelSignal)
      }, gcCancelSignal);
    };
  });
  // Create automatically the right `PeriodStream` for every possible types
  for (var _iterator = stream_orchestrator_createForOfIteratorHelperLoose(segmentBuffersStore.getBufferTypes()), _step; !(_step = _iterator()).done;) {
    var bufferType = _step.value;
    manageEveryStreams(bufferType, initialPeriod);
  }
  /**
   * Manage creation and removal of Streams for every Periods for a given type.
   *
   * Works by creating consecutive Streams through the
   * `manageConsecutivePeriodStreams` function, and restarting it when the
   * current position goes out of the bounds of these Streams.
   * @param {string} bufferType - e.g. "audio" or "video"
   * @param {Period} basePeriod - Initial Period downloaded.
   */
  function manageEveryStreams(bufferType, basePeriod) {
    /** Each Period for which there is currently a Stream, chronologically */
    var periodList = new sorted_list/* default */.A(function (a, b) {
      return a.start - b.start;
    });
    /**
     * When set to `true`, all the currently active PeriodStream will be destroyed
     * and re-created from the new current position if we detect it to be out of
     * their bounds.
     * This is set to false when we're in the process of creating the first
     * PeriodStream, to avoid interferences while no PeriodStream is available.
     */
    var enableOutOfBoundsCheck = false;
    /** Cancels currently created `PeriodStream`s. */
    var currentCanceller = new task_canceller/* default */.Ay();
    currentCanceller.linkToSignal(orchestratorCancelSignal);
    // Restart the current Stream when the wanted time is in another period
    // than the ones already considered
    playbackObserver.listen(function (_ref) {
      var position = _ref.position;
      var _a, _b;
      var time = (_a = position.pending) !== null && _a !== void 0 ? _a : position.last;
      if (!enableOutOfBoundsCheck || !isOutOfPeriodList(time)) {
        return;
      }
      log/* default */.A.info("Stream: Destroying all PeriodStreams due to out of bounds situation", bufferType, time);
      enableOutOfBoundsCheck = false;
      while (periodList.length() > 0) {
        var period = periodList.get(periodList.length() - 1);
        periodList.removeElement(period);
        callbacks.periodStreamCleared({
          type: bufferType,
          period: period
        });
      }
      currentCanceller.cancel();
      currentCanceller = new task_canceller/* default */.Ay();
      currentCanceller.linkToSignal(orchestratorCancelSignal);
      var nextPeriod = (_b = manifest.getPeriodForTime(time)) !== null && _b !== void 0 ? _b : manifest.getNextPeriod(time);
      if (nextPeriod === undefined) {
        log/* default */.A.warn("Stream: The wanted position is not found in the Manifest.");
        enableOutOfBoundsCheck = true;
        return;
      }
      launchConsecutiveStreamsForPeriod(nextPeriod);
    }, {
      clearSignal: orchestratorCancelSignal,
      includeLastObservation: true
    });
    manifest.addEventListener("decipherabilityUpdate", function (evt) {
      onDecipherabilityUpdates(evt)["catch"](function (err) {
        currentCanceller.cancel();
        callbacks.error(err);
      });
    }, orchestratorCancelSignal);
    return launchConsecutiveStreamsForPeriod(basePeriod);
    /**
     * @param {Object} period
     */
    function launchConsecutiveStreamsForPeriod(period) {
      var consecutivePeriodStreamCb = Object.assign(Object.assign({}, callbacks), {
        waitingMediaSourceReload: function waitingMediaSourceReload(payload) {
          // Only reload the MediaSource when the more immediately required
          // Period is the one asking for it
          var firstPeriod = periodList.head();
          if (firstPeriod === undefined || firstPeriod.id !== payload.period.id) {
            callbacks.lockedStream({
              bufferType: payload.bufferType,
              period: payload.period
            });
          } else {
            callbacks.needsMediaSourceReload({
              timeOffset: payload.timeOffset,
              minimumPosition: payload.stayInPeriod ? payload.period.start : undefined,
              maximumPosition: payload.stayInPeriod ? payload.period.end : undefined
            });
          }
        },
        periodStreamReady: function periodStreamReady(payload) {
          enableOutOfBoundsCheck = true;
          periodList.add(payload.period);
          callbacks.periodStreamReady(payload);
        },
        periodStreamCleared: function periodStreamCleared(payload) {
          periodList.removeElement(payload.period);
          callbacks.periodStreamCleared(payload);
        },
        error: function error(err) {
          currentCanceller.cancel();
          callbacks.error(err);
        }
      });
      manageConsecutivePeriodStreams(bufferType, period, consecutivePeriodStreamCb, currentCanceller.signal);
    }
    /**
     * Returns true if the given time is either:
     *   - less than the start of the chronologically first Period
     *   - more than the end of the chronologically last Period
     * @param {number} time
     * @returns {boolean}
     */
    function isOutOfPeriodList(time) {
      var head = periodList.head();
      var last = periodList.last();
      if (head == null || last == null) {
        // if no period
        return true;
      }
      return head.start > time || (last.end == null ? Infinity : last.end) < time;
    }
    /**
     * React to a Manifest's decipherability updates.
     * @param {Array.<Object>} updates
     * @returns {Promise}
     */
    function onDecipherabilityUpdates(_x) {
      return _onDecipherabilityUpdates.apply(this, arguments);
    }
    function _onDecipherabilityUpdates() {
      _onDecipherabilityUpdates = (0,asyncToGenerator/* default */.A)( /*#__PURE__*/regenerator_default().mark(function _callee(updates) {
        var segmentBufferStatus, ofCurrentType, segmentBuffer, resettedContent, undecipherableContent, undecipherableRanges, rangesToRemove, period, _i, _arr, _arr$_i, start, end;
        return regenerator_default().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              segmentBufferStatus = segmentBuffersStore.getStatus(bufferType);
              ofCurrentType = updates.filter(function (update) {
                return update.adaptation.type === bufferType;
              });
              if (!(
              // No update concerns the current type of data
              ofCurrentType.length === 0 || segmentBufferStatus.type !== "initialized" ||
              // The update only notifies of now-decipherable streams
              ofCurrentType.every(function (x) {
                return x.representation.decipherable === true;
              }))) {
                _context.next = 4;
                break;
              }
              return _context.abrupt("return");
            case 4:
              segmentBuffer = segmentBufferStatus.value;
              resettedContent = ofCurrentType.filter(function (update) {
                return update.representation.decipherable === undefined;
              });
              undecipherableContent = ofCurrentType.filter(function (update) {
                return update.representation.decipherable === false;
              });
              /**
               * Time ranges now containing undecipherable content.
               * Those should first be removed and, depending on the platform, may
               * need Supplementary actions as playback issues may remain even after
               * removal.
               */
              undecipherableRanges = getTimeRangesForContent(segmentBuffer, undecipherableContent);
              /**
               * Time ranges now containing content whose decipherability status came
               * back to being unknown.
               * To simplify its handling, those are just removed from the buffer.
               * Less considerations have to be taken than for the `undecipherableRanges`.
               */
              rangesToRemove = getTimeRangesForContent(segmentBuffer, resettedContent); // First close all Stream currently active so they don't continue to
              // load and push segments.
              enableOutOfBoundsCheck = false;
              log/* default */.A.info("Stream: Destroying all PeriodStreams for decipherability matters", bufferType);
              while (periodList.length() > 0) {
                period = periodList.get(periodList.length() - 1);
                periodList.removeElement(period);
                callbacks.periodStreamCleared({
                  type: bufferType,
                  period: period
                });
              }
              currentCanceller.cancel();
              currentCanceller = new task_canceller/* default */.Ay();
              currentCanceller.linkToSignal(orchestratorCancelSignal);
              /** Remove from the `SegmentBuffer` all the concerned time ranges. */
              _i = 0, _arr = [].concat(undecipherableRanges, rangesToRemove);
            case 16:
              if (!(_i < _arr.length)) {
                _context.next = 26;
                break;
              }
              _arr$_i = _arr[_i], start = _arr$_i.start, end = _arr$_i.end;
              if (!(start < end)) {
                _context.next = 23;
                break;
              }
              if (!orchestratorCancelSignal.isCancelled()) {
                _context.next = 21;
                break;
              }
              return _context.abrupt("return");
            case 21:
              _context.next = 23;
              return segmentBuffer.removeBuffer(start, end, orchestratorCancelSignal);
            case 23:
              _i++;
              _context.next = 16;
              break;
            case 26:
              // Schedule micro task before checking the last playback observation
              // to reduce the risk of race conditions where the next observation
              // was going to be emitted synchronously.
              next_tick_default()(function () {
                var _a;
                if (orchestratorCancelSignal.isCancelled()) {
                  return;
                }
                var observation = playbackObserver.getReference().getValue();
                if (needsFlushingAfterClean(observation, undecipherableRanges)) {
                  // Bind to Period start and end
                  callbacks.needsDecipherabilityFlush();
                  if (orchestratorCancelSignal.isCancelled()) {
                    return;
                  }
                } else if (needsFlushingAfterClean(observation, rangesToRemove)) {
                  callbacks.needsBufferFlush();
                  if (orchestratorCancelSignal.isCancelled()) {
                    return;
                  }
                }
                var lastPosition = (_a = observation.position.pending) !== null && _a !== void 0 ? _a : observation.position.last;
                var newInitialPeriod = manifest.getPeriodForTime(lastPosition);
                if (newInitialPeriod == null) {
                  callbacks.error(new media_error/* default */.A("MEDIA_TIME_NOT_FOUND", "The wanted position is not found in the Manifest."));
                  return;
                }
                launchConsecutiveStreamsForPeriod(newInitialPeriod);
              });
            case 27:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));
      return _onDecipherabilityUpdates.apply(this, arguments);
    }
  }
  /**
   * Create lazily consecutive PeriodStreams:
   *
   * It first creates the `PeriodStream` for `basePeriod` and - once it becomes
   * full - automatically creates the next chronological one.
   * This process repeats until the `PeriodStream` linked to the last Period is
   * full.
   *
   * If an "old" `PeriodStream` becomes active again, it destroys all
   * `PeriodStream` coming after it (from the last chronological one to the
   * first).
   *
   * To clean-up PeriodStreams, each one of them are also automatically
   * destroyed once the current position is superior or equal to the end of
   * the concerned Period.
   *
   * The "periodStreamReady" callback is alled each times a new `PeriodStream`
   * is created.
   *
   * The "periodStreamCleared" callback is called each times a PeriodStream is
   * destroyed (this callback is though not called if it was destroyed due to
   * the given `cancelSignal` emitting or due to a fatal error).
   * @param {string} bufferType - e.g. "audio" or "video"
   * @param {Period} basePeriod - Initial Period downloaded.
   * @param {Object} consecutivePeriodStreamCb - Callbacks called on various
   * events. See type for more information.
   * @param {Object} cancelSignal - `CancellationSignal` allowing to stop
   * everything that this function was doing. Callbacks in
   * `consecutivePeriodStreamCb` might still be sent as a consequence of this
   * signal emitting.
   */
  function manageConsecutivePeriodStreams(bufferType, basePeriod, consecutivePeriodStreamCb, cancelSignal) {
    log/* default */.A.info("Stream: Creating new Stream for", bufferType, basePeriod.start);
    /**
     * Contains properties linnked to the next chronological `PeriodStream` that
     * may be created here.
     */
    var nextStreamInfo = null;
    /** Emits when the `PeriodStream` linked to `basePeriod` should be destroyed. */
    var currentStreamCanceller = new task_canceller/* default */.Ay();
    currentStreamCanceller.linkToSignal(cancelSignal);
    // Stop current PeriodStream when the current position goes over the end of
    // that Period.
    playbackObserver.listen(function (_ref2, stopListeningObservations) {
      var position = _ref2.position;
      var _a, _b;
      var wantedPosition = (_a = position.pending) !== null && _a !== void 0 ? _a : position.last;
      if (basePeriod.end !== undefined && wantedPosition >= basePeriod.end) {
        var nextPeriod = manifest.getPeriodAfter(basePeriod);
        // Handle special wantedPosition === basePeriod.end cases
        if (basePeriod.containsTime(wantedPosition, nextPeriod)) {
          return;
        }
        log/* default */.A.info("Stream: Destroying PeriodStream as the current playhead moved above it", bufferType, basePeriod.start, (_b = position.pending) !== null && _b !== void 0 ? _b : position.last, basePeriod.end);
        stopListeningObservations();
        consecutivePeriodStreamCb.periodStreamCleared({
          type: bufferType,
          period: basePeriod
        });
        currentStreamCanceller.cancel();
      }
    }, {
      clearSignal: cancelSignal,
      includeLastObservation: true
    });
    var periodStreamArgs = {
      bufferType: bufferType,
      content: {
        manifest: manifest,
        period: basePeriod
      },
      garbageCollectors: garbageCollectors,
      maxVideoBufferSize: maxVideoBufferSize,
      segmentFetcherCreator: segmentFetcherCreator,
      segmentBuffersStore: segmentBuffersStore,
      options: options,
      playbackObserver: playbackObserver,
      representationEstimator: representationEstimator,
      wantedBufferAhead: wantedBufferAhead
    };
    var periodStreamCallbacks = Object.assign(Object.assign({}, consecutivePeriodStreamCb), {
      streamStatusUpdate: function streamStatusUpdate(value) {
        if (value.hasFinishedLoading) {
          var nextPeriod = manifest.getPeriodAfter(basePeriod);
          if (nextPeriod !== null) {
            // current Stream is full, create the next one if not
            checkOrCreateNextPeriodStream(nextPeriod);
          }
        } else if (nextStreamInfo !== null) {
          // current Stream is active, destroy next Stream if created
          log/* default */.A.info("Stream: Destroying next PeriodStream due to current one being active", bufferType, nextStreamInfo.period.start);
          consecutivePeriodStreamCb.periodStreamCleared({
            type: bufferType,
            period: nextStreamInfo.period
          });
          nextStreamInfo.canceller.cancel();
          nextStreamInfo = null;
        }
        consecutivePeriodStreamCb.streamStatusUpdate(value);
      },
      error: function error(err) {
        if (nextStreamInfo !== null) {
          nextStreamInfo.canceller.cancel();
          nextStreamInfo = null;
        }
        currentStreamCanceller.cancel();
        consecutivePeriodStreamCb.error(err);
      }
    });
    period(periodStreamArgs, periodStreamCallbacks, currentStreamCanceller.signal);
    /**
     * Create `PeriodStream` for the next Period, specified under `nextPeriod`.
     * @param {Object} nextPeriod
     */
    function checkOrCreateNextPeriodStream(nextPeriod) {
      if (nextStreamInfo !== null) {
        if (nextStreamInfo.period.id === nextPeriod.id) {
          return;
        }
        log/* default */.A.warn("Stream: Creating next `PeriodStream` while one was already created.", bufferType, nextPeriod.id, nextStreamInfo.period.id);
        consecutivePeriodStreamCb.periodStreamCleared({
          type: bufferType,
          period: nextStreamInfo.period
        });
        nextStreamInfo.canceller.cancel();
      }
      var nextStreamCanceller = new task_canceller/* default */.Ay();
      nextStreamCanceller.linkToSignal(cancelSignal);
      nextStreamInfo = {
        canceller: nextStreamCanceller,
        period: nextPeriod
      };
      manageConsecutivePeriodStreams(bufferType, nextPeriod, consecutivePeriodStreamCb, nextStreamInfo.canceller.signal);
    }
  }
}
/**
 * Returns `true` if low-level buffers have to be "flushed" after the given
 * `cleanedRanges` time ranges have been removed from an audio or video
 * SourceBuffer, to prevent playback issues.
 * @param {Object} observation
 * @param {Array.<Object>} cleanedRanges
 * @returns {boolean}
 */
function needsFlushingAfterClean(observation, cleanedRanges) {
  if (cleanedRanges.length === 0) {
    return false;
  }
  var curPos = observation.position.last;
  // Based on the playback direction, we just check whether we may encounter
  // the corresponding ranges, without seeking or re-switching playback
  // direction which is expected to lead to a low-level flush anyway.
  // There's a 5 seconds security, just to be sure.
  return observation.speed >= 0 ? cleanedRanges[cleanedRanges.length - 1].end >= curPos - 5 : cleanedRanges[0].start <= curPos + 5;
}
;// CONCATENATED MODULE: ./src/core/stream/orchestrator/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ var orchestrator = (StreamOrchestrator);
;// CONCATENATED MODULE: ./src/core/stream/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ var stream = (orchestrator);
// EXTERNAL MODULE: ./src/core/init/types.ts
var init_types = __webpack_require__(4640);
;// CONCATENATED MODULE: ./src/core/init/utils/content_time_boundaries_observer.ts

function content_time_boundaries_observer_createForOfIteratorHelperLoose(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (t) return (t = t.call(r)).next.bind(t); if (Array.isArray(r) || (t = content_time_boundaries_observer_unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var o = 0; return function () { return o >= r.length ? { done: !0 } : { done: !1, value: r[o++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function content_time_boundaries_observer_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return content_time_boundaries_observer_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? content_time_boundaries_observer_arrayLikeToArray(r, a) : void 0; } }
function content_time_boundaries_observer_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * Observes what's being played and take care of media events relating to time
 * boundaries:
 *   - Emits a `endingPositionChange` when the known maximum playable position
 *     of the current content is known and every time it changes.
 *   - Emits `endOfStream` API once segments have been pushed until the end and
 *     `resumeStream` if downloads starts back.
 *   - Emits a `periodChange` event when the currently-playing Period seemed to
 *     have changed.
 *   - emit "warning" events when what is being played is outside of the
 *     Manifest range.
 * @class ContentTimeBoundariesObserver
 */
var ContentTimeBoundariesObserver = /*#__PURE__*/function (_EventEmitter) {
  /**
   * @param {Object} manifest
   * @param {Object} playbackObserver
   */
  function ContentTimeBoundariesObserver(manifest, playbackObserver, bufferTypes) {
    var _this;
    _this = _EventEmitter.call(this) || this;
    _this._canceller = new task_canceller/* default */.Ay();
    _this._manifest = manifest;
    _this._activeStreams = new Map();
    _this._allBufferTypes = bufferTypes;
    _this._lastCurrentPeriodId = null;
    /**
     * Allows to calculate the minimum and maximum playable position on the
     * whole content.
     */
    var maximumPositionCalculator = new MaximumPositionCalculator(manifest);
    _this._maximumPositionCalculator = maximumPositionCalculator;
    var cancelSignal = _this._canceller.signal;
    playbackObserver.listen(function (_ref) {
      var position = _ref.position;
      var _a;
      var wantedPosition = (_a = position.pending) !== null && _a !== void 0 ? _a : position.last;
      if (wantedPosition < manifest.getMinimumSafePosition()) {
        var warning = new media_error/* default */.A("MEDIA_TIME_BEFORE_MANIFEST", "The current position is behind the " + "earliest time announced in the Manifest.");
        _this.trigger("warning", warning);
      } else if (wantedPosition > maximumPositionCalculator.getMaximumAvailablePosition()) {
        var _warning = new media_error/* default */.A("MEDIA_TIME_AFTER_MANIFEST", "The current position is after the latest " + "time announced in the Manifest.");
        _this.trigger("warning", _warning);
      }
    }, {
      includeLastObservation: true,
      clearSignal: cancelSignal
    });
    manifest.addEventListener("manifestUpdate", function () {
      _this.trigger("endingPositionChange", _this._getManifestEndTime());
      if (cancelSignal.isCancelled()) {
        return;
      }
      _this._checkEndOfStream();
    }, cancelSignal);
    return _this;
  }
  /**
   * Returns an estimate of the current last position which may be played in
   * the content at the moment.
   * @returns {Object}
   */
  (0,inheritsLoose/* default */.A)(ContentTimeBoundariesObserver, _EventEmitter);
  var _proto = ContentTimeBoundariesObserver.prototype;
  _proto.getCurrentEndingTime = function getCurrentEndingTime() {
    return this._getManifestEndTime();
  }
  /**
   * Method to call any time an Adaptation has been selected.
   *
   * That Adaptation switch will be considered as active until the
   * `onPeriodCleared` method has been called for the same `bufferType` and
   * `Period`, or until `dispose` is called.
   * @param {string} bufferType - The type of buffer concerned by the Adaptation
   * switch
   * @param {Object} period - The Period concerned by the Adaptation switch
   * @param {Object|null} adaptation - The Adaptation selected. `null` if the
   * absence of `Adaptation` has been explicitely selected for this Period and
   * buffer type (e.g. no video).
   */;
  _proto.onAdaptationChange = function onAdaptationChange(bufferType, period, adaptation) {
    if (this._manifest.isLastPeriodKnown) {
      var lastPeriod = this._manifest.periods[this._manifest.periods.length - 1];
      if (period.id === (lastPeriod === null || lastPeriod === void 0 ? void 0 : lastPeriod.id)) {
        if (bufferType === "audio" || bufferType === "video") {
          if (bufferType === "audio") {
            this._maximumPositionCalculator.updateLastAudioAdaptation(adaptation);
          } else {
            this._maximumPositionCalculator.updateLastVideoAdaptation(adaptation);
          }
          var endingPosition = this._maximumPositionCalculator.getEndingPosition();
          var newEndingPosition = endingPosition !== undefined ? {
            isEnd: true,
            endingPosition: endingPosition
          } : {
            isEnd: false,
            endingPosition: this._maximumPositionCalculator.getMaximumAvailablePosition()
          };
          this.trigger("endingPositionChange", newEndingPosition);
        }
      }
    }
    if (this._canceller.isUsed()) {
      return;
    }
    if (adaptation === null) {
      this._addActivelyLoadedPeriod(period, bufferType);
    }
  }
  /**
   * Method to call any time a Representation has been selected.
   *
   * That Representation switch will be considered as active until the
   * `onPeriodCleared` method has been called for the same `bufferType` and
   * `Period`, or until `dispose` is called.
   * @param {string} bufferType - The type of buffer concerned by the
   * Representation switch
   * @param {Object} period - The Period concerned by the Representation switch
   */;
  _proto.onRepresentationChange = function onRepresentationChange(bufferType, period) {
    this._addActivelyLoadedPeriod(period, bufferType);
  }
  /**
   * Method to call any time a Period and type combination is not considered
   * anymore.
   *
   * Calling this method allows to signal that a previous Adaptation and/or
   * Representation change respectively indicated by an `onAdaptationChange` and
   * an `onRepresentationChange` call, are not active anymore.
   * @param {string} bufferType - The type of buffer concerned
   * @param {Object} period - The Period concerned
   */;
  _proto.onPeriodCleared = function onPeriodCleared(bufferType, period) {
    this._removeActivelyLoadedPeriod(period, bufferType);
  }
  /**
   * Method to call when the last chronological segment for a given buffer type
   * is known to have been loaded and is either pushed or in the process of
   * being pushed to the corresponding MSE `SourceBuffer` or equivalent.
   *
   * This method can even be called multiple times in a row as long as the
   * aforementioned condition is true, if it simplify your code's management.
   * @param {string} bufferType
   */;
  _proto.onLastSegmentFinishedLoading = function onLastSegmentFinishedLoading(bufferType) {
    var streamInfo = this._lazilyCreateActiveStreamInfo(bufferType);
    if (!streamInfo.hasFinishedLoadingLastPeriod) {
      streamInfo.hasFinishedLoadingLastPeriod = true;
      this._checkEndOfStream();
    }
  }
  /**
   * Method to call to "cancel" a previous call to
   * `onLastSegmentFinishedLoading`.
   *
   * That is, calling this method indicates that the last chronological segment
   * of a given buffer type is now either not loaded or it is not known.
   *
   * This method can even be called multiple times in a row as long as the
   * aforementioned condition is true, if it simplify your code's management.
   * @param {string} bufferType
   */;
  _proto.onLastSegmentLoadingResume = function onLastSegmentLoadingResume(bufferType) {
    var streamInfo = this._lazilyCreateActiveStreamInfo(bufferType);
    if (streamInfo.hasFinishedLoadingLastPeriod) {
      streamInfo.hasFinishedLoadingLastPeriod = false;
      this._checkEndOfStream();
    }
  }
  /**
   * Free all resources used by the `ContentTimeBoundariesObserver` and cancels
   * all recurring processes it performs.
   */;
  _proto.dispose = function dispose() {
    this.removeEventListener();
    this._canceller.cancel();
  };
  _proto._addActivelyLoadedPeriod = function _addActivelyLoadedPeriod(period, bufferType) {
    var streamInfo = this._lazilyCreateActiveStreamInfo(bufferType);
    if (!streamInfo.activePeriods.has(period)) {
      streamInfo.activePeriods.add(period);
      this._checkCurrentPeriod();
    }
  };
  _proto._removeActivelyLoadedPeriod = function _removeActivelyLoadedPeriod(period, bufferType) {
    var streamInfo = this._activeStreams.get(bufferType);
    if (streamInfo === undefined) {
      return;
    }
    if (streamInfo.activePeriods.has(period)) {
      streamInfo.activePeriods.removeElement(period);
      this._checkCurrentPeriod();
    }
  };
  _proto._checkCurrentPeriod = function _checkCurrentPeriod() {
    var _this2 = this;
    if (this._allBufferTypes.length === 0) {
      return;
    }
    var streamInfo = this._activeStreams.get(this._allBufferTypes[0]);
    if (streamInfo === undefined) {
      return;
    }
    var _loop = function _loop() {
        var period = _step.value;
        var wasFoundInAllTypes = true;
        for (var i = 1; i < _this2._allBufferTypes.length; i++) {
          var streamInfo2 = _this2._activeStreams.get(_this2._allBufferTypes[i]);
          if (streamInfo2 === undefined) {
            return {
              v: void 0
            };
          }
          var activePeriods = streamInfo2.activePeriods.toArray();
          var hasPeriod = activePeriods.some(function (p) {
            return p.id === period.id;
          });
          if (!hasPeriod) {
            wasFoundInAllTypes = false;
            break;
          }
        }
        if (wasFoundInAllTypes) {
          if (_this2._lastCurrentPeriodId !== period.id) {
            _this2._lastCurrentPeriodId = period.id;
            _this2.trigger("periodChange", period);
          }
          return {
            v: void 0
          };
        }
      },
      _ret;
    for (var _iterator = content_time_boundaries_observer_createForOfIteratorHelperLoose(streamInfo.activePeriods.toArray()), _step; !(_step = _iterator()).done;) {
      _ret = _loop();
      if (_ret) return _ret.v;
    }
  };
  _proto._getManifestEndTime = function _getManifestEndTime() {
    var endingPosition = this._maximumPositionCalculator.getEndingPosition();
    return endingPosition !== undefined ? {
      isEnd: true,
      endingPosition: endingPosition
    } : {
      isEnd: false,
      endingPosition: this._maximumPositionCalculator.getMaximumAvailablePosition()
    };
  };
  _proto._lazilyCreateActiveStreamInfo = function _lazilyCreateActiveStreamInfo(bufferType) {
    var streamInfo = this._activeStreams.get(bufferType);
    if (streamInfo === undefined) {
      streamInfo = {
        activePeriods: new sorted_list/* default */.A(function (a, b) {
          return a.start - b.start;
        }),
        hasFinishedLoadingLastPeriod: false
      };
      this._activeStreams.set(bufferType, streamInfo);
    }
    return streamInfo;
  };
  _proto._checkEndOfStream = function _checkEndOfStream() {
    var _this3 = this;
    if (!this._manifest.isLastPeriodKnown) {
      return;
    }
    var everyBufferTypeLoaded = this._allBufferTypes.every(function (bt) {
      var streamInfo = _this3._activeStreams.get(bt);
      return streamInfo !== undefined && streamInfo.hasFinishedLoadingLastPeriod;
    });
    if (everyBufferTypeLoaded) {
      this.trigger("endOfStream", null);
    } else {
      this.trigger("resumeStream", null);
    }
  };
  return ContentTimeBoundariesObserver;
}(event_emitter/* default */.A);
/**
 * Calculate the last position from the last chosen audio and video Adaptations
 * for the last Period (or a default one, if no Adaptations has been chosen).
 * @class MaximumPositionCalculator
 */

var MaximumPositionCalculator = /*#__PURE__*/function () {
  /**
   * @param {Object} manifest
   */
  function MaximumPositionCalculator(manifest) {
    this._manifest = manifest;
    this._lastAudioAdaptation = undefined;
    this._lastVideoAdaptation = undefined;
  }
  /**
   * Update the last known audio Adaptation for the last Period.
   * If no Adaptation has been set, it should be set to `null`.
   *
   * Allows to calculate the maximum position more precizely in
   * `getMaximumAvailablePosition` and `getEndingPosition`.
   * @param {Object|null} adaptation
   */
  var _proto2 = MaximumPositionCalculator.prototype;
  _proto2.updateLastAudioAdaptation = function updateLastAudioAdaptation(adaptation) {
    this._lastAudioAdaptation = adaptation;
  }
  /**
   * Update the last known video Adaptation for the last Period.
   * If no Adaptation has been set, it should be set to `null`.
   *
   * Allows to calculate the maximum position more precizely in
   * `getMaximumAvailablePosition` and `getEndingPosition`.
   * @param {Object|null} adaptation
   */;
  _proto2.updateLastVideoAdaptation = function updateLastVideoAdaptation(adaptation) {
    this._lastVideoAdaptation = adaptation;
  }
  /**
   * Returns an estimate of the maximum position currently reachable (i.e.
   * segments are available) under the current circumstances.
   * @returns {number}
   */;
  _proto2.getMaximumAvailablePosition = function getMaximumAvailablePosition() {
    if (this._manifest.isDynamic) {
      return this._manifest.getMaximumSafePosition();
    }
    if (this._lastVideoAdaptation === undefined || this._lastAudioAdaptation === undefined) {
      return this._manifest.getMaximumSafePosition();
    } else if (this._lastAudioAdaptation === null) {
      if (this._lastVideoAdaptation === null) {
        return this._manifest.getMaximumSafePosition();
      } else {
        var lastVideoPosition = getLastAvailablePositionFromAdaptation(this._lastVideoAdaptation);
        if (typeof lastVideoPosition !== "number") {
          return this._manifest.getMaximumSafePosition();
        }
        return lastVideoPosition;
      }
    } else if (this._lastVideoAdaptation === null) {
      var lastAudioPosition = getLastAvailablePositionFromAdaptation(this._lastAudioAdaptation);
      if (typeof lastAudioPosition !== "number") {
        return this._manifest.getMaximumSafePosition();
      }
      return lastAudioPosition;
    } else {
      var _lastAudioPosition = getLastAvailablePositionFromAdaptation(this._lastAudioAdaptation);
      var _lastVideoPosition = getLastAvailablePositionFromAdaptation(this._lastVideoAdaptation);
      if (typeof _lastAudioPosition !== "number" || typeof _lastVideoPosition !== "number") {
        return this._manifest.getMaximumSafePosition();
      } else {
        return Math.min(_lastAudioPosition, _lastVideoPosition);
      }
    }
  }
  /**
   * Returns an estimate of the actual ending position once
   * the full content is available.
   * Returns `undefined` if that could not be determined, for various reasons.
   * @returns {number|undefined}
   */;
  _proto2.getEndingPosition = function getEndingPosition() {
    var _a, _b;
    if (!this._manifest.isDynamic) {
      return this.getMaximumAvailablePosition();
    }
    if (this._lastVideoAdaptation === undefined || this._lastAudioAdaptation === undefined) {
      return undefined;
    } else if (this._lastAudioAdaptation === null) {
      if (this._lastVideoAdaptation === null) {
        return undefined;
      } else {
        return (_a = getEndingPositionFromAdaptation(this._lastVideoAdaptation)) !== null && _a !== void 0 ? _a : undefined;
      }
    } else if (this._lastVideoAdaptation === null) {
      return (_b = getEndingPositionFromAdaptation(this._lastAudioAdaptation)) !== null && _b !== void 0 ? _b : undefined;
    } else {
      var lastAudioPosition = getEndingPositionFromAdaptation(this._lastAudioAdaptation);
      var lastVideoPosition = getEndingPositionFromAdaptation(this._lastVideoAdaptation);
      if (typeof lastAudioPosition !== "number" || typeof lastVideoPosition !== "number") {
        return undefined;
      } else {
        return Math.min(lastAudioPosition, lastVideoPosition);
      }
    }
  };
  return MaximumPositionCalculator;
}();
/**
 * Returns last currently available position from the Adaptation given.
 * `undefined` if a time could not be found.
 * `null` if the Adaptation has no segments (it could be that it didn't started or
 * that it already finished for example).
 *
 * We consider the earliest last available position from every Representation
 * in the given Adaptation.
 * @param {Object} adaptation
 * @returns {Number|undefined|null}
 */
function getLastAvailablePositionFromAdaptation(adaptation) {
  var representations = adaptation.representations;
  var min = null;
  /**
   * Some Manifest parsers use the exact same `IRepresentationIndex` reference
   * for each Representation of a given Adaptation, because in the actual source
   * Manifest file, indexing data is often defined at Adaptation-level.
   * This variable allows to optimize the logic here when this is the case.
   */
  var lastIndex;
  for (var i = 0; i < representations.length; i++) {
    if (representations[i].index !== lastIndex) {
      lastIndex = representations[i].index;
      var lastPosition = representations[i].index.getLastAvailablePosition();
      if (lastPosition === undefined) {
        // we cannot tell
        return undefined;
      }
      if (lastPosition !== null) {
        min = (0,is_null_or_undefined/* default */.A)(min) ? lastPosition : Math.min(min, lastPosition);
      }
    }
  }
  return min;
}
/**
 * Returns ending time from the Adaptation given, once all its segments are
 * available.
 * `undefined` if a time could not be found.
 * `null` if the Adaptation has no segments (it could be that it already
 * finished for example).
 *
 * We consider the earliest ending time from every Representation in the given
 * Adaptation.
 * @param {Object} adaptation
 * @returns {Number|undefined|null}
 */
function getEndingPositionFromAdaptation(adaptation) {
  var representations = adaptation.representations;
  var min = null;
  /**
   * Some Manifest parsers use the exact same `IRepresentationIndex` reference
   * for each Representation of a given Adaptation, because in the actual source
   * Manifest file, indexing data is often defined at Adaptation-level.
   * This variable allows to optimize the logic here when this is the case.
   */
  var lastIndex;
  for (var i = 0; i < representations.length; i++) {
    if (representations[i].index !== lastIndex) {
      lastIndex = representations[i].index;
      var lastPosition = representations[i].index.getEnd();
      if (lastPosition === undefined) {
        // we cannot tell
        return undefined;
      }
      if (lastPosition !== null) {
        min = (0,is_null_or_undefined/* default */.A)(min) ? lastPosition : Math.min(min, lastPosition);
      }
    }
  }
  return min;
}
// EXTERNAL MODULE: ./src/compat/clear_element_src.ts
var clear_element_src = __webpack_require__(3116);
// EXTERNAL MODULE: ./src/compat/browser_compatibility_types.ts
var browser_compatibility_types = __webpack_require__(9770);
// EXTERNAL MODULE: ./src/compat/event_listeners.ts
var event_listeners = __webpack_require__(5121);
// EXTERNAL MODULE: ./src/utils/is_non_empty_string.ts
var is_non_empty_string = __webpack_require__(2384);
;// CONCATENATED MODULE: ./src/core/init/utils/create_media_source.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * Dispose of ressources taken by the MediaSource:
 *   - Clear the MediaSource' SourceBuffers
 *   - Clear the mediaElement's src (stop the mediaElement)
 *   - Revoke MediaSource' URL
 * @param {HTMLMediaElement} mediaElement
 * @param {MediaSource|null} mediaSource
 * @param {string|null} mediaSourceURL
 */
function resetMediaSource(mediaElement, mediaSource, mediaSourceURL) {
  if (mediaSource !== null && mediaSource.readyState !== "closed") {
    var readyState = mediaSource.readyState,
      sourceBuffers = mediaSource.sourceBuffers;
    for (var i = sourceBuffers.length - 1; i >= 0; i--) {
      var sourceBuffer = sourceBuffers[i];
      try {
        if (readyState === "open") {
          log/* default */.A.info("Init: Aborting SourceBuffer before removing");
          sourceBuffer.abort();
        }
        log/* default */.A.info("Init: Removing SourceBuffer from mediaSource");
        mediaSource.removeSourceBuffer(sourceBuffer);
      } catch (e) {
        log/* default */.A.warn("Init: Error while disposing SourceBuffer", e instanceof Error ? e : "");
      }
    }
    if (sourceBuffers.length > 0) {
      log/* default */.A.warn("Init: Not all SourceBuffers could have been removed.");
    }
  }
  log/* default */.A.info("Init: Clearing HTMLMediaElement's src");
  (0,clear_element_src/* default */.A)(mediaElement);
  if (mediaSourceURL !== null) {
    try {
      log/* default */.A.debug("Init: Revoking previous URL");
      URL.revokeObjectURL(mediaSourceURL);
    } catch (e) {
      log/* default */.A.warn("Init: Error while revoking the media source URL", e instanceof Error ? e : "");
    }
  }
}
/**
 * Create a MediaSource instance and attach it to the given mediaElement element's
 * src attribute.
 *
 * Returns a Promise which resolves with the MediaSource when created and attached
 * to the `mediaElement` element.
 *
 * When the given `unlinkSignal` emits, mediaElement.src is cleaned, MediaSource
 * SourceBuffers are aborted and some minor cleaning is done.
 * @param {HTMLMediaElement} mediaElement
 * @param {Object} unlinkSignal
 * @returns {MediaSource}
 */
function createMediaSource(mediaElement, unlinkSignal) {
  if (browser_compatibility_types/* MediaSource_ */.j == null) {
    throw new media_error/* default */.A("MEDIA_SOURCE_NOT_SUPPORTED", "No MediaSource Object was found in the current browser.");
  }
  // make sure the media has been correctly reset
  var oldSrc = (0,is_non_empty_string/* default */.A)(mediaElement.src) ? mediaElement.src : null;
  resetMediaSource(mediaElement, null, oldSrc);
  log/* default */.A.info("Init: Creating MediaSource");
  var mediaSource = new browser_compatibility_types/* MediaSource_ */.j();
  var objectURL = URL.createObjectURL(mediaSource);
  log/* default */.A.info("Init: Attaching MediaSource URL to the media element", objectURL);
  mediaElement.src = objectURL;
  unlinkSignal.register(function () {
    resetMediaSource(mediaElement, mediaSource, objectURL);
  });
  return mediaSource;
}
/**
 * Create and open a new MediaSource object on the given media element.
 * Resolves with the MediaSource when done.
 *
 * When the given `unlinkSignal` emits, mediaElement.src is cleaned, MediaSource
 * SourceBuffers are aborted and some minor cleaning is done.
 * @param {HTMLMediaElement} mediaElement
 * @param {Object} unlinkSignal
 * @returns {Promise}
 */
function openMediaSource(mediaElement, unlinkSignal) {
  return (0,create_cancellable_promise/* default */.A)(unlinkSignal, function (resolve) {
    var mediaSource = createMediaSource(mediaElement, unlinkSignal);
    event_listeners/* onSourceOpen */.bF(mediaSource, function () {
      log/* default */.A.info("Init: MediaSource opened");
      resolve(mediaSource);
    }, unlinkSignal);
  });
}
;// CONCATENATED MODULE: ./src/core/init/utils/create_stream_playback_observer.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Create PlaybackObserver for the `Stream` part of the code.
 * @param {Object} srcPlaybackObserver - Base `PlaybackObserver` from which we
 * will derive information.
 * @param {Object} context - Various information linked to the current content
 * being played.
 * @param {Object} fnCancelSignal - Abort the created PlaybackObserver.
 * @returns {Object}
 */
function createStreamPlaybackObserver(srcPlaybackObserver, _ref, fnCancelSignal) {
  var autoPlay = _ref.autoPlay,
    initialPlayPerformed = _ref.initialPlayPerformed,
    initialSeekPerformed = _ref.initialSeekPerformed,
    manifest = _ref.manifest,
    speed = _ref.speed,
    startTime = _ref.startTime;
  return srcPlaybackObserver.deriveReadOnlyObserver(function transform(observationRef, parentObserverCancelSignal) {
    var canceller = new task_canceller/* default */.Ay();
    canceller.linkToSignal(parentObserverCancelSignal);
    canceller.linkToSignal(fnCancelSignal);
    var newRef = new reference/* default */.A(constructStreamPlaybackObservation(), canceller.signal);
    speed.onUpdate(emitStreamPlaybackObservation, {
      clearSignal: canceller.signal,
      emitCurrentValue: false
    });
    observationRef.onUpdate(emitStreamPlaybackObservation, {
      clearSignal: canceller.signal,
      emitCurrentValue: false
    });
    return newRef;
    function constructStreamPlaybackObservation() {
      var observation = observationRef.getValue();
      var lastSpeed = speed.getValue();
      var pendingPosition;
      if (!initialSeekPerformed.getValue()) {
        pendingPosition = startTime;
      } else if (!manifest.isDynamic || manifest.isLastPeriodKnown) {
        // HACK: When the position is actually further than the maximum
        // position for a finished content, we actually want to be loading
        // the last segment before ending.
        // For now, this behavior is implicitely forced by making as if we
        // want to seek one second before the period's end (despite never
        // doing it).
        var lastPeriod = manifest.periods[manifest.periods.length - 1];
        if (lastPeriod !== undefined && lastPeriod.end !== undefined && observation.position > lastPeriod.end) {
          pendingPosition = lastPeriod.end - 1;
        }
      }
      return {
        // TODO more exact according to the current Adaptation chosen?
        maximumPosition: manifest.getMaximumSafePosition(),
        position: {
          last: observation.position,
          pending: pendingPosition
        },
        duration: observation.duration,
        paused: {
          last: observation.paused,
          pending: initialPlayPerformed.getValue() ? undefined : !autoPlay === observation.paused ? undefined : !autoPlay
        },
        readyState: observation.readyState,
        speed: lastSpeed
      };
    }
    function emitStreamPlaybackObservation() {
      newRef.setValue(constructStreamPlaybackObservation());
    }
  });
}
;// CONCATENATED MODULE: ./src/core/init/utils/end_of_stream.ts
function end_of_stream_createForOfIteratorHelperLoose(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (t) return (t = t.call(r)).next.bind(t); if (Array.isArray(r) || (t = end_of_stream_unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var o = 0; return function () { return o >= r.length ? { done: !0 } : { done: !1, value: r[o++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function end_of_stream_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return end_of_stream_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? end_of_stream_arrayLikeToArray(r, a) : void 0; } }
function end_of_stream_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



var onRemoveSourceBuffers = event_listeners/* onRemoveSourceBuffers */.yS,
  onSourceOpen = event_listeners/* onSourceOpen */.bF,
  onSourceBufferUpdate = event_listeners/* onSourceBufferUpdate */.G1;
/**
 * Get "updating" SourceBuffers from a SourceBufferList.
 * @param {SourceBufferList} sourceBuffers
 * @returns {Array.<SourceBuffer>}
 */
function getUpdatingSourceBuffers(sourceBuffers) {
  var updatingSourceBuffers = [];
  for (var i = 0; i < sourceBuffers.length; i++) {
    var SourceBuffer = sourceBuffers[i];
    if (SourceBuffer.updating) {
      updatingSourceBuffers.push(SourceBuffer);
    }
  }
  return updatingSourceBuffers;
}
/**
 * Trigger the `endOfStream` method of a MediaSource.
 *
 * If the MediaSource is ended/closed, do not call this method.
 * If SourceBuffers are updating, wait for them to be updated before closing
 * it.
 * @param {MediaSource} mediaSource
 * @param {Object} cancelSignal
 */
function triggerEndOfStream(mediaSource, cancelSignal) {
  log/* default */.A.debug("Init: Trying to call endOfStream");
  if (mediaSource.readyState !== "open") {
    log/* default */.A.debug("Init: MediaSource not open, cancel endOfStream");
    return;
  }
  var sourceBuffers = mediaSource.sourceBuffers;
  var updatingSourceBuffers = getUpdatingSourceBuffers(sourceBuffers);
  if (updatingSourceBuffers.length === 0) {
    log/* default */.A.info("Init: Triggering end of stream");
    mediaSource.endOfStream();
    return;
  }
  log/* default */.A.debug("Init: Waiting SourceBuffers to be updated before calling endOfStream.");
  var innerCanceller = new task_canceller/* default */.Ay();
  innerCanceller.linkToSignal(cancelSignal);
  for (var _iterator = end_of_stream_createForOfIteratorHelperLoose(updatingSourceBuffers), _step; !(_step = _iterator()).done;) {
    var sourceBuffer = _step.value;
    onSourceBufferUpdate(sourceBuffer, function () {
      innerCanceller.cancel();
      triggerEndOfStream(mediaSource, cancelSignal);
    }, innerCanceller.signal);
  }
  onRemoveSourceBuffers(sourceBuffers, function () {
    innerCanceller.cancel();
    triggerEndOfStream(mediaSource, cancelSignal);
  }, innerCanceller.signal);
}
/**
 * Trigger the `endOfStream` method of a MediaSource each times it opens.
 * @see triggerEndOfStream
 * @param {MediaSource} mediaSource
 * @param {Object} cancelSignal
 */
function maintainEndOfStream(mediaSource, cancelSignal) {
  var endOfStreamCanceller = new task_canceller/* default */.Ay();
  endOfStreamCanceller.linkToSignal(cancelSignal);
  onSourceOpen(mediaSource, function () {
    log/* default */.A.debug("Init: MediaSource re-opened while end-of-stream is active");
    endOfStreamCanceller.cancel();
    endOfStreamCanceller = new task_canceller/* default */.Ay();
    endOfStreamCanceller.linkToSignal(cancelSignal);
    triggerEndOfStream(mediaSource, endOfStreamCanceller.signal);
  }, cancelSignal);
  triggerEndOfStream(mediaSource, endOfStreamCanceller.signal);
}
;// CONCATENATED MODULE: ./src/core/init/utils/get_initial_time.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Returns the calculated initial time for the content described by the given
 * Manifest:
 *   1. if a start time is defined by user, calculate starting time from the
 *      manifest information
 *   2. else if the media is live, use the live edge and suggested delays from
 *      it
 *   3. else returns the minimum time announced in the manifest
 * @param {Manifest} manifest
 * @param {boolean} lowLatencyMode
 * @param {Object} startAt
 * @returns {Number}
 */
function getInitialTime(manifest, lowLatencyMode, startAt) {
  var _a;
  if (!(0,is_null_or_undefined/* default */.A)(startAt)) {
    var min = manifest.getMinimumSafePosition();
    var max = manifest.getMaximumSafePosition();
    if (!(0,is_null_or_undefined/* default */.A)(startAt.position)) {
      log/* default */.A.debug("Init: using startAt.minimumPosition");
      return Math.max(Math.min(startAt.position, max), min);
    } else if (!(0,is_null_or_undefined/* default */.A)(startAt.wallClockTime)) {
      log/* default */.A.debug("Init: using startAt.wallClockTime");
      var ast = manifest.availabilityStartTime === undefined ? 0 : manifest.availabilityStartTime;
      var position = startAt.wallClockTime - ast;
      return Math.max(Math.min(position, max), min);
    } else if (!(0,is_null_or_undefined/* default */.A)(startAt.fromFirstPosition)) {
      log/* default */.A.debug("Init: using startAt.fromFirstPosition");
      var fromFirstPosition = startAt.fromFirstPosition;
      return fromFirstPosition <= 0 ? min : Math.min(max, min + fromFirstPosition);
    } else if (!(0,is_null_or_undefined/* default */.A)(startAt.fromLastPosition)) {
      log/* default */.A.debug("Init: using startAt.fromLastPosition");
      var fromLastPosition = startAt.fromLastPosition;
      return fromLastPosition >= 0 ? max : Math.max(min, max + fromLastPosition);
    } else if (!(0,is_null_or_undefined/* default */.A)(startAt.fromLivePosition)) {
      log/* default */.A.debug("Init: using startAt.fromLivePosition");
      var livePosition = (_a = manifest.getLivePosition()) !== null && _a !== void 0 ? _a : max;
      var fromLivePosition = startAt.fromLivePosition;
      return fromLivePosition >= 0 ? livePosition : Math.max(min, livePosition + fromLivePosition);
    } else if (!(0,is_null_or_undefined/* default */.A)(startAt.percentage)) {
      log/* default */.A.debug("Init: using startAt.percentage");
      var percentage = startAt.percentage;
      if (percentage > 100) {
        return max;
      } else if (percentage < 0) {
        return min;
      }
      var ratio = +percentage / 100;
      var extent = max - min;
      return min + extent * ratio;
    }
  }
  var minimumPosition = manifest.getMinimumSafePosition();
  if (manifest.isLive) {
    var suggestedPresentationDelay = manifest.suggestedPresentationDelay,
      clockOffset = manifest.clockOffset;
    var maximumPosition = manifest.getMaximumSafePosition();
    var liveTime;
    var _config$getCurrent = config/* default */.A.getCurrent(),
      DEFAULT_LIVE_GAP = _config$getCurrent.DEFAULT_LIVE_GAP;
    if (clockOffset === undefined) {
      log/* default */.A.info("Init: no clock offset found for a live content, " + "starting close to maximum available position");
      liveTime = maximumPosition;
    } else {
      log/* default */.A.info("Init: clock offset found for a live content, " + "checking if we can start close to it");
      var _ast = manifest.availabilityStartTime === undefined ? 0 : manifest.availabilityStartTime;
      var clockRelativeLiveTime = (performance.now() + clockOffset) / 1000 - _ast;
      liveTime = Math.min(maximumPosition, clockRelativeLiveTime);
    }
    var diffFromLiveTime = suggestedPresentationDelay !== undefined ? suggestedPresentationDelay : lowLatencyMode ? DEFAULT_LIVE_GAP.LOW_LATENCY : DEFAULT_LIVE_GAP.DEFAULT;
    log/* default */.A.debug("Init: " + liveTime + " defined as the live time, applying a live gap" + (" of " + diffFromLiveTime));
    return Math.max(liveTime - diffFromLiveTime, minimumPosition);
  }
  log/* default */.A.info("Init: starting at the minimum available position:", minimumPosition);
  return minimumPosition;
}
// EXTERNAL MODULE: ./src/core/init/utils/get_loaded_reference.ts + 2 modules
var get_loaded_reference = __webpack_require__(5097);
// EXTERNAL MODULE: ./src/core/init/utils/initial_seek_and_play.ts + 1 modules
var initial_seek_and_play = __webpack_require__(107);
// EXTERNAL MODULE: ./src/core/init/utils/initialize_content_decryption.ts
var initialize_content_decryption = __webpack_require__(6899);
;// CONCATENATED MODULE: ./src/compat/has_issues_with_high_media_source_duration.ts

/**
 * Some platforms have issues when the `MediaSource`'s `duration` property
 * is set to a very high value (playback freezes) but not when setting it
 * to `Infinity`, which is what the HTML spec as of now (2023-05-15) recommends
 * for live contents.
 *
 * However setting the `MediaSource`'s `duration` property to `Infinity` seems
 * more risky, considering all platforms we now support, than setting it at a
 * relatively high ~2**32 value which is what we do generally.
 *
 * Moreover, setting it to `Infinity` require us to use another MSE API,
 * `setLiveSeekableRange` to properly allow seeking. We're used to MSE issues so
 * I'm not too confident of using another MSE API for all platforms directly.
 *
 * So this methods just return `true` based on a whitelist of platform for which
 * it has been detected that high `duration` values cause issues but setting it
 * to Infinity AND playing with `setLiveSeekableRange` does not.
 *
 * @returns {boolean}
 */
function hasIssuesWithHighMediaSourceDuration() {
  // For now only seen on the Webkit present in the PlayStation 5, for which the
  // alternative is known to work.
  return browser_detection/* isPlayStation5 */.A7;
}
;// CONCATENATED MODULE: ./src/core/init/utils/media_source_duration_updater.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* eslint-disable-next-line max-len */




/** Number of seconds in a regular year. */
var YEAR_IN_SECONDS = 365 * 24 * 3600;
/**
 * Keep the MediaSource's `duration` attribute up-to-date with the duration of
 * the content played on it.
 * @class MediaSourceDurationUpdater
 */
var MediaSourceDurationUpdater = /*#__PURE__*/function () {
  /**
   * Create a new `MediaSourceDurationUpdater`,
   * @param {MediaSource} mediaSource - The MediaSource on which the content is
   * played.
   */
  function MediaSourceDurationUpdater(mediaSource) {
    this._mediaSource = mediaSource;
    this._currentMediaSourceDurationUpdateCanceller = null;
  }
  /**
   * Indicate to the `MediaSourceDurationUpdater` the currently known duration
   * of the content.
   *
   * The `MediaSourceDurationUpdater` will then use that value to determine
   * which `duration` attribute should be set on the `MediaSource` associated
   *
   * @param {number} newDuration
   * @param {boolean} isRealEndKnown - If set to `false`, the current content is
   * a dynamic content (it might evolve in the future) and the `newDuration`
   * communicated might be greater still. In effect the
   * `MediaSourceDurationUpdater` will actually set a much higher value to the
   * `MediaSource`'s duration to prevent being annoyed by the HTML-related
   * side-effects of having a too low duration (such as the impossibility to
   * seek over that value).
   */
  var _proto = MediaSourceDurationUpdater.prototype;
  _proto.updateDuration = function updateDuration(newDuration, isRealEndKnown) {
    if (this._currentMediaSourceDurationUpdateCanceller !== null) {
      this._currentMediaSourceDurationUpdateCanceller.cancel();
    }
    this._currentMediaSourceDurationUpdateCanceller = new task_canceller/* default */.Ay();
    var mediaSource = this._mediaSource;
    var currentSignal = this._currentMediaSourceDurationUpdateCanceller.signal;
    var isMediaSourceOpened = createMediaSourceOpenReference(mediaSource, currentSignal);
    /** TaskCanceller triggered each time the MediaSource switches to and from "open". */
    var msOpenStatusCanceller = new task_canceller/* default */.Ay();
    msOpenStatusCanceller.linkToSignal(currentSignal);
    isMediaSourceOpened.onUpdate(onMediaSourceOpenedStatusChanged, {
      emitCurrentValue: true,
      clearSignal: currentSignal
    });
    function onMediaSourceOpenedStatusChanged() {
      msOpenStatusCanceller.cancel();
      if (!isMediaSourceOpened.getValue()) {
        return;
      }
      msOpenStatusCanceller = new task_canceller/* default */.Ay();
      msOpenStatusCanceller.linkToSignal(currentSignal);
      var areSourceBuffersUpdating = createSourceBuffersUpdatingReference(mediaSource.sourceBuffers, msOpenStatusCanceller.signal);
      /** TaskCanceller triggered each time SourceBuffers' updating status changes */
      var sourceBuffersUpdatingCanceller = new task_canceller/* default */.Ay();
      sourceBuffersUpdatingCanceller.linkToSignal(msOpenStatusCanceller.signal);
      return areSourceBuffersUpdating.onUpdate(function (areUpdating) {
        sourceBuffersUpdatingCanceller.cancel();
        sourceBuffersUpdatingCanceller = new task_canceller/* default */.Ay();
        sourceBuffersUpdatingCanceller.linkToSignal(msOpenStatusCanceller.signal);
        if (areUpdating) {
          return;
        }
        recursivelyForceDurationUpdate(mediaSource, newDuration, isRealEndKnown, sourceBuffersUpdatingCanceller.signal);
      }, {
        clearSignal: msOpenStatusCanceller.signal,
        emitCurrentValue: true
      });
    }
  }
  /**
   * Abort the last duration-setting operation and free its resources.
   */;
  _proto.stopUpdating = function stopUpdating() {
    if (this._currentMediaSourceDurationUpdateCanceller !== null) {
      this._currentMediaSourceDurationUpdateCanceller.cancel();
      this._currentMediaSourceDurationUpdateCanceller = null;
    }
  };
  return MediaSourceDurationUpdater;
}();
/**
 * Checks that duration can be updated on the MediaSource, and then
 * sets it.
 *
 * Returns either:
 *   - the new duration it has been updated to if it has
 *   - `null` if it hasn'nt been updated
 *
 * @param {MediaSource} mediaSource
 * @param {number} duration
 * @param {boolean} isRealEndKnown
 * @returns {string}
 */

function setMediaSourceDuration(mediaSource, duration, isRealEndKnown) {
  var newDuration = duration;
  if (!isRealEndKnown) {
    newDuration = hasIssuesWithHighMediaSourceDuration() ? Infinity : getMaximumLiveSeekablePosition(duration);
  }
  var maxBufferedEnd = 0;
  for (var i = 0; i < mediaSource.sourceBuffers.length; i++) {
    var sourceBuffer = mediaSource.sourceBuffers[i];
    var sbBufferedLen = sourceBuffer.buffered.length;
    if (sbBufferedLen > 0) {
      maxBufferedEnd = Math.max(sourceBuffer.buffered.end(sbBufferedLen - 1));
    }
  }
  if (newDuration === mediaSource.duration) {
    return "success" /* MediaSourceDurationUpdateStatus.Success */;
  } else if (maxBufferedEnd > newDuration) {
    // We already buffered further than the duration we want to set.
    // Keep the duration that was set at that time as a security.
    if (maxBufferedEnd < mediaSource.duration) {
      try {
        log/* default */.A.info("Init: Updating duration to what is currently buffered", maxBufferedEnd);
        mediaSource.duration = maxBufferedEnd;
      } catch (err) {
        log/* default */.A.warn("Duration Updater: Can't update duration on the MediaSource.", err instanceof Error ? err : "");
        return "failed" /* MediaSourceDurationUpdateStatus.Failed */;
      }
    }
    return "partial" /* MediaSourceDurationUpdateStatus.Partial */;
  } else {
    var oldDuration = mediaSource.duration;
    try {
      log/* default */.A.info("Init: Updating duration", newDuration);
      mediaSource.duration = newDuration;
      if (mediaSource.readyState === "open" && !isFinite(newDuration)) {
        var maxSeekable = getMaximumLiveSeekablePosition(duration);
        log/* default */.A.info("Init: calling `mediaSource.setLiveSeekableRange`", maxSeekable);
        mediaSource.setLiveSeekableRange(0, maxSeekable);
      }
    } catch (err) {
      log/* default */.A.warn("Duration Updater: Can't update duration on the MediaSource.", err instanceof Error ? err : "");
      return "failed" /* MediaSourceDurationUpdateStatus.Failed */;
    }
    var deltaToExpected = Math.abs(mediaSource.duration - newDuration);
    if (deltaToExpected >= 0.1) {
      var deltaToBefore = Math.abs(mediaSource.duration - oldDuration);
      return deltaToExpected < deltaToBefore ? "partial" /* MediaSourceDurationUpdateStatus.Partial */ : "failed" /* MediaSourceDurationUpdateStatus.Failed */;
    }
    return "success" /* MediaSourceDurationUpdateStatus.Success */;
  }
}
/**
 * Returns a `SharedReference` wrapping a boolean that tells if all the
 * SourceBuffers ended all pending updates.
 * @param {SourceBufferList} sourceBuffers
 * @param {Object} cancelSignal
 * @returns {Object}
 */
function createSourceBuffersUpdatingReference(sourceBuffers, cancelSignal) {
  if (sourceBuffers.length === 0) {
    var notOpenedRef = new reference/* default */.A(false);
    notOpenedRef.finish();
    return notOpenedRef;
  }
  var areUpdatingRef = new reference/* default */.A(false, cancelSignal);
  reCheck();
  var _loop = function _loop() {
    var sourceBuffer = sourceBuffers[i];
    sourceBuffer.addEventListener("updatestart", reCheck);
    sourceBuffer.addEventListener("update", reCheck);
    cancelSignal.register(function () {
      sourceBuffer.removeEventListener("updatestart", reCheck);
      sourceBuffer.removeEventListener("update", reCheck);
    });
  };
  for (var i = 0; i < sourceBuffers.length; i++) {
    _loop();
  }
  return areUpdatingRef;
  function reCheck() {
    for (var _i = 0; _i < sourceBuffers.length; _i++) {
      var sourceBuffer = sourceBuffers[_i];
      if (sourceBuffer.updating) {
        areUpdatingRef.setValueIfChanged(true);
        return;
      }
    }
    areUpdatingRef.setValueIfChanged(false);
  }
}
/**
 * Returns a `SharedReference` wrapping a boolean that tells if the media
 * source is opened or not.
 * @param {MediaSource} mediaSource
 * @param {Object} cancelSignal
 * @returns {Object}
 */
function createMediaSourceOpenReference(mediaSource, cancelSignal) {
  var isMediaSourceOpen = new reference/* default */.A(mediaSource.readyState === "open", cancelSignal);
  (0,event_listeners/* onSourceOpen */.bF)(mediaSource, function () {
    log/* default */.A.debug("Init: Reacting to MediaSource open in duration updater");
    isMediaSourceOpen.setValueIfChanged(true);
  }, cancelSignal);
  (0,event_listeners/* onSourceEnded */.Z1)(mediaSource, function () {
    log/* default */.A.debug("Init: Reacting to MediaSource ended in duration updater");
    isMediaSourceOpen.setValueIfChanged(false);
  }, cancelSignal);
  (0,event_listeners/* onSourceClose */.XC)(mediaSource, function () {
    log/* default */.A.debug("Init: Reacting to MediaSource close in duration updater");
    isMediaSourceOpen.setValueIfChanged(false);
  }, cancelSignal);
  return isMediaSourceOpen;
}
/**
 * Immediately tries to set the MediaSource's duration to the most appropriate
 * one.
 *
 * If it fails, wait 2 seconds and retries.
 *
 * @param {MediaSource} mediaSource
 * @param {number} duration
 * @param {boolean} isRealEndKnown
 * @param {Object} cancelSignal
 */
function recursivelyForceDurationUpdate(mediaSource, duration, isRealEndKnown, cancelSignal) {
  var res = setMediaSourceDuration(mediaSource, duration, isRealEndKnown);
  if (res === "success" /* MediaSourceDurationUpdateStatus.Success */) {
    return;
  }
  var timeoutId = setTimeout(function () {
    unregisterClear();
    recursivelyForceDurationUpdate(mediaSource, duration, isRealEndKnown, cancelSignal);
  }, 2000);
  var unregisterClear = cancelSignal.register(function () {
    clearTimeout(timeoutId);
  });
}
function getMaximumLiveSeekablePosition(contentLastPosition) {
  // Some targets poorly support setting a very high number for seekable
  // ranges.
  // Yet, in contents whose end is not yet known (e.g. live contents), we
  // would prefer setting a value as high as possible to still be able to
  // seek anywhere we want to (even ahead of the Manifest if we want to).
  // As such, we put it at a safe default value of 2^32 excepted when the
  // maximum position is already relatively close to that value, where we
  // authorize exceptionally going over it.
  return Math.max(Math.pow(2, 32), contentLastPosition + YEAR_IN_SECONDS);
}
// EXTERNAL MODULE: ./src/core/init/utils/rebuffering_controller.ts
var rebuffering_controller = __webpack_require__(3137);
;// CONCATENATED MODULE: ./src/core/init/utils/stream_events_emitter/are_same_stream_events.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Compare 2 events.
 * As the payload of two events may be the same, but the JS objects may not
 * have the same references, it may be difficult to compare them.
 * If two events start and end at the same moment, and possess the same id,
 * we consider the two to be the same.
 * /!\ However, the DASH-if spec does not say that the event payload
 * may be the same if these conditions are met. Thus, there are high chances
 * that it may be the case.
 * TODO See if we can compare payloads
 * @param {Object} evt1
 * @param {Object} evt2
 * @returns {Boolean}
 */
function areSameStreamEvents(evt1, evt2) {
  return evt1.id === evt2.id && evt1.start === evt2.start && evt1.end === evt2.end;
}
/* harmony default export */ var are_same_stream_events = (areSameStreamEvents);
;// CONCATENATED MODULE: ./src/core/init/utils/stream_events_emitter/refresh_scheduled_events_list.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Refresh local scheduled events list
 * @param {Array.<Object>} oldScheduledEvents
 * @param {Object} manifest
 * @returns {Array.<Object>}
 */
function refreshScheduledEventsList(oldScheduledEvents, manifest) {
  var scheduledEvents = [];
  var periods = manifest.periods;
  for (var i = 0; i < periods.length; i++) {
    var period = periods[i];
    var streamEvents = period.streamEvents;
    streamEvents.forEach(function (_ref) {
      var start = _ref.start,
        end = _ref.end,
        id = _ref.id,
        data = _ref.data;
      for (var j = 0; j < oldScheduledEvents.length; j++) {
        var currentScheduledEvent = oldScheduledEvents[j];
        if (are_same_stream_events(currentScheduledEvent, {
          id: id,
          start: start,
          end: end
        })) {
          scheduledEvents.push(currentScheduledEvent);
          return;
        }
      }
      var element = data.value.element;
      var actualData = {
        type: data.type,
        value: Object.assign(Object.assign({}, data.value), {
          element: element
        })
      };
      if (end === undefined) {
        var newScheduledEvent = {
          start: start,
          id: id,
          data: actualData,
          publicEvent: {
            start: start,
            data: actualData
          }
        };
        scheduledEvents.push(newScheduledEvent);
      } else {
        var _newScheduledEvent = {
          start: start,
          end: end,
          id: id,
          data: actualData,
          publicEvent: {
            start: start,
            end: end,
            data: actualData
          }
        };
        scheduledEvents.push(_newScheduledEvent);
      }
    });
  }
  return scheduledEvents;
}
/* harmony default export */ var refresh_scheduled_events_list = (refreshScheduledEventsList);
;// CONCATENATED MODULE: ./src/core/init/utils/stream_events_emitter/stream_events_emitter.ts

function stream_events_emitter_createForOfIteratorHelperLoose(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (t) return (t = t.call(r)).next.bind(t); if (Array.isArray(r) || (t = stream_events_emitter_unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var o = 0; return function () { return o >= r.length ? { done: !0 } : { done: !1, value: r[o++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function stream_events_emitter_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return stream_events_emitter_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? stream_events_emitter_arrayLikeToArray(r, a) : void 0; } }
function stream_events_emitter_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * Get events from manifest and emit each time an event has to be emitted
 */
var StreamEventsEmitter = /*#__PURE__*/function (_EventEmitter) {
  /**
   * @param {Object} manifest
   * @param {HTMLMediaElement} mediaElement
   * @param {Object} playbackObserver
   */
  function StreamEventsEmitter(manifest, mediaElement, playbackObserver) {
    var _this;
    _this = _EventEmitter.call(this) || this;
    _this._manifest = manifest;
    _this._mediaElement = mediaElement;
    _this._playbackObserver = playbackObserver;
    _this._canceller = null;
    _this._scheduledEventsRef = new reference/* default */.A([]);
    _this._eventsBeingPlayed = new WeakMap();
    return _this;
  }
  (0,inheritsLoose/* default */.A)(StreamEventsEmitter, _EventEmitter);
  var _proto = StreamEventsEmitter.prototype;
  _proto.start = function start() {
    var _this2 = this;
    if (this._canceller !== null) {
      return;
    }
    this._canceller = new task_canceller/* default */.Ay();
    var cancelSignal = this._canceller.signal;
    var playbackObserver = this._playbackObserver;
    var mediaElement = this._mediaElement;
    var isPollingEvents = false;
    var cancelCurrentPolling = new task_canceller/* default */.Ay();
    cancelCurrentPolling.linkToSignal(cancelSignal);
    this._manifest.addEventListener("manifestUpdate", function () {
      var prev = _this2._scheduledEventsRef.getValue();
      _this2._scheduledEventsRef.setValue(refresh_scheduled_events_list(prev, _this2._manifest));
    }, this._canceller.signal);
    this._scheduledEventsRef.setValue(refresh_scheduled_events_list([], this._manifest));
    this._scheduledEventsRef.onUpdate(function (_ref) {
      var scheduledEventsLength = _ref.length;
      if (scheduledEventsLength === 0) {
        if (isPollingEvents) {
          cancelCurrentPolling.cancel();
          cancelCurrentPolling = new task_canceller/* default */.Ay();
          cancelCurrentPolling.linkToSignal(cancelSignal);
          isPollingEvents = false;
        }
        return;
      } else if (isPollingEvents) {
        return;
      }
      isPollingEvents = true;
      var oldObservation = constructObservation();
      var checkStreamEvents = function checkStreamEvents() {
        var newObservation = constructObservation();
        _this2._emitStreamEvents(_this2._scheduledEventsRef.getValue(), oldObservation, newObservation, cancelCurrentPolling.signal);
        oldObservation = newObservation;
      };
      var _config$getCurrent = config/* default */.A.getCurrent(),
        STREAM_EVENT_EMITTER_POLL_INTERVAL = _config$getCurrent.STREAM_EVENT_EMITTER_POLL_INTERVAL;
      var intervalId = setInterval(checkStreamEvents, STREAM_EVENT_EMITTER_POLL_INTERVAL);
      playbackObserver.listen(checkStreamEvents, {
        includeLastObservation: false,
        clearSignal: cancelCurrentPolling.signal
      });
      cancelCurrentPolling.signal.register(function () {
        clearInterval(intervalId);
      });
      function constructObservation() {
        var isSeeking = playbackObserver.getReference().getValue().seeking;
        return {
          currentTime: mediaElement.currentTime,
          isSeeking: isSeeking
        };
      }
    }, {
      emitCurrentValue: true,
      clearSignal: cancelSignal
    });
  };
  _proto.stop = function stop() {
    if (this._canceller !== null) {
      this._canceller.cancel();
      this._canceller = null;
    }
  }
  /**
   * Examine playback situation from playback observations to emit stream events and
   * prepare set onExit callbacks if needed.
   * @param {Array.<Object>} scheduledEvents
   * @param {Object} oldObservation
   * @param {Object} newObservation
   * @param {Object} stopSignal
   */;
  _proto._emitStreamEvents = function _emitStreamEvents(scheduledEvents, oldObservation, newObservation, stopSignal) {
    var previousTime = oldObservation.currentTime;
    var isSeeking = newObservation.isSeeking,
      currentTime = newObservation.currentTime;
    var eventsToSend = [];
    var eventsToExit = [];
    for (var i = 0; i < scheduledEvents.length; i++) {
      var event = scheduledEvents[i];
      var start = event.start;
      var end = isFiniteStreamEvent(event) ? event.end : undefined;
      var isBeingPlayed = this._eventsBeingPlayed.has(event);
      if (isBeingPlayed) {
        if (start > currentTime || end !== undefined && currentTime >= end) {
          if (isFiniteStreamEvent(event)) {
            eventsToExit.push(event.publicEvent);
          }
          this._eventsBeingPlayed["delete"](event);
        }
      } else if (start <= currentTime && end !== undefined && currentTime < end) {
        eventsToSend.push({
          type: "stream-event",
          value: event.publicEvent
        });
        this._eventsBeingPlayed.set(event, true);
      } else if (previousTime < start && currentTime >= (end !== null && end !== void 0 ? end : start)) {
        if (isSeeking) {
          eventsToSend.push({
            type: "stream-event-skip",
            value: event.publicEvent
          });
        } else {
          eventsToSend.push({
            type: "stream-event",
            value: event.publicEvent
          });
          if (isFiniteStreamEvent(event)) {
            eventsToExit.push(event.publicEvent);
          }
        }
      }
    }
    if (eventsToSend.length > 0) {
      for (var _iterator = stream_events_emitter_createForOfIteratorHelperLoose(eventsToSend), _step; !(_step = _iterator()).done;) {
        var _event = _step.value;
        if (_event.type === "stream-event") {
          this.trigger("event", _event.value);
        } else {
          this.trigger("eventSkip", _event.value);
        }
        if (stopSignal.isCancelled()) {
          return;
        }
      }
    }
    if (eventsToExit.length > 0) {
      for (var _iterator2 = stream_events_emitter_createForOfIteratorHelperLoose(eventsToExit), _step2; !(_step2 = _iterator2()).done;) {
        var _event2 = _step2.value;
        if (typeof _event2.onExit === "function") {
          _event2.onExit();
        }
        if (stopSignal.isCancelled()) {
          return;
        }
      }
    }
  };
  return StreamEventsEmitter;
}(event_emitter/* default */.A);
/**
 * Tells if a stream event has a duration
 * @param {Object} evt
 * @returns {Boolean}
 */

function isFiniteStreamEvent(evt) {
  return evt.end !== undefined;
}
;// CONCATENATED MODULE: ./src/core/init/utils/stream_events_emitter/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ var stream_events_emitter = (StreamEventsEmitter);
// EXTERNAL MODULE: ./src/core/init/utils/throw_on_media_error.ts
var throw_on_media_error = __webpack_require__(8345);
;// CONCATENATED MODULE: ./src/core/init/media_source_content_initializer.ts


function media_source_content_initializer_createForOfIteratorHelperLoose(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (t) return (t = t.call(r)).next.bind(t); if (Array.isArray(r) || (t = media_source_content_initializer_unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var o = 0; return function () { return o >= r.length ? { done: !0 } : { done: !1, value: r[o++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function media_source_content_initializer_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return media_source_content_initializer_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? media_source_content_initializer_arrayLikeToArray(r, a) : void 0; } }
function media_source_content_initializer_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* eslint-disable-next-line max-len */



























/**
 * Allows to load a new content thanks to the MediaSource Extensions (a.k.a. MSE)
 * Web APIs.
 *
 * Through this `ContentInitializer`, a Manifest will be fetched (and depending
 * on the situation, refreshed), a `MediaSource` instance will be linked to the
 * wanted `HTMLMediaElement` and chunks of media data, called segments, will be
 * pushed on buffers associated to this `MediaSource` instance.
 *
 * @class MediaSourceContentInitializer
 */
var MediaSourceContentInitializer = /*#__PURE__*/function (_ContentInitializer) {
  /**
   * Create a new `MediaSourceContentInitializer`, associated to the given
   * settings.
   * @param {Object} settings
   */
  function MediaSourceContentInitializer(settings) {
    var _this;
    _this = _ContentInitializer.call(this) || this;
    _this._settings = settings;
    _this._initCanceller = new task_canceller/* default */.Ay();
    _this._initialManifestProm = null;
    var urls = settings.url === undefined ? undefined : [settings.url];
    _this._manifestFetcher = new fetchers_manifest(urls, settings.transport, settings.manifestRequestSettings);
    return _this;
  }
  /**
   * Perform non-destructive preparation steps, to prepare a future content.
   * For now, this mainly mean loading the Manifest document.
   */
  (0,inheritsLoose/* default */.A)(MediaSourceContentInitializer, _ContentInitializer);
  var _proto = MediaSourceContentInitializer.prototype;
  _proto.prepare = function prepare() {
    var _this2 = this;
    if (this._initialManifestProm !== null) {
      return;
    }
    this._initialManifestProm = (0,create_cancellable_promise/* default */.A)(this._initCanceller.signal, function (res, rej) {
      _this2._manifestFetcher.addEventListener("warning", function (err) {
        return _this2.trigger("warning", err);
      });
      _this2._manifestFetcher.addEventListener("error", function (err) {
        _this2.trigger("error", err);
        rej(err);
      });
      _this2._manifestFetcher.addEventListener("manifestReady", function (manifest) {
        res(manifest);
      });
    });
    this._manifestFetcher.start();
    this._initCanceller.signal.register(function () {
      _this2._manifestFetcher.dispose();
    });
  }
  /**
   * @param {HTMLMediaElement} mediaElement
   * @param {Object} playbackObserver
   */;
  _proto.start = function start(mediaElement, playbackObserver) {
    var _this3 = this;
    this.prepare(); // Load Manifest if not already done
    /** Translate errors coming from the media element into RxPlayer errors. */
    (0,throw_on_media_error/* default */.A)(mediaElement, function (error) {
      return _this3._onFatalError(error);
    }, this._initCanceller.signal);
    /** Send content protection initialization data to the decryption logic. */
    var protectionRef = new reference/* default */.A(null, this._initCanceller.signal);
    this._initializeMediaSourceAndDecryption(mediaElement, protectionRef).then(function (initResult) {
      return _this3._onInitialMediaSourceReady(mediaElement, initResult.mediaSource, playbackObserver, initResult.drmSystemId, protectionRef, initResult.unlinkMediaSource);
    })["catch"](function (err) {
      _this3._onFatalError(err);
    });
  }
  /**
   * Update URL of the Manifest.
   * @param {Array.<string>|undefined} urls - URLs to reach that Manifest from
   * the most prioritized URL to the least prioritized URL.
   * @param {boolean} refreshNow - If `true` the resource in question (e.g.
   * DASH's MPD) will be refreshed immediately.
   */;
  _proto.updateContentUrls = function updateContentUrls(urls, refreshNow) {
    this._manifestFetcher.updateContentUrls(urls, refreshNow);
  };
  _proto.dispose = function dispose() {
    this._initCanceller.cancel();
  };
  _proto._onFatalError = function _onFatalError(err) {
    if (this._initCanceller.isUsed()) {
      return;
    }
    this._initCanceller.cancel();
    this.trigger("error", err);
  };
  _proto._initializeMediaSourceAndDecryption = function _initializeMediaSourceAndDecryption(mediaElement, protectionRef) {
    var _this4 = this;
    var initCanceller = this._initCanceller;
    return (0,create_cancellable_promise/* default */.A)(initCanceller.signal, function (resolve) {
      var keySystems = _this4._settings.keySystems;
      /** Initialize decryption capabilities. */
      var drmInitRef = (0,initialize_content_decryption/* default */.A)(mediaElement, keySystems, protectionRef, {
        onWarning: function onWarning(err) {
          return _this4.trigger("warning", err);
        },
        onError: function onError(err) {
          return _this4._onFatalError(err);
        }
      }, initCanceller.signal);
      drmInitRef.onUpdate(function (drmStatus, stopListeningToDrmUpdates) {
        if (drmStatus.initializationState.type === "uninitialized") {
          return;
        }
        stopListeningToDrmUpdates();
        var mediaSourceCanceller = new task_canceller/* default */.Ay();
        mediaSourceCanceller.linkToSignal(initCanceller.signal);
        openMediaSource(mediaElement, mediaSourceCanceller.signal).then(function (mediaSource) {
          var lastDrmStatus = drmInitRef.getValue();
          if (lastDrmStatus.initializationState.type === "awaiting-media-link") {
            lastDrmStatus.initializationState.value.isMediaLinked.setValue(true);
            drmInitRef.onUpdate(function (newDrmStatus, stopListeningToDrmUpdatesAgain) {
              if (newDrmStatus.initializationState.type === "initialized") {
                stopListeningToDrmUpdatesAgain();
                resolve({
                  mediaSource: mediaSource,
                  drmSystemId: newDrmStatus.drmSystemId,
                  unlinkMediaSource: mediaSourceCanceller
                });
                return;
              }
            }, {
              emitCurrentValue: true,
              clearSignal: initCanceller.signal
            });
          } else if (drmStatus.initializationState.type === "initialized") {
            resolve({
              mediaSource: mediaSource,
              drmSystemId: drmStatus.drmSystemId,
              unlinkMediaSource: mediaSourceCanceller
            });
            return;
          }
        })["catch"](function (err) {
          if (mediaSourceCanceller.isUsed()) {
            return;
          }
          _this4._onFatalError(err);
        });
      }, {
        emitCurrentValue: true,
        clearSignal: initCanceller.signal
      });
    });
  };
  _proto._onInitialMediaSourceReady = /*#__PURE__*/function () {
    var _onInitialMediaSourceReady2 = (0,asyncToGenerator/* default */.A)( /*#__PURE__*/regenerator_default().mark(function _callee(mediaElement, initialMediaSource, playbackObserver, drmSystemId, protectionRef, initialMediaSourceCanceller) {
      var _this5 = this;
      var _this$_settings, adaptiveOptions, autoPlay, bufferOptions, lowLatencyMode, segmentRequestOptions, speed, startAt, textTrackOptions, transport, initCanceller, manifestProm, manifest, initialTime, representationEstimator, subBufferOptions, segmentFetcherCreator, bufferOnMediaSource, triggerEvent, onFatalError, recursivelyLoadOnMediaSource;
      return regenerator_default().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            recursivelyLoadOnMediaSource = function _recursivelyLoadOnMed(mediaSource, startingPos, shouldPlay, currentCanceller) {
              var opts = {
                mediaElement: mediaElement,
                playbackObserver: playbackObserver,
                mediaSource: mediaSource,
                initialTime: startingPos,
                autoPlay: shouldPlay,
                manifest: manifest,
                representationEstimator: representationEstimator,
                segmentFetcherCreator: segmentFetcherCreator,
                speed: speed,
                protectionRef: protectionRef,
                bufferOptions: subBufferOptions
              };
              bufferOnMediaSource(opts, onReloadMediaSource, currentCanceller.signal);
              function onReloadMediaSource(reloadOrder) {
                currentCanceller.cancel();
                if (initCanceller.isUsed()) {
                  return;
                }
                triggerEvent("reloadingMediaSource", reloadOrder);
                if (initCanceller.isUsed()) {
                  return;
                }
                var newCanceller = new task_canceller/* default */.Ay();
                newCanceller.linkToSignal(initCanceller.signal);
                openMediaSource(mediaElement, newCanceller.signal).then(function (newMediaSource) {
                  recursivelyLoadOnMediaSource(newMediaSource, reloadOrder.position, reloadOrder.autoPlay, newCanceller);
                })["catch"](function (err) {
                  if (newCanceller.isUsed()) {
                    return;
                  }
                  onFatalError(err);
                });
              }
            };
            _this$_settings = this._settings, adaptiveOptions = _this$_settings.adaptiveOptions, autoPlay = _this$_settings.autoPlay, bufferOptions = _this$_settings.bufferOptions, lowLatencyMode = _this$_settings.lowLatencyMode, segmentRequestOptions = _this$_settings.segmentRequestOptions, speed = _this$_settings.speed, startAt = _this$_settings.startAt, textTrackOptions = _this$_settings.textTrackOptions, transport = _this$_settings.transport;
            initCanceller = this._initCanceller;
            (0,assert/* default */.h)(this._initialManifestProm !== null);
            manifestProm = this._initialManifestProm;
            _context.prev = 5;
            _context.next = 8;
            return manifestProm;
          case 8:
            manifest = _context.sent;
            _context.next = 14;
            break;
          case 11:
            _context.prev = 11;
            _context.t0 = _context["catch"](5);
            return _context.abrupt("return");
          case 14:
            manifest.addEventListener("manifestUpdate", function () {
              _this5.trigger("manifestUpdate", null);
            }, initCanceller.signal);
            manifest.addEventListener("decipherabilityUpdate", function (args) {
              _this5.trigger("decipherabilityUpdate", args);
            }, initCanceller.signal);
            log/* default */.A.debug("Init: Calculating initial time");
            initialTime = getInitialTime(manifest, lowLatencyMode, startAt);
            log/* default */.A.debug("Init: Initial time calculated:", initialTime);
            /** Choose the right "Representation" for a given "Adaptation". */
            representationEstimator = adaptive(adaptiveOptions);
            subBufferOptions = (0,object_assign/* default */.A)({
              textTrackOptions: textTrackOptions,
              drmSystemId: drmSystemId
            }, bufferOptions);
            segmentFetcherCreator = new segment(transport, segmentRequestOptions, initCanceller.signal);
            this.trigger("manifestReady", manifest);
            if (!initCanceller.isUsed()) {
              _context.next = 25;
              break;
            }
            return _context.abrupt("return");
          case 25:
            bufferOnMediaSource = this._startBufferingOnMediaSource.bind(this);
            triggerEvent = this.trigger.bind(this);
            onFatalError = this._onFatalError.bind(this); // handle initial load and reloads
            recursivelyLoadOnMediaSource(initialMediaSource, initialTime, autoPlay, initialMediaSourceCanceller);
            /**
             * Load the content defined by the Manifest in the mediaSource given at the
             * given position and playing status.
             * This function recursively re-call itself when a MediaSource reload is
             * wanted.
             * @param {MediaSource} mediaSource
             * @param {number} startingPos
             * @param {Object} currentCanceller
             * @param {boolean} shouldPlay
             */
          case 29:
          case "end":
            return _context.stop();
        }
      }, _callee, this, [[5, 11]]);
    }));
    function _onInitialMediaSourceReady(_x, _x2, _x3, _x4, _x5, _x6) {
      return _onInitialMediaSourceReady2.apply(this, arguments);
    }
    return _onInitialMediaSourceReady;
  }()
  /**
   * Buffer the content on the given MediaSource.
   * @param {Object} args
   * @param {function} onReloadOrder
   * @param {Object} cancelSignal
   */
  ;
  _proto._startBufferingOnMediaSource = function _startBufferingOnMediaSource(args, onReloadOrder, cancelSignal) {
    var _this6 = this;
    var _a;
    var autoPlay = args.autoPlay,
      bufferOptions = args.bufferOptions,
      initialTime = args.initialTime,
      manifest = args.manifest,
      mediaElement = args.mediaElement,
      mediaSource = args.mediaSource,
      playbackObserver = args.playbackObserver,
      protectionRef = args.protectionRef,
      representationEstimator = args.representationEstimator,
      segmentFetcherCreator = args.segmentFetcherCreator,
      speed = args.speed;
    var initialPeriod = (_a = manifest.getPeriodForTime(initialTime)) !== null && _a !== void 0 ? _a : manifest.getNextPeriod(initialTime);
    if (initialPeriod === undefined) {
      var error = new media_error/* default */.A("MEDIA_STARTING_TIME_NOT_FOUND", "Wanted starting time not found in the Manifest.");
      return this._onFatalError(error);
    }
    /** Interface to create media buffers. */
    var segmentBuffersStore = new segment_buffers(mediaElement, mediaSource);
    cancelSignal.register(function () {
      segmentBuffersStore.disposeAll();
    });
    var _performInitialSeekAn = (0,initial_seek_and_play/* default */.A)(mediaElement, playbackObserver, initialTime, autoPlay, function (err) {
        return _this6.trigger("warning", err);
      }, true, cancelSignal),
      autoPlayResult = _performInitialSeekAn.autoPlayResult,
      initialPlayPerformed = _performInitialSeekAn.initialPlayPerformed,
      initialSeekPerformed = _performInitialSeekAn.initialSeekPerformed;
    if (cancelSignal.isCancelled()) {
      return;
    }
    initialPlayPerformed.onUpdate(function (isPerformed, stopListening) {
      if (isPerformed) {
        stopListening();
        var streamEventsEmitter = new stream_events_emitter(manifest, mediaElement, playbackObserver);
        streamEventsEmitter.addEventListener("event", function (payload) {
          _this6.trigger("streamEvent", payload);
        }, cancelSignal);
        streamEventsEmitter.addEventListener("eventSkip", function (payload) {
          _this6.trigger("streamEventSkip", payload);
        }, cancelSignal);
        streamEventsEmitter.start();
        cancelSignal.register(function () {
          streamEventsEmitter.stop();
        });
      }
    }, {
      clearSignal: cancelSignal,
      emitCurrentValue: true
    });
    var streamObserver = createStreamPlaybackObserver(playbackObserver, {
      autoPlay: autoPlay,
      manifest: manifest,
      initialPlayPerformed: initialPlayPerformed,
      initialSeekPerformed: initialSeekPerformed,
      speed: speed,
      startTime: initialTime
    }, cancelSignal);
    var rebufferingController = this._createRebufferingController(playbackObserver, manifest, speed, cancelSignal);
    var contentTimeBoundariesObserver = this._createContentTimeBoundariesObserver(manifest, mediaSource, streamObserver, segmentBuffersStore, cancelSignal);
    if (may_media_element_fail_on_undecipherable_data) {
      // On some devices, just reload immediately when data become undecipherable
      manifest.addEventListener("decipherabilityUpdate", function (elts) {
        if (elts.some(function (e) {
          return e.representation.decipherable !== true;
        })) {
          reloadMediaSource(0, undefined, undefined);
        }
      }, cancelSignal);
    }
    /**
     * Emit a "loaded" events once the initial play has been performed and the
     * media can begin playback.
     * Also emits warning events if issues arise when doing so.
     */
    autoPlayResult.then(function () {
      (0,get_loaded_reference/* default */.A)(playbackObserver, mediaElement, false, cancelSignal).onUpdate(function (isLoaded, stopListening) {
        if (isLoaded) {
          stopListening();
          _this6.trigger("loaded", {
            segmentBuffersStore: segmentBuffersStore
          });
        }
      }, {
        emitCurrentValue: true,
        clearSignal: cancelSignal
      });
    })["catch"](function (err) {
      if (cancelSignal.isCancelled()) {
        return; // Current loading cancelled, no need to trigger the error
      }
      _this6._onFatalError(err);
    });
    /* eslint-disable-next-line @typescript-eslint/no-this-alias */
    var self = this;
    stream({
      manifest: manifest,
      initialPeriod: initialPeriod
    }, streamObserver, representationEstimator, segmentBuffersStore, segmentFetcherCreator, bufferOptions, handleStreamOrchestratorCallbacks(), cancelSignal);
    /**
     * Returns Object handling the callbacks from a `StreamOrchestrator`, which
     * are basically how it communicates about events.
     * @returns {Object}
     */
    function handleStreamOrchestratorCallbacks() {
      return {
        needsBufferFlush: function needsBufferFlush() {
          var seekedTime = mediaElement.currentTime + 0.001;
          playbackObserver.setCurrentTime(seekedTime);
          // Seek again once data begins to be buffered.
          // This is sadly necessary on some browsers to avoid decoding
          // issues after a flush.
          //
          // NOTE: there's in theory a potential race condition in the following
          // logic as the callback could be called when media data is still
          // being removed by the browser - which is an asynchronous process.
          // The following condition checking for buffered data could thus lead
          // to a false positive where we're actually checking previous data.
          // For now, such scenario is avoided by setting the
          // `includeLastObservation` option to `false` and calling
          // `needsBufferFlush` once MSE media removal operations have been
          // explicitely validated by the browser, but that's a complex and easy
          // to break system.
          playbackObserver.listen(function (obs, stopListening) {
            if (
            // Data is buffered around the current position
            obs.currentRange !== null ||
            // Or, for whatever reason, playback is already advancing
            obs.position > seekedTime + 0.1) {
              stopListening();
              playbackObserver.setCurrentTime(obs.position + 0.001);
            }
          }, {
            includeLastObservation: false,
            clearSignal: cancelSignal
          });
        },
        streamStatusUpdate: function streamStatusUpdate(value) {
          // Announce discontinuities if found
          var period = value.period,
            bufferType = value.bufferType,
            imminentDiscontinuity = value.imminentDiscontinuity,
            position = value.position;
          rebufferingController.updateDiscontinuityInfo({
            period: period,
            bufferType: bufferType,
            discontinuity: imminentDiscontinuity,
            position: position
          });
          if (cancelSignal.isCancelled()) {
            return; // Previous call has stopped streams due to a side-effect
          }
          // If the status for the last Period indicates that segments are all loaded
          // or on the contrary that the loading resumed, announce it to the
          // ContentTimeBoundariesObserver.
          if (manifest.isLastPeriodKnown && value.period.id === manifest.periods[manifest.periods.length - 1].id) {
            var hasFinishedLoadingLastPeriod = value.hasFinishedLoading || value.isEmptyStream;
            if (hasFinishedLoadingLastPeriod) {
              contentTimeBoundariesObserver.onLastSegmentFinishedLoading(value.bufferType);
            } else {
              contentTimeBoundariesObserver.onLastSegmentLoadingResume(value.bufferType);
            }
          }
        },
        needsManifestRefresh: function needsManifestRefresh() {
          return self._manifestFetcher.scheduleManualRefresh({
            enablePartialRefresh: true,
            canUseUnsafeMode: true
          });
        },
        manifestMightBeOufOfSync: function manifestMightBeOufOfSync() {
          var _config$getCurrent = config/* default */.A.getCurrent(),
            OUT_OF_SYNC_MANIFEST_REFRESH_DELAY = _config$getCurrent.OUT_OF_SYNC_MANIFEST_REFRESH_DELAY;
          self._manifestFetcher.scheduleManualRefresh({
            enablePartialRefresh: false,
            canUseUnsafeMode: false,
            delay: OUT_OF_SYNC_MANIFEST_REFRESH_DELAY
          });
        },
        lockedStream: function lockedStream(value) {
          return rebufferingController.onLockedStream(value.bufferType, value.period);
        },
        adaptationChange: function adaptationChange(value) {
          self.trigger("adaptationChange", value);
          if (cancelSignal.isCancelled()) {
            return; // Previous call has stopped streams due to a side-effect
          }
          contentTimeBoundariesObserver.onAdaptationChange(value.type, value.period, value.adaptation);
        },
        representationChange: function representationChange(value) {
          self.trigger("representationChange", value);
          if (cancelSignal.isCancelled()) {
            return; // Previous call has stopped streams due to a side-effect
          }
          contentTimeBoundariesObserver.onRepresentationChange(value.type, value.period);
        },
        inbandEvent: function inbandEvent(value) {
          return self.trigger("inbandEvents", value);
        },
        warning: function warning(value) {
          return self.trigger("warning", value);
        },
        periodStreamReady: function periodStreamReady(value) {
          return self.trigger("periodStreamReady", value);
        },
        periodStreamCleared: function periodStreamCleared(value) {
          contentTimeBoundariesObserver.onPeriodCleared(value.type, value.period);
          if (cancelSignal.isCancelled()) {
            return; // Previous call has stopped streams due to a side-effect
          }
          self.trigger("periodStreamCleared", value);
        },
        bitrateEstimationChange: function bitrateEstimationChange(value) {
          return self.trigger("bitrateEstimationChange", value);
        },
        addedSegment: function addedSegment(value) {
          return self.trigger("addedSegment", value);
        },
        needsMediaSourceReload: function needsMediaSourceReload(payload) {
          reloadMediaSource(payload.timeOffset, payload.minimumPosition, payload.maximumPosition);
        },
        needsDecipherabilityFlush: function needsDecipherabilityFlush() {
          var _a, _b, _c;
          var keySystem = (0,get_key_system_configuration/* default */.A)(mediaElement);
          if (shouldReloadMediaSourceOnDecipherabilityUpdate(keySystem === null || keySystem === void 0 ? void 0 : keySystem[0])) {
            var lastObservation = streamObserver.getReference().getValue();
            var position = (_a = lastObservation.position.pending) !== null && _a !== void 0 ? _a : streamObserver.getCurrentTime();
            var isPaused = (_b = lastObservation.paused.pending) !== null && _b !== void 0 ? _b : streamObserver.getIsPaused();
            onReloadOrder({
              position: position,
              autoPlay: !isPaused
            });
          } else {
            var _lastObservation = streamObserver.getReference().getValue();
            var _position = (_c = _lastObservation.position.pending) !== null && _c !== void 0 ? _c : streamObserver.getCurrentTime();
            // simple seek close to the current position
            // to flush the buffers
            if (_position + 0.001 < _lastObservation.duration) {
              playbackObserver.setCurrentTime(mediaElement.currentTime + 0.001);
            } else {
              playbackObserver.setCurrentTime(_position);
            }
          }
        },
        encryptionDataEncountered: function encryptionDataEncountered(value) {
          for (var _iterator = media_source_content_initializer_createForOfIteratorHelperLoose(value), _step; !(_step = _iterator()).done;) {
            var protectionData = _step.value;
            protectionRef.setValue(protectionData);
            if (cancelSignal.isCancelled()) {
              return; // Previous call has stopped streams due to a side-effect
            }
          }
        },
        error: function error(err) {
          return self._onFatalError(err);
        }
      };
    }
    /**
     * Callback allowing to reload the current content.
     * @param {number} deltaPosition - Position you want to seek to after
     * reloading, as a delta in seconds from the last polled playing position.
     * @param {number|undefined} minimumPosition - If set, minimum time bound
     * in seconds after `deltaPosition` has been applied.
     * @param {number|undefined} maximumPosition - If set, minimum time bound
     * in seconds after `deltaPosition` has been applied.
     */
    function reloadMediaSource(deltaPosition, minimumPosition, maximumPosition) {
      var _a, _b;
      var lastObservation = streamObserver.getReference().getValue();
      var currentPosition = (_a = lastObservation.position.pending) !== null && _a !== void 0 ? _a : streamObserver.getCurrentTime();
      var isPaused = (_b = lastObservation.paused.pending) !== null && _b !== void 0 ? _b : streamObserver.getIsPaused();
      var position = currentPosition + deltaPosition;
      if (minimumPosition !== undefined) {
        position = Math.max(minimumPosition, position);
      }
      if (maximumPosition !== undefined) {
        position = Math.min(maximumPosition, position);
      }
      onReloadOrder({
        position: position,
        autoPlay: !isPaused
      });
    }
  }
  /**
   * Creates a `ContentTimeBoundariesObserver`, a class indicating various
   * events related to media time (such as duration updates, period changes,
   * warnings about being out of the Manifest time boundaries or "endOfStream"
   * management), handle those events and returns the class.
   *
   * Various methods from that class need then to be called at various events
   * (see `ContentTimeBoundariesObserver`).
   * @param {Object} manifest
   * @param {MediaSource} mediaSource
   * @param {Object} streamObserver
   * @param {Object} segmentBuffersStore
   * @param {Object} cancelSignal
   * @returns {Object}
   */;
  _proto._createContentTimeBoundariesObserver = function _createContentTimeBoundariesObserver(manifest, mediaSource, streamObserver, segmentBuffersStore, cancelSignal) {
    var _this7 = this;
    /** Maintains the MediaSource's duration up-to-date with the Manifest */
    var mediaSourceDurationUpdater = new MediaSourceDurationUpdater(mediaSource);
    cancelSignal.register(function () {
      mediaSourceDurationUpdater.stopUpdating();
    });
    /** Allows to cancel a pending `end-of-stream` operation. */
    var endOfStreamCanceller = null;
    var contentTimeBoundariesObserver = new ContentTimeBoundariesObserver(manifest, streamObserver, segmentBuffersStore.getBufferTypes());
    cancelSignal.register(function () {
      contentTimeBoundariesObserver.dispose();
    });
    contentTimeBoundariesObserver.addEventListener("warning", function (err) {
      return _this7.trigger("warning", err);
    });
    contentTimeBoundariesObserver.addEventListener("periodChange", function (period) {
      _this7.trigger("activePeriodChanged", {
        period: period
      });
    });
    contentTimeBoundariesObserver.addEventListener("endingPositionChange", function (x) {
      return mediaSourceDurationUpdater.updateDuration(x.endingPosition, x.isEnd);
    });
    contentTimeBoundariesObserver.addEventListener("endOfStream", function () {
      if (endOfStreamCanceller === null) {
        endOfStreamCanceller = new task_canceller/* default */.Ay();
        endOfStreamCanceller.linkToSignal(cancelSignal);
        log/* default */.A.debug("Init: end-of-stream order received.");
        maintainEndOfStream(mediaSource, endOfStreamCanceller.signal);
      }
    });
    contentTimeBoundariesObserver.addEventListener("resumeStream", function () {
      if (endOfStreamCanceller !== null) {
        log/* default */.A.debug("Init: resume-stream order received.");
        endOfStreamCanceller.cancel();
        endOfStreamCanceller = null;
      }
    });
    var endInfo = contentTimeBoundariesObserver.getCurrentEndingTime();
    mediaSourceDurationUpdater.updateDuration(endInfo.endingPosition, endInfo.isEnd);
    return contentTimeBoundariesObserver;
  }
  /**
   * Creates a `RebufferingController`, a class trying to avoid various stalling
   * situations (such as rebuffering periods), and returns it.
   *
   * Various methods from that class need then to be called at various events
   * (see `RebufferingController` definition).
   *
   * This function also handles the `RebufferingController`'s events:
   *   - emit "stalled" events when stalling situations cannot be prevented,
   *   - emit "unstalled" events when we could get out of one,
   *   - emit "warning" on various rebuffering-related minor issues
   *     like discontinuity skipping.
   * @param {Object} playbackObserver
   * @param {Object} manifest
   * @param {Object} speed
   * @param {Object} cancelSignal
   * @returns {Object}
   */;
  _proto._createRebufferingController = function _createRebufferingController(playbackObserver, manifest, speed, cancelSignal) {
    var _this8 = this;
    var rebufferingController = new rebuffering_controller/* default */.A(playbackObserver, manifest, speed);
    // Bubble-up events
    rebufferingController.addEventListener("stalled", function (evt) {
      return _this8.trigger("stalled", evt);
    });
    rebufferingController.addEventListener("unstalled", function () {
      return _this8.trigger("unstalled", null);
    });
    rebufferingController.addEventListener("warning", function (err) {
      return _this8.trigger("warning", err);
    });
    cancelSignal.register(function () {
      return rebufferingController.destroy();
    });
    rebufferingController.start();
    return rebufferingController;
  };
  return MediaSourceContentInitializer;
}(init_types/* ContentInitializer */.Y);


/***/ }),

/***/ 4640:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Y: function() { return /* binding */ ContentInitializer; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7387);
/* harmony import */ var _utils_event_emitter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(79);

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Class allowing to start playing a content on an `HTMLMediaElement`.
 *
 * The actual constructor arguments depend on the `ContentInitializer` defined,
 * but should reflect all potential configuration wanted relative to this
 * content's playback.
 *
 * Various events may be emitted by a `ContentInitializer`. However, no event
 * should be emitted before `prepare` or `start` is called and no event should
 * be emitted after `dispose` is called.
 */
var ContentInitializer = /*#__PURE__*/function (_EventEmitter) {
  function ContentInitializer() {
    return _EventEmitter.apply(this, arguments) || this;
  }
  (0,_babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(ContentInitializer, _EventEmitter);
  return ContentInitializer;
}(_utils_event_emitter__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A);
// a decryption key)

/***/ }),

/***/ 5097:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: function() { return /* binding */ getLoadedReference; }
});

// EXTERNAL MODULE: ./src/compat/browser_detection.ts
var browser_detection = __webpack_require__(443);
;// CONCATENATED MODULE: ./src/compat/should_wait_for_data_before_loaded.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * On some browsers, the ready state might never go above `1` when autoplay is
 * blocked. On these cases, for now, we just advertise the content as "loaded".
 * We might go into BUFFERING just after that state, but that's a small price to
 * pay.
 * @param {Boolean} isDirectfile
 * @returns {Boolean}
 */
function shouldWaitForDataBeforeLoaded(isDirectfile) {
  if (isDirectfile && browser_detection/* isSafariMobile */.dX) {
    return false;
  } else {
    return true;
  }
}
;// CONCATENATED MODULE: ./src/compat/should_wait_for_have_enough_data.ts

/**
 * An `HTMLMediaElement`'s readyState allows the browser to communicate whether
 * it can play a content reliably.
 * Usually, we may consider that a `HAVE_FUTURE_DATA` (readyState `3`) or even
 * a `HAVE_CURRENT_DATA` (readyState `2`) is enough to begin playing the content
 * and consider it as loaded.
 *
 * However some devices wrongly anounce those readyStates before being actually
 * able to decode the content. For those devices we wait for the
 * `HAVE_ENOUGH_DATA` readyState before considering the content as loaded.
 * @returns {boolean}
 */
function shouldWaitForHaveEnoughData() {
  return browser_detection/* isPlayStation5 */.A7;
}
// EXTERNAL MODULE: ./src/compat/should_validate_metadata.ts
var should_validate_metadata = __webpack_require__(2097);
// EXTERNAL MODULE: ./src/utils/reference.ts
var reference = __webpack_require__(8315);
// EXTERNAL MODULE: ./src/utils/task_canceller.ts
var task_canceller = __webpack_require__(2507);
;// CONCATENATED MODULE: ./src/core/init/utils/get_loaded_reference.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Returns an `IReadOnlySharedReference` that switches to `true` once the
 * content is considered loaded (i.e. once it can begin to be played).
 * @param {Object} playbackObserver
 * @param {HTMLMediaElement} mediaElement
 * @param {boolean} isDirectfile - `true` if this is a directfile content
 * @param {Object} cancelSignal
 * @returns {Object}
 */
function getLoadedReference(playbackObserver, mediaElement, isDirectfile, cancelSignal) {
  var listenCanceller = new task_canceller/* default */.Ay();
  listenCanceller.linkToSignal(cancelSignal);
  var isLoaded = new reference/* default */.A(false, listenCanceller.signal);
  playbackObserver.listen(function (observation) {
    if (observation.rebuffering !== null || observation.freezing !== null || observation.readyState === 0) {
      return;
    }
    if (!shouldWaitForDataBeforeLoaded(isDirectfile)) {
      // The duration is NaN if no media data is available,
      // which means media is not loaded yet.
      if (isNaN(mediaElement.duration)) {
        return;
      }
      if (mediaElement.duration > 0) {
        isLoaded.setValue(true);
        listenCanceller.cancel();
        return;
      }
    }
    var minReadyState = shouldWaitForHaveEnoughData() ? 4 : 3;
    if (observation.readyState >= minReadyState) {
      if (observation.currentRange !== null || observation.ended) {
        if (!(0,should_validate_metadata/* default */.A)() || mediaElement.duration > 0) {
          isLoaded.setValue(true);
          listenCanceller.cancel();
          return;
        }
      }
    }
  }, {
    includeLastObservation: true,
    clearSignal: listenCanceller.signal
  });
  return isLoaded;
}

/***/ }),

/***/ 107:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: function() { return /* binding */ performInitialSeekAndPlay; }
});

// EXTERNAL MODULE: ./src/compat/should_validate_metadata.ts
var should_validate_metadata = __webpack_require__(2097);
// EXTERNAL MODULE: ./src/compat/browser_compatibility_types.ts
var browser_compatibility_types = __webpack_require__(9770);
// EXTERNAL MODULE: ./src/compat/browser_detection.ts
var browser_detection = __webpack_require__(443);
// EXTERNAL MODULE: ./src/compat/is_seeking_approximate.ts
var is_seeking_approximate = __webpack_require__(7913);
;// CONCATENATED MODULE: ./src/compat/should_prevent_seeking_at_0_initially.ts

/**
 * We noticed that on Xbox game consoles and Universal windows platforms
 * (presumably an Edge version is in cause here), the browser didn't send
 * a "seeking" event if we were seeking at a 0 position initially.
 *
 * We could theoretically never seek at 0 initially as the initial position of
 * an HTMLMediaElement should be at 0 anyway, but we still do it as a safe
 * solution, as many devices have a buggy integration of HTML5 media API.
 *
 * This function returns `true` when we should avoid doing so, for now only for
 * the non-standard behavior of those Edge platforms.
 * @returns {number}
 */
function shouldPreventSeekingAt0Initially() {
  return browser_detection/* isXbox */.qe || browser_detection/* isIEOrEdge */.h$;
}
// EXTERNAL MODULE: ./src/errors/media_error.ts
var media_error = __webpack_require__(5575);
// EXTERNAL MODULE: ./src/log.ts + 1 modules
var log = __webpack_require__(9477);
// EXTERNAL MODULE: ./src/utils/reference.ts
var reference = __webpack_require__(8315);
;// CONCATENATED MODULE: ./src/core/init/utils/initial_seek_and_play.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/* eslint-disable-next-line max-len */




/**
 * Seek as soon as possible at the initially wanted position and play if
 * autoPlay is wanted.
 * @param {HTMLMediaElement} mediaElement
 * @param {Object} playbackObserver
 * @param {number|Function} startTime
 * @param {boolean} mustAutoPlay
 * @param {Function} onWarning
 * @param {boolean} isDirectfile
 * @param {Object} cancelSignal
 * @returns {Object}
 */
function performInitialSeekAndPlay(mediaElement, playbackObserver, startTime, mustAutoPlay, onWarning, isDirectfile, cancelSignal) {
  var resolveAutoPlay;
  var rejectAutoPlay;
  var autoPlayResult = new Promise(function (res, rej) {
    resolveAutoPlay = res;
    rejectAutoPlay = rej;
  });
  var initialSeekPerformed = new reference/* default */.A(false, cancelSignal);
  var initialPlayPerformed = new reference/* default */.A(false, cancelSignal);
  mediaElement.addEventListener("loadedmetadata", onLoadedMetadata);
  var deregisterCancellation = cancelSignal.register(function (err) {
    mediaElement.removeEventListener("loadedmetadata", onLoadedMetadata);
    rejectAutoPlay(err);
  });
  if (mediaElement.readyState >= browser_compatibility_types/* READY_STATES */.t.HAVE_METADATA) {
    onLoadedMetadata();
  }
  return {
    autoPlayResult: autoPlayResult,
    initialPlayPerformed: initialPlayPerformed,
    initialSeekPerformed: initialSeekPerformed
  };
  function onLoadedMetadata() {
    mediaElement.removeEventListener("loadedmetadata", onLoadedMetadata);
    /** `true` if we asked the `PlaybackObserver` to perform an initial seek. */
    var hasAskedForInitialSeek = false;
    var performInitialSeek = function performInitialSeek(initialSeekTime) {
      log/* default */.A.info("Init: Set initial time", initialSeekTime);
      playbackObserver.setCurrentTime(initialSeekTime);
      hasAskedForInitialSeek = true;
      initialSeekPerformed.setValue(true);
      initialSeekPerformed.finish();
    };
    // `startTime` defined as a function might depend on metadata to make its
    // choice, such as the content duration, minimum and/or maximum position.
    //
    // The RxPlayer might already know those through the Manifest file for
    // non-Directfile contents, yet only through the `HTMLMediaElement` once a
    // a sufficient `readyState` has been reached for directfile contents.
    // So let's divide the two possibilities here.
    var initialTime = typeof startTime === "function" ? startTime() : startTime;
    if (initialTime === undefined && isDirectfile && mediaElement.readyState < HTMLMediaElement.HAVE_CURRENT_DATA) {
      /**
       * The starting position may not be known yet.
       * Postpone the seek to a moment where the starting position should be known,
       * assumely it's when readyState is greater or equal to HAVE_CURRENT_DATA (2).
       * If the initiallySeekedTime is still `undefined` when the readyState is >= 2,
       * let assume that the initiallySeekedTime will never be known and continue
       * the logic without seeking.
       */
      playbackObserver.listen(function (obs, stopListening) {
        if (obs.readyState >= HTMLMediaElement.HAVE_CURRENT_DATA) {
          var observationInitialTime = typeof startTime === "function" ? startTime() : startTime;
          if (observationInitialTime === undefined) {
            initialSeekPerformed.setValue(true);
            initialSeekPerformed.finish();
          } else if (isDirectfile && browser_detection/* isSafariMobile */.dX) {
            // On safari mobile (version 17.1.2) seeking too early cause the video
            // to never buffer media data. Using setTimeout 0 defers the seek
            // to a moment at which safari should be more able to handle a seek.
            setTimeout(function () {
              performInitialSeek(observationInitialTime);
            }, 0);
          } else {
            performInitialSeek(observationInitialTime);
          }
          stopListening();
        }
      });
    } else if (initialTime === undefined) {
      initialSeekPerformed.setValue(true);
      initialSeekPerformed.finish();
    } else if (shouldPreventSeekingAt0Initially() && initialTime === 0) {
      initialSeekPerformed.setValue(true);
      initialSeekPerformed.finish();
    } else if (isDirectfile && browser_detection/* isSafariMobile */.dX) {
      // On safari mobile (version 17.1.2) seeking too early cause the video
      // to never buffer media data. Using setTimeout 0 defers the seek
      // to a moment at which safari should be more able to handle a seek.
      setTimeout(function () {
        performInitialSeek(initialTime);
      }, 0);
    } else {
      performInitialSeek(initialTime);
    }
    if ((0,should_validate_metadata/* default */.A)() && mediaElement.duration === 0) {
      var error = new media_error/* default */.A("MEDIA_ERR_NOT_LOADED_METADATA", "Cannot load automatically: your browser " + "falsely announced having loaded the content.");
      onWarning(error);
    }
    if (cancelSignal.isCancelled()) {
      return;
    }
    /**
     * We only want to continue to `play` when a `seek` has actually been
     * performed (if it has been asked). This boolean keep track of if the
     * seek arised.
     */
    var isAwaitingSeek = hasAskedForInitialSeek;
    playbackObserver.listen(function (observation, stopListening) {
      if (hasAskedForInitialSeek && (observation.seeking || observation.event === "seeking" || observation.event === "internal-seeking")) {
        isAwaitingSeek = false;
        return;
      }
      if (!isAwaitingSeek && !observation.seeking && (is_seeking_approximate/* default */.A && observation.readyState >= 3 || observation.rebuffering === null) && observation.readyState >= 1) {
        stopListening();
        onPlayable();
      }
    }, {
      includeLastObservation: true,
      clearSignal: cancelSignal
    });
  }
  function onPlayable() {
    var _a;
    log/* default */.A.info("Init: Can begin to play content");
    if (!mustAutoPlay) {
      if (mediaElement.autoplay) {
        log/* default */.A.warn("Init: autoplay is enabled on HTML media element. " + "Media will play as soon as possible.");
      }
      initialPlayPerformed.setValue(true);
      initialPlayPerformed.finish();
      deregisterCancellation();
      return resolveAutoPlay({
        type: "skipped"
      });
    } else if (mediaElement.ended) {
      // the video has ended state to true, executing VideoElement.play() will
      // restart the video from the start, which is not wanted in most cases.
      // returning "skipped" prevents the call to play() and fix the issue
      log/* default */.A.warn("Init: autoplay is enabled but the video is ended. " + "Skipping autoplay to prevent video to start again");
      initialPlayPerformed.setValue(true);
      initialPlayPerformed.finish();
      deregisterCancellation();
      return resolveAutoPlay({
        type: "skipped"
      });
    }
    var playResult;
    try {
      playResult = (_a = mediaElement.play()) !== null && _a !== void 0 ? _a : Promise.resolve();
    } catch (playError) {
      deregisterCancellation();
      return rejectAutoPlay(playError);
    }
    playResult.then(function () {
      if (cancelSignal.isCancelled()) {
        return;
      }
      initialPlayPerformed.setValue(true);
      initialPlayPerformed.finish();
      deregisterCancellation();
      return resolveAutoPlay({
        type: "autoplay"
      });
    })["catch"](function (playError) {
      deregisterCancellation();
      if (cancelSignal.isCancelled()) {
        return;
      }
      if (playError instanceof Error && playError.name === "NotAllowedError") {
        // auto-play was probably prevented.
        log/* default */.A.warn("Init: Media element can't play." + " It may be due to browser auto-play policies.");
        var error = new media_error/* default */.A("MEDIA_ERR_BLOCKED_AUTOPLAY", "Cannot trigger auto-play automatically: " + "your browser does not allow it.");
        onWarning(error);
        if (cancelSignal.isCancelled()) {
          return;
        }
        return resolveAutoPlay({
          type: "autoplay-blocked"
        });
      } else {
        rejectAutoPlay(playError);
      }
    });
  }
}

/***/ }),

/***/ 6899:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: function() { return /* binding */ initializeContentDecryption; }
/* harmony export */ });
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(1956);
/* harmony import */ var _features__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(418);
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(9477);
/* harmony import */ var _utils_reference__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(8315);
/* harmony import */ var _utils_task_canceller__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2507);
/* harmony import */ var _decrypt__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(2137);






/**
 * Initialize content decryption capabilities on the given `HTMLMediaElement`.
 *
 * You can call this function even if you don't want decrytpion capabilities, in
 * which case you can just set the `keySystems` option as an empty array.
 * In this situation, the returned object will directly correspond to an
 * "`initialized`" state and the `onError` callback will be triggered as soon
 * as protection information is received.
 *
 * @param {HTMLMediaElement} mediaElement - `HTMLMediaElement` on which content
 * decryption may be wanted.
 * @param {Array.<Object>} keySystems - Key system configuration(s) wanted
 * Empty array if no content decryption capability is wanted.
 * @param {Object} protectionRef - Reference through which content
 * protection initialization data will be sent through.
 * @param {Object} callbacks - Callbacks called at various decryption-related
 * events.
 * @param {Object} cancelSignal - When that signal emits, this function will
 * stop listening to various events as well as items sent through the
 * `protectionRef` parameter.
 * @returns {Object} - Reference emitting the current status regarding DRM
 * initialization.
 */
function initializeContentDecryption(mediaElement, keySystems, protectionRef, callbacks, cancelSignal) {
  if (keySystems.length === 0) {
    return createEmeDisabledReference("No `keySystems` option given.");
  } else if (_features__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.decrypt === null) {
    return createEmeDisabledReference("EME feature not activated.");
  }
  var decryptorCanceller = new _utils_task_canceller__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Ay();
  decryptorCanceller.linkToSignal(cancelSignal);
  var drmStatusRef = new _utils_reference__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A({
    initializationState: {
      type: "uninitialized",
      value: null
    },
    drmSystemId: undefined
  }, cancelSignal);
  var ContentDecryptor = _features__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.decrypt;
  if (!ContentDecryptor.hasEmeApis()) {
    return createEmeDisabledReference("EME API not available on the current page.");
  }
  _log__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A.debug("Init: Creating ContentDecryptor");
  var contentDecryptor = new ContentDecryptor(mediaElement, keySystems);
  contentDecryptor.addEventListener("stateChange", function (state) {
    if (state === _decrypt__WEBPACK_IMPORTED_MODULE_4__/* .ContentDecryptorState */ .R.WaitingForAttachment) {
      var isMediaLinked = new _utils_reference__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A(false);
      isMediaLinked.onUpdate(function (isAttached, stopListening) {
        if (isAttached) {
          stopListening();
          if (state === _decrypt__WEBPACK_IMPORTED_MODULE_4__/* .ContentDecryptorState */ .R.WaitingForAttachment) {
            contentDecryptor.attach();
          }
        }
      }, {
        clearSignal: decryptorCanceller.signal
      });
      drmStatusRef.setValue({
        initializationState: {
          type: "awaiting-media-link",
          value: {
            isMediaLinked: isMediaLinked
          }
        },
        drmSystemId: contentDecryptor.systemId
      });
    } else if (state === _decrypt__WEBPACK_IMPORTED_MODULE_4__/* .ContentDecryptorState */ .R.ReadyForContent) {
      drmStatusRef.setValue({
        initializationState: {
          type: "initialized",
          value: null
        },
        drmSystemId: contentDecryptor.systemId
      });
      contentDecryptor.removeEventListener("stateChange");
    }
  });
  contentDecryptor.addEventListener("error", function (error) {
    decryptorCanceller.cancel();
    callbacks.onError(error);
  });
  contentDecryptor.addEventListener("warning", function (error) {
    callbacks.onWarning(error);
  });
  protectionRef.onUpdate(function (data) {
    if (data === null) {
      return;
    }
    contentDecryptor.onInitializationData(data);
  }, {
    clearSignal: decryptorCanceller.signal
  });
  decryptorCanceller.signal.register(function () {
    contentDecryptor.dispose();
  });
  return drmStatusRef;
  function createEmeDisabledReference(errMsg) {
    protectionRef.onUpdate(function (data, stopListening) {
      if (data === null) {
        // initial value
        return;
      }
      stopListening();
      var err = new _errors__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A("MEDIA_IS_ENCRYPTED_ERROR", errMsg);
      callbacks.onError(err);
    }, {
      clearSignal: cancelSignal
    });
    var ref = new _utils_reference__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A({
      initializationState: {
        type: "initialized",
        value: null
      },
      drmSystemId: undefined
    });
    ref.finish(); // We know that no new value will be triggered
    return ref;
  }
}

/***/ }),

/***/ 3137:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: function() { return /* binding */ RebufferingController; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7387);
/* harmony import */ var _compat_is_seeking_approximate__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7913);
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5151);
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(5575);
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(9477);
/* harmony import */ var _utils_event_emitter__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(79);
/* harmony import */ var _utils_ranges__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(3650);
/* harmony import */ var _utils_task_canceller__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2507);

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */







/**
 * Work-around rounding errors with floating points by setting an acceptable,
 * very short, deviation when checking equalities.
 */
var EPSILON = 1 / 60;
/**
 * Monitor playback, trying to avoid stalling situation.
 * If stopping the player to build buffer is needed, temporarily set the
 * playback rate (i.e. speed) at `0` until enough buffer is available again.
 *
 * Emit "stalled" then "unstalled" respectively when an unavoidable stall is
 * encountered and exited.
 */
var RebufferingController = /*#__PURE__*/function (_EventEmitter) {
  /**
   * @param {object} playbackObserver - emit the current playback conditions.
   * @param {Object} manifest - The Manifest of the currently-played content.
   * @param {Object} speed - The last speed set by the user
   */
  function RebufferingController(playbackObserver, manifest, speed) {
    var _this;
    _this = _EventEmitter.call(this) || this;
    _this._playbackObserver = playbackObserver;
    _this._manifest = manifest;
    _this._speed = speed;
    _this._discontinuitiesStore = [];
    _this._isStarted = false;
    _this._canceller = new _utils_task_canceller__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay();
    return _this;
  }
  (0,_babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(RebufferingController, _EventEmitter);
  var _proto = RebufferingController.prototype;
  _proto.start = function start() {
    var _this2 = this;
    if (this._isStarted) {
      return;
    }
    this._isStarted = true;
    /**
     * On some devices (right now only seen on Tizen), seeking through the
     * `currentTime` property can lead to the browser re-seeking once the
     * segments have been loaded to improve seeking performances (for
     * example, by seeking right to an intra video frame).
     * In that case, we risk being in a conflict with that behavior: if for
     * example we encounter a small discontinuity at the position the browser
     * seeks to, we will seek over it, the browser would seek back and so on.
     *
     * This variable allows to store the last known position we were seeking to
     * so we can detect when the browser seeked back (to avoid performing another
     * seek after that). When browsers seek back to a position behind a
     * discontinuity, they are usually able to skip them without our help.
     */
    var lastSeekingPosition;
    /**
     * In some conditions (see `lastSeekingPosition`), we might want to not
     * automatically seek over discontinuities because the browser might do it
     * itself instead.
     * In that case, we still want to perform the seek ourselves if the browser
     * doesn't do it after sufficient time.
     * This variable allows to store the timestamp at which a discontinuity began
     * to be ignored.
     */
    var ignoredStallTimeStamp = null;
    var playbackRateUpdater = new PlaybackRateUpdater(this._playbackObserver, this._speed);
    this._canceller.signal.register(function () {
      playbackRateUpdater.dispose();
    });
    var prevFreezingState = null;
    this._playbackObserver.listen(function (observation) {
      var _a;
      var discontinuitiesStore = _this2._discontinuitiesStore;
      var buffered = observation.buffered,
        position = observation.position,
        readyState = observation.readyState,
        rebuffering = observation.rebuffering,
        freezing = observation.freezing;
      var _config$getCurrent = _config__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A.getCurrent(),
        BUFFER_DISCONTINUITY_THRESHOLD = _config$getCurrent.BUFFER_DISCONTINUITY_THRESHOLD,
        FORCE_DISCONTINUITY_SEEK_DELAY = _config$getCurrent.FORCE_DISCONTINUITY_SEEK_DELAY,
        FREEZING_STALLED_DELAY = _config$getCurrent.FREEZING_STALLED_DELAY,
        UNFREEZING_SEEK_DELAY = _config$getCurrent.UNFREEZING_SEEK_DELAY,
        UNFREEZING_DELTA_POSITION = _config$getCurrent.UNFREEZING_DELTA_POSITION;
      if (!observation.seeking && _compat_is_seeking_approximate__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A && ignoredStallTimeStamp === null && lastSeekingPosition !== null && observation.position < lastSeekingPosition) {
        _log__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A.debug("Init: the device appeared to have seeked back by itself.");
        var now = performance.now();
        ignoredStallTimeStamp = now;
      }
      lastSeekingPosition = observation.seeking ? Math.max((_a = observation.pendingInternalSeek) !== null && _a !== void 0 ? _a : 0, observation.position) : null;
      if (freezing !== null) {
        var _now = performance.now();
        var referenceTimestamp = prevFreezingState === null ? freezing.timestamp : prevFreezingState.attemptTimestamp;
        if (_now - referenceTimestamp > UNFREEZING_SEEK_DELAY) {
          _log__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A.warn("Init: trying to seek to un-freeze player");
          _this2._playbackObserver.setCurrentTime(_this2._playbackObserver.getCurrentTime() + UNFREEZING_DELTA_POSITION);
          prevFreezingState = {
            attemptTimestamp: _now
          };
        }
        if (_now - freezing.timestamp > FREEZING_STALLED_DELAY) {
          if (rebuffering === null || ignoredStallTimeStamp !== null) {
            playbackRateUpdater.stopRebuffering();
          } else {
            playbackRateUpdater.startRebuffering();
          }
          _this2.trigger("stalled", "freezing");
          return;
        }
      } else {
        prevFreezingState = null;
      }
      if (rebuffering === null) {
        playbackRateUpdater.stopRebuffering();
        if (readyState === 1) {
          // With a readyState set to 1, we should still not be able to play:
          // Return that we're stalled
          var reason;
          if (observation.seeking) {
            reason = observation.pendingInternalSeek !== null ? "internal-seek" : "seeking";
          } else {
            reason = "not-ready";
          }
          _this2.trigger("stalled", reason);
          return;
        }
        _this2.trigger("unstalled", null);
        return;
      }
      // We want to separate a stall situation when a seek is due to a seek done
      // internally by the player to when its due to a regular user seek.
      var stalledReason = rebuffering.reason === "seeking" && observation.pendingInternalSeek !== null ? "internal-seek" : rebuffering.reason;
      if (ignoredStallTimeStamp !== null) {
        var _now2 = performance.now();
        if (_now2 - ignoredStallTimeStamp < FORCE_DISCONTINUITY_SEEK_DELAY) {
          playbackRateUpdater.stopRebuffering();
          _log__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A.debug("Init: letting the device get out of a stall by itself");
          _this2.trigger("stalled", stalledReason);
          return;
        } else {
          _log__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A.warn("Init: ignored stall for too long, checking discontinuity", _now2 - ignoredStallTimeStamp);
        }
      }
      ignoredStallTimeStamp = null;
      playbackRateUpdater.startRebuffering();
      if (_this2._manifest === null) {
        _this2.trigger("stalled", stalledReason);
        return;
      }
      /** Position at which data is awaited. */
      var stalledPosition = rebuffering.position;
      if (stalledPosition !== null && stalledPosition !== undefined && _this2._speed.getValue() > 0) {
        var skippableDiscontinuity = findSeekableDiscontinuity(discontinuitiesStore, _this2._manifest, stalledPosition);
        if (skippableDiscontinuity !== null) {
          var realSeekTime = skippableDiscontinuity + 0.001;
          if (realSeekTime <= _this2._playbackObserver.getCurrentTime()) {
            _log__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A.info("Init: position to seek already reached, no seeking", _this2._playbackObserver.getCurrentTime(), realSeekTime);
          } else {
            _log__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A.warn("SA: skippable discontinuity found in the stream", position, realSeekTime);
            _this2._playbackObserver.setCurrentTime(realSeekTime);
            _this2.trigger("warning", generateDiscontinuityError(stalledPosition, realSeekTime));
            return;
          }
        }
      }
      var freezePosition = stalledPosition !== null && stalledPosition !== void 0 ? stalledPosition : position;
      // Is it a very short discontinuity in buffer ? -> Seek at the beginning of the
      //                                                 next range
      //
      // Discontinuity check in case we are close a buffered range but still
      // calculate a stalled state. This is useful for some
      // implementation that might drop an injected segment, or in
      // case of small discontinuity in the content.
      var nextBufferRangeGap = (0,_utils_ranges__WEBPACK_IMPORTED_MODULE_5__/* .getNextRangeGap */ .Td)(buffered, freezePosition);
      if (_this2._speed.getValue() > 0 && nextBufferRangeGap < BUFFER_DISCONTINUITY_THRESHOLD) {
        var seekTo = freezePosition + nextBufferRangeGap + EPSILON;
        if (_this2._playbackObserver.getCurrentTime() < seekTo) {
          _log__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A.warn("Init: discontinuity encountered inferior to the threshold", freezePosition, seekTo, BUFFER_DISCONTINUITY_THRESHOLD);
          _this2._playbackObserver.setCurrentTime(seekTo);
          _this2.trigger("warning", generateDiscontinuityError(freezePosition, seekTo));
          return;
        }
      }
      // Are we in a discontinuity between periods ? -> Seek at the beginning of the
      //                                                next period
      for (var i = _this2._manifest.periods.length - 2; i >= 0; i--) {
        var period = _this2._manifest.periods[i];
        if (period.end !== undefined && period.end <= freezePosition) {
          if (_this2._manifest.periods[i + 1].start > freezePosition && _this2._manifest.periods[i + 1].start > _this2._playbackObserver.getCurrentTime()) {
            var nextPeriod = _this2._manifest.periods[i + 1];
            _this2._playbackObserver.setCurrentTime(nextPeriod.start);
            _this2.trigger("warning", generateDiscontinuityError(freezePosition, nextPeriod.start));
            return;
          }
          break;
        }
      }
      _this2.trigger("stalled", stalledReason);
    }, {
      includeLastObservation: true,
      clearSignal: this._canceller.signal
    });
  }
  /**
   * Update information on an upcoming discontinuity for a given buffer type and
   * Period.
   * Each new update for the same Period and type overwrites the previous one.
   * @param {Object} evt
   */;
  _proto.updateDiscontinuityInfo = function updateDiscontinuityInfo(evt) {
    if (!this._isStarted) {
      this.start();
    }
    var lastObservation = this._playbackObserver.getReference().getValue();
    updateDiscontinuitiesStore(this._discontinuitiesStore, evt, lastObservation);
  }
  /**
   * Function to call when a Stream is currently locked, i.e. we cannot load
   * segments for the corresponding Period and buffer type until it is seeked
   * to.
   * @param {string} bufferType - Buffer type for which no segment will
   * currently load.
   * @param {Object} period - Period for which no segment will currently load.
   */;
  _proto.onLockedStream = function onLockedStream(bufferType, period) {
    var _a;
    if (!this._isStarted) {
      this.start();
    }
    var observation = this._playbackObserver.getReference().getValue();
    if (!observation.rebuffering || observation.paused || this._speed.getValue() <= 0 || bufferType !== "audio" && bufferType !== "video") {
      return;
    }
    var currPos = observation.position;
    var rebufferingPos = (_a = observation.rebuffering.position) !== null && _a !== void 0 ? _a : currPos;
    var lockedPeriodStart = period.start;
    if (currPos < lockedPeriodStart && Math.abs(rebufferingPos - lockedPeriodStart) < 1) {
      _log__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A.warn("Init: rebuffering because of a future locked stream.\n" + "Trying to unlock by seeking to the next Period");
      this._playbackObserver.setCurrentTime(lockedPeriodStart + 0.001);
    }
  }
  /**
   * Stops the `RebufferingController` from montoring stalling situations,
   * forever.
   */;
  _proto.destroy = function destroy() {
    this._canceller.cancel();
  };
  return RebufferingController;
}(_utils_event_emitter__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A);
/**
 * @param {Array.<Object>} discontinuitiesStore
 * @param {Object} manifest
 * @param {number} stalledPosition
 * @returns {number|null}
 */

function findSeekableDiscontinuity(discontinuitiesStore, manifest, stalledPosition) {
  if (discontinuitiesStore.length === 0) {
    return null;
  }
  var maxDiscontinuityEnd = null;
  for (var i = 0; i < discontinuitiesStore.length; i++) {
    var period = discontinuitiesStore[i].period;
    if (period.start > stalledPosition) {
      return maxDiscontinuityEnd;
    }
    var discontinuityEnd = void 0;
    if (period.end === undefined || period.end > stalledPosition) {
      var _discontinuitiesStore = discontinuitiesStore[i],
        discontinuity = _discontinuitiesStore.discontinuity,
        position = _discontinuitiesStore.position;
      var start = discontinuity.start,
        end = discontinuity.end;
      var discontinuityLowerLimit = start !== null && start !== void 0 ? start : position;
      if (stalledPosition >= discontinuityLowerLimit - EPSILON) {
        if (end === null) {
          var nextPeriod = manifest.getPeriodAfter(period);
          if (nextPeriod !== null) {
            discontinuityEnd = nextPeriod.start + EPSILON;
          } else {
            _log__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A.warn("Init: discontinuity at Period's end but no next Period");
          }
        } else if (stalledPosition < end + EPSILON) {
          discontinuityEnd = end + EPSILON;
        }
      }
      if (discontinuityEnd !== undefined) {
        _log__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A.info("Init: discontinuity found", stalledPosition, discontinuityEnd);
        maxDiscontinuityEnd = maxDiscontinuityEnd !== null && maxDiscontinuityEnd > discontinuityEnd ? maxDiscontinuityEnd : discontinuityEnd;
      }
    }
  }
  return maxDiscontinuityEnd;
}
/**
 * Return `true` if the given event indicates that a discontinuity is present.
 * @param {Object} evt
 * @returns {Array.<Object>}
 */
function eventContainsDiscontinuity(evt) {
  return evt.discontinuity !== null;
}
/**
 * Update the `discontinuitiesStore` Object with the given event information:
 *
 *   - If that event indicates than no discontinuity is found for a Period
 *     and buffer type, remove a possible existing discontinuity for that
 *     combination.
 *
 *   - If that event indicates that a discontinuity can be found for a Period
 *     and buffer type, replace previous occurences for that combination and
 *     store it in Period's chronological order in the Array.
 * @param {Array.<Object>} discontinuitiesStore
 * @param {Object} evt
 * @param {Object} observation
 * @returns {Array.<Object>}
 */
function updateDiscontinuitiesStore(discontinuitiesStore, evt, observation) {
  // First, perform clean-up of old discontinuities
  while (discontinuitiesStore.length > 0 && discontinuitiesStore[0].period.end !== undefined && discontinuitiesStore[0].period.end + 10 < observation.position) {
    discontinuitiesStore.shift();
  }
  var period = evt.period,
    bufferType = evt.bufferType;
  if (bufferType !== "audio" && bufferType !== "video") {
    return;
  }
  for (var i = 0; i < discontinuitiesStore.length; i++) {
    if (discontinuitiesStore[i].period.id === period.id) {
      if (discontinuitiesStore[i].bufferType === bufferType) {
        if (!eventContainsDiscontinuity(evt)) {
          discontinuitiesStore.splice(i, 1);
        } else {
          discontinuitiesStore[i] = evt;
        }
        return;
      }
    } else if (discontinuitiesStore[i].period.start > period.start) {
      if (eventContainsDiscontinuity(evt)) {
        discontinuitiesStore.splice(i, 0, evt);
      }
      return;
    }
  }
  if (eventContainsDiscontinuity(evt)) {
    discontinuitiesStore.push(evt);
  }
  return;
}
/**
 * Generate error emitted when a discontinuity has been encountered.
 * @param {number} stalledPosition
 * @param {number} seekTo
 * @returns {Error}
 */
function generateDiscontinuityError(stalledPosition, seekTo) {
  return new _errors__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .A("DISCONTINUITY_ENCOUNTERED", "A discontinuity has been encountered at position " + String(stalledPosition) + ", seeked at position " + String(seekTo));
}
/**
 * Manage playback speed, allowing to force a playback rate of `0` when
 * rebuffering is wanted.
 *
 * Only one `PlaybackRateUpdater` should be created per HTMLMediaElement.
 * Note that the `PlaybackRateUpdater` reacts to playback event and wanted
 * speed change. You should call its `dispose` method once you don't need it
 * anymore.
 * @class PlaybackRateUpdater
 */
var PlaybackRateUpdater = /*#__PURE__*/function () {
  /**
   * Create a new `PlaybackRateUpdater`.
   * @param {Object} playbackObserver
   * @param {Object} speed
   */
  function PlaybackRateUpdater(playbackObserver, speed) {
    this._speedUpdateCanceller = new _utils_task_canceller__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay();
    this._isRebuffering = false;
    this._playbackObserver = playbackObserver;
    this._isDisposed = false;
    this._speed = speed;
    this._updateSpeed();
  }
  /**
   * Force the playback rate to `0`, to start a rebuffering phase.
   *
   * You can call `stopRebuffering` when you want the rebuffering phase to end.
   */
  var _proto2 = PlaybackRateUpdater.prototype;
  _proto2.startRebuffering = function startRebuffering() {
    if (this._isRebuffering || this._isDisposed) {
      return;
    }
    this._isRebuffering = true;
    this._speedUpdateCanceller.cancel();
    _log__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A.info("Init: Pause playback to build buffer");
    this._playbackObserver.setPlaybackRate(0);
  }
  /**
   * If in a rebuffering phase (during which the playback rate is forced to
   * `0`), exit that phase to apply the wanted playback rate instead.
   *
   * Do nothing if not in a rebuffering phase.
   */;
  _proto2.stopRebuffering = function stopRebuffering() {
    if (!this._isRebuffering || this._isDisposed) {
      return;
    }
    this._isRebuffering = false;
    this._speedUpdateCanceller = new _utils_task_canceller__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay();
    this._updateSpeed();
  }
  /**
   * The `PlaybackRateUpdater` allocate resources to for example listen to
   * wanted speed changes and react to it.
   *
   * Consequently, you should call the `dispose` method, when you don't want the
   * `PlaybackRateUpdater` to have an effect anymore.
   */;
  _proto2.dispose = function dispose() {
    this._speedUpdateCanceller.cancel();
    this._isDisposed = true;
  };
  _proto2._updateSpeed = function _updateSpeed() {
    var _this3 = this;
    this._speed.onUpdate(function (lastSpeed) {
      _log__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A.info("Init: Resume playback speed", lastSpeed);
      _this3._playbackObserver.setPlaybackRate(lastSpeed);
    }, {
      clearSignal: this._speedUpdateCanceller.signal,
      emitCurrentValue: true
    });
  };
  return PlaybackRateUpdater;
}();

/***/ }),

/***/ 8345:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: function() { return /* binding */ listenToMediaError; }
/* harmony export */ });
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5575);
/* harmony import */ var _utils_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6787);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @param {HTMLMediaElement} mediaElement
 * @param {Function} onError
 * @param {Object} cancelSignal
 */
function listenToMediaError(mediaElement, onError, cancelSignal) {
  if (cancelSignal.isCancelled()) {
    return;
  }
  mediaElement.addEventListener("error", onMediaError);
  cancelSignal.register(function () {
    mediaElement.removeEventListener("error", onMediaError);
  });
  function onMediaError() {
    var mediaError = mediaElement.error;
    var errorCode;
    var errorMessage;
    if (!(0,_utils_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(mediaError)) {
      errorCode = mediaError.code;
      errorMessage = mediaError.message;
    }
    switch (errorCode) {
      case 1:
        errorMessage = errorMessage !== null && errorMessage !== void 0 ? errorMessage : "The fetching of the associated resource was aborted by the user's request.";
        return onError(new _errors__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A("MEDIA_ERR_ABORTED", errorMessage));
      case 2:
        errorMessage = errorMessage !== null && errorMessage !== void 0 ? errorMessage : "A network error occurred which prevented the media from being " + "successfully fetched";
        return onError(new _errors__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A("MEDIA_ERR_NETWORK", errorMessage));
      case 3:
        errorMessage = errorMessage !== null && errorMessage !== void 0 ? errorMessage : "An error occurred while trying to decode the media resource";
        return onError(new _errors__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A("MEDIA_ERR_DECODE", errorMessage));
      case 4:
        errorMessage = errorMessage !== null && errorMessage !== void 0 ? errorMessage : "The media resource has been found to be unsuitable.";
        return onError(new _errors__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A("MEDIA_ERR_SRC_NOT_SUPPORTED", errorMessage));
      default:
        errorMessage = errorMessage !== null && errorMessage !== void 0 ? errorMessage : "The HTMLMediaElement errored due to an unknown reason.";
        return onError(new _errors__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A("MEDIA_ERR_UNKNOWN", errorMessage));
    }
  }
}

/***/ }),

/***/ 4166:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: function() { return /* binding */ implementations_image; }
});

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js
var inheritsLoose = __webpack_require__(7387);
// EXTERNAL MODULE: ./src/log.ts + 1 modules
var log = __webpack_require__(9477);
// EXTERNAL MODULE: ./src/core/segment_buffers/implementations/types.ts + 3 modules
var types = __webpack_require__(7500);
// EXTERNAL MODULE: ./src/core/segment_buffers/implementations/utils/manual_time_ranges.ts
var manual_time_ranges = __webpack_require__(3481);
;// CONCATENATED MODULE: ./src/core/segment_buffers/implementations/image/image_segment_buffer.ts

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Image SegmentBuffer implementation.
 * @class ImageSegmentBuffer
 */
var ImageSegmentBuffer = /*#__PURE__*/function (_SegmentBuffer) {
  function ImageSegmentBuffer() {
    var _this;
    log/* default */.A.debug("ISB: Creating ImageSegmentBuffer");
    _this = _SegmentBuffer.call(this) || this;
    _this.bufferType = "image";
    _this._buffered = new manual_time_ranges/* default */.A();
    return _this;
  }
  /**
   * @param {string} uniqueId
   */
  (0,inheritsLoose/* default */.A)(ImageSegmentBuffer, _SegmentBuffer);
  var _proto = ImageSegmentBuffer.prototype;
  _proto.declareInitSegment = function declareInitSegment(uniqueId) {
    log/* default */.A.warn("ISB: Declaring initialization segment for image SegmentBuffer", uniqueId);
  }
  /**
   * @param {string} uniqueId
   */;
  _proto.freeInitSegment = function freeInitSegment(uniqueId) {
    log/* default */.A.warn("ISB: Freeing initialization segment for image SegmentBuffer", uniqueId);
  }
  /**
   * @param {Object} data
   * @returns {Promise}
   */;
  _proto.pushChunk = function pushChunk(infos) {
    var _a, _b;
    log/* default */.A.debug("ISB: appending new data.");
    if (infos.data.chunk === null) {
      return Promise.resolve();
    }
    var _infos$data = infos.data,
      appendWindow = _infos$data.appendWindow,
      chunk = _infos$data.chunk;
    // The following check is ugly. I don't care, the image buffer is there
    // due to an ugly deprecated API that will soon disappear
    var start = chunk.start,
      end = chunk.end,
      timescale = chunk.timescale;
    var appendWindowStart = (_a = appendWindow[0]) !== null && _a !== void 0 ? _a : 0;
    var appendWindowEnd = (_b = appendWindow[1]) !== null && _b !== void 0 ? _b : Infinity;
    var timescaledStart = start / timescale;
    var timescaledEnd = end / timescale;
    var startTime = Math.max(appendWindowStart, timescaledStart);
    var endTime = Math.min(appendWindowEnd, timescaledEnd);
    try {
      this._buffered.insert(startTime, endTime);
      if (infos.inventoryInfos !== null) {
        this._segmentInventory.insertChunk(infos.inventoryInfos, true, performance.now());
      }
    } catch (err) {
      return Promise.reject(err);
    }
    return Promise.resolve();
  }
  /**
   * @param {Number} from
   * @param {Number} to
   * @returns {Promise}
   */;
  _proto.removeBuffer = function removeBuffer(start, end) {
    log/* default */.A.info("ISB: ignored image data remove order", start, end);
    // Logic removed as it caused more problems than it resolved:
    // Image thumbnails are always downloaded as a single BIF file, meaning that
    // any removing might necessitate to re-load the whole file in the future
    // which seems pointless.
    // In any case, image handling through the regular RxPlayer APIs has been
    // completely deprecated now for several reasons, and should disappear in
    // the next major version.
    return Promise.resolve();
  }
  /**
   * Indicate that every chunks from a Segment has been given to pushChunk so
   * far.
   * This will update our internal Segment inventory accordingly.
   * The returned Promise will resolve once the whole segment has been pushed
   * and this indication is acknowledged.
   * @param {Object} _infos
   * @returns {Promise}
   */;
  _proto.endOfSegment = function endOfSegment(_infos) {
    this._segmentInventory.completeSegment(_infos, this._buffered);
    return Promise.resolve();
  }
  /**
   * Returns the currently buffered data, in a TimeRanges object.
   * @returns {TimeRanges}
   */;
  _proto.getBufferedRanges = function getBufferedRanges() {
    return this._buffered;
  };
  _proto.dispose = function dispose() {
    log/* default */.A.debug("ISB: disposing image SegmentBuffer");
    this._buffered.remove(0, Infinity);
  };
  return ImageSegmentBuffer;
}(types/* SegmentBuffer */.K);

;// CONCATENATED MODULE: ./src/core/segment_buffers/implementations/image/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ var implementations_image = (ImageSegmentBuffer);

/***/ }),

/***/ 7938:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: function() { return /* binding */ html; }
});

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js
var inheritsLoose = __webpack_require__(7387);
// EXTERNAL MODULE: ./src/compat/event_listeners.ts
var event_listeners = __webpack_require__(5121);
// EXTERNAL MODULE: ./src/log.ts + 1 modules
var log = __webpack_require__(9477);
// EXTERNAL MODULE: ./src/utils/reference.ts
var reference = __webpack_require__(8315);
// EXTERNAL MODULE: ./src/compat/is_node.ts
var is_node = __webpack_require__(2186);
;// CONCATENATED MODULE: ./src/compat/on_height_width_change.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/* eslint-disable @typescript-eslint/no-unsafe-member-access */
/* eslint-disable @typescript-eslint/no-unsafe-assignment */
var _ResizeObserver = is_node/* default */.A ? undefined : window.ResizeObserver;
/* eslint-enable @typescript-eslint/no-unsafe-member-access */
/* eslint-enable @typescript-eslint/no-unsafe-assignment */
/**
 * Emit the current height and width of the given `element` each time it
 * changes.
 *
 * On some browsers, we might not be able to rely on a native API to know when
 * it changes, the `interval` argument allow us to provide us an inverval in
 * milliseconds at which we should query that element's size.
 * @param {HTMLElement} element
 * @param {number} interval
 * @returns {Object}
 */
function onHeightWidthChange(element, interval, cancellationSignal) {
  var _element$getBoundingC = element.getBoundingClientRect(),
    initHeight = _element$getBoundingC.height,
    initWidth = _element$getBoundingC.width;
  var ref = new reference/* default */.A({
    height: initHeight,
    width: initWidth
  }, cancellationSignal);
  var lastHeight = initHeight;
  var lastWidth = initWidth;
  if (_ResizeObserver !== undefined) {
    var resizeObserver = new _ResizeObserver(function (entries) {
      if (entries.length === 0) {
        log/* default */.A.error("Compat: Resized but no observed element.");
        return;
      }
      var entry = entries[0];
      var _entry$contentRect = entry.contentRect,
        height = _entry$contentRect.height,
        width = _entry$contentRect.width;
      if (height !== lastHeight || width !== lastWidth) {
        lastHeight = height;
        lastWidth = width;
        ref.setValue({
          height: height,
          width: width
        });
      }
    });
    resizeObserver.observe(element);
    cancellationSignal.register(function () {
      resizeObserver.disconnect();
    });
  } else {
    var intervalId = setInterval(function () {
      var _element$getBoundingC2 = element.getBoundingClientRect(),
        height = _element$getBoundingC2.height,
        width = _element$getBoundingC2.width;
      if (height !== lastHeight || width !== lastWidth) {
        lastHeight = height;
        lastWidth = width;
        ref.setValue({
          height: height,
          width: width
        });
      }
    }, interval);
    cancellationSignal.register(function () {
      clearInterval(intervalId);
    });
  }
  return ref;
}
// EXTERNAL MODULE: ./src/config.ts + 2 modules
var config = __webpack_require__(5151);
// EXTERNAL MODULE: ./src/utils/task_canceller.ts
var task_canceller = __webpack_require__(2507);
// EXTERNAL MODULE: ./src/core/segment_buffers/implementations/types.ts + 3 modules
var types = __webpack_require__(7500);
// EXTERNAL MODULE: ./src/core/segment_buffers/implementations/utils/manual_time_ranges.ts
var manual_time_ranges = __webpack_require__(3481);
// EXTERNAL MODULE: ./src/features/index.ts
var features = __webpack_require__(418);
;// CONCATENATED MODULE: ./src/core/segment_buffers/implementations/text/html/parsers.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Convert text track data into timed HTML Cues.
 * @param {string} type - Text track format wanted
 * @param {string} data - Text track data
 * @param {Number} timestampOffset - offset to apply to every timed text
 * @param {string} [language] - language of the text tracks
 * @returns {Array.<Object>}
 * @throws Error - Throw if no parser is found for the given type
 */
function parseTextTrackToElements(type, data, timestampOffset, language) {
  log/* default */.A.debug("HTSB: Finding parser for html text tracks:", type);
  var parser = features/* default */.A.htmlTextTracksParsers[type];
  if (typeof parser !== "function") {
    throw new Error("no parser found for the given text track");
  }
  log/* default */.A.debug("HTSB: Parser found, parsing...");
  var parsed = parser(data, timestampOffset, language);
  log/* default */.A.debug("HTTB: Parsed successfully!", parsed.length);
  return parsed;
}
;// CONCATENATED MODULE: ./src/core/segment_buffers/implementations/text/html/utils.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Maximum time difference, in seconds, between two text segment's start times
 * and/or end times for them to be considered the same in the
 * HTMLTextSegmentBuffer (used for the "html" textTrackMode).
 *
 * For example for two segments s1 and s2 which have a start time respectively
 * of st1 and st2 and end time of et1 and et2:
 *   - if both the absolute difference between st1 and st2 AND the one between
 *     et1 and et2 is inferior or equal to the MAX_DELTA_BUFFER_TIME, s1 and s2
 *     are considered to target the exact same time. As a consequence, if s2 is
 *     added after s1 in the buffer, s1 will be completely replaced by it and
 *     vice-versa.
 *   - if only one of the two (absolute difference between st1 and st2 OR et1
 *     and et2) is inferior to the MAX_DELTA_BUFFER_TIME then the last added
 *     is not completely considered the same. It WILL still replace - either
 *     partially or completely (depending on the sign of the other difference) -
 *     the previously added segment.
 *   - if both differences are strictly superior to the MAX_DELTA_BUFFER_TIME,
 *     then they are not considered to have the same start nor the same end.
 *     They can still overlap however, and MIGHT thus still replace partially
 *     or completely each other.
 *
 * Setting a value too low might lead to two segments targeting the same time,
 * both being present in the buffer. In worst case scenarios, this could lead
 * to indicate that an unwanted text track is still here (theorically though,
 * this is a case that should never happen for reasons that might be too long
 * to explain here).
 *
 * Setting a value too high might lead to two segments targeting different times
 * to be wrongly believed to target the same time. In worst case scenarios, this
 * could lead to wanted text tracks being removed.
 *
 * When comparing 2 segments s1 and s2, you may want to take into account the duration
 * of the segments:
 *   - if s1 is [0, 2] and s2 is [0, 2.1] s1 and s2 can be considered as nearly equal as
 *     there is a relative difference of: (2.1-2) / 2 = 5%;
 *     Formula: (end_s1 - end_s2) / duration_s2 = relative_difference
 *   - if s1 is [0, 0.04] and s2 is [0.04, 0.08] s1 and s2 may not considered as nearly
 *     equal as there is a relative difference of: (0.04-0.08) / 0.04 = 100%
 *
 * To compare relatively to the duration of a segment you can provide and additional
 * parameter "delta" that remplace MAX_DELTA_BUFFER_TIME.
 * If parameter "delta" is higher than MAX_DELTA_BUFFER_TIME, MAX_DELTA_BUFFER_TIME
 * is used instead of delta. This ensure that segments are nearly equal when comparing
 * relatively AND absolutely.
 *
 * @type Number
 */
var MAX_DELTA_BUFFER_TIME = 0.2;
/**
 * @see MAX_DELTA_BUFFER_TIME
 * @param {Number} a
 * @param {Number} b
 * @param {Number} delta
 * @returns {Boolean}
 */
function areNearlyEqual(a, b, delta) {
  if (delta === void 0) {
    delta = MAX_DELTA_BUFFER_TIME;
  }
  return Math.abs(a - b) <= Math.min(delta, MAX_DELTA_BUFFER_TIME);
}
var EPSILON = 5e-2; // 5%
/**
 * Check if two cues start are almost the same.
 * It should depend on there relative length:
 *
 * [0, 2] and [2, 4] start are NOT equals
 * [0, 2] and [0, 4]  start are equals
 * [0, 0.1] and [0.101, 2] start are NOT equals
 * [0, 2] and [0.01, 4]  start are equals
 * [0, 100] and [1, 200]  start are NOT equals
 * @see MAX_DELTA_BUFFER_TIME
 * @param {Number} firstCue the existing cue
 * @param {Number} secondCue the cue that we test if it follow firstCue
 * @returns {Boolean}
 */
function areCuesStartNearlyEqual(firstCue, secondCue) {
  var firstCueDuration = firstCue.end - firstCue.start;
  var secondCueDuration = secondCue.end - secondCue.start;
  var diffBetweenStart = Math.abs(firstCue.start - secondCue.start);
  var minDuration = Math.min(firstCueDuration, secondCueDuration, MAX_DELTA_BUFFER_TIME);
  // ratio diff/ minduration is bellow 5%
  return diffBetweenStart / minDuration <= EPSILON;
}
/**
 * Get all cues which have data before the given time.
 * @param {Object} cues
 * @param {Number} time
 * @returns {Array.<Object>}
 */
function getCuesBefore(cues, time) {
  for (var i = cues.length - 1; i >= 0; i--) {
    var cue = cues[i];
    if (cue.start < time) {
      return cues.slice(0, i + 1);
    }
  }
  return [];
}
/**
 * Get all cues which have data after the given time.
 * @param {Object} cues
 * @param {Number} time
 * @returns {Array.<Object>}
 */
function getCuesAfter(cues, time) {
  for (var i = 0; i < cues.length; i++) {
    var cue = cues[i];
    if (cue.end > time) {
      return cues.slice(i, cues.length);
    }
  }
  return [];
}
/**
 * @param {Object} cuesInfos
 * @param {Number} start
 * @param {Number} end
 * @returns {Array.<Object>}
 */
function removeCuesInfosBetween(cuesInfos, start, end) {
  var endCuesInfos1 = Math.max(cuesInfos.start, start);
  var cues1 = getCuesBefore(cuesInfos.cues, start);
  var cuesInfos1 = {
    start: cuesInfos.start,
    end: endCuesInfos1,
    cues: cues1
  };
  var startCuesInfos2 = Math.min(end, cuesInfos.end);
  var cues2 = getCuesAfter(cuesInfos.cues, end);
  var cuesInfos2 = {
    start: startCuesInfos2,
    end: cuesInfos.end,
    cues: cues2
  };
  return [cuesInfos1, cuesInfos2];
}
;// CONCATENATED MODULE: ./src/core/segment_buffers/implementations/text/html/text_track_cues_store.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * first or last IHTMLCue in a group can have a slighlty different start
 * or end time than the start or end time of the ICuesGroup due to parsing
 * approximation.
 * DELTA_CUES_GROUP defines the tolerance level when comparing the start/end
 * of a IHTMLCue to the start/end of a ICuesGroup.
 * Having this value too high may lead to have unwanted subtitle displayed
 * Having this value too low may lead to have subtitles not displayed
 */
var DELTA_CUES_GROUP = 1e-3;
/**
 * segment_duration / RELATIVE_DELTA_RATIO = relative_delta
 *
 * relative_delta is the tolerance to determine if two segements are the same
 */
var RELATIVE_DELTA_RATIO = 5;
/**
 * Manage the buffer of the HTMLTextSegmentBuffer.
 * Allows to add, remove and recuperate cues at given times.
 * @class TextTrackCuesStore
 */
var TextTrackCuesStore = /*#__PURE__*/function () {
  function TextTrackCuesStore() {
    this._cuesBuffer = [];
  }
  /**
   * Get corresponding cue(s) for the given time.
   * A cue is an object with three properties:
   *   - start {Number}: start time for which the cue should be displayed.
   *   - end {Number}: end time for which the cue should be displayed.
   *   - element {HTMLElement}: The cue to diplay
   *
   * We do not mutate individual cue here.
   * That is, if the ``get`` method returns the same cue's reference than a
   * previous ``get`` call, its properties are guaranteed to have the exact same
   * values than before, if you did not mutate it on your side.
   * The inverse is true, if the values are the same than before, the reference
   * will stay the same (this is useful to easily check if the DOM should be
   * updated, for example).
   *
   * @param {Number} time
   * @returns {Array.<HTMLElement>} - The cues that need to be displayed at that
   * time.
   */
  var _proto = TextTrackCuesStore.prototype;
  _proto.get = function get(time) {
    var cuesBuffer = this._cuesBuffer;
    var ret = [];
    // begins at the end as most of the time the player will ask for the last
    // CuesGroup
    for (var cueIdx = cuesBuffer.length - 1; cueIdx >= 0; cueIdx--) {
      var segment = cuesBuffer[cueIdx];
      if (time < segment.end && time >= segment.start) {
        var cues = segment.cues;
        for (var j = 0; j < cues.length; j++) {
          if (time >= cues[j].start && time < cues[j].end) {
            ret.push(cues[j].element);
          }
        }
        // first or last IHTMLCue in a group can have a slighlty different start
        // or end time than the start or end time of the ICuesGroup due to parsing
        // approximation.
        // Add a tolerance of 1ms to fix this issue
        if (ret.length === 0 && cues.length > 0) {
          for (var _j = 0; _j < cues.length; _j++) {
            if (areNearlyEqual(time, cues[_j].start, DELTA_CUES_GROUP) || areNearlyEqual(time, cues[_j].end, DELTA_CUES_GROUP)) {
              ret.push(cues[_j].element);
            }
          }
        }
        return ret;
      }
    }
    return [];
  }
  /**
   * Remove cue from a certain range of time.
   * @param {Number} from
   * @param {Number} to
   */;
  _proto.remove = function remove(from, _to) {
    if (false) {}
    var to = Math.max(from, _to);
    var cuesBuffer = this._cuesBuffer;
    for (var cueIdx = 0; cueIdx < cuesBuffer.length; cueIdx++) {
      if (cuesBuffer[cueIdx].end > from) {
        // this cuesInfos is concerned by the remove
        var startCuesInfos = cuesBuffer[cueIdx];
        if (startCuesInfos.start >= to) {
          // our cuesInfos is strictly after this interval, we have nothing to do
          return;
        }
        if (startCuesInfos.end >= to) {
          // our cuesInfos ends after `to`, we have to keep the end of it
          if (from <= startCuesInfos.start) {
            // from -> to only remove the start of startCuesInfos
            startCuesInfos.cues = getCuesAfter(startCuesInfos.cues, to);
            startCuesInfos.start = to;
          } else {
            // from -> to is in the middle part of startCuesInfos
            var _removeCuesInfosBetwe = removeCuesInfosBetween(startCuesInfos, from, to),
              cuesInfos1 = _removeCuesInfosBetwe[0],
              cuesInfos2 = _removeCuesInfosBetwe[1];
            this._cuesBuffer[cueIdx] = cuesInfos1;
            cuesBuffer.splice(cueIdx + 1, 0, cuesInfos2);
          }
          // No cuesInfos can be concerned after this one, we can quit
          return;
        }
        // Else remove all part after `from`
        if (startCuesInfos.start >= from) {
          // all the segment is concerned
          cuesBuffer.splice(cueIdx, 1);
          cueIdx--; // one less element, we have to decrement the loop
        } else {
          // only the end is concerned
          startCuesInfos.cues = getCuesBefore(startCuesInfos.cues, from);
          startCuesInfos.end = Math.max(from, startCuesInfos.start);
        }
      }
    }
  }
  /**
   * Insert new cues in our text buffer.
   * cues is an array of objects with three properties:
   *   - start {Number}: start time for which the cue should be displayed.
   *   - end {Number}: end time for which the cue should be displayed.
   *   - element {HTMLElement}: The cue to diplay
   *
   * @param {Array.<Object>} cues - CuesGroups, array of objects with the
   * following properties:
   *   - start {Number}: the time at which the cue will start to be displayed
   *   - end {Number}: the time at which the cue will end to be displayed
   *   - cue {HTMLElement}: The cue
   * @param {Number} start - Start time at which the CuesGroup applies.
   * This is different than the start of the first cue to display in it, this
   * has more to do with the time at which the _text segment_ starts.
   * @param {Number} end - End time at which the CuesGroup applies.
   * This is different than the end of the last cue to display in it, this
   * has more to do with the time at which the _text segment_ ends.
   *
   * TODO add securities to ensure that:
   *   - the start of a CuesGroup is inferior or equal to the start of the first
   *     cue in it
   *   - the end of a CuesGroup is superior or equal to the end of the last
   *     cue in it
   * If those requirements are not met, we could delete some cues when adding
   * a CuesGroup before/after. Find a solution.
   */;
  _proto.insert = function insert(cues, start, end) {
    var cuesBuffer = this._cuesBuffer;
    var cuesInfosToInsert = {
      start: start,
      end: end,
      cues: cues
    };
    // it's preferable to have a delta depending on the duration of the segment
    // if the delta is one fifth of the length of the segment:
    // a segment of [0, 2] is the "same" segment as [0, 2.1]
    // but [0, 0.04] is not the "same" segement as [0,04, 0.08]
    var relativeDelta = Math.abs(start - end) / RELATIVE_DELTA_RATIO;
    /**
     * Called when we found the index of the next cue relative to the cue we
     * want to insert (that is a cue starting after its start or at the same
     * time but ending strictly after its end).
     * Will insert the cue at the right place and update the next cue
     * accordingly.
     * @param {number} indexOfNextCue
     */
    function onIndexOfNextCueFound(indexOfNextCue) {
      var nextCue = cuesBuffer[indexOfNextCue];
      if (nextCue === undefined ||
      // no cue
      areNearlyEqual(cuesInfosToInsert.end, nextCue.end, relativeDelta)) {
        // samey end
        //   ours:            |AAAAA|
        //   the current one: |BBBBB|
        //   Result:          |AAAAA|
        cuesBuffer[indexOfNextCue] = cuesInfosToInsert;
      } else if (nextCue.start >= cuesInfosToInsert.end) {
        // Either
        //   ours:            |AAAAA|
        //   the current one:         |BBBBBB|
        //   Result:          |AAAAA| |BBBBBB|
        // Or:
        //   ours:            |AAAAA|
        //   the current one:       |BBBBBB|
        //   Result:          |AAAAA|BBBBBB|
        // Add ours before
        cuesBuffer.splice(indexOfNextCue, 0, cuesInfosToInsert);
      } else {
        // Either
        //   ours:            |AAAAA|
        //   the current one: |BBBBBBBB|
        //   Result:          |AAAAABBB|
        // Or:
        //   ours:            |AAAAA|
        //   the current one:    |BBBBB|
        //   Result:          |AAAAABBB|
        nextCue.cues = getCuesAfter(nextCue.cues, cuesInfosToInsert.end);
        nextCue.start = cuesInfosToInsert.end;
        cuesBuffer.splice(indexOfNextCue, 0, cuesInfosToInsert);
      }
    }
    for (var cueIdx = 0; cueIdx < cuesBuffer.length; cueIdx++) {
      var cuesInfos = cuesBuffer[cueIdx];
      if (start < cuesInfos.end) {
        if (areCuesStartNearlyEqual(cuesInfosToInsert, cuesInfos)) {
          if (areNearlyEqual(end, cuesInfos.end, relativeDelta)) {
            // exact same segment
            //   ours:            |AAAAA|
            //   the current one: |BBBBB|
            //   Result:          |AAAAA|
            // Which means:
            //   1. replace the current cue with ours
            cuesBuffer[cueIdx] = cuesInfosToInsert;
            return;
          } else if (end < cuesInfos.end) {
            // our cue overlaps with the current one:
            //   ours:            |AAAAA|
            //   the current one: |BBBBBBBB|
            //   Result:          |AAAAABBB|
            // Which means:
            //   1. remove some cues at the start of the current one
            //   2. update start of current one
            //   3. add ours before the current one
            cuesInfos.cues = getCuesAfter(cuesInfos.cues, end);
            cuesInfos.start = end;
            cuesBuffer.splice(cueIdx, 0, cuesInfosToInsert);
            return;
          }
          // our cue goes beyond the current one:
          //   ours:            |AAAAAAA|
          //   the current one: |BBBB|...
          //   Result:          |AAAAAAA|
          // Here we have to delete any cuesInfos which end before ours end,
          // and see about the following one.
          do {
            cuesBuffer.splice(cueIdx, 1);
            cuesInfos = cuesBuffer[cueIdx];
          } while (cuesInfos !== undefined && end > cuesInfos.end);
          onIndexOfNextCueFound(cueIdx);
          return;
        } else if (start < cuesInfos.start) {
          if (end < cuesInfos.start) {
            // our cue goes strictly before the current one:
            //   ours:            |AAAAAAA|
            //   the current one:           |BBBB|
            //   Result:          |AAAAAAA| |BBBB|
            // Which means:
            //   - add ours before the current one
            cuesBuffer.splice(cueIdx, 0, cuesInfosToInsert);
            return;
          } else if (areNearlyEqual(end, cuesInfos.start, relativeDelta)) {
            // our cue goes just before the current one:
            //   ours:            |AAAAAAA|
            //   the current one:         |BBBB|
            //   Result:          |AAAAAAA|BBBB|
            // Which means:
            //   - update start time of the current one to be sure
            //   - add ours before the current one
            cuesInfos.start = end;
            cuesBuffer.splice(cueIdx, 0, cuesInfosToInsert);
            return;
          } else if (areNearlyEqual(end, cuesInfos.end, relativeDelta)) {
            //   ours:            |AAAAAAA|
            //   the current one:    |BBBB|
            //   Result:          |AAAAAAA|
            // Replace
            cuesBuffer.splice(cueIdx, 1, cuesInfosToInsert);
            return;
          } else if (end < cuesInfos.end) {
            //   ours:            |AAAAAAA|
            //   the current one:     |BBBBB|
            //   Result:          |AAAAAAABB|
            cuesInfos.cues = getCuesAfter(cuesInfos.cues, end);
            cuesInfos.start = end;
            cuesBuffer.splice(cueIdx, 0, cuesInfosToInsert);
            return;
          }
          //   ours:            |AAAAAAA|
          //   the current one:   |BBB|...
          //   Result:          |AAAAAAA|...
          do {
            cuesBuffer.splice(cueIdx, 1);
            cuesInfos = cuesBuffer[cueIdx];
          } while (cuesInfos !== undefined && end > cuesInfos.end);
          onIndexOfNextCueFound(cueIdx);
          return;
        }
        // else -> start > cuesInfos.start
        if (areNearlyEqual(cuesInfos.end, end, relativeDelta)) {
          //   ours:              |AAAAAA|
          //   the current one: |BBBBBBBB|
          //   Result:          |BBAAAAAA|
          cuesInfos.cues = getCuesBefore(cuesInfos.cues, start);
          cuesInfos.end = start;
          cuesBuffer.splice(cueIdx + 1, 0, cuesInfosToInsert);
          return;
        } else if (cuesInfos.end > end) {
          //   ours:              |AAAAAA|
          //   the current one: |BBBBBBBBBBB|
          //   Result:          |BBAAAAAABBB|
          var _removeCuesInfosBetwe2 = removeCuesInfosBetween(cuesInfos, start, end),
            cuesInfos1 = _removeCuesInfosBetwe2[0],
            cuesInfos2 = _removeCuesInfosBetwe2[1];
          this._cuesBuffer[cueIdx] = cuesInfos1;
          cuesBuffer.splice(cueIdx + 1, 0, cuesInfosToInsert);
          cuesBuffer.splice(cueIdx + 2, 0, cuesInfos2);
          return;
        } else {
          //   ours:              |AAAAAA|
          //   the current one: |BBBBB|...
          //   Result:          |BBAAAAAA|...
          cuesInfos.cues = getCuesBefore(cuesInfos.cues, start);
          cuesInfos.end = start;
          var nextCueIdx = cueIdx + 1;
          cuesInfos = cuesBuffer[nextCueIdx];
          while (cuesInfos !== undefined && end > cuesInfos.end) {
            cuesBuffer.splice(nextCueIdx, 1);
            cuesInfos = cuesBuffer[nextCueIdx];
          }
          onIndexOfNextCueFound(nextCueIdx);
          return;
        }
      }
    }
    if (cuesBuffer.length) {
      var lastCue = cuesBuffer[cuesBuffer.length - 1];
      if (areNearlyEqual(lastCue.end, start, relativeDelta)) {
        // Match the end of the previous cue to the start of the following one
        // if they are close enough. If there is a small gap between two segments
        // it can lead to having no subtitles for a short time, this is noticeable when
        // two successive segments displays the same text, making it diseappear
        // and reappear quickly, which gives the impression of blinking
        //
        //   ours:                   |AAAAA|
        //   the current one: |BBBBB|...
        //   Result:          |BBBBBBBAAAAA|
        lastCue.end = start;
      }
    }
    // no cues group has the end after our current start.
    // These cues should be the last one
    cuesBuffer.push(cuesInfosToInsert);
  };
  return TextTrackCuesStore;
}();

;// CONCATENATED MODULE: ./src/core/segment_buffers/implementations/text/html/update_proportional_elements.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Update size of element which are proportional to the current text track
 * element.
 * Returns `true` if at least a single styling information is proportional,
 * `false` otherwise.
 * @param {number} currentHeight
 * @param {number} currentWidth
 * @param {Object} resolution
 * @param {HTMLElement} textTrackElement
 * @returns {boolean}
 */
function updateProportionalElements(currentHeight, currentWidth, resolution, textTrackElement) {
  var cellUnit = [currentWidth / resolution.columns, currentHeight / resolution.rows];
  var proportElts = textTrackElement.getElementsByClassName("proportional-style");
  for (var eltIdx = 0; eltIdx < proportElts.length; eltIdx++) {
    var elt = proportElts[eltIdx];
    if (elt instanceof HTMLElement) {
      var fontSizeVal = elt.getAttribute("data-proportional-font-size");
      if (fontSizeVal !== null && !isNaN(+fontSizeVal)) {
        elt.style.fontSize = String(+fontSizeVal * cellUnit[1]) + "px";
      }
      var widthVal = elt.getAttribute("data-proportional-width");
      if (widthVal !== null && !isNaN(+widthVal)) {
        elt.style.width = String(+widthVal * cellUnit[0]) + "px";
      }
      var heightVal = elt.getAttribute("data-proportional-height");
      if (heightVal !== null && !isNaN(+heightVal)) {
        elt.style.height = String(+heightVal * cellUnit[1]) + "px";
      }
      var lineHeightVal = elt.getAttribute("data-proportional-line-height");
      if (lineHeightVal !== null && !isNaN(+lineHeightVal)) {
        elt.style.lineHeight = String(+lineHeightVal * cellUnit[1]) + "px";
      }
      var leftVal = elt.getAttribute("data-proportional-left");
      if (leftVal !== null && !isNaN(+leftVal)) {
        elt.style.left = String(+leftVal * cellUnit[0]) + "px";
      }
      var topVal = elt.getAttribute("data-proportional-top");
      if (topVal !== null && !isNaN(+topVal)) {
        elt.style.top = String(+topVal * cellUnit[1]) + "px";
      }
      var paddingTopVal = elt.getAttribute("data-proportional-padding-top");
      if (paddingTopVal !== null && !isNaN(+paddingTopVal)) {
        elt.style.paddingTop = String(+paddingTopVal * cellUnit[1]) + "px";
      }
      var paddingBottomVal = elt.getAttribute("data-proportional-padding-bottom");
      if (paddingBottomVal !== null && !isNaN(+paddingBottomVal)) {
        elt.style.paddingBottom = String(+paddingBottomVal * cellUnit[1]) + "px";
      }
      var paddingLeftVal = elt.getAttribute("data-proportional-padding-left");
      if (paddingLeftVal !== null && !isNaN(+paddingLeftVal)) {
        elt.style.paddingLeft = String(+paddingLeftVal * cellUnit[0]) + "px";
      }
      var paddingRightVal = elt.getAttribute("data-proportional-padding-right");
      if (paddingRightVal !== null && !isNaN(+paddingRightVal)) {
        elt.style.paddingRight = String(+paddingRightVal * cellUnit[0]) + "px";
      }
    }
  }
  return proportElts.length > 0;
}
;// CONCATENATED MODULE: ./src/core/segment_buffers/implementations/text/html/html_text_segment_buffer.ts

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */









var onEnded = event_listeners/* onEnded */.g9,
  onSeeked = event_listeners/* onSeeked */.Bi,
  onSeeking = event_listeners/* onSeeking */.ID;
/**
 * @param {Element} element
 * @param {Element} child
 */
function safelyRemoveChild(element, child) {
  try {
    element.removeChild(child);
  } catch (_error) {
    log/* default */.A.warn("HTSB: Can't remove text track: not in the element.");
  }
}
/**
 * @param {HTMLElement} element
 * @returns {Object|null}
 */
function getElementResolution(element) {
  var strRows = element.getAttribute("data-resolution-rows");
  var strColumns = element.getAttribute("data-resolution-columns");
  if (strRows === null || strColumns === null) {
    return null;
  }
  var rows = parseInt(strRows, 10);
  var columns = parseInt(strColumns, 10);
  if (rows === null || columns === null) {
    return null;
  }
  return {
    rows: rows,
    columns: columns
  };
}
/**
 * SegmentBuffer implementation which display buffered TextTracks in the given
 * HTML element.
 * @class HTMLTextSegmentBuffer
 */
var HTMLTextSegmentBuffer = /*#__PURE__*/function (_SegmentBuffer) {
  /**
   * @param {HTMLMediaElement} videoElement
   * @param {HTMLElement} textTrackElement
   */
  function HTMLTextSegmentBuffer(videoElement, textTrackElement) {
    var _this;
    log/* default */.A.debug("HTSB: Creating HTMLTextSegmentBuffer");
    _this = _SegmentBuffer.call(this) || this;
    _this.bufferType = "text";
    _this._buffered = new manual_time_ranges/* default */.A();
    _this._videoElement = videoElement;
    _this._textTrackElement = textTrackElement;
    _this._sizeUpdateCanceller = new task_canceller/* default */.Ay();
    _this._canceller = new task_canceller/* default */.Ay();
    _this._buffer = new TextTrackCuesStore();
    _this._currentCues = [];
    _this.autoRefreshSubtitles(_this._canceller.signal);
    return _this;
  }
  /**
   * @param {string} uniqueId
   */
  (0,inheritsLoose/* default */.A)(HTMLTextSegmentBuffer, _SegmentBuffer);
  var _proto = HTMLTextSegmentBuffer.prototype;
  _proto.declareInitSegment = function declareInitSegment(uniqueId) {
    log/* default */.A.warn("ISB: Declaring initialization segment for image SegmentBuffer", uniqueId);
  }
  /**
   * @param {string} uniqueId
   */;
  _proto.freeInitSegment = function freeInitSegment(uniqueId) {
    log/* default */.A.warn("ISB: Freeing initialization segment for image SegmentBuffer", uniqueId);
  }
  /**
   * Push text segment to the HTMLTextSegmentBuffer.
   * @param {Object} infos
   * @returns {Promise}
   */;
  _proto.pushChunk = function pushChunk(infos) {
    try {
      this.pushChunkSync(infos);
    } catch (err) {
      return Promise.reject(err);
    }
    return Promise.resolve();
  }
  /**
   * Remove buffered data.
   * @param {number} start - start position, in seconds
   * @param {number} end - end position, in seconds
   * @returns {Promise}
   */;
  _proto.removeBuffer = function removeBuffer(start, end) {
    this.removeBufferSync(start, end);
    return Promise.resolve();
  }
  /**
   * @param {Object} infos
   * @returns {Promise}
   */;
  _proto.endOfSegment = function endOfSegment(infos) {
    this._segmentInventory.completeSegment(infos, this._buffered);
    return Promise.resolve();
  }
  /**
   * Returns the currently buffered data, in a TimeRanges object.
   * @returns {TimeRanges}
   */;
  _proto.getBufferedRanges = function getBufferedRanges() {
    return this._buffered;
  };
  _proto.dispose = function dispose() {
    log/* default */.A.debug("HTSB: Disposing HTMLTextSegmentBuffer");
    this._disableCurrentCues();
    this._buffer.remove(0, Infinity);
    this._buffered.remove(0, Infinity);
    this._canceller.cancel();
  }
  /**
   * Push the text track contained in `data` to the HTMLTextSegmentBuffer
   * synchronously.
   * Returns a boolean:
   *   - `true` if text tracks have been added the the HTMLTextSegmentBuffer's
   *     buffer after that segment has been added.
   *   - `false` if no text tracks have been added the the
   *     HTMLTextSegmentBuffer's buffer (e.g. empty text-track, incoherent times
   *     etc.)
   *
   * /!\ This method won't add any data to the linked inventory.
   * Please use the `pushChunk` method for most use-cases.
   * @param {Object} infos
   * @returns {boolean}
   */;
  _proto.pushChunkSync = function pushChunkSync(infos) {
    var _a, _b;
    log/* default */.A.debug("HTSB: Appending new html text tracks");
    var _infos$data = infos.data,
      timestampOffset = _infos$data.timestampOffset,
      appendWindow = _infos$data.appendWindow,
      chunk = _infos$data.chunk;
    if (chunk === null) {
      return;
    }
    assertChunkIsTextTrackSegmentData(chunk);
    var startTime = chunk.start,
      endTime = chunk.end,
      dataString = chunk.data,
      type = chunk.type,
      language = chunk.language;
    var appendWindowStart = (_a = appendWindow[0]) !== null && _a !== void 0 ? _a : 0;
    var appendWindowEnd = (_b = appendWindow[1]) !== null && _b !== void 0 ? _b : Infinity;
    var cues = parseTextTrackToElements(type, dataString, timestampOffset, language);
    if (appendWindowStart !== 0 && appendWindowEnd !== Infinity) {
      // Removing before window start
      var i = 0;
      while (i < cues.length && cues[i].end <= appendWindowStart) {
        i++;
      }
      cues.splice(0, i);
      i = 0;
      while (i < cues.length && cues[i].start < appendWindowStart) {
        cues[i].start = appendWindowStart;
        i++;
      }
      // Removing after window end
      i = cues.length - 1;
      while (i >= 0 && cues[i].start >= appendWindowEnd) {
        i--;
      }
      cues.splice(i, cues.length);
      i = cues.length - 1;
      while (i >= 0 && cues[i].end > appendWindowEnd) {
        cues[i].end = appendWindowEnd;
        i--;
      }
    }
    var start;
    if (startTime !== undefined) {
      start = Math.max(appendWindowStart, startTime);
    } else {
      if (cues.length <= 0) {
        log/* default */.A.warn("HTSB: Current text tracks have no cues nor start time. Aborting");
        return;
      }
      log/* default */.A.warn("HTSB: No start time given. Guessing from cues.");
      start = cues[0].start;
    }
    var end;
    if (endTime !== undefined) {
      end = Math.min(appendWindowEnd, endTime);
    } else {
      if (cues.length <= 0) {
        log/* default */.A.warn("HTSB: Current text tracks have no cues nor end time. Aborting");
        return;
      }
      log/* default */.A.warn("HTSB: No end time given. Guessing from cues.");
      end = cues[cues.length - 1].end;
    }
    if (end <= start) {
      log/* default */.A.warn("HTSB: Invalid text track appended: ", "the start time is inferior or equal to the end time.");
      return;
    }
    if (infos.inventoryInfos !== null) {
      this._segmentInventory.insertChunk(infos.inventoryInfos, true, performance.now());
    }
    this._buffer.insert(cues, start, end);
    this._buffered.insert(start, end);
  }
  /**
   * Remove buffer data between the given start and end, synchronously.
   * @param {number} start
   * @param {number} end
   */;
  _proto.removeBufferSync = function removeBufferSync(start, end) {
    log/* default */.A.debug("HTSB: Removing html text track data", start, end);
    this._buffer.remove(start, end);
    this._buffered.remove(start, end);
  }
  /**
   * Remove the current cue from being displayed.
   */;
  _proto._disableCurrentCues = function _disableCurrentCues() {
    this._sizeUpdateCanceller.cancel();
    if (this._currentCues.length > 0) {
      for (var i = 0; i < this._currentCues.length; i++) {
        safelyRemoveChild(this._textTrackElement, this._currentCues[i].element);
      }
      this._currentCues = [];
    }
  }
  /**
   * Display a new Cue. If one was already present, it will be replaced.
   * @param {HTMLElement} elements
   */;
  _proto._displayCues = function _displayCues(elements) {
    var nothingChanged = this._currentCues.length === elements.length && this._currentCues.every(function (current, index) {
      return current.element === elements[index];
    });
    if (nothingChanged) {
      return;
    }
    // Remove and re-display everything
    // TODO More intelligent handling
    this._sizeUpdateCanceller.cancel();
    for (var i = 0; i < this._currentCues.length; i++) {
      safelyRemoveChild(this._textTrackElement, this._currentCues[i].element);
    }
    this._currentCues = [];
    for (var _i = 0; _i < elements.length; _i++) {
      var element = elements[_i];
      var resolution = getElementResolution(element);
      this._currentCues.push({
        element: element,
        resolution: resolution
      });
      this._textTrackElement.appendChild(element);
    }
    var proportionalCues = this._currentCues.filter(function (cue) {
      return cue.resolution !== null;
    });
    if (proportionalCues.length > 0) {
      this._sizeUpdateCanceller = new task_canceller/* default */.Ay();
      this._sizeUpdateCanceller.linkToSignal(this._canceller.signal);
      var _config$getCurrent = config/* default */.A.getCurrent(),
        TEXT_TRACK_SIZE_CHECKS_INTERVAL = _config$getCurrent.TEXT_TRACK_SIZE_CHECKS_INTERVAL;
      // update propertionally-sized elements periodically
      var heightWidthRef = onHeightWidthChange(this._textTrackElement, TEXT_TRACK_SIZE_CHECKS_INTERVAL, this._sizeUpdateCanceller.signal);
      heightWidthRef.onUpdate(function (_ref) {
        var height = _ref.height,
          width = _ref.width;
        for (var _i2 = 0; _i2 < proportionalCues.length; _i2++) {
          var _proportionalCues$_i = proportionalCues[_i2],
            _resolution = _proportionalCues$_i.resolution,
            _element = _proportionalCues$_i.element;
          updateProportionalElements(height, width, _resolution, _element);
        }
      }, {
        clearSignal: this._sizeUpdateCanceller.signal,
        emitCurrentValue: true
      });
    }
  }
  /**
   * Auto-refresh the display of subtitles according to the media element's
   * position and events.
   * @param {Object} cancellationSignal
   */;
  _proto.autoRefreshSubtitles = function autoRefreshSubtitles(cancellationSignal) {
    var _this2 = this;
    var autoRefreshCanceller = null;
    var _config$getCurrent2 = config/* default */.A.getCurrent(),
      MAXIMUM_HTML_TEXT_TRACK_UPDATE_INTERVAL = _config$getCurrent2.MAXIMUM_HTML_TEXT_TRACK_UPDATE_INTERVAL;
    var startAutoRefresh = function startAutoRefresh() {
      stopAutoRefresh();
      autoRefreshCanceller = new task_canceller/* default */.Ay();
      autoRefreshCanceller.linkToSignal(cancellationSignal);
      var intervalId = setInterval(function () {
        return _this2.refreshSubtitles();
      }, MAXIMUM_HTML_TEXT_TRACK_UPDATE_INTERVAL);
      autoRefreshCanceller.signal.register(function () {
        clearInterval(intervalId);
      });
      _this2.refreshSubtitles();
    };
    onSeeking(this._videoElement, function () {
      stopAutoRefresh();
      _this2._disableCurrentCues();
    }, cancellationSignal);
    onSeeked(this._videoElement, startAutoRefresh, cancellationSignal);
    onEnded(this._videoElement, startAutoRefresh, cancellationSignal);
    startAutoRefresh();
    function stopAutoRefresh() {
      if (autoRefreshCanceller !== null) {
        autoRefreshCanceller.cancel();
        autoRefreshCanceller = null;
      }
    }
  }
  /**
   * Refresh current subtitles according to the current media element's
   * position.
   */;
  _proto.refreshSubtitles = function refreshSubtitles() {
    var _config$getCurrent3 = config/* default */.A.getCurrent(),
      MAXIMUM_HTML_TEXT_TRACK_UPDATE_INTERVAL = _config$getCurrent3.MAXIMUM_HTML_TEXT_TRACK_UPDATE_INTERVAL;
    var time;
    if (this._videoElement.paused || this._videoElement.playbackRate <= 0) {
      time = this._videoElement.currentTime;
    } else {
      // to spread the time error, we divide the regular chosen interval.
      time = Math.max(this._videoElement.currentTime + MAXIMUM_HTML_TEXT_TRACK_UPDATE_INTERVAL / 1000 / 2, 0);
    }
    var cues = this._buffer.get(time);
    if (cues.length === 0) {
      this._disableCurrentCues();
    } else {
      this._displayCues(cues);
    }
  };
  return HTMLTextSegmentBuffer;
}(types/* SegmentBuffer */.K);
/**
 * Throw if the given input is not in the expected format.
 * Allows to enforce runtime type-checking as compile-time type-checking here is
 * difficult to enforce.
 * @param {Object} chunk
 */

function assertChunkIsTextTrackSegmentData(chunk) {
  if (true) {
    return;
  }
  if (typeof chunk !== "object" || chunk === null || typeof chunk.data !== "string" || typeof chunk.type !== "string" || chunk.language !== undefined && typeof chunk.language !== "string" || chunk.start !== undefined && typeof chunk.start !== "number" || chunk.end !== undefined && typeof chunk.end !== "number") {
    throw new Error("Invalid format given to a HTMLTextSegmentBuffer");
  }
}
/*
 * The following ugly code is here to provide a compile-time check that an
 * `IHTMLTextTracksBufferSegmentData` (type of data pushed to a
 * `HTMLTextSegmentBuffer`) can be derived from a `ITextTrackSegmentData`
 * (text track data parsed from a segment).
 *
 * It doesn't correspond at all to real code that will be called. This is just
 * a hack to tell TypeScript to perform that check.
 */
if (false) { var _checkType; }
;// CONCATENATED MODULE: ./src/core/segment_buffers/implementations/text/html/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */

/* harmony default export */ var html = (HTMLTextSegmentBuffer);

/***/ }),

/***/ 8385:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: function() { return /* binding */ text_native; }
});

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js
var inheritsLoose = __webpack_require__(7387);
// EXTERNAL MODULE: ./src/compat/browser_detection.ts
var browser_detection = __webpack_require__(443);
;// CONCATENATED MODULE: ./src/compat/add_text_track.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Add text track to the given media element.
 *
 * Returns an object with the following properties:
 *   - track {TextTrack}: the added text track
 *   - trackElement {HTMLElement|undefined}: the added <track> element.
 *     undefined if no trackElement was added.
 *
 * @param {HTMLMediaElement} mediaElement
 * @param {Boolean} hidden - If `true`, the text track will be hidden by
 * default. If `false`, the text track will be directly showing.
 * @returns {Object}
 */
function addTextTrack(mediaElement, hidden) {
  var _a, _b;
  var track;
  var trackElement;
  var kind = "subtitles";
  if (browser_detection/* isIEOrEdge */.h$) {
    var tracksLength = mediaElement.textTracks.length;
    track = tracksLength > 0 ? mediaElement.textTracks[tracksLength - 1] : mediaElement.addTextTrack(kind);
    track.mode = hidden ? (_a = track.HIDDEN) !== null && _a !== void 0 ? _a : "hidden" : (_b = track.SHOWING) !== null && _b !== void 0 ? _b : "showing";
  } else {
    trackElement = document.createElement("track");
    mediaElement.appendChild(trackElement);
    track = trackElement.track;
    trackElement.kind = kind;
    track.mode = hidden ? "hidden" : "showing";
  }
  return {
    track: track,
    trackElement: trackElement
  };
}
// EXTERNAL MODULE: ./src/log.ts + 1 modules
var log = __webpack_require__(9477);
;// CONCATENATED MODULE: ./src/compat/remove_cue.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Return true if given cue is active.
 * @param {TextTrack} track
 * @param {TextTrackCue} cue
 * @returns {boolean}
 */
function isActiveCue(track, cue) {
  var activeCues = track.activeCues;
  if (activeCues === null) {
    return false;
  }
  for (var i = 0; i < activeCues.length; i++) {
    if (activeCues[i] === cue) {
      return true;
    }
  }
  return false;
}
/**
 * Remove cue from text track.
 * @param {TextTrack} track
 * @param {TextTrackCue} cue
 */
function removeCue(track, cue) {
  // On Firefox, cue doesn't dissapear when it is removed from track. Track
  // should be hidden, and shown again after removing cue, in order to
  // definitely clean the cue.
  if (browser_detection/* isFirefox */.gm && isActiveCue(track, cue)) {
    var trackMode = track.mode;
    track.mode = "hidden";
    try {
      track.removeCue(cue);
    } catch (err) {
      log/* default */.A.warn("Compat: Could not remove cue from text track.");
    }
    track.mode = trackMode;
    return;
  }
  try {
    track.removeCue(cue);
  } catch (err) {
    log/* default */.A.warn("Compat: Could not remove cue from text track.");
  }
}
// EXTERNAL MODULE: ./src/core/segment_buffers/implementations/types.ts + 3 modules
var types = __webpack_require__(7500);
// EXTERNAL MODULE: ./src/core/segment_buffers/implementations/utils/manual_time_ranges.ts
var manual_time_ranges = __webpack_require__(3481);
// EXTERNAL MODULE: ./src/features/index.ts
var features = __webpack_require__(418);
;// CONCATENATED MODULE: ./src/core/segment_buffers/implementations/text/native/parsers.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Convert text track data into timed VTT Cues.
 * @param {string} type - Text track format wanted
 * @param {string} data - Text track data
 * @param {Number} timestampOffset - offset to apply to every timed text
 * @param {string} [language] - language of the text tracks
 * @returns {Array.<VTTCue>}
 * @throws Error - Throw if no parser is found for the given type
 */
function parseTextTrackToCues(type, data, timestampOffset, language) {
  log/* default */.A.debug("NTSB: Finding parser for native text tracks:", type);
  var parser = features/* default */.A.nativeTextTracksParsers[type];
  if (typeof parser !== "function") {
    throw new Error("no parser found for the given text track");
  }
  log/* default */.A.debug("NTSB: Parser found, parsing...");
  var parsed = parser(data, timestampOffset, language);
  log/* default */.A.debug("NTSB: Parsed successfully!", parsed.length);
  return parsed;
}
;// CONCATENATED MODULE: ./src/core/segment_buffers/implementations/text/native/native_text_segment_buffer.ts

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






/**
 * Implementation of an SegmentBuffer for "native" text tracks.
 * "Native" text tracks rely on a `<track>` HTMLElement and its associated
 * expected behavior to display subtitles synchronized to the video.
 * @class NativeTextSegmentBuffer
 */
var NativeTextSegmentBuffer = /*#__PURE__*/function (_SegmentBuffer) {
  /**
   * @param {HTMLMediaElement} videoElement
   * @param {Boolean} hideNativeSubtitle
   */
  function NativeTextSegmentBuffer(videoElement, hideNativeSubtitle) {
    var _this;
    log/* default */.A.debug("NTSB: Creating NativeTextSegmentBuffer");
    _this = _SegmentBuffer.call(this) || this;
    var _addTextTrack = addTextTrack(videoElement, hideNativeSubtitle),
      track = _addTextTrack.track,
      trackElement = _addTextTrack.trackElement;
    _this.bufferType = "text";
    _this._buffered = new manual_time_ranges/* default */.A();
    _this._videoElement = videoElement;
    _this._track = track;
    _this._trackElement = trackElement;
    return _this;
  }
  /**
   * @param {string} uniqueId
   */
  (0,inheritsLoose/* default */.A)(NativeTextSegmentBuffer, _SegmentBuffer);
  var _proto = NativeTextSegmentBuffer.prototype;
  _proto.declareInitSegment = function declareInitSegment(uniqueId) {
    log/* default */.A.warn("ISB: Declaring initialization segment for image SegmentBuffer", uniqueId);
  }
  /**
   * @param {string} uniqueId
   */;
  _proto.freeInitSegment = function freeInitSegment(uniqueId) {
    log/* default */.A.warn("ISB: Freeing initialization segment for image SegmentBuffer", uniqueId);
  }
  /**
   * @param {Object} infos
   * @returns {Promise}
   */;
  _proto.pushChunk = function pushChunk(infos) {
    var _a, _b;
    log/* default */.A.debug("NTSB: Appending new native text tracks");
    if (infos.data.chunk === null) {
      return Promise.resolve();
    }
    var _infos$data = infos.data,
      timestampOffset = _infos$data.timestampOffset,
      appendWindow = _infos$data.appendWindow,
      chunk = _infos$data.chunk;
    assertChunkIsTextTrackSegmentData(chunk);
    var startTime = chunk.start,
      endTime = chunk.end,
      dataString = chunk.data,
      type = chunk.type,
      language = chunk.language;
    var appendWindowStart = (_a = appendWindow[0]) !== null && _a !== void 0 ? _a : 0;
    var appendWindowEnd = (_b = appendWindow[1]) !== null && _b !== void 0 ? _b : Infinity;
    try {
      var cues = parseTextTrackToCues(type, dataString, timestampOffset, language);
      if (appendWindowStart !== 0 && appendWindowEnd !== Infinity) {
        // Removing before window start
        var i = 0;
        while (i < cues.length && cues[i].endTime <= appendWindowStart) {
          i++;
        }
        cues.splice(0, i);
        i = 0;
        while (i < cues.length && cues[i].startTime < appendWindowStart) {
          cues[i].startTime = appendWindowStart;
          i++;
        }
        // Removing after window end
        i = cues.length - 1;
        while (i >= 0 && cues[i].startTime >= appendWindowEnd) {
          i--;
        }
        cues.splice(i, cues.length);
        i = cues.length - 1;
        while (i >= 0 && cues[i].endTime > appendWindowEnd) {
          cues[i].endTime = appendWindowEnd;
          i--;
        }
      }
      var start;
      if (startTime !== undefined) {
        start = Math.max(appendWindowStart, startTime);
      } else {
        if (cues.length <= 0) {
          log/* default */.A.warn("NTSB: Current text tracks have no cues nor start time. Aborting");
          return Promise.resolve();
        }
        log/* default */.A.warn("NTSB: No start time given. Guessing from cues.");
        start = cues[0].startTime;
      }
      var end;
      if (endTime !== undefined) {
        end = Math.min(appendWindowEnd, endTime);
      } else {
        if (cues.length <= 0) {
          log/* default */.A.warn("NTSB: Current text tracks have no cues nor end time. Aborting");
          return Promise.resolve();
        }
        log/* default */.A.warn("NTSB: No end time given. Guessing from cues.");
        end = cues[cues.length - 1].endTime;
      }
      if (end <= start) {
        log/* default */.A.warn("NTSB: Invalid text track appended: ", "the start time is inferior or equal to the end time.");
        return Promise.resolve();
      }
      if (cues.length > 0) {
        var firstCue = cues[0];
        // NOTE(compat): cleanup all current cues if the newly added
        // ones are in the past. this is supposed to fix an issue on
        // IE/Edge.
        // TODO Move to compat
        var currentCues = this._track.cues;
        if (currentCues !== null && currentCues.length > 0) {
          if (firstCue.startTime < currentCues[currentCues.length - 1].startTime) {
            this._removeData(firstCue.startTime, +Infinity);
          }
        }
        for (var _i = 0; _i < cues.length; _i++) {
          this._track.addCue(cues[_i]);
        }
      }
      this._buffered.insert(start, end);
      if (infos.inventoryInfos !== null) {
        this._segmentInventory.insertChunk(infos.inventoryInfos, true, performance.now());
      }
    } catch (err) {
      return Promise.reject(err);
    }
    return Promise.resolve();
  }
  /**
   * Remove buffered data.
   * @param {number} start - start position, in seconds
   * @param {number} end - end position, in seconds
   * @returns {Promise}
   */;
  _proto.removeBuffer = function removeBuffer(start, end) {
    this._removeData(start, end);
    return Promise.resolve();
  }
  /**
   * @param {Object} infos
   * @returns {Promise}
   */;
  _proto.endOfSegment = function endOfSegment(_infos) {
    this._segmentInventory.completeSegment(_infos, this._buffered);
    return Promise.resolve();
  }
  /**
   * Returns the currently buffered data, in a TimeRanges object.
   * @returns {TimeRanges}
   */;
  _proto.getBufferedRanges = function getBufferedRanges() {
    return this._buffered;
  };
  _proto.dispose = function dispose() {
    log/* default */.A.debug("NTSB: Aborting NativeTextSegmentBuffer");
    this._removeData(0, Infinity);
    var _trackElement = this._trackElement,
      _videoElement = this._videoElement;
    if (_trackElement !== undefined && _videoElement.hasChildNodes()) {
      try {
        _videoElement.removeChild(_trackElement);
      } catch (e) {
        log/* default */.A.warn("NTSB: Can't remove track element from the video");
      }
    }
    this._track.mode = "disabled";
    if (this._trackElement !== undefined) {
      this._trackElement.innerHTML = "";
    }
  };
  _proto._removeData = function _removeData(start, end) {
    log/* default */.A.debug("NTSB: Removing native text track data", start, end);
    var track = this._track;
    var cues = track.cues;
    if (cues !== null) {
      for (var i = cues.length - 1; i >= 0; i--) {
        var cue = cues[i];
        var startTime = cue.startTime,
          endTime = cue.endTime;
        if (startTime >= start && startTime <= end && endTime <= end) {
          removeCue(track, cue);
        }
      }
    }
    this._buffered.remove(start, end);
  };
  return NativeTextSegmentBuffer;
}(types/* SegmentBuffer */.K);
/**
 * Throw if the given input is not in the expected format.
 * Allows to enforce runtime type-checking as compile-time type-checking here is
 * difficult to enforce.
 * @param {Object} chunk
 */

function assertChunkIsTextTrackSegmentData(chunk) {
  if (true) {
    return;
  }
  if (typeof chunk !== "object" || chunk === null || typeof chunk.data !== "string" || typeof chunk.type !== "string" || chunk.language !== undefined && typeof chunk.language !== "string" || chunk.start !== undefined && typeof chunk.start !== "number" || chunk.end !== undefined && typeof chunk.end !== "number") {
    throw new Error("Invalid format given to a NativeTextSegmentBuffer");
  }
}
/*
 * The following ugly code is here to provide a compile-time check that an
 * `INativeTextTracksBufferSegmentData` (type of data pushed to a
 * `NativeTextSegmentBuffer`) can be derived from a `ITextTrackSegmentData`
 * (text track data parsed from a segment).
 *
 * It doesn't correspond at all to real code that will be called. This is just
 * a hack to tell TypeScript to perform that check.
 */
if (false) { var _checkType; }
;// CONCATENATED MODULE: ./src/core/segment_buffers/implementations/text/native/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ var text_native = (NativeTextSegmentBuffer);

/***/ }),

/***/ 7500:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  K: function() { return /* binding */ SegmentBuffer; },
  B: function() { return /* binding */ SegmentBufferOperation; }
});

// EXTERNAL MODULE: ./src/config.ts + 2 modules
var config = __webpack_require__(5151);
// EXTERNAL MODULE: ./src/log.ts + 1 modules
var log = __webpack_require__(9477);
// EXTERNAL MODULE: ./src/manifest/utils.ts
var utils = __webpack_require__(7841);
;// CONCATENATED MODULE: ./src/core/segment_buffers/inventory/buffered_history.ts
function _createForOfIteratorHelperLoose(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (t) return (t = t.call(r)).next.bind(t); if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var o = 0; return function () { return o >= r.length ? { done: !0 } : { done: !1, value: r[o++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Register a short-lived history of buffer information.
 *
 * This class can be useful to develop heuristics based on short-term buffer
 * history, such as knowing the real start and end of a buffered segment once
 * it has been pushed in a buffer.
 *
 * By storing in a history important recent actions and events, the
 * `BufferedHistory` can help other RxPlayer modules detect and work-around
 * unusual behavior.
 *
 * @class BufferedHistory
 */
var BufferedHistory = /*#__PURE__*/function () {
  /**
   * @param {number} lifetime - Maximum time a history entry should be retained.
   * @param {number} maxHistoryLength - Maximum number of entries the history
   * should have.
   */
  function BufferedHistory(lifetime, maxHistoryLength) {
    this._history = [];
    this._lifetime = lifetime;
    this._maxHistoryLength = maxHistoryLength;
  }
  /**
   * Add an entry to the `BufferedHistory`'s history indicating the buffered
   * range of a pushed segment.
   *
   * To call when the full range of a given segment becomes known.
   *
   * @param {Object} context
   * @param {Array.<number>|null} buffered
   */
  var _proto = BufferedHistory.prototype;
  _proto.addBufferedSegment = function addBufferedSegment(context, buffered) {
    var now = performance.now();
    this._history.push({
      date: now,
      buffered: buffered,
      context: context
    });
    this._cleanHistory(now);
  }
  /**
   * Returns all entries linked to the given segment.
   * @param {Object} context
   * @returns {Array.<Object>}
   */;
  _proto.getHistoryFor = function getHistoryFor(context) {
    return this._history.filter(function (el) {
      return (0,utils/* areSameContent */.Q)(el.context, context);
    });
  }
  /**
   * If the current history does not satisfy `_lifetime` or `_maxHistoryLength`,
   * clear older entries until it does.
   * @param {number} now - Current `performance.now()` result.
   */;
  _proto._cleanHistory = function _cleanHistory(now) {
    var historyEarliestLimit = now - this._lifetime;
    var firstKeptIndex = 0;
    for (var _iterator = _createForOfIteratorHelperLoose(this._history), _step; !(_step = _iterator()).done;) {
      var event = _step.value;
      if (event.date < historyEarliestLimit) {
        firstKeptIndex++;
      } else {
        break;
      }
    }
    if (firstKeptIndex > 0) {
      this._history = this._history.splice(firstKeptIndex);
    }
    if (this._history.length > this._maxHistoryLength) {
      var toRemove = this._history.length - this._maxHistoryLength;
      this._history = this._history.splice(toRemove);
    }
  };
  return BufferedHistory;
}();

;// CONCATENATED MODULE: ./src/core/segment_buffers/inventory/segment_inventory.ts
function segment_inventory_createForOfIteratorHelperLoose(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (t) return (t = t.call(r)).next.bind(t); if (Array.isArray(r) || (t = segment_inventory_unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var o = 0; return function () { return o >= r.length ? { done: !0 } : { done: !1, value: r[o++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function segment_inventory_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return segment_inventory_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? segment_inventory_arrayLikeToArray(r, a) : void 0; } }
function segment_inventory_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Keep track of every chunk downloaded and currently in the linked media
 * buffer.
 *
 * The main point of this class is to know which chunks are already pushed to
 * the corresponding media buffer, at which bitrate, and which have been garbage-collected
 * since by the browser (and thus may need to be re-loaded).
 * @class SegmentInventory
 */
var SegmentInventory = /*#__PURE__*/function () {
  function SegmentInventory() {
    var _config$getCurrent = config/* default */.A.getCurrent(),
      BUFFERED_HISTORY_RETENTION_TIME = _config$getCurrent.BUFFERED_HISTORY_RETENTION_TIME,
      BUFFERED_HISTORY_MAXIMUM_ENTRIES = _config$getCurrent.BUFFERED_HISTORY_MAXIMUM_ENTRIES;
    this._inventory = [];
    this._bufferedHistory = new BufferedHistory(BUFFERED_HISTORY_RETENTION_TIME, BUFFERED_HISTORY_MAXIMUM_ENTRIES);
  }
  /**
   * Reset the whole inventory.
   */
  var _proto = SegmentInventory.prototype;
  _proto.reset = function reset() {
    this._inventory.length = 0;
  }
  /**
   * Infer each segment's `bufferedStart` and `bufferedEnd` properties from the
   * TimeRanges given.
   *
   * The TimeRanges object given should come from the media buffer linked to
   * that SegmentInventory.
   *
   * /!\ A SegmentInventory should not be associated to multiple media buffers
   * at a time, so each `synchronizeBuffered` call should be given a TimeRanges
   * coming from the same buffer.
   * @param {TimeRanges} buffered
   * @param {boolean|undefined} [skipLog=false] - This method normally may
   * trigger a voluminous debug log if debug logs are enabled.
   * As this method might be called very often in some specific debugging
   * situations, setting this value to `true` allows to prevent the call from
   * triggering a log.
   */;
  _proto.synchronizeBuffered = function synchronizeBuffered(buffered, skipLog) {
    if (skipLog === void 0) {
      skipLog = false;
    }
    var _a, _b, _c, _d, _e, _f, _g;
    var inventory = this._inventory;
    var inventoryIndex = 0; // Current index considered.
    var thisSegment = inventory[0]; // Current segmentInfos considered
    var _config$getCurrent2 = config/* default */.A.getCurrent(),
      MINIMUM_SEGMENT_SIZE = _config$getCurrent2.MINIMUM_SEGMENT_SIZE;
    /** Type of buffer considered, used for logs */
    var bufferType = thisSegment === null || thisSegment === void 0 ? void 0 : thisSegment.infos.adaptation.type;
    var rangesLength = buffered.length;
    for (var i = 0; i < rangesLength; i++) {
      if (thisSegment === undefined) {
        // we arrived at the end of our inventory
        return;
      }
      // take the i'nth contiguous buffered TimeRange
      var rangeStart = buffered.start(i);
      var rangeEnd = buffered.end(i);
      if (rangeEnd - rangeStart < MINIMUM_SEGMENT_SIZE) {
        log/* default */.A.warn("SI: skipped TimeRange when synchronizing because it was too small", bufferType, rangeStart, rangeEnd);
        continue;
      }
      var indexBefore = inventoryIndex; // keep track of that number
      // Find the first segment either within this TimeRange or completely past
      // it:
      // skip until first segment with at least `MINIMUM_SEGMENT_SIZE` past the
      // start of that range.
      while (thisSegment !== undefined && ((_a = thisSegment.bufferedEnd) !== null && _a !== void 0 ? _a : thisSegment.end) - rangeStart < MINIMUM_SEGMENT_SIZE) {
        thisSegment = inventory[++inventoryIndex];
      }
      // Contains infos about the last garbage-collected segment before
      // `thisSegment`.
      var lastDeletedSegmentInfos = null;
      // remove garbage-collected segments
      // (Those not in that TimeRange nor in the previous one)
      var numberOfSegmentToDelete = inventoryIndex - indexBefore;
      if (numberOfSegmentToDelete > 0) {
        var lastDeletedSegment = inventory[indexBefore + numberOfSegmentToDelete - 1]; // last garbage-collected segment
        lastDeletedSegmentInfos = {
          end: (_b = lastDeletedSegment.bufferedEnd) !== null && _b !== void 0 ? _b : lastDeletedSegment.end,
          precizeEnd: lastDeletedSegment.precizeEnd
        };
        log/* default */.A.debug("SI: " + numberOfSegmentToDelete + " segments GCed.", bufferType);
        var removed = inventory.splice(indexBefore, numberOfSegmentToDelete);
        for (var _iterator = segment_inventory_createForOfIteratorHelperLoose(removed), _step; !(_step = _iterator()).done;) {
          var seg = _step.value;
          if (seg.bufferedStart === undefined && seg.bufferedEnd === undefined && seg.status !== 2 /* ChunkStatus.Failed */) {
            this._bufferedHistory.addBufferedSegment(seg.infos, null);
          }
        }
        inventoryIndex = indexBefore;
      }
      if (thisSegment === undefined) {
        return;
      }
      // If the current segment is actually completely outside that range (it
      // is contained in one of the next one), skip that part.
      if (rangeEnd - ((_c = thisSegment.bufferedStart) !== null && _c !== void 0 ? _c : thisSegment.start) >= MINIMUM_SEGMENT_SIZE) {
        guessBufferedStartFromRangeStart(thisSegment, rangeStart, lastDeletedSegmentInfos, bufferType);
        if (inventoryIndex === inventory.length - 1) {
          // This is the last segment in the inventory.
          // We can directly update the end as the end of the current range.
          guessBufferedEndFromRangeEnd(thisSegment, rangeEnd, bufferType);
          return;
        }
        thisSegment = inventory[++inventoryIndex];
        // Make contiguous until first segment outside that range
        var thisSegmentStart = (_d = thisSegment.bufferedStart) !== null && _d !== void 0 ? _d : thisSegment.start;
        var thisSegmentEnd = (_e = thisSegment.bufferedEnd) !== null && _e !== void 0 ? _e : thisSegment.end;
        var nextRangeStart = i < rangesLength - 1 ? buffered.start(i + 1) : undefined;
        while (thisSegment !== undefined && rangeEnd - thisSegmentStart >= MINIMUM_SEGMENT_SIZE && (nextRangeStart === undefined || rangeEnd - thisSegmentStart >= thisSegmentEnd - nextRangeStart)) {
          var prevSegment = inventory[inventoryIndex - 1];
          // those segments are contiguous, we have no way to infer their real
          // end
          if (prevSegment.bufferedEnd === undefined) {
            if (thisSegment.precizeStart) {
              prevSegment.bufferedEnd = thisSegment.start;
            } else if (prevSegment.infos.segment.complete) {
              prevSegment.bufferedEnd = prevSegment.end;
            } else {
              // We cannot truly trust the anounced end here as the segment was
              // potentially not complete at its time of announce.
              // Just assume the next's segment announced start is right - as
              // `start` is in that scenario more "trustable" than `end`.
              prevSegment.bufferedEnd = thisSegment.start;
            }
            log/* default */.A.debug("SI: calculating buffered end of contiguous segment", bufferType, prevSegment.bufferedEnd, prevSegment.end);
          }
          thisSegment.bufferedStart = prevSegment.bufferedEnd;
          thisSegment = inventory[++inventoryIndex];
          if (thisSegment !== undefined) {
            thisSegmentStart = (_f = thisSegment.bufferedStart) !== null && _f !== void 0 ? _f : thisSegment.start;
            thisSegmentEnd = (_g = thisSegment.bufferedEnd) !== null && _g !== void 0 ? _g : thisSegment.end;
          }
        }
      }
      // update the bufferedEnd of the last segment in that range
      var lastSegmentInRange = inventory[inventoryIndex - 1];
      if (lastSegmentInRange !== undefined) {
        guessBufferedEndFromRangeEnd(lastSegmentInRange, rangeEnd, bufferType);
      }
    }
    // if we still have segments left, they are not affiliated to any range.
    // They might have been garbage collected, delete them from here.
    if (thisSegment != null) {
      log/* default */.A.debug("SI: last segments have been GCed", bufferType, inventoryIndex, inventory.length);
      var _removed = inventory.splice(inventoryIndex, inventory.length - inventoryIndex);
      for (var _iterator2 = segment_inventory_createForOfIteratorHelperLoose(_removed), _step2; !(_step2 = _iterator2()).done;) {
        var _seg = _step2.value;
        if (_seg.bufferedStart === undefined && _seg.bufferedEnd === undefined && _seg.status !== 2 /* ChunkStatus.Failed */) {
          this._bufferedHistory.addBufferedSegment(_seg.infos, null);
        }
      }
    }
    if (!skipLog && bufferType !== undefined && log/* default */.A.hasLevel("DEBUG")) {
      log/* default */.A.debug("SI: current " + bufferType + " inventory timeline:\n" + prettyPrintInventory(this._inventory));
    }
  }
  /**
   * Add a new chunk in the inventory.
   *
   * Chunks are decodable sub-parts of a whole segment. Once all chunks in a
   * segment have been inserted, you should call the `completeSegment` method.
   * @param {Object} chunkInformation
   * @param {boolean} succeed - If `true` the insertion operation finished with
   * success, if `false` an error arised while doing it.
   * @param {number} insertionTs - The monotonically-increasing timestamp at the
   * time the segment has been confirmed to be inserted by the buffer.
   */;
  _proto.insertChunk = function insertChunk(_ref, succeed, insertionTs) {
    var period = _ref.period,
      adaptation = _ref.adaptation,
      representation = _ref.representation,
      segment = _ref.segment,
      chunkSize = _ref.chunkSize,
      start = _ref.start,
      end = _ref.end;
    if (segment.isInit) {
      return;
    }
    var bufferType = adaptation.type;
    if (start >= end) {
      log/* default */.A.warn("SI: Invalid chunked inserted: starts before it ends", bufferType, start, end);
      return;
    }
    var inventory = this._inventory;
    var newSegment = {
      status: succeed ? 0 /* ChunkStatus.PartiallyPushed */ : 2 /* ChunkStatus.Failed */,
      insertionTs: insertionTs,
      chunkSize: chunkSize,
      splitted: false,
      start: start,
      end: end,
      precizeStart: false,
      precizeEnd: false,
      bufferedStart: undefined,
      bufferedEnd: undefined,
      infos: {
        segment: segment,
        period: period,
        adaptation: adaptation,
        representation: representation
      }
    };
    // begin by the end as in most use cases this will be faster
    for (var i = inventory.length - 1; i >= 0; i--) {
      var segmentI = inventory[i];
      if (segmentI.start <= start) {
        if (segmentI.end <= start) {
          // our segment is after, push it after this one
          //
          // Case 1:
          //   prevSegment  : |------|
          //   newSegment   :        |======|
          //   ===>         : |------|======|
          //
          // Case 2:
          //   prevSegment  : |------|
          //   newSegment   :          |======|
          //   ===>         : |------| |======|
          log/* default */.A.debug("SI: Pushing segment strictly after previous one.", bufferType, start, segmentI.end);
          this._inventory.splice(i + 1, 0, newSegment);
          i += 2; // Go to segment immediately after newSegment
          while (i < inventory.length && inventory[i].start < newSegment.end) {
            if (inventory[i].end > newSegment.end) {
              // The next segment ends after newSegment.
              // Mutate the next segment.
              //
              // Case 1:
              //   prevSegment  : |------|
              //   newSegment   :        |======|
              //   nextSegment  :            |----|
              //   ===>         : |------|======|-|
              log/* default */.A.debug("SI: Segment pushed updates the start of the next one", bufferType, newSegment.end, inventory[i].start);
              inventory[i].start = newSegment.end;
              inventory[i].bufferedStart = undefined;
              inventory[i].precizeStart = inventory[i].precizeStart && newSegment.precizeEnd;
              return;
            }
            // The next segment was completely contained in newSegment.
            // Remove it.
            //
            // Case 1:
            //   prevSegment  : |------|
            //   newSegment   :        |======|
            //   nextSegment  :          |---|
            //   ===>         : |------|======|
            //
            // Case 2:
            //   prevSegment  : |------|
            //   newSegment   :        |======|
            //   nextSegment  :          |----|
            //   ===>         : |------|======|
            log/* default */.A.debug("SI: Segment pushed removes the next one", bufferType, start, end, inventory[i].start, inventory[i].end);
            inventory.splice(i, 1);
          }
          return;
        } else {
          if (segmentI.start === start) {
            if (segmentI.end <= end) {
              // In those cases, replace
              //
              // Case 1:
              //  prevSegment  : |-------|
              //  newSegment   : |=======|
              //  ===>         : |=======|
              //
              // Case 2:
              //  prevSegment  : |-------|
              //  newSegment   : |==========|
              //  ===>         : |==========|
              log/* default */.A.debug("SI: Segment pushed replace another one", bufferType, start, end, segmentI.end);
              this._inventory.splice(i, 1, newSegment);
              i += 1; // Go to segment immediately after newSegment
              while (i < inventory.length && inventory[i].start < newSegment.end) {
                if (inventory[i].end > newSegment.end) {
                  // The next segment ends after newSegment.
                  // Mutate the next segment.
                  //
                  // Case 1:
                  //   newSegment   : |======|
                  //   nextSegment  :      |----|
                  //   ===>         : |======|--|
                  log/* default */.A.debug("SI: Segment pushed updates the start of the next one", bufferType, newSegment.end, inventory[i].start);
                  inventory[i].start = newSegment.end;
                  inventory[i].bufferedStart = undefined;
                  inventory[i].precizeStart = inventory[i].precizeStart && newSegment.precizeEnd;
                  return;
                }
                // The next segment was completely contained in newSegment.
                // Remove it.
                //
                // Case 1:
                //   newSegment   : |======|
                //   nextSegment  :   |---|
                //   ===>         : |======|
                //
                // Case 2:
                //   newSegment   : |======|
                //   nextSegment  :   |----|
                //   ===>         : |======|
                log/* default */.A.debug("SI: Segment pushed removes the next one", bufferType, start, end, inventory[i].start, inventory[i].end);
                inventory.splice(i, 1);
              }
              return;
            } else {
              // The previous segment starts at the same time and finishes
              // after the new segment.
              // Update the start of the previous segment and put the new
              // segment before.
              //
              // Case 1:
              //  prevSegment  : |------------|
              //  newSegment   : |==========|
              //  ===>         : |==========|-|
              log/* default */.A.debug("SI: Segment pushed ends before another with the same start", bufferType, start, end, segmentI.end);
              inventory.splice(i, 0, newSegment);
              segmentI.start = newSegment.end;
              segmentI.bufferedStart = undefined;
              segmentI.precizeStart = segmentI.precizeStart && newSegment.precizeEnd;
              return;
            }
          } else {
            if (segmentI.end <= newSegment.end) {
              // our segment has a "complex" relation with this one,
              // update the old one end and add this one after it.
              //
              // Case 1:
              //  prevSegment  : |-------|
              //  newSegment   :    |======|
              //  ===>         : |--|======|
              //
              // Case 2:
              //  prevSegment  : |-------|
              //  newSegment   :    |====|
              //  ===>         : |--|====|
              log/* default */.A.debug("SI: Segment pushed updates end of previous one", bufferType, start, end, segmentI.start, segmentI.end);
              this._inventory.splice(i + 1, 0, newSegment);
              segmentI.end = newSegment.start;
              segmentI.bufferedEnd = undefined;
              segmentI.precizeEnd = segmentI.precizeEnd && newSegment.precizeStart;
              i += 2; // Go to segment immediately after newSegment
              while (i < inventory.length && inventory[i].start < newSegment.end) {
                if (inventory[i].end > newSegment.end) {
                  // The next segment ends after newSegment.
                  // Mutate the next segment.
                  //
                  // Case 1:
                  //   newSegment   : |======|
                  //   nextSegment  :      |----|
                  //   ===>         : |======|--|
                  log/* default */.A.debug("SI: Segment pushed updates the start of the next one", bufferType, newSegment.end, inventory[i].start);
                  inventory[i].start = newSegment.end;
                  inventory[i].bufferedStart = undefined;
                  inventory[i].precizeStart = inventory[i].precizeStart && newSegment.precizeEnd;
                  return;
                }
                // The next segment was completely contained in newSegment.
                // Remove it.
                //
                // Case 1:
                //   newSegment   : |======|
                //   nextSegment  :   |---|
                //   ===>         : |======|
                //
                // Case 2:
                //   newSegment   : |======|
                //   nextSegment  :   |----|
                //   ===>         : |======|
                log/* default */.A.debug("SI: Segment pushed removes the next one", bufferType, start, end, inventory[i].start, inventory[i].end);
                inventory.splice(i, 1);
              }
              return;
            } else {
              // The previous segment completely recovers the new segment.
              // Split the previous segment into two segments, before and after
              // the new segment.
              //
              // Case 1:
              //  prevSegment  : |---------|
              //  newSegment   :    |====|
              //  ===>         : |--|====|-|
              log/* default */.A.warn("SI: Segment pushed is contained in a previous one", bufferType, start, end, segmentI.start, segmentI.end);
              var nextSegment = {
                status: segmentI.status,
                insertionTs: segmentI.insertionTs,
                /**
                 * Note: this sadly means we're doing as if
                 * that chunk is present two times.
                 * Thankfully, this scenario should be
                 * fairly rare.
                 */
                chunkSize: segmentI.chunkSize,
                splitted: true,
                start: newSegment.end,
                end: segmentI.end,
                precizeStart: segmentI.precizeStart && segmentI.precizeEnd && newSegment.precizeEnd,
                precizeEnd: segmentI.precizeEnd,
                bufferedStart: undefined,
                bufferedEnd: segmentI.end,
                infos: segmentI.infos
              };
              segmentI.end = newSegment.start;
              segmentI.splitted = true;
              segmentI.bufferedEnd = undefined;
              segmentI.precizeEnd = segmentI.precizeEnd && newSegment.precizeStart;
              inventory.splice(i + 1, 0, newSegment);
              inventory.splice(i + 2, 0, nextSegment);
              return;
            }
          }
        }
      }
    }
    // if we got here, we are at the first segment
    // check bounds of the previous first segment
    var firstSegment = this._inventory[0];
    if (firstSegment === undefined) {
      // we do not have any segment yet
      log/* default */.A.debug("SI: first segment pushed", bufferType, start, end);
      this._inventory.push(newSegment);
      return;
    }
    if (firstSegment.start >= end) {
      // our segment is before, put it before
      //
      // Case 1:
      //  firstSegment :      |----|
      //  newSegment   : |====|
      //  ===>         : |====|----|
      //
      // Case 2:
      //  firstSegment :        |----|
      //  newSegment   : |====|
      //  ===>         : |====| |----|
      log/* default */.A.debug("SI: Segment pushed comes before all previous ones", bufferType, start, end, firstSegment.start);
      this._inventory.splice(0, 0, newSegment);
    } else if (firstSegment.end <= end) {
      // Our segment is bigger, replace the first
      //
      // Case 1:
      //  firstSegment :   |---|
      //  newSegment   : |=======|
      //  ===>         : |=======|
      //
      // Case 2:
      //  firstSegment :   |-----|
      //  newSegment   : |=======|
      //  ===>         : |=======|
      log/* default */.A.debug("SI: Segment pushed starts before and completely " + "recovers the previous first one", bufferType, start, end, firstSegment.start, firstSegment.end);
      this._inventory.splice(0, 1, newSegment);
      while (inventory.length > 1 && inventory[1].start < newSegment.end) {
        if (inventory[1].end > newSegment.end) {
          // The next segment ends after newSegment.
          // Mutate the next segment.
          //
          // Case 1:
          //   newSegment   : |======|
          //   nextSegment  :      |----|
          //   ===>         : |======|--|
          log/* default */.A.debug("SI: Segment pushed updates the start of the next one", bufferType, newSegment.end, inventory[1].start);
          inventory[1].start = newSegment.end;
          inventory[1].bufferedStart = undefined;
          inventory[1].precizeStart = newSegment.precizeEnd;
          return;
        }
        // The next segment was completely contained in newSegment.
        // Remove it.
        //
        // Case 1:
        //   newSegment   : |======|
        //   nextSegment  :   |---|
        //   ===>         : |======|
        //
        // Case 2:
        //   newSegment   : |======|
        //   nextSegment  :   |----|
        //   ===>         : |======|
        log/* default */.A.debug("SI: Segment pushed removes the next one", bufferType, start, end, inventory[1].start, inventory[1].end);
        inventory.splice(1, 1);
      }
      return;
    } else {
      // our segment has a "complex" relation with the first one,
      // update the old one start and add this one before it.
      //
      // Case 1:
      //  firstSegment :    |------|
      //  newSegment   : |======|
      //  ===>         : |======|--|
      log/* default */.A.debug("SI: Segment pushed start of the next one", bufferType, start, end, firstSegment.start, firstSegment.end);
      firstSegment.start = end;
      firstSegment.bufferedStart = undefined;
      firstSegment.precizeStart = newSegment.precizeEnd;
      this._inventory.splice(0, 0, newSegment);
      return;
    }
  }
  /**
   * Indicate that inserted chunks can now be considered as a fully-loaded
   * segment.
   * Take in argument the same content than what was given to `insertChunk` for
   * the corresponding chunks.
   * @param {Object} content
   */;
  _proto.completeSegment = function completeSegment(content, newBuffered) {
    if (content.segment.isInit) {
      return;
    }
    var inventory = this._inventory;
    var resSegments = [];
    for (var i = 0; i < inventory.length; i++) {
      if ((0,utils/* areSameContent */.Q)(inventory[i].infos, content)) {
        var splitted = false;
        if (resSegments.length > 0) {
          splitted = true;
          if (resSegments.length === 1) {
            log/* default */.A.warn("SI: Completed Segment is splitted.", content.segment.id, content.segment.time, content.segment.end);
            resSegments[0].splitted = true;
          }
        }
        var firstI = i;
        var segmentSize = inventory[i].chunkSize;
        i += 1;
        while (i < inventory.length && (0,utils/* areSameContent */.Q)(inventory[i].infos, content)) {
          var chunkSize = inventory[i].chunkSize;
          if (segmentSize !== undefined && chunkSize !== undefined) {
            segmentSize += chunkSize;
          }
          i++;
        }
        var lastI = i - 1;
        var length = lastI - firstI;
        var lastEnd = inventory[lastI].end;
        var lastBufferedEnd = inventory[lastI].bufferedEnd;
        if (length > 0) {
          this._inventory.splice(firstI + 1, length);
          i -= length;
        }
        if (this._inventory[firstI].status === 0 /* ChunkStatus.PartiallyPushed */) {
          this._inventory[firstI].status = 1 /* ChunkStatus.FullyLoaded */;
        }
        this._inventory[firstI].chunkSize = segmentSize;
        this._inventory[firstI].end = lastEnd;
        this._inventory[firstI].bufferedEnd = lastBufferedEnd;
        this._inventory[firstI].splitted = splitted;
        resSegments.push(this._inventory[firstI]);
      }
    }
    if (resSegments.length === 0) {
      log/* default */.A.warn("SI: Completed Segment not found", content.segment.id, content.segment.time);
    } else {
      this.synchronizeBuffered(newBuffered);
      for (var _iterator3 = segment_inventory_createForOfIteratorHelperLoose(resSegments), _step3; !(_step3 = _iterator3()).done;) {
        var seg = _step3.value;
        if (seg.bufferedStart !== undefined && seg.bufferedEnd !== undefined) {
          if (seg.status !== 2 /* ChunkStatus.Failed */) {
            this._bufferedHistory.addBufferedSegment(seg.infos, {
              start: seg.bufferedStart,
              end: seg.bufferedEnd
            });
          }
        } else {
          // TODO FIXME There might be a false positive here when the
          // `SEGMENT_SYNCHRONIZATION_DELAY` config value is at play
          log/* default */.A.debug("SI: buffered range not known after sync. Skipping history.", seg.start, seg.end);
        }
      }
    }
  }
  /**
   * Returns the whole inventory.
   *
   * To get a list synchronized with what a media buffer actually has buffered
   * you might want to call `synchronizeBuffered` before calling this method.
   * @returns {Array.<Object>}
   */;
  _proto.getInventory = function getInventory() {
    return this._inventory;
  }
  /**
   * Returns a recent history of registered operations performed and event
   * received linked to the segment given in argument.
   *
   * Not all operations and events are registered in the returned history.
   * Please check the return type for more information on what is available.
   *
   * Note that history is short-lived for memory usage and performance reasons.
   * You may not receive any information on operations that happened too long
   * ago.
   * @param {Object} context
   * @returns {Array.<Object>}
   */;
  _proto.getHistoryFor = function getHistoryFor(context) {
    return this._bufferedHistory.getHistoryFor(context);
  };
  return SegmentInventory;
}();
/**
 * Returns `true` if the buffered start of the given chunk looks coherent enough
 * relatively to what is announced in the Manifest.
 * @param {Object} thisSegment
 * @returns {Boolean}
 */

function bufferedStartLooksCoherent(thisSegment) {
  if (thisSegment.bufferedStart === undefined || thisSegment.status !== 1 /* ChunkStatus.FullyLoaded */) {
    return false;
  }
  var start = thisSegment.start,
    end = thisSegment.end;
  var duration = end - start;
  var _config$getCurrent3 = config/* default */.A.getCurrent(),
    MAX_MANIFEST_BUFFERED_START_END_DIFFERENCE = _config$getCurrent3.MAX_MANIFEST_BUFFERED_START_END_DIFFERENCE,
    MAX_MANIFEST_BUFFERED_DURATION_DIFFERENCE = _config$getCurrent3.MAX_MANIFEST_BUFFERED_DURATION_DIFFERENCE;
  return Math.abs(start - thisSegment.bufferedStart) <= MAX_MANIFEST_BUFFERED_START_END_DIFFERENCE && (thisSegment.bufferedEnd === undefined || thisSegment.bufferedEnd > thisSegment.bufferedStart && Math.abs(thisSegment.bufferedEnd - thisSegment.bufferedStart - duration) <= Math.min(MAX_MANIFEST_BUFFERED_DURATION_DIFFERENCE, duration / 3));
}
/**
 * Returns `true` if the buffered end of the given chunk looks coherent enough
 * relatively to what is announced in the Manifest.
 * @param {Object} thisSegment
 * @returns {Boolean}
 */
function bufferedEndLooksCoherent(thisSegment) {
  if (thisSegment.bufferedEnd === undefined || !thisSegment.infos.segment.complete || thisSegment.status !== 1 /* ChunkStatus.FullyLoaded */) {
    return false;
  }
  var start = thisSegment.start,
    end = thisSegment.end;
  var duration = end - start;
  var _config$getCurrent4 = config/* default */.A.getCurrent(),
    MAX_MANIFEST_BUFFERED_START_END_DIFFERENCE = _config$getCurrent4.MAX_MANIFEST_BUFFERED_START_END_DIFFERENCE,
    MAX_MANIFEST_BUFFERED_DURATION_DIFFERENCE = _config$getCurrent4.MAX_MANIFEST_BUFFERED_DURATION_DIFFERENCE;
  return Math.abs(end - thisSegment.bufferedEnd) <= MAX_MANIFEST_BUFFERED_START_END_DIFFERENCE && thisSegment.bufferedStart != null && thisSegment.bufferedEnd > thisSegment.bufferedStart && Math.abs(thisSegment.bufferedEnd - thisSegment.bufferedStart - duration) <= Math.min(MAX_MANIFEST_BUFFERED_DURATION_DIFFERENCE, duration / 3);
}
/**
 * Evaluate the given buffered Chunk's buffered start from its range's start,
 * considering that this chunk is the first one in it.
 * @param {Object} firstSegmentInRange
 * @param {number} rangeStart
 * @param {Object} lastDeletedSegmentInfos
 */
function guessBufferedStartFromRangeStart(firstSegmentInRange, rangeStart, lastDeletedSegmentInfos, bufferType) {
  var _config$getCurrent5 = config/* default */.A.getCurrent(),
    MAX_MANIFEST_BUFFERED_START_END_DIFFERENCE = _config$getCurrent5.MAX_MANIFEST_BUFFERED_START_END_DIFFERENCE,
    MISSING_DATA_TRIGGER_SYNC_DELAY = _config$getCurrent5.MISSING_DATA_TRIGGER_SYNC_DELAY,
    SEGMENT_SYNCHRONIZATION_DELAY = _config$getCurrent5.SEGMENT_SYNCHRONIZATION_DELAY;
  if (firstSegmentInRange.bufferedStart !== undefined) {
    if (firstSegmentInRange.bufferedStart < rangeStart) {
      log/* default */.A.debug("SI: Segment partially GCed at the start", bufferType, firstSegmentInRange.bufferedStart, rangeStart);
      firstSegmentInRange.bufferedStart = rangeStart;
    }
    if (!firstSegmentInRange.precizeStart && bufferedStartLooksCoherent(firstSegmentInRange)) {
      firstSegmentInRange.start = firstSegmentInRange.bufferedStart;
      firstSegmentInRange.precizeStart = true;
    }
  } else if (firstSegmentInRange.precizeStart) {
    log/* default */.A.debug("SI: buffered start is precize start", bufferType, firstSegmentInRange.start);
    firstSegmentInRange.bufferedStart = firstSegmentInRange.start;
  } else if (lastDeletedSegmentInfos !== null && lastDeletedSegmentInfos.end > rangeStart && (lastDeletedSegmentInfos.precizeEnd || firstSegmentInRange.start - lastDeletedSegmentInfos.end <= MAX_MANIFEST_BUFFERED_START_END_DIFFERENCE)) {
    log/* default */.A.debug("SI: buffered start is end of previous segment", bufferType, rangeStart, firstSegmentInRange.start, lastDeletedSegmentInfos.end);
    firstSegmentInRange.bufferedStart = lastDeletedSegmentInfos.end;
    if (bufferedStartLooksCoherent(firstSegmentInRange)) {
      firstSegmentInRange.start = lastDeletedSegmentInfos.end;
      firstSegmentInRange.precizeStart = true;
    }
  } else if (firstSegmentInRange.start - rangeStart <= MAX_MANIFEST_BUFFERED_START_END_DIFFERENCE) {
    var now = performance.now();
    if (firstSegmentInRange.start - rangeStart >= MISSING_DATA_TRIGGER_SYNC_DELAY && now - firstSegmentInRange.insertionTs < SEGMENT_SYNCHRONIZATION_DELAY) {
      log/* default */.A.debug("SI: Ignored bufferedStart synchronization", bufferType, rangeStart, firstSegmentInRange.start, now - firstSegmentInRange.insertionTs);
      return;
    }
    log/* default */.A.debug("SI: found true buffered start", bufferType, rangeStart, firstSegmentInRange.start);
    firstSegmentInRange.bufferedStart = rangeStart;
    if (bufferedStartLooksCoherent(firstSegmentInRange)) {
      firstSegmentInRange.start = rangeStart;
      firstSegmentInRange.precizeStart = true;
    }
  } else if (rangeStart < firstSegmentInRange.start) {
    log/* default */.A.debug("SI: range start too far from expected start", bufferType, rangeStart, firstSegmentInRange.start);
    firstSegmentInRange.bufferedStart = firstSegmentInRange.start;
  } else {
    var _now = performance.now();
    if (firstSegmentInRange.start - rangeStart >= MISSING_DATA_TRIGGER_SYNC_DELAY && _now - firstSegmentInRange.insertionTs < SEGMENT_SYNCHRONIZATION_DELAY) {
      log/* default */.A.debug("SI: Ignored bufferedStart synchronization", bufferType, rangeStart, firstSegmentInRange.start, _now - firstSegmentInRange.insertionTs);
      return;
    }
    log/* default */.A.debug("SI: Segment appears immediately garbage collected at the start", bufferType, rangeStart, firstSegmentInRange.start);
    firstSegmentInRange.bufferedStart = rangeStart;
  }
}
/**
 * Evaluate the given buffered Chunk's buffered end from its range's end,
 * considering that this chunk is the last one in it.
 * @param {Object} lastSegmentInRange
 * @param {number} rangeEnd
 * @param {string} bufferType
 */
function guessBufferedEndFromRangeEnd(lastSegmentInRange, rangeEnd, bufferType) {
  var _config$getCurrent6 = config/* default */.A.getCurrent(),
    MAX_MANIFEST_BUFFERED_START_END_DIFFERENCE = _config$getCurrent6.MAX_MANIFEST_BUFFERED_START_END_DIFFERENCE,
    MISSING_DATA_TRIGGER_SYNC_DELAY = _config$getCurrent6.MISSING_DATA_TRIGGER_SYNC_DELAY,
    SEGMENT_SYNCHRONIZATION_DELAY = _config$getCurrent6.SEGMENT_SYNCHRONIZATION_DELAY;
  if (lastSegmentInRange.bufferedEnd !== undefined) {
    if (lastSegmentInRange.bufferedEnd > rangeEnd) {
      log/* default */.A.debug("SI: Segment partially GCed at the end", bufferType, lastSegmentInRange.bufferedEnd, rangeEnd);
      lastSegmentInRange.bufferedEnd = rangeEnd;
    }
    if (!lastSegmentInRange.precizeEnd && rangeEnd - lastSegmentInRange.end <= MAX_MANIFEST_BUFFERED_START_END_DIFFERENCE && bufferedEndLooksCoherent(lastSegmentInRange)) {
      lastSegmentInRange.precizeEnd = true;
      lastSegmentInRange.end = rangeEnd;
    }
  } else if (lastSegmentInRange.precizeEnd) {
    log/* default */.A.debug("SI: buffered end is precize end", bufferType, lastSegmentInRange.end);
    lastSegmentInRange.bufferedEnd = lastSegmentInRange.end;
  } else if (rangeEnd - lastSegmentInRange.end <= MAX_MANIFEST_BUFFERED_START_END_DIFFERENCE || !lastSegmentInRange.infos.segment.complete) {
    var now = performance.now();
    if (rangeEnd - lastSegmentInRange.end >= MISSING_DATA_TRIGGER_SYNC_DELAY && now - lastSegmentInRange.insertionTs < SEGMENT_SYNCHRONIZATION_DELAY) {
      log/* default */.A.debug("SI: Ignored bufferedEnd synchronization", bufferType, rangeEnd, lastSegmentInRange.end, now - lastSegmentInRange.insertionTs);
      return;
    }
    log/* default */.A.debug("SI: found true buffered end", bufferType, rangeEnd, lastSegmentInRange.end);
    lastSegmentInRange.bufferedEnd = rangeEnd;
    if (bufferedEndLooksCoherent(lastSegmentInRange)) {
      lastSegmentInRange.end = rangeEnd;
      lastSegmentInRange.precizeEnd = true;
    }
  } else if (rangeEnd > lastSegmentInRange.end) {
    log/* default */.A.debug("SI: range end too far from expected end", bufferType, rangeEnd, lastSegmentInRange.end);
    lastSegmentInRange.bufferedEnd = lastSegmentInRange.end;
  } else {
    var _now2 = performance.now();
    if (rangeEnd - lastSegmentInRange.end >= MISSING_DATA_TRIGGER_SYNC_DELAY && _now2 - lastSegmentInRange.insertionTs < SEGMENT_SYNCHRONIZATION_DELAY) {
      log/* default */.A.debug("SI: Ignored bufferedEnd synchronization", bufferType, rangeEnd, lastSegmentInRange.end, _now2 - lastSegmentInRange.insertionTs);
      return;
    }
    log/* default */.A.debug("SI: Segment appears immediately garbage collected at the end", bufferType, lastSegmentInRange.bufferedEnd, rangeEnd);
    lastSegmentInRange.bufferedEnd = rangeEnd;
  }
}
/**
 * Pretty print the inventory, to easily note which segments are where in the
 * current buffer.
 *
 * This is mostly useful when logging.
 *
 * @example
 * This function is called by giving it the inventory, such as:
 * ```js
 * prettyPrintInventory(inventory);
 * ```
 *
 * Let's consider this possible return:
 * ```
 * 0.00|A|9.00 ~ 9.00|B|45.08 ~ 282.08|B|318.08
 * [A] P: gen-dash-period-0 || R: video/5(2362822)
 * [B] P: gen-dash-period-0 || R: video/6(2470094)
 * ```
 * We have a first part, from 0 to 9 seconds, which contains segments for
 * the Representation with the id "video/5" and an associated bitrate of
 * 2362822 bits per seconds (in the Period with the id "gen-dash-period-0").
 *
 * Then from 9.00 seconds to 45.08 seconds, we have segments from another
 * Representation from the same Period (with the id "video/6" and a bitrate
 * of 2470094 bits per seconds).
 *
 * At last we have a long time between 45.08 and 282.08 with no segment followed
 * by a segment from that same Representation between 282.08 seconds and 318.08
 * seconds.
 * @param {Array.<Object>} inventory
 * @returns {string}
 */
function prettyPrintInventory(inventory) {
  var roundingError = 1 / 60;
  var encounteredReps = {};
  var letters = [];
  var lastChunk = null;
  var lastLetter = null;
  function generateNewLetter(infos) {
    var currentLetter = String.fromCharCode(letters.length + 65);
    letters.push({
      letter: currentLetter,
      periodId: infos.period.id,
      representationId: infos.representation.id,
      bitrate: infos.representation.bitrate
    });
    return currentLetter;
  }
  var str = "";
  for (var i = 0; i < inventory.length; i++) {
    var chunk = inventory[i];
    if (chunk.bufferedStart !== undefined && chunk.bufferedEnd !== undefined) {
      var periodId = chunk.infos.period.id;
      var representationId = chunk.infos.representation.id;
      var encounteredPeriod = encounteredReps[periodId];
      var currentLetter = void 0;
      if (encounteredPeriod === undefined) {
        var _encounteredReps$peri;
        currentLetter = generateNewLetter(chunk.infos);
        encounteredReps[periodId] = (_encounteredReps$peri = {}, _encounteredReps$peri[representationId] = currentLetter, _encounteredReps$peri);
      } else if (encounteredPeriod[representationId] === undefined) {
        currentLetter = generateNewLetter(chunk.infos);
        encounteredPeriod[representationId] = currentLetter;
      } else {
        currentLetter = encounteredPeriod[representationId];
      }
      if (lastChunk === null) {
        str += chunk.bufferedStart.toFixed(2) + "|" + currentLetter + "|";
      } else if (lastLetter === currentLetter) {
        if (lastChunk.bufferedEnd + roundingError < chunk.bufferedStart) {
          str += lastChunk.bufferedEnd.toFixed(2) + " ~ " + (chunk.bufferedStart.toFixed(2) + "|" + currentLetter + "|");
        }
      } else {
        str += lastChunk.bufferedEnd.toFixed(2) + " ~ " + (chunk.bufferedStart.toFixed(2) + "|" + currentLetter + "|");
      }
      lastChunk = chunk;
      lastLetter = currentLetter;
    }
  }
  if (lastChunk !== null) {
    str += String(lastChunk.end.toFixed(2));
  }
  letters.forEach(function (letterInfo) {
    var _a;
    str += "\n[" + letterInfo.letter + "] " + ("P: " + letterInfo.periodId + " || R: " + letterInfo.representationId) + ("(" + ((_a = letterInfo.bitrate) !== null && _a !== void 0 ? _a : "unknown bitrate") + ")");
  });
  return str;
}
;// CONCATENATED MODULE: ./src/core/segment_buffers/inventory/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ var inventory = (SegmentInventory);
;// CONCATENATED MODULE: ./src/core/segment_buffers/implementations/types.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Class allowing to push segments and remove data to a buffer to be able
 * to decode them in the future as well as retrieving information about which
 * segments have already been pushed.
 *
 * A `SegmentBuffer` can rely on a browser's SourceBuffer as well as being
 * entirely defined in the code.
 *
 * A SegmentBuffer is associated to a given "bufferType" (e.g. "audio",
 * "video", "text") and allows to push segments as well as removing part of
 * already-pushed segments for that type.
 *
 * Because a segment can be divided into multiple chunks, one should call the
 * `endOfSegment` method once all chunks of a given segment have been pushed
 * (through the `pushChunk` method) to validate that a segment has been
 * completely pushed.
 * It is expected to push chunks from only one segment at a time before calling
 * the `endOfSegment` function for that segment. Pushing chunks from multiple
 * segments in parallel could have unexpected result depending on the underlying
 * implementation.
 * TODO reflect that in the API?
 *
 * A SegmentBuffer also maintains an "inventory", which is the current
 * list of segments contained in the underlying buffer.
 * This inventory has to be manually "synchronized" (through the
 * `synchronizeInventory` method) before being retrieved (through the
 * `getInventory` method).
 *
 * Also depending on the underlying implementation, the various operations
 * performed on a `SegmentBuffer` (push/remove/endOfSegment) can happen
 * synchronously or asynchronously.
 * In the latter case, such operations are put in a FIFO Queue.
 * You can retrieve the current queue of operations by calling the
 * `getPendingOperations` method.
 * If operations happens synchronously, this method will just return an empty
 * array.
 */
var SegmentBuffer = /*#__PURE__*/function () {
  function SegmentBuffer() {
    // Use SegmentInventory by default for inventory purposes
    this._segmentInventory = new inventory();
  }
  /**
   * The maintained inventory can fall out of sync from garbage collection or
   * other events.
   *
   * This methods allow to manually trigger a synchronization. It should be
   * called before retrieving Segment information from it (e.g. with
   * `getInventory`).
   * @param {boolean} [skipLog] - This method may trigger a voluminous debug
   * log once synchronization is finished if debug logs are enabled.
   * As this method might be called very often in some specific debugging
   * situations, setting this value to `true` allows to prevent the call from
   * triggering a log.
   */
  var _proto = SegmentBuffer.prototype;
  _proto.synchronizeInventory = function synchronizeInventory(skipLog) {
    // The default implementation just use the SegmentInventory
    this._segmentInventory.synchronizeBuffered(this.getBufferedRanges(), skipLog);
  }
  /**
   * Returns the currently buffered data for which the content is known with
   * the corresponding content information.
   * /!\ This data can fall out of sync with the real buffered ranges. Please
   * call `synchronizeInventory` before to make sure it is correctly
   * synchronized.
   * @returns {Array.<Object>}
   */;
  _proto.getInventory = function getInventory() {
    // The default implementation just use the SegmentInventory
    return this._segmentInventory.getInventory();
  }
  /**
   * Returns the list of every operations that the `SegmentBuffer` is still
   * processing. From the one with the highest priority (like the one being
   * processed)
   * @returns {Array.<Object>}
   */;
  _proto.getPendingOperations = function getPendingOperations() {
    // Return no pending operation by default (for synchronous SegmentBuffers)
    return [];
  }
  /**
   * Returns a recent history of registered operations performed and event
   * received linked to the segment given in argument.
   *
   * Not all operations and events are registered in the returned history.
   * Please check the return type for more information on what is available.
   *
   * Note that history is short-lived for memory usage and performance reasons.
   * You may not receive any information on operations that happened too long
   * ago.
   * @param {Object} context
   * @returns {Array.<Object>}
   */;
  _proto.getSegmentHistory = function getSegmentHistory(context) {
    return this._segmentInventory.getHistoryFor(context);
  };
  return SegmentBuffer;
}();
/**
 * Enum used by a SegmentBuffer as a discriminant in its queue of
 * "operations".
 */
var SegmentBufferOperation;
(function (SegmentBufferOperation) {
  SegmentBufferOperation[SegmentBufferOperation["Push"] = 0] = "Push";
  SegmentBufferOperation[SegmentBufferOperation["Remove"] = 1] = "Remove";
  SegmentBufferOperation[SegmentBufferOperation["EndOfSegment"] = 2] = "EndOfSegment";
})(SegmentBufferOperation || (SegmentBufferOperation = {}));

/***/ }),

/***/ 3481:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: function() { return /* binding */ ManualTimeRanges; }
/* harmony export */ });
/* harmony import */ var _utils_ranges__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3650);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Simulate TimeRanges as returned by SourceBuffer.prototype.buffered.
 * Add an "insert" and "remove" methods to manually update it.
 * @class ManualTimeRanges
 */
var ManualTimeRanges = /*#__PURE__*/function () {
  function ManualTimeRanges() {
    this._ranges = [];
    this.length = 0;
  }
  var _proto = ManualTimeRanges.prototype;
  _proto.insert = function insert(start, end) {
    if (false) {}
    (0,_utils_ranges__WEBPACK_IMPORTED_MODULE_0__/* .insertInto */ .C$)(this._ranges, {
      start: start,
      end: end
    });
    this.length = this._ranges.length;
  };
  _proto.remove = function remove(start, end) {
    if (false) {}
    var rangesToIntersect = [];
    if (start > 0) {
      rangesToIntersect.push({
        start: 0,
        end: start
      });
    }
    if (end < Infinity) {
      rangesToIntersect.push({
        start: end,
        end: Infinity
      });
    }
    this._ranges = (0,_utils_ranges__WEBPACK_IMPORTED_MODULE_0__/* .keepRangeIntersection */ .aW)(this._ranges, rangesToIntersect);
    this.length = this._ranges.length;
  };
  _proto.start = function start(index) {
    if (index >= this._ranges.length) {
      throw new Error("INDEX_SIZE_ERROR");
    }
    return this._ranges[index].start;
  };
  _proto.end = function end(index) {
    if (index >= this._ranges.length) {
      throw new Error("INDEX_SIZE_ERROR");
    }
    return this._ranges[index].end;
  };
  return ManualTimeRanges;
}();


/***/ }),

/***/ 7004:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: function() { return /* binding */ CustomLoaderError; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7387);
/* harmony import */ var _babel_runtime_helpers_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8593);


/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Internal error used to better handle errors happening when a custom
 * `segmentLoader` or `manifestLoader` has been used.
 *
 * It is not part of the API, as such it is only a temporary error which is
 * later converted to another Error instance (e.g. NETWORK_ERROR).
 * @class CustomLoaderError
 * @extends Error
 */
var CustomLoaderError = /*#__PURE__*/function (_Error) {
  /**
   * @param {string} message
   * @param {boolean} canRetry
   * @param {boolean} isOfflineError
   * @param {XMLHttpRequest} xhr
   */
  function CustomLoaderError(message, canRetry, isOfflineError, xhr) {
    var _this;
    _this = _Error.call(this, message) || this;
    // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class
    Object.setPrototypeOf(_this, CustomLoaderError.prototype);
    _this.name = "CustomLoaderError";
    _this.canRetry = canRetry;
    _this.isOfflineError = isOfflineError;
    _this.xhr = xhr;
    return _this;
  }
  (0,_babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(CustomLoaderError, _Error);
  return CustomLoaderError;
}( /*#__PURE__*/(0,_babel_runtime_helpers_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(Error));


/***/ }),

/***/ 1956:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: function() { return /* binding */ EncryptedMediaError; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7387);
/* harmony import */ var _babel_runtime_helpers_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(8593);
/* harmony import */ var _error_codes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5497);
/* harmony import */ var _error_message__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2620);


/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Error linked to the encryption of the media.
 *
 * @class EncryptedMediaError
 * @extends Error
 */
var EncryptedMediaError = /*#__PURE__*/function (_Error) {
  function EncryptedMediaError(code, reason, supplementaryInfos) {
    var _this;
    _this = _Error.call(this, (0,_error_message__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)("EncryptedMediaError", code, reason)) || this;
    // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class
    Object.setPrototypeOf(_this, EncryptedMediaError.prototype);
    _this.name = "EncryptedMediaError";
    _this.type = _error_codes__WEBPACK_IMPORTED_MODULE_1__/* .ErrorTypes */ .wU.ENCRYPTED_MEDIA_ERROR;
    _this.code = code;
    _this.fatal = false;
    if (typeof (supplementaryInfos === null || supplementaryInfos === void 0 ? void 0 : supplementaryInfos.keyStatuses) === "string") {
      _this.keyStatuses = supplementaryInfos.keyStatuses;
    }
    return _this;
  }
  (0,_babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A)(EncryptedMediaError, _Error);
  return EncryptedMediaError;
}( /*#__PURE__*/(0,_babel_runtime_helpers_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A)(Error));


/***/ }),

/***/ 5497:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   tG: function() { return /* binding */ ErrorCodes; },
/* harmony export */   wU: function() { return /* binding */ ErrorTypes; },
/* harmony export */   yl: function() { return /* binding */ NetworkErrorTypes; }
/* harmony export */ });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var ErrorTypes = {
  NETWORK_ERROR: "NETWORK_ERROR",
  MEDIA_ERROR: "MEDIA_ERROR",
  ENCRYPTED_MEDIA_ERROR: "ENCRYPTED_MEDIA_ERROR",
  OTHER_ERROR: "OTHER_ERROR"
};
var NetworkErrorTypes = {
  TIMEOUT: "TIMEOUT",
  ERROR_EVENT: "ERROR_EVENT",
  ERROR_HTTP_CODE: "ERROR_HTTP_CODE",
  PARSE_ERROR: "PARSE_ERROR"
};
var ErrorCodes = {
  PIPELINE_LOAD_ERROR: "PIPELINE_LOAD_ERROR",
  PIPELINE_PARSE_ERROR: "PIPELINE_PARSE_ERROR",
  INTEGRITY_ERROR: "INTEGRITY_ERROR",
  MANIFEST_PARSE_ERROR: "MANIFEST_PARSE_ERROR",
  MANIFEST_INCOMPATIBLE_CODECS_ERROR: "MANIFEST_INCOMPATIBLE_CODECS_ERROR",
  MANIFEST_UPDATE_ERROR: "MANIFEST_UPDATE_ERROR",
  MANIFEST_UNSUPPORTED_ADAPTATION_TYPE: "MANIFEST_UNSUPPORTED_ADAPTATION_TYPE",
  MEDIA_STARTING_TIME_NOT_FOUND: "MEDIA_STARTING_TIME_NOT_FOUND",
  MEDIA_TIME_BEFORE_MANIFEST: "MEDIA_TIME_BEFORE_MANIFEST",
  MEDIA_TIME_AFTER_MANIFEST: "MEDIA_TIME_AFTER_MANIFEST",
  MEDIA_TIME_NOT_FOUND: "MEDIA_TIME_NOT_FOUND",
  NO_PLAYABLE_REPRESENTATION: "NO_PLAYABLE_REPRESENTATION",
  MEDIA_IS_ENCRYPTED_ERROR: "MEDIA_IS_ENCRYPTED_ERROR",
  CREATE_MEDIA_KEYS_ERROR: "CREATE_MEDIA_KEYS_ERROR",
  KEY_ERROR: "KEY_ERROR",
  KEY_STATUS_CHANGE_ERROR: "KEY_STATUS_CHANGE_ERROR",
  KEY_UPDATE_ERROR: "KEY_UPDATE_ERROR",
  KEY_LOAD_ERROR: "KEY_LOAD_ERROR",
  KEY_LOAD_TIMEOUT: "KEY_LOAD_TIMEOUT",
  KEY_GENERATE_REQUEST_ERROR: "KEY_GENERATE_REQUEST_ERROR",
  INCOMPATIBLE_KEYSYSTEMS: "INCOMPATIBLE_KEYSYSTEMS",
  INVALID_ENCRYPTED_EVENT: "INVALID_ENCRYPTED_EVENT",
  INVALID_KEY_SYSTEM: "INVALID_KEY_SYSTEM",
  LICENSE_SERVER_CERTIFICATE_ERROR: "LICENSE_SERVER_CERTIFICATE_ERROR",
  MULTIPLE_SESSIONS_SAME_INIT_DATA: "MULTIPLE_SESSIONS_SAME_INIT_DATA",
  BUFFER_APPEND_ERROR: "BUFFER_APPEND_ERROR",
  BUFFER_FULL_ERROR: "BUFFER_FULL_ERROR",
  BUFFER_TYPE_UNKNOWN: "BUFFER_TYPE_UNKNOWN",
  MEDIA_ERR_BLOCKED_AUTOPLAY: "MEDIA_ERR_BLOCKED_AUTOPLAY",
  MEDIA_ERR_PLAY_NOT_ALLOWED: "MEDIA_ERR_PLAY_NOT_ALLOWED",
  MEDIA_ERR_NOT_LOADED_METADATA: "MEDIA_ERR_NOT_LOADED_METADATA",
  MEDIA_ERR_ABORTED: "MEDIA_ERR_ABORTED",
  MEDIA_ERR_NETWORK: "MEDIA_ERR_NETWORK",
  MEDIA_ERR_DECODE: "MEDIA_ERR_DECODE",
  MEDIA_ERR_SRC_NOT_SUPPORTED: "MEDIA_ERR_SRC_NOT_SUPPORTED",
  MEDIA_ERR_UNKNOWN: "MEDIA_ERR_UNKNOWN",
  MEDIA_SOURCE_NOT_SUPPORTED: "MEDIA_SOURCE_NOT_SUPPORTED",
  MEDIA_KEYS_NOT_SUPPORTED: "MEDIA_KEYS_NOT_SUPPORTED",
  DISCONTINUITY_ENCOUNTERED: "DISCONTINUITY_ENCOUNTERED",
  NONE: "NONE"
};


/***/ }),

/***/ 2620:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: function() { return /* binding */ errorMessage; }
/* harmony export */ });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Generate a normalized error message.
 * @param {string} name
 * @param {string} code
 * @param {Error|string|Event|null} [reason]
 * @returns {string}
 */
function errorMessage(name, code, reason) {
  return name + " (" + code + ") " + reason;
}

/***/ }),

/***/ 874:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: function() { return /* binding */ formatError; }
/* harmony export */ });
/* harmony import */ var _is_known_error__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4637);
/* harmony import */ var _other_error__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1858);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/*
 * Format an unknown error into an API-defined error.
 * @param {*} error
 * @returns {Error}
 */
function formatError(error, _ref) {
  var defaultCode = _ref.defaultCode,
    defaultReason = _ref.defaultReason;
  if ((0,_is_known_error__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(error)) {
    return error;
  }
  var reason = error instanceof Error ? error.toString() : defaultReason;
  return new _other_error__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A(defaultCode, reason);
}

/***/ }),

/***/ 4637:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: function() { return /* binding */ isKnownError; }
/* harmony export */ });
/* harmony import */ var _encrypted_media_error__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1956);
/* harmony import */ var _error_codes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(5497);
/* harmony import */ var _media_error__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5575);
/* harmony import */ var _network_error__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7941);
/* harmony import */ var _other_error__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1858);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * Whether the error given is a ICustomError.
 * @param {Error} error
 * @returns {Boolean}
 */
function isKnownError(error) {
  return (error instanceof _encrypted_media_error__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A || error instanceof _media_error__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A || error instanceof _other_error__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A || error instanceof _network_error__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A) && Object.keys(_error_codes__WEBPACK_IMPORTED_MODULE_4__/* .ErrorTypes */ .wU).indexOf(error.type) >= 0;
}

/***/ }),

/***/ 5575:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: function() { return /* binding */ MediaError; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7387);
/* harmony import */ var _babel_runtime_helpers_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(8593);
/* harmony import */ var _error_codes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5497);
/* harmony import */ var _error_message__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2620);


/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Error linked to the media Playback.
 *
 * @class MediaError
 * @extends Error
 */
var MediaError = /*#__PURE__*/function (_Error) {
  function MediaError(code, reason, context) {
    var _this;
    _this = _Error.call(this, (0,_error_message__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)("MediaError", code, reason)) || this;
    // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class
    Object.setPrototypeOf(_this, MediaError.prototype);
    _this.name = "MediaError";
    _this.type = _error_codes__WEBPACK_IMPORTED_MODULE_1__/* .ErrorTypes */ .wU.MEDIA_ERROR;
    _this.code = code;
    _this.fatal = false;
    var adaptation = context === null || context === void 0 ? void 0 : context.adaptation;
    if (adaptation !== undefined) {
      switch (adaptation.type) {
        case "audio":
          _this.trackInfo = {
            type: "audio",
            track: adaptation.toAudioTrack()
          };
          break;
        case "video":
          _this.trackInfo = {
            type: "video",
            track: adaptation.toVideoTrack()
          };
          break;
        case "text":
          _this.trackInfo = {
            type: "text",
            track: adaptation.toTextTrack()
          };
          break;
      }
    }
    return _this;
  }
  (0,_babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A)(MediaError, _Error);
  return MediaError;
}( /*#__PURE__*/(0,_babel_runtime_helpers_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A)(Error));


/***/ }),

/***/ 7941:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: function() { return /* binding */ NetworkError; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7387);
/* harmony import */ var _babel_runtime_helpers_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(8593);
/* harmony import */ var _error_codes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5497);
/* harmony import */ var _error_message__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2620);


/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Error linked to network interactions (requests).
 *
 * @class NetworkError
 * @extends Error
 */
var NetworkError = /*#__PURE__*/function (_Error) {
  /**
   * @param {string} code
   * @param {Error} baseError
   */
  function NetworkError(code, baseError) {
    var _this;
    _this = _Error.call(this, (0,_error_message__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)("NetworkError", code, baseError.message)) || this;
    // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class
    Object.setPrototypeOf(_this, NetworkError.prototype);
    _this.name = "NetworkError";
    _this.type = _error_codes__WEBPACK_IMPORTED_MODULE_1__/* .ErrorTypes */ .wU.NETWORK_ERROR;
    _this.xhr = baseError.xhr === undefined ? null : baseError.xhr;
    _this.url = baseError.url;
    _this.status = baseError.status;
    _this.errorType = baseError.type;
    _this.code = code;
    _this.fatal = false;
    return _this;
  }
  /**
   * Returns true if the NetworkError is due to the given http error code
   * @param {number} httpErrorCode
   * @returns {Boolean}
   */
  (0,_babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A)(NetworkError, _Error);
  var _proto = NetworkError.prototype;
  _proto.isHttpError = function isHttpError(httpErrorCode) {
    return this.errorType === _error_codes__WEBPACK_IMPORTED_MODULE_1__/* .NetworkErrorTypes */ .yl.ERROR_HTTP_CODE && this.status === httpErrorCode;
  };
  return NetworkError;
}( /*#__PURE__*/(0,_babel_runtime_helpers_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A)(Error));


/***/ }),

/***/ 1858:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: function() { return /* binding */ OtherError; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7387);
/* harmony import */ var _babel_runtime_helpers_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(8593);
/* harmony import */ var _error_codes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5497);
/* harmony import */ var _error_message__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2620);


/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @class OtherError
 * @extends Error
 */
var OtherError = /*#__PURE__*/function (_Error) {
  /**
   * @param {string} code
   * @param {string} reason
   */
  function OtherError(code, reason) {
    var _this;
    _this = _Error.call(this, (0,_error_message__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)("OtherError", code, reason)) || this;
    // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class
    Object.setPrototypeOf(_this, OtherError.prototype);
    _this.name = "OtherError";
    _this.type = _error_codes__WEBPACK_IMPORTED_MODULE_1__/* .ErrorTypes */ .wU.OTHER_ERROR;
    _this.code = code;
    _this.fatal = false;
    return _this;
  }
  (0,_babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A)(OtherError, _Error);
  return OtherError;
}( /*#__PURE__*/(0,_babel_runtime_helpers_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A)(Error));


/***/ }),

/***/ 3506:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: function() { return /* binding */ RequestError; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7387);
/* harmony import */ var _babel_runtime_helpers_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8593);


/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Internal Error used when doing requests through fetch / XHRs.
 *
 * It is not part of the API, as such it is only a temporary error which is
 * later converted to another Error instance (e.g. NETWORK_ERROR).
 *
 * @class RequestError
 * @extends Error
 */
var RequestError = /*#__PURE__*/function (_Error) {
  /**
   * @param {XMLHttpRequest} xhr
   * @param {string} url
   * @param {string} type
   */
  function RequestError(url, status, type, xhr) {
    var _this;
    var message;
    switch (type) {
      case "TIMEOUT":
        message = "The request timed out";
        break;
      case "ERROR_EVENT":
        message = "An error prevented the request to be performed successfully";
        break;
      case "PARSE_ERROR":
        message = "An error happened while formatting the response data";
        break;
      case "ERROR_HTTP_CODE":
        message = "An HTTP status code indicating failure was received: " + String(status);
        break;
    }
    _this = _Error.call(this, message) || this;
    // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class
    Object.setPrototypeOf(_this, RequestError.prototype);
    _this.name = "RequestError";
    _this.url = url;
    if (xhr !== undefined) {
      _this.xhr = xhr;
    }
    _this.status = status;
    _this.type = type;
    return _this;
  }
  (0,_babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(RequestError, _Error);
  return RequestError;
}( /*#__PURE__*/(0,_babel_runtime_helpers_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(Error));


/***/ }),

/***/ 8589:
/***/ (function(__unused_webpack_module, __webpack_exports__) {

"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Initial features object, with no feature activated by default.
 * @type {Object}
 */
var features = {
  dashParsers: {
    wasm: null,
    js: null
  },
  createDebugElement: null,
  directfile: null,
  decrypt: null,
  htmlTextTracksBuffer: null,
  htmlTextTracksParsers: {},
  imageBuffer: null,
  imageParser: null,
  mediaSourceInit: null,
  nativeTextTracksBuffer: null,
  nativeTextTracksParsers: {},
  transports: {}
};
/* harmony default export */ __webpack_exports__.A = (features);

/***/ }),

/***/ 418:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _features_object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8589);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * File allowing feature-switching.
 *
 * Every optional feature is included here.
 * They all should subsequently be accessed in the code through the exported
 * `features` object.
 *
 * The then exported features object will be used dynamically to know which
 * features are activated.
 *
 * This also lazy-feature loading, where this exported object can be updated
 * at runtime, to allow some new features even if the player instance has
 * already have been instanciated.
 */


/* harmony default export */ __webpack_exports__.A = (_features_object__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A);


/***/ }),

/***/ 9477:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: function() { return /* binding */ log; }
});

// EXTERNAL MODULE: ./src/utils/noop.ts
var noop = __webpack_require__(8060);
;// CONCATENATED MODULE: ./src/utils/logger.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var DEFAULT_LOG_LEVEL = "NONE";
/**
 * Logger implementation.
 * @class Logger
 */
var Logger = /*#__PURE__*/function () {
  function Logger() {
    this.error = noop/* default */.A;
    this.warn = noop/* default */.A;
    this.info = noop/* default */.A;
    this.debug = noop/* default */.A;
    this._levels = {
      NONE: 0,
      ERROR: 1,
      WARNING: 2,
      INFO: 3,
      DEBUG: 4
    };
    this._currentLevel = DEFAULT_LOG_LEVEL;
  }
  /**
   * @param {string} levelStr
   */
  var _proto = Logger.prototype;
  _proto.setLevel = function setLevel(levelStr) {
    var level;
    var foundLevel = this._levels[levelStr];
    if (typeof foundLevel === "number") {
      level = foundLevel;
      this._currentLevel = levelStr;
    } else {
      // not found
      level = 0;
      this._currentLevel = "NONE";
    }
    /* eslint-disable no-invalid-this */
    /* eslint-disable no-console */
    this.error = level >= this._levels.ERROR ? console.error.bind(console) : noop/* default */.A;
    this.warn = level >= this._levels.WARNING ? console.warn.bind(console) : noop/* default */.A;
    this.info = level >= this._levels.INFO ? console.info.bind(console) : noop/* default */.A;
    this.debug = level >= this._levels.DEBUG ? console.log.bind(console) : noop/* default */.A;
    /* eslint-enable no-console */
    /* eslint-enable no-invalid-this */
  }
  /**
   * @returns {string}
   */;
  _proto.getLevel = function getLevel() {
    return this._currentLevel;
  }
  /**
   * Returns `true` if the currently set level includes logs of the level given
   * in argument.
   * @param {string} logLevel
   * @returns {boolean}
   */;
  _proto.hasLevel = function hasLevel(logLevel) {
    return this._levels[logLevel] >= this._levels[this._currentLevel];
  };
  return Logger;
}();

;// CONCATENATED MODULE: ./src/log.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// create a logger specifically for the RxPlayer.
var logger = new Logger();
/* harmony default export */ var log = (logger);

/***/ }),

/***/ 4129:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  B: function() { return /* binding */ SUPPORTED_ADAPTATIONS_TYPE; },
  A: function() { return /* binding */ Adaptation; }
});

// EXTERNAL MODULE: ./src/log.ts + 1 modules
var log = __webpack_require__(9477);
// EXTERNAL MODULE: ./src/utils/array_find.ts
var array_find = __webpack_require__(1729);
// EXTERNAL MODULE: ./src/utils/is_null_or_undefined.ts
var is_null_or_undefined = __webpack_require__(6787);
// EXTERNAL MODULE: ./src/utils/languages/index.ts
var languages = __webpack_require__(8202);
;// CONCATENATED MODULE: ./src/utils/uniq.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Uniq implementation by combining a filter and an indexOf.
 * @param {Array.<*>} arr
 * @returns {Array.<*>}
 */
function uniqFromFilter(arr) {
  return arr.filter(function (val, i, self) {
    return self.indexOf(val) === i;
  });
}
/**
 * Uniq implementation by using the Set browser API.
 * @param {Array.<*>} arr
 * @returns {Array.<*>}
 */
function uniqFromSet(arr) {
  return Array.from(new Set(arr));
}
/**
 * Returns the input array without duplicates values.
 * All values are unique.
 * @param {Array.<*>} arr
 * @returns {Array.<*>}
 */
/* harmony default export */ var uniq = (typeof window !== "undefined" &&
// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
typeof window.Set === "function" && typeof Array.from === "function" ? uniqFromSet : uniqFromFilter);

// EXTERNAL MODULE: ./src/compat/browser_compatibility_types.ts
var browser_compatibility_types = __webpack_require__(9770);
;// CONCATENATED MODULE: ./src/compat/is_codec_supported.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns true if the given codec is supported by the browser's MediaSource
 * implementation.
 * @param {string} mimeType - The MIME media type that you want to test support
 * for in the current browser.
 * This may include the codecs parameter to provide added details about the
 * codecs used within the file.
 * @returns {Boolean}
 */
function isCodecSupported(mimeType) {
  if (browser_compatibility_types/* MediaSource_ */.j == null) {
    return false;
  }
  /* eslint-disable @typescript-eslint/unbound-method */
  if (typeof browser_compatibility_types/* MediaSource_ */.j.isTypeSupported === "function") {
    /* eslint-enable @typescript-eslint/unbound-method */
    return browser_compatibility_types/* MediaSource_ */.j.isTypeSupported(mimeType);
  }
  return true;
}
// EXTERNAL MODULE: ./src/utils/are_arrays_of_numbers_equal.ts
var are_arrays_of_numbers_equal = __webpack_require__(987);
// EXTERNAL MODULE: ./src/utils/id_generator.ts
var id_generator = __webpack_require__(8795);
;// CONCATENATED MODULE: ./src/manifest/representation.ts
function _createForOfIteratorHelperLoose(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (t) return (t = t.call(r)).next.bind(t); if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var o = 0; return function () { return o >= r.length ? { done: !0 } : { done: !1, value: r[o++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




var generateRepresentationUniqueId = (0,id_generator/* default */.A)();
/**
 * Normalized Representation structure.
 * @class Representation
 */
var Representation = /*#__PURE__*/function () {
  /**
   * @param {Object} args
   */
  function Representation(args, opts) {
    var _a;
    this.id = args.id;
    this.uniqueId = generateRepresentationUniqueId();
    this.bitrate = args.bitrate;
    this.codec = args.codecs;
    if (args.isSpatialAudio !== undefined) {
      this.isSpatialAudio = args.isSpatialAudio;
    }
    if (args.height !== undefined) {
      this.height = args.height;
    }
    if (args.width !== undefined) {
      this.width = args.width;
    }
    if (args.mimeType !== undefined) {
      this.mimeType = args.mimeType;
    }
    if (args.contentProtections !== undefined) {
      this.contentProtections = args.contentProtections;
    }
    if (args.frameRate !== undefined) {
      this.frameRate = args.frameRate;
    }
    if (args.hdrInfo !== undefined) {
      this.hdrInfo = args.hdrInfo;
    }
    this.cdnMetadata = args.cdnMetadata;
    this.index = args.index;
    if (opts.type === "audio" || opts.type === "video") {
      this.isSupported = false;
      // Supplemental codecs are defined as backwards-compatible codecs enhancing
      // the experience of a base layer codec
      if (args.supplementalCodecs !== undefined) {
        var supplementalCodecMimeTypeStr = ((_a = this.mimeType) !== null && _a !== void 0 ? _a : "") + ";codecs=\"" + args.supplementalCodecs + "\"";
        if (isCodecSupported(supplementalCodecMimeTypeStr)) {
          this.codec = args.supplementalCodecs;
          this.isSupported = true;
        }
      }
      if (!this.isSupported) {
        var mimeTypeStr = this.getMimeTypeString();
        var isSupported = isCodecSupported(mimeTypeStr);
        if (!isSupported) {
          log/* default */.A.info("Unsupported Representation", mimeTypeStr, this.id, this.bitrate);
        }
        this.isSupported = isSupported;
      }
    } else {
      this.isSupported = true; // TODO for other types
    }
  }
  /**
   * Returns "mime-type string" which includes both the mime-type and the codec,
   * which is often needed when interacting with the browser's APIs.
   * @returns {string}
   */
  var _proto = Representation.prototype;
  _proto.getMimeTypeString = function getMimeTypeString() {
    var _a, _b;
    return ((_a = this.mimeType) !== null && _a !== void 0 ? _a : "") + ";codecs=\"" + ((_b = this.codec) !== null && _b !== void 0 ? _b : "") + "\"";
  }
  /**
   * Returns encryption initialization data linked to the given DRM's system ID.
   * This data may be useful to decrypt encrypted media segments.
   *
   * Returns an empty array if there is no data found for that system ID at the
   * moment.
   *
   * When you know that all encryption data has been added to this
   * Representation, you can also call the `getAllEncryptionData` method.
   * This second function will return all encryption initialization data
   * regardless of the DRM system, and might thus be used in all cases.
   *
   * /!\ Note that encryption initialization data may be progressively added to
   * this Representation after `_addProtectionData` calls or Manifest updates.
   * Because of this, the return value of this function might change after those
   * events.
   *
   * @param {string} drmSystemId - The hexa-encoded DRM system ID
   * @returns {Array.<Object>}
   */;
  _proto.getEncryptionData = function getEncryptionData(drmSystemId) {
    var _a, _b;
    var allInitData = this.getAllEncryptionData();
    var filtered = [];
    for (var i = 0; i < allInitData.length; i++) {
      var createdObjForType = false;
      var initData = allInitData[i];
      for (var j = 0; j < initData.values.length; j++) {
        if (initData.values[j].systemId.toLowerCase() === drmSystemId.toLowerCase()) {
          if (!createdObjForType) {
            var keyIds = (_b = (_a = this.contentProtections) === null || _a === void 0 ? void 0 : _a.keyIds) === null || _b === void 0 ? void 0 : _b.map(function (val) {
              return val.keyId;
            });
            filtered.push({
              type: initData.type,
              keyIds: keyIds,
              values: [initData.values[j]]
            });
            createdObjForType = true;
          } else {
            filtered[filtered.length - 1].values.push(initData.values[j]);
          }
        }
      }
    }
    return filtered;
  }
  /**
   * Returns all currently-known encryption initialization data linked to this
   * Representation.
   * Encryption initialization data is generally required to be able to decrypt
   * those Representation's media segments.
   *
   * Unlike `getEncryptionData`, this method will return all available
   * encryption data.
   * It might as such might be used when either the current drm's system id is
   * not known or when no encryption data specific to it was found. In that
   * case, providing every encryption data linked to this Representation might
   * still allow decryption.
   *
   * Returns an empty array in two cases:
   *   - the content is not encrypted.
   *   - We don't have any decryption data yet.
   *
   * /!\ Note that new encryption initialization data can be added progressively
   * through the `_addProtectionData` method or through Manifest updates.
   * It is thus highly advised to only rely on this method once every protection
   * data related to this Representation has been known to be added.
   *
   * The main situation where new encryption initialization data is added is
   * after parsing this Representation's initialization segment, if one exists.
   * @returns {Array.<Object>}
   */;
  _proto.getAllEncryptionData = function getAllEncryptionData() {
    var _a, _b;
    if (this.contentProtections === undefined || this.contentProtections.initData.length === 0) {
      return [];
    }
    var keyIds = (_b = (_a = this.contentProtections) === null || _a === void 0 ? void 0 : _a.keyIds) === null || _b === void 0 ? void 0 : _b.map(function (val) {
      return val.keyId;
    });
    return this.contentProtections.initData.map(function (x) {
      return {
        type: x.type,
        keyIds: keyIds,
        values: x.values
      };
    });
  }
  /**
   * Add new encryption initialization data to this Representation if it was not
   * already included.
   *
   * Returns `true` if new encryption initialization data has been added.
   * Returns `false` if none has been added (e.g. because it was already known).
   *
   * /!\ Mutates the current Representation
   *
   * TODO better handle use cases like key rotation by not always grouping
   * every protection data together? To check.
   * @param {string} initDataType
   * @param {Uint8Array|undefined} keyId
   * @param {Uint8Array} data
   * @returns {boolean}
   */;
  _proto._addProtectionData = function _addProtectionData(initDataType, keyId, data) {
    var hasUpdatedProtectionData = false;
    if (this.contentProtections === undefined) {
      this.contentProtections = {
        keyIds: keyId !== undefined ? [{
          keyId: keyId
        }] : [],
        initData: [{
          type: initDataType,
          values: data
        }]
      };
      return true;
    }
    if (keyId !== undefined) {
      var keyIds = this.contentProtections.keyIds;
      if (keyIds === undefined) {
        this.contentProtections.keyIds = [{
          keyId: keyId
        }];
      } else {
        var foundKeyId = false;
        for (var _iterator = _createForOfIteratorHelperLoose(keyIds), _step; !(_step = _iterator()).done;) {
          var knownKeyId = _step.value;
          if ((0,are_arrays_of_numbers_equal/* default */.A)(knownKeyId.keyId, keyId)) {
            foundKeyId = true;
          }
        }
        if (!foundKeyId) {
          log/* default */.A.warn("Manifest: found unanounced key id.");
          keyIds.push({
            keyId: keyId
          });
        }
      }
    }
    var cInitData = this.contentProtections.initData;
    for (var i = 0; i < cInitData.length; i++) {
      if (cInitData[i].type === initDataType) {
        var cValues = cInitData[i].values;
        // loop through data
        for (var dataI = 0; dataI < data.length; dataI++) {
          var dataToAdd = data[dataI];
          var cValuesIdx = void 0;
          for (cValuesIdx = 0; cValuesIdx < cValues.length; cValuesIdx++) {
            if (dataToAdd.systemId === cValues[cValuesIdx].systemId) {
              if ((0,are_arrays_of_numbers_equal/* default */.A)(dataToAdd.data, cValues[cValuesIdx].data)) {
                // go to next dataToAdd
                break;
              } else {
                log/* default */.A.warn("Manifest: different init data for the same system ID");
              }
            }
          }
          if (cValuesIdx === cValues.length) {
            // we didn't break the loop === we didn't already find that value
            cValues.push(dataToAdd);
            hasUpdatedProtectionData = true;
          }
        }
        return hasUpdatedProtectionData;
      }
    }
    // If we are here, this means that we didn't find the corresponding
    // init data type in this.contentProtections.initData.
    this.contentProtections.initData.push({
      type: initDataType,
      values: data
    });
    return true;
  }
  /**
   * Format Representation as an `IAudioRepresentation`.
   * @returns {Object}
   */;
  _proto.toAudioRepresentation = function toAudioRepresentation() {
    var id = this.id,
      isSpatialAudio = this.isSpatialAudio,
      bitrate = this.bitrate,
      codec = this.codec;
    return {
      id: id,
      isSpatialAudio: isSpatialAudio,
      bitrate: bitrate,
      codec: codec
    };
  }
  /**
   * Format Representation as an `IVideoRepresentation`.
   * @returns {Object}
   */;
  _proto.toVideoRepresentation = function toVideoRepresentation() {
    var id = this.id,
      bitrate = this.bitrate,
      frameRate = this.frameRate,
      width = this.width,
      height = this.height,
      codec = this.codec,
      hdrInfo = this.hdrInfo;
    return {
      id: id,
      bitrate: bitrate,
      frameRate: frameRate,
      width: width,
      height: height,
      codec: codec,
      hdrInfo: hdrInfo
    };
  };
  return Representation;
}();
/* harmony default export */ var manifest_representation = (Representation);
;// CONCATENATED MODULE: ./src/manifest/adaptation.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






/** List in an array every possible value for the Adaptation's `type` property. */
var SUPPORTED_ADAPTATIONS_TYPE = ["audio", "video", "text", "image"];
/**
 * Normalized Adaptation structure.
 * An `Adaptation` describes a single `Track`. For example a specific audio
 * track (in a given language) or a specific video track.
 * It istelf can be represented in different qualities, which we call here
 * `Representation`.
 * @class Adaptation
 */
var Adaptation = /*#__PURE__*/function () {
  /**
   * @constructor
   * @param {Object} parsedAdaptation
   * @param {Object|undefined} [options]
   */
  function Adaptation(parsedAdaptation, options) {
    if (options === void 0) {
      options = {};
    }
    var trickModeTracks = parsedAdaptation.trickModeTracks;
    var _options = options,
      representationFilter = _options.representationFilter,
      isManuallyAdded = _options.isManuallyAdded;
    this.id = parsedAdaptation.id;
    this.type = parsedAdaptation.type;
    if (parsedAdaptation.isTrickModeTrack !== undefined) {
      this.isTrickModeTrack = parsedAdaptation.isTrickModeTrack;
    }
    if (parsedAdaptation.language !== undefined) {
      this.language = parsedAdaptation.language;
      this.normalizedLanguage = (0,languages/* default */.Ay)(parsedAdaptation.language);
    }
    if (parsedAdaptation.closedCaption !== undefined) {
      this.isClosedCaption = parsedAdaptation.closedCaption;
    }
    if (parsedAdaptation.audioDescription !== undefined) {
      this.isAudioDescription = parsedAdaptation.audioDescription;
    }
    if (parsedAdaptation.isDub !== undefined) {
      this.isDub = parsedAdaptation.isDub;
    }
    if (parsedAdaptation.forcedSubtitles !== undefined) {
      this.isForcedSubtitles = parsedAdaptation.forcedSubtitles;
    }
    if (parsedAdaptation.isSignInterpreted !== undefined) {
      this.isSignInterpreted = parsedAdaptation.isSignInterpreted;
    }
    if (parsedAdaptation.label !== undefined) {
      this.label = parsedAdaptation.label;
    }
    if (trickModeTracks !== undefined && trickModeTracks.length > 0) {
      this.trickModeTracks = trickModeTracks.map(function (track) {
        return new Adaptation(track);
      });
    }
    var argsRepresentations = parsedAdaptation.representations;
    var representations = [];
    var isSupported = false;
    for (var i = 0; i < argsRepresentations.length; i++) {
      var representation = new manifest_representation(argsRepresentations[i], {
        type: this.type
      });
      var shouldAdd = (0,is_null_or_undefined/* default */.A)(representationFilter) || representationFilter(representation, {
        bufferType: this.type,
        language: this.language,
        normalizedLanguage: this.normalizedLanguage,
        isClosedCaption: this.isClosedCaption,
        isDub: this.isDub,
        isAudioDescription: this.isAudioDescription,
        isSignInterpreted: this.isSignInterpreted
      });
      if (shouldAdd) {
        representations.push(representation);
        if (!isSupported && representation.isSupported) {
          isSupported = true;
        }
      } else {
        log/* default */.A.debug("Filtering Representation due to representationFilter", this.type, "Adaptation: " + this.id, "Representation: " + representation.id, "(" + representation.bitrate + ")");
      }
    }
    representations.sort(function (a, b) {
      return a.bitrate - b.bitrate;
    });
    this.representations = representations;
    this.isSupported = isSupported;
    // for manuallyAdded adaptations (not in the manifest)
    this.manuallyAdded = isManuallyAdded === true;
  }
  /**
   * Returns unique bitrate for every Representation in this Adaptation.
   * @returns {Array.<Number>}
   */
  var _proto = Adaptation.prototype;
  _proto.getAvailableBitrates = function getAvailableBitrates() {
    var bitrates = [];
    for (var i = 0; i < this.representations.length; i++) {
      var representation = this.representations[i];
      if (representation.decipherable !== false) {
        bitrates.push(representation.bitrate);
      }
    }
    return uniq(bitrates);
  }
  /**
   * Returns all Representation in this Adaptation that can be played (that is:
   * not undecipherable and with a supported codec).
   * @returns {Array.<Representation>}
   */;
  _proto.getPlayableRepresentations = function getPlayableRepresentations() {
    return this.representations.filter(function (rep) {
      return rep.isSupported && rep.decipherable !== false;
    });
  }
  /**
   * Returns the Representation linked to the given ID.
   * @param {number|string} wantedId
   * @returns {Object|undefined}
   */;
  _proto.getRepresentation = function getRepresentation(wantedId) {
    return (0,array_find/* default */.A)(this.representations, function (_ref) {
      var id = _ref.id;
      return wantedId === id;
    });
  }
  /**
   * Format an `Adaptation`, generally of type `"audio"`, as an `IAudioTrack`.
   * @returns {Object}
   */;
  _proto.toAudioTrack = function toAudioTrack() {
    var _a, _b;
    var formatted = {
      language: (_a = this.language) !== null && _a !== void 0 ? _a : "",
      normalized: (_b = this.normalizedLanguage) !== null && _b !== void 0 ? _b : "",
      audioDescription: this.isAudioDescription === true,
      id: this.id,
      representations: this.representations.map(function (r) {
        return r.toAudioRepresentation();
      }),
      label: this.label
    };
    if (this.isDub === true) {
      formatted.dub = true;
    }
    return formatted;
  }
  /**
   * Format an `Adaptation`, generally of type `"audio"`, as an `IAudioTrack`.
   * @returns {Object}
   */;
  _proto.toTextTrack = function toTextTrack() {
    var _a, _b;
    return {
      language: (_a = this.language) !== null && _a !== void 0 ? _a : "",
      normalized: (_b = this.normalizedLanguage) !== null && _b !== void 0 ? _b : "",
      closedCaption: this.isClosedCaption === true,
      id: this.id,
      label: this.label,
      forced: this.isForcedSubtitles
    };
  }
  /**
   * Format an `Adaptation`, generally of type `"video"`, as an `IAudioTrack`.
   * @returns {Object}
   */;
  _proto.toVideoTrack = function toVideoTrack() {
    var trickModeTracks = this.trickModeTracks !== undefined ? this.trickModeTracks.map(function (trickModeAdaptation) {
      var representations = trickModeAdaptation.representations.map(function (r) {
        return r.toVideoRepresentation();
      });
      var trickMode = {
        id: trickModeAdaptation.id,
        representations: representations,
        isTrickModeTrack: true
      };
      if (trickModeAdaptation.isSignInterpreted === true) {
        trickMode.signInterpreted = true;
      }
      return trickMode;
    }) : undefined;
    var videoTrack = {
      id: this.id,
      representations: this.representations.map(function (r) {
        return r.toVideoRepresentation();
      }),
      label: this.label
    };
    if (this.isSignInterpreted === true) {
      videoTrack.signInterpreted = true;
    }
    if (this.isTrickModeTrack === true) {
      videoTrack.isTrickModeTrack = true;
    }
    if (trickModeTracks !== undefined) {
      videoTrack.trickModeTracks = trickModeTracks;
    }
    return videoTrack;
  };
  return Adaptation;
}();


/***/ }),

/***/ 8568:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Ay: function() { return /* binding */ manifest; }
});

// UNUSED EXPORTS: Adaptation, MANIFEST_UPDATE_TYPE, Period, Representation, SUPPORTED_ADAPTATIONS_TYPE, StaticRepresentationIndex, areSameContent, getLoggableSegmentId

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js
var inheritsLoose = __webpack_require__(7387);
// EXTERNAL MODULE: ./src/errors/media_error.ts
var media_error = __webpack_require__(5575);
// EXTERNAL MODULE: ./src/log.ts + 1 modules
var log = __webpack_require__(9477);
// EXTERNAL MODULE: ./src/utils/array_find.ts
var array_find = __webpack_require__(1729);
// EXTERNAL MODULE: ./src/utils/event_emitter.ts
var event_emitter = __webpack_require__(79);
// EXTERNAL MODULE: ./src/utils/id_generator.ts
var id_generator = __webpack_require__(8795);
// EXTERNAL MODULE: ./src/utils/resolve_url.ts
var resolve_url = __webpack_require__(2716);
// EXTERNAL MODULE: ./src/utils/warn_once.ts
var warn_once = __webpack_require__(5950);
// EXTERNAL MODULE: ./src/manifest/adaptation.ts + 3 modules
var manifest_adaptation = __webpack_require__(4129);
// EXTERNAL MODULE: ./src/utils/object_values.ts
var object_values = __webpack_require__(4324);
;// CONCATENATED MODULE: ./src/manifest/period.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Class representing the tracks and qualities available from a given time
 * period in the the Manifest.
 * @class Period
 */
var Period = /*#__PURE__*/function () {
  /**
   * @constructor
   * @param {Object} args
   * @param {function|undefined} [representationFilter]
   */
  function Period(args, representationFilter) {
    var _this = this;
    this.contentWarnings = [];
    this.id = args.id;
    this.adaptations = Object.keys(args.adaptations).reduce(function (acc, type) {
      var adaptationsForType = args.adaptations[type];
      if (adaptationsForType == null) {
        return acc;
      }
      var filteredAdaptations = adaptationsForType.map(function (adaptation) {
        var newAdaptation = new manifest_adaptation/* default */.A(adaptation, {
          representationFilter: representationFilter
        });
        if (newAdaptation.representations.length > 0 && !newAdaptation.isSupported) {
          var error = new media_error/* default */.A("MANIFEST_INCOMPATIBLE_CODECS_ERROR", "An Adaptation contains only incompatible codecs.", {
            adaptation: newAdaptation
          });
          _this.contentWarnings.push(error);
        }
        return newAdaptation;
      }).filter(function (adaptation) {
        return adaptation.representations.length > 0;
      });
      if (filteredAdaptations.every(function (adaptation) {
        return !adaptation.isSupported;
      }) && adaptationsForType.length > 0 && (type === "video" || type === "audio")) {
        throw new media_error/* default */.A("MANIFEST_PARSE_ERROR", "No supported " + type + " adaptations");
      }
      if (filteredAdaptations.length > 0) {
        acc[type] = filteredAdaptations;
      }
      return acc;
    }, {});
    if (!Array.isArray(this.adaptations.video) && !Array.isArray(this.adaptations.audio)) {
      throw new media_error/* default */.A("MANIFEST_PARSE_ERROR", "No supported audio and video tracks.");
    }
    this.duration = args.duration;
    this.start = args.start;
    if (this.duration != null && this.start != null) {
      this.end = this.start + this.duration;
    }
    this.streamEvents = args.streamEvents === undefined ? [] : args.streamEvents;
  }
  /**
   * Returns every `Adaptations` (or `tracks`) linked to that Period, in an
   * Array.
   * @returns {Array.<Object>}
   */
  var _proto = Period.prototype;
  _proto.getAdaptations = function getAdaptations() {
    var adaptationsByType = this.adaptations;
    return (0,object_values/* default */.A)(adaptationsByType).reduce(
    // Note: the second case cannot happen. TS is just being dumb here
    function (acc, adaptations) {
      return adaptations != null ? acc.concat(adaptations) : acc;
    }, []);
  }
  /**
   * Returns every `Adaptations` (or `tracks`) linked to that Period for a
   * given type.
   * @param {string} adaptationType
   * @returns {Array.<Object>}
   */;
  _proto.getAdaptationsForType = function getAdaptationsForType(adaptationType) {
    var adaptationsForType = this.adaptations[adaptationType];
    return adaptationsForType == null ? [] : adaptationsForType;
  }
  /**
   * Returns the Adaptation linked to the given ID.
   * @param {number|string} wantedId
   * @returns {Object|undefined}
   */;
  _proto.getAdaptation = function getAdaptation(wantedId) {
    return (0,array_find/* default */.A)(this.getAdaptations(), function (_ref) {
      var id = _ref.id;
      return wantedId === id;
    });
  }
  /**
   * Returns Adaptations that contain Representations in supported codecs.
   * @param {string|undefined} type - If set filter on a specific Adaptation's
   * type. Will return for all types if `undefined`.
   * @returns {Array.<Adaptation>}
   */;
  _proto.getSupportedAdaptations = function getSupportedAdaptations(type) {
    if (type === undefined) {
      return this.getAdaptations().filter(function (ada) {
        return ada.isSupported;
      });
    }
    var adaptationsForType = this.adaptations[type];
    if (adaptationsForType === undefined) {
      return [];
    }
    return adaptationsForType.filter(function (ada) {
      return ada.isSupported;
    });
  }
  /**
   * Returns true if the give time is in the time boundaries of this `Period`.
   * @param {number} time
   * @param {object|null} nextPeriod - Period coming chronologically just
   * after in the same Manifest. `null` if this instance is the last `Period`.
   * @returns {boolean}
   */;
  _proto.containsTime = function containsTime(time, nextPeriod) {
    if (time >= this.start && (this.end === undefined || time < this.end)) {
      return true;
    } else if (time === this.end && (nextPeriod === null || nextPeriod.start > this.end)) {
      // The last possible timed position of a Period is ambiguous as it is
      // frequently in common with the start of the next one: is it part of
      // the current or of the next Period?
      // Here we only consider it part of the current Period if it is the
      // only one with that position.
      return true;
    }
    return false;
  };
  return Period;
}();

;// CONCATENATED MODULE: ./src/manifest/representation_index/static.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Simple RepresentationIndex implementation for static files.
 * @class StaticRepresentationIndex
 */
var StaticRepresentationIndex = /*#__PURE__*/function () {
  /**
   * @param {Object} infos
   */
  function StaticRepresentationIndex(infos) {
    this._url = infos.media;
  }
  /**
   * Static contents do not have any initialization segments.
   * Just return null.
   * @returns {null}
   */
  var _proto = StaticRepresentationIndex.prototype;
  _proto.getInitSegment = function getInitSegment() {
    return null;
  }
  /**
   * Returns the only Segment available here.
   * @returns {Array.<Object>}
   */;
  _proto.getSegments = function getSegments() {
    return [{
      id: "0",
      isInit: false,
      number: 0,
      url: this._url,
      time: 0,
      end: Number.MAX_VALUE,
      duration: Number.MAX_VALUE,
      complete: true,
      privateInfos: {},
      timescale: 1
    }];
  }
  /**
   * Returns first position in index.
   * @returns {undefined}
   */;
  _proto.getFirstAvailablePosition = function getFirstAvailablePosition() {
    return;
  }
  /**
   * Returns last position in index.
   * @returns {undefined}
   */;
  _proto.getLastAvailablePosition = function getLastAvailablePosition() {
    return;
  }
  /**
   * Returns the absolute end in seconds this RepresentationIndex can reach once
   * all segments are available.
   * @returns {number|null|undefined}
   */;
  _proto.getEnd = function getEnd() {
    return;
  }
  /**
   * Returns:
   *   - `true` if in the given time interval, at least one new segment is
   *     expected to be available in the future.
   *   - `false` either if all segments in that time interval are already
   *     available for download or if none will ever be available for it.
   *   - `undefined` when it is not possible to tell.
   *
   * Always `false` in a `StaticRepresentationIndex` because all segments should
   * be directly available.
   * @returns {boolean}
   */;
  _proto.awaitSegmentBetween = function awaitSegmentBetween() {
    return false;
  }
  /**
   * Returns false as a static file never need to be refreshed.
   * @returns {Boolean}
   */;
  _proto.shouldRefresh = function shouldRefresh() {
    return false;
  }
  /**
   * @returns {null}
   */;
  _proto.checkDiscontinuity = function checkDiscontinuity() {
    return null;
  }
  /**
   * Returns true as a static file should never need lose availability.
   * @returns {Boolean}
   */;
  _proto.isSegmentStillAvailable = function isSegmentStillAvailable() {
    return true;
  }
  /**
   * @returns {Boolean}
   */;
  _proto.canBeOutOfSyncError = function canBeOutOfSyncError() {
    return false;
  }
  /**
   * @returns {Boolean}
   */;
  _proto.isStillAwaitingFutureSegments = function isStillAwaitingFutureSegments() {
    return false;
  }
  /**
   * @returns {Boolean}
   */;
  _proto.isInitialized = function isInitialized() {
    return true;
  };
  _proto._replace = function _replace() {
    log/* default */.A.warn("Tried to replace a static RepresentationIndex");
  };
  _proto._update = function _update() {
    log/* default */.A.warn("Tried to update a static RepresentationIndex");
  };
  return StaticRepresentationIndex;
}();

;// CONCATENATED MODULE: ./src/manifest/types.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** Enumerate the different ways a Manifest update can be done. */
var MANIFEST_UPDATE_TYPE;
(function (MANIFEST_UPDATE_TYPE) {
  /**
   * Manifest is updated entirely thanks to a re-downloaded version of
   * the original manifest document.
   */
  MANIFEST_UPDATE_TYPE[MANIFEST_UPDATE_TYPE["Full"] = 0] = "Full";
  /**
   * Manifest is updated partially thanks to a shortened version
   * of the manifest document. The latter's URL might be different
   * from the original one.
   */
  MANIFEST_UPDATE_TYPE[MANIFEST_UPDATE_TYPE["Partial"] = 1] = "Partial";
})(MANIFEST_UPDATE_TYPE || (MANIFEST_UPDATE_TYPE = {}));
// EXTERNAL MODULE: ./src/utils/array_find_index.ts
var array_find_index = __webpack_require__(3786);
;// CONCATENATED MODULE: ./src/manifest/update_period_in_place.ts
function _createForOfIteratorHelperLoose(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (t) return (t = t.call(r)).next.bind(t); if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var o = 0; return function () { return o >= r.length ? { done: !0 } : { done: !1, value: r[o++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Update oldPeriod attributes with the one from newPeriod (e.g. when updating
 * the Manifest).
 * @param {Object} oldPeriod
 * @param {Object} newPeriod
 * @param {number} updateType
 * @returns {Object}
 */
function updatePeriodInPlace(oldPeriod, newPeriod, updateType) {
  var res = {
    updatedAdaptations: [],
    removedAdaptations: [],
    addedAdaptations: []
  };
  oldPeriod.start = newPeriod.start;
  oldPeriod.end = newPeriod.end;
  oldPeriod.duration = newPeriod.duration;
  oldPeriod.streamEvents = newPeriod.streamEvents;
  var oldAdaptations = oldPeriod.getAdaptations();
  var newAdaptations = newPeriod.getAdaptations();
  var _loop = function _loop(_j) {
    var oldAdaptation = oldAdaptations[_j];
    var newAdaptationIdx = (0,array_find_index/* default */.A)(newAdaptations, function (a) {
      return a.id === oldAdaptation.id;
    });
    if (newAdaptationIdx === -1) {
      log/* default */.A.warn('Manifest: Adaptation "' + oldAdaptations[_j].id + '" not found when merging.');
      var _oldAdaptations$splic = oldAdaptations.splice(_j, 1),
        removed = _oldAdaptations$splic[0];
      _j--;
      res.removedAdaptations.push(removed);
    } else {
      var _newAdaptations$splic = newAdaptations.splice(newAdaptationIdx, 1),
        newAdaptation = _newAdaptations$splic[0];
      var updatedRepresentations = [];
      var addedRepresentations = [];
      var removedRepresentations = [];
      res.updatedAdaptations.push({
        adaptation: oldAdaptation,
        updatedRepresentations: updatedRepresentations,
        addedRepresentations: addedRepresentations,
        removedRepresentations: removedRepresentations
      });
      var oldRepresentations = oldAdaptation.representations;
      var newRepresentations = newAdaptation.representations.slice();
      var _loop2 = function _loop2(_k) {
        var oldRepresentation = oldRepresentations[_k];
        var newRepresentationIdx = (0,array_find_index/* default */.A)(newRepresentations, function (representation) {
          return representation.id === oldRepresentation.id;
        });
        if (newRepresentationIdx === -1) {
          log/* default */.A.warn("Manifest: Representation \"" + oldRepresentations[_k].id + "\" " + "not found when merging.");
          var _oldRepresentations$s = oldRepresentations.splice(_k, 1),
            _removed = _oldRepresentations$s[0];
          _k--;
          removedRepresentations.push(_removed);
        } else {
          var _newRepresentations$s = newRepresentations.splice(newRepresentationIdx, 1),
            newRepresentation = _newRepresentations$s[0];
          updatedRepresentations.push(oldRepresentation);
          oldRepresentation.cdnMetadata = newRepresentation.cdnMetadata;
          if (updateType === MANIFEST_UPDATE_TYPE.Full) {
            oldRepresentation.index._replace(newRepresentation.index);
          } else {
            oldRepresentation.index._update(newRepresentation.index);
          }
        }
        k = _k;
      };
      for (var k = 0; k < oldRepresentations.length; k++) {
        _loop2(k);
      }
      if (newRepresentations.length > 0) {
        var _oldAdaptation$repres;
        log/* default */.A.warn("Manifest: " + newRepresentations.length + " new Representations " + "found when merging.");
        (_oldAdaptation$repres = oldAdaptation.representations).push.apply(_oldAdaptation$repres, newRepresentations);
        addedRepresentations.push.apply(addedRepresentations, newRepresentations);
      }
    }
    j = _j;
  };
  for (var j = 0; j < oldAdaptations.length; j++) {
    _loop(j);
  }
  if (newAdaptations.length > 0) {
    log/* default */.A.warn("Manifest: " + newAdaptations.length + " new Adaptations " + "found when merging.");
    for (var _iterator = _createForOfIteratorHelperLoose(newAdaptations), _step; !(_step = _iterator()).done;) {
      var adap = _step.value;
      var prevAdaps = oldPeriod.adaptations[adap.type];
      if (prevAdaps === undefined) {
        oldPeriod.adaptations[adap.type] = [adap];
      } else {
        prevAdaps.push(adap);
      }
      res.addedAdaptations.push(adap);
    }
  }
  return res;
}
;// CONCATENATED MODULE: ./src/manifest/update_periods.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * Update old periods by adding new periods and removing
 * not available ones.
 * @param {Array.<Object>} oldPeriods
 * @param {Array.<Object>} newPeriods
 * @returns {Object}
 */
function replacePeriods(oldPeriods, newPeriods) {
  var res = {
    updatedPeriods: [],
    addedPeriods: [],
    removedPeriods: []
  };
  var firstUnhandledPeriodIdx = 0;
  for (var i = 0; i < newPeriods.length; i++) {
    var newPeriod = newPeriods[i];
    var j = firstUnhandledPeriodIdx;
    var oldPeriod = oldPeriods[j];
    while (oldPeriod != null && oldPeriod.id !== newPeriod.id) {
      j++;
      oldPeriod = oldPeriods[j];
    }
    if (oldPeriod != null) {
      var _res$removedPeriods, _res$addedPeriods;
      var result = updatePeriodInPlace(oldPeriod, newPeriod, MANIFEST_UPDATE_TYPE.Full);
      res.updatedPeriods.push({
        period: oldPeriod,
        result: result
      });
      var periodsToInclude = newPeriods.slice(firstUnhandledPeriodIdx, i);
      var nbrOfPeriodsToRemove = j - firstUnhandledPeriodIdx;
      var removed = oldPeriods.splice.apply(oldPeriods, [firstUnhandledPeriodIdx, nbrOfPeriodsToRemove].concat(periodsToInclude));
      (_res$removedPeriods = res.removedPeriods).push.apply(_res$removedPeriods, removed);
      (_res$addedPeriods = res.addedPeriods).push.apply(_res$addedPeriods, periodsToInclude);
      firstUnhandledPeriodIdx = i + 1;
    }
  }
  if (firstUnhandledPeriodIdx > oldPeriods.length) {
    log/* default */.A.error("Manifest: error when updating Periods");
    return res;
  }
  if (firstUnhandledPeriodIdx < oldPeriods.length) {
    var _res$removedPeriods2;
    var _removed = oldPeriods.splice(firstUnhandledPeriodIdx, oldPeriods.length - firstUnhandledPeriodIdx);
    (_res$removedPeriods2 = res.removedPeriods).push.apply(_res$removedPeriods2, _removed);
  }
  var remainingNewPeriods = newPeriods.slice(firstUnhandledPeriodIdx, newPeriods.length);
  if (remainingNewPeriods.length > 0) {
    var _res$addedPeriods2;
    oldPeriods.push.apply(oldPeriods, remainingNewPeriods);
    (_res$addedPeriods2 = res.addedPeriods).push.apply(_res$addedPeriods2, remainingNewPeriods);
  }
  return res;
}
/**
 * Update old periods by adding new periods and removing
 * not available ones.
 * @param {Array.<Object>} oldPeriods
 * @param {Array.<Object>} newPeriods
 * @returns {Object}
 */
function updatePeriods(oldPeriods, newPeriods) {
  var res = {
    updatedPeriods: [],
    addedPeriods: [],
    removedPeriods: []
  };
  if (oldPeriods.length === 0) {
    var _res$addedPeriods3;
    oldPeriods.splice.apply(oldPeriods, [0, 0].concat(newPeriods));
    (_res$addedPeriods3 = res.addedPeriods).push.apply(_res$addedPeriods3, newPeriods);
    return res;
  }
  if (newPeriods.length === 0) {
    return res;
  }
  var oldLastPeriod = oldPeriods[oldPeriods.length - 1];
  if (oldLastPeriod.start < newPeriods[0].start) {
    var _res$addedPeriods4;
    if (oldLastPeriod.end !== newPeriods[0].start) {
      throw new media_error/* default */.A("MANIFEST_UPDATE_ERROR", "Cannot perform partial update: not enough data");
    }
    oldPeriods.push.apply(oldPeriods, newPeriods);
    (_res$addedPeriods4 = res.addedPeriods).push.apply(_res$addedPeriods4, newPeriods);
    return res;
  }
  /** Index, in `oldPeriods` of the first element of `newPeriods` */
  var indexOfNewFirstPeriod = (0,array_find_index/* default */.A)(oldPeriods, function (_ref) {
    var id = _ref.id;
    return id === newPeriods[0].id;
  });
  if (indexOfNewFirstPeriod < 0) {
    throw new media_error/* default */.A("MANIFEST_UPDATE_ERROR", "Cannot perform partial update: incoherent data");
  }
  // The first updated Period can only be a partial part
  var updateRes = updatePeriodInPlace(oldPeriods[indexOfNewFirstPeriod], newPeriods[0], MANIFEST_UPDATE_TYPE.Partial);
  res.updatedPeriods.push({
    period: oldPeriods[indexOfNewFirstPeriod],
    result: updateRes
  });
  // Search each consecutive elements of `newPeriods` - after the initial one already
  // processed - in `oldPeriods`, removing and adding unfound Periods in the process
  var prevIndexOfNewPeriod = indexOfNewFirstPeriod + 1;
  for (var i = 1; i < newPeriods.length; i++) {
    var newPeriod = newPeriods[i];
    var indexOfNewPeriod = -1;
    for (var j = prevIndexOfNewPeriod; j < oldPeriods.length; j++) {
      if (newPeriod.id === oldPeriods[j].id) {
        indexOfNewPeriod = j;
        break; // end the loop
      }
    }
    if (indexOfNewPeriod < 0) {
      var _res$removedPeriods3;
      // Next element of `newPeriods` not found: insert it
      var toRemoveUntil = -1;
      for (var _j = prevIndexOfNewPeriod; _j < oldPeriods.length; _j++) {
        if (newPeriod.start < oldPeriods[_j].start) {
          toRemoveUntil = _j;
          break; // end the loop
        }
      }
      var nbElementsToRemove = toRemoveUntil - prevIndexOfNewPeriod;
      var removed = oldPeriods.splice(prevIndexOfNewPeriod, nbElementsToRemove, newPeriod);
      res.addedPeriods.push(newPeriod);
      (_res$removedPeriods3 = res.removedPeriods).push.apply(_res$removedPeriods3, removed);
    } else {
      if (indexOfNewPeriod > prevIndexOfNewPeriod) {
        var _res$removedPeriods4;
        // Some old periods were not found: remove
        log/* default */.A.warn("Manifest: old Periods not found in new when updating, removing");
        var _removed2 = oldPeriods.splice(prevIndexOfNewPeriod, indexOfNewPeriod - prevIndexOfNewPeriod);
        (_res$removedPeriods4 = res.removedPeriods).push.apply(_res$removedPeriods4, _removed2);
        indexOfNewPeriod = prevIndexOfNewPeriod;
      }
      // Later Periods can be fully replaced
      var result = updatePeriodInPlace(oldPeriods[indexOfNewPeriod], newPeriod, MANIFEST_UPDATE_TYPE.Full);
      res.updatedPeriods.push({
        period: oldPeriods[indexOfNewPeriod],
        result: result
      });
    }
    prevIndexOfNewPeriod++;
  }
  if (prevIndexOfNewPeriod < oldPeriods.length) {
    var _res$removedPeriods5;
    log/* default */.A.warn("Manifest: Ending Periods not found in new when updating, removing");
    var _removed3 = oldPeriods.splice(prevIndexOfNewPeriod, oldPeriods.length - prevIndexOfNewPeriod);
    (_res$removedPeriods5 = res.removedPeriods).push.apply(_res$removedPeriods5, _removed3);
  }
  return res;
}
;// CONCATENATED MODULE: ./src/manifest/manifest.ts

function manifest_createForOfIteratorHelperLoose(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (t) return (t = t.call(r)).next.bind(t); if (Array.isArray(r) || (t = manifest_unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var o = 0; return function () { return o >= r.length ? { done: !0 } : { done: !1, value: r[o++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function manifest_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return manifest_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? manifest_arrayLikeToArray(r, a) : void 0; } }
function manifest_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */












var generateSupplementaryTrackID = (0,id_generator/* default */.A)();
var generateNewManifestId = (0,id_generator/* default */.A)();
/**
 * Normalized Manifest structure.
 *
 * Details the current content being played:
 *   - the duration of the content
 *   - the available tracks
 *   - the available qualities
 *   - the segments defined in those qualities
 *   - ...
 * while staying agnostic of the transport protocol used (Smooth, DASH etc.).
 *
 * The Manifest and its contained information can evolve over time (like when
 * updating a dynamic manifest or when right management forbid some tracks from
 * being played).
 * To perform actions on those changes, any module using this Manifest can
 * listen to its sent events and react accordingly.
 *
 * @class Manifest
 */
var Manifest = /*#__PURE__*/function (_EventEmitter) {
  /**
   * Construct a Manifest instance from a parsed Manifest object (as returned by
   * Manifest parsers) and options.
   *
   * Some minor errors can arise during that construction. `this.contentWarnings`
   * will contain all such errors, in the order they have been encountered.
   * @param {Object} parsedManifest
   * @param {Object} options
   */
  function Manifest(parsedManifest, options) {
    var _this;
    var _a;
    _this = _EventEmitter.call(this) || this;
    var _options$supplementar = options.supplementaryTextTracks,
      supplementaryTextTracks = _options$supplementar === void 0 ? [] : _options$supplementar,
      _options$supplementar2 = options.supplementaryImageTracks,
      supplementaryImageTracks = _options$supplementar2 === void 0 ? [] : _options$supplementar2,
      representationFilter = options.representationFilter,
      manifestUpdateUrl = options.manifestUpdateUrl;
    _this.contentWarnings = [];
    _this.id = generateNewManifestId();
    _this.expired = (_a = parsedManifest.expired) !== null && _a !== void 0 ? _a : null;
    _this.transport = parsedManifest.transportType;
    _this.clockOffset = parsedManifest.clockOffset;
    _this.periods = parsedManifest.periods.map(function (parsedPeriod) {
      var _this$contentWarnings;
      var period = new Period(parsedPeriod, representationFilter);
      (_this$contentWarnings = _this.contentWarnings).push.apply(_this$contentWarnings, period.contentWarnings);
      return period;
    }).sort(function (a, b) {
      return a.start - b.start;
    });
    /**
     * @deprecated It is here to ensure compatibility with the way the
     * v3.x.x manages adaptations at the Manifest level
     */
    /* eslint-disable import/no-deprecated */
    _this.adaptations = _this.periods[0] === undefined ? {} : _this.periods[0].adaptations;
    /* eslint-enable import/no-deprecated */
    _this._timeBounds = parsedManifest.timeBounds;
    _this.isDynamic = parsedManifest.isDynamic;
    _this.isLive = parsedManifest.isLive;
    _this.isLastPeriodKnown = parsedManifest.isLastPeriodKnown;
    _this.uris = parsedManifest.uris === undefined ? [] : parsedManifest.uris;
    _this.updateUrl = manifestUpdateUrl;
    _this.lifetime = parsedManifest.lifetime;
    _this.clockOffset = parsedManifest.clockOffset;
    _this.suggestedPresentationDelay = parsedManifest.suggestedPresentationDelay;
    _this.availabilityStartTime = parsedManifest.availabilityStartTime;
    _this.publishTime = parsedManifest.publishTime;
    if (supplementaryImageTracks.length > 0) {
      _this._addSupplementaryImageAdaptations(supplementaryImageTracks);
    }
    if (supplementaryTextTracks.length > 0) {
      _this._addSupplementaryTextAdaptations(supplementaryTextTracks);
    }
    return _this;
  }
  /**
   * Returns the Period corresponding to the given `id`.
   * Returns `undefined` if there is none.
   * @param {string} id
   * @returns {Object|undefined}
   */
  (0,inheritsLoose/* default */.A)(Manifest, _EventEmitter);
  var _proto = Manifest.prototype;
  _proto.getPeriod = function getPeriod(id) {
    return (0,array_find/* default */.A)(this.periods, function (period) {
      return id === period.id;
    });
  }
  /**
   * Returns the Period encountered at the given time.
   * Returns `undefined` if there is no Period exactly at the given time.
   * @param {number} time
   * @returns {Object|undefined}
   */;
  _proto.getPeriodForTime = function getPeriodForTime(time) {
    var nextPeriod = null;
    for (var i = this.periods.length - 1; i >= 0; i--) {
      var period = this.periods[i];
      if (period.containsTime(time, nextPeriod)) {
        return period;
      }
      nextPeriod = period;
    }
  }
  /**
   * Returns the first Period starting strictly after the given time.
   * Returns `undefined` if there is no Period starting after that time.
   * @param {number} time
   * @returns {Object|undefined}
   */;
  _proto.getNextPeriod = function getNextPeriod(time) {
    return (0,array_find/* default */.A)(this.periods, function (period) {
      return period.start > time;
    });
  }
  /**
   * Returns the Period coming chronologically just after another given Period.
   * Returns `undefined` if not found.
   * @param {Object} period
   * @returns {Object|null}
   */;
  _proto.getPeriodAfter = function getPeriodAfter(period) {
    var endOfPeriod = period.end;
    if (endOfPeriod === undefined) {
      return null;
    }
    var nextPeriod = (0,array_find/* default */.A)(this.periods, function (_period) {
      return _period.end === undefined || endOfPeriod < _period.end;
    });
    return nextPeriod === undefined ? null : nextPeriod;
  }
  /**
   * Returns the most important URL from which the Manifest can be refreshed.
   * `undefined` if no URL is found.
   * @returns {string|undefined}
   */;
  _proto.getUrl = function getUrl() {
    return this.uris[0];
  }
  /**
   * Update the current Manifest properties by giving a new updated version.
   * This instance will be updated with the new information coming from it.
   * @param {Object} newManifest
   */;
  _proto.replace = function replace(newManifest) {
    this._performUpdate(newManifest, MANIFEST_UPDATE_TYPE.Full);
  }
  /**
   * Update the current Manifest properties by giving a new but shorter version
   * of it.
   * This instance will add the new information coming from it and will
   * automatically clean old Periods that shouldn't be available anymore.
   *
   * /!\ Throws if the given Manifest cannot be used or is not sufficient to
   * update the Manifest.
   * @param {Object} newManifest
   */;
  _proto.update = function update(newManifest) {
    this._performUpdate(newManifest, MANIFEST_UPDATE_TYPE.Partial);
  }
  /**
   * Returns the theoretical minimum playable position on the content
   * regardless of the current Adaptation chosen, as estimated at parsing
   * time.
   * @returns {number}
   */;
  _proto.getMinimumSafePosition = function getMinimumSafePosition() {
    var _a, _b;
    var windowData = this._timeBounds;
    if (windowData.timeshiftDepth === null) {
      return (_a = windowData.minimumSafePosition) !== null && _a !== void 0 ? _a : 0;
    }
    var maximumTimeData = windowData.maximumTimeData;
    var maximumTime;
    if (!windowData.maximumTimeData.isLinear) {
      maximumTime = maximumTimeData.maximumSafePosition;
    } else {
      var timeDiff = performance.now() - maximumTimeData.time;
      maximumTime = maximumTimeData.maximumSafePosition + timeDiff / 1000;
    }
    var theoricalMinimum = maximumTime - windowData.timeshiftDepth;
    return Math.max((_b = windowData.minimumSafePosition) !== null && _b !== void 0 ? _b : 0, theoricalMinimum);
  }
  /**
   * Get the position of the live edge - that is, the position of what is
   * currently being broadcasted, in seconds.
   * @returns {number|undefined}
   */;
  _proto.getLivePosition = function getLivePosition() {
    var maximumTimeData = this._timeBounds.maximumTimeData;
    if (!this.isLive || maximumTimeData.livePosition === undefined) {
      return undefined;
    }
    if (!maximumTimeData.isLinear) {
      return maximumTimeData.livePosition;
    }
    var timeDiff = performance.now() - maximumTimeData.time;
    return maximumTimeData.livePosition + timeDiff / 1000;
  }
  /**
   * Returns the theoretical maximum playable position on the content
   * regardless of the current Adaptation chosen, as estimated at parsing
   * time.
   */;
  _proto.getMaximumSafePosition = function getMaximumSafePosition() {
    var maximumTimeData = this._timeBounds.maximumTimeData;
    if (!maximumTimeData.isLinear) {
      return maximumTimeData.maximumSafePosition;
    }
    var timeDiff = performance.now() - maximumTimeData.time;
    return maximumTimeData.maximumSafePosition + timeDiff / 1000;
  }
  /**
   * Look in the Manifest for Representations linked to the given key ID,
   * and mark them as being impossible to decrypt.
   * Then trigger a "decipherabilityUpdate" event to notify everyone of the
   * changes performed.
   * @param {Function} isDecipherableCb
   */;
  _proto.updateRepresentationsDeciperability = function updateRepresentationsDeciperability(isDecipherableCb) {
    var updates = updateDeciperability(this, isDecipherableCb);
    if (updates.length > 0) {
      this.trigger("decipherabilityUpdate", updates);
    }
  }
  /**
   * @deprecated only returns adaptations for the first period
   * @returns {Array.<Object>}
   */;
  _proto.getAdaptations = function getAdaptations() {
    (0,warn_once/* default */.A)("manifest.getAdaptations() is deprecated." + " Please use manifest.period[].getAdaptations() instead");
    var firstPeriod = this.periods[0];
    if (firstPeriod === undefined) {
      return [];
    }
    var adaptationsByType = firstPeriod.adaptations;
    var adaptationsList = [];
    for (var adaptationType in adaptationsByType) {
      if (adaptationsByType.hasOwnProperty(adaptationType)) {
        var adaptations = adaptationsByType[adaptationType];
        adaptationsList.push.apply(adaptationsList, adaptations);
      }
    }
    return adaptationsList;
  }
  /**
   * @deprecated only returns adaptations for the first period
   * @returns {Array.<Object>}
   */;
  _proto.getAdaptationsForType = function getAdaptationsForType(adaptationType) {
    (0,warn_once/* default */.A)("manifest.getAdaptationsForType(type) is deprecated." + " Please use manifest.period[].getAdaptationsForType(type) instead");
    var firstPeriod = this.periods[0];
    if (firstPeriod === undefined) {
      return [];
    }
    var adaptationsForType = firstPeriod.adaptations[adaptationType];
    return adaptationsForType === undefined ? [] : adaptationsForType;
  }
  /**
   * @deprecated only returns adaptations for the first period
   * @returns {Array.<Object>}
   */;
  _proto.getAdaptation = function getAdaptation(wantedId) {
    (0,warn_once/* default */.A)("manifest.getAdaptation(id) is deprecated." + " Please use manifest.period[].getAdaptation(id) instead");
    /* eslint-disable import/no-deprecated */
    return (0,array_find/* default */.A)(this.getAdaptations(), function (_ref) {
      var id = _ref.id;
      return wantedId === id;
    });
    /* eslint-enable import/no-deprecated */
  }
  /**
   * Add supplementary image Adaptation(s) to the manifest.
   * @private
   * @param {Object|Array.<Object>} imageTracks
   */;
  _proto._addSupplementaryImageAdaptations = function _addSupplementaryImageAdaptations( /* eslint-disable import/no-deprecated */
  imageTracks) {
    var _this2 = this;
    var _imageTracks = Array.isArray(imageTracks) ? imageTracks : [imageTracks];
    var newImageTracks = _imageTracks.map(function (_ref2) {
      var mimeType = _ref2.mimeType,
        url = _ref2.url;
      var adaptationID = "gen-image-ada-" + generateSupplementaryTrackID();
      var representationID = "gen-image-rep-" + generateSupplementaryTrackID();
      var indexOfFilename = (0,resolve_url/* getFilenameIndexInUrl */.Cl)(url);
      var cdnUrl = url.substring(0, indexOfFilename);
      var filename = url.substring(indexOfFilename);
      var newAdaptation = new manifest_adaptation/* default */.A({
        id: adaptationID,
        type: "image",
        representations: [{
          bitrate: 0,
          cdnMetadata: [{
            baseUrl: cdnUrl
          }],
          id: representationID,
          mimeType: mimeType,
          index: new StaticRepresentationIndex({
            media: filename
          })
        }]
      }, {
        isManuallyAdded: true
      });
      if (newAdaptation.representations.length > 0 && !newAdaptation.isSupported) {
        var error = new media_error/* default */.A("MANIFEST_INCOMPATIBLE_CODECS_ERROR", "An Adaptation contains only incompatible codecs.", {
          adaptation: newAdaptation
        });
        _this2.contentWarnings.push(error);
      }
      return newAdaptation;
    });
    if (newImageTracks.length > 0 && this.periods.length > 0) {
      var adaptations = this.periods[0].adaptations;
      adaptations.image = adaptations.image != null ? adaptations.image.concat(newImageTracks) : newImageTracks;
    }
  }
  /**
   * Add supplementary text Adaptation(s) to the manifest.
   * @private
   * @param {Object|Array.<Object>} textTracks
   */;
  _proto._addSupplementaryTextAdaptations = function _addSupplementaryTextAdaptations( /* eslint-disable import/no-deprecated */
  textTracks) {
    var _this3 = this;
    var _textTracks = Array.isArray(textTracks) ? textTracks : [textTracks];
    var newTextAdaptations = _textTracks.reduce(function (allSubs, _ref3) {
      var mimeType = _ref3.mimeType,
        codecs = _ref3.codecs,
        url = _ref3.url,
        language = _ref3.language,
        languages = _ref3.languages,
        closedCaption = _ref3.closedCaption;
      var langsToMapOn = language != null ? [language] : languages != null ? languages : [];
      var indexOfFilename = (0,resolve_url/* getFilenameIndexInUrl */.Cl)(url);
      var cdnUrl = url.substring(0, indexOfFilename);
      var filename = url.substring(indexOfFilename);
      return allSubs.concat(langsToMapOn.map(function (_language) {
        var adaptationID = "gen-text-ada-" + generateSupplementaryTrackID();
        var representationID = "gen-text-rep-" + generateSupplementaryTrackID();
        var newAdaptation = new manifest_adaptation/* default */.A({
          id: adaptationID,
          type: "text",
          language: _language,
          closedCaption: closedCaption,
          representations: [{
            bitrate: 0,
            cdnMetadata: [{
              baseUrl: cdnUrl
            }],
            id: representationID,
            mimeType: mimeType,
            codecs: codecs,
            index: new StaticRepresentationIndex({
              media: filename
            })
          }]
        }, {
          isManuallyAdded: true
        });
        if (newAdaptation.representations.length > 0 && !newAdaptation.isSupported) {
          var error = new media_error/* default */.A("MANIFEST_INCOMPATIBLE_CODECS_ERROR", "An Adaptation contains only incompatible codecs.", {
            adaptation: newAdaptation
          });
          _this3.contentWarnings.push(error);
        }
        return newAdaptation;
      }));
    }, []);
    if (newTextAdaptations.length > 0 && this.periods.length > 0) {
      var adaptations = this.periods[0].adaptations;
      adaptations.text = adaptations.text != null ? adaptations.text.concat(newTextAdaptations) : newTextAdaptations;
    }
  }
  /**
   * @param {Object} newManifest
   * @param {number} updateType
   */;
  _proto._performUpdate = function _performUpdate(newManifest, updateType) {
    this.availabilityStartTime = newManifest.availabilityStartTime;
    this.expired = newManifest.expired;
    this.isDynamic = newManifest.isDynamic;
    this.isLive = newManifest.isLive;
    this.isLastPeriodKnown = newManifest.isLastPeriodKnown;
    this.lifetime = newManifest.lifetime;
    this.contentWarnings = newManifest.contentWarnings;
    this.suggestedPresentationDelay = newManifest.suggestedPresentationDelay;
    this.transport = newManifest.transport;
    this.publishTime = newManifest.publishTime;
    var updatedPeriodsResult;
    if (updateType === MANIFEST_UPDATE_TYPE.Full) {
      this._timeBounds = newManifest._timeBounds;
      this.uris = newManifest.uris;
      updatedPeriodsResult = replacePeriods(this.periods, newManifest.periods);
    } else {
      this._timeBounds.maximumTimeData = newManifest._timeBounds.maximumTimeData;
      this.updateUrl = newManifest.uris[0];
      updatedPeriodsResult = updatePeriods(this.periods, newManifest.periods);
      // Partial updates do not remove old Periods.
      // This can become a memory problem when playing a content long enough.
      // Let's clean manually Periods behind the minimum possible position.
      var min = this.getMinimumSafePosition();
      while (this.periods.length > 0) {
        var period = this.periods[0];
        if (period.end === undefined || period.end > min) {
          break;
        }
        this.periods.shift();
      }
    }
    // Re-set this.adaptations for retro-compatibility in v3.x.x
    /* eslint-disable import/no-deprecated */
    this.adaptations = this.periods[0] === undefined ? {} : this.periods[0].adaptations;
    /* eslint-enable import/no-deprecated */
    // Let's trigger events at the end, as those can trigger side-effects.
    // We do not want the current Manifest object to be incomplete when those
    // happen.
    this.trigger("manifestUpdate", updatedPeriodsResult);
  };
  return Manifest;
}(event_emitter/* default */.A);
/**
 * Update `decipherable` property of every `Representation` found in the
 * Manifest based on the result of a `isDecipherable` callback:
 *   - When that callback returns `true`, update `decipherable` to `true`
 *   - When that callback returns `false`, update `decipherable` to `false`
 *   - When that callback returns `undefined`, update `decipherable` to
 *     `undefined`
 * @param {Manifest} manifest
 * @param {Function} isDecipherable
 * @returns {Array.<Object>}
 */

function updateDeciperability(manifest, isDecipherable) {
  var updates = [];
  for (var _iterator = manifest_createForOfIteratorHelperLoose(manifest.periods), _step; !(_step = _iterator()).done;) {
    var period = _step.value;
    for (var _iterator2 = manifest_createForOfIteratorHelperLoose(period.getAdaptations()), _step2; !(_step2 = _iterator2()).done;) {
      var adaptation = _step2.value;
      for (var _iterator3 = manifest_createForOfIteratorHelperLoose(adaptation.representations), _step3; !(_step3 = _iterator3()).done;) {
        var representation = _step3.value;
        var result = isDecipherable(representation);
        if (result !== representation.decipherable) {
          updates.push({
            manifest: manifest,
            period: period,
            adaptation: adaptation,
            representation: representation
          });
          representation.decipherable = result;
          log/* default */.A.debug("Decipherability changed for \"" + representation.id + "\"", "(" + representation.bitrate + ")", String(representation.decipherable));
        }
      }
    }
  }
  return updates;
}
;// CONCATENATED MODULE: ./src/manifest/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






/* harmony default export */ var manifest = (Manifest);



/***/ }),

/***/ 7841:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   M: function() { return /* binding */ getLoggableSegmentId; },
/* harmony export */   Q: function() { return /* binding */ areSameContent; }
/* harmony export */ });
/* harmony import */ var _utils_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6787);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Check if two contents are the same
 * @param {Object} content1
 * @param {Object} content2
 * @returns {boolean}
 */
function areSameContent(content1, content2) {
  return content1.segment.id === content2.segment.id && content1.representation.uniqueId === content2.representation.uniqueId;
}
/**
 * Get string describing a given ISegment, useful for log functions.
 * @param {Object} content
 * @returns {string|null|undefined}
 */
function getLoggableSegmentId(content) {
  if ((0,_utils_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(content)) {
    return "";
  }
  var period = content.period,
    adaptation = content.adaptation,
    representation = content.representation,
    segment = content.segment;
  return adaptation.type + " P: " + period.id + " A: " + adaptation.id + " " + ("R: " + representation.id + " S: ") + (segment.isInit ? "init" : segment.complete ? segment.time + "-" + segment.duration : "" + segment.time);
}

/***/ }),

/***/ 3058:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: function() { return /* binding */ MAX_32_BIT_INT; }
/* harmony export */ });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Maximum integer that can be stored on 32 bits.
 *
 * This can be used for example to know what is the maximum ISOBMFF box size
 * that can be stored on the first four bytes of a box. Any value higher than
 * that will need 8 bytes (64 bits) to be stored.
 */
var MAX_32_BIT_INT = Math.pow(2, 32) - 1;

/***/ }),

/***/ 8797:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $H: function() { return /* binding */ getUuidContent; },
/* harmony export */   QL: function() { return /* binding */ getBoxOffsets; },
/* harmony export */   YH: function() { return /* binding */ getBox; },
/* harmony export */   fP: function() { return /* binding */ getNextBoxOffsets; },
/* harmony export */   fZ: function() { return /* binding */ getBoxContent; },
/* harmony export */   fj: function() { return /* binding */ getBoxesContent; },
/* harmony export */   o$: function() { return /* binding */ getChildBox; }
/* harmony export */ });
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9477);
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7994);
/* harmony import */ var _utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5553);
function _createForOfIteratorHelperLoose(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (t) return (t = t.call(r)).next.bind(t); if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var o = 0; return function () { return o >= r.length ? { done: !0 } : { done: !1, value: r[o++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * From a given buffer representing ISOBMFF data, browses inner boxes in
 * `childNames`, each element being a child box of the one before it.
 * Returns `null` if one of the child (or if the parent) is not found.
 * @param {Uint8Array} buf
 * @param {number[]} childNames
 * @returns {Uint8Array|null}
 */
function getChildBox(buf, childNames) {
  var currBox = buf;
  for (var _iterator = _createForOfIteratorHelperLoose(childNames), _step; !(_step = _iterator()).done;) {
    var childName = _step.value;
    var box = getBoxContent(currBox, childName);
    if (box === null) {
      return null;
    }
    currBox = box;
  }
  return currBox;
}
/**
 * Returns the content of a box based on its name.
 * `null` if not found.
 * @param {Uint8Array} buf - the isobmff data
 * @param {Number} boxName - the 4-letter 'name' of the box as a 4 byte integer
 * generated from encoding the corresponding ASCII in big endian.
 * @returns {UInt8Array|null}
 */
function getBoxContent(buf, boxName) {
  var offsets = getBoxOffsets(buf, boxName);
  return offsets !== null ? buf.subarray(offsets[1], offsets[2]) : null;
}
/**
 * Reads the whole ISOBMFF and returns the content of all boxes with the given
 * name, in order.
 * @param {Uint8Array} buf - the isobmff data
 * @param {Number} boxName - the 4-letter 'name' of the box as a 4 byte integer
 * generated from encoding the corresponding ASCII in big endian.
 * @returns {Array.<Uint8Array>}
 */
function getBoxesContent(buf, boxName) {
  var ret = [];
  var currentBuf = buf;
  while (true) {
    var offsets = getBoxOffsets(currentBuf, boxName);
    if (offsets === null) {
      return ret;
    }
    // Guard against a (very highly improbable) infinite loop
    (0,_utils_assert__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .h)(offsets[2] !== 0 && currentBuf.length !== 0);
    ret.push(currentBuf.subarray(offsets[1], offsets[2]));
    currentBuf = currentBuf.subarray(offsets[2]);
  }
}
/**
 * Returns an ISOBMFF box - size and name included - based on its name.
 * `null` if not found.
 * @param {Uint8Array} buf - the isobmff data
 * @param {Number} boxName - the 4-letter 'name' of the box as a 4 byte integer
 * generated from encoding the corresponding ASCII in big endian.
 * @returns {UInt8Array|null}
 */
function getBox(buf, boxName) {
  var offsets = getBoxOffsets(buf, boxName);
  return offsets !== null ? buf.subarray(offsets[0], offsets[2]) : null;
}
/**
 * Returns byte offsets for the start of the box, the start of its content and
 * the end of the box (not inclusive).
 *
 * `null` if not found.
 *
 * If found, the tuple returned has three elements, all numbers:
 *   1. The starting byte corresponding to the start of the box (from its size)
 *   2. The beginning of the box content - meaning the first byte after the
 *      size and the name of the box.
 *   3. The first byte after the end of the box, might be equal to `buf`'s
 *      length if we're considering the last box.
 * @param {Uint8Array} buf - the isobmff data
 * @param {Number} boxName - the 4-letter 'name' of the box as a 4 byte integer
 * generated from encoding the corresponding ASCII in big endian.
 * @returns {Array.<number>|null}
 */
function getBoxOffsets(buf, boxName) {
  var len = buf.length;
  var boxBaseOffset = 0;
  var name;
  var lastBoxSize = 0;
  var lastOffset;
  while (boxBaseOffset + 8 <= len) {
    lastOffset = boxBaseOffset;
    lastBoxSize = (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .be4toi */ .mq)(buf, lastOffset);
    lastOffset += 4;
    name = (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .be4toi */ .mq)(buf, lastOffset);
    lastOffset += 4;
    if (lastBoxSize === 0) {
      lastBoxSize = len - boxBaseOffset;
    } else if (lastBoxSize === 1) {
      if (lastOffset + 8 > len) {
        return null;
      }
      lastBoxSize = (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .be8toi */ .CQ)(buf, lastOffset);
      lastOffset += 8;
    }
    if (lastBoxSize < 0) {
      throw new Error("ISOBMFF: Size out of range");
    }
    if (name === boxName) {
      if (boxName === 0x75756964 /* === "uuid" */) {
        lastOffset += 16; // Skip uuid name
      }
      return [boxBaseOffset, lastOffset, boxBaseOffset + lastBoxSize];
    } else {
      boxBaseOffset += lastBoxSize;
    }
  }
  return null;
}
/**
 * Gives the content of a specific UUID box.
 * `undefined` if that box is not found.
 *
 * If found, the returned Uint8Array contains just the box's content: the box
 * without its name and size.
 * @param {Uint8Array} buf
 * @param {Number} id1
 * @param {Number} id2
 * @param {Number} id3
 * @param {Number} id4
 * @returns {Uint8Array|undefined}
 */
function getUuidContent(buf, id1, id2, id3, id4) {
  var len = buf.length;
  var boxSize;
  for (var boxBaseOffset = 0; boxBaseOffset < len; boxBaseOffset += boxSize) {
    var currentOffset = boxBaseOffset;
    boxSize = (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .be4toi */ .mq)(buf, currentOffset);
    currentOffset += 4;
    var boxName = (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .be4toi */ .mq)(buf, currentOffset);
    currentOffset += 4;
    if (boxSize === 0) {
      boxSize = len - boxBaseOffset;
    } else if (boxSize === 1) {
      if (currentOffset + 8 > len) {
        return undefined;
      }
      boxSize = (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .be8toi */ .CQ)(buf, currentOffset);
      currentOffset += 8;
    }
    if (boxName === 0x75756964 /* === "uuid" */ && currentOffset + 16 <= len && (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .be4toi */ .mq)(buf, currentOffset) === id1 && (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .be4toi */ .mq)(buf, currentOffset + 4) === id2 && (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .be4toi */ .mq)(buf, currentOffset + 8) === id3 && (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .be4toi */ .mq)(buf, currentOffset + 12) === id4) {
      currentOffset += 16;
      return buf.subarray(currentOffset, boxBaseOffset + boxSize);
    }
  }
}
/**
 * For the next encountered box, return byte offsets corresponding to:
 *   1. the starting byte offset for the next box (should always be equal to
 *       `0`).
 *   2. The beginning of the box content - meaning the first byte after the
 *      size and the name of the box.
 *   3. The first byte after the end of the box, might be equal to `buf`'s
 *      length if we're considering the last box.
 *
 * `null` if no box is found.
 * @param {Uint8Array} buf - the isobmff data
 * @param {Number} boxName - the 4-letter 'name' of the box as a 4 byte integer
 * generated from encoding the corresponding ASCII in big endian.
 */
function getNextBoxOffsets(buf) {
  var len = buf.length;
  if (len < 8) {
    _log__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A.warn("ISOBMFF: box inferior to 8 bytes, cannot find offsets");
    return null;
  }
  var lastOffset = 0;
  var boxSize = (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .be4toi */ .mq)(buf, lastOffset);
  lastOffset += 4;
  var name = (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .be4toi */ .mq)(buf, lastOffset);
  lastOffset += 4;
  if (boxSize === 0) {
    boxSize = len;
  } else if (boxSize === 1) {
    if (lastOffset + 8 > len) {
      _log__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A.warn("ISOBMFF: box too short, cannot find offsets");
      return null;
    }
    boxSize = (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .be8toi */ .CQ)(buf, lastOffset);
    lastOffset += 8;
  }
  if (boxSize < 0) {
    throw new Error("ISOBMFF: Size out of range");
  }
  if (name === 0x75756964 /* === "uuid" */) {
    lastOffset += 16; // Skip uuid name
  }
  return [0, lastOffset, boxSize];
}


/***/ }),

/***/ 2875:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Y2: function() { return /* binding */ getTRAF; },
/* harmony export */   hZ: function() { return /* binding */ getEMSG; },
/* harmony export */   ht: function() { return /* binding */ getTRAFs; },
/* harmony export */   iA: function() { return /* binding */ getMDIA; },
/* harmony export */   j8: function() { return /* binding */ getMDAT; }
/* harmony export */ });
/* harmony import */ var _get_box__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8797);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns the content of the first "traf" box encountered in the given ISOBMFF
 * data.
 * Returns null if not found.
 * @param {Uint8Array} buffer
 * @returns {Uint8Array|null}
 */
function getTRAF(buffer) {
  var moof = (0,_get_box__WEBPACK_IMPORTED_MODULE_0__/* .getBoxContent */ .fZ)(buffer, 0x6d6f6f66 /* moof */);
  if (moof === null) {
    return null;
  }
  return (0,_get_box__WEBPACK_IMPORTED_MODULE_0__/* .getBoxContent */ .fZ)(moof, 0x74726166 /* traf */);
}
/**
 * Returns the content of all "traf" boxes encountered in the given ISOBMFF
 * data.
 * Might be preferred to just `getTRAF` if you suspect that your ISOBMFF may
 * have multiple "moof" boxes.
 * @param {Uint8Array} buffer
 * @returns {Array.<Uint8Array>}
 */
function getTRAFs(buffer) {
  var moofs = (0,_get_box__WEBPACK_IMPORTED_MODULE_0__/* .getBoxesContent */ .fj)(buffer, 0x6d6f6f66 /* moof */);
  return moofs.reduce(function (acc, moof) {
    var traf = (0,_get_box__WEBPACK_IMPORTED_MODULE_0__/* .getBoxContent */ .fZ)(moof, 0x74726166 /* traf */);
    if (traf !== null) {
      acc.push(traf);
    }
    return acc;
  }, []);
}
/**
 * Returns the content of the first "moof" box encountered in the given ISOBMFF
 * data.
 * Returns null if not found.
 * @param {Uint8Array} buffer
 * @returns {Uint8Array|null}
 */
function getMDAT(buf) {
  return (0,_get_box__WEBPACK_IMPORTED_MODULE_0__/* .getBoxContent */ .fZ)(buf, 0x6d646174 /* "mdat" */);
}
/**
 * Returns the content of the first "mdia" box encountered in the given ISOBMFF
 * data.
 * Returns null if not found.
 * @param {Uint8Array} buffer
 * @returns {Uint8Array|null}
 */
function getMDIA(buf) {
  var moov = (0,_get_box__WEBPACK_IMPORTED_MODULE_0__/* .getBoxContent */ .fZ)(buf, 0x6d6f6f76 /* moov */);
  if (moov === null) {
    return null;
  }
  var trak = (0,_get_box__WEBPACK_IMPORTED_MODULE_0__/* .getBoxContent */ .fZ)(moov, 0x7472616b /* "trak" */);
  if (trak === null) {
    return null;
  }
  return (0,_get_box__WEBPACK_IMPORTED_MODULE_0__/* .getBoxContent */ .fZ)(trak, 0x6d646961 /* "mdia" */);
}
/**
 * Returns the content of the first "emsg" box encountered in the given ISOBMFF
 * data.
 * Returns null if not found.
 * @param {Uint8Array} buffer
 * @returns {Uint8Array|null}
 */
function getEMSG(buffer, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  return (0,_get_box__WEBPACK_IMPORTED_MODULE_0__/* .getBoxContent */ .fZ)(buffer.subarray(offset), 0x656d7367 /* emsg */);
}


/***/ }),

/***/ 2948:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: function() { return /* binding */ takePSSHOut; },
  L: function() { return /* binding */ getPsshSystemID; }
});

// EXTERNAL MODULE: ./src/log.ts + 1 modules
var log = __webpack_require__(9477);
;// CONCATENATED MODULE: ./src/utils/slice_uint8array.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @param {Uint8Array} arr - The Uint8Array you want to slice
 * @param {number} start - The starting byte index from the beginning
 * @param {number} end -     Byte index before which to end slicing.
 * If end is unspecified, the new ArrayBuffer contains all bytes from begin to
 * the end of this ArrayBuffer. If negative, it will make the Byte index begin
 * from the last Byte.
 * @returns {Uint8Array}
 */
function arraySlice(arr, start, end) {
  return new Uint8Array(Array.prototype.slice.call(arr, start, end));
}
/**
 * @param {Uint8Array} arr - The Uint8Array you want to slice
 * @param {number} start - The starting byte index from the beginning
 * @param {number} end -     Byte index before which to end slicing.
 * If end is unspecified, the new ArrayBuffer contains all bytes from begin to
 * the end of this ArrayBuffer. If negative, it will make the Byte index begin
 * from the last Byte.
 * @returns {Uint8Array}
 */
function uint8ArraySlice(arr, start, end) {
  return arr.slice(start, end);
}
/* harmony default export */ var slice_uint8array = (typeof Uint8Array.prototype.slice === "function" ? uint8ArraySlice : arraySlice);
// EXTERNAL MODULE: ./src/utils/string_parsing.ts
var string_parsing = __webpack_require__(4670);
// EXTERNAL MODULE: ./src/parsers/containers/isobmff/get_box.ts
var get_box = __webpack_require__(8797);
;// CONCATENATED MODULE: ./src/parsers/containers/isobmff/take_pssh_out.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Replace every PSSH box from an ISOBMFF segment by FREE boxes and returns the
 * removed PSSH in an array.
 * Useful to manually manage encryption while avoiding the round-trip with the
 * browser's encrypted event.
 * @param {Uint8Array} data - the ISOBMFF segment
 * @returns {Array.<Uint8Array>} - The extracted PSSH boxes. In the order they
 * are encountered.
 */
function takePSSHOut(data) {
  var i = 0;
  var moov = (0,get_box/* getBoxContent */.fZ)(data, 0x6d6f6f76 /* moov */);
  if (moov === null) {
    return [];
  }
  var psshBoxes = [];
  while (i < moov.length) {
    var psshOffsets = void 0;
    try {
      psshOffsets = (0,get_box/* getBoxOffsets */.QL)(moov, 0x70737368 /* pssh */);
    } catch (e) {
      var err = e instanceof Error ? e : "";
      log/* default */.A.warn("Error while removing PSSH from ISOBMFF", err);
      return psshBoxes;
    }
    if (psshOffsets == null) {
      return psshBoxes;
    }
    var pssh = slice_uint8array(moov, psshOffsets[0], psshOffsets[2]);
    var systemId = getPsshSystemID(pssh, psshOffsets[1] - psshOffsets[0]);
    if (systemId !== undefined) {
      psshBoxes.push({
        systemId: systemId,
        data: pssh
      });
    }
    // replace by `free` box.
    moov[psshOffsets[0] + 4] = 0x66;
    moov[psshOffsets[0] + 5] = 0x72;
    moov[psshOffsets[0] + 6] = 0x65;
    moov[psshOffsets[0] + 7] = 0x65;
    i = psshOffsets[2];
  }
  return psshBoxes;
}
/**
 * Parse systemId from a "pssh" box into an hexadecimal string.
 * `undefined` if we could not extract a systemId.
 * @param {Uint8Array} buff - The pssh box
 * @param {number} initialDataOffset - offset of the first byte after the size
 * and name in this pssh box.
 * @returns {string|undefined}
 */
function getPsshSystemID(buff, initialDataOffset) {
  if (buff[initialDataOffset] > 1) {
    log/* default */.A.warn("ISOBMFF: un-handled PSSH version");
    return undefined;
  }
  var offset = initialDataOffset + 4; /* version + flags */
  if (offset + 16 > buff.length) {
    return undefined;
  }
  var systemIDBytes = slice_uint8array(buff, offset, offset + 16);
  return (0,string_parsing/* bytesToHex */.My)(systemIDBytes);
}

/***/ }),

/***/ 1134:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   D1: function() { return /* binding */ getTrackFragmentDecodeTime; },
/* harmony export */   J_: function() { return /* binding */ updateBoxLength; },
/* harmony export */   Tr: function() { return /* binding */ getSegmentsFromSidx; },
/* harmony export */   a5: function() { return /* binding */ getKeyIdFromInitSegment; },
/* harmony export */   cS: function() { return /* binding */ getDurationFromTrun; },
/* harmony export */   pk: function() { return /* binding */ parseEmsgBoxes; },
/* harmony export */   zS: function() { return /* binding */ getMDHDTimescale; }
/* harmony export */ });
/* unused harmony export patchPssh */
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(9477);
/* harmony import */ var _utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5553);
/* harmony import */ var _utils_string_parsing__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(4670);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(3058);
/* harmony import */ var _get_box__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8797);
/* harmony import */ var _read__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2875);
function _createForOfIteratorHelperLoose(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (t) return (t = t.call(r)).next.bind(t); if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var o = 0; return function () { return o >= r.length ? { done: !0 } : { done: !1, value: r[o++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */









/**
 * Parse the sidx part (segment index) of an ISOBMFF buffer and construct a
 * corresponding Array of available segments.
 *
 * Returns `null` if not found.
 * @param {Uint8Array} buf
 * @param {Number} sidxOffsetInWholeSegment
 * @returns {Object|null} {Array.<Object>} - Information about each subsegment.
 */
function getSegmentsFromSidx(buf, sidxOffsetInWholeSegment) {
  var sidxOffsets = (0,_get_box__WEBPACK_IMPORTED_MODULE_0__/* .getBoxOffsets */ .QL)(buf, 0x73696478 /* "sidx" */);
  if (sidxOffsets === null) {
    return null;
  }
  var offset = sidxOffsetInWholeSegment;
  var boxSize = sidxOffsets[2] - sidxOffsets[0];
  var cursor = sidxOffsets[1];
  /* version(8) */
  /* flags(24) */
  /* reference_ID(32); */
  /* timescale(32); */
  var version = buf[cursor];
  cursor += 4 + 4;
  var timescale = (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .be4toi */ .mq)(buf, cursor);
  cursor += 4;
  /* earliest_presentation_time(32 / 64) */
  /* first_offset(32 / 64) */
  var time;
  if (version === 0) {
    time = (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .be4toi */ .mq)(buf, cursor);
    cursor += 4;
    offset += (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .be4toi */ .mq)(buf, cursor) + boxSize;
    cursor += 4;
  } else if (version === 1) {
    time = (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .be8toi */ .CQ)(buf, cursor);
    cursor += 8;
    offset += (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .be8toi */ .CQ)(buf, cursor) + boxSize;
    cursor += 8;
  } else {
    return null;
  }
  var segments = [];
  /* reserved(16) */
  /* reference_count(16) */
  cursor += 2;
  var count = (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .be2toi */ .UU)(buf, cursor);
  cursor += 2;
  while (--count >= 0) {
    /* reference_type(1) */
    /* reference_size(31) */
    /* segment_duration(32) */
    /* sap..(32) */
    var refChunk = (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .be4toi */ .mq)(buf, cursor);
    cursor += 4;
    var refType = (refChunk & 0x80000000) >>> 31;
    var refSize = refChunk & 0x7fffffff;
    // when set to 1 indicates that the reference is to a sidx, else to media
    if (refType === 1) {
      throw new Error("sidx with reference_type `1` not yet implemented");
    }
    var duration = (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .be4toi */ .mq)(buf, cursor);
    cursor += 4;
    // let sapChunk = be4toi(buf, cursor + 8);
    cursor += 4;
    // TODO(pierre): handle sap
    // let startsWithSap = (sapChunk & 0x80000000) >>> 31;
    // let sapType = (sapChunk & 0x70000000) >>> 28;
    // let sapDelta = sapChunk & 0x0FFFFFFF;
    segments.push({
      time: time,
      duration: duration,
      timescale: timescale,
      range: [offset, offset + refSize - 1]
    });
    time += duration;
    offset += refSize;
  }
  return segments;
}
/**
 * Parse track Fragment Decode Time to get a precize initial time for this
 * segment (in the media timescale).
 *
 * Stops at the first tfdt encountered from the beginning of the file.
 * Returns this time.
 * `undefined` if not found.
 * @param {Uint8Array} buffer
 * @returns {Number | undefined}
 */
function getTrackFragmentDecodeTime(buffer) {
  var traf = (0,_read__WEBPACK_IMPORTED_MODULE_2__/* .getTRAF */ .Y2)(buffer);
  if (traf === null) {
    return undefined;
  }
  var tfdt = (0,_get_box__WEBPACK_IMPORTED_MODULE_0__/* .getBoxContent */ .fZ)(traf, 0x74666474 /* tfdt */);
  if (tfdt === null) {
    return undefined;
  }
  var version = tfdt[0];
  return version === 1 ? (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .be8toi */ .CQ)(tfdt, 4) : version === 0 ? (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .be4toi */ .mq)(tfdt, 4) : undefined;
}
/**
 * Returns the "default sample duration" which is the default value for duration
 * of samples found in a "traf" ISOBMFF box.
 *
 * Returns `undefined` if no "default sample duration" has been found.
 * @param {Uint8Array} traf
 * @returns {number|undefined}
 */
function getDefaultDurationFromTFHDInTRAF(traf) {
  var tfhd = (0,_get_box__WEBPACK_IMPORTED_MODULE_0__/* .getBoxContent */ .fZ)(traf, 0x74666864 /* tfhd */);
  if (tfhd === null) {
    return undefined;
  }
  var cursor = /* version */1;
  var flags = (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .be3toi */ .tb)(tfhd, cursor);
  cursor += 3;
  var hasBaseDataOffset = (flags & 0x000001) > 0;
  var hasSampleDescriptionIndex = (flags & 0x000002) > 0;
  var hasDefaultSampleDuration = (flags & 0x000008) > 0;
  if (!hasDefaultSampleDuration) {
    return undefined;
  }
  cursor += 4;
  if (hasBaseDataOffset) {
    cursor += 8;
  }
  if (hasSampleDescriptionIndex) {
    cursor += 4;
  }
  var defaultDuration = (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .be4toi */ .mq)(tfhd, cursor);
  return defaultDuration;
}
/**
 * Calculate segment duration approximation by additioning the duration from
 * every samples in a trun ISOBMFF box.
 *
 * Returns `undefined` if we could not parse the duration.
 * @param {Uint8Array} buffer
 * @returns {number | undefined}
 */
function getDurationFromTrun(buffer) {
  var trafs = (0,_read__WEBPACK_IMPORTED_MODULE_2__/* .getTRAFs */ .ht)(buffer);
  if (trafs.length === 0) {
    return undefined;
  }
  var completeDuration = 0;
  for (var _iterator = _createForOfIteratorHelperLoose(trafs), _step; !(_step = _iterator()).done;) {
    var traf = _step.value;
    var trun = (0,_get_box__WEBPACK_IMPORTED_MODULE_0__/* .getBoxContent */ .fZ)(traf, 0x7472756e /* trun */);
    if (trun === null) {
      return undefined;
    }
    var cursor = 0;
    var version = trun[cursor];
    cursor += 1;
    if (version > 1) {
      return undefined;
    }
    var flags = (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .be3toi */ .tb)(trun, cursor);
    cursor += 3;
    var hasSampleDuration = (flags & 0x000100) > 0;
    var defaultDuration = 0;
    if (!hasSampleDuration) {
      defaultDuration = getDefaultDurationFromTFHDInTRAF(traf);
      if (defaultDuration === undefined) {
        return undefined;
      }
    }
    var hasDataOffset = (flags & 0x000001) > 0;
    var hasFirstSampleFlags = (flags & 0x000004) > 0;
    var hasSampleSize = (flags & 0x000200) > 0;
    var hasSampleFlags = (flags & 0x000400) > 0;
    var hasSampleCompositionOffset = (flags & 0x000800) > 0;
    var sampleCounts = (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .be4toi */ .mq)(trun, cursor);
    cursor += 4;
    if (hasDataOffset) {
      cursor += 4;
    }
    if (hasFirstSampleFlags) {
      cursor += 4;
    }
    var i = sampleCounts;
    var duration = 0;
    while (i-- > 0) {
      if (hasSampleDuration) {
        duration += (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .be4toi */ .mq)(trun, cursor);
        cursor += 4;
      } else {
        duration += defaultDuration;
      }
      if (hasSampleSize) {
        cursor += 4;
      }
      if (hasSampleFlags) {
        cursor += 4;
      }
      if (hasSampleCompositionOffset) {
        cursor += 4;
      }
    }
    completeDuration += duration;
  }
  return completeDuration;
}
/**
 * Get timescale information from a movie header box. Found in init segments.
 * `undefined` if not found or not parsed.
 *
 * This timescale is the default timescale used for segments.
 * @param {Uint8Array} buffer
 * @returns {Number | undefined}
 */
function getMDHDTimescale(buffer) {
  var mdia = (0,_read__WEBPACK_IMPORTED_MODULE_2__/* .getMDIA */ .iA)(buffer);
  if (mdia === null) {
    return undefined;
  }
  var mdhd = (0,_get_box__WEBPACK_IMPORTED_MODULE_0__/* .getBoxContent */ .fZ)(mdia, 0x6d646864 /* "mdhd" */);
  if (mdhd === null) {
    return undefined;
  }
  var cursor = 0;
  var version = mdhd[cursor];
  cursor += 4;
  return version === 1 ? (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .be4toi */ .mq)(mdhd, cursor + 16) : version === 0 ? (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .be4toi */ .mq)(mdhd, cursor + 8) : undefined;
}
/**
 * Creates a PSSH box with the given systemId and data.
 * @param {Array.<Object>} psshInfo
 * @returns {Uint8Array}
 */
function createPssh(_ref) {
  var systemId = _ref.systemId,
    privateData = _ref.privateData;
  var _systemId = systemId.replace(/-/g, "");
  assert(_systemId.length === 32);
  return createBox("pssh", concat(4,
  // 4 initial zeroed bytes
  hexToBytes(_systemId), itobe4(privateData.length), privateData));
}
/**
 * Update ISOBMFF given to add a "pssh" box in the "moov" box for every content
 * protection in the psshList array given.
 * @param {Uint8Array} buf - the ISOBMFF file
 * @param {Array.<Object>} psshList
 * @returns {Uint8Array} - The new ISOBMFF generated.
 */
function patchPssh(buf, psshList) {
  if (psshList == null || psshList.length === 0) {
    return buf;
  }
  var moovOffsets = getBoxOffsets(buf, 0x6d6f6f76 /* = "moov" */);
  if (moovOffsets === null) {
    return buf;
  }
  var moov = buf.subarray(moovOffsets[0], moovOffsets[2]);
  var moovArr = [moov];
  for (var i = 0; i < psshList.length; i++) {
    moovArr.push(createPssh(psshList[i]));
  }
  var newmoov = updateBoxLength(concat.apply(void 0, moovArr));
  return concat(buf.subarray(0, moovOffsets[0]), newmoov, buf.subarray(moovOffsets[2]));
}
/**
 * Returns a new version of the given box with the size updated
 * so it reflects its actual size.
 *
 * You can use this function after modifying a ISOBMFF box so its size is
 * updated.
 *
 * /!\ Please consider that this function might mutate the given Uint8Array
 * in place or might create a new one, depending on the current conditions.
 * @param {Uint8Array} buf - The ISOBMFF box
 * @returns {Uint8Array}
 */
function updateBoxLength(buf) {
  var newLen = buf.length;
  if (newLen < 4) {
    throw new Error("Cannot update box length: box too short");
  }
  var oldSize = (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .be4toi */ .mq)(buf, 0);
  if (oldSize === 0) {
    if (newLen > _constants__WEBPACK_IMPORTED_MODULE_3__/* .MAX_32_BIT_INT */ .Z) {
      var newBox = new Uint8Array(newLen + 8);
      newBox.set((0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .itobe4 */ .KS)(1), 0);
      newBox.set(buf.subarray(4, 8), 4);
      newBox.set((0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .itobe8 */ .Kk)(newLen + 8), 8);
      newBox.set(buf.subarray(8, newLen), 16);
      return newBox;
    } else {
      buf.set((0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .itobe4 */ .KS)(newLen), 0);
      return buf;
    }
  } else if (oldSize === 1) {
    if (newLen < 16) {
      throw new Error("Cannot update box length: box too short");
    }
    buf.set((0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .itobe8 */ .Kk)(newLen), 8);
    return buf;
  } else if (newLen <= _constants__WEBPACK_IMPORTED_MODULE_3__/* .MAX_32_BIT_INT */ .Z) {
    buf.set((0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .itobe4 */ .KS)(newLen), 0);
    return buf;
  } else {
    var _newBox = new Uint8Array(newLen + 8);
    _newBox.set((0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .itobe4 */ .KS)(1), 0);
    _newBox.set(buf.subarray(4, 8), 4);
    _newBox.set((0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .itobe8 */ .Kk)(newLen + 8), 8);
    _newBox.set(buf.subarray(8, newLen), 16);
    return _newBox;
  }
}
/**
 * Parse EMSG boxes from ISOBMFF data.
 * @param {Uint8Array} buffer
 * @returns {Array.<Object> | undefined}
 */
function parseEmsgBoxes(buffer) {
  var emsgs = [];
  var offset = 0;
  while (offset < buffer.length) {
    var emsg = (0,_read__WEBPACK_IMPORTED_MODULE_2__/* .getEMSG */ .hZ)(buffer, offset);
    if (emsg === null) {
      break;
    }
    var length = emsg.length;
    offset += length;
    var version = emsg[0];
    if (version !== 0) {
      _log__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A.warn("ISOBMFF: EMSG version " + version.toString() + " not supported.");
    } else {
      var position = 4; // skip version + flags
      var _readNullTerminatedSt = (0,_utils_string_parsing__WEBPACK_IMPORTED_MODULE_5__/* .readNullTerminatedString */ .Yn)(emsg, position),
        schemeIdEnd = _readNullTerminatedSt.end,
        schemeIdUri = _readNullTerminatedSt.string;
      position = schemeIdEnd; // skip schemeIdUri
      var _readNullTerminatedSt2 = (0,_utils_string_parsing__WEBPACK_IMPORTED_MODULE_5__/* .readNullTerminatedString */ .Yn)(emsg, position),
        valueEnd = _readNullTerminatedSt2.end,
        value = _readNullTerminatedSt2.string;
      position = valueEnd; // skip value
      var timescale = (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .be4toi */ .mq)(emsg, position);
      position += 4; // skip timescale
      var presentationTimeDelta = (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .be4toi */ .mq)(emsg, position);
      position += 4; // skip presentationTimeDelta
      var eventDuration = (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .be4toi */ .mq)(emsg, position);
      position += 4; // skip eventDuration
      var id = (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .be4toi */ .mq)(emsg, position);
      position += 4; // skip id
      var messageData = emsg.subarray(position, length);
      var emsgData = {
        schemeIdUri: schemeIdUri,
        value: value,
        timescale: timescale,
        presentationTimeDelta: presentationTimeDelta,
        eventDuration: eventDuration,
        id: id,
        messageData: messageData
      };
      emsgs.push(emsgData);
    }
  }
  if (emsgs.length === 0) {
    return undefined;
  }
  return emsgs;
}
/**
 * @param {Uint8Array} segment
 * @returns {Uint8Array|null}
 */
function getKeyIdFromInitSegment(segment) {
  var stsd = (0,_get_box__WEBPACK_IMPORTED_MODULE_0__/* .getChildBox */ .o$)(segment, [0x6d6f6f76 /* moov */, 0x7472616b /* trak */, 0x6d646961 /* mdia */, 0x6d696e66 /* minf */, 0x7374626c /* stbl */, 0x73747364 /* stsd */]);
  if (stsd === null) {
    return null;
  }
  var stsdSubBoxes = stsd.subarray(8);
  var encBox = (0,_get_box__WEBPACK_IMPORTED_MODULE_0__/* .getBoxContent */ .fZ)(stsdSubBoxes, 0x656e6376 /* encv */);
  var encContentOffset = 0;
  if (encBox === null) {
    encContentOffset = 8 +
    // sample entry header
    8 +
    // reserved
    2 +
    // channelcount
    2 +
    // samplesize
    2 +
    // predefined
    2 +
    // reserved
    4; // samplerate
    encBox = (0,_get_box__WEBPACK_IMPORTED_MODULE_0__/* .getBoxContent */ .fZ)(stsdSubBoxes, 0x656e6361 /* enca */);
  } else {
    encContentOffset = 8 +
    // sample entry header
    2 + 2 + 12 +
    // predefined + reserved + predefined
    2 + 2 +
    // width + height
    4 + 4 +
    // horizresolution + vertresolution
    4 +
    // reserved
    2 +
    // frame_count
    32 + 2 +
    // depth
    2; // pre-defined;
  }
  if (encBox === null) {
    // There's no encryption data here
    return null;
  }
  var tenc = (0,_get_box__WEBPACK_IMPORTED_MODULE_0__/* .getChildBox */ .o$)(encBox.subarray(encContentOffset), [0x73696e66 /* sinf */, 0x73636869 /* schi */, 0x74656e63 /* tenc */]);
  if (tenc === null || tenc.byteLength < 24) {
    return null;
  }
  var keyId = tenc.subarray(8, 24);
  // Zero-filled keyId should only be valid for unencrypted content
  return keyId.every(function (b) {
    return b === 0;
  }) ? null : keyId;
}


/***/ }),

/***/ 1755:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5553);
/* harmony import */ var _utils_string_parsing__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4670);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */


/**
 * @param {UInt8Array} buf
 * @returns {Object}
 */
function parseBif(buf) {
  var pos = 0;
  var length = buf.length;
  var fileFormat = (0,_utils_string_parsing__WEBPACK_IMPORTED_MODULE_0__/* .utf8ToStr */ .Es)(buf.subarray(pos + 1, pos + 8));
  pos += 8;
  if (buf[0] !== 0x89 || fileFormat !== "BIF\r\n\x1A\n") {
    throw new Error("Invalid BIF file");
  }
  var minorVersion = buf[pos];
  pos += 1;
  var majorVersion = buf[pos];
  pos += 1;
  var patchVersion = buf[pos];
  pos += 1;
  var increVersion = buf[pos];
  pos += 1;
  var version = [minorVersion, majorVersion, patchVersion, increVersion].join(".");
  if (majorVersion > 0) {
    throw new Error("Unhandled version: " + majorVersion);
  }
  var imageCount = (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .le4toi */ .eR)(buf, pos);
  pos += 4;
  var framewiseSeparation = (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .le4toi */ .eR)(buf, pos);
  pos += 4;
  var format = (0,_utils_string_parsing__WEBPACK_IMPORTED_MODULE_0__/* .utf8ToStr */ .Es)(buf.subarray(pos, pos + 4));
  pos += 4;
  var width = (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .le2toi */ .AT)(buf, pos);
  pos += 2;
  var height = (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .le2toi */ .AT)(buf, pos);
  pos += 2;
  var aspectRatio = [buf[pos], buf[pos + 1]].join(":");
  pos += 2;
  var isVod = buf[pos] === 1;
  // bytes 0x1F to 0x40 is unused data for now
  pos = 0x40;
  var thumbs = [];
  if (imageCount === 0) {
    throw new Error("bif: no images to parse");
  }
  var index = 0;
  var previousImageInfo = null;
  while (pos < length) {
    var currentImageTimestamp = (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .le4toi */ .eR)(buf, pos);
    pos += 4;
    var currentImageOffset = (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .le4toi */ .eR)(buf, pos);
    pos += 4;
    if (previousImageInfo !== null) {
      // calculate for index-1
      var ts = previousImageInfo.timestamp * framewiseSeparation;
      var duration = framewiseSeparation;
      var data = buf.slice(previousImageInfo.offset, currentImageOffset);
      thumbs.push({
        index: index,
        duration: duration,
        ts: ts,
        data: data
      });
      index++;
    }
    if (currentImageTimestamp === 0xffffffff) {
      break;
    }
    previousImageInfo = {
      timestamp: currentImageTimestamp,
      offset: currentImageOffset
    };
  }
  return {
    fileFormat: "BIF",
    version: version,
    imageCount: imageCount,
    timescale: 1000,
    format: format,
    width: width,
    height: height,
    aspectRatio: aspectRatio,
    isVod: isVod,
    thumbs: thumbs
  };
}
/* harmony default export */ __webpack_exports__.A = (parseBif);

/***/ }),

/***/ 9044:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: function() { return /* binding */ BaseRepresentationIndex; }
/* harmony export */ });
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(9477);
/* harmony import */ var _utils_index_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3877);
/* harmony import */ var _get_init_segment__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1160);
/* harmony import */ var _get_segments_from_timeline__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(5403);
/* harmony import */ var _tokens__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9955);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * Add a new segment to the index.
 *
 * /!\ Mutate the given index
 * @param {Object} index
 * @param {Object} segmentInfos
 * @returns {Boolean} - true if the segment has been added
 */
function _addSegmentInfos(index, segmentInfos) {
  if (segmentInfos.timescale !== index.timescale) {
    var timescale = index.timescale;
    index.timeline.push({
      start: segmentInfos.time / segmentInfos.timescale * timescale,
      duration: segmentInfos.duration / segmentInfos.timescale * timescale,
      repeatCount: segmentInfos.count === undefined ? 0 : segmentInfos.count,
      range: segmentInfos.range
    });
  } else {
    index.timeline.push({
      start: segmentInfos.time,
      duration: segmentInfos.duration,
      repeatCount: segmentInfos.count === undefined ? 0 : segmentInfos.count,
      range: segmentInfos.range
    });
  }
  return true;
}
var BaseRepresentationIndex = /*#__PURE__*/function () {
  /**
   * @param {Object} index
   * @param {Object} context
   */
  function BaseRepresentationIndex(index, context) {
    var _a, _b, _c;
    var periodStart = context.periodStart,
      periodEnd = context.periodEnd,
      representationId = context.representationId,
      representationBitrate = context.representationBitrate,
      isEMSGWhitelisted = context.isEMSGWhitelisted;
    var timescale = (_a = index.timescale) !== null && _a !== void 0 ? _a : 1;
    var presentationTimeOffset = index.presentationTimeOffset != null ? index.presentationTimeOffset : 0;
    var indexTimeOffset = presentationTimeOffset - periodStart * timescale;
    var initializationUrl = ((_b = index.initialization) === null || _b === void 0 ? void 0 : _b.media) === undefined ? null : (0,_tokens__WEBPACK_IMPORTED_MODULE_0__/* .constructRepresentationUrl */ .I1)(index.initialization.media, representationId, representationBitrate);
    var segmentUrlTemplate = index.media === undefined ? null : (0,_tokens__WEBPACK_IMPORTED_MODULE_0__/* .constructRepresentationUrl */ .I1)(index.media, representationId, representationBitrate);
    // TODO If indexRange is either undefined or behind the initialization segment
    // the following logic will not work.
    // However taking the nth first bytes like `dash.js` does (where n = 1500) is
    // not straightforward as we would need to clean-up the segment after that.
    // The following logic corresponds to 100% of tested cases, so good enough for
    // now.
    var range = index.initialization !== undefined ? index.initialization.range : index.indexRange !== undefined ? [0, index.indexRange[0] - 1] : undefined;
    this._index = {
      indexRange: index.indexRange,
      indexTimeOffset: indexTimeOffset,
      initialization: {
        url: initializationUrl,
        range: range
      },
      segmentUrlTemplate: segmentUrlTemplate,
      startNumber: index.startNumber,
      endNumber: index.endNumber,
      timeline: (_c = index.timeline) !== null && _c !== void 0 ? _c : [],
      timescale: timescale
    };
    this._manifestBoundsCalculator = context.manifestBoundsCalculator;
    this._scaledPeriodStart = (0,_utils_index_helpers__WEBPACK_IMPORTED_MODULE_1__/* .toIndexTime */ .vb)(periodStart, this._index);
    this._scaledPeriodEnd = periodEnd == null ? undefined : (0,_utils_index_helpers__WEBPACK_IMPORTED_MODULE_1__/* .toIndexTime */ .vb)(periodEnd, this._index);
    this._isInitialized = this._index.timeline.length > 0;
    this._isEMSGWhitelisted = isEMSGWhitelisted;
  }
  /**
   * Construct init Segment.
   * @returns {Object}
   */
  var _proto = BaseRepresentationIndex.prototype;
  _proto.getInitSegment = function getInitSegment() {
    return (0,_get_init_segment__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A)(this._index, this._isEMSGWhitelisted);
  }
  /**
   * Get the list of segments that are currently available from the `from`
   * position, in seconds, ending `dur` seconds after that position.
   *
   * Note that if not already done, you might need to "initialize" the
   * `BaseRepresentationIndex` first so that the list of available segments
   * is known.
   *
   * @see isInitialized for more information on `BaseRepresentationIndex`
   * initialization.
   * @param {Number} from
   * @param {Number} dur
   * @returns {Array.<Object>}
   */;
  _proto.getSegments = function getSegments(from, dur) {
    return (0,_get_segments_from_timeline__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A)(this._index, from, dur, this._manifestBoundsCalculator, this._scaledPeriodEnd, this._isEMSGWhitelisted);
  }
  /**
   * Returns false as no Segment-Base based index should need to be refreshed.
   * @returns {Boolean}
   */;
  _proto.shouldRefresh = function shouldRefresh() {
    return false;
  }
  /**
   * Returns first position in index.
   * @returns {Number|null}
   */;
  _proto.getFirstAvailablePosition = function getFirstAvailablePosition() {
    var index = this._index;
    if (index.timeline.length === 0) {
      return null;
    }
    return (0,_utils_index_helpers__WEBPACK_IMPORTED_MODULE_1__/* .fromIndexTime */ ._l)(Math.max(this._scaledPeriodStart, index.timeline[0].start), index);
  }
  /**
   * Returns last position in index.
   * @returns {Number|null}
   */;
  _proto.getLastAvailablePosition = function getLastAvailablePosition() {
    var _a;
    var timeline = this._index.timeline;
    if (timeline.length === 0) {
      return null;
    }
    var lastTimelineElement = timeline[timeline.length - 1];
    var lastTime = Math.min((0,_utils_index_helpers__WEBPACK_IMPORTED_MODULE_1__/* .getIndexSegmentEnd */ .Rb)(lastTimelineElement, null, this._scaledPeriodEnd), (_a = this._scaledPeriodEnd) !== null && _a !== void 0 ? _a : Infinity);
    return (0,_utils_index_helpers__WEBPACK_IMPORTED_MODULE_1__/* .fromIndexTime */ ._l)(lastTime, this._index);
  }
  /**
   * Returns the absolute end in seconds this RepresentationIndex can reach once
   * all segments are available.
   * @returns {number|null|undefined}
   */;
  _proto.getEnd = function getEnd() {
    return this.getLastAvailablePosition();
  }
  /**
   * Returns:
   *   - `true` if in the given time interval, at least one new segment is
   *     expected to be available in the future.
   *   - `false` either if all segments in that time interval are already
   *     available for download or if none will ever be available for it.
   *   - `undefined` when it is not possible to tell.
   *
   * Always `false` in a `BaseRepresentationIndex` because all segments should
   * be directly available.
   * @returns {boolean}
   */;
  _proto.awaitSegmentBetween = function awaitSegmentBetween() {
    return false;
  }
  /**
   * Segments in a segmentBase scheme should stay available.
   * @returns {Boolean|undefined}
   */;
  _proto.isSegmentStillAvailable = function isSegmentStillAvailable() {
    return true;
  }
  /**
   * We do not check for discontinuity in SegmentBase-based indexes.
   * @returns {null}
   */;
  _proto.checkDiscontinuity = function checkDiscontinuity() {
    return null;
  }
  /**
   * No segment in a `BaseRepresentationIndex` are known initially.
   * It is only defined generally in an "index segment" that will thus need to
   * be first loaded and parsed.
   * Until then, this `BaseRepresentationIndex` is considered as `uninitialized`
   * (@see isInitialized).
   *
   * Once that those information are available, the present
   * `BaseRepresentationIndex` can be "initialized" by adding that parsed
   * segment information through this method.
   * @param {Array.<Object>} indexSegments
   * @returns {Array.<Object>}
   */;
  _proto.initializeIndex = function initializeIndex(indexSegments) {
    for (var i = 0; i < indexSegments.length; i++) {
      _addSegmentInfos(this._index, indexSegments[i]);
    }
    this._isInitialized = true;
  }
  /**
   * Returns `false` as a `BaseRepresentationIndex` should not be dynamic and as
   * such segments should never fall out-of-sync.
   * @returns {Boolean}
   */;
  _proto.canBeOutOfSyncError = function canBeOutOfSyncError() {
    return false;
  }
  /**
   * Returns `true` as SegmentBase are not dynamic and as such no new segment
   * should become available in the future.
   * @returns {Boolean}
   */;
  _proto.isStillAwaitingFutureSegments = function isStillAwaitingFutureSegments() {
    return false;
  }
  /**
   * No segment in a `BaseRepresentationIndex` are known initially.
   * It is only defined generally in an "index segment" that will thus need to
   * be first loaded and parsed.
   *
   * Once the index segment or equivalent has been parsed, the `initializeIndex`
   * method have to be called with the corresponding segment information so the
   * `BaseRepresentationIndex` can be considered as "initialized" (and so this
   * method can return `true`).
   * Until then this method will return `false` and segments linked to that
   * Representation may be missing.
   * @returns {Boolean}
   */;
  _proto.isInitialized = function isInitialized() {
    return this._isInitialized;
  }
  /**
   * Replace in-place this `BaseRepresentationIndex` information by the
   * information from another one.
   * @param {Object} newIndex
   */;
  _proto._replace = function _replace(newIndex) {
    this._index = newIndex._index;
    this._isInitialized = newIndex._isInitialized;
    this._scaledPeriodEnd = newIndex._scaledPeriodEnd;
    this._isEMSGWhitelisted = newIndex._isEMSGWhitelisted;
  };
  _proto._update = function _update() {
    _log__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A.error("Base RepresentationIndex: Cannot update a SegmentList");
  };
  return BaseRepresentationIndex;
}();


/***/ }),

/***/ 1160:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: function() { return /* binding */ getInitSegment; }
/* harmony export */ });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Construct init segment for the given index.
 * @param {Object} index
 * @param {function} isEMSGWhitelisted
 * @returns {Object}
 */
function getInitSegment(index, isEMSGWhitelisted) {
  var _a;
  var initialization = index.initialization;
  var privateInfos = {};
  if (isEMSGWhitelisted !== undefined) {
    privateInfos.isEMSGWhitelisted = isEMSGWhitelisted;
  }
  return {
    id: "init",
    isInit: true,
    time: 0,
    end: 0,
    duration: 0,
    timescale: 1,
    range: initialization != null ? initialization.range : undefined,
    indexRange: index.indexRange,
    url: (_a = initialization === null || initialization === void 0 ? void 0 : initialization.url) !== null && _a !== void 0 ? _a : null,
    complete: true,
    privateInfos: privateInfos,
    timestampOffset: -(index.indexTimeOffset / index.timescale)
  };
}

/***/ }),

/***/ 5403:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: function() { return /* binding */ getSegmentsFromTimeline; }
/* harmony export */ });
/* harmony import */ var _utils_index_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3877);
/* harmony import */ var _tokens__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9955);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * For the given start time and duration of a timeline element, calculate how
 * much this element should be repeated to contain the time given.
 * 0 being the same element, 1 being the next one etc.
 * @param {Number} segmentStartTime
 * @param {Number} segmentDuration
 * @param {Number} wantedTime
 * @returns {Number}
 */
function getWantedRepeatIndex(segmentStartTime, segmentDuration, wantedTime) {
  var diff = wantedTime - segmentStartTime;
  return diff > 0 ? Math.floor(diff / segmentDuration) : 0;
}
/**
 * Get a list of Segments for the time range wanted.
 * @param {Object} index - index object, constructed by parsing the manifest.
 * @param {number} from - starting timestamp wanted, in seconds
 * @param {number} durationWanted - duration wanted, in seconds
 * @param {Object} manifestBoundsCalculator
 * @param {number|undefined} scaledPeriodEnd
 * @param {function} isEMSGWhitelisted
 * @returns {Array.<Object>}
 */
function getSegmentsFromTimeline(index, from, durationWanted, manifestBoundsCalculator, scaledPeriodEnd, isEMSGWhitelisted) {
  var _a;
  var maximumTime = manifestBoundsCalculator.getEstimatedMaximumPosition((_a = index.availabilityTimeOffset) !== null && _a !== void 0 ? _a : 0);
  var wantedMaximum = Math.min(from + durationWanted, maximumTime !== null && maximumTime !== void 0 ? maximumTime : Infinity);
  var scaledUp = (0,_utils_index_helpers__WEBPACK_IMPORTED_MODULE_0__/* .toIndexTime */ .vb)(from, index);
  var scaledTo = (0,_utils_index_helpers__WEBPACK_IMPORTED_MODULE_0__/* .toIndexTime */ .vb)(wantedMaximum, index);
  var timeline = index.timeline,
    timescale = index.timescale,
    segmentUrlTemplate = index.segmentUrlTemplate,
    startNumber = index.startNumber,
    endNumber = index.endNumber;
  var currentNumber = startNumber !== null && startNumber !== void 0 ? startNumber : 1;
  var segments = [];
  var timelineLength = timeline.length;
  for (var i = 0; i < timelineLength; i++) {
    var timelineItem = timeline[i];
    var duration = timelineItem.duration,
      start = timelineItem.start,
      range = timelineItem.range;
    var maxRepeatTime = void 0;
    if (maximumTime === undefined) {
      maxRepeatTime = scaledPeriodEnd;
    } else {
      maxRepeatTime = Math.min(maximumTime * timescale, scaledPeriodEnd !== null && scaledPeriodEnd !== void 0 ? scaledPeriodEnd : Infinity);
    }
    var repeat = (0,_utils_index_helpers__WEBPACK_IMPORTED_MODULE_0__/* .calculateRepeat */ .yi)(timelineItem, timeline[i + 1], maxRepeatTime);
    var complete = index.availabilityTimeComplete !== false || i !== timelineLength - 1 && repeat !== 0;
    var segmentNumberInCurrentRange = getWantedRepeatIndex(start, duration, scaledUp);
    var segmentTime = start + segmentNumberInCurrentRange * duration;
    while (segmentTime < scaledTo && segmentNumberInCurrentRange <= repeat) {
      var segmentNumber = currentNumber + segmentNumberInCurrentRange;
      if (endNumber !== undefined && segmentNumber > endNumber) {
        break;
      }
      var detokenizedURL = segmentUrlTemplate === null ? null : (0,_tokens__WEBPACK_IMPORTED_MODULE_1__/* .createDashUrlDetokenizer */ .Qy)(segmentTime, segmentNumber)(segmentUrlTemplate);
      var time = segmentTime - index.indexTimeOffset;
      var realDuration = duration;
      if (time < 0) {
        realDuration = duration + time; // Remove from duration the part before `0`
        time = 0;
      }
      var segment = {
        id: String(segmentTime),
        time: time / timescale,
        end: (time + realDuration) / timescale,
        duration: realDuration / timescale,
        isInit: false,
        range: range,
        timescale: 1,
        url: detokenizedURL,
        number: segmentNumber,
        timestampOffset: -(index.indexTimeOffset / timescale),
        complete: complete,
        privateInfos: {
          isEMSGWhitelisted: isEMSGWhitelisted
        }
      };
      segments.push(segment);
      // update segment number and segment time for the next segment
      segmentNumberInCurrentRange++;
      segmentTime = start + segmentNumberInCurrentRange * duration;
    }
    if (segmentTime >= scaledTo) {
      // we reached ``scaledTo``, we're done
      return segments;
    }
    currentNumber += repeat + 1;
    if (endNumber !== undefined && currentNumber > endNumber) {
      return segments;
    }
  }
  return segments;
}

/***/ }),

/***/ 9955:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   I1: function() { return /* binding */ constructRepresentationUrl; },
/* harmony export */   Qy: function() { return /* binding */ createDashUrlDetokenizer; }
/* harmony export */ });
/* unused harmony export replaceRepresentationDASHTokens */
/* harmony import */ var _utils_is_non_empty_string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2384);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Pad with 0 in the left of the given n argument to reach l length
 * @param {Number|string} n
 * @param {Number} l
 * @returns {string}
 */
function padLeftWithZeros(n, l) {
  var nToString = n.toString();
  if (nToString.length >= l) {
    return nToString;
  }
  var arr = new Array(l + 1).join("0") + nToString;
  return arr.slice(-l);
}
/**
 * @param {string|number} replacer
 * @returns {Function}
 */
function processFormatedToken(replacer) {
  return function (_match, _format, widthStr) {
    var width = (0,_utils_is_non_empty_string__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(widthStr) ? parseInt(widthStr, 10) : 1;
    return padLeftWithZeros(String(replacer), width);
  };
}
/**
 * @param {string} urlTemplate
 * @param {string|undefined} representationId
 * @param {number|undefined} bitrate
 * @returns {string}
 */
function constructRepresentationUrl(urlTemplate, representationId, bitrate) {
  return replaceRepresentationDASHTokens(urlTemplate, representationId, bitrate);
}
/**
 * Replace "tokens" written in a given path (e.g. $RepresentationID$) by the corresponding
 * infos, taken from the given segment.
 * @param {string} path
 * @param {string|undefined} id
 * @param {number|undefined} bitrate
 * @returns {string}
 */
function replaceRepresentationDASHTokens(path, id, bitrate) {
  if (path.indexOf("$") === -1) {
    return path;
  } else {
    return path.replace(/\$\$/g, "$").replace(/\$RepresentationID\$/g, String(id)).replace(/\$Bandwidth(\%0(\d+)d)?\$/g, processFormatedToken(bitrate === undefined ? 0 : bitrate));
  }
}
/**
 * Create function allowing to replace "tokens" in a given DASH segment URL
 * (e.g. $Time$, which has to be replaced by the segment's start time) by the
 * right information.
 * @param {number|undefined} time
 * @param {number|undefined} nb
 * @returns {Function}
 */
function createDashUrlDetokenizer(time, nb) {
  /**
   * Replace the tokens in the given `url` by the segment information defined
   * by the outer function.
   * @param {string} url
   * @returns {string}
   *
   * @throws Error - Throws if we do not have enough data to construct the URL
   */
  return function replaceTokensInUrl(url) {
    if (url.indexOf("$") === -1) {
      return url;
    } else {
      return url.replace(/\$\$/g, "$").replace(/\$Number(\%0(\d+)d)?\$/g, function (_x, _y, widthStr) {
        if (nb === undefined) {
          throw new Error("Segment number not defined in a $Number$ scheme");
        }
        return processFormatedToken(nb)(_x, _y, widthStr);
      }).replace(/\$Time(\%0(\d+)d)?\$/g, function (_x, _y, widthStr) {
        if (time === undefined) {
          throw new Error("Segment time not defined in a $Time$ scheme");
        }
        return processFormatedToken(time)(_x, _y, widthStr);
      });
    }
  };
}

/***/ }),

/***/ 95:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: function() { return /* binding */ js_parser; }
});

// EXTERNAL MODULE: ./src/utils/assert_unreachable.ts + 1 modules
var assert_unreachable = __webpack_require__(2038);
// EXTERNAL MODULE: ./src/utils/is_null_or_undefined.ts
var is_null_or_undefined = __webpack_require__(6787);
// EXTERNAL MODULE: ./src/config.ts + 2 modules
var config = __webpack_require__(5151);
// EXTERNAL MODULE: ./src/log.ts + 1 modules
var log = __webpack_require__(9477);
// EXTERNAL MODULE: ./src/utils/array_find.ts
var array_find = __webpack_require__(1729);
// EXTERNAL MODULE: ./src/utils/resolve_url.ts
var resolve_url = __webpack_require__(2716);
;// CONCATENATED MODULE: ./src/parsers/manifest/dash/common/get_clock_offset.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Get difference between the server's clock, in milliseconds and the return of
 * the JS function `performance.now`.
 * This property allows to calculate the server time at any moment.
 *
 * `undefined` if we could not define such offset (in which case, you could have
 * to rely on the user's clock instead).
 *
 * For example, a response of 1000 would mean that performance.now() is 1 second
 * behind the server's time.
 * @param {string} serverClock
 * @returns {number|undefined}
 */
function getClockOffset(serverClock) {
  var httpOffset = Date.parse(serverClock) - performance.now();
  if (isNaN(httpOffset)) {
    log/* default */.A.warn("DASH Parser: Invalid clock received: ", serverClock);
    return undefined;
  }
  return httpOffset;
}
;// CONCATENATED MODULE: ./src/parsers/manifest/dash/common/get_http_utc-timing_url.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @param {Object} mpdIR
 * @returns {string|undefined}
 */
function getHTTPUTCTimingURL(mpdIR) {
  var UTCTimingHTTP = mpdIR.children.utcTimings.filter(function (utcTiming) {
    return (utcTiming.schemeIdUri === "urn:mpeg:dash:utc:http-iso:2014" || utcTiming.schemeIdUri === "urn:mpeg:dash:utc:http-xsdate:2014") && utcTiming.value !== undefined;
  });
  return UTCTimingHTTP.length > 0 ? UTCTimingHTTP[0].value : undefined;
}
;// CONCATENATED MODULE: ./src/parsers/manifest/utils/get_last_time_from_adaptation.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Returns "last time of reference" from the adaptation given, considering a
 * dynamic content.
 * Undefined if a time could not be found.
 * Null if the Adaptation has no segments (it could be that it didn't started or
 * that it already finished for example).
 *
 * We consider the earliest last time from every representations in the given
 * adaptation.
 * @param {Object} adaptation
 * @returns {Number|undefined|null}
 */
function getLastPositionFromAdaptation(adaptation) {
  var representations = adaptation.representations;
  var min = null;
  for (var i = 0; i < representations.length; i++) {
    var lastPosition = representations[i].index.getLastAvailablePosition();
    if (lastPosition === undefined) {
      // we cannot tell
      return undefined;
    }
    if (lastPosition !== null) {
      min = min == null ? lastPosition : Math.min(min, lastPosition);
    }
  }
  if (min === null) {
    // It means that all positions were null === no segments (yet?)
    return null;
  }
  return min;
}
;// CONCATENATED MODULE: ./src/parsers/manifest/utils/get_maximum_positions.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @param {Object} manifest
 * @returns {number | undefined}
 */
function getMaximumPosition(periods) {
  for (var i = periods.length - 1; i >= 0; i--) {
    var periodAdaptations = periods[i].adaptations;
    var firstAudioAdaptationFromPeriod = periodAdaptations.audio === undefined ? undefined : periodAdaptations.audio[0];
    var firstVideoAdaptationFromPeriod = periodAdaptations.video === undefined ? undefined : periodAdaptations.video[0];
    if (firstAudioAdaptationFromPeriod !== undefined || firstVideoAdaptationFromPeriod !== undefined) {
      // null == no segment
      var maximumAudioPosition = null;
      var maximumVideoPosition = null;
      if (firstAudioAdaptationFromPeriod !== undefined) {
        var lastPosition = getLastPositionFromAdaptation(firstAudioAdaptationFromPeriod);
        if (lastPosition === undefined) {
          return {
            safe: undefined,
            unsafe: undefined
          };
        }
        maximumAudioPosition = lastPosition;
      }
      if (firstVideoAdaptationFromPeriod !== undefined) {
        var _lastPosition = getLastPositionFromAdaptation(firstVideoAdaptationFromPeriod);
        if (_lastPosition === undefined) {
          return {
            safe: undefined,
            unsafe: undefined
          };
        }
        maximumVideoPosition = _lastPosition;
      }
      if (firstAudioAdaptationFromPeriod !== undefined && maximumAudioPosition === null || firstVideoAdaptationFromPeriod !== undefined && maximumVideoPosition === null) {
        log/* default */.A.info("Parser utils: found Period with no segment. ", "Going to previous one to calculate last position");
        return {
          safe: undefined,
          unsafe: undefined
        };
      }
      if (maximumVideoPosition !== null) {
        if (maximumAudioPosition !== null) {
          return {
            safe: Math.min(maximumAudioPosition, maximumVideoPosition),
            unsafe: Math.max(maximumAudioPosition, maximumVideoPosition)
          };
        }
        return {
          safe: maximumVideoPosition,
          unsafe: maximumVideoPosition
        };
      }
      if (maximumAudioPosition !== null) {
        return {
          safe: maximumAudioPosition,
          unsafe: maximumAudioPosition
        };
      }
    }
  }
  return {
    safe: undefined,
    unsafe: undefined
  };
}
;// CONCATENATED MODULE: ./src/parsers/manifest/utils/get_first_time_from_adaptation.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Returns "first time of reference" from the adaptation given, considering a
 * dynamic content.
 * Undefined if a time could not be found.
 *
 * We consider the latest first time from every representations in the given
 * adaptation.
 * @param {Object} adaptation
 * @returns {Number|undefined}
 */
function getFirstPositionFromAdaptation(adaptation) {
  var representations = adaptation.representations;
  var max = null;
  for (var i = 0; i < representations.length; i++) {
    var firstPosition = representations[i].index.getFirstAvailablePosition();
    if (firstPosition === undefined) {
      // we cannot tell
      return undefined;
    }
    if (firstPosition !== null) {
      max = max == null ? firstPosition : Math.max(max, firstPosition);
    }
  }
  if (max === null) {
    // It means that all positions were null === no segments (yet?)
    return null;
  }
  return max;
}
;// CONCATENATED MODULE: ./src/parsers/manifest/utils/get_minimum_position.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @param {Object} manifest
 * @returns {number | undefined}
 */
function getMinimumPosition(periods) {
  for (var i = 0; i <= periods.length - 1; i++) {
    var periodAdaptations = periods[i].adaptations;
    var firstAudioAdaptationFromPeriod = periodAdaptations.audio === undefined ? undefined : periodAdaptations.audio[0];
    var firstVideoAdaptationFromPeriod = periodAdaptations.video === undefined ? undefined : periodAdaptations.video[0];
    if (firstAudioAdaptationFromPeriod !== undefined || firstVideoAdaptationFromPeriod !== undefined) {
      // null == no segment
      var minimumAudioPosition = null;
      var minimumVideoPosition = null;
      if (firstAudioAdaptationFromPeriod !== undefined) {
        var firstPosition = getFirstPositionFromAdaptation(firstAudioAdaptationFromPeriod);
        if (firstPosition === undefined) {
          return undefined;
        }
        minimumAudioPosition = firstPosition;
      }
      if (firstVideoAdaptationFromPeriod !== undefined) {
        var _firstPosition = getFirstPositionFromAdaptation(firstVideoAdaptationFromPeriod);
        if (_firstPosition === undefined) {
          return undefined;
        }
        minimumVideoPosition = _firstPosition;
      }
      if (firstAudioAdaptationFromPeriod !== undefined && minimumAudioPosition === null || firstVideoAdaptationFromPeriod !== undefined && minimumVideoPosition === null) {
        log/* default */.A.info("Parser utils: found Period with no segment. ", "Going to next one to calculate first position");
        return undefined;
      }
      if (minimumVideoPosition !== null) {
        if (minimumAudioPosition !== null) {
          return Math.max(minimumAudioPosition, minimumVideoPosition);
        }
        return minimumVideoPosition;
      }
      if (minimumAudioPosition !== null) {
        return minimumAudioPosition;
      }
    }
  }
}
;// CONCATENATED MODULE: ./src/parsers/manifest/dash/common/get_minimum_and_maximum_positions.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @param {Object} periods
 * @returns {Array.<number>}
 */
function getMinimumAndMaximumPositions(periods) {
  if (periods.length === 0) {
    throw new Error("DASH Parser: no period available for a dynamic content");
  }
  var minimumSafePosition = getMinimumPosition(periods);
  var maxPositions = getMaximumPosition(periods);
  return {
    minimumSafePosition: minimumSafePosition,
    maximumSafePosition: maxPositions.safe,
    maximumUnsafePosition: maxPositions.unsafe
  };
}
;// CONCATENATED MODULE: ./src/parsers/manifest/dash/common/manifest_bounds_calculator.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * This class allows to easily calculate the first and last available positions
 * in a content at any time.
 *
 * By centralizing the manifest bounds calculation in this class and by giving
 * an instance of it to each parsed elements which might depend on it, we
 * ensure that we can provide it once it is known to every one of those
 * elements without needing to parse a second time the MPD.
 * @class ManifestBoundsCalculator
 */
var ManifestBoundsCalculator = /*#__PURE__*/function () {
  /**
   * @param {Object} args
   */
  function ManifestBoundsCalculator(args) {
    this._isDynamic = args.isDynamic;
    this._timeShiftBufferDepth = !args.isDynamic || args.timeShiftBufferDepth === undefined ? null : args.timeShiftBufferDepth;
    this._serverTimestampOffset = args.serverTimestampOffset;
    this._availabilityStartTime = args.availabilityStartTime;
  }
  /**
   * Set the last position and the position time (the value of `performance.now()`
   * at the time that position was true converted into seconds).
   *
   * @example
   * Example if you trust `Date.now()` to give you a reliable offset:
   * ```js
   * const lastPosition = Date.now();
   * const positionTime = performance.now() / 1000;
   * manifestBoundsCalculator.setLastPosition(lastPosition, positionTime);
   * ```
   *
   * @param {number} lastPosition
   * @param {number|undefined} positionTime
   */
  var _proto = ManifestBoundsCalculator.prototype;
  _proto.setLastPosition = function setLastPosition(lastPosition, positionTime) {
    this._lastPosition = lastPosition;
    this._positionTime = positionTime;
  }
  /**
   * Returns `true` if the last position and the position time
   * (for dynamic content only) have been comunicated.
   * `false` otherwise.
   * @returns {boolean}
   */;
  _proto.lastPositionIsKnown = function lastPositionIsKnown() {
    if (this._isDynamic) {
      return this._positionTime != null && this._lastPosition != null;
    }
    return this._lastPosition != null;
  }
  /**
   * Estimate a minimum bound for the content from the last set segment time
   * and buffer depth.
   * Consider that it is only an estimate, not the real value.
   * @param {number} segmentDuration - In DASH, the buffer depth actually also
   * depend on a corresponding's segment duration (e.g. a segment become
   * unavailable once the `timeShiftBufferDepth` + its duration has elapsed).
   * This argument can thus be set the approximate duration of a segment.
   * @return {number|undefined}
   */;
  _proto.getEstimatedMinimumSegmentTime = function getEstimatedMinimumSegmentTime(segmentDuration) {
    var _a;
    if (!this._isDynamic || this._timeShiftBufferDepth === null) {
      return 0;
    }
    var maximumBound = (_a = this.getEstimatedLiveEdge()) !== null && _a !== void 0 ? _a : this.getEstimatedMaximumPosition(0);
    if (maximumBound === undefined) {
      return undefined;
    }
    var minimumBound = maximumBound - (this._timeShiftBufferDepth + segmentDuration);
    return minimumBound;
  }
  /**
   * Estimate the segment time in seconds that corresponds to what could be
   * considered the live edge (or `undefined` for non-live contents).
   *
   * Note that for some contents which just anounce segments in advance, this
   * value might be very different than the maximum position that is
   * requestable.
   * @return {number|undefined}
   */;
  _proto.getEstimatedLiveEdge = function getEstimatedLiveEdge() {
    if (!this._isDynamic || this._serverTimestampOffset === undefined) {
      return undefined;
    }
    return (performance.now() + this._serverTimestampOffset) / 1000 - this._availabilityStartTime;
  }
  /**
   * Produce a rough estimate of the ending time of the last requestable segment
   * in that content.
   *
   * This value is only an estimate and may be far from reality.
   *
   * The `availabilityTimeOffset` in argument is the corresponding
   * `availabilityTimeOffset` that applies to the current wanted segment, or `0`
   * if none exist. It will be applied on live content to deduce the maximum
   * segment time available.
   */;
  _proto.getEstimatedMaximumPosition = function getEstimatedMaximumPosition(availabilityTimeOffset) {
    if (!this._isDynamic) {
      return this._lastPosition;
    }
    var liveEdge = this.getEstimatedLiveEdge();
    if (liveEdge !== undefined && availabilityTimeOffset !== Infinity) {
      return liveEdge + availabilityTimeOffset;
    } else if (this._positionTime !== undefined && this._lastPosition !== undefined) {
      return Math.max(this._lastPosition - this._positionTime + performance.now() / 1000, 0);
    }
    return this._lastPosition;
  };
  return ManifestBoundsCalculator;
}();

;// CONCATENATED MODULE: ./src/parsers/manifest/dash/common/parse_availability_start_time.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Returns the base time of the Manifest.
 * @param {Object} rootAttributes
 * @param {number|undefined}
 */
function parseAvailabilityStartTime(rootAttributes, referenceDateTime) {
  if (rootAttributes.type !== "dynamic") {
    return 0;
  }
  if (rootAttributes.availabilityStartTime == null) {
    return referenceDateTime == null ? 0 : referenceDateTime;
  }
  return rootAttributes.availabilityStartTime;
}
// EXTERNAL MODULE: ./src/utils/flat_map.ts
var flat_map = __webpack_require__(3262);
// EXTERNAL MODULE: ./src/utils/id_generator.ts
var id_generator = __webpack_require__(8795);
// EXTERNAL MODULE: ./src/utils/object_values.ts
var object_values = __webpack_require__(4324);
// EXTERNAL MODULE: ./src/utils/string_parsing.ts
var string_parsing = __webpack_require__(4670);
;// CONCATENATED MODULE: ./src/parsers/manifest/dash/common/flatten_overlapping_periods.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Avoid periods to overlap.
 *
 * According to DASH guidelines, if a period has media duration longer than
 * the distance between the start of this period and the start of the next period,
 * use of start times implies that the client will start the playout of the next
 * period at the time stated, rather than finishing the playout of the last period.
 *
 * Even if that case if defined when period last(s) segment(s) is/are a bit longer,
 * it can be meaningful when two periods are overlapping. We will always shorten
 * the first period, and even erase it if its duration is equal to zero.
 *
 * Example (Periods are numbered under their manifest order) :
 *
 * [ Period 1 ][ Period 2 ]       ------>  [ Period 1 ][ Period 3 ]
 *             [ Period 3 ]
 *
 * [ Period 1 ][ Period 2 ]       ------>  [ Period 1 ][  2  ][ Period 3 ]
 *                  [ Period 3 ]
 *
 * [ Period 1 ][ Period 2 ]       ------>  [  1  ][      Period 3     ]
 *        [      Period 3     ]
 *
 * @param {Array.<Object>} parsedPeriods
 * @return {Array.<Object>}
 */
function flattenOverlappingPeriods(parsedPeriods) {
  if (parsedPeriods.length === 0) {
    return [];
  }
  var flattenedPeriods = [parsedPeriods[0]];
  for (var i = 1; i < parsedPeriods.length; i++) {
    var parsedPeriod = parsedPeriods[i];
    var lastFlattenedPeriod = flattenedPeriods[flattenedPeriods.length - 1];
    while (lastFlattenedPeriod.duration === undefined || lastFlattenedPeriod.start + lastFlattenedPeriod.duration > parsedPeriod.start) {
      log/* default */.A.warn("DASH: Updating overlapping Periods.", lastFlattenedPeriod === null || lastFlattenedPeriod === void 0 ? void 0 : lastFlattenedPeriod.start, parsedPeriod.start);
      lastFlattenedPeriod.duration = parsedPeriod.start - lastFlattenedPeriod.start;
      lastFlattenedPeriod.end = parsedPeriod.start;
      if (lastFlattenedPeriod.duration > 0) {
        // Note: Calling `break` to quit the while loop should theoritically be
        // unnecessary as the previous operations should ensure we do not re-enter
        // the loop's condition.
        // Yet we dit encounter infinite loops without it because of float-related
        // rounding errors.
        break;
      } else {
        // `lastFlattenedPeriod` has now a negative or `0` duration.
        // Remove it, consider the next Period in its place, and re-start the loop.
        flattenedPeriods.pop();
        if (flattenedPeriods.length === 0) {
          // There's no remaining Period to compare to `parsedPeriod`
          break;
        }
        // Take the previous Period as reference and compare it now to `parsedPeriod`
        lastFlattenedPeriod = flattenedPeriods[flattenedPeriods.length - 1];
      }
    }
    flattenedPeriods.push(parsedPeriod);
  }
  return flattenedPeriods;
}
;// CONCATENATED MODULE: ./src/parsers/manifest/dash/common/get_periods_time_infos.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Get periods time information from current, next and previous
 * periods.
 * @param {Array.<Object>} periodsIR
 * @param {Object} manifestInfos
 * @return {Array.<Object>}
 */
function getPeriodsTimeInformation(periodsIR, manifestInfos) {
  var periodsTimeInformation = [];
  periodsIR.forEach(function (currentPeriod, i) {
    var periodStart;
    if (currentPeriod.attributes.start != null) {
      periodStart = currentPeriod.attributes.start;
    } else {
      if (i === 0) {
        periodStart = !manifestInfos.isDynamic || manifestInfos.availabilityStartTime == null ? 0 : manifestInfos.availabilityStartTime;
      } else {
        // take time information from previous period
        var prevPeriodInfos = periodsTimeInformation[periodsTimeInformation.length - 1];
        if (prevPeriodInfos != null && prevPeriodInfos.periodEnd != null) {
          periodStart = prevPeriodInfos.periodEnd;
        } else {
          throw new Error("Missing start time when parsing periods.");
        }
      }
    }
    var periodDuration;
    var nextPeriod = periodsIR[i + 1];
    if (currentPeriod.attributes.duration != null) {
      periodDuration = currentPeriod.attributes.duration;
    } else if (i === periodsIR.length - 1) {
      periodDuration = manifestInfos.duration;
    } else if (nextPeriod.attributes.start != null) {
      periodDuration = nextPeriod.attributes.start - periodStart;
    }
    var periodEnd = periodDuration != null ? periodStart + periodDuration : undefined;
    periodsTimeInformation.push({
      periodStart: periodStart,
      periodDuration: periodDuration,
      periodEnd: periodEnd
    });
  });
  return periodsTimeInformation;
}
// EXTERNAL MODULE: ./src/manifest/adaptation.ts + 3 modules
var manifest_adaptation = __webpack_require__(4129);
// EXTERNAL MODULE: ./src/utils/array_find_index.ts
var array_find_index = __webpack_require__(3786);
// EXTERNAL MODULE: ./src/utils/array_includes.ts
var array_includes = __webpack_require__(4031);
// EXTERNAL MODULE: ./src/utils/is_non_empty_string.ts
var is_non_empty_string = __webpack_require__(2384);
;// CONCATENATED MODULE: ./src/parsers/manifest/dash/common/attach_trickmode_track.ts
function _createForOfIteratorHelperLoose(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (t) return (t = t.call(r)).next.bind(t); if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var o = 0; return function () { return o >= r.length ? { done: !0 } : { done: !1, value: r[o++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Attach trick mode tracks to adaptations by assigning to the trickModeTracks
 * property an array of trick mode track adaptations.
 * @param {Object} adaptations
 * @param {Array.<Object>} trickModeTracks
 * @returns {void}
 */
function attachTrickModeTrack(adaptations, trickModeTracks) {
  for (var _iterator = _createForOfIteratorHelperLoose(trickModeTracks), _step; !(_step = _iterator()).done;) {
    var track = _step.value;
    var adaptation = track.adaptation,
      trickModeAttachedAdaptationIds = track.trickModeAttachedAdaptationIds;
    for (var _iterator2 = _createForOfIteratorHelperLoose(trickModeAttachedAdaptationIds), _step2; !(_step2 = _iterator2()).done;) {
      var trickModeAttachedAdaptationId = _step2.value;
      for (var _iterator3 = _createForOfIteratorHelperLoose(manifest_adaptation/* SUPPORTED_ADAPTATIONS_TYPE */.B), _step3; !(_step3 = _iterator3()).done;) {
        var adaptationType = _step3.value;
        var adaptationsByType = adaptations[adaptationType];
        if (adaptationsByType !== undefined) {
          for (var _iterator4 = _createForOfIteratorHelperLoose(adaptationsByType), _step4; !(_step4 = _iterator4()).done;) {
            var adaptationByType = _step4.value;
            if (adaptationByType.id === trickModeAttachedAdaptationId) {
              if (adaptationByType.trickModeTracks === undefined) {
                adaptationByType.trickModeTracks = [];
              }
              adaptationByType.trickModeTracks.push(adaptation);
            }
          }
        }
      }
    }
  }
}
/* harmony default export */ var attach_trickmode_track = (attachTrickModeTrack);
;// CONCATENATED MODULE: ./src/parsers/manifest/dash/common/infer_adaptation_type.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/** Different `role`s a text Adaptation can be. */
var SUPPORTED_TEXT_TYPES = ["subtitle", "caption"];
/**
 * Infers the type of adaptation from codec and mimetypes found in it.
 *
 * This follows the guidelines defined by the DASH-IF IOP:
 *   - one adaptation set contains a single media type
 *   - The order of verifications are:
 *       1. mimeType
 *       2. Role
 *       3. codec
 *
 * Note: This is based on DASH-IF-IOP-v4.0 with some more freedom.
 * @param {Array.<Object>} representations
 * @param {string|null} adaptationMimeType
 * @param {string|null} adaptationCodecs
 * @param {Array.<Object>|null} adaptationRoles
 * @returns {string} - "audio"|"video"|"text"|"image"|"metadata"|"unknown"
 */
function inferAdaptationType(representations, adaptationMimeType, adaptationCodecs, adaptationRoles) {
  function fromMimeType(mimeType, roles) {
    var topLevel = mimeType.split("/")[0];
    if ((0,array_includes/* default */.A)(manifest_adaptation/* SUPPORTED_ADAPTATIONS_TYPE */.B, topLevel)) {
      return topLevel;
    }
    if (mimeType === "application/bif") {
      return "image";
    }
    if (mimeType === "application/ttml+xml") {
      return "text";
    }
    // manage DASH-IF mp4-embedded subtitles and metadata
    if (mimeType === "application/mp4") {
      if (roles != null) {
        if ((0,array_find/* default */.A)(roles, function (role) {
          return role.schemeIdUri === "urn:mpeg:dash:role:2011" && (0,array_includes/* default */.A)(SUPPORTED_TEXT_TYPES, role.value);
        }) != null) {
          return "text";
        }
      }
      return undefined;
    }
  }
  function fromCodecs(codecs) {
    switch (codecs.substring(0, 3)) {
      case "avc":
      case "hev":
      case "hvc":
      case "vp8":
      case "vp9":
      case "av1":
        return "video";
      case "vtt":
        return "text";
      case "bif":
        return "image";
    }
    switch (codecs.substring(0, 4)) {
      case "mp4a":
        return "audio";
      case "wvtt":
      case "stpp":
        return "text";
    }
  }
  if (adaptationMimeType !== null) {
    var typeFromMimeType = fromMimeType(adaptationMimeType, adaptationRoles);
    if (typeFromMimeType !== undefined) {
      return typeFromMimeType;
    }
  }
  if (adaptationCodecs !== null) {
    var typeFromCodecs = fromCodecs(adaptationCodecs);
    if (typeFromCodecs !== undefined) {
      return typeFromCodecs;
    }
  }
  for (var i = 0; i < representations.length; i++) {
    var representation = representations[i];
    var _representation$attri = representation.attributes,
      mimeType = _representation$attri.mimeType,
      codecs = _representation$attri.codecs;
    if (mimeType !== undefined) {
      var _typeFromMimeType = fromMimeType(mimeType, adaptationRoles);
      if (_typeFromMimeType !== undefined) {
        return _typeFromMimeType;
      }
    }
    if (codecs !== undefined) {
      var _typeFromCodecs = fromCodecs(codecs);
      if (_typeFromCodecs !== undefined) {
        return _typeFromCodecs;
      }
    }
  }
  return undefined;
}
// EXTERNAL MODULE: ./src/utils/object_assign.ts
var object_assign = __webpack_require__(8935);
;// CONCATENATED MODULE: ./src/parsers/manifest/dash/common/convert_supplemental_codecs.ts

var supplementalCodecSeparator = /[, ]+/g;
/**
 * Converts SCTE 214 supplemental codec string into RFC4281 codec string
 *
 * The returned value is a codec string respecting RFC6381
 *
 * SCTE 214 defines supplemental codecs as a whitespace-separated multiple list of
 * codec strings
 *
 * RFC6381 defines codecs as a comma-separated list of codec strings.
 *
 * This two syntax differs and this parser is used to convert SCTE214
 * to be compliant with what MSE APIs expect
 *
 * @param {string} val - The codec string to parse
 * @returns { Array.<string |undefined | null>}
 */
function convertSupplementalCodecsToRFC6381(val) {
  if ((0,is_non_empty_string/* default */.A)(val)) {
    return val.trim().replace(supplementalCodecSeparator, ", ");
  }
  return "";
}
;// CONCATENATED MODULE: ./src/parsers/manifest/dash/common/get_hdr_information.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Extract the webm HDR information out of the codec string.
 * The syntax of the codec string is defined in VP Codec ISO Media File Format
 * Binding, in the section Codecs Parameter String.
 * @param {string} codecString
 * @returns {Object | undefined}
 */
function getWEBMHDRInformation(codecString) {
  // cccc.PP.LL.DD.CC[.cp[.tc[.mc[.FF]]]]
  var _codecString$split = codecString.split("."),
    cccc = _codecString$split[0],
    _PP = _codecString$split[1],
    _LL = _codecString$split[2],
    DD = _codecString$split[3],
    _CC = _codecString$split[4],
    cp = _codecString$split[5],
    tc = _codecString$split[6],
    mc = _codecString$split[7];
  if (cccc !== "vp08" && cccc !== "vp09" && cccc !== "vp10") {
    return undefined;
  }
  var colorDepth;
  var eotf;
  var colorSpace;
  if (DD !== undefined && DD === "10" || DD === "12") {
    colorDepth = parseInt(DD, 10);
  }
  if (tc !== undefined) {
    if (tc === "16") {
      eotf = "pq";
    } else if (tc === "18") {
      eotf = "hlg";
    }
  }
  if (cp !== undefined && mc !== undefined && cp === "09" && mc === "09") {
    colorSpace = "rec2020";
  }
  if (colorDepth === undefined || eotf === undefined) {
    return undefined;
  }
  return {
    colorDepth: colorDepth,
    eotf: eotf,
    colorSpace: colorSpace
  };
}
// EXTERNAL MODULE: ./src/parsers/manifest/dash/common/indexes/base.ts
var base = __webpack_require__(9044);
// EXTERNAL MODULE: ./src/parsers/manifest/utils/index_helpers.ts
var index_helpers = __webpack_require__(3877);
// EXTERNAL MODULE: ./src/parsers/manifest/dash/common/indexes/get_init_segment.ts
var get_init_segment = __webpack_require__(1160);
// EXTERNAL MODULE: ./src/parsers/manifest/dash/common/indexes/tokens.ts
var tokens = __webpack_require__(9955);
;// CONCATENATED MODULE: ./src/parsers/manifest/dash/common/indexes/list.ts
/*
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




var ListRepresentationIndex = /*#__PURE__*/function () {
  /**
   * @param {Object} index
   * @param {Object} context
   */
  function ListRepresentationIndex(index, context) {
    var _a, _b;
    if (index.duration === undefined) {
      throw new Error("Invalid SegmentList: no duration");
    }
    var periodStart = context.periodStart,
      periodEnd = context.periodEnd,
      representationId = context.representationId,
      representationBitrate = context.representationBitrate,
      isEMSGWhitelisted = context.isEMSGWhitelisted;
    this._isEMSGWhitelisted = isEMSGWhitelisted;
    this._periodStart = periodStart;
    this._periodEnd = periodEnd;
    var presentationTimeOffset = index.presentationTimeOffset != null ? index.presentationTimeOffset : 0;
    var timescale = (_a = index.timescale) !== null && _a !== void 0 ? _a : 1;
    var indexTimeOffset = presentationTimeOffset - periodStart * timescale;
    var initializationUrl = ((_b = index.initialization) === null || _b === void 0 ? void 0 : _b.media) === undefined ? null : (0,tokens/* constructRepresentationUrl */.I1)(index.initialization.media, representationId, representationBitrate);
    var list = index.list.map(function (lItem) {
      return {
        url: lItem.media === undefined ? null : (0,tokens/* constructRepresentationUrl */.I1)(lItem.media, representationId, representationBitrate),
        mediaRange: lItem.mediaRange
      };
    });
    this._index = {
      list: list,
      timescale: timescale,
      duration: index.duration,
      indexTimeOffset: indexTimeOffset,
      indexRange: index.indexRange,
      initialization: index.initialization == null ? undefined : {
        url: initializationUrl,
        range: index.initialization.range
      }
    };
  }
  /**
   * Construct init Segment.
   * @returns {Object}
   */
  var _proto = ListRepresentationIndex.prototype;
  _proto.getInitSegment = function getInitSegment() {
    var initSegment = (0,get_init_segment/* default */.A)(this._index);
    if (initSegment.privateInfos === undefined) {
      initSegment.privateInfos = {};
    }
    initSegment.privateInfos.isEMSGWhitelisted = this._isEMSGWhitelisted;
    return initSegment;
  }
  /**
   * @param {Number} fromTime
   * @param {Number} dur
   * @returns {Array.<Object>}
   */;
  _proto.getSegments = function getSegments(fromTime, dur) {
    var index = this._index;
    var duration = index.duration,
      list = index.list,
      timescale = index.timescale;
    var durationInSeconds = duration / timescale;
    var fromTimeInPeriod = fromTime - this._periodStart;
    var _getTimescaledRange = (0,index_helpers/* getTimescaledRange */.jX)(fromTimeInPeriod, dur, timescale),
      up = _getTimescaledRange[0],
      to = _getTimescaledRange[1];
    var length = Math.min(list.length - 1, Math.floor(to / duration));
    var segments = [];
    var i = Math.floor(up / duration);
    while (i <= length) {
      var range = list[i].mediaRange;
      var url = list[i].url;
      var time = i * durationInSeconds + this._periodStart;
      var segment = {
        id: String(i),
        time: time,
        isInit: false,
        range: range,
        duration: durationInSeconds,
        timescale: 1,
        end: time + durationInSeconds,
        url: url,
        timestampOffset: -(index.indexTimeOffset / timescale),
        complete: true,
        privateInfos: {
          isEMSGWhitelisted: this._isEMSGWhitelisted
        }
      };
      segments.push(segment);
      i++;
    }
    return segments;
  }
  /**
   * Returns whether the Manifest should be refreshed based on the
   * `ListRepresentationIndex`'s state and the time range the player is
   * currently considering.
   * @param {Number} _fromTime
   * @param {Number} _toTime
   * @returns {Boolean}
   */;
  _proto.shouldRefresh = function shouldRefresh(_fromTime, _toTime) {
    // DASH Manifests are usually refreshed through other means, i.e. thanks to
    // the `minimumUpdatePeriod` attribute.
    // Moreover, SegmentList are usually only found in static MPDs.
    return false;
  }
  /**
   * Returns first position in this index, in seconds.
   * @returns {Number}
   */;
  _proto.getFirstAvailablePosition = function getFirstAvailablePosition() {
    return this._periodStart;
  }
  /**
   * Returns last position in this index, in seconds.
   * @returns {Number}
   */;
  _proto.getLastAvailablePosition = function getLastAvailablePosition() {
    var _a;
    var index = this._index;
    var duration = index.duration,
      list = index.list;
    return Math.min(list.length * duration / index.timescale + this._periodStart, (_a = this._periodEnd) !== null && _a !== void 0 ? _a : Infinity);
  }
  /**
   * Returns the absolute end in seconds this RepresentationIndex can reach once
   * all segments are available.
   * @returns {number|null|undefined}
   */;
  _proto.getEnd = function getEnd() {
    return this.getLastAvailablePosition();
  }
  /**
   * Returns:
   *   - `true` if in the given time interval, at least one new segment is
   *     expected to be available in the future.
   *   - `false` either if all segments in that time interval are already
   *     available for download or if none will ever be available for it.
   *   - `undefined` when it is not possible to tell.
   *
   * Always `false` in a `ListRepresentationIndex` because all segments should
   * be directly available.
   * @returns {boolean}
   */;
  _proto.awaitSegmentBetween = function awaitSegmentBetween() {
    return false;
  }
  /**
   * Returns true if a Segment returned by this index is still considered
   * available.
   * @returns {Boolean}
   */;
  _proto.isSegmentStillAvailable = function isSegmentStillAvailable() {
    return true;
  }
  /**
   * We do not check for discontinuity in SegmentList-based indexes.
   * @returns {null}
   */;
  _proto.checkDiscontinuity = function checkDiscontinuity() {
    return null;
  }
  /**
   * SegmentList should not be updated.
   * @returns {Boolean}
   */;
  _proto.canBeOutOfSyncError = function canBeOutOfSyncError() {
    return false;
  }
  /**
   * @returns {Boolean}
   */;
  _proto.isStillAwaitingFutureSegments = function isStillAwaitingFutureSegments() {
    return false;
  }
  /**
   * @returns {Boolean}
   */;
  _proto.isInitialized = function isInitialized() {
    return true;
  }
  /**
   * @param {Object} newIndex
   */;
  _proto._replace = function _replace(newIndex) {
    this._index = newIndex._index;
  };
  _proto._update = function _update() {
    log/* default */.A.error("List RepresentationIndex: Cannot update a SegmentList");
  };
  return ListRepresentationIndex;
}();

// EXTERNAL MODULE: ./src/errors/network_error.ts
var network_error = __webpack_require__(7941);
// EXTERNAL MODULE: ./src/utils/assert.ts
var assert = __webpack_require__(7994);
// EXTERNAL MODULE: ./src/parsers/manifest/utils/clear_timeline_from_position.ts
var clear_timeline_from_position = __webpack_require__(5019);
// EXTERNAL MODULE: ./src/parsers/manifest/utils/update_segment_timeline.ts
var update_segment_timeline = __webpack_require__(860);
// EXTERNAL MODULE: ./src/parsers/manifest/dash/common/indexes/get_segments_from_timeline.ts
var get_segments_from_timeline = __webpack_require__(5403);
;// CONCATENATED MODULE: ./src/parsers/manifest/dash/common/indexes/utils.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * In Javascript, numbers are encoded in a way that a floating number may be
 * represented internally with a rounding error.
 *
 * This function returns a small number allowing to accound for rounding many
 * rounding errors.
 * @param {number} timescale
 * @returns {boolean}
 */
function getSegmentTimeRoundingError(timescale) {
  return config/* default */.A.getCurrent().DEFAULT_MAXIMUM_TIME_ROUNDING_ERROR * timescale;
}
;// CONCATENATED MODULE: ./src/parsers/manifest/dash/common/indexes/timeline/convert_element_to_index_segment.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Translate parsed `S` node into Segment compatible with this index:
 * Find out the start, repeatCount and duration of each of these.
 *
 * @param {Object} item - parsed `S` node
 * @param {Object|null} previousItem - the previously parsed Segment (related
 * to the `S` node coming just before). If `null`, we're talking about the first
 * segment.
 * @param {Object|null} nextItem - the `S` node coming next. If `null`, we're
 * talking about the last segment.
 * @returns {Object|null}
 */
function convertElementsToIndexSegment(item, previousItem, nextItem) {
  var start = item.start;
  var duration = item.duration;
  var repeatCount = item.repeatCount;
  if (start === undefined) {
    if (previousItem === null) {
      start = 0;
    } else if (!(0,is_null_or_undefined/* default */.A)(previousItem.duration)) {
      start = previousItem.start + previousItem.duration * (previousItem.repeatCount + 1);
    }
  }
  if ((duration === undefined || isNaN(duration)) && nextItem !== null && nextItem.start !== undefined && !isNaN(nextItem.start) && start !== undefined && !isNaN(start)) {
    duration = nextItem.start - start;
  }
  if (start !== undefined && !isNaN(start) && duration !== undefined && !isNaN(duration) && (repeatCount === undefined || !isNaN(repeatCount))) {
    return {
      start: start,
      duration: duration,
      repeatCount: repeatCount === undefined ? 0 : repeatCount
    };
  }
  log/* default */.A.warn('DASH: A "S" Element could not have been parsed.');
  return null;
}
;// CONCATENATED MODULE: ./src/parsers/manifest/dash/common/indexes/timeline/parse_s_element.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Parse a given <S> element in the MPD into a JS Object.
 * @param {Element} root
 * @returns {Object}
 */
function parseSElement(root) {
  var parsedS = {};
  for (var j = 0; j < root.attributes.length; j++) {
    var attribute = root.attributes[j];
    switch (attribute.name) {
      case "t":
        var start = parseInt(attribute.value, 10);
        if (isNaN(start)) {
          log/* default */.A.warn("DASH: invalid t (\"" + attribute.value + "\")");
        } else {
          parsedS.start = start;
        }
        break;
      case "d":
        var duration = parseInt(attribute.value, 10);
        if (isNaN(duration)) {
          log/* default */.A.warn("DASH: invalid d (\"" + attribute.value + "\")");
        } else {
          parsedS.duration = duration;
        }
        break;
      case "r":
        var repeatCount = parseInt(attribute.value, 10);
        if (isNaN(repeatCount)) {
          log/* default */.A.warn("DASH: invalid r (\"" + attribute.value + "\")");
        } else {
          parsedS.repeatCount = repeatCount;
        }
        break;
    }
  }
  return parsedS;
}
;// CONCATENATED MODULE: ./src/parsers/manifest/dash/common/indexes/timeline/construct_timeline_from_elements.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Allows to generate the "timeline" for the "Timeline" RepresentationIndex.
 * Call this function when the timeline is unknown.
 * This function was added to only perform that task lazily, i.e. only when
 * first needed.
 * @param {HTMLCollection} elements - All S nodes constituting the corresponding
 * SegmentTimeline node.
 * @returns {Array.<Object>}
 */
function constructTimelineFromElements(elements) {
  var initialTimeline = [];
  for (var i = 0; i < elements.length; i++) {
    initialTimeline.push(parseSElement(elements[i]));
  }
  var timeline = [];
  for (var _i = 0; _i < initialTimeline.length; _i++) {
    var item = initialTimeline[_i];
    var previousItem = timeline[timeline.length - 1] === undefined ? null : timeline[timeline.length - 1];
    var nextItem = initialTimeline[_i + 1] === undefined ? null : initialTimeline[_i + 1];
    var timelineElement = convertElementsToIndexSegment(item, previousItem, nextItem);
    if (timelineElement !== null) {
      timeline.push(timelineElement);
    }
  }
  return timeline;
}
;// CONCATENATED MODULE: ./src/parsers/manifest/dash/common/indexes/timeline/find_first_common_start_time.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * By comparing two timelines for the same content at different points in time,
 * retrieve the index in both timelines of the first segment having the same
 * starting time.
 * Returns `null` if not found.
 * @param {Array.<Object>} prevTimeline
 * @param {HTMLCollection} newElements
 * @returns {Object|null}
 */
function findFirstCommonStartTime(prevTimeline, newElements) {
  if (prevTimeline.length === 0 || newElements.length === 0) {
    return null;
  }
  var prevInitialStart = prevTimeline[0].start;
  var newFirstTAttr = newElements[0].getAttribute("t");
  var newInitialStart = newFirstTAttr === null ? null : parseInt(newFirstTAttr, 10);
  if (newInitialStart === null || Number.isNaN(newInitialStart)) {
    return null;
  }
  if (prevInitialStart === newInitialStart) {
    return {
      prevSegmentsIdx: 0,
      newElementsIdx: 0,
      repeatNumberInPrevSegments: 0,
      repeatNumberInNewElements: 0
    };
  } else if (prevInitialStart < newInitialStart) {
    var prevElt = prevTimeline[0];
    var prevElementIndex = 0;
    while (true) {
      if (prevElt.repeatCount > 0) {
        var diff = newInitialStart - prevElt.start;
        if (diff % prevElt.duration === 0 && diff / prevElt.duration <= prevElt.repeatCount) {
          var repeatNumberInPrevSegments = diff / prevElt.duration;
          return {
            repeatNumberInPrevSegments: repeatNumberInPrevSegments,
            prevSegmentsIdx: prevElementIndex,
            newElementsIdx: 0,
            repeatNumberInNewElements: 0
          };
        }
      }
      prevElementIndex++;
      if (prevElementIndex >= prevTimeline.length) {
        return null;
      }
      prevElt = prevTimeline[prevElementIndex];
      if (prevElt.start === newInitialStart) {
        return {
          prevSegmentsIdx: prevElementIndex,
          newElementsIdx: 0,
          repeatNumberInPrevSegments: 0,
          repeatNumberInNewElements: 0
        };
      } else if (prevElt.start > newInitialStart) {
        return null;
      }
    }
  } else {
    var newElementsIdx = 0;
    var newElt = newElements[0];
    var currentTimeOffset = newInitialStart;
    while (true) {
      var dAttr = newElt.getAttribute("d");
      var duration = dAttr === null ? null : parseInt(dAttr, 10);
      if (duration === null || Number.isNaN(duration)) {
        return null;
      }
      var rAttr = newElt.getAttribute("r");
      var repeatCount = rAttr === null ? null : parseInt(rAttr, 10);
      if (repeatCount !== null) {
        if (Number.isNaN(repeatCount) || repeatCount < 0) {
          return null;
        }
        if (repeatCount > 0) {
          var _diff = prevInitialStart - currentTimeOffset;
          if (_diff % duration === 0 && _diff / duration <= repeatCount) {
            var repeatNumberInNewElements = _diff / duration;
            return {
              repeatNumberInPrevSegments: 0,
              repeatNumberInNewElements: repeatNumberInNewElements,
              prevSegmentsIdx: 0,
              newElementsIdx: newElementsIdx
            };
          }
        }
        currentTimeOffset += duration * (repeatCount + 1);
      } else {
        currentTimeOffset += duration;
      }
      newElementsIdx++;
      if (newElementsIdx >= newElements.length) {
        return null;
      }
      newElt = newElements[newElementsIdx];
      var tAttr = newElt.getAttribute("t");
      var time = tAttr === null ? null : parseInt(tAttr, 10);
      if (time !== null) {
        if (Number.isNaN(time)) {
          return null;
        }
        currentTimeOffset = time;
      }
      if (currentTimeOffset === prevInitialStart) {
        return {
          newElementsIdx: newElementsIdx,
          prevSegmentsIdx: 0,
          repeatNumberInPrevSegments: 0,
          repeatNumberInNewElements: 0
        };
      } else if (currentTimeOffset > newInitialStart) {
        return null;
      }
    }
  }
}
;// CONCATENATED MODULE: ./src/parsers/manifest/dash/common/indexes/timeline/construct_timeline_from_previous_timeline.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





function constructTimelineFromPreviousTimeline(newElements, prevTimeline) {
  var _a;
  // Find first index in both timeline where a common segment is found.
  var commonStartInfo = findFirstCommonStartTime(prevTimeline, newElements);
  if (commonStartInfo === null) {
    log/* default */.A.warn('DASH: Cannot perform "based" update. Common segment not found.');
    return constructTimelineFromElements(newElements);
  }
  var prevSegmentsIdx = commonStartInfo.prevSegmentsIdx,
    newElementsIdx = commonStartInfo.newElementsIdx,
    repeatNumberInPrevSegments = commonStartInfo.repeatNumberInPrevSegments,
    repeatNumberInNewElements = commonStartInfo.repeatNumberInNewElements;
  /** Guess of the number of elements in common. */
  var numberCommonEltGuess = prevTimeline.length - prevSegmentsIdx;
  var lastCommonEltNewEltsIdx = numberCommonEltGuess + newElementsIdx - 1;
  if (lastCommonEltNewEltsIdx >= newElements.length) {
    log/* default */.A.info('DASH: Cannot perform "based" update. New timeline too short');
    return constructTimelineFromElements(newElements);
  }
  // Remove elements which are not available anymore
  var newTimeline = prevTimeline.slice(prevSegmentsIdx);
  if (repeatNumberInPrevSegments > 0) {
    var commonEltInOldTimeline = newTimeline[0];
    commonEltInOldTimeline.start += commonEltInOldTimeline.duration * repeatNumberInPrevSegments;
    newTimeline[0].repeatCount -= repeatNumberInPrevSegments;
  }
  if (repeatNumberInNewElements > 0 && newElementsIdx !== 0) {
    log/* default */.A.info('DASH: Cannot perform "based" update. ' + "The new timeline has a different form.");
    return constructTimelineFromElements(newElements);
  }
  var prevLastElement = newTimeline[newTimeline.length - 1];
  var newCommonElt = parseSElement(newElements[lastCommonEltNewEltsIdx]);
  var newRepeatCountOffseted = ((_a = newCommonElt.repeatCount) !== null && _a !== void 0 ? _a : 0) - repeatNumberInNewElements;
  if (newCommonElt.duration !== prevLastElement.duration || prevLastElement.repeatCount > newRepeatCountOffseted) {
    log/* default */.A.info('DASH: Cannot perform "based" update. ' + "The new timeline has a different form at the beginning.");
    return constructTimelineFromElements(newElements);
  }
  if (newCommonElt.repeatCount !== undefined && newCommonElt.repeatCount > prevLastElement.repeatCount) {
    prevLastElement.repeatCount = newCommonElt.repeatCount;
  }
  var newEltsToPush = [];
  var items = [];
  for (var i = lastCommonEltNewEltsIdx + 1; i < newElements.length; i++) {
    items.push(parseSElement(newElements[i]));
  }
  for (var _i = 0; _i < items.length; _i++) {
    var item = items[_i];
    var previousItem = newEltsToPush[newEltsToPush.length - 1] === undefined ? prevLastElement : newEltsToPush[newEltsToPush.length - 1];
    var nextItem = items[_i + 1] === undefined ? null : items[_i + 1];
    var timelineElement = convertElementsToIndexSegment(item, previousItem, nextItem);
    if (timelineElement !== null) {
      newEltsToPush.push(timelineElement);
    }
  }
  return newTimeline.concat(newEltsToPush);
}
;// CONCATENATED MODULE: ./src/parsers/manifest/dash/common/indexes/timeline/timeline_representation_index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */













// eslint-disable-next-line max-len

/**
 * `IRepresentationIndex` implementation for a DASH `SegmentTimeline` segment
 * indexing scheme.
 * @class TimelineRepresentationIndex
 */
var TimelineRepresentationIndex = /*#__PURE__*/function () {
  /**
   * @param {Object} index
   * @param {Object} context
   */
  function TimelineRepresentationIndex(index, context) {
    var _a, _b, _c;
    if (!TimelineRepresentationIndex.isTimelineIndexArgument(index)) {
      throw new Error("The given index is not compatible with a " + "TimelineRepresentationIndex.");
    }
    var availabilityTimeComplete = context.availabilityTimeComplete,
      availabilityTimeOffset = context.availabilityTimeOffset,
      manifestBoundsCalculator = context.manifestBoundsCalculator,
      isDynamic = context.isDynamic,
      isLastPeriod = context.isLastPeriod,
      representationId = context.representationId,
      representationBitrate = context.representationBitrate,
      periodStart = context.periodStart,
      periodEnd = context.periodEnd,
      isEMSGWhitelisted = context.isEMSGWhitelisted;
    var timescale = (_a = index.timescale) !== null && _a !== void 0 ? _a : 1;
    var presentationTimeOffset = index.presentationTimeOffset != null ? index.presentationTimeOffset : 0;
    var scaledStart = periodStart * timescale;
    var indexTimeOffset = presentationTimeOffset - scaledStart;
    this._manifestBoundsCalculator = manifestBoundsCalculator;
    this._isEMSGWhitelisted = isEMSGWhitelisted;
    this._isLastPeriod = isLastPeriod;
    this._lastUpdate = context.receivedTime == null ? performance.now() : context.receivedTime;
    this._unsafelyBaseOnPreviousIndex = null;
    if (context.unsafelyBaseOnPreviousRepresentation !== null && context.unsafelyBaseOnPreviousRepresentation.index instanceof TimelineRepresentationIndex) {
      // avoid too much nested references, to keep memory down
      context.unsafelyBaseOnPreviousRepresentation.index._unsafelyBaseOnPreviousIndex = null;
      this._unsafelyBaseOnPreviousIndex = context.unsafelyBaseOnPreviousRepresentation.index;
    }
    this._isDynamic = isDynamic;
    this._parseTimeline = (_b = index.timelineParser) !== null && _b !== void 0 ? _b : null;
    var initializationUrl = ((_c = index.initialization) === null || _c === void 0 ? void 0 : _c.media) === undefined ? null : (0,tokens/* constructRepresentationUrl */.I1)(index.initialization.media, representationId, representationBitrate);
    var segmentUrlTemplate = index.media === undefined ? null : (0,tokens/* constructRepresentationUrl */.I1)(index.media, representationId, representationBitrate);
    var actualAvailabilityTimeOffset;
    // Technically, it seems (although it is not clear) that an MPD may contain
    // future segments and it's the job of a player to not request segments later
    // than the time at which they should be available.
    // In practice, we don't do that for various reasons: precision issues,
    // various DASH spec interpretations by packagers and players...
    //
    // So as a compromise, if nothing in the MPD indicates that future segments
    // may be announced (see code below), we will act as if ALL segments in this
    // TimelineRepresentationIndex are requestable
    if (availabilityTimeOffset === undefined && availabilityTimeComplete === undefined) {
      actualAvailabilityTimeOffset = Infinity; // Meaning: we can request
      // everything in the index
    } else {
      actualAvailabilityTimeOffset = availabilityTimeOffset !== null && availabilityTimeOffset !== void 0 ? availabilityTimeOffset : 0;
    }
    this._index = {
      availabilityTimeComplete: availabilityTimeComplete !== null && availabilityTimeComplete !== void 0 ? availabilityTimeComplete : true,
      availabilityTimeOffset: actualAvailabilityTimeOffset,
      indexRange: index.indexRange,
      indexTimeOffset: indexTimeOffset,
      initialization: index.initialization == null ? undefined : {
        url: initializationUrl,
        range: index.initialization.range
      },
      segmentUrlTemplate: segmentUrlTemplate,
      startNumber: index.startNumber,
      endNumber: index.endNumber,
      timeline: index.timeline === undefined ? null : updateTimelineFromEndNumber(index.timeline, index.startNumber, index.endNumber),
      timescale: timescale
    };
    this._scaledPeriodStart = (0,index_helpers/* toIndexTime */.vb)(periodStart, this._index);
    this._scaledPeriodEnd = periodEnd === undefined ? undefined : (0,index_helpers/* toIndexTime */.vb)(periodEnd, this._index);
  }
  /**
   * Construct init Segment.
   * @returns {Object}
   */
  var _proto = TimelineRepresentationIndex.prototype;
  _proto.getInitSegment = function getInitSegment() {
    return (0,get_init_segment/* default */.A)(this._index, this._isEMSGWhitelisted);
  }
  /**
   * Asks for segments to download for a given time range.
   * @param {Number} from - Beginning of the time wanted, in seconds
   * @param {Number} duration - duration wanted, in seconds
   * @returns {Array.<Object>}
   */;
  _proto.getSegments = function getSegments(from, duration) {
    this._refreshTimeline(); // clear timeline if needed
    if (this._index.timeline === null) {
      this._index.timeline = this._getTimeline();
    }
    return (0,get_segments_from_timeline/* default */.A)(this._index, from, duration, this._manifestBoundsCalculator, this._scaledPeriodEnd, this._isEMSGWhitelisted);
  }
  /**
   * Returns true if the index should be refreshed.
   * @returns {Boolean}
   */;
  _proto.shouldRefresh = function shouldRefresh() {
    // DASH Manifest based on a SegmentTimeline should have minimumUpdatePeriod
    // attribute which should be sufficient to know when to refresh it.
    return false;
  }
  /**
   * Returns the starting time, in seconds, of the earliest segment currently
   * available.
   * Returns null if nothing is in the index
   * @returns {Number|null}
   */;
  _proto.getFirstAvailablePosition = function getFirstAvailablePosition() {
    this._refreshTimeline();
    if (this._index.timeline === null) {
      this._index.timeline = this._getTimeline();
    }
    var timeline = this._index.timeline;
    return timeline.length === 0 ? null : (0,index_helpers/* fromIndexTime */._l)(Math.max(this._scaledPeriodStart, timeline[0].start), this._index);
  }
  /**
   * Returns the ending time, in seconds, of the last segment currently
   * available.
   * Returns null if nothing is in the index
   * @returns {Number|null}
   */;
  _proto.getLastAvailablePosition = function getLastAvailablePosition() {
    var _a;
    this._refreshTimeline();
    if (this._index.timeline === null) {
      this._index.timeline = this._getTimeline();
    }
    var lastReqSegInfo = getLastRequestableSegmentInfo(
    // Needed typecast for TypeScript
    this._index, this._manifestBoundsCalculator, this._scaledPeriodEnd);
    if (lastReqSegInfo === null) {
      return null;
    }
    var lastScaledPosition = Math.min(lastReqSegInfo.end, (_a = this._scaledPeriodEnd) !== null && _a !== void 0 ? _a : Infinity);
    return (0,index_helpers/* fromIndexTime */._l)(lastScaledPosition, this._index);
  }
  /**
   * Returns the absolute end in seconds this RepresentationIndex can reach once
   * all segments are available.
   * @returns {number|null|undefined}
   */;
  _proto.getEnd = function getEnd() {
    var _a;
    if (this._isDynamic && !this._isLastPeriod) {
      return undefined;
    }
    this._refreshTimeline();
    if (this._index.timeline === null) {
      this._index.timeline = this._getTimeline();
    }
    if (this._index.timeline.length <= 0) {
      return null;
    }
    var lastSegment = this._index.timeline[this._index.timeline.length - 1];
    var lastTime = Math.min((0,index_helpers/* getIndexSegmentEnd */.Rb)(lastSegment, null, this._scaledPeriodEnd), (_a = this._scaledPeriodEnd) !== null && _a !== void 0 ? _a : Infinity);
    return (0,index_helpers/* fromIndexTime */._l)(lastTime, this._index);
  }
  /**
   * Returns:
   *   - `true` if in the given time interval, at least one new segment is
   *     expected to be available in the future.
   *   - `false` either if all segments in that time interval are already
   *     available for download or if none will ever be available for it.
   *   - `undefined` when it is not possible to tell.
   * @param {number} start
   * @param {number} end
   * @returns {boolean|undefined}
   */;
  _proto.awaitSegmentBetween = function awaitSegmentBetween(start, end) {
    var _a, _b;
    (0,assert/* default */.h)(start <= end);
    if (!this._isDynamic) {
      return false; // No segment will be newly available in the future
    }
    this._refreshTimeline();
    if (this._index.timeline === null) {
      this._index.timeline = this._getTimeline();
    }
    var _this$_index = this._index,
      timescale = _this$_index.timescale,
      timeline = _this$_index.timeline;
    var segmentTimeRounding = getSegmentTimeRoundingError(timescale);
    var scaledWantedEnd = (0,index_helpers/* toIndexTime */.vb)(end, this._index);
    var lastReqSegInfo = getLastRequestableSegmentInfo(
    // Needed typecast for TypeScript
    this._index, this._manifestBoundsCalculator, this._scaledPeriodEnd);
    if (lastReqSegInfo !== null) {
      var lastReqSegmentEnd = Math.min(lastReqSegInfo.end, (_a = this._scaledPeriodEnd) !== null && _a !== void 0 ? _a : Infinity);
      var roundedReqSegmentEnd = lastReqSegmentEnd + segmentTimeRounding;
      if (roundedReqSegmentEnd >= Math.min(scaledWantedEnd, (_b = this._scaledPeriodEnd) !== null && _b !== void 0 ? _b : Infinity)) {
        return false; // everything up to that point is already requestable
      }
    }
    var scaledWantedStart = (0,index_helpers/* toIndexTime */.vb)(start, this._index);
    if (timeline.length > 0 && lastReqSegInfo !== null && !lastReqSegInfo.isLastOfTimeline) {
      // There are some future segments already anounced in the MPD
      var lastSegment = timeline[timeline.length - 1];
      var lastSegmentEnd = (0,index_helpers/* getIndexSegmentEnd */.Rb)(lastSegment, null, this._scaledPeriodEnd);
      var roundedLastSegEnd = lastSegmentEnd + segmentTimeRounding;
      if (scaledWantedStart < roundedLastSegEnd + segmentTimeRounding) {
        return true; // The MPD's timeline already contains one such element,
        // It is just not requestable yet
      }
    }
    if (!this._isLastPeriod) {
      // Let's consider - perhaps wrongly, that Periods which aren't the last
      // one have all of their segments announced.
      return false;
    }
    if (this._scaledPeriodEnd === undefined) {
      return scaledWantedEnd + segmentTimeRounding > this._scaledPeriodStart ? undefined // There may be future segments at this point
      : false; // Before the current Period
    }
    // `true` if within the boundaries of this Period. `false` otherwise.
    return scaledWantedStart - segmentTimeRounding < this._scaledPeriodEnd && scaledWantedEnd + segmentTimeRounding > this._scaledPeriodStart;
  }
  /**
   * Returns true if a Segment returned by this index is still considered
   * available.
   * Returns false if it is not available anymore.
   * Returns undefined if we cannot know whether it is still available or not.
   * @param {Object} segment
   * @returns {Boolean|undefined}
   */;
  _proto.isSegmentStillAvailable = function isSegmentStillAvailable(segment) {
    if (segment.isInit) {
      return true;
    }
    this._refreshTimeline();
    if (this._index.timeline === null) {
      this._index.timeline = this._getTimeline();
    }
    return _isSegmentStillAvailable(segment,
    // Needed typecast for TypeScript
    this._index, this._manifestBoundsCalculator, this._scaledPeriodEnd);
  }
  /**
   * Checks if the time given is in a discontinuity. That is:
   *   - We're on the upper bound of the current range (end of the range - time
   *     is inferior to the timescale)
   *   - The next range starts after the end of the current range.
   * @param {Number} time
   * @returns {Number|null}
   */;
  _proto.checkDiscontinuity = function checkDiscontinuity(time) {
    this._refreshTimeline();
    var timeline = this._index.timeline;
    if (timeline === null) {
      timeline = this._getTimeline();
      this._index.timeline = timeline;
    }
    return (0,index_helpers/* checkDiscontinuity */.ph)({
      timeline: timeline,
      timescale: this._index.timescale,
      indexTimeOffset: this._index.indexTimeOffset
    }, time, this._scaledPeriodEnd);
  }
  /**
   * @param {Error} error
   * @returns {Boolean}
   */;
  _proto.canBeOutOfSyncError = function canBeOutOfSyncError(error) {
    if (!this._isDynamic) {
      return false;
    }
    return error instanceof network_error/* default */.A && error.isHttpError(404);
  }
  /**
   * Replace this RepresentationIndex with one from a new version of the
   * Manifest.
   * @param {Object} newIndex
   */;
  _proto._replace = function _replace(newIndex) {
    this._parseTimeline = newIndex._parseTimeline;
    this._index = newIndex._index;
    this._isDynamic = newIndex._isDynamic;
    this._scaledPeriodStart = newIndex._scaledPeriodStart;
    this._scaledPeriodEnd = newIndex._scaledPeriodEnd;
    this._lastUpdate = newIndex._lastUpdate;
    this._manifestBoundsCalculator = newIndex._manifestBoundsCalculator;
    this._isLastPeriod = newIndex._isLastPeriod;
  }
  /**
   * Update this RepresentationIndex with a shorter version of it coming from a
   * new version of the MPD.
   * @param {Object} newIndex
   */;
  _proto._update = function _update(newIndex) {
    if (this._index.timeline === null) {
      this._index.timeline = this._getTimeline();
    }
    if (newIndex._index.timeline === null) {
      newIndex._index.timeline = newIndex._getTimeline();
    }
    var hasReplaced = (0,update_segment_timeline/* default */.A)(this._index.timeline, newIndex._index.timeline);
    if (hasReplaced) {
      this._index.startNumber = newIndex._index.startNumber;
    }
    this._index.availabilityTimeOffset = newIndex._index.availabilityTimeOffset;
    this._index.availabilityTimeComplete = newIndex._index.availabilityTimeComplete;
    this._index.endNumber = newIndex._index.endNumber;
    this._isDynamic = newIndex._isDynamic;
    this._scaledPeriodStart = newIndex._scaledPeriodStart;
    this._scaledPeriodEnd = newIndex._scaledPeriodEnd;
    this._lastUpdate = newIndex._lastUpdate;
    this._isLastPeriod = newIndex._isLastPeriod;
  }
  /**
   * Returns `false` if this RepresentationIndex currently contains its last
   * segment.
   * Returns `true` if it's still pending.
   * @returns {Boolean}
   */;
  _proto.isStillAwaitingFutureSegments = function isStillAwaitingFutureSegments() {
    var _a;
    if (!this._isDynamic) {
      return false;
    }
    this._refreshTimeline();
    if (this._index.timeline === null) {
      this._index.timeline = this._getTimeline();
    }
    var timeline = this._index.timeline;
    if (timeline.length === 0) {
      // No segment announced in this Period
      if (this._scaledPeriodEnd !== undefined) {
        var liveEdge = this._manifestBoundsCalculator.getEstimatedLiveEdge();
        if (liveEdge !== undefined && (0,index_helpers/* toIndexTime */.vb)(liveEdge, this._index) > this._scaledPeriodEnd) {
          // This Period is over, we're not awaiting anything
          return false;
        }
      }
      // Let's just consider that we're awaiting only for when this is the last Period.
      return this._isLastPeriod;
    }
    var segmentTimeRounding = getSegmentTimeRoundingError(this._index.timescale);
    var lastReqSegInfo = getLastRequestableSegmentInfo(
    // Needed typecast for TypeScript
    this._index, this._manifestBoundsCalculator, this._scaledPeriodEnd);
    if (lastReqSegInfo !== null && !lastReqSegInfo.isLastOfTimeline) {
      // There might be non-yet requestable segments in the manifest
      var lastReqSegmentEnd = Math.min(lastReqSegInfo.end, (_a = this._scaledPeriodEnd) !== null && _a !== void 0 ? _a : Infinity);
      if (this._scaledPeriodEnd !== undefined && lastReqSegmentEnd + segmentTimeRounding >= this._scaledPeriodEnd) {
        // The last requestable segment ends after the end of the Period anyway
        return false;
      }
      return true; // There are not-yet requestable segments
    }
    if (!this._isLastPeriod) {
      // This index is not linked to the current last Period in the MPD, in
      // which case it is inferred that all segments have been announced.
      //
      // Note that this condition might break very very rare use cases where old
      // Periods are still being generated, yet it should fix more cases than it
      // breaks.
      return false;
    }
    if (this._scaledPeriodEnd === undefined) {
      // This is the last Period of a dynamic content whose end is unknown.
      // Just return true.
      return true;
    }
    var lastSegment = timeline[timeline.length - 1];
    var lastSegmentEnd = (0,index_helpers/* getIndexSegmentEnd */.Rb)(lastSegment, null, this._scaledPeriodEnd);
    // We're awaiting future segments only if the current end is before the end
    // of the Period
    return lastSegmentEnd + segmentTimeRounding < this._scaledPeriodEnd;
  }
  /**
   * @returns {Boolean}
   */;
  _proto.isInitialized = function isInitialized() {
    return true;
  }
  /**
   * Returns `true` if the given object can be used as an "index" argument to
   * create a new `TimelineRepresentationIndex`.
   * @param {Object} index
   * @returns {boolean}
   */;
  TimelineRepresentationIndex.isTimelineIndexArgument = function isTimelineIndexArgument(index) {
    return typeof index.timelineParser === "function" || Array.isArray(index.timeline);
  }
  /**
   * Clean-up timeline to remove segment information which should not be
   * available due to timeshifting.
   */;
  _proto._refreshTimeline = function _refreshTimeline() {
    var _a, _b;
    if (this._index.timeline === null) {
      this._index.timeline = this._getTimeline();
    }
    if (!this._isDynamic) {
      return;
    }
    var firstPosition = this._manifestBoundsCalculator.getEstimatedMinimumSegmentTime(((_b = (_a = this._index.timeline[0]) === null || _a === void 0 ? void 0 : _a.duration) !== null && _b !== void 0 ? _b : 0) / this._index.timescale);
    if ((0,is_null_or_undefined/* default */.A)(firstPosition)) {
      return; // we don't know yet
    }
    var scaledFirstPosition = (0,index_helpers/* toIndexTime */.vb)(firstPosition, this._index);
    var nbEltsRemoved = (0,clear_timeline_from_position/* default */.A)(this._index.timeline, scaledFirstPosition);
    if (this._index.startNumber !== undefined) {
      this._index.startNumber += nbEltsRemoved;
    } else if (this._index.endNumber !== undefined) {
      this._index.startNumber = nbEltsRemoved + 1;
    }
  }
  /**
   * Allows to generate the "timeline" for this RepresentationIndex.
   * Call this function when the timeline is unknown.
   * This function was added to only perform that task lazily, i.e. only when
   * first needed.
   * After calling it, every now unneeded variable will be freed from memory.
   * This means that calling _getTimeline more than once will just return an
   * empty array.
   *
   * /!\ Please note that this structure should follow the exact same structure
   * than a SegmentTimeline element in the corresponding MPD.
   * This means:
   *   - It should have the same amount of elements in its array than there was
   *     `<S>` elements in the SegmentTimeline.
   *   - Each of those same elements should have the same start time, the same
   *     duration and the same repeat counter than what could be deduced from
   *     the SegmentTimeline.
   * This is needed to be able to run parsing optimization when refreshing the
   * MPD. Not doing so could lead to the RxPlayer not being able to play the
   * stream anymore.
   * @returns {Array.<Object>}
   */;
  _proto._getTimeline = function _getTimeline() {
    if (this._parseTimeline === null) {
      if (this._index.timeline !== null) {
        return this._index.timeline;
      }
      log/* default */.A.error("DASH: Timeline already lazily parsed.");
      return [];
    }
    var newElements = this._parseTimeline();
    this._parseTimeline = null; // Free memory
    var _config$getCurrent = config/* default */.A.getCurrent(),
      MIN_DASH_S_ELEMENTS_TO_PARSE_UNSAFELY = _config$getCurrent.MIN_DASH_S_ELEMENTS_TO_PARSE_UNSAFELY;
    if (this._unsafelyBaseOnPreviousIndex === null || newElements.length < MIN_DASH_S_ELEMENTS_TO_PARSE_UNSAFELY) {
      // Just completely parse the current timeline
      return updateTimelineFromEndNumber(constructTimelineFromElements(newElements), this._index.startNumber, this._index.endNumber);
    }
    // Construct previously parsed timeline if not already done
    var prevTimeline;
    if (this._unsafelyBaseOnPreviousIndex._index.timeline === null) {
      prevTimeline = this._unsafelyBaseOnPreviousIndex._getTimeline();
      this._unsafelyBaseOnPreviousIndex._index.timeline = prevTimeline;
    } else {
      prevTimeline = this._unsafelyBaseOnPreviousIndex._index.timeline;
    }
    this._unsafelyBaseOnPreviousIndex = null; // Free memory
    return updateTimelineFromEndNumber(constructTimelineFromPreviousTimeline(newElements, prevTimeline), this._index.startNumber, this._index.endNumber);
  };
  return TimelineRepresentationIndex;
}();
/**
 * Take the original SegmentTimeline's parsed timeline and, if an `endNumber` is
 * specified, filter segments which possess a number superior to that number.
 *
 * This should only be useful in only rare and broken MPDs, but we aim to
 * respect the specification even in those cases.
 *
 * @param {Array.<Object>} timeline
 * @param {number|undefined} startNumber
 * @param {Array.<Object>} endNumber
 * @returns {number|undefined}
 */

function updateTimelineFromEndNumber(timeline, startNumber, endNumber) {
  if (endNumber === undefined) {
    return timeline;
  }
  var currNumber = startNumber !== null && startNumber !== void 0 ? startNumber : 1;
  for (var idx = 0; idx < timeline.length; idx++) {
    var seg = timeline[idx];
    currNumber += seg.repeatCount + 1;
    if (currNumber > endNumber) {
      if (currNumber === endNumber + 1) {
        return timeline.slice(0, idx + 1);
      } else {
        var newTimeline = timeline.slice(0, idx);
        var lastElt = Object.assign({}, seg);
        var beginningNumber = currNumber - seg.repeatCount - 1;
        lastElt.repeatCount = Math.max(0, endNumber - beginningNumber);
        newTimeline.push(lastElt);
        return newTimeline;
      }
    }
  }
  return timeline;
}
/**
 * Returns true if a Segment returned by the corresponding index is still
 * considered available.
 * Returns false if it is not available anymore.
 * Returns undefined if we cannot know whether it is still available or not.
 * /!\ We do not check the mediaURLs of the segment.
 * @param {Object} segment
 * @param {Object} index
 * @param {Object} manifestBoundsCalculator
 * @param {number|undefined} scaledPeriodEnd
 * @returns {Boolean|undefined}
 */
function _isSegmentStillAvailable(segment, index, manifestBoundsCalculator, scaledPeriodEnd) {
  var lastReqSegInfo = getLastRequestableSegmentInfo(index, manifestBoundsCalculator, scaledPeriodEnd);
  if (lastReqSegInfo === null) {
    return false;
  }
  for (var i = 0; i < index.timeline.length; i++) {
    if (lastReqSegInfo.timelineIdx < i) {
      return false;
    }
    var tSegment = index.timeline[i];
    var tSegmentTime = (tSegment.start - index.indexTimeOffset) / index.timescale;
    if (tSegmentTime > segment.time) {
      return false; // We went over it without finding it
    } else if (tSegmentTime === segment.time) {
      if (tSegment.range === undefined) {
        return segment.range === undefined;
      }
      return segment.range != null && tSegment.range[0] === segment.range[0] && tSegment.range[1] === segment.range[1];
    } else {
      // tSegment.start < segment.time
      if (tSegment.repeatCount >= 0 && tSegment.duration !== undefined) {
        var timeDiff = tSegmentTime - tSegment.start;
        var repeat = timeDiff / tSegment.duration - 1;
        return repeat % 1 === 0 && repeat <= lastReqSegInfo.newRepeatCount;
      }
    }
  }
  return false;
}
/**
 * Returns from the given RepresentationIndex information on the last segment
 * that may be requested currently.
 *
 * Returns `null` if there's no such segment.
 * @param {Object} index
 * @param {Object} manifestBoundsCalculator
 * @param {number|undefined} scaledPeriodEnd
 * @returns {number|null}
 */

function getLastRequestableSegmentInfo(index, manifestBoundsCalculator, scaledPeriodEnd) {
  if (index.timeline.length <= 0) {
    return null;
  }
  if (index.availabilityTimeOffset === Infinity) {
    // availabilityTimeOffset to Infinity == Everything is requestable in the timeline.
    var lastIndex = index.timeline.length - 1;
    var lastElem = index.timeline[lastIndex];
    return {
      isLastOfTimeline: true,
      timelineIdx: lastIndex,
      newRepeatCount: lastElem.repeatCount,
      end: (0,index_helpers/* getIndexSegmentEnd */.Rb)(lastElem, null, scaledPeriodEnd)
    };
  }
  var adjustedMaxSeconds = manifestBoundsCalculator.getEstimatedMaximumPosition(index.availabilityTimeOffset);
  if (adjustedMaxSeconds === undefined) {
    var _lastIndex = index.timeline.length - 1;
    var _lastElem = index.timeline[_lastIndex];
    return {
      isLastOfTimeline: true,
      timelineIdx: _lastIndex,
      newRepeatCount: _lastElem.repeatCount,
      end: (0,index_helpers/* getIndexSegmentEnd */.Rb)(_lastElem, null, scaledPeriodEnd)
    };
  }
  for (var i = index.timeline.length - 1; i >= index.timeline.length; i--) {
    var element = index.timeline[i];
    var endOfFirstOccurence = element.start + element.duration;
    if ((0,index_helpers/* fromIndexTime */._l)(endOfFirstOccurence, index) <= adjustedMaxSeconds) {
      var endTime = (0,index_helpers/* getIndexSegmentEnd */.Rb)(element, index.timeline[i + 1], scaledPeriodEnd);
      if ((0,index_helpers/* fromIndexTime */._l)(endTime, index) <= adjustedMaxSeconds) {
        return {
          isLastOfTimeline: i === index.timeline.length - 1,
          timelineIdx: i,
          newRepeatCount: element.repeatCount,
          end: endOfFirstOccurence
        };
      } else {
        // We have to find the right repeatCount
        var maxIndexTime = (0,index_helpers/* toIndexTime */.vb)(adjustedMaxSeconds, index);
        var diffToSegStart = maxIndexTime - element.start;
        var nbOfSegs = Math.floor(diffToSegStart / element.duration);
        (0,assert/* default */.h)(nbOfSegs >= 1);
        return {
          isLastOfTimeline: false,
          timelineIdx: i,
          newRepeatCount: nbOfSegs - 1,
          end: element.start + nbOfSegs * element.duration
        };
      }
    }
  }
  return null;
}
;// CONCATENATED MODULE: ./src/parsers/manifest/dash/common/indexes/timeline/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ var timeline = (TimelineRepresentationIndex);
;// CONCATENATED MODULE: ./src/parsers/manifest/dash/common/indexes/template.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






/**
 * IRepresentationIndex implementation for DASH' SegmentTemplate without a
 * SegmentTimeline.
 * @class TemplateRepresentationIndex
 */
var TemplateRepresentationIndex = /*#__PURE__*/function () {
  /**
   * @param {Object} index
   * @param {Object} context
   */
  function TemplateRepresentationIndex(index, context) {
    var _a, _b;
    var availabilityTimeOffset = context.availabilityTimeOffset,
      manifestBoundsCalculator = context.manifestBoundsCalculator,
      isDynamic = context.isDynamic,
      periodEnd = context.periodEnd,
      periodStart = context.periodStart,
      representationId = context.representationId,
      representationBitrate = context.representationBitrate,
      isEMSGWhitelisted = context.isEMSGWhitelisted;
    var timescale = (_a = index.timescale) !== null && _a !== void 0 ? _a : 1;
    this._availabilityTimeOffset = availabilityTimeOffset;
    this._manifestBoundsCalculator = manifestBoundsCalculator;
    var presentationTimeOffset = index.presentationTimeOffset != null ? index.presentationTimeOffset : 0;
    var scaledStart = periodStart * timescale;
    var indexTimeOffset = presentationTimeOffset - scaledStart;
    if (index.duration === undefined) {
      throw new Error("Invalid SegmentTemplate: no duration");
    }
    var initializationUrl = ((_b = index.initialization) === null || _b === void 0 ? void 0 : _b.media) === undefined ? null : (0,tokens/* constructRepresentationUrl */.I1)(index.initialization.media, representationId, representationBitrate);
    var segmentUrlTemplate = index.media === undefined ? null : (0,tokens/* constructRepresentationUrl */.I1)(index.media, representationId, representationBitrate);
    this._index = {
      duration: index.duration,
      timescale: timescale,
      indexRange: index.indexRange,
      indexTimeOffset: indexTimeOffset,
      initialization: index.initialization == null ? undefined : {
        url: initializationUrl,
        range: index.initialization.range
      },
      url: segmentUrlTemplate,
      presentationTimeOffset: presentationTimeOffset,
      startNumber: index.startNumber,
      endNumber: index.endNumber
    };
    this._isDynamic = isDynamic;
    this._periodStart = periodStart;
    this._scaledRelativePeriodEnd = periodEnd === undefined ? undefined : (periodEnd - periodStart) * timescale;
    this._isEMSGWhitelisted = isEMSGWhitelisted;
  }
  /**
   * Construct init Segment.
   * @returns {Object}
   */
  var _proto = TemplateRepresentationIndex.prototype;
  _proto.getInitSegment = function getInitSegment() {
    return (0,get_init_segment/* default */.A)(this._index, this._isEMSGWhitelisted);
  }
  /**
   * @param {Number} fromTime
   * @param {Number} dur
   * @returns {Array.<Object>}
   */;
  _proto.getSegments = function getSegments(fromTime, dur) {
    var index = this._index;
    var duration = index.duration,
      startNumber = index.startNumber,
      endNumber = index.endNumber,
      timescale = index.timescale,
      url = index.url;
    var scaledStart = this._periodStart * timescale;
    var scaledEnd = this._scaledRelativePeriodEnd;
    // Convert the asked position to the right timescales, and consider them
    // relatively to the Period's start.
    var upFromPeriodStart = fromTime * timescale - scaledStart;
    var toFromPeriodStart = (fromTime + dur) * timescale - scaledStart;
    var firstSegmentStart = this._getFirstSegmentStart();
    var lastSegmentStart = this._getLastSegmentStart();
    if (firstSegmentStart == null || lastSegmentStart == null) {
      return [];
    }
    var startPosition = Math.max(firstSegmentStart, upFromPeriodStart);
    var lastWantedStartPosition = Math.min(lastSegmentStart, toFromPeriodStart);
    if (lastWantedStartPosition + duration <= startPosition) {
      return [];
    }
    var segments = [];
    // number corresponding to the Period's start
    var numberOffset = startNumber !== null && startNumber !== void 0 ? startNumber : 1;
    // calcul initial time from Period start, where the first segment would have
    // the `0` number
    var numberIndexedToZero = Math.floor(startPosition / duration);
    for (var timeFromPeriodStart = numberIndexedToZero * duration; timeFromPeriodStart <= lastWantedStartPosition; timeFromPeriodStart += duration) {
      // To obtain the real number, adds the real number from the Period's start
      var realNumber = numberIndexedToZero + numberOffset;
      if (endNumber !== undefined && realNumber > endNumber) {
        return segments;
      }
      var realDuration = scaledEnd != null && timeFromPeriodStart + duration > scaledEnd ? scaledEnd - timeFromPeriodStart : duration;
      var realTime = timeFromPeriodStart + scaledStart;
      var manifestTime = timeFromPeriodStart + this._index.presentationTimeOffset;
      var detokenizedURL = url === null ? null : (0,tokens/* createDashUrlDetokenizer */.Qy)(manifestTime, realNumber)(url);
      var args = {
        id: String(realNumber),
        number: realNumber,
        time: realTime / timescale,
        end: (realTime + realDuration) / timescale,
        duration: realDuration / timescale,
        timescale: 1,
        isInit: false,
        scaledDuration: realDuration / timescale,
        url: detokenizedURL,
        timestampOffset: -(index.indexTimeOffset / timescale),
        complete: true,
        privateInfos: {
          isEMSGWhitelisted: this._isEMSGWhitelisted
        }
      };
      segments.push(args);
      numberIndexedToZero++;
    }
    return segments;
  }
  /**
   * Returns first possible position in the index, in seconds.
   * @returns {number|null|undefined}
   */;
  _proto.getFirstAvailablePosition = function getFirstAvailablePosition() {
    var firstSegmentStart = this._getFirstSegmentStart();
    if (firstSegmentStart == null) {
      return firstSegmentStart; // return undefined or null
    }
    return firstSegmentStart / this._index.timescale + this._periodStart;
  }
  /**
   * Returns last possible position in the index, in seconds.
   * @returns {number|null}
   */;
  _proto.getLastAvailablePosition = function getLastAvailablePosition() {
    var lastSegmentStart = this._getLastSegmentStart();
    if ((0,is_null_or_undefined/* default */.A)(lastSegmentStart)) {
      // In that case (null or undefined), getLastAvailablePosition should reflect
      // the result of getLastSegmentStart, as the meaning is the same for
      // the two functions. So, we return the result of the latter.
      return lastSegmentStart;
    }
    var scaledRelativeIndexEnd = this._estimateRelativeScaledEnd();
    var lastSegmentEnd = Math.min(lastSegmentStart + this._index.duration, scaledRelativeIndexEnd !== null && scaledRelativeIndexEnd !== void 0 ? scaledRelativeIndexEnd : Infinity);
    return lastSegmentEnd / this._index.timescale + this._periodStart;
  }
  /**
   * Returns the absolute end in seconds this RepresentationIndex can reach once
   * all segments are available.
   * @returns {number|null|undefined}
   */;
  _proto.getEnd = function getEnd() {
    if (!this._isDynamic) {
      return this.getLastAvailablePosition();
    }
    var scaledRelativeIndexEnd = this._estimateRelativeScaledEnd();
    if (scaledRelativeIndexEnd === undefined) {
      return undefined;
    }
    var timescale = this._index.timescale;
    var absoluteScaledIndexEnd = scaledRelativeIndexEnd + this._periodStart * timescale;
    return absoluteScaledIndexEnd / timescale;
  }
  /**
   * Returns:
   *   - `true` if in the given time interval, at least one new segment is
   *     expected to be available in the future.
   *   - `false` either if all segments in that time interval are already
   *     available for download or if none will ever be available for it.
   *   - `undefined` when it is not possible to tell.
   *
   * Always `false` in a `BaseRepresentationIndex` because all segments should
   * be directly available.
   * @returns {boolean}
   */;
  _proto.awaitSegmentBetween = function awaitSegmentBetween(start, end) {
    (0,assert/* default */.h)(start <= end);
    if (!this._isDynamic) {
      return false;
    }
    var timescale = this._index.timescale;
    var segmentTimeRounding = getSegmentTimeRoundingError(timescale);
    var scaledPeriodStart = this._periodStart * timescale;
    var scaledRelativeStart = start * timescale - scaledPeriodStart;
    var scaledRelativeEnd = end * timescale - scaledPeriodStart;
    var lastSegmentStart = this._getLastSegmentStart();
    if ((0,is_null_or_undefined/* default */.A)(lastSegmentStart)) {
      var _relativeScaledIndexEnd = this._estimateRelativeScaledEnd();
      if (_relativeScaledIndexEnd === undefined) {
        return scaledRelativeEnd + segmentTimeRounding >= 0;
      }
      return scaledRelativeEnd + segmentTimeRounding >= 0 && scaledRelativeStart < _relativeScaledIndexEnd - segmentTimeRounding;
    }
    var lastSegmentEnd = lastSegmentStart + this._index.duration;
    var relativeScaledIndexEnd = this._estimateRelativeScaledEnd();
    if (relativeScaledIndexEnd === undefined) {
      return scaledRelativeEnd > lastSegmentEnd - segmentTimeRounding;
    }
    return scaledRelativeEnd > lastSegmentEnd - segmentTimeRounding && scaledRelativeStart < relativeScaledIndexEnd - segmentTimeRounding;
  }
  /**
   * Returns true if, based on the arguments, the index should be refreshed.
   * We never have to refresh a SegmentTemplate-based manifest.
   * @returns {Boolean}
   */;
  _proto.shouldRefresh = function shouldRefresh() {
    return false;
  }
  /**
   * We cannot check for discontinuity in SegmentTemplate-based indexes.
   * @returns {null}
   */;
  _proto.checkDiscontinuity = function checkDiscontinuity() {
    return null;
  }
  /**
   * Returns `true` if the given segment should still be available as of now
   * (not removed since and still request-able).
   * Returns `false` if that's not the case.
   * Returns `undefined` if we do not know whether that's the case or not.
   * @param {Object} segment
   * @returns {boolean|undefined}
   */;
  _proto.isSegmentStillAvailable = function isSegmentStillAvailable(segment) {
    if (segment.isInit) {
      return true;
    }
    var segmentsForTime = this.getSegments(segment.time, 0.1);
    if (segmentsForTime.length === 0) {
      return false;
    }
    return segmentsForTime[0].time === segment.time && segmentsForTime[0].end === segment.end && segmentsForTime[0].number === segment.number;
  }
  /**
   * SegmentTemplate without a SegmentTimeline should not be updated.
   * @returns {Boolean}
   */;
  _proto.canBeOutOfSyncError = function canBeOutOfSyncError() {
    return false;
  }
  /**
   * Returns `false` if the last segments in this index have already been
   * generated so that we can freely go to the next period.
   * Returns `true` if the index is still waiting on future segments to be
   * generated.
   * @returns {Boolean}
   */;
  _proto.isStillAwaitingFutureSegments = function isStillAwaitingFutureSegments() {
    if (!this._isDynamic) {
      return false;
    }
    var scaledRelativeIndexEnd = this._estimateRelativeScaledEnd();
    if (scaledRelativeIndexEnd === undefined) {
      return true;
    }
    var timescale = this._index.timescale;
    var lastSegmentStart = this._getLastSegmentStart();
    // As last segment start is null if live time is before
    // current period, consider the index not to be finished.
    if ((0,is_null_or_undefined/* default */.A)(lastSegmentStart)) {
      return true;
    }
    var lastSegmentEnd = lastSegmentStart + this._index.duration;
    var segmentTimeRounding = getSegmentTimeRoundingError(timescale);
    return lastSegmentEnd + segmentTimeRounding < scaledRelativeIndexEnd;
  }
  /**
   * @returns {Boolean}
   */;
  _proto.isInitialized = function isInitialized() {
    return true;
  }
  /**
   * @param {Object} newIndex
   */;
  _proto._replace = function _replace(newIndex) {
    this._index = newIndex._index;
    this._isDynamic = newIndex._isDynamic;
    this._periodStart = newIndex._periodStart;
    this._scaledRelativePeriodEnd = newIndex._scaledRelativePeriodEnd;
    this._manifestBoundsCalculator = newIndex._manifestBoundsCalculator;
  }
  /**
   * @param {Object} newIndex
   */;
  _proto._update = function _update(newIndex) {
    // As segments are not declared individually, as long as this Representation
    // is present, we have every information we need
    this._replace(newIndex);
  }
  /**
   * Returns the timescaled start of the first segment that should be available,
   * relatively to the start of the Period.
   * @returns {number | null | undefined}
   */;
  _proto._getFirstSegmentStart = function _getFirstSegmentStart() {
    var _a;
    if (!this._isDynamic) {
      return 0; // it is the start of the Period
    }
    // 1 - check that this index is already available
    if (this._scaledRelativePeriodEnd === 0 || this._scaledRelativePeriodEnd === undefined) {
      // /!\ The scaled max position augments continuously and might not
      // reflect exactly the real server-side value. As segments are
      // generated discretely.
      var maximumSegmentTime = this._manifestBoundsCalculator.getEstimatedMaximumPosition((_a = this._availabilityTimeOffset) !== null && _a !== void 0 ? _a : 0);
      if (maximumSegmentTime !== undefined && maximumSegmentTime < this._periodStart) {
        // Maximum position is before this period.
        // No segment is yet available here
        return null;
      }
    }
    var _this$_index = this._index,
      duration = _this$_index.duration,
      timescale = _this$_index.timescale;
    var firstPosition = this._manifestBoundsCalculator.getEstimatedMinimumSegmentTime(duration / timescale);
    if (firstPosition === undefined) {
      return undefined;
    }
    var segmentTime = firstPosition > this._periodStart ? (firstPosition - this._periodStart) * timescale : 0;
    var numberIndexedToZero = Math.floor(segmentTime / duration);
    return numberIndexedToZero * duration;
  }
  /**
   * Returns the timescaled start of the last segment that should be available,
   * relatively to the start of the Period.
   * Returns null if live time is before current period.
   * @returns {number|null|undefined}
   */;
  _proto._getLastSegmentStart = function _getLastSegmentStart() {
    var _a, _b;
    var _this$_index2 = this._index,
      duration = _this$_index2.duration,
      timescale = _this$_index2.timescale,
      endNumber = _this$_index2.endNumber,
      _this$_index2$startNu = _this$_index2.startNumber,
      startNumber = _this$_index2$startNu === void 0 ? 1 : _this$_index2$startNu;
    if (this._isDynamic) {
      var liveEdge = this._manifestBoundsCalculator.getEstimatedLiveEdge();
      if (liveEdge !== undefined && this._scaledRelativePeriodEnd !== undefined && this._scaledRelativePeriodEnd < liveEdge - this._periodStart * this._index.timescale) {
        var numberOfSegments = Math.ceil(this._scaledRelativePeriodEnd / duration);
        if (endNumber !== undefined && endNumber - startNumber + 1 < numberOfSegments) {
          numberOfSegments = endNumber - startNumber + 1;
        }
        return (numberOfSegments - 1) * duration;
      }
      var lastPosition = this._manifestBoundsCalculator.getEstimatedMaximumPosition((_a = this._availabilityTimeOffset) !== null && _a !== void 0 ? _a : 0);
      if (lastPosition === undefined) {
        return undefined;
      }
      // /!\ The scaled last position augments continuously and might not
      // reflect exactly the real server-side value. As segments are
      // generated discretely.
      var scaledLastPosition = (lastPosition - this._periodStart) * timescale;
      // Maximum position is before this period.
      // No segment is yet available here
      if (scaledLastPosition < 0) {
        return null;
      }
      var numberOfSegmentsAvailable = Math.floor(scaledLastPosition / duration);
      if (endNumber !== undefined && endNumber - startNumber + 1 < numberOfSegmentsAvailable) {
        numberOfSegmentsAvailable = endNumber - startNumber + 1;
      }
      return numberOfSegmentsAvailable <= 0 ? null : (numberOfSegmentsAvailable - 1) * duration;
    } else {
      var maximumTime = (_b = this._scaledRelativePeriodEnd) !== null && _b !== void 0 ? _b : 0;
      var _numberOfSegments = Math.ceil(maximumTime / duration);
      if (endNumber !== undefined && endNumber - startNumber + 1 < _numberOfSegments) {
        _numberOfSegments = endNumber - startNumber + 1;
      }
      var regularLastSegmentStart = (_numberOfSegments - 1) * duration;
      // In some SegmentTemplate, we could think that there is one more
      // segment that there actually is due to a very little difference between
      // the period's duration and a multiple of a segment's duration.
      // Check that we're within a good margin
      var minimumDuration = config/* default */.A.getCurrent().MINIMUM_SEGMENT_SIZE * timescale;
      if (endNumber !== undefined || maximumTime - regularLastSegmentStart > minimumDuration || _numberOfSegments < 2) {
        return regularLastSegmentStart;
      }
      return (_numberOfSegments - 2) * duration;
    }
  }
  /**
   * Returns an estimate of the last available position in this
   * `RepresentationIndex` based on attributes such as the Period's end and
   * the `endNumber` attribute.
   * If the estimate cannot be made (e.g. this Period's segments are still being
   * generated and its end is yet unknown), returns `undefined`.
   * @returns {number|undefined}
   */;
  _proto._estimateRelativeScaledEnd = function _estimateRelativeScaledEnd() {
    var _a, _b;
    if (this._index.endNumber !== undefined) {
      var numberOfSegments = this._index.endNumber - ((_a = this._index.startNumber) !== null && _a !== void 0 ? _a : 1) + 1;
      return Math.max(Math.min(numberOfSegments * this._index.duration, (_b = this._scaledRelativePeriodEnd) !== null && _b !== void 0 ? _b : Infinity), 0);
    }
    if (this._scaledRelativePeriodEnd === undefined) {
      return undefined;
    }
    return Math.max(this._scaledRelativePeriodEnd, 0);
  };
  return TemplateRepresentationIndex;
}();

;// CONCATENATED MODULE: ./src/parsers/manifest/dash/common/parse_representation_index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Parse the specific segment indexing information found in a representation
 * into a IRepresentationIndex implementation.
 * @param {Array.<Object>} representation
 * @param {Object} context
 * @returns {Array.<Object>}
 */
function parseRepresentationIndex(representation, context) {
  var _a, _b, _c;
  var availabilityTimeOffset = context.availabilityTimeOffset,
    manifestBoundsCalculator = context.manifestBoundsCalculator,
    isDynamic = context.isDynamic,
    periodEnd = context.end,
    periodStart = context.start,
    receivedTime = context.receivedTime,
    unsafelyBaseOnPreviousRepresentation = context.unsafelyBaseOnPreviousRepresentation,
    inbandEventStreams = context.inbandEventStreams,
    isLastPeriod = context.isLastPeriod;
  var isEMSGWhitelisted = function isEMSGWhitelisted(inbandEvent) {
    if (inbandEventStreams === undefined) {
      return false;
    }
    return inbandEventStreams.some(function (_ref) {
      var schemeIdUri = _ref.schemeIdUri;
      return schemeIdUri === inbandEvent.schemeIdUri;
    });
  };
  var reprIndexCtxt = {
    availabilityTimeComplete: undefined,
    availabilityTimeOffset: availabilityTimeOffset,
    unsafelyBaseOnPreviousRepresentation: unsafelyBaseOnPreviousRepresentation,
    isEMSGWhitelisted: isEMSGWhitelisted,
    isLastPeriod: isLastPeriod,
    manifestBoundsCalculator: manifestBoundsCalculator,
    isDynamic: isDynamic,
    periodEnd: periodEnd,
    periodStart: periodStart,
    receivedTime: receivedTime,
    representationBitrate: representation.attributes.bitrate,
    representationId: representation.attributes.id
  };
  var representationIndex;
  if (representation.children.segmentBase !== undefined) {
    var segmentBase = representation.children.segmentBase;
    representationIndex = new base/* default */.A(segmentBase, reprIndexCtxt);
  } else if (representation.children.segmentList !== undefined) {
    var segmentList = representation.children.segmentList;
    representationIndex = new ListRepresentationIndex(segmentList, reprIndexCtxt);
  } else if (representation.children.segmentTemplate !== undefined || context.parentSegmentTemplates.length > 0) {
    var segmentTemplates = context.parentSegmentTemplates.slice();
    var childSegmentTemplate = representation.children.segmentTemplate;
    if (childSegmentTemplate !== undefined) {
      segmentTemplates.push(childSegmentTemplate);
    }
    var segmentTemplate = object_assign/* default */.A.apply(void 0, [{}].concat(segmentTemplates));
    if (segmentTemplate.availabilityTimeOffset !== undefined || context.availabilityTimeOffset !== undefined) {
      reprIndexCtxt.availabilityTimeOffset = ((_a = segmentTemplate.availabilityTimeOffset) !== null && _a !== void 0 ? _a : 0) + ((_b = context.availabilityTimeOffset) !== null && _b !== void 0 ? _b : 0);
    }
    if (segmentTemplate.availabilityTimeComplete !== undefined || context.availabilityTimeComplete !== undefined) {
      reprIndexCtxt.availabilityTimeComplete = (_c = segmentTemplate.availabilityTimeComplete) !== null && _c !== void 0 ? _c : context.availabilityTimeComplete;
    }
    representationIndex = timeline.isTimelineIndexArgument(segmentTemplate) ? new timeline(segmentTemplate, reprIndexCtxt) : new TemplateRepresentationIndex(segmentTemplate, reprIndexCtxt);
  } else {
    var adaptationChildren = context.adaptation.children;
    if (adaptationChildren.segmentBase !== undefined) {
      var _segmentBase = adaptationChildren.segmentBase;
      representationIndex = new base/* default */.A(_segmentBase, reprIndexCtxt);
    } else if (adaptationChildren.segmentList !== undefined) {
      var _segmentList = adaptationChildren.segmentList;
      representationIndex = new ListRepresentationIndex(_segmentList, reprIndexCtxt);
    } else {
      representationIndex = new TemplateRepresentationIndex({
        duration: Number.MAX_VALUE,
        timescale: 1,
        startNumber: 0,
        media: ""
      }, reprIndexCtxt);
    }
  }
  return representationIndex;
}
;// CONCATENATED MODULE: ./src/parsers/manifest/dash/common/resolve_base_urls.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @param {Array.<string>} currentBaseURLs
 * @param {Array.<Object>} newBaseUrlsIR
 * @returns {Array.<string>}
 */
function resolveBaseURLs(currentBaseURLs, newBaseUrlsIR) {
  var _a;
  if (newBaseUrlsIR.length === 0) {
    return currentBaseURLs;
  }
  var newBaseUrls = newBaseUrlsIR.map(function (ir) {
    return {
      url: ir.value
    };
  });
  if (currentBaseURLs.length === 0) {
    return newBaseUrls;
  }
  var result = [];
  for (var i = 0; i < currentBaseURLs.length; i++) {
    var curBaseUrl = currentBaseURLs[i];
    for (var j = 0; j < newBaseUrls.length; j++) {
      var newBaseUrl = newBaseUrls[j];
      var newUrl = (0,resolve_url/* default */.Ay)(curBaseUrl.url, newBaseUrl.url);
      result.push({
        url: newUrl,
        serviceLocation: (_a = newBaseUrl.serviceLocation) !== null && _a !== void 0 ? _a : curBaseUrl.serviceLocation
      });
    }
  }
  return result;
}
;// CONCATENATED MODULE: ./src/parsers/manifest/dash/common/parse_representations.ts
function parse_representations_createForOfIteratorHelperLoose(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (t) return (t = t.call(r)).next.bind(t); if (Array.isArray(r) || (t = parse_representations_unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var o = 0; return function () { return o >= r.length ? { done: !0 } : { done: !1, value: r[o++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function parse_representations_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return parse_representations_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? parse_representations_arrayLikeToArray(r, a) : void 0; } }
function parse_representations_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */







/**
 * Combine inband event streams from representation and
 * adaptation data.
 * @param {Object} representation
 * @param {Object} adaptation
 * @returns {undefined |Array.<Object>}
 */
function combineInbandEventStreams(representation, adaptation) {
  var newSchemeId = [];
  if (representation.children.inbandEventStreams !== undefined) {
    newSchemeId.push.apply(newSchemeId, representation.children.inbandEventStreams);
  }
  if (adaptation.children.inbandEventStreams !== undefined) {
    newSchemeId.push.apply(newSchemeId, adaptation.children.inbandEventStreams);
  }
  if (newSchemeId.length === 0) {
    return undefined;
  }
  return newSchemeId;
}
/**
 * Extract HDR information from manifest and codecs.
 * @param {Object}
 * @returns {Object | undefined}
 */
function getHDRInformation(_ref) {
  var adaptationProfiles = _ref.adaptationProfiles,
    essentialProperties = _ref.essentialProperties,
    supplementalProperties = _ref.supplementalProperties,
    manifestProfiles = _ref.manifestProfiles,
    codecs = _ref.codecs;
  var profiles = (adaptationProfiles !== null && adaptationProfiles !== void 0 ? adaptationProfiles : "") + (manifestProfiles !== null && manifestProfiles !== void 0 ? manifestProfiles : "");
  if (profiles.indexOf("http://dashif.org/guidelines/dash-if-uhd#hevc-hdr-pq10") !== -1) {
    if (codecs === "hvc1.2.4.L153.B0" || codecs === "hev1.2.4.L153.B0") {
      return {
        colorDepth: 10,
        eotf: "pq",
        colorSpace: "rec2020"
      };
    }
  }
  var transferCharacteristicScheme = (0,array_find/* default */.A)([].concat(essentialProperties !== null && essentialProperties !== void 0 ? essentialProperties : [], supplementalProperties !== null && supplementalProperties !== void 0 ? supplementalProperties : []), function (p) {
    return p.schemeIdUri === "urn:mpeg:mpegB:cicp:TransferCharacteristics";
  });
  if (transferCharacteristicScheme !== undefined) {
    switch (transferCharacteristicScheme.value) {
      case "15":
        return undefined;
      // SDR
      case "16":
        return {
          eotf: "pq"
        };
      case "18":
        return {
          eotf: "hlg"
        };
    }
  }
  if (codecs !== undefined && /^vp(08|09|10)/.exec(codecs)) {
    return getWEBMHDRInformation(codecs);
  }
}
/**
 * Process intermediate representations to create final parsed representations.
 * @param {Array.<Object>} representationsIR
 * @param {Object} context
 * @returns {Array.<Object>}
 */
function parseRepresentations(representationsIR, adaptation, context) {
  var _a, _b, _c, _d, _e;
  var parsedRepresentations = [];
  var _loop = function _loop() {
    var representation = _step.value;
    // Compute Representation ID
    var representationID = representation.attributes.id !== undefined ? representation.attributes.id : String(representation.attributes.bitrate) + (representation.attributes.height !== undefined ? "-" + representation.attributes.height : "") + (representation.attributes.width !== undefined ? "-" + representation.attributes.width : "") + (representation.attributes.mimeType !== undefined ? "-" + representation.attributes.mimeType : "") + (representation.attributes.codecs !== undefined ? "-" + representation.attributes.codecs : "");
    // Avoid duplicate IDs
    while (parsedRepresentations.some(function (r) {
      return r.id === representationID;
    })) {
      representationID += "-dup";
    }
    // Retrieve previous version of the Representation, if one.
    var unsafelyBaseOnPreviousRepresentation = (_b = (_a = context.unsafelyBaseOnPreviousAdaptation) === null || _a === void 0 ? void 0 : _a.getRepresentation(representationID)) !== null && _b !== void 0 ? _b : null;
    var inbandEventStreams = combineInbandEventStreams(representation, adaptation);
    var availabilityTimeComplete = (_c = representation.attributes.availabilityTimeComplete) !== null && _c !== void 0 ? _c : context.availabilityTimeComplete;
    var availabilityTimeOffset;
    if (representation.attributes.availabilityTimeOffset !== undefined || context.availabilityTimeOffset !== undefined) {
      availabilityTimeOffset = ((_d = representation.attributes.availabilityTimeOffset) !== null && _d !== void 0 ? _d : 0) + ((_e = context.availabilityTimeOffset) !== null && _e !== void 0 ? _e : 0);
    }
    var reprIndexCtxt = (0,object_assign/* default */.A)({}, context, {
      availabilityTimeOffset: availabilityTimeOffset,
      availabilityTimeComplete: availabilityTimeComplete,
      unsafelyBaseOnPreviousRepresentation: unsafelyBaseOnPreviousRepresentation,
      adaptation: adaptation,
      inbandEventStreams: inbandEventStreams
    });
    var representationIndex = parseRepresentationIndex(representation, reprIndexCtxt);
    // Find bitrate
    var representationBitrate;
    if (representation.attributes.bitrate === undefined) {
      log/* default */.A.warn("DASH: No usable bitrate found in the Representation.");
      representationBitrate = 0;
    } else {
      representationBitrate = representation.attributes.bitrate;
    }
    var representationBaseURLs = resolveBaseURLs(context.baseURLs, representation.children.baseURLs);
    var cdnMetadata = representationBaseURLs.length === 0 ?
    // No BaseURL seems to be associated to this Representation, nor to the MPD,
    // but underlying segments might have one. To indicate that segments should
    // still be available through a CDN without giving any root CDN URL here,
    // we just communicate about an empty `baseUrl`, as documented.
    [{
      baseUrl: "",
      id: undefined
    }] : representationBaseURLs.map(function (x) {
      return {
        baseUrl: x.url,
        id: x.serviceLocation
      };
    });
    // Construct Representation Base
    var parsedRepresentation = {
      bitrate: representationBitrate,
      cdnMetadata: cdnMetadata,
      index: representationIndex,
      id: representationID
    };
    if (representation.children.supplementalProperties !== undefined && (0,array_find/* default */.A)(representation.children.supplementalProperties, function (r) {
      return r.schemeIdUri === "tag:dolby.com,2018:dash:EC3_ExtensionType:2018" && r.value === "JOC";
    })) {
      parsedRepresentation.isSpatialAudio = true;
    }
    // Add optional attributes
    var codecs;
    if (representation.attributes.codecs !== undefined) {
      codecs = representation.attributes.codecs;
    } else if (adaptation.attributes.codecs !== undefined) {
      codecs = adaptation.attributes.codecs;
    }
    if (codecs !== undefined) {
      codecs = codecs === "mp4a.40.02" ? "mp4a.40.2" : codecs;
      parsedRepresentation.codecs = codecs;
    }
    var supplementalCodecs;
    if (representation.attributes.supplementalCodecs !== undefined) {
      supplementalCodecs = representation.attributes.supplementalCodecs;
    } else if (adaptation.attributes.supplementalCodecs !== undefined) {
      supplementalCodecs = adaptation.attributes.supplementalCodecs;
    }
    if (supplementalCodecs !== undefined) {
      parsedRepresentation.supplementalCodecs = convertSupplementalCodecsToRFC6381(supplementalCodecs);
    }
    if (representation.attributes.frameRate !== undefined) {
      parsedRepresentation.frameRate = representation.attributes.frameRate;
    } else if (adaptation.attributes.frameRate !== undefined) {
      parsedRepresentation.frameRate = adaptation.attributes.frameRate;
    }
    if (representation.attributes.height !== undefined) {
      parsedRepresentation.height = representation.attributes.height;
    } else if (adaptation.attributes.height !== undefined) {
      parsedRepresentation.height = adaptation.attributes.height;
    }
    if (representation.attributes.mimeType !== undefined) {
      parsedRepresentation.mimeType = representation.attributes.mimeType;
    } else if (adaptation.attributes.mimeType !== undefined) {
      parsedRepresentation.mimeType = adaptation.attributes.mimeType;
    }
    if (representation.attributes.width !== undefined) {
      parsedRepresentation.width = representation.attributes.width;
    } else if (adaptation.attributes.width !== undefined) {
      parsedRepresentation.width = adaptation.attributes.width;
    }
    var contentProtectionsIr = adaptation.children.contentProtections !== undefined ? adaptation.children.contentProtections : [];
    if (representation.children.contentProtections !== undefined) {
      contentProtectionsIr.push.apply(contentProtectionsIr, representation.children.contentProtections);
    }
    if (contentProtectionsIr.length > 0) {
      var contentProtections = contentProtectionsIr.reduce(function (acc, cp) {
        var systemId;
        if (cp.attributes.schemeIdUri !== undefined && cp.attributes.schemeIdUri.substring(0, 9) === "urn:uuid:") {
          systemId = cp.attributes.schemeIdUri.substring(9).replace(/-/g, "").toLowerCase();
        }
        if (cp.attributes.keyId !== undefined && cp.attributes.keyId.length > 0) {
          var kidObj = {
            keyId: cp.attributes.keyId,
            systemId: systemId
          };
          if (acc.keyIds === undefined) {
            acc.keyIds = [kidObj];
          } else {
            acc.keyIds.push(kidObj);
          }
        }
        if (systemId !== undefined) {
          var cencPssh = cp.children.cencPssh;
          var values = [];
          for (var _iterator2 = parse_representations_createForOfIteratorHelperLoose(cencPssh), _step2; !(_step2 = _iterator2()).done;) {
            var data = _step2.value;
            values.push({
              systemId: systemId,
              data: data
            });
          }
          if (values.length > 0) {
            var cencInitData = (0,array_find/* default */.A)(acc.initData, function (i) {
              return i.type === "cenc";
            });
            if (cencInitData === undefined) {
              acc.initData.push({
                type: "cenc",
                values: values
              });
            } else {
              var _cencInitData$values;
              (_cencInitData$values = cencInitData.values).push.apply(_cencInitData$values, values);
            }
          }
        }
        return acc;
      }, {
        keyIds: undefined,
        initData: []
      });
      if (Object.keys(contentProtections.initData).length > 0 || contentProtections.keyIds !== undefined && contentProtections.keyIds.length > 0) {
        parsedRepresentation.contentProtections = contentProtections;
      }
    }
    parsedRepresentation.hdrInfo = getHDRInformation({
      adaptationProfiles: adaptation.attributes.profiles,
      supplementalProperties: adaptation.children.supplementalProperties,
      essentialProperties: adaptation.children.essentialProperties,
      manifestProfiles: context.manifestProfiles,
      codecs: codecs
    });
    parsedRepresentations.push(parsedRepresentation);
  };
  for (var _iterator = parse_representations_createForOfIteratorHelperLoose(representationsIR), _step; !(_step = _iterator()).done;) {
    _loop();
  }
  return parsedRepresentations;
}
;// CONCATENATED MODULE: ./src/parsers/manifest/dash/common/parse_adaptation_sets.ts
function parse_adaptation_sets_createForOfIteratorHelperLoose(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (t) return (t = t.call(r)).next.bind(t); if (Array.isArray(r) || (t = parse_adaptation_sets_unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var o = 0; return function () { return o >= r.length ? { done: !0 } : { done: !1, value: r[o++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function parse_adaptation_sets_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return parse_adaptation_sets_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? parse_adaptation_sets_arrayLikeToArray(r, a) : void 0; } }
function parse_adaptation_sets_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */







// eslint-disable-next-line max-len



/**
 * Detect if the accessibility given defines an adaptation for the visually
 * impaired.
 * Based on DVB Document A168 (DVB-DASH) and DASH-IF 4.3.
 * @param {Object} accessibility
 * @returns {Boolean}
 */
function isVisuallyImpaired(accessibility) {
  if (accessibility === undefined) {
    return false;
  }
  var isVisuallyImpairedAudioDvbDash = accessibility.schemeIdUri === "urn:tva:metadata:cs:AudioPurposeCS:2007" && accessibility.value === "1";
  var isVisuallyImpairedDashIf = accessibility.schemeIdUri === "urn:mpeg:dash:role:2011" && accessibility.value === "description";
  return isVisuallyImpairedAudioDvbDash || isVisuallyImpairedDashIf;
}
/**
 * Detect if the accessibility given defines an adaptation for the hard of
 * hearing.
 * Based on DVB Document A168 (DVB-DASH) and DASH specification.
 * @param {Array.<Object>} accessibilities
 * @param {Array.<Object>} roles
 * @returns {Boolean}
 */
function isCaptionning(accessibilities, roles) {
  if (accessibilities !== undefined) {
    var hasDvbClosedCaptionSignaling = accessibilities.some(function (accessibility) {
      return accessibility.schemeIdUri === "urn:tva:metadata:cs:AudioPurposeCS:2007" && accessibility.value === "2";
    });
    if (hasDvbClosedCaptionSignaling) {
      return true;
    }
  }
  if (roles !== undefined) {
    var hasDashCaptionSinaling = roles.some(function (role) {
      return role.schemeIdUri === "urn:mpeg:dash:role:2011" && role.value === "caption";
    });
    if (hasDashCaptionSinaling) {
      return true;
    }
  }
  return false;
}
/**
 * Detect if the accessibility given defines an AdaptationSet containing a sign
 * language interpretation.
 * Based on DASH-IF 4.3.
 * @param {Object} accessibility
 * @returns {Boolean}
 */
function hasSignLanguageInterpretation(accessibility) {
  if (accessibility === undefined) {
    return false;
  }
  return accessibility.schemeIdUri === "urn:mpeg:dash:role:2011" && accessibility.value === "sign";
}
/**
 * Contruct Adaptation ID from the information we have.
 * @param {Object} adaptation
 * @param {Object} infos
 * @returns {string}
 */
function getAdaptationID(adaptation, infos) {
  if ((0,is_non_empty_string/* default */.A)(adaptation.attributes.id)) {
    return adaptation.attributes.id;
  }
  var isClosedCaption = infos.isClosedCaption,
    isForcedSubtitle = infos.isForcedSubtitle,
    isAudioDescription = infos.isAudioDescription,
    isSignInterpreted = infos.isSignInterpreted,
    isTrickModeTrack = infos.isTrickModeTrack,
    type = infos.type;
  var idString = type;
  if ((0,is_non_empty_string/* default */.A)(adaptation.attributes.language)) {
    idString += "-" + adaptation.attributes.language;
  }
  if (isClosedCaption === true) {
    idString += "-cc";
  }
  if (isForcedSubtitle === true) {
    idString += "-cc";
  }
  if (isAudioDescription === true) {
    idString += "-ad";
  }
  if (isSignInterpreted === true) {
    idString += "-si";
  }
  if (isTrickModeTrack) {
    idString += "-trickMode";
  }
  if ((0,is_non_empty_string/* default */.A)(adaptation.attributes.contentType)) {
    idString += "-" + adaptation.attributes.contentType;
  }
  if ((0,is_non_empty_string/* default */.A)(adaptation.attributes.codecs)) {
    idString += "-" + adaptation.attributes.codecs;
  }
  if ((0,is_non_empty_string/* default */.A)(adaptation.attributes.mimeType)) {
    idString += "-" + adaptation.attributes.mimeType;
  }
  if ((0,is_non_empty_string/* default */.A)(adaptation.attributes.frameRate)) {
    idString += "-" + adaptation.attributes.frameRate;
  }
  return idString;
}
/**
 * Returns a list of ID this adaptation can be seamlessly switched to
 * @param {Object} adaptation
 * @returns {Array.<string>}
 */
function getAdaptationSetSwitchingIDs(adaptation) {
  if (adaptation.children.supplementalProperties != null) {
    var supplementalProperties = adaptation.children.supplementalProperties;
    for (var _iterator = parse_adaptation_sets_createForOfIteratorHelperLoose(supplementalProperties), _step; !(_step = _iterator()).done;) {
      var supplementalProperty = _step.value;
      if (supplementalProperty.schemeIdUri === "urn:mpeg:dash:adaptation-set-switching:2016" && supplementalProperty.value != null) {
        return supplementalProperty.value.split(",").map(function (id) {
          return id.trim();
        }).filter(function (id) {
          return id;
        });
      }
    }
  }
  return [];
}
/**
 * Process AdaptationSets intermediate representations to return under its final
 * form.
 * Note that the AdaptationSets returned are sorted by priority (from the most
 * priority to the least one).
 * @param {Array.<Object>} adaptationsIR
 * @param {Object} context
 * @returns {Array.<Object>}
 */
function parseAdaptationSets(adaptationsIR, context) {
  var _a, _b, _c, _d, _e, _f, _g;
  var parsedAdaptations = {
    video: [],
    audio: [],
    text: [],
    image: []
  };
  var trickModeAdaptations = [];
  var adaptationSwitchingInfos = {};
  var parsedAdaptationsIDs = [];
  for (var adaptationIdx = 0; adaptationIdx < adaptationsIR.length; adaptationIdx++) {
    var adaptation = adaptationsIR[adaptationIdx];
    var adaptationChildren = adaptation.children;
    var essentialProperties = adaptationChildren.essentialProperties,
      roles = adaptationChildren.roles,
      label = adaptationChildren.label;
    var isMainAdaptation = Array.isArray(roles) && roles.some(function (role) {
      return role.value === "main";
    }) && roles.some(function (role) {
      return role.schemeIdUri === "urn:mpeg:dash:role:2011";
    });
    var representationsIR = adaptation.children.representations;
    var availabilityTimeComplete = (_a = adaptation.attributes.availabilityTimeComplete) !== null && _a !== void 0 ? _a : context.availabilityTimeComplete;
    var availabilityTimeOffset = void 0;
    if (adaptation.attributes.availabilityTimeOffset !== undefined || context.availabilityTimeOffset !== undefined) {
      availabilityTimeOffset = ((_b = adaptation.attributes.availabilityTimeOffset) !== null && _b !== void 0 ? _b : 0) + ((_c = context.availabilityTimeOffset) !== null && _c !== void 0 ? _c : 0);
    }
    var adaptationMimeType = adaptation.attributes.mimeType;
    var adaptationCodecs = adaptation.attributes.codecs;
    var type = inferAdaptationType(representationsIR, (0,is_non_empty_string/* default */.A)(adaptationMimeType) ? adaptationMimeType : null, (0,is_non_empty_string/* default */.A)(adaptationCodecs) ? adaptationCodecs : null, adaptationChildren.roles != null ? adaptationChildren.roles : null);
    if (type === undefined) {
      continue;
    }
    var priority = (_d = adaptation.attributes.selectionPriority) !== null && _d !== void 0 ? _d : 1;
    var originalID = adaptation.attributes.id;
    var adaptationSetSwitchingIDs = getAdaptationSetSwitchingIDs(adaptation);
    var parentSegmentTemplates = [];
    if (context.segmentTemplate !== undefined) {
      parentSegmentTemplates.push(context.segmentTemplate);
    }
    if (adaptation.children.segmentTemplate !== undefined) {
      parentSegmentTemplates.push(adaptation.children.segmentTemplate);
    }
    var reprCtxt = {
      availabilityTimeComplete: availabilityTimeComplete,
      availabilityTimeOffset: availabilityTimeOffset,
      baseURLs: resolveBaseURLs(context.baseURLs, adaptationChildren.baseURLs),
      manifestBoundsCalculator: context.manifestBoundsCalculator,
      end: context.end,
      isDynamic: context.isDynamic,
      isLastPeriod: context.isLastPeriod,
      manifestProfiles: context.manifestProfiles,
      parentSegmentTemplates: parentSegmentTemplates,
      receivedTime: context.receivedTime,
      start: context.start,
      unsafelyBaseOnPreviousAdaptation: null
    };
    var trickModeProperty = Array.isArray(essentialProperties) ? (0,array_find/* default */.A)(essentialProperties, function (scheme) {
      return scheme.schemeIdUri === "http://dashif.org/guidelines/trickmode";
    }) : undefined;
    var trickModeAttachedAdaptationIds = (_e = trickModeProperty === null || trickModeProperty === void 0 ? void 0 : trickModeProperty.value) === null || _e === void 0 ? void 0 : _e.split(" ");
    var isTrickModeTrack = trickModeAttachedAdaptationIds !== undefined;
    var accessibilities = adaptationChildren.accessibilities;
    var isDub = void 0;
    if (roles !== undefined && roles.some(function (role) {
      return role.value === "dub";
    })) {
      isDub = true;
    }
    var isClosedCaption = void 0;
    if (type !== "text") {
      isClosedCaption = false;
    } else {
      isClosedCaption = isCaptionning(accessibilities, roles);
    }
    var isForcedSubtitle = void 0;
    if (type === "text" && roles !== undefined && roles.some(function (role) {
      return role.value === "forced-subtitle" || role.value === "forced_subtitle";
    })) {
      isForcedSubtitle = true;
    }
    var isAudioDescription = void 0;
    if (type !== "audio") {
      isAudioDescription = false;
    } else if (accessibilities !== undefined) {
      isAudioDescription = accessibilities.some(isVisuallyImpaired);
    }
    var isSignInterpreted = void 0;
    if (type !== "video") {
      isSignInterpreted = false;
    } else if (accessibilities !== undefined) {
      isSignInterpreted = accessibilities.some(hasSignLanguageInterpretation);
    }
    var adaptationID = getAdaptationID(adaptation, {
      isAudioDescription: isAudioDescription,
      isForcedSubtitle: isForcedSubtitle,
      isClosedCaption: isClosedCaption,
      isSignInterpreted: isSignInterpreted,
      isTrickModeTrack: isTrickModeTrack,
      type: type
    });
    // Avoid duplicate IDs
    while ((0,array_includes/* default */.A)(parsedAdaptationsIDs, adaptationID)) {
      adaptationID += "-dup";
    }
    var newID = adaptationID;
    parsedAdaptationsIDs.push(adaptationID);
    reprCtxt.unsafelyBaseOnPreviousAdaptation = (_g = (_f = context.unsafelyBaseOnPreviousPeriod) === null || _f === void 0 ? void 0 : _f.getAdaptation(adaptationID)) !== null && _g !== void 0 ? _g : null;
    var representations = parseRepresentations(representationsIR, adaptation, reprCtxt);
    var parsedAdaptationSet = {
      id: adaptationID,
      representations: representations,
      type: type,
      isTrickModeTrack: isTrickModeTrack
    };
    if (adaptation.attributes.language != null) {
      parsedAdaptationSet.language = adaptation.attributes.language;
    }
    if (isClosedCaption != null) {
      parsedAdaptationSet.closedCaption = isClosedCaption;
    }
    if (isAudioDescription != null) {
      parsedAdaptationSet.audioDescription = isAudioDescription;
    }
    if (isDub === true) {
      parsedAdaptationSet.isDub = true;
    }
    if (isForcedSubtitle !== undefined) {
      parsedAdaptationSet.forcedSubtitles = isForcedSubtitle;
    }
    if (isSignInterpreted === true) {
      parsedAdaptationSet.isSignInterpreted = true;
    }
    if (label !== undefined) {
      parsedAdaptationSet.label = label;
    }
    if (trickModeAttachedAdaptationIds !== undefined) {
      trickModeAdaptations.push({
        adaptation: parsedAdaptationSet,
        trickModeAttachedAdaptationIds: trickModeAttachedAdaptationIds
      });
    } else {
      // look if we have to merge this into another Adaptation
      var mergedIntoIdx = -1;
      var _loop = function _loop() {
        var id = _step2.value;
        var switchingInfos = adaptationSwitchingInfos[id];
        if (switchingInfos !== undefined && switchingInfos.newID !== newID && (0,array_includes/* default */.A)(switchingInfos.adaptationSetSwitchingIDs, originalID)) {
          mergedIntoIdx = (0,array_find_index/* default */.A)(parsedAdaptations[type], function (a) {
            return a[0].id === id;
          });
          var mergedInto = parsedAdaptations[type][mergedIntoIdx];
          if (mergedInto !== undefined && mergedInto[0].audioDescription === parsedAdaptationSet.audioDescription && mergedInto[0].closedCaption === parsedAdaptationSet.closedCaption && mergedInto[0].language === parsedAdaptationSet.language) {
            var _mergedInto$0$represe;
            log/* default */.A.info('DASH Parser: merging "switchable" AdaptationSets', originalID, id);
            (_mergedInto$0$represe = mergedInto[0].representations).push.apply(_mergedInto$0$represe, parsedAdaptationSet.representations);
            mergedInto[1] = {
              priority: Math.max(priority, mergedInto[1].priority),
              isMainAdaptation: isMainAdaptation || mergedInto[1].isMainAdaptation,
              indexInMpd: Math.min(adaptationIdx, mergedInto[1].indexInMpd)
            };
            return 1; // break
          }
        }
      };
      for (var _iterator2 = parse_adaptation_sets_createForOfIteratorHelperLoose(adaptationSetSwitchingIDs), _step2; !(_step2 = _iterator2()).done;) {
        if (_loop()) break;
      }
      if (mergedIntoIdx < 0) {
        parsedAdaptations[type].push([parsedAdaptationSet, {
          priority: priority,
          isMainAdaptation: isMainAdaptation,
          indexInMpd: adaptationIdx
        }]);
      }
    }
    if (originalID != null && adaptationSwitchingInfos[originalID] == null) {
      adaptationSwitchingInfos[originalID] = {
        newID: newID,
        adaptationSetSwitchingIDs: adaptationSetSwitchingIDs
      };
    }
  }
  var adaptationsPerType = manifest_adaptation/* SUPPORTED_ADAPTATIONS_TYPE */.B.reduce(function (acc, adaptationType) {
    var adaptationsParsedForType = parsedAdaptations[adaptationType];
    if (adaptationsParsedForType.length > 0) {
      adaptationsParsedForType.sort(compareAdaptations);
      acc[adaptationType] = adaptationsParsedForType.map(function (_ref) {
        var parsedAdaptation = _ref[0];
        return parsedAdaptation;
      });
    }
    return acc;
  }, {});
  parsedAdaptations.video.sort(compareAdaptations);
  attach_trickmode_track(adaptationsPerType, trickModeAdaptations);
  return adaptationsPerType;
}
/**
 * Compare groups of parsed AdaptationSet, alongside some ordering metadata,
 * allowing to easily sort them through JavaScript's `Array.prototype.sort`
 * method.
 * @param {Array.<Object>} a
 * @param {Array.<Object>} b
 * @returns {number}
 */
function compareAdaptations(a, b) {
  var priorityDiff = b[1].priority - a[1].priority;
  if (priorityDiff !== 0) {
    return priorityDiff;
  }
  if (a[1].isMainAdaptation !== b[1].isMainAdaptation) {
    return a[1].isMainAdaptation ? -1 : 1;
  }
  return a[1].indexInMpd - b[1].indexInMpd;
}
;// CONCATENATED MODULE: ./src/parsers/manifest/dash/common/parse_periods.ts
function parse_periods_createForOfIteratorHelperLoose(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (t) return (t = t.call(r)).next.bind(t); if (Array.isArray(r) || (t = parse_periods_unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var o = 0; return function () { return o >= r.length ? { done: !0 } : { done: !1, value: r[o++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function parse_periods_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return parse_periods_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? parse_periods_arrayLikeToArray(r, a) : void 0; } }
function parse_periods_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






// eslint-disable-next-line max-len




var generatePeriodID = (0,id_generator/* default */.A)();
/**
 * Process intermediate periods to create final parsed periods.
 * @param {Array.<Object>} periodsIR
 * @param {Object} context
 * @returns {Array.<Object>}
 */
function parsePeriods(periodsIR, context) {
  var _a, _b, _c, _d;
  var parsedPeriods = [];
  var periodsTimeInformation = getPeriodsTimeInformation(periodsIR, context);
  if (periodsTimeInformation.length !== periodsIR.length) {
    throw new Error("MPD parsing error: the time information are incoherent.");
  }
  var isDynamic = context.isDynamic,
    manifestBoundsCalculator = context.manifestBoundsCalculator;
  if (!isDynamic && !(0,is_null_or_undefined/* default */.A)(context.duration)) {
    manifestBoundsCalculator.setLastPosition(context.duration);
  }
  // We parse it in reverse because we might need to deduce the buffer depth from
  // the last Periods' indexes
  var _loop = function _loop() {
    var isLastPeriod = i === periodsIR.length - 1;
    var periodIR = periodsIR[i];
    var xlinkInfos = context.xlinkInfos.get(periodIR);
    var periodBaseURLs = resolveBaseURLs(context.baseURLs, periodIR.children.baseURLs);
    var _periodsTimeInformati = periodsTimeInformation[i],
      periodStart = _periodsTimeInformati.periodStart,
      periodDuration = _periodsTimeInformati.periodDuration,
      periodEnd = _periodsTimeInformati.periodEnd;
    var periodID;
    if ((0,is_null_or_undefined/* default */.A)(periodIR.attributes.id)) {
      log/* default */.A.warn("DASH: No usable id found in the Period. Generating one.");
      periodID = "gen-dash-period-" + generatePeriodID();
    } else {
      periodID = periodIR.attributes.id;
    }
    // Avoid duplicate IDs
    while (parsedPeriods.some(function (p) {
      return p.id === periodID;
    })) {
      periodID += "-dup";
    }
    var receivedTime = xlinkInfos !== undefined ? xlinkInfos.receivedTime : context.receivedTime;
    var unsafelyBaseOnPreviousPeriod = (_b = (_a = context.unsafelyBaseOnPreviousManifest) === null || _a === void 0 ? void 0 : _a.getPeriod(periodID)) !== null && _b !== void 0 ? _b : null;
    var availabilityTimeComplete = periodIR.attributes.availabilityTimeComplete;
    var availabilityTimeOffset = periodIR.attributes.availabilityTimeOffset;
    var manifestProfiles = context.manifestProfiles;
    var segmentTemplate = periodIR.children.segmentTemplate;
    var adapCtxt = {
      availabilityTimeComplete: availabilityTimeComplete,
      availabilityTimeOffset: availabilityTimeOffset,
      baseURLs: periodBaseURLs,
      manifestBoundsCalculator: manifestBoundsCalculator,
      end: periodEnd,
      isDynamic: isDynamic,
      isLastPeriod: isLastPeriod,
      manifestProfiles: manifestProfiles,
      receivedTime: receivedTime,
      segmentTemplate: segmentTemplate,
      start: periodStart,
      unsafelyBaseOnPreviousPeriod: unsafelyBaseOnPreviousPeriod
    };
    var adaptations = parseAdaptationSets(periodIR.children.adaptations, adapCtxt);
    var namespaces = ((_c = context.xmlNamespaces) !== null && _c !== void 0 ? _c : []).concat((_d = periodIR.attributes.namespaces) !== null && _d !== void 0 ? _d : []);
    var streamEvents = generateStreamEvents(periodIR.children.eventStreams, periodStart, namespaces);
    var parsedPeriod = {
      id: periodID,
      start: periodStart,
      end: periodEnd,
      duration: periodDuration,
      adaptations: adaptations,
      streamEvents: streamEvents
    };
    parsedPeriods.unshift(parsedPeriod);
    if (!manifestBoundsCalculator.lastPositionIsKnown()) {
      var _lastPosition = getMaximumLastPosition(adaptations);
      if (!isDynamic) {
        if (typeof _lastPosition === "number") {
          manifestBoundsCalculator.setLastPosition(_lastPosition);
        }
      } else {
        if (typeof _lastPosition === "number") {
          var _positionTime = performance.now() / 1000;
          manifestBoundsCalculator.setLastPosition(_lastPosition, _positionTime);
        } else {
          var _guessedLastPositionFromClock = guessLastPositionFromClock(context, periodStart);
          if (_guessedLastPositionFromClock !== undefined) {
            var guessedLastPosition = _guessedLastPositionFromClock[0],
              guessedPositionTime = _guessedLastPositionFromClock[1];
            manifestBoundsCalculator.setLastPosition(guessedLastPosition, guessedPositionTime);
          }
        }
      }
    }
  };
  for (var i = periodsIR.length - 1; i >= 0; i--) {
    _loop();
  }
  if (context.isDynamic && !manifestBoundsCalculator.lastPositionIsKnown()) {
    // Guess a last time the last position
    var guessedLastPositionFromClock = guessLastPositionFromClock(context, 0);
    if (guessedLastPositionFromClock !== undefined) {
      var lastPosition = guessedLastPositionFromClock[0],
        positionTime = guessedLastPositionFromClock[1];
      manifestBoundsCalculator.setLastPosition(lastPosition, positionTime);
    }
  }
  return flattenOverlappingPeriods(parsedPeriods);
}
/**
 * Try to guess the "last position", which is the last position
 * available in the manifest in seconds, and the "position time", the time
 * (`performance.now()`) in which the last position was collected.
 *
 * These values allows to retrieve at any time in the future the new last
 * position, by substracting the position time to the last position, and
 * adding to it the new value returned by `performance.now`.
 *
 * The last position and position time are returned by this function if and only if
 * it would indicate a last position superior to the `minimumTime` given.
 *
 * This last part allows for example to detect which Period is likely to be the
 * "current" one in multi-periods contents. By giving the Period's start as a
 * `minimumTime`, you ensure that you will get a value only if the current time
 * is in that period.
 *
 * This is useful as guessing the live time from the clock can be seen as a last
 * resort. By detecting that the current time is before the currently considered
 * Period, we can just parse and look at the previous Period. If we can guess
 * the live time more directly from that previous one, we might be better off
 * than just using the clock.
 *
 * @param {Object} context
 * @param {number} minimumTime
 * @returns {Array.<number|undefined>}
 */
function guessLastPositionFromClock(context, minimumTime) {
  if (!(0,is_null_or_undefined/* default */.A)(context.clockOffset)) {
    var lastPosition = context.clockOffset / 1000 - context.availabilityStartTime;
    var positionTime = performance.now() / 1000;
    var timeInSec = positionTime + lastPosition;
    if (timeInSec >= minimumTime) {
      return [timeInSec, positionTime];
    }
  } else {
    var now = Date.now() / 1000;
    if (now >= minimumTime) {
      log/* default */.A.warn("DASH Parser: no clock synchronization mechanism found." + " Using the system clock instead.");
      var _lastPosition2 = now - context.availabilityStartTime;
      var _positionTime2 = performance.now() / 1000;
      return [_lastPosition2, _positionTime2];
    }
  }
  return undefined;
}
/**
 * Try to extract the last position declared for any segments in a Period:
 *   - If at least a single index' last position is defined, take the maximum
 *     among them.
 *   - If segments are available but we cannot define the last position
 *     return undefined.
 *   - If no segment are available in that period, return null
 * @param {Object} adaptationsPerType
 * @returns {number|null|undefined}
 */
function getMaximumLastPosition(adaptationsPerType) {
  var maxEncounteredPosition = null;
  var allIndexAreEmpty = true;
  var adaptationsVal = (0,object_values/* default */.A)(adaptationsPerType).filter(function (ada) {
    return !(0,is_null_or_undefined/* default */.A)(ada);
  });
  var allAdaptations = (0,flat_map/* default */.A)(adaptationsVal, function (adaptationsForType) {
    return adaptationsForType;
  });
  for (var _iterator = parse_periods_createForOfIteratorHelperLoose(allAdaptations), _step; !(_step = _iterator()).done;) {
    var adaptation = _step.value;
    var representations = adaptation.representations;
    for (var _iterator2 = parse_periods_createForOfIteratorHelperLoose(representations), _step2; !(_step2 = _iterator2()).done;) {
      var representation = _step2.value;
      var position = representation.index.getLastAvailablePosition();
      if (position !== null) {
        allIndexAreEmpty = false;
        if (typeof position === "number") {
          maxEncounteredPosition = (0,is_null_or_undefined/* default */.A)(maxEncounteredPosition) ? position : Math.max(maxEncounteredPosition, position);
        }
      }
    }
  }
  if (!(0,is_null_or_undefined/* default */.A)(maxEncounteredPosition)) {
    return maxEncounteredPosition;
  } else if (allIndexAreEmpty) {
    return null;
  }
  return undefined;
}
/**
 * Generate parsed "eventStream" objects from a `StreamEvent` node's
 * intermediate Representation.
 * @param {Array.<Object>} baseIr - The array of every encountered StreamEvent's
 * intermediate representations for a given Period.
 * @param {number} periodStart - The time in seconds at which this corresponding
 * Period starts.
 * @returns {Array.<Object>} - The parsed objects.
 */
function generateStreamEvents(baseIr, periodStart, xmlNamespaces) {
  var _a, _b;
  var res = [];
  for (var _iterator3 = parse_periods_createForOfIteratorHelperLoose(baseIr), _step3; !(_step3 = _iterator3()).done;) {
    var eventStreamIr = _step3.value;
    var _eventStreamIr$attrib = eventStreamIr.attributes,
      _eventStreamIr$attrib2 = _eventStreamIr$attrib.schemeIdUri,
      schemeIdUri = _eventStreamIr$attrib2 === void 0 ? "" : _eventStreamIr$attrib2,
      _eventStreamIr$attrib3 = _eventStreamIr$attrib.timescale,
      timescale = _eventStreamIr$attrib3 === void 0 ? 1 : _eventStreamIr$attrib3;
    var allNamespaces = xmlNamespaces.concat((_a = eventStreamIr.attributes.namespaces) !== null && _a !== void 0 ? _a : []);
    for (var _iterator4 = parse_periods_createForOfIteratorHelperLoose(eventStreamIr.children.events), _step4; !(_step4 = _iterator4()).done;) {
      var eventIr = _step4.value;
      if (eventIr.eventStreamData !== undefined) {
        var start = ((_b = eventIr.presentationTime) !== null && _b !== void 0 ? _b : 0) / timescale + periodStart;
        var end = eventIr.duration === undefined ? undefined : start + eventIr.duration / timescale;
        var element = void 0;
        if (eventIr.eventStreamData instanceof Element) {
          element = eventIr.eventStreamData;
        } else {
          // First, we will create a parent Element defining all namespaces that
          // should have been encountered until know.
          // This is needed because the DOMParser API might throw when
          // encountering unknown namespaced attributes or elements in the given
          // `<Event>` xml subset.
          var parentNode = allNamespaces.reduce(function (acc, ns) {
            return acc + "xmlns:" + ns.key + '="' + ns.value + '" ';
          }, "<toremove ");
          parentNode += ">";
          var elementToString = (0,string_parsing/* utf8ToStr */.Es)(new Uint8Array(eventIr.eventStreamData));
          element = new DOMParser().parseFromString(parentNode + elementToString + "</toremove>", "application/xml").documentElement.childNodes[0]; // unwrap from the `<toremove>` element
        }
        res.push({
          start: start,
          end: end,
          id: eventIr.id,
          data: {
            type: "dash-event-stream",
            value: {
              schemeIdUri: schemeIdUri,
              timescale: timescale,
              element: element
            }
          }
        });
      }
    }
  }
  return res;
}
;// CONCATENATED MODULE: ./src/parsers/manifest/dash/common/parse_mpd.ts
function parse_mpd_createForOfIteratorHelperLoose(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (t) return (t = t.call(r)).next.bind(t); if (Array.isArray(r) || (t = parse_mpd_unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var o = 0; return function () { return o >= r.length ? { done: !0 } : { done: !1, value: r[o++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function parse_mpd_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return parse_mpd_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? parse_mpd_arrayLikeToArray(r, a) : void 0; } }
function parse_mpd_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




// eslint-disable-next-line max-len







/**
 * Checks if xlinks needs to be loaded before actually parsing the manifest.
 * @param {Object} mpdIR
 * @param {Object} args
 * @param {boolean} hasLoadedClock
 * @param {Array.<Object>} warnings
 * @returns {Object}
 */
function parseMpdIr(mpdIR, args, warnings, hasLoadedClock, xlinkInfos) {
  if (xlinkInfos === void 0) {
    xlinkInfos = new WeakMap();
  }
  var rootChildren = mpdIR.children,
    rootAttributes = mpdIR.attributes;
  if (args.externalClockOffset == null) {
    var isDynamic = rootAttributes.type === "dynamic";
    var directTiming = (0,array_find/* default */.A)(rootChildren.utcTimings, function (utcTiming) {
      return utcTiming.schemeIdUri === "urn:mpeg:dash:utc:direct:2014" && utcTiming.value != null;
    });
    var clockOffsetFromDirectUTCTiming = directTiming != null && directTiming.value != null ? getClockOffset(directTiming.value) : undefined;
    var clockOffset = clockOffsetFromDirectUTCTiming != null && !isNaN(clockOffsetFromDirectUTCTiming) ? clockOffsetFromDirectUTCTiming : undefined;
    if (clockOffset != null && hasLoadedClock !== true) {
      args.externalClockOffset = clockOffset;
    } else if (isDynamic && hasLoadedClock !== true) {
      var UTCTimingHTTPURL = getHTTPUTCTimingURL(mpdIR);
      if (UTCTimingHTTPURL != null && UTCTimingHTTPURL.length > 0) {
        // TODO fetch UTCTiming and XLinks at the same time
        return {
          type: "needs-clock",
          value: {
            url: UTCTimingHTTPURL,
            "continue": function continueParsingMPD(responseDataClock) {
              if (!responseDataClock.success) {
                warnings.push(responseDataClock.error);
                log/* default */.A.warn("DASH Parser: Error on fetching the clock ressource", responseDataClock.error);
                return parseMpdIr(mpdIR, args, warnings, true);
              }
              args.externalClockOffset = getClockOffset(responseDataClock.data);
              return parseMpdIr(mpdIR, args, warnings, true);
            }
          }
        };
      }
    }
  }
  var xlinksToLoad = [];
  for (var i = 0; i < rootChildren.periods.length; i++) {
    var _rootChildren$periods = rootChildren.periods[i].attributes,
      xlinkHref = _rootChildren$periods.xlinkHref,
      xlinkActuate = _rootChildren$periods.xlinkActuate;
    if (xlinkHref != null && xlinkActuate === "onLoad") {
      xlinksToLoad.push({
        index: i,
        ressource: xlinkHref
      });
    }
  }
  if (xlinksToLoad.length === 0) {
    return parseCompleteIntermediateRepresentation(mpdIR, args, warnings, xlinkInfos);
  }
  return {
    type: "needs-xlinks",
    value: {
      xlinksUrls: xlinksToLoad.map(function (_ref) {
        var ressource = _ref.ressource;
        return ressource;
      }),
      "continue": function continueParsingMPD(loadedRessources) {
        if (loadedRessources.length !== xlinksToLoad.length) {
          throw new Error("DASH parser: wrong number of loaded ressources.");
        }
        // Note: It is important to go from the last index to the first index in
        // the resulting array, as we will potentially add elements to the array
        for (var _i = loadedRessources.length - 1; _i >= 0; _i--) {
          var _rootChildren$periods2;
          var index = xlinksToLoad[_i].index;
          var _loadedRessources$_i = loadedRessources[_i],
            periodsIR = _loadedRessources$_i.parsed,
            parsingWarnings = _loadedRessources$_i.warnings,
            receivedTime = _loadedRessources$_i.receivedTime,
            sendingTime = _loadedRessources$_i.sendingTime,
            url = _loadedRessources$_i.url;
          if (parsingWarnings.length > 0) {
            warnings.push.apply(warnings, parsingWarnings);
          }
          for (var _iterator = parse_mpd_createForOfIteratorHelperLoose(periodsIR), _step; !(_step = _iterator()).done;) {
            var periodIR = _step.value;
            xlinkInfos.set(periodIR, {
              receivedTime: receivedTime,
              sendingTime: sendingTime,
              url: url
            });
          }
          // replace original "xlinked" periods by the real deal
          (_rootChildren$periods2 = rootChildren.periods).splice.apply(_rootChildren$periods2, [index, 1].concat(periodsIR));
        }
        return parseMpdIr(mpdIR, args, warnings, hasLoadedClock, xlinkInfos);
      }
    }
  };
}
/**
 * Parse the MPD intermediate representation into a regular Manifest.
 * @param {Object} mpdIR
 * @param {Object} args
 * @param {Array.<Object>} warnings
 * @param {Object} xlinkInfos
 * @returns {Object}
 */
function parseCompleteIntermediateRepresentation(mpdIR, args, warnings, xlinkInfos) {
  var _a, _b, _c;
  var rootChildren = mpdIR.children,
    rootAttributes = mpdIR.attributes;
  var isDynamic = rootAttributes.type === "dynamic";
  var initialBaseUrl = args.url !== undefined ? [{
    url: args.url.substring(0, (0,resolve_url/* getFilenameIndexInUrl */.Cl)(args.url))
  }] : [];
  var mpdBaseUrls = resolveBaseURLs(initialBaseUrl, rootChildren.baseURLs);
  var availabilityStartTime = parseAvailabilityStartTime(rootAttributes, args.referenceDateTime);
  var timeShiftBufferDepth = rootAttributes.timeShiftBufferDepth;
  var maxSegmentDuration = rootAttributes.maxSegmentDuration;
  var clockOffset = args.externalClockOffset,
    unsafelyBaseOnPreviousManifest = args.unsafelyBaseOnPreviousManifest;
  var externalClockOffset = args.externalClockOffset;
  var manifestBoundsCalculator = new ManifestBoundsCalculator({
    availabilityStartTime: availabilityStartTime,
    isDynamic: isDynamic,
    timeShiftBufferDepth: timeShiftBufferDepth,
    serverTimestampOffset: externalClockOffset
  });
  var manifestInfos = {
    aggressiveMode: args.aggressiveMode,
    availabilityStartTime: availabilityStartTime,
    baseURLs: mpdBaseUrls,
    clockOffset: clockOffset,
    duration: rootAttributes.duration,
    isDynamic: isDynamic,
    manifestBoundsCalculator: manifestBoundsCalculator,
    manifestProfiles: mpdIR.attributes.profiles,
    receivedTime: args.manifestReceivedTime,
    timeShiftBufferDepth: timeShiftBufferDepth,
    unsafelyBaseOnPreviousManifest: unsafelyBaseOnPreviousManifest,
    xlinkInfos: xlinkInfos,
    xmlNamespaces: mpdIR.attributes.namespaces
  };
  var parsedPeriods = parsePeriods(rootChildren.periods, manifestInfos);
  var mediaPresentationDuration = rootAttributes.duration;
  var lifetime;
  var minimumTime;
  var timeshiftDepth = null;
  var maximumTimeData;
  if (rootAttributes.minimumUpdatePeriod !== undefined && rootAttributes.minimumUpdatePeriod >= 0) {
    lifetime = rootAttributes.minimumUpdatePeriod === 0 ? config/* default */.A.getCurrent().DASH_FALLBACK_LIFETIME_WHEN_MINIMUM_UPDATE_PERIOD_EQUAL_0 : rootAttributes.minimumUpdatePeriod;
  }
  var _getMinimumAndMaximum = getMinimumAndMaximumPositions(parsedPeriods),
    minimumSafePosition = _getMinimumAndMaximum.minimumSafePosition,
    maximumSafePosition = _getMinimumAndMaximum.maximumSafePosition,
    maximumUnsafePosition = _getMinimumAndMaximum.maximumUnsafePosition;
  var now = performance.now();
  if (!isDynamic) {
    minimumTime = minimumSafePosition !== undefined ? minimumSafePosition : ((_a = parsedPeriods[0]) === null || _a === void 0 ? void 0 : _a.start) !== undefined ? parsedPeriods[0].start : 0;
    var finalMaximumSafePosition = mediaPresentationDuration !== null && mediaPresentationDuration !== void 0 ? mediaPresentationDuration : Infinity;
    if (parsedPeriods[parsedPeriods.length - 1] !== undefined) {
      var lastPeriod = parsedPeriods[parsedPeriods.length - 1];
      var lastPeriodEnd = (_b = lastPeriod.end) !== null && _b !== void 0 ? _b : lastPeriod.duration !== undefined ? lastPeriod.start + lastPeriod.duration : undefined;
      if (lastPeriodEnd !== undefined && lastPeriodEnd < finalMaximumSafePosition) {
        finalMaximumSafePosition = lastPeriodEnd;
      }
    }
    if (maximumSafePosition !== undefined && maximumSafePosition < finalMaximumSafePosition) {
      finalMaximumSafePosition = maximumSafePosition;
    }
    maximumTimeData = {
      isLinear: false,
      maximumSafePosition: finalMaximumSafePosition,
      livePosition: undefined,
      time: now
    };
  } else {
    // Determine the maximum seekable position
    var _finalMaximumSafePosition;
    if (maximumSafePosition !== undefined) {
      _finalMaximumSafePosition = maximumSafePosition;
    } else {
      if (externalClockOffset === undefined) {
        log/* default */.A.warn("DASH Parser: use system clock to define maximum position");
        _finalMaximumSafePosition = Date.now() / 1000 - availabilityStartTime;
      } else {
        var serverTime = performance.now() + externalClockOffset;
        _finalMaximumSafePosition = serverTime / 1000 - availabilityStartTime;
      }
    }
    // Determine live edge (what position corresponds to live content, can be
    // inferior or superior to the maximum anounced position in some specific
    // scenarios). However, the `timeShiftBufferDepth` should be based on it.
    var livePosition = manifestBoundsCalculator.getEstimatedLiveEdge();
    if (livePosition === undefined) {
      if (maximumUnsafePosition !== undefined) {
        livePosition = maximumUnsafePosition;
      } else {
        livePosition = _finalMaximumSafePosition;
      }
      // manifestBoundsCalculator.forceLiveEdge(livePosition);
    }
    maximumTimeData = {
      isLinear: true,
      maximumSafePosition: _finalMaximumSafePosition,
      livePosition: livePosition,
      time: now
    };
    // if the minimum calculated time is even below the buffer depth, perhaps we
    // can go even lower in terms of depth
    minimumTime = minimumSafePosition;
    timeshiftDepth = timeShiftBufferDepth !== null && timeShiftBufferDepth !== void 0 ? timeShiftBufferDepth : null;
    if (timeshiftDepth !== null) {
      // The DASH spec implies that a segment is still available after a given
      // `timeShiftBufferDepth` for a time equal to its duration
      // (What I interpret from "ISO/IEC 23009-1 fifth edition 2022-08
      // A.3.4 Media Segment list restrictions).
      //
      // This `timeshiftDepth` property is global for the whole Manifest (and
      // not per segment), thus we cannot do exactly that, but we can take the
      // anounced `maxSegmentDuration` by default instead. This may be a little
      // too optimistic, but would in reality not lead to a lot of issues as
      // this `timeshiftDepth` property is not the one that should be relied on
      // to know which segment can or cannot be requested anymore.
      timeshiftDepth += maxSegmentDuration !== null && maxSegmentDuration !== void 0 ? maxSegmentDuration : 0;
    }
    if (timeshiftDepth !== null && minimumTime !== undefined && livePosition - minimumTime > timeshiftDepth) {
      timeshiftDepth = livePosition - minimumTime;
    }
  }
  // `isLastPeriodKnown` should be `true` in two cases for DASH contents:
  //   1. When the content is static, because we know that no supplementary
  //      Period will be added.
  //   2. If the content is dynamic, only when both the duration is known and
  //      the `minimumUpdatePeriod` is not set. This corresponds to the case
  //      explained in "4.6.4. Transition Phase between Live and On-Demand" of
  //      the DASH-IF IOP v4.3 for live contents transitionning to on-demand.
  var isLastPeriodKnown = !isDynamic || mpdIR.attributes.minimumUpdatePeriod === undefined && (((_c = parsedPeriods[parsedPeriods.length - 1]) === null || _c === void 0 ? void 0 : _c.end) !== undefined || mpdIR.attributes.duration !== undefined);
  var parsedMPD = {
    availabilityStartTime: availabilityStartTime,
    clockOffset: args.externalClockOffset,
    isDynamic: isDynamic,
    isLive: isDynamic,
    isLastPeriodKnown: isLastPeriodKnown,
    periods: parsedPeriods,
    publishTime: rootAttributes.publishTime,
    suggestedPresentationDelay: rootAttributes.suggestedPresentationDelay,
    transportType: "dash",
    timeBounds: {
      minimumSafePosition: minimumTime,
      timeshiftDepth: timeshiftDepth,
      maximumTimeData: maximumTimeData
    },
    lifetime: lifetime,
    uris: args.url == null ? rootChildren.locations : [args.url].concat(rootChildren.locations)
  };
  return {
    type: "done",
    value: {
      parsed: parsedMPD,
      warnings: warnings
    }
  };
}
;// CONCATENATED MODULE: ./src/parsers/manifest/dash/common/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/* harmony default export */ var common = (parseMpdIr);

;// CONCATENATED MODULE: ./src/parsers/manifest/dash/js-parser/node_parsers/BaseURL.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Parse an BaseURL element into an BaseURL intermediate
 * representation.
 * @param {Element} root - The BaseURL root element.
 * @returns {Array.<Object|undefined>}
 */
function parseBaseURL(root) {
  var value = root.textContent;
  var warnings = [];
  if (value === null || value.length === 0) {
    return [undefined, warnings];
  }
  return [{
    value: value
  }, warnings];
}
;// CONCATENATED MODULE: ./src/parsers/manifest/dash/js-parser/node_parsers/ContentComponent.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Parse a "ContentComponent" Element in a DASH MPD.
 * @param {Element} root
 * @returns {Object}
 */
function parseContentComponent(root) {
  var ret = {};
  for (var i = 0; i < root.attributes.length; i++) {
    var attribute = root.attributes[i];
    switch (attribute.name) {
      case "id":
        ret.id = attribute.value;
        break;
      case "lang":
        ret.language = attribute.value;
        break;
      case "contentType":
        ret.contentType = attribute.value;
        break;
      case "par":
        ret.par = attribute.value;
        break;
    }
  }
  return ret;
}
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js
var inheritsLoose = __webpack_require__(7387);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js + 4 modules
var wrapNativeSuper = __webpack_require__(8593);
// EXTERNAL MODULE: ./src/utils/base64.ts
var base64 = __webpack_require__(603);
;// CONCATENATED MODULE: ./src/parsers/manifest/dash/js-parser/node_parsers/utils.ts


/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// XML-Schema
/* eslint-disable max-len */
// <http://standards.iso.org/ittf/PubliclyAvailableStandards/MPEG-DASH_schema_files/DASH-MPD.xsd>
/* eslint-enable max-len */



var iso8601Duration = /^P(([\d.]*)Y)?(([\d.]*)M)?(([\d.]*)D)?T?(([\d.]*)H)?(([\d.]*)M)?(([\d.]*)S)?/;
var rangeRe = /([0-9]+)-([0-9]+)/;
/**
 * Parse MPD boolean attributes.
 *
 * The returned value is a tuple of two elements where:
 *   1. the first value is the parsed boolean - or `null` if we could not parse
 *      it
 *   2. the second value is a possible error encountered while parsing this
 *      value - set to `null` if no error was encountered.
 * @param {string} val - The value to parse
 * @param {string} displayName - The name of the property. Used for error
 * formatting.
 * @returns {Array.<Boolean | Error | null>}
 */
function parseBoolean(val, displayName) {
  if (val === "true") {
    return [true, null];
  }
  if (val === "false") {
    return [false, null];
  }
  var error = new MPDError("`" + displayName + "` property is not a boolean value but \"" + val + "\"");
  return [false, error];
}
/**
 * Parse MPD integer attributes.
 *
 * The returned value is a tuple of two elements where:
 *   1. the first value is the parsed boolean - or `null` if we could not parse
 *      it
 *   2. the second value is a possible error encountered while parsing this
 *      value - set to `null` if no error was encountered.
 * @param {string} val - The value to parse
 * @param {string} displayName - The name of the property. Used for error
 * formatting.
 * @returns {Array.<number | Error | null>}
 */
function parseMPDInteger(val, displayName) {
  var toInt = parseInt(val, 10);
  if (isNaN(toInt)) {
    var error = new MPDError("`" + displayName + "` property is not an integer value but \"" + val + "\"");
    return [null, error];
  }
  return [toInt, null];
}
/**
 * Parse MPD float attributes.
 *
 * The returned value is a tuple of two elements where:
 *   1. the first value is the parsed boolean - or `null` if we could not parse
 *      it
 *   2. the second value is a possible error encountered while parsing this
 *      value - set to `null` if no error was encountered.
 * @param {string} val - The value to parse
 * @param {string} displayName - The name of the property. Used for error
 * formatting.
 * @returns {Array.<number | Error | null>}
 */
function parseMPDFloat(val, displayName) {
  if (val === "INF") {
    return [Infinity, null];
  }
  var toInt = parseFloat(val);
  if (isNaN(toInt)) {
    var error = new MPDError("`" + displayName + "` property is not an integer value but \"" + val + "\"");
    return [null, error];
  }
  return [toInt, null];
}
/**
 * Parse MPD attributes which are either integer or boolean values.
 *
 * The returned value is a tuple of two elements where:
 *   1. the first value is the parsed value - or `null` if we could not parse
 *      it
 *   2. the second value is a possible error encountered while parsing this
 *      value - set to `null` if no error was encountered.
 * @param {string} val - The value to parse
 * @param {string} displayName - The name of the property. Used for error
 * formatting.
 * @returns {Array.<Boolean | number | Error | null>}
 */
function parseIntOrBoolean(val, displayName) {
  if (val === "true") {
    return [true, null];
  }
  if (val === "false") {
    return [false, null];
  }
  var toInt = parseInt(val, 10);
  if (isNaN(toInt)) {
    var error = new MPDError("`" + displayName + "` property is not a boolean nor an integer but \"" + val + "\"");
    return [null, error];
  }
  return [toInt, null];
}
/**
 * Parse MPD date attributes.
 *
 * The returned value is a tuple of two elements where:
 *   1. the first value is the parsed value - or `null` if we could not parse
 *      it
 *   2. the second value is a possible error encountered while parsing this
 *      value - set to `null` if no error was encountered.
 * @param {string} val - The value to parse
 * @param {string} displayName - The name of the property. Used for error
 * formatting.
 * @returns {Array.<Date | null | Error>}
 */
function parseDateTime(val, displayName) {
  var parsed = Date.parse(val);
  if (isNaN(parsed)) {
    var error = new MPDError("`" + displayName + "` is in an invalid date format: \"" + val + "\"");
    return [null, error];
  }
  return [new Date(Date.parse(val)).getTime() / 1000, null];
}
/**
 * Parse MPD ISO8601 duration attributes into seconds.
 *
 * The returned value is a tuple of two elements where:
 *   1. the first value is the parsed value - or `null` if we could not parse
 *      it
 *   2. the second value is a possible error encountered while parsing this
 *      value - set to `null` if no error was encountered.
 * @param {string} val - The value to parse
 * @param {string} displayName - The name of the property. Used for error
 * formatting.
 * @returns {Array.<number | Error | null>}
 */
function parseDuration(val, displayName) {
  if (!(0,is_non_empty_string/* default */.A)(val)) {
    var error = new MPDError("`" + displayName + "` property is empty");
    return [0, error];
  }
  var match = iso8601Duration.exec(val);
  if (match === null) {
    var _error = new MPDError("`" + displayName + "` property has an unrecognized format \"" + val + "\"");
    return [null, _error];
  }
  var duration = parseFloat((0,is_non_empty_string/* default */.A)(match[2]) ? match[2] : "0") * 365 * 24 * 60 * 60 + parseFloat((0,is_non_empty_string/* default */.A)(match[4]) ? match[4] : "0") * 30 * 24 * 60 * 60 + parseFloat((0,is_non_empty_string/* default */.A)(match[6]) ? match[6] : "0") * 24 * 60 * 60 + parseFloat((0,is_non_empty_string/* default */.A)(match[8]) ? match[8] : "0") * 60 * 60 + parseFloat((0,is_non_empty_string/* default */.A)(match[10]) ? match[10] : "0") * 60 + parseFloat((0,is_non_empty_string/* default */.A)(match[12]) ? match[12] : "0");
  return [duration, null];
}
/**
 * Parse MPD byterange attributes into arrays of two elements: the start and
 * the end.
 *
 * The returned value is a tuple of two elements where:
 *   1. the first value is the parsed value - or `null` if we could not parse
 *      it
 *   2. the second value is a possible error encountered while parsing this
 *      value - set to `null` if no error was encountered.
 * @param {string} val
 * @param {string} displayName
 * @returns {Array.<Array.<number> | Error | null>}
 */
function parseByteRange(val, displayName) {
  var match = rangeRe.exec(val);
  if (match === null) {
    var error = new MPDError("`" + displayName + "` property has an unrecognized format \"" + val + "\"");
    return [null, error];
  } else {
    return [[+match[1], +match[2]], null];
  }
}
/**
 * Parse MPD base64 attribute into an Uint8Array.
 * the end.
 *
 * The returned value is a tuple of two elements where:
 *   1. the first value is the parsed value - or `null` if we could not parse
 *      it
 *   2. the second value is a possible error encountered while parsing this
 *      value - set to `null` if no error was encountered.
 * @param {string} val
 * @param {string} displayName
 * @returns {Uint8Array | Error | null>}
 */
function parseBase64(val, displayName) {
  try {
    return [(0,base64/* base64ToBytes */.K)(val), null];
  } catch (_) {
    var error = new MPDError("`" + displayName + "` is not a valid base64 string: \"" + val + "\"");
    return [null, error];
  }
}
/**
 * @param {Element} root
 * @returns {Object}
 */
function parseScheme(root) {
  var schemeIdUri;
  var value;
  for (var i = 0; i < root.attributes.length; i++) {
    var attribute = root.attributes[i];
    switch (attribute.name) {
      case "schemeIdUri":
        schemeIdUri = attribute.value;
        break;
      case "value":
        value = attribute.value;
        break;
    }
  }
  return {
    schemeIdUri: schemeIdUri,
    value: value
  };
}
/**
 * Create a function to factorize the MPD parsing logic.
 * @param {Object} dest - The destination object which will contain the parsed
 * values.
 * @param {Array.<Error>} warnings - An array which will contain every parsing
 * error encountered.
 * @return {Function}
 */
function ValueParser(dest, warnings) {
  /**
   * Parse a single value and add it to the `dest` objects.
   * If an error arised while parsing, add it at the end of the `warnings` array.
   * @param {string} objKey - The key which will be added to the `dest` object.
   * @param {string} val - The value found in the MPD which we should parse.
   * @param {Function} parsingFn - The parsing function adapted for this value.
   * @param {string} displayName - The name of the key as it appears in the MPD.
   * This is used only in error formatting,
   */
  return function (val, _ref) {
    var asKey = _ref.asKey,
      parser = _ref.parser,
      dashName = _ref.dashName;
    var _parser = parser(val, dashName),
      parsingResult = _parser[0],
      parsingError = _parser[1];
    if (parsingError !== null) {
      log/* default */.A.warn(parsingError.message);
      warnings.push(parsingError);
    }
    if (parsingResult !== null) {
      dest[asKey] = parsingResult;
    }
  };
}
/**
 * Error arising when parsing the MPD.
 * @class MPDError
 * @extends Error
 */
var MPDError = /*#__PURE__*/function (_Error) {
  /**
   * @param {string} message
   */
  function MPDError(message) {
    var _this;
    _this = _Error.call(this, message) || this;
    // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class
    Object.setPrototypeOf(_this, MPDError.prototype);
    _this.name = "MPDError";
    return _this;
  }
  (0,inheritsLoose/* default */.A)(MPDError, _Error);
  return MPDError;
}( /*#__PURE__*/(0,wrapNativeSuper/* default */.A)(Error));

;// CONCATENATED MODULE: ./src/parsers/manifest/dash/js-parser/node_parsers/ContentProtection.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * @param {NodeList} contentProtectionChildren
 * @Returns {Object}
 */
function parseContentProtectionChildren(contentProtectionChildren) {
  var warnings = [];
  var cencPssh = [];
  for (var i = 0; i < contentProtectionChildren.length; i++) {
    if (contentProtectionChildren[i].nodeType === Node.ELEMENT_NODE) {
      var currentElement = contentProtectionChildren[i];
      if (currentElement.nodeName === "cenc:pssh") {
        var content = currentElement.textContent;
        if (content !== null && content.length > 0) {
          var _parseBase = parseBase64(content, "cenc:pssh"),
            toUint8Array = _parseBase[0],
            error = _parseBase[1];
          if (error !== null) {
            log/* default */.A.warn(error.message);
            warnings.push(error);
          }
          if (toUint8Array !== null) {
            cencPssh.push(toUint8Array);
          }
        }
      }
    }
  }
  return [{
    cencPssh: cencPssh
  }, warnings];
}
/**
 * @param {Element} root
 * @returns {Object}
 */
function parseContentProtectionAttributes(root) {
  var ret = {};
  for (var i = 0; i < root.attributes.length; i++) {
    var attribute = root.attributes[i];
    switch (attribute.name) {
      case "schemeIdUri":
        ret.schemeIdUri = attribute.value;
        break;
      case "value":
        ret.value = attribute.value;
        break;
      case "cenc:default_KID":
        ret.keyId = (0,string_parsing/* hexToBytes */.aT)(attribute.value.replace(/-/g, ""));
    }
  }
  return ret;
}
/**
 * @param {Element} contentProtectionElement
 * @returns {Object}
 */
function parseContentProtection(contentProtectionElement) {
  var _parseContentProtecti = parseContentProtectionChildren(contentProtectionElement.childNodes),
    children = _parseContentProtecti[0],
    childrenWarnings = _parseContentProtecti[1];
  var attributes = parseContentProtectionAttributes(contentProtectionElement);
  return [{
    children: children,
    attributes: attributes
  }, childrenWarnings];
}
;// CONCATENATED MODULE: ./src/parsers/manifest/dash/js-parser/node_parsers/Initialization.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @param {Element} root
 * @returns {Array.<Object>}
 */
function parseInitialization(root) {
  var parsedInitialization = {};
  var warnings = [];
  var parseValue = ValueParser(parsedInitialization, warnings);
  for (var i = 0; i < root.attributes.length; i++) {
    var attribute = root.attributes[i];
    switch (attribute.name) {
      case "range":
        parseValue(attribute.value, {
          asKey: "range",
          parser: parseByteRange,
          dashName: "range"
        });
        break;
      case "sourceURL":
        parsedInitialization.media = attribute.value;
        break;
    }
  }
  return [parsedInitialization, warnings];
}
;// CONCATENATED MODULE: ./src/parsers/manifest/dash/js-parser/node_parsers/SegmentBase.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Parse a SegmentBase element into a SegmentBase intermediate representation.
 * @param {Element} root - The SegmentBase root element.
 * @returns {Array}
 */
function parseSegmentBase(root) {
  var attributes = {};
  var warnings = [];
  var parseValue = ValueParser(attributes, warnings);
  var segmentBaseChildren = root.childNodes;
  for (var i = 0; i < segmentBaseChildren.length; i++) {
    if (segmentBaseChildren[i].nodeType === Node.ELEMENT_NODE) {
      var currentNode = segmentBaseChildren[i];
      if (currentNode.nodeName === "Initialization") {
        var _parseInitialization = parseInitialization(currentNode),
          initialization = _parseInitialization[0],
          initializationWarnings = _parseInitialization[1];
        attributes.initialization = initialization;
        warnings = warnings.concat(initializationWarnings);
      }
    }
  }
  for (var _i = 0; _i < root.attributes.length; _i++) {
    var attr = root.attributes[_i];
    switch (attr.name) {
      case "timescale":
        parseValue(attr.value, {
          asKey: "timescale",
          parser: parseMPDInteger,
          dashName: "timescale"
        });
        break;
      case "presentationTimeOffset":
        parseValue(attr.value, {
          asKey: "presentationTimeOffset",
          parser: parseMPDFloat,
          dashName: "presentationTimeOffset"
        });
        break;
      case "indexRange":
        parseValue(attr.value, {
          asKey: "indexRange",
          parser: parseByteRange,
          dashName: "indexRange"
        });
        break;
      case "indexRangeExact":
        parseValue(attr.value, {
          asKey: "indexRangeExact",
          parser: parseBoolean,
          dashName: "indexRangeExact"
        });
        break;
      case "availabilityTimeOffset":
        parseValue(attr.value, {
          asKey: "availabilityTimeOffset",
          parser: parseMPDFloat,
          dashName: "availabilityTimeOffset"
        });
        break;
      case "availabilityTimeComplete":
        parseValue(attr.value, {
          asKey: "availabilityTimeComplete",
          parser: parseBoolean,
          dashName: "availabilityTimeComplete"
        });
        break;
      case "duration":
        parseValue(attr.value, {
          asKey: "duration",
          parser: parseMPDInteger,
          dashName: "duration"
        });
        break;
      case "startNumber":
        parseValue(attr.value, {
          asKey: "startNumber",
          parser: parseMPDInteger,
          dashName: "startNumber"
        });
        break;
      case "endNumber":
        parseValue(attr.value, {
          asKey: "endNumber",
          parser: parseMPDInteger,
          dashName: "endNumber"
        });
        break;
    }
  }
  return [attributes, warnings];
}
;// CONCATENATED MODULE: ./src/parsers/manifest/dash/js-parser/node_parsers/SegmentURL.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Parse a SegmentURL element into a SegmentURL intermediate
 * representation.
 * @param {Element} root - The SegmentURL root element.
 * @returns {Array}
 */
function parseSegmentURL(root) {
  var parsedSegmentURL = {};
  var warnings = [];
  var parseValue = ValueParser(parsedSegmentURL, warnings);
  for (var i = 0; i < root.attributes.length; i++) {
    var attribute = root.attributes[i];
    switch (attribute.name) {
      case "media":
        parsedSegmentURL.media = attribute.value;
        break;
      case "indexRange":
        parseValue(attribute.value, {
          asKey: "indexRange",
          parser: parseByteRange,
          dashName: "indexRange"
        });
        break;
      case "index":
        parsedSegmentURL.index = attribute.value;
        break;
      case "mediaRange":
        parseValue(attribute.value, {
          asKey: "mediaRange",
          parser: parseByteRange,
          dashName: "mediaRange"
        });
        break;
    }
  }
  return [parsedSegmentURL, warnings];
}
;// CONCATENATED MODULE: ./src/parsers/manifest/dash/js-parser/node_parsers/SegmentList.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * @param {Element} root
 * @returns {Array}
 */
function parseSegmentList(root) {
  var _parseSegmentBase = parseSegmentBase(root),
    base = _parseSegmentBase[0],
    baseWarnings = _parseSegmentBase[1];
  var warnings = baseWarnings;
  var list = [];
  var segmentListChildren = root.childNodes;
  for (var i = 0; i < segmentListChildren.length; i++) {
    if (segmentListChildren[i].nodeType === Node.ELEMENT_NODE) {
      var currentNode = segmentListChildren[i];
      if (currentNode.nodeName === "SegmentURL") {
        var _parseSegmentURL = parseSegmentURL(currentNode),
          segmentURL = _parseSegmentURL[0],
          segmentURLWarnings = _parseSegmentURL[1];
        list.push(segmentURL);
        warnings = warnings.concat(segmentURLWarnings);
      }
    }
  }
  var ret = (0,object_assign/* default */.A)(base, {
    list: list
  });
  return [ret, warnings];
}
;// CONCATENATED MODULE: ./src/parsers/manifest/dash/js-parser/node_parsers/SegmentTimeline.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @param {Element} root
 * @returns {Function}
 */
function createSegmentTimelineParser(root) {
  var result = null;
  return function () {
    if (result === null) {
      var elements = root.getElementsByTagName("S");
      result = elements;
      return elements;
    }
    return result;
  };
}
;// CONCATENATED MODULE: ./src/parsers/manifest/dash/js-parser/node_parsers/SegmentTemplate.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Parse a SegmentTemplate element into a SegmentTemplate intermediate
 * representation.
 * @param {Element} root - The SegmentTemplate root element.
 * @returns {Array}
 */
function parseSegmentTemplate(root) {
  var _parseSegmentBase = parseSegmentBase(root),
    base = _parseSegmentBase[0],
    segmentBaseWarnings = _parseSegmentBase[1];
  var warnings = segmentBaseWarnings;
  var timelineParser;
  // First look for a possible SegmentTimeline
  for (var i = 0; i < root.childNodes.length; i++) {
    if (root.childNodes[i].nodeType === Node.ELEMENT_NODE) {
      var currentNode = root.childNodes[i];
      if (currentNode.nodeName === "SegmentTimeline") {
        timelineParser = createSegmentTimelineParser(currentNode);
      }
    }
  }
  var ret = (0,object_assign/* default */.A)({}, base, {
    duration: base.duration,
    timelineParser: timelineParser
  });
  var parseValue = ValueParser(ret, warnings);
  for (var _i = 0; _i < root.attributes.length; _i++) {
    var attribute = root.attributes[_i];
    switch (attribute.nodeName) {
      case "initialization":
        if (ret.initialization == null) {
          ret.initialization = {
            media: attribute.value
          };
        }
        break;
      case "index":
        ret.index = attribute.value;
        break;
      case "availabilityTimeOffset":
        parseValue(attribute.value, {
          asKey: "availabilityTimeOffset",
          parser: parseMPDFloat,
          dashName: "availabilityTimeOffset"
        });
        break;
      case "availabilityTimeComplete":
        parseValue(attribute.value, {
          asKey: "availabilityTimeComplete",
          parser: parseBoolean,
          dashName: "availabilityTimeComplete"
        });
        break;
      case "media":
        ret.media = attribute.value;
        break;
      case "bitstreamSwitching":
        parseValue(attribute.value, {
          asKey: "bitstreamSwitching",
          parser: parseBoolean,
          dashName: "bitstreamSwitching"
        });
        break;
    }
  }
  return [ret, warnings];
}
;// CONCATENATED MODULE: ./src/parsers/manifest/dash/js-parser/node_parsers/Representation.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






/**
 * @param {NodeList} representationChildren
 * @returns {Object}
 */
function parseRepresentationChildren(representationChildren) {
  var children = {
    baseURLs: []
  };
  var contentProtections = [];
  var warnings = [];
  for (var i = 0; i < representationChildren.length; i++) {
    if (representationChildren[i].nodeType === Node.ELEMENT_NODE) {
      var currentElement = representationChildren[i];
      switch (currentElement.nodeName) {
        case "BaseURL":
          var _parseBaseURL = parseBaseURL(currentElement),
            baseURLObj = _parseBaseURL[0],
            baseURLWarnings = _parseBaseURL[1];
          if (baseURLObj !== undefined) {
            children.baseURLs.push(baseURLObj);
          }
          warnings = warnings.concat(baseURLWarnings);
          break;
        case "InbandEventStream":
          if (children.inbandEventStreams === undefined) {
            children.inbandEventStreams = [];
          }
          children.inbandEventStreams.push(parseScheme(currentElement));
          break;
        case "SegmentBase":
          var _parseSegmentBase = parseSegmentBase(currentElement),
            segmentBase = _parseSegmentBase[0],
            segmentBaseWarnings = _parseSegmentBase[1];
          children.segmentBase = segmentBase;
          if (segmentBaseWarnings.length > 0) {
            warnings = warnings.concat(segmentBaseWarnings);
          }
          break;
        case "SegmentList":
          var _parseSegmentList = parseSegmentList(currentElement),
            segmentList = _parseSegmentList[0],
            segmentListWarnings = _parseSegmentList[1];
          warnings = warnings.concat(segmentListWarnings);
          children.segmentList = segmentList;
          break;
        case "SegmentTemplate":
          var _parseSegmentTemplate = parseSegmentTemplate(currentElement),
            segmentTemplate = _parseSegmentTemplate[0],
            segmentTemplateWarnings = _parseSegmentTemplate[1];
          warnings = warnings.concat(segmentTemplateWarnings);
          children.segmentTemplate = segmentTemplate;
          break;
        case "ContentProtection":
          var _parseContentProtecti = parseContentProtection(currentElement),
            contentProtection = _parseContentProtecti[0],
            contentProtectionWarnings = _parseContentProtecti[1];
          if (contentProtectionWarnings.length > 0) {
            warnings = warnings.concat(contentProtectionWarnings);
          }
          if (contentProtection !== undefined) {
            contentProtections.push(contentProtection);
          }
          break;
        case "SupplementalProperty":
          if (children.supplementalProperties == null) {
            children.supplementalProperties = [parseScheme(currentElement)];
          } else {
            children.supplementalProperties.push(parseScheme(currentElement));
          }
          break;
      }
    }
  }
  if (contentProtections.length > 0) {
    children.contentProtections = contentProtections;
  }
  return [children, warnings];
}
/**
 * @param {Element} representationElement
 * @returns {Array}
 */
function parseRepresentationAttributes(representationElement) {
  var attributes = {};
  var warnings = [];
  var parseValue = ValueParser(attributes, warnings);
  for (var i = 0; i < representationElement.attributes.length; i++) {
    var attr = representationElement.attributes[i];
    switch (attr.name) {
      case "audioSamplingRate":
        attributes.audioSamplingRate = attr.value;
        break;
      case "bandwidth":
        parseValue(attr.value, {
          asKey: "bitrate",
          parser: parseMPDInteger,
          dashName: "bandwidth"
        });
        break;
      case "codecs":
        attributes.codecs = attr.value;
        break;
      case "codingDependency":
        parseValue(attr.value, {
          asKey: "codingDependency",
          parser: parseBoolean,
          dashName: "codingDependency"
        });
        break;
      case "frameRate":
        attributes.frameRate = attr.value;
        break;
      case "height":
        parseValue(attr.value, {
          asKey: "height",
          parser: parseMPDInteger,
          dashName: "height"
        });
        break;
      case "id":
        attributes.id = attr.value;
        break;
      case "maxPlayoutRate":
        parseValue(attr.value, {
          asKey: "maxPlayoutRate",
          parser: parseMPDFloat,
          dashName: "maxPlayoutRate"
        });
        break;
      case "maximumSAPPeriod":
        parseValue(attr.value, {
          asKey: "maximumSAPPeriod",
          parser: parseMPDFloat,
          dashName: "maximumSAPPeriod"
        });
        break;
      case "mimeType":
        attributes.mimeType = attr.value;
        break;
      case "profiles":
        attributes.profiles = attr.value;
        break;
      case "qualityRanking":
        parseValue(attr.value, {
          asKey: "qualityRanking",
          parser: parseMPDInteger,
          dashName: "qualityRanking"
        });
        break;
      case "scte214:supplementalCodecs":
        attributes.supplementalCodecs = attr.value;
        break;
      case "segmentProfiles":
        attributes.segmentProfiles = attr.value;
        break;
      case "width":
        parseValue(attr.value, {
          asKey: "width",
          parser: parseMPDInteger,
          dashName: "width"
        });
        break;
      case "availabilityTimeOffset":
        parseValue(attr.value, {
          asKey: "availabilityTimeOffset",
          parser: parseMPDFloat,
          dashName: "availabilityTimeOffset"
        });
        break;
      case "availabilityTimeComplete":
        parseValue(attr.value, {
          asKey: "availabilityTimeComplete",
          parser: parseBoolean,
          dashName: "availabilityTimeComplete"
        });
        break;
    }
  }
  if (attributes.bitrate === undefined) {
    warnings.push(new MPDError("No bitrate found on a Representation"));
  }
  return [attributes, warnings];
}
/**
 * @param {Element} representationElement
 * @returns {Array}
 */
function createRepresentationIntermediateRepresentation(representationElement) {
  var _parseRepresentationC = parseRepresentationChildren(representationElement.childNodes),
    children = _parseRepresentationC[0],
    childrenWarnings = _parseRepresentationC[1];
  var _parseRepresentationA = parseRepresentationAttributes(representationElement),
    attributes = _parseRepresentationA[0],
    attrsWarnings = _parseRepresentationA[1];
  var warnings = childrenWarnings.concat(attrsWarnings);
  return [{
    children: children,
    attributes: attributes
  }, warnings];
}
;// CONCATENATED MODULE: ./src/parsers/manifest/dash/js-parser/node_parsers/AdaptationSet.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */








/**
 * Parse child nodes from an AdaptationSet.
 * @param {NodeList} adaptationSetChildren - The AdaptationSet child nodes.
 * @returns {Array.<Object>}
 */
function parseAdaptationSetChildren(adaptationSetChildren) {
  var children = {
    baseURLs: [],
    representations: []
  };
  var contentProtections = [];
  var warnings = [];
  for (var i = 0; i < adaptationSetChildren.length; i++) {
    if (adaptationSetChildren[i].nodeType === Node.ELEMENT_NODE) {
      var currentElement = adaptationSetChildren[i];
      switch (currentElement.nodeName) {
        case "Accessibility":
          if (children.accessibilities === undefined) {
            children.accessibilities = [parseScheme(currentElement)];
          } else {
            children.accessibilities.push(parseScheme(currentElement));
          }
          break;
        case "BaseURL":
          var _parseBaseURL = parseBaseURL(currentElement),
            baseURLObj = _parseBaseURL[0],
            baseURLWarnings = _parseBaseURL[1];
          if (baseURLObj !== undefined) {
            children.baseURLs.push(baseURLObj);
          }
          if (baseURLWarnings.length > 0) {
            warnings = warnings.concat(baseURLWarnings);
          }
          break;
        case "ContentComponent":
          children.contentComponent = parseContentComponent(currentElement);
          break;
        case "EssentialProperty":
          if (children.essentialProperties == null) {
            children.essentialProperties = [parseScheme(currentElement)];
          } else {
            children.essentialProperties.push(parseScheme(currentElement));
          }
          break;
        case "InbandEventStream":
          if (children.inbandEventStreams === undefined) {
            children.inbandEventStreams = [];
          }
          children.inbandEventStreams.push(parseScheme(currentElement));
          break;
        case "Label":
          var label = currentElement.textContent;
          if (label !== null && label !== undefined) {
            children.label = label;
          }
          break;
        case "Representation":
          var _createRepresentation = createRepresentationIntermediateRepresentation(currentElement),
            representation = _createRepresentation[0],
            representationWarnings = _createRepresentation[1];
          children.representations.push(representation);
          if (representationWarnings.length > 0) {
            warnings = warnings.concat(representationWarnings);
          }
          break;
        case "Role":
          if (children.roles == null) {
            children.roles = [parseScheme(currentElement)];
          } else {
            children.roles.push(parseScheme(currentElement));
          }
          break;
        case "SupplementalProperty":
          if (children.supplementalProperties == null) {
            children.supplementalProperties = [parseScheme(currentElement)];
          } else {
            children.supplementalProperties.push(parseScheme(currentElement));
          }
          break;
        case "SegmentBase":
          var _parseSegmentBase = parseSegmentBase(currentElement),
            segmentBase = _parseSegmentBase[0],
            segmentBaseWarnings = _parseSegmentBase[1];
          children.segmentBase = segmentBase;
          if (segmentBaseWarnings.length > 0) {
            warnings = warnings.concat(segmentBaseWarnings);
          }
          break;
        case "SegmentList":
          var _parseSegmentList = parseSegmentList(currentElement),
            segmentList = _parseSegmentList[0],
            segmentListWarnings = _parseSegmentList[1];
          children.segmentList = segmentList;
          if (segmentListWarnings.length > 0) {
            warnings = warnings.concat(segmentListWarnings);
          }
          break;
        case "SegmentTemplate":
          var _parseSegmentTemplate = parseSegmentTemplate(currentElement),
            segmentTemplate = _parseSegmentTemplate[0],
            segmentTemplateWarnings = _parseSegmentTemplate[1];
          children.segmentTemplate = segmentTemplate;
          if (segmentTemplateWarnings.length > 0) {
            warnings = warnings.concat(segmentTemplateWarnings);
          }
          break;
        case "ContentProtection":
          var _parseContentProtecti = parseContentProtection(currentElement),
            contentProtection = _parseContentProtecti[0],
            contentProtectionWarnings = _parseContentProtecti[1];
          if (contentProtectionWarnings.length > 0) {
            warnings = warnings.concat(contentProtectionWarnings);
          }
          if (contentProtection !== undefined) {
            contentProtections.push(contentProtection);
          }
          break;
        // case "Rating":
        //   children.rating = currentElement;
        //   break;
        // case "Viewpoint":
        //   children.viewpoint = currentElement;
        //   break;
      }
    }
  }
  if (contentProtections.length > 0) {
    children.contentProtections = contentProtections;
  }
  return [children, warnings];
}
/**
 * Parse every attributes from an AdaptationSet root element into a simple JS
 * object.
 * @param {Element} root - The AdaptationSet root element.
 * @returns {Array.<Object>}
 */
function parseAdaptationSetAttributes(root) {
  var parsedAdaptation = {};
  var warnings = [];
  var parseValue = ValueParser(parsedAdaptation, warnings);
  for (var i = 0; i < root.attributes.length; i++) {
    var attribute = root.attributes[i];
    switch (attribute.name) {
      case "id":
        parsedAdaptation.id = attribute.value;
        break;
      case "group":
        parseValue(attribute.value, {
          asKey: "group",
          parser: parseMPDInteger,
          dashName: "group"
        });
        break;
      case "lang":
        parsedAdaptation.language = attribute.value;
        break;
      case "contentType":
        parsedAdaptation.contentType = attribute.value;
        break;
      case "par":
        parsedAdaptation.par = attribute.value;
        break;
      case "minBandwidth":
        parseValue(attribute.value, {
          asKey: "minBitrate",
          parser: parseMPDInteger,
          dashName: "minBandwidth"
        });
        break;
      case "maxBandwidth":
        parseValue(attribute.value, {
          asKey: "maxBitrate",
          parser: parseMPDInteger,
          dashName: "maxBandwidth"
        });
        break;
      case "minWidth":
        parseValue(attribute.value, {
          asKey: "minWidth",
          parser: parseMPDInteger,
          dashName: "minWidth"
        });
        break;
      case "maxWidth":
        parseValue(attribute.value, {
          asKey: "maxWidth",
          parser: parseMPDInteger,
          dashName: "maxWidth"
        });
        break;
      case "minHeight":
        parseValue(attribute.value, {
          asKey: "minHeight",
          parser: parseMPDInteger,
          dashName: "minHeight"
        });
        break;
      case "maxHeight":
        parseValue(attribute.value, {
          asKey: "maxHeight",
          parser: parseMPDInteger,
          dashName: "maxHeight"
        });
        break;
      case "minFrameRate":
        {
          parsedAdaptation.minFrameRate = attribute.value;
        }
        break;
      case "maxFrameRate":
        parsedAdaptation.maxFrameRate = attribute.value;
        break;
      case "selectionPriority":
        parseValue(attribute.value, {
          asKey: "selectionPriority",
          parser: parseMPDInteger,
          dashName: "selectionPriority"
        });
        break;
      case "segmentAlignment":
        parseValue(attribute.value, {
          asKey: "segmentAlignment",
          parser: parseIntOrBoolean,
          dashName: "segmentAlignment"
        });
        break;
      case "subsegmentAlignment":
        parseValue(attribute.value, {
          asKey: "subsegmentAlignment",
          parser: parseIntOrBoolean,
          dashName: "subsegmentAlignment"
        });
        break;
      case "bitstreamSwitching":
        parseValue(attribute.value, {
          asKey: "bitstreamSwitching",
          parser: parseBoolean,
          dashName: "bitstreamSwitching"
        });
        break;
      case "audioSamplingRate":
        parsedAdaptation.audioSamplingRate = attribute.value;
        break;
      case "codecs":
        parsedAdaptation.codecs = attribute.value;
        break;
      case "scte214:supplementalCodecs":
        parsedAdaptation.supplementalCodecs = attribute.value;
        break;
      case "codingDependency":
        parseValue(attribute.value, {
          asKey: "codingDependency",
          parser: parseBoolean,
          dashName: "codingDependency"
        });
        break;
      case "frameRate":
        parsedAdaptation.frameRate = attribute.value;
        break;
      case "height":
        parseValue(attribute.value, {
          asKey: "height",
          parser: parseMPDInteger,
          dashName: "height"
        });
        break;
      case "maxPlayoutRate":
        parseValue(attribute.value, {
          asKey: "maxPlayoutRate",
          parser: parseMPDFloat,
          dashName: "maxPlayoutRate"
        });
        break;
      case "maximumSAPPeriod":
        parseValue(attribute.value, {
          asKey: "maximumSAPPeriod",
          parser: parseMPDFloat,
          dashName: "maximumSAPPeriod"
        });
        break;
      case "mimeType":
        parsedAdaptation.mimeType = attribute.value;
        break;
      case "profiles":
        parsedAdaptation.profiles = attribute.value;
        break;
      case "segmentProfiles":
        parsedAdaptation.segmentProfiles = attribute.value;
        break;
      case "width":
        parseValue(attribute.value, {
          asKey: "width",
          parser: parseMPDInteger,
          dashName: "width"
        });
        break;
      case "availabilityTimeOffset":
        parseValue(attribute.value, {
          asKey: "availabilityTimeOffset",
          parser: parseMPDFloat,
          dashName: "availabilityTimeOffset"
        });
        break;
      case "availabilityTimeComplete":
        parseValue(attribute.value, {
          asKey: "availabilityTimeComplete",
          parser: parseBoolean,
          dashName: "availabilityTimeComplete"
        });
        break;
    }
  }
  return [parsedAdaptation, warnings];
}
/**
 * Parse an AdaptationSet element into an AdaptationSet intermediate
 * representation.
 * @param {Element} adaptationSetElement - The AdaptationSet root element.
 * @returns {Array.<Object>}
 */
function createAdaptationSetIntermediateRepresentation(adaptationSetElement) {
  var childNodes = adaptationSetElement.childNodes;
  var _parseAdaptationSetCh = parseAdaptationSetChildren(childNodes),
    children = _parseAdaptationSetCh[0],
    childrenWarnings = _parseAdaptationSetCh[1];
  var _parseAdaptationSetAt = parseAdaptationSetAttributes(adaptationSetElement),
    attributes = _parseAdaptationSetAt[0],
    attrsWarnings = _parseAdaptationSetAt[1];
  var warnings = childrenWarnings.concat(attrsWarnings);
  return [{
    children: children,
    attributes: attributes
  }, warnings];
}
;// CONCATENATED MODULE: ./src/parsers/manifest/dash/js-parser/node_parsers/EventStream.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Parse the EventStream node to extract Event nodes and their
 * content.
 * @param {Element} element
 * @returns {Array}
 */
function parseEventStream(element) {
  var eventStreamIR = {
    children: {
      events: []
    },
    attributes: {}
  };
  var warnings = [];
  // 1 - Parse attributes
  var parseValue = ValueParser(eventStreamIR.attributes, warnings);
  for (var i = 0; i < element.attributes.length; i++) {
    var attr = element.attributes[i];
    switch (attr.name) {
      case "schemeIdUri":
        eventStreamIR.attributes.schemeIdUri = attr.value;
        break;
      case "timescale":
        parseValue(attr.value, {
          asKey: "timescale",
          parser: parseMPDInteger,
          dashName: "timescale"
        });
        break;
      case "value":
        eventStreamIR.attributes.value = attr.value;
        break;
    }
  }
  for (var _i = 0; _i < element.childNodes.length; _i++) {
    if (element.childNodes[_i].nodeType === Node.ELEMENT_NODE) {
      var currentElement = element.childNodes[_i];
      switch (currentElement.nodeName) {
        case "Event":
          var _parseEvent = parseEvent(currentElement),
            event = _parseEvent[0],
            eventWarnings = _parseEvent[1];
          eventStreamIR.children.events.push(event);
          if (eventWarnings.length > 0) {
            warnings = warnings.concat(eventWarnings);
          }
          break;
      }
    }
  }
  return [eventStreamIR, warnings];
}
/**
 * Parse `Event` Element, as found in EventStream nodes.
 * @param {Element} element
 * @returns {Array}
 */
function parseEvent(element) {
  var eventIR = {
    eventStreamData: element
  };
  var warnings = [];
  // 1 - Parse attributes
  var parseValue = ValueParser(eventIR, warnings);
  for (var i = 0; i < element.attributes.length; i++) {
    var attr = element.attributes[i];
    switch (attr.name) {
      case "presentationTime":
        parseValue(attr.value, {
          asKey: "presentationTime",
          parser: parseMPDInteger,
          dashName: "presentationTime"
        });
        break;
      case "duration":
        parseValue(attr.value, {
          asKey: "duration",
          parser: parseMPDInteger,
          dashName: "duration"
        });
        break;
      case "id":
        eventIR.id = attr.value;
        break;
    }
  }
  return [eventIR, warnings];
}
;// CONCATENATED MODULE: ./src/parsers/manifest/dash/js-parser/node_parsers/Period.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * @param {NodeList} periodChildren
 * @returns {Array}
 */
function parsePeriodChildren(periodChildren) {
  var baseURLs = [];
  var adaptations = [];
  var segmentTemplate;
  var warnings = [];
  var eventStreams = [];
  for (var i = 0; i < periodChildren.length; i++) {
    if (periodChildren[i].nodeType === Node.ELEMENT_NODE) {
      var currentElement = periodChildren[i];
      switch (currentElement.nodeName) {
        case "BaseURL":
          var _parseBaseURL = parseBaseURL(currentElement),
            baseURLObj = _parseBaseURL[0],
            baseURLWarnings = _parseBaseURL[1];
          if (baseURLObj !== undefined) {
            baseURLs.push(baseURLObj);
          }
          warnings = warnings.concat(baseURLWarnings);
          break;
        case "AdaptationSet":
          var _createAdaptationSetI = createAdaptationSetIntermediateRepresentation(currentElement),
            adaptation = _createAdaptationSetI[0],
            adaptationWarnings = _createAdaptationSetI[1];
          adaptations.push(adaptation);
          warnings = warnings.concat(adaptationWarnings);
          break;
        case "EventStream":
          var _parseEventStream = parseEventStream(currentElement),
            eventStream = _parseEventStream[0],
            eventStreamWarnings = _parseEventStream[1];
          eventStreams.push(eventStream);
          warnings = warnings.concat(eventStreamWarnings);
          break;
        case "SegmentTemplate":
          var _parseSegmentTemplate = parseSegmentTemplate(currentElement),
            parsedSegmentTemplate = _parseSegmentTemplate[0],
            segmentTemplateWarnings = _parseSegmentTemplate[1];
          segmentTemplate = parsedSegmentTemplate;
          if (segmentTemplateWarnings.length > 0) {
            warnings = warnings.concat(segmentTemplateWarnings);
          }
          break;
      }
    }
  }
  return [{
    baseURLs: baseURLs,
    adaptations: adaptations,
    eventStreams: eventStreams,
    segmentTemplate: segmentTemplate
  }, warnings];
}
/**
 * @param {Element} periodElement
 * @returns {Array}
 */
function parsePeriodAttributes(periodElement) {
  var res = {};
  var warnings = [];
  var parseValue = ValueParser(res, warnings);
  for (var i = 0; i < periodElement.attributes.length; i++) {
    var attr = periodElement.attributes[i];
    switch (attr.name) {
      case "id":
        res.id = attr.value;
        break;
      case "start":
        parseValue(attr.value, {
          asKey: "start",
          parser: parseDuration,
          dashName: "start"
        });
        break;
      case "duration":
        parseValue(attr.value, {
          asKey: "duration",
          parser: parseDuration,
          dashName: "duration"
        });
        break;
      case "bitstreamSwitching":
        parseValue(attr.value, {
          asKey: "bitstreamSwitching",
          parser: parseBoolean,
          dashName: "bitstreamSwitching"
        });
        break;
      case "xlink:href":
        res.xlinkHref = attr.value;
        break;
      case "xlink:actuate":
        res.xlinkActuate = attr.value;
        break;
    }
  }
  return [res, warnings];
}
/**
 * @param {Element} periodElement
 * @returns {Array}
 */
function createPeriodIntermediateRepresentation(periodElement) {
  var _parsePeriodChildren = parsePeriodChildren(periodElement.childNodes),
    children = _parsePeriodChildren[0],
    childrenWarnings = _parsePeriodChildren[1];
  var _parsePeriodAttribute = parsePeriodAttributes(periodElement),
    attributes = _parsePeriodAttribute[0],
    attrsWarnings = _parsePeriodAttribute[1];
  var warnings = childrenWarnings.concat(attrsWarnings);
  return [{
    children: children,
    attributes: attributes
  }, warnings];
}
;// CONCATENATED MODULE: ./src/parsers/manifest/dash/js-parser/node_parsers/MPD.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Parse children of the MPD's root into a simple object.
 * @param {NodeList} mpdChildren
 * @returns {Array.<Object>}
 */
function parseMPDChildren(mpdChildren) {
  var baseURLs = [];
  var locations = [];
  var periods = [];
  var utcTimings = [];
  var warnings = [];
  for (var i = 0; i < mpdChildren.length; i++) {
    if (mpdChildren[i].nodeType === Node.ELEMENT_NODE) {
      var currentNode = mpdChildren[i];
      switch (currentNode.nodeName) {
        case "BaseURL":
          var _parseBaseURL = parseBaseURL(currentNode),
            baseURLObj = _parseBaseURL[0],
            baseURLWarnings = _parseBaseURL[1];
          if (baseURLObj !== undefined) {
            baseURLs.push(baseURLObj);
          }
          warnings = warnings.concat(baseURLWarnings);
          break;
        case "Location":
          locations.push(currentNode.textContent === null ? "" : currentNode.textContent);
          break;
        case "Period":
          var _createPeriodIntermed = createPeriodIntermediateRepresentation(currentNode),
            period = _createPeriodIntermed[0],
            periodWarnings = _createPeriodIntermed[1];
          periods.push(period);
          warnings = warnings.concat(periodWarnings);
          break;
        case "UTCTiming":
          var utcTiming = parseScheme(currentNode);
          utcTimings.push(utcTiming);
          break;
      }
    }
  }
  return [{
    baseURLs: baseURLs,
    locations: locations,
    periods: periods,
    utcTimings: utcTimings
  }, warnings];
}
/**
 * @param {Element} root
 * @returns {Array.<Object>}
 */
function parseMPDAttributes(root) {
  var res = {};
  var warnings = [];
  var parseValue = ValueParser(res, warnings);
  for (var i = 0; i < root.attributes.length; i++) {
    var attribute = root.attributes[i];
    switch (attribute.name) {
      case "id":
        res.id = attribute.value;
        break;
      case "profiles":
        res.profiles = attribute.value;
        break;
      case "type":
        res.type = attribute.value;
        break;
      case "availabilityStartTime":
        parseValue(attribute.value, {
          asKey: "availabilityStartTime",
          parser: parseDateTime,
          dashName: "availabilityStartTime"
        });
        break;
      case "availabilityEndTime":
        parseValue(attribute.value, {
          asKey: "availabilityEndTime",
          parser: parseDateTime,
          dashName: "availabilityEndTime"
        });
        break;
      case "publishTime":
        parseValue(attribute.value, {
          asKey: "publishTime",
          parser: parseDateTime,
          dashName: "publishTime"
        });
        break;
      case "mediaPresentationDuration":
        parseValue(attribute.value, {
          asKey: "duration",
          parser: parseDuration,
          dashName: "mediaPresentationDuration"
        });
        break;
      case "minimumUpdatePeriod":
        parseValue(attribute.value, {
          asKey: "minimumUpdatePeriod",
          parser: parseDuration,
          dashName: "minimumUpdatePeriod"
        });
        break;
      case "minBufferTime":
        parseValue(attribute.value, {
          asKey: "minBufferTime",
          parser: parseDuration,
          dashName: "minBufferTime"
        });
        break;
      case "timeShiftBufferDepth":
        parseValue(attribute.value, {
          asKey: "timeShiftBufferDepth",
          parser: parseDuration,
          dashName: "timeShiftBufferDepth"
        });
        break;
      case "suggestedPresentationDelay":
        parseValue(attribute.value, {
          asKey: "suggestedPresentationDelay",
          parser: parseDuration,
          dashName: "suggestedPresentationDelay"
        });
        break;
      case "maxSegmentDuration":
        parseValue(attribute.value, {
          asKey: "maxSegmentDuration",
          parser: parseDuration,
          dashName: "maxSegmentDuration"
        });
        break;
      case "maxSubsegmentDuration":
        parseValue(attribute.value, {
          asKey: "maxSubsegmentDuration",
          parser: parseDuration,
          dashName: "maxSubsegmentDuration"
        });
        break;
    }
  }
  return [res, warnings];
}
/**
 * @param {Element} root
 * @returns {Array.<Object>}
 */
function createMPDIntermediateRepresentation(root) {
  var _parseMPDChildren = parseMPDChildren(root.childNodes),
    children = _parseMPDChildren[0],
    childrenWarnings = _parseMPDChildren[1];
  var _parseMPDAttributes = parseMPDAttributes(root),
    attributes = _parseMPDAttributes[0],
    attrsWarnings = _parseMPDAttributes[1];
  var warnings = childrenWarnings.concat(attrsWarnings);
  return [{
    children: children,
    attributes: attributes
  }, warnings];
}
;// CONCATENATED MODULE: ./src/parsers/manifest/dash/js-parser/parse_from_document.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * Parse MPD through the JS parser, on a `Document` instance.
 * @param {Document} document - Original manifest as returned by the server
 * @param {Object} args - Various parsing options and information.
 * @returns {Object} - Response returned by the DASH-JS parser.
 */
function parseFromDocument(document, args) {
  var root = document.documentElement;
  if ((0,is_null_or_undefined/* default */.A)(root) || root.nodeName !== "MPD") {
    throw new Error("DASH Parser: document root should be MPD");
  }
  var _createMPDIntermediat = createMPDIntermediateRepresentation(root),
    mpdIR = _createMPDIntermediat[0],
    warnings = _createMPDIntermediat[1];
  var ret = common(mpdIR, args, warnings);
  return processReturn(ret);
  /**
   * Handle `parseMpdIr` return values, asking for resources if they are needed
   * and pre-processing them before continuing parsing.
   *
   * @param {Object} initialRes
   * @returns {Object}
   */
  function processReturn(initialRes) {
    if (initialRes.type === "done") {
      return initialRes;
    } else if (initialRes.type === "needs-clock") {
      return {
        type: "needs-resources",
        value: {
          urls: [initialRes.value.url],
          format: "string",
          "continue": function _continue(loadedClock) {
            if (loadedClock.length !== 1) {
              throw new Error("DASH parser: wrong number of loaded ressources.");
            }
            var newRet = initialRes.value["continue"](loadedClock[0].responseData);
            return processReturn(newRet);
          }
        }
      };
    } else if (initialRes.type === "needs-xlinks") {
      return {
        type: "needs-resources",
        value: {
          urls: initialRes.value.xlinksUrls,
          format: "string",
          "continue": function _continue(loadedXlinks) {
            var resourceInfos = [];
            for (var i = 0; i < loadedXlinks.length; i++) {
              var _loadedXlinks$i = loadedXlinks[i],
                xlinkResp = _loadedXlinks$i.responseData,
                receivedTime = _loadedXlinks$i.receivedTime,
                sendingTime = _loadedXlinks$i.sendingTime,
                url = _loadedXlinks$i.url;
              if (!xlinkResp.success) {
                throw xlinkResp.error;
              }
              var wrappedData = "<root>" + xlinkResp.data + "</root>";
              var dataAsXML = new DOMParser().parseFromString(wrappedData, "text/xml");
              if (dataAsXML == null || dataAsXML.children.length === 0) {
                throw new Error("DASH parser: Invalid external ressources");
              }
              var periods = dataAsXML.children[0].children;
              var periodsIR = [];
              var periodsIRWarnings = [];
              for (var j = 0; j < periods.length; j++) {
                if (periods[j].nodeType === Node.ELEMENT_NODE) {
                  var _createPeriodIntermed = createPeriodIntermediateRepresentation(periods[j]),
                    periodIR = _createPeriodIntermed[0],
                    periodWarnings = _createPeriodIntermed[1];
                  periodsIRWarnings.push.apply(periodsIRWarnings, periodWarnings);
                  periodsIR.push(periodIR);
                }
              }
              resourceInfos.push({
                url: url,
                receivedTime: receivedTime,
                sendingTime: sendingTime,
                parsed: periodsIR,
                warnings: periodsIRWarnings
              });
            }
            var newRet = initialRes.value["continue"](resourceInfos);
            return processReturn(newRet);
          }
        }
      };
    } else {
      (0,assert_unreachable/* default */.A)(initialRes);
    }
  }
}
;// CONCATENATED MODULE: ./src/parsers/manifest/dash/js-parser/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ var js_parser = (parseFromDocument);

/***/ }),

/***/ 5019:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: function() { return /* binding */ clearTimelineFromPosition; }
/* harmony export */ });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Remove segments which starts before the given `firstAvailablePosition` from
 * the timeline. `firstAvailablePosition` has to be time scaled.
 * @param {Array.<Object>}
 * @returns {number} - Returns the number of removed segments. This includes
 * potential implicit segment from decremented `repeatCount` attributes.
 */
function clearTimelineFromPosition(timeline, firstAvailablePosition) {
  var nbEltsRemoved = 0;
  while (timeline.length > 0) {
    var firstElt = timeline[0];
    if (firstElt.start >= firstAvailablePosition) {
      return nbEltsRemoved; // all clear
    }
    if (firstElt.repeatCount === -1) {
      return nbEltsRemoved;
    } else if (firstElt.repeatCount === 0) {
      timeline.shift();
      nbEltsRemoved += 1;
    } else {
      // we have a segment repetition
      var nextElt = timeline[1];
      if (nextElt !== undefined && nextElt.start <= firstAvailablePosition) {
        timeline.shift();
        nbEltsRemoved += 1;
      } else {
        // no next segment or next segment is available
        if (firstElt.duration <= 0) {
          return nbEltsRemoved;
        }
        var nextStart = firstElt.start + firstElt.duration;
        var nextRepeat = 1;
        while (nextStart < firstAvailablePosition && nextRepeat <= firstElt.repeatCount) {
          nextStart += firstElt.duration;
          nextRepeat++;
        }
        if (nextRepeat > firstElt.repeatCount) {
          // every start is before
          timeline.shift();
          nbEltsRemoved = firstElt.repeatCount + 1;
        } else {
          // some repetitions start after and some before
          var newRepeat = firstElt.repeatCount - nextRepeat;
          firstElt.start = nextStart;
          firstElt.repeatCount = newRepeat;
          nbEltsRemoved += nextRepeat;
          return nbEltsRemoved;
        }
      }
    }
  }
  return nbEltsRemoved;
}

/***/ }),

/***/ 3877:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Rb: function() { return /* binding */ getIndexSegmentEnd; },
/* harmony export */   _l: function() { return /* binding */ fromIndexTime; },
/* harmony export */   jX: function() { return /* binding */ getTimescaledRange; },
/* harmony export */   ph: function() { return /* binding */ checkDiscontinuity; },
/* harmony export */   vb: function() { return /* binding */ toIndexTime; },
/* harmony export */   yi: function() { return /* binding */ calculateRepeat; }
/* harmony export */ });
/* harmony import */ var _utils_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6787);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Calculate the number of times a timeline element repeats based on the next
 * element.
 * @param {Object} element
 * @param {Object|null|undefined} nextElement
 * @param {number|undefined} maxPosition
 * @returns {Number}
 */
function calculateRepeat(element, nextElement, maxPosition) {
  var repeatCount = element.repeatCount;
  if (repeatCount >= 0) {
    return repeatCount;
  }
  // A negative value of the @r attribute of the S element indicates
  // that the duration indicated in @d attribute repeats until the
  // start of the next S element, the end of the Period or until the
  // next MPD update.
  var segmentEnd;
  if (!(0,_utils_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(nextElement)) {
    segmentEnd = nextElement.start;
  } else if (maxPosition !== undefined) {
    segmentEnd = maxPosition;
  } else {
    segmentEnd = Number.MAX_VALUE;
  }
  return Math.ceil((segmentEnd - element.start) / element.duration) - 1;
}
/**
 * Returns end of the segment given, in index time.
 * @param {Object} segment
 * @param {Object|null} [nextSegment]
 * @param {number} maxPosition
 * @returns {Number}
 */
function getIndexSegmentEnd(segment, nextSegment, maxPosition) {
  var start = segment.start,
    duration = segment.duration;
  if (duration <= 0) {
    return start;
  }
  var repeat = calculateRepeat(segment, nextSegment, maxPosition);
  return start + (repeat + 1) * duration;
}
/**
 * Convert from `presentationTime`, the time of the segment at the moment it
 * is decoded to `mediaTime`, the original time the segments point at.
 * @param {number} time
 * @param {Object} indexOptions
 * @returns {number}
 */
function toIndexTime(time, indexOptions) {
  var _a;
  return time * indexOptions.timescale + ((_a = indexOptions.indexTimeOffset) !== null && _a !== void 0 ? _a : 0);
}
/**
 * Convert from `mediaTime`, the original time the segments point at to
 * `presentationTime`, the time of the segment at the moment it is decoded.
 * @param {number} time
 * @param {Object} indexOptions
 * @returns {number}
 */
function fromIndexTime(time, indexOptions) {
  var _a;
  return (time - ((_a = indexOptions.indexTimeOffset) !== null && _a !== void 0 ? _a : 0)) / indexOptions.timescale;
}
/**
 * @param {Number} start
 * @param {Number} duration
 * @param {Number} timescale
 * @returns {Object} - Object with two properties:
 *   - up {Number}: timescaled timestamp of the beginning time
 *   - to {Number}: timescaled timestamp of the end time (start time + duration)
 */
function getTimescaledRange(start, duration, timescale) {
  return [start * timescale, (start + duration) * timescale];
}
/**
 * Get index of the last segment in the timeline starting before/at the given
 * timescaled time.
 * Returns -1 if the given time is lower than the start of the first available
 * segment.
 * @param {Object} timeline
 * @param {Number} timeTScaled
 * @returns {Number}
 */
function getIndexOfLastObjectBefore(timeline, timeTScaled) {
  var low = 0;
  var high = timeline.length;
  while (low < high) {
    var mid = low + high >>> 1; // Divide by two + floor
    if (timeline[mid].start <= timeTScaled) {
      low = mid + 1;
    } else {
      high = mid;
    }
  }
  return low - 1;
}
/**
 * @param {Object} index
 * @param {number} timeSec
 * @param {number} [maxPosition]
 * @returns {number|null}
 */
function checkDiscontinuity(index, timeSec, maxPosition) {
  var timeline = index.timeline;
  var scaledTime = toIndexTime(timeSec, index);
  if (scaledTime < 0) {
    return null;
  }
  var segmentIndex = getIndexOfLastObjectBefore(timeline, scaledTime);
  if (segmentIndex < 0 || segmentIndex >= timeline.length - 1) {
    return null;
  }
  var timelineItem = timeline[segmentIndex];
  if (timelineItem.duration <= 0) {
    return null;
  }
  var nextTimelineItem = timeline[segmentIndex + 1];
  if (nextTimelineItem === undefined) {
    return null;
  }
  var nextStart = nextTimelineItem.start;
  var segmentEnd = getIndexSegmentEnd(timelineItem, nextTimelineItem, maxPosition);
  return scaledTime >= segmentEnd && scaledTime < nextStart ? fromIndexTime(nextStart, index) : null;
}

/***/ }),

/***/ 860:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: function() { return /* binding */ updateSegmentTimeline; }
/* harmony export */ });
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5575);
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9477);
/* harmony import */ var _index_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3877);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Update a complete array of segments in a given timeline with a [generally]
 * smaller but [generally] newer set of segments.
 *
 * Returns a boolean:
 *   - If set to `true`, the old timeline was emptied and completely replaced by
 *     the content of the newer timeline.
 *     This could happen either if a problem happened while trying to update or
 *     when the update is actually bigger than what it is updating.
 *   - If set to `false`, the older timeline was either updated to add the newer
 *     segments, or untouched.
 *
 * @param {Array.<Object>} oldTimeline
 * @param {Array.<Object>} newTimeline
 * @returns {boolean}
 */
function updateSegmentTimeline(oldTimeline, newTimeline) {
  if (oldTimeline.length === 0) {
    oldTimeline.push.apply(oldTimeline, newTimeline);
    return true;
  } else if (newTimeline.length === 0) {
    return false;
  }
  var prevTimelineLength = oldTimeline.length;
  var newIndexStart = newTimeline[0].start;
  var oldLastElt = oldTimeline[prevTimelineLength - 1];
  var oldIndexEnd = (0,_index_helpers__WEBPACK_IMPORTED_MODULE_0__/* .getIndexSegmentEnd */ .Rb)(oldLastElt, newTimeline[0]);
  if (oldIndexEnd < newIndexStart) {
    throw new _errors__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A("MANIFEST_UPDATE_ERROR", "Cannot perform partial update: not enough data");
  }
  for (var i = prevTimelineLength - 1; i >= 0; i--) {
    var currStart = oldTimeline[i].start;
    if (currStart === newIndexStart) {
      // replace that one and those after it
      var nbEltsToRemove = prevTimelineLength - i;
      oldTimeline.splice.apply(oldTimeline, [i, nbEltsToRemove].concat(newTimeline));
      return false;
    } else if (currStart < newIndexStart) {
      // first to be before
      var currElt = oldTimeline[i];
      if (currElt.start + currElt.duration > newIndexStart) {
        // The new Manifest overlaps a previous segment (weird)
        // In that improbable case, we'll just completely replace segments
        _log__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A.warn("RepresentationIndex: Manifest update removed all previous segments");
        oldTimeline.splice.apply(oldTimeline, [0, prevTimelineLength].concat(newTimeline));
        return true;
      } else if (currElt.repeatCount === undefined || currElt.repeatCount <= 0) {
        if (currElt.repeatCount < 0) {
          currElt.repeatCount = Math.floor((newIndexStart - currElt.start) / currElt.duration) - 1;
        }
        oldTimeline.splice.apply(oldTimeline, [i + 1, prevTimelineLength - (i + 1)].concat(newTimeline));
        return false;
      }
      // else, there is a positive repeat we might want to update
      var eltLastTime = currElt.start + currElt.duration * (currElt.repeatCount + 1);
      if (eltLastTime <= newIndexStart) {
        // our new index comes directly after
        // put it after this one
        oldTimeline.splice.apply(oldTimeline, [i + 1, prevTimelineLength - (i + 1)].concat(newTimeline));
        return false;
      }
      var newCurrRepeat = (newIndexStart - currElt.start) / currElt.duration - 1;
      if (newCurrRepeat % 1 === 0 && currElt.duration === newTimeline[0].duration) {
        var newRepeatCount = newTimeline[0].repeatCount < 0 ? -1 // === maximum possible repeat
        : newTimeline[0].repeatCount + newCurrRepeat + 1;
        // replace that one and those after it
        oldTimeline.splice.apply(oldTimeline, [i, prevTimelineLength - i].concat(newTimeline));
        oldTimeline[i].start = currElt.start;
        oldTimeline[i].repeatCount = newRepeatCount;
        return false;
      }
      _log__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A.warn("RepresentationIndex: Manifest update removed previous segments");
      oldTimeline[i].repeatCount = Math.floor(newCurrRepeat);
      // put it after this one
      oldTimeline.splice.apply(oldTimeline, [i + 1, prevTimelineLength - (i + 1)].concat(newTimeline));
      return false;
    }
  }
  // if we got here, it means that every segments in the previous manifest are
  // after the new one. This is unusual.
  // Either the new one has more depth or it's an older one.
  var prevLastElt = oldTimeline[oldTimeline.length - 1];
  var newLastElt = newTimeline[newTimeline.length - 1];
  if (prevLastElt.repeatCount !== undefined && prevLastElt.repeatCount < 0) {
    if (prevLastElt.start > newLastElt.start) {
      _log__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A.warn("RepresentationIndex: The new index is older than the previous one");
      return false;
    } else {
      // the new has more depth
      _log__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A.warn('RepresentationIndex: The new index is "bigger" than the previous one');
      oldTimeline.splice.apply(oldTimeline, [0, prevTimelineLength].concat(newTimeline));
      return true;
    }
  }
  var prevLastTime = prevLastElt.start + prevLastElt.duration * (prevLastElt.repeatCount + 1);
  var newLastTime = newLastElt.start + newLastElt.duration * (newLastElt.repeatCount + 1);
  if (prevLastTime >= newLastTime) {
    _log__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A.warn("RepresentationIndex: The new index is older than the previous one");
    return false;
  }
  // the new one has more depth. full update
  _log__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A.warn('RepresentationIndex: The new index is "bigger" than the previous one');
  oldTimeline.splice.apply(oldTimeline, [0, prevTimelineLength].concat(newTimeline));
  return true;
}

/***/ }),

/***/ 9561:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _utils_is_non_empty_string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2384);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// __VERY__ simple SAMI parser, based on ugly-but-working REGEXP:
//   - the text, start and end times are correctly parsed.
//   - only text for the given language is parsed.
//   - only the CSS style associated to the P element is set.
//   - we should be safe for any XSS.
// The language indicated to the parser should be present in the CSS and the
// corresponding Class should be on the P elements. If we fail to find the
// language in a "lang" property of a CSS class, the parser will throw.
/**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */

var HTML_ENTITIES = /&#([0-9]+);/g;
var BR = /<br>/gi;
var STYLE = /<style[^>]*>([\s\S]*?)<\/style[^>]*>/i;
var PARAG = /\s*<p (?:class=([^>]+))?>(.*)/i;
var START = /<sync[^>]+?start="?([0-9]*)"?[^0-9]/i;
/**
 * Returns classnames for every languages.
 * @param {string} str
 * @returns {Object}
 */
function getClassNameByLang(str) {
  var ruleRe = /\.(\S+)\s*{([^}]*)}/gi;
  var langs = {};
  var m = ruleRe.exec(str);
  while (m !== null) {
    var name = m[1];
    var lang = getCSSProperty(m[2], "lang");
    if (name != null && lang != null) {
      langs[lang] = name;
    }
    m = ruleRe.exec(str);
  }
  return langs;
}
/**
 * Returns the rules defined for the P element.
 * Empty string if not found.
 * @param {string} str - The entire styling part.
 * @returns {string}
 */
function getPCSSRules(str) {
  var pRuleRegex = /p\s*{([^}]*)}/gi;
  var rule = pRuleRegex.exec(str);
  if (rule === null) {
    return "";
  }
  return rule[1];
}
/**
 * @param {string} str - entire CSS rule
 * @param {string} name - name of the property
 * @returns {string|null} - value of the property. Null if not found.
 */
function getCSSProperty(str, name) {
  var matches = new RegExp("\\s*" + name + ":\\s*(\\S+);", "i").exec(str);
  return Array.isArray(matches) ? matches[1] : null;
}
/**
 * @param {string} text
 * @returns {string}
 */
function decodeEntities(text) {
  return text.replace(HTML_ENTITIES, function (_, $1) {
    return String.fromCharCode(Number($1));
  });
}
/**
 * Because sami is not really html... we have to use
 * some kind of regular expressions to parse it...
 * the cthulhu way :)
 * The specification being quite clunky, this parser
 * may not work for every sami input.
 *
 * @param {string} smi
 * @param {Number} timeOffset
 * @param {string} lang
 */
function parseSami(smi, timeOffset, lang) {
  var syncOpen = /<sync[ >]/gi;
  var syncClose = /<sync[ >]|<\/body>/gi;
  var subs = [];
  var styleMatches = STYLE.exec(smi);
  var css = Array.isArray(styleMatches) ? styleMatches[1] : "";
  var up;
  var to;
  // FIXME Is that wanted?
  // previously written as let to = SyncClose.exec(smi); but never used
  syncClose.exec(smi);
  var langs = getClassNameByLang(css);
  var pCSS = getPCSSRules(css);
  var klass;
  if ((0,_utils_is_non_empty_string__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(lang)) {
    klass = langs[lang];
    if (klass === undefined) {
      throw new Error("sami: could not find lang " + lang + " in CSS");
    }
  }
  while (true) {
    up = syncOpen.exec(smi);
    to = syncClose.exec(smi);
    if (up === null && to === null) {
      break;
    }
    if (up === null || to === null || up.index >= to.index) {
      throw new Error("parse error");
    }
    var str = smi.slice(up.index, to.index);
    var tim = START.exec(str);
    if (!Array.isArray(tim)) {
      throw new Error("parse error (sync time attribute)");
    }
    var start = +tim[1];
    if (isNaN(start)) {
      throw new Error("parse error (sync time attribute NaN)");
    }
    appendToSubs(str.split("\n"), start / 1000);
  }
  return subs;
  function appendToSubs(lines, start) {
    var i = lines.length;
    while (--i >= 0) {
      var paragraphInfos = PARAG.exec(lines[i]);
      if (!Array.isArray(paragraphInfos)) {
        continue;
      }
      var className = paragraphInfos[1],
        txt = paragraphInfos[2];
      if (klass !== className) {
        continue;
      }
      if (txt === "&nbsp;") {
        subs[subs.length - 1].end = start;
      } else {
        var wrapperEl = document.createElement("DIV");
        wrapperEl.className = "rxp-texttrack-region";
        var divEl = document.createElement("DIV");
        divEl.className = "rxp-texttrack-div";
        divEl.style.position = "absolute";
        divEl.style.bottom = "0";
        divEl.style.width = "100%";
        divEl.style.color = "#fff";
        divEl.style.textShadow = "-1px -1px 0 #000," + "1px -1px 0 #000," + "-1px 1px 0 #000," + "1px 1px 0 #000";
        var pEl = document.createElement("div");
        pEl.className = "rxp-texttrack-p";
        if ((0,_utils_is_non_empty_string__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(pCSS)) {
          pEl.style.cssText = pCSS;
        }
        var textEls = txt.split(BR);
        for (var j = 0; j < textEls.length; j++) {
          if (j !== 0) {
            pEl.appendChild(document.createElement("BR"));
          }
          var spanEl = document.createElement("SPAN");
          spanEl.className = "rxp-texttrack-span";
          spanEl.textContent = decodeEntities(textEls[j]);
          pEl.appendChild(spanEl);
        }
        divEl.appendChild(pEl);
        wrapperEl.appendChild(divEl);
        subs.push({
          element: wrapperEl,
          start: start + timeOffset,
          end: -1 /* Will be updated on a following iteration */
        });
      }
    }
  }
}
/* harmony default export */ __webpack_exports__.A = (parseSami);

/***/ }),

/***/ 7275:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _compat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8068);
/* harmony import */ var _utils_is_non_empty_string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2384);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var HTML_ENTITIES = /&#([0-9]+);/g;
var BR = /<br>/gi;
var STYLE = /<style[^>]*>([\s\S]*?)<\/style[^>]*>/i;
var PARAG = /\s*<p (?:class=([^>]+))?>(.*)/i;
var START = /<sync[^>]+?start="?([0-9]*)"?[^0-9]/i;
/**
 * Creates an array of VTTCue/TextTrackCue from a given array of cue objects.
 * @param {Array.<Object>} cuesArray - Objects containing the start, end and
 * text.
 * @returns {Array.<VTTCue>}
 */
function createCuesFromArray(cuesArray) {
  var nativeCues = [];
  for (var i = 0; i < cuesArray.length; i++) {
    var _cuesArray$i = cuesArray[i],
      start = _cuesArray$i.start,
      end = _cuesArray$i.end,
      text = _cuesArray$i.text;
    if ((0,_utils_is_non_empty_string__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(text) && end != null) {
      var cue = (0,_compat__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(start, end, text);
      if (cue != null) {
        nativeCues.push(cue);
      }
    }
  }
  return nativeCues;
}
/**
 * Returns classnames for every languages.
 * @param {string} str
 * @returns {Object}
 */
function getClassNameByLang(str) {
  var ruleRe = /\.(\S+)\s*{([^}]*)}/gi;
  var langs = {};
  var m = ruleRe.exec(str);
  while (Array.isArray(m)) {
    var name = m[1];
    var lang = getCSSProperty(m[2], "lang");
    if (name != null && lang != null) {
      langs[lang] = name;
    }
    m = ruleRe.exec(str);
  }
  return langs;
}
/**
 * @param {string} str - entire CSS rule
 * @param {string} name - name of the property
 * @returns {string|null} - value of the property. Null if not found.
 */
function getCSSProperty(str, name) {
  var matches = new RegExp("\\s*" + name + ":\\s*(\\S+);", "i").exec(str);
  return Array.isArray(matches) ? matches[1] : null;
}
/**
 * Decode HMTL formatting into a string.
 * @param {string} text
 * @returns {string}
 */
function decodeEntities(text) {
  return text.replace(BR, "\n").replace(HTML_ENTITIES, function (_, $1) {
    return String.fromCharCode(Number($1));
  });
}
/**
 * Because sami is not really html... we have to use
 * some kind of regular expressions to parse it...
 * the cthulhu way :)
 * The specification being quite clunky, this parser
 * may not work for every sami input.
 *
 * @param {string} smi
 * @param {Number} timeOffset
 * @param {string} lang
 * @returns {Array.<VTTCue|TextTrackCue>}
 */
function parseSami(smi, timeOffset, lang) {
  var syncOpen = /<sync[ >]/gi;
  var syncClose = /<sync[ >]|<\/body>/gi;
  var subs = [];
  var styleMatches = STYLE.exec(smi);
  var css = styleMatches !== null ? styleMatches[1] : "";
  var up;
  var to;
  // FIXME Is that wanted?
  // previously written as let to = SyncClose.exec(smi); but never used
  syncClose.exec(smi);
  var langs = getClassNameByLang(css);
  var klass;
  if ((0,_utils_is_non_empty_string__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(lang)) {
    klass = langs[lang];
    if (klass === undefined) {
      throw new Error("sami: could not find lang " + lang + " in CSS");
    }
  }
  while (true) {
    up = syncOpen.exec(smi);
    to = syncClose.exec(smi);
    if (up === null && to === null) {
      break;
    }
    if (up === null || to === null || up.index >= to.index) {
      throw new Error("parse error");
    }
    var str = smi.slice(up.index, to.index);
    var tim = START.exec(str);
    if (tim === null) {
      throw new Error("parse error (sync time attribute)");
    }
    var start = +tim[1];
    if (isNaN(start)) {
      throw new Error("parse error (sync time attribute NaN)");
    }
    appendToSubs(str.split("\n"), start / 1000);
  }
  return createCuesFromArray(subs);
  function appendToSubs(lines, start) {
    var i = lines.length;
    var m;
    while (--i >= 0) {
      m = PARAG.exec(lines[i]);
      if (m === null) {
        continue;
      }
      var _m = m,
        kl = _m[1],
        txt = _m[2];
      if (klass !== kl) {
        continue;
      }
      if (txt === "&nbsp;") {
        subs[subs.length - 1].end = start;
      } else {
        subs.push({
          text: decodeEntities(txt),
          start: start + timeOffset
        });
      }
    }
  }
}
/* harmony default export */ __webpack_exports__.A = (parseSami);

/***/ }),

/***/ 9413:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: function() { return /* binding */ getCueBlocks; }
});

// EXTERNAL MODULE: ./src/utils/is_non_empty_string.ts
var is_non_empty_string = __webpack_require__(2384);
;// CONCATENATED MODULE: ./src/parsers/texttracks/srt/find_end_of_cue_block.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns the first line that is not apart of the given cue block.
 * The index given can be anywhere in a known cue block.
 *
 * This function is extra-resilient due to observed real-life malformed
 * subtitles.
 * Basically, it allows some deviation from the specification as long as the
 * intent is pretty clear.
 * @param {Array<string>} linified - Whole srt. Line by line.
 * @param {number} startIndex - Index in `linified` of the first line within the
 * block.
 * @returns {number}
 */
function findEndOfCueBlock(linified, startIndex) {
  var firstEmptyLineIndex = startIndex + 1;
  // continue incrementing i until either:
  //   - an empty line
  //   - the end
  while ((0,is_non_empty_string/* default */.A)(linified[firstEmptyLineIndex])) {
    firstEmptyLineIndex++;
  }
  return firstEmptyLineIndex;
}
;// CONCATENATED MODULE: ./src/parsers/texttracks/srt/get_cue_blocks.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Get cue blocks from a srt file.
 * @param {Array.<string>} linified - Whole srt file. Each new element in this
 * array is a new line.
 * @returns {Array.<Array.<string>>}
 */
function getCueBlocks(linified) {
  var cueBlocks = [];
  for (var i = 0; i < linified.length; i++) {
    if ((0,is_non_empty_string/* default */.A)(linified[i])) {
      var endOfCue = findEndOfCueBlock(linified, i);
      var cueBlockCandidate = linified.slice(i, endOfCue);
      if (cueBlockCandidate.length > 0) {
        if (cueBlockCandidate.length === 1) {
          if (cueBlockCandidate[0].indexOf("-->") >= 0) {
            cueBlocks.push(cueBlockCandidate);
          }
        } else {
          if (cueBlockCandidate[1].indexOf("-->") >= 0 || cueBlockCandidate[0].indexOf("-->") >= 0) {
            cueBlocks.push(cueBlockCandidate);
          }
        }
      }
      i = endOfCue;
    }
  }
  return cueBlocks;
}

/***/ }),

/***/ 1650:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: function() { return /* binding */ parseSRTStringToHTML; }
/* harmony export */ });
/* harmony import */ var _get_cue_blocks__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9413);
/* harmony import */ var _parse_cue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5842);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */
// Parse SRT subtitles into HTML.
// Done for fun. Understand <b>, <i>, <u> and <font color="#ff0000" /> type
// of tags.


/**
 * @param {string} srtStr
 * @param {Number} timeOffset
 * @returns {Array.<Object>}
 */
function parseSRTStringToHTML(srtStr, timeOffset) {
  // Even if srt only authorize CRLF, we will also take LF or CR as line
  // terminators for resilience
  var lines = srtStr.split(/\r\n|\n|\r/);
  var cueBlocks = (0,_get_cue_blocks__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(lines);
  var cues = [];
  for (var i = 0; i < cueBlocks.length; i++) {
    var cueObject = (0,_parse_cue__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(cueBlocks[i], timeOffset);
    if (cueObject != null) {
      var htmlCue = toHTML(cueObject);
      if (htmlCue != null) {
        cues.push(htmlCue);
      }
    }
  }
  return cues;
}
/**
 * @param {Array.<string>} cueLines
 * @param {Number} timeOffset
 * @returns {Object|null}
 */
function toHTML(cueObj) {
  var start = cueObj.start,
    end = cueObj.end,
    payload = cueObj.payload;
  var pEl = document.createElement("div");
  pEl.className = "rxp-texttrack-p";
  pEl.style.fontSize = "28px";
  pEl.style.position = "absolute";
  pEl.style.bottom = "5%";
  pEl.style.width = "100%";
  pEl.style.textAlign = "center";
  pEl.style.color = "#fff";
  pEl.style.textShadow = "-1px -1px 2px #000," + "1px -1px 2px #000," + "-1px 1px 2px #000," + "1px 1px 2px #000";
  for (var i = 0; i < payload.length; i++) {
    if (i !== 0) {
      pEl.appendChild(document.createElement("br"));
    }
    var span = generateSpansFromSRTText(payload[i]);
    pEl.appendChild(span);
  }
  return {
    start: start,
    end: end,
    element: pEl
  };
}
/**
 * Take a single srt line and convert it into a span with the right style while
 * avoiding XSS.
 * What we do is set a whitelist of authorized tags, and recreate the
 * corresponding tag from scratch.
 * Supported tags:
 *   - <b>: make content bold
 *   - <i>: make content italic
 *   - <u>: draw underline on content
 *   - <font color="x">: add color x to the content
 * @param {string} text
 * @returns {HTMLElement}
 */
function generateSpansFromSRTText(text) {
  var secureDiv = document.createElement("div");
  secureDiv.innerHTML = text;
  var _loop = function _loop(node) {
    var childNodes = node.childNodes;
    var span = document.createElement("span");
    span.className = "rxp-texttrack-span";
    for (var i = 0; i < childNodes.length; i++) {
      var currentNode = childNodes[i];
      if (currentNode.nodeName === "#text") {
        var linifiedText = currentNode.wholeText.split("\n");
        for (var line = 0; line < linifiedText.length; line++) {
          if (line !== 0) {
            span.appendChild(document.createElement("br"));
          }
          if (linifiedText[line].length > 0) {
            var textNode = document.createTextNode(linifiedText[line]);
            span.appendChild(textNode);
          }
        }
      } else if (currentNode.nodeName === "B") {
        var spanChild = _loop(currentNode);
        spanChild.style.fontWeight = "bold";
        span.appendChild(spanChild);
      } else if (currentNode.nodeName === "I") {
        var _spanChild = _loop(currentNode);
        _spanChild.style.fontStyle = "italic";
        span.appendChild(_spanChild);
      } else if (currentNode.nodeName === "U") {
        var _spanChild2 = _loop(currentNode);
        _spanChild2.style.textDecoration = "underline";
        span.appendChild(_spanChild2);
      } else if (isNodeFontWithColorProp(currentNode) && typeof currentNode.color === "string") {
        // TODO loop through attributes to find color?
        var _spanChild3 = _loop(currentNode);
        _spanChild3.style.color = currentNode.color;
        span.appendChild(_spanChild3);
      } else {
        var _spanChild4 = _loop(currentNode);
        span.appendChild(_spanChild4);
      }
    }
    return span;
  };
  return _loop(secureDiv);
}
/**
 * Returns `true` if the given node is a `<font>` element which contains a
 * `color` attribute.
 * @param {Node} node
 * @returns {boolean}
 */
function isNodeFontWithColorProp(node) {
  return node.nodeName === "FONT" && "color" in node;
}

/***/ }),

/***/ 5992:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: function() { return /* binding */ parseSRTStringToVTTCues; }
/* harmony export */ });
/* harmony import */ var _compat_index__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(8068);
/* harmony import */ var _get_cue_blocks__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9413);
/* harmony import */ var _parse_cue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5842);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Parse whole srt file into an array of cues, to be inserted in a video's
 * TrackElement.
 * @param {string} srtStr
 * @param {Number} timeOffset
 * @returns {Array.<VTTCue|TextTrackCue>}
 */
function parseSRTStringToVTTCues(srtStr, timeOffset) {
  // Even if srt only authorize CRLF, we will also take LF or CR as line
  // terminators for resilience
  var lines = srtStr.split(/\r\n|\n|\r/);
  var cueBlocks = (0,_get_cue_blocks__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(lines);
  var cues = [];
  for (var i = 0; i < cueBlocks.length; i++) {
    var cueObject = (0,_parse_cue__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(cueBlocks[i], timeOffset);
    if (cueObject !== null) {
      var nativeCue = toNativeCue(cueObject);
      if (nativeCue !== null) {
        cues.push(nativeCue);
      }
    }
  }
  return cues;
}
/**
 * @param {Object} cue Object
 * @returns {TextTrackCue|VTTCue|null}
 */
function toNativeCue(cueObj) {
  var start = cueObj.start,
    end = cueObj.end,
    payload = cueObj.payload;
  var text = payload.join("\n");
  return (0,_compat_index__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A)(start, end, text);
}

/***/ }),

/***/ 5842:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: function() { return /* binding */ parseCueBlock; }
});

// EXTERNAL MODULE: ./src/utils/is_non_empty_string.ts
var is_non_empty_string = __webpack_require__(2384);
;// CONCATENATED MODULE: ./src/parsers/texttracks/srt/parse_timestamp.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Parse a single srt timestamp into seconds
 * @param {string} timestampString
 * @returns {Number|undefined}
 */
function parseTimestamp(timestampString) {
  var splittedTS = timestampString.split(":");
  if ((0,is_non_empty_string/* default */.A)(splittedTS[2])) {
    var hours = parseInt(splittedTS[0], 10);
    var minutes = parseInt(splittedTS[1], 10);
    var seconds = parseFloat(splittedTS[2].replace(",", "."));
    if (isNaN(hours) || isNaN(minutes) || isNaN(seconds)) {
      return undefined;
    }
    return hours * 60 * 60 + minutes * 60 + seconds;
  }
}
;// CONCATENATED MODULE: ./src/parsers/texttracks/srt/parse_cue.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Parse cue block into a cue object which contains:
 *   - start {number}: the start of the cue as a timestamp in seconds
 *   - end {number}: the end of the cue as a timestamp in seconds
 *   - payload {Array.<string>}: the payload of the cue
 * @param {Array.<string>} cueLines
 * @param {Number} timeOffset
 * @returns {Object}
 */
function parseCueBlock(cueLines, timeOffset) {
  if (cueLines.length === 0) {
    return null;
  }
  var startTimeString;
  var endTimeString;
  var payload = [];
  // normally in srt, the timing is at second position.
  // We still authorize to put it in the first position for resilience
  if ((0,is_non_empty_string/* default */.A)(cueLines[1]) && cueLines[1].indexOf("-->") !== -1) {
    var _cueLines$1$split$map = cueLines[1].split("-->").map(function (s) {
      return s.trim();
    });
    startTimeString = _cueLines$1$split$map[0];
    endTimeString = _cueLines$1$split$map[1];
    payload = cueLines.slice(2, cueLines.length);
  }
  if (!(0,is_non_empty_string/* default */.A)(startTimeString) || !(0,is_non_empty_string/* default */.A)(endTimeString)) {
    // Try to see if we find them in the first position
    var _cueLines$0$split$map = cueLines[0].split("-->").map(function (s) {
      return s.trim();
    });
    startTimeString = _cueLines$0$split$map[0];
    endTimeString = _cueLines$0$split$map[1];
    payload = cueLines.slice(1, cueLines.length);
  }
  if (!(0,is_non_empty_string/* default */.A)(startTimeString) || !(0,is_non_empty_string/* default */.A)(endTimeString)) {
    // if the time is still not found, exit
    return null;
  }
  var start = parseTimestamp(startTimeString);
  var end = parseTimestamp(endTimeString);
  if (start === undefined || end === undefined) {
    return null;
  }
  return {
    start: start + timeOffset,
    end: end + timeOffset,
    payload: payload
  };
}

/***/ }),

/***/ 2632:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   d: function() { return /* binding */ getStylingFromElement; },
/* harmony export */   i: function() { return /* binding */ getStylingAttributes; }
/* harmony export */ });
/* harmony import */ var _utils_array_find__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1729);
/* harmony import */ var _utils_array_includes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4031);
/* harmony import */ var _utils_is_non_empty_string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2384);
/* harmony import */ var _utils_starts_with__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(9828);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Retrieve the attributes given in arguments in the given nodes and their
 * associated style(s)/region.
 * The first notion of the attribute encountered will be taken (by looping
 * through the given nodes in order).
 *
 * TODO manage IDREFS (plural) for styles and regions, that is, multiple one
 * @param {Array.<string>} attributes
 * @param {Array.<Node>} nodes
 * @param {Array.<Object>} styles
 * @param {Array.<Object>} regions
 * @returns {Object}
 */
function getStylingAttributes(attributes, nodes, styles, regions) {
  var currentStyle = {};
  var leftAttributes = attributes.slice();
  var _loop = function _loop() {
      var node = nodes[i];
      if (node !== undefined) {
        var styleID;
        var regionID;
        // 1. the style is directly set on a "tts:" attribute
        if (node.nodeType === Node.ELEMENT_NODE) {
          var element = node;
          for (var j = 0; j <= element.attributes.length - 1; j++) {
            var attribute = element.attributes[j];
            var name = attribute.name;
            if (name === "style") {
              styleID = attribute.value;
            } else if (name === "region") {
              regionID = attribute.value;
            } else {
              var nameWithoutTTS = name.substring(4);
              if ((0,_utils_array_includes__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(leftAttributes, nameWithoutTTS)) {
                currentStyle[nameWithoutTTS] = attribute.value;
                leftAttributes.splice(j, 1);
                if (leftAttributes.length === 0) {
                  return {
                    v: currentStyle
                  };
                }
              }
            }
          }
        }
        // 2. the style is referenced on a "style" attribute
        if ((0,_utils_is_non_empty_string__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(styleID)) {
          var style = (0,_utils_array_find__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A)(styles, function (x) {
            return x.id === styleID;
          });
          if (style !== undefined) {
            for (var _j = 0; _j <= leftAttributes.length - 1; _j++) {
              var _attribute = leftAttributes[_j];
              if (!(0,_utils_is_non_empty_string__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(currentStyle[_attribute])) {
                if ((0,_utils_is_non_empty_string__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(style.style[_attribute])) {
                  currentStyle[_attribute] = style.style[_attribute];
                  leftAttributes.splice(_j, 1);
                  if (leftAttributes.length === 0) {
                    return {
                      v: currentStyle
                    };
                  }
                  _j--;
                }
              }
            }
          }
        }
        // 3. the node reference a region (which can have a value for the
        //    corresponding style)
        if ((0,_utils_is_non_empty_string__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(regionID)) {
          var region = (0,_utils_array_find__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A)(regions, function (x) {
            return x.id === regionID;
          });
          if (region !== undefined) {
            for (var _j2 = 0; _j2 <= leftAttributes.length - 1; _j2++) {
              var _attribute2 = leftAttributes[_j2];
              if (!(0,_utils_is_non_empty_string__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(currentStyle[_attribute2])) {
                if ((0,_utils_is_non_empty_string__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(region.style[_attribute2])) {
                  currentStyle[_attribute2] = region.style[_attribute2];
                  leftAttributes.splice(_j2, 1);
                  if (leftAttributes.length === 0) {
                    return {
                      v: currentStyle
                    };
                  }
                  _j2--;
                }
              }
            }
          }
        }
      }
    },
    _ret;
  for (var i = 0; i <= nodes.length - 1; i++) {
    _ret = _loop();
    if (_ret) return _ret.v;
  }
  return currentStyle;
}
/**
 * Returns the styling directly linked to an element.
 * @param {Node} node
 * @returns {Object}
 */
function getStylingFromElement(node) {
  if (node.nodeType !== Node.ELEMENT_NODE) {
    return {};
  }
  var element = node;
  var currentStyle = {};
  for (var i = 0; i <= element.attributes.length - 1; i++) {
    var styleAttribute = element.attributes[i];
    if ((0,_utils_starts_with__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A)(styleAttribute.name, "tts")) {
      var nameWithoutTTS = styleAttribute.name.substring(4);
      currentStyle[nameWithoutTTS] = styleAttribute.value;
    }
  }
  return currentStyle;
}

/***/ }),

/***/ 9750:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: function() { return /* binding */ getTimeDelimiters; }
});

// EXTERNAL MODULE: ./src/utils/is_non_empty_string.ts
var is_non_empty_string = __webpack_require__(2384);
// EXTERNAL MODULE: ./src/parsers/texttracks/ttml/regexps.ts
var regexps = __webpack_require__(8623);
;// CONCATENATED MODULE: ./src/parsers/texttracks/ttml/time_parsing.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Parses a TTML time into seconds.
 * @param {string} text
 * @param {Object} ttParams
 * @returns {Number|undefined}
 */
function parseTime(text, ttParams) {
  if (regexps/* REGXP_TIME_COLON_FRAMES */.Cn.test(text)) {
    return parseColonTimeWithFrames(ttParams, text);
  } else if (regexps/* REGXP_TIME_COLON */.lP.test(text)) {
    return parseTimeFromRegExp(regexps/* REGXP_TIME_COLON */.lP, text);
  } else if (regexps/* REGXP_TIME_COLON_MS */.uA.test(text)) {
    return parseTimeFromRegExp(regexps/* REGXP_TIME_COLON_MS */.uA, text);
  } else if (regexps/* REGXP_TIME_FRAMES */.s_.test(text)) {
    return parseFramesTime(ttParams, text);
  } else if (regexps/* REGXP_TIME_TICK */.Nm.test(text)) {
    return parseTickTime(ttParams, text);
  } else if (regexps/* REGXP_TIME_HMS */.QF.test(text)) {
    return parseTimeFromRegExp(regexps/* REGXP_TIME_HMS */.QF, text);
  }
}
/**
 * Parses a TTML time in frame format
 * @param {Object} ttParams
 * @param {string} text
 * @returns {Number}
 */
function parseFramesTime(ttParams, text) {
  // 75f or 75.5f
  // (We cast as we're sure the regexp is respected here)
  var results = regexps/* REGXP_TIME_FRAMES */.s_.exec(text);
  var frames = Number(results[1]);
  return frames / ttParams.frameRate;
}
/**
 * Parses a TTML time in tick format
 * @param {Object} ttParams
 * @param {string} text
 * @returns {Number}
 */
function parseTickTime(ttParams, text) {
  // 50t or 50.5t
  // (We cast as we're sure the regexp is respected here)
  var results = regexps/* REGXP_TIME_TICK */.Nm.exec(text);
  var ticks = Number(results[1]);
  return ticks / ttParams.tickRate;
}
/**
 * Parses a TTML colon formatted time containing frames
 * @param {Object} ttParams
 * @param {string} text
 * @returns {Number}
 */
function parseColonTimeWithFrames(ttParams, text) {
  // 01:02:43:07 ("07" is frames) or 01:02:43:07.1 (subframes)
  // (We cast as we're sure the regexp is respected here)
  var results = regexps/* REGXP_TIME_COLON_FRAMES */.Cn.exec(text);
  var hours = Number(results[1]);
  var minutes = Number(results[2]);
  var seconds = Number(results[3]);
  var frames = Number(results[4]);
  var subframes = Number(results[5]);
  if (isNaN(subframes)) {
    subframes = 0;
  }
  frames += subframes / ttParams.subFrameRate;
  seconds += frames / ttParams.frameRate;
  return seconds + minutes * 60 + hours * 3600;
}
/**
 * Parses a TTML time with a given regex. Expects regex to be some
 * sort of a time-matcher to match hours, minutes, seconds and milliseconds
 *
 * @param {RegExp} regex
 * @param {string} text
 * @returns {number|null}
 */
function parseTimeFromRegExp(regex, text) {
  var results = regex.exec(text);
  if (results === null || results[0] === "") {
    return null;
  }
  // This capture is optional, but will still be in the array as undefined,
  // default to 0.
  var hours = Number(results[1]);
  if (isNaN(hours)) {
    hours = 0;
  }
  var minutes = Number(results[2]);
  if (isNaN(minutes)) {
    minutes = 0;
  }
  var seconds = Number(results[3]);
  if (isNaN(seconds)) {
    seconds = 0;
  }
  var milliseconds = Number(results[4]);
  if (isNaN(milliseconds)) {
    milliseconds = 0;
  }
  return milliseconds / 1000 + seconds + minutes * 60 + hours * 3600;
}
/* harmony default export */ var time_parsing = (parseTime);
;// CONCATENATED MODULE: ./src/parsers/texttracks/ttml/get_time_delimiters.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Get start and end time of an element.
 * @param {Element} element
 * @param {Object} ttParams
 * @returns {Object}
 */
function getTimeDelimiters(element, ttParams) {
  var beginAttr = element.getAttribute("begin");
  var durationAttr = element.getAttribute("dur");
  var endAttr = element.getAttribute("end");
  var start = (0,is_non_empty_string/* default */.A)(beginAttr) ? time_parsing(beginAttr, ttParams) : null;
  var duration = (0,is_non_empty_string/* default */.A)(durationAttr) ? time_parsing(durationAttr, ttParams) : null;
  var parsedEnd = (0,is_non_empty_string/* default */.A)(endAttr) ? time_parsing(endAttr, ttParams) : null;
  if (start == null || parsedEnd == null && duration == null) {
    throw new Error("Invalid text cue");
  }
  // Huh? Is TypeScript that dumb here?
  var end = parsedEnd == null ? start + duration : parsedEnd;
  return {
    start: start,
    end: end
  };
}

/***/ }),

/***/ 8342:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: function() { return /* binding */ html; }
});

// EXTERNAL MODULE: ./src/parsers/texttracks/ttml/parse_ttml.ts + 2 modules
var parse_ttml = __webpack_require__(3487);
;// CONCATENATED MODULE: ./src/parsers/texttracks/ttml/html/apply_default_ttml_paragraph_style.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Return true if no style has been already declared and no conflict is
 * detected with current cue style.
 *
 * No position, orientation and dimension style should have been set to
 * avoid any conflict.
 * @param {object} paragraphStyle
 * @returns {boolean}
 */
function shouldApplyDefaultTTMLStyle(paragraphStyle) {
  return paragraphStyle.extent === undefined && paragraphStyle.origin === undefined && paragraphStyle.displayAlign === undefined && paragraphStyle.display === undefined && paragraphStyle.textAlign === undefined && paragraphStyle.fontSize === undefined;
}
/**
 * Apply a default style to TTML cue.
 *
 * The default style propose to set the cue at the bottom, centered
 * and lightly spaced apart from the edges :
 *
 *        -----------------------------------------------
 *        |                                             |
 *        |                                             |
 *        |                                             |
 *        |                                             |
 *        |                                             |
 *        |                                             |
 *        |            subtitle is displayed            |
 *        |                    here                     |
 *        -----------------------------------------------
 *
 * @param {Object} cue
 * TODO This code can be seen as risky because we might not predict every
 * possible styles that can enter in conflict.
 * A better solution should be found in the future
 */
function applyDefaultTTMLStyle(paragraphStyle) {
  paragraphStyle.extent = "70% 20%";
  paragraphStyle.fontSize = "1c";
  paragraphStyle.origin = "15% 80%";
  paragraphStyle.displayAlign = "before";
  paragraphStyle.textAlign = "center";
}
// EXTERNAL MODULE: ./src/parsers/texttracks/ttml/get_time_delimiters.ts + 1 modules
var get_time_delimiters = __webpack_require__(9750);
;// CONCATENATED MODULE: ./src/compat/add_class_name.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var hasClassList;
/**
 * Add className to an HTMLElement. Do nothing if the className was already
 * added.
 * @param {HTMLElement} elt
 * @param {string} className
 */
function addClassName(elt, className) {
  if (hasClassList === undefined) {
    hasClassList = elt.classList !== undefined && /* eslint-disable @typescript-eslint/unbound-method */
    typeof elt.classList.add === "function";
    /* eslint-enable @typescript-eslint/unbound-method */
  }
  if (hasClassList) {
    elt.classList.add(className);
  } else {
    var classNamesWithSpaces = " " + elt.className + " ";
    if (classNamesWithSpaces.indexOf(" " + className + " ") < 0) {
      elt.className += " " + className;
    }
  }
}
// EXTERNAL MODULE: ./src/utils/is_non_empty_string.ts
var is_non_empty_string = __webpack_require__(2384);
// EXTERNAL MODULE: ./src/utils/object_assign.ts
var object_assign = __webpack_require__(8935);
// EXTERNAL MODULE: ./src/parsers/texttracks/ttml/get_styling.ts
var get_styling = __webpack_require__(2632);
// EXTERNAL MODULE: ./src/parsers/texttracks/ttml/xml_utils.ts
var xml_utils = __webpack_require__(4666);
// EXTERNAL MODULE: ./src/log.ts + 1 modules
var log = __webpack_require__(9477);
// EXTERNAL MODULE: ./src/parsers/texttracks/ttml/regexps.ts
var regexps = __webpack_require__(8623);
;// CONCATENATED MODULE: ./src/parsers/texttracks/ttml/html/apply_extent.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Apply `tts:extent` styling to an HTML element.
 * @param {HTMLElement} element
 * @param {string} extent
 */
function applyExtent(element, extent) {
  var trimmedExtent = extent.trim();
  if (trimmedExtent === "auto") {
    return;
  }
  var splittedExtent = trimmedExtent.split(" ");
  if (splittedExtent.length !== 2) {
    return;
  }
  var firstExtent = regexps/* REGXP_LENGTH */.iP.exec(splittedExtent[0]);
  var secondExtent = regexps/* REGXP_LENGTH */.iP.exec(splittedExtent[1]);
  if (firstExtent !== null && secondExtent !== null) {
    if (firstExtent[2] === "px" || firstExtent[2] === "%" || firstExtent[2] === "em") {
      element.style.width = firstExtent[1] + firstExtent[2];
    } else if (firstExtent[2] === "c") {
      addClassName(element, "proportional-style");
      element.setAttribute("data-proportional-width", firstExtent[1]);
    } else {
      log/* default */.A.warn("TTML Parser: unhandled extent unit:", firstExtent[2]);
    }
    if (secondExtent[2] === "px" || secondExtent[2] === "%" || secondExtent[2] === "em") {
      element.style.height = secondExtent[1] + secondExtent[2];
    } else if (secondExtent[2] === "c") {
      addClassName(element, "proportional-style");
      element.setAttribute("data-proportional-height", secondExtent[1]);
    } else {
      log/* default */.A.warn("TTML Parser: unhandled extent unit:", secondExtent[2]);
    }
  }
}
;// CONCATENATED MODULE: ./src/parsers/texttracks/ttml/html/apply_font_size.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Apply `tts:fontSize` styling to an HTML element.
 * @param {HTMLElement} element
 * @param {string} fontSize
 */
function applyFontSize(element, fontSize) {
  var trimmedFontSize = fontSize.trim();
  var splittedFontSize = trimmedFontSize.split(" ");
  if (splittedFontSize.length === 0) {
    return;
  }
  var firstFontSize = regexps/* REGXP_LENGTH */.iP.exec(splittedFontSize[0]);
  if (firstFontSize === null) {
    return;
  }
  if (firstFontSize[2] === "px" || firstFontSize[2] === "em") {
    element.style.fontSize = firstFontSize[1] + firstFontSize[2];
  } else if (firstFontSize[2] === "c") {
    element.style.position = "relative";
    addClassName(element, "proportional-style");
    element.setAttribute("data-proportional-font-size", firstFontSize[1]);
  } else if (firstFontSize[2] === "%") {
    var toNum = Number(firstFontSize[1]);
    if (isNaN(toNum)) {
      log/* default */.A.warn('TTML Parser: could not parse fontSize value "' + firstFontSize[1] + '" into a number');
    } else {
      element.style.position = "relative";
      addClassName(element, "proportional-style");
      element.setAttribute("data-proportional-font-size", String(toNum / 100));
    }
  } else {
    log/* default */.A.warn("TTML Parser: unhandled fontSize unit:", firstFontSize[2]);
  }
}
;// CONCATENATED MODULE: ./src/parsers/texttracks/ttml/html/apply_line_height.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * @param {HTMLElement} element
 * @param {string} lineHeight
 */
function applyLineHeight(element, lineHeight) {
  var trimmedLineHeight = lineHeight.trim();
  var splittedLineHeight = trimmedLineHeight.split(" ");
  if (trimmedLineHeight === "auto") {
    return;
  }
  var firstLineHeight = regexps/* REGXP_LENGTH */.iP.exec(splittedLineHeight[0]);
  if (firstLineHeight === null) {
    return;
  }
  if (firstLineHeight[2] === "px" || firstLineHeight[2] === "%" || firstLineHeight[2] === "em") {
    element.style.lineHeight = firstLineHeight[1] + firstLineHeight[2];
  } else if (firstLineHeight[2] === "c") {
    addClassName(element, "proportional-style");
    element.setAttribute("data-proportional-line-height", firstLineHeight[1]);
  } else {
    log/* default */.A.warn("TTML Parser: unhandled lineHeight unit:", firstLineHeight[2]);
  }
}
;// CONCATENATED MODULE: ./src/parsers/texttracks/ttml/html/apply_origin.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * @param {HTMLElement} element
 * @param {string} origin
 */
function applyOrigin(element, origin) {
  var trimmedOrigin = origin.trim();
  if (trimmedOrigin === "auto") {
    return;
  }
  var splittedOrigin = trimmedOrigin.split(" ");
  if (splittedOrigin.length !== 2) {
    return;
  }
  var firstOrigin = regexps/* REGXP_LENGTH */.iP.exec(splittedOrigin[0]);
  var secondOrigin = regexps/* REGXP_LENGTH */.iP.exec(splittedOrigin[1]);
  if (firstOrigin !== null && secondOrigin !== null) {
    if (firstOrigin[2] === "px" || firstOrigin[2] === "%" || firstOrigin[2] === "em") {
      element.style.left = firstOrigin[1] + firstOrigin[2];
    } else if (firstOrigin[2] === "c") {
      addClassName(element, "proportional-style");
      element.setAttribute("data-proportional-left", firstOrigin[1]);
    } else {
      log/* default */.A.warn("TTML Parser: unhandled origin unit:", firstOrigin[2]);
    }
    if (secondOrigin[2] === "px" || secondOrigin[2] === "%" || secondOrigin[2] === "em") {
      element.style.top = secondOrigin[1] + secondOrigin[2];
    } else if (secondOrigin[2] === "c") {
      addClassName(element, "proportional-style");
      element.setAttribute("data-proportional-top", secondOrigin[1]);
    } else {
      log/* default */.A.warn("TTML Parser: unhandled origin unit:", secondOrigin[2]);
    }
  }
}
;// CONCATENATED MODULE: ./src/parsers/texttracks/ttml/html/apply_padding.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * @param {HTMLElement} element
 * @param {string} padding
 */
function applyPadding(element, padding) {
  var trimmedPadding = padding.trim();
  var splittedPadding = trimmedPadding.split(" ");
  if (splittedPadding.length < 1) {
    return;
  }
  var firstPadding = regexps/* REGXP_LENGTH */.iP.exec(splittedPadding[0]);
  if (firstPadding === null) {
    return;
  }
  if (firstPadding[2] === "px" || firstPadding[2] === "%" || firstPadding[2] === "em") {
    var firstPaddingValue = firstPadding[1] + firstPadding[2];
    if (splittedPadding.length === 1) {
      element.style.padding = firstPaddingValue;
    } else if (splittedPadding.length === 2) {
      element.style.paddingTop = firstPaddingValue;
      element.style.paddingBottom = firstPaddingValue;
    } else {
      element.style.paddingTop = firstPaddingValue;
    }
  } else if (firstPadding[2] === "c") {
    addClassName(element, "proportional-style");
    if (splittedPadding.length === 1) {
      element.setAttribute("data-proportional-padding-top", firstPadding[1]);
      element.setAttribute("data-proportional-padding-bottom", firstPadding[1]);
      element.setAttribute("data-proportional-padding-left", firstPadding[1]);
      element.setAttribute("data-proportional-padding-right", firstPadding[1]);
    } else if (splittedPadding.length === 2) {
      element.setAttribute("data-proportional-padding-top", firstPadding[1]);
      element.setAttribute("data-proportional-padding-bottom", firstPadding[1]);
    } else {
      element.setAttribute("data-proportional-padding-top", firstPadding[1]);
    }
  } else {
    log/* default */.A.warn("TTML Parser: unhandled padding unit:", firstPadding[2]);
  }
  if (splittedPadding.length === 1) {
    return;
  }
  var secondPadding = regexps/* REGXP_LENGTH */.iP.exec(splittedPadding[1]);
  if (secondPadding === null) {
    return;
  }
  if (secondPadding[2] === "px" || secondPadding[2] === "%" || secondPadding[2] === "em") {
    var secondPaddingValue = secondPadding[1] + secondPadding[2];
    if (splittedPadding.length < 4) {
      element.style.paddingLeft = secondPaddingValue;
      element.style.paddingRight = secondPaddingValue;
    } else {
      element.style.paddingRight = secondPaddingValue;
    }
  } else if (secondPadding[2] === "c") {
    addClassName(element, "proportional-style");
    if (splittedPadding.length < 4) {
      element.setAttribute("data-proportional-padding-left", secondPadding[1]);
      element.setAttribute("data-proportional-padding-right", secondPadding[1]);
    } else {
      element.setAttribute("data-proportional-padding-right", secondPadding[1]);
    }
  } else {
    log/* default */.A.warn("TTML Parser: unhandled padding unit:", secondPadding[2]);
  }
  if (splittedPadding.length === 2) {
    return;
  }
  var thirdPadding = regexps/* REGXP_LENGTH */.iP.exec(splittedPadding[2]);
  if (thirdPadding === null) {
    return;
  }
  if (thirdPadding[2] === "px" || thirdPadding[2] === "%" || thirdPadding[2] === "em") {
    var thirdPaddingValue = thirdPadding[1] + thirdPadding[2];
    element.style.paddingBottom = thirdPaddingValue;
  } else if (thirdPadding[2] === "c") {
    addClassName(element, "proportional-style");
    element.setAttribute("data-proportional-padding-bottom", thirdPadding[1]);
  } else {
    log/* default */.A.warn("TTML Parser: unhandled padding unit:", thirdPadding[2]);
  }
  if (splittedPadding.length === 3) {
    return;
  }
  var fourthPadding = regexps/* REGXP_LENGTH */.iP.exec(splittedPadding[3]);
  if (fourthPadding === null) {
    return;
  }
  if (fourthPadding[2] === "px" || fourthPadding[2] === "%" || fourthPadding[2] === "em") {
    var fourthPaddingValue = fourthPadding[1] + fourthPadding[2];
    element.style.paddingLeft = fourthPaddingValue;
  } else if (fourthPadding[2] === "c") {
    addClassName(element, "proportional-style");
    element.setAttribute("data-proportional-padding-left", fourthPadding[1]);
  } else {
    log/* default */.A.warn("TTML Parser: unhandled padding unit:", fourthPadding[2]);
  }
}
;// CONCATENATED MODULE: ./src/parsers/texttracks/ttml/html/generate_css_test_outline.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Try to replicate the textOutline TTML style property into CSS.
 *
 * We mock it throught the text-shadow property, translating the TTML thickness
 * into blur radius and the blur-radius into... nothing.
 *
 * @param {string} color
 * @param {string|number} thickness
 * @returns {string}
 */
function generateCSSTextOutline(color, thickness) {
  var thick = thickness;
  if ((0,is_non_empty_string/* default */.A)(thickness) && thickness.trim().endsWith("%")) {
    // As em and % are basically equivalent in CSS
    // (they both are relative to the font-size
    // of the current element)
    // We convert the non supported % into the supported em
    thick = thickness.trim().slice(0, -1);
    thick = (parseInt(thick, 10) / 100).toString() + "em";
  }
  return "-1px -1px " + thick + " " + color + "," + ("1px -1px " + thick + " " + color + ",") + ("-1px 1px " + thick + " " + color + ",") + ("1px 1px " + thick + " " + color);
}
;// CONCATENATED MODULE: ./src/parsers/texttracks/ttml/html/ttml_color_to_css_color.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Translate a color indicated in TTML-style to a CSS-style color.
 * @param {string} color
 * @returns {string} color
 */
function ttmlColorToCSSColor(color) {
  // TODO check all possible color fomats
  var regRes;
  regRes = regexps/* REGXP_8_HEX_COLOR */.UR.exec(color);
  if (regRes != null) {
    return "rgba(" + String(parseInt(regRes[1], 16)) + "," + String(parseInt(regRes[2], 16)) + "," + String(parseInt(regRes[3], 16)) + "," + String(parseInt(regRes[4], 16) / 255) + ")";
  }
  regRes = regexps/* REGXP_4_HEX_COLOR */.Ce.exec(color);
  if (regRes != null) {
    return "rgba(" + String(parseInt(regRes[1] + regRes[1], 16)) + "," + String(parseInt(regRes[2] + regRes[2], 16)) + "," + String(parseInt(regRes[3] + regRes[3], 16)) + "," + String(parseInt(regRes[4] + regRes[4], 16) / 255) + ")";
  }
  regRes = regexps/* REGXP_RGB_COLOR */.PL.exec(color);
  if (regRes != null) {
    return "rgb(" + String(+regRes[1]) + "," + String(+regRes[2]) + "," + String(+regRes[3]) + ")";
  }
  regRes = regexps/* REGXP_RGBA_COLOR */._Y.exec(color);
  if (regRes != null) {
    return "rgba(" + String(+regRes[1]) + "," + String(+regRes[2]) + "," + String(+regRes[3]) + "," + String(+regRes[4] / 255) + ")";
  }
  return color;
}
;// CONCATENATED MODULE: ./src/parsers/texttracks/ttml/html/create_element.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */












// Styling which can be applied to <span> from any level upper.
// Added here as an optimization
var SPAN_LEVEL_ATTRIBUTES = ["color", "direction", "display", "fontFamily", "fontSize", "fontStyle", "fontWeight", "textDecoration", "textOutline", "unicodeBidi", "visibility", "wrapOption"];
// TODO
// tts:showBackground (applies to region)
// tts:zIndex (applies to region)
/**
 * Apply style set for a singular text span of the current cue.
 * @param {HTMLElement} element - The text span
 * @param {Object} style - The style to apply
 */
function applyTextStyle(element, style, shouldTrimWhiteSpace) {
  // applies to span
  var color = style.color;
  if ((0,is_non_empty_string/* default */.A)(color)) {
    element.style.color = ttmlColorToCSSColor(color);
  }
  // applies to body, div, p, region, span
  var backgroundColor = style.backgroundColor;
  if ((0,is_non_empty_string/* default */.A)(backgroundColor)) {
    element.style.backgroundColor = ttmlColorToCSSColor(backgroundColor);
  }
  // applies to span
  var textOutline = style.textOutline;
  if ((0,is_non_empty_string/* default */.A)(textOutline)) {
    var outlineData = textOutline.trim().replace(/\s+/g, " ").split(" ");
    var len = outlineData.length;
    if (len === 3) {
      var outlineColor = ttmlColorToCSSColor(outlineData[0]);
      var thickness = outlineData[1];
      element.style.textShadow = generateCSSTextOutline(outlineColor, thickness);
    } else if ((0,is_non_empty_string/* default */.A)(color) && len === 1) {
      var _thickness = outlineData[0];
      element.style.textShadow = generateCSSTextOutline(color, _thickness);
    } else if (len === 2) {
      var isFirstArgAColor = /^[#A-Z]/i.test(outlineData[0]);
      var isFirstArgANumber = /^[0-9]/.test(outlineData[0]);
      // XOR-ing to be sure we get what we have
      if (isFirstArgAColor !== isFirstArgANumber) {
        if (isFirstArgAColor) {
          var _outlineColor = ttmlColorToCSSColor(outlineData[0]);
          var _thickness2 = outlineData[1];
          element.style.textShadow = generateCSSTextOutline(_outlineColor, _thickness2);
        } else if ((0,is_non_empty_string/* default */.A)(color)) {
          var _thickness3 = outlineData[0];
          element.style.textShadow = generateCSSTextOutline(color, _thickness3);
        }
      }
    }
  }
  // applies to span
  var textDecoration = style.textDecoration;
  if ((0,is_non_empty_string/* default */.A)(textDecoration)) {
    switch (textDecoration) {
      case "noUnderline":
      case "noLineThrough":
      case "noOverline":
        element.style.textDecoration = "none";
        break;
      case "lineThrough":
        element.style.textDecoration = "line-through";
        break;
      default:
        element.style.textDecoration = textDecoration;
        break;
    }
  }
  // applies to span
  var fontFamily = style.fontFamily;
  if ((0,is_non_empty_string/* default */.A)(fontFamily)) {
    switch (fontFamily) {
      case "proportionalSansSerif":
        element.style.fontFamily = "Arial, Helvetica, Liberation Sans, sans-serif";
        break;
      // TODO monospace or sans-serif or font with both?
      case "monospaceSansSerif":
      case "sansSerif":
        element.style.fontFamily = "sans-serif";
        break;
      case "monospaceSerif":
      case "default":
        element.style.fontFamily = "Courier New, Liberation Mono, monospace";
        break;
      // TODO font with both?
      case "proportionalSerif":
        element.style.fontFamily = "serif";
        break;
      default:
        element.style.fontFamily = fontFamily;
    }
  }
  // applies to span
  var fontStyle = style.fontStyle;
  if ((0,is_non_empty_string/* default */.A)(fontStyle)) {
    element.style.fontStyle = fontStyle;
  }
  // applies to span
  var fontWeight = style.fontWeight;
  if ((0,is_non_empty_string/* default */.A)(fontWeight)) {
    element.style.fontWeight = fontWeight;
  }
  // applies to span
  var fontSize = style.fontSize;
  if ((0,is_non_empty_string/* default */.A)(fontSize)) {
    applyFontSize(element, fontSize);
  } else {
    addClassName(element, "proportional-style");
    element.setAttribute("data-proportional-font-size", "1");
  }
  // applies to p, span
  var direction = style.direction;
  if ((0,is_non_empty_string/* default */.A)(direction)) {
    element.style.direction = direction;
  }
  // applies to p, span
  var unicodeBidi = style.unicodeBidi;
  if ((0,is_non_empty_string/* default */.A)(unicodeBidi)) {
    switch (unicodeBidi) {
      case "bidiOverride":
        element.style.unicodeBidi = "bidi-override";
        break;
      case "embed":
        element.style.unicodeBidi = "embed";
        break;
      default:
        element.style.unicodeBidi = "normal";
    }
  }
  // applies to body, div, p, region, span
  var visibility = style.visibility;
  if ((0,is_non_empty_string/* default */.A)(visibility)) {
    element.style.visibility = visibility;
  }
  // applies to body, div, p, region, span
  var display = style.display;
  if (display === "none") {
    element.style.display = "none";
  }
  // applies to body, div, p, region, span
  var wrapOption = style.wrapOption;
  element.style.whiteSpace = wrapOption === "noWrap" ? shouldTrimWhiteSpace ? "nowrap" : "pre" : shouldTrimWhiteSpace ? "normal" : "pre-wrap";
}
/**
 * Apply style for the general text track div.
 * @param {HTMLElement} element - The <div> the style will be applied on.
 * @param {Object} style - The general style object of the paragraph.
 */
function applyGeneralStyle(element, style) {
  // Set default text color. It can be overrided by text element color.
  element.style.color = "white";
  element.style.position = "absolute";
  // applies to tt, region
  var extent = style.extent;
  if ((0,is_non_empty_string/* default */.A)(extent)) {
    applyExtent(element, extent);
  }
  // applies to region
  var writingMode = style.writingMode;
  if ((0,is_non_empty_string/* default */.A)(writingMode)) {
    // TODO
  }
  // applies to region
  var overflow = style.overflow;
  element.style.overflow = (0,is_non_empty_string/* default */.A)(overflow) ? overflow : "hidden";
  // applies to region
  var padding = style.padding;
  if ((0,is_non_empty_string/* default */.A)(padding)) {
    applyPadding(element, padding);
  }
  // applies to region
  var origin = style.origin;
  if ((0,is_non_empty_string/* default */.A)(origin)) {
    applyOrigin(element, origin);
  }
  // applies to region
  var displayAlign = style.displayAlign;
  if ((0,is_non_empty_string/* default */.A)(displayAlign)) {
    element.style.display = "flex";
    element.style.flexDirection = "column";
    switch (displayAlign) {
      case "before":
        element.style.justifyContent = "flex-start";
        break;
      case "center":
        element.style.justifyContent = "center";
        break;
      case "after":
        element.style.justifyContent = "flex-end";
        break;
    }
  }
  // applies to region
  var opacity = style.opacity;
  if ((0,is_non_empty_string/* default */.A)(opacity)) {
    element.style.opacity = opacity;
  }
  // applies to body, div, p, region, span
  var visibility = style.visibility;
  if ((0,is_non_empty_string/* default */.A)(visibility)) {
    element.style.visibility = visibility;
  }
  // applies to body, div, p, region, span
  var display = style.display;
  if (display === "none") {
    element.style.display = "none";
  }
}
/**
 * Apply style set for a <p> element
 * @param {HTMLElement} element - The <p> element
 * @param {Object} style - The general style object of the paragraph.
 */
function applyPStyle(element, style) {
  element.style.margin = "0px";
  // Set on it the default font-size, more specific font sizes may then be set
  // on children elements.
  // Doing this on the parent <p> elements seems to fix some CSS issues we had
  // with too large inner line breaks spacing when the text track element was
  // too small, for some reasons.
  addClassName(element, "proportional-style");
  element.setAttribute("data-proportional-font-size", "1");
  // applies to body, div, p, region, span
  var paragraphBackgroundColor = style.backgroundColor;
  if ((0,is_non_empty_string/* default */.A)(paragraphBackgroundColor)) {
    element.style.backgroundColor = ttmlColorToCSSColor(paragraphBackgroundColor);
  }
  // applies to p
  var lineHeight = style.lineHeight;
  if ((0,is_non_empty_string/* default */.A)(lineHeight)) {
    applyLineHeight(element, lineHeight);
  }
  // applies to p
  var textAlign = style.textAlign;
  if ((0,is_non_empty_string/* default */.A)(textAlign)) {
    switch (textAlign) {
      case "center":
        element.style.textAlign = "center";
        break;
      case "left":
      case "start":
        // TODO check what start means (difference with left, writing direction?)
        element.style.textAlign = "left";
        break;
      case "right":
      case "end":
        // TODO check what end means (difference with right, writing direction?)
        element.style.textAlign = "right";
        break;
    }
  }
}
/**
 * Creates span of text for the given #text element, with the right style.
 *
 * TODO create text elements as string? Might help performances.
 * @param {Element} el - the #text element, which text content should be
 * displayed
 * @param {Object} style - the style object for the given text
 * @param {Boolean} shouldTrimWhiteSpace - True if the space should be
 * trimmed.
 * @returns {HTMLElement}
 */
function createTextElement(el, style, shouldTrimWhiteSpace) {
  var textElement = document.createElement("span");
  var textContent = el.textContent === null ? "" : el.textContent;
  if (shouldTrimWhiteSpace) {
    // 1. Trim leading and trailing whitespace.
    // 2. Collapse multiple spaces into one.
    var trimmed = textContent.trim();
    trimmed = trimmed.replace(/\s+/g, " ");
    textContent = trimmed;
  }
  var textNode = document.createTextNode(textContent);
  textElement.appendChild(textNode);
  textElement.className = "rxp-texttrack-span";
  applyTextStyle(textElement, style, shouldTrimWhiteSpace);
  return textElement;
}
/**
 * Generate every text elements to display in a given paragraph.
 * @param {Element} paragraph - The <p> tag.
 * @param {Array.<Object>} regions
 * @param {Array.<Object>} styles
 * @param {Object} paragraphStyle - The general style object of the paragraph.
 * @param {Boolean} shouldTrimWhiteSpace
 * @returns {Array.<HTMLElement>}
 */
function generateTextContent(paragraph, regions, styles, paragraphStyle, shouldTrimWhiteSpace) {
  /**
   * Recursive function, taking a node in argument and returning the
   * corresponding array of HTMLElement in order.
   * @param {Node} node - the node in question
   * @param {Object} style - the current state of the style for the node.
   * /!\ The style object can be mutated, provide a copy of it.
   * @param {Array.<Element>} spans - The spans parent of this node.
   * @param {Boolean} shouldTrimWhiteSpaceFromParent - True if the space should be
   * trimmed by default. From the parent xml:space parameter.
   * @returns {Array.<HTMLElement>}
   */
  function loop(node, style, spans, shouldTrimWhiteSpaceFromParent) {
    var childNodes = node.childNodes;
    var elements = [];
    for (var i = 0; i < childNodes.length; i++) {
      var currentNode = childNodes[i];
      if (currentNode.nodeName === "#text") {
        var _getStylingAttributes = (0,get_styling/* getStylingAttributes */.i)(["backgroundColor"], spans, styles, regions),
          backgroundColor = _getStylingAttributes.backgroundColor;
        if ((0,is_non_empty_string/* default */.A)(backgroundColor)) {
          style.backgroundColor = backgroundColor;
        } else {
          delete style.backgroundColor;
        }
        var el = createTextElement(currentNode, style, shouldTrimWhiteSpaceFromParent);
        elements.push(el);
      } else if ((0,xml_utils/* isLineBreakElement */.SV)(currentNode)) {
        var br = document.createElement("BR");
        elements.push(br);
      } else if ((0,xml_utils/* isSpanElement */.f_)(currentNode) && currentNode.nodeType === Node.ELEMENT_NODE && currentNode.childNodes.length > 0) {
        var spaceAttribute = currentNode.getAttribute("xml:space");
        var shouldTrimWhiteSpaceOnSpan = (0,is_non_empty_string/* default */.A)(spaceAttribute) ? spaceAttribute === "default" : shouldTrimWhiteSpaceFromParent;
        // compute the new applyable style
        var newStyle = (0,object_assign/* default */.A)({}, style, (0,get_styling/* getStylingAttributes */.i)(SPAN_LEVEL_ATTRIBUTES, [currentNode], styles, regions));
        elements.push.apply(elements, loop(currentNode, newStyle, [currentNode].concat(spans), shouldTrimWhiteSpaceOnSpan));
      }
    }
    return elements;
  }
  return loop(paragraph, (0,object_assign/* default */.A)({}, paragraphStyle), [], shouldTrimWhiteSpace);
}
/**
 * @param {Element} paragraph
 * @param {Element} body
 * @param {Array.<Object>} regions
 * @param {Array.<Object>} styles
 * @param {Object} paragraphStyle
 * @param {Object}
 * @returns {HTMLElement}
 */
function createElement(paragraph, body, regions, styles, paragraphStyle, _ref) {
  var cellResolution = _ref.cellResolution,
    shouldTrimWhiteSpace = _ref.shouldTrimWhiteSpace;
  var divs = (0,xml_utils/* getParentDivElements */.Ft)(paragraph);
  var parentElement = document.createElement("DIV");
  parentElement.className = "rxp-texttrack-region";
  parentElement.setAttribute("data-resolution-columns", String(cellResolution.columns));
  parentElement.setAttribute("data-resolution-rows", String(cellResolution.rows));
  applyGeneralStyle(parentElement, paragraphStyle);
  if (body !== null) {
    // applies to body, div, p, region, span
    var _getStylingAttributes2 = (0,get_styling/* getStylingAttributes */.i)(["backgroundColor"], [].concat(divs, [body]), styles, regions),
      bodyBackgroundColor = _getStylingAttributes2.bodyBackgroundColor;
    if ((0,is_non_empty_string/* default */.A)(bodyBackgroundColor)) {
      parentElement.style.backgroundColor = ttmlColorToCSSColor(bodyBackgroundColor);
    }
  }
  var pElement = document.createElement("p");
  pElement.className = "rxp-texttrack-p";
  applyPStyle(pElement, paragraphStyle);
  var textContent = generateTextContent(paragraph, regions, styles, paragraphStyle, shouldTrimWhiteSpace);
  for (var i = 0; i < textContent.length; i++) {
    pElement.appendChild(textContent[i]);
  }
  // NOTE:
  // The following code is for the inclusion of div elements. This has no
  // advantage for now, and might only with future evolutions.
  // (This is only an indication of what the base of the code could look like).
  // if (divs.length) {
  //   let container = parentElement;
  //   for (let i = divs.length - 1; i >= 0; i--) {
  //     // TODO manage style at div level?
  //     // They are: visibility, display and backgroundColor
  //     // All these do not have any difference if applied to the <p> element
  //     // instead of the div.
  //     // The advantage might only be for multiple <p> elements dispatched
  //     // in multiple div Which we do not manage anyway for now.
  //     const divEl = document.createElement("DIV");
  //     divEl.className = "rxp-texttrack-div";
  //     container.appendChild(divEl);
  //     container = divEl;
  //   }
  //   container.appendChild(pElement);
  //   parentElement.appendChild(container);
  // } else {
  //   parentElement.appendChild(pElement);
  // }
  parentElement.appendChild(pElement);
  return parentElement;
}
;// CONCATENATED MODULE: ./src/parsers/texttracks/ttml/html/parse_cue.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @param {Object} parsedCue
 * @returns {Object|null}
 */
function parseCue(parsedCue) {
  var paragraph = parsedCue.paragraph,
    ttParams = parsedCue.ttParams,
    body = parsedCue.body,
    regionStyles = parsedCue.regionStyles,
    idStyles = parsedCue.idStyles,
    paragraphStyle = parsedCue.paragraphStyle,
    timeOffset = parsedCue.timeOffset,
    shouldTrimWhiteSpace = parsedCue.shouldTrimWhiteSpace;
  // Disregard empty elements:
  // TTML allows for empty elements like <div></div>.
  // If paragraph has neither time attributes, nor
  // non-whitespace text, don't try to make a cue out of it.
  if (!paragraph.hasAttribute("begin") && !paragraph.hasAttribute("end") && /^\s*$/.test(paragraph.textContent === null ? "" : paragraph.textContent)) {
    return null;
  }
  var cellResolution = ttParams.cellResolution;
  var _getTimeDelimiters = (0,get_time_delimiters/* default */.A)(paragraph, ttParams),
    start = _getTimeDelimiters.start,
    end = _getTimeDelimiters.end;
  var element = createElement(paragraph, body, regionStyles, idStyles, paragraphStyle, {
    cellResolution: cellResolution,
    shouldTrimWhiteSpace: shouldTrimWhiteSpace
  });
  return {
    start: start + timeOffset,
    end: end + timeOffset,
    element: element
  };
}
;// CONCATENATED MODULE: ./src/parsers/texttracks/ttml/html/parse_ttml_to_div.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Create array of objects which should represent the given TTML text track.
 * These objects have the following structure
 *   - start {Number}: start time, in seconds, at which the cue should
 *     be displayed
 *   - end {Number}: end time, in seconds, at which the cue should
 *     be displayed
 *   - element {HTMLElement}: <div> element representing the cue, with the
 *     right style. This div should then be appended to an element having
 *     the exact size of the wanted region the text track provide cues for.
 *
 * TODO TTML parsing is still pretty heavy on the CPU.
 * Optimizations have been done, principally to avoid using too much XML APIs,
 * but we can still do better.
 * @param {string} str
 * @param {number} timeOffset
 */
function parseTTMLToDiv(str, timeOffset) {
  var parsedCues = (0,parse_ttml/* default */.A)(str, timeOffset);
  var cues = [];
  for (var i = 0; i < parsedCues.length; i++) {
    var paragraphStyle = parsedCues[i].paragraphStyle;
    if (shouldApplyDefaultTTMLStyle(paragraphStyle)) {
      applyDefaultTTMLStyle(paragraphStyle);
    }
    var cue = parseCue(parsedCues[i]);
    if (cue !== null) {
      cues.push(cue);
    }
  }
  return cues;
}
;// CONCATENATED MODULE: ./src/parsers/texttracks/ttml/html/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */

/* harmony default export */ var html = (parseTTMLToDiv);

/***/ }),

/***/ 5084:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: function() { return /* binding */ ttml_native; }
});

// EXTERNAL MODULE: ./src/parsers/texttracks/ttml/parse_ttml.ts + 2 modules
var parse_ttml = __webpack_require__(3487);
// EXTERNAL MODULE: ./src/compat/make_vtt_cue.ts
var make_vtt_cue = __webpack_require__(8068);
// EXTERNAL MODULE: ./src/compat/is_vtt_cue.ts
var is_vtt_cue = __webpack_require__(7402);
// EXTERNAL MODULE: ./src/utils/is_non_empty_string.ts
var is_non_empty_string = __webpack_require__(2384);
// EXTERNAL MODULE: ./src/parsers/texttracks/ttml/get_time_delimiters.ts + 1 modules
var get_time_delimiters = __webpack_require__(9750);
// EXTERNAL MODULE: ./src/parsers/texttracks/ttml/regexps.ts
var regexps = __webpack_require__(8623);
// EXTERNAL MODULE: ./src/parsers/texttracks/ttml/xml_utils.ts
var xml_utils = __webpack_require__(4666);
;// CONCATENATED MODULE: ./src/parsers/texttracks/ttml/native/parse_cue.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





var TEXT_ALIGN_TO_LIGN_ALIGN = {
  left: "start",
  center: "center",
  right: "end",
  start: "start",
  end: "end"
};
/**
 * @type {Object}
 */
var TEXT_ALIGN_TO_POSITION_ALIGN = {
  left: "line-left",
  center: "center",
  right: "line-right"
};
/**
 * Parses an Element into a TextTrackCue or VTTCue.
 * /!\ Mutates the given cueElement Element
 * @param {Element} paragraph
 * @param {Number} offset
 * @param {Array.<Object>} styles
 * @param {Array.<Object>} regions
 * @param {Object} paragraphStyle
 * @param {Object} ttParams
 * @param {Boolean} shouldTrimWhiteSpace
 * @returns {TextTrackCue|null}
 */
function parseCue(parsedCue) {
  var paragraph = parsedCue.paragraph,
    timeOffset = parsedCue.timeOffset,
    paragraphStyle = parsedCue.paragraphStyle,
    ttParams = parsedCue.ttParams,
    shouldTrimWhiteSpace = parsedCue.shouldTrimWhiteSpace;
  // Disregard empty elements:
  // TTML allows for empty elements like <div></div>.
  // If paragraph has neither time attributes, nor
  // non-whitespace text, don't try to make a cue out of it.
  if (!paragraph.hasAttribute("begin") && !paragraph.hasAttribute("end") && /^\s*$/.test(paragraph.textContent === null ? "" : paragraph.textContent)) {
    return null;
  }
  var _getTimeDelimiters = (0,get_time_delimiters/* default */.A)(paragraph, ttParams),
    start = _getTimeDelimiters.start,
    end = _getTimeDelimiters.end;
  var text = generateTextContent(paragraph, shouldTrimWhiteSpace);
  var cue = (0,make_vtt_cue/* default */.A)(start + timeOffset, end + timeOffset, text);
  if (cue === null) {
    return null;
  }
  if ((0,is_vtt_cue/* default */.A)(cue)) {
    addStyle(cue, paragraphStyle);
  }
  return cue;
}
/**
 * Generate text to display for a given paragraph.
 * @param {Element} paragraph - The <p> tag.
 * @param {Boolean} shouldTrimWhiteSpaceForParagraph
 * @returns {string}
 */
function generateTextContent(paragraph, shouldTrimWhiteSpaceForParagraph) {
  /**
   * Recursive function, taking a node in argument and returning the
   * corresponding string.
   * @param {Node} node - the node in question
   * @returns {string}
   */
  function loop(node, shouldTrimWhiteSpaceFromParent) {
    var childNodes = node.childNodes;
    var text = "";
    for (var i = 0; i < childNodes.length; i++) {
      var currentNode = childNodes[i];
      if (currentNode.nodeName === "#text") {
        var textContent = currentNode.textContent;
        if (textContent === null) {
          textContent = "";
        }
        if (shouldTrimWhiteSpaceFromParent) {
          // 1. Trim leading and trailing whitespace.
          // 2. Collapse multiple spaces into one.
          var trimmed = textContent.trim();
          trimmed = trimmed.replace(/\s+/g, " ");
          textContent = trimmed;
        }
        // DOM Parser turns HTML escape caracters into caracters,
        // that may be misinterpreted by VTTCue API (typically, less-than sign
        // and greater-than sign can be interpreted as HTML tags signs).
        // Original escaped caracters must be conserved.
        var escapedTextContent = textContent.replace(/&|\u0026/g, "&amp;").replace(/<|\u003C/g, "&lt;").replace(/>|\u2265/g, "&gt;").replace(/\u200E/g, "&lrm;").replace(/\u200F/g, "&rlm;").replace(/\u00A0/g, "&nbsp;");
        text += escapedTextContent;
      } else if ((0,xml_utils/* isLineBreakElement */.SV)(currentNode)) {
        text += "\n";
      } else if ((0,xml_utils/* isSpanElement */.f_)(currentNode) && currentNode.nodeType === Node.ELEMENT_NODE && currentNode.childNodes.length > 0) {
        var spaceAttribute = currentNode.getAttribute("xml:space");
        var shouldTrimWhiteSpaceForSpan = (0,is_non_empty_string/* default */.A)(spaceAttribute) ? spaceAttribute === "default" : shouldTrimWhiteSpaceFromParent;
        text += loop(currentNode, shouldTrimWhiteSpaceForSpan);
      }
    }
    return text;
  }
  return loop(paragraph, shouldTrimWhiteSpaceForParagraph);
}
/**
 * Adds applicable style properties to a cue.
 * /!\ Mutates cue argument.
 * @param {VTTCue} cue
 * @param {Object} style
 */
function addStyle(cue, style) {
  var extent = style.extent;
  if ((0,is_non_empty_string/* default */.A)(extent)) {
    var results = regexps/* REGXP_PERCENT_VALUES */.KP.exec(extent);
    if (results != null) {
      // Use width value of the extent attribute for size.
      // Height value is ignored.
      cue.size = Number(results[1]);
    }
  }
  var writingMode = style.writingMode;
  // let isVerticalText = true;
  switch (writingMode) {
    case "tb":
    case "tblr":
      cue.vertical = "lr";
      break;
    case "tbrl":
      cue.vertical = "rl";
      break;
    default:
      // isVerticalText = false;
      break;
  }
  var origin = style.origin;
  if ((0,is_non_empty_string/* default */.A)(origin)) {
    var _results = regexps/* REGXP_PERCENT_VALUES */.KP.exec(origin);
    if (_results != null) {
      // for vertical text use first coordinate of tts:origin
      // to represent line of the cue and second - for position.
      // Otherwise (horizontal), use them the other way around.
      // if (isVerticalText) {
      // TODO check and uncomment
      // cue.position = Number(results[2]);
      // cue.line = Number(results[1]);
      // } else {
      // TODO check and uncomment
      // cue.position = Number(results[1]);
      // cue.line = Number(results[2]);
      // }
      // A boolean indicating whether the line is an integer
      // number of lines (using the line dimensions of the first
      // line of the cue), or whether it is a percentage of the
      // dimension of the video. The flag is set to true when lines
      // are counted, and false otherwise.
      // TODO check and uncomment
      // cue.snapToLines = false;
    }
  }
  var align = style.align;
  if ((0,is_non_empty_string/* default */.A)(align)) {
    cue.align = align;
    if (align === "center") {
      if (cue.align !== "center") {
        // Workaround for a Chrome bug http://crbug.com/663797
        // Chrome does not support align = "center"
        cue.align = "middle";
      }
      cue.position = "auto";
    }
    var positionAlign = TEXT_ALIGN_TO_POSITION_ALIGN[align];
    cue.positionAlign = positionAlign === undefined ? "" : positionAlign;
    var lineAlign = TEXT_ALIGN_TO_LIGN_ALIGN[align];
    cue.lineAlign = lineAlign === undefined ? "" : lineAlign;
  }
}
;// CONCATENATED MODULE: ./src/parsers/texttracks/ttml/native/parse_ttml_to_vtt.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @param str
 * @param timeOffset
 */
function parseTtmlToNative(str, timeOffset) {
  var parsedCues = (0,parse_ttml/* default */.A)(str, timeOffset);
  var cues = [];
  for (var i = 0; i < parsedCues.length; i++) {
    var parsedCue = parsedCues[i];
    var cue = parseCue(parsedCue);
    if (cue !== null) {
      cues.push(cue);
    }
  }
  return cues;
}
;// CONCATENATED MODULE: ./src/parsers/texttracks/ttml/native/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */

/* harmony default export */ var ttml_native = (parseTtmlToNative);

/***/ }),

/***/ 3487:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: function() { return /* binding */ parseTTMLString; }
});

// EXTERNAL MODULE: ./src/utils/array_find.ts
var array_find = __webpack_require__(1729);
// EXTERNAL MODULE: ./src/utils/is_non_empty_string.ts
var is_non_empty_string = __webpack_require__(2384);
// EXTERNAL MODULE: ./src/utils/object_assign.ts
var object_assign = __webpack_require__(8935);
// EXTERNAL MODULE: ./src/log.ts + 1 modules
var log = __webpack_require__(9477);
;// CONCATENATED MODULE: ./src/parsers/texttracks/ttml/get_parameters.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var CELL_RESOLUTION_REGEXP = /(\d+) (\d+)/;
/**
 * Returns global parameters from a TTML Document
 * @param {Element} tt - <tt> node
 * @throws Error - Throws if the spacing style is invalid.
 * @returns {Object}
 */
function getParameters(tt) {
  var parsedFrameRate = tt.getAttribute("ttp:frameRate");
  var parsedSubFrameRate = tt.getAttribute("ttp:subFramRate");
  var parsedTickRate = tt.getAttribute("ttp:tickRate");
  var parsedFrameRateMultiplier = tt.getAttribute("ttp:frameRateMultiplier");
  var parsedSpaceStyle = tt.getAttribute("xml:space");
  var parsedCellResolution = tt.getAttribute("ttp:cellResolution");
  var cellResolution = {
    columns: 32,
    rows: 15
  };
  if (parsedCellResolution !== null) {
    var extractedData = CELL_RESOLUTION_REGEXP.exec(parsedCellResolution);
    if (extractedData === null || extractedData.length < 3) {
      log/* default */.A.warn("TTML Parser: Invalid cellResolution");
    } else {
      var columns = parseInt(extractedData[1], 10);
      var rows = parseInt(extractedData[2], 10);
      if (isNaN(columns) || isNaN(rows)) {
        log/* default */.A.warn("TTML Parser: Invalid cellResolution");
      } else {
        cellResolution = {
          columns: columns,
          rows: rows
        };
      }
    }
  }
  if ((0,is_non_empty_string/* default */.A)(parsedSpaceStyle) && parsedSpaceStyle !== "default" && parsedSpaceStyle !== "preserve") {
    throw new Error("Invalid spacing style");
  }
  var nbFrameRate = Number(parsedFrameRate);
  if (isNaN(nbFrameRate) || nbFrameRate <= 0) {
    nbFrameRate = 30;
  }
  var nbSubFrameRate = Number(parsedSubFrameRate);
  if (isNaN(nbSubFrameRate) || nbSubFrameRate <= 0) {
    nbSubFrameRate = 1;
  }
  var nbTickRate = Number(parsedTickRate);
  if (isNaN(nbTickRate) || nbTickRate <= 0) {
    nbTickRate = undefined;
  }
  var frameRate = nbFrameRate;
  var subFrameRate = nbSubFrameRate != null ? nbSubFrameRate : 1;
  var spaceStyle = parsedSpaceStyle !== null ? parsedSpaceStyle : "default";
  var tickRate = nbTickRate !== undefined ? nbTickRate : nbFrameRate * nbSubFrameRate;
  if (parsedFrameRateMultiplier !== null) {
    var multiplierResults = /^(\d+) (\d+)$/g.exec(parsedFrameRateMultiplier);
    if (multiplierResults !== null) {
      var numerator = Number(multiplierResults[1]);
      var denominator = Number(multiplierResults[2]);
      var multiplierNum = numerator / denominator;
      frameRate = nbFrameRate * multiplierNum;
    }
  }
  return {
    cellResolution: cellResolution,
    tickRate: tickRate,
    frameRate: frameRate,
    subFrameRate: subFrameRate,
    spaceStyle: spaceStyle
  };
}
// EXTERNAL MODULE: ./src/parsers/texttracks/ttml/get_styling.ts
var get_styling = __webpack_require__(2632);
// EXTERNAL MODULE: ./src/utils/array_find_index.ts
var array_find_index = __webpack_require__(3786);
// EXTERNAL MODULE: ./src/utils/array_includes.ts
var array_includes = __webpack_require__(4031);
;// CONCATENATED MODULE: ./src/parsers/texttracks/ttml/resolve_styles_inheritance.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Transform all styles inheriting from other styles to the same styles but with
 * the inheritance removed (by resolving those inheritance here).
 *
 * Note that the original style object is directly mutated with every
 * inheritance they had resolved and removed.
 *
 * To make a pseudo-code analogy this would be equivalent to transform those
 * two classes:
 * ```
 * class A {
 *   methodA() {}
 * }
 *
 * class B extends A {
 *   method B() {}
 * }
 * ```
 * into the same two classes without inheritance:
 * ```
 * class A {
 *   methodA() {}
 * }
 * class B {
 *   methodA() {} // inherited from class A
 *   methodB() {}
 * }
 * ```
 *
 * Doing this here allows to simplify further treatment of those styles.
 * @param {Array.<Object>} styles
 */
function resolveStylesInheritance(styles) {
  // keep track of all the indexes parsed to avoid infinite loops
  var recursivelyBrowsedIndexes = [];
  function resolveStyleInheritance(styleElt, index) {
    recursivelyBrowsedIndexes.push(index);
    var _loop = function _loop() {
      var extendedStyleID = styleElt.extendsStyles[j];
      var extendedStyleIndex = (0,array_find_index/* default */.A)(styles, function (x) {
        return x.id === extendedStyleID;
      });
      if (extendedStyleIndex < 0) {
        log/* default */.A.warn("TTML Parser: unknown style inheritance: " + extendedStyleID);
      } else {
        var extendedStyle = styles[extendedStyleIndex];
        if ((0,array_includes/* default */.A)(recursivelyBrowsedIndexes, extendedStyleIndex)) {
          log/* default */.A.warn("TTML Parser: infinite style inheritance loop avoided");
        } else {
          resolveStyleInheritance(extendedStyle, extendedStyleIndex);
        }
        styleElt.style = (0,object_assign/* default */.A)({}, extendedStyle.style, styleElt.style);
      }
    };
    for (var j = 0; j < styleElt.extendsStyles.length; j++) {
      _loop();
    }
    styleElt.extendsStyles.length = 0;
  }
  for (var i = 0; i < styles.length; i++) {
    resolveStyleInheritance(styles[i], i);
    recursivelyBrowsedIndexes.length = 0; // reset
  }
}
// EXTERNAL MODULE: ./src/parsers/texttracks/ttml/xml_utils.ts
var xml_utils = __webpack_require__(4666);
;// CONCATENATED MODULE: ./src/parsers/texttracks/ttml/parse_ttml.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */







var STYLE_ATTRIBUTES = ["align", "backgroundColor", "color", "direction", "display", "displayAlign", "extent", "fontFamily", "fontSize", "fontStyle", "fontWeight", "lineHeight", "opacity", "origin", "overflow", "padding", "textAlign", "textDecoration", "textOutline", "unicodeBidi", "visibility", "wrapOption", "writingMode"
// Not managed anywhere for now
// "showBackground",
// "zIndex",
];
/**
 * Create array of objects which should represent the given TTML text track.
 * TODO TTML parsing is still pretty heavy on the CPU.
 * Optimizations have been done, principally to avoid using too much XML APIs,
 * but we can still do better.
 * @param {string} str
 * @param {Number} timeOffset
 * @returns {Array.<Object>}
 */
function parseTTMLString(str, timeOffset) {
  var cues = [];
  var xml = new DOMParser().parseFromString(str, "text/xml");
  if (xml !== null && xml !== undefined) {
    var tts = xml.getElementsByTagName("tt");
    var tt = tts[0];
    if (tt === undefined) {
      // EBU-TT sometimes namespaces tt, by "tt:"
      // Just catch all namespaces to play it safe
      var namespacedTT = xml.getElementsByTagNameNS("*", "tt");
      tt = namespacedTT[0];
      if (tt === undefined) {
        throw new Error("invalid XML");
      }
    }
    var body = (0,xml_utils/* getBodyNode */.$K)(tt);
    var styleNodes = (0,xml_utils/* getStyleNodes */.bL)(tt);
    var regionNodes = (0,xml_utils/* getRegionNodes */.Y$)(tt);
    var paragraphNodes = (0,xml_utils/* getTextNodes */.zn)(tt);
    var ttParams = getParameters(tt);
    // construct idStyles array based on the xml as an optimization
    var idStyles = [];
    for (var i = 0; i <= styleNodes.length - 1; i++) {
      var styleNode = styleNodes[i];
      if (styleNode instanceof Element) {
        var styleID = styleNode.getAttribute("xml:id");
        if (styleID !== null) {
          var subStyles = styleNode.getAttribute("style");
          var extendsStyles = subStyles === null ? [] : subStyles.split(" ");
          idStyles.push({
            id: styleID,
            style: (0,get_styling/* getStylingFromElement */.d)(styleNode),
            extendsStyles: extendsStyles
          });
        }
      }
    }
    resolveStylesInheritance(idStyles);
    // construct regionStyles array based on the xml as an optimization
    var regionStyles = [];
    var _loop = function _loop() {
      var regionNode = regionNodes[_i];
      if (regionNode instanceof Element) {
        var regionID = regionNode.getAttribute("xml:id");
        if (regionID !== null) {
          var regionStyle = (0,get_styling/* getStylingFromElement */.d)(regionNode);
          var associatedStyleID = regionNode.getAttribute("style");
          if ((0,is_non_empty_string/* default */.A)(associatedStyleID)) {
            var style = (0,array_find/* default */.A)(idStyles, function (x) {
              return x.id === associatedStyleID;
            });
            if (style !== undefined) {
              regionStyle = (0,object_assign/* default */.A)({}, style.style, regionStyle);
            }
          }
          regionStyles.push({
            id: regionID,
            style: regionStyle,
            // already handled
            extendsStyles: []
          });
        }
      }
    };
    for (var _i = 0; _i <= regionNodes.length - 1; _i++) {
      _loop();
    }
    // Computing the style takes a lot of ressources.
    // To avoid too much re-computation, let's compute the body style right
    // now and do the rest progressively.
    // TODO Compute corresponding CSS style here (as soon as we now the TTML
    // style) to speed up the process even more.
    var bodyStyle = (0,get_styling/* getStylingAttributes */.i)(STYLE_ATTRIBUTES, body !== null ? [body] : [], idStyles, regionStyles);
    var bodySpaceAttribute = body !== null ? body.getAttribute("xml:space") : undefined;
    var shouldTrimWhiteSpaceOnBody = bodySpaceAttribute === "default" || ttParams.spaceStyle === "default";
    for (var _i2 = 0; _i2 < paragraphNodes.length; _i2++) {
      var paragraph = paragraphNodes[_i2];
      if (paragraph instanceof Element) {
        var divs = (0,xml_utils/* getParentDivElements */.Ft)(paragraph);
        var paragraphStyle = (0,object_assign/* default */.A)({}, bodyStyle, (0,get_styling/* getStylingAttributes */.i)(STYLE_ATTRIBUTES, [paragraph].concat(divs), idStyles, regionStyles));
        var paragraphSpaceAttribute = paragraph.getAttribute("xml:space");
        var shouldTrimWhiteSpace = (0,is_non_empty_string/* default */.A)(paragraphSpaceAttribute) ? paragraphSpaceAttribute === "default" : shouldTrimWhiteSpaceOnBody;
        var cue = {
          paragraph: paragraph,
          timeOffset: timeOffset,
          idStyles: idStyles,
          regionStyles: regionStyles,
          body: body,
          paragraphStyle: paragraphStyle,
          ttParams: ttParams,
          shouldTrimWhiteSpace: shouldTrimWhiteSpace
        };
        if (cue !== null) {
          cues.push(cue);
        }
      }
    }
  }
  return cues;
}

/***/ }),

/***/ 8623:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ce: function() { return /* binding */ REGXP_4_HEX_COLOR; },
/* harmony export */   Cn: function() { return /* binding */ REGXP_TIME_COLON_FRAMES; },
/* harmony export */   KP: function() { return /* binding */ REGXP_PERCENT_VALUES; },
/* harmony export */   Nm: function() { return /* binding */ REGXP_TIME_TICK; },
/* harmony export */   PL: function() { return /* binding */ REGXP_RGB_COLOR; },
/* harmony export */   QF: function() { return /* binding */ REGXP_TIME_HMS; },
/* harmony export */   UR: function() { return /* binding */ REGXP_8_HEX_COLOR; },
/* harmony export */   _Y: function() { return /* binding */ REGXP_RGBA_COLOR; },
/* harmony export */   iP: function() { return /* binding */ REGXP_LENGTH; },
/* harmony export */   lP: function() { return /* binding */ REGXP_TIME_COLON; },
/* harmony export */   s_: function() { return /* binding */ REGXP_TIME_FRAMES; },
/* harmony export */   uA: function() { return /* binding */ REGXP_TIME_COLON_MS; }
/* harmony export */ });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// examples: 00:00:40:07 (7 frames) or 00:00:40:07.1 (7 frames, 1 subframe)
var REGXP_TIME_COLON_FRAMES = /^(\d{2,}):(\d{2}):(\d{2}):(\d{2})\.?(\d+)?$/;
// examples: 00:00:40:07 (7 frames) or 00:00:40:07.1 (7 frames, 1 subframe)
var REGXP_TIME_COLON = /^(?:(\d{2,}):)?(\d{2}):(\d{2})$/;
// examples: 01:02:43.0345555 or 02:43.03
var REGXP_TIME_COLON_MS = /^(?:(\d{2,}):)?(\d{2}):(\d{2}\.\d{2,})$/;
// examples: 75f or 75.5f
var REGXP_TIME_FRAMES = /^(\d*\.?\d*)f$/;
// examples: 50t or 50.5t
var REGXP_TIME_TICK = /^(\d*\.?\d*)t$/;
// examples: 3.45h, 3m or 4.20s
var REGXP_TIME_HMS = /^(?:(\d*\.?\d*)h)?(?:(\d*\.?\d*)m)?(?:(\d*\.?\d*)s)?(?:(\d*\.?\d*)ms)?$/;
// examples: 50% 10%
var REGXP_PERCENT_VALUES = /^(\d{1,2}|100)% (\d{1,2}|100)%$/;
var REGXP_LENGTH = /^((?:\+|\-)?\d*(?:\.\d+)?)(px|em|c|%|rh|rw)$/;
var REGXP_8_HEX_COLOR = /^#([0-9A-f]{2})([0-9A-f]{2})([0-9A-f]{2})([0-9A-f]{2})$/;
var REGXP_4_HEX_COLOR = /^#([0-9A-f])([0-9A-f])([0-9A-f])([0-9A-f])$/;
var REGXP_RGB_COLOR = /^rgb\( *(\d+) *, *(\d+) *, *(\d+) *\)/;
var REGXP_RGBA_COLOR = /^rgba\( *(\d+) *, *(\d+) *, *(\d+) *, *(\d+) *\)/;


/***/ }),

/***/ 4666:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $K: function() { return /* binding */ getBodyNode; },
/* harmony export */   Ft: function() { return /* binding */ getParentDivElements; },
/* harmony export */   SV: function() { return /* binding */ isLineBreakElement; },
/* harmony export */   Y$: function() { return /* binding */ getRegionNodes; },
/* harmony export */   bL: function() { return /* binding */ getStyleNodes; },
/* harmony export */   f_: function() { return /* binding */ isSpanElement; },
/* harmony export */   zn: function() { return /* binding */ getTextNodes; }
/* harmony export */ });
/* unused harmony exports getParentElementsByTagName, getAttributeInElements */
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Returns the parent elements which have the given tagName, by order of
 * closeness relative to our element.
 * @param {Element|Node} element
 * @param {string} tagName
 * @returns {Array.<Element>}
 */
function getParentElementsByTagName(element, tagName) {
  if (!(element.parentNode instanceof Element)) {
    return [];
  }
  function constructArray(_element) {
    var elements = [];
    if (_element.tagName.toLowerCase() === tagName.toLowerCase()) {
      elements.push(_element);
    }
    var parentNode = _element.parentNode;
    if (parentNode instanceof Element) {
      elements.push.apply(elements, constructArray(parentNode));
    }
    return elements;
  }
  return constructArray(element.parentNode);
}
/**
 * Returns the parent elements which have the given tagName, by order of
 * closeness relative to our element.
 * @param {Element|Node} element
 * @returns {Array.<Element>}
 */
function getParentDivElements(element) {
  var divs = getParentElementsByTagName(element, "div");
  if (divs.length === 0) {
    var ttDivs = getParentElementsByTagName(element, "tt:div");
    if (ttDivs.length > 0) {
      divs = ttDivs;
    }
  }
  return divs;
}
/**
 * Returns the first notion of the attribute encountered in the list of elemnts
 * given.
 * @param {string} attribute
 * @param {Array.<Element>} elements
 * @returns {string|undefined}
 */
function getAttributeInElements(attribute, elements) {
  for (var i = 0; i <= elements.length - 1; i++) {
    var element = elements[i];
    if (element !== undefined) {
      var directAttrValue = element.getAttribute(attribute);
      if (directAttrValue != null) {
        return directAttrValue;
      }
    }
  }
}
/**
 * @param {Element} tt
 * @returns {Element}
 */
function getBodyNode(tt) {
  var bodyNodes = tt.getElementsByTagName("body");
  if (bodyNodes.length > 0) {
    return bodyNodes[0];
  }
  var namespacedBodyNodes = tt.getElementsByTagName("tt:body");
  if (namespacedBodyNodes.length > 0) {
    return namespacedBodyNodes[0];
  }
  return null;
}
/**
 * @param {Element} tt - <tt> node
 * @returns {Array.<Element>}
 */
function getStyleNodes(tt) {
  var styleNodes = tt.getElementsByTagName("style");
  if (styleNodes.length > 0) {
    return styleNodes;
  }
  var namespacedStyleNodes = tt.getElementsByTagName("tt:style");
  if (namespacedStyleNodes.length > 0) {
    return namespacedStyleNodes;
  }
  return styleNodes;
}
/**
 * @param {Element} tt - <tt> node
 * @returns {Array.<Element>}
 */
function getRegionNodes(tt) {
  var regionNodes = tt.getElementsByTagName("region");
  if (regionNodes.length > 0) {
    return regionNodes;
  }
  var namespacedRegionNodes = tt.getElementsByTagName("tt:region");
  if (namespacedRegionNodes.length > 0) {
    return namespacedRegionNodes;
  }
  return regionNodes;
}
/**
 * @param {Element} tt - <tt> node
 * @returns {Array.<Element>}
 */
function getTextNodes(tt) {
  var pNodes = tt.getElementsByTagName("p");
  if (pNodes.length > 0) {
    return pNodes;
  }
  var namespacedPNodes = tt.getElementsByTagName("tt:p");
  if (namespacedPNodes.length > 0) {
    return namespacedPNodes;
  }
  return pNodes;
}
/**
 * Returns true if the given node corresponds to a TTML line break element.
 * @param {Node} node
 * @returns {boolean}
 */
function isLineBreakElement(node) {
  return node.nodeName === "br" || node.nodeName === "tt:br";
}
/**
 * Returns true if the given node corresponds to a TTML span element.
 * @param {Node} node
 * @returns {boolean}
 */
function isSpanElement(node) {
  return node.nodeName === "span" || node.nodeName === "tt:span";
}

/***/ }),

/***/ 7093:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: function() { return /* binding */ getCueBlocks; }
/* harmony export */ });
/* harmony import */ var _utils_is_non_empty_string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2384);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6525);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Get cue blocks from a WebVTT file.
 * @param {Array.<string>} linified - Whole WebVTT file. Each new element in
 * this array is a new line.
 * @param {number} headerOffset - index of the first line after the header.
 * Used to avoid taking the header into consideration.
 * @returns {Array.<Array.<string>>}
 */
function getCueBlocks(linified, headerOffset) {
  var cueBlocks = [];
  for (var i = headerOffset; i < linified.length; i++) {
    if ((0,_utils__WEBPACK_IMPORTED_MODULE_0__/* .isStartOfCueBlock */ .GX)(linified, i)) {
      var endOfCue = (0,_utils__WEBPACK_IMPORTED_MODULE_0__/* .findEndOfCueBlock */ .o4)(linified, i);
      cueBlocks.push(linified.slice(i, endOfCue));
      i = endOfCue;
    } else if ((0,_utils_is_non_empty_string__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(linified[i])) {
      // continue incrementing i until either:
      //   - empty line
      //   - end
      while ((0,_utils_is_non_empty_string__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(linified[i])) {
        i++;
      }
    }
  }
  return cueBlocks;
}

/***/ }),

/***/ 8977:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: function() { return /* binding */ html; }
});

// EXTERNAL MODULE: ./src/parsers/texttracks/webvtt/get_cue_blocks.ts
var get_cue_blocks = __webpack_require__(7093);
// EXTERNAL MODULE: ./src/utils/is_non_empty_string.ts
var is_non_empty_string = __webpack_require__(2384);
// EXTERNAL MODULE: ./src/parsers/texttracks/webvtt/utils.ts
var utils = __webpack_require__(6525);
;// CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/get_style_blocks.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Get cue blocks from a WebVTT file.
 * @param {Array.<string>} linified - Whole WebVTT file. Each new element in
 * this array is a new line.
 * @param {number} headerOffset - index of the first line after the header.
 * Used to avoid taking the header into consideration.
 * @returns {Array.<Array.<string>>}
 */
function getStyleBlocks(linified, headerOffset) {
  var styleBlocks = [];
  for (var i = headerOffset; i < linified.length; i++) {
    //
    if ((0,utils/* isStartOfStyleBlock */.iq)(linified, i)) {
      var startOfStyleBlock = i;
      i++;
      // continue incrementing i until either:
      //   - empty line
      //   - end of file
      while ((0,is_non_empty_string/* default */.A)(linified[i])) {
        i++;
      }
      var styleBlock = linified.slice(startOfStyleBlock, i);
      styleBlocks.push(styleBlock);
    } else if ((0,is_non_empty_string/* default */.A)(linified[i])) {
      // continue incrementing i until either:
      //   - empty line
      //   - end
      while ((0,is_non_empty_string/* default */.A)(linified[i])) {
        i++;
      }
    }
  }
  return styleBlocks;
}
// EXTERNAL MODULE: ./src/parsers/texttracks/webvtt/parse_cue_block.ts + 1 modules
var parse_cue_block = __webpack_require__(8786);
;// CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/html/create_default_style_elements.ts
/**
 * Creates default classes defined in the W3 specification
 *
 * https://www.w3.org/TR/webvtt1/#default-classes
 */
var colorMap = {
  white: "#ffffff",
  lime: "#00ff00",
  cyan: "#00ffff",
  red: "#ff0000",
  yellow: "#ffff00",
  magenta: "#ff00ff",
  blue: "#0000ff",
  black: "#000000"
};
function createDefaultStyleElements() {
  return Object.keys(colorMap).reduce(function (result, key) {
    result[key] = "color: " + colorMap[key] + ";";
    result["bg_" + key] = "background-color: " + colorMap[key] + ";";
    return result;
  }, {});
}
;// CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/html/parse_style_block.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Parse style element from WebVTT.
 * @param {Array.<Array.<string>>} styleBlocks
 * @return {Object}
 */
function parseStyleBlocks(styleBlocks) {
  var classes = createDefaultStyleElements();
  var global = "";
  styleBlocks.forEach(function (styleBlock) {
    if (styleBlock.length >= 2) {
      var _loop = function _loop(_index) {
        var line = styleBlock[_index];
        if (Array.isArray(/::cue {/.exec(line))) {
          line = styleBlock[++_index];
          while ((0,is_non_empty_string/* default */.A)(line) && !(Array.isArray(/}/.exec(line)) || line.length === 0)) {
            global += line;
            line = styleBlock[++_index];
          }
        } else {
          var classNames = [];
          var cueClassLine = /::cue\(\.?(.*?)\)(?:,| {)/.exec(line);
          while ((0,is_non_empty_string/* default */.A)(line) && Array.isArray(cueClassLine)) {
            classNames.push(cueClassLine[1]);
            line = styleBlock[++_index];
            cueClassLine = /::cue\(\.?(.*?)\)(?:,| {)/.exec(line);
          }
          var styleContent = "";
          while ((0,is_non_empty_string/* default */.A)(line) && !(Array.isArray(/}/.exec(line)) || line.length === 0)) {
            styleContent += line;
            line = styleBlock[++_index];
          }
          classNames.forEach(function (className) {
            var styleElement = classes[className];
            if (styleElement === undefined) {
              classes[className] = styleContent;
            } else {
              classes[className] += styleContent;
            }
          });
        }
        index = _index;
      };
      for (var index = 1; index < styleBlock.length; index++) {
        _loop(index);
      }
    }
  });
  return {
    classes: classes,
    global: global
  };
}
// EXTERNAL MODULE: ./src/utils/array_includes.ts
var array_includes = __webpack_require__(4031);
;// CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/html/create_styled_element.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Construct an HTMLElement/TextNode representing the given node and apply
 * the right styling on it.
 * @param {Node} baseNode
 * @param {Array.<Object>} styleElements
 * @param {Array.<string>} styleClasses
 * @returns {Node}
 */
function createStyledElement(baseNode, styleElements) {
  var HTMLTags = ["u", "i", "b"];
  var authorizedNodeNames = ["u", "i", "b", "c", "#text"];
  var mainNodeName = baseNode.nodeName.toLowerCase().split(".")[0];
  var nodeWithStyle;
  if ((0,array_includes/* default */.A)(authorizedNodeNames, mainNodeName)) {
    if (mainNodeName === "#text") {
      var linifiedText = baseNode.wholeText.split("\n");
      nodeWithStyle = document.createElement("span");
      for (var i = 0; i < linifiedText.length; i++) {
        if (i > 0) {
          nodeWithStyle.appendChild(document.createElement("br"));
        }
        if (linifiedText[i].length > 0) {
          var textNode = document.createTextNode(linifiedText[i]);
          nodeWithStyle.appendChild(textNode);
        }
      }
    } else {
      var nodeClasses = baseNode.nodeName.toLowerCase().split(".");
      var styleContents = [];
      nodeClasses.forEach(function (nodeClass) {
        if ((0,is_non_empty_string/* default */.A)(styleElements[nodeClass])) {
          styleContents.push(styleElements[nodeClass]);
        }
      });
      if (styleContents.length !== 0) {
        // If style must be applied
        var attr = document.createAttribute("style");
        styleContents.forEach(function (styleContent) {
          attr.value += styleContent;
        });
        var nameClass = (0,array_includes/* default */.A)(HTMLTags, mainNodeName) ? mainNodeName : "span";
        nodeWithStyle = document.createElement(nameClass);
        nodeWithStyle.setAttributeNode(attr);
      } else {
        // If style mustn't be applied. Rebuild element with tag name
        var elementTag = !(0,array_includes/* default */.A)(HTMLTags, mainNodeName) ? "span" : mainNodeName;
        nodeWithStyle = document.createElement(elementTag);
      }
      for (var j = 0; j < baseNode.childNodes.length; j++) {
        var child = createStyledElement(baseNode.childNodes[j], styleElements);
        nodeWithStyle.appendChild(child);
      }
    }
  } else {
    nodeWithStyle = document.createElement("span");
    for (var _j = 0; _j < baseNode.childNodes.length; _j++) {
      var _child = createStyledElement(baseNode.childNodes[_j], styleElements);
      nodeWithStyle.appendChild(_child);
    }
  }
  return nodeWithStyle;
}
;// CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/html/convert_payload_to_html.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @param {string} text
 * @param {Array.<Object>} styleElements
 * @returns {Array.<HTMLElement>}
 */
function convertPayloadToHTML(text, styleElements) {
  var filteredText = text
  // Remove timestamp tags
  .replace(/<[0-9]{2}:[0-9]{2}.[0-9]{3}>/, "")
  // Remove tag content or attributes (e.g. <b dfgfdg> => <b>)
  .replace(/<([u,i,b,c])(\..*?)?(?: .*?)?>(.*?)<\/\1>/g, "<$1$2>$3</$1$2>");
  var parsedWebVTT = new DOMParser().parseFromString(filteredText, "text/html");
  var nodes = parsedWebVTT.body.childNodes;
  var styledElements = [];
  for (var i = 0; i < nodes.length; i++) {
    styledElements.push(createStyledElement(nodes[i], styleElements));
  }
  return styledElements;
}
// EXTERNAL MODULE: ./src/utils/object_values.ts
var object_values = __webpack_require__(4324);
;// CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/html/create_style_attribute.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Construct a DOM attribute reflecting given cue settings
 * @param {Partial<Record<string, string>>} settings
 * @returns {Attr}
 */
function createStyleAttribute(settings) {
  var pAttr = document.createAttribute("style");
  pAttr.value = getAttrValue(settings);
  return pAttr;
}
var getAttrValue = function getAttrValue(settings) {
  var hasSettings = settings !== undefined && (0,object_values/* default */.A)(settings).length !== 0;
  if (!hasSettings) {
    return "text-align:center";
  }
  var xPositioning = getPositioningX(settings);
  var yPositioning = getPositioningY(settings);
  return "position: absolute;" + "margin: 0;" + ("transform: translate(" + xPositioning.offset + "%," + yPositioning.offset + "%);") + ("width: " + getSizePercentage(settings.size) + "%;") + ("left: " + xPositioning.position + "%;") + ("top: " + (yPositioning.position !== null ? yPositioning.position + "%" : "auto") + ";") + ("text-align: " + getAlignValue(settings.align) + ";");
};
var PositionAlignment;
(function (PositionAlignment) {
  PositionAlignment["LINE_LEFT"] = "line-left";
  PositionAlignment["CENTER"] = "center";
  PositionAlignment["LINE_RIGHT"] = "line-right";
})(PositionAlignment || (PositionAlignment = {}));
var Align;
(function (Align) {
  Align["LEFT"] = "left";
  Align["CENTER"] = "center";
  Align["RIGHT"] = "right";
})(Align || (Align = {}));
var LineAlignment;
(function (LineAlignment) {
  LineAlignment["START"] = "start";
  LineAlignment["CENTER"] = "center";
  LineAlignment["END"] = "end";
})(LineAlignment || (LineAlignment = {}));
var getPositioningX = function getPositioningX(settings) {
  return {
    position: getXPositionPercentage(settings),
    offset: getXOffsetPercentage(settings)
  };
};
var getXPositionPercentage = function getXPositionPercentage(settings) {
  var _alignMap;
  var positionPercentage = getPercentageValue(settings.position);
  if (positionPercentage !== null) {
    return positionPercentage;
  }
  var align = getAlignValue(settings.align);
  var alignMap = (_alignMap = {}, _alignMap[Align.LEFT] = 0, _alignMap[Align.CENTER] = 50, _alignMap[Align.RIGHT] = 100, _alignMap);
  return alignMap[align];
};
var getXOffsetPercentage = function getXOffsetPercentage(settings) {
  var _positionAlignmentMap, _alignMap2;
  var getPositionAlignment = function getPositionAlignment(positionSetting) {
    var positionRegex = /,(line-left|line-right|center)/;
    var matches = positionRegex.exec(positionSetting);
    if (!Array.isArray(matches) || matches.length < 2) {
      return null;
    }
    return matches[1];
  };
  var positionAlignmentMap = (_positionAlignmentMap = {}, _positionAlignmentMap[PositionAlignment.LINE_LEFT] = 0, _positionAlignmentMap[PositionAlignment.CENTER] = -50, _positionAlignmentMap[PositionAlignment.LINE_RIGHT] = -100, _positionAlignmentMap);
  var positionAlignment = settings.position !== undefined ? getPositionAlignment(settings.position) : null;
  if (positionAlignment !== null) {
    return positionAlignmentMap[positionAlignment];
  }
  var alignMap = (_alignMap2 = {}, _alignMap2[Align.LEFT] = 0, _alignMap2[Align.CENTER] = -50, _alignMap2[Align.RIGHT] = -100, _alignMap2);
  var align = settings.align !== undefined ? getAlignValue(settings.align) : Align.CENTER;
  return alignMap[align];
};
var getPositioningY = function getPositioningY(settings) {
  return {
    position: getYPositionPercentage(settings.line),
    offset: getYOffsetPercentage(settings.line)
  };
};
var getYPositionPercentage = function getYPositionPercentage(lineSetting) {
  return getPercentageValue(lineSetting);
};
var getYOffsetPercentage = function getYOffsetPercentage(lineSetting) {
  var _lineAlignmentMap;
  var getLineAlignment = function getLineAlignment(line) {
    var positionRegex = /,(start|center|end)/;
    var matches = positionRegex.exec(line);
    if (!Array.isArray(matches) || matches.length < 2) {
      return null;
    }
    return matches[1];
  };
  var lineAlignmentMap = (_lineAlignmentMap = {}, _lineAlignmentMap[LineAlignment.START] = 0, _lineAlignmentMap[LineAlignment.CENTER] = -50, _lineAlignmentMap[LineAlignment.END] = -100, _lineAlignmentMap);
  if (lineSetting === undefined) {
    return lineAlignmentMap[LineAlignment.START];
  }
  var lineAlignment = getLineAlignment(lineSetting);
  return lineAlignment !== null ? lineAlignmentMap[lineAlignment] : lineAlignmentMap[LineAlignment.START];
};
var getAlignValue = function getAlignValue(alignSetting) {
  switch (alignSetting) {
    case "left":
    case "start":
      return "left";
    case "right":
    case "end":
      return "right";
    default:
      return "center";
  }
};
var getSizePercentage = function getSizePercentage(sizeSetting) {
  var defaultSize = 100;
  return getPercentageValueOrDefault(sizeSetting, defaultSize);
};
var getPercentageValueOrDefault = function getPercentageValueOrDefault(percentageString, defaultValue) {
  var value = getPercentageValue(percentageString);
  return value !== null ? value : defaultValue;
};
var getPercentageValue = function getPercentageValue(percentageString) {
  if (percentageString === undefined) {
    return null;
  }
  var percentageValueRegex = /^([\d.]+)%/;
  var matches = percentageValueRegex.exec(percentageString);
  if (!Array.isArray(matches) || matches.length < 2) {
    return null;
  }
  return parseInt(matches[1], 10);
};
;// CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/html/to_html.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Parse cue block into an object with the following properties:
 *   - start {number}: start time at which the cue should be displayed
 *   - end {number}: end time at which the cue should be displayed
 *   - element {HTMLElement}: the cue text, translated into an HTMLElement
 *
 * Returns undefined if the cue block could not be parsed.
 * @param {Array.<string>} cueBlock
 * @param {Number} timeOffset
 * @param {Array.<Object>} classes
 * @returns {Object|undefined}
 */
function toHTML(cueObj, styling) {
  var start = cueObj.start,
    end = cueObj.end,
    settings = cueObj.settings,
    header = cueObj.header,
    payload = cueObj.payload;
  var region = document.createElement("div");
  var regionAttr = document.createAttribute("style");
  regionAttr.value = "width:100%;" + "height:100%;" + "display:flex;" + "flex-direction:column;" + "justify-content:flex-end;" + "align-items:center;";
  region.setAttributeNode(regionAttr);
  // Get content, format and apply style.
  var pElement = document.createElement("p");
  var pAttr = createStyleAttribute(settings);
  pElement.setAttributeNode(pAttr);
  var spanElement = document.createElement("span");
  var attr = document.createAttribute("style");
  // set color and background-color default values, as indicated in:
  // https://www.w3.org/TR/webvtt1/#applying-css-properties
  attr.value = "background-color:rgba(0,0,0,0.8);" + "color:white;";
  spanElement.setAttributeNode(attr);
  var global = styling.global,
    classes = styling.classes;
  var localStyle = (0,is_non_empty_string/* default */.A)(header) ? classes[header] : undefined;
  var styles = [global, localStyle].filter(function (s) {
    return s !== undefined;
  }).join("");
  attr.value += styles;
  spanElement.setAttributeNode(attr);
  convertPayloadToHTML(payload.join("\n"), classes).forEach(function (element) {
    spanElement.appendChild(element);
  });
  region.appendChild(pElement);
  pElement.appendChild(spanElement);
  return {
    start: start,
    end: end,
    element: region
  };
}
;// CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/html/parse_webvtt_to_div.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






/**
 * Parse WebVTT from text. Returns an array with:
 * - start : start of current cue, in seconds
 * - end : end of current cue, in seconds
 * - content : HTML formatted cue.
 *
 * Global style is parsed and applied to div element.
 * Specific style is parsed and applied to class element.
 *
 * @throws Error - Throws if the given WebVTT string is invalid.
 * @param {string} text - The whole webvtt subtitles to parse
 * @param {Number} timeOffset - Offset to add to start and end times, in seconds
 * @return {Array.<Object>}
 */
function parseWebVTT(text, timeOffset) {
  var newLineChar = /\r\n|\n|\r/g; // CRLF|LF|CR
  var linified = text.split(newLineChar);
  var cuesArray = [];
  if (/^WEBVTT( |\t|\n|\r|$)/.exec(linified[0]) === null) {
    throw new Error("Can't parse WebVTT: Invalid File.");
  }
  var firstLineAfterHeader = (0,utils/* getFirstLineAfterHeader */.yW)(linified);
  var styleBlocks = getStyleBlocks(linified, firstLineAfterHeader);
  var cueBlocks = (0,get_cue_blocks/* default */.A)(linified, firstLineAfterHeader);
  var styles = parseStyleBlocks(styleBlocks);
  for (var i = 0; i < cueBlocks.length; i++) {
    var cueObject = (0,parse_cue_block/* default */.A)(cueBlocks[i], timeOffset);
    if (cueObject != null) {
      var htmlCue = toHTML(cueObject, styles);
      cuesArray.push(htmlCue);
    }
  }
  return cuesArray;
}
;// CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/html/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */

/* harmony default export */ var html = (parseWebVTT);

/***/ }),

/***/ 2537:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: function() { return /* binding */ webvtt_native; }
});

// EXTERNAL MODULE: ./src/compat/is_vtt_cue.ts
var is_vtt_cue = __webpack_require__(7402);
// EXTERNAL MODULE: ./src/parsers/texttracks/webvtt/get_cue_blocks.ts
var get_cue_blocks = __webpack_require__(7093);
// EXTERNAL MODULE: ./src/parsers/texttracks/webvtt/parse_cue_block.ts + 1 modules
var parse_cue_block = __webpack_require__(8786);
// EXTERNAL MODULE: ./src/parsers/texttracks/webvtt/utils.ts
var utils = __webpack_require__(6525);
// EXTERNAL MODULE: ./src/utils/array_includes.ts
var array_includes = __webpack_require__(4031);
// EXTERNAL MODULE: ./src/utils/is_non_empty_string.ts
var is_non_empty_string = __webpack_require__(2384);
;// CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/native/set_settings_on_cue.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Add the corresponding settings on the given cue.
 * /!\ Mutates the cue given.
 * @param {Object} settings - settings for the cue, as a key-value object.
 * @param {ICompatVTTCue|TextTrackCue} cue
 */
function setSettingsOnCue(settings, cue) {
  if ((0,is_non_empty_string/* default */.A)(settings.vertical) && (settings.vertical === "rl" || settings.vertical === "lr")) {
    cue.vertical = settings.vertical;
  }
  if ((0,is_non_empty_string/* default */.A)(settings.line)) {
    // Capture groups:
    //   1 -> percentage position
    //   2 -> optional decimals from percentage position
    //   3 -> optional follow-up of the string indicating alignment value
    //   4 -> alignment value
    var percentagePosition = /^(\d+(\.\d+)?)%(,([a-z]+))?/;
    var percentageMatches = percentagePosition.exec(settings.line);
    if (Array.isArray(percentageMatches)) {
      cue.line = Number(percentageMatches[1]);
      cue.snapToLines = false;
      if ((0,array_includes/* default */.A)(["start", "center", "end"], percentageMatches[4])) {
        cue.lineAlign = percentageMatches[4];
      }
    } else {
      // Capture groups:
      //   1 -> line number
      //   2 -> optional follow-up of the string indicating alignment value
      //   3 -> alignment value
      var linePosition = /^(-?\d+)(,([a-z]+))?/;
      var lineMatches = linePosition.exec(settings.line);
      if (Array.isArray(lineMatches)) {
        cue.line = Number(lineMatches[1]);
        cue.snapToLines = true;
        if ((0,array_includes/* default */.A)(["start", "center", "end"], lineMatches[3])) {
          cue.lineAlign = lineMatches[3];
        }
      }
    }
  }
  if ((0,is_non_empty_string/* default */.A)(settings.position)) {
    var positionRegex = /^([\d\.]+)%(?:,(line-left|line-right|center))?$/;
    var positionArr = positionRegex.exec(settings.position);
    if (Array.isArray(positionArr) && positionArr.length >= 2) {
      var position = parseInt(positionArr[1], 10);
      if (!isNaN(position)) {
        cue.position = position;
        if (positionArr[2] !== undefined) {
          cue.positionAlign = positionArr[2];
        }
      }
    }
  }
  if ((0,is_non_empty_string/* default */.A)(settings.size)) {
    cue.size = settings.size;
  }
  if (typeof settings.align === "string" && (0,array_includes/* default */.A)(["start", "center", "end", "left"], settings.align)) {
    cue.align = settings.align;
  }
}
// EXTERNAL MODULE: ./src/compat/make_vtt_cue.ts
var make_vtt_cue = __webpack_require__(8068);
;// CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/native/to_native_cue.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @param {Object} cue Object
 * @returns {TextTrackCue|ICompatVTTCue|null}
 */
function toNativeCue(cueObj) {
  var start = cueObj.start,
    end = cueObj.end,
    payload = cueObj.payload;
  var text = payload.join("\n");
  return (0,make_vtt_cue/* default */.A)(start, end, text);
}
;// CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/native/parse_vtt_to_cues.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






// Simple VTT to ICompatVTTCue parser:
// Just parse cues and associated settings.
// Does not take into consideration STYLE and REGION blocks.
/**
 * Parse whole WEBVTT file into an array of cues, to be inserted in a video's
 * TrackElement.
 * @param {string} vttStr
 * @param {Number} timeOffset
 * @returns {Array.<ICompatVTTCue|TextTrackCue>}
 */
function parseVTTStringToVTTCues(vttStr, timeOffset) {
  // WEBVTT authorize CRLF, LF or CR as line terminators
  var lines = vttStr.split(/\r\n|\n|\r/);
  if (!/^WEBVTT($| |\t)/.test(lines[0])) {
    throw new Error("Can't parse WebVTT: Invalid file.");
  }
  var firstLineAfterHeader = (0,utils/* getFirstLineAfterHeader */.yW)(lines);
  var cueBlocks = (0,get_cue_blocks/* default */.A)(lines, firstLineAfterHeader);
  var cues = [];
  for (var i = 0; i < cueBlocks.length; i++) {
    var cueObject = (0,parse_cue_block/* default */.A)(cueBlocks[i], timeOffset);
    if (cueObject != null) {
      var nativeCue = toNativeCue(cueObject);
      if (nativeCue != null) {
        if ((0,is_vtt_cue/* default */.A)(nativeCue)) {
          setSettingsOnCue(cueObject.settings, nativeCue);
        }
        cues.push(nativeCue);
      }
    }
  }
  return cues;
}
;// CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/native/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */

/* harmony default export */ var webvtt_native = (parseVTTStringToVTTCues);

/***/ }),

/***/ 8786:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: function() { return /* binding */ parseCueBlock; }
});

// EXTERNAL MODULE: ./src/utils/is_non_empty_string.ts
var is_non_empty_string = __webpack_require__(2384);
;// CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/parse_timestamp.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Parse a single webvtt timestamp into seconds
 * @param {string} timestampString
 * @returns {Number|undefined}
 */
function parseTimestamp(timestampString) {
  var splittedTS = timestampString.split(":").reverse();
  if ((0,is_non_empty_string/* default */.A)(splittedTS[2]) || (0,is_non_empty_string/* default */.A)(splittedTS[1])) {
    var hours = (0,is_non_empty_string/* default */.A)(splittedTS[2]) ? parseInt(splittedTS[2], 10) : 0;
    var minutes = parseInt(splittedTS[1], 10);
    var seconds = parseFloat(splittedTS[0].replace(",", "."));
    if (isNaN(hours) || isNaN(minutes) || isNaN(seconds)) {
      return undefined;
    }
    return hours * 60 * 60 + minutes * 60 + seconds;
  }
}
;// CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/parse_cue_block.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Parse the settings part of a cue, into key-value object.
 * @param {string} settingsString
 * @returns {Object}
 */
function parseSettings(settingsString) {
  var splittedSettings = settingsString.split(/ |\t/);
  return splittedSettings.reduce(function (acc, setting) {
    var splittedSetting = setting.split(":");
    if (splittedSetting.length === 2) {
      acc[splittedSetting[0]] = splittedSetting[1];
    }
    return acc;
  }, {});
}
/**
 * Parse the line containing the timestamp and settings in a cue.
 * The returned object has the following properties:
 *   - start {Number}: start of the cue, in seconds
 *   - end {Number}: end of the cue, in seconds
 *   - settings {Object}: settings for the cue as a key-value object.
 * @param {string} timeString
 * @returns {Object|null}
 */
function parseTimeAndSettings(timeString) {
  // RegExp for the timestamps + settings line.
  // Capture groups:
  //   1 -> start timestamp
  //   2 -> end timestamp
  //   3 - settings
  var lineRegex = /^([\d:.]+)[ |\t]+-->[ |\t]+([\d:.]+)[ |\t]*(.*)$/;
  var matches = lineRegex.exec(timeString);
  if (matches === null) {
    return null;
  }
  var start = parseTimestamp(matches[1]);
  var end = parseTimestamp(matches[2]);
  if (start == null || end == null) {
    return null;
  }
  var settings = parseSettings(matches[3]);
  return {
    start: start,
    end: end,
    settings: settings
  };
}
/**
 * Parse cue block into a cue object which contains:
 *   - start {number}: the start of the cue as a timestamp in seconds
 *   - end {number}: the end of the cue as a timestamp in seconds
 *   - header {string|undefined}: The optional cue identifier
 *   - payload {Array.<string>}: the payload of the cue
 * @param {Array.<string>} cueLines
 * @param {Number} timeOffset
 * @returns {Object}
 */
function parseCueBlock(cueLines, timeOffset) {
  var timingRegexp = /-->/;
  var timeString;
  var payload;
  var header;
  if (!timingRegexp.test(cueLines[0])) {
    if (!timingRegexp.test(cueLines[1])) {
      // not a cue
      return null;
    }
    header = cueLines[0];
    timeString = cueLines[1];
    payload = cueLines.slice(2, cueLines.length);
  } else {
    timeString = cueLines[0];
    payload = cueLines.slice(1, cueLines.length);
  }
  var timeAndSettings = parseTimeAndSettings(timeString);
  if (timeAndSettings === null) {
    return null;
  }
  var start = timeAndSettings.start,
    end = timeAndSettings.end,
    settings = timeAndSettings.settings;
  return {
    start: start + timeOffset,
    end: end + timeOffset,
    settings: settings,
    payload: payload,
    header: header
  };
}

/***/ }),

/***/ 6525:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GX: function() { return /* binding */ isStartOfCueBlock; },
/* harmony export */   iq: function() { return /* binding */ isStartOfStyleBlock; },
/* harmony export */   o4: function() { return /* binding */ findEndOfCueBlock; },
/* harmony export */   yW: function() { return /* binding */ getFirstLineAfterHeader; }
/* harmony export */ });
/* unused harmony exports isStartOfNoteBlock, isStartOfRegionBlock */
/* harmony import */ var _utils_is_non_empty_string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2384);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns first line after the WEBVTT header.
 * That is, the line after the first blank line after the first line!
 * @param {Array.<string>} linified
 * @returns {Number}
 */
function getFirstLineAfterHeader(linified) {
  var i = 0;
  while (i < linified.length) {
    if (linified[i] === "") {
      return i + 1;
    }
    i++;
  }
  return i;
}
/**
 * Returns true if the given line looks like the beginning of a Style block.
 * @param {string} text
 * @returns {Boolean}
 */
function isStartOfStyleBlock(lines, index) {
  return typeof lines[index] === "string" && /^STYLE( .*)?$/g.test(lines[index]) && (
  // A cue identifer can also contain "STYLE". Check that we have no timings
  // on the second line
  lines[index + 1] === undefined || lines[index + 1].indexOf("-->") < 0);
}
/**
 * Returns true if the given line looks like the beginning of a comment block.
 * @param {string} text
 * @returns {Boolean}
 */
function isStartOfNoteBlock(lines, index) {
  return typeof lines[index] === "string" && /^NOTE( .*)?$/g.test(lines[index]) && (
  // A cue identifer can also contain "NOTE". Check that we have no timings
  // on the second line
  lines[index + 1] === undefined || lines[index + 1].indexOf("-->") < 0);
}
/**
 * Returns true if the given line looks like the beginning of a region block.
 * @param {string} text
 * @returns {Boolean}
 */
function isStartOfRegionBlock(lines, index) {
  return typeof lines[index] === "string" && /^REGION( .*)?$/g.test(lines[index]) && (
  // A cue identifer can also contain "REGION". Check that we have no timings
  // on the second line
  lines[index + 1] === undefined || lines[index + 1].indexOf("-->") < 0);
}
/**
 * Returns true if the line given looks like the beginning of a cue.
 * You should provide to this function only lines following "empty" lines.
 * @param {Array.<string>} lines
 * @param {number} index
 * @returns {Boolean}
 */
function isStartOfCueBlock(lines, index) {
  // checked cases:
  //   - empty lines
  //   - start of a comment
  //   - start of a region
  //   - start of a style
  // Anything else whose first or second line is a timestamp line is a cue.
  var firstLine = lines[index];
  if (firstLine === undefined || firstLine === "" || isStartOfStyleBlock(lines, index) || isStartOfRegionBlock(lines, index) || isStartOfNoteBlock(lines, index)) {
    return false;
  }
  if (firstLine.indexOf("-->") >= 0) {
    return true;
  }
  var secondLine = lines[index + 1];
  return secondLine !== undefined && secondLine.indexOf("-->") >= 0;
}
/**
 * Find end of current WebVTT cue block.
 * @param {Array<string>} linified
 * @param {number} startOfCueBlock
 * @returns {number}
 */
function findEndOfCueBlock(linified, startOfCueBlock) {
  var firstEmptyLineIndex = startOfCueBlock + 1;
  // continue incrementing i until either:
  //   - empty line
  //   - end
  while ((0,_utils_is_non_empty_string__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(linified[firstEmptyLineIndex])) {
    firstEmptyLineIndex++;
  }
  return firstEmptyLineIndex;
}


/***/ }),

/***/ 9502:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: function() { return /* binding */ dash; }
});

// EXTERNAL MODULE: ./src/features/index.ts
var features = __webpack_require__(418);
// EXTERNAL MODULE: ./src/transports/utils/generate_manifest_loader.ts + 1 modules
var generate_manifest_loader = __webpack_require__(1856);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js
var asyncToGenerator = __webpack_require__(467);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/regenerator/index.js
var regenerator = __webpack_require__(4756);
var regenerator_default = /*#__PURE__*/__webpack_require__.n(regenerator);
// EXTERNAL MODULE: ./src/utils/request/index.ts + 1 modules
var request = __webpack_require__(4389);
// EXTERNAL MODULE: ./src/utils/resolve_url.ts
var resolve_url = __webpack_require__(2716);
;// CONCATENATED MODULE: ./src/transports/dash/construct_segment_url.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function constructSegmentUrl(wantedCdn, segment) {
  return wantedCdn === null ? null : segment.url === null ? wantedCdn.baseUrl : (0,resolve_url/* default */.Ay)(wantedCdn.baseUrl, segment.url);
}
;// CONCATENATED MODULE: ./src/transports/dash/image_pipelines.ts


/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Loads an image segment.
 * @param {Object|null} wantedCdn
 * @param {Object} content
 * @param {Object} options
 * @param {Object} cancelSignal
 * @param {Object} callbacks
 * @returns {Promise}
 */
function imageLoader(_x, _x2, _x3, _x4, _x5) {
  return _imageLoader.apply(this, arguments);
}
/**
 * Parses an image segment.
 * @param {Object} loadedSegment
 * @param {Object} content
 * @returns {Object}
 */
function _imageLoader() {
  _imageLoader = (0,asyncToGenerator/* default */.A)( /*#__PURE__*/regenerator_default().mark(function _callee(wantedCdn, content, options, cancelSignal, callbacks) {
    var segment, url, data;
    return regenerator_default().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          segment = content.segment;
          url = constructSegmentUrl(wantedCdn, segment);
          if (!(segment.isInit || url === null)) {
            _context.next = 4;
            break;
          }
          return _context.abrupt("return", {
            resultType: "segment-created",
            resultData: null
          });
        case 4:
          _context.next = 6;
          return (0,request/* default */.Ay)({
            url: url,
            responseType: "arraybuffer",
            timeout: options.timeout,
            onProgress: callbacks.onProgress,
            cancelSignal: cancelSignal
          });
        case 6:
          data = _context.sent;
          return _context.abrupt("return", {
            resultType: "segment-loaded",
            resultData: data
          });
        case 8:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return _imageLoader.apply(this, arguments);
}
function imageParser(loadedSegment, content) {
  var _a;
  var segment = content.segment,
    period = content.period;
  var data = loadedSegment.data,
    isChunked = loadedSegment.isChunked;
  if (content.segment.isInit) {
    // image init segment has no use
    return {
      segmentType: "init",
      initializationData: null,
      initializationDataSize: 0,
      protectionDataUpdate: false,
      initTimescale: undefined
    };
  }
  if (isChunked) {
    throw new Error("Image data should not be downloaded in chunks");
  }
  var chunkOffset = (_a = segment.timestampOffset) !== null && _a !== void 0 ? _a : 0;
  // TODO image Parsing should be more on the buffer side, no?
  if (data === null || features/* default */.A.imageParser === null) {
    return {
      segmentType: "media",
      chunkData: null,
      chunkSize: 0,
      chunkInfos: {
        duration: segment.duration,
        time: segment.time
      },
      chunkOffset: chunkOffset,
      protectionDataUpdate: false,
      appendWindow: [period.start, period.end]
    };
  }
  var bifObject = features/* default */.A.imageParser(new Uint8Array(data));
  var thumbsData = bifObject.thumbs;
  return {
    segmentType: "media",
    chunkData: {
      data: thumbsData,
      start: 0,
      end: Number.MAX_VALUE,
      timescale: 1,
      type: "bif"
    },
    chunkSize: undefined,
    chunkInfos: {
      time: 0,
      duration: Number.MAX_VALUE
    },
    chunkOffset: chunkOffset,
    protectionDataUpdate: false,
    appendWindow: [period.start, period.end]
  };
}
// EXTERNAL MODULE: ./src/config.ts + 2 modules
var config = __webpack_require__(5151);
// EXTERNAL MODULE: ./src/errors/format_error.ts
var format_error = __webpack_require__(874);
// EXTERNAL MODULE: ./src/log.ts + 1 modules
var log = __webpack_require__(9477);
// EXTERNAL MODULE: ./src/manifest/index.ts + 6 modules
var src_manifest = __webpack_require__(8568);
// EXTERNAL MODULE: ./src/utils/object_assign.ts
var object_assign = __webpack_require__(8935);
// EXTERNAL MODULE: ./src/utils/string_parsing.ts
var string_parsing = __webpack_require__(4670);
;// CONCATENATED MODULE: ./src/transports/dash/manifest_parser.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */








function generateManifestParser(options) {
  var aggressiveMode = options.aggressiveMode,
    referenceDateTime = options.referenceDateTime;
  var serverTimeOffset = options.serverSyncInfos !== undefined ? options.serverSyncInfos.serverTimestamp - options.serverSyncInfos.clientTime : undefined;
  return function manifestParser(manifestData, parserOptions, onWarnings, cancelSignal, scheduleRequest) {
    var _a;
    var responseData = manifestData.responseData;
    var argClockOffset = parserOptions.externalClockOffset;
    var url = (_a = manifestData.url) !== null && _a !== void 0 ? _a : parserOptions.originalUrl;
    var optAggressiveMode = aggressiveMode === true;
    var externalClockOffset = serverTimeOffset !== null && serverTimeOffset !== void 0 ? serverTimeOffset : argClockOffset;
    var unsafelyBaseOnPreviousManifest = parserOptions.unsafeMode ? parserOptions.previousManifest : null;
    var dashParserOpts = {
      aggressiveMode: optAggressiveMode,
      unsafelyBaseOnPreviousManifest: unsafelyBaseOnPreviousManifest,
      url: url,
      referenceDateTime: referenceDateTime,
      externalClockOffset: externalClockOffset
    };
    var parsers = features/* default */.A.dashParsers;
    if (parsers.wasm === null || parsers.wasm.status === "uninitialized" || parsers.wasm.status === "failure") {
      log/* default */.A.debug("DASH: WASM MPD Parser not initialized. Running JS one.");
      return runDefaultJsParser();
    } else {
      var manifestAB = getManifestAsArrayBuffer(responseData);
      if (!doesXmlSeemsUtf8Encoded(manifestAB)) {
        log/* default */.A.info("DASH: MPD doesn't seem to be UTF-8-encoded. " + "Running JS parser instead of the WASM one.");
        return runDefaultJsParser();
      }
      if (parsers.wasm.status === "initialized") {
        log/* default */.A.debug("DASH: Running WASM MPD Parser.");
        var parsed = parsers.wasm.runWasmParser(manifestAB, dashParserOpts);
        return processMpdParserResponse(parsed);
      } else {
        log/* default */.A.debug("DASH: Awaiting WASM initialization before parsing the MPD.");
        var initProm = parsers.wasm.waitForInitialization()["catch"](function () {
          /* ignore errors, we will check the status later */
        });
        return initProm.then(function () {
          if (parsers.wasm === null || parsers.wasm.status !== "initialized") {
            log/* default */.A.warn("DASH: WASM MPD parser initialization failed. " + "Running JS parser instead");
            return runDefaultJsParser();
          }
          log/* default */.A.debug("DASH: Running WASM MPD Parser.");
          var parsed = parsers.wasm.runWasmParser(manifestAB, dashParserOpts);
          return processMpdParserResponse(parsed);
        });
      }
    }
    /**
     * Parse the MPD through the default JS-written parser (as opposed to the
     * WebAssembly one).
     * If it is not defined, throws.
     * @returns {Object|Promise.<Object>}
     */
    function runDefaultJsParser() {
      if (parsers.js === null) {
        throw new Error("No MPD parser is imported");
      }
      var manifestDoc = getManifestAsDocument(responseData);
      var parsedManifest = parsers.js(manifestDoc, dashParserOpts);
      return processMpdParserResponse(parsedManifest);
    }
    /**
     * Process return of one of the MPD parser.
     * If it asks for a resource, load it then continue.
     * @param {Object} parserResponse - Response returned from a MPD parser.
     * @returns {Object|Promise.<Object>}
     */
    function processMpdParserResponse(parserResponse) {
      if (parserResponse.type === "done") {
        if (parserResponse.value.warnings.length > 0) {
          onWarnings(parserResponse.value.warnings);
        }
        if (cancelSignal.isCancelled()) {
          return Promise.reject(cancelSignal.cancellationError);
        }
        var manifest = new src_manifest/* default */.Ay(parserResponse.value.parsed, options);
        return {
          manifest: manifest,
          url: url
        };
      }
      var value = parserResponse.value;
      var externalResources = value.urls.map(function (resourceUrl) {
        return scheduleRequest(function () {
          var defaultTimeout = config/* default */.A.getCurrent().DEFAULT_REQUEST_TIMEOUT;
          return value.format === "string" ? (0,request/* default */.Ay)({
            url: resourceUrl,
            responseType: "text",
            timeout: defaultTimeout,
            cancelSignal: cancelSignal
          }) : (0,request/* default */.Ay)({
            url: resourceUrl,
            responseType: "arraybuffer",
            timeout: defaultTimeout,
            cancelSignal: cancelSignal
          });
        }).then(function (res) {
          if (value.format === "string") {
            if (typeof res.responseData !== "string") {
              throw new Error("External DASH resources should have been a string");
            }
            return (0,object_assign/* default */.A)(res, {
              responseData: {
                success: true,
                data: res.responseData
              }
            });
          } else {
            if (!(res.responseData instanceof ArrayBuffer)) {
              throw new Error("External DASH resources should have been ArrayBuffers");
            }
            return (0,object_assign/* default */.A)(res, {
              responseData: {
                success: true,
                data: res.responseData
              }
            });
          }
        }, function (err) {
          var error = (0,format_error/* default */.A)(err, {
            defaultCode: "PIPELINE_PARSE_ERROR",
            defaultReason: "An unknown error occured when parsing ressources."
          });
          return (0,object_assign/* default */.A)({}, {
            size: undefined,
            requestDuration: undefined,
            responseData: {
              success: false,
              error: error
            }
          });
        });
      });
      return Promise.all(externalResources).then(function (loadedResources) {
        if (value.format === "string") {
          assertLoadedResourcesFormatString(loadedResources);
          return processMpdParserResponse(value["continue"](loadedResources));
        } else {
          assertLoadedResourcesFormatArrayBuffer(loadedResources);
          return processMpdParserResponse(value["continue"](loadedResources));
        }
      });
    }
  };
}
/**
 * Throw if the given input is not in the expected format.
 * Allows to enforce runtime type-checking as compile-time type-checking here is
 * difficult to enforce.
 *
 * @param loadedResource
 * @returns
 */
function assertLoadedResourcesFormatString(loadedResources) {
  if (true) {
    return;
  }
  loadedResources.forEach(function (loadedResource) {
    var responseData = loadedResource.responseData;
    if (responseData.success && typeof responseData.data === "string") {
      return;
    } else if (!responseData.success) {
      return;
    }
    throw new Error("Invalid data given to the LoadedRessource");
  });
}
/**
 * Throw if the given input is not in the expected format.
 * Allows to enforce runtime type-checking as compile-time type-checking here is
 * difficult to enforce.
 *
 * @param loadedResource
 * @returns
 */
function assertLoadedResourcesFormatArrayBuffer(loadedResources) {
  if (true) {
    return;
  }
  loadedResources.forEach(function (loadedResource) {
    var responseData = loadedResource.responseData;
    if (responseData.success && responseData.data instanceof ArrayBuffer) {
      return;
    } else if (!responseData.success) {
      return;
    }
    throw new Error("Invalid data given to the LoadedRessource");
  });
}
/**
 * Try to convert a Manifest from an unknown format to a `Document` format.
 * Useful to exploit DOM-parsing APIs to quickly parse an XML Manifest.
 *
 * Throws if the format cannot be converted.
 * @param {*} manifestSrc
 * @returns {Document}
 */
function getManifestAsDocument(manifestSrc) {
  if (manifestSrc instanceof ArrayBuffer) {
    return new DOMParser().parseFromString((0,string_parsing/* utf8ToStr */.Es)(new Uint8Array(manifestSrc)), "text/xml");
  } else if (typeof manifestSrc === "string") {
    return new DOMParser().parseFromString(manifestSrc, "text/xml");
  } else if (manifestSrc instanceof Document) {
    return manifestSrc;
  } else {
    throw new Error("DASH Manifest Parser: Unrecognized Manifest format");
  }
}
/**
 * Try to convert a Manifest from an unknown format to an `ArrayBuffer` format.
 * Throws if the format cannot be converted.
 * @param {*} manifestSrc
 * @returns {ArrayBuffer}
 */
function getManifestAsArrayBuffer(manifestSrc) {
  if (manifestSrc instanceof ArrayBuffer) {
    return manifestSrc;
  } else if (typeof manifestSrc === "string") {
    return (0,string_parsing/* strToUtf8 */.eb)(manifestSrc).buffer;
  } else if (manifestSrc instanceof Document) {
    return (0,string_parsing/* strToUtf8 */.eb)(manifestSrc.documentElement.innerHTML).buffer;
  } else {
    throw new Error("DASH Manifest Parser: Unrecognized Manifest format");
  }
}
/**
 * Returns true if the given XML appears to be encoded in UTF-8.
 *
 * For now, this function can return a lot of false positives, but it should
 * mostly work with real use cases.
 * @param {ArrayBuffer} xmlData
 * @returns {boolean}
 */
function doesXmlSeemsUtf8Encoded(xmlData) {
  var dv = new DataView(xmlData);
  if (dv.getUint16(0) === 0xefbb && dv.getUint8(2) === 0xbf) {
    // (UTF-8 BOM)
    return true;
  } else if (dv.getUint16(0) === 0xfeff || dv.getUint16(0) === 0xfffe) {
    // (UTF-16 BOM)
    return false;
  }
  // TODO check encoding from request mimeType and text declaration?
  // https://www.w3.org/TR/xml/#sec-TextDecl
  return true;
}
// EXTERNAL MODULE: ./src/errors/custom_loader_error.ts
var custom_loader_error = __webpack_require__(7004);
// EXTERNAL MODULE: ./src/errors/request_error.ts
var request_error = __webpack_require__(3506);
// EXTERNAL MODULE: ./src/errors/error_codes.ts
var error_codes = __webpack_require__(5497);
// EXTERNAL MODULE: ./src/utils/is_null_or_undefined.ts
var is_null_or_undefined = __webpack_require__(6787);
;// CONCATENATED MODULE: ./src/utils/request/fetch.ts


/*
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



var _Headers = typeof Headers === "function" ? Headers : null;
var _AbortController = typeof AbortController === "function" ? AbortController : null;
function fetchRequest(options) {
  var headers;
  if (!(0,is_null_or_undefined/* default */.A)(options.headers)) {
    if ((0,is_null_or_undefined/* default */.A)(_Headers)) {
      headers = options.headers;
    } else {
      headers = new _Headers();
      var headerNames = Object.keys(options.headers);
      for (var i = 0; i < headerNames.length; i++) {
        var headerName = headerNames[i];
        headers.append(headerName, options.headers[headerName]);
      }
    }
  }
  log/* default */.A.debug("Fetch: Called with URL", options.url);
  var cancellation = null;
  var timeouted = false;
  var sendingTime = performance.now();
  var abortController = !(0,is_null_or_undefined/* default */.A)(_AbortController) ? new _AbortController() : null;
  /**
   * Abort current fetchRequest by triggering AbortController signal.
   * @returns {void}
   */
  function abortFetch() {
    if ((0,is_null_or_undefined/* default */.A)(abortController)) {
      log/* default */.A.warn("Fetch: AbortController API not available.");
      return;
    }
    abortController.abort();
  }
  var timeout;
  if (options.timeout !== undefined) {
    timeout = window.setTimeout(function () {
      timeouted = true;
      abortFetch();
    }, options.timeout);
  }
  var deregisterCancelLstnr = options.cancelSignal.register(function abortRequest(err) {
    cancellation = err;
    abortFetch();
  });
  var fetchOpts = {
    method: "GET"
  };
  if (headers !== undefined) {
    fetchOpts.headers = headers;
  }
  fetchOpts.signal = !(0,is_null_or_undefined/* default */.A)(abortController) ? abortController.signal : null;
  return fetch(options.url, fetchOpts).then(function (response) {
    if (!(0,is_null_or_undefined/* default */.A)(timeout)) {
      clearTimeout(timeout);
    }
    if (response.status >= 300) {
      log/* default */.A.warn("Fetch: Request HTTP Error", response.status, response.url);
      throw new request_error/* default */.A(response.url, response.status, error_codes/* NetworkErrorTypes */.yl.ERROR_HTTP_CODE);
    }
    if ((0,is_null_or_undefined/* default */.A)(response.body)) {
      throw new request_error/* default */.A(response.url, response.status, error_codes/* NetworkErrorTypes */.yl.PARSE_ERROR);
    }
    var contentLengthHeader = response.headers.get("Content-Length");
    var contentLength = !(0,is_null_or_undefined/* default */.A)(contentLengthHeader) && !isNaN(+contentLengthHeader) ? +contentLengthHeader : undefined;
    var reader = response.body.getReader();
    var size = 0;
    return readBufferAndSendEvents();
    function readBufferAndSendEvents() {
      return _readBufferAndSendEvents.apply(this, arguments);
    }
    function _readBufferAndSendEvents() {
      _readBufferAndSendEvents = (0,asyncToGenerator/* default */.A)( /*#__PURE__*/regenerator_default().mark(function _callee() {
        var data, currentTime, dataInfo, receivedTime, requestDuration;
        return regenerator_default().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return reader.read();
            case 2:
              data = _context.sent;
              if (!(!data.done && !(0,is_null_or_undefined/* default */.A)(data.value))) {
                _context.next = 11;
                break;
              }
              size += data.value.byteLength;
              currentTime = performance.now();
              dataInfo = {
                url: response.url,
                currentTime: currentTime,
                duration: currentTime - sendingTime,
                sendingTime: sendingTime,
                chunkSize: data.value.byteLength,
                chunk: data.value.buffer,
                size: size,
                totalSize: contentLength
              };
              options.onData(dataInfo);
              return _context.abrupt("return", readBufferAndSendEvents());
            case 11:
              if (!data.done) {
                _context.next = 16;
                break;
              }
              deregisterCancelLstnr();
              receivedTime = performance.now();
              requestDuration = receivedTime - sendingTime;
              return _context.abrupt("return", {
                requestDuration: requestDuration,
                receivedTime: receivedTime,
                sendingTime: sendingTime,
                size: size,
                status: response.status,
                url: response.url
              });
            case 16:
              return _context.abrupt("return", readBufferAndSendEvents());
            case 17:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));
      return _readBufferAndSendEvents.apply(this, arguments);
    }
  })["catch"](function (err) {
    if (cancellation !== null) {
      throw cancellation;
    }
    deregisterCancelLstnr();
    if (timeouted) {
      log/* default */.A.warn("Fetch: Request timeouted.");
      throw new request_error/* default */.A(options.url, 0, error_codes/* NetworkErrorTypes */.yl.TIMEOUT);
    } else if (err instanceof request_error/* default */.A) {
      throw err;
    }
    log/* default */.A.warn("Fetch: Request Error", err instanceof Error ? err.toString() : "");
    throw new request_error/* default */.A(options.url, 0, error_codes/* NetworkErrorTypes */.yl.ERROR_EVENT);
  });
}
/**
 * Returns true if fetch should be supported in the current browser.
 * @return {boolean}
 */
function fetchIsSupported() {
  return typeof window.fetch === "function" && !(0,is_null_or_undefined/* default */.A)(_AbortController) && !(0,is_null_or_undefined/* default */.A)(_Headers);
}
// EXTERNAL MODULE: ./src/utils/warn_once.ts
var warn_once = __webpack_require__(5950);
// EXTERNAL MODULE: ./src/transports/utils/byte_range.ts
var byte_range = __webpack_require__(3233);
;// CONCATENATED MODULE: ./src/transports/utils/infer_segment_container.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Guess the type of container a segment is in based on Manifest information.
 *
 * Returns:
 *   - "mp4" if we can say with confidence the segment will be in an mp4 format
 *   - "webm" if we can say with confidence the segment will be in a webm format
 *   - `undefined` if we cannot say with confidence in which container the
 *     segment will be in.
 * @param {string} adaptationType
 * @param {Object} representation
 * @returns {string | undefined}
 */
function inferSegmentContainer(adaptationType, representation) {
  if (adaptationType === "audio" || adaptationType === "video") {
    if (representation.mimeType === "video/mp4" || representation.mimeType === "audio/mp4") {
      return "mp4";
    }
    if (representation.mimeType === "video/webm" || representation.mimeType === "audio/webm") {
      return "webm";
    }
    return undefined;
  } else if (adaptationType === "text") {
    return representation.mimeType === "application/mp4" ? "mp4" : undefined;
  }
  return undefined;
}
// EXTERNAL MODULE: ./src/utils/task_canceller.ts
var task_canceller = __webpack_require__(2507);
// EXTERNAL MODULE: ./src/transports/utils/check_isobmff_integrity.ts
var check_isobmff_integrity = __webpack_require__(3598);
;// CONCATENATED MODULE: ./src/transports/dash/add_segment_integrity_checks_to_loader.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Add multiple checks on the response given by the `segmentLoader` in argument.
 * If the response appear to be corrupted, the returned Promise will reject with
 * an error with an `INTEGRITY_ERROR` code.
 * @param {Function} segmentLoader
 * @returns {Function}
 */
function addSegmentIntegrityChecks(segmentLoader) {
  return function (url, content, loaderOptions, initialCancelSignal, callbacks) {
    return new Promise(function (resolve, reject) {
      var requestCanceller = new task_canceller/* default */.Ay();
      var unlinkCanceller = requestCanceller.linkToSignal(initialCancelSignal);
      requestCanceller.signal.register(reject);
      segmentLoader(url, content, loaderOptions, requestCanceller.signal, Object.assign(Object.assign({}, callbacks), {
        onNewChunk: function onNewChunk(data) {
          try {
            trowOnIntegrityError(data);
            callbacks.onNewChunk(data);
          } catch (err) {
            // Do not reject with a `CancellationError` after cancelling the request
            cleanUpCancellers();
            // Cancel the request
            requestCanceller.cancel();
            // Reject with thrown error
            reject(err);
          }
        }
      })).then(function (info) {
        cleanUpCancellers();
        if (requestCanceller.isUsed()) {
          return;
        }
        if (info.resultType === "segment-loaded") {
          try {
            trowOnIntegrityError(info.resultData.responseData);
          } catch (err) {
            reject(err);
            return;
          }
        }
        resolve(info);
      }, function (err) {
        cleanUpCancellers();
        reject(err);
      });
      function cleanUpCancellers() {
        requestCanceller.signal.deregister(reject);
        unlinkCanceller();
      }
    });
    /**
     * If the data's seems to be corrupted, throws an `INTEGRITY_ERROR` error.
     * @param {*} data
     */
    function trowOnIntegrityError(data) {
      if (!(data instanceof ArrayBuffer) && !(data instanceof Uint8Array) || inferSegmentContainer(content.adaptation.type, content.representation) !== "mp4") {
        return;
      }
      (0,check_isobmff_integrity/* default */.A)(new Uint8Array(data), content.segment.isInit);
    }
  };
}
// EXTERNAL MODULE: ./src/utils/byte_parsing.ts
var byte_parsing = __webpack_require__(5553);
;// CONCATENATED MODULE: ./src/transports/dash/init_segment_loader.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Perform a request for an initialization segment, agnostic to the container.
 * @param {string} url
 * @param {Object} segment
 * @param {Object} options
 * @param {CancellationSignal} cancelSignal
 * @param {Object} callbacks
 * @returns {Promise}
 */
function initSegmentLoader(url, segment, options, cancelSignal, callbacks) {
  if (segment.range === undefined) {
    return (0,request/* default */.Ay)({
      url: url,
      responseType: "arraybuffer",
      timeout: options.timeout,
      cancelSignal: cancelSignal,
      onProgress: callbacks.onProgress
    }).then(function (data) {
      return {
        resultType: "segment-loaded",
        resultData: data
      };
    });
  }
  if (segment.indexRange === undefined) {
    return (0,request/* default */.Ay)({
      url: url,
      headers: {
        Range: (0,byte_range/* default */.A)(segment.range)
      },
      responseType: "arraybuffer",
      timeout: options.timeout,
      cancelSignal: cancelSignal,
      onProgress: callbacks.onProgress
    }).then(function (data) {
      return {
        resultType: "segment-loaded",
        resultData: data
      };
    });
  }
  // range and indexRange are contiguous (99% of the cases)
  if (segment.range[1] + 1 === segment.indexRange[0]) {
    return (0,request/* default */.Ay)({
      url: url,
      headers: {
        Range: (0,byte_range/* default */.A)([segment.range[0], segment.indexRange[1]])
      },
      responseType: "arraybuffer",
      timeout: options.timeout,
      cancelSignal: cancelSignal,
      onProgress: callbacks.onProgress
    }).then(function (data) {
      return {
        resultType: "segment-loaded",
        resultData: data
      };
    });
  }
  var rangeRequest$ = (0,request/* default */.Ay)({
    url: url,
    headers: {
      Range: (0,byte_range/* default */.A)(segment.range)
    },
    responseType: "arraybuffer",
    timeout: options.timeout,
    cancelSignal: cancelSignal,
    onProgress: callbacks.onProgress
  });
  var indexRequest$ = (0,request/* default */.Ay)({
    url: url,
    headers: {
      Range: (0,byte_range/* default */.A)(segment.indexRange)
    },
    responseType: "arraybuffer",
    timeout: options.timeout,
    cancelSignal: cancelSignal,
    onProgress: callbacks.onProgress
  });
  return Promise.all([rangeRequest$, indexRequest$]).then(function (_ref) {
    var initData = _ref[0],
      indexData = _ref[1];
    var data = (0,byte_parsing/* concat */.xW)(new Uint8Array(initData.responseData), new Uint8Array(indexData.responseData));
    var sendingTime = Math.min(initData.sendingTime, indexData.sendingTime);
    var receivedTime = Math.max(initData.receivedTime, indexData.receivedTime);
    return {
      resultType: "segment-loaded",
      resultData: {
        url: url,
        responseData: data,
        size: initData.size + indexData.size,
        requestDuration: receivedTime - sendingTime,
        sendingTime: sendingTime,
        receivedTime: receivedTime
      }
    };
  });
}
// EXTERNAL MODULE: ./src/transports/utils/find_complete_box.ts
var find_complete_box = __webpack_require__(1688);
;// CONCATENATED MODULE: ./src/transports/dash/extract_complete_chunks.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Take a chunk of ISOBMFF data and extract complete `moof`+`mdat` subsegments
 * which are ready to be decoded.
 * Returns a tuple of two containing first an array of those subsegments
 * followed by tha last un-decodable part.
 * @param {Uint8Array} buffer
 * @returns {Array}
 */
function extractCompleteChunks(buffer) {
  var _position = 0;
  var chunks = [];
  var currentBuffer = null;
  while (_position < buffer.length) {
    currentBuffer = buffer.subarray(_position, Infinity);
    var moofIndex = (0,find_complete_box/* default */.A)(currentBuffer, 0x6d6f6f66 /* moof */);
    if (moofIndex < 0) {
      // no moof, not a segment.
      return [chunks, currentBuffer];
    }
    var moofLen = (0,byte_parsing/* be4toi */.mq)(buffer, moofIndex + _position);
    var moofEnd = _position + moofIndex + moofLen;
    if (moofEnd > buffer.length) {
      // not a complete moof segment
      return [chunks, currentBuffer];
    }
    var mdatIndex = (0,find_complete_box/* default */.A)(currentBuffer, 0x6d646174 /* mdat */);
    if (mdatIndex < 0) {
      // no mdat, not a segment.
      return [chunks, currentBuffer];
    }
    var mdatLen = (0,byte_parsing/* be4toi */.mq)(buffer, mdatIndex + _position);
    var mdatEnd = _position + mdatIndex + mdatLen;
    if (mdatEnd > buffer.length) {
      // not a complete mdat segment
      return [chunks, currentBuffer];
    }
    var maxEnd = Math.max(moofEnd, mdatEnd);
    var chunk = buffer.subarray(_position, maxEnd);
    chunks.push(chunk);
    _position = maxEnd;
  }
  if (chunks.length === 0) {
    return [null, currentBuffer];
  }
  return [chunks, currentBuffer];
}
;// CONCATENATED MODULE: ./src/transports/dash/low_latency_segment_loader.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Load segments through a "chunk" mode (decodable chunk by decodable chunk).
 *
 * This method is particularly adapted to low-latency streams.
 *
 * @param {string} url - URL of the segment to download.
 * @param {Object} content - Context of the segment needed.
 * @param {Object} options
 * @param {Object} callbacks
 * @param {CancellationSignal} cancelSignal
 * @returns {Promise}
 */
function lowLatencySegmentLoader(url, content, options, callbacks, cancelSignal) {
  var segment = content.segment;
  var headers = segment.range !== undefined ? {
    Range: (0,byte_range/* default */.A)(segment.range)
  } : undefined;
  var partialChunk = null;
  /**
   * Called each time `fetch` has new data available.
   * @param {Object} info
   */
  function onData(info) {
    var chunk = new Uint8Array(info.chunk);
    var concatenated = partialChunk !== null ? (0,byte_parsing/* concat */.xW)(partialChunk, chunk) : chunk;
    var res = extractCompleteChunks(concatenated);
    var completeChunks = res[0];
    partialChunk = res[1];
    if (completeChunks !== null) {
      completeChunks.forEach(function (completedChunk) {
        callbacks.onNewChunk(completedChunk);
      });
      if (cancelSignal.isCancelled()) {
        return;
      }
    }
    callbacks.onProgress({
      duration: info.duration,
      size: info.size,
      totalSize: info.totalSize
    });
    if (cancelSignal.isCancelled()) {
      return;
    }
  }
  return fetchRequest({
    url: url,
    headers: headers,
    onData: onData,
    timeout: options.timeout,
    cancelSignal: cancelSignal
  }).then(function (res) {
    return {
      resultType: "chunk-complete",
      resultData: res
    };
  });
}
;// CONCATENATED MODULE: ./src/transports/dash/segment_loader.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */









/**
 * Segment loader triggered if there was no custom-defined one in the API.
 * @param {string} url
 * @param {Object} content
 * @param {boolean} lowLatencyMode
 * @param {Object} options
 * @param {Object} callbacks
 * @param {Object} cancelSignal
 * @returns {Promise}
 */
function regularSegmentLoader(url, content, lowLatencyMode, options, callbacks, cancelSignal) {
  if (content.segment.isInit) {
    return initSegmentLoader(url, content.segment, options, cancelSignal, callbacks);
  }
  var containerType = inferSegmentContainer(content.adaptation.type, content.representation);
  if (lowLatencyMode && (containerType === "mp4" || containerType === undefined)) {
    if (fetchIsSupported()) {
      return lowLatencySegmentLoader(url, content, options, callbacks, cancelSignal);
    } else {
      (0,warn_once/* default */.A)("DASH: Your browser does not have the fetch API. You will have " + "a higher chance of rebuffering when playing close to the live edge");
    }
  }
  var segment = content.segment;
  return (0,request/* default */.Ay)({
    url: url,
    responseType: "arraybuffer",
    headers: segment.range !== undefined ? {
      Range: (0,byte_range/* default */.A)(segment.range)
    } : undefined,
    timeout: options.timeout,
    cancelSignal: cancelSignal,
    onProgress: callbacks.onProgress
  }).then(function (data) {
    return {
      resultType: "segment-loaded",
      resultData: data
    };
  });
}
/**
 * @param {Object} config
 * @returns {Function}
 */
function generateSegmentLoader(_ref) {
  var lowLatencyMode = _ref.lowLatencyMode,
    customSegmentLoader = _ref.segmentLoader,
    checkMediaSegmentIntegrity = _ref.checkMediaSegmentIntegrity;
  return checkMediaSegmentIntegrity !== true ? segmentLoader : addSegmentIntegrityChecks(segmentLoader);
  /**
   * @param {Object|null} wantedCdn
   * @returns {Promise.<Object>}
   */
  function segmentLoader(wantedCdn, content, options, cancelSignal, callbacks) {
    var url = constructSegmentUrl(wantedCdn, content.segment);
    if (url == null) {
      return Promise.resolve({
        resultType: "segment-created",
        resultData: null
      });
    }
    if (lowLatencyMode || customSegmentLoader === undefined) {
      return regularSegmentLoader(url, content, lowLatencyMode, options, callbacks, cancelSignal);
    }
    var args = {
      adaptation: content.adaptation,
      manifest: content.manifest,
      period: content.period,
      representation: content.representation,
      segment: content.segment,
      transport: "dash",
      timeout: options.timeout,
      url: url
    };
    return new Promise(function (res, rej) {
      /** `true` when the custom segmentLoader should not be active anymore. */
      var hasFinished = false;
      /**
       * Callback triggered when the custom segment loader has a response.
       * @param {Object} _args
       */
      var resolve = function resolve(_args) {
        if (hasFinished || cancelSignal.isCancelled()) {
          return;
        }
        hasFinished = true;
        cancelSignal.deregister(abortCustomLoader);
        res({
          resultType: "segment-loaded",
          resultData: {
            responseData: _args.data,
            size: _args.size,
            requestDuration: _args.duration
          }
        });
      };
      /**
       * Callback triggered when the custom segment loader fails
       * @param {*} err - The corresponding error encountered
       */
      var reject = function reject(err) {
        var _a, _b, _c;
        if (hasFinished || cancelSignal.isCancelled()) {
          return;
        }
        hasFinished = true;
        cancelSignal.deregister(abortCustomLoader);
        // Format error and send it
        var castedErr = err;
        var message = (_a = castedErr === null || castedErr === void 0 ? void 0 : castedErr.message) !== null && _a !== void 0 ? _a : "Unknown error when fetching a DASH segment through a " + "custom segmentLoader.";
        var emittedErr = new custom_loader_error/* default */.A(message, (_b = castedErr === null || castedErr === void 0 ? void 0 : castedErr.canRetry) !== null && _b !== void 0 ? _b : false, (_c = castedErr === null || castedErr === void 0 ? void 0 : castedErr.isOfflineError) !== null && _c !== void 0 ? _c : false, castedErr === null || castedErr === void 0 ? void 0 : castedErr.xhr);
        rej(emittedErr);
      };
      var progress = function progress(_args) {
        if (hasFinished || cancelSignal.isCancelled()) {
          return;
        }
        callbacks.onProgress({
          duration: _args.duration,
          size: _args.size,
          totalSize: _args.totalSize
        });
      };
      /**
       * Callback triggered when the custom segment loader wants to fallback to
       * the "regular" implementation
       */
      var fallback = function fallback() {
        if (hasFinished || cancelSignal.isCancelled()) {
          return;
        }
        hasFinished = true;
        cancelSignal.deregister(abortCustomLoader);
        regularSegmentLoader(url, content, lowLatencyMode, options, callbacks, cancelSignal).then(res, rej);
      };
      var customCallbacks = {
        reject: reject,
        resolve: resolve,
        progress: progress,
        fallback: fallback
      };
      var abort = customSegmentLoader(args, customCallbacks);
      cancelSignal.register(abortCustomLoader);
      /**
       * The logic to run when the custom loader is cancelled while pending.
       * @param {Error} err
       */
      function abortCustomLoader(err) {
        if (hasFinished) {
          return;
        }
        hasFinished = true;
        if (typeof abort === "function") {
          abort();
        }
        rej(err);
      }
    });
  }
}
// EXTERNAL MODULE: ./src/parsers/containers/isobmff/take_pssh_out.ts + 1 modules
var take_pssh_out = __webpack_require__(2948);
// EXTERNAL MODULE: ./src/parsers/containers/isobmff/utils.ts
var utils = __webpack_require__(1134);
;// CONCATENATED MODULE: ./src/parsers/containers/matroska/utils.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var SEGMENT_ID = 0x18538067;
var INFO_ID = 0x1549a966;
var TIMECODESCALE_ID = 0x2ad7b1;
var DURATION_ID = 0x4489;
var CUES_ID = 0x1c53bb6b;
var CUE_POINT_ID = 0xbb;
var CUE_TIME_ID = 0xb3;
var CUE_TRACK_POSITIONS_ID = 0xb7;
var CUE_CLUSTER_POSITIONS_ID = 0xf1;
/**
 * Find the offsets of the value linked to the given element ID.
 * @param {number} elementID - ID for the searched element.
 * @param {Array.<number>} parents - eventual IDs of the parent elements. From
 * top level to lower level (from the furthest to the closest).
 * @param {Uint8Array} buffer - buffer where the ID will be searched
 * @param {Array.<number>} range - start and end offsets in the buffer where the
 * ID will be searched.
 * @returns {Array.<number>|null}
 */
function findNextElement(elementID, parents, buffer, _ref) {
  var initialOffset = _ref[0],
    maxOffset = _ref[1];
  var currentOffset = initialOffset;
  while (currentOffset < maxOffset) {
    var parsedID = getEBMLID(buffer, currentOffset);
    if (parsedID == null) {
      return null;
    }
    var ebmlTagID = parsedID.value,
      ebmlTagLength = parsedID.length;
    var sizeOffset = currentOffset + ebmlTagLength;
    var parsedValue = getEBMLValue(buffer, sizeOffset);
    if (parsedValue == null) {
      return null;
    }
    var valueLengthLength = parsedValue.length,
      valueLength = parsedValue.value;
    var valueOffset = sizeOffset + valueLengthLength;
    var valueEndOffset = valueOffset + valueLength;
    if (ebmlTagID === elementID) {
      return [valueOffset, valueEndOffset];
    } else if (parents.length > 0) {
      for (var i = 0; i < parents.length; i++) {
        if (ebmlTagID === parents[i]) {
          var newParents = parents.slice(i + 1, parents.length);
          return findNextElement(elementID, newParents, buffer, [valueOffset, valueEndOffset]);
        }
      }
    }
    currentOffset = valueEndOffset;
  }
  return null;
}
/**
 * Return the timecode scale (basically timescale) of the whole file.
 * @param {Uint8Array} buffer
 * @param {number} initialOffset
 * @returns {number|null}
 */
function getTimeCodeScale(buffer, initialOffset) {
  var timeCodeScaleOffsets = findNextElement(TIMECODESCALE_ID, [SEGMENT_ID, INFO_ID], buffer, [initialOffset, buffer.length]);
  if (timeCodeScaleOffsets == null) {
    return null;
  }
  var length = timeCodeScaleOffsets[1] - timeCodeScaleOffsets[0];
  return 1e9 / bytesToNumber(buffer, timeCodeScaleOffsets[0], length);
}
/**
 * Return the duration of the concerned media.
 * @param {Uint8Array} buffer
 * @param {number} initialOffset
 * @returns {number|null}
 */
function getDuration(buffer, initialOffset) {
  var timeCodeScaleOffsets = findNextElement(DURATION_ID, [SEGMENT_ID, INFO_ID], buffer, [initialOffset, buffer.length]);
  if (timeCodeScaleOffsets == null) {
    return null;
  }
  var length = timeCodeScaleOffsets[1] - timeCodeScaleOffsets[0];
  if (length === 4) {
    return get_IEEE754_32Bits(buffer, timeCodeScaleOffsets[0]);
  } else if (length === 8) {
    return get_IEEE754_64Bits(buffer, timeCodeScaleOffsets[0]);
  }
  return null;
}
/**
 * @param {Uint8Array} buffer
 * @param {number} initialOffset
 * @returns {Array.<Object>|null}
 */
function getSegmentsFromCues(buffer, initialOffset) {
  var segmentRange = findNextElement(SEGMENT_ID, [], buffer, [initialOffset, buffer.length]);
  if (segmentRange == null) {
    return null;
  }
  var segmentRangeStart = segmentRange[0],
    segmentRangeEnd = segmentRange[1];
  var timescale = getTimeCodeScale(buffer, segmentRangeStart);
  if (timescale == null) {
    return null;
  }
  var duration = getDuration(buffer, segmentRangeStart);
  if (duration == null) {
    return null;
  }
  var cuesRange = findNextElement(CUES_ID, [], buffer, [segmentRangeStart, segmentRangeEnd]);
  if (cuesRange == null) {
    return null;
  }
  var rawInfos = [];
  var currentOffset = cuesRange[0];
  while (currentOffset < cuesRange[1]) {
    var cuePointRange = findNextElement(CUE_POINT_ID, [], buffer, [currentOffset, cuesRange[1]]);
    if (cuePointRange == null) {
      break;
    }
    var cueTimeRange = findNextElement(CUE_TIME_ID, [], buffer, [cuePointRange[0], cuePointRange[1]]);
    if (cueTimeRange == null) {
      return null;
    }
    var time = bytesToNumber(buffer, cueTimeRange[0], cueTimeRange[1] - cueTimeRange[0]);
    var cueOffsetRange = findNextElement(CUE_CLUSTER_POSITIONS_ID, [CUE_TRACK_POSITIONS_ID], buffer, [cuePointRange[0], cuePointRange[1]]);
    if (cueOffsetRange == null) {
      return null;
    }
    var rangeStart = bytesToNumber(buffer, cueOffsetRange[0], cueOffsetRange[1] - cueOffsetRange[0]) + segmentRangeStart;
    rawInfos.push({
      time: time,
      rangeStart: rangeStart
    });
    currentOffset = cuePointRange[1];
  }
  var segments = [];
  for (var i = 0; i < rawInfos.length; i++) {
    var currentSegment = rawInfos[i];
    if (i === rawInfos.length - 1) {
      segments.push({
        time: currentSegment.time,
        timescale: timescale,
        duration: i === 0 ? duration : duration - currentSegment.time,
        range: [currentSegment.rangeStart, Infinity]
      });
    } else {
      segments.push({
        time: currentSegment.time,
        timescale: timescale,
        duration: rawInfos[i + 1].time - currentSegment.time,
        range: [currentSegment.rangeStart, rawInfos[i + 1].rangeStart - 1]
      });
    }
  }
  return segments;
}
function getLength(buffer, offset) {
  for (var length = 1; length <= 8; length++) {
    if (buffer[offset] >= Math.pow(2, 8 - length)) {
      return length;
    }
  }
  return undefined;
}
function getEBMLID(buffer, offset) {
  var length = getLength(buffer, offset);
  if (length == null) {
    log/* default */.A.warn("webm: unrepresentable length");
    return null;
  }
  if (offset + length > buffer.length) {
    log/* default */.A.warn("webm: impossible length");
    return null;
  }
  var value = 0;
  for (var i = 0; i < length; i++) {
    value = buffer[offset + i] * Math.pow(2, (length - i - 1) * 8) + value;
  }
  return {
    length: length,
    value: value
  };
}
function getEBMLValue(buffer, offset) {
  var length = getLength(buffer, offset);
  if (length == null) {
    log/* default */.A.warn("webm: unrepresentable length");
    return null;
  }
  if (offset + length > buffer.length) {
    log/* default */.A.warn("webm: impossible length");
    return null;
  }
  var value = (buffer[offset] & (1 << 8 - length) - 1) * Math.pow(2, (length - 1) * 8);
  for (var i = 1; i < length; i++) {
    value = buffer[offset + i] * Math.pow(2, (length - i - 1) * 8) + value;
  }
  return {
    length: length,
    value: value
  };
}
/**
 * Convert a IEEE754 32 bits floating number as an Uint8Array into its
 * corresponding Number.
 * @param {Uint8Array} buffer
 * @param {number} offset
 * @returns {number}
 */
function get_IEEE754_32Bits(buffer, offset) {
  return new DataView(buffer.buffer).getFloat32(offset);
}
/**
 * Convert a IEEE754 64 bits floating number as an Uint8Array into its
 * corresponding Number.
 * @param {Uint8Array} buffer
 * @param {number} offset
 * @returns {number}
 */
function get_IEEE754_64Bits(buffer, offset) {
  return new DataView(buffer.buffer).getFloat64(offset);
}
function bytesToNumber(buffer, offset, length) {
  var value = 0;
  for (var i = 0; i < length; i++) {
    value = buffer[offset + i] * Math.pow(2, (length - i - 1) * 8) + value;
  }
  return value;
}
// EXTERNAL MODULE: ./src/parsers/manifest/dash/common/indexes/base.ts
var base = __webpack_require__(9044);
;// CONCATENATED MODULE: ./src/transports/utils/get_isobmff_timing_infos.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Get precize start and duration of a chunk.
 * @param {UInt8Array} buffer - An ISOBMFF container (at least a `moof` + a
 * `mdat` box.
 * @param {Boolean} isChunked - If true, the whole segment was chunked into
 * multiple parts and buffer is one of them. If false, buffer is the whole
 * segment.
 * @param {Object} segment
 * @param {number|undefined} initTimescale
 * @returns {Object}
 */
function getISOBMFFTimingInfos(buffer, isChunked, segment, initTimescale) {
  var baseDecodeTime = (0,utils/* getTrackFragmentDecodeTime */.D1)(buffer);
  if (baseDecodeTime === undefined || initTimescale === undefined) {
    return null;
  }
  var startTime = segment.timestampOffset !== undefined ? baseDecodeTime + segment.timestampOffset * initTimescale : baseDecodeTime;
  var trunDuration = (0,utils/* getDurationFromTrun */.cS)(buffer);
  if (startTime < 0) {
    if (trunDuration !== undefined) {
      trunDuration += startTime; // remove from duration what comes before `0`
    }
    startTime = 0;
  }
  if (isChunked || !segment.complete) {
    if (trunDuration === undefined) {
      log/* default */.A.warn("DASH: Chunked segments should indicate a duration through their" + " trun boxes");
    }
    return {
      time: startTime / initTimescale,
      duration: trunDuration !== undefined ? trunDuration / initTimescale : undefined
    };
  }
  var duration;
  var segmentDuration = segment.duration * initTimescale;
  // we could always make a mistake when reading a container.
  // If the estimate is too far from what the segment seems to imply, take
  // the segment infos instead.
  var maxDecodeTimeDelta = Math.min(initTimescale * 0.9, segmentDuration / 4);
  if (trunDuration !== undefined && Math.abs(trunDuration - segmentDuration) <= maxDecodeTimeDelta) {
    duration = trunDuration;
  }
  return {
    time: startTime / initTimescale,
    duration: duration !== undefined ? duration / initTimescale : duration
  };
}
;// CONCATENATED MODULE: ./src/transports/dash/get_events_out_of_emsgs.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * From an array of EMSGs with manifest validity scheme id,
 * tells if the manifest needs to be refreshed.
 * @param {Array.<Object>} emsgs
 * @param {Object} segment
 * @param {number} manifestPublishTime
 * @returns {boolean}
 */
function manifestNeedsToBeRefreshed(emsgs, manifestPublishTime) {
  if (emsgs.length <= 0) {
    return false;
  }
  var len = emsgs.length;
  for (var i = 0; i < len; i++) {
    var manifestRefreshEventFromEMSGs = emsgs[i];
    var currentManifestPublishTime = manifestPublishTime;
    var messageData = manifestRefreshEventFromEMSGs.messageData;
    var strPublishTime = (0,string_parsing/* utf8ToStr */.Es)(messageData);
    var eventManifestPublishTime = Date.parse(strPublishTime);
    if (currentManifestPublishTime === undefined || eventManifestPublishTime === undefined || isNaN(eventManifestPublishTime) ||
    // DASH-if 4.3 tells (4.5.2.1) :
    // "The media presentation time beyond the event time (indicated
    // time by presentation_time_delta) is correctly described only
    // by MPDs with publish time greater than indicated value in the
    // message_data field."
    //
    // Here, if the current manifest has its publish time inferior or
    // identical to the event manifest publish time, then the manifest needs
    // to be updated
    eventManifestPublishTime >= currentManifestPublishTime) {
      return true;
    }
  }
  return false;
}
/**
 * Get wrapped inband events and manifest refresh event from
 * parsed ISOBMFF EMSG boxes.
 * @param {Array.<Object>} parsedEMSGs
 * @param {undefined | number} manifestPublishTime
 * @returns {Object}
 */
function getEventsOutOfEMSGs(parsedEMSGs, manifestPublishTime) {
  if (parsedEMSGs.length === 0) {
    return undefined;
  }
  var _parsedEMSGs$reduce = parsedEMSGs.reduce(function (acc, val) {
      // Scheme that signals manifest update
      if (val.schemeIdUri === "urn:mpeg:dash:event:2012" &&
      // TODO support value 2 and 3
      val.value === "1") {
        if (acc.manifestRefreshEventsFromEMSGs === undefined) {
          acc.manifestRefreshEventsFromEMSGs = [];
        }
        acc.manifestRefreshEventsFromEMSGs.push(val);
      } else {
        if (acc.EMSGs === undefined) {
          acc.EMSGs = [];
        }
        acc.EMSGs.push(val);
      }
      return acc;
    }, {
      manifestRefreshEventsFromEMSGs: undefined,
      EMSGs: undefined
    }),
    manifestRefreshEventsFromEMSGs = _parsedEMSGs$reduce.manifestRefreshEventsFromEMSGs,
    EMSGs = _parsedEMSGs$reduce.EMSGs;
  var inbandEvents = EMSGs === null || EMSGs === void 0 ? void 0 : EMSGs.map(function (evt) {
    return {
      type: "emsg",
      value: evt
    };
  });
  var needsManifestRefresh = manifestPublishTime === undefined || manifestRefreshEventsFromEMSGs === undefined ? false : manifestNeedsToBeRefreshed(manifestRefreshEventsFromEMSGs, manifestPublishTime);
  return {
    inbandEvents: inbandEvents,
    needsManifestRefresh: needsManifestRefresh
  };
}
;// CONCATENATED MODULE: ./src/transports/dash/segment_parser.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */








/**
 * @param {Object} config
 * @returns {Function}
 */
function generateAudioVideoSegmentParser(_ref) {
  var __priv_patchLastSegmentInSidx = _ref.__priv_patchLastSegmentInSidx;
  return function audioVideoSegmentParser(loadedSegment, content, initTimescale) {
    var _a, _b;
    var period = content.period,
      adaptation = content.adaptation,
      representation = content.representation,
      segment = content.segment,
      manifest = content.manifest;
    var data = loadedSegment.data,
      isChunked = loadedSegment.isChunked;
    var appendWindow = [period.start, period.end];
    if (data === null) {
      if (segment.isInit) {
        return {
          segmentType: "init",
          initializationData: null,
          initializationDataSize: 0,
          protectionDataUpdate: false,
          initTimescale: undefined
        };
      }
      return {
        segmentType: "media",
        chunkData: null,
        chunkSize: 0,
        chunkInfos: null,
        chunkOffset: 0,
        protectionDataUpdate: false,
        appendWindow: appendWindow
      };
    }
    var chunkData = data instanceof Uint8Array ? data : new Uint8Array(data);
    var containerType = inferSegmentContainer(adaptation.type, representation);
    // TODO take a look to check if this is an ISOBMFF/webm?
    var seemsToBeMP4 = containerType === "mp4" || containerType === undefined;
    var protectionDataUpdate = false;
    if (seemsToBeMP4) {
      var psshInfo = (0,take_pssh_out/* default */.A)(chunkData);
      var keyId;
      if (segment.isInit) {
        keyId = (_a = (0,utils/* getKeyIdFromInitSegment */.a5)(chunkData)) !== null && _a !== void 0 ? _a : undefined;
      }
      if (psshInfo.length > 0 || keyId !== undefined) {
        protectionDataUpdate = representation._addProtectionData("cenc", keyId, psshInfo);
      }
    }
    if (!segment.isInit) {
      var chunkInfos = seemsToBeMP4 ? getISOBMFFTimingInfos(chunkData, isChunked, segment, initTimescale) : null; // TODO extract time info from webm
      var chunkOffset = (_b = segment.timestampOffset) !== null && _b !== void 0 ? _b : 0;
      if (seemsToBeMP4) {
        var parsedEMSGs = (0,utils/* parseEmsgBoxes */.pk)(chunkData);
        if (parsedEMSGs !== undefined) {
          var whitelistedEMSGs = parsedEMSGs.filter(function (evt) {
            if (segment.privateInfos === undefined || segment.privateInfos.isEMSGWhitelisted === undefined) {
              return false;
            }
            return segment.privateInfos.isEMSGWhitelisted(evt);
          });
          var events = getEventsOutOfEMSGs(whitelistedEMSGs, manifest.publishTime);
          if (events !== undefined) {
            var needsManifestRefresh = events.needsManifestRefresh,
              inbandEvents = events.inbandEvents;
            return {
              segmentType: "media",
              chunkData: chunkData,
              chunkSize: chunkData.length,
              chunkInfos: chunkInfos,
              chunkOffset: chunkOffset,
              appendWindow: appendWindow,
              inbandEvents: inbandEvents,
              protectionDataUpdate: protectionDataUpdate,
              needsManifestRefresh: needsManifestRefresh
            };
          }
        }
      }
      return {
        segmentType: "media",
        chunkData: chunkData,
        chunkSize: chunkData.length,
        chunkInfos: chunkInfos,
        chunkOffset: chunkOffset,
        protectionDataUpdate: protectionDataUpdate,
        appendWindow: appendWindow
      };
    }
    // we're handling an initialization segment
    var indexRange = segment.indexRange;
    var nextSegments = null;
    if (containerType === "webm") {
      nextSegments = getSegmentsFromCues(chunkData, 0);
    } else if (seemsToBeMP4) {
      nextSegments = (0,utils/* getSegmentsFromSidx */.Tr)(chunkData, Array.isArray(indexRange) ? indexRange[0] : 0);
      // This is a very specific handling for streams we know have a very
      // specific problem at Canal+: The last reference gives a truncated
      // segment.
      // Sadly, people on the packaging side could not fix all legacy contents.
      // This is an easy-but-ugly fix for those.
      // TODO Cleaner way? I tried to always check the obtained segment after
      // a byte-range request but it leads to a lot of code.
      if (__priv_patchLastSegmentInSidx === true && nextSegments !== null && nextSegments.length > 0) {
        var lastSegment = nextSegments[nextSegments.length - 1];
        if (Array.isArray(lastSegment.range)) {
          lastSegment.range[1] = Infinity;
        }
      }
    }
    if (representation.index instanceof base/* default */.A && nextSegments !== null && nextSegments.length > 0) {
      representation.index.initializeIndex(nextSegments);
    }
    var timescale = seemsToBeMP4 ? (0,utils/* getMDHDTimescale */.zS)(chunkData) : containerType === "webm" ? getTimeCodeScale(chunkData, 0) : undefined;
    var parsedTimescale = (0,is_null_or_undefined/* default */.A)(timescale) ? undefined : timescale;
    return {
      segmentType: "init",
      initializationData: chunkData,
      initializationDataSize: chunkData.length,
      protectionDataUpdate: protectionDataUpdate,
      initTimescale: parsedTimescale
    };
  };
}
;// CONCATENATED MODULE: ./src/transports/dash/text_loader.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */








/**
 * Perform requests for "text" segments
 * @param {boolean} lowLatencyMode
 * @returns {Function}
 */
function generateTextTrackLoader(_ref) {
  var lowLatencyMode = _ref.lowLatencyMode,
    checkMediaSegmentIntegrity = _ref.checkMediaSegmentIntegrity;
  return checkMediaSegmentIntegrity !== true ? textTrackLoader : addSegmentIntegrityChecks(textTrackLoader);
  /**
   * @param {Object|null} wantedCdn
   * @param {Object} content
   * @param {Object} options
   * @param {Object} cancelSignal
   * @param {Object} callbacks
   * @returns {Promise}
   */
  function textTrackLoader(wantedCdn, content, options, cancelSignal, callbacks) {
    var adaptation = content.adaptation,
      representation = content.representation,
      segment = content.segment;
    var range = segment.range;
    var url = constructSegmentUrl(wantedCdn, segment);
    if (url === null) {
      return Promise.resolve({
        resultType: "segment-created",
        resultData: null
      });
    }
    if (segment.isInit) {
      return initSegmentLoader(url, segment, options, cancelSignal, callbacks);
    }
    var containerType = inferSegmentContainer(adaptation.type, representation);
    var seemsToBeMP4 = containerType === "mp4" || containerType === undefined;
    if (lowLatencyMode && seemsToBeMP4) {
      if (fetchIsSupported()) {
        return lowLatencySegmentLoader(url, content, options, callbacks, cancelSignal);
      } else {
        (0,warn_once/* default */.A)("DASH: Your browser does not have the fetch API. You will have " + "a higher chance of rebuffering when playing close to the live edge");
      }
    }
    if (seemsToBeMP4) {
      return (0,request/* default */.Ay)({
        url: url,
        responseType: "arraybuffer",
        headers: Array.isArray(range) ? {
          Range: (0,byte_range/* default */.A)(range)
        } : null,
        timeout: options.timeout,
        onProgress: callbacks.onProgress,
        cancelSignal: cancelSignal
      }).then(function (data) {
        return {
          resultType: "segment-loaded",
          resultData: data
        };
      });
    }
    return (0,request/* default */.Ay)({
      url: url,
      responseType: "text",
      headers: Array.isArray(range) ? {
        Range: (0,byte_range/* default */.A)(range)
      } : null,
      timeout: options.timeout,
      onProgress: callbacks.onProgress,
      cancelSignal: cancelSignal
    }).then(function (data) {
      return {
        resultType: "segment-loaded",
        resultData: data
      };
    });
  }
}
// EXTERNAL MODULE: ./src/parsers/containers/isobmff/read.ts
var read = __webpack_require__(2875);
;// CONCATENATED MODULE: ./src/transports/utils/parse_text_track.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Return plain text text track from the given ISOBMFF.
 * @param {Uint8Array} chunkBytes
 * @returns {string}
 */
function extractTextTrackFromISOBMFF(chunkBytes) {
  var mdat = (0,read/* getMDAT */.j8)(chunkBytes);
  return mdat === null ? "" : (0,string_parsing/* utf8ToStr */.Es)(mdat);
}
/**
 * Returns the a string expliciting the format of a text track when that text
 * track is embedded into a ISOBMFF file.
 * @param {Object} representation
 * @returns {string}
 */
function getISOBMFFTextTrackFormat(representation) {
  var codec = representation.codec;
  if (codec === undefined) {
    throw new Error("Cannot parse subtitles: unknown format");
  }
  switch (codec.toLowerCase()) {
    case "stpp": // stpp === TTML in MP4
    case "stpp.ttml":
    case "stpp.ttml.im1t":
      return "ttml";
    case "wvtt":
      // wvtt === WebVTT in MP4
      return "vtt";
  }
  throw new Error("The codec used for the subtitles " + ("\"" + codec + "\" is not managed yet."));
}
/**
 * Returns the a string expliciting the format of a text track in plain text.
 * @param {Object} representation
 * @returns {string}
 */
function getPlainTextTrackFormat(representation) {
  var _representation$mimeT = representation.mimeType,
    mimeType = _representation$mimeT === void 0 ? "" : _representation$mimeT;
  switch (representation.mimeType) {
    case "application/ttml+xml":
      return "ttml";
    case "application/x-sami":
    case "application/smil":
      return "sami";
    case "text/vtt":
      return "vtt";
  }
  var _representation$codec = representation.codec,
    codec = _representation$codec === void 0 ? "" : _representation$codec;
  var codeLC = codec.toLowerCase();
  if (codeLC === "srt") {
    return "srt";
  }
  throw new Error("could not find a text-track parser for the type " + mimeType);
}
/**
 * @param {Object} content
 * @param {ArrayBuffer|UInt8Array|null} chunkData
 * @param {Object|null} chunkInfos
 * @param {boolean} isChunked
 * @returns {Object|null}
 */
function getISOBMFFEmbeddedTextTrackData(_ref, chunkBytes, chunkInfos, isChunked) {
  var segment = _ref.segment,
    adaptation = _ref.adaptation,
    representation = _ref.representation;
  if (segment.isInit) {
    return null;
  }
  var startTime;
  var endTime;
  if (chunkInfos === null) {
    if (!isChunked) {
      log/* default */.A.warn("Transport: Unavailable time data for current text track.");
    } else {
      startTime = segment.time;
      endTime = segment.end;
    }
  } else {
    startTime = chunkInfos.time;
    if (chunkInfos.duration !== undefined) {
      endTime = startTime + chunkInfos.duration;
    } else if (!isChunked && segment.complete) {
      endTime = startTime + segment.duration;
    }
  }
  var type = getISOBMFFTextTrackFormat(representation);
  var textData = extractTextTrackFromISOBMFF(chunkBytes);
  return {
    data: textData,
    type: type,
    language: adaptation.language,
    start: startTime,
    end: endTime
  };
}
/**
 * @param {Object} content
 * @param {ArrayBuffer|UInt8Array|null} chunkData
 * @param {Object|null} chunkInfos
 * @param {boolean} isChunked
 * @returns {Object|null}
 */
function getPlainTextTrackData(_ref2, textTrackData, isChunked) {
  var segment = _ref2.segment,
    adaptation = _ref2.adaptation,
    representation = _ref2.representation;
  if (segment.isInit) {
    return null;
  }
  var start;
  var end;
  if (isChunked) {
    log/* default */.A.warn("Transport: Unavailable time data for current text track.");
  } else {
    start = segment.time;
    if (segment.complete) {
      end = segment.time + segment.duration;
    }
  }
  var type = getPlainTextTrackFormat(representation);
  return {
    data: textTrackData,
    type: type,
    language: adaptation.language,
    start: start,
    end: end
  };
}
;// CONCATENATED MODULE: ./src/transports/dash/text_parser.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






/**
 * Parse TextTrack data when it is embedded in an ISOBMFF file.
 *
 * @param {ArrayBuffer|Uint8Array|string} data - The segment data.
 * @param {boolean} isChunked - If `true`, the `data` may contain only a
 * decodable subpart of the full data in the linked segment.
 * @param {Object} content - Object describing the context of the given
 * segment's data: of which segment, `Representation`, `Adaptation`, `Period`,
 * `Manifest` it is a part of etc.
 * @param {number|undefined} initTimescale - `timescale` value - encountered
 * in this linked initialization segment (if it exists) - that may also apply
 * to that segment if no new timescale is defined in it.
 * Can be `undefined` if no timescale was defined, if it is not known, or if
 * no linked initialization segment was yet parsed.
 * @param {boolean} __priv_patchLastSegmentInSidx - Enable ugly Canal+-specific
 * fix for an issue people on the content-packaging side could not fix.
 * For more information on that, look at the code using it.
 * @returns {Object}
 */
function parseISOBMFFEmbeddedTextTrack(data, isChunked, content, initTimescale, __priv_patchLastSegmentInSidx) {
  var _a;
  var period = content.period,
    representation = content.representation,
    segment = content.segment;
  var isInit = segment.isInit,
    indexRange = segment.indexRange;
  var chunkBytes = typeof data === "string" ? (0,string_parsing/* strToUtf8 */.eb)(data) : data instanceof Uint8Array ? data : new Uint8Array(data);
  if (isInit) {
    var sidxSegments = (0,utils/* getSegmentsFromSidx */.Tr)(chunkBytes, Array.isArray(indexRange) ? indexRange[0] : 0);
    // This is a very specific handling for streams we know have a very
    // specific problem at Canal+: The last reference gives a truncated
    // segment.
    // Sadly, people on the packaging side could not fix all legacy contents.
    // This is an easy-but-ugly fix for those.
    // TODO Cleaner way? I tried to always check the obtained segment after
    // a byte-range request but it leads to a lot of code.
    if (__priv_patchLastSegmentInSidx === true && sidxSegments !== null && sidxSegments.length > 0) {
      var lastSegment = sidxSegments[sidxSegments.length - 1];
      if (Array.isArray(lastSegment.range)) {
        lastSegment.range[1] = Infinity;
      }
    }
    var mdhdTimescale = (0,utils/* getMDHDTimescale */.zS)(chunkBytes);
    if (representation.index instanceof base/* default */.A && sidxSegments !== null && sidxSegments.length > 0) {
      representation.index.initializeIndex(sidxSegments);
    }
    return {
      segmentType: "init",
      initializationData: null,
      initializationDataSize: 0,
      protectionDataUpdate: false,
      initTimescale: mdhdTimescale
    };
  }
  var chunkInfos = getISOBMFFTimingInfos(chunkBytes, isChunked, segment, initTimescale);
  var chunkData = getISOBMFFEmbeddedTextTrackData(content, chunkBytes, chunkInfos, isChunked);
  var chunkOffset = (_a = segment.timestampOffset) !== null && _a !== void 0 ? _a : 0;
  return {
    segmentType: "media",
    chunkData: chunkData,
    chunkSize: chunkBytes.length,
    chunkInfos: chunkInfos,
    chunkOffset: chunkOffset,
    protectionDataUpdate: false,
    appendWindow: [period.start, period.end]
  };
}
/**
 * Parse TextTrack data when it is in plain text form.
 *
 * @param {ArrayBuffer|Uint8Array|string} data - The segment data.
 * @param {boolean} isChunked - If `true`, the `data` may contain only a
 * decodable subpart of the full data in the linked segment.
 * @param {Object} content - Object describing the context of the given
 * segment's data: of which segment, `Representation`, `Adaptation`, `Period`,
 * `Manifest` it is a part of etc.
 * @returns {Object}
 */
function parsePlainTextTrack(data, isChunked, content) {
  var period = content.period,
    segment = content.segment;
  var _segment$timestampOff = segment.timestampOffset,
    timestampOffset = _segment$timestampOff === void 0 ? 0 : _segment$timestampOff;
  if (segment.isInit) {
    return {
      segmentType: "init",
      initializationData: null,
      initializationDataSize: 0,
      protectionDataUpdate: false,
      initTimescale: undefined
    };
  }
  var textTrackData;
  var chunkSize;
  if (typeof data !== "string") {
    var bytesData = data instanceof Uint8Array ? data : new Uint8Array(data);
    textTrackData = (0,string_parsing/* utf8ToStr */.Es)(bytesData);
    chunkSize = bytesData.length;
  } else {
    textTrackData = data;
  }
  var chunkData = getPlainTextTrackData(content, textTrackData, isChunked);
  return {
    segmentType: "media",
    chunkData: chunkData,
    chunkSize: chunkSize,
    chunkInfos: null,
    chunkOffset: timestampOffset,
    protectionDataUpdate: false,
    appendWindow: [period.start, period.end]
  };
}
/**
 * Generate a "segment parser" for DASH text tracks.
 *
 * @param {Object} config
 * @returns {Function}
 */
function generateTextTrackParser(_ref) {
  var __priv_patchLastSegmentInSidx = _ref.__priv_patchLastSegmentInSidx;
  /**
   * Parse TextTrack data.
   * @param {Object} loadedSegment
   * @param {Object} content
   * @param {number|undefined} initTimescale
   * @returns {Object}
   */
  return function textTrackParser(loadedSegment, content, initTimescale) {
    var _a;
    var period = content.period,
      adaptation = content.adaptation,
      representation = content.representation,
      segment = content.segment;
    var data = loadedSegment.data,
      isChunked = loadedSegment.isChunked;
    if (data === null) {
      // No data, just return an empty placeholder object
      return segment.isInit ? {
        segmentType: "init",
        initializationData: null,
        initializationDataSize: 0,
        protectionDataUpdate: false,
        initTimescale: undefined
      } : {
        segmentType: "media",
        chunkData: null,
        chunkSize: 0,
        chunkInfos: null,
        chunkOffset: (_a = segment.timestampOffset) !== null && _a !== void 0 ? _a : 0,
        protectionDataUpdate: false,
        appendWindow: [period.start, period.end]
      };
    }
    var containerType = inferSegmentContainer(adaptation.type, representation);
    // TODO take a look to check if this is an ISOBMFF/webm when undefined?
    if (containerType === "webm") {
      // TODO Handle webm containers
      throw new Error("Text tracks with a WEBM container are not yet handled.");
    } else if (containerType === "mp4") {
      return parseISOBMFFEmbeddedTextTrack(data, isChunked, content, initTimescale, __priv_patchLastSegmentInSidx);
    } else {
      return parsePlainTextTrack(data, isChunked, content);
    }
  };
}
;// CONCATENATED MODULE: ./src/transports/dash/pipelines.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */








/**
 * Returns pipelines used for DASH streaming.
 * @param {Object} options
 * implementation. Used for each generated http request.
 * @returns {Object}
 */
/* harmony default export */ function pipelines(options) {
  var manifestLoader = (0,generate_manifest_loader/* default */.A)({
    customManifestLoader: options.manifestLoader
  }, mightUseDashWasmFeature() ? "text" : "arraybuffer");
  var manifestParser = generateManifestParser(options);
  var segmentLoader = generateSegmentLoader(options);
  var audioVideoSegmentParser = generateAudioVideoSegmentParser(options);
  var textTrackLoader = generateTextTrackLoader(options);
  var textTrackParser = generateTextTrackParser(options);
  return {
    manifest: {
      loadManifest: manifestLoader,
      parseManifest: manifestParser
    },
    audio: {
      loadSegment: segmentLoader,
      parseSegment: audioVideoSegmentParser
    },
    video: {
      loadSegment: segmentLoader,
      parseSegment: audioVideoSegmentParser
    },
    text: {
      loadSegment: textTrackLoader,
      parseSegment: textTrackParser
    },
    image: {
      loadSegment: imageLoader,
      parseSegment: imageParser
    }
  };
}
/**
 * Returns true if the DASH-WASM parser is either initialized or being
 * initialized.
 * @returns {boolean}
 */
function mightUseDashWasmFeature() {
  return features/* default */.A.dashParsers.wasm !== null && (features/* default */.A.dashParsers.wasm.status === "initialized" || features/* default */.A.dashParsers.wasm.status === "initializing");
}
;// CONCATENATED MODULE: ./src/transports/dash/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */

/* harmony default export */ var dash = (pipelines);

/***/ }),

/***/ 5564:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: function() { return /* binding */ transports_smooth; }
});

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js
var asyncToGenerator = __webpack_require__(467);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/regenerator/index.js
var regenerator = __webpack_require__(4756);
var regenerator_default = /*#__PURE__*/__webpack_require__.n(regenerator);
// EXTERNAL MODULE: ./src/features/index.ts
var features = __webpack_require__(418);
// EXTERNAL MODULE: ./src/log.ts + 1 modules
var log = __webpack_require__(9477);
// EXTERNAL MODULE: ./src/manifest/index.ts + 6 modules
var src_manifest = __webpack_require__(8568);
// EXTERNAL MODULE: ./src/parsers/containers/isobmff/read.ts
var read = __webpack_require__(2875);
// EXTERNAL MODULE: ./src/errors/network_error.ts
var network_error = __webpack_require__(7941);
// EXTERNAL MODULE: ./src/utils/assert.ts
var assert = __webpack_require__(7994);
// EXTERNAL MODULE: ./src/parsers/manifest/utils/clear_timeline_from_position.ts
var clear_timeline_from_position = __webpack_require__(5019);
// EXTERNAL MODULE: ./src/parsers/manifest/utils/index_helpers.ts
var index_helpers = __webpack_require__(3877);
// EXTERNAL MODULE: ./src/parsers/manifest/utils/update_segment_timeline.ts
var update_segment_timeline = __webpack_require__(860);
;// CONCATENATED MODULE: ./src/parsers/manifest/smooth/utils/add_segment_infos.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Add a new segment to the index.
 *
 * /!\ Mutate the given index
 * @param {Object} index
 * @param {Object} newSegment
 * @param {Object} currentSegment
 * @returns {Boolean} - true if the segment has been added
 */
function _addSegmentInfos(index, newSegment, currentSegment) {
  var timeline = index.timeline,
    timescale = index.timescale;
  var timelineLength = timeline.length;
  var last = timeline[timelineLength - 1];
  var scaledNewSegment = newSegment.timescale === timescale ? {
    time: newSegment.time,
    duration: newSegment.duration
  } : {
    time: newSegment.time / newSegment.timescale * timescale,
    duration: newSegment.duration / newSegment.timescale * timescale
  };
  // in some circumstances, the new segment information are only duration
  // information that we could use to deduct the start of the next segment.
  // This is the case where the new segment are associated to a current
  // segment and have the same start.
  // However, we prefer to be sure of the duration of the new segments
  // before adding such segments.
  var shouldDeductNextSegment = currentSegment.time === scaledNewSegment.time;
  if (shouldDeductNextSegment) {
    return false;
  } else if (scaledNewSegment.time >= (0,index_helpers/* getIndexSegmentEnd */.Rb)(last, null)) {
    // if the given timing has a timestamp after the timeline end we
    // just need to push a new element in the timeline, or increase
    // the @r attribute of the last element.
    if (last.duration === scaledNewSegment.duration) {
      last.repeatCount++;
    } else {
      index.timeline.push({
        duration: scaledNewSegment.duration,
        start: scaledNewSegment.time,
        repeatCount: 0
      });
    }
    return true;
  }
  return false;
}
;// CONCATENATED MODULE: ./src/parsers/manifest/smooth/utils/tokens.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @param {string} url
 * @param {string|number} bitrate
 * @returns {string}
 */
function replaceRepresentationSmoothTokens(url, bitrate, customAttributes) {
  return url.replace(/\{bitrate\}/g, String(bitrate)).replace(/{CustomAttributes}/g, customAttributes.length > 0 ? customAttributes[0] : "");
}
/**
 * @param {string} url
 * @param {number} time
 * @returns {string}
 */
function replaceSegmentSmoothTokens(url, time) {
  return url.replace(/\{start time\}/g, String(time));
}

;// CONCATENATED MODULE: ./src/parsers/manifest/smooth/representation_index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */








/**
 * @param {Number} start
 * @param {Number} up
 * @param {Number} duration
 * @returns {Number}
 */
function getSegmentNumber(start, up, duration) {
  var diff = up - start;
  return diff > 0 ? Math.floor(diff / duration) : 0;
}
/**
 * Convert second-based start time and duration to the timescale of the
 * manifest's index.
 * @param {Object} index
 * @param {Number} start
 * @param {Number} duration
 * @returns {Object} - Object with two properties:
 *   - up {Number}: timescaled timestamp of the beginning time
 *   - to {Number}: timescaled timestamp of the end time (start time + duration)
 */
function normalizeRange(index, start, duration) {
  var timescale = index.timescale === undefined || index.timescale === 0 ? 1 : index.timescale;
  return {
    up: start * timescale,
    to: (start + duration) * timescale
  };
}
/**
 * Calculate the number of times a segment repeat based on the next segment.
 * @param {Object} segment
 * @param {Object} nextSegment
 * @returns {Number}
 */
function calculateRepeat(segment, nextSegment) {
  var repeatCount = segment.repeatCount;
  // A negative value of the @r attribute of the S element indicates
  // that the duration indicated in @d attribute repeats until the
  // start of the next S element, the end of the Period or until the
  // next MPD update.
  // TODO Also for SMOOTH????
  if (segment.duration != null && repeatCount < 0) {
    var repeatEnd = nextSegment !== undefined ? nextSegment.start : Infinity;
    repeatCount = Math.ceil((repeatEnd - segment.start) / segment.duration) - 1;
  }
  return repeatCount;
}
/**
 * RepresentationIndex implementation for Smooth Manifests.
 *
 * Allows to interact with the index to create new Segments.
 *
 * @class SmoothRepresentationIndex
 */
var SmoothRepresentationIndex = /*#__PURE__*/function () {
  /**
   * Creates a new `SmoothRepresentationIndex`.
   * @param {Object} index
   * @param {Object} options
   */
  function SmoothRepresentationIndex(index, options) {
    var aggressiveMode = options.aggressiveMode,
      isLive = options.isLive,
      segmentPrivateInfos = options.segmentPrivateInfos,
      timeShiftBufferDepth = options.timeShiftBufferDepth;
    var estimatedReceivedTime = options.manifestReceivedTime == null ? performance.now() : options.manifestReceivedTime;
    this._index = index;
    this._indexValidityTime = estimatedReceivedTime;
    this._timeShiftBufferDepth = timeShiftBufferDepth;
    this._initSegmentInfos = {
      bitsPerSample: segmentPrivateInfos.bitsPerSample,
      channels: segmentPrivateInfos.channels,
      codecPrivateData: segmentPrivateInfos.codecPrivateData,
      packetSize: segmentPrivateInfos.packetSize,
      samplingRate: segmentPrivateInfos.samplingRate,
      timescale: index.timescale,
      protection: segmentPrivateInfos.protection
    };
    this._isAggressiveMode = aggressiveMode;
    this._isLive = isLive;
    if (index.timeline.length !== 0) {
      var lastItem = index.timeline[index.timeline.length - 1];
      var scaledEnd = (0,index_helpers/* getIndexSegmentEnd */.Rb)(lastItem, null);
      this._initialScaledLastPosition = scaledEnd;
      if (isLive) {
        var scaledReceivedTime = estimatedReceivedTime / 1000 * index.timescale;
        this._scaledLiveGap = scaledReceivedTime - scaledEnd;
      }
    }
  }
  /**
   * Construct init Segment compatible with a Smooth Manifest.
   * @returns {Object}
   */
  var _proto = SmoothRepresentationIndex.prototype;
  _proto.getInitSegment = function getInitSegment() {
    return {
      id: "init",
      isInit: true,
      privateInfos: {
        smoothInitSegment: this._initSegmentInfos
      },
      url: null,
      time: 0,
      end: 0,
      duration: 0,
      timescale: 1,
      complete: true
    };
  }
  /**
   * Generate a list of Segments for a particular period of time.
   *
   * @param {Number} from
   * @param {Number} dur
   * @returns {Array.<Object>}
   */;
  _proto.getSegments = function getSegments(from, dur) {
    this._refreshTimeline();
    var _normalizeRange = normalizeRange(this._index, from, dur),
      up = _normalizeRange.up,
      to = _normalizeRange.to;
    var _this$_index = this._index,
      timeline = _this$_index.timeline,
      timescale = _this$_index.timescale,
      media = _this$_index.media;
    var isAggressive = this._isAggressiveMode;
    var currentNumber;
    var segments = [];
    var timelineLength = timeline.length;
    var maxPosition = this._scaledLiveGap == null ? undefined : performance.now() / 1000 * timescale - this._scaledLiveGap;
    for (var i = 0; i < timelineLength; i++) {
      var segmentRange = timeline[i];
      var duration = segmentRange.duration,
        start = segmentRange.start;
      var repeat = calculateRepeat(segmentRange, timeline[i + 1]);
      var segmentNumberInCurrentRange = getSegmentNumber(start, up, duration);
      var segmentTime = start + segmentNumberInCurrentRange * duration;
      var timeToAddToCheckMaxPosition = isAggressive ? 0 : duration;
      while (segmentTime < to && segmentNumberInCurrentRange <= repeat && (maxPosition == null || segmentTime + timeToAddToCheckMaxPosition <= maxPosition)) {
        var time = segmentTime;
        var number = currentNumber != null ? currentNumber + segmentNumberInCurrentRange : undefined;
        var segment = {
          id: String(segmentTime),
          isInit: false,
          time: time / timescale,
          end: (time + duration) / timescale,
          duration: duration / timescale,
          timescale: 1,
          number: number,
          url: replaceSegmentSmoothTokens(media, time),
          complete: true,
          privateInfos: {
            smoothMediaSegment: {
              time: time,
              duration: duration
            }
          }
        };
        segments.push(segment);
        // update segment number and segment time for the next segment
        segmentNumberInCurrentRange++;
        segmentTime = start + segmentNumberInCurrentRange * duration;
      }
      if (segmentTime >= to) {
        // we reached ``to``, we're done
        return segments;
      }
      if (currentNumber != null) {
        currentNumber += repeat + 1;
      }
    }
    return segments;
  }
  /**
   * Returns true if, based on the arguments, the index should be refreshed.
   * (If we should re-fetch the manifest)
   * @param {Number} up
   * @param {Number} to
   * @returns {Boolean}
   */;
  _proto.shouldRefresh = function shouldRefresh(up, to) {
    this._refreshTimeline();
    if (!this._isLive) {
      return false;
    }
    var _this$_index2 = this._index,
      timeline = _this$_index2.timeline,
      timescale = _this$_index2.timescale;
    var lastSegmentInCurrentTimeline = timeline[timeline.length - 1];
    if (lastSegmentInCurrentTimeline === undefined) {
      return false;
    }
    var repeat = lastSegmentInCurrentTimeline.repeatCount;
    var endOfLastSegmentInCurrentTimeline = lastSegmentInCurrentTimeline.start + (repeat + 1) * lastSegmentInCurrentTimeline.duration;
    if (to * timescale < endOfLastSegmentInCurrentTimeline) {
      return false;
    }
    if (up * timescale >= endOfLastSegmentInCurrentTimeline) {
      return true;
    }
    // ----
    var startOfLastSegmentInCurrentTimeline = lastSegmentInCurrentTimeline.start + repeat * lastSegmentInCurrentTimeline.duration;
    return up * timescale > startOfLastSegmentInCurrentTimeline;
  }
  /**
   * Returns first position available in the index.
   * @returns {Number|null}
   */;
  _proto.getFirstAvailablePosition = function getFirstAvailablePosition() {
    this._refreshTimeline();
    var index = this._index;
    if (index.timeline.length === 0) {
      return null;
    }
    return index.timeline[0].start / index.timescale;
  }
  /**
   * Returns last position available in the index.
   * @returns {Number}
   */;
  _proto.getLastAvailablePosition = function getLastAvailablePosition() {
    this._refreshTimeline();
    var index = this._index;
    if (this._scaledLiveGap == null) {
      var lastTimelineElement = index.timeline[index.timeline.length - 1];
      return (0,index_helpers/* getIndexSegmentEnd */.Rb)(lastTimelineElement, null) / index.timescale;
    }
    for (var i = index.timeline.length - 1; i >= 0; i--) {
      var timelineElt = index.timeline[i];
      var timescaledNow = performance.now() / 1000 * index.timescale;
      var start = timelineElt.start,
        duration = timelineElt.duration,
        repeatCount = timelineElt.repeatCount;
      for (var j = repeatCount; j >= 0; j--) {
        var end = start + duration * (j + 1);
        var positionToReach = this._isAggressiveMode ? end - duration : end;
        if (positionToReach <= timescaledNow - this._scaledLiveGap) {
          return end / index.timescale;
        }
      }
    }
    return undefined;
  }
  /**
   * Returns the absolute end in seconds this RepresentationIndex can reach once
   * all segments are available.
   * @returns {number|null|undefined}
   */;
  _proto.getEnd = function getEnd() {
    if (!this._isLive) {
      return this.getLastAvailablePosition();
    }
    return undefined;
  }
  /**
   * Returns:
   *   - `true` if in the given time interval, at least one new segment is
   *     expected to be available in the future.
   *   - `false` either if all segments in that time interval are already
   *     available for download or if none will ever be available for it.
   *   - `undefined` when it is not possible to tell.
   * @param {number} start
   * @param {number} end
   * @returns {boolean|undefined}
   */;
  _proto.awaitSegmentBetween = function awaitSegmentBetween(start, end) {
    var _a;
    (0,assert/* default */.h)(start <= end);
    if (this.isStillAwaitingFutureSegments()) {
      return false;
    }
    var lastAvailablePosition = this.getLastAvailablePosition();
    if (lastAvailablePosition !== undefined && end < lastAvailablePosition) {
      return false;
    }
    return end > ((_a = this.getFirstAvailablePosition()) !== null && _a !== void 0 ? _a : 0) ? undefined : false;
  }
  /**
   * Checks if `timeSec` is in a discontinuity.
   * That is, if there's no segment available for the `timeSec` position.
   * @param {number} timeSec - The time to check if it's in a discontinuity, in
   * seconds.
   * @returns {number | null} - If `null`, no discontinuity is encountered at
   * `time`. If this is a number instead, there is one and that number is the
   * position for which a segment is available in seconds.
   */;
  _proto.checkDiscontinuity = function checkDiscontinuity(timeSec) {
    this._refreshTimeline();
    return (0,index_helpers/* checkDiscontinuity */.ph)(this._index, timeSec, undefined);
  }
  /**
   * Returns `true` if a Segment returned by this index is still considered
   * available.
   * Returns `false` if it is not available anymore.
   * Returns `undefined` if we cannot know whether it is still available or not.
   * @param {Object} segment
   * @returns {Boolean|undefined}
   */;
  _proto.isSegmentStillAvailable = function isSegmentStillAvailable(segment) {
    if (segment.isInit) {
      return true;
    }
    this._refreshTimeline();
    var _this$_index3 = this._index,
      timeline = _this$_index3.timeline,
      timescale = _this$_index3.timescale;
    for (var i = 0; i < timeline.length; i++) {
      var tSegment = timeline[i];
      var tSegmentTime = tSegment.start / timescale;
      if (tSegmentTime > segment.time) {
        return false; // We went over it without finding it
      } else if (tSegmentTime === segment.time) {
        return true;
      } else {
        // tSegment.start < segment.time
        if (tSegment.repeatCount >= 0 && tSegment.duration !== undefined) {
          var timeDiff = tSegmentTime - tSegment.start;
          var repeat = timeDiff / tSegment.duration - 1;
          return repeat % 1 === 0 && repeat <= tSegment.repeatCount;
        }
      }
    }
    return false;
  }
  /**
   * @param {Error} error
   * @returns {Boolean}
   */;
  _proto.canBeOutOfSyncError = function canBeOutOfSyncError(error) {
    if (!this._isLive) {
      return false;
    }
    return error instanceof network_error/* default */.A && (error.isHttpError(404) || error.isHttpError(412));
  }
  /**
   * Replace this RepresentationIndex by a newly downloaded one.
   * Check if the old index had more information about new segments and re-add
   * them if that's the case.
   * @param {Object} newIndex
   */;
  _proto._replace = function _replace(newIndex) {
    var oldTimeline = this._index.timeline;
    var newTimeline = newIndex._index.timeline;
    var oldTimescale = this._index.timescale;
    var newTimescale = newIndex._index.timescale;
    this._index = newIndex._index;
    this._initialScaledLastPosition = newIndex._initialScaledLastPosition;
    this._indexValidityTime = newIndex._indexValidityTime;
    this._scaledLiveGap = newIndex._scaledLiveGap;
    if (oldTimeline.length === 0 || newTimeline.length === 0 || oldTimescale !== newTimescale) {
      return; // don't take risk, if something is off, take the new one
    }
    var lastOldTimelineElement = oldTimeline[oldTimeline.length - 1];
    var lastNewTimelineElement = newTimeline[newTimeline.length - 1];
    var newEnd = (0,index_helpers/* getIndexSegmentEnd */.Rb)(lastNewTimelineElement, null);
    if ((0,index_helpers/* getIndexSegmentEnd */.Rb)(lastOldTimelineElement, null) <= newEnd) {
      return;
    }
    for (var i = 0; i < oldTimeline.length; i++) {
      var oldTimelineRange = oldTimeline[i];
      var oldEnd = (0,index_helpers/* getIndexSegmentEnd */.Rb)(oldTimelineRange, null);
      if (oldEnd === newEnd) {
        // just add the supplementary segments
        this._index.timeline = this._index.timeline.concat(oldTimeline.slice(i + 1));
        return;
      }
      if (oldEnd > newEnd) {
        // adjust repeatCount + add supplementary segments
        if (oldTimelineRange.duration !== lastNewTimelineElement.duration) {
          return;
        }
        var rangeDuration = newEnd - oldTimelineRange.start;
        if (rangeDuration === 0) {
          log/* default */.A.warn("Smooth Parser: a discontinuity detected in the previous manifest" + " has been resolved.");
          this._index.timeline = this._index.timeline.concat(oldTimeline.slice(i));
          return;
        }
        if (rangeDuration < 0 || rangeDuration % oldTimelineRange.duration !== 0) {
          return;
        }
        var repeatWithOld = rangeDuration / oldTimelineRange.duration - 1;
        var relativeRepeat = oldTimelineRange.repeatCount - repeatWithOld;
        if (relativeRepeat < 0) {
          return;
        }
        lastNewTimelineElement.repeatCount += relativeRepeat;
        var supplementarySegments = oldTimeline.slice(i + 1);
        this._index.timeline = this._index.timeline.concat(supplementarySegments);
        return;
      }
    }
  }
  /**
   * Update the current index with a new, partial, version.
   * This method might be use to only add information about new segments.
   * @param {Object} newIndex
   */;
  _proto._update = function _update(newIndex) {
    (0,update_segment_timeline/* default */.A)(this._index.timeline, newIndex._index.timeline);
    this._initialScaledLastPosition = newIndex._initialScaledLastPosition;
    this._indexValidityTime = newIndex._indexValidityTime;
    this._scaledLiveGap = newIndex._scaledLiveGap;
  }
  /**
   * Returns `false` if the last segments in this index have already been
   * generated.
   * Returns `true` if the index is still waiting on future segments to be
   * generated.
   *
   * For Smooth, it should only depend on whether the content is a live content
   * or not.
   * TODO What about Smooth live content that finishes at some point?
   * @returns {boolean}
   */;
  _proto.isStillAwaitingFutureSegments = function isStillAwaitingFutureSegments() {
    return this._isLive;
  }
  /**
   * @returns {Boolean}
   */;
  _proto.isInitialized = function isInitialized() {
    return true;
  }
  /**
   * Add new segments to a `SmoothRepresentationIndex`.
   * @param {Array.<Object>} nextSegments - The segment information parsed.
   * @param {Object} currentSegment - Information on the segment which contained
   * that new segment information.
   */;
  _proto.addNewSegments = function addNewSegments(nextSegments, currentSegment) {
    this._refreshTimeline();
    for (var i = 0; i < nextSegments.length; i++) {
      _addSegmentInfos(this._index, nextSegments[i], currentSegment);
    }
  }
  /**
   * Clean-up timeline to remove segment information which should not be
   * available due to the timeshift window
   */;
  _proto._refreshTimeline = function _refreshTimeline() {
    // clean segments before time shift buffer depth
    if (this._initialScaledLastPosition == null) {
      return;
    }
    var index = this._index;
    var timeShiftBufferDepth = this._timeShiftBufferDepth;
    var timeSinceLastRealUpdate = (performance.now() - this._indexValidityTime) / 1000;
    var lastPositionEstimate = timeSinceLastRealUpdate + this._initialScaledLastPosition / index.timescale;
    if (timeShiftBufferDepth != null) {
      var minimumPosition = (lastPositionEstimate - timeShiftBufferDepth) * index.timescale;
      (0,clear_timeline_from_position/* default */.A)(index.timeline, minimumPosition);
    }
  };
  return SmoothRepresentationIndex;
}();

// EXTERNAL MODULE: ./src/manifest/adaptation.ts + 3 modules
var adaptation = __webpack_require__(4129);
// EXTERNAL MODULE: ./src/utils/array_includes.ts
var array_includes = __webpack_require__(4031);
// EXTERNAL MODULE: ./src/utils/byte_parsing.ts
var byte_parsing = __webpack_require__(5553);
// EXTERNAL MODULE: ./src/utils/is_non_empty_string.ts
var is_non_empty_string = __webpack_require__(2384);
// EXTERNAL MODULE: ./src/utils/object_assign.ts
var object_assign = __webpack_require__(8935);
// EXTERNAL MODULE: ./src/utils/resolve_url.ts
var resolve_url = __webpack_require__(2716);
// EXTERNAL MODULE: ./src/utils/string_parsing.ts
var string_parsing = __webpack_require__(4670);
// EXTERNAL MODULE: ./src/parsers/containers/isobmff/constants.ts
var constants = __webpack_require__(3058);
;// CONCATENATED MODULE: ./src/parsers/containers/isobmff/create_box.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Speed up string to bytes conversion by memorizing the result
 *
 * The keys here are ISOBMFF box names. The values are the corresponding
 * bytes conversion for putting as an ISOBMFF boxes.
 *
 * Used by the boxName method.
 * @type {Object}
 */
var boxNamesMem = {};
/**
 * Convert the string name of an ISOBMFF box into the corresponding bytes.
 * Has a memorization mechanism to speed-up if you want to translate the
 * same string multiple times.
 * @param {string} str
 * @returns {Uint8Array}
 */
function boxName(str) {
  if (boxNamesMem[str] != null) {
    return boxNamesMem[str];
  }
  var nameInBytes = (0,string_parsing/* strToUtf8 */.eb)(str);
  boxNamesMem[str] = nameInBytes;
  return nameInBytes;
}
/**
 * Create a new ISOBMFF "box" with the given name.
 * @param {string} name - name of the box you want to create, must always
 * be 4 characters (uuid boxes not supported)
 * @param {Uint8Array} buff - content of the box
 * @returns {Uint8Array} - The entire ISOBMFF box (length+name+content)
 */
function createBox(name, buff) {
  var len = buff.length + 8;
  return len <= constants/* MAX_32_BIT_INT */.Z ? (0,byte_parsing/* concat */.xW)((0,byte_parsing/* itobe4 */.KS)(len), boxName(name), buff) : (0,byte_parsing/* concat */.xW)((0,byte_parsing/* itobe4 */.KS)(1), boxName(name), (0,byte_parsing/* itobe8 */.Kk)(len + 8), buff);
}
/**
 * @param {string} name
 * @param {Array.<Uint8Array>} children
 * @returns {Uint8Array}
 */
function createBoxWithChildren(name, children) {
  return createBox(name, byte_parsing/* concat */.xW.apply(void 0, children));
}

;// CONCATENATED MODULE: ./src/parsers/manifest/utils/check_manifest_ids.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Ensure that no two periods, adaptations from the same period and
 * representations from the same adaptation, have the same ID.
 *
 * Log and mutate their ID if not until this is verified.
 *
 * @param {Object} manifest
 */
function checkManifestIDs(manifest) {
  var periodIDS = [];
  manifest.periods.forEach(function (period) {
    var periodID = period.id;
    if ((0,array_includes/* default */.A)(periodIDS, periodID)) {
      log/* default */.A.warn("Two periods with the same ID found. Updating.");
      var newID = periodID + "-dup";
      period.id = newID;
      checkManifestIDs(manifest);
      periodIDS.push(newID);
    } else {
      periodIDS.push(periodID);
    }
    var adaptations = period.adaptations;
    var adaptationIDs = [];
    Object.keys(adaptations).forEach(function (type) {
      var adaptationsForType = adaptations[type];
      if (adaptationsForType === undefined) {
        return;
      }
      adaptationsForType.forEach(function (adaptation) {
        var adaptationID = adaptation.id;
        if ((0,array_includes/* default */.A)(adaptationIDs, adaptationID)) {
          log/* default */.A.warn("Two adaptations with the same ID found. Updating.", adaptationID);
          var _newID = adaptationID + "-dup";
          adaptation.id = _newID;
          checkManifestIDs(manifest);
          adaptationIDs.push(_newID);
        } else {
          adaptationIDs.push(adaptationID);
        }
        var representationIDs = [];
        adaptation.representations.forEach(function (representation) {
          var representationID = representation.id;
          if ((0,array_includes/* default */.A)(representationIDs, representationID)) {
            log/* default */.A.warn("Two representations with the same ID found. Updating.", representationID);
            var _newID2 = representationID + "-dup";
            representation.id = _newID2;
            checkManifestIDs(manifest);
            representationIDs.push(_newID2);
          } else {
            representationIDs.push(representationID);
          }
        });
      });
    });
  });
}
;// CONCATENATED MODULE: ./src/parsers/manifest/smooth/get_codecs.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @param {string} codecPrivateData
 * @param {string|undefined} fourCC
 * @returns {string}
 */
function getAudioCodecs(codecPrivateData, fourCC) {
  var mpProfile;
  if (fourCC === "AACH") {
    mpProfile = 5; // High Efficiency AAC Profile
  } else {
    mpProfile = (0,is_non_empty_string/* default */.A)(codecPrivateData) ? (parseInt(codecPrivateData.substring(0, 2), 16) & 0xf8) >> 3 : 2;
  }
  if (mpProfile === 0) {
    // Return default audio codec
    return "mp4a.40.2";
  }
  return "mp4a.40." + mpProfile;
}
/**
 * @param {string} codecPrivateData
 * @returns {string}
 */
function getVideoCodecs(codecPrivateData) {
  // we can extract codes only if fourCC is on of "H264", "X264", "DAVC", "AVC1"
  var arr = /00000001\d7([0-9a-fA-F]{6})/.exec(codecPrivateData);
  if (arr === null || !(0,is_non_empty_string/* default */.A)(arr[1])) {
    // Return default video codec
    return "avc1.4D401E";
  }
  return "avc1." + arr[1];
}
;// CONCATENATED MODULE: ./src/parsers/manifest/smooth/parse_C_nodes.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Parse C nodes to build index timeline.
 * @param {Element} nodes
 */
function parseCNodes(nodes) {
  return nodes.reduce(function (timeline, node, i) {
    var dAttr = node.getAttribute("d");
    var tAttr = node.getAttribute("t");
    var rAttr = node.getAttribute("r");
    var repeatCount = rAttr !== null ? +rAttr - 1 : 0;
    var start = tAttr !== null ? +tAttr : undefined;
    var duration = dAttr !== null ? +dAttr : undefined;
    if (i === 0) {
      // first node
      start = start === undefined || isNaN(start) ? 0 : start;
    } else {
      // from second node to the end
      var prev = timeline[i - 1];
      if (start == null || isNaN(start)) {
        if (prev.duration == null || isNaN(prev.duration)) {
          throw new Error("Smooth: Invalid CNodes. Missing timestamp.");
        }
        start = prev.start + prev.duration * (prev.repeatCount + 1);
      }
    }
    if (duration == null || isNaN(duration)) {
      var nextNode = nodes[i + 1];
      if (nextNode !== undefined) {
        var nextTAttr = nextNode.getAttribute("t");
        var nextStart = (0,is_non_empty_string/* default */.A)(nextTAttr) ? +nextTAttr : null;
        if (nextStart === null) {
          throw new Error("Can't build index timeline from Smooth Manifest.");
        }
        duration = nextStart - start;
      } else {
        return timeline;
      }
    }
    timeline.push({
      duration: duration,
      start: start,
      repeatCount: repeatCount
    });
    return timeline;
  }, []);
}
// EXTERNAL MODULE: ./src/utils/base64.ts
var base64 = __webpack_require__(603);
;// CONCATENATED MODULE: ./src/parsers/containers/isobmff/drm/playready.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Parse PlayReady privateData to get its Hexa-coded KeyID.
 * @param {Uint8Array} privateData
 * @returns {string}
 */
function getPlayReadyKIDFromPrivateData(data) {
  var xmlLength = (0,byte_parsing/* le2toi */.AT)(data, 8);
  var xml = (0,string_parsing/* utf16LEToStr */.Yg)(data.subarray(10, xmlLength + 10));
  var doc = new DOMParser().parseFromString(xml, "application/xml");
  var kidElement = doc.querySelector("KID");
  if (kidElement === null) {
    throw new Error("Cannot parse PlayReady private data: invalid XML");
  }
  var b64guidKid = kidElement.textContent === null ? "" : kidElement.textContent;
  var uuidKid = (0,string_parsing/* guidToUuid */.KZ)((0,base64/* base64ToBytes */.K)(b64guidKid));
  return (0,string_parsing/* bytesToHex */.My)(uuidKid).toLowerCase();
}
;// CONCATENATED MODULE: ./src/parsers/manifest/smooth/parse_protection_node.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * @param {Uint8Array} keyIdBytes
 * @returns {Array.<Object>}
 */
function createWidevineKeySystem(keyIdBytes) {
  return [{
    systemId: "edef8ba9-79d6-4ace-a3c8-27dcd51d21ed",
    // Widevine
    privateData: (0,byte_parsing/* concat */.xW)([0x08, 0x01, 0x12, 0x10], keyIdBytes)
  }];
}
/**
 * Parse "Protection" Node, which contains DRM information
 * @param {Element} protectionNode
 * @returns {Object}
 */
function parseProtectionNode(protectionNode, keySystemCreator) {
  if (keySystemCreator === void 0) {
    keySystemCreator = createWidevineKeySystem;
  }
  if (protectionNode.firstElementChild === null || protectionNode.firstElementChild.nodeName !== "ProtectionHeader") {
    throw new Error("Protection should have ProtectionHeader child");
  }
  var header = protectionNode.firstElementChild;
  var privateData = (0,base64/* base64ToBytes */.K)(header.textContent === null ? "" : header.textContent);
  var keyIdHex = getPlayReadyKIDFromPrivateData(privateData);
  var keyIdBytes = (0,string_parsing/* hexToBytes */.aT)(keyIdHex);
  // remove possible braces
  var systemIdAttr = header.getAttribute("SystemID");
  var systemId = (systemIdAttr !== null ? systemIdAttr : "").toLowerCase().replace(/\{|\}/g, "");
  return {
    keyId: keyIdBytes,
    keySystems: [{
      systemId: systemId,
      privateData: privateData
      /* keyIds: [keyIdBytes], */
    }].concat(keySystemCreator(keyIdBytes))
  };
}
;// CONCATENATED MODULE: ./src/parsers/manifest/smooth/utils/parseBoolean.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @param {*} parseBoolean
 * @returns {Boolean}
 */
function parseBoolean(val) {
  if (typeof val === "boolean") {
    return val;
  } else if (typeof val === "string") {
    return val.toUpperCase() === "TRUE";
  } else {
    return false;
  }
}
;// CONCATENATED MODULE: ./src/parsers/manifest/smooth/utils/reduceChildren.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Reduce implementation for the children of the given element.
 * @param {Element} root
 * @param {Function} fn
 * @param {*} init
 * @returns {*}
 */
function reduceChildren(root, fn, init) {
  var node = root.firstElementChild;
  var accumulator = init;
  while (node !== null) {
    accumulator = fn(accumulator, node.nodeName, node);
    node = node.nextElementSibling;
  }
  return accumulator;
}
;// CONCATENATED MODULE: ./src/parsers/manifest/smooth/create_parser.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


















/**
 * Default value for the aggressive `mode`.
 * In this mode, segments will be returned even if we're not sure those had time
 * to be generated.
 */
var DEFAULT_AGGRESSIVE_MODE = false;
var DEFAULT_MIME_TYPES = {
  audio: "audio/mp4",
  video: "video/mp4",
  text: "application/ttml+xml"
};
var MIME_TYPES = {
  AACL: "audio/mp4",
  AVC1: "video/mp4",
  H264: "video/mp4",
  TTML: "application/ttml+xml+mp4",
  DFXP: "application/ttml+xml+mp4"
};
/**
 * @param {Object|undefined} parserOptions
 * @returns {Function}
 */
function createSmoothStreamingParser(parserOptions) {
  if (parserOptions === void 0) {
    parserOptions = {};
  }
  var referenceDateTime = parserOptions.referenceDateTime === undefined ? Date.UTC(1970, 0, 1, 0, 0, 0, 0) / 1000 : parserOptions.referenceDateTime;
  var minRepresentationBitrate = parserOptions.minRepresentationBitrate === undefined ? 0 : parserOptions.minRepresentationBitrate;
  var _parserOptions = parserOptions,
    serverSyncInfos = _parserOptions.serverSyncInfos;
  var serverTimeOffset = serverSyncInfos !== undefined ? serverSyncInfos.serverTimestamp - serverSyncInfos.clientTime : undefined;
  /**
   * @param {Element} q
   * @param {string} streamType
   * @return {Object}
   */
  function parseQualityLevel(q, streamType) {
    var customAttributes = reduceChildren(q, function (acc, qName, qNode) {
      if (qName === "CustomAttributes") {
        acc.push.apply(acc, reduceChildren(qNode, function (cAttrs, cName, cNode) {
          if (cName === "Attribute") {
            var name = cNode.getAttribute("Name");
            var value = cNode.getAttribute("Value");
            if (name !== null && value !== null) {
              cAttrs.push(name + "=" + value);
            }
          }
          return cAttrs;
        }, []));
      }
      return acc;
    }, []);
    /**
     * @param {string} name
     * @returns {string|undefined}
     */
    function getAttribute(name) {
      var attr = q.getAttribute(name);
      return attr == null ? undefined : attr;
    }
    switch (streamType) {
      case "audio":
        {
          var audiotag = getAttribute("AudioTag");
          var bitsPerSample = getAttribute("BitsPerSample");
          var channels = getAttribute("Channels");
          var codecPrivateData = getAttribute("CodecPrivateData");
          var fourCC = getAttribute("FourCC");
          var packetSize = getAttribute("PacketSize");
          var samplingRate = getAttribute("SamplingRate");
          var bitrateAttr = getAttribute("Bitrate");
          var bitrate = bitrateAttr === undefined ? 0 : isNaN(parseInt(bitrateAttr, 10)) ? 0 : parseInt(bitrateAttr, 10);
          if (fourCC !== undefined && MIME_TYPES[fourCC] === undefined || codecPrivateData === undefined) {
            log/* default */.A.warn("Smooth parser: Unsupported audio codec. Ignoring quality level.");
            return null;
          }
          var codecs = getAudioCodecs(codecPrivateData, fourCC);
          return {
            audiotag: audiotag !== undefined ? parseInt(audiotag, 10) : audiotag,
            bitrate: bitrate,
            bitsPerSample: bitsPerSample !== undefined ? parseInt(bitsPerSample, 10) : bitsPerSample,
            channels: channels !== undefined ? parseInt(channels, 10) : channels,
            codecPrivateData: codecPrivateData,
            codecs: codecs,
            customAttributes: customAttributes,
            mimeType: fourCC !== undefined ? MIME_TYPES[fourCC] : fourCC,
            packetSize: packetSize !== undefined ? parseInt(packetSize, 10) : packetSize,
            samplingRate: samplingRate !== undefined ? parseInt(samplingRate, 10) : samplingRate
          };
        }
      case "video":
        {
          var _codecPrivateData = getAttribute("CodecPrivateData");
          var _fourCC = getAttribute("FourCC");
          var width = getAttribute("MaxWidth");
          var height = getAttribute("MaxHeight");
          var _bitrateAttr = getAttribute("Bitrate");
          var _bitrate = _bitrateAttr === undefined ? 0 : isNaN(parseInt(_bitrateAttr, 10)) ? 0 : parseInt(_bitrateAttr, 10);
          if (_fourCC !== undefined && MIME_TYPES[_fourCC] === undefined || _codecPrivateData === undefined) {
            log/* default */.A.warn("Smooth parser: Unsupported video codec. Ignoring quality level.");
            return null;
          }
          var _codecs = getVideoCodecs(_codecPrivateData);
          return {
            bitrate: _bitrate,
            customAttributes: customAttributes,
            mimeType: _fourCC !== undefined ? MIME_TYPES[_fourCC] : _fourCC,
            codecPrivateData: _codecPrivateData,
            codecs: _codecs,
            width: width !== undefined ? parseInt(width, 10) : undefined,
            height: height !== undefined ? parseInt(height, 10) : undefined
          };
        }
      case "text":
        {
          var _codecPrivateData2 = getAttribute("CodecPrivateData");
          var _fourCC2 = getAttribute("FourCC");
          var _bitrateAttr2 = getAttribute("Bitrate");
          var _bitrate2 = _bitrateAttr2 === undefined ? 0 : isNaN(parseInt(_bitrateAttr2, 10)) ? 0 : parseInt(_bitrateAttr2, 10);
          return {
            bitrate: _bitrate2,
            customAttributes: customAttributes,
            mimeType: _fourCC2 !== undefined ? MIME_TYPES[_fourCC2] : _fourCC2,
            codecPrivateData: _codecPrivateData2 !== null && _codecPrivateData2 !== void 0 ? _codecPrivateData2 : ""
          };
        }
      default:
        log/* default */.A.error("Smooth Parser: Unrecognized StreamIndex type: " + streamType);
        return null;
    }
  }
  /**
   * Parse the adaptations (<StreamIndex>) tree containing
   * representations (<QualityLevels>) and timestamp indexes (<c>).
   * Indexes can be quite huge, and this function needs to
   * to be optimized.
   * @param {Object} args
   * @returns {Object}
   */
  function parseAdaptation(args) {
    var root = args.root,
      timescale = args.timescale,
      baseUrl = args.baseUrl,
      protections = args.protections,
      timeShiftBufferDepth = args.timeShiftBufferDepth,
      manifestReceivedTime = args.manifestReceivedTime,
      isLive = args.isLive;
    var timescaleAttr = root.getAttribute("Timescale");
    var _timescale = timescaleAttr === null ? timescale : isNaN(+timescaleAttr) ? timescale : +timescaleAttr;
    var typeAttribute = root.getAttribute("Type");
    if (typeAttribute === null) {
      throw new Error("StreamIndex without type.");
    }
    if (!(0,array_includes/* default */.A)(adaptation/* SUPPORTED_ADAPTATIONS_TYPE */.B, typeAttribute)) {
      log/* default */.A.warn("Smooth Parser: Unrecognized adaptation type:", typeAttribute);
    }
    var adaptationType = typeAttribute;
    var subType = root.getAttribute("Subtype");
    var language = root.getAttribute("Language");
    var UrlAttr = root.getAttribute("Url");
    var UrlPathWithTokens = UrlAttr === null ? "" : UrlAttr;
    if (false) {}
    var _reduceChildren = reduceChildren(root, function (res, _name, node) {
        switch (_name) {
          case "QualityLevel":
            var qualityLevel = parseQualityLevel(node, adaptationType);
            if (qualityLevel === null) {
              return res;
            }
            // filter out video qualityLevels with small bitrates
            if (adaptationType !== "video" || qualityLevel.bitrate > minRepresentationBitrate) {
              res.qualityLevels.push(qualityLevel);
            }
            break;
          case "c":
            res.cNodes.push(node);
            break;
        }
        return res;
      }, {
        qualityLevels: [],
        cNodes: []
      }),
      qualityLevels = _reduceChildren.qualityLevels,
      cNodes = _reduceChildren.cNodes;
    var index = {
      timeline: parseCNodes(cNodes),
      timescale: _timescale
    };
    // we assume that all qualityLevels have the same
    // codec and mimeType
    (0,assert/* default */.h)(qualityLevels.length !== 0, "Adaptation should have at least one playable representation.");
    var adaptationID = adaptationType + ((0,is_non_empty_string/* default */.A)(language) ? "_" + language : "");
    var representations = qualityLevels.map(function (qualityLevel) {
      var repIndex = {
        timeline: index.timeline,
        timescale: index.timescale,
        media: replaceRepresentationSmoothTokens(UrlPathWithTokens, qualityLevel.bitrate, qualityLevel.customAttributes)
      };
      var mimeType = (0,is_non_empty_string/* default */.A)(qualityLevel.mimeType) ? qualityLevel.mimeType : DEFAULT_MIME_TYPES[adaptationType];
      var codecs = qualityLevel.codecs;
      var id = adaptationID + "_" + (adaptationType != null ? adaptationType + "-" : "") + (mimeType != null ? mimeType + "-" : "") + (codecs != null ? codecs + "-" : "") + String(qualityLevel.bitrate);
      var keyIDs = [];
      var firstProtection;
      if (protections.length > 0) {
        firstProtection = protections[0];
        protections.forEach(function (protection) {
          var keyId = protection.keyId;
          protection.keySystems.forEach(function (keySystem) {
            keyIDs.push({
              keyId: keyId,
              systemId: keySystem.systemId
            });
          });
        });
      }
      var segmentPrivateInfos = {
        bitsPerSample: qualityLevel.bitsPerSample,
        channels: qualityLevel.channels,
        codecPrivateData: qualityLevel.codecPrivateData,
        packetSize: qualityLevel.packetSize,
        samplingRate: qualityLevel.samplingRate,
        // TODO set multiple protections here
        // instead of the first one
        protection: firstProtection != null ? {
          keyId: firstProtection.keyId
        } : undefined
      };
      var aggressiveMode = parserOptions.aggressiveMode == null ? DEFAULT_AGGRESSIVE_MODE : parserOptions.aggressiveMode;
      var reprIndex = new SmoothRepresentationIndex(repIndex, {
        aggressiveMode: aggressiveMode,
        isLive: isLive,
        manifestReceivedTime: manifestReceivedTime,
        segmentPrivateInfos: segmentPrivateInfos,
        timeShiftBufferDepth: timeShiftBufferDepth
      });
      var representation = (0,object_assign/* default */.A)({}, qualityLevel, {
        index: reprIndex,
        cdnMetadata: [{
          baseUrl: baseUrl
        }],
        mimeType: mimeType,
        codecs: codecs,
        id: id
      });
      if (keyIDs.length > 0 || firstProtection !== undefined) {
        var initDataValues = firstProtection === undefined ? [] : firstProtection.keySystems.map(function (keySystemData) {
          var systemId = keySystemData.systemId,
            privateData = keySystemData.privateData;
          var cleanedSystemId = systemId.replace(/-/g, "");
          var pssh = createPSSHBox(cleanedSystemId, privateData);
          return {
            systemId: cleanedSystemId,
            data: pssh
          };
        });
        if (initDataValues.length > 0) {
          var initData = [{
            type: "cenc",
            values: initDataValues
          }];
          representation.contentProtections = {
            keyIds: keyIDs,
            initData: initData
          };
        } else {
          representation.contentProtections = {
            keyIds: keyIDs,
            initData: []
          };
        }
      }
      return representation;
    });
    // TODO(pierre): real ad-insert support
    if (subType === "ADVT") {
      return null;
    }
    var parsedAdaptation = {
      id: adaptationID,
      type: adaptationType,
      representations: representations,
      language: language == null ? undefined : language
    };
    if (adaptationType === "text" && subType === "DESC") {
      parsedAdaptation.closedCaption = true;
    }
    return parsedAdaptation;
  }
  function parseFromDocument(doc, url, manifestReceivedTime) {
    var baseUrl = "";
    if (url !== undefined) {
      var filenameIdx = (0,resolve_url/* getFilenameIndexInUrl */.Cl)(url);
      baseUrl = url.substring(0, filenameIdx);
    }
    var root = doc.documentElement;
    if (root == null || root.nodeName !== "SmoothStreamingMedia") {
      throw new Error("document root should be SmoothStreamingMedia");
    }
    var majorVersionAttr = root.getAttribute("MajorVersion");
    var minorVersionAttr = root.getAttribute("MinorVersion");
    if (majorVersionAttr === null || minorVersionAttr === null || !/^[2]-[0-2]$/.test(majorVersionAttr + "-" + minorVersionAttr)) {
      throw new Error("Version should be 2.0, 2.1 or 2.2");
    }
    var timescaleAttr = root.getAttribute("Timescale");
    var timescale = !(0,is_non_empty_string/* default */.A)(timescaleAttr) ? 10000000 : isNaN(+timescaleAttr) ? 10000000 : +timescaleAttr;
    var _reduceChildren2 = reduceChildren(root, function (res, name, node) {
        switch (name) {
          case "Protection":
            {
              res.protections.push(parseProtectionNode(node, parserOptions.keySystems));
              break;
            }
          case "StreamIndex":
            res.adaptationNodes.push(node);
            break;
        }
        return res;
      }, {
        adaptationNodes: [],
        protections: []
      }),
      protections = _reduceChildren2.protections,
      adaptationNodes = _reduceChildren2.adaptationNodes;
    var initialAdaptations = {};
    var isLive = parseBoolean(root.getAttribute("IsLive"));
    var timeShiftBufferDepth;
    if (isLive) {
      var dvrWindowLength = root.getAttribute("DVRWindowLength");
      if (dvrWindowLength != null && !isNaN(+dvrWindowLength) && +dvrWindowLength !== 0) {
        timeShiftBufferDepth = +dvrWindowLength / timescale;
      }
    }
    var adaptations = adaptationNodes.reduce(function (acc, node) {
      var adaptation = parseAdaptation({
        root: node,
        baseUrl: baseUrl,
        timescale: timescale,
        protections: protections,
        isLive: isLive,
        timeShiftBufferDepth: timeShiftBufferDepth,
        manifestReceivedTime: manifestReceivedTime
      });
      if (adaptation === null) {
        return acc;
      }
      var type = adaptation.type;
      var adaps = acc[type];
      if (adaps === undefined) {
        acc[type] = [adaptation];
      } else {
        adaps.push(adaptation);
      }
      return acc;
    }, initialAdaptations);
    var suggestedPresentationDelay;
    var availabilityStartTime;
    var minimumTime;
    var timeshiftDepth = null;
    var maximumTimeData;
    var firstVideoAdaptation = adaptations.video !== undefined ? adaptations.video[0] : undefined;
    var firstAudioAdaptation = adaptations.audio !== undefined ? adaptations.audio[0] : undefined;
    /** Minimum time that can be reached regardless of the StreamIndex chosen. */
    var safeMinimumTime;
    /** Maximum time that can be reached regardless of the StreamIndex chosen. */
    var safeMaximumTime;
    /** Maximum time that can be reached in absolute on the content. */
    var unsafeMaximumTime;
    if (firstVideoAdaptation !== undefined || firstAudioAdaptation !== undefined) {
      var firstTimeReferences = [];
      var lastTimeReferences = [];
      if (firstVideoAdaptation !== undefined) {
        var firstVideoRepresentation = firstVideoAdaptation.representations[0];
        if (firstVideoRepresentation !== undefined) {
          var firstVideoTimeReference = firstVideoRepresentation.index.getFirstAvailablePosition();
          var lastVideoTimeReference = firstVideoRepresentation.index.getLastAvailablePosition();
          if (firstVideoTimeReference != null) {
            firstTimeReferences.push(firstVideoTimeReference);
          }
          if (lastVideoTimeReference != null) {
            lastTimeReferences.push(lastVideoTimeReference);
          }
        }
      }
      if (firstAudioAdaptation !== undefined) {
        var firstAudioRepresentation = firstAudioAdaptation.representations[0];
        if (firstAudioRepresentation !== undefined) {
          var firstAudioTimeReference = firstAudioRepresentation.index.getFirstAvailablePosition();
          var lastAudioTimeReference = firstAudioRepresentation.index.getLastAvailablePosition();
          if (firstAudioTimeReference != null) {
            firstTimeReferences.push(firstAudioTimeReference);
          }
          if (lastAudioTimeReference != null) {
            lastTimeReferences.push(lastAudioTimeReference);
          }
        }
      }
      if (firstTimeReferences.length > 0) {
        safeMinimumTime = Math.max.apply(Math, firstTimeReferences);
      }
      if (lastTimeReferences.length > 0) {
        safeMaximumTime = Math.min.apply(Math, lastTimeReferences);
        unsafeMaximumTime = Math.max.apply(Math, lastTimeReferences);
      }
    }
    var manifestDuration = root.getAttribute("Duration");
    var duration = manifestDuration !== null && +manifestDuration !== 0 ? +manifestDuration / timescale : undefined;
    if (isLive) {
      suggestedPresentationDelay = parserOptions.suggestedPresentationDelay;
      availabilityStartTime = referenceDateTime;
      minimumTime = safeMinimumTime !== null && safeMinimumTime !== void 0 ? safeMinimumTime : availabilityStartTime;
      var livePosition = unsafeMaximumTime;
      if (livePosition === undefined) {
        livePosition = Date.now() / 1000 - availabilityStartTime;
      }
      var maximumSafePosition = safeMaximumTime;
      if (maximumSafePosition === undefined) {
        maximumSafePosition = livePosition;
      }
      maximumTimeData = {
        isLinear: true,
        maximumSafePosition: maximumSafePosition,
        livePosition: livePosition,
        time: performance.now()
      };
      timeshiftDepth = timeShiftBufferDepth !== null && timeShiftBufferDepth !== void 0 ? timeShiftBufferDepth : null;
    } else {
      minimumTime = safeMinimumTime !== null && safeMinimumTime !== void 0 ? safeMinimumTime : 0;
      var maximumTime = safeMaximumTime !== undefined ? safeMaximumTime : duration !== undefined ? minimumTime + duration : Infinity;
      maximumTimeData = {
        isLinear: false,
        maximumSafePosition: maximumTime,
        livePosition: undefined,
        time: performance.now()
      };
    }
    var periodStart = isLive ? 0 : minimumTime;
    var periodEnd = isLive ? undefined : maximumTimeData.maximumSafePosition;
    var manifest = {
      availabilityStartTime: availabilityStartTime === undefined ? 0 : availabilityStartTime,
      clockOffset: serverTimeOffset,
      isLive: isLive,
      isDynamic: isLive,
      isLastPeriodKnown: true,
      timeBounds: {
        minimumSafePosition: minimumTime,
        timeshiftDepth: timeshiftDepth,
        maximumTimeData: maximumTimeData
      },
      periods: [{
        adaptations: adaptations,
        duration: periodEnd !== undefined ? periodEnd - periodStart : duration,
        end: periodEnd,
        id: "gen-smooth-period-0",
        start: periodStart
      }],
      suggestedPresentationDelay: suggestedPresentationDelay,
      transportType: "smooth",
      uris: url == null ? [] : [url]
    };
    checkManifestIDs(manifest);
    return manifest;
  }
  return parseFromDocument;
}
/**
 * @param {string} systemId - Hex string representing the CDM, 16 bytes.
 * @param {Uint8Array|undefined} privateData - Data associated to protection
 * specific system.
 * @returns {Uint8Array}
 */
function createPSSHBox(systemId, privateData) {
  if (systemId.length !== 32) {
    throw new Error("HSS: wrong system id length");
  }
  var version = 0;
  return createBox("pssh", (0,byte_parsing/* concat */.xW)([version, 0, 0, 0], (0,string_parsing/* hexToBytes */.aT)(systemId), /** To put there KIDs if it exists (necessitate PSSH v1) */
  (0,byte_parsing/* itobe4 */.KS)(privateData.length), privateData));
}
/* harmony default export */ var create_parser = (createSmoothStreamingParser);
;// CONCATENATED MODULE: ./src/parsers/manifest/smooth/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/* harmony default export */ var smooth = (create_parser);

// EXTERNAL MODULE: ./src/utils/request/index.ts + 1 modules
var request = __webpack_require__(4389);
// EXTERNAL MODULE: ./src/utils/warn_once.ts
var warn_once = __webpack_require__(5950);
// EXTERNAL MODULE: ./src/transports/utils/check_isobmff_integrity.ts
var check_isobmff_integrity = __webpack_require__(3598);
// EXTERNAL MODULE: ./src/transports/utils/generate_manifest_loader.ts + 1 modules
var generate_manifest_loader = __webpack_require__(1856);
// EXTERNAL MODULE: ./src/parsers/containers/isobmff/utils.ts
var utils = __webpack_require__(1134);
// EXTERNAL MODULE: ./src/parsers/containers/isobmff/get_box.ts
var get_box = __webpack_require__(8797);
;// CONCATENATED MODULE: ./src/transports/smooth/isobmff/parse_tfrf.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @param {Uint8Array} traf
 * @returns {Array.<Object>}
 */
function parseTfrf(traf) {
  var tfrf = (0,get_box/* getUuidContent */.$H)(traf, 0xd4807ef2, 0xca394695, 0x8e5426cb, 0x9e46a79f);
  if (tfrf === undefined) {
    return [];
  }
  var frags = [];
  var version = tfrf[0];
  var fragCount = tfrf[4];
  for (var i = 0; i < fragCount; i++) {
    var duration = void 0;
    var time = void 0;
    if (version === 1) {
      time = (0,byte_parsing/* be8toi */.CQ)(tfrf, i * 16 + 5);
      duration = (0,byte_parsing/* be8toi */.CQ)(tfrf, i * 16 + 5 + 8);
    } else {
      time = (0,byte_parsing/* be4toi */.mq)(tfrf, i * 8 + 5);
      duration = (0,byte_parsing/* be4toi */.mq)(tfrf, i * 8 + 5 + 4);
    }
    frags.push({
      time: time,
      duration: duration
    });
  }
  return frags;
}
;// CONCATENATED MODULE: ./src/transports/smooth/isobmff/parse_tfxd.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @param {Uint8Array} traf
 * @returns {Object|undefined}
 */
function parseTfxd(traf) {
  var tfxd = (0,get_box/* getUuidContent */.$H)(traf, 0x6d1d9b05, 0x42d544e6, 0x80e2141d, 0xaff757b2);
  if (tfxd === undefined) {
    return undefined;
  }
  return {
    duration: (0,byte_parsing/* be8toi */.CQ)(tfxd, 12),
    time: (0,byte_parsing/* be8toi */.CQ)(tfxd, 4)
  };
}
;// CONCATENATED MODULE: ./src/transports/smooth/extract_timings_infos.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Try to obtain time information from the given data.
 * @param {Uint8Array} data
 * @param {boolean} isChunked
 * @param {Object} segment
 * @param {boolean} isLive
 * @returns {Object}
 */
function extractTimingsInfos(data, isChunked, initTimescale, segment, isLive) {
  var _a;
  var nextSegments = [];
  var chunkInfos;
  var tfxdSegment;
  var tfrfSegments;
  if (isLive) {
    var traf = (0,read/* getTRAF */.Y2)(data);
    if (traf !== null) {
      tfrfSegments = parseTfrf(traf);
      tfxdSegment = parseTfxd(traf);
    } else {
      log/* default */.A.warn("smooth: could not find traf atom");
    }
  }
  if (tfrfSegments !== undefined) {
    for (var i = 0; i < tfrfSegments.length; i++) {
      nextSegments.push({
        time: tfrfSegments[i].time,
        duration: tfrfSegments[i].duration,
        timescale: initTimescale
      });
    }
  }
  if (tfxdSegment !== undefined) {
    chunkInfos = {
      time: tfxdSegment.time / initTimescale,
      duration: tfxdSegment.duration / initTimescale
    };
    return {
      nextSegments: nextSegments,
      chunkInfos: chunkInfos,
      scaledSegmentTime: tfxdSegment.time
    };
  }
  if (isChunked || !segment.complete) {
    return {
      nextSegments: nextSegments,
      chunkInfos: null,
      scaledSegmentTime: undefined
    };
  }
  var segmentDuration = segment.duration * initTimescale;
  // we could always make a mistake when reading a container.
  // If the estimate is too far from what the segment seems to imply, take
  // the segment infos instead.
  var maxDecodeTimeDelta = Math.min(initTimescale * 0.9, segmentDuration / 4);
  var trunDuration = (0,utils/* getDurationFromTrun */.cS)(data);
  var scaledSegmentTime = ((_a = segment.privateInfos) === null || _a === void 0 ? void 0 : _a.smoothMediaSegment) !== undefined ? segment.privateInfos.smoothMediaSegment.time : Math.round(segment.time * initTimescale);
  if (trunDuration !== undefined && Math.abs(trunDuration - segmentDuration) <= maxDecodeTimeDelta) {
    chunkInfos = {
      time: segment.time,
      duration: trunDuration / initTimescale
    };
  } else {
    chunkInfos = {
      time: segment.time,
      duration: segment.duration
    };
  }
  return {
    nextSegments: nextSegments,
    chunkInfos: chunkInfos,
    scaledSegmentTime: scaledSegmentTime
  };
}
// EXTERNAL MODULE: ./src/compat/browser_detection.ts
var browser_detection = __webpack_require__(443);
;// CONCATENATED MODULE: ./src/compat/can_patch_isobmff.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * TODO(pierre): fix patchSegmentInPlace to work with IE11. Maybe
 * try to put free atom inside traf children
 *
 * Returns true if the current target is tolerant enough for us to
 * simply be able to "patch" an ISOBMFF segment or if we have to create a
 * new one from scratch instead.
 * @returns {Boolean}
 */
function canPatchISOBMFFSegment() {
  return !browser_detection/* isIEOrEdge */.h$;
}
;// CONCATENATED MODULE: ./src/transports/smooth/isobmff/create_boxes.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * @param {Number} width
 * @param {Number} height
 * @param {Number} hRes - horizontal resolution, eg 72
 * @param {Number} vRes - vertical resolution, eg 72
 * @param {string} encName
 * @param {Number} colorDepth - eg 24
 * @param {Uint8Array} avcc - Uint8Array representing the avcC atom
 * @returns {Uint8Array}
 */
function createAVC1Box(width, height, hRes, vRes, encName, colorDepth, avcc) {
  return createBox("avc1", (0,byte_parsing/* concat */.xW)(6,
  // 6 bytes reserved
  (0,byte_parsing/* itobe2 */.ww)(1), 16,
  // drefIdx + QuickTime reserved, zeroes
  (0,byte_parsing/* itobe2 */.ww)(width),
  // size 2 w
  (0,byte_parsing/* itobe2 */.ww)(height),
  // size 2 h
  (0,byte_parsing/* itobe2 */.ww)(hRes), 2,
  // reso 4 h
  (0,byte_parsing/* itobe2 */.ww)(vRes), 2 + 4,
  // reso 4 v + QuickTime reserved, zeroes
  [0, 1, encName.length],
  // frame count (default 1)
  (0,string_parsing/* strToUtf8 */.eb)(encName),
  // 1byte len + encoder name str
  31 - encName.length,
  // + padding
  (0,byte_parsing/* itobe2 */.ww)(colorDepth),
  // color depth
  [0xff, 0xff],
  // reserved ones
  avcc));
}
/**
 * @param {Number} width
 * @param {Number} height
 * @param {Number} hRes - horizontal resolution, eg 72
 * @param {Number} vRes - vertical resolution, eg 72
 * @param {string} encName
 * @param {Number} colorDepth - eg 24
 * @param {Uint8Array} avcc - Uint8Array representing the avcC atom
 * @param {Uint8Array} sinf - Uint8Array representing the sinf atom
 * @returns {Uint8Array}
 */
function createENCVBox(width, height, hRes, vRes, encName, colorDepth, avcc, sinf) {
  return createBox("encv", (0,byte_parsing/* concat */.xW)(6,
  // 6 bytes reserved
  (0,byte_parsing/* itobe2 */.ww)(1), 16,
  // drefIdx + QuickTime reserved, zeroes
  (0,byte_parsing/* itobe2 */.ww)(width),
  // size 2 w
  (0,byte_parsing/* itobe2 */.ww)(height),
  // size 2 h
  (0,byte_parsing/* itobe2 */.ww)(hRes), 2,
  // reso 4 h
  (0,byte_parsing/* itobe2 */.ww)(vRes), 2 + 4,
  // reso 4 v + QuickTime reserved, zeroes
  [0, 1, encName.length],
  // frame count (default 1)
  (0,string_parsing/* strToUtf8 */.eb)(encName),
  // 1byte len + encoder name str
  31 - encName.length,
  // + padding
  (0,byte_parsing/* itobe2 */.ww)(colorDepth),
  // color depth
  [0xff, 0xff],
  // reserved ones
  avcc,
  // avcc atom,
  sinf));
}
/**
 * @param {Number} drefIdx
 * @param {Number} channelsCount
 * @param {Number} sampleSize
 * @param {Number} packetSize
 * @param {Number} sampleRate
 * @param {Uint8Array} esds - Uint8Array representing the esds atom
 * @returns {Uint8Array}
 */
function createMP4ABox(drefIdx, channelsCount, sampleSize, packetSize, sampleRate, esds) {
  return createBox("mp4a", (0,byte_parsing/* concat */.xW)(6, (0,byte_parsing/* itobe2 */.ww)(drefIdx), 8, (0,byte_parsing/* itobe2 */.ww)(channelsCount), (0,byte_parsing/* itobe2 */.ww)(sampleSize), 2, (0,byte_parsing/* itobe2 */.ww)(packetSize), (0,byte_parsing/* itobe2 */.ww)(sampleRate), 2, esds));
}
/**
 * @param {Number} drefIdx
 * @param {Number} channelsCount
 * @param {Number} sampleSize
 * @param {Number} packetSize
 * @param {Number} sampleRate
 * @param {Uint8Array} esds - Uint8Array representing the esds atom
 * @param {Uint8Array} [sinf] - Uint8Array representing the sinf atom,
 * only if name == "enca"
 * @returns {Uint8Array}
 */
function createENCABox(drefIdx, channelsCount, sampleSize, packetSize, sampleRate, esds, sinf) {
  return createBox("enca", (0,byte_parsing/* concat */.xW)(6, (0,byte_parsing/* itobe2 */.ww)(drefIdx), 8, (0,byte_parsing/* itobe2 */.ww)(channelsCount), (0,byte_parsing/* itobe2 */.ww)(sampleSize), 2, (0,byte_parsing/* itobe2 */.ww)(packetSize), (0,byte_parsing/* itobe2 */.ww)(sampleRate), 2, esds, sinf));
}
/**
 * @param {Uint8Array} url
 * @returns {Uint8Array}
 */
function createDREFBox(url) {
  // only one description here... FIXME
  return createBox("dref", (0,byte_parsing/* concat */.xW)(7, [1], url));
}
/**
 * @param {string} majorBrand
 * @param {Array.<string>} brands
 * @returns {Uint8Array}
 */
function createFTYPBox(majorBrand, brands) {
  var content = byte_parsing/* concat */.xW.apply(void 0, [(0,string_parsing/* strToUtf8 */.eb)(majorBrand), [0, 0, 0, 1]].concat(brands.map(string_parsing/* strToUtf8 */.eb)));
  return createBox("ftyp", content);
}
/**
 * @param {string} schemeType - four letters (eg "cenc" for Common Encryption)
 * @param {Number} schemeVersion - eg 65536
 * @returns {Uint8Array}
 */
function createSCHMBox(schemeType, schemeVersion) {
  return createBox("schm", (0,byte_parsing/* concat */.xW)(4, (0,string_parsing/* strToUtf8 */.eb)(schemeType), (0,byte_parsing/* itobe4 */.KS)(schemeVersion)));
}
/**
 * Create tfdt box from a decoding time.
 * @param {number} decodeTime
 * @returns {Uint8Array}
 */
function createTfdtBox(decodeTime) {
  return createBox("tfdt", (0,byte_parsing/* concat */.xW)([1, 0, 0, 0], (0,byte_parsing/* itobe8 */.Kk)(decodeTime)));
}
/**
 * @returns {Uint8Array}
 */
function createVMHDBox() {
  var arr = new Uint8Array(12);
  arr[3] = 1; // QuickTime...
  return createBox("vmhd", arr);
}
/**
 * @param {Number} trackId
 * @returns {Uint8Array}
 */
function createTREXBox(trackId) {
  // default sample desc idx = 1
  return createBox("trex", (0,byte_parsing/* concat */.xW)(4, (0,byte_parsing/* itobe4 */.KS)(trackId), [0, 0, 0, 1], 12));
}
/**
 * @param {Number} length
 * @returns {Uint8Array}
 */
function createFreeBox(length) {
  return createBox("free", new Uint8Array(length - 8));
}
/**
 * @param {Number} stream
 * @param {string} codecPrivateData - hex string
 * @returns {Uint8Array}
 */
function createESDSBox(stream, codecPrivateData) {
  return createBox("esds", (0,byte_parsing/* concat */.xW)(4, [0x03, 0x19], (0,byte_parsing/* itobe2 */.ww)(stream), [0x00, 0x04, 0x11, 0x40, 0x15], 11, [0x05, 0x02], (0,string_parsing/* hexToBytes */.aT)(codecPrivateData), [0x06, 0x01, 0x02]));
}
/**
 * @param {string} dataFormat - four letters (eg "avc1")
 * @returns {Uint8Array}
 */
function createFRMABox(dataFormat) {
  return createBox("frma", (0,string_parsing/* strToUtf8 */.eb)(dataFormat));
}
/**
 * @param {Uint8Array} sps
 * @param {Uint8Array} pps
 * @param {Number} nalLen - NAL Unit length: 1, 2 or 4 bytes
 * eg: avcc(0x4d, 0x40, 0x0d, 4, 0xe1, "674d400d96560c0efcb80a70505050a0",
 * 1, "68ef3880")
 * @returns {Uint8Array}
 */
function createAVCCBox(sps, pps, nalLen) {
  var nal = nalLen === 2 ? 0x1 : nalLen === 4 ? 0x3 : 0x0;
  // Deduce AVC Profile from SPS
  var h264Profile = sps[1];
  var h264CompatibleProfile = sps[2];
  var h264Level = sps[3];
  return createBox("avcC", (0,byte_parsing/* concat */.xW)([1, h264Profile, h264CompatibleProfile, h264Level, 0x3f << 2 | nal, 0xe0 | 1], (0,byte_parsing/* itobe2 */.ww)(sps.length), sps, [1], (0,byte_parsing/* itobe2 */.ww)(pps.length), pps));
}
/**
 * @param {string} type - "video"/"audio"/"hint"
 * @returns {Uint8Array}
 */
function createHDLRBox(type) {
  var name;
  var handlerName;
  switch (type) {
    case "video":
      name = "vide";
      handlerName = "VideoHandler";
      break;
    case "audio":
      name = "soun";
      handlerName = "SoundHandler";
      break;
    default:
      name = "hint";
      handlerName = "";
      break;
  }
  return createBox("hdlr", (0,byte_parsing/* concat */.xW)(8, (0,string_parsing/* strToUtf8 */.eb)(name), 12, (0,string_parsing/* strToUtf8 */.eb)(handlerName), 1));
}
/**
 * @param {number} timescale
 * @returns {Uint8Array}
 */
function createMDHDBox(timescale) {
  return createBox("mdhd", (0,byte_parsing/* concat */.xW)(12, (0,byte_parsing/* itobe4 */.KS)(timescale), 8));
}
/**
 * @param {Number} timescale
 * @param {Number} trackId
 * @returns {Uint8Array}
 */
function createMVHDBox(timescale, trackId) {
  return createBox("mvhd", (0,byte_parsing/* concat */.xW)(12, (0,byte_parsing/* itobe4 */.KS)(timescale), 4, [0, 1], 2,
  // we assume rate = 1;
  [1, 0], 10,
  // we assume volume = 100%;
  [0, 1], 14,
  // default matrix
  [0, 1], 14,
  // default matrix
  [64, 0, 0, 0], 26, (0,byte_parsing/* itobe2 */.ww)(trackId + 1)));
}
/**
 * @param {Uint8Array} mfhd
 * @param {Uint8Array} tfhd
 * @param {Uint8Array} tfdt
 * @param {Uint8Array} trun
 * @returns {Uint8Array}
 */
function createSAIOBox(mfhd, tfhd, tfdt, trun) {
  return createBox("saio", (0,byte_parsing/* concat */.xW)(4, [0, 0, 0, 1],
  // ??
  (0,byte_parsing/* itobe4 */.KS)(mfhd.length + tfhd.length + tfdt.length + trun.length + 8 + 8 + 8 + 8)));
}
/**
 * @param {Uint8Array} sencContent - including 8 bytes flags and entries count
 * @returns {Uint8Array}
 */
function createSAIZBox(sencContent) {
  if (sencContent.length === 0) {
    return createBox("saiz", new Uint8Array(0));
  }
  var flags = (0,byte_parsing/* be4toi */.mq)(sencContent, 0);
  var entries = (0,byte_parsing/* be4toi */.mq)(sencContent, 4);
  var arr = new Uint8Array(entries + 9);
  arr.set((0,byte_parsing/* itobe4 */.KS)(entries), 5);
  var i = 9;
  var j = 8;
  var pairsCnt;
  var pairsLen;
  while (j < sencContent.length) {
    j += 8; // assuming IV is 8 bytes TODO handle 16 bytes IV
    // if we have extradata for each entry
    if ((flags & 0x2) === 0x2) {
      pairsLen = 2;
      pairsCnt = (0,byte_parsing/* be2toi */.UU)(sencContent, j);
      j += pairsCnt * 6 + 2;
    } else {
      pairsCnt = 0;
      pairsLen = 0;
    }
    arr[i] = pairsCnt * 6 + 8 + pairsLen;
    i++;
  }
  return createBox("saiz", arr);
}
/**
 * @returns {Uint8Array}
 */
function createSMHDBox() {
  return createBox("smhd", new Uint8Array(8));
}
/**
 * @param {Array.<Uint8Array>} reps - arrays of Uint8Array,
 * typically [avc1] or [encv, avc1]
 * @returns {Uint8Array}
 */
function createSTSDBox(reps) {
  // only one description here... FIXME
  var arrBase = [7, [reps.length]];
  return createBox("stsd", byte_parsing/* concat */.xW.apply(void 0, arrBase.concat(reps)));
}
/**
 * @param {Number} width
 * @param {Number} height
 * @param {Number} trackId
 * @returns {Uint8Array}
 */
function createTKHDBox(width, height, trackId) {
  return createBox("tkhd", (0,byte_parsing/* concat */.xW)((0,byte_parsing/* itobe4 */.KS)(1 + 2 + 4), 8,
  // we assume track is enabled,
  // in media and in preview.
  (0,byte_parsing/* itobe4 */.KS)(trackId), 20,
  // we assume trackId = 1;
  [1, 0, 0, 0],
  // we assume volume = 100%;
  [0, 1, 0, 0], 12,
  // default matrix
  [0, 1, 0, 0], 12,
  // default matrix
  [64, 0, 0, 0],
  // ??
  (0,byte_parsing/* itobe2 */.ww)(width), 2,
  // width (TODO handle fixed)
  (0,byte_parsing/* itobe2 */.ww)(height), 2));
}
/**
 * @param {Number} algId - eg 1
 * @param {Number} ivSize - eg 8
 * @param {string} keyId - Hex KID 93789920e8d6520098577df8f2dd5546
 * @returns {Uint8Array}
 */
function createTENCBox(algId, ivSize, keyId) {
  return createBox("tenc", (0,byte_parsing/* concat */.xW)(6, [algId, ivSize], keyId));
}

;// CONCATENATED MODULE: ./src/transports/smooth/isobmff/create_traf_box.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


function createTrafBox(tfhd, tfdt, trun, mfhd, senc) {
  var trafs = [tfhd, tfdt, trun];
  if (senc !== undefined) {
    trafs.push(createBox("senc", senc), createSAIZBox(senc), createSAIOBox(mfhd, tfhd, tfdt, trun));
  }
  return createBoxWithChildren("traf", trafs);
}
;// CONCATENATED MODULE: ./src/transports/smooth/isobmff/patch_segment.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * Update ISOBMFF Segment downloaded in Smooth Streaming so it is playable on
 * the browser.
 * @param {Uint8Array} segment
 * @param {Number} decodeTime
 * @return {Uint8Array}
 */
function patchSegment(segment, decodeTime) {
  var oldMoofOffsets = (0,get_box/* getBoxOffsets */.QL)(segment, 0x6d6f6f66 /* moof */);
  if (oldMoofOffsets === null) {
    throw new Error("Smooth: Invalid ISOBMFF given");
  }
  var oldMoofContent = segment.subarray(oldMoofOffsets[1], oldMoofOffsets[2]);
  var mfhdBox = (0,get_box/* getBox */.YH)(oldMoofContent, 0x6d666864 /* mfhd */);
  var trafContent = (0,get_box/* getBoxContent */.fZ)(oldMoofContent, 0x74726166 /* traf */);
  if (trafContent === null || mfhdBox === null) {
    throw new Error("Smooth: Invalid ISOBMFF given");
  }
  var tfhdOffsets = (0,get_box/* getBoxOffsets */.QL)(trafContent, 0x74666864 /* tfhd */);
  var oldTrunOffsets = (0,get_box/* getBoxOffsets */.QL)(trafContent, 0x7472756e /* trun */);
  if (tfhdOffsets === null || oldTrunOffsets === null) {
    throw new Error("Smooth: Invalid ISOBMFF given");
  }
  var tfhdBox = trafContent.subarray(tfhdOffsets[0], tfhdOffsets[2]);
  var oldTrunBox = trafContent.subarray(oldTrunOffsets[0], oldTrunOffsets[2]);
  // force trackId=1 since trackIds are not always reliable...
  tfhdBox.set([0, 0, 0, 1], tfhdOffsets[1] - tfhdOffsets[0] + 4 /* version + flags */);
  var tfdtBox = createTfdtBox(decodeTime);
  var newTrunBox = updateTrunDataOffset(oldTrunBox, oldTrunOffsets[1] - oldTrunOffsets[0]);
  var sencContent = (0,get_box/* getUuidContent */.$H)(trafContent, 0xa2394f52, 0x5a9b4f14, 0xa2446c42, 0x7c648df4);
  var newTrafBox = createTrafBox(tfhdBox, tfdtBox, newTrunBox, mfhdBox, sencContent);
  var newMoof = createBoxWithChildren("moof", [mfhdBox, newTrafBox]);
  var newMoofOffsets = (0,get_box/* getBoxOffsets */.QL)(newMoof, 0x6d6f6f66 /* moof */);
  var newTrafOffsets = (0,get_box/* getBoxOffsets */.QL)(newTrafBox, 0x74726166 /* traf */);
  var newTrunOffsets = (0,get_box/* getBoxOffsets */.QL)(newTrunBox, 0x7472756e /* trun */);
  if (newMoofOffsets === null || newTrafOffsets === null || newTrunOffsets === null) {
    throw new Error("Smooth: Invalid moof, trun or traf generation");
  }
  /** index of the `data_offset` property from the trun box in the whole "moof". */
  var indexOfTrunDataOffsetInMoof = newMoofOffsets[1] - newMoofOffsets[0] + mfhdBox.length + ( /* new traf size + name */
  newTrafOffsets[1] - newTrafOffsets[0]) + tfhdBox.length + tfdtBox.length + ( /* new trun size + name */
  newTrunOffsets[1] - newTrunOffsets[0]) + 8; /* trun version + flags + `sample_count` */
  var oldMoofLength = oldMoofOffsets[2] - oldMoofOffsets[0];
  var newMoofSizeDiff = newMoof.length - oldMoofLength;
  var oldMdatOffset = (0,get_box/* getBoxOffsets */.QL)(segment, 0x6d646174 /* "mdat" */);
  if (oldMdatOffset === null) {
    throw new Error("Smooth: Invalid ISOBMFF given");
  }
  if (canPatchISOBMFFSegment() && (newMoofSizeDiff === 0 || newMoofSizeDiff <= -8)) {
    // patch trun data_offset
    var mdatContentOffset = oldMdatOffset[1];
    newMoof.set((0,byte_parsing/* itobe4 */.KS)(mdatContentOffset), indexOfTrunDataOffsetInMoof);
    segment.set(newMoof, oldMoofOffsets[0]);
    // add "free" box for the remaining space
    if (newMoofSizeDiff <= -8) {
      segment.set(createFreeBox(-newMoofSizeDiff), newMoof.length);
    }
    return segment;
  } else {
    // patch trun data_offset
    var _mdatContentOffset = oldMdatOffset[1] + newMoofSizeDiff;
    newMoof.set((0,byte_parsing/* itobe4 */.KS)(_mdatContentOffset), indexOfTrunDataOffsetInMoof);
    var newSegment = new Uint8Array(segment.length + newMoofSizeDiff);
    var beforeMoof = segment.subarray(0, oldMoofOffsets[0]);
    var afterMoof = segment.subarray(oldMoofOffsets[2], segment.length);
    newSegment.set(beforeMoof, 0);
    newSegment.set(newMoof, beforeMoof.length);
    newSegment.set(afterMoof, beforeMoof.length + newMoof.length);
    return newSegment;
  }
}
/**
 * Update `trun` box given or create a new one from it to add a data offset
 * flag and the corresponding space to set a data offset.
 * Do not do anything if the flag is already set.
 *
 * Note that the `oldTrunBox` given should not be mutated by this function but
 * the returned value CAN point to the exact same `Uint8Array`.
 *
 * @param {Uint8Array} oldTrunBox - The whole original trun box
 * @param {number} initialDataOffset - Offset at which the first value of the
 * "trun" box (the "version") is set.
 * @returns {Uint8Array}
 */
function updateTrunDataOffset(oldTrunBox, initialDataOffset) {
  var trunHasDataOffset = (oldTrunBox[initialDataOffset + 3 /* last flag */] & 0x01) > 0;
  if (trunHasDataOffset) {
    return oldTrunBox;
  }
  // If no data_offset is present, we create another "trun" with one
  var newTrunBox = new Uint8Array(oldTrunBox.length + 4);
  // copy size + name + version=1 + flags=3 + sample_count=4
  newTrunBox.set(oldTrunBox.subarray(0, initialDataOffset + 8), 0);
  // add data_offset flag
  newTrunBox[initialDataOffset + 3] = newTrunBox[initialDataOffset + 3] | 0x01;
  newTrunBox.set([0, 0, 0, 0], initialDataOffset + 8); // add data offset
  // add the rest
  newTrunBox.set(oldTrunBox.subarray(initialDataOffset + 8, oldTrunBox.length), initialDataOffset + 12);
  return (0,utils/* updateBoxLength */.J_)(newTrunBox); // update the trun box's length
}
// EXTERNAL MODULE: ./src/errors/custom_loader_error.ts
var custom_loader_error = __webpack_require__(7004);
// EXTERNAL MODULE: ./src/transports/utils/byte_range.ts
var byte_range = __webpack_require__(3233);
;// CONCATENATED MODULE: ./src/transports/smooth/isobmff/create_init_segment.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * @param {Uint8Array} mvhd
 * @param {Uint8Array} mvex
 * @param {Uint8Array} trak
 * @returns {Array.<Uint8Array>}
 */
function createMOOVBox(mvhd, mvex, trak) {
  var children = [mvhd, mvex, trak];
  return createBoxWithChildren("moov", children);
}
/**
 * Create an initialization segment with the information given.
 * @param {Number} timescale
 * @param {string} type
 * @param {Uint8Array} stsd
 * @param {Uint8Array} mhd
 * @param {Number} width
 * @param {Number} height
 * @param {Array.<Object>} pssList - List of dict, example:
 * {systemId: "DEADBEEF", codecPrivateData: "DEAFBEEF}
 * @returns {Uint8Array}
 */
function createInitSegment(timescale, type, stsd, mhd, width, height) {
  var stbl = createBoxWithChildren("stbl", [stsd, createBox("stts", new Uint8Array(0x08)), createBox("stsc", new Uint8Array(0x08)), createBox("stsz", new Uint8Array(0x0c)), createBox("stco", new Uint8Array(0x08))]);
  var url = createBox("url ", new Uint8Array([0, 0, 0, 1]));
  var dref = createDREFBox(url);
  var dinf = createBoxWithChildren("dinf", [dref]);
  var minf = createBoxWithChildren("minf", [mhd, dinf, stbl]);
  var hdlr = createHDLRBox(type);
  var mdhd = createMDHDBox(timescale); // this one is really important
  var mdia = createBoxWithChildren("mdia", [mdhd, hdlr, minf]);
  var tkhd = createTKHDBox(width, height, 1);
  var trak = createBoxWithChildren("trak", [tkhd, mdia]);
  var trex = createTREXBox(1);
  var mvex = createBoxWithChildren("mvex", [trex]);
  var mvhd = createMVHDBox(timescale, 1); // in fact, we don't give a sh** about
  // this value :O
  var moov = createMOOVBox(mvhd, mvex, trak);
  var ftyp = createFTYPBox("isom", ["isom", "iso2", "iso6", "avc1", "dash"]);
  return (0,byte_parsing/* concat */.xW)(ftyp, moov);
}
;// CONCATENATED MODULE: ./src/transports/smooth/isobmff/create_video_init_segment.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Return full video Init segment as Uint8Array
 * @param {Number} timescale - lowest number, this one will be set into mdhd
 * *10000 in mvhd, e.g. 1000
 * @param {Number} width
 * @param {Number} height
 * @param {Number} hRes
 * @param {Number} vRes
 * @param {Number} nalLength (1, 2 or 4)
 * @param {string} codecPrivateData
 * @param {Uint8Array} [keyId]
 * @returns {Uint8Array}
 */
function createVideoInitSegment(timescale, width, height, hRes, vRes, nalLength, codecPrivateData, keyId) {
  var _codecPrivateData$spl = codecPrivateData.split("00000001"),
    spsHex = _codecPrivateData$spl[1],
    ppsHex = _codecPrivateData$spl[2];
  if (spsHex === undefined || ppsHex === undefined) {
    throw new Error("Smooth: unsupported codec private data.");
  }
  var sps = (0,string_parsing/* hexToBytes */.aT)(spsHex);
  var pps = (0,string_parsing/* hexToBytes */.aT)(ppsHex);
  // TODO NAL length is forced to 4
  var avcc = createAVCCBox(sps, pps, nalLength);
  var stsd;
  if (keyId === undefined) {
    var avc1 = createAVC1Box(width, height, hRes, vRes, "AVC Coding", 24, avcc);
    stsd = createSTSDBox([avc1]);
  } else {
    var tenc = createTENCBox(1, 8, keyId);
    var schi = createBoxWithChildren("schi", [tenc]);
    var schm = createSCHMBox("cenc", 65536);
    var frma = createFRMABox("avc1");
    var sinf = createBoxWithChildren("sinf", [frma, schm, schi]);
    var encv = createENCVBox(width, height, hRes, vRes, "AVC Coding", 24, avcc, sinf);
    stsd = createSTSDBox([encv]);
  }
  return createInitSegment(timescale, "video", stsd, createVMHDBox(), width, height);
}
;// CONCATENATED MODULE: ./src/transports/smooth/isobmff/get_aaces_header.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Sampling frequencies defined in MPEG-4 Audio.
 * @type {Array.<Number>}
 */
var SAMPLING_FREQUENCIES = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];
/**
 * Return AAC ES Header (hexstr form)
 *
 * @param {Number} type
 *          1 = AAC Main
 *          2 = AAC LC
 *          cf http://wiki.multimedia.cx/index.php?title=MPEG-4_Audio
 * @param {Number} frequency
 * @param {Number} chans (1 or 2)
 * @returns {string}
 */
function getAacesHeader(type, frequency, chans) {
  var freq = SAMPLING_FREQUENCIES.indexOf(frequency); // TODO : handle Idx = 15...
  var val;
  val = (type & 0x3f) << 0x4;
  val = (val | freq & 0x1f) << 0x4;
  val = (val | chans & 0x1f) << 0x3;
  return (0,string_parsing/* bytesToHex */.My)((0,byte_parsing/* itobe2 */.ww)(val));
}
;// CONCATENATED MODULE: ./src/transports/smooth/isobmff/create_audio_init_segment.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Return full audio initialization segment as Uint8Array.
 * @param {Number} timescale
 * @param {Number} channelsCount
 * @param {Number} sampleSize
 * @param {Number} packetSize
 * @param {Number} sampleRate
 * @param {string} codecPrivateData
 * @param {Uint8Array} keyId - hex string representing the key Id, 32 chars.
 * eg. a800dbed49c12c4cb8e0b25643844b9b
 * @param {Array.<Object>} [pssList]
 * @returns {Uint8Array}
 */
function createAudioInitSegment(timescale, channelsCount, sampleSize, packetSize, sampleRate, codecPrivateData, keyId) {
  var _codecPrivateData = codecPrivateData.length === 0 ? getAacesHeader(2, sampleRate, channelsCount) : codecPrivateData;
  var esds = createESDSBox(1, _codecPrivateData);
  var stsd = function () {
    if (keyId === undefined) {
      var mp4a = createMP4ABox(1, channelsCount, sampleSize, packetSize, sampleRate, esds);
      return createSTSDBox([mp4a]);
    }
    var tenc = createTENCBox(1, 8, keyId);
    var schi = createBoxWithChildren("schi", [tenc]);
    var schm = createSCHMBox("cenc", 65536);
    var frma = createFRMABox("mp4a");
    var sinf = createBoxWithChildren("sinf", [frma, schm, schi]);
    var enca = createENCABox(1, channelsCount, sampleSize, packetSize, sampleRate, esds, sinf);
    return createSTSDBox([enca]);
  }();
  return createInitSegment(timescale, "audio", stsd, createSMHDBox(), 0, 0);
}
;// CONCATENATED MODULE: ./src/transports/smooth/utils.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



var ISM_REG = /(\.isml?)(\?token=\S+)?$/;
var TOKEN_REG = /\?token=(\S+)/;
/**
 * TODO Remove this logic completely from the player
 * @param {Document} doc
 * @returns {string|null}
 */
function extractISML(doc) {
  return doc.getElementsByTagName("media")[0].getAttribute("src");
}
/**
 * Returns string corresponding to the token contained in the url's querystring.
 * Empty string if no token is found.
 * @param {string} url
 * @returns {string}
 */
function extractToken(url) {
  var tokenMatch = TOKEN_REG.exec(url);
  if (tokenMatch !== null) {
    var match = tokenMatch[1];
    if (match !== undefined) {
      return match;
    }
  }
  return "";
}
/**
 * Replace/Remove token from the url's querystring
 * @param {string} url
 * @param {string} [token]
 * @returns {string}
 */
function replaceToken(url, token) {
  if ((0,is_non_empty_string/* default */.A)(token)) {
    return url.replace(TOKEN_REG, "?token=" + token);
  } else {
    return url.replace(TOKEN_REG, "");
  }
}
/**
 * @param {string} url
 * @returns {string}
 */
function resolveManifest(url) {
  if (ISM_REG.test(url)) {
    (0,warn_once/* default */.A)("Giving a isml URL to loadVideo is deprecated." + " Please give the Manifest URL directly");
    return url.replace(ISM_REG, "$1/manifest$2");
  }
  return url;
}
/**
 * Returns `true` if the given Representation refers to segments in an MP4
 * container
 * @param {Representation} representation
 * @returns {Boolean}
 */
function isMP4EmbeddedTrack(representation) {
  return typeof representation.mimeType === "string" && representation.mimeType.indexOf("mp4") >= 0;
}
function constructSegmentUrl(wantedCdn, segment) {
  return wantedCdn === null ? null : segment.url === null ? wantedCdn.baseUrl : (0,resolve_url/* default */.Ay)(wantedCdn.baseUrl, segment.url);
}

;// CONCATENATED MODULE: ./src/transports/smooth/segment_loader.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */







/**
 * Segment loader triggered if there was no custom-defined one in the API.
 * @param {string} url
 * @param {Object} content
 * @param {Object} loaderOptions
 * @param {Object} callbacks
 * @param {Object} cancelSignal
 * @param {boolean} checkMediaSegmentIntegrity
 * @returns {Promise}
 */
function regularSegmentLoader(url, content, callbacks, loaderOptions, cancelSignal, checkMediaSegmentIntegrity) {
  var headers;
  var range = content.segment.range;
  if (Array.isArray(range)) {
    headers = {
      Range: (0,byte_range/* default */.A)(range)
    };
  }
  return (0,request/* default */.Ay)({
    url: url,
    responseType: "arraybuffer",
    headers: headers,
    timeout: loaderOptions.timeout,
    cancelSignal: cancelSignal,
    onProgress: callbacks.onProgress
  }).then(function (data) {
    var isMP4 = isMP4EmbeddedTrack(content.representation);
    if (!isMP4 || checkMediaSegmentIntegrity !== true) {
      return {
        resultType: "segment-loaded",
        resultData: data
      };
    }
    var dataU8 = new Uint8Array(data.responseData);
    (0,check_isobmff_integrity/* default */.A)(dataU8, content.segment.isInit);
    return {
      resultType: "segment-loaded",
      resultData: Object.assign(Object.assign({}, data), {
        responseData: dataU8
      })
    };
  });
}
/**
 * Defines the url for the request, load the right loader (custom/default
 * one).
 */
var generateSegmentLoader = function generateSegmentLoader(_ref) {
  var checkMediaSegmentIntegrity = _ref.checkMediaSegmentIntegrity,
    customSegmentLoader = _ref.customSegmentLoader;
  return function (url, content, loaderOptions, cancelSignal, callbacks) {
    var segment = content.segment,
      manifest = content.manifest,
      period = content.period,
      adaptation = content.adaptation,
      representation = content.representation;
    if (segment.isInit) {
      if (segment.privateInfos === undefined || segment.privateInfos.smoothInitSegment === undefined) {
        throw new Error("Smooth: Invalid segment format");
      }
      var smoothInitPrivateInfos = segment.privateInfos.smoothInitSegment;
      var responseData;
      var codecPrivateData = smoothInitPrivateInfos.codecPrivateData,
        timescale = smoothInitPrivateInfos.timescale,
        _smoothInitPrivateInf = smoothInitPrivateInfos.protection,
        protection = _smoothInitPrivateInf === void 0 ? {
          keyId: undefined,
          keySystems: undefined
        } : _smoothInitPrivateInf;
      if (codecPrivateData === undefined) {
        throw new Error("Smooth: no codec private data.");
      }
      switch (adaptation.type) {
        case "video":
          {
            var _representation$width = representation.width,
              width = _representation$width === void 0 ? 0 : _representation$width,
              _representation$heigh = representation.height,
              height = _representation$heigh === void 0 ? 0 : _representation$heigh;
            responseData = createVideoInitSegment(timescale, width, height, 72, 72, 4,
            // vRes, hRes, nal
            codecPrivateData, protection.keyId);
            break;
          }
        case "audio":
          {
            var _smoothInitPrivateInf2 = smoothInitPrivateInfos.channels,
              channels = _smoothInitPrivateInf2 === void 0 ? 0 : _smoothInitPrivateInf2,
              _smoothInitPrivateInf3 = smoothInitPrivateInfos.bitsPerSample,
              bitsPerSample = _smoothInitPrivateInf3 === void 0 ? 0 : _smoothInitPrivateInf3,
              _smoothInitPrivateInf4 = smoothInitPrivateInfos.packetSize,
              packetSize = _smoothInitPrivateInf4 === void 0 ? 0 : _smoothInitPrivateInf4,
              _smoothInitPrivateInf5 = smoothInitPrivateInfos.samplingRate,
              samplingRate = _smoothInitPrivateInf5 === void 0 ? 0 : _smoothInitPrivateInf5;
            responseData = createAudioInitSegment(timescale, channels, bitsPerSample, packetSize, samplingRate, codecPrivateData, protection.keyId);
            break;
          }
        default:
          if (false) {}
          responseData = new Uint8Array(0);
      }
      return Promise.resolve({
        resultType: "segment-created",
        resultData: responseData
      });
    } else if (url === null) {
      return Promise.resolve({
        resultType: "segment-created",
        resultData: null
      });
    } else {
      var args = {
        adaptation: adaptation,
        manifest: manifest,
        period: period,
        representation: representation,
        segment: segment,
        transport: "smooth",
        timeout: loaderOptions.timeout,
        url: url
      };
      if (typeof customSegmentLoader !== "function") {
        return regularSegmentLoader(url, content, callbacks, loaderOptions, cancelSignal, checkMediaSegmentIntegrity);
      }
      return new Promise(function (res, rej) {
        /** `true` when the custom segmentLoader should not be active anymore. */
        var hasFinished = false;
        /**
         * Callback triggered when the custom segment loader has a response.
         * @param {Object} args
         */
        var resolve = function resolve(_args) {
          if (hasFinished || cancelSignal.isCancelled()) {
            return;
          }
          hasFinished = true;
          cancelSignal.deregister(abortCustomLoader);
          var isMP4 = isMP4EmbeddedTrack(content.representation);
          if (!isMP4 || checkMediaSegmentIntegrity !== true) {
            res({
              resultType: "segment-loaded",
              resultData: {
                responseData: _args.data,
                size: _args.size,
                requestDuration: _args.duration
              }
            });
          }
          var dataU8 = _args.data instanceof Uint8Array ? _args.data : new Uint8Array(_args.data);
          (0,check_isobmff_integrity/* default */.A)(dataU8, content.segment.isInit);
          res({
            resultType: "segment-loaded",
            resultData: {
              responseData: dataU8,
              size: _args.size,
              requestDuration: _args.duration
            }
          });
        };
        /**
         * Callback triggered when the custom segment loader fails
         * @param {*} err - The corresponding error encountered
         */
        var reject = function reject(err) {
          var _a, _b, _c;
          if (hasFinished || cancelSignal.isCancelled()) {
            return;
          }
          hasFinished = true;
          cancelSignal.deregister(abortCustomLoader);
          // Format error and send it
          var castedErr = err;
          var message = (_a = castedErr === null || castedErr === void 0 ? void 0 : castedErr.message) !== null && _a !== void 0 ? _a : "Unknown error when fetching a Smooth segment through a " + "custom segmentLoader.";
          var emittedErr = new custom_loader_error/* default */.A(message, (_b = castedErr === null || castedErr === void 0 ? void 0 : castedErr.canRetry) !== null && _b !== void 0 ? _b : false, (_c = castedErr === null || castedErr === void 0 ? void 0 : castedErr.isOfflineError) !== null && _c !== void 0 ? _c : false, castedErr === null || castedErr === void 0 ? void 0 : castedErr.xhr);
          rej(emittedErr);
        };
        var progress = function progress(_args) {
          if (hasFinished || cancelSignal.isCancelled()) {
            return;
          }
          callbacks.onProgress({
            duration: _args.duration,
            size: _args.size,
            totalSize: _args.totalSize
          });
        };
        var fallback = function fallback() {
          if (hasFinished || cancelSignal.isCancelled()) {
            return;
          }
          hasFinished = true;
          cancelSignal.deregister(abortCustomLoader);
          regularSegmentLoader(url, content, callbacks, loaderOptions, cancelSignal, checkMediaSegmentIntegrity).then(res, rej);
        };
        var customCallbacks = {
          reject: reject,
          resolve: resolve,
          fallback: fallback,
          progress: progress
        };
        var abort = customSegmentLoader(args, customCallbacks);
        cancelSignal.register(abortCustomLoader);
        /**
         * The logic to run when the custom loader is cancelled while pending.
         * @param {Error} err
         */
        function abortCustomLoader(err) {
          if (hasFinished) {
            return;
          }
          hasFinished = true;
          if (!hasFinished && typeof abort === "function") {
            abort();
          }
          rej(err);
        }
      });
    }
  };
};
/* harmony default export */ var segment_loader = (generateSegmentLoader);
;// CONCATENATED MODULE: ./src/transports/smooth/pipelines.ts


/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */














var WSX_REG = /\.wsx?(\?token=\S+)?/;
/**
 * @param {Object} adaptation
 * @param {Object} dlSegment
 * @param {Object} nextSegments
 */
function addNextSegments(adaptation, nextSegments, dlSegment) {
  var _a;
  log/* default */.A.debug("Smooth Parser: update segments information.");
  var representations = adaptation.representations;
  for (var i = 0; i < representations.length; i++) {
    var representation = representations[i];
    if (representation.index instanceof SmoothRepresentationIndex && ((_a = dlSegment === null || dlSegment === void 0 ? void 0 : dlSegment.privateInfos) === null || _a === void 0 ? void 0 : _a.smoothMediaSegment) !== undefined) {
      representation.index.addNewSegments(nextSegments, dlSegment.privateInfos.smoothMediaSegment);
    } else {
      log/* default */.A.warn("Smooth Parser: should only encounter SmoothRepresentationIndex");
    }
  }
}
/* harmony default export */ function pipelines(transportOptions) {
  var smoothManifestParser = smooth(transportOptions);
  var segmentLoader = segment_loader(transportOptions);
  var manifestLoaderOptions = {
    customManifestLoader: transportOptions.manifestLoader
  };
  var manifestLoader = (0,generate_manifest_loader/* default */.A)(manifestLoaderOptions, "text");
  var manifestPipeline = {
    // TODO (v4.x.x) Remove that function
    resolveManifestUrl: function resolveManifestUrl(url, cancelSignal) {
      if (url === undefined) {
        return Promise.resolve(undefined);
      }
      var resolving;
      if (WSX_REG.test(url)) {
        (0,warn_once/* default */.A)("Giving WSX URL to loadVideo is deprecated." + " You should only give Manifest URLs.");
        resolving = (0,request/* default */.Ay)({
          url: replaceToken(url, ""),
          responseType: "document",
          cancelSignal: cancelSignal
        }).then(function (value) {
          var extractedURL = extractISML(value.responseData);
          if (extractedURL === null || extractedURL.length === 0) {
            throw new Error("Invalid ISML");
          }
          return extractedURL;
        });
      } else {
        resolving = Promise.resolve(url);
      }
      var token = extractToken(url);
      return resolving.then(function (_url) {
        return replaceToken(resolveManifest(_url), token);
      });
    },
    loadManifest: manifestLoader,
    parseManifest: function parseManifest(manifestData, parserOptions) {
      var _a;
      var url = (_a = manifestData.url) !== null && _a !== void 0 ? _a : parserOptions.originalUrl;
      var manifestReceivedTime = manifestData.receivedTime,
        responseData = manifestData.responseData;
      var documentData = typeof responseData === "string" ? new DOMParser().parseFromString(responseData, "text/xml") : responseData; // TODO find a way to check if Document?
      var parserResult = smoothManifestParser(documentData, url, manifestReceivedTime);
      var manifest = new src_manifest/* default */.Ay(parserResult, {
        representationFilter: transportOptions.representationFilter,
        supplementaryImageTracks: transportOptions.supplementaryImageTracks,
        supplementaryTextTracks: transportOptions.supplementaryTextTracks
      });
      return {
        manifest: manifest,
        url: url
      };
    }
  };
  /**
   * Export functions allowing to load and parse audio and video smooth
   * segments.
   */
  var audioVideoPipeline = {
    /**
     * Load a Smooth audio/video segment.
     * @param {Object|null} wantedCdn
     * @param {Object} content
     * @param {Object} loaderOptions
     * @param {Object} cancelSignal
     * @param {Object} callbacks
     * @returns {Promise}
     */
    loadSegment: function loadSegment(wantedCdn, content, loaderOptions, cancelSignal, callbacks) {
      var url = constructSegmentUrl(wantedCdn, content.segment);
      return segmentLoader(url, content, loaderOptions, cancelSignal, callbacks);
    },
    parseSegment: function parseSegment(loadedSegment, content, initTimescale) {
      var _a, _b;
      var segment = content.segment,
        adaptation = content.adaptation,
        manifest = content.manifest;
      var data = loadedSegment.data,
        isChunked = loadedSegment.isChunked;
      if (data === null) {
        if (segment.isInit) {
          return {
            segmentType: "init",
            initializationData: null,
            initializationDataSize: 0,
            protectionDataUpdate: false,
            initTimescale: undefined
          };
        }
        return {
          segmentType: "media",
          chunkData: null,
          chunkInfos: null,
          chunkOffset: 0,
          chunkSize: 0,
          protectionDataUpdate: false,
          appendWindow: [undefined, undefined]
        };
      }
      var responseBuffer = data instanceof Uint8Array ? data : new Uint8Array(data);
      if (segment.isInit) {
        var timescale = (_b = (_a = segment.privateInfos) === null || _a === void 0 ? void 0 : _a.smoothInitSegment) === null || _b === void 0 ? void 0 : _b.timescale;
        return {
          segmentType: "init",
          initializationData: data,
          initializationDataSize: data.byteLength,
          // smooth init segments are crafted by hand.
          // Their timescale is the one from the manifest.
          initTimescale: timescale,
          protectionDataUpdate: false
        };
      }
      var timingInfos = initTimescale !== undefined ? extractTimingsInfos(responseBuffer, isChunked, initTimescale, segment, manifest.isLive) : null;
      if (timingInfos === null || timingInfos.chunkInfos === null || timingInfos.scaledSegmentTime === undefined) {
        throw new Error("Smooth Segment without time information");
      }
      var nextSegments = timingInfos.nextSegments,
        chunkInfos = timingInfos.chunkInfos,
        scaledSegmentTime = timingInfos.scaledSegmentTime;
      var chunkData = patchSegment(responseBuffer, scaledSegmentTime);
      if (nextSegments.length > 0) {
        addNextSegments(adaptation, nextSegments, segment);
      }
      return {
        segmentType: "media",
        chunkData: chunkData,
        chunkInfos: chunkInfos,
        chunkOffset: 0,
        chunkSize: chunkData.length,
        protectionDataUpdate: false,
        appendWindow: [undefined, undefined]
      };
    }
  };
  var textTrackPipeline = {
    loadSegment: function loadSegment(wantedCdn, content, loaderOptions, cancelSignal, callbacks) {
      var segment = content.segment,
        representation = content.representation;
      var url = constructSegmentUrl(wantedCdn, segment);
      if (segment.isInit || url === null) {
        return Promise.resolve({
          resultType: "segment-created",
          resultData: null
        });
      }
      var isMP4 = isMP4EmbeddedTrack(representation);
      if (!isMP4) {
        return (0,request/* default */.Ay)({
          url: url,
          responseType: "text",
          timeout: loaderOptions.timeout,
          cancelSignal: cancelSignal,
          onProgress: callbacks.onProgress
        }).then(function (data) {
          return {
            resultType: "segment-loaded",
            resultData: data
          };
        });
      } else {
        return (0,request/* default */.Ay)({
          url: url,
          responseType: "arraybuffer",
          timeout: loaderOptions.timeout,
          cancelSignal: cancelSignal,
          onProgress: callbacks.onProgress
        }).then(function (data) {
          if (transportOptions.checkMediaSegmentIntegrity !== true) {
            return {
              resultType: "segment-loaded",
              resultData: data
            };
          }
          var dataU8 = new Uint8Array(data.responseData);
          (0,check_isobmff_integrity/* default */.A)(dataU8, content.segment.isInit);
          return {
            resultType: "segment-loaded",
            resultData: Object.assign(Object.assign({}, data), {
              responseData: dataU8
            })
          };
        });
      }
    },
    parseSegment: function parseSegment(loadedSegment, content, initTimescale) {
      var _a;
      var manifest = content.manifest,
        adaptation = content.adaptation,
        representation = content.representation,
        segment = content.segment;
      var language = adaptation.language;
      var isMP4 = isMP4EmbeddedTrack(representation);
      var _representation$mimeT = representation.mimeType,
        mimeType = _representation$mimeT === void 0 ? "" : _representation$mimeT,
        _representation$codec = representation.codec,
        codec = _representation$codec === void 0 ? "" : _representation$codec;
      var data = loadedSegment.data,
        isChunked = loadedSegment.isChunked;
      var chunkSize;
      if (segment.isInit) {
        // text init segment has no use in HSS
        return {
          segmentType: "init",
          initializationData: null,
          initializationDataSize: 0,
          protectionDataUpdate: false,
          initTimescale: undefined
        };
      }
      if (data === null) {
        return {
          segmentType: "media",
          chunkData: null,
          chunkInfos: null,
          chunkOffset: 0,
          chunkSize: 0,
          protectionDataUpdate: false,
          appendWindow: [undefined, undefined]
        };
      }
      var nextSegments;
      var chunkInfos = null;
      var segmentStart;
      var segmentEnd;
      var _sdData;
      var _sdType;
      if (isMP4) {
        var chunkBytes;
        if (typeof data === "string") {
          chunkBytes = (0,string_parsing/* strToUtf8 */.eb)(data);
        } else {
          chunkBytes = data instanceof Uint8Array ? data : new Uint8Array(data);
        }
        chunkSize = chunkBytes.length;
        var timingInfos = initTimescale !== undefined ? extractTimingsInfos(chunkBytes, isChunked, initTimescale, segment, manifest.isLive) : null;
        nextSegments = timingInfos === null || timingInfos === void 0 ? void 0 : timingInfos.nextSegments;
        chunkInfos = (_a = timingInfos === null || timingInfos === void 0 ? void 0 : timingInfos.chunkInfos) !== null && _a !== void 0 ? _a : null;
        if (chunkInfos === null) {
          if (isChunked) {
            log/* default */.A.warn("Smooth: Unavailable time data for current text track.");
          } else {
            segmentStart = segment.time;
            segmentEnd = segment.end;
          }
        } else {
          segmentStart = chunkInfos.time;
          segmentEnd = chunkInfos.duration !== undefined ? chunkInfos.time + chunkInfos.duration : segment.end;
        }
        var lcCodec = codec.toLowerCase();
        if (mimeType === "application/ttml+xml+mp4" || lcCodec === "stpp" || lcCodec === "stpp.ttml" || lcCodec === "stpp.ttml.im1t") {
          _sdType = "ttml";
        } else if (lcCodec === "wvtt") {
          _sdType = "vtt";
        } else {
          throw new Error("could not find a text-track parser for the type " + mimeType);
        }
        var mdat = (0,read/* getMDAT */.j8)(chunkBytes);
        _sdData = mdat === null ? "" : (0,string_parsing/* utf8ToStr */.Es)(mdat);
      } else {
        // not MP4
        segmentStart = segment.time;
        segmentEnd = segment.end;
        var chunkString;
        if (typeof data !== "string") {
          var bytesData = data instanceof Uint8Array ? data : new Uint8Array(data);
          chunkSize = bytesData.length;
          chunkString = (0,string_parsing/* utf8ToStr */.Es)(bytesData);
        } else {
          chunkString = data;
        }
        switch (mimeType) {
          case "application/x-sami":
          case "application/smil":
            // TODO SMIL should be its own format, no?
            _sdType = "sami";
            break;
          case "application/ttml+xml":
            _sdType = "ttml";
            break;
          case "text/vtt":
            _sdType = "vtt";
            break;
        }
        if (_sdType === undefined) {
          var _lcCodec = codec.toLowerCase();
          if (_lcCodec === "srt") {
            _sdType = "srt";
          } else {
            throw new Error("could not find a text-track parser for the type " + mimeType);
          }
        }
        _sdData = chunkString;
      }
      if (chunkInfos !== null && Array.isArray(nextSegments) && nextSegments.length > 0) {
        addNextSegments(adaptation, nextSegments, segment);
      }
      var chunkOffset = segmentStart !== null && segmentStart !== void 0 ? segmentStart : 0;
      return {
        segmentType: "media",
        chunkData: {
          type: _sdType,
          data: _sdData,
          start: segmentStart,
          end: segmentEnd,
          language: language
        },
        chunkSize: chunkSize,
        chunkInfos: chunkInfos,
        chunkOffset: chunkOffset,
        protectionDataUpdate: false,
        appendWindow: [undefined, undefined]
      };
    }
  };
  var imageTrackPipeline = {
    loadSegment: function loadSegment(wantedCdn, content, loaderOptions, cancelSignal, callbacks) {
      return (0,asyncToGenerator/* default */.A)( /*#__PURE__*/regenerator_default().mark(function _callee() {
        var segment, url, data;
        return regenerator_default().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              segment = content.segment;
              url = constructSegmentUrl(wantedCdn, segment);
              if (!(segment.isInit || url === null)) {
                _context.next = 4;
                break;
              }
              return _context.abrupt("return", {
                resultType: "segment-created",
                resultData: null
              });
            case 4:
              _context.next = 6;
              return (0,request/* default */.Ay)({
                url: url,
                responseType: "arraybuffer",
                timeout: loaderOptions.timeout,
                onProgress: callbacks.onProgress,
                cancelSignal: cancelSignal
              });
            case 6:
              data = _context.sent;
              return _context.abrupt("return", {
                resultType: "segment-loaded",
                resultData: data
              });
            case 8:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }))();
    },
    parseSegment: function parseSegment(loadedSegment, content, _initTimescale) {
      var data = loadedSegment.data,
        isChunked = loadedSegment.isChunked;
      if (content.segment.isInit) {
        // image init segment has no use
        return {
          segmentType: "init",
          initializationData: null,
          initializationDataSize: 0,
          protectionDataUpdate: false,
          initTimescale: undefined
        };
      }
      if (isChunked) {
        throw new Error("Image data should not be downloaded in chunks");
      }
      // TODO image Parsing should be more on the buffer side, no?
      if (data === null || features/* default */.A.imageParser === null) {
        return {
          segmentType: "media",
          chunkData: null,
          chunkInfos: null,
          chunkOffset: 0,
          chunkSize: 0,
          protectionDataUpdate: false,
          appendWindow: [undefined, undefined]
        };
      }
      var bifObject = features/* default */.A.imageParser(new Uint8Array(data));
      var thumbsData = bifObject.thumbs;
      return {
        segmentType: "media",
        chunkData: {
          data: thumbsData,
          start: 0,
          end: Number.MAX_VALUE,
          timescale: 1,
          type: "bif"
        },
        chunkInfos: {
          time: 0,
          duration: Number.MAX_VALUE
        },
        chunkSize: undefined,
        chunkOffset: 0,
        protectionDataUpdate: false,
        appendWindow: [undefined, undefined]
      };
    }
  };
  return {
    manifest: manifestPipeline,
    audio: audioVideoPipeline,
    video: audioVideoPipeline,
    text: textTrackPipeline,
    image: imageTrackPipeline
  };
}
;// CONCATENATED MODULE: ./src/transports/smooth/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */

/* harmony default export */ var transports_smooth = (pipelines);

/***/ }),

/***/ 3233:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: function() { return /* binding */ byteRange; }
/* harmony export */ });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Returns text-formatted byteRange (`bytes=$start-$end?)`
 * @param {Array.<string|Number>} arr
 * @returns {string}
 */
function byteRange(_ref) {
  var start = _ref[0],
    end = _ref[1];
  return end === Infinity ? "bytes=" + start + "-" : "bytes=" + start + "-" + end;
}

/***/ }),

/***/ 3598:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: function() { return /* binding */ checkISOBMFFIntegrity; }
/* harmony export */ });
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1858);
/* harmony import */ var _find_complete_box__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1688);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Check if an ISOBMFF segment has all the right box needed to be decoded.
 * Throw if that's not the case.
 * @param {Uint8Array} buffer - The whole ISOBMFF segment
 * @param {boolean} isInitSegment - `true` if this is an initialization segment,
 * `false` otherwise.
 */
function checkISOBMFFIntegrity(buffer, isInitSegment) {
  if (isInitSegment) {
    var ftypIndex = (0,_find_complete_box__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(buffer, 0x66747970 /* ftyp */);
    if (ftypIndex < 0) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A("INTEGRITY_ERROR", "Incomplete `ftyp` box");
    }
    var moovIndex = (0,_find_complete_box__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(buffer, 0x6d6f6f76 /* moov */);
    if (moovIndex < 0) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A("INTEGRITY_ERROR", "Incomplete `moov` box");
    }
  } else {
    var moofIndex = (0,_find_complete_box__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(buffer, 0x6d6f6f66 /* moof */);
    if (moofIndex < 0) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A("INTEGRITY_ERROR", "Incomplete `moof` box");
    }
    var mdatIndex = (0,_find_complete_box__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(buffer, 0x6d646174 /* mdat */);
    if (mdatIndex < 0) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A("INTEGRITY_ERROR", "Incomplete `mdat` box");
    }
  }
}

/***/ }),

/***/ 1688:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: function() { return /* binding */ findCompleteBox; }
/* harmony export */ });
/* harmony import */ var _utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5553);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Find the offset for the first declaration of the given box in an isobmff.
 * Returns -1 if not found or if incomplete.
 *
 * This function does not throw or log in case of partial segments.
 * @param {Uint8Array} buf - the isobmff
 * @param {Number} wantedName
 * @returns {Number} - Offset where the box begins. -1 if not found.
 */
function findCompleteBox(buf, wantedName) {
  var len = buf.length;
  var i = 0;
  while (i + 8 <= len) {
    var size = (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__/* .be4toi */ .mq)(buf, i);
    if (size === 0) {
      size = len - i;
    } else if (size === 1) {
      if (i + 16 > len) {
        return -1;
      }
      size = (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__/* .be8toi */ .CQ)(buf, i + 8);
    }
    if (isNaN(size) || size <= 0) {
      // should not happen
      return -1;
    }
    var name = (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__/* .be4toi */ .mq)(buf, i + 4);
    if (name === wantedName) {
      if (i + size <= len) {
        return i;
      }
      return -1;
    }
    i += size;
  }
  return -1;
}

/***/ }),

/***/ 1856:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: function() { return /* binding */ generateManifestLoader; }
});

// EXTERNAL MODULE: ./src/utils/assert_unreachable.ts + 1 modules
var assert_unreachable = __webpack_require__(2038);
// EXTERNAL MODULE: ./src/utils/request/index.ts + 1 modules
var request = __webpack_require__(4389);
// EXTERNAL MODULE: ./src/errors/custom_loader_error.ts
var custom_loader_error = __webpack_require__(7004);
;// CONCATENATED MODULE: ./src/transports/utils/call_custom_manifest_loader.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function callCustomManifestLoader(customManifestLoader, fallbackManifestLoader) {
  return function (url, loaderOptions, cancelSignal) {
    return new Promise(function (res, rej) {
      var timeAPIsDelta = Date.now() - performance.now();
      /** `true` when the custom segmentLoader should not be active anymore. */
      var hasFinished = false;
      /**
       * Callback triggered when the custom manifest loader has a response.
       * @param {Object} args
       */
      var resolve = function resolve(_args) {
        if (hasFinished || cancelSignal.isCancelled()) {
          return;
        }
        hasFinished = true;
        cancelSignal.deregister(abortCustomLoader);
        var receivedTime = _args.receivingTime !== undefined ? _args.receivingTime - timeAPIsDelta : undefined;
        var sendingTime = _args.sendingTime !== undefined ? _args.sendingTime - timeAPIsDelta : undefined;
        res({
          responseData: _args.data,
          size: _args.size,
          requestDuration: _args.duration,
          url: _args.url,
          receivedTime: receivedTime,
          sendingTime: sendingTime
        });
      };
      /**
       * Callback triggered when the custom manifest loader fails
       * @param {*} err - The corresponding error encountered
       */
      var reject = function reject(err) {
        var _a, _b, _c;
        if (hasFinished || cancelSignal.isCancelled()) {
          return;
        }
        hasFinished = true;
        cancelSignal.deregister(abortCustomLoader);
        // Format error and send it
        var castedErr = err;
        var message = (_a = castedErr === null || castedErr === void 0 ? void 0 : castedErr.message) !== null && _a !== void 0 ? _a : "Unknown error when fetching the Manifest through a " + "custom manifestLoader.";
        var emittedErr = new custom_loader_error/* default */.A(message, (_b = castedErr === null || castedErr === void 0 ? void 0 : castedErr.canRetry) !== null && _b !== void 0 ? _b : false, (_c = castedErr === null || castedErr === void 0 ? void 0 : castedErr.isOfflineError) !== null && _c !== void 0 ? _c : false, castedErr === null || castedErr === void 0 ? void 0 : castedErr.xhr);
        rej(emittedErr);
      };
      /**
       * Callback triggered when the custom manifest loader wants to fallback to
       * the "regular" implementation
       */
      var fallback = function fallback() {
        if (hasFinished || cancelSignal.isCancelled()) {
          return;
        }
        hasFinished = true;
        cancelSignal.deregister(abortCustomLoader);
        fallbackManifestLoader(url, loaderOptions, cancelSignal).then(res, rej);
      };
      var callbacks = {
        reject: reject,
        resolve: resolve,
        fallback: fallback
      };
      var abort = customManifestLoader(url, callbacks, {
        timeout: loaderOptions.timeout
      });
      cancelSignal.register(abortCustomLoader);
      /**
       * The logic to run when the custom loader is cancelled while pending.
       * @param {Error} err
       */
      function abortCustomLoader(err) {
        if (hasFinished) {
          return;
        }
        hasFinished = true;
        if (typeof abort === "function") {
          abort();
        }
        rej(err);
      }
    });
  };
}
;// CONCATENATED MODULE: ./src/transports/utils/generate_manifest_loader.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Manifest loader triggered if there was no custom-defined one in the API.
 * @param {string} preferredType
 * @returns {Function}
 */
function generateRegularManifestLoader(preferredType) {
  return function regularManifestLoader(url, loaderOptions, cancelSignal) {
    if (url === undefined) {
      throw new Error("Cannot perform HTTP(s) request. URL not known");
    }
    // What follows could be written in a single line, but TypeScript wouldn't
    // shut up.
    // So I wrote that instead, temporarily of course ;)
    switch (preferredType) {
      case "arraybuffer":
        return (0,request/* default */.Ay)({
          url: url,
          responseType: "arraybuffer",
          timeout: loaderOptions.timeout,
          cancelSignal: cancelSignal
        });
      case "text":
        return (0,request/* default */.Ay)({
          url: url,
          responseType: "text",
          timeout: loaderOptions.timeout,
          cancelSignal: cancelSignal
        });
      case "document":
        return (0,request/* default */.Ay)({
          url: url,
          responseType: "document",
          timeout: loaderOptions.timeout,
          cancelSignal: cancelSignal
        });
      default:
        (0,assert_unreachable/* default */.A)(preferredType);
    }
  };
}
/**
 * Generate a manifest loader for the application
 * @param {Function} [customManifestLoader]
 * @returns {Function}
 */
function generateManifestLoader(_ref, preferredType) {
  var customManifestLoader = _ref.customManifestLoader;
  var regularManifestLoader = generateRegularManifestLoader(preferredType);
  if (typeof customManifestLoader !== "function") {
    return regularManifestLoader;
  }
  return callCustomManifestLoader(customManifestLoader, regularManifestLoader);
}

/***/ }),

/***/ 987:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: function() { return /* binding */ areArraysOfNumbersEqual; }
/* harmony export */ });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Check if two two arrays containing only numbers are equal.
 * @param {Array.<number>|TypedArray} arr1
 * @param {Array.<number>|TypedArray} arr2
 * @returns {Boolean}
 */
function areArraysOfNumbersEqual(arr1, arr2) {
  if (arr1.length !== arr2.length) {
    return false;
  }
  if (arr1 === arr2) {
    return true;
  }
  for (var i = arr1.length - 1; i >= 0; i--) {
    if (arr1[i] !== arr2[i]) {
      return false;
    }
  }
  return true;
}

/***/ }),

/***/ 1729:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: function() { return /* binding */ arrayFind; }
/* harmony export */ });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Array.prototype.find ponyfill.
 * @param {Array} arr
 * @param {Function} predicate
 * @param {*} context
 * @returns {boolean}
 */
function arrayFind(arr, predicate, thisArg) {
  if (typeof Array.prototype.find === "function") {
    return arr.find(predicate, thisArg);
  }
  var len = arr.length >>> 0;
  for (var i = 0; i < len; i++) {
    var val = arr[i];
    if (predicate.call(thisArg, val, i, arr)) {
      return val;
    }
  }
  return undefined;
}

/***/ }),

/***/ 3786:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: function() { return /* binding */ arrayFindIndex; }
/* harmony export */ });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Array.prototype.find ponyfill.
 * @param {Array} arr
 * @param {Function} predicate
 * @param {*} context
 * @returns {boolean}
 */
function arrayFindIndex(arr, predicate, thisArg) {
  if (typeof Array.prototype.findIndex === "function") {
    return arr.findIndex(predicate, thisArg);
  }
  var len = arr.length >>> 0;
  for (var i = 0; i < len; i++) {
    if (predicate.call(thisArg, arr[i], i, arr)) {
      return i;
    }
  }
  return -1;
}

/***/ }),

/***/ 4031:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: function() { return /* binding */ arrayIncludes; }
/* harmony export */ });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Array.prototype.includes ponyfill.
 * Returns ``true`` if the given array ``arr`` contains the element
 * ``searchElement``. false ``otherwise``.
 *
 * Inspired from MDN polyfill, but ponyfilled instead
 *
 * @example
 * ```js
 * arrayIncludes([1, 2, 3], 3);
 * // => true
 *
 * arrayIncludes([1, 2, 3], 7);
 * // => false
 *
 * const obj = { a: 4 };
 * arrayIncludes([obj, { b: 7 }, { a: 3 }], obj);
 * // => true
 *
 * // does not perform deep equality
 * arrayIncludes([{ a: 4 }, { b: 7 }, { a: 3 }], { a: 4 });
 * // => false
 *
 * // the third argument state the starting index. 0 if not set.
 *
 * arrayIncludes([1, 2, 3], 2, 1);
 * // => true
 *
 * arrayIncludes([1, 2, 3], 2, 2);
 * // => false
 * ```
 *
 * @param {Array} arr
 * @param {*} searchElement
 * @param {number} [fromIndex]
 * @returns {boolean}
 */
function arrayIncludes(arr, searchElement, fromIndex) {
  /* eslint-disable @typescript-eslint/unbound-method */
  // eslint-disable-next-line no-restricted-properties
  if (typeof Array.prototype.includes === "function") {
    /* eslint-enable @typescript-eslint/unbound-method */
    // eslint-disable-next-line no-restricted-properties
    return arr.includes(searchElement, fromIndex);
  }
  var len = arr.length >>> 0;
  if (len === 0) {
    return false;
  }
  var n = fromIndex | 0;
  var k = n >= 0 ? Math.min(n, len - 1) : Math.max(len + n, 0);
  var areTheSame = function areTheSame(x, y) {
    return x === y ||
    // Viva las JavaScriptas!
    typeof x === "number" && typeof y === "number" && isNaN(x) && isNaN(y);
  };
  while (k < len) {
    if (areTheSame(arr[k], searchElement)) {
      return true;
    }
    k++;
  }
  return false;
}

/***/ }),

/***/ 7994:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: function() { return /* binding */ assertInterface; },
/* harmony export */   h: function() { return /* binding */ assert; }
/* harmony export */ });
/* harmony import */ var _is_null_or_undefined__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6787);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Throw an AssertionError if the given assertion is false.
 * @param {boolean} assertion
 * @param {string} [message] - Optional message property for the AssertionError.
 * @throws AssertionError - Throws if the assertion given is false
 */
function assert(assertion, message) {
  if (false) {}
}
/**
 * Throws if the given Object does not respect the interface.
 * @param {Object} o
 * @param {Object} iface - Contains the checked keynames of o and link them
 * to their types (obtained through the typeof operator).
 * @param {string} [name="object"] - name of the _interface_
 * @throws AssertionError - The argument o given is not an object
 * @throws AssertionError - The _interface_ is not respected.
 */
function assertInterface(o, iface, name) {
  if (name === void 0) {
    name = "object";
  }
  assert(!(0,_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(o), name + " should be an object");
  for (var k in iface) {
    if (iface.hasOwnProperty(k)) {
      /* eslint-disable max-len  */
      /* eslint-disable @typescript-eslint/restrict-template-expressions */
      assert(typeof o[k] === iface[k], name + " should have property " + k + " as a " + iface[k]);
      /* eslint-enable max-len */
      /* eslint-enable @typescript-eslint/restrict-template-expressions */
    }
  }
}

/***/ }),

/***/ 2038:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: function() { return /* binding */ assertUnreachable; }
});

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js
var inheritsLoose = __webpack_require__(7387);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js + 4 modules
var wrapNativeSuper = __webpack_require__(8593);
;// CONCATENATED MODULE: ./src/errors/assertion_error.ts


/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Error due to an abnormal assertion fails.
 *
 * This should be an internal error which is later transformed into a documented
 * (as part of the API) Error instance before being emitted to the application.
 * @class AssertionError
 * @extends Error
 */
var AssertionError = /*#__PURE__*/function (_Error) {
  /**
   * @param {string} message
   */
  function AssertionError(message) {
    var _this;
    _this = _Error.call(this, message) || this;
    // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class
    Object.setPrototypeOf(_this, AssertionError.prototype);
    _this.name = "AssertionError";
    return _this;
  }
  (0,inheritsLoose/* default */.A)(AssertionError, _Error);
  return AssertionError;
}( /*#__PURE__*/(0,wrapNativeSuper/* default */.A)(Error));

;// CONCATENATED MODULE: ./src/utils/assert_unreachable.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * TypeScript hack to make sure a code path is never taken.
 *
 * This can for example be used to ensure that a switch statement handle all
 * possible cases by adding a default clause calling assertUnreachable with
 * an argument (it doesn't matter which one).
 *
 * @example
 * function parseBinary(str : "0" | "1") : number {
 *   switch (str) {
 *     case "0:
 *       return 0;
 *     case "1":
 *       return 1;
 *     default:
 *       // branch never taken. If it can be, TypeScript will yell at us because
 *       // its argument (here, `str`) is not of the right type.
 *       assertUnreachable(str);
 *   }
 * }
 * @param {*} _
 * @throws AssertionError - Throw an AssertionError when called. If we're
 * sufficiently strict with how we use TypeScript, this should never happen.
 */
function assertUnreachable(_) {
  throw new AssertionError("Unreachable path taken");
}

/***/ }),

/***/ 603:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   K: function() { return /* binding */ base64ToBytes; },
/* harmony export */   i: function() { return /* binding */ bytesToBase64; }
/* harmony export */ });
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9477);
/* eslint-disable */
/*
MIT License
Copyright (c) 2020 Egor Nepomnyaschih
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
 */

/*
// This constant can also be computed with the following algorithm:
const base64abc = [],
  A = "A".charCodeAt(0),
  a = "a".charCodeAt(0),
  n = "0".charCodeAt(0);
for (let i = 0; i < 26; ++i) {
  base64abc.push(String.fromCharCode(A + i));
}
for (let i = 0; i < 26; ++i) {
  base64abc.push(String.fromCharCode(a + i));
}
for (let i = 0; i < 10; ++i) {
  base64abc.push(String.fromCharCode(n + i));
}
base64abc.push("+");
base64abc.push("/");
 */
var base64abc = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "+", "/"];
/*
// This constant can also be computed with the following algorithm:
const l = 256, base64codes = new Uint8Array(l);
for (let i = 0; i < l; ++i) {
  base64codes[i] = 255; // invalid character
}
base64abc.forEach((char, index) => {
  base64codes[char.charCodeAt(0)] = index;
});
base64codes["=".charCodeAt(0)] = 0; // ignored anyway, so we just need to prevent an error
 */
var base64codes = [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 62, 255, 255, 255, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 255, 255, 255, 0, 255, 255, 255, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 255, 255, 255, 255, 255, 255, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51];
/**
 * Obtain the value corresponding to a base64 char code.
 * /!\ Can throw if the char code given is invalid.
 * @param {number} charCode
 * @returns {number}
 */
function getBase64Code(charCode) {
  if (charCode >= base64codes.length) {
    throw new Error("Unable to parse base64 string.");
  }
  var code = base64codes[charCode];
  if (code === 255) {
    throw new Error("Unable to parse base64 string.");
  }
  return code;
}
/**
 * Convert an array of bytes into a base64 string.
 * @param {Array.<number>|Uint8Array} bytes
 * @returns {string}
 */
function bytesToBase64(bytes) {
  var result = "";
  var i;
  var length = bytes.length;
  for (i = 2; i < length; i += 3) {
    result += base64abc[bytes[i - 2] >> 2];
    result += base64abc[(bytes[i - 2] & 0x03) << 4 | bytes[i - 1] >> 4];
    result += base64abc[(bytes[i - 1] & 0x0f) << 2 | bytes[i] >> 6];
    result += base64abc[bytes[i] & 0x3f];
  }
  if (i === length + 1) {
    // 1 octet yet to write
    result += base64abc[bytes[i - 2] >> 2];
    result += base64abc[(bytes[i - 2] & 0x03) << 4];
    result += "==";
  }
  if (i === length) {
    // 2 octets yet to write
    result += base64abc[bytes[i - 2] >> 2];
    result += base64abc[(bytes[i - 2] & 0x03) << 4 | bytes[i - 1] >> 4];
    result += base64abc[(bytes[i - 1] & 0x0f) << 2];
    result += "=";
  }
  return result;
}
/**
 * Convert a base64 string into the corresponding Uint8Array containing its
 * corresponding binary data.
 * /!\ Can throw if an invalid base64 string was given.
 * @param {Array.<number>|Uint8Array} bytes
 * @returns {string}
 */
function base64ToBytes(str) {
  var paddingNeeded = str.length % 4;
  var paddedStr = str;
  if (paddingNeeded !== 0) {
    _log__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.warn("base64ToBytes: base64 given miss padding");
    paddedStr += paddingNeeded === 3 ? "=" : paddingNeeded === 2 ? "==" : "==="; // invalid, but we will catch it
  }
  var index = paddedStr.indexOf("=");
  if (index !== -1 && index < paddedStr.length - 2) {
    throw new Error("Unable to parse base64 string.");
  }
  var missingOctets = paddedStr.endsWith("==") ? 2 : paddedStr.endsWith("=") ? 1 : 0;
  var n = paddedStr.length;
  var result = new Uint8Array(n / 4 * 3);
  var buffer;
  for (var i = 0, j = 0; i < n; i += 4, j += 3) {
    buffer = getBase64Code(paddedStr.charCodeAt(i)) << 18 | getBase64Code(paddedStr.charCodeAt(i + 1)) << 12 | getBase64Code(paddedStr.charCodeAt(i + 2)) << 6 | getBase64Code(paddedStr.charCodeAt(i + 3));
    result[j] = buffer >> 16;
    result[j + 1] = buffer >> 8 & 0xff;
    result[j + 2] = buffer & 0xff;
  }
  return result.subarray(0, result.length - missingOctets);
}

/***/ }),

/***/ 5553:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AT: function() { return /* binding */ le2toi; },
/* harmony export */   CQ: function() { return /* binding */ be8toi; },
/* harmony export */   KS: function() { return /* binding */ itobe4; },
/* harmony export */   Kk: function() { return /* binding */ itobe8; },
/* harmony export */   UU: function() { return /* binding */ be2toi; },
/* harmony export */   WO: function() { return /* binding */ itole2; },
/* harmony export */   Wz: function() { return /* binding */ itole4; },
/* harmony export */   eR: function() { return /* binding */ le4toi; },
/* harmony export */   mq: function() { return /* binding */ be4toi; },
/* harmony export */   tb: function() { return /* binding */ be3toi; },
/* harmony export */   ww: function() { return /* binding */ itobe2; },
/* harmony export */   xW: function() { return /* binding */ concat; }
/* harmony export */ });
/* unused harmony exports le8toi, isABEqualBytes, toUint8Array */
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Returns a Uint8Array from the arguments given, in order:
 *   - if the next argument given is a number N set the N next bytes to 0.
 *   - else set the next bytes to the argument given.
 * @param {...(Number|Uint8Array)} args
 * @returns {Uint8Array}
 */
function concat() {
  var l = arguments.length;
  var i = -1;
  var len = 0;
  var arg;
  while (++i < l) {
    arg = i < 0 || arguments.length <= i ? undefined : arguments[i];
    len += typeof arg === "number" ? arg : arg.length;
  }
  var arr = new Uint8Array(len);
  var offset = 0;
  i = -1;
  while (++i < l) {
    arg = i < 0 || arguments.length <= i ? undefined : arguments[i];
    if (typeof arg === "number") {
      offset += arg;
    } else if (arg.length > 0) {
      arr.set(arg, offset);
      offset += arg.length;
    }
  }
  return arr;
}
/**
 * Translate groups of 2 big-endian bytes to Integer (from 0 up to 65535).
 * @param {Uint8Array} bytes
 * @param {Number} offset - The offset (from the start of the given array)
 * @returns {Number}
 */
function be2toi(bytes, offset) {
  return (bytes[offset + 0] << 8) + (bytes[offset + 1] << 0);
}
/**
 * Translate groups of 3 big-endian bytes to Integer.
 * @param {Uint8Array} bytes
 * @param {Number} offset - The offset (from the start of the given array)
 * @returns {Number}
 */
function be3toi(bytes, offset) {
  return bytes[offset + 0] * 0x0010000 + bytes[offset + 1] * 0x0000100 + bytes[offset + 2];
}
/**
 * Translate groups of 4 big-endian bytes to Integer.
 * @param {Uint8Array} bytes
 * @param {Number} offset - The offset (from the start of the given array)
 * @returns {Number}
 */
function be4toi(bytes, offset) {
  return bytes[offset + 0] * 0x1000000 + bytes[offset + 1] * 0x0010000 + bytes[offset + 2] * 0x0000100 + bytes[offset + 3];
}
/**
 * Translate groups of 8 big-endian bytes to Integer.
 * @param {Uint8Array} bytes
 * @param {Number} offset - The offset (from the start of the given array)
 * @returns {Number}
 */
function be8toi(bytes, offset) {
  return (bytes[offset + 0] * 0x1000000 + bytes[offset + 1] * 0x0010000 + bytes[offset + 2] * 0x0000100 + bytes[offset + 3]) * 0x100000000 + bytes[offset + 4] * 0x1000000 + bytes[offset + 5] * 0x0010000 + bytes[offset + 6] * 0x0000100 + bytes[offset + 7];
}
/**
 * Translate Integer (from 0 up to 65535) to a Uint8Array of length 2 of
 * the corresponding big-endian bytes.
 * @param {Number} num
 * @returns {Uint8Array}
 */
function itobe2(num) {
  return new Uint8Array([num >>> 8 & 0xff, num & 0xff]);
}
/**
 * Translate Integer to a Uint8Array of length 4 of the corresponding big-endian
 * bytes.
 * @param {Number} num
 * @returns {Uint8Array}
 */
function itobe4(num) {
  return new Uint8Array([num >>> 24 & 0xff, num >>> 16 & 0xff, num >>> 8 & 0xff, num & 0xff]);
}
/**
 * Translate Integer to a Uint8Array of length 8 of the corresponding big-endian
 * bytes.
 * /!\ If the top-most bytes are set, this might go over MAX_SAFE_INTEGER, thus
 * leading to a "bad" value.
 * @param {Number} num
 * @returns {Uint8Array}
 */
function itobe8(num) {
  var l = num % 0x100000000;
  var h = (num - l) / 0x100000000;
  return new Uint8Array([h >>> 24 & 0xff, h >>> 16 & 0xff, h >>> 8 & 0xff, h & 0xff, l >>> 24 & 0xff, l >>> 16 & 0xff, l >>> 8 & 0xff, l & 0xff]);
}
/**
 * Translate groups of 2 little-endian bytes to Integer (from 0 up to 65535).
 * @param {Uint8Array} bytes
 * @param {Number} offset - The offset (from the start of the given array)
 * @returns {Number}
 */
function le2toi(bytes, offset) {
  return (bytes[offset + 0] << 0) + (bytes[offset + 1] << 8);
}
/**
 * Translate groups of 4 little-endian bytes to Integer.
 * @param {Uint8Array} bytes
 * @param {Number} offset - The offset (from the start of the given array)
 * @returns {Number}
 */
function le4toi(bytes, offset) {
  return bytes[offset + 0] + bytes[offset + 1] * 0x0000100 + bytes[offset + 2] * 0x0010000 + bytes[offset + 3] * 0x1000000;
}
/**
 * Translate groups of 8 little-endian bytes to Integer.
 * @param {Uint8Array} bytes
 * @param {Number} offset - The offset (from the start of the given array)
 * @returns {Number}
 */
function le8toi(bytes, offset) {
  return bytes[offset + 0] + bytes[offset + 1] * 0x0000100 + bytes[offset + 2] * 0x0010000 + bytes[offset + 3] * 0x1000000 + (bytes[offset + 4] + bytes[offset + 5] * 0x0000100 + bytes[offset + 6] * 0x0010000 + bytes[offset + 7] * 0x1000000) * 0x100000000;
}
/**
 * Translate Integer (from 0 up to 65535) to a Uint8Array of length 2 of
 * the corresponding little-endian bytes.
 * @param {Number} num
 * @returns {Uint8Array}
 */
function itole2(num) {
  return new Uint8Array([num & 0xff, num >>> 8 & 0xff]);
}
/**
 * Translate Integer to a Uint8Array of length 4 of the corresponding
 * little-endian bytes.
 * @param {Number} num
 * @returns {Uint8Array}
 */
function itole4(num) {
  return new Uint8Array([num & 0xff, num >>> 8 & 0xff, num >>> 16 & 0xff, num >>> 24 & 0xff]);
}
/**
 * Check if an ArrayBuffer is equal to the bytes given.
 * @param {ArrayBuffer} buffer
 * @param {Uint8Array} bytes
 * @returns {Boolean}
 */
function isABEqualBytes(buffer, bytes) {
  var view = new DataView(buffer);
  var len = view.byteLength;
  if (len !== bytes.length) {
    return false;
  }
  for (var i = 0; i < len; i++) {
    if (view.getUint8(i) !== bytes[i]) {
      return false;
    }
  }
  return true;
}
/**
 * Convert any BufferSource-typed structure into the corresponding Uint8Array.
 * @param {BufferSource} input
 * @returns {Uint8Array}
 */
function toUint8Array(input) {
  return input instanceof Uint8Array ? input : input instanceof ArrayBuffer ? new Uint8Array(input) : new Uint8Array(input.buffer);
}


/***/ }),

/***/ 2432:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: function() { return /* binding */ cancellableSleep; }
/* harmony export */ });
/* harmony import */ var _create_cancellable_promise__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4339);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Wait the given `delay`, resolving the Promise when finished.
 *
 * The `cancellationSignal` given allows to cancel that timeout. In the case it
 * is triggered before the timeout ended, this function will reject the
 * corresponding `CancellationError` through the returned Promise.
 *
 * @param {number} delay - Delay to wait, in milliseconds
 * @param {Object} cancellationSignal - `CancellationSignal` allowing to abort
 * the timeout.
 * @returns {Promise} - Resolve on timeout completion, rejects on timeout
 * cancellation with the corresponding `CancellationError`.
 */
function cancellableSleep(delay, cancellationSignal) {
  return (0,_create_cancellable_promise__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(cancellationSignal, function (res) {
    var timeout = setTimeout(function () {
      return res();
    }, delay);
    return function () {
      return clearTimeout(timeout);
    };
  });
}

/***/ }),

/***/ 4339:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: function() { return /* binding */ createCancellablePromise; }
/* harmony export */ });
/**
 * Returns a Promise linked to a `CancellationSignal`, which will reject the
 * corresponding `CancellationError` if that signal emits before the wanted
 * task finishes (either on success or on error).
 *
 * The given callback mimicks the Promise interface with the added possibility
 * of returning a callback which will be called when and if the task is
 * cancelled before being either resolved or rejected.
 * In that case, that logic will be called just before the Promise is rejected
 * with the corresponding `CancellationError`.
 * The point of this callback is to implement aborting logic, such as for
 * example aborting a request.
 *
 * @param {Object} cancellationSignal - The `CancellationSignal` the returned
 * Promise will be linked to.
 * @param {Function} cb - The function implementing the cancellable Promise. Its
 * arguments follow Promise's semantics but it can also return a function which
 * will be called when and if `cancellationSignal` emits before either arguments
 * are called.
 * @returns {Promise} - The created Promise, which will resolve when and if the
 * first argument to `cb` is called first and reject either if the second
 * argument to `cb` is called first or if the given `CancellationSignal` emits
 * before either of the two previous conditions.
 */
function createCancellablePromise(cancellationSignal, cb) {
  var abortingLogic;
  return new Promise(function (res, rej) {
    if (cancellationSignal.cancellationError !== null) {
      // If the signal was already triggered before, do not even call `cb`
      return rej(cancellationSignal.cancellationError);
    }
    var hasUnregistered = false;
    abortingLogic = cb(function onCancellablePromiseSuccess(val) {
      cancellationSignal.deregister(onCancellablePromiseCancellation);
      hasUnregistered = true;
      res(val);
    }, function onCancellablePromiseFailure(err) {
      cancellationSignal.deregister(onCancellablePromiseCancellation);
      hasUnregistered = true;
      rej(err);
    });
    if (!hasUnregistered) {
      cancellationSignal.register(onCancellablePromiseCancellation);
    }
    function onCancellablePromiseCancellation(error) {
      if (abortingLogic !== undefined) {
        abortingLogic();
      }
      rej(error);
    }
  });
}

/***/ }),

/***/ 79:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: function() { return /* binding */ EventEmitter; }
/* harmony export */ });
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9477);
/* harmony import */ var _is_null_or_undefined__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6787);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Simple but fully type-safe EventEmitter implementation.
 * @class EventEmitter
 */
var EventEmitter = /*#__PURE__*/function () {
  function EventEmitter() {
    this._listeners = {};
  }
  /**
   * Register a new callback for an event.
   *
   * @param {string} evt - The event to register a callback to
   * @param {Function} fn - The callback to call as that event is triggered.
   * The callback will take as argument the eventual payload of the event
   * (single argument).
   * @param {Object | undefined} cancellationSignal - When that signal emits,
   * the event listener is automatically removed.
   */
  var _proto = EventEmitter.prototype;
  _proto.addEventListener = function addEventListener(evt, fn, cancellationSignal) {
    var _this = this;
    var listeners = this._listeners[evt];
    if (!Array.isArray(listeners)) {
      this._listeners[evt] = [fn];
    } else {
      listeners.push(fn);
    }
    if (cancellationSignal !== undefined) {
      cancellationSignal.register(function () {
        _this.removeEventListener(evt, fn);
      });
    }
  }
  /**
   * Unregister callbacks linked to events.
   * @param {string} [evt] - The event for which the callback[s] should be
   * unregistered. Set it to null or undefined to remove all callbacks
   * currently registered (for any event).
   * @param {Function} [fn] - The callback to unregister. If set to null
   * or undefined while the evt argument is set, all callbacks linked to that
   * event will be unregistered.
   */;
  _proto.removeEventListener = function removeEventListener(evt, fn) {
    if ((0,_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(evt)) {
      this._listeners = {};
      return;
    }
    var listeners = this._listeners[evt];
    if (!Array.isArray(listeners)) {
      return;
    }
    if ((0,_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(fn)) {
      delete this._listeners[evt];
      return;
    }
    var index = listeners.indexOf(fn);
    if (index !== -1) {
      listeners.splice(index, 1);
    }
    if (listeners.length === 0) {
      delete this._listeners[evt];
    }
  }
  /**
   * Trigger every registered callbacks for a given event
   * @param {string} evt - The event to trigger
   * @param {*} arg - The eventual payload for that event. All triggered
   * callbacks will recieve this payload as argument.
   */;
  _proto.trigger = function trigger(evt, arg) {
    var listeners = this._listeners[evt];
    if (!Array.isArray(listeners)) {
      return;
    }
    listeners.slice().forEach(function (listener) {
      try {
        listener(arg);
      } catch (e) {
        _log__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.error("EventEmitter: listener error", e instanceof Error ? e : null);
      }
    });
  };
  return EventEmitter;
}();


/***/ }),

/***/ 3262:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: function() { return /* binding */ flatMap; }
/* harmony export */ });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Map each element using a mapping function, then flat the result into
 * a new array.
 * @param {Array.<*>}originalArray
 * @param {Function}fn
 */
function flatMap(originalArray, fn) {
  /* eslint-disable @typescript-eslint/unbound-method */
  if (typeof Array.prototype.flatMap === "function") {
    return originalArray.flatMap(fn);
  }
  /* eslint-enable @typescript-eslint/unbound-method */
  return originalArray.reduce(function (acc, arg) {
    var r = fn(arg);
    if (Array.isArray(r)) {
      acc.push.apply(acc, r);
      return acc;
    }
    acc.push(r);
    return acc;
  }, []);
}

/***/ }),

/***/ 7021:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: function() { return /* binding */ getFuzzedDelay; }
/* harmony export */ });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var FUZZ_FACTOR = 0.3;
/**
 * Perform "fuzzing" on the delay given.
 * @param {Number} retryDelay
 * @returns {Number}
 */
function getFuzzedDelay(retryDelay) {
  var fuzzingFactor = (Math.random() * 2 - 1) * FUZZ_FACTOR;
  return retryDelay * (fuzzingFactor + 1); // Max 1.3 Min 0.7
}

/***/ }),

/***/ 8795:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: function() { return /* binding */ idGenerator; }
/* harmony export */ });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* eslint-disable @typescript-eslint/no-unsafe-member-access */
/**
 * Creates an ID generator which generates a number containing an incremented
 * number each time you call it.
 * @returns {Function}
 */
function idGenerator() {
  var prefix = "";
  var currId = -1;
  return function generateNewId() {
    currId++;
    if (currId >= Number.MAX_SAFE_INTEGER) {
      prefix += "0";
      currId = 0;
    }
    return prefix + String(currId);
  };
}

/***/ }),

/***/ 2384:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: function() { return /* binding */ isNonEmptyString; }
/* harmony export */ });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @param {*} x
 * @returns {string}
 */
function isNonEmptyString(x) {
  return typeof x === "string" && x.length > 0;
}

/***/ }),

/***/ 6787:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: function() { return /* binding */ isNullOrUndefined; }
/* harmony export */ });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Returns true if the argument given is either null or undefined.
 * This function was added to have a clearer alternative to `== null` which is
 * not always understood by newcomers to the code, and which can be overused when
 * only one of the possibility can arise.
 * @param {*} x
 * @returns {boolean}
 */
function isNullOrUndefined(x) {
  return x === null || x === undefined;
}

/***/ }),

/***/ 8202:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _normalize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4971);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ __webpack_exports__.Ay = (_normalize__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay);


/***/ }),

/***/ 4971:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Ay: function() { return /* binding */ normalize; },
  BU: function() { return /* binding */ normalizeAudioTrack; },
  E4: function() { return /* binding */ normalizeTextTrack; }
});

// EXTERNAL MODULE: ./src/utils/is_non_empty_string.ts
var is_non_empty_string = __webpack_require__(2384);
// EXTERNAL MODULE: ./src/utils/is_null_or_undefined.ts
var is_null_or_undefined = __webpack_require__(6787);
;// CONCATENATED MODULE: ./src/utils/languages/ISO_639-1_to_ISO_639-3.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Translate ISO 639-1 language codes into ISO 639-3 ones.
 */
var ISO_MAP_1_TO_3 = {
  aa: "aar",
  // Afar
  ab: "abk",
  // Abkhazian
  ae: "ave",
  // Avestan
  af: "afr",
  // Afrikaans
  ak: "aka",
  // Akan
  am: "amh",
  // Amharic
  an: "arg",
  // Aragonese
  ar: "ara",
  // Arabic
  as: "asm",
  // Assamese
  av: "ava",
  // Avaric
  ay: "aym",
  // Aymara
  az: "aze",
  // Azerbaijani
  ba: "bak",
  // Bashkir
  be: "bel",
  // Belarusian
  bg: "bul",
  // Bulgarian
  bi: "bis",
  // Bislama
  bm: "bam",
  // Bambara
  bn: "ben",
  // Bengali
  bo: "bod",
  // Tibetan
  br: "bre",
  // Breton
  bs: "bos",
  // Bosnian
  ca: "cat",
  // Catalan, Valencian
  ce: "che",
  // Chechen
  ch: "cha",
  // Chamorro
  co: "cos",
  // Corsican
  cr: "cre",
  // Cree
  cs: "ces",
  // Czech
  cu: "chu",
  // Church Slavic, Church Slavonic, Old Church Slavonic,
  // Old Slavonic, Old Bulgarian
  cv: "chv",
  // Chuvash
  cy: "cym",
  // Welsh
  da: "dan",
  // Danish
  de: "deu",
  // German
  dv: "div",
  // Divehi, Dhivehi, Maldivian
  dz: "dzo",
  // Dzongkha
  ee: "ewe",
  // Ewe
  el: "ell",
  // Greek (modern)
  en: "eng",
  // English
  eo: "epo",
  // Esperanto
  es: "spa",
  // Spanish, Castilian
  et: "est",
  // Estonian
  eu: "eus",
  // Basque
  fa: "fas",
  // Persian
  ff: "ful",
  // Fulah
  fi: "fin",
  // Finnish
  fj: "fij",
  // Fijian
  fo: "fao",
  // Faroese
  fr: "fra",
  // French
  fy: "fry",
  // Western Frisian
  ga: "gle",
  // Irish
  gd: "gla",
  // Gaelic, Scottish Gaelic
  gl: "glg",
  // Galician
  gn: "grn",
  // Guaran
  gu: "guj",
  // Gujarati
  gv: "glv",
  // Manx
  ha: "hau",
  // Hausa
  he: "heb",
  // Hebrew (modern)
  hi: "hin",
  // Hindi
  ho: "hmo",
  // Hiri Motu
  hr: "hrv",
  // Croatian
  ht: "hat",
  // Haitian, Haitian Creole
  hu: "hun",
  // Hungarian
  hy: "hye",
  // Armenian
  hz: "her",
  // Herero
  ia: "ina",
  // Interlingua
  id: "ind",
  // Indonesian
  ie: "ile",
  // Interlingue
  ig: "ibo",
  // Igbo
  ii: "iii",
  // Sichuan Yi, Nuosu
  ik: "ipk",
  // Inupiaq
  io: "ido",
  // Ido
  is: "isl",
  // Icelandic
  it: "ita",
  // Italian
  iu: "iku",
  // Inuktitut
  ja: "jpn",
  // Japanese
  jv: "jav",
  // Javanese
  ka: "kat",
  // Georgian
  kg: "kon",
  // Kongo
  ki: "kik",
  // Kikuyu, Gikuyu
  kj: "kua",
  // Kuanyama, Kwanyama
  kk: "kaz",
  // Kazakh
  kl: "kal",
  // Kalaallisut, Greenlandic
  km: "khm",
  // Central Khmer
  kn: "kan",
  // Kannada
  ko: "kor",
  // Korean
  kr: "kau",
  // Kanuri
  ks: "kas",
  // Kashmiri
  ku: "kur",
  // Kurdish
  kv: "kom",
  // Komi
  kw: "cor",
  // Cornish
  ky: "kir",
  // Kirghiz, Kyrgyz
  la: "lat",
  // Latin
  lb: "ltz",
  // Luxembourgish, Letzeburgesch
  lg: "lug",
  // Ganda
  li: "lim",
  // Limburgan, Limburger, Limburgish
  ln: "lin",
  // Lingala
  lo: "lao",
  // Lao
  lt: "lit",
  // Lithuanian
  lu: "lub",
  // Luba-Katanga
  lv: "lav",
  // Latvian
  mg: "mlg",
  // Malagasy
  mh: "mah",
  // Marshallese
  mi: "mri",
  // Maori
  mk: "mkd",
  // Macedonian
  ml: "mal",
  // Malayalam
  mn: "mon",
  // Mongolian
  mr: "mar",
  // Marathi
  ms: "msa",
  // Malay
  mt: "mlt",
  // Maltese
  my: "mya",
  // Burmese
  na: "nau",
  // Nauru
  nb: "nob",
  // Norwegian Bokml
  nd: "nde",
  // North Ndebele
  ne: "nep",
  // Nepali
  ng: "ndo",
  // Ndonga
  nl: "nld",
  // Dutch, Flemish
  nn: "nno",
  // Norwegian Nynorsk
  no: "nor",
  // Norwegian
  nr: "nbl",
  // South Ndebele
  nv: "nav",
  // Navajo, Navaho
  ny: "nya",
  // Chichewa, Chewa, Nyanja
  oc: "oci",
  // Occitan
  oj: "oji",
  // Ojibwa
  om: "orm",
  // Oromo
  or: "ori",
  // Oriya
  os: "oss",
  // Ossetian, Ossetic
  pa: "pan",
  // Panjabi, Punjabi
  pi: "pli",
  // Pali
  pl: "pol",
  // Polish
  ps: "pus",
  // Pashto, Pushto
  pt: "por",
  // Portuguese
  qu: "que",
  // Quechua
  rm: "roh",
  // Romansh
  rn: "run",
  // Rundi
  ro: "ron",
  // Romanian, Moldavian, Moldovan
  ru: "rus",
  // Russian
  rw: "kin",
  // Kinyarwanda
  sa: "san",
  // Sanskrit
  sc: "srd",
  // Sardinian
  sd: "snd",
  // Sindhi
  se: "sme",
  // Northern Sami
  sg: "sag",
  // Sango
  si: "sin",
  // Sinhala, Sinhalese
  sk: "slk",
  // Slovak
  sl: "slv",
  // Slovenian
  sm: "smo",
  // Samoan
  sn: "sna",
  // Shona
  so: "som",
  // Somali
  sq: "sqi",
  // Albanian
  sr: "srp",
  // Serbian
  ss: "ssw",
  // Swati
  st: "sot",
  // Southern Sotho
  su: "sun",
  // Sundanese
  sv: "swe",
  // Swedish
  sw: "swa",
  // Swahili
  ta: "tam",
  // Tamil
  te: "tel",
  // Telugu
  tg: "tgk",
  // Tajik
  th: "tha",
  // Thai
  ti: "tir",
  // Tigrinya
  tk: "tuk",
  // Turkmen
  tl: "tgl",
  // Tagalog
  tn: "tsn",
  // Tswana
  to: "ton",
  // Tonga (Tonga Islands)
  tr: "tur",
  // Turkish
  ts: "tso",
  // Tsonga
  tt: "tat",
  // Tatar
  tw: "twi",
  // Twi
  ty: "tah",
  // Tahitian
  ug: "uig",
  // Uighur, Uyghur
  uk: "ukr",
  // Ukrainian
  ur: "urd",
  // Urdu
  uz: "uzb",
  // Uzbek
  ve: "ven",
  // Venda
  vi: "vie",
  // Vietnamese
  vo: "vol",
  // Volapk
  wa: "wln",
  // Walloon
  wo: "wol",
  // Wolof
  xh: "xho",
  // Xhosa
  yi: "yid",
  // Yiddish
  yo: "yor",
  // Yoruba
  za: "zha",
  // Zhuang, Chuang
  zh: "zho",
  // Chinese
  zu: "zul" // Zulu
};
/* harmony default export */ var ISO_639_1_to_ISO_639_3 = (ISO_MAP_1_TO_3);
;// CONCATENATED MODULE: ./src/utils/languages/ISO_639-2_to_ISO_639-3.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Translate ISO 639-2 synonyms to their ISO 639-3 counterparts.
 */
var ISO_MAP_2_TO_3 = {
  alb: "sqi",
  // Albanian
  arm: "hye",
  // Armenian
  baq: "eus",
  // Basque
  bur: "mya",
  // Burmese
  chi: "zho",
  // Chinese
  cze: "ces",
  // Czech
  dut: "nld",
  // Dutch; Flemish
  fre: "fra",
  // French
  geo: "kat",
  // Georgian
  ger: "deu",
  // German
  gre: "ell",
  // Modern Greek (1453)
  ice: "isl",
  // Icelandic
  mac: "mkd",
  // Macedonian
  mao: "mri",
  // Maori
  may: "msa",
  // Malay
  per: "fas",
  // Persian
  slo: "slk",
  // Slovak
  rum: "ron",
  // Moldovan
  tib: "bod",
  // Tibetan
  wel: "cym" // Welsh
};
/* harmony default export */ var ISO_639_2_to_ISO_639_3 = (ISO_MAP_2_TO_3);
;// CONCATENATED MODULE: ./src/utils/languages/normalize.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Normalize language given.
 * Basically:
 *   - converts it to lowercase.
 *   - normalize "base" (what is before the possible first "-") to an ISO639-3
 *     compatible string.
 * @param {string} _language
 * @returns {string}
 */
function normalizeLanguage(_language) {
  if ((0,is_null_or_undefined/* default */.A)(_language) || _language === "") {
    /**
     * "und" is a special value in ISO 639-3 that stands for "undetermined language".
     */
    return "und";
  }
  var fields = ("" + _language).toLowerCase().split("-");
  var base = fields[0];
  var normalizedBase = normalizeBase(base);
  if ((0,is_non_empty_string/* default */.A)(normalizedBase)) {
    return normalizedBase;
  }
  return _language;
}
/**
 * Normalize language into an ISO639-3 format.
 * Returns undefined if it failed to do so
 * @param {string} base
 * @returns {string}
 */
function normalizeBase(base) {
  var result;
  switch (base.length) {
    case 2:
      result = ISO_639_1_to_ISO_639_3[base];
      break;
    case 3:
      result = ISO_639_2_to_ISO_639_3[base];
      break;
  }
  return result;
}
/**
 * Normalize text track from a user given input into an object
 * with three properties:
 *   - language {string}: The language the user gave us
 *   - normalized {string}: An attempt to normalize the language into an
 *     ISO 639-3 code
 *   - closedCaption {Boolean}: Whether the track is a closed caption track
 * @param {Object|string|null|undefined} _language
 * @returns {Object|null|undefined}
 */
function normalizeTextTrack(_language) {
  if (!(0,is_null_or_undefined/* default */.A)(_language)) {
    var language;
    var closedCaption = false;
    if (typeof _language === "string") {
      language = _language;
    } else {
      language = _language.language;
      if (_language.closedCaption === true) {
        closedCaption = true;
      }
    }
    return {
      language: language,
      closedCaption: closedCaption,
      normalized: normalizeLanguage(language)
    };
  }
  return _language;
}
/**
 * Normalize audio track from a user given input into an object
 * with the following properties:
 *   - language {string}: The language the user gave us
 *   - normalized {string}: An attempt to normalize the language into an
 *     ISO 639-3 code
 *   - audioDescription {Boolean}: Whether the track is a closed caption track
 *   - isDub {Boolean|undefined}: if true, this is a dub.
 * @param {Object|string|null|undefined} _language
 * @returns {Object|null|undefined}
 */
function normalizeAudioTrack(_language) {
  if ((0,is_null_or_undefined/* default */.A)(_language)) {
    return _language;
  }
  if (typeof _language === "string") {
    return {
      language: _language,
      audioDescription: false,
      normalized: normalizeLanguage(_language)
    };
  }
  var normalized = {
    language: _language.language,
    audioDescription: _language.audioDescription === true,
    normalized: normalizeLanguage(normalizeLanguage(_language.language))
  };
  if (_language.isDub === true) {
    normalized.isDub = true;
  }
  return normalized;
}
/* harmony default export */ var normalize = (normalizeLanguage);


/***/ }),

/***/ 8060:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Do nothing (but do it well).
 *
 * Having this definition here allow to use the same reference each time a noop
 * is needed.
 * Also, it allows to avoid telling eslint to ignore empty blocks everywhere.
 */
/* eslint-disable no-empty,@typescript-eslint/no-empty-function */
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {}
/* eslint-enable no-empty, @typescript-eslint/no-empty-function */

/***/ }),

/***/ 8935:
/***/ (function(__unused_webpack_module, __webpack_exports__) {

"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function objectAssign(target) {
  if (target === null || target === undefined) {
    throw new TypeError("Cannot convert undefined or null to object");
  }
  // eslint-disable-next-line  @typescript-eslint/no-unsafe-assignment
  var to = Object(target);
  for (var i = 0; i < (arguments.length <= 1 ? 0 : arguments.length - 1); i++) {
    var source = i + 1 < 1 || arguments.length <= i + 1 ? undefined : arguments[i + 1];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        /* eslint-disable @typescript-eslint/no-unsafe-member-access */
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion
        to[key] = source[key];
        /* eslint-enable @typescript-eslint/no-unsafe-member-access */
      }
    }
  }
  return to;
}
// eslint-disable-next-line @typescript-eslint/unbound-method, no-restricted-properties
/* harmony default export */ __webpack_exports__.A = (typeof Object.assign === "function" ?
// eslint-disable-next-line no-restricted-properties
Object.assign :
// eslint-disable-next-line  @typescript-eslint/unbound-method
objectAssign);

/***/ }),

/***/ 4324:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export objectValues */
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @param {Object|Array} o
 * @returns {Array.<*>}
 */
function objectValues(o) {
  return Object.keys(o).map(function (k) {
    return o[k];
  });
}
// eslint-disable-next-line  @typescript-eslint/unbound-method, no-restricted-properties
/* harmony default export */ __webpack_exports__.A = (typeof Object.values === "function" ? Object.values : objectValues);


/***/ }),

/***/ 3650:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   C$: function() { return /* binding */ insertInto; },
/* harmony export */   D3: function() { return /* binding */ getPlayedSizeOfRange; },
/* harmony export */   Hh: function() { return /* binding */ isTimeInRanges; },
/* harmony export */   Nn: function() { return /* binding */ convertToRanges; },
/* harmony export */   OT: function() { return /* binding */ getInnerAndOuterTimeRanges; },
/* harmony export */   Td: function() { return /* binding */ getNextRangeGap; },
/* harmony export */   UL: function() { return /* binding */ getSizeOfRange; },
/* harmony export */   aW: function() { return /* binding */ keepRangeIntersection; },
/* harmony export */   bo: function() { return /* binding */ excludeFromRanges; },
/* harmony export */   eO: function() { return /* binding */ getRange; },
/* harmony export */   gV: function() { return /* binding */ isTimeInRange; },
/* harmony export */   vK: function() { return /* binding */ getLeftSizeOfRange; }
/* harmony export */ });
/* unused harmony exports isAfter, isBefore, isTimeInTimeRanges, mergeContiguousRanges, removeEmptyRanges */
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * This file contains functions helping with TimeRanges management.
 *
 * For simplicity/performance reasons, many of those work with a simplified
 * "Range" object, which is an object with two keys:
 *   - start {Number}
 *   - end {Number}
 *
 * Those two corresponds to what is returned by the start and end methods of a
 * TimeRanges Object.
 *
 * You can convert from TimeRanges to Range object(s) with the getRange/
 * convertToRanges methods.
 */
// Factor for rounding errors
var EPSILON = 1 / 60;
/**
 * Check equality with a tolerance of EPSILON.
 * Used for various functions with this sort of tolerance regarding the
 * start/end of contiguous ranges.
 * @param {Number} a
 * @param {Number} b
 * @returns {Boolean}
 */
function nearlyEqual(a, b) {
  return Math.abs(a - b) < EPSILON;
}
/**
 * Construct a new range which will have, as start/end, the min/max
 * of both the range given, and the given bitrate.
 * @param {Object} range1
 * @param {Object} range2
 * @returns {Object}
 */
function createRangeUnion(range1, range2) {
  var start = Math.min(range1.start, range2.start);
  var end = Math.max(range1.end, range2.end);
  return {
    start: start,
    end: end
  };
}
/**
 * Clean array ranges from "empty" ranges.
 * That is, range objects which have their start equal to their end.
 * /!\ Mutate the array of ranges.
 * @param {Array<Object>} ranges
 * @returns {Array<Object>}
 */
function removeEmptyRanges(ranges) {
  for (var index = 0; index < ranges.length; index++) {
    var range = ranges[index];
    if (range.start === range.end) {
      ranges.splice(index--, 1);
    }
  }
  return ranges;
}
/**
 * /!\ Mutate the array of ranges.
 * @param {Array<Object>} ranges
 * @returns {Array<Object>}
 */
function mergeContiguousRanges(ranges) {
  for (var index = 1; index < ranges.length; index++) {
    var prevRange = ranges[index - 1];
    var currRange = ranges[index];
    if (areRangesNearlyContiguous(prevRange, currRange)) {
      var unionRange = createRangeUnion(prevRange, currRange);
      ranges.splice(--index, 2, unionRange);
    }
  }
  return ranges;
}
/**
 * True if range1 is considered _after_ range2.
 * @param {Object} range1
 * @param {Object} range2
 * @returns {Boolean}
 */
function isAfter(range1, range2) {
  return range1.start >= range2.end;
}
/**
 * True if range1 is considered _before_ range2.
 * @param {Object} range1
 * @param {Object} range2
 * @returns {Boolean}
 */
function isBefore(range1, range2) {
  return range1.end <= range2.start;
}
/**
 * Returns true if the time given can be considered as part of any of the given
 * ranges.
 * @param {Array.<Object>} ranges
 * @param {number} time
 * @returns {boolean}
 */
function isTimeInRanges(ranges, time) {
  for (var i = 0; i < ranges.length; i++) {
    if (isTimeInRange(ranges[i], time)) {
      return true;
    }
  }
  return false;
}
/**
 * Returns true if the time given can be considered as part of the given range.
 * @param {Object} range1
 * @param {Number} Time
 * @returns {Boolean}
 */
function isTimeInRange(_ref, time) {
  var start = _ref.start,
    end = _ref.end;
  return start <= time && time < end;
}
/**
 * Returns true if the two ranges given are overlapping.
 * @param {Object} range1
 * @param {Object} range2
 * @returns {Boolean}
 */
function areRangesOverlapping(range1, range2) {
  return isTimeInRange(range1, range2.start) || range1.start < range2.end && range2.end < range1.end || isTimeInRange(range2, range1.start);
}
/**
 * Returns true if the two ranges given can be considered contiguous.
 * @param {Object} range1
 * @param {Object} range2
 * @returns {Boolean}
 */
function areRangesNearlyContiguous(range1, range2) {
  return nearlyEqual(range2.start, range1.end) || nearlyEqual(range2.end, range1.start);
}
/**
 * Convert from a TimeRanges object to an array of Ranges.
 * @param {TimeRanges} timeRanges
 * @returns {Array.<Object>}
 */
function convertToRanges(timeRanges) {
  var ranges = [];
  for (var i = 0; i < timeRanges.length; i++) {
    ranges.push({
      start: timeRanges.start(i),
      end: timeRanges.end(i)
    });
  }
  return ranges;
}
/**
 * Get range object of a specific time in a TimeRanges object.
 * @param {TimeRanges} timeRanges
 * @returns {Object}
 */
function getRange(timeRanges, time) {
  for (var i = timeRanges.length - 1; i >= 0; i--) {
    var start = timeRanges.start(i);
    if (time >= start) {
      var end = timeRanges.end(i);
      if (time < end) {
        return {
          start: start,
          end: end
        };
      }
    }
  }
  return null;
}
/**
 * Get gap from a specific time until the start of the next Range.
 * @param {TimeRanges} timeRanges
 * @param {Number} time
 * @returns {Number}
 */
function getNextRangeGap(timeRanges, time) {
  var len = timeRanges.length;
  for (var i = 0; i < len; i++) {
    var start = timeRanges.start(i);
    if (time < start) {
      return start - time;
    }
  }
  return Infinity;
}
/**
 * @param {TimeRanges} timeRanges
 * @param {Number} time
 * @returns {Object} - Object with two properties:
 *   - outerRanges {Array.<Object>}: every ranges which does not contain the
 *     given time.
 *   - innerRange {Object|null}: the range which contain the given time.
 */
function getInnerAndOuterTimeRanges(timeRanges, time) {
  var innerRange = null;
  var outerRanges = [];
  for (var i = 0; i < timeRanges.length; i++) {
    var start = timeRanges.start(i);
    var end = timeRanges.end(i);
    if (time < start || time >= end) {
      outerRanges.push({
        start: start,
        end: end
      });
    } else {
      innerRange = {
        start: start,
        end: end
      };
    }
  }
  return {
    outerRanges: outerRanges,
    innerRange: innerRange
  };
}
/**
 * Get "size" (difference between end and start) of the range containing the
 * given time. 0 if the range is not found.
 * @param {TimeRanges} timeRanges
 * @param {Number} currentTime
 * @returns {Number}
 */
function getSizeOfRange(timeRanges, currentTime) {
  var range = getRange(timeRanges, currentTime);
  return range !== null ? range.end - range.start : 0;
}
/**
 * Get "currently played" (difference between time given and start) of the
 * range containing the given time. 0 if the range is not found.
 * @param {TimeRanges} timeRanges
 * @param {Number} currentTime
 * @returns {Number}
 */
function getPlayedSizeOfRange(timeRanges, currentTime) {
  var range = getRange(timeRanges, currentTime);
  return range !== null ? currentTime - range.start : 0;
}
/**
 * Get "left to play" (difference between end and time given) of the range
 * containing the given time. Infinity if the range is not found.
 * @param {TimeRanges} timeRanges
 * @param {Number} currentTime
 * @returns {Number}
 */
function getLeftSizeOfRange(timeRanges, currentTime) {
  var range = getRange(timeRanges, currentTime);
  return range !== null ? range.end - currentTime : Infinity;
}
/**
 * Insert a range object into an array of ranges objects, at the right place.
 * /!\ Mutate the array of ranges.
 * @param {Array.<Object>} ranges
 * @param {Object} rangeToAddArg
 * @returns {Array.<Object>}
 */
function insertInto(ranges, rangeToAddArg) {
  if (rangeToAddArg.start === rangeToAddArg.end) {
    return ranges;
  }
  var rangeToAdd = rangeToAddArg;
  // For each present range check if we need to:
  // - In case we are overlapping or contiguous:
  //   - if added range has the same bitrate as the overlapped or
  //     contiguous one, we can merge themcurrentRange
  //   - if added range has a different bitrate we need to insert it
  //     in place
  // - Need to insert in place, we we are completely, not overlapping
  //   and not contiguous in between two ranges.
  var index = 0;
  for (; index < ranges.length; index++) {
    var range = ranges[index];
    var overlapping = areRangesOverlapping(rangeToAdd, range);
    var contiguous = areRangesNearlyContiguous(rangeToAdd, range);
    // We assume ranges are ordered and two ranges can not be
    // completely overlapping.
    if (overlapping || contiguous) {
      rangeToAdd = createRangeUnion(rangeToAdd, range);
      ranges.splice(index--, 1);
    } else {
      // Check the case for which there is no more to do
      if (index === 0) {
        if (isBefore(rangeToAdd, ranges[0])) {
          // First index, and we are completely before that range (and
          // not contiguous, nor overlapping). We just need to be
          // inserted here.
          break;
        }
      } else {
        if (isBefore(ranges[index - 1], rangeToAdd) && isBefore(rangeToAdd, range)) {
          // We are exactly after the current previous range, and
          // before the current range, while not overlapping with none
          // of them. Insert here.
          break;
        }
      }
    }
  }
  // Now that we are sure we don't overlap with any range, just add it.
  ranges.splice(index, 0, rangeToAdd);
  return mergeContiguousRanges(removeEmptyRanges(ranges));
}
/**
 * Returns range, from a range objects array overlapping with a range given
 * in argument. null if none is found.
 * @param {Object} range
 * @param {Array.<Object>} ranges
 * @returns {Array.<Object>}
 */
function findOverlappingRanges(range, ranges) {
  var resultingRanges = [];
  for (var i = 0; i < ranges.length; i++) {
    if (areRangesOverlapping(range, ranges[i])) {
      resultingRanges.push(ranges[i]);
    }
  }
  return resultingRanges;
}
/**
 * Returns only the intersection between the two ranges, from the first
 * ranges argument given.
 * @param {Array.<Range>} ranges1
 * @param {Array.<Range>} ranges2
 * @returns {Array.<Range>}
 */
function keepRangeIntersection(ranges1, ranges2) {
  var result = [];
  for (var i = 0; i < ranges1.length; i++) {
    var range = ranges1[i];
    var overlappingRanges = findOverlappingRanges(range, ranges2);
    if (overlappingRanges.length > 0) {
      for (var j = 0; j < overlappingRanges.length; j++) {
        var overlappingRange = overlappingRanges[j];
        result.push({
          start: Math.max(range.start, overlappingRange.start),
          end: Math.min(range.end, overlappingRange.end)
        });
      }
    }
  }
  return result;
}
/**
 * Exclude from the `baseRanges` everything that is in `rangesToExclude`.
 * Example:
 *
 * Let's say we have the following base ranges:
 *       |==========|        |===============| |======|    |==========|
 *
 * From which we want to "exclude" the following ranges:
 *          |=========| |==|        |===|  |=====|
 *
 * We will obtain the first ranges from which we remove the second ranges:
 * -----------------------------------------------------------------------
 *       |==========|        |===============| |======|    |==========|
 *          |=========| |==|        |===|  |=====|
 * _______________________________________________________________________
 *                                     |
 *                                     |
 *                                     V
 * -----------------------------------------------------------------------
 *       |==|                |======|   |==|     |====|    |==========|
 * -----------------------------------------------------------------------
 *
 * @param {Array.<Object} baseRanges
 * @param {Array.<Object} rangesToExclude
 * @return {Array.<Object>}
 */
function excludeFromRanges(baseRanges, rangesToExclude) {
  var result = [];
  // For every range in `baseRanges`, find overlapping ranges with
  // `rangesToExclude` and remove them.
  for (var i = 0; i < baseRanges.length; i++) {
    var range = baseRanges[i];
    var intersections = [];
    var overlappingRanges = findOverlappingRanges(range, rangesToExclude);
    if (overlappingRanges.length > 0) {
      for (var j = 0; j < overlappingRanges.length; j++) {
        var overlappingRange = overlappingRanges[j];
        intersections.push({
          start: Math.max(range.start, overlappingRange.start),
          end: Math.min(range.end, overlappingRange.end)
        });
      }
    }
    if (intersections.length === 0) {
      result.push(range);
    } else {
      var lastStart = range.start;
      for (var _j = 0; _j < intersections.length; _j++) {
        if (intersections[_j].start > lastStart) {
          result.push({
            start: lastStart,
            end: intersections[_j].start
          });
        }
        lastStart = intersections[_j].end;
      }
      if (lastStart < range.end) {
        result.push({
          start: lastStart,
          end: range.end
        });
      }
    }
  }
  return result;
}
/**
 * Returns `true` if the given `time` is available in the TimeRanges object
 * given.
 * Returns `false` otherwise.
 * @param {TimeRanges} ranges
 * @param {Number} time
 * @returns {boolean}
 */
function isTimeInTimeRanges(ranges, time) {
  for (var i = 0; i < ranges.length; i++) {
    if (ranges.start(i) <= time && time < ranges.end(i)) {
      return true;
    }
  }
  return false;
}


/***/ }),

/***/ 8315:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   D: function() { return /* binding */ createMappedReference; }
/* harmony export */ });
/* harmony import */ var _array_find_index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3786);
/* harmony import */ var _noop__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8060);
function _createForOfIteratorHelperLoose(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (t) return (t = t.call(r)).next.bind(t); if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var o = 0; return function () { return o >= r.length ? { done: !0 } : { done: !1, value: r[o++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * A value behind a shared reference, meaning that any update to its value from
 * anywhere can be retrieved from any other parts of the code in possession of
 * the same `SharedReference`.
 *
 * @example
 * ```ts
 * const myVal = 1;
 * const myRef : SharedReference<number> = new SharedReference(1);
 *
 * function setValTo2(num : number) {
 *   num = 2;
 * }
 *
 * function setRefTo2(num : SharedReference<number>) {
 *   num.setValue(2);
 * }
 *
 * setValTo2(myVal);
 * console.log(myVal); // output: 1
 *
 * myRef.onUpdate((val) => {
 *   console.log(val); // outputs first synchronously `1`, then `2`
 * }, { emitCurrentValue: true });
 *
 * setRefTo2(myRef);
 * console.log(myRef.getValue()); // output: 2
 *
 * myRef.listen((val) => {
 *   console.log(val); // outputs only `2`
 * }, { emitCurrentValue: true });
 * ```
 *
 * This type was added because we found that the usage of an explicit type for
 * those use cases makes the intent of the corresponding code clearer.
 */
var SharedReference = /*#__PURE__*/function () {
  /**
   * Create a `SharedReference` object encapsulating the mutable `initialValue`
   * value of type T.
   * @param {*} initialValue
   * @param {Object|undefined} [cancelSignal] - If set, the created shared
   * reference will be automatically "finished" once that signal emits.
   * Finished references won't be able to update their value anymore, and will
   * also automatically have their listeners (callbacks linked to value change)
   * removed - as they cannot be triggered anymore, thus providing a security
   * against memory leaks.
   */
  function SharedReference(initialValue, cancelSignal) {
    var _this = this;
    this._value = initialValue;
    this._listeners = [];
    this._isFinished = false;
    this._onFinishCbs = [];
    if (cancelSignal !== undefined) {
      this._deregisterCancellation = cancelSignal.register(function () {
        return _this.finish();
      });
    }
  }
  /**
   * Returns the current value of this shared reference.
   * @returns {*}
   */
  var _proto = SharedReference.prototype;
  _proto.getValue = function getValue() {
    return this._value;
  }
  /**
   * Update the value of this shared reference.
   * @param {*} newVal
   */;
  _proto.setValue = function setValue(newVal) {
    if (this._isFinished) {
      if (false) {}
      return;
    }
    this._value = newVal;
    if (this._listeners.length === 0) {
      return;
    }
    var clonedCbs = this._listeners.slice();
    for (var _iterator = _createForOfIteratorHelperLoose(clonedCbs), _step; !(_step = _iterator()).done;) {
      var cbObj = _step.value;
      try {
        if (!cbObj.hasBeenCleared) {
          cbObj.trigger(newVal, cbObj.complete);
        }
      } catch (_) {
        /* nothing */
      }
    }
  }
  /**
   * Update the value of this shared reference only if the value changed.
   *
   * Note that this function only performs a strict equality reference through
   * the "===" operator. Different objects that are structurally the same will
   * thus be considered different.
   * @param {*} newVal
   */;
  _proto.setValueIfChanged = function setValueIfChanged(newVal) {
    if (newVal !== this._value) {
      this.setValue(newVal);
    }
  }
  /**
   * Allows to register a callback to be called each time the value inside the
   * reference is updated.
   * @param {Function} cb - Callback to be called each time the reference is
   * updated. Takes as first argument its new value and in second argument a
   * callback allowing to unregister the callback.
   * @param {Object|undefined} [options]
   * @param {Object|undefined} [options.clearSignal] - Allows to provide a
   * CancellationSignal which will unregister the callback when it emits.
   * @param {boolean|undefined} [options.emitCurrentValue] - If `true`, the
   * callback will also be immediately called with the current value.
   */;
  _proto.onUpdate = function onUpdate(cb, options) {
    var _this2 = this;
    var unlisten = function unlisten() {
      if ((options === null || options === void 0 ? void 0 : options.clearSignal) !== undefined) {
        options.clearSignal.deregister(unlisten);
      }
      if (cbObj.hasBeenCleared) {
        return;
      }
      cbObj.hasBeenCleared = true;
      var indexOf = _this2._listeners.indexOf(cbObj);
      if (indexOf >= 0) {
        _this2._listeners.splice(indexOf, 1);
      }
    };
    var cbObj = {
      trigger: cb,
      complete: unlisten,
      hasBeenCleared: false
    };
    this._listeners.push(cbObj);
    if ((options === null || options === void 0 ? void 0 : options.emitCurrentValue) === true) {
      cb(this._value, unlisten);
    }
    if (this._isFinished || cbObj.hasBeenCleared) {
      unlisten();
      return;
    }
    if ((options === null || options === void 0 ? void 0 : options.clearSignal) === undefined) {
      return;
    }
    options.clearSignal.register(unlisten);
  }
  /**
   * Variant of `onUpdate` which will only call the callback once, once the
   * value inside the reference is different from `undefined`.
   * The callback is called synchronously if the value already isn't set to
   * `undefined`.
   *
   * This method can be used as a lighter weight alternative to `onUpdate` when
   * just waiting that the stored value becomes defined.
   * As such, it is an explicit equivalent to something like:
   * ```js
   * myReference.onUpdate((newVal, stopListening) => {
   *  if (newVal !== undefined) {
   *    stopListening();
   *
   *    // ... do the logic
   *  }
   * }, { emitCurrentValue: true });
   * ```
   * @param {Function} cb - Callback to be called each time the reference is
   * updated. Takes the new value in argument.
   * @param {Object | undefined} [options]
   * @param {Object | undefined} [options.clearSignal] - Allows to provide a
   * CancellationSignal which will unregister the callback when it emits.
   */;
  _proto.waitUntilDefined = function waitUntilDefined(cb, options) {
    var _this3 = this;
    this.onUpdate(function (val, stopListening) {
      if (val !== undefined) {
        stopListening();
        cb(_this3._value);
      }
    }, {
      clearSignal: options === null || options === void 0 ? void 0 : options.clearSignal,
      emitCurrentValue: true
    });
  }
  /**
   * Allows to register a callback for when the Shared Reference is "finished".
   *
   * This function is mostly there for implementing operators on the shared
   * reference and isn't meant to be used by regular code, hence it being
   * prefixed by `_`.
   * @param {Function} cb - Callback to be called once the reference is
   * finished.
   * @param {Object} onFinishCancelSignal - Allows to provide a
   * CancellationSignal which will unregister the callback when it emits.
   */;
  _proto._onFinished = function _onFinished(cb, onFinishCancelSignal) {
    var _this4 = this;
    if (onFinishCancelSignal.isCancelled()) {
      return _noop__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A;
    }
    var cleanUp = function cleanUp() {
      var indexOf = (0,_array_find_index__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(_this4._onFinishCbs, function (x) {
        return x.trigger === trigger;
      });
      if (indexOf >= 0) {
        _this4._onFinishCbs[indexOf].hasBeenCleared = true;
        _this4._onFinishCbs.splice(indexOf, 1);
      }
    };
    var trigger = function trigger() {
      cleanUp();
      cb();
    };
    var deregisterCancellation = onFinishCancelSignal.register(cleanUp);
    this._onFinishCbs.push({
      trigger: trigger,
      hasBeenCleared: false
    });
    return deregisterCancellation;
  }
  /**
   * Indicate that no new values will be emitted.
   * Allows to automatically free all listeners linked to this reference.
   */;
  _proto.finish = function finish() {
    if (this._deregisterCancellation !== undefined) {
      this._deregisterCancellation();
    }
    this._isFinished = true;
    var clonedCbs = this._listeners.slice();
    for (var _iterator2 = _createForOfIteratorHelperLoose(clonedCbs), _step2; !(_step2 = _iterator2()).done;) {
      var _cbObj = _step2.value;
      try {
        if (!_cbObj.hasBeenCleared) {
          _cbObj.complete();
          _cbObj.hasBeenCleared = true;
        }
      } catch (_) {
        /* nothing */
      }
    }
    this._listeners.length = 0;
    if (this._onFinishCbs.length > 0) {
      var clonedFinishedCbs = this._onFinishCbs.slice();
      for (var _iterator3 = _createForOfIteratorHelperLoose(clonedFinishedCbs), _step3; !(_step3 = _iterator3()).done;) {
        var cbObj = _step3.value;
        try {
          if (!cbObj.hasBeenCleared) {
            cbObj.trigger();
            cbObj.hasBeenCleared = true;
          }
        } catch (_) {
          /* nothing */
        }
      }
      this._onFinishCbs.length = 0;
    }
  };
  return SharedReference;
}();
/**
 * Create a new `SharedReference` based on another one by mapping over its
 * referenced value each time it is updated and finishing once it finishes.
 * @param {Object} originalRef - The Original `SharedReference` you wish to map
 * over.
 * @param {Function} mappingFn - The mapping function which will receives
 * `originalRef`'s value and outputs this new reference's value.
 * @param {Object} cancellationSignal - Optionally, a `CancellationSignal` which
 * will finish that reference when it emits.
 * @returns {Object} - The new, mapped, reference.
 */
function createMappedReference(originalRef, mappingFn, cancellationSignal) {
  var newRef = new SharedReference(mappingFn(originalRef.getValue()), cancellationSignal);
  originalRef.onUpdate(function mapOriginalReference(x) {
    newRef.setValue(mappingFn(x));
  }, {
    clearSignal: cancellationSignal
  });
  originalRef._onFinished(function () {
    newRef.finish();
  }, cancellationSignal);
  return newRef;
}
/* harmony default export */ __webpack_exports__.A = (SharedReference);

/***/ }),

/***/ 4389:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Ay: function() { return /* binding */ utils_request; }
});

// UNUSED EXPORTS: fetchIsSupported, fetchRequest, xhr

// EXTERNAL MODULE: ./src/errors/request_error.ts
var request_error = __webpack_require__(3506);
// EXTERNAL MODULE: ./src/utils/is_non_empty_string.ts
var is_non_empty_string = __webpack_require__(2384);
// EXTERNAL MODULE: ./src/utils/is_null_or_undefined.ts
var is_null_or_undefined = __webpack_require__(6787);
;// CONCATENATED MODULE: ./src/utils/request/xhr.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



var DEFAULT_RESPONSE_TYPE = "json";
function request(options) {
  var requestOptions = {
    url: options.url,
    headers: options.headers,
    responseType: (0,is_null_or_undefined/* default */.A)(options.responseType) ? DEFAULT_RESPONSE_TYPE : options.responseType,
    timeout: options.timeout
  };
  return new Promise(function (resolve, reject) {
    var onProgress = options.onProgress,
      cancelSignal = options.cancelSignal;
    var url = requestOptions.url,
      headers = requestOptions.headers,
      responseType = requestOptions.responseType,
      timeout = requestOptions.timeout;
    var xhr = new XMLHttpRequest();
    xhr.open("GET", url, true);
    var timeoutId;
    if (timeout !== undefined) {
      xhr.timeout = timeout;
      // We've seen on some browser (mainly on some LG TVs), that `xhr.timeout`
      // was either not supported or did not function properly despite the
      // browser being recent enough to support it.
      // That's why we also start a manual timeout. We do this a little later
      // than the "native one" performed on the xhr assuming that the latter
      // is more precise, it might also be more efficient.
      timeoutId = window.setTimeout(function () {
        clearCancellingProcess();
        reject(new request_error/* default */.A(url, xhr.status, "TIMEOUT", xhr));
      }, timeout + 3000);
    }
    xhr.responseType = responseType;
    if (xhr.responseType === "document") {
      xhr.overrideMimeType("text/xml");
    }
    if (!(0,is_null_or_undefined/* default */.A)(headers)) {
      var _headers = headers;
      for (var key in _headers) {
        if (_headers.hasOwnProperty(key)) {
          xhr.setRequestHeader(key, _headers[key]);
        }
      }
    }
    var sendingTime = performance.now();
    // Handle request cancellation
    var deregisterCancellationListener = null;
    if (cancelSignal !== undefined) {
      deregisterCancellationListener = cancelSignal.register(function abortRequest(err) {
        clearCancellingProcess();
        if (!(0,is_null_or_undefined/* default */.A)(xhr) && xhr.readyState !== 4) {
          xhr.abort();
        }
        reject(err);
      });
      if (cancelSignal.isCancelled()) {
        return;
      }
    }
    xhr.onerror = function onXHRError() {
      clearCancellingProcess();
      reject(new request_error/* default */.A(url, xhr.status, "ERROR_EVENT", xhr));
    };
    xhr.ontimeout = function onXHRTimeout() {
      clearCancellingProcess();
      reject(new request_error/* default */.A(url, xhr.status, "TIMEOUT", xhr));
    };
    if (onProgress !== undefined) {
      xhr.onprogress = function onXHRProgress(event) {
        var currentTime = performance.now();
        onProgress({
          url: url,
          duration: currentTime - sendingTime,
          sendingTime: sendingTime,
          currentTime: currentTime,
          size: event.loaded,
          totalSize: event.total
        });
      };
    }
    xhr.onload = function onXHRLoad(event) {
      if (xhr.readyState === 4) {
        clearCancellingProcess();
        if (xhr.status >= 200 && xhr.status < 300) {
          var receivedTime = performance.now();
          var totalSize = xhr.response instanceof ArrayBuffer ? xhr.response.byteLength : event.total;
          var status = xhr.status;
          var loadedResponseType = xhr.responseType;
          var _url = (0,is_non_empty_string/* default */.A)(xhr.responseURL) ? xhr.responseURL : url;
          var responseData;
          if (loadedResponseType === "json") {
            // IE bug where response is string with responseType json
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            responseData = typeof xhr.response === "object" ? xhr.response : toJSONForIE(xhr.responseText);
          } else {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            responseData = xhr.response;
          }
          if ((0,is_null_or_undefined/* default */.A)(responseData)) {
            reject(new request_error/* default */.A(url, xhr.status, "PARSE_ERROR", xhr));
            return;
          }
          resolve({
            status: status,
            url: _url,
            responseType: loadedResponseType,
            sendingTime: sendingTime,
            receivedTime: receivedTime,
            requestDuration: receivedTime - sendingTime,
            size: totalSize,
            responseData: responseData
          });
        } else {
          reject(new request_error/* default */.A(url, xhr.status, "ERROR_HTTP_CODE", xhr));
        }
      }
    };
    xhr.send();
    /**
     * Clear resources and timers created to handle cancellation and timeouts.
     */
    function clearCancellingProcess() {
      if (timeoutId !== undefined) {
        clearTimeout(timeoutId);
      }
      if (deregisterCancellationListener !== null) {
        deregisterCancellationListener();
      }
    }
  });
}
/**
 * @param {string} data
 * @returns {Object|null}
 */
function toJSONForIE(data) {
  try {
    return JSON.parse(data);
  } catch (e) {
    return null;
  }
}
;// CONCATENATED MODULE: ./src/utils/request/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/* harmony default export */ var utils_request = (request);


/***/ }),

/***/ 2716:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Cl: function() { return /* binding */ getFilenameIndexInUrl; }
/* harmony export */ });
/* unused harmony export resolveURL */
/* harmony import */ var _starts_with__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9828);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Scheme part of an url (e.g. "http://").
var schemeRe = /^(?:[a-z]+:)?\/\//i;
/**
 * Match the different components of an URL.
 *
 *     foo://example.com:8042/over/there?name=ferret#nose
       \_/   \______________/\_________/ \_________/ \__/
        |           |            |            |        |
      scheme     authority       path        query   fragment
 * 1st match is the scheme: (e.g. "foo://")
 * 2nd match is the authority (e.g "example.com:8042")
 * 3rd match is the path (e.g "/over/there")
 * 4th match is the query params (e.g "name=ferret")
 * 5th match is the fragment (e.g "nose")
 * */
var urlComponentRegex = /^(?:([^:\/?#]+):)?(?:\/\/([^\/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?$/;
/**
 * In a given URL, find the index at which the filename begins.
 * That is, this function finds the index of the last `/` character and returns
 * the index after it, returning the length of the whole URL if no `/` was found
 * after the scheme (i.e. in `http://`, the slashes are not considered).
 * @param {string} url
 * @returns {number}
 */
function getFilenameIndexInUrl(url) {
  var indexOfLastSlash = url.lastIndexOf("/");
  if (indexOfLastSlash < 0) {
    return url.length;
  }
  if (schemeRe.test(url)) {
    var firstSlashIndex = url.indexOf("/");
    if (firstSlashIndex >= 0 && indexOfLastSlash === firstSlashIndex + 1) {
      // The "/" detected is actually the one from the protocol part of the URL
      // ("https://")
      return url.length;
    }
  }
  var indexOfQuestionMark = url.indexOf("?");
  if (indexOfQuestionMark >= 0 && indexOfQuestionMark < indexOfLastSlash) {
    // There are query parameters. Let's ignore them and re-run the logic
    // without
    return getFilenameIndexInUrl(url.substring(0, indexOfQuestionMark));
  }
  return indexOfLastSlash + 1;
}
/**
 * Resolve the output URL from the baseURL and the relative reference as
 * specified by RFC 3986 section 5.
 * @param base
 * @param relative
 * @see https://datatracker.ietf.org/doc/html/rfc3986#section-5
 * @example base: http://example.com |relative: /b/c | output: http://example.com/b/c
 * @returns the resolved url
 */
function _resolveURL(base, relative) {
  var baseParts = parseURL(base);
  var relativeParts = parseURL(relative);
  if (relativeParts.scheme) {
    return formatURL(relativeParts);
  }
  var target = {
    scheme: baseParts.scheme,
    authority: baseParts.authority,
    path: "",
    query: relativeParts.query,
    fragment: relativeParts.fragment
  };
  if (relativeParts.authority) {
    target.authority = relativeParts.authority;
    target.path = removeDotSegment(relativeParts.path);
    return formatURL(target);
  }
  if (relativeParts.path === "") {
    target.path = baseParts.path;
    if (!relativeParts.query) {
      target.query = baseParts.query;
    }
  } else {
    if ((0,_starts_with__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(relativeParts.path, "/")) {
      // path is absolute
      target.path = removeDotSegment(relativeParts.path);
    } else {
      // path is relative
      target.path = removeDotSegment(mergePaths(baseParts, relativeParts.path));
    }
  }
  return formatURL(target);
}
/**
 * Cache to store already parsed URLs to avoid unnecessary computation when
 * parsing the same URL again.
 */
var parsedUrlCache = new Map();
/**
 * Sets the maximum number of entries allowed in the parsedUrlCache map.
 * This limit helps prevent excessive memory usage. The value is arbitrary.
 */
var MAX_URL_CACHE_ENTRIES = 200;
/**
 * Parses a URL into its components.
 * @param {string} url - The URL to parse.
 * @returns {IParsedURL} The parsed URL components.
 */
function parseURL(url) {
  var _a, _b, _c, _d, _e;
  if (parsedUrlCache.has(url)) {
    return parsedUrlCache.get(url);
  }
  var matches = url.match(urlComponentRegex);
  var parsed;
  if (matches === null) {
    parsed = {
      scheme: "",
      authority: "",
      path: "",
      query: "",
      fragment: ""
    };
  } else {
    parsed = {
      scheme: (_a = matches[1]) !== null && _a !== void 0 ? _a : "",
      authority: (_b = matches[2]) !== null && _b !== void 0 ? _b : "",
      path: (_c = matches[3]) !== null && _c !== void 0 ? _c : "",
      query: (_d = matches[4]) !== null && _d !== void 0 ? _d : "",
      fragment: (_e = matches[5]) !== null && _e !== void 0 ? _e : ""
    };
  }
  if (parsedUrlCache.size >= MAX_URL_CACHE_ENTRIES) {
    parsedUrlCache.clear();
  }
  parsedUrlCache.set(url, parsed);
  return parsed;
}
/**
 * Formats a parsed URL into a string.
 * @param {IParsedURL} parts - The parsed URL components.
 * @returns {string} The formatted URL string.
 */
function formatURL(parts) {
  var url = "";
  if (parts.scheme) {
    url += parts.scheme + ":";
  }
  if (parts.authority) {
    url += "//" + parts.authority;
  }
  url += parts.path;
  if (parts.query) {
    url += "?" + parts.query;
  }
  if (parts.fragment) {
    url += "#" + parts.fragment;
  }
  return url;
}
/**
 * Removes "." and ".." from the URL path, as described by the algorithm
 * in RFC 3986 Section 5.2.4. Remove Dot Segments
 * @param {string} path - The URL path
 * @see https://datatracker.ietf.org/doc/html/rfc3986#section-5.2.4
 * @returns The path with dot segments removed.
 * @example "/baz/booz/../biz" => "/baz/biz"
 */
function removeDotSegment(path) {
  var segments = path.split(/(?=\/)/);
  var output = [];
  for (var i = 0; i < segments.length; i++) {
    var segment = segments[i];
    if (segment === ".." || segment === "." || segment === "") {
      continue;
    }
    if (segment === "/..") {
      output.pop();
      // if it's last segment push a trailing "/"
      if (i === segments.length - 1) {
        output.push("/");
      }
      continue;
    }
    if (segment === "/.") {
      // if it's last segment push a trailing "/"
      if (i === segments.length - 1) {
        output.push("/");
      }
      continue;
    }
    output.push(segment);
  }
  return output.join("");
}
/**
 * Merges a base URL path with a relative URL path, as described by
 * the algorithm merge paths in RFC 3986 Section 5.2.3. Merge Paths
 * @param {IParsedURL} baseParts - The parsed base URL components.
 * @param {string} relativePath - The relative URL path.
 * @returns {string} The merged URL path.
 * @see https://datatracker.ietf.org/doc/html/rfc3986#section-5.2.3
 */
function mergePaths(baseParts, relativePath) {
  if (baseParts.authority && baseParts.path === "") {
    return "/" + relativePath;
  }
  var basePath = baseParts.path;
  return basePath.substring(0, basePath.lastIndexOf("/") + 1) + relativePath;
}
/**
 * Resolves multiple URL segments using the RFC 3986 URL resolution algorithm.
 *
 * This function takes a variable number of URL segments and resolves them
 * sequentially according to the RFC 3986 URL resolution algorithm.
 * First argument is the base URL.
 * Empty string arguments are ignored.
 *
 * @param {...(string|undefined)} args - The URL segments to resolve.
 * @returns {string} The resolved URL as a string.
 */
function resolveURL() {
  var _a, _b, _c;
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  var filteredArgs = args.filter(function (val) {
    return val !== "";
  });
  var len = filteredArgs.length;
  if (len === 0) {
    return "";
  }
  if (len === 1) {
    return (_a = filteredArgs[0]) !== null && _a !== void 0 ? _a : "";
  } else {
    var basePart = (_b = filteredArgs[0]) !== null && _b !== void 0 ? _b : "";
    var relativeParts = (_c = filteredArgs[1]) !== null && _c !== void 0 ? _c : "";
    var resolvedURL = _resolveURL(basePart, relativeParts);
    var remainingArgs = filteredArgs.slice(2);
    return resolveURL.apply(void 0, [resolvedURL].concat(remainingArgs));
  }
}

/* harmony default export */ __webpack_exports__.Ay = (resolveURL);

/***/ }),

/***/ 8801:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: function() { return /* binding */ sleep; }
/* harmony export */ });
/**
 * Convert a setTimeout to a Promise.
 *
 * You can use it to have a much more readable blocking code with async/await
 * in some asynchronous tests.
 *
 * @param {number} timeInMs
 * @returns {Promise}
 */
function sleep(timeInMs) {
  return new Promise(function (res) {
    setTimeout(res, timeInMs);
  });
}

/***/ }),

/***/ 7296:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: function() { return /* binding */ SortedList; }
/* harmony export */ });
/* harmony import */ var _array_find__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1729);
/* harmony import */ var _array_includes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4031);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Creates an Array automatically sorted with the sorting function given to the
 * constructor when the add method is called.
 *
 * @example
 * ```js
 * const sortedList = new SortedList((a, b) => a.start - b.start);
 * const element1 = { start: 20 };
 * const element2 = { start: 10 };
 * const element3 = { start: 15 };
 *
 * sortedList.add(element1, element2);
 * console.log(sortedList.unwrap());
 * // -> [{ start: 10 }, { start : 20 }]
 *
 * sortedList.add(element3);
 * console.log(sortedList.unwrap());
 * // -> [{ start: 10 }, { start : 15 }, { start: 20 }]
 *
 * sortedList.removeElement(element2);
 * // -> [{ start: 10 }, { start: 15 }]
 * ```
 * @class SortedList
 */
var SortedList = /*#__PURE__*/function () {
  /**
   * @param {Function} sortingFunction
   */
  function SortedList(sortingFunction) {
    this._array = [];
    this._sortingFn = sortingFunction;
  }
  /**
   * Add a new element to the List at the right place for the List to stay
   * sorted.
   *
   * /!\ The added Element will share the same reference than the given
   * argument, any mutation on your part can lead to an un-sorted SortedList.
   * You can still re-force the sorting to happen by calling forceSort.
   * @param {...*} elements
   */
  var _proto = SortedList.prototype;
  _proto.add = function add() {
    for (var _len = arguments.length, elements = new Array(_len), _key = 0; _key < _len; _key++) {
      elements[_key] = arguments[_key];
    }
    elements.sort(this._sortingFn);
    var j = 0;
    for (var i = 0; i < elements.length; i++) {
      var element = elements[i];
      var inserted = false;
      while (!inserted && j < this._array.length) {
        if (this._sortingFn(element, this._array[j]) < 0) {
          this._array.splice(j, 0, element);
          inserted = true;
        } else {
          j++;
        }
      }
      if (!inserted) {
        this._array.push(element);
      }
    }
  }
  /**
   * Returns the current length of the list.
   * @returns {number}
   */;
  _proto.length = function length() {
    return this._array.length;
  }
  /**
   * Returns the nth element. Throws if the index does not exist.
   *
   * /!\ The returned Element shares the same reference with what is used
   * internally, any mutation on your part can lead to an un-sorted SortedList.
   * You can still re-force the sorting to happen by calling forceSort.
   * @throws Error - Throws if the given index is negative or superior to the
   * array's length.
   * @param {number} index
   * @returns {*}
   */;
  _proto.get = function get(index) {
    if (index < 0 || index >= this._array.length) {
      throw new Error("Invalid index.");
    }
    return this._array[index];
  };
  _proto.toArray = function toArray() {
    return this._array.slice();
  }
  /**
   * Find the first element corresponding to the given predicate.
   *
   * /!\ The returned element shares the same reference with what is used
   * internally, any mutation on your part can lead to an un-sorted SortedList.
   * You can still re-force the sorting to happen by calling forceSort.
   * @param {Function} fn
   * @returns {*}
   */;
  _proto.findFirst = function findFirst(fn) {
    return (0,_array_find__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(this._array, fn);
  }
  /**
   * Returns true if the List contains the given element.
   * @param {*} element
   * @returns {Boolean}
   */;
  _proto.has = function has(element) {
    return (0,_array_includes__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(this._array, element);
  }
  /**
   * Remove the first occurence of the given element.
   * Returns the index of the removed element. Undefined if not found.
   * @returns {number|undefined}
   */;
  _proto.removeElement = function removeElement(element) {
    var indexOf = this._array.indexOf(element);
    if (indexOf >= 0) {
      this._array.splice(indexOf, 1);
      return indexOf;
    }
    return undefined;
  }
  /**
   * Returns the first element.
   *
   * /!\ The returned Element shares the same reference with what is used
   * internally, any mutation on your part can lead to an un-sorted SortedList.
   * You can still re-force the sorting to happen by calling forceSort.
   * @returns {*}
   */;
  _proto.head = function head() {
    return this._array[0];
  }
  /**
   * Returns the last element.
   *
   * /!\ The returned Element shares the same reference with what is used
   * internally, any mutation on your part can lead to an un-sorted SortedList.
   * You can still re-force the sorting to happen by calling forceSort.
   * @returns {*}
   */;
  _proto.last = function last() {
    return this._array[this._array.length - 1];
  }
  /**
   * Remove the first element.
   * Returns the element removed or undefined if no element were removed.
   * @returns {*}
   */;
  _proto.shift = function shift() {
    return this._array.shift();
  }
  /**
   * Remove the last element.
   * Returns the element removed or undefined if no element were removed.
   * @returns {*}
   */;
  _proto.pop = function pop() {
    return this._array.pop();
  };
  return SortedList;
}();


/***/ }),

/***/ 9828:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: function() { return /* binding */ startsWith; }
/* harmony export */ });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * String.prototype.startsWith ponyfill.
 * Indicates Whether a string starts with another substring.
 *
 * Inspired from MDN polyfill, but ponyfilled instead.
 * @param {string} completeString
 * @param {string} searchString
 * @param {number} [position]
 * @returns {boolean}
 */
function startsWith(completeString, searchString, position) {
  // eslint-disable-next-line @typescript-eslint/unbound-method
  // eslint-disable-next-line no-restricted-properties
  if (typeof String.prototype.startsWith === "function") {
    // eslint-disable-next-line no-restricted-properties
    return completeString.startsWith(searchString, position);
  }
  var initialPosition = typeof position === "number" ? Math.max(position, 0) : 0;
  return completeString.substring(initialPosition, initialPosition + searchString.length) === searchString;
}

/***/ }),

/***/ 4670:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Es: function() { return /* binding */ utf8ToStr; },
/* harmony export */   KZ: function() { return /* binding */ guidToUuid; },
/* harmony export */   My: function() { return /* binding */ bytesToHex; },
/* harmony export */   Yg: function() { return /* binding */ utf16LEToStr; },
/* harmony export */   Yn: function() { return /* binding */ readNullTerminatedString; },
/* harmony export */   aT: function() { return /* binding */ hexToBytes; },
/* harmony export */   eb: function() { return /* binding */ strToUtf8; },
/* harmony export */   kY: function() { return /* binding */ strToUtf16LE; }
/* harmony export */ });
/* unused harmony exports strToBeUtf16, beUtf16ToStr */
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9477);
/* harmony import */ var _assert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7994);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var hasTextDecoder = typeof window === "object" && typeof window.TextDecoder === "function";
var hasTextEncoder = typeof window === "object" && typeof window.TextEncoder === "function";
/**
 * Convert a string to an Uint8Array containing the corresponding UTF-16 code
 * units in little-endian.
 * @param {string} str
 * @returns {Uint8Array}
 */
function strToUtf16LE(str) {
  var buffer = new ArrayBuffer(str.length * 2);
  var res = new Uint8Array(buffer);
  for (var i = 0; i < res.length; i += 2) {
    var value = str.charCodeAt(i / 2);
    res[i] = value & 0xff;
    res[i + 1] = value >> 8 & 0xff;
  }
  return res;
}
/**
 * Convert a string to an Uint8Array containing the corresponding UTF-16 code
 * units in big-endian.
 * @param {string} str
 * @returns {Uint8Array}
 */
function strToBeUtf16(str) {
  var buffer = new ArrayBuffer(str.length * 2);
  var res = new Uint8Array(buffer);
  for (var i = 0; i < res.length; i += 2) {
    var value = str.charCodeAt(i / 2);
    res[i + 1] = value & 0xff;
    res[i] = value >> 8 & 0xff;
  }
  return res;
}
/**
 * Construct string from the little-endian UTF-16 code units given.
 * @param {Uint8Array} bytes
 * @returns {string}
 */
function utf16LEToStr(bytes) {
  if (hasTextDecoder) {
    try {
      // instanciation throws if the encoding is unsupported
      var decoder = new TextDecoder("utf-16le");
      return decoder.decode(bytes);
    } catch (e) {
      var err = e instanceof Error ? e : "";
      _log__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.warn("Utils: could not use TextDecoder to parse UTF-16LE, " + "fallbacking to another implementation", err);
    }
  }
  var str = "";
  for (var i = 0; i < bytes.length; i += 2) {
    str += String.fromCharCode((bytes[i + 1] << 8) + bytes[i]);
  }
  return str;
}
/**
 * Construct string from the little-endian UTF-16 code units given.
 * @param {Uint8Array} bytes
 * @returns {string}
 */
function beUtf16ToStr(bytes) {
  if (hasTextDecoder) {
    try {
      // instanciation throws if the encoding is unsupported
      var decoder = new TextDecoder("utf-16be");
      return decoder.decode(bytes);
    } catch (e) {
      var err = e instanceof Error ? e : "";
      log.warn("Utils: could not use TextDecoder to parse UTF-16BE, " + "fallbacking to another implementation", err);
    }
  }
  var str = "";
  for (var i = 0; i < bytes.length; i += 2) {
    str += String.fromCharCode((bytes[i] << 8) + bytes[i + 1]);
  }
  return str;
}
/**
 * Convert a string to an Uint8Array containing the corresponding UTF-8 code
 * units.
 * @param {string} str
 * @returns {Uint8Array}
 */
function strToUtf8(str) {
  if (hasTextEncoder) {
    try {
      var encoder = new TextEncoder();
      return encoder.encode(str);
    } catch (e) {
      var err = e instanceof Error ? e : "";
      _log__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.warn("Utils: could not use TextEncoder to encode string into UTF-8, " + "fallbacking to another implementation", err);
    }
  }
  // http://stackoverflow.com/a/13691499 provides an ugly but functional solution.
  // (Note you have to dig deeper to understand it but I have more faith in
  // stackoverflow not going down in the future so I leave that link.)
  // Briefly said, `utf8Str` will contain a version of `str` where every
  // non-ASCII characters will be replaced by an escape sequence of the
  // corresponding representation of those characters in UTF-8.
  // It does sound weird and unnecessarily complicated, but it works!
  //
  // Here is actually what happens with more words. We will rely on two browser
  // APIs:
  //
  //   - `encodeURIComponent` will take a string and convert the non-ASCII
  //     characters in it into the percent-encoded version of the corresponding
  //     UTF-8 bytes
  //     Example: encodeURIComponent("") => 0xC3 0xA9 => `"%C3%A9"`
  //
  //   - `unescape` unescapes (so far so good) a percent-encoded string. But it
  //     does it in a really simple way: percent-encoded byte by percent-encoded
  //     byte into the corresponding extended ASCII representation on 8 bits.
  //     As a result, we end-up with a string which actually contains instead of
  //     each of its original characters, the UTF-8 code units (8 bits) of
  //     those characters.
  //     Let's take our previous `"" => "%C3%A9"` example. Here we would get:
  //     unecape("%C3%A9") => "\u00c3\u00a9" === "" (in extended ASCII)
  //
  // By iterating on the resulting string, we will then be able to generate a
  // Uint8Array containing the UTF-8 representation of that original string, by
  // just calling the charCodeAt API on it.
  var utf8Str;
  var pcStr = encodeURIComponent(str);
  // As "unescape" is a deprecated function we want to declare a fallback in the
  // case a browser decide to not implement it.
  if (typeof unescape === "function") {
    utf8Str = unescape(pcStr);
  } else {
    // Let's implement a simple unescape function (got to admit it was for the challenge)
    // http://ecma-international.org/ecma-262/9.0/#sec-unescape-string
    var isHexChar = /[0-9a-fA-F]/;
    var pcStrLen = pcStr.length;
    utf8Str = "";
    for (var i = 0; i < pcStr.length; i++) {
      var wasPercentEncoded = false;
      if (pcStr[i] === "%") {
        if (i <= pcStrLen - 6 && pcStr[i + 1] === "u" && isHexChar.test(pcStr[i + 2]) && isHexChar.test(pcStr[i + 3]) && isHexChar.test(pcStr[i + 4]) && isHexChar.test(pcStr[i + 5])) {
          var charCode = parseInt(pcStr.substring(i + 1, i + 6), 16);
          utf8Str += String.fromCharCode(charCode);
          wasPercentEncoded = true;
          i += 5; // Skip the next 5 chars
        } else if (i <= pcStrLen - 3 && isHexChar.test(pcStr[i + 1]) && isHexChar.test(pcStr[i + 2])) {
          var _charCode = parseInt(pcStr.substring(i + 1, i + 3), 16);
          utf8Str += String.fromCharCode(_charCode);
          wasPercentEncoded = true;
          i += 2; // Skip the next 2 chars
        }
      }
      if (!wasPercentEncoded) {
        utf8Str += pcStr[i];
      }
    }
  }
  // Now let's just build our array from every other bytes of that string's
  // UTF-16 representation
  var res = new Uint8Array(utf8Str.length);
  for (var _i = 0; _i < utf8Str.length; _i++) {
    res[_i] = utf8Str.charCodeAt(_i) & 0xff; // first byte should be 0x00 anyway
  }
  return res;
}
/**
 * Creates a new string from the given array of char codes.
 * @param {Uint8Array} args
 * @returns {string}
 */
function stringFromCharCodes(args) {
  var max = 16000;
  var ret = "";
  for (var i = 0; i < args.length; i += max) {
    var subArray = args.subarray(i, i + max);
    // NOTE: ugly I know, but TS is problematic here (you can try)
    ret += String.fromCharCode.apply(null, subArray);
  }
  return ret;
}
/**
 * Transform an integer into an hexadecimal string of the given length, padded
 * to the left with `0` if needed.
 * @example
 * ```
 * intToHex(5, 4); // => "0005"
 * intToHex(5, 2); // => "05"
 * intToHex(10, 1); // => "a"
 * intToHex(268, 3); // => "10c"
 * intToHex(4584, 6) // => "0011e8"
 * intToHex(123456, 4); // => "1e240" (we do nothing when going over 4 chars)
 * ```
 * @param {number} num
 * @param {number} size
 * @returns {string}
 */
function intToHex(num, size) {
  var toStr = num.toString(16);
  return toStr.length >= size ? toStr : new Array(size - toStr.length + 1).join("0") + toStr;
}
/**
 * Creates a string from the given Uint8Array containing utf-8 code units.
 * @param {Uint8Array} bytes
 * @returns {string}
 */
function utf8ToStr(data) {
  if (hasTextDecoder) {
    try {
      // TextDecoder use UTF-8 by default
      var decoder = new TextDecoder();
      return decoder.decode(data);
    } catch (e) {
      var err = e instanceof Error ? e : "";
      _log__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.warn("Utils: could not use TextDecoder to parse UTF-8, " + "fallbacking to another implementation", err);
    }
  }
  var uint8 = data;
  // If present, strip off the UTF-8 BOM.
  if (uint8[0] === 0xef && uint8[1] === 0xbb && uint8[2] === 0xbf) {
    uint8 = uint8.subarray(3);
  }
  // We're basically doing strToUtf8 in reverse.
  // You can look at that other function for the whole story.
  // Generate string containing escaped UTF-8 code units
  var utf8Str = stringFromCharCodes(uint8);
  var escaped;
  if (typeof escape === "function") {
    // Transform UTF-8 escape sequence into percent-encoded escape sequences.
    escaped = escape(utf8Str);
  } else {
    // Let's implement a simple escape function
    // http://ecma-international.org/ecma-262/9.0/#sec-escape-string
    var nonEscapedChar = /[A-Za-z0-9*_\+-\.\/]/;
    escaped = "";
    for (var i = 0; i < utf8Str.length; i++) {
      if (nonEscapedChar.test(utf8Str[i])) {
        escaped += utf8Str[i];
      } else {
        var charCode = utf8Str.charCodeAt(i);
        escaped += charCode >= 256 ? "%u" + intToHex(charCode, 4) : "%" + intToHex(charCode, 2);
      }
    }
  }
  // Decode the percent-encoded UTF-8 string into the proper JS string.
  // Example: "g#%E3%82%AC" -> "g#"
  return decodeURIComponent(escaped);
}
/**
 * Convert hex codes in a string form into the corresponding bytes.
 * @param {string} str
 * @returns {Uint8Array}
 * @throws TypeError - str.length is odd
 */
function hexToBytes(str) {
  var len = str.length;
  var arr = new Uint8Array(len / 2);
  for (var i = 0, j = 0; i < len; i += 2, j++) {
    arr[j] = parseInt(str.substring(i, i + 2), 16) & 0xff;
  }
  return arr;
}
/**
 * Convert bytes into the corresponding hex string, with the possibility
 * to add a separator.
 * @param {Uint8Array} bytes
 * @param {string} [sep=""] - separator. Separate each two hex character.
 * @returns {string}
 */
function bytesToHex(bytes, sep) {
  if (sep === void 0) {
    sep = "";
  }
  var hex = "";
  for (var i = 0; i < bytes.byteLength; i++) {
    hex += (bytes[i] >>> 4).toString(16);
    hex += (bytes[i] & 0xf).toString(16);
    if (sep.length > 0 && i < bytes.byteLength - 1) {
      hex += sep;
    }
  }
  return hex;
}
/**
 * Convert little-endian GUID into big-endian UUID.
 * @param {Uint8Array} guid
 * @returns {Uint8Array} - uuid
 * @throws AssertionError - The guid length is not 16
 */
function guidToUuid(guid) {
  (0,_assert__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .h)(guid.length === 16, "GUID length should be 16");
  var p1A = guid[0];
  var p1B = guid[1];
  var p1C = guid[2];
  var p1D = guid[3];
  var p2A = guid[4];
  var p2B = guid[5];
  var p3A = guid[6];
  var p3B = guid[7];
  var uuid = new Uint8Array(16);
  // swapping byte endian on 4 bytes
  // [1, 2, 3, 4] => [4, 3, 2, 1]
  uuid[0] = p1D;
  uuid[1] = p1C;
  uuid[2] = p1B;
  uuid[3] = p1A;
  // swapping byte endian on 2 bytes
  // [5, 6] => [6, 5]
  uuid[4] = p2B;
  uuid[5] = p2A;
  // swapping byte endian on 2 bytes
  // [7, 8] => [8, 7]
  uuid[6] = p3B;
  uuid[7] = p3A;
  uuid.set(guid.subarray(8, 16), 8);
  return uuid;
}
/**
 * Decode string from bytes (UTF-8).
 * Keeps reading until it reaches a byte that equals to zero.
 * @param {Uint8Array} buffer
 * @param {number} offset
 * @returns {Object}
 */
function readNullTerminatedString(buffer, offset) {
  var position = offset;
  while (position < buffer.length) {
    var value = buffer[position];
    if (value === 0) {
      break;
    }
    position += 1;
  }
  var bytes = buffer.subarray(offset, position);
  return {
    end: position + 1,
    string: utf8ToStr(bytes)
  };
}


/***/ }),

/***/ 2507:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AK: function() { return /* binding */ CancellationSignal; },
/* harmony export */   AL: function() { return /* binding */ CancellationError; },
/* harmony export */   Ay: function() { return /* binding */ TaskCanceller; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7387);
/* harmony import */ var _babel_runtime_helpers_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(8593);
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9477);
/* harmony import */ var _assert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7994);
/* harmony import */ var _noop__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(8060);


/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Class facilitating asynchronous task cancellation.
 *
 * This class can be used to notify some code running an asynchronous task (for
 * example, a request) that is should abort what it is doing (for example, abort
 * a request when it isn't needed anymore).
 *
 * To do that, the code which might ask for cancellation have to create a new
 * `TaskCanceller`:
 * ```js
 * const canceller = new TaskCanceller();
 * ```
 *
 * And has to provide its associated `CancellationSignal` to the code running
 * the asynchronous task:
 * ```js
 * runAsyncTask(canceller.signal);
 * ```
 *
 * In the asynchronous task, the signal can be listened to (see documentation
 * on `CancellationSignal` for more information):
 * ```js
 * function runAsyncTask(cancellationSignal) {
 *  // Let's say this function returns a Promise (this is not mandatory however)
 *  return Promise((resolve, reject) => {
 *    // In this example, we'll even catch the case where an asynchronous task
 *    // was already cancelled before being called.
 *    // This ensure that no code will run if that's the case.
 *    if (cancellationSignal.isCancelled) {
 *      // Here we're rejecting the CancellationError to notify the caller that
 *      // this error was due to the task being aborted.
 *      reject(cancellationSignal.cancellationError);
 *      return;
 *    }
 *
 *    // Example:
 *    // performing asynchronous task and registering callbacks on success/failure.
 *    const myCancellableTask = doSomeAsyncTasks()
 *      .onFinished(onTaskFinished);
 *      .onFailed(onTaskFailed);
 *
 *    // Run a callback when/if the corresponding `TaskCanceller` was triggered.
 *    // Run immediately if the TaskCanceller was already triggered.
 *    const deregisterSignal = cancellationSignal.register(onCancellation);
 *
 *    // Callback called on cancellation (if this task was cancelled while the
 *    // cancellationSignal's listener is still registered).
 *    // The `error` in argument is linked to that cancellation. It is usually
 *    // expected that the same Error instance is used when rejecting Promises.
 *    function onCancellation(error : CancellationError) {
 *      // abort asynchronous task
 *      myCancellableTask.cancel();
 *
 *      // In this example, reject the current pending Promise
 *      reject(CancellationError);
 *    }
 *
 *    // Callback called after the asynchronous task has finished with success.
 *    function onTaskFinished() {
 *      // Stop listening to the cancellationSignal
 *      deregisterSignal();
 *
 *      // Resolve the Promise
 *      resolve();
 *    }
 *
 *    // Callback called after the asynchronous task has finished with failure.
 *    function onTaskFailed(someError : Error) {
 *      // Stop listening to the cancellationSignal
 *      deregisterSignal();
 *
 *      // Resolve the Promise
 *      reject(error);
 *    }
 *  });
 * }
 * ```
 *
 * The code asking for cancellation can then trigger a cancellation at any time
 * (even before the signal was given) and listen to possible CancellationErrors
 * to know when it was cancelled.
 * ```js
 * const canceller = new TaskCanceller();
 *
 * runAsyncTask(canceller.signal)
 *   .then(() => { console.log("Task succeeded!"); )
 *   .catch((err) => {
 *      if (TaskCanceller.isCancellationError(err)) {
 *        console.log("Task cancelled!");
 *      } else {
 *        console.log("Task failed:", err);
 *      }
 *   });
 * canceller.cancel(); // Cancel the task, calling registered callbacks
 * ```
 * @class TaskCanceller
 */
var TaskCanceller = /*#__PURE__*/function () {
  /**
   * Creates a new `TaskCanceller`, with its own `CancellationSignal` created
   * as its `signal` provide.
   * You can then pass this property to async task you wish to be cancellable.
   */
  function TaskCanceller() {
    var _createCancellationFu = createCancellationFunctions(),
      trigger = _createCancellationFu[0],
      register = _createCancellationFu[1];
    this._isUsed = false;
    this._trigger = trigger;
    this.signal = new CancellationSignal(register);
  }
  /**
   * Returns `true` if this `TaskCanceller` has already been triggered.
   * `false` otherwise.
   */
  var _proto = TaskCanceller.prototype;
  _proto.isUsed = function isUsed() {
    return this._isUsed;
  }
  /**
   * Bind this `TaskCanceller` to a `CancellationSignal`, so the former
   * is automatically cancelled when the latter is triggered.
   *
   * Note that this call registers a callback on the given signal, until either
   * the current `TaskCanceller` is cancelled or until this given
   * `CancellationSignal` is triggered.
   * To avoid leaking memory, the returned callback allow to undo this link.
   * It should be called if/when that link is not needed anymore, such as when
   * there is no need for this `TaskCanceller` anymore.
   *
   * @param {Object} signal
   * @returns {Function}
   */;
  _proto.linkToSignal = function linkToSignal(signal) {
    var _this = this;
    var unregister = signal.register(function () {
      _this.cancel();
    });
    this.signal.register(unregister);
    return unregister;
  }
  /**
   * "Trigger" the `TaskCanceller`, notify through its associated
   * `CancellationSignal` (its `signal` property) that a task should be aborted.
   *
   * Once called the `TaskCanceller` is permanently triggered.
   *
   * An optional CancellationError can be given in argument for when this
   * cancellation is actually triggered as a chain reaction from a previous
   * cancellation.
   * @param {Error} [srcError]
   */;
  _proto.cancel = function cancel(srcError) {
    if (this._isUsed) {
      return;
    }
    this._isUsed = true;
    var cancellationError = srcError !== null && srcError !== void 0 ? srcError : new CancellationError();
    this._trigger(cancellationError);
  }
  /**
   * Check that the `error` in argument is a `CancellationError`, most likely
   * meaning that the linked error is due to a task aborted via a
   * `CancellationSignal`.
   * @param {*} error
   * @returns {boolean}
   */;
  TaskCanceller.isCancellationError = function isCancellationError(error) {
    return error instanceof CancellationError;
  };
  return TaskCanceller;
}();
/**
 * Signal allowing to be notified when the linked task needs to be aborted.
 * @class
 */

var CancellationSignal = /*#__PURE__*/function () {
  /**
   * Creates a new CancellationSignal.
   * /!\ Note: Only a `TaskCanceller` is supposed to be able to create one.
   * @param {Function} registerToSource - Function called when the task is
   * cancelled.
   */
  function CancellationSignal(registerToSource) {
    var _this2 = this;
    this._isCancelled = false;
    this.cancellationError = null;
    this._listeners = [];
    registerToSource(function (cancellationError) {
      _this2.cancellationError = cancellationError;
      _this2._isCancelled = true;
      while (_this2._listeners.length > 0) {
        try {
          var listener = _this2._listeners.pop();
          listener === null || listener === void 0 ? void 0 : listener(cancellationError);
        } catch (err) {
          _log__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.error("Error while calling clean up listener", err instanceof Error ? err.toString() : "Unknown error");
        }
      }
    });
  }
  /**
   * Returns `true` when the cancellation order was already triggered, meaning
   * that the linked task needs to be aborted.
   * @returns boolean
   */
  var _proto2 = CancellationSignal.prototype;
  _proto2.isCancelled = function isCancelled() {
    return this._isCancelled;
  }
  /**
   * Registers a function that will be called when/if the current task is
   * cancelled.
   *
   * Multiple calls to `register` can be performed to register multiple
   * callbacks on cancellation associated to the same `CancellationSignal`.
   *
   * @param {Function} fn - This function should perform all logic allowing to
   * abort everything the task is doing.
   *
   * It takes in argument the `CancellationError` which was created when the
   * task was aborted.
   * You can use this error to notify callers that the task has been aborted,
   * for example through a rejected Promise.
   *
   * @return {Function} - Removes that cancellation listener. You can call this
   * once you don't want the callback to be triggered anymore (e.g. after the
   * task succeeded or failed).
   * You don't need to call that function when cancellation has already been
   * performed.
   */;
  _proto2.register = function register(fn) {
    var _this3 = this;
    if (this._isCancelled) {
      (0,_assert__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .h)(this.cancellationError !== null);
      fn(this.cancellationError);
      return _noop__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A;
    }
    this._listeners.push(fn);
    return function () {
      return _this3.deregister(fn);
    };
  }
  /**
   * De-register a function registered through the `register` function.
   * Do nothing if that function wasn't registered.
   *
   * You can call this method when using the return value of `register` is not
   * practical.
   * @param {Function} fn
   */;
  _proto2.deregister = function deregister(fn) {
    for (var i = this._listeners.length - 1; i >= 0; i--) {
      if (this._listeners[i] === fn) {
        this._listeners.splice(i, 1);
      }
    }
  };
  return CancellationSignal;
}();
/**
 * Error created when a task is cancelled.
 * @class CancellationError
 * @extends Error
 */
var CancellationError = /*#__PURE__*/function (_Error) {
  function CancellationError() {
    var _this4;
    var message = "This task was cancelled.";
    _this4 = _Error.call(this, message) || this;
    // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class
    Object.setPrototypeOf(_this4, CancellationError.prototype);
    _this4.name = "CancellationError";
    return _this4;
  }
  (0,_babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A)(CancellationError, _Error);
  return CancellationError;
}( /*#__PURE__*/(0,_babel_runtime_helpers_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A)(Error));
/**
 * Helper function allowing communication between a `TaskCanceller` and a
 * `CancellationSignal`.
 * @returns {Array.<Function>}
 */
function createCancellationFunctions() {
  var listener = _noop__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A;
  return [function trigger(error) {
    listener(error);
  }, function register(newListener) {
    listener = newListener;
  }];
}

/***/ }),

/***/ 5950:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: function() { return /* binding */ warnOnce; }
/* harmony export */ });
/* harmony import */ var _array_includes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4031);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var WARNED_MESSAGES = [];
/**
 * Perform a console.warn only once in the application lifetime.
 *
 * Useful for deprecated messages, for example.
 *
 * @param {string} message
 */
function warnOnce(message) {
  if (!(0,_array_includes__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(WARNED_MESSAGES, message)) {
    // eslint-disable-next-line no-console
    console.warn(message);
    WARNED_MESSAGES.push(message);
  }
}

/***/ }),

/***/ 6826:
/***/ (function(module) {

"use strict";


var ensureCallable = function (fn) {
	if (typeof fn !== 'function') throw new TypeError(fn + " is not a function");
	return fn;
};

var byObserver = function (Observer) {
	var node = document.createTextNode(''), queue, currentQueue, i = 0;
	new Observer(function () {
		var callback;
		if (!queue) {
			if (!currentQueue) return;
			queue = currentQueue;
		} else if (currentQueue) {
			queue = currentQueue.concat(queue);
		}
		currentQueue = queue;
		queue = null;
		if (typeof currentQueue === 'function') {
			callback = currentQueue;
			currentQueue = null;
			callback();
			return;
		}
		node.data = (i = ++i % 2); // Invoke other batch, to handle leftover callbacks in case of crash
		while (currentQueue) {
			callback = currentQueue.shift();
			if (!currentQueue.length) currentQueue = null;
			callback();
		}
	}).observe(node, { characterData: true });
	return function (fn) {
		ensureCallable(fn);
		if (queue) {
			if (typeof queue === 'function') queue = [queue, fn];
			else queue.push(fn);
			return;
		}
		queue = fn;
		node.data = (i = ++i % 2);
	};
};

module.exports = (function () {
	// Node.js
	if ((typeof process === 'object') && process && (typeof process.nextTick === 'function')) {
		return process.nextTick;
	}

	// queueMicrotask
	if (typeof queueMicrotask === "function") {
		return function (cb) { queueMicrotask(ensureCallable(cb)); };
	}

	// MutationObserver
	if ((typeof document === 'object') && document) {
		if (typeof MutationObserver === 'function') return byObserver(MutationObserver);
		if (typeof WebKitMutationObserver === 'function') return byObserver(WebKitMutationObserver);
	}

	// W3C Draft
	// http://dvcs.w3.org/hg/webperf/raw-file/tip/specs/setImmediate/Overview.html
	if (typeof setImmediate === 'function') {
		return function (cb) { setImmediate(ensureCallable(cb)); };
	}

	// Wide available standard
	if ((typeof setTimeout === 'function') || (typeof setTimeout === 'object')) {
		return function (cb) { setTimeout(ensureCallable(cb), 0); };
	}

	return null;
}());


/***/ }),

/***/ 4633:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var _typeof = (__webpack_require__(3738)["default"]);
function _regeneratorRuntime() {
  "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
  module.exports = _regeneratorRuntime = function _regeneratorRuntime() {
    return e;
  }, module.exports.__esModule = true, module.exports["default"] = module.exports;
  var t,
    e = {},
    r = Object.prototype,
    n = r.hasOwnProperty,
    o = Object.defineProperty || function (t, e, r) {
      t[e] = r.value;
    },
    i = "function" == typeof Symbol ? Symbol : {},
    a = i.iterator || "@@iterator",
    c = i.asyncIterator || "@@asyncIterator",
    u = i.toStringTag || "@@toStringTag";
  function define(t, e, r) {
    return Object.defineProperty(t, e, {
      value: r,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), t[e];
  }
  try {
    define({}, "");
  } catch (t) {
    define = function define(t, e, r) {
      return t[e] = r;
    };
  }
  function wrap(t, e, r, n) {
    var i = e && e.prototype instanceof Generator ? e : Generator,
      a = Object.create(i.prototype),
      c = new Context(n || []);
    return o(a, "_invoke", {
      value: makeInvokeMethod(t, r, c)
    }), a;
  }
  function tryCatch(t, e, r) {
    try {
      return {
        type: "normal",
        arg: t.call(e, r)
      };
    } catch (t) {
      return {
        type: "throw",
        arg: t
      };
    }
  }
  e.wrap = wrap;
  var h = "suspendedStart",
    l = "suspendedYield",
    f = "executing",
    s = "completed",
    y = {};
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  var p = {};
  define(p, a, function () {
    return this;
  });
  var d = Object.getPrototypeOf,
    v = d && d(d(values([])));
  v && v !== r && n.call(v, a) && (p = v);
  var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
  function defineIteratorMethods(t) {
    ["next", "throw", "return"].forEach(function (e) {
      define(t, e, function (t) {
        return this._invoke(e, t);
      });
    });
  }
  function AsyncIterator(t, e) {
    function invoke(r, o, i, a) {
      var c = tryCatch(t[r], t, o);
      if ("throw" !== c.type) {
        var u = c.arg,
          h = u.value;
        return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) {
          invoke("next", t, i, a);
        }, function (t) {
          invoke("throw", t, i, a);
        }) : e.resolve(h).then(function (t) {
          u.value = t, i(u);
        }, function (t) {
          return invoke("throw", t, i, a);
        });
      }
      a(c.arg);
    }
    var r;
    o(this, "_invoke", {
      value: function value(t, n) {
        function callInvokeWithMethodAndArg() {
          return new e(function (e, r) {
            invoke(t, n, e, r);
          });
        }
        return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(e, r, n) {
    var o = h;
    return function (i, a) {
      if (o === f) throw Error("Generator is already running");
      if (o === s) {
        if ("throw" === i) throw a;
        return {
          value: t,
          done: !0
        };
      }
      for (n.method = i, n.arg = a;;) {
        var c = n.delegate;
        if (c) {
          var u = maybeInvokeDelegate(c, n);
          if (u) {
            if (u === y) continue;
            return u;
          }
        }
        if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) {
          if (o === h) throw o = s, n.arg;
          n.dispatchException(n.arg);
        } else "return" === n.method && n.abrupt("return", n.arg);
        o = f;
        var p = tryCatch(e, r, n);
        if ("normal" === p.type) {
          if (o = n.done ? s : l, p.arg === y) continue;
          return {
            value: p.arg,
            done: n.done
          };
        }
        "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg);
      }
    };
  }
  function maybeInvokeDelegate(e, r) {
    var n = r.method,
      o = e.iterator[n];
    if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y;
    var i = tryCatch(o, e.iterator, r.arg);
    if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y;
    var a = i.arg;
    return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y);
  }
  function pushTryEntry(t) {
    var e = {
      tryLoc: t[0]
    };
    1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);
  }
  function resetTryEntry(t) {
    var e = t.completion || {};
    e.type = "normal", delete e.arg, t.completion = e;
  }
  function Context(t) {
    this.tryEntries = [{
      tryLoc: "root"
    }], t.forEach(pushTryEntry, this), this.reset(!0);
  }
  function values(e) {
    if (e || "" === e) {
      var r = e[a];
      if (r) return r.call(e);
      if ("function" == typeof e.next) return e;
      if (!isNaN(e.length)) {
        var o = -1,
          i = function next() {
            for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next;
            return next.value = t, next.done = !0, next;
          };
        return i.next = i;
      }
    }
    throw new TypeError(_typeof(e) + " is not iterable");
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: !0
  }), o(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: !0
  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) {
    var e = "function" == typeof t && t.constructor;
    return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name));
  }, e.mark = function (t) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t;
  }, e.awrap = function (t) {
    return {
      __await: t
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () {
    return this;
  }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) {
    void 0 === i && (i = Promise);
    var a = new AsyncIterator(wrap(t, r, n, o), i);
    return e.isGeneratorFunction(r) ? a : a.next().then(function (t) {
      return t.done ? t.value : a.next();
    });
  }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () {
    return this;
  }), define(g, "toString", function () {
    return "[object Generator]";
  }), e.keys = function (t) {
    var e = Object(t),
      r = [];
    for (var n in e) r.push(n);
    return r.reverse(), function next() {
      for (; r.length;) {
        var t = r.pop();
        if (t in e) return next.value = t, next.done = !1, next;
      }
      return next.done = !0, next;
    };
  }, e.values = values, Context.prototype = {
    constructor: Context,
    reset: function reset(e) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t);
    },
    stop: function stop() {
      this.done = !0;
      var t = this.tryEntries[0].completion;
      if ("throw" === t.type) throw t.arg;
      return this.rval;
    },
    dispatchException: function dispatchException(e) {
      if (this.done) throw e;
      var r = this;
      function handle(n, o) {
        return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o;
      }
      for (var o = this.tryEntries.length - 1; o >= 0; --o) {
        var i = this.tryEntries[o],
          a = i.completion;
        if ("root" === i.tryLoc) return handle("end");
        if (i.tryLoc <= this.prev) {
          var c = n.call(i, "catchLoc"),
            u = n.call(i, "finallyLoc");
          if (c && u) {
            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
          } else if (c) {
            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
          } else {
            if (!u) throw Error("try statement without catch or finally");
            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
          }
        }
      }
    },
    abrupt: function abrupt(t, e) {
      for (var r = this.tryEntries.length - 1; r >= 0; --r) {
        var o = this.tryEntries[r];
        if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) {
          var i = o;
          break;
        }
      }
      i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);
      var a = i ? i.completion : {};
      return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a);
    },
    complete: function complete(t, e) {
      if ("throw" === t.type) throw t.arg;
      return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y;
    },
    finish: function finish(t) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var r = this.tryEntries[e];
        if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y;
      }
    },
    "catch": function _catch(t) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var r = this.tryEntries[e];
        if (r.tryLoc === t) {
          var n = r.completion;
          if ("throw" === n.type) {
            var o = n.arg;
            resetTryEntry(r);
          }
          return o;
        }
      }
      throw Error("illegal catch attempt");
    },
    delegateYield: function delegateYield(e, r, n) {
      return this.delegate = {
        iterator: values(e),
        resultName: r,
        nextLoc: n
      }, "next" === this.method && (this.arg = t), y;
    }
  }, e;
}
module.exports = _regeneratorRuntime, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 3738:
/***/ (function(module) {

function _typeof(o) {
  "@babel/helpers - typeof";

  return (module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, module.exports.__esModule = true, module.exports["default"] = module.exports), _typeof(o);
}
module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 4756:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// TODO(Babel 8): Remove this file.

var runtime = __webpack_require__(4633)();
module.exports = runtime;

// Copied from https://github.com/facebook/regenerator/blob/main/packages/runtime/runtime.js#L736=
try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  if (typeof globalThis === "object") {
    globalThis.regeneratorRuntime = runtime;
  } else {
    Function("r", "regeneratorRuntime = r")(runtime);
  }
}


/***/ }),

/***/ 467:
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: function() { return /* binding */ _asyncToGenerator; }
/* harmony export */ });
function asyncGeneratorStep(n, t, e, r, o, a, c) {
  try {
    var i = n[a](c),
      u = i.value;
  } catch (n) {
    return void e(n);
  }
  i.done ? t(u) : Promise.resolve(u).then(r, o);
}
function _asyncToGenerator(n) {
  return function () {
    var t = this,
      e = arguments;
    return new Promise(function (r, o) {
      var a = n.apply(t, e);
      function _next(n) {
        asyncGeneratorStep(a, r, o, _next, _throw, "next", n);
      }
      function _throw(n) {
        asyncGeneratorStep(a, r, o, _next, _throw, "throw", n);
      }
      _next(void 0);
    });
  };
}


/***/ }),

/***/ 2212:
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: function() { return /* binding */ _createClass; }
});

;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/typeof.js
function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}

;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/toPrimitive.js

function toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}

;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js


function toPropertyKey(t) {
  var i = toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : i + "";
}

;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/createClass.js

function _defineProperties(e, r) {
  for (var t = 0; t < r.length; t++) {
    var o = r[t];
    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, toPropertyKey(o.key), o);
  }
}
function _createClass(e, r, t) {
  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}


/***/ }),

/***/ 7387:
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: function() { return /* binding */ _inheritsLoose; }
/* harmony export */ });
/* harmony import */ var _setPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3662);

function _inheritsLoose(t, o) {
  t.prototype = Object.create(o.prototype), t.prototype.constructor = t, (0,_setPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(t, o);
}


/***/ }),

/***/ 3662:
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: function() { return /* binding */ _setPrototypeOf; }
/* harmony export */ });
function _setPrototypeOf(t, e) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
    return t.__proto__ = e, t;
  }, _setPrototypeOf(t, e);
}


/***/ }),

/***/ 8593:
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: function() { return /* binding */ _wrapNativeSuper; }
});

;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js
function _getPrototypeOf(t) {
  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, _getPrototypeOf(t);
}

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
var setPrototypeOf = __webpack_require__(3662);
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/isNativeFunction.js
function _isNativeFunction(t) {
  try {
    return -1 !== Function.toString.call(t).indexOf("[native code]");
  } catch (n) {
    return "function" == typeof t;
  }
}

;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js
function _isNativeReflectConstruct() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
  } catch (t) {}
  return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {
    return !!t;
  })();
}

;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/construct.js


function _construct(t, e, r) {
  if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);
  var o = [null];
  o.push.apply(o, e);
  var p = new (t.bind.apply(t, o))();
  return r && (0,setPrototypeOf/* default */.A)(p, r.prototype), p;
}

;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js




function _wrapNativeSuper(t) {
  var r = "function" == typeof Map ? new Map() : void 0;
  return _wrapNativeSuper = function _wrapNativeSuper(t) {
    if (null === t || !_isNativeFunction(t)) return t;
    if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function");
    if (void 0 !== r) {
      if (r.has(t)) return r.get(t);
      r.set(t, Wrapper);
    }
    function Wrapper() {
      return _construct(t, arguments, _getPrototypeOf(this).constructor);
    }
    return Wrapper.prototype = Object.create(t.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }), (0,setPrototypeOf/* default */.A)(Wrapper, t);
  }, _wrapNativeSuper(t);
}


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
!function() {
"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "default": function() { return /* binding */ src; }
});

;// CONCATENATED MODULE: ./src/compat/is_debug_mode_enabled.ts
/**
 * Some external tools set that boolean, in which case, we should enable DEBUG
 * logs and various tricks to make as much logs as available to those tools.
 *
 * @returns {boolean}
 */
function isDebugModeEnabled() {
  return typeof __RX_PLAYER_DEBUG_MODE__ === "boolean" && __RX_PLAYER_DEBUG_MODE__;
}
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/createClass.js + 3 modules
var createClass = __webpack_require__(2212);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js
var inheritsLoose = __webpack_require__(7387);
// EXTERNAL MODULE: ./src/compat/event_listeners.ts
var event_listeners = __webpack_require__(5121);
;// CONCATENATED MODULE: ./src/compat/get_start_date.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Calculating a live-offseted media position necessitate to obtain first an
 * offset, and then adding that offset to the wanted position.
 *
 * That offset is in most case present inside the Manifest file, yet in cases
 * without it or without a Manifest, such as the "directfile" mode, the RxPlayer
 * won't know that offset.
 *
 * Thankfully Safari declares a `getStartDate` method allowing to obtain that
 * offset when available. This logic is mainly useful when playing HLS contents
 * in directfile mode on Safari.
 * @param {HTMLMediaElement} mediaElement
 * @returns {number|undefined}
 */
function getStartDate(mediaElement) {
  var _mediaElement = mediaElement;
  if (typeof _mediaElement.getStartDate === "function") {
    var startDate = _mediaElement.getStartDate();
    if (typeof startDate === "object" && startDate !== null) {
      var startDateNum = +startDate;
      if (!isNaN(startDateNum)) {
        return startDateNum / 1000;
      }
    } else if (typeof startDate === "number" && !isNaN(startDate)) {
      return startDate;
    }
  }
}
;// CONCATENATED MODULE: ./src/compat/fullscreen.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Request fullScreen action on a given element.
 * @param {HTMLElement} elt
 */
function requestFullscreen(element) {
  if (!fullscreen_isFullscreen()) {
    var elt = element;
    /* eslint-disable @typescript-eslint/unbound-method */
    if (typeof elt.requestFullscreen === "function") {
      /* eslint-enable @typescript-eslint/unbound-method */
      /* eslint-disable @typescript-eslint/no-floating-promises */
      elt.requestFullscreen();
      /* eslint-enable @typescript-eslint/no-floating-promises */
    } else if (typeof elt.msRequestFullscreen === "function") {
      elt.msRequestFullscreen();
    } else if (typeof elt.mozRequestFullScreen === "function") {
      elt.mozRequestFullScreen();
    } else if (typeof elt.webkitRequestFullscreen === "function") {
      elt.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
    }
  }
}
/**
 * Exit fullscreen if an element is currently in fullscreen.
 */
function fullscreen_exitFullscreen() {
  if (fullscreen_isFullscreen()) {
    var doc = document;
    /* eslint-disable @typescript-eslint/unbound-method */
    if (typeof doc.exitFullscreen === "function") {
      /* eslint-enable @typescript-eslint/unbound-method */
      /* eslint-disable @typescript-eslint/no-floating-promises */
      doc.exitFullscreen();
      /* eslint-enable @typescript-eslint/no-floating-promises */
    } else if (typeof doc.msExitFullscreen === "function") {
      doc.msExitFullscreen();
    } else if (typeof doc.mozCancelFullScreen === "function") {
      doc.mozCancelFullScreen();
    } else if (typeof doc.webkitExitFullscreen === "function") {
      doc.webkitExitFullscreen();
    }
  }
}
/**
 * Returns true if an element in the document is being displayed in fullscreen
 * mode;
 * otherwise it's false.
 * @returns {boolean}
 */
function fullscreen_isFullscreen() {
  var doc = document;
  return doc.fullscreenElement != null || doc.mozFullScreenElement != null || doc.webkitFullscreenElement != null || doc.msFullscreenElement != null;
}

// EXTERNAL MODULE: ./src/compat/browser_detection.ts
var browser_detection = __webpack_require__(443);
// EXTERNAL MODULE: ./src/log.ts + 1 modules
var src_log = __webpack_require__(9477);
;// CONCATENATED MODULE: ./src/compat/browser_version.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Returns either :
 * - 'null' when the current browser is not Firefox.
 * - '-1' when it is impossible to get the Firefox version
 * - A number above 0 that is the Firefox version number
 * @returns {number|null}
 */
function getFirefoxVersion() {
  if (!browser_detection/* isFirefox */.gm) {
    src_log/* default */.A.warn("Compat: Can't access Firefox version on no firefox browser.");
    return null;
  }
  var userAgent = navigator.userAgent;
  var match = /Firefox\/([0-9]+)\./.exec(userAgent);
  if (match === null) {
    return -1;
  }
  var result = parseInt(match[1], 10);
  if (isNaN(result)) {
    return -1;
  }
  return result;
}

;// CONCATENATED MODULE: ./src/compat/can_rely_on_video_visibility_and_size.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * This functions tells if the RxPlayer can trust on any browser data
 * about video element visibility and size.
 *
 * On Firefox (version >= 67) :
 * - The PIP feature exists but can be disabled by default according
 * to the OS and the channel used for updating / getting Firefox binaries.
 * - There is no API to know if the Picture-in-picture (PIP) is enabled
 * - There is no API to get the width of the PIP window
 *
 * The element clientWidth tells the width of the original video element, and
 * no PIP window API exists to determine its presence or width. Thus, there are
 * no way to determine the real width of the video window, as we can't know when
 * the PIP feature or window is enabled, and we can't have access to the windo
 * size information.
 *
 * Moreover, when the document is considered as hidden (e.g. in case of hidden
 * tab), as there is no way to know if the PIP feature or window is enabled,
 * we can't know if the video window is visible or not.
 * @returns {boolean}
 */
function canRelyOnVideoVisibilityAndSize() {
  if (!browser_detection/* isFirefox */.gm) {
    return true;
  }
  var firefoxVersion = getFirefoxVersion();
  if (firefoxVersion === null || firefoxVersion < 67) {
    return true;
  }
  var proto = HTMLVideoElement === null || HTMLVideoElement === void 0 ? void 0 : HTMLVideoElement.prototype;
  return (proto === null || proto === void 0 ? void 0 : proto.requirePictureInPicture) !== undefined;
}
// EXTERNAL MODULE: ./src/config.ts + 2 modules
var config = __webpack_require__(5151);
// EXTERNAL MODULE: ./src/errors/format_error.ts
var format_error = __webpack_require__(874);
// EXTERNAL MODULE: ./src/errors/media_error.ts
var media_error = __webpack_require__(5575);
// EXTERNAL MODULE: ./src/errors/error_codes.ts
var error_codes = __webpack_require__(5497);
// EXTERNAL MODULE: ./src/utils/is_null_or_undefined.ts
var is_null_or_undefined = __webpack_require__(6787);
// EXTERNAL MODULE: ./src/features/features_object.ts
var features_object = __webpack_require__(8589);
;// CONCATENATED MODULE: ./src/features/add_features.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIE OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @param {Array.<Object>} featureFuncList
 */
function add_features_addFeatures(featureFuncList) {
  for (var i = 0; i < featureFuncList.length; i++) {
    var addFeature = featureFuncList[i];
    if (typeof addFeature === "function") {
      addFeature(features_object/* default */.A);
    } else if (!(0,is_null_or_undefined/* default */.A)(addFeature) && typeof addFeature._addFeature === "function") {
      addFeature._addFeature(features_object/* default */.A);
    } else {
      throw new Error("Unrecognized feature");
    }
  }
}
// EXTERNAL MODULE: ./src/features/index.ts
var features = __webpack_require__(418);
// EXTERNAL MODULE: ./src/utils/are_arrays_of_numbers_equal.ts
var are_arrays_of_numbers_equal = __webpack_require__(987);
// EXTERNAL MODULE: ./src/utils/array_includes.ts
var array_includes = __webpack_require__(4031);
// EXTERNAL MODULE: ./src/utils/assert.ts
var src_assert = __webpack_require__(7994);
// EXTERNAL MODULE: ./src/utils/event_emitter.ts
var event_emitter = __webpack_require__(79);
// EXTERNAL MODULE: ./src/utils/id_generator.ts
var id_generator = __webpack_require__(8795);
// EXTERNAL MODULE: ./src/utils/object_assign.ts
var object_assign = __webpack_require__(8935);
// EXTERNAL MODULE: ./src/utils/ranges.ts
var ranges = __webpack_require__(3650);
// EXTERNAL MODULE: ./src/utils/reference.ts
var reference = __webpack_require__(8315);
// EXTERNAL MODULE: ./src/utils/task_canceller.ts
var task_canceller = __webpack_require__(2507);
// EXTERNAL MODULE: ./src/utils/warn_once.ts
var warn_once = __webpack_require__(5950);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js
var asyncToGenerator = __webpack_require__(467);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/regenerator/index.js
var regenerator = __webpack_require__(4756);
var regenerator_default = /*#__PURE__*/__webpack_require__.n(regenerator);
// EXTERNAL MODULE: ./src/utils/sleep.ts
var sleep = __webpack_require__(8801);
// EXTERNAL MODULE: ./src/core/decrypt/utils/media_keys_infos_store.ts
var media_keys_infos_store = __webpack_require__(7365);
;// CONCATENATED MODULE: ./src/core/decrypt/dispose_decryption_resources.ts


/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Free up all ressources taken by the content decryption logic.
 * @param {HTMLMediaElement} mediaElement
 * @returns {Promise}
 */
function disposeDecryptionResources(_x) {
  return _disposeDecryptionResources.apply(this, arguments);
}
function _disposeDecryptionResources() {
  _disposeDecryptionResources = (0,asyncToGenerator/* default */.A)( /*#__PURE__*/regenerator_default().mark(function _callee(mediaElement) {
    var currentState, loadedSessionsStore;
    return regenerator_default().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          currentState = media_keys_infos_store/* default */.A.getState(mediaElement);
          if (!(currentState === null)) {
            _context.next = 3;
            break;
          }
          return _context.abrupt("return", undefined);
        case 3:
          src_log/* default */.A.info("DRM: Disposing of the current MediaKeys");
          loadedSessionsStore = currentState.loadedSessionsStore;
          media_keys_infos_store/* default */.A.clearState(mediaElement);
          _context.next = 8;
          return loadedSessionsStore.closeAllSessions();
        case 8:
          return _context.abrupt("return", Promise.race([currentState.emeImplementation.setMediaKeys(mediaElement, null)["catch"](function (err) {
            src_log/* default */.A.error("DRM: Could not reset MediaKeys", err instanceof Error ? err : "Unknown Error");
          }),
          // Because we know how much EME has implementation issues, let's not block
          // everything because that API hangs
          (0,sleep/* default */.A)(1000)]));
        case 9:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return _disposeDecryptionResources.apply(this, arguments);
}
// EXTERNAL MODULE: ./src/core/decrypt/get_key_system_configuration.ts
var get_key_system_configuration = __webpack_require__(5283);
;// CONCATENATED MODULE: ./src/compat/should_unset_media_keys.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns true if the mediakeys associated to a media element should be
 * unset once the content is stopped.
 * Depends on the target.
 * @returns {Boolean}
 */
function shouldUnsetMediaKeys() {
  return browser_detection/* isIE11 */.lw;
}
;// CONCATENATED MODULE: ./src/core/decrypt/clear_on_stop.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Clear DRM-related resources that should be cleared when the current content
 * stops its playback.
 * @param {HTMLMediaElement} mediaElement
 * @returns {Promise}
 */
function clearOnStop(mediaElement) {
  src_log/* default */.A.info("DRM: Clearing-up DRM session.");
  if (shouldUnsetMediaKeys()) {
    src_log/* default */.A.info("DRM: disposing current MediaKeys.");
    return disposeDecryptionResources(mediaElement);
  }
  var currentState = media_keys_infos_store/* default */.A.getState(mediaElement);
  if (currentState !== null && currentState.keySystemOptions.closeSessionsOnStop === true) {
    src_log/* default */.A.info("DRM: closing all current sessions.");
    return currentState.loadedSessionsStore.closeAllSessions();
  }
  src_log/* default */.A.info("DRM: Nothing to clear. Returning right away. No state =", currentState === null);
  return Promise.resolve();
}
// EXTERNAL MODULE: ./src/utils/languages/normalize.ts + 2 modules
var normalize = __webpack_require__(4971);
;// CONCATENATED MODULE: ./src/core/api/option_utils.ts
function _createForOfIteratorHelperLoose(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (t) return (t = t.call(r)).next.bind(t); if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var o = 0; return function () { return o >= r.length ? { done: !0 } : { done: !1, value: r[o++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * This file exports various helpers to parse options given to various APIs,
 * throw if something is wrong, and return a normalized option object.
 */







/**
 * Parse options given to the API constructor and set default options as found
 * in the config.
 *
 * Do not mutate anything, only cross the given options and sane default options
 * (most coming from the config).
 * @param {Object|undefined} options
 * @returns {Object}
 */
function parseConstructorOptions(options) {
  var maxBufferAhead;
  var maxBufferBehind;
  var wantedBufferAhead;
  var maxVideoBufferSize;
  var throttleWhenHidden;
  var throttleVideoBitrateWhenHidden;
  var preferredAudioTracks;
  var preferredTextTracks;
  var preferredVideoTracks;
  var videoElement;
  var initialVideoBitrate;
  var initialAudioBitrate;
  var minAudioBitrate;
  var minVideoBitrate;
  var maxAudioBitrate;
  var maxVideoBitrate;
  var _config$getCurrent = config/* default */.A.getCurrent(),
    DEFAULT_INITIAL_BITRATES = _config$getCurrent.DEFAULT_INITIAL_BITRATES,
    DEFAULT_LIMIT_VIDEO_WIDTH = _config$getCurrent.DEFAULT_LIMIT_VIDEO_WIDTH,
    DEFAULT_MIN_BITRATES = _config$getCurrent.DEFAULT_MIN_BITRATES,
    DEFAULT_MAX_BITRATES = _config$getCurrent.DEFAULT_MAX_BITRATES,
    DEFAULT_MAX_BUFFER_AHEAD = _config$getCurrent.DEFAULT_MAX_BUFFER_AHEAD,
    DEFAULT_MAX_BUFFER_BEHIND = _config$getCurrent.DEFAULT_MAX_BUFFER_BEHIND,
    DEFAULT_MAX_VIDEO_BUFFER_SIZE = _config$getCurrent.DEFAULT_MAX_VIDEO_BUFFER_SIZE,
    DEFAULT_STOP_AT_END = _config$getCurrent.DEFAULT_STOP_AT_END,
    DEFAULT_THROTTLE_WHEN_HIDDEN = _config$getCurrent.DEFAULT_THROTTLE_WHEN_HIDDEN,
    DEFAULT_THROTTLE_VIDEO_BITRATE_WHEN_HIDDEN = _config$getCurrent.DEFAULT_THROTTLE_VIDEO_BITRATE_WHEN_HIDDEN,
    DEFAULT_WANTED_BUFFER_AHEAD = _config$getCurrent.DEFAULT_WANTED_BUFFER_AHEAD;
  if ((0,is_null_or_undefined/* default */.A)(options.maxBufferAhead)) {
    maxBufferAhead = DEFAULT_MAX_BUFFER_AHEAD;
  } else {
    maxBufferAhead = Number(options.maxBufferAhead);
    if (isNaN(maxBufferAhead)) {
      throw new Error("Invalid maxBufferAhead parameter. Should be a number.");
    }
  }
  if ((0,is_null_or_undefined/* default */.A)(options.maxBufferBehind)) {
    maxBufferBehind = DEFAULT_MAX_BUFFER_BEHIND;
  } else {
    maxBufferBehind = Number(options.maxBufferBehind);
    if (isNaN(maxBufferBehind)) {
      throw new Error("Invalid maxBufferBehind parameter. Should be a number.");
    }
  }
  if ((0,is_null_or_undefined/* default */.A)(options.wantedBufferAhead)) {
    wantedBufferAhead = DEFAULT_WANTED_BUFFER_AHEAD;
  } else {
    wantedBufferAhead = Number(options.wantedBufferAhead);
    if (isNaN(wantedBufferAhead)) {
      /* eslint-disable max-len */
      throw new Error("Invalid wantedBufferAhead parameter. Should be a number.");
      /* eslint-enable max-len */
    }
  }
  if ((0,is_null_or_undefined/* default */.A)(options.maxVideoBufferSize)) {
    maxVideoBufferSize = DEFAULT_MAX_VIDEO_BUFFER_SIZE;
  } else {
    maxVideoBufferSize = Number(options.maxVideoBufferSize);
    if (isNaN(maxVideoBufferSize)) {
      /* eslint-disable max-len */
      throw new Error("Invalid maxVideoBufferSize parameter. Should be a number.");
      /* eslint-enable max-len */
    }
  }
  var limitVideoWidth = (0,is_null_or_undefined/* default */.A)(options.limitVideoWidth) ? DEFAULT_LIMIT_VIDEO_WIDTH : !!options.limitVideoWidth;
  if (!(0,is_null_or_undefined/* default */.A)(options.throttleWhenHidden)) {
    (0,warn_once/* default */.A)("`throttleWhenHidden` API is deprecated. Consider using " + "`throttleVideoBitrateWhenHidden` instead.");
    throttleWhenHidden = !!options.throttleWhenHidden;
  } else {
    throttleWhenHidden = DEFAULT_THROTTLE_WHEN_HIDDEN;
  }
  // `throttleWhenHidden` and `throttleVideoBitrateWhenHidden` can be in conflict
  // Do not activate the latter if the former is
  if (throttleWhenHidden) {
    throttleVideoBitrateWhenHidden = false;
  } else {
    throttleVideoBitrateWhenHidden = (0,is_null_or_undefined/* default */.A)(options.throttleVideoBitrateWhenHidden) ? DEFAULT_THROTTLE_VIDEO_BITRATE_WHEN_HIDDEN : !!options.throttleVideoBitrateWhenHidden;
  }
  if (options.preferredTextTracks !== undefined) {
    if (!Array.isArray(options.preferredTextTracks)) {
      (0,warn_once/* default */.A)("Invalid `preferredTextTracks` option, it should be an Array");
      preferredTextTracks = [];
    } else {
      preferredTextTracks = options.preferredTextTracks;
    }
  } else {
    preferredTextTracks = [];
  }
  if (options.preferredAudioTracks !== undefined) {
    if (!Array.isArray(options.preferredAudioTracks)) {
      (0,warn_once/* default */.A)("Invalid `preferredAudioTracks` option, it should be an Array");
      preferredAudioTracks = [];
    } else {
      preferredAudioTracks = options.preferredAudioTracks;
    }
  } else {
    preferredAudioTracks = [];
  }
  if (options.preferredVideoTracks !== undefined) {
    if (!Array.isArray(options.preferredVideoTracks)) {
      (0,warn_once/* default */.A)("Invalid `preferredVideoTracks` option, it should be an Array");
      preferredVideoTracks = [];
    } else {
      preferredVideoTracks = options.preferredVideoTracks;
    }
  } else {
    preferredVideoTracks = [];
  }
  if ((0,is_null_or_undefined/* default */.A)(options.videoElement)) {
    videoElement = document.createElement("video");
  } else if (options.videoElement instanceof HTMLMediaElement) {
    videoElement = options.videoElement;
  } else {
    /* eslint-disable max-len */
    throw new Error("Invalid videoElement parameter. Should be a HTMLMediaElement.");
    /* eslint-enable max-len */
  }
  if ((0,is_null_or_undefined/* default */.A)(options.initialVideoBitrate)) {
    initialVideoBitrate = DEFAULT_INITIAL_BITRATES.video;
  } else {
    initialVideoBitrate = Number(options.initialVideoBitrate);
    if (isNaN(initialVideoBitrate)) {
      /* eslint-disable max-len */
      throw new Error("Invalid initialVideoBitrate parameter. Should be a number.");
      /* eslint-enable max-len */
    }
  }
  if ((0,is_null_or_undefined/* default */.A)(options.initialAudioBitrate)) {
    initialAudioBitrate = DEFAULT_INITIAL_BITRATES.audio;
  } else {
    initialAudioBitrate = Number(options.initialAudioBitrate);
    if (isNaN(initialAudioBitrate)) {
      /* eslint-disable max-len */
      throw new Error("Invalid initialAudioBitrate parameter. Should be a number.");
      /* eslint-enable max-len */
    }
  }
  if ((0,is_null_or_undefined/* default */.A)(options.minVideoBitrate)) {
    minVideoBitrate = DEFAULT_MIN_BITRATES.video;
  } else {
    minVideoBitrate = Number(options.minVideoBitrate);
    if (isNaN(minVideoBitrate)) {
      throw new Error("Invalid maxVideoBitrate parameter. Should be a number.");
    }
  }
  if ((0,is_null_or_undefined/* default */.A)(options.minAudioBitrate)) {
    minAudioBitrate = DEFAULT_MIN_BITRATES.audio;
  } else {
    minAudioBitrate = Number(options.minAudioBitrate);
    if (isNaN(minAudioBitrate)) {
      throw new Error("Invalid minAudioBitrate parameter. Should be a number.");
    }
  }
  if ((0,is_null_or_undefined/* default */.A)(options.maxVideoBitrate)) {
    maxVideoBitrate = DEFAULT_MAX_BITRATES.video;
  } else {
    maxVideoBitrate = Number(options.maxVideoBitrate);
    if (isNaN(maxVideoBitrate)) {
      throw new Error("Invalid maxVideoBitrate parameter. Should be a number.");
    } else if (minVideoBitrate > maxVideoBitrate) {
      throw new Error('Invalid maxVideoBitrate parameter. Its value, "' + (maxVideoBitrate + "\", is inferior to the set minVideoBitrate, \"") + (minVideoBitrate + "\""));
    }
  }
  if ((0,is_null_or_undefined/* default */.A)(options.maxAudioBitrate)) {
    maxAudioBitrate = DEFAULT_MAX_BITRATES.audio;
  } else {
    maxAudioBitrate = Number(options.maxAudioBitrate);
    if (isNaN(maxAudioBitrate)) {
      throw new Error("Invalid maxAudioBitrate parameter. Should be a number.");
    } else if (minAudioBitrate > maxAudioBitrate) {
      throw new Error('Invalid maxAudioBitrate parameter. Its value, "' + (maxAudioBitrate + "\", is inferior to the set minAudioBitrate, \"") + (minAudioBitrate + "\""));
    }
  }
  var stopAtEnd = (0,is_null_or_undefined/* default */.A)(options.stopAtEnd) ? DEFAULT_STOP_AT_END : !!options.stopAtEnd;
  return {
    maxBufferAhead: maxBufferAhead,
    maxBufferBehind: maxBufferBehind,
    limitVideoWidth: limitVideoWidth,
    videoElement: videoElement,
    wantedBufferAhead: wantedBufferAhead,
    maxVideoBufferSize: maxVideoBufferSize,
    throttleWhenHidden: throttleWhenHidden,
    throttleVideoBitrateWhenHidden: throttleVideoBitrateWhenHidden,
    preferredAudioTracks: preferredAudioTracks,
    preferredTextTracks: preferredTextTracks,
    preferredVideoTracks: preferredVideoTracks,
    initialAudioBitrate: initialAudioBitrate,
    initialVideoBitrate: initialVideoBitrate,
    minAudioBitrate: minAudioBitrate,
    minVideoBitrate: minVideoBitrate,
    maxAudioBitrate: maxAudioBitrate,
    maxVideoBitrate: maxVideoBitrate,
    stopAtEnd: stopAtEnd
  };
}
/**
 * Check the format of given reload options.
 * Throw if format in invalid.
 * @param {object | undefined} options
 */
function checkReloadOptions(options) {
  var _a, _b, _c, _d;
  if (options === null || typeof options !== "object" && options !== undefined) {
    throw new Error("API: reload - Invalid options format.");
  }
  if ((options === null || options === void 0 ? void 0 : options.reloadAt) === null || typeof (options === null || options === void 0 ? void 0 : options.reloadAt) !== "object" && (options === null || options === void 0 ? void 0 : options.reloadAt) !== undefined) {
    throw new Error("API: reload - Invalid 'reloadAt' option format.");
  }
  if (typeof ((_a = options === null || options === void 0 ? void 0 : options.reloadAt) === null || _a === void 0 ? void 0 : _a.position) !== "number" && ((_b = options === null || options === void 0 ? void 0 : options.reloadAt) === null || _b === void 0 ? void 0 : _b.position) !== undefined) {
    throw new Error("API: reload - Invalid 'reloadAt.position' option format.");
  }
  if (typeof ((_c = options === null || options === void 0 ? void 0 : options.reloadAt) === null || _c === void 0 ? void 0 : _c.relative) !== "number" && ((_d = options === null || options === void 0 ? void 0 : options.reloadAt) === null || _d === void 0 ? void 0 : _d.relative) !== undefined) {
    throw new Error("API: reload - Invalid 'reloadAt.relative' option format.");
  }
  if (!Array.isArray(options === null || options === void 0 ? void 0 : options.keySystems) && (options === null || options === void 0 ? void 0 : options.keySystems) !== undefined) {
    throw new Error("API: reload - Invalid 'keySystems' option format.");
  }
  if ((options === null || options === void 0 ? void 0 : options.autoPlay) !== undefined && typeof options.autoPlay !== "boolean") {
    throw new Error("API: reload - Invalid 'autoPlay' option format.");
  }
}
/**
 * Parse options given to loadVideo and set default options as found
 * in the config.
 *
 * Do not mutate anything, only cross the given options and sane default options
 * (most coming from the config).
 *
 * Throws if any mandatory option is not set.
 * @param {Object|undefined} options
 * @param {Object} ctx - The player context, needed for some default values.
 * @returns {Object}
 */
function parseLoadVideoOptions(options) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j;
  var url;
  var transport;
  var keySystems;
  var textTrackMode;
  var textTrackElement;
  var startAt;
  var _config$getCurrent2 = config/* default */.A.getCurrent(),
    DEFAULT_AUDIO_TRACK_SWITCHING_MODE = _config$getCurrent2.DEFAULT_AUDIO_TRACK_SWITCHING_MODE,
    DEFAULT_AUTO_PLAY = _config$getCurrent2.DEFAULT_AUTO_PLAY,
    DEFAULT_CODEC_SWITCHING_BEHAVIOR = _config$getCurrent2.DEFAULT_CODEC_SWITCHING_BEHAVIOR,
    DEFAULT_ENABLE_FAST_SWITCHING = _config$getCurrent2.DEFAULT_ENABLE_FAST_SWITCHING,
    DEFAULT_MANUAL_BITRATE_SWITCHING_MODE = _config$getCurrent2.DEFAULT_MANUAL_BITRATE_SWITCHING_MODE,
    DEFAULT_SHOW_NATIVE_SUBTITLE = _config$getCurrent2.DEFAULT_SHOW_NATIVE_SUBTITLE,
    DEFAULT_TEXT_TRACK_MODE = _config$getCurrent2.DEFAULT_TEXT_TRACK_MODE;
  if ((0,is_null_or_undefined/* default */.A)(options)) {
    throw new Error("No option set on loadVideo");
  }
  if (!(0,is_null_or_undefined/* default */.A)(options.url)) {
    url = String(options.url);
  } else if ((0,is_null_or_undefined/* default */.A)((_a = options.transportOptions) === null || _a === void 0 ? void 0 : _a.initialManifest) && (0,is_null_or_undefined/* default */.A)((_b = options.transportOptions) === null || _b === void 0 ? void 0 : _b.manifestLoader)) {
    throw new Error("Unable to load a content: no url set on loadVideo.\n" + "Please provide at least either an `url` argument, a " + "`transportOptions.initialManifest` option or a " + "`transportOptions.manifestLoader` option so the RxPlayer " + "can load the content.");
  }
  if ((0,is_null_or_undefined/* default */.A)(options.transport)) {
    throw new Error("No transport set on loadVideo");
  } else {
    transport = String(options.transport);
  }
  if (!(0,is_null_or_undefined/* default */.A)((_c = options.transportOptions) === null || _c === void 0 ? void 0 : _c.aggressiveMode)) {
    (0,warn_once/* default */.A)("`transportOptions.aggressiveMode` is deprecated and won't " + "be present in the next major version. " + "Please open an issue if you still need this.");
  }
  var autoPlay = (0,is_null_or_undefined/* default */.A)(options.autoPlay) ? DEFAULT_AUTO_PLAY : !!options.autoPlay;
  if ((0,is_null_or_undefined/* default */.A)(options.keySystems)) {
    keySystems = [];
  } else {
    keySystems = Array.isArray(options.keySystems) ? options.keySystems : [options.keySystems];
    for (var _iterator = _createForOfIteratorHelperLoose(keySystems), _step; !(_step = _iterator()).done;) {
      var keySystem = _step.value;
      if (typeof keySystem.type !== "string" || typeof keySystem.getLicense !== "function") {
        throw new Error("Invalid key system given: Missing type string or " + "getLicense callback");
      }
      if (!(0,is_null_or_undefined/* default */.A)(keySystem.onKeyStatusesChange)) {
        (0,warn_once/* default */.A)("`keySystems[].onKeyStatusesChange` is deprecated and won't " + "be present in the next major version. " + "Please open an issue if you still need this.");
      }
      if (!(0,is_null_or_undefined/* default */.A)(keySystem.throwOnLicenseExpiration)) {
        (0,warn_once/* default */.A)("`keySystems[].throwOnLicenseExpiration` is deprecated and won't " + "be present in the next major version. " + "Please open an issue if you still need this.");
      }
    }
  }
  var lowLatencyMode = options.lowLatencyMode === undefined ? false : !!options.lowLatencyMode;
  var transportOptsArg = typeof options.transportOptions === "object" && options.transportOptions !== null ? options.transportOptions : {};
  var initialManifest = (_d = options.transportOptions) === null || _d === void 0 ? void 0 : _d.initialManifest;
  var minimumManifestUpdateInterval = (_f = (_e = options.transportOptions) === null || _e === void 0 ? void 0 : _e.minimumManifestUpdateInterval) !== null && _f !== void 0 ? _f : 0;
  var audioTrackSwitchingMode = (0,is_null_or_undefined/* default */.A)(options.audioTrackSwitchingMode) ? DEFAULT_AUDIO_TRACK_SWITCHING_MODE : options.audioTrackSwitchingMode;
  if (!(0,array_includes/* default */.A)(["seamless", "direct", "reload"], audioTrackSwitchingMode)) {
    src_log/* default */.A.warn("The `audioTrackSwitchingMode` loadVideo option must match one of " + "the following strategy name:\n" + "- `seamless`\n" + "- `direct`\n" + "- `reload`\n" + "If badly set, " + DEFAULT_AUDIO_TRACK_SWITCHING_MODE + " strategy will be used as default");
    audioTrackSwitchingMode = DEFAULT_AUDIO_TRACK_SWITCHING_MODE;
  }
  var onCodecSwitch = (0,is_null_or_undefined/* default */.A)(options.onCodecSwitch) ? DEFAULT_CODEC_SWITCHING_BEHAVIOR : options.onCodecSwitch;
  if (!(0,array_includes/* default */.A)(["continue", "reload"], onCodecSwitch)) {
    src_log/* default */.A.warn("The `onCodecSwitch` loadVideo option must match one of " + "the following string:\n" + "- `continue`\n" + "- `reload`\n" + "If badly set, " + DEFAULT_CODEC_SWITCHING_BEHAVIOR + " will be used as default");
    onCodecSwitch = DEFAULT_CODEC_SWITCHING_BEHAVIOR;
  }
  var transportOptions = (0,object_assign/* default */.A)({}, transportOptsArg, {
    /* eslint-disable import/no-deprecated */
    supplementaryImageTracks: [],
    supplementaryTextTracks: [],
    /* eslint-enable import/no-deprecated */
    lowLatencyMode: lowLatencyMode
  });
  // remove already parsed data to simplify the `transportOptions` object
  delete transportOptions.initialManifest;
  delete transportOptions.minimumManifestUpdateInterval;
  if (options.supplementaryTextTracks !== undefined) {
    (0,warn_once/* default */.A)("The `supplementaryTextTracks` loadVideo option is deprecated.\n" + "Please use the `TextTrackRenderer` tool instead.");
    var supplementaryTextTracks = Array.isArray(options.supplementaryTextTracks) ? options.supplementaryTextTracks : [options.supplementaryTextTracks];
    for (var _iterator2 = _createForOfIteratorHelperLoose(supplementaryTextTracks), _step2; !(_step2 = _iterator2()).done;) {
      var supplementaryTextTrack = _step2.value;
      if (typeof supplementaryTextTrack.language !== "string" || typeof supplementaryTextTrack.mimeType !== "string" || typeof supplementaryTextTrack.url !== "string") {
        throw new Error("Invalid supplementary text track given. " + "Missing either language, mimetype or url");
      }
    }
    transportOptions.supplementaryTextTracks = supplementaryTextTracks;
  }
  if (options.supplementaryImageTracks !== undefined) {
    (0,warn_once/* default */.A)("The `supplementaryImageTracks` loadVideo option is deprecated.\n" + "Please use the `parseBifThumbnails` tool instead.");
    var supplementaryImageTracks = Array.isArray(options.supplementaryImageTracks) ? options.supplementaryImageTracks : [options.supplementaryImageTracks];
    for (var _iterator3 = _createForOfIteratorHelperLoose(supplementaryImageTracks), _step3; !(_step3 = _iterator3()).done;) {
      var supplementaryImageTrack = _step3.value;
      if (typeof supplementaryImageTrack.mimeType !== "string" || typeof supplementaryImageTrack.url !== "string") {
        throw new Error("Invalid supplementary image track given. " + "Missing either mimetype or url");
      }
    }
    transportOptions.supplementaryImageTracks = supplementaryImageTracks;
  }
  if (!(0,is_null_or_undefined/* default */.A)((_g = options.transportOptions) === null || _g === void 0 ? void 0 : _g.manifestUpdateUrl)) {
    (0,warn_once/* default */.A)("`manifestUpdateUrl` API is deprecated, please open an issue if you" + " still rely on this.");
  }
  if ((0,is_null_or_undefined/* default */.A)(options.textTrackMode)) {
    textTrackMode = DEFAULT_TEXT_TRACK_MODE;
  } else {
    if (options.textTrackMode !== "native" && options.textTrackMode !== "html") {
      throw new Error("Invalid textTrackMode.");
    }
    textTrackMode = options.textTrackMode;
  }
  if (!(0,is_null_or_undefined/* default */.A)(options.defaultAudioTrack)) {
    (0,warn_once/* default */.A)("The `defaultAudioTrack` loadVideo option is deprecated.\n" + "Please use the `preferredAudioTracks` constructor option or the" + "`setPreferredAudioTracks` method instead");
  }
  var defaultAudioTrack = (0,normalize/* normalizeAudioTrack */.BU)(options.defaultAudioTrack);
  if (!(0,is_null_or_undefined/* default */.A)(options.defaultTextTrack)) {
    (0,warn_once/* default */.A)("The `defaultTextTrack` loadVideo option is deprecated.\n" + "Please use the `preferredTextTracks` constructor option or the" + "`setPreferredTextTracks` method instead");
  }
  var defaultTextTrack = (0,normalize/* normalizeTextTrack */.E4)(options.defaultTextTrack);
  var hideNativeSubtitle = !DEFAULT_SHOW_NATIVE_SUBTITLE;
  if (!(0,is_null_or_undefined/* default */.A)(options.hideNativeSubtitle)) {
    (0,warn_once/* default */.A)("The `hideNativeSubtitle` loadVideo option is deprecated");
    hideNativeSubtitle = !!options.hideNativeSubtitle;
  }
  var manualBitrateSwitchingMode = (_h = options.manualBitrateSwitchingMode) !== null && _h !== void 0 ? _h : DEFAULT_MANUAL_BITRATE_SWITCHING_MODE;
  var enableFastSwitching = (0,is_null_or_undefined/* default */.A)(options.enableFastSwitching) ? DEFAULT_ENABLE_FAST_SWITCHING : options.enableFastSwitching;
  if (textTrackMode === "html") {
    // TODO Better way to express that in TypeScript?
    if ((0,is_null_or_undefined/* default */.A)(options.textTrackElement)) {
      throw new Error("You have to provide a textTrackElement " + 'in "html" textTrackMode.');
    } else if (!(options.textTrackElement instanceof HTMLElement)) {
      throw new Error("textTrackElement should be an HTMLElement.");
    } else {
      textTrackElement = options.textTrackElement;
    }
  } else if (!(0,is_null_or_undefined/* default */.A)(options.textTrackElement)) {
    src_log/* default */.A.warn("API: You have set a textTrackElement without being in " + 'an "html" textTrackMode. It will be ignored.');
  }
  if (!(0,is_null_or_undefined/* default */.A)(options.startAt)) {
    if ("wallClockTime" in options.startAt && options.startAt.wallClockTime instanceof Date) {
      var wallClockTime = options.startAt.wallClockTime.getTime() / 1000;
      startAt = (0,object_assign/* default */.A)({}, options.startAt, {
        wallClockTime: wallClockTime
      });
    } else {
      startAt = options.startAt;
    }
  }
  var networkConfig = (_j = options.networkConfig) !== null && _j !== void 0 ? _j : {};
  // TODO without cast
  /* eslint-disable @typescript-eslint/consistent-type-assertions */
  return {
    autoPlay: autoPlay,
    defaultAudioTrack: defaultAudioTrack,
    defaultTextTrack: defaultTextTrack,
    enableFastSwitching: enableFastSwitching,
    hideNativeSubtitle: hideNativeSubtitle,
    keySystems: keySystems,
    initialManifest: initialManifest,
    lowLatencyMode: lowLatencyMode,
    manualBitrateSwitchingMode: manualBitrateSwitchingMode,
    audioTrackSwitchingMode: audioTrackSwitchingMode,
    minimumManifestUpdateInterval: minimumManifestUpdateInterval,
    networkConfig: networkConfig,
    onCodecSwitch: onCodecSwitch,
    startAt: startAt,
    textTrackElement: textTrackElement,
    textTrackMode: textTrackMode,
    transport: transport,
    transportOptions: transportOptions,
    url: url
  };
  /* eslint-enable @typescript-eslint/consistent-type-assertions */
}

// EXTERNAL MODULE: ./src/utils/noop.ts
var noop = __webpack_require__(8060);
;// CONCATENATED MODULE: ./src/core/api/playback_observer.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */







/**
 * HTMLMediaElement Events for which playback observations are calculated and
 * emitted.
 * @type {Array.<string>}
 */
var SCANNED_MEDIA_ELEMENTS_EVENTS = ["canplay", "ended", "play", "pause", "seeking", "seeked", "loadedmetadata", "ratechange"];
/**
 * Class allowing to "observe" current playback conditions so the RxPlayer is
 * then able to react upon them.
 *
 * This is a central class of the RxPlayer as many modules rely on the
 * `PlaybackObserver` to know the current state of the media being played.
 *
 * You can use the PlaybackObserver to either get the last observation
 * performed, get the current media state or listen to media observation sent
 * at a regular interval.
 *
 * @class {PlaybackObserver}
 */
var PlaybackObserver = /*#__PURE__*/function () {
  /**
   * Create a new `PlaybackObserver`, which allows to produce new "playback
   * observations" on various media events and intervals.
   *
   * Note that creating a `PlaybackObserver` lead to the usage of resources,
   * such as event listeners which will only be freed once the `stop` method is
   * called.
   * @param {HTMLMediaElement} mediaElement
   * @param {Object} options
   */
  function PlaybackObserver(mediaElement, options) {
    this._internalSeeksIncoming = [];
    this._mediaElement = mediaElement;
    this._withMediaSource = options.withMediaSource;
    this._lowLatencyMode = options.lowLatencyMode;
    this._canceller = new task_canceller/* default */.Ay();
    this._observationRef = this._createSharedReference();
  }
  /**
   * Stop the `PlaybackObserver` from emitting playback observations and free all
   * resources reserved to emitting them such as event listeners and intervals.
   *
   * Once `stop` is called, no new playback observation will ever be emitted.
   *
   * Note that it is important to call stop once the `PlaybackObserver` is no
   * more needed to avoid unnecessarily leaking resources.
   */
  var _proto = PlaybackObserver.prototype;
  _proto.stop = function stop() {
    this._canceller.cancel();
  }
  /**
   * Returns the current position advertised by the `HTMLMediaElement`, in
   * seconds.
   * @returns {number}
   */;
  _proto.getCurrentTime = function getCurrentTime() {
    return this._mediaElement.currentTime;
  }
  /**
   * Returns the current playback rate advertised by the `HTMLMediaElement`.
   * @returns {number}
   */;
  _proto.getPlaybackRate = function getPlaybackRate() {
    return this._mediaElement.playbackRate;
  }
  /**
   * Returns the current `paused` status advertised by the `HTMLMediaElement`.
   *
   * Use this instead of the same status emitted on an observation when you want
   * to be sure you're using the current value.
   * @returns {boolean}
   */;
  _proto.getIsPaused = function getIsPaused() {
    return this._mediaElement.paused;
  }
  /**
   * Update the current position (seek) on the `HTMLMediaElement`, by giving a
   * new position in seconds.
   *
   * Note that seeks performed through this method are caracherized as
   * "internal" seeks. They don't result into the exact same playback
   * observation than regular seeks (which most likely comes from the outside,
   * e.g. the user).
   * @param {number} time
   */;
  _proto.setCurrentTime = function setCurrentTime(time) {
    this._internalSeeksIncoming.push(time);
    src_log/* default */.A.info("API: Seeking internally", time);
    this._mediaElement.currentTime = time;
  }
  /**
   * Update the playback rate of the `HTMLMediaElement`.
   * @param {number} playbackRate
   */;
  _proto.setPlaybackRate = function setPlaybackRate(playbackRate) {
    this._mediaElement.playbackRate = playbackRate;
  }
  /**
   * Returns the current `readyState` advertised by the `HTMLMediaElement`.
   * @returns {number}
   */;
  _proto.getReadyState = function getReadyState() {
    return this._mediaElement.readyState;
  }
  /**
   * Returns an `IReadOnlySharedReference` storing the last playback observation
   * produced by the `PlaybackObserver` and updated each time a new one is
   * produced.
   *
   * This value can then be for example listened to to be notified of future
   * playback observations.
   *
   * @returns {Object}
   */;
  _proto.getReference = function getReference() {
    return this._observationRef;
  }
  /**
   * Register a callback so it regularly receives playback observations.
   * @param {Function} cb
   * @param {Object} options - Configuration options:
   *   - `includeLastObservation`: If set to `true` the last observation will
   *     be first emitted synchronously.
   *   - `clearSignal`: If set, the callback will be unregistered when this
   *     CancellationSignal emits.
   */;
  _proto.listen = function listen(cb, options) {
    var _a;
    if (this._canceller.isUsed() || ((_a = options === null || options === void 0 ? void 0 : options.clearSignal) === null || _a === void 0 ? void 0 : _a.isCancelled()) === true) {
      return noop/* default */.A;
    }
    this._observationRef.onUpdate(cb, {
      clearSignal: options === null || options === void 0 ? void 0 : options.clearSignal,
      emitCurrentValue: options === null || options === void 0 ? void 0 : options.includeLastObservation
    });
  }
  /**
   * Generate a new playback observer which can listen to other
   * properties and which can only be accessed to read observations (e.g.
   * it cannot ask to perform a seek).
   *
   * The object returned will respect the `IReadOnlyPlaybackObserver` interface
   * and will inherit this `PlaybackObserver`'s lifecycle: it will emit when
   * the latter emits.
   *
   * As argument, this method takes a function which will allow to produce
   * the new set of properties to be present on each observation.
   * @param {Function} transform
   * @returns {Object}
   */;
  _proto.deriveReadOnlyObserver = function deriveReadOnlyObserver(transform) {
    return generateReadOnlyObserver(this, transform, this._canceller.signal);
  }
  /**
   * Creates the `IReadOnlySharedReference` that will generate playback
   * observations.
   * @returns {Object}
   */;
  _proto._createSharedReference = function _createSharedReference() {
    var _this = this;
    if (this._observationRef !== undefined) {
      return this._observationRef;
    }
    var lastObservation;
    var _config$getCurrent = config/* default */.A.getCurrent(),
      SAMPLING_INTERVAL_MEDIASOURCE = _config$getCurrent.SAMPLING_INTERVAL_MEDIASOURCE,
      SAMPLING_INTERVAL_LOW_LATENCY = _config$getCurrent.SAMPLING_INTERVAL_LOW_LATENCY,
      SAMPLING_INTERVAL_NO_MEDIASOURCE = _config$getCurrent.SAMPLING_INTERVAL_NO_MEDIASOURCE;
    var getCurrentObservation = function getCurrentObservation(event) {
      var tmpEvt = event;
      var startedInternalSeekTime;
      if (tmpEvt === "seeking" && _this._internalSeeksIncoming.length > 0) {
        tmpEvt = "internal-seeking";
        startedInternalSeekTime = _this._internalSeeksIncoming.shift();
      }
      var _lastObservation = lastObservation !== null && lastObservation !== void 0 ? lastObservation : _this._generateInitialObservation();
      var mediaTimings = getMediaInfos(_this._mediaElement, tmpEvt, _this._withMediaSource);
      var pendingInternalSeek = null;
      if (mediaTimings.seeking) {
        if (typeof startedInternalSeekTime === "number") {
          pendingInternalSeek = startedInternalSeekTime;
        } else if (_lastObservation.pendingInternalSeek !== null && event !== "seeking") {
          pendingInternalSeek = _lastObservation.pendingInternalSeek;
        }
      }
      var rebufferingStatus = getRebufferingStatus(_lastObservation, mediaTimings, {
        lowLatencyMode: _this._lowLatencyMode,
        withMediaSource: _this._withMediaSource
      });
      var freezingStatus = getFreezingStatus(_lastObservation, mediaTimings);
      var timings = (0,object_assign/* default */.A)({}, {
        rebuffering: rebufferingStatus,
        freezing: freezingStatus,
        pendingInternalSeek: pendingInternalSeek
      }, mediaTimings);
      if (src_log/* default */.A.hasLevel("DEBUG")) {
        src_log/* default */.A.debug("API: current media element state tick", "event", timings.event, "position", timings.position, "seeking", timings.seeking, "internalSeek", timings.pendingInternalSeek, "rebuffering", timings.rebuffering !== null, "freezing", timings.freezing !== null, "ended", timings.ended, "paused", timings.paused, "playbackRate", timings.playbackRate, "readyState", timings.readyState);
      }
      return timings;
    };
    var returnedSharedReference = new reference/* default */.A(getCurrentObservation("init"), this._canceller.signal);
    var generateObservationForEvent = function generateObservationForEvent(event) {
      var newObservation = getCurrentObservation(event);
      if (src_log/* default */.A.hasLevel("DEBUG")) {
        src_log/* default */.A.debug("API: current playback timeline:\n" + prettyPrintBuffered(newObservation.buffered, newObservation.position), "\n" + event);
      }
      lastObservation = newObservation;
      returnedSharedReference.setValue(newObservation);
    };
    var interval = this._lowLatencyMode ? SAMPLING_INTERVAL_LOW_LATENCY : this._withMediaSource ? SAMPLING_INTERVAL_MEDIASOURCE : SAMPLING_INTERVAL_NO_MEDIASOURCE;
    var intervalId = setInterval(onInterval, interval);
    var removeEventListeners = SCANNED_MEDIA_ELEMENTS_EVENTS.map(function (eventName) {
      _this._mediaElement.addEventListener(eventName, onMediaEvent);
      function onMediaEvent() {
        restartInterval();
        generateObservationForEvent(eventName);
      }
      return function () {
        _this._mediaElement.removeEventListener(eventName, onMediaEvent);
      };
    });
    this._canceller.signal.register(function () {
      clearInterval(intervalId);
      removeEventListeners.forEach(function (cb) {
        return cb();
      });
      returnedSharedReference.finish();
    });
    return returnedSharedReference;
    function onInterval() {
      generateObservationForEvent("timeupdate");
    }
    function restartInterval() {
      clearInterval(intervalId);
      intervalId = setInterval(onInterval, interval);
    }
  };
  _proto._generateInitialObservation = function _generateInitialObservation() {
    return (0,object_assign/* default */.A)(getMediaInfos(this._mediaElement, "init", this._withMediaSource), {
      rebuffering: null,
      freezing: null,
      pendingInternalSeek: null
    });
  };
  return PlaybackObserver;
}();
/**
 * Returns the amount of time in seconds the buffer should have ahead of the
 * current position before resuming playback. Based on the infos of the
 * rebuffering status.
 *
 * Waiting time differs between a rebuffering happening after a "seek" or one
 * happening after a buffer starvation occured.
 * @param {Object|null} rebufferingStatus
 * @param {Boolean} lowLatencyMode
 * @returns {Number}
 */

function getRebufferingEndGap(rebufferingStatus, lowLatencyMode) {
  if (rebufferingStatus === null) {
    return 0;
  }
  var suffix = lowLatencyMode ? "LOW_LATENCY" : "DEFAULT";
  var _config$getCurrent2 = config/* default */.A.getCurrent(),
    RESUME_GAP_AFTER_SEEKING = _config$getCurrent2.RESUME_GAP_AFTER_SEEKING,
    RESUME_GAP_AFTER_NOT_ENOUGH_DATA = _config$getCurrent2.RESUME_GAP_AFTER_NOT_ENOUGH_DATA,
    RESUME_GAP_AFTER_BUFFERING = _config$getCurrent2.RESUME_GAP_AFTER_BUFFERING;
  switch (rebufferingStatus.reason) {
    case "seeking":
      return RESUME_GAP_AFTER_SEEKING[suffix];
    case "not-ready":
      return RESUME_GAP_AFTER_NOT_ENOUGH_DATA[suffix];
    case "buffering":
      return RESUME_GAP_AFTER_BUFFERING[suffix];
  }
}
/**
 * @param {Object} currentRange
 * @param {Number} duration
 * @param {Boolean} lowLatencyMode
 * @returns {Boolean}
 */
function hasLoadedUntilTheEnd(currentTime, currentRange, ended, duration, lowLatencyMode) {
  var _config$getCurrent3 = config/* default */.A.getCurrent(),
    REBUFFERING_GAP = _config$getCurrent3.REBUFFERING_GAP;
  var suffix = lowLatencyMode ? "LOW_LATENCY" : "DEFAULT";
  if (currentRange === undefined) {
    return ended && Math.abs(duration - currentTime) <= REBUFFERING_GAP[suffix];
  }
  return currentRange !== null && duration - currentRange.end <= REBUFFERING_GAP[suffix];
}
/**
 * Get basic playback information.
 * @param {HTMLMediaElement} mediaElement
 * @param {string} event
 * @returns {Object}
 */
function getMediaInfos(mediaElement, event, withMediaSource) {
  var buffered = mediaElement.buffered,
    currentTime = mediaElement.currentTime,
    duration = mediaElement.duration,
    ended = mediaElement.ended,
    paused = mediaElement.paused,
    playbackRate = mediaElement.playbackRate,
    readyState = mediaElement.readyState,
    seeking = mediaElement.seeking;
  var currentRange;
  var bufferGap;
  if (!withMediaSource && buffered.length === 0 && readyState >= 3) {
    // Sometimes `buffered` stay empty for directfile contents yet we are able
    // to play. This seems to be linked to browser-side issues but has been
    // encountered on enough platforms (Chrome desktop and PlayStation 4's
    // WebKit for us to do something about it in the player.
    currentRange = undefined;
    bufferGap = undefined;
  } else {
    currentRange = (0,ranges/* getRange */.eO)(buffered, currentTime);
    bufferGap = currentRange !== null ? currentRange.end - currentTime :
    // TODO null/0 would probably be
    // more appropriate
    Infinity;
  }
  return {
    bufferGap: bufferGap,
    buffered: buffered,
    currentRange: currentRange,
    position: currentTime,
    duration: duration,
    ended: ended,
    paused: paused,
    playbackRate: playbackRate,
    readyState: readyState,
    seeking: seeking,
    event: event
  };
}
/**
 * Infer rebuffering status of the media based on:
 *   - the return of the function getMediaInfos
 *   - the previous observation object.
 *
 * @param {Object} prevObservation - Previous playback observation object.
 * @param {Object} currentInfo - Current set of basic information on the
 * `HTMLMediaElement`. This does not need every single property from a regular
 * playback observation.
 * @param {Object} options
 * @returns {Object|null}
 */
function getRebufferingStatus(prevObservation, currentInfo, _ref) {
  var withMediaSource = _ref.withMediaSource,
    lowLatencyMode = _ref.lowLatencyMode;
  var _config$getCurrent4 = config/* default */.A.getCurrent(),
    REBUFFERING_GAP = _config$getCurrent4.REBUFFERING_GAP;
  var currentEvt = currentInfo.event,
    currentTime = currentInfo.position,
    bufferGap = currentInfo.bufferGap,
    currentRange = currentInfo.currentRange,
    duration = currentInfo.duration,
    paused = currentInfo.paused,
    readyState = currentInfo.readyState,
    ended = currentInfo.ended;
  var prevRebuffering = prevObservation.rebuffering,
    prevEvt = prevObservation.event,
    prevTime = prevObservation.position;
  var fullyLoaded = hasLoadedUntilTheEnd(currentTime, currentRange, ended, duration, lowLatencyMode);
  var canSwitchToRebuffering = readyState >= 1 && currentEvt !== "loadedmetadata" && prevRebuffering === null && !(fullyLoaded || ended);
  var rebufferEndPosition = null;
  var shouldRebuffer;
  var shouldStopRebuffer;
  var rebufferGap = lowLatencyMode ? REBUFFERING_GAP.LOW_LATENCY : REBUFFERING_GAP.DEFAULT;
  if (withMediaSource) {
    if (canSwitchToRebuffering) {
      if (bufferGap === Infinity) {
        shouldRebuffer = true;
        rebufferEndPosition = currentTime;
      } else if (bufferGap === undefined) {
        if (readyState < 3) {
          shouldRebuffer = true;
          rebufferEndPosition = undefined;
        }
      } else if (bufferGap <= rebufferGap) {
        shouldRebuffer = true;
        rebufferEndPosition = currentTime + bufferGap;
      }
    } else if (prevRebuffering !== null) {
      var resumeGap = getRebufferingEndGap(prevRebuffering, lowLatencyMode);
      if (shouldRebuffer !== true && prevRebuffering !== null && readyState > 1 && (fullyLoaded || ended || bufferGap !== undefined && isFinite(bufferGap) && bufferGap > resumeGap) || bufferGap === undefined && readyState >= 3) {
        shouldStopRebuffer = true;
      } else if (bufferGap === undefined) {
        rebufferEndPosition = undefined;
      } else if (bufferGap === Infinity) {
        rebufferEndPosition = currentTime;
      } else if (bufferGap <= resumeGap) {
        rebufferEndPosition = currentTime + bufferGap;
      }
    }
  }
  // when using a direct file, the media will stall and unstall on its
  // own, so we only try to detect when the media timestamp has not changed
  // between two consecutive timeupdates
  else {
    if (canSwitchToRebuffering && (!paused && currentEvt === "timeupdate" && prevEvt === "timeupdate" && currentTime === prevTime || currentEvt === "seeking" && (bufferGap === Infinity || bufferGap === undefined && readyState < 3))) {
      shouldRebuffer = true;
    } else if (prevRebuffering !== null && (currentEvt !== "seeking" && currentTime !== prevTime || currentEvt === "canplay" || bufferGap === undefined && readyState >= 3 || bufferGap !== undefined && bufferGap < Infinity && (bufferGap > getRebufferingEndGap(prevRebuffering, lowLatencyMode) || fullyLoaded || ended))) {
      shouldStopRebuffer = true;
    }
  }
  if (shouldStopRebuffer === true) {
    return null;
  } else if (shouldRebuffer === true || prevRebuffering !== null) {
    var reason;
    if (currentEvt === "seeking" || prevRebuffering !== null && prevRebuffering.reason === "seeking") {
      reason = "seeking";
    } else if (currentInfo.seeking) {
      reason = "seeking";
    } else if (readyState === 1) {
      reason = "not-ready";
    } else {
      reason = "buffering";
    }
    if (prevRebuffering !== null && prevRebuffering.reason === reason) {
      return {
        reason: prevRebuffering.reason,
        timestamp: prevRebuffering.timestamp,
        position: rebufferEndPosition
      };
    }
    return {
      reason: reason,
      timestamp: performance.now(),
      position: rebufferEndPosition
    };
  }
  return null;
}
/**
 * Detect if the current media can be considered as "freezing" (i.e. not
 * advancing for unknown reasons).
 *
 * Returns a corresponding `IFreezingStatus` object if that's the case and
 * `null` if not.
 * @param {Object} prevObservation
 * @param {Object} currentInfo
 * @returns {Object|null}
 */
function getFreezingStatus(prevObservation, currentInfo) {
  var _config$getCurrent5 = config/* default */.A.getCurrent(),
    MINIMUM_BUFFER_AMOUNT_BEFORE_FREEZING = _config$getCurrent5.MINIMUM_BUFFER_AMOUNT_BEFORE_FREEZING;
  if (prevObservation.freezing) {
    if (currentInfo.ended || currentInfo.paused || currentInfo.readyState === 0 || currentInfo.playbackRate === 0 || prevObservation.position !== currentInfo.position) {
      return null; // Quit freezing status
    }
    return prevObservation.freezing; // Stay in it
  }
  return currentInfo.event === "timeupdate" && currentInfo.bufferGap !== undefined && currentInfo.bufferGap > MINIMUM_BUFFER_AMOUNT_BEFORE_FREEZING && !currentInfo.ended && !currentInfo.paused && currentInfo.readyState >= 1 && currentInfo.playbackRate !== 0 && currentInfo.position === prevObservation.position ? {
    timestamp: performance.now()
  } : null;
}
/**
 * Pretty print a TimeRanges Object, to see the current content of it in a
 * one-liner string.
 *
 * @example
 * This function is called by giving it directly the TimeRanges, such as:
 * ```js
 * prettyPrintBuffered(document.getElementsByTagName("video")[0].buffered);
 * ```
 *
 * Let's consider this possible return:
 *
 * ```
 * 0.00|==29.95==|29.95 ~30.05~ 60.00|==29.86==|89.86
 *          ^14
 * ```
 * This means that our video element has 29.95 seconds of buffer between 0 and
 * 29.95 seconds.
 * Then 30.05 seconds where no buffer is found.
 * Then 29.86 seconds of buffer between 60.00 and 89.86 seconds.
 *
 * A caret on the second line indicates the current time we're at.
 * The number coming after it is the current time.
 * @param {TimeRanges} buffered
 * @param {number} currentTime
 * @returns {string}
 */
function prettyPrintBuffered(buffered, currentTime) {
  var str = "";
  var currentTimeStr = "";
  for (var i = 0; i < buffered.length; i++) {
    var start = buffered.start(i);
    var end = buffered.end(i);
    var fixedStart = start.toFixed(2);
    var fixedEnd = end.toFixed(2);
    var fixedDuration = (end - start).toFixed(2);
    var newIntervalStr = fixedStart + "|==" + fixedDuration + "==|" + fixedEnd;
    str += newIntervalStr;
    if (currentTimeStr.length === 0 && end > currentTime) {
      var padBefore = str.length - Math.floor(newIntervalStr.length / 2);
      currentTimeStr = " ".repeat(padBefore) + ("^" + currentTime);
    }
    if (i < buffered.length - 1) {
      var nextStart = buffered.start(i + 1);
      var fixedDiff = (nextStart - end).toFixed(2);
      var holeStr = " ~" + fixedDiff + "~ ";
      str += holeStr;
      if (currentTimeStr.length === 0 && currentTime < nextStart) {
        var _padBefore = str.length - Math.floor(holeStr.length / 2);
        currentTimeStr = " ".repeat(_padBefore) + ("^" + currentTime);
      }
    }
  }
  if (currentTimeStr.length === 0) {
    currentTimeStr = " ".repeat(str.length) + ("^" + currentTime);
  }
  return str + "\n" + currentTimeStr;
}
/**
 * Create `IReadOnlyPlaybackObserver` from a source `IReadOnlyPlaybackObserver`
 * and a mapping function.
 * @param {Object} src
 * @param {Function} transform
 * @returns {Object}
 */
function generateReadOnlyObserver(src, transform, cancellationSignal) {
  var mappedRef = transform(src.getReference(), cancellationSignal);
  return {
    getCurrentTime: function getCurrentTime() {
      return src.getCurrentTime();
    },
    getReadyState: function getReadyState() {
      return src.getReadyState();
    },
    getPlaybackRate: function getPlaybackRate() {
      return src.getPlaybackRate();
    },
    getIsPaused: function getIsPaused() {
      return src.getIsPaused();
    },
    getReference: function getReference() {
      return mappedRef;
    },
    listen: function listen(cb, options) {
      var _a;
      if (cancellationSignal.isCancelled() || ((_a = options === null || options === void 0 ? void 0 : options.clearSignal) === null || _a === void 0 ? void 0 : _a.isCancelled()) === true) {
        return;
      }
      mappedRef.onUpdate(cb, {
        clearSignal: options === null || options === void 0 ? void 0 : options.clearSignal,
        emitCurrentValue: options === null || options === void 0 ? void 0 : options.includeLastObservation
      });
    },
    deriveReadOnlyObserver: function deriveReadOnlyObserver(newTransformFn) {
      return generateReadOnlyObserver(this, newTransformFn, cancellationSignal);
    }
  };
}
// EXTERNAL MODULE: ./src/utils/array_find.ts
var array_find = __webpack_require__(1729);
// EXTERNAL MODULE: ./src/utils/languages/index.ts
var languages = __webpack_require__(8202);
// EXTERNAL MODULE: ./src/utils/sorted_list.ts
var sorted_list = __webpack_require__(7296);
;// CONCATENATED MODULE: ./src/core/api/tracks_management/track_choice_manager.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * This file is used to abstract the notion of text, audio and video tracks
 * switching for an easier API management.
 */







/**
 * Transform an array of IAudioTrackPreference into an array of
 * INormalizedPreferredAudioTrack to be exploited by the TrackChoiceManager.
 * @param {Array.<Object|null>} tracks
 * @returns {Array.<Object|null>}
 */
function normalizeAudioTracks(tracks) {
  return tracks.map(function (t) {
    return t === null ? t : {
      normalized: t.language === undefined ? undefined : (0,languages/* default */.Ay)(t.language),
      audioDescription: t.audioDescription,
      codec: t.codec
    };
  });
}
/**
 * Transform an array of ITextTrackPreference into an array of
 * INormalizedPreferredTextTrack to be exploited by the TrackChoiceManager.
 * @param {Array.<Object|null>} tracks
 * @returns {Array.<Object|null>}
 */
function normalizeTextTracks(tracks) {
  return tracks.map(function (t) {
    return t === null ? t : {
      normalized: (0,languages/* default */.Ay)(t.language),
      forced: t.forced,
      closedCaption: t.closedCaption
    };
  });
}
/**
 * Manage audio and text tracks for all active periods.
 * Choose the audio and text tracks for each period and record this choice.
 * @class TrackChoiceManager
 */
var TrackChoiceManager = /*#__PURE__*/function () {
  function TrackChoiceManager(args) {
    this._periods = new sorted_list/* default */.A(function (a, b) {
      return a.period.start - b.period.start;
    });
    this._audioChoiceMemory = new WeakMap();
    this._textChoiceMemory = new WeakMap();
    this._videoChoiceMemory = new WeakMap();
    this._preferredAudioTracks = [];
    this._preferredTextTracks = [];
    this._preferredVideoTracks = [];
    this.trickModeTrackEnabled = args.preferTrickModeTracks;
  }
  /**
   * Set the list of preferred audio tracks, in preference order.
   * @param {Array.<Object>} preferredAudioTracks
   * @param {boolean} shouldApply - `true` if those preferences should be
   * applied on the currently loaded Period. `false` if it should only
   * be applied to new content.
   */
  var _proto = TrackChoiceManager.prototype;
  _proto.setPreferredAudioTracks = function setPreferredAudioTracks(preferredAudioTracks, shouldApply) {
    this._preferredAudioTracks = preferredAudioTracks;
    if (shouldApply) {
      this._applyAudioPreferences();
    }
  }
  /**
   * Set the list of preferred text tracks, in preference order.
   * @param {Array.<Object>} preferredTextTracks
   * @param {boolean} shouldApply - `true` if those preferences should be
   * applied on the currently loaded Periods. `false` if it should only
   * be applied to new content.
   */;
  _proto.setPreferredTextTracks = function setPreferredTextTracks(preferredTextTracks, shouldApply) {
    this._preferredTextTracks = preferredTextTracks;
    if (shouldApply) {
      this._applyTextPreferences();
    }
  }
  /**
   * Set the list of preferred text tracks, in preference order.
   * @param {Array.<Object>} preferredVideoTracks
   * @param {boolean} shouldApply - `true` if those preferences should be
   * applied on the currently loaded Period. `false` if it should only
   * be applied to new content.
   */;
  _proto.setPreferredVideoTracks = function setPreferredVideoTracks(preferredVideoTracks, shouldApply) {
    this._preferredVideoTracks = preferredVideoTracks;
    if (shouldApply) {
      this._applyVideoPreferences();
    }
  }
  /**
   * Add shared reference to choose Adaptation for new "audio" or "text" Period.
   * @param {string} bufferType - The concerned buffer type
   * @param {Period} period - The concerned Period.
   * @param {Object} adaptationRef
   */;
  _proto.addPeriod = function addPeriod(bufferType, period, adaptationRef) {
    var periodItem = getPeriodItem(this._periods, period);
    var adaptations = period.getSupportedAdaptations(bufferType);
    if (periodItem !== undefined) {
      if (periodItem[bufferType] !== undefined) {
        src_log/* default */.A.warn("TrackChoiceManager: " + bufferType + " already added for period", period.start);
        return;
      } else {
        periodItem[bufferType] = {
          adaptations: adaptations,
          adaptationRef: adaptationRef
        };
      }
    } else {
      var _this$_periods$add;
      this._periods.add((_this$_periods$add = {
        period: period
      }, _this$_periods$add[bufferType] = {
        adaptations: adaptations,
        adaptationRef: adaptationRef
      }, _this$_periods$add));
    }
  }
  /**
   * Remove shared reference to choose an "audio", "video" or "text" Adaptation
   * for a Period.
   * @param {string} bufferType - The concerned buffer type
   * @param {Period} period - The concerned Period.
   */;
  _proto.removePeriod = function removePeriod(bufferType, period) {
    var periodIndex = findPeriodIndex(this._periods, period);
    if (periodIndex === undefined) {
      src_log/* default */.A.warn("TrackChoiceManager: " + bufferType + " not found for period", period.start);
      return;
    }
    var periodItem = this._periods.get(periodIndex);
    if (periodItem[bufferType] === undefined) {
      src_log/* default */.A.warn("TrackChoiceManager: " + bufferType + " already removed for period", period.start);
      return;
    }
    delete periodItem[bufferType];
    if (periodItem.audio === undefined && periodItem.text === undefined && periodItem.video === undefined) {
      this._periods.removeElement(periodItem);
    }
  };
  _proto.resetPeriods = function resetPeriods() {
    while (this._periods.length() > 0) {
      this._periods.pop();
    }
  }
  /**
   * Update the choice of all added Periods based on:
   *   1. What was the last chosen adaptation
   *   2. If not found, the preferences
   */;
  _proto.update = function update() {
    this._resetChosenAudioTracks();
    this._resetChosenTextTracks();
    this._resetChosenVideoTracks();
  }
  /**
   * Emit initial audio Adaptation through the given shared reference based on:
   *   - the preferred audio tracks
   *   - the last choice for this period, if one
   * @param {Period} period - The concerned Period.
   */;
  _proto.setInitialAudioTrack = function setInitialAudioTrack(period) {
    var periodItem = getPeriodItem(this._periods, period);
    var audioInfos = periodItem !== undefined ? periodItem.audio : null;
    if ((0,is_null_or_undefined/* default */.A)(audioInfos) || periodItem === undefined) {
      throw new Error("TrackChoiceManager: Given Period not found.");
    }
    var audioAdaptations = period.getSupportedAdaptations("audio");
    var chosenAudioAdaptation = this._audioChoiceMemory.get(period);
    if (chosenAudioAdaptation === null) {
      // If the Period was previously without audio, keep it that way
      audioInfos.adaptationRef.setValue(null);
    } else if (chosenAudioAdaptation === undefined || !(0,array_includes/* default */.A)(audioAdaptations, chosenAudioAdaptation)) {
      // Find the optimal audio Adaptation
      var preferredAudioTracks = this._preferredAudioTracks;
      var normalizedPref = normalizeAudioTracks(preferredAudioTracks);
      var optimalAdaptation = findFirstOptimalAudioAdaptation(audioAdaptations, normalizedPref);
      this._audioChoiceMemory.set(period, optimalAdaptation);
      audioInfos.adaptationRef.setValue(optimalAdaptation);
    } else {
      audioInfos.adaptationRef.setValue(chosenAudioAdaptation); // set last one
    }
  }
  /**
   * Emit initial text Adaptation through the given shared reference based on:
   *   - the preferred text tracks
   *   - the last choice for this period, if one
   * @param {Period} period - The concerned Period.
   */;
  _proto.setInitialTextTrack = function setInitialTextTrack(period) {
    var periodItem = getPeriodItem(this._periods, period);
    var textInfos = periodItem !== undefined ? periodItem.text : null;
    if ((0,is_null_or_undefined/* default */.A)(textInfos) || periodItem === undefined) {
      throw new Error("TrackChoiceManager: Given Period not found.");
    }
    var textAdaptations = period.getSupportedAdaptations("text");
    var chosenTextAdaptation = this._textChoiceMemory.get(period);
    if (chosenTextAdaptation === null) {
      // If the Period was previously without text, keep it that way
      textInfos.adaptationRef.setValue(null);
    } else if (chosenTextAdaptation === undefined || !(0,array_includes/* default */.A)(textAdaptations, chosenTextAdaptation)) {
      // Find the optimal text Adaptation
      var preferredTextTracks = this._preferredTextTracks;
      var normalizedPref = normalizeTextTracks(preferredTextTracks);
      var optimalAdaptation = findFirstOptimalTextAdaptation(textAdaptations, normalizedPref, this._audioChoiceMemory.get(period));
      this._textChoiceMemory.set(period, optimalAdaptation);
      textInfos.adaptationRef.setValue(optimalAdaptation);
    } else {
      textInfos.adaptationRef.setValue(chosenTextAdaptation); // set last one
    }
  }
  /**
   * Emit initial video Adaptation through the given shared reference based on:
   *   - the preferred video tracks
   *   - the last choice for this period, if one
   * @param {Period} period - The concerned Period.
   */;
  _proto.setInitialVideoTrack = function setInitialVideoTrack(period) {
    var periodItem = getPeriodItem(this._periods, period);
    var videoInfos = periodItem !== undefined ? periodItem.video : null;
    if ((0,is_null_or_undefined/* default */.A)(videoInfos) || periodItem === undefined) {
      throw new Error("TrackChoiceManager: Given Period not found.");
    }
    var videoAdaptations = period.getSupportedAdaptations("video");
    var prevVideoAdaptation = this._videoChoiceMemory.get(period);
    var newBaseAdaptation;
    if (prevVideoAdaptation === null) {
      newBaseAdaptation = null;
    } else if (prevVideoAdaptation !== undefined && (0,array_includes/* default */.A)(videoAdaptations, prevVideoAdaptation.baseAdaptation)) {
      // still exists, re-select it
      newBaseAdaptation = prevVideoAdaptation.baseAdaptation;
    } else {
      // If that Adaptation does not exist (e.g. no choice has been made or it
      // is not in the Manifest anymore), look at preferences
      var preferredVideoTracks = this._preferredVideoTracks;
      newBaseAdaptation = findFirstOptimalVideoAdaptation(videoAdaptations, preferredVideoTracks);
    }
    if (newBaseAdaptation === null) {
      this._videoChoiceMemory.set(period, null);
      videoInfos.adaptationRef.setValue(null);
      return;
    }
    var newVideoAdaptation = getRightVideoTrack(newBaseAdaptation, this.trickModeTrackEnabled);
    this._videoChoiceMemory.set(period, {
      baseAdaptation: newBaseAdaptation,
      adaptation: newVideoAdaptation
    });
    videoInfos.adaptationRef.setValue(newVideoAdaptation);
  }
  /**
   * Set audio track based on the ID of its adaptation for a given added Period.
   * @param {Period} period - The concerned Period.
   * @param {string} wantedId - adaptation id of the wanted track
   */;
  _proto.setAudioTrackByID = function setAudioTrackByID(period, wantedId) {
    var periodItem = getPeriodItem(this._periods, period);
    var audioInfos = periodItem !== undefined ? periodItem.audio : null;
    if ((0,is_null_or_undefined/* default */.A)(audioInfos)) {
      throw new Error("TrackChoiceManager: Given Period not found.");
    }
    var wantedAdaptation = (0,array_find/* default */.A)(audioInfos.adaptations, function (_ref) {
      var id = _ref.id;
      return id === wantedId;
    });
    if (wantedAdaptation === undefined) {
      throw new Error("Audio Track not found.");
    }
    var chosenAudioAdaptation = this._audioChoiceMemory.get(period);
    if (chosenAudioAdaptation === wantedAdaptation) {
      return;
    }
    this._audioChoiceMemory.set(period, wantedAdaptation);
    audioInfos.adaptationRef.setValue(wantedAdaptation);
  }
  /**
   * Set text track based on the ID of its adaptation for a given added Period.
   * @param {Period} period - The concerned Period.
   * @param {string} wantedId - adaptation id of the wanted track
   */;
  _proto.setTextTrackByID = function setTextTrackByID(period, wantedId) {
    var periodItem = getPeriodItem(this._periods, period);
    var textInfos = periodItem !== undefined ? periodItem.text : null;
    if ((0,is_null_or_undefined/* default */.A)(textInfos)) {
      throw new Error("TrackChoiceManager: Given Period not found.");
    }
    var wantedAdaptation = (0,array_find/* default */.A)(textInfos.adaptations, function (_ref2) {
      var id = _ref2.id;
      return id === wantedId;
    });
    if (wantedAdaptation === undefined) {
      throw new Error("Text Track not found.");
    }
    var chosenTextAdaptation = this._textChoiceMemory.get(period);
    if (chosenTextAdaptation === wantedAdaptation) {
      return;
    }
    this._textChoiceMemory.set(period, wantedAdaptation);
    textInfos.adaptationRef.setValue(wantedAdaptation);
  }
  /**
   * Set video track based on the ID of its adaptation for a given added Period.
   * @param {Period} period - The concerned Period.
   * @param {string} wantedId - adaptation id of the wanted track
   *
   * @throws Error - Throws if the period given has not been added
   * @throws Error - Throws if the given id is not found in any video adaptation
   * of the given Period.
   */;
  _proto.setVideoTrackByID = function setVideoTrackByID(period, wantedId) {
    var periodItem = getPeriodItem(this._periods, period);
    var videoInfos = periodItem !== undefined ? periodItem.video : null;
    if ((0,is_null_or_undefined/* default */.A)(videoInfos)) {
      throw new Error("LanguageManager: Given Period not found.");
    }
    var wantedBaseAdaptation = (0,array_find/* default */.A)(videoInfos.adaptations, function (_ref3) {
      var id = _ref3.id;
      return id === wantedId;
    });
    if (wantedBaseAdaptation === undefined) {
      throw new Error("Video Track not found.");
    }
    var newVideoAdaptation = getRightVideoTrack(wantedBaseAdaptation, this.trickModeTrackEnabled);
    this._videoChoiceMemory.set(period, {
      baseAdaptation: wantedBaseAdaptation,
      adaptation: newVideoAdaptation
    });
    videoInfos.adaptationRef.setValue(newVideoAdaptation);
  }
  /**
   * Disable the current text track for a given period.
   *
   * @param {Period} period - The concerned Period.
   *
   * @throws Error - Throws if the period given has not been added
   */;
  _proto.disableTextTrack = function disableTextTrack(period) {
    var periodItem = getPeriodItem(this._periods, period);
    var textInfos = periodItem !== undefined ? periodItem.text : null;
    if ((0,is_null_or_undefined/* default */.A)(textInfos)) {
      throw new Error("TrackChoiceManager: Given Period not found.");
    }
    var chosenTextAdaptation = this._textChoiceMemory.get(period);
    if (chosenTextAdaptation === null) {
      return;
    }
    this._textChoiceMemory.set(period, null);
    textInfos.adaptationRef.setValue(null);
  }
  /**
   * Disable the current video track for a given period.
   * @param {Object} period
   * @throws Error - Throws if the period given has not been added
   */;
  _proto.disableVideoTrack = function disableVideoTrack(period) {
    var periodItem = getPeriodItem(this._periods, period);
    var videoInfos = periodItem === null || periodItem === void 0 ? void 0 : periodItem.video;
    if (videoInfos === undefined) {
      throw new Error("TrackManager: Given Period not found.");
    }
    var chosenVideoAdaptation = this._videoChoiceMemory.get(period);
    if (chosenVideoAdaptation === null) {
      return;
    }
    this._videoChoiceMemory.set(period, null);
    videoInfos.adaptationRef.setValue(null);
  };
  _proto.disableVideoTrickModeTracks = function disableVideoTrickModeTracks() {
    this.trickModeTrackEnabled = false;
    this._resetChosenVideoTracks();
  };
  _proto.enableVideoTrickModeTracks = function enableVideoTrickModeTracks() {
    this.trickModeTrackEnabled = true;
    this._resetChosenVideoTracks();
  }
  /**
   * @returns {boolean}
   */;
  _proto.isTrickModeEnabled = function isTrickModeEnabled() {
    return this.trickModeTrackEnabled;
  }
  /**
   * Returns an object describing the chosen audio track for the given audio
   * Period.
   *
   * Returns null is the the current audio track is disabled or not
   * set yet.
   *
   * @param {Period} period - The concerned Period.
   * @returns {Object|null} - The audio track chosen for this Period
   */;
  _proto.getChosenAudioTrack = function getChosenAudioTrack(period) {
    var periodItem = getPeriodItem(this._periods, period);
    var audioInfos = periodItem !== undefined ? periodItem.audio : null;
    if ((0,is_null_or_undefined/* default */.A)(audioInfos)) {
      return null;
    }
    var chosenTrack = this._audioChoiceMemory.get(period);
    if ((0,is_null_or_undefined/* default */.A)(chosenTrack)) {
      return null;
    }
    return chosenTrack.toAudioTrack();
  }
  /**
   * Returns an object describing the chosen text track for the given text
   * Period.
   *
   * Returns null is the the current text track is disabled or not
   * set yet.
   *
   * @param {Period} period - The concerned Period.
   * @returns {Object|null} - The text track chosen for this Period
   */;
  _proto.getChosenTextTrack = function getChosenTextTrack(period) {
    var periodItem = getPeriodItem(this._periods, period);
    var textInfos = periodItem !== undefined ? periodItem.text : null;
    if ((0,is_null_or_undefined/* default */.A)(textInfos)) {
      return null;
    }
    var chosenTextAdaptation = this._textChoiceMemory.get(period);
    if ((0,is_null_or_undefined/* default */.A)(chosenTextAdaptation)) {
      return null;
    }
    return chosenTextAdaptation.toTextTrack();
  }
  /**
   * Returns an object describing the chosen video track for the given video
   * Period.
   *
   * Returns null is the the current video track is disabled or not
   * set yet.
   *
   * @param {Period} period - The concerned Period.
   * @returns {Object|null} - The video track chosen for this Period
   */;
  _proto.getChosenVideoTrack = function getChosenVideoTrack(period) {
    var periodItem = getPeriodItem(this._periods, period);
    var videoInfos = periodItem !== undefined ? periodItem.video : null;
    if ((0,is_null_or_undefined/* default */.A)(videoInfos)) {
      return null;
    }
    var chosenVideoAdaptation = this._videoChoiceMemory.get(period);
    if ((0,is_null_or_undefined/* default */.A)(chosenVideoAdaptation)) {
      return null;
    }
    var currAdaptation = chosenVideoAdaptation.adaptation;
    return currAdaptation.toVideoTrack();
  }
  /**
   * Returns all available audio tracks for a given Period, as an array of
   * objects.
   *
   * @returns {Array.<Object>}
   */;
  _proto.getAvailableAudioTracks = function getAvailableAudioTracks(period) {
    var periodItem = getPeriodItem(this._periods, period);
    var audioInfos = periodItem !== undefined ? periodItem.audio : null;
    if ((0,is_null_or_undefined/* default */.A)(audioInfos)) {
      return [];
    }
    var chosenAudioAdaptation = this._audioChoiceMemory.get(period);
    var currentId = !(0,is_null_or_undefined/* default */.A)(chosenAudioAdaptation) ? chosenAudioAdaptation.id : null;
    return audioInfos.adaptations.map(function (adaptation) {
      var active = currentId === null ? false : currentId === adaptation.id;
      return (0,object_assign/* default */.A)(adaptation.toAudioTrack(), {
        active: active
      });
    });
  }
  /**
   * Returns all available text tracks for a given Period, as an array of
   * objects.
   *
   * @param {Period} period
   * @returns {Array.<Object>}
   */;
  _proto.getAvailableTextTracks = function getAvailableTextTracks(period) {
    var periodItem = getPeriodItem(this._periods, period);
    var textInfos = periodItem !== undefined ? periodItem.text : null;
    if ((0,is_null_or_undefined/* default */.A)(textInfos)) {
      return [];
    }
    var chosenTextAdaptation = this._textChoiceMemory.get(period);
    var currentId = !(0,is_null_or_undefined/* default */.A)(chosenTextAdaptation) ? chosenTextAdaptation.id : null;
    return textInfos.adaptations.map(function (adaptation) {
      var active = currentId === null ? false : currentId === adaptation.id;
      return (0,object_assign/* default */.A)(adaptation.toTextTrack(), {
        active: active
      });
    });
  }
  /**
   * Returns all available video tracks for a given Period, as an array of
   * objects.
   *
   * @returns {Array.<Object>}
   */;
  _proto.getAvailableVideoTracks = function getAvailableVideoTracks(period) {
    var _a;
    var periodItem = getPeriodItem(this._periods, period);
    var videoInfos = periodItem !== undefined ? periodItem.video : null;
    if ((0,is_null_or_undefined/* default */.A)(videoInfos)) {
      return [];
    }
    var chosenVideoAdaptation = this._videoChoiceMemory.get(period);
    var currentId = chosenVideoAdaptation === undefined ? undefined : (_a = chosenVideoAdaptation === null || chosenVideoAdaptation === void 0 ? void 0 : chosenVideoAdaptation.adaptation.id) !== null && _a !== void 0 ? _a : undefined;
    return videoInfos.adaptations.map(function (adaptation) {
      var active = currentId === null ? false : currentId === adaptation.id;
      var track = adaptation.toVideoTrack();
      var trickModeTracks = track.trickModeTracks !== undefined ? track.trickModeTracks.map(function (trickModeAdaptation) {
        var isActive = currentId === null ? false : currentId === trickModeAdaptation.id;
        return (0,object_assign/* default */.A)(trickModeAdaptation, {
          active: isActive
        });
      }) : [];
      var availableTrack = (0,object_assign/* default */.A)(track, {
        active: active
      });
      if (trickModeTracks !== undefined) {
        availableTrack.trickModeTracks = trickModeTracks;
      }
      return availableTrack;
    });
  }
  /**
   * Reset all audio tracks choices to corresponds to the current preferences.
   */;
  _proto._applyAudioPreferences = function _applyAudioPreferences() {
    // Remove all memorized choices and start over
    this._audioChoiceMemory = new WeakMap();
    this._resetChosenAudioTracks();
  }
  /**
   * Reset all text tracks choices to corresponds to the current preferences.
   */;
  _proto._applyTextPreferences = function _applyTextPreferences() {
    // Remove all memorized choices and start over
    this._textChoiceMemory = new WeakMap();
    this._resetChosenTextTracks();
  }
  /**
   * Reset all video tracks choices to corresponds to the current preferences.
   */;
  _proto._applyVideoPreferences = function _applyVideoPreferences() {
    // Remove all memorized choices and start over
    this._videoChoiceMemory = new WeakMap();
    this._resetChosenVideoTracks();
  }
  /**
   * Choose again the best audio tracks for all current Periods.
   * This is based on two things:
   *   1. what was the track previously chosen for that Period (by checking
   *      `this._audioChoiceMemory`).
   *   2. If no track were previously chosen or if it is not available anymore
   *      we check the audio preferences.
   */;
  _proto._resetChosenAudioTracks = function _resetChosenAudioTracks() {
    var _this = this;
    var preferredAudioTracks = this._preferredAudioTracks;
    var normalizedPref = normalizeAudioTracks(preferredAudioTracks);
    var recursiveUpdateAudioTrack = function recursiveUpdateAudioTrack(index) {
      if (index >= _this._periods.length()) {
        // we did all audio Periods, exit
        return;
      }
      var periodItem = _this._periods.get(index);
      if ((0,is_null_or_undefined/* default */.A)(periodItem.audio)) {
        // No audio choice for this period, check next one
        recursiveUpdateAudioTrack(index + 1);
        return;
      }
      var period = periodItem.period,
        audioItem = periodItem.audio;
      var audioAdaptations = period.getSupportedAdaptations("audio");
      var chosenAudioAdaptation = _this._audioChoiceMemory.get(period);
      if (chosenAudioAdaptation === null || chosenAudioAdaptation !== undefined && (0,array_includes/* default */.A)(audioAdaptations, chosenAudioAdaptation)) {
        // Already best audio for this Period, check next one
        recursiveUpdateAudioTrack(index + 1);
        return;
      }
      var optimalAdaptation = findFirstOptimalAudioAdaptation(audioAdaptations, normalizedPref);
      _this._audioChoiceMemory.set(period, optimalAdaptation);
      audioItem.adaptationRef.setValue(optimalAdaptation);
      // previous "next" call could have changed everything, start over
      recursiveUpdateAudioTrack(0);
    };
    recursiveUpdateAudioTrack(0);
  }
  /**
   * Choose again the best text tracks for all current Periods.
   * This is based on two things:
   *   1. what was the track previously chosen for that Period (by checking
   *      `this._textChoiceMemory`).
   *   2. If no track were previously chosen or if it is not available anymore
   *      we check the text preferences.
   */;
  _proto._resetChosenTextTracks = function _resetChosenTextTracks() {
    var _this2 = this;
    var preferredTextTracks = this._preferredTextTracks;
    var normalizedPref = normalizeTextTracks(preferredTextTracks);
    var recursiveUpdateTextTrack = function recursiveUpdateTextTrack(index) {
      if (index >= _this2._periods.length()) {
        // we did all text Periods, exit
        return;
      }
      var periodItem = _this2._periods.get(index);
      if ((0,is_null_or_undefined/* default */.A)(periodItem.text)) {
        // No text choice for this period, check next one
        recursiveUpdateTextTrack(index + 1);
        return;
      }
      var period = periodItem.period,
        textItem = periodItem.text;
      var textAdaptations = period.getSupportedAdaptations("text");
      var chosenTextAdaptation = _this2._textChoiceMemory.get(period);
      if (chosenTextAdaptation === null || chosenTextAdaptation !== undefined && (0,array_includes/* default */.A)(textAdaptations, chosenTextAdaptation)) {
        // Already best text for this Period, check next one
        recursiveUpdateTextTrack(index + 1);
        return;
      }
      var optimalAdaptation = findFirstOptimalTextAdaptation(textAdaptations, normalizedPref, _this2._audioChoiceMemory.get(period));
      _this2._textChoiceMemory.set(period, optimalAdaptation);
      textItem.adaptationRef.setValue(optimalAdaptation);
      // previous "next" call could have changed everything, start over
      recursiveUpdateTextTrack(0);
    };
    recursiveUpdateTextTrack(0);
  }
  /**
   * Choose again the best video tracks for all current Periods.
   * This is based on two things:
   *   1. what was the track previously chosen for that Period (by checking
   *      `this._videoChoiceMemory`).
   *   2. If no track were previously chosen or if it is not available anymore
   *      we check the video preferences.
   */;
  _proto._resetChosenVideoTracks = function _resetChosenVideoTracks() {
    var _this3 = this;
    var preferredVideoTracks = this._preferredVideoTracks;
    var recursiveUpdateVideoTrack = function recursiveUpdateVideoTrack(index) {
      if (index >= _this3._periods.length()) {
        // we did all video Periods, exit
        return;
      }
      var periodItem = _this3._periods.get(index);
      if ((0,is_null_or_undefined/* default */.A)(periodItem.video)) {
        // No video choice for this period, check next one
        recursiveUpdateVideoTrack(index + 1);
        return;
      }
      var period = periodItem.period,
        videoItem = periodItem.video;
      var videoAdaptations = period.getSupportedAdaptations("video");
      var chosenVideoAdaptation = _this3._videoChoiceMemory.get(period);
      if (chosenVideoAdaptation === null) {
        // No video track for that one, so nothing to change.
        recursiveUpdateVideoTrack(index + 1);
        return;
      } else if (chosenVideoAdaptation !== undefined && (0,array_includes/* default */.A)(videoAdaptations, chosenVideoAdaptation.baseAdaptation)) {
        // The right Base Adaptation is selected and is still available.
        // Check if the selected Adaptation is still right
        var wantedVideoAdaptation = getRightVideoTrack(chosenVideoAdaptation.baseAdaptation, _this3.trickModeTrackEnabled);
        if (wantedVideoAdaptation.id === chosenVideoAdaptation.adaptation.id) {
          // We're good, continue.
          recursiveUpdateVideoTrack(index + 1);
          return;
        } else {
          // select the right track
          _this3._videoChoiceMemory.set(period, {
            baseAdaptation: chosenVideoAdaptation.baseAdaptation,
            adaptation: wantedVideoAdaptation
          });
          videoItem.adaptationRef.setValue(wantedVideoAdaptation);
          // previous "next" call could have changed everything, start over
          return recursiveUpdateVideoTrack(0);
        }
      }
      var optimalAdaptation = findFirstOptimalVideoAdaptation(videoAdaptations, preferredVideoTracks);
      if (optimalAdaptation === null) {
        _this3._videoChoiceMemory.set(period, null);
        videoItem.adaptationRef.setValue(null);
        // previous "next" call could have changed everything, start over
        return recursiveUpdateVideoTrack(0);
      }
      var newVideoAdaptation = getRightVideoTrack(optimalAdaptation, _this3.trickModeTrackEnabled);
      _this3._videoChoiceMemory.set(period, {
        baseAdaptation: optimalAdaptation,
        adaptation: newVideoAdaptation
      });
      videoItem.adaptationRef.setValue(newVideoAdaptation);
      // previous "next" call could have changed everything, start over
      return recursiveUpdateVideoTrack(0);
    };
    recursiveUpdateVideoTrack(0);
  };
  return TrackChoiceManager;
}();
/**
 * Create a function allowing to compare audio Adaptations with a given
 * `preferredAudioTrack` preference to see if they match.
 *
 * This function is curried to be easily and optimally used in a loop context.
 *
 * @param {Object} preferredAudioTrack - The audio track preference you want to
 * compare audio Adaptations to.
 * @returns {Function} - Function taking in argument an audio Adaptation and
 * returning `true` if it matches the `preferredAudioTrack` preference (and
 * `false` otherwise.
 */

function createAudioPreferenceMatcher(preferredAudioTrack) {
  /**
   * Compares an audio Adaptation to the given `preferredAudioTrack` preference.
   * Returns `true` if it matches, false otherwise.
   * @param {Object} audioAdaptation
   * @returns {boolean}
   */
  return function matchAudioPreference(audioAdaptation) {
    var _a;
    if (preferredAudioTrack.normalized !== undefined) {
      var language = (_a = audioAdaptation.normalizedLanguage) !== null && _a !== void 0 ? _a : "";
      if (language !== preferredAudioTrack.normalized) {
        return false;
      }
    }
    if (preferredAudioTrack.audioDescription !== undefined) {
      if (preferredAudioTrack.audioDescription) {
        if (audioAdaptation.isAudioDescription !== true) {
          return false;
        }
      } else if (audioAdaptation.isAudioDescription === true) {
        return false;
      }
    }
    if (preferredAudioTrack.codec === undefined) {
      return true;
    }
    var regxp = preferredAudioTrack.codec.test;
    var codecTestingFn = function codecTestingFn(rep) {
      return rep.codec !== undefined && regxp.test(rep.codec);
    };
    if (preferredAudioTrack.codec.all) {
      return audioAdaptation.representations.every(codecTestingFn);
    }
    return audioAdaptation.representations.some(codecTestingFn);
  };
}
/**
 * Find an optimal audio adaptation given their list and the array of preferred
 * audio tracks sorted from the most preferred to the least preferred.
 *
 * `null` if the most optimal audio adaptation is no audio adaptation.
 * @param {Array.<Adaptation>} audioAdaptations
 * @param {Array.<Object|null>} preferredAudioTracks
 * @returns {Adaptation|null}
 */
function findFirstOptimalAudioAdaptation(audioAdaptations, preferredAudioTracks) {
  if (audioAdaptations.length === 0) {
    return null;
  }
  for (var i = 0; i < preferredAudioTracks.length; i++) {
    var preferredAudioTrack = preferredAudioTracks[i];
    if (preferredAudioTrack === null) {
      return null;
    }
    var matchPreferredAudio = createAudioPreferenceMatcher(preferredAudioTrack);
    var foundAdaptation = (0,array_find/* default */.A)(audioAdaptations, matchPreferredAudio);
    if (foundAdaptation !== undefined) {
      return foundAdaptation;
    }
  }
  // no optimal adaptation, just return the first one
  return audioAdaptations[0];
}
/**
 * Create a function allowing to compare text Adaptations with a given
 * `preferredTextTrack` preference to see if they match.
 *
 * This function is curried to be easily and optimally used in a loop context.
 *
 * @param {Object} preferredTextTrack - The text track preference you want to
 * compare text Adaptations to.
 * @returns {Function} - Function taking in argument a text Adaptation and
 * returning `true` if it matches the `preferredTextTrack` preference (and
 * `false` otherwise.
 */
function createTextPreferenceMatcher(preferredTextTrack) {
  /**
   * Compares a text Adaptation to the given `preferredTextTrack` preference.
   * Returns `true` if it matches, false otherwise.
   * @param {Object} textAdaptation
   * @returns {boolean}
   */
  return function matchTextPreference(textAdaptation) {
    var _a;
    return ((_a = textAdaptation.normalizedLanguage) !== null && _a !== void 0 ? _a : "") === preferredTextTrack.normalized && (preferredTextTrack.closedCaption ? textAdaptation.isClosedCaption === true : textAdaptation.isClosedCaption !== true) && (preferredTextTrack.forced === true ? textAdaptation.isForcedSubtitles === true : textAdaptation.isForcedSubtitles !== true);
  };
}
/**
 * Find an optimal text adaptation given their list and the array of preferred
 * text tracks sorted from the most preferred to the least preferred.
 *
 * `null` if the most optimal text adaptation is no text adaptation.
 * @param {Array.<Object>} textAdaptations
 * @param {Array.<Object|null>} preferredTextTracks
 * @param {Object|null|undefined} chosenAudioAdaptation
 * @returns {Adaptation|null}
 */
function findFirstOptimalTextAdaptation(textAdaptations, preferredTextTracks, chosenAudioAdaptation) {
  var _a;
  if (textAdaptations.length === 0) {
    return null;
  }
  for (var i = 0; i < preferredTextTracks.length; i++) {
    var preferredTextTrack = preferredTextTracks[i];
    if (preferredTextTrack === null) {
      return null;
    }
    var matchPreferredText = createTextPreferenceMatcher(preferredTextTrack);
    var foundAdaptation = (0,array_find/* default */.A)(textAdaptations, matchPreferredText);
    if (foundAdaptation !== undefined) {
      return foundAdaptation;
    }
  }
  var forcedSubtitles = textAdaptations.filter(function (ad) {
    return ad.isForcedSubtitles === true;
  });
  if (forcedSubtitles.length > 0) {
    if (chosenAudioAdaptation !== null && chosenAudioAdaptation !== undefined) {
      var sameLanguage = (0,array_find/* default */.A)(forcedSubtitles, function (f) {
        return f.normalizedLanguage === chosenAudioAdaptation.normalizedLanguage;
      });
      if (sameLanguage !== undefined) {
        return sameLanguage;
      }
    }
    return (_a = (0,array_find/* default */.A)(forcedSubtitles, function (f) {
      return f.normalizedLanguage === undefined;
    })) !== null && _a !== void 0 ? _a : null;
  }
  // no optimal adaptation
  return null;
}
/**
 * Create a function allowing to compare video Adaptations with a given
 * `preferredVideoTrack` preference to see if they match.
 *
 * This function is curried to be easily and optimally used in a loop context.
 *
 * @param {Object} preferredVideoTrack - The video track preference you want to
 * compare video Adaptations to.
 * @returns {Function} - Function taking in argument a video Adaptation and
 * returning `true` if it matches the `preferredVideoTrack` preference (and
 * `false` otherwise.
 */
function createVideoPreferenceMatcher(preferredVideoTrack) {
  /**
   * Compares a video Adaptation to the given `preferredVideoTrack` preference.
   * Returns `true` if it matches, false otherwise.
   * @param {Object} videoAdaptation
   * @returns {boolean}
   */
  return function matchVideoPreference(videoAdaptation) {
    if (preferredVideoTrack.signInterpreted !== undefined && preferredVideoTrack.signInterpreted !== videoAdaptation.isSignInterpreted) {
      return false;
    }
    if (preferredVideoTrack.codec === undefined) {
      return true;
    }
    var regxp = preferredVideoTrack.codec.test;
    var codecTestingFn = function codecTestingFn(rep) {
      return rep.codec !== undefined && regxp.test(rep.codec);
    };
    if (preferredVideoTrack.codec.all) {
      return videoAdaptation.representations.every(codecTestingFn);
    }
    return videoAdaptation.representations.some(codecTestingFn);
  };
}
/**
 * Find an optimal video adaptation given their list and the array of preferred
 * video tracks sorted from the most preferred to the least preferred.
 *
 * `null` if the most optimal video adaptation is no video adaptation.
 * @param {Array.<Adaptation>} videoAdaptations
 * @param {Array.<Object|null>} preferredVideoTracks
 * @returns {Adaptation|null}
 */
function findFirstOptimalVideoAdaptation(videoAdaptations, preferredVideoTracks) {
  if (videoAdaptations.length === 0) {
    return null;
  }
  for (var i = 0; i < preferredVideoTracks.length; i++) {
    var preferredVideoTrack = preferredVideoTracks[i];
    if (preferredVideoTrack === null) {
      return null;
    }
    var matchPreferredVideo = createVideoPreferenceMatcher(preferredVideoTrack);
    var foundAdaptation = (0,array_find/* default */.A)(videoAdaptations, matchPreferredVideo);
    if (foundAdaptation !== undefined) {
      return foundAdaptation;
    }
  }
  // no optimal adaptation, just return the first one
  return videoAdaptations[0];
}
/**
 * Returns the index of the given `period` in the given `periods`
 * SortedList.
 * Returns `undefined` if that `period` is not found.
 * @param {Object} periods
 * @param {Object} period
 * @returns {number|undefined}
 */
function findPeriodIndex(periods, period) {
  for (var i = 0; i < periods.length(); i++) {
    var periodI = periods.get(i);
    if (periodI.period.id === period.id) {
      return i;
    }
  }
}
/**
 * Returns element in the given `periods` SortedList that corresponds to the
 * `period` given.
 * Returns `undefined` if that `period` is not found.
 * @param {Object} periods
 * @param {Object} period
 * @returns {Object|undefined}
 */
function getPeriodItem(periods, period) {
  for (var i = 0; i < periods.length(); i++) {
    var periodI = periods.get(i);
    if (periodI.period.id === period.id) {
      return periodI;
    }
  }
}
function getRightVideoTrack(adaptation, isTrickModeEnabled) {
  var _a;
  if (isTrickModeEnabled && ((_a = adaptation.trickModeTracks) === null || _a === void 0 ? void 0 : _a[0]) !== undefined) {
    return adaptation.trickModeTracks[0];
  }
  return adaptation;
}
;// CONCATENATED MODULE: ./src/core/api/utils.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * @param {HTMLMediaElement} mediaElement
 * @param {Object} playbackObserver - Observes playback conditions on
 * `mediaElement`.
 * @param {function} onSeeking - Callback called when a seeking operation starts
 * on `mediaElement`.
 * @param {function} onSeeked - Callback called when a seeking operation ends
 * on `mediaElement`.
 * @param {Object} cancelSignal - When triggered, stop calling callbacks and
 * remove all listeners this function has registered.
 */
function emitSeekEvents(mediaElement, playbackObserver, onSeeking, onSeeked, cancelSignal) {
  if (cancelSignal.isCancelled() || mediaElement === null) {
    return;
  }
  var wasSeeking = playbackObserver.getReference().getValue().seeking;
  if (wasSeeking) {
    onSeeking();
    if (cancelSignal.isCancelled()) {
      return;
    }
  }
  playbackObserver.listen(function (obs) {
    if (obs.event === "seeking") {
      wasSeeking = true;
      onSeeking();
    } else if (wasSeeking && obs.event === "seeked") {
      wasSeeking = false;
      onSeeked();
    }
  }, {
    includeLastObservation: true,
    clearSignal: cancelSignal
  });
}
/**
 * @param {HTMLMediaElement} mediaElement
 * @param {function} onPlay - Callback called when a play operation has started
 * on `mediaElement`.
 * @param {function} onPause - Callback called when a pause operation has
 * started on `mediaElement`.
 * @param {Object} cancelSignal - When triggered, stop calling callbacks and
 * remove all listeners this function has registered.
 */
function emitPlayPauseEvents(mediaElement, onPlay, onPause, cancelSignal) {
  if (cancelSignal.isCancelled() || mediaElement === null) {
    return;
  }
  mediaElement.addEventListener("play", onPlay);
  mediaElement.addEventListener("pause", onPause);
  cancelSignal.register(function () {
    mediaElement.removeEventListener("play", onPlay);
    mediaElement.removeEventListener("pause", onPause);
  });
}
function constructPlayerStateReference(initializer, mediaElement, playbackObserver, cancelSignal) {
  var playerStateRef = new reference/* default */.A("LOADING" /* PLAYER_STATES.LOADING */, cancelSignal);
  initializer.addEventListener("loaded", function () {
    if (playerStateRef.getValue() === "LOADING" /* PLAYER_STATES.LOADING */) {
      playerStateRef.setValue("LOADED" /* PLAYER_STATES.LOADED */);
      if (!cancelSignal.isCancelled()) {
        var newState = getLoadedContentState(mediaElement, null);
        if (newState !== "PAUSED" /* PLAYER_STATES.PAUSED */) {
          playerStateRef.setValue(newState);
        }
      }
    } else {
      playerStateRef.setValueIfChanged(getLoadedContentState(mediaElement, null));
    }
  }, cancelSignal);
  initializer.addEventListener("reloadingMediaSource", function () {
    if (isLoadedState(playerStateRef.getValue())) {
      playerStateRef.setValueIfChanged("RELOADING" /* PLAYER_STATES.RELOADING */);
    }
  }, cancelSignal);
  /**
   * Keep track of the last known stalling situation.
   * `null` if playback is not stalled.
   */
  var prevStallReason = null;
  initializer.addEventListener("stalled", function (s) {
    if (s !== prevStallReason) {
      if (isLoadedState(playerStateRef.getValue())) {
        playerStateRef.setValueIfChanged(getLoadedContentState(mediaElement, s));
      }
      prevStallReason = s;
    }
  }, cancelSignal);
  initializer.addEventListener("unstalled", function () {
    if (prevStallReason !== null) {
      if (isLoadedState(playerStateRef.getValue())) {
        playerStateRef.setValueIfChanged(getLoadedContentState(mediaElement, null));
      }
      prevStallReason = null;
    }
  }, cancelSignal);
  playbackObserver.listen(function (observation) {
    if (isLoadedState(playerStateRef.getValue()) && (0,array_includes/* default */.A)(["seeking", "ended", "play", "pause"], observation.event)) {
      playerStateRef.setValueIfChanged(getLoadedContentState(mediaElement, prevStallReason));
    }
  }, {
    clearSignal: cancelSignal
  });
  return playerStateRef;
}
/**
 * Get state string for a _loaded_ content.
 * @param {HTMLMediaElement} mediaElement
 * @param {Object} stalledStatus - Current stalled state:
 *   - null when not stalled
 *   - a description of the situation if stalled.
 * @returns {string}
 */
function getLoadedContentState(mediaElement, stalledStatus) {
  var _config$getCurrent = config/* default */.A.getCurrent(),
    FORCED_ENDED_THRESHOLD = _config$getCurrent.FORCED_ENDED_THRESHOLD;
  if (mediaElement.ended) {
    return "ENDED" /* PLAYER_STATES.ENDED */;
  }
  if (stalledStatus !== null) {
    // On some old browsers (e.g. Chrome 54), the browser does not
    // emit an 'ended' event in some conditions. Detect if we
    // reached the end by comparing the current position and the
    // duration instead.
    var gapBetweenDurationAndCurrentTime = Math.abs(mediaElement.duration - mediaElement.currentTime);
    if (FORCED_ENDED_THRESHOLD != null && gapBetweenDurationAndCurrentTime < FORCED_ENDED_THRESHOLD) {
      return "ENDED" /* PLAYER_STATES.ENDED */;
    }
    return stalledStatus === "seeking" ? "SEEKING" /* PLAYER_STATES.SEEKING */ : "BUFFERING" /* PLAYER_STATES.BUFFERING */;
  }
  return mediaElement.paused ? "PAUSED" /* PLAYER_STATES.PAUSED */ : "PLAYING" /* PLAYER_STATES.PLAYING */;
}
function isLoadedState(state) {
  return state !== "LOADING" /* PLAYER_STATES.LOADING */ && state !== "RELOADING" /* PLAYER_STATES.RELOADING */ && state !== "STOPPED" /* PLAYER_STATES.STOPPED */;
}
;// CONCATENATED MODULE: ./src/core/api/public_api.ts


function public_api_createForOfIteratorHelperLoose(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (t) return (t = t.call(r)).next.bind(t); if (Array.isArray(r) || (t = public_api_unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var o = 0; return function () { return o >= r.length ? { done: !0 } : { done: !1, value: r[o++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function public_api_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return public_api_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? public_api_arrayLikeToArray(r, a) : void 0; } }
function public_api_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * This file defines the public API for the RxPlayer.
 * It also starts the different sub-parts of the player on various API calls.
 */

/* eslint-disable-next-line max-len */





















/* eslint-disable @typescript-eslint/naming-convention */
var generateContentId = (0,id_generator/* default */.A)();
var getPageActivityRef = event_listeners/* getPageActivityRef */.Sb,
  getPictureOnPictureStateRef = event_listeners/* getPictureOnPictureStateRef */.o8,
  getVideoVisibilityRef = event_listeners/* getVideoVisibilityRef */.ng,
  getVideoWidthRef = event_listeners/* getVideoWidthRef */.Vb,
  onFullscreenChange = event_listeners/* onFullscreenChange */.rR,
  onTextTrackAdded = event_listeners/* onTextTrackAdded */.Ah,
  onTextTrackRemoved = event_listeners/* onTextTrackRemoved */.c_;
/**
 * @class Player
 * @extends EventEmitter
 */
var Player = /*#__PURE__*/function (_EventEmitter) {
  /**
   * @constructor
   * @param {Object} options
   */
  function Player(options) {
    var _this;
    if (options === void 0) {
      options = {};
    }
    var _a, _b;
    _this = _EventEmitter.call(this) || this;
    var _parseConstructorOpti = parseConstructorOptions(options),
      initialAudioBitrate = _parseConstructorOpti.initialAudioBitrate,
      initialVideoBitrate = _parseConstructorOpti.initialVideoBitrate,
      limitVideoWidth = _parseConstructorOpti.limitVideoWidth,
      minAudioBitrate = _parseConstructorOpti.minAudioBitrate,
      minVideoBitrate = _parseConstructorOpti.minVideoBitrate,
      maxAudioBitrate = _parseConstructorOpti.maxAudioBitrate,
      maxBufferAhead = _parseConstructorOpti.maxBufferAhead,
      maxBufferBehind = _parseConstructorOpti.maxBufferBehind,
      maxVideoBitrate = _parseConstructorOpti.maxVideoBitrate,
      preferredAudioTracks = _parseConstructorOpti.preferredAudioTracks,
      preferredTextTracks = _parseConstructorOpti.preferredTextTracks,
      preferredVideoTracks = _parseConstructorOpti.preferredVideoTracks,
      throttleWhenHidden = _parseConstructorOpti.throttleWhenHidden,
      throttleVideoBitrateWhenHidden = _parseConstructorOpti.throttleVideoBitrateWhenHidden,
      videoElement = _parseConstructorOpti.videoElement,
      wantedBufferAhead = _parseConstructorOpti.wantedBufferAhead,
      maxVideoBufferSize = _parseConstructorOpti.maxVideoBufferSize,
      stopAtEnd = _parseConstructorOpti.stopAtEnd;
    var _config$getCurrent = config/* default */.A.getCurrent(),
      DEFAULT_UNMUTED_VOLUME = _config$getCurrent.DEFAULT_UNMUTED_VOLUME;
    // Workaround to support Firefox autoplay on FF 42.
    // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1194624
    videoElement.preload = "auto";
    _this.version = /* PLAYER_VERSION */"3.33.4";
    _this.log = src_log/* default */.A;
    _this.state = "STOPPED";
    _this.videoElement = videoElement;
    Player._priv_registerVideoElement(_this.videoElement);
    var destroyCanceller = new task_canceller/* default */.Ay();
    _this._destroyCanceller = destroyCanceller;
    _this._priv_pictureInPictureRef = getPictureOnPictureStateRef(videoElement, destroyCanceller.signal);
    /** @deprecated */
    onFullscreenChange(videoElement, function () {
      /* eslint-disable import/no-deprecated */
      _this.trigger("fullscreenChange", _this.isFullscreen());
      /* eslint-enable import/no-deprecated */
    }, destroyCanceller.signal);
    /** Store last known TextTrack array linked to the media element. */
    var prevTextTracks = [];
    for (var i = 0; i < ((_a = videoElement.textTracks) === null || _a === void 0 ? void 0 : _a.length); i++) {
      var textTrack = (_b = videoElement.textTracks) === null || _b === void 0 ? void 0 : _b[i];
      if (!(0,is_null_or_undefined/* default */.A)(textTrack)) {
        prevTextTracks.push(textTrack);
      }
    }
    /** Callback called when a TextTrack element is added or removed. */
    var onTextTrackChanges = function onTextTrackChanges(_evt) {
      var evt = _evt;
      var target = evt.target;
      var textTrackArr = [];
      for (var _i = 0; _i < target.length; _i++) {
        var _textTrack = target[_i];
        textTrackArr.push(_textTrack);
      }
      var oldTextTracks = prevTextTracks;
      prevTextTracks = textTrackArr;
      // We can have two consecutive textTrackChanges with the exact same
      // payload when we perform multiple texttrack operations before the event
      // loop is freed.
      if (oldTextTracks.length !== textTrackArr.length) {
        _this._priv_onNativeTextTracksNext(textTrackArr);
        return;
      }
      for (var _i2 = 0; _i2 < oldTextTracks.length; _i2++) {
        if (oldTextTracks[_i2] !== textTrackArr[_i2]) {
          _this._priv_onNativeTextTracksNext(textTrackArr);
          return;
        }
      }
      return;
    };
    if (!(0,is_null_or_undefined/* default */.A)(videoElement.textTracks)) {
      onTextTrackAdded(videoElement.textTracks, onTextTrackChanges, destroyCanceller.signal);
      onTextTrackRemoved(videoElement.textTracks, onTextTrackChanges, destroyCanceller.signal);
    }
    _this._priv_speed = new reference/* default */.A(videoElement.playbackRate, _this._destroyCanceller.signal);
    _this._priv_preferTrickModeTracks = false;
    _this._priv_contentLock = new reference/* default */.A(false, _this._destroyCanceller.signal);
    _this._priv_bufferOptions = {
      wantedBufferAhead: new reference/* default */.A(wantedBufferAhead, _this._destroyCanceller.signal),
      maxBufferAhead: new reference/* default */.A(maxBufferAhead, _this._destroyCanceller.signal),
      maxBufferBehind: new reference/* default */.A(maxBufferBehind, _this._destroyCanceller.signal),
      maxVideoBufferSize: new reference/* default */.A(maxVideoBufferSize, _this._destroyCanceller.signal)
    };
    _this._priv_bitrateInfos = {
      lastBitrates: {
        audio: initialAudioBitrate,
        video: initialVideoBitrate
      },
      minAutoBitrates: {
        audio: new reference/* default */.A(minAudioBitrate, _this._destroyCanceller.signal),
        video: new reference/* default */.A(minVideoBitrate, _this._destroyCanceller.signal)
      },
      maxAutoBitrates: {
        audio: new reference/* default */.A(maxAudioBitrate, _this._destroyCanceller.signal),
        video: new reference/* default */.A(maxVideoBitrate, _this._destroyCanceller.signal)
      },
      manualBitrates: {
        audio: new reference/* default */.A(-1, _this._destroyCanceller.signal),
        video: new reference/* default */.A(-1, _this._destroyCanceller.signal)
      }
    };
    _this._priv_throttleWhenHidden = throttleWhenHidden;
    _this._priv_throttleVideoBitrateWhenHidden = throttleVideoBitrateWhenHidden;
    _this._priv_limitVideoWidth = limitVideoWidth;
    _this._priv_mutedMemory = DEFAULT_UNMUTED_VOLUME;
    _this._priv_currentError = null;
    _this._priv_contentInfos = null;
    _this._priv_contentEventsMemory = {};
    _this._priv_stopAtEnd = stopAtEnd;
    _this._priv_setPlayerState("STOPPED" /* PLAYER_STATES.STOPPED */);
    _this._priv_preferredAudioTracks = preferredAudioTracks;
    _this._priv_preferredTextTracks = preferredTextTracks;
    _this._priv_preferredVideoTracks = preferredVideoTracks;
    _this._priv_reloadingMetadata = {};
    _this._priv_lastAutoPlay = false;
    return _this;
  }
  /**
   * Register a new callback for a player event event.
   *
   * @param {string} evt - The event to register a callback to
   * @param {Function} fn - The callback to call as that event is triggered.
   * The callback will take as argument the eventual payload of the event
   * (single argument).
   */
  (0,inheritsLoose/* default */.A)(Player, _EventEmitter);
  /**
   * Add feature(s) to the RxPlayer.
   * @param {Array.<Object>} featureList - Features wanted.
   */
  Player.addFeatures = function addFeatures(featureList) {
    add_features_addFeatures(featureList);
  }
  /**
   * Register the video element to the set of elements currently in use.
   * @param videoElement the video element to register.
   * @throws Error - Throws if the element is already used by another player instance.
   */;
  Player._priv_registerVideoElement = function _priv_registerVideoElement(videoElement) {
    if (Player._priv_currentlyUsedVideoElements.has(videoElement)) {
      var errorMessage = "The video element is already attached to another RxPlayer instance." + "\nMake sure to dispose the previous instance with player.dispose() " + "before creating a new player instance attaching that video element.";
      // eslint-disable-next-line no-console
      console.warn(errorMessage);
      /*
       * TODO: for next major version 5.0: this need to throw an error instead
       * of just logging this was not done for minor version as it could be
       * considerated a breaking change.
       *
       * throw new Error(errorMessage);
       */
    }
    Player._priv_currentlyUsedVideoElements.add(videoElement);
  }
  /**
   * Deregister the video element of the set of elements currently in use.
   * @param videoElement the video element to deregister.
   */;
  Player._priv_deregisterVideoElement = function _priv_deregisterVideoElement(videoElement) {
    if (Player._priv_currentlyUsedVideoElements.has(videoElement)) {
      Player._priv_currentlyUsedVideoElements["delete"](videoElement);
    }
  };
  var _proto = Player.prototype;
  _proto.addEventListener = function addEventListener(evt, fn) {
    // The EventEmitter's `addEventListener` method takes an optional third
    // argument that we do not want to expose in the public API.
    // We thus overwrite that function to remove any possible usage of that
    // third argument.
    return _EventEmitter.prototype.addEventListener.call(this, evt, fn);
  }
  /**
   * Stop the playback for the current content.
   */;
  _proto.stop = function stop() {
    if (this._priv_contentInfos !== null) {
      this._priv_contentInfos.currentContentCanceller.cancel();
    }
    this._priv_cleanUpCurrentContentState();
    if (this.state !== "STOPPED" /* PLAYER_STATES.STOPPED */) {
      this._priv_setPlayerState("STOPPED" /* PLAYER_STATES.STOPPED */);
    }
  }
  /**
   * Free the resources used by the player.
   * /!\ The player cannot be "used" anymore after this method has been called.
   */;
  _proto.dispose = function dispose() {
    // free resources linked to the loaded content
    this.stop();
    if (this.videoElement !== null) {
      Player._priv_deregisterVideoElement(this.videoElement);
      // free resources used for decryption management
      disposeDecryptionResources(this.videoElement)["catch"](function (err) {
        var message = err instanceof Error ? err.message : "Unknown error";
        src_log/* default */.A.error("API: Could not dispose decryption resources: " + message);
      });
    }
    // free resources linked to the Player instance
    this._destroyCanceller.cancel();
    this._priv_reloadingMetadata = {};
    // un-attach video element
    this.videoElement = null;
  }
  /**
   * Load a new video.
   * @param {Object} opts
   */;
  _proto.loadVideo = function loadVideo(opts) {
    var options = parseLoadVideoOptions(opts);
    src_log/* default */.A.info("API: Calling loadvideo", options.url, options.transport);
    this._priv_reloadingMetadata = {
      options: options
    };
    this._priv_initializeContentPlayback(options);
    this._priv_lastAutoPlay = options.autoPlay;
  }
  /**
   * Reload the last loaded content.
   * @param {Object} reloadOpts
   */;
  _proto.reload = function reload(reloadOpts) {
    var _a, _b, _c;
    var _this$_priv_reloading = this._priv_reloadingMetadata,
      options = _this$_priv_reloading.options,
      manifest = _this$_priv_reloading.manifest,
      reloadPosition = _this$_priv_reloading.reloadPosition,
      reloadInPause = _this$_priv_reloading.reloadInPause;
    if (options === undefined) {
      throw new Error("API: Can't reload without having previously loaded a content.");
    }
    checkReloadOptions(reloadOpts);
    var startAt;
    if (((_a = reloadOpts === null || reloadOpts === void 0 ? void 0 : reloadOpts.reloadAt) === null || _a === void 0 ? void 0 : _a.position) !== undefined) {
      startAt = {
        position: reloadOpts.reloadAt.position
      };
    } else if (((_b = reloadOpts === null || reloadOpts === void 0 ? void 0 : reloadOpts.reloadAt) === null || _b === void 0 ? void 0 : _b.relative) !== undefined) {
      if (reloadPosition === undefined) {
        throw new Error("Can't reload to a relative position when previous content was not loaded.");
      } else {
        startAt = {
          position: reloadOpts.reloadAt.relative + reloadPosition
        };
      }
    } else if (reloadPosition !== undefined) {
      startAt = {
        position: reloadPosition
      };
    }
    var autoPlay;
    if ((reloadOpts === null || reloadOpts === void 0 ? void 0 : reloadOpts.autoPlay) !== undefined) {
      autoPlay = reloadOpts.autoPlay;
    } else if (reloadInPause !== undefined) {
      autoPlay = !reloadInPause;
    }
    var keySystems;
    if ((reloadOpts === null || reloadOpts === void 0 ? void 0 : reloadOpts.keySystems) !== undefined) {
      keySystems = reloadOpts.keySystems;
    } else if (((_c = this._priv_reloadingMetadata.options) === null || _c === void 0 ? void 0 : _c.keySystems) !== undefined) {
      keySystems = this._priv_reloadingMetadata.options.keySystems;
    }
    var newOptions = Object.assign(Object.assign({}, options), {
      initialManifest: manifest
    });
    if (startAt !== undefined) {
      newOptions.startAt = startAt;
    }
    if (autoPlay !== undefined) {
      newOptions.autoPlay = autoPlay;
    }
    if (keySystems !== undefined) {
      newOptions.keySystems = keySystems;
    }
    this._priv_initializeContentPlayback(newOptions);
  };
  _proto.createDebugElement = function createDebugElement(element) {
    if (features/* default */.A.createDebugElement === null) {
      throw new Error("Feature `DEBUG_ELEMENT` not added to the RxPlayer");
    }
    var canceller = new task_canceller/* default */.Ay();
    features/* default */.A.createDebugElement(element, this, canceller.signal);
    return {
      dispose: function dispose() {
        canceller.cancel();
      }
    };
  }
  /**
   * From given options, initialize content playback.
   * @param {Object} options
   */;
  _proto._priv_initializeContentPlayback = function _priv_initializeContentPlayback(options) {
    var _this2 = this;
    var autoPlay = options.autoPlay,
      audioTrackSwitchingMode = options.audioTrackSwitchingMode,
      defaultAudioTrack = options.defaultAudioTrack,
      defaultTextTrack = options.defaultTextTrack,
      enableFastSwitching = options.enableFastSwitching,
      initialManifest = options.initialManifest,
      keySystems = options.keySystems,
      lowLatencyMode = options.lowLatencyMode,
      manualBitrateSwitchingMode = options.manualBitrateSwitchingMode,
      minimumManifestUpdateInterval = options.minimumManifestUpdateInterval,
      networkConfig = options.networkConfig,
      onCodecSwitch = options.onCodecSwitch,
      startAt = options.startAt,
      transport = options.transport,
      transportOptions = options.transportOptions,
      url = options.url;
    // Perform multiple checks on the given options
    if (this.videoElement === null) {
      throw new Error("the attached video element is disposed");
    }
    var isDirectFile = transport === "directfile";
    /** Emit to stop the current content. */
    var currentContentCanceller = new task_canceller/* default */.Ay();
    var videoElement = this.videoElement;
    var initializer;
    var mediaElementTrackChoiceManager = null;
    if (!isDirectFile) {
      var transportFn = features/* default */.A.transports[transport];
      if (typeof transportFn !== "function") {
        // Stop previous content and reset its state
        this.stop();
        this._priv_currentError = null;
        throw new Error("transport \"" + transport + "\" not supported");
      }
      if (features/* default */.A.mediaSourceInit === null) {
        throw new Error("MediaSource streaming not supported");
      }
      var transportPipelines = transportFn(transportOptions);
      var offlineRetry = networkConfig.offlineRetry,
        segmentRetry = networkConfig.segmentRetry,
        manifestRetry = networkConfig.manifestRetry,
        manifestRequestTimeout = networkConfig.manifestRequestTimeout,
        segmentRequestTimeout = networkConfig.segmentRequestTimeout;
      /** Interface used to load and refresh the Manifest. */
      var manifestRequestSettings = {
        lowLatencyMode: lowLatencyMode,
        maxRetryRegular: manifestRetry,
        maxRetryOffline: offlineRetry,
        requestTimeout: manifestRequestTimeout,
        minimumManifestUpdateInterval: minimumManifestUpdateInterval,
        initialManifest: initialManifest
      };
      var relyOnVideoVisibilityAndSize = canRelyOnVideoVisibilityAndSize();
      var throttlers = {
        throttle: {},
        throttleBitrate: {},
        limitWidth: {}
      };
      if (this._priv_throttleWhenHidden) {
        if (!relyOnVideoVisibilityAndSize) {
          src_log/* default */.A.warn("API: Can't apply throttleWhenHidden because " + "browser can't be trusted for visibility.");
        } else {
          throttlers.throttle = {
            video: (0,reference/* createMappedReference */.D)(getPageActivityRef(currentContentCanceller.signal), function (isActive) {
              return isActive ? Infinity : 0;
            }, currentContentCanceller.signal)
          };
        }
      }
      if (this._priv_throttleVideoBitrateWhenHidden) {
        if (!relyOnVideoVisibilityAndSize) {
          src_log/* default */.A.warn("API: Can't apply throttleVideoBitrateWhenHidden because " + "browser can't be trusted for visibility.");
        } else {
          throttlers.throttleBitrate = {
            video: (0,reference/* createMappedReference */.D)(getVideoVisibilityRef(this._priv_pictureInPictureRef, currentContentCanceller.signal), function (isActive) {
              return isActive ? Infinity : 0;
            }, currentContentCanceller.signal)
          };
        }
      }
      if (this._priv_limitVideoWidth) {
        if (!relyOnVideoVisibilityAndSize) {
          src_log/* default */.A.warn("API: Can't apply limitVideoWidth because browser can't be " + "trusted for video size.");
        } else {
          throttlers.limitWidth = {
            video: getVideoWidthRef(videoElement, this._priv_pictureInPictureRef, currentContentCanceller.signal)
          };
        }
      }
      /** Options used by the adaptive logic. */
      var adaptiveOptions = {
        initialBitrates: this._priv_bitrateInfos.lastBitrates,
        lowLatencyMode: lowLatencyMode,
        manualBitrates: this._priv_bitrateInfos.manualBitrates,
        minAutoBitrates: this._priv_bitrateInfos.minAutoBitrates,
        maxAutoBitrates: this._priv_bitrateInfos.maxAutoBitrates,
        throttlers: throttlers
      };
      /** Options used by the TextTrack SegmentBuffer. */
      var textTrackOptions = options.textTrackMode === "native" ? {
        textTrackMode: "native",
        hideNativeSubtitle: options.hideNativeSubtitle
      } : {
        textTrackMode: "html",
        textTrackElement: options.textTrackElement
      };
      var bufferOptions = (0,object_assign/* default */.A)({
        audioTrackSwitchingMode: audioTrackSwitchingMode,
        enableFastSwitching: enableFastSwitching,
        manualBitrateSwitchingMode: manualBitrateSwitchingMode,
        onCodecSwitch: onCodecSwitch
      }, this._priv_bufferOptions);
      var segmentRequestOptions = {
        lowLatencyMode: lowLatencyMode,
        maxRetryRegular: segmentRetry,
        requestTimeout: segmentRequestTimeout,
        maxRetryOffline: offlineRetry
      };
      initializer = new features/* default */.A.mediaSourceInit({
        adaptiveOptions: adaptiveOptions,
        autoPlay: autoPlay,
        bufferOptions: bufferOptions,
        keySystems: keySystems,
        lowLatencyMode: lowLatencyMode,
        manifestRequestSettings: manifestRequestSettings,
        transport: transportPipelines,
        segmentRequestOptions: segmentRequestOptions,
        speed: this._priv_speed,
        startAt: startAt,
        textTrackOptions: textTrackOptions,
        url: url
      });
    } else {
      if (features/* default */.A.directfile === null) {
        this.stop();
        this._priv_currentError = null;
        throw new Error("DirectFile feature not activated in your build.");
      } else if ((0,is_null_or_undefined/* default */.A)(url)) {
        throw new Error("No URL for a DirectFile content");
      }
      mediaElementTrackChoiceManager = this._priv_initializeMediaElementTrackChoiceManager(defaultAudioTrack, defaultTextTrack, currentContentCanceller.signal);
      if (currentContentCanceller.isUsed()) {
        return;
      }
      initializer = new features/* default */.A.directfile.initDirectFile({
        autoPlay: autoPlay,
        keySystems: keySystems,
        speed: this._priv_speed,
        startAt: startAt,
        url: url
      });
    }
    /** Future `this._priv_contentInfos` related to this content. */
    var contentInfos = {
      contentId: generateContentId(),
      originalUrl: url,
      currentContentCanceller: currentContentCanceller,
      initializer: initializer,
      isDirectFile: isDirectFile,
      segmentBuffersStore: null,
      thumbnails: null,
      manifest: null,
      currentPeriod: null,
      activeAdaptations: null,
      activeRepresentations: null,
      initialAudioTrack: defaultAudioTrack,
      initialTextTrack: defaultTextTrack,
      trackChoiceManager: null,
      mediaElementTrackChoiceManager: mediaElementTrackChoiceManager
    };
    // Bind events
    initializer.addEventListener("error", function (error) {
      var formattedError = (0,format_error/* default */.A)(error, {
        defaultCode: "NONE",
        defaultReason: "An unknown error stopped content playback."
      });
      formattedError.fatal = true;
      contentInfos.currentContentCanceller.cancel();
      _this2._priv_cleanUpCurrentContentState();
      _this2._priv_currentError = formattedError;
      src_log/* default */.A.error("API: The player stopped because of an error", error instanceof Error ? error : "");
      _this2._priv_setPlayerState("STOPPED" /* PLAYER_STATES.STOPPED */);
      // TODO This condition is here because the eventual callback called when the
      // player state is updated can launch a new content, thus the error will not
      // be here anymore, in which case triggering the "error" event is unwanted.
      // This is very ugly though, and we should probable have a better solution
      if (_this2._priv_currentError === formattedError) {
        _this2.trigger("error", formattedError);
      }
    });
    initializer.addEventListener("warning", function (error) {
      var formattedError = (0,format_error/* default */.A)(error, {
        defaultCode: "NONE",
        defaultReason: "An unknown error happened."
      });
      src_log/* default */.A.warn("API: Sending warning:", formattedError);
      _this2.trigger("warning", formattedError);
    });
    initializer.addEventListener("reloadingMediaSource", function (payload) {
      contentInfos.segmentBuffersStore = null;
      if (contentInfos.trackChoiceManager !== null) {
        contentInfos.trackChoiceManager.resetPeriods();
      }
      _this2._priv_lastAutoPlay = payload.autoPlay;
    });
    initializer.addEventListener("inbandEvents", function (inbandEvents) {
      return _this2.trigger("inbandEvents", inbandEvents);
    });
    initializer.addEventListener("streamEvent", function (streamEvent) {
      return _this2.trigger("streamEvent", streamEvent);
    });
    initializer.addEventListener("streamEventSkip", function (streamEventSkip) {
      return _this2.trigger("streamEventSkip", streamEventSkip);
    });
    initializer.addEventListener("decipherabilityUpdate", function (decipherabilityUpdate) {
      return _this2.trigger("decipherabilityUpdate", decipherabilityUpdate);
    });
    initializer.addEventListener("activePeriodChanged", function (periodInfo) {
      return _this2._priv_onActivePeriodChanged(contentInfos, periodInfo);
    });
    initializer.addEventListener("periodStreamReady", function (periodReadyInfo) {
      return _this2._priv_onPeriodStreamReady(contentInfos, periodReadyInfo);
    });
    initializer.addEventListener("periodStreamCleared", function (periodClearedInfo) {
      return _this2._priv_onPeriodStreamCleared(contentInfos, periodClearedInfo);
    });
    initializer.addEventListener("representationChange", function (representationInfo) {
      return _this2._priv_onRepresentationChange(contentInfos, representationInfo);
    });
    initializer.addEventListener("adaptationChange", function (adaptationInfo) {
      return _this2._priv_onAdaptationChange(contentInfos, adaptationInfo);
    });
    initializer.addEventListener("bitrateEstimationChange", function (bitrateEstimationInfo) {
      return _this2._priv_onBitrateEstimationChange(bitrateEstimationInfo);
    });
    initializer.addEventListener("manifestReady", function (manifest) {
      return _this2._priv_onManifestReady(contentInfos, manifest);
    });
    initializer.addEventListener("loaded", function (evt) {
      contentInfos.segmentBuffersStore = evt.segmentBuffersStore;
    });
    initializer.addEventListener("addedSegment", function (evt) {
      // Manage image tracks
      // @deprecated
      var content = evt.content,
        segmentData = evt.segmentData;
      if (content.adaptation.type === "image") {
        if (!(0,is_null_or_undefined/* default */.A)(segmentData) && segmentData.type === "bif") {
          var imageData = segmentData.data;
          /* eslint-disable import/no-deprecated */
          contentInfos.thumbnails = imageData;
          _this2.trigger("imageTrackUpdate", {
            data: contentInfos.thumbnails
          });
          /* eslint-enable import/no-deprecated */
        }
      }
    });
    // Now, that most events are linked, prepare the next content.
    initializer.prepare();
    // Now that the content is prepared, stop previous content and reset state
    // This is done after content preparation as `stop` could technically have
    // a long and synchronous blocking time.
    // Note that this call is done **synchronously** after all events linking.
    // This is **VERY** important so:
    //   - the `STOPPED` state is switched to synchronously after loading a new
    //     content.
    //   - we can avoid involontarily catching events linked to the previous
    //     content.
    this.stop();
    /** Global "playback observer" which will emit playback conditions */
    var playbackObserver = new PlaybackObserver(videoElement, {
      withMediaSource: !isDirectFile,
      lowLatencyMode: lowLatencyMode
    });
    currentContentCanceller.signal.register(function () {
      playbackObserver.stop();
    });
    // Update the RxPlayer's state at the right events
    var playerStateRef = constructPlayerStateReference(initializer, videoElement, playbackObserver, currentContentCanceller.signal);
    currentContentCanceller.signal.register(function () {
      initializer.dispose();
    });
    /**
     * Function updating `this._priv_reloadingMetadata` in function of the
     * current state and playback conditions.
     * To call when either might change.
     * @param {string} state - The player state we're about to switch to.
     */
    var updateReloadingMetadata = function updateReloadingMetadata(state) {
      switch (state) {
        case "STOPPED":
        case "RELOADING":
        case "LOADING":
          break;
        // keep previous metadata
        case "ENDED":
          _this2._priv_reloadingMetadata.reloadInPause = true;
          _this2._priv_reloadingMetadata.reloadPosition = playbackObserver.getReference().getValue().position;
          break;
        default:
          var o = playbackObserver.getReference().getValue();
          _this2._priv_reloadingMetadata.reloadInPause = o.paused;
          _this2._priv_reloadingMetadata.reloadPosition = o.position;
          break;
      }
    };
    /**
     * `TaskCanceller` allowing to stop emitting `"play"` and `"pause"`
     * events.
     * `null` when such events are not emitted currently.
     */
    var playPauseEventsCanceller = null;
    /**
     * Callback emitting `"play"` and `"pause`" events once the content is
     * loaded, starting from the state indicated in argument.
     * @param {boolean} willAutoPlay - If `false`, we're currently paused.
     */
    var triggerPlayPauseEventsWhenReady = function triggerPlayPauseEventsWhenReady(willAutoPlay) {
      if (playPauseEventsCanceller !== null) {
        playPauseEventsCanceller.cancel(); // cancel previous logic
        playPauseEventsCanceller = null;
      }
      playerStateRef.onUpdate(function (val, stopListeningToStateUpdates) {
        if (!isLoadedState(val)) {
          return; // content not loaded yet: no event
        }
        stopListeningToStateUpdates();
        if (playPauseEventsCanceller !== null) {
          playPauseEventsCanceller.cancel();
        }
        playPauseEventsCanceller = new task_canceller/* default */.Ay();
        playPauseEventsCanceller.linkToSignal(currentContentCanceller.signal);
        if (willAutoPlay !== !videoElement.paused) {
          // paused status is not at the expected value on load: emit event
          if (videoElement.paused) {
            _this2.trigger("pause", null);
          } else {
            _this2.trigger("play", null);
          }
        }
        emitPlayPauseEvents(videoElement, function () {
          return _this2.trigger("play", null);
        }, function () {
          return _this2.trigger("pause", null);
        }, currentContentCanceller.signal);
      }, {
        emitCurrentValue: false,
        clearSignal: currentContentCanceller.signal
      });
    };
    triggerPlayPauseEventsWhenReady(autoPlay);
    initializer.addEventListener("reloadingMediaSource", function (payload) {
      triggerPlayPauseEventsWhenReady(payload.autoPlay);
    });
    /**
     * `TaskCanceller` allowing to stop emitting `"seeking"` and `"seeked"`
     * events.
     * `null` when such events are not emitted currently.
     */
    var seekEventsCanceller = null;
    // React to player state change
    playerStateRef.onUpdate(function (newState) {
      updateReloadingMetadata(newState);
      _this2._priv_setPlayerState(newState);
      if (currentContentCanceller.isUsed()) {
        return;
      }
      if (seekEventsCanceller !== null) {
        if (!isLoadedState(_this2.state)) {
          seekEventsCanceller.cancel();
          seekEventsCanceller = null;
        }
      } else if (isLoadedState(_this2.state)) {
        seekEventsCanceller = new task_canceller/* default */.Ay();
        seekEventsCanceller.linkToSignal(currentContentCanceller.signal);
        emitSeekEvents(videoElement, playbackObserver, function () {
          return _this2.trigger("seeking", null);
        }, function () {
          return _this2.trigger("seeked", null);
        }, seekEventsCanceller.signal);
      }
      // Previous call could have performed all kind of side-effects, thus,
      // we re-check the current state associated to the RxPlayer
      if (_this2.state === "ENDED" /* PLAYER_STATES.ENDED */ && _this2._priv_stopAtEnd) {
        _this2.stop();
      }
    }, {
      emitCurrentValue: true,
      clearSignal: currentContentCanceller.signal
    });
    // React to playback conditions change
    playbackObserver.listen(function (observation) {
      updateReloadingMetadata(_this2.state);
      _this2._priv_triggerPositionUpdate(contentInfos, observation);
    }, {
      clearSignal: currentContentCanceller.signal
    });
    this._priv_currentError = null;
    this._priv_contentInfos = contentInfos;
    currentContentCanceller.signal.register(function () {
      initializer.removeEventListener();
    });
    // initialize the content only when the lock is inactive
    this._priv_contentLock.onUpdate(function (isLocked, stopListeningToLock) {
      if (!isLocked) {
        stopListeningToLock();
        // start playback!
        initializer.start(videoElement, playbackObserver);
      }
    }, {
      emitCurrentValue: true,
      clearSignal: currentContentCanceller.signal
    });
  }
  /**
   * Returns fatal error if one for the current content.
   * null otherwise.
   * @returns {Object|null} - The current Error (`null` when no error).
   */;
  _proto.getError = function getError() {
    return this._priv_currentError;
  }
  /**
   * Returns manifest/playlist object.
   * null if the player is STOPPED.
   * @deprecated
   * @returns {Manifest|null} - The current Manifest (`null` when not known).
   */;
  _proto.getManifest = function getManifest() {
    (0,warn_once/* default */.A)("getManifest is deprecated." + " Please open an issue if you used this API.");
    if (this._priv_contentInfos === null) {
      return null;
    }
    return this._priv_contentInfos.manifest;
  }
  /**
   * Returns Adaptations (tracks) for every currently playing type
   * (audio/video/text...).
   * @deprecated
   * @returns {Object|null} - The current Adaptation objects, per type (`null`
   * when none is known for now.
   */;
  _proto.getCurrentAdaptations = function getCurrentAdaptations() {
    (0,warn_once/* default */.A)("getCurrentAdaptations is deprecated." + " Please open an issue if you used this API.");
    if (this._priv_contentInfos === null) {
      return null;
    }
    var _this$_priv_contentIn = this._priv_contentInfos,
      currentPeriod = _this$_priv_contentIn.currentPeriod,
      activeAdaptations = _this$_priv_contentIn.activeAdaptations;
    if (currentPeriod === null || activeAdaptations === null || (0,is_null_or_undefined/* default */.A)(activeAdaptations[currentPeriod.id])) {
      return null;
    }
    return activeAdaptations[currentPeriod.id];
  }
  /**
   * Returns representations (qualities) for every currently playing type
   * (audio/video/text...).
   * @deprecated
   * @returns {Object|null} - The current Representation objects, per type
   * (`null` when none is known for now.
   */;
  _proto.getCurrentRepresentations = function getCurrentRepresentations() {
    (0,warn_once/* default */.A)("getCurrentRepresentations is deprecated." + " Please open an issue if you used this API.");
    return this._priv_getCurrentRepresentations();
  }
  /**
   * Returns the media DOM element used by the player.
   * You should not its HTML5 API directly and use the player's method instead,
   * to ensure a well-behaved player.
   * @returns {HTMLMediaElement|null} - The HTMLMediaElement used (`null` when
   * disposed)
   */;
  _proto.getVideoElement = function getVideoElement() {
    return this.videoElement;
  }
  /**
   * If one returns the first native text-track element attached to the media element.
   * @deprecated
   * @returns {TextTrack} - The native TextTrack attached (`null` when none)
   */;
  _proto.getNativeTextTrack = function getNativeTextTrack() {
    (0,warn_once/* default */.A)("getNativeTextTrack is deprecated." + " Please open an issue if you used this API.");
    if (this.videoElement === null) {
      throw new Error("Disposed player");
    }
    var videoElement = this.videoElement;
    var textTracks = videoElement.textTracks;
    if (textTracks.length > 0) {
      return videoElement.textTracks[0];
    } else {
      return null;
    }
  }
  /**
   * Returns the player's current state.
   * @returns {string} - The current Player's state
   */;
  _proto.getPlayerState = function getPlayerState() {
    return this.state;
  }
  /**
   * Returns true if a content is loaded.
   * @returns {Boolean} - `true` if a content is loaded, `false` otherwise.
   */;
  _proto.isContentLoaded = function isContentLoaded() {
    return !(0,array_includes/* default */.A)(["LOADING", "RELOADING", "STOPPED"], this.state);
  }
  /**
   * Returns true if the player is buffering.
   * @returns {Boolean} - `true` if the player is buffering, `false` otherwise.
   */;
  _proto.isBuffering = function isBuffering() {
    return (0,array_includes/* default */.A)(["BUFFERING", "SEEKING", "LOADING", "RELOADING"], this.state);
  }
  /**
   * Returns the play/pause status of the player :
   *   - when `LOADING` or `RELOADING`, returns the scheduled play/pause condition
   *     for when loading is over,
   *   - in other states, returns the `<video>` element .paused value,
   *   - if the player is disposed, returns `true`.
   * @returns {Boolean} - `true` if the player is paused or will be after loading,
   * `false` otherwise.
   */;
  _proto.isPaused = function isPaused() {
    if (this.videoElement) {
      if ((0,array_includes/* default */.A)(["LOADING", "RELOADING"], this.state)) {
        return !this._priv_lastAutoPlay;
      } else {
        return this.videoElement.paused;
      }
    }
    return true;
  }
  /**
   * Returns true if both:
   *   - a content is loaded
   *   - the content loaded is a live content
   * @returns {Boolean} - `true` if we're playing a live content, `false` otherwise.
   */;
  _proto.isLive = function isLive() {
    if (this._priv_contentInfos === null) {
      return false;
    }
    var _this$_priv_contentIn2 = this._priv_contentInfos,
      isDirectFile = _this$_priv_contentIn2.isDirectFile,
      manifest = _this$_priv_contentIn2.manifest;
    if (isDirectFile || manifest === null) {
      return false;
    }
    return manifest.isLive;
  }
  /**
   * Returns `true` if trickmode playback is active (usually through the usage
   * of the `setPlaybackRate` method), which means that the RxPlayer selects
   * "trickmode" video tracks in priority.
   * @returns {Boolean}
   */;
  _proto.areTrickModeTracksEnabled = function areTrickModeTracksEnabled() {
    return this._priv_preferTrickModeTracks;
  }
  /**
   * Returns the url of the currently considered Manifest, or of the content for
   * directfile content.
   * @returns {string|undefined} - Current URL. `undefined` if not known or no
   * URL yet.
   */;
  _proto.getUrl = function getUrl() {
    if (this._priv_contentInfos === null) {
      return undefined;
    }
    var _this$_priv_contentIn3 = this._priv_contentInfos,
      isDirectFile = _this$_priv_contentIn3.isDirectFile,
      manifest = _this$_priv_contentIn3.manifest,
      originalUrl = _this$_priv_contentIn3.originalUrl;
    if (isDirectFile) {
      return originalUrl;
    }
    if (manifest !== null) {
      return manifest.getUrl();
    }
    return undefined;
  }
  /**
   * Update URL of the content currently being played (e.g. DASH's MPD).
   * @param {Array.<string>|undefined} urls - URLs to reach that content /
   * Manifest from the most prioritized URL to the least prioritized URL.
   * @param {Object|undefined} [params]
   * @param {boolean} params.refresh - If `true` the resource in question
   * (e.g. DASH's MPD) will be refreshed immediately.
   */;
  _proto.updateContentUrls = function updateContentUrls(urls, params) {
    if (this._priv_contentInfos === null) {
      throw new Error("No content loaded");
    }
    var refreshNow = (params === null || params === void 0 ? void 0 : params.refresh) === true;
    this._priv_contentInfos.initializer.updateContentUrls(urls, refreshNow);
  }
  /**
   * Returns the video duration, in seconds.
   * NaN if no video is playing.
   * @returns {Number}
   */;
  _proto.getVideoDuration = function getVideoDuration() {
    if (this.videoElement === null) {
      throw new Error("Disposed player");
    }
    return this.videoElement.duration;
  }
  /**
   * Returns in seconds the difference between:
   *   - the end of the current contiguous loaded range.
   *   - the current time
   * @returns {Number}
   */;
  _proto.getVideoBufferGap = function getVideoBufferGap() {
    if (this.videoElement === null) {
      throw new Error("Disposed player");
    }
    var videoElement = this.videoElement;
    return (0,ranges/* getLeftSizeOfRange */.vK)(videoElement.buffered, videoElement.currentTime);
  }
  /**
   * Returns in seconds the difference between:
   *   - the end of the current contiguous loaded range.
   *   - the start of the current contiguous loaded range.
   * @returns {Number}
   */;
  _proto.getVideoLoadedTime = function getVideoLoadedTime() {
    (0,warn_once/* default */.A)("`getVideoLoadedTime` is deprecated and won't be present in the " + "next major version");
    if (this.videoElement === null) {
      throw new Error("Disposed player");
    }
    var videoElement = this.videoElement;
    return (0,ranges/* getSizeOfRange */.UL)(videoElement.buffered, videoElement.currentTime);
  }
  /**
   * Returns in seconds the difference between:
   *   - the current time.
   *   - the start of the current contiguous loaded range.
   * @returns {Number}
   */;
  _proto.getVideoPlayedTime = function getVideoPlayedTime() {
    (0,warn_once/* default */.A)("`getVideoPlayedTime` is deprecated and won't be present in the " + "next major version");
    if (this.videoElement === null) {
      throw new Error("Disposed player");
    }
    var videoElement = this.videoElement;
    return (0,ranges/* getPlayedSizeOfRange */.D3)(videoElement.buffered, videoElement.currentTime);
  }
  /**
   * Get the current position, in s, in wall-clock time.
   * That is:
   *   - for live content, get a timestamp, in s, of the current played content.
   *   - for static content, returns the position from beginning in s.
   *
   * If you do not know if you want to use this method or getPosition:
   *   - If what you want is to display the current time to the user, use this
   *     one.
   *   - If what you want is to interact with the player's API or perform other
   *     actions (like statistics) with the real player data, use getPosition.
   *
   * @returns {Number}
   */;
  _proto.getWallClockTime = function getWallClockTime() {
    if (this.videoElement === null) {
      throw new Error("Disposed player");
    }
    if (this._priv_contentInfos === null) {
      return this.videoElement.currentTime;
    }
    var _this$_priv_contentIn4 = this._priv_contentInfos,
      isDirectFile = _this$_priv_contentIn4.isDirectFile,
      manifest = _this$_priv_contentIn4.manifest;
    if (isDirectFile) {
      var startDate = getStartDate(this.videoElement);
      return (startDate !== null && startDate !== void 0 ? startDate : 0) + this.videoElement.currentTime;
    }
    if (manifest !== null) {
      var currentTime = this.videoElement.currentTime;
      var ast = manifest.availabilityStartTime !== undefined ? manifest.availabilityStartTime : 0;
      return currentTime + ast;
    }
    return 0;
  }
  /**
   * Get the current position, in seconds, of the video element.
   *
   * If you do not know if you want to use this method or getWallClockTime:
   *   - If what you want is to display the current time to the user, use
   *     getWallClockTime.
   *   - If what you want is to interact with the player's API or perform other
   *     actions (like statistics) with the real player data, use this one.
   *
   * @returns {Number}
   */;
  _proto.getPosition = function getPosition() {
    if (this.videoElement === null) {
      throw new Error("Disposed player");
    }
    return this.videoElement.currentTime;
  }
  /**
   * Returns the last stored content position, in seconds.
   *
   * @returns {number|undefined}
   */;
  _proto.getLastStoredContentPosition = function getLastStoredContentPosition() {
    return this._priv_reloadingMetadata.reloadPosition;
  }
  /**
   * Returns the current playback rate at which the video plays.
   * @returns {Number}
   */;
  _proto.getPlaybackRate = function getPlaybackRate() {
    return this._priv_speed.getValue();
  }
  /**
   * Update the playback rate of the video.
   *
   * This method's effect is persisted from content to content, and can be
   * called even when no content is playing (it will still have an effect for
   * the next contents).
   *
   * If you want to reverse effects provoked by `setPlaybackRate` before playing
   * another content, you will have to call `setPlaybackRate` first with the
   * default settings you want to set.
   *
   * As an example, to reset the speed to "normal" (x1) speed and to disable
   * trickMode video tracks (which may have been enabled by a previous
   * `setPlaybackRate` call), you can call:
   * ```js
   * player.setPlaybackRate(1, { preferTrickModeTracks: false });
   * ```
   *
   * --
   *
   * This method can be used to switch to or exit from "trickMode" video tracks,
   * which are tracks specifically defined to mimic the visual aspect of a VCR's
   * fast forward/rewind feature, by only displaying a few video frames during
   * playback.
   *
   * This behavior is configurable through the second argument, by adding a
   * property named `preferTrickModeTracks` to that object.
   *
   * You can set that value to `true` to switch to trickMode video tracks when
   * available, and set it to `false` when you want to disable that logic.
   * Note that like any configuration given to `setPlaybackRate`, this setting
   * is persisted through all future contents played by the player.
   *
   * If you want to stop enabling trickMode tracks, you will have to call
   * `setPlaybackRate` again with `preferTrickModeTracks` set to `false`.
   *
   * You can know at any moment whether this behavior is enabled by calling
   * the `areTrickModeTracksEnabled` method. This will only means that the
   * RxPlayer will select in priority trickmode video tracks, not that the
   * currently chosen video tracks is a trickmode track (for example, some
   * contents may have no trickmode tracks available).
   *
   * If you want to know about the latter instead, you can call `getVideoTrack`
   * and/or listen to `videoTrackChange` events. The track returned may have an
   * `isTrickModeTrack` property set to `true`, indicating that it is a
   * trickmode track.
   *
   * Note that switching to or getting out of a trickmode video track may
   * lead to the player being a brief instant in a `"RELOADING"` state (notified
   * through `playerStateChange` events and the `getLoadedContentState` method).
   * When in that state, a black screen may be displayed and multiple RxPlayer
   * APIs will not be usable.
   *
   * @param {Number} rate
   * @param {Object} opts
   */;
  _proto.setPlaybackRate = function setPlaybackRate(rate, opts) {
    var _a;
    if (rate !== this._priv_speed.getValue()) {
      this._priv_speed.setValue(rate);
    }
    var preferTrickModeTracks = opts === null || opts === void 0 ? void 0 : opts.preferTrickModeTracks;
    if (typeof preferTrickModeTracks !== "boolean") {
      return;
    }
    this._priv_preferTrickModeTracks = preferTrickModeTracks;
    var trackChoiceManager = (_a = this._priv_contentInfos) === null || _a === void 0 ? void 0 : _a.trackChoiceManager;
    if (!(0,is_null_or_undefined/* default */.A)(trackChoiceManager)) {
      if (preferTrickModeTracks && !trackChoiceManager.isTrickModeEnabled()) {
        trackChoiceManager.enableVideoTrickModeTracks();
      } else if (!preferTrickModeTracks && trackChoiceManager.isTrickModeEnabled()) {
        trackChoiceManager.disableVideoTrickModeTracks();
      }
    }
  }
  /**
   * Returns all available bitrates for the current video Adaptation.
   * @returns {Array.<Number>}
   */;
  _proto.getAvailableVideoBitrates = function getAvailableVideoBitrates() {
    if (this._priv_contentInfos === null) {
      return [];
    }
    var _this$_priv_contentIn5 = this._priv_contentInfos,
      currentPeriod = _this$_priv_contentIn5.currentPeriod,
      activeAdaptations = _this$_priv_contentIn5.activeAdaptations;
    if (currentPeriod === null || activeAdaptations === null) {
      return [];
    }
    var adaptations = activeAdaptations[currentPeriod.id];
    if (adaptations === undefined || (0,is_null_or_undefined/* default */.A)(adaptations.video)) {
      return [];
    }
    return adaptations.video.getAvailableBitrates();
  }
  /**
   * Returns all available bitrates for the current audio Adaptation.
   * @returns {Array.<Number>}
   */;
  _proto.getAvailableAudioBitrates = function getAvailableAudioBitrates() {
    if (this._priv_contentInfos === null) {
      return [];
    }
    var _this$_priv_contentIn6 = this._priv_contentInfos,
      currentPeriod = _this$_priv_contentIn6.currentPeriod,
      activeAdaptations = _this$_priv_contentIn6.activeAdaptations;
    if (currentPeriod === null || activeAdaptations === null) {
      return [];
    }
    var adaptations = activeAdaptations[currentPeriod.id];
    if (adaptations === undefined || (0,is_null_or_undefined/* default */.A)(adaptations.audio)) {
      return [];
    }
    return adaptations.audio.getAvailableBitrates();
  }
  /**
   * Returns the manual audio bitrate set. -1 if in AUTO mode.
   * @returns {Number}
   */;
  _proto.getManualAudioBitrate = function getManualAudioBitrate() {
    return this._priv_bitrateInfos.manualBitrates.audio.getValue();
  }
  /**
   * Returns the manual video bitrate set. -1 if in AUTO mode.
   * @returns {Number}
   */;
  _proto.getManualVideoBitrate = function getManualVideoBitrate() {
    return this._priv_bitrateInfos.manualBitrates.video.getValue();
  }
  /**
   * Returns currently considered bitrate for video segments.
   * @returns {Number|undefined}
   */;
  _proto.getVideoBitrate = function getVideoBitrate() {
    var representations = this._priv_getCurrentRepresentations();
    if (representations === null || (0,is_null_or_undefined/* default */.A)(representations.video)) {
      return undefined;
    }
    return representations.video.bitrate;
  }
  /**
   * Returns currently considered bitrate for audio segments.
   * @returns {Number|undefined}
   */;
  _proto.getAudioBitrate = function getAudioBitrate() {
    var representations = this._priv_getCurrentRepresentations();
    if (representations === null || (0,is_null_or_undefined/* default */.A)(representations.audio)) {
      return undefined;
    }
    return representations.audio.bitrate;
  }
  /**
   * Returns minimum wanted video bitrate currently set.
   * @returns {Number}
   */;
  _proto.getMinVideoBitrate = function getMinVideoBitrate() {
    return this._priv_bitrateInfos.minAutoBitrates.video.getValue();
  }
  /**
   * Returns minimum wanted audio bitrate currently set.
   * @returns {Number}
   */;
  _proto.getMinAudioBitrate = function getMinAudioBitrate() {
    return this._priv_bitrateInfos.minAutoBitrates.audio.getValue();
  }
  /**
   * Returns maximum wanted video bitrate currently set.
   * @returns {Number}
   */;
  _proto.getMaxVideoBitrate = function getMaxVideoBitrate() {
    return this._priv_bitrateInfos.maxAutoBitrates.video.getValue();
  }
  /**
   * Returns maximum wanted audio bitrate currently set.
   * @returns {Number}
   */;
  _proto.getMaxAudioBitrate = function getMaxAudioBitrate() {
    return this._priv_bitrateInfos.maxAutoBitrates.audio.getValue();
  }
  /**
   * Play/Resume the current video.
   * @returns {Promise}
   */;
  _proto.play = function play() {
    var _this3 = this;
    if (this.videoElement === null) {
      throw new Error("Disposed player");
    }
    var playPromise = this.videoElement.play();
    /* eslint-disable @typescript-eslint/unbound-method */
    if ((0,is_null_or_undefined/* default */.A)(playPromise) || typeof playPromise["catch"] !== "function") {
      /* eslint-enable @typescript-eslint/unbound-method */
      return Promise.resolve();
    }
    return playPromise["catch"](function (error) {
      if (error.name === "NotAllowedError") {
        var warning = new media_error/* default */.A("MEDIA_ERR_PLAY_NOT_ALLOWED", error.toString());
        _this3.trigger("warning", warning);
      }
      throw error;
    });
  }
  /**
   * Pause the current video.
   */;
  _proto.pause = function pause() {
    if (this.videoElement === null) {
      throw new Error("Disposed player");
    }
    this.videoElement.pause();
  }
  /**
   * Seek to a given absolute position.
   * @param {Number|Object} time
   * @returns {Number} - The time the player has seek to
   */;
  _proto.seekTo = function seekTo(time) {
    var _a;
    if (this.videoElement === null) {
      throw new Error("Disposed player");
    }
    if (this._priv_contentInfos === null) {
      throw new Error("player: no content loaded");
    }
    var _this$_priv_contentIn7 = this._priv_contentInfos,
      isDirectFile = _this$_priv_contentIn7.isDirectFile,
      manifest = _this$_priv_contentIn7.manifest;
    if (!isDirectFile && manifest === null) {
      throw new Error("player: the content did not load yet");
    }
    var positionWanted;
    if (typeof time === "number") {
      positionWanted = time;
    } else if (typeof time === "object") {
      var timeObj = time;
      var currentTs = this.videoElement.currentTime;
      if (!(0,is_null_or_undefined/* default */.A)(timeObj.relative)) {
        positionWanted = currentTs + timeObj.relative;
      } else if (!(0,is_null_or_undefined/* default */.A)(timeObj.position)) {
        positionWanted = timeObj.position;
      } else if (!(0,is_null_or_undefined/* default */.A)(timeObj.wallClockTime)) {
        if (manifest !== null) {
          positionWanted = timeObj.wallClockTime - ((_a = manifest.availabilityStartTime) !== null && _a !== void 0 ? _a : 0);
        } else if (isDirectFile && this.videoElement !== null) {
          var startDate = getStartDate(this.videoElement);
          if (startDate !== undefined) {
            positionWanted = timeObj.wallClockTime - startDate;
          }
        }
        if (positionWanted === undefined) {
          positionWanted = timeObj.wallClockTime;
        }
      } else {
        throw new Error("invalid time object. You must set one of the " + 'following properties: "relative", "position" or ' + '"wallClockTime"');
      }
    }
    if (positionWanted === undefined) {
      throw new Error("invalid time given");
    }
    src_log/* default */.A.info("API: API Seek to", positionWanted);
    this.videoElement.currentTime = positionWanted;
    return positionWanted;
  }
  /**
   * Returns true if the media element is full screen.
   * @deprecated
   * @returns {Boolean}
   */;
  _proto.isFullscreen = function isFullscreen() {
    (0,warn_once/* default */.A)("isFullscreen is deprecated." + " Fullscreen management should now be managed by the application");
    return fullscreen_isFullscreen();
  }
  /**
   * Set/exit fullScreen.
   * @deprecated
   * @param {Boolean} [goFull=true] - if false, exit full screen.
   */;
  _proto.setFullscreen = function setFullscreen(goFull) {
    if (goFull === void 0) {
      goFull = true;
    }
    (0,warn_once/* default */.A)("setFullscreen is deprecated." + " Fullscreen management should now be managed by the application");
    if (this.videoElement === null) {
      throw new Error("Disposed player");
    }
    if (goFull) {
      requestFullscreen(this.videoElement);
    } else {
      fullscreen_exitFullscreen();
    }
  }
  /**
   * Exit from full screen mode.
   * @deprecated
   */;
  _proto.exitFullscreen = function exitFullscreen() {
    (0,warn_once/* default */.A)("exitFullscreen is deprecated." + " Fullscreen management should now be managed by the application");
    fullscreen_exitFullscreen();
  }
  /**
   * Returns the current player's audio volume on the media element.
   * From 0 (no audio) to 1 (maximum volume).
   * @returns {Number}
   */;
  _proto.getVolume = function getVolume() {
    if (this.videoElement === null) {
      throw new Error("Disposed player");
    }
    return this.videoElement.volume;
  }
  /**
   * Set the player's audio volume. From 0 (no volume) to 1 (maximum volume).
   * @param {Number} volume
   */;
  _proto.setVolume = function setVolume(volume) {
    if (this.videoElement === null) {
      throw new Error("Disposed player");
    }
    var videoElement = this.videoElement;
    if (volume !== videoElement.volume) {
      videoElement.volume = volume;
      this.trigger("volumeChange", volume);
    }
  }
  /**
   * Returns true if the volume is set to 0. false otherwise.
   * @returns {Boolean}
   */;
  _proto.isMute = function isMute() {
    return this.getVolume() === 0;
  }
  /**
   * Set the volume to 0 and save current one for when unmuted.
   */;
  _proto.mute = function mute() {
    this._priv_mutedMemory = this.getVolume();
    this.setVolume(0);
  }
  /**
   * Set the volume back to when it was when mute was last called.
   * If the volume was set to 0, set a default volume instead (see config).
   */;
  _proto.unMute = function unMute() {
    var _config$getCurrent2 = config/* default */.A.getCurrent(),
      DEFAULT_UNMUTED_VOLUME = _config$getCurrent2.DEFAULT_UNMUTED_VOLUME;
    var vol = this.getVolume();
    if (vol === 0) {
      this.setVolume(this._priv_mutedMemory === 0 ? DEFAULT_UNMUTED_VOLUME : this._priv_mutedMemory);
    }
  }
  /**
   * Force the video bitrate to a given value. Act as a ceil.
   * -1 to set it on AUTO Mode
   * @param {Number} btr
   */;
  _proto.setVideoBitrate = function setVideoBitrate(btr) {
    this._priv_bitrateInfos.manualBitrates.video.setValue(btr);
  }
  /**
   * Force the audio bitrate to a given value. Act as a ceil.
   * -1 to set it on AUTO Mode
   * @param {Number} btr
   */;
  _proto.setAudioBitrate = function setAudioBitrate(btr) {
    this._priv_bitrateInfos.manualBitrates.audio.setValue(btr);
  }
  /**
   * Update the minimum video bitrate the user can switch to.
   * @param {Number} btr
   */;
  _proto.setMinVideoBitrate = function setMinVideoBitrate(btr) {
    var maxVideoBitrate = this._priv_bitrateInfos.maxAutoBitrates.video.getValue();
    if (btr > maxVideoBitrate) {
      throw new Error("Invalid minimum video bitrate given. " + ("Its value, \"" + btr + "\" is superior the current maximum ") + ("video birate, \"" + maxVideoBitrate + "\"."));
    }
    this._priv_bitrateInfos.minAutoBitrates.video.setValue(btr);
  }
  /**
   * Update the minimum audio bitrate the user can switch to.
   * @param {Number} btr
   */;
  _proto.setMinAudioBitrate = function setMinAudioBitrate(btr) {
    var maxAudioBitrate = this._priv_bitrateInfos.maxAutoBitrates.audio.getValue();
    if (btr > maxAudioBitrate) {
      throw new Error("Invalid minimum audio bitrate given. " + ("Its value, \"" + btr + "\" is superior the current maximum ") + ("audio birate, \"" + maxAudioBitrate + "\"."));
    }
    this._priv_bitrateInfos.minAutoBitrates.audio.setValue(btr);
  }
  /**
   * Update the maximum video bitrate the user can switch to.
   * @param {Number} btr
   */;
  _proto.setMaxVideoBitrate = function setMaxVideoBitrate(btr) {
    var minVideoBitrate = this._priv_bitrateInfos.minAutoBitrates.video.getValue();
    if (btr < minVideoBitrate) {
      throw new Error("Invalid maximum video bitrate given. " + ("Its value, \"" + btr + "\" is inferior the current minimum ") + ("video birate, \"" + minVideoBitrate + "\"."));
    }
    this._priv_bitrateInfos.maxAutoBitrates.video.setValue(btr);
  }
  /**
   * Update the maximum audio bitrate the user can switch to.
   * @param {Number} btr
   */;
  _proto.setMaxAudioBitrate = function setMaxAudioBitrate(btr) {
    var minAudioBitrate = this._priv_bitrateInfos.minAutoBitrates.audio.getValue();
    if (btr < minAudioBitrate) {
      throw new Error("Invalid maximum audio bitrate given. " + ("Its value, \"" + btr + "\" is inferior the current minimum ") + ("audio birate, \"" + minAudioBitrate + "\"."));
    }
    this._priv_bitrateInfos.maxAutoBitrates.audio.setValue(btr);
  }
  /**
   * Set the max buffer size for the buffer behind the current position.
   * Every buffer data before will be removed.
   * @param {Number} depthInSeconds
   */;
  _proto.setMaxBufferBehind = function setMaxBufferBehind(depthInSeconds) {
    this._priv_bufferOptions.maxBufferBehind.setValue(depthInSeconds);
  }
  /**
   * Set the max buffer size for the buffer behind the current position.
   * Every buffer data before will be removed.
   * @param {Number} depthInSeconds
   */;
  _proto.setMaxBufferAhead = function setMaxBufferAhead(depthInSeconds) {
    this._priv_bufferOptions.maxBufferAhead.setValue(depthInSeconds);
  }
  /**
   * Set the max buffer size for the buffer ahead of the current position.
   * The player will stop downloading chunks when this size is reached.
   * @param {Number} sizeInSeconds
   */;
  _proto.setWantedBufferAhead = function setWantedBufferAhead(sizeInSeconds) {
    this._priv_bufferOptions.wantedBufferAhead.setValue(sizeInSeconds);
  }
  /**
   * Set the max buffer size the buffer should take in memory
   * The player . will stop downloading chunks when this size is reached.
   * @param {Number} sizeInKBytes
   */;
  _proto.setMaxVideoBufferSize = function setMaxVideoBufferSize(sizeInKBytes) {
    this._priv_bufferOptions.maxVideoBufferSize.setValue(sizeInKBytes);
  }
  /**
   * Returns the max buffer size for the buffer behind the current position.
   * @returns {Number}
   */;
  _proto.getMaxBufferBehind = function getMaxBufferBehind() {
    return this._priv_bufferOptions.maxBufferBehind.getValue();
  }
  /**
   * Returns the max buffer size for the buffer behind the current position.
   * @returns {Number}
   */;
  _proto.getMaxBufferAhead = function getMaxBufferAhead() {
    return this._priv_bufferOptions.maxBufferAhead.getValue();
  }
  /**
   * Returns the max buffer size for the buffer ahead of the current position.
   * @returns {Number}
   */;
  _proto.getWantedBufferAhead = function getWantedBufferAhead() {
    return this._priv_bufferOptions.wantedBufferAhead.getValue();
  }
  /**
   * Returns the max buffer memory size for the buffer in kilobytes
   * @returns {Number}
   */;
  _proto.getMaxVideoBufferSize = function getMaxVideoBufferSize() {
    return this._priv_bufferOptions.maxVideoBufferSize.getValue();
  }
  /**
   * Returns type of current keysystem (e.g. playready, widevine) if the content
   * is encrypted. null otherwise.
   * @deprecated
   * @returns {string|null}
   */;
  _proto.getCurrentKeySystem = function getCurrentKeySystem() {
    (0,warn_once/* default */.A)("`getCurrentKeySystem` is deprecated." + "Please use the `getKeySystemConfiguration` method instead.");
    if (this.videoElement === null) {
      throw new Error("Disposed player");
    }
    return (0,get_key_system_configuration/* getCurrentKeySystem */.c)(this.videoElement);
  }
  /**
   * Returns both the name of the key system (e.g. `"com.widevine.alpha"`) and
   * the `MediaKeySystemConfiguration` currently associated to the
   * HTMLMediaElement linked to the RxPlayer.
   *
   * Returns `null` if no such capabilities is associated or if unknown.
   * @returns {Object|null}
   */;
  _proto.getKeySystemConfiguration = function getKeySystemConfiguration() {
    if (this.videoElement === null) {
      throw new Error("Disposed player");
    }
    var values = (0,get_key_system_configuration/* default */.A)(this.videoElement);
    if (values === null) {
      return null;
    }
    return {
      keySystem: values[0],
      configuration: values[1]
    };
  }
  /**
   * Returns every available audio tracks for the current Period.
   * @returns {Array.<Object>|null}
   */;
  _proto.getAvailableAudioTracks = function getAvailableAudioTracks() {
    var _a;
    if (this._priv_contentInfos === null) {
      return [];
    }
    var _this$_priv_contentIn8 = this._priv_contentInfos,
      currentPeriod = _this$_priv_contentIn8.currentPeriod,
      isDirectFile = _this$_priv_contentIn8.isDirectFile,
      trackChoiceManager = _this$_priv_contentIn8.trackChoiceManager,
      mediaElementTrackChoiceManager = _this$_priv_contentIn8.mediaElementTrackChoiceManager;
    if (isDirectFile) {
      return (_a = mediaElementTrackChoiceManager === null || mediaElementTrackChoiceManager === void 0 ? void 0 : mediaElementTrackChoiceManager.getAvailableAudioTracks()) !== null && _a !== void 0 ? _a : [];
    }
    if (trackChoiceManager === null || currentPeriod === null) {
      return [];
    }
    return trackChoiceManager.getAvailableAudioTracks(currentPeriod);
  }
  /**
   * Returns every available text tracks for the current Period.
   * @returns {Array.<Object>|null}
   */;
  _proto.getAvailableTextTracks = function getAvailableTextTracks() {
    var _a;
    if (this._priv_contentInfos === null) {
      return [];
    }
    var _this$_priv_contentIn9 = this._priv_contentInfos,
      currentPeriod = _this$_priv_contentIn9.currentPeriod,
      isDirectFile = _this$_priv_contentIn9.isDirectFile,
      trackChoiceManager = _this$_priv_contentIn9.trackChoiceManager,
      mediaElementTrackChoiceManager = _this$_priv_contentIn9.mediaElementTrackChoiceManager;
    if (isDirectFile) {
      return (_a = mediaElementTrackChoiceManager === null || mediaElementTrackChoiceManager === void 0 ? void 0 : mediaElementTrackChoiceManager.getAvailableTextTracks()) !== null && _a !== void 0 ? _a : [];
    }
    if (trackChoiceManager === null || currentPeriod === null) {
      return [];
    }
    return trackChoiceManager.getAvailableTextTracks(currentPeriod);
  }
  /**
   * Returns every available video tracks for the current Period.
   * @returns {Array.<Object>|null}
   */;
  _proto.getAvailableVideoTracks = function getAvailableVideoTracks() {
    var _a;
    if (this._priv_contentInfos === null) {
      return [];
    }
    var _this$_priv_contentIn10 = this._priv_contentInfos,
      currentPeriod = _this$_priv_contentIn10.currentPeriod,
      isDirectFile = _this$_priv_contentIn10.isDirectFile,
      trackChoiceManager = _this$_priv_contentIn10.trackChoiceManager,
      mediaElementTrackChoiceManager = _this$_priv_contentIn10.mediaElementTrackChoiceManager;
    if (isDirectFile) {
      return (_a = mediaElementTrackChoiceManager === null || mediaElementTrackChoiceManager === void 0 ? void 0 : mediaElementTrackChoiceManager.getAvailableVideoTracks()) !== null && _a !== void 0 ? _a : [];
    }
    if (trackChoiceManager === null || currentPeriod === null) {
      return [];
    }
    return trackChoiceManager.getAvailableVideoTracks(currentPeriod);
  }
  /**
   * Returns currently chosen audio language for the current Period.
   * @returns {string}
   */;
  _proto.getAudioTrack = function getAudioTrack() {
    if (this._priv_contentInfos === null) {
      return undefined;
    }
    var _this$_priv_contentIn11 = this._priv_contentInfos,
      currentPeriod = _this$_priv_contentIn11.currentPeriod,
      isDirectFile = _this$_priv_contentIn11.isDirectFile,
      trackChoiceManager = _this$_priv_contentIn11.trackChoiceManager,
      mediaElementTrackChoiceManager = _this$_priv_contentIn11.mediaElementTrackChoiceManager;
    if (isDirectFile) {
      if (mediaElementTrackChoiceManager === null) {
        return undefined;
      }
      return mediaElementTrackChoiceManager.getChosenAudioTrack();
    }
    if (trackChoiceManager === null || currentPeriod === null) {
      return undefined;
    }
    return trackChoiceManager.getChosenAudioTrack(currentPeriod);
  }
  /**
   * Returns currently chosen subtitle for the current Period.
   * @returns {string}
   */;
  _proto.getTextTrack = function getTextTrack() {
    if (this._priv_contentInfos === null) {
      return undefined;
    }
    var _this$_priv_contentIn12 = this._priv_contentInfos,
      currentPeriod = _this$_priv_contentIn12.currentPeriod,
      isDirectFile = _this$_priv_contentIn12.isDirectFile,
      trackChoiceManager = _this$_priv_contentIn12.trackChoiceManager,
      mediaElementTrackChoiceManager = _this$_priv_contentIn12.mediaElementTrackChoiceManager;
    if (isDirectFile) {
      if (mediaElementTrackChoiceManager === null) {
        return undefined;
      }
      return mediaElementTrackChoiceManager.getChosenTextTrack();
    }
    if (trackChoiceManager === null || currentPeriod === null) {
      return undefined;
    }
    return trackChoiceManager.getChosenTextTrack(currentPeriod);
  }
  /**
   * Returns currently chosen video track for the current Period.
   * @returns {string}
   */;
  _proto.getVideoTrack = function getVideoTrack() {
    if (this._priv_contentInfos === null) {
      return undefined;
    }
    var _this$_priv_contentIn13 = this._priv_contentInfos,
      currentPeriod = _this$_priv_contentIn13.currentPeriod,
      isDirectFile = _this$_priv_contentIn13.isDirectFile,
      trackChoiceManager = _this$_priv_contentIn13.trackChoiceManager,
      mediaElementTrackChoiceManager = _this$_priv_contentIn13.mediaElementTrackChoiceManager;
    if (isDirectFile) {
      if (mediaElementTrackChoiceManager === null) {
        return undefined;
      }
      return mediaElementTrackChoiceManager.getChosenVideoTrack();
    }
    if (trackChoiceManager === null || currentPeriod === null) {
      return undefined;
    }
    return trackChoiceManager.getChosenVideoTrack(currentPeriod);
  }
  /**
   * Update the audio language for the current Period.
   * @param {string} audioId
   * @throws Error - the current content has no TrackChoiceManager.
   * @throws Error - the given id is linked to no audio track.
   */;
  _proto.setAudioTrack = function setAudioTrack(audioId) {
    if (this._priv_contentInfos === null) {
      throw new Error("No content loaded");
    }
    var _this$_priv_contentIn14 = this._priv_contentInfos,
      currentPeriod = _this$_priv_contentIn14.currentPeriod,
      isDirectFile = _this$_priv_contentIn14.isDirectFile,
      trackChoiceManager = _this$_priv_contentIn14.trackChoiceManager,
      mediaElementTrackChoiceManager = _this$_priv_contentIn14.mediaElementTrackChoiceManager;
    if (isDirectFile) {
      try {
        mediaElementTrackChoiceManager === null || mediaElementTrackChoiceManager === void 0 ? void 0 : mediaElementTrackChoiceManager.setAudioTrackById(audioId);
        return;
      } catch (e) {
        throw new Error("player: unknown audio track");
      }
    }
    if (trackChoiceManager === null || currentPeriod === null) {
      throw new Error("No compatible content launched.");
    }
    try {
      trackChoiceManager.setAudioTrackByID(currentPeriod, audioId);
    } catch (e) {
      throw new Error("player: unknown audio track");
    }
  }
  /**
   * Update the text language for the current Period.
   * @param {string} sub
   * @throws Error - the current content has no TrackChoiceManager.
   * @throws Error - the given id is linked to no text track.
   */;
  _proto.setTextTrack = function setTextTrack(textId) {
    if (this._priv_contentInfos === null) {
      throw new Error("No content loaded");
    }
    var _this$_priv_contentIn15 = this._priv_contentInfos,
      currentPeriod = _this$_priv_contentIn15.currentPeriod,
      isDirectFile = _this$_priv_contentIn15.isDirectFile,
      trackChoiceManager = _this$_priv_contentIn15.trackChoiceManager,
      mediaElementTrackChoiceManager = _this$_priv_contentIn15.mediaElementTrackChoiceManager;
    if (isDirectFile) {
      try {
        mediaElementTrackChoiceManager === null || mediaElementTrackChoiceManager === void 0 ? void 0 : mediaElementTrackChoiceManager.setTextTrackById(textId);
        return;
      } catch (e) {
        throw new Error("player: unknown text track");
      }
    }
    if (trackChoiceManager === null || currentPeriod === null) {
      throw new Error("No compatible content launched.");
    }
    try {
      trackChoiceManager.setTextTrackByID(currentPeriod, textId);
    } catch (e) {
      throw new Error("player: unknown text track");
    }
  }
  /**
   * Disable subtitles for the current content.
   */;
  _proto.disableTextTrack = function disableTextTrack() {
    if (this._priv_contentInfos === null) {
      return;
    }
    var _this$_priv_contentIn16 = this._priv_contentInfos,
      currentPeriod = _this$_priv_contentIn16.currentPeriod,
      isDirectFile = _this$_priv_contentIn16.isDirectFile,
      trackChoiceManager = _this$_priv_contentIn16.trackChoiceManager,
      mediaElementTrackChoiceManager = _this$_priv_contentIn16.mediaElementTrackChoiceManager;
    if (isDirectFile) {
      mediaElementTrackChoiceManager === null || mediaElementTrackChoiceManager === void 0 ? void 0 : mediaElementTrackChoiceManager.disableTextTrack();
      return;
    }
    if (trackChoiceManager === null || currentPeriod === null) {
      return;
    }
    return trackChoiceManager.disableTextTrack(currentPeriod);
  }
  /**
   * Update the video track for the current Period.
   * @param {string} videoId
   * @throws Error - the current content has no TrackChoiceManager.
   * @throws Error - the given id is linked to no video track.
   */;
  _proto.setVideoTrack = function setVideoTrack(videoId) {
    if (this._priv_contentInfos === null) {
      throw new Error("No content loaded");
    }
    var _this$_priv_contentIn17 = this._priv_contentInfos,
      currentPeriod = _this$_priv_contentIn17.currentPeriod,
      isDirectFile = _this$_priv_contentIn17.isDirectFile,
      trackChoiceManager = _this$_priv_contentIn17.trackChoiceManager,
      mediaElementTrackChoiceManager = _this$_priv_contentIn17.mediaElementTrackChoiceManager;
    if (isDirectFile) {
      try {
        mediaElementTrackChoiceManager === null || mediaElementTrackChoiceManager === void 0 ? void 0 : mediaElementTrackChoiceManager.setVideoTrackById(videoId);
        return;
      } catch (e) {
        throw new Error("player: unknown video track");
      }
    }
    if (trackChoiceManager === null || currentPeriod === null) {
      throw new Error("No compatible content launched.");
    }
    try {
      trackChoiceManager.setVideoTrackByID(currentPeriod, videoId);
    } catch (e) {
      throw new Error("player: unknown video track");
    }
  }
  /**
   * Disable video track for the current content.
   */;
  _proto.disableVideoTrack = function disableVideoTrack() {
    if (this._priv_contentInfos === null) {
      return;
    }
    var _this$_priv_contentIn18 = this._priv_contentInfos,
      currentPeriod = _this$_priv_contentIn18.currentPeriod,
      isDirectFile = _this$_priv_contentIn18.isDirectFile,
      trackChoiceManager = _this$_priv_contentIn18.trackChoiceManager,
      mediaElementTrackChoiceManager = _this$_priv_contentIn18.mediaElementTrackChoiceManager;
    if (isDirectFile && mediaElementTrackChoiceManager !== null) {
      return mediaElementTrackChoiceManager.disableVideoTrack();
    }
    if (trackChoiceManager === null || currentPeriod === null) {
      return;
    }
    return trackChoiceManager.disableVideoTrack(currentPeriod);
  }
  /**
   * Returns the current list of preferred audio tracks, in preference order.
   * @returns {Array.<Object>}
   */;
  _proto.getPreferredAudioTracks = function getPreferredAudioTracks() {
    return this._priv_preferredAudioTracks;
  }
  /**
   * Returns the current list of preferred text tracks, in preference order.
   * @returns {Array.<Object>}
   */;
  _proto.getPreferredTextTracks = function getPreferredTextTracks() {
    return this._priv_preferredTextTracks;
  }
  /**
   * Returns the current list of preferred text tracks, in preference order.
   * @returns {Array.<Object>}
   */;
  _proto.getPreferredVideoTracks = function getPreferredVideoTracks() {
    return this._priv_preferredVideoTracks;
  }
  /**
   * Set the list of preferred audio tracks, in preference order.
   * @param {Array.<Object>} tracks
   * @param {boolean} shouldApply - `true` if those preferences should be
   * applied on the currently loaded Period. `false` if it should only
   * be applied to new content.
   */;
  _proto.setPreferredAudioTracks = function setPreferredAudioTracks(tracks, shouldApply) {
    if (shouldApply === void 0) {
      shouldApply = false;
    }
    if (!Array.isArray(tracks)) {
      throw new Error("Invalid `setPreferredAudioTracks` argument. " + "Should have been an Array.");
    }
    this._priv_preferredAudioTracks = tracks;
    var contentInfos = this._priv_contentInfos;
    if (!(0,is_null_or_undefined/* default */.A)(contentInfos === null || contentInfos === void 0 ? void 0 : contentInfos.trackChoiceManager)) {
      contentInfos === null || contentInfos === void 0 ? void 0 : contentInfos.trackChoiceManager.setPreferredAudioTracks(tracks, shouldApply);
    } else if (!(0,is_null_or_undefined/* default */.A)(contentInfos === null || contentInfos === void 0 ? void 0 : contentInfos.mediaElementTrackChoiceManager)) {
      contentInfos === null || contentInfos === void 0 ? void 0 : contentInfos.mediaElementTrackChoiceManager.setPreferredAudioTracks(tracks, shouldApply);
    }
  }
  /**
   * Set the list of preferred text tracks, in preference order.
   * @param {Array.<Object>} tracks
   * @param {boolean} shouldApply - `true` if those preferences should be
   * applied on the currently loaded Periods. `false` if it should only
   * be applied to new content.
   */;
  _proto.setPreferredTextTracks = function setPreferredTextTracks(tracks, shouldApply) {
    if (shouldApply === void 0) {
      shouldApply = false;
    }
    if (!Array.isArray(tracks)) {
      throw new Error("Invalid `setPreferredTextTracks` argument. " + "Should have been an Array.");
    }
    this._priv_preferredTextTracks = tracks;
    var contentInfos = this._priv_contentInfos;
    if (!(0,is_null_or_undefined/* default */.A)(contentInfos === null || contentInfos === void 0 ? void 0 : contentInfos.trackChoiceManager)) {
      contentInfos === null || contentInfos === void 0 ? void 0 : contentInfos.trackChoiceManager.setPreferredTextTracks(tracks, shouldApply);
    } else if (!(0,is_null_or_undefined/* default */.A)(contentInfos === null || contentInfos === void 0 ? void 0 : contentInfos.mediaElementTrackChoiceManager)) {
      contentInfos === null || contentInfos === void 0 ? void 0 : contentInfos.mediaElementTrackChoiceManager.setPreferredTextTracks(tracks, shouldApply);
    }
  }
  /**
   * Set the list of preferred text tracks, in preference order.
   * @param {Array.<Object>} tracks
   * @param {boolean} shouldApply - `true` if those preferences should be
   * applied on the currently loaded Period. `false` if it should only
   * be applied to new content.
   */;
  _proto.setPreferredVideoTracks = function setPreferredVideoTracks(tracks, shouldApply) {
    if (shouldApply === void 0) {
      shouldApply = false;
    }
    if (!Array.isArray(tracks)) {
      throw new Error("Invalid `setPreferredVideoTracks` argument. " + "Should have been an Array.");
    }
    this._priv_preferredVideoTracks = tracks;
    var contentInfos = this._priv_contentInfos;
    if (!(0,is_null_or_undefined/* default */.A)(contentInfos === null || contentInfos === void 0 ? void 0 : contentInfos.trackChoiceManager)) {
      contentInfos === null || contentInfos === void 0 ? void 0 : contentInfos.trackChoiceManager.setPreferredVideoTracks(tracks, shouldApply);
    } else if (!(0,is_null_or_undefined/* default */.A)(contentInfos === null || contentInfos === void 0 ? void 0 : contentInfos.mediaElementTrackChoiceManager)) {
      contentInfos === null || contentInfos === void 0 ? void 0 : contentInfos.mediaElementTrackChoiceManager.setPreferredVideoTracks(tracks, shouldApply);
    }
  }
  /**
   * @returns {Array.<Object>|null}
   * @deprecated
   */;
  _proto.getImageTrackData = function getImageTrackData() {
    (0,warn_once/* default */.A)("`getImageTrackData` is deprecated." + "Please use the `parseBifThumbnails` tool instead.");
    if (this._priv_contentInfos === null) {
      return null;
    }
    /* eslint-disable import/no-deprecated */
    return this._priv_contentInfos.thumbnails;
    /* eslint-enable import/no-deprecated */
  }
  /**
   * Get minimum seek-able position.
   * @returns {number}
   */;
  _proto.getMinimumPosition = function getMinimumPosition() {
    if (this._priv_contentInfos === null) {
      return null;
    }
    if (this._priv_contentInfos.isDirectFile) {
      return 0;
    }
    var manifest = this._priv_contentInfos.manifest;
    if (manifest !== null) {
      return manifest.getMinimumSafePosition();
    }
    return null;
  }
  /**
   * Returns the current position for live contents.
   *
   * Returns `null` if no content is loaded or if the current loaded content is
   * not considered as a live content.
   * Returns `undefined` if that live position is currently unknown.
   * @returns {number}
   */;
  _proto.getLivePosition = function getLivePosition() {
    if (this._priv_contentInfos === null) {
      return null;
    }
    var _this$_priv_contentIn19 = this._priv_contentInfos,
      isDirectFile = _this$_priv_contentIn19.isDirectFile,
      manifest = _this$_priv_contentIn19.manifest;
    if (isDirectFile) {
      return undefined;
    }
    if ((manifest === null || manifest === void 0 ? void 0 : manifest.isLive) !== true) {
      return null;
    }
    return manifest.getLivePosition();
  }
  /**
   * Get maximum seek-able position.
   * @returns {number}
   */;
  _proto.getMaximumPosition = function getMaximumPosition() {
    if (this._priv_contentInfos === null) {
      return null;
    }
    var _this$_priv_contentIn20 = this._priv_contentInfos,
      isDirectFile = _this$_priv_contentIn20.isDirectFile,
      manifest = _this$_priv_contentIn20.manifest;
    if (isDirectFile) {
      if (this.videoElement === null) {
        throw new Error("Disposed player");
      }
      return this.videoElement.duration;
    }
    if (manifest !== null) {
      if (!manifest.isDynamic && this.videoElement !== null) {
        return this.videoElement.duration;
      }
      return manifest.getMaximumSafePosition();
    }
    return null;
  }
  /**
   * /!\ For demo use only! Do not touch!
   *
   * Returns every chunk buffered for a given buffer type.
   * Returns `null` if no SegmentBuffer was created for this type of buffer.
   * @param {string} bufferType
   * @returns {Array.<Object>|null}
   */;
  _proto.__priv_getSegmentBufferContent = function __priv_getSegmentBufferContent(bufferType) {
    if (this._priv_contentInfos === null || this._priv_contentInfos.segmentBuffersStore === null) {
      return null;
    }
    var segmentBufferStatus = this._priv_contentInfos.segmentBuffersStore.getStatus(bufferType);
    if (segmentBufferStatus.type === "initialized") {
      segmentBufferStatus.value.synchronizeInventory(true);
      return segmentBufferStatus.value.getInventory();
    }
    return null;
  }
  /**
   * Reset all state properties relative to a playing content.
   */;
  _proto._priv_cleanUpCurrentContentState = function _priv_cleanUpCurrentContentState() {
    var _this4 = this;
    var _a, _b;
    src_log/* default */.A.debug("Locking `contentLock` to clean-up the current content.");
    // lock playback of new contents while cleaning up is pending
    this._priv_contentLock.setValue(true);
    (_b = (_a = this._priv_contentInfos) === null || _a === void 0 ? void 0 : _a.mediaElementTrackChoiceManager) === null || _b === void 0 ? void 0 : _b.dispose();
    this._priv_contentInfos = null;
    this._priv_contentEventsMemory = {};
    // DRM-related clean-up
    var freeUpContentLock = function freeUpContentLock() {
      if (_this4.videoElement !== null) {
        // If not disposed
        src_log/* default */.A.debug("Unlocking `contentLock`. Next content can begin.");
        _this4._priv_contentLock.setValue(false);
      }
    };
    if (!(0,is_null_or_undefined/* default */.A)(this.videoElement)) {
      clearOnStop(this.videoElement).then(function () {
        src_log/* default */.A.debug("API: DRM session cleaned-up with success!");
        freeUpContentLock();
      }, function (err) {
        src_log/* default */.A.error("API: An error arised when trying to clean-up the DRM session:" + (err instanceof Error ? err.toString() : "Unknown Error"));
        freeUpContentLock();
      });
    } else {
      freeUpContentLock();
    }
  }
  /**
   * Triggered when the Manifest has been loaded for the current content.
   * Initialize various private properties and emit initial event.
   * @param {Object} contentInfos
   * @param {Object} manifest
   */;
  _proto._priv_onManifestReady = function _priv_onManifestReady(contentInfos, manifest) {
    var _this5 = this;
    var _a;
    if (contentInfos.contentId !== ((_a = this._priv_contentInfos) === null || _a === void 0 ? void 0 : _a.contentId)) {
      return; // Event for another content
    }
    contentInfos.manifest = manifest;
    var cancelSignal = contentInfos.currentContentCanceller.signal;
    this._priv_reloadingMetadata.manifest = manifest;
    var initialAudioTrack = contentInfos.initialAudioTrack,
      initialTextTrack = contentInfos.initialTextTrack;
    contentInfos.trackChoiceManager = new TrackChoiceManager({
      preferTrickModeTracks: this._priv_preferTrickModeTracks
    });
    var preferredAudioTracks = initialAudioTrack === undefined ? this._priv_preferredAudioTracks : [initialAudioTrack];
    contentInfos.trackChoiceManager.setPreferredAudioTracks(preferredAudioTracks, true);
    var preferredTextTracks = initialTextTrack === undefined ? this._priv_preferredTextTracks : [initialTextTrack];
    contentInfos.trackChoiceManager.setPreferredTextTracks(preferredTextTracks, true);
    contentInfos.trackChoiceManager.setPreferredVideoTracks(this._priv_preferredVideoTracks, true);
    manifest.addEventListener("manifestUpdate", function (updates) {
      var _a, _b, _c;
      // Update the tracks chosen if it changed
      if (contentInfos.trackChoiceManager !== null) {
        contentInfos.trackChoiceManager.update();
      }
      var currentPeriod = (_b = (_a = _this5._priv_contentInfos) === null || _a === void 0 ? void 0 : _a.currentPeriod) !== null && _b !== void 0 ? _b : undefined;
      var trackChoiceManager = (_c = _this5._priv_contentInfos) === null || _c === void 0 ? void 0 : _c.trackChoiceManager;
      if (currentPeriod === undefined || (0,is_null_or_undefined/* default */.A)(trackChoiceManager)) {
        return;
      }
      for (var _iterator = public_api_createForOfIteratorHelperLoose(updates.updatedPeriods), _step; !(_step = _iterator()).done;) {
        var update = _step.value;
        if (update.period.id === currentPeriod.id) {
          if (update.result.addedAdaptations.length > 0 || update.result.removedAdaptations.length > 0) {
            // We might have new (or less) tracks, send events just to be sure
            var audioTracks = trackChoiceManager.getAvailableAudioTracks(currentPeriod);
            _this5._priv_triggerEventIfNotStopped("availableAudioTracksChange", audioTracks !== null && audioTracks !== void 0 ? audioTracks : [], cancelSignal);
            var textTracks = trackChoiceManager.getAvailableTextTracks(currentPeriod);
            _this5._priv_triggerEventIfNotStopped("availableTextTracksChange", textTracks !== null && textTracks !== void 0 ? textTracks : [], cancelSignal);
            var videoTracks = trackChoiceManager.getAvailableVideoTracks(currentPeriod);
            _this5._priv_triggerEventIfNotStopped("availableVideoTracksChange", videoTracks !== null && videoTracks !== void 0 ? videoTracks : [], cancelSignal);
          }
        }
        return;
      }
    }, contentInfos.currentContentCanceller.signal);
  }
  /**
   * Triggered each times the current Period Changed.
   * Store and emit initial state for the Period.
   *
   * @param {Object} contentInfos
   * @param {Object} periodInfo
   */;
  _proto._priv_onActivePeriodChanged = function _priv_onActivePeriodChanged(contentInfos, _ref) {
    var period = _ref.period;
    var _a, _b, _c, _d, _e, _f, _g, _h;
    if (contentInfos.contentId !== ((_a = this._priv_contentInfos) === null || _a === void 0 ? void 0 : _a.contentId)) {
      return; // Event for another content
    }
    contentInfos.currentPeriod = period;
    var cancelSignal = contentInfos.currentContentCanceller.signal;
    if (this._priv_contentEventsMemory.periodChange !== period) {
      this._priv_contentEventsMemory.periodChange = period;
      this._priv_triggerEventIfNotStopped("periodChange", period, cancelSignal);
    }
    this._priv_triggerEventIfNotStopped("availableAudioTracksChange", this.getAvailableAudioTracks(), cancelSignal);
    this._priv_triggerEventIfNotStopped("availableTextTracksChange", this.getAvailableTextTracks(), cancelSignal);
    this._priv_triggerEventIfNotStopped("availableVideoTracksChange", this.getAvailableVideoTracks(), cancelSignal);
    var trackChoiceManager = (_b = this._priv_contentInfos) === null || _b === void 0 ? void 0 : _b.trackChoiceManager;
    // Emit intial events for the Period
    if (!(0,is_null_or_undefined/* default */.A)(trackChoiceManager)) {
      var audioTrack = trackChoiceManager.getChosenAudioTrack(period);
      this._priv_triggerEventIfNotStopped("audioTrackChange", audioTrack, cancelSignal);
      var textTrack = trackChoiceManager.getChosenTextTrack(period);
      this._priv_triggerEventIfNotStopped("textTrackChange", textTrack, cancelSignal);
      var videoTrack = trackChoiceManager.getChosenVideoTrack(period);
      this._priv_triggerEventIfNotStopped("videoTrackChange", videoTrack, cancelSignal);
    } else {
      this._priv_triggerEventIfNotStopped("audioTrackChange", null, cancelSignal);
      this._priv_triggerEventIfNotStopped("textTrackChange", null, cancelSignal);
      this._priv_triggerEventIfNotStopped("videoTrackChange", null, cancelSignal);
    }
    this._priv_triggerAvailableBitratesChangeEvent("availableAudioBitratesChange", this.getAvailableAudioBitrates(), cancelSignal);
    if (contentInfos.currentContentCanceller.isUsed()) {
      return;
    }
    this._priv_triggerAvailableBitratesChangeEvent("availableVideoBitratesChange", this.getAvailableVideoBitrates(), cancelSignal);
    if (contentInfos.currentContentCanceller.isUsed()) {
      return;
    }
    var audioBitrate = (_e = (_d = (_c = this._priv_getCurrentRepresentations()) === null || _c === void 0 ? void 0 : _c.audio) === null || _d === void 0 ? void 0 : _d.bitrate) !== null && _e !== void 0 ? _e : -1;
    this._priv_triggerCurrentBitrateChangeEvent("audioBitrateChange", audioBitrate, cancelSignal);
    if (contentInfos.currentContentCanceller.isUsed()) {
      return;
    }
    var videoBitrate = (_h = (_g = (_f = this._priv_getCurrentRepresentations()) === null || _f === void 0 ? void 0 : _f.video) === null || _g === void 0 ? void 0 : _g.bitrate) !== null && _h !== void 0 ? _h : -1;
    this._priv_triggerCurrentBitrateChangeEvent("videoBitrateChange", videoBitrate, cancelSignal);
  }
  /**
   * Triggered each times a new "PeriodStream" is ready.
   * Choose the right Adaptation for the Period and emit it.
   * @param {Object} contentInfos
   * @param {Object} value
   */;
  _proto._priv_onPeriodStreamReady = function _priv_onPeriodStreamReady(contentInfos, value) {
    var _a;
    if (contentInfos.contentId !== ((_a = this._priv_contentInfos) === null || _a === void 0 ? void 0 : _a.contentId)) {
      return; // Event for another content
    }
    var type = value.type,
      period = value.period,
      adaptationRef = value.adaptationRef;
    var trackChoiceManager = contentInfos.trackChoiceManager;
    switch (type) {
      case "video":
        if ((0,is_null_or_undefined/* default */.A)(trackChoiceManager)) {
          src_log/* default */.A.error("API: TrackChoiceManager not instanciated for a new video period");
          adaptationRef.setValue(null);
        } else {
          trackChoiceManager.addPeriod(type, period, adaptationRef);
          trackChoiceManager.setInitialVideoTrack(period);
        }
        break;
      case "audio":
        if ((0,is_null_or_undefined/* default */.A)(trackChoiceManager)) {
          src_log/* default */.A.error("API: TrackChoiceManager not instanciated for a new " + type + " period");
          adaptationRef.setValue(null);
        } else {
          trackChoiceManager.addPeriod(type, period, adaptationRef);
          trackChoiceManager.setInitialAudioTrack(period);
        }
        break;
      case "text":
        if ((0,is_null_or_undefined/* default */.A)(trackChoiceManager)) {
          src_log/* default */.A.error("API: TrackChoiceManager not instanciated for a new " + type + " period");
          adaptationRef.setValue(null);
        } else {
          trackChoiceManager.addPeriod(type, period, adaptationRef);
          trackChoiceManager.setInitialTextTrack(period);
        }
        break;
      default:
        var adaptations = period.adaptations[type];
        if (!(0,is_null_or_undefined/* default */.A)(adaptations) && adaptations.length > 0) {
          adaptationRef.setValue(adaptations[0]);
        } else {
          adaptationRef.setValue(null);
        }
        break;
    }
  }
  /**
   * Triggered each times we "remove" a PeriodStream.
   * @param {Object} contentInfos
   * @param {Object} value
   */;
  _proto._priv_onPeriodStreamCleared = function _priv_onPeriodStreamCleared(contentInfos, value) {
    var _a;
    if (contentInfos.contentId !== ((_a = this._priv_contentInfos) === null || _a === void 0 ? void 0 : _a.contentId)) {
      return; // Event for another content
    }
    var type = value.type,
      period = value.period;
    var trackChoiceManager = contentInfos.trackChoiceManager;
    // Clean-up track choice from TrackChoiceManager
    switch (type) {
      case "audio":
      case "text":
      case "video":
        if (!(0,is_null_or_undefined/* default */.A)(trackChoiceManager)) {
          trackChoiceManager.removePeriod(type, period);
        }
        break;
    }
    // Clean-up stored Representation and Adaptation information
    var activeAdaptations = contentInfos.activeAdaptations,
      activeRepresentations = contentInfos.activeRepresentations;
    if (!(0,is_null_or_undefined/* default */.A)(activeAdaptations) && !(0,is_null_or_undefined/* default */.A)(activeAdaptations[period.id])) {
      var activePeriodAdaptations = activeAdaptations[period.id];
      delete activePeriodAdaptations[type];
      if (Object.keys(activePeriodAdaptations).length === 0) {
        delete activeAdaptations[period.id];
      }
    }
    if (!(0,is_null_or_undefined/* default */.A)(activeRepresentations) && !(0,is_null_or_undefined/* default */.A)(activeRepresentations[period.id])) {
      var activePeriodRepresentations = activeRepresentations[period.id];
      delete activePeriodRepresentations[type];
      if (Object.keys(activePeriodRepresentations).length === 0) {
        delete activeRepresentations[period.id];
      }
    }
  }
  /**
   * Triggered each times a new Adaptation is considered for the current
   * content.
   * Store given Adaptation and emit it if from the current Period.
   * @param {Object} contentInfos
   * @param {Object} value
   */;
  _proto._priv_onAdaptationChange = function _priv_onAdaptationChange(contentInfos, _ref2) {
    var type = _ref2.type,
      adaptation = _ref2.adaptation,
      period = _ref2.period;
    var _a;
    if (contentInfos.contentId !== ((_a = this._priv_contentInfos) === null || _a === void 0 ? void 0 : _a.contentId)) {
      return; // Event for another content
    }
    // lazily create contentInfos.activeAdaptations
    if (contentInfos.activeAdaptations === null) {
      contentInfos.activeAdaptations = {};
    }
    var activeAdaptations = contentInfos.activeAdaptations,
      currentPeriod = contentInfos.currentPeriod;
    var activePeriodAdaptations = activeAdaptations[period.id];
    if ((0,is_null_or_undefined/* default */.A)(activePeriodAdaptations)) {
      var _activeAdaptations$pe;
      activeAdaptations[period.id] = (_activeAdaptations$pe = {}, _activeAdaptations$pe[type] = adaptation, _activeAdaptations$pe);
    } else {
      activePeriodAdaptations[type] = adaptation;
    }
    var trackChoiceManager = contentInfos.trackChoiceManager;
    var cancelSignal = contentInfos.currentContentCanceller.signal;
    if (trackChoiceManager !== null && currentPeriod !== null && !(0,is_null_or_undefined/* default */.A)(period) && period.id === currentPeriod.id) {
      switch (type) {
        case "audio":
          var audioTrack = trackChoiceManager.getChosenAudioTrack(currentPeriod);
          this._priv_triggerEventIfNotStopped("audioTrackChange", audioTrack, cancelSignal);
          var availableAudioBitrates = this.getAvailableAudioBitrates();
          this._priv_triggerAvailableBitratesChangeEvent("availableAudioBitratesChange", availableAudioBitrates, cancelSignal);
          break;
        case "text":
          var textTrack = trackChoiceManager.getChosenTextTrack(currentPeriod);
          this._priv_triggerEventIfNotStopped("textTrackChange", textTrack, cancelSignal);
          break;
        case "video":
          var videoTrack = trackChoiceManager.getChosenVideoTrack(currentPeriod);
          this._priv_triggerEventIfNotStopped("videoTrackChange", videoTrack, cancelSignal);
          var availableVideoBitrates = this.getAvailableVideoBitrates();
          this._priv_triggerAvailableBitratesChangeEvent("availableVideoBitratesChange", availableVideoBitrates, cancelSignal);
          break;
      }
    }
  }
  /**
   * Triggered each times a new Representation is considered during playback.
   *
   * Store given Representation and emit it if from the current Period.
   *
   * @param {Object} contentInfos
   * @param {Object} obj
   */;
  _proto._priv_onRepresentationChange = function _priv_onRepresentationChange(contentInfos, _ref3) {
    var type = _ref3.type,
      period = _ref3.period,
      representation = _ref3.representation;
    var _a, _b;
    if (contentInfos.contentId !== ((_a = this._priv_contentInfos) === null || _a === void 0 ? void 0 : _a.contentId)) {
      return; // Event for another content
    }
    // lazily create contentInfos.activeRepresentations
    if (contentInfos.activeRepresentations === null) {
      contentInfos.activeRepresentations = {};
    }
    var activeRepresentations = contentInfos.activeRepresentations,
      currentPeriod = contentInfos.currentPeriod;
    var activePeriodRepresentations = activeRepresentations[period.id];
    if ((0,is_null_or_undefined/* default */.A)(activePeriodRepresentations)) {
      var _activeRepresentation;
      activeRepresentations[period.id] = (_activeRepresentation = {}, _activeRepresentation[type] = representation, _activeRepresentation);
    } else {
      activePeriodRepresentations[type] = representation;
    }
    var bitrate = (_b = representation === null || representation === void 0 ? void 0 : representation.bitrate) !== null && _b !== void 0 ? _b : -1;
    if (!(0,is_null_or_undefined/* default */.A)(period) && currentPeriod !== null && currentPeriod.id === period.id) {
      var cancelSignal = this._priv_contentInfos.currentContentCanceller.signal;
      if (type === "video") {
        this._priv_triggerCurrentBitrateChangeEvent("videoBitrateChange", bitrate, cancelSignal);
      } else if (type === "audio") {
        this._priv_triggerCurrentBitrateChangeEvent("audioBitrateChange", bitrate, cancelSignal);
      }
    }
  }
  /**
   * Triggered each time a bitrate estimate is calculated.
   *
   * Emit it.
   *
   * @param {Object} value
   */;
  _proto._priv_onBitrateEstimationChange = function _priv_onBitrateEstimationChange(_ref4) {
    var type = _ref4.type,
      bitrate = _ref4.bitrate;
    if (bitrate !== undefined) {
      this._priv_bitrateInfos.lastBitrates[type] = bitrate;
    }
    this.trigger("bitrateEstimationChange", {
      type: type,
      bitrate: bitrate
    });
  }
  /**
   * Triggered each time a textTrack is added to the video DOM Element.
   *
   * Trigger the right Player Event.
   *
   * @param {Array.<TextTrackElement>} tracks
   */;
  _proto._priv_onNativeTextTracksNext = function _priv_onNativeTextTracksNext(tracks) {
    this.trigger("nativeTextTracksChange", tracks);
  }
  /**
   * Triggered each time the player state updates.
   *
   * Trigger the right Player Event.
   *
   * @param {string} newState
   */;
  _proto._priv_setPlayerState = function _priv_setPlayerState(newState) {
    if (this.state !== newState) {
      this.state = newState;
      src_log/* default */.A.info("API: playerStateChange event", newState);
      this.trigger("playerStateChange", newState);
    }
  }
  /**
   * Triggered each time a playback observation.
   *
   * Trigger the right Player Event
   *
   * @param {Object} contentInfos
   * @param {Object} observation
   */;
  _proto._priv_triggerPositionUpdate = function _priv_triggerPositionUpdate(contentInfos, observation) {
    var _a, _b;
    if (contentInfos.contentId !== ((_a = this._priv_contentInfos) === null || _a === void 0 ? void 0 : _a.contentId)) {
      return; // Event for another content
    }
    var isDirectFile = contentInfos.isDirectFile,
      manifest = contentInfos.manifest;
    if (!isDirectFile && manifest === null || (0,is_null_or_undefined/* default */.A)(observation)) {
      return;
    }
    var maximumPosition = manifest !== null ? manifest.getMaximumSafePosition() : undefined;
    var positionData = {
      position: observation.position,
      duration: observation.duration,
      playbackRate: observation.playbackRate,
      maximumBufferTime: maximumPosition,
      // TODO bufferGap may be undefined
      bufferGap: observation.bufferGap === undefined || !isFinite(observation.bufferGap) ? 0 : observation.bufferGap
    };
    if (manifest !== null && manifest.isLive && observation.position > 0) {
      var ast = (_b = manifest.availabilityStartTime) !== null && _b !== void 0 ? _b : 0;
      positionData.wallClockTime = observation.position + ast;
      var livePosition = manifest.getLivePosition();
      if (livePosition !== undefined) {
        positionData.liveGap = livePosition - observation.position;
      }
    } else if (isDirectFile && this.videoElement !== null) {
      var startDate = getStartDate(this.videoElement);
      if (startDate !== undefined) {
        positionData.wallClockTime = startDate + observation.position;
      }
    }
    this.trigger("positionUpdate", positionData);
  }
  /**
   * Trigger one of the "availableBitratesChange" event only if it changed from
   * the previously stored value.
   * @param {string} event
   * @param {Array.<number>} newVal
   * @param {Object} currentContentCancelSignal
   */;
  _proto._priv_triggerAvailableBitratesChangeEvent = function _priv_triggerAvailableBitratesChangeEvent(event, newVal, currentContentCancelSignal) {
    var prevVal = this._priv_contentEventsMemory[event];
    if (!currentContentCancelSignal.isCancelled() && (prevVal === undefined || !(0,are_arrays_of_numbers_equal/* default */.A)(newVal, prevVal))) {
      this._priv_contentEventsMemory[event] = newVal;
      this.trigger(event, newVal);
    }
  }
  /**
   * Trigger one of the "bitrateChange" event only if it changed from the
   * previously stored value.
   * @param {string} event
   * @param {number} newVal
   * @param {Object} currentContentCancelSignal
   */;
  _proto._priv_triggerCurrentBitrateChangeEvent = function _priv_triggerCurrentBitrateChangeEvent(event, newVal, currentContentCancelSignal) {
    if (!currentContentCancelSignal.isCancelled() && newVal !== this._priv_contentEventsMemory[event]) {
      this._priv_contentEventsMemory[event] = newVal;
      this.trigger(event, newVal);
    }
  };
  _proto._priv_getCurrentRepresentations = function _priv_getCurrentRepresentations() {
    if (this._priv_contentInfos === null) {
      return null;
    }
    var _this$_priv_contentIn21 = this._priv_contentInfos,
      currentPeriod = _this$_priv_contentIn21.currentPeriod,
      activeRepresentations = _this$_priv_contentIn21.activeRepresentations;
    if (currentPeriod === null || activeRepresentations === null || (0,is_null_or_undefined/* default */.A)(activeRepresentations[currentPeriod.id])) {
      return null;
    }
    return activeRepresentations[currentPeriod.id];
  }
  /**
   * @param {string} evt
   * @param {*} arg
   * @param {Object} currentContentCancelSignal
   */;
  _proto._priv_triggerEventIfNotStopped = function _priv_triggerEventIfNotStopped(evt, arg, currentContentCancelSignal) {
    if (!currentContentCancelSignal.isCancelled()) {
      this.trigger(evt, arg);
    }
  }
  /**
   * @param {Object} defaultAudioTrack
   * @param {Object} defaultTextTrack
   * @param {Object} cancelSignal
   * @returns {Object}
   */;
  _proto._priv_initializeMediaElementTrackChoiceManager = function _priv_initializeMediaElementTrackChoiceManager(defaultAudioTrack, defaultTextTrack, cancelSignal) {
    var _this6 = this;
    var _a, _b, _c;
    (0,src_assert/* default */.h)(features/* default */.A.directfile !== null, "Initializing `MediaElementTrackChoiceManager` without Directfile feature");
    (0,src_assert/* default */.h)(this.videoElement !== null, "Initializing `MediaElementTrackChoiceManager` on a disposed RxPlayer");
    var mediaElementTrackChoiceManager = new features/* default */.A.directfile.mediaElementTrackChoiceManager(this.videoElement);
    var preferredAudioTracks = defaultAudioTrack === undefined ? this._priv_preferredAudioTracks : [defaultAudioTrack];
    mediaElementTrackChoiceManager.setPreferredAudioTracks(preferredAudioTracks, true);
    var preferredTextTracks = defaultTextTrack === undefined ? this._priv_preferredTextTracks : [defaultTextTrack];
    mediaElementTrackChoiceManager.setPreferredTextTracks(preferredTextTracks, true);
    mediaElementTrackChoiceManager.setPreferredVideoTracks(this._priv_preferredVideoTracks, true);
    this._priv_triggerEventIfNotStopped("availableAudioTracksChange", mediaElementTrackChoiceManager.getAvailableAudioTracks(), cancelSignal);
    this._priv_triggerEventIfNotStopped("availableVideoTracksChange", mediaElementTrackChoiceManager.getAvailableVideoTracks(), cancelSignal);
    this._priv_triggerEventIfNotStopped("availableTextTracksChange", mediaElementTrackChoiceManager.getAvailableTextTracks(), cancelSignal);
    this._priv_triggerEventIfNotStopped("audioTrackChange", (_a = mediaElementTrackChoiceManager.getChosenAudioTrack()) !== null && _a !== void 0 ? _a : null, cancelSignal);
    this._priv_triggerEventIfNotStopped("textTrackChange", (_b = mediaElementTrackChoiceManager.getChosenTextTrack()) !== null && _b !== void 0 ? _b : null, cancelSignal);
    this._priv_triggerEventIfNotStopped("videoTrackChange", (_c = mediaElementTrackChoiceManager.getChosenVideoTrack()) !== null && _c !== void 0 ? _c : null, cancelSignal);
    mediaElementTrackChoiceManager.addEventListener("availableVideoTracksChange", function (val) {
      return _this6.trigger("availableVideoTracksChange", val);
    });
    mediaElementTrackChoiceManager.addEventListener("availableAudioTracksChange", function (val) {
      return _this6.trigger("availableAudioTracksChange", val);
    });
    mediaElementTrackChoiceManager.addEventListener("availableTextTracksChange", function (val) {
      return _this6.trigger("availableTextTracksChange", val);
    });
    mediaElementTrackChoiceManager.addEventListener("audioTrackChange", function (val) {
      return _this6.trigger("audioTrackChange", val);
    });
    mediaElementTrackChoiceManager.addEventListener("videoTrackChange", function (val) {
      return _this6.trigger("videoTrackChange", val);
    });
    mediaElementTrackChoiceManager.addEventListener("textTrackChange", function (val) {
      return _this6.trigger("textTrackChange", val);
    });
    return mediaElementTrackChoiceManager;
  };
  return (0,createClass/* default */.A)(Player, null, [{
    key: "ErrorTypes",
    get: /** All possible Error types emitted by the RxPlayer. */
    function get() {
      return error_codes/* ErrorTypes */.wU;
    }
    /** All possible Error codes emitted by the RxPlayer. */
  }, {
    key: "ErrorCodes",
    get: function get() {
      return error_codes/* ErrorCodes */.tG;
    }
    /**
     * Current log level.
     * Update current log level.
     * Should be either (by verbosity ascending):
     *   - "NONE"
     *   - "ERROR"
     *   - "WARNING"
     *   - "INFO"
     *   - "DEBUG"
     * Any other value will be translated to "NONE".
     */
  }, {
    key: "LogLevel",
    get: function get() {
      return src_log/* default */.A.getLevel();
    },
    set: function set(logLevel) {
      src_log/* default */.A.setLevel(logLevel);
    }
  }]);
}(event_emitter/* default */.A);
/**
 * Store all video elements currently in use by an RxPlayer instance.
 * This is used to check that a video element is not shared between multiple instances.
 * Use of a WeakSet ensure the object is garbage collected if it's not used anymore.
 */
Player._priv_currentlyUsedVideoElements = new WeakSet();
Player.version = /* PLAYER_VERSION */"3.33.4";
/* harmony default export */ var public_api = (Player);
;// CONCATENATED MODULE: ./src/core/api/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/* harmony default export */ var api = (public_api);
;// CONCATENATED MODULE: ./src/features/initialize_features.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* eslint-disable @typescript-eslint/no-unsafe-assignment */
/* eslint-disable @typescript-eslint/no-unsafe-member-access */
/* eslint-disable @typescript-eslint/no-var-requires */
/* eslint-disable @typescript-eslint/no-require-imports */

/**
 * Selects the features to include.
 */
function initializeFeaturesObject() {
  var HAS_MEDIA_SOURCE =  true || 0;
  if (HAS_MEDIA_SOURCE) {
    features_object/* default */.A.mediaSourceInit = (__webpack_require__(1737)/* ["default"] */ .A);
  }
  if (true) {
    features_object/* default */.A.decrypt = (__webpack_require__(6699)/* ["default"] */ .Ay);
  }
  if (true) {
    features_object/* default */.A.imageBuffer = (__webpack_require__(4166)/* ["default"] */ .A);
    features_object/* default */.A.imageParser = (__webpack_require__(1755)/* ["default"] */ .A);
  }
  // Feature switching the Native TextTrack implementation
  var HAS_NATIVE_MODE =  true || 0;
  if (true) {
    features_object/* default */.A.transports.smooth = (__webpack_require__(5564)/* ["default"] */ .A);
  }
  if (true) {
    features_object/* default */.A.transports.dash = (__webpack_require__(9502)/* ["default"] */ .A);
    features_object/* default */.A.dashParsers.js = (__webpack_require__(95)/* ["default"] */ .A);
  }
  if (false) {}
  if (false) {}
  if (false) {}
  if (HAS_NATIVE_MODE) {
    features_object/* default */.A.nativeTextTracksBuffer = (__webpack_require__(8385)/* ["default"] */ .A);
    if (true) {
      features_object/* default */.A.nativeTextTracksParsers.vtt = (__webpack_require__(2537)/* ["default"] */ .A);
    }
    if (true) {
      features_object/* default */.A.nativeTextTracksParsers.ttml = (__webpack_require__(5084)/* ["default"] */ .A);
    }
    if (true) {
      features_object/* default */.A.nativeTextTracksParsers.sami = (__webpack_require__(7275)/* ["default"] */ .A);
    }
    if (true) {
      features_object/* default */.A.nativeTextTracksParsers.srt = (__webpack_require__(5992)/* ["default"] */ .A);
    }
  }
  // Feature switching the HTML TextTrack implementation
  var HAS_HTML_MODE =  true || 0;
  if (HAS_HTML_MODE) {
    features_object/* default */.A.htmlTextTracksBuffer = (__webpack_require__(7938)/* ["default"] */ .A);
    if (true) {
      features_object/* default */.A.htmlTextTracksParsers.sami = (__webpack_require__(9561)/* ["default"] */ .A);
    }
    if (true) {
      features_object/* default */.A.htmlTextTracksParsers.ttml = (__webpack_require__(8342)/* ["default"] */ .A);
    }
    if (true) {
      features_object/* default */.A.htmlTextTracksParsers.srt = (__webpack_require__(1650)/* ["default"] */ .A);
    }
    if (true) {
      features_object/* default */.A.htmlTextTracksParsers.vtt = (__webpack_require__(8977)/* ["default"] */ .A);
    }
  }
  if (true) {
    var initDirectFile = (__webpack_require__(5963)/* ["default"] */ .A);
    var mediaElementTrackChoiceManager = (__webpack_require__(3568)/* ["default"] */ .A);
    features_object/* default */.A.directfile = {
      initDirectFile: initDirectFile,
      mediaElementTrackChoiceManager: mediaElementTrackChoiceManager
    };
  }
}
;// CONCATENATED MODULE: ./src/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * This file exports a Player class with a default feature set (depends on the
 * environment variables set at build).
 *
 * This is the class used from a regular build.
 */




// set initial features according to environment variables
initializeFeaturesObject();
if (isDebugModeEnabled()) {
  src_log/* default */.A.setLevel("DEBUG");
} else if (false) {}
/* harmony default export */ var src = (api);
}();
__webpack_exports__ = __webpack_exports__["default"];
/******/ 	return __webpack_exports__;
/******/ })()
;
});