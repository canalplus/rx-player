!function webpackUniversalModuleDefinition(root, factory) {
    "object" == typeof exports && "object" == typeof module ? module.exports = factory() : "function" == typeof define && define.amd ? define([], factory) : "object" == typeof exports ? exports.RxPlayer = factory() : root.RxPlayer = factory();
}(window, function() {
    /******/
    return function(modules) {
        // webpackBootstrap
        /******/ // The module cache
        /******/ var installedModules = {};
        /******/
        /******/ // The require function
        /******/        function __webpack_require__(moduleId) {
            /******/
            /******/ // Check if module is in cache
            /******/ if (installedModules[moduleId]) 
            /******/ return installedModules[moduleId].exports;
            /******/
            /******/ // Create a new module (and put it into the cache)
            /******/            var module = installedModules[moduleId] = {
                /******/ i: moduleId,
                /******/ l: !1,
                /******/ exports: {}
                /******/            };
            /******/
            /******/ // Execute the module function
            /******/            
            /******/
            /******/ // Return the exports of the module
            /******/ return modules[moduleId].call(module.exports, module, module.exports, __webpack_require__), 
            /******/
            /******/ // Flag the module as loaded
            /******/ module.l = !0, module.exports;
            /******/        }
        /******/
        /******/
        /******/ // expose the modules object (__webpack_modules__)
        /******/        
        /******/
        /******/
        /******/ // Load entry module and return exports
        /******/ return __webpack_require__.m = modules, 
        /******/
        /******/ // expose the module cache
        /******/ __webpack_require__.c = installedModules, 
        /******/
        /******/ // define getter function for harmony exports
        /******/ __webpack_require__.d = function(exports, name, getter) {
            /******/ __webpack_require__.o(exports, name) || 
            /******/ Object.defineProperty(exports, name, {
                enumerable: !0,
                get: getter
            })
            /******/;
        }, 
        /******/
        /******/ // define __esModule on exports
        /******/ __webpack_require__.r = function(exports) {
            /******/ "undefined" != typeof Symbol && Symbol.toStringTag && 
            /******/ Object.defineProperty(exports, Symbol.toStringTag, {
                value: "Module"
            })
            /******/ , Object.defineProperty(exports, "__esModule", {
                value: !0
            });
        }, 
        /******/
        /******/ // create a fake namespace object
        /******/ // mode & 1: value is a module id, require it
        /******/ // mode & 2: merge all properties of value into the ns
        /******/ // mode & 4: return value when already ns object
        /******/ // mode & 8|1: behave like require
        /******/ __webpack_require__.t = function(value, mode) {
            /******/ if (
            /******/ 1 & mode && (value = __webpack_require__(value)), 8 & mode) return value;
            /******/            if (4 & mode && "object" == typeof value && value && value.__esModule) return value;
            /******/            var ns = Object.create(null);
            /******/            
            /******/ if (__webpack_require__.r(ns), 
            /******/ Object.defineProperty(ns, "default", {
                enumerable: !0,
                value: value
            }), 2 & mode && "string" != typeof value) for (var key in value) __webpack_require__.d(ns, key, function(key) {
                return value[key];
            }.bind(null, key));
            /******/            return ns;
            /******/        }, 
        /******/
        /******/ // getDefaultExport function for compatibility with non-harmony modules
        /******/ __webpack_require__.n = function(module) {
            /******/ var getter = module && module.__esModule ? 
            /******/ function getDefault() {
                return module.default;
            } : 
            /******/ function getModuleExports() {
                return module;
            };
            /******/            
            /******/ return __webpack_require__.d(getter, "a", getter), getter;
            /******/        }, 
        /******/
        /******/ // Object.prototype.hasOwnProperty.call
        /******/ __webpack_require__.o = function(object, property) {
            return Object.prototype.hasOwnProperty.call(object, property);
        }, 
        /******/
        /******/ // __webpack_public_path__
        /******/ __webpack_require__.p = "", __webpack_require__(__webpack_require__.s = 144);
        /******/    }
    /************************************************************************/
    /******/ ([ 
    /* 0 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // EXTERNAL MODULE: ./src/utils/noop.ts
                var noop = __webpack_require__(27), logger = new (
        /* */
        function() {
            function Logger() {
                this.error = noop.a, this.warn = noop.a, this.info = noop.a, this.debug = noop.a, 
                this.LEVELS = {
                    NONE: 0,
                    ERROR: 1,
                    WARNING: 2,
                    INFO: 3,
                    DEBUG: 4
                }, this.currentLevel = "NONE";
            }
            /**
   * @param {string} levelStr
   */            var _proto = Logger.prototype;
            return _proto.setLevel = function setLevel(levelStr) {
                var level, foundLevel = this.LEVELS[levelStr];
                this.currentLevel = foundLevel ? (
                // levelStr is a ILoggerLevel
                level = foundLevel, levelStr) : (
                // either 0 or not found
                level = 0, "NONE")
                /* tslint:disable no-invalid-this */
                /* tslint:disable no-console */ , this.error = level >= this.LEVELS.ERROR ? console.error.bind(console) : noop.a, 
                this.warn = level >= this.LEVELS.WARNING ? console.warn.bind(console) : noop.a, 
                this.info = level >= this.LEVELS.INFO ? console.info.bind(console) : noop.a, this.debug = level >= this.LEVELS.DEBUG ? console.log.bind(console) : noop.a;
            }
            /**
   * @returns {string}
   */ , _proto.getLevel = function getLevel() {
                return this.currentLevel;
            }, Logger;
        }())();
        // CONCATENATED MODULE: ./src/utils/logger.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        __webpack_exports__.a = logger;
    }, 
    /* 1 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "p", function() {
            return strToBytes;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() {
            return bytesToStr;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() {
            return bytesToUTF16Str;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() {
            return hexToBytes;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() {
            return bytesToHex;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() {
            return concat;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return be2toi;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() {
            return be3toi;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() {
            return be4toi;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() {
            return be8toi;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() {
            return le2toi;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "o", function() {
            return le4toi;
        }), 
        /* unused harmony export le8toi */
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() {
            return itobe2;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() {
            return itobe4;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() {
            return itobe8;
        }), 
        /* unused harmony export itole2 */
        /* unused harmony export itole4 */
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() {
            return guidToUuid;
        });
        /* harmony import */ var _assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(16);
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Convert a simple string to an Uint8Array containing the corresponding
 * UTF-8 code units.
 * /!\ its implementation favors simplicity and performance over accuracy.
 * Each character having a code unit higher than 255 in UTF-16 will be
 * truncated (real value % 256).
 * Please take that into consideration when calling this function.
 * @param {string} str
 * @returns {Uint8Array}
 */        function strToBytes(str) {
            for (var len = str.length, arr = new Uint8Array(len), i = 0; i < len; i++) arr[i] = 255 & str.charCodeAt(i);
            return arr;
        }
        /**
 * construct string from the code units given
 * @param {Uint16Array|Uint8Array} bytes
 * @returns {string}
 */        function bytesToStr(bytes) {
            // NOTE: ugly I know, but TS is problematic here (you can try)
            return String.fromCharCode.apply(null, bytes);
        }
        /**
 * construct string from the code units given.
 * Only use every other byte for each UTF-16 character.
 * @param {Uint8Array} bytes
 * @returns {string}
 */        function bytesToUTF16Str(bytes) {
            for (var str = "", len = bytes.length, i = 0; i < len; i += 2) str += String.fromCharCode(bytes[i]);
            return str;
        }
        /**
 * Convert hex codes in a string form into the corresponding bytes.
 * @param {string} str
 * @returns {Uint8Array}
 * @throws TypeError - str.length is odd
 */        function hexToBytes(str) {
            for (var len = str.length, arr = new Uint8Array(len / 2), i = 0, j = 0; i < len; i += 2, 
            j++) arr[j] = 255 & parseInt(str.substring(i, i + 2), 16);
            return arr;
        }
        /**
 * Convert bytes into the corresponding hex string, with the possibility
 * to add a separator.
 * @param {Uint8Array} bytes
 * @param {string} [sep=""] - separator. Separate each two hex character.
 * @returns {string}
 */        function bytesToHex(bytes, sep) {
            void 0 === sep && (sep = "");
            for (var hex = "", i = 0; i < bytes.byteLength; i++) hex += (bytes[i] >>> 4).toString(16), 
            hex += (15 & bytes[i]).toString(16), sep.length && i < bytes.byteLength - 1 && (hex += sep);
            return hex;
        }
        /**
 * Returns a Uint8Array from the arguments given, in order:
 *   - if the next argument given is a number N set the N next bytes to 0.
 *   - else set the next bytes to the argument given.
 * @param {...(Number|Uint8Array)} args
 * @returns {Uint8Array}
 */        function concat() {
            for (var arg, l = arguments.length, i = -1, len = 0; ++i < l; ) len += "number" == typeof (arg = i < 0 || arguments.length <= i ? void 0 : arguments[i]) ? arg : arg.length;
            var arr = new Uint8Array(len), offset = 0;
            for (i = -1; ++i < l; ) "number" == typeof (arg = i < 0 || arguments.length <= i ? void 0 : arguments[i]) ? offset += arg : 0 < arg.length && (arr.set(arg, offset), 
            offset += arg.length);
            return arr;
        }
        /**
 * Translate groups of 2 big-endian bytes to Integer (from 0 up to 65535).
 * @param {Uint8Array} bytes
 * @param {Number} offset - The offset (from the start of the given array)
 * @returns {Number}
 */        function be2toi(bytes, offset) {
            return (bytes[offset + 0] << 8) + (bytes[offset + 1] << 0);
        }
        /**
 * Translate groups of 3 big-endian bytes to Integer.
 * @param {Uint8Array} bytes
 * @param {Number} offset - The offset (from the start of the given array)
 * @returns {Number}
 */        function be3toi(bytes, offset) {
            return 65536 * bytes[offset + 0] + 256 * bytes[offset + 1] + bytes[offset + 2];
        }
        /**
 * Translate groups of 4 big-endian bytes to Integer.
 * @param {Uint8Array} bytes
 * @param {Number} offset - The offset (from the start of the given array)
 * @returns {Number}
 */        function be4toi(bytes, offset) {
            return 16777216 * bytes[offset + 0] + 65536 * bytes[offset + 1] + 256 * bytes[offset + 2] + bytes[offset + 3];
        }
        /**
 * Translate groups of 8 big-endian bytes to Integer.
 * @param {Uint8Array} bytes
 * @param {Number} offset - The offset (from the start of the given array)
 * @returns {Number}
 */        function be8toi(bytes, offset) {
            return 4294967296 * (16777216 * bytes[offset + 0] + 65536 * bytes[offset + 1] + 256 * bytes[offset + 2] + bytes[offset + 3]) + 16777216 * bytes[offset + 4] + 65536 * bytes[offset + 5] + 256 * bytes[offset + 6] + bytes[offset + 7];
        }
        /**
 * Translate Integer (from 0 up to 65535) to a Uint8Array of length 2 of
 * the corresponding big-endian bytes.
 * @param {Number} num
 * @returns {Uint8Array}
 */        function itobe2(num) {
            return new Uint8Array([ num >>> 8 & 255, 255 & num ]);
        }
        /**
 * Translate Integer to a Uint8Array of length 4 of the corresponding big-endian
 * bytes.
 * @param {Number} num
 * @returns {Uint8Array}
 */        function itobe4(num) {
            return new Uint8Array([ num >>> 24 & 255, num >>> 16 & 255, num >>> 8 & 255, 255 & num ]);
        }
        /**
 * Translate Integer to a Uint8Array of length 8 of the corresponding big-endian
 * bytes.
 * /!\ If the top-most bytes are set, this might go over MAX_SAFE_INTEGER, thus
 * leading to a "bad" value.
 * @param {Number} num
 * @returns {Uint8Array}
 */        function itobe8(num) {
            var l = num % 4294967296, h = (num - l) / 4294967296;
            return new Uint8Array([ h >>> 24 & 255, h >>> 16 & 255, h >>> 8 & 255, 255 & h, l >>> 24 & 255, l >>> 16 & 255, l >>> 8 & 255, 255 & l ]);
        }
        /**
 * Translate groups of 2 little-endian bytes to Integer (from 0 up to 65535).
 * @param {Uint8Array} bytes
 * @param {Number} offset - The offset (from the start of the given array)
 * @returns {Number}
 */        function le2toi(bytes, offset) {
            return (bytes[offset + 0] << 0) + (bytes[offset + 1] << 8);
        }
        /**
 * Translate groups of 4 little-endian bytes to Integer.
 * @param {Uint8Array} bytes
 * @param {Number} offset - The offset (from the start of the given array)
 * @returns {Number}
 */        function le4toi(bytes, offset) {
            return bytes[offset + 0] + 256 * bytes[offset + 1] + 65536 * bytes[offset + 2] + 16777216 * bytes[offset + 3];
        }
        /**
 * Translate groups of 8 little-endian bytes to Integer.
 * @param {Uint8Array} bytes
 * @param {Number} offset - The offset (from the start of the given array)
 * @returns {Number}
 */        
        /**
 * @param {string} uuid
 * @returns {string}
 * @throws AssertionError - The uuid length is not 16
 */
        function guidToUuid(uuid) {
            Object(_assert__WEBPACK_IMPORTED_MODULE_0__.b)(16 === uuid.length, "UUID length should be 16");
            var buf = strToBytes(uuid), p1A = buf[0], p1B = buf[1], p1C = buf[2], p1D = buf[3], p2A = buf[4], p2B = buf[5], p3A = buf[6], p3B = buf[7], p4 = buf.subarray(8, 10), p5 = buf.subarray(10, 16), ord = new Uint8Array(16);
            return ord[0] = p1D, ord[1] = p1C, ord[2] = p1B, ord[3] = p1A, // swap32 BE -> LE
            ord[4] = p2B, ord[5] = p2A, // swap16 BE -> LE
            ord[6] = p3B, ord[7] = p3A, // swap16 BE -> LE
            ord.set(p4, 8), ord.set(p5, 10), bytesToHex(ord);
        }
        /***/    }, 
    /* 2 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Configuration file for the whole player.
 * Feel free to tweak those values if you know what you're doing.
 *
 * Please not that you will need to re-build the whole project to take these
 * modifications into account.
 *
 * @type {Object}
 */
        /* harmony default export */        __webpack_exports__.a = {
            /**
   * Volume set on unMute if the volume is set to 0 and either:
   *   - mute has never been called before
   *   - mute has last been called while the volume was already set to 0 (either
   *     via setVolume, or a previous mute call)
   * @type {Number}
   */
            DEFAULT_UNMUTED_VOLUME: .1,
            /**
   * Default time interval after which a request will timeout, in ms.
   * @type {Number}
   */
            DEFAULT_REQUEST_TIMEOUT: 3e4,
            /**
   * Can be either:
   *   - "native": Subtitles are all displayed in a <track> element
   *   - "html": Subtitles are all displayed in a <div> separated from the video
   *     element. Can be useful to display richer TTML subtitles, for example.
   * @type {Object|null}
   */
            DEFAULT_TEXT_TRACK_MODE: "native",
            /**
   * Strategy to adopt when manually setting the current bitrate.
   * Can be either:
   *   - "seamless": transitions are very smooth but not immediate.
   *   - "direct": the quality switch happens immediately but to achieve that,
   *     the player will need to set a new MediaSource on the media element in
   *     some cases. This often leads to a black screen + unavailable APIs
   *     during a short moment.
   * @type {string}
   */
            DEFAULT_MANUAL_BITRATE_SWITCHING_MODE: "seamless",
            /**
   * If set to true, video through loadVideo will auto play by default
   * @type {Boolean}
   */
            DEFAULT_AUTO_PLAY: !1,
            /**
   * If set to false, "native" subtitles (in a <track> element) will be hidden
   * by default.
   * @type {Boolean}
   */
            DEFAULT_SHOW_NATIVE_SUBTITLE: !0,
            /**
   * If set to true, the player will by default stop immediately and unload the
   * content on reaching the end of the media.
   *
   * If set to false, it will not unload nor stop by default, leaving the user
   * free to seek in the already-loaded content.
   *
   * Set to `true` for legacy reasons.
   * @type {Boolean}
   */
            DEFAULT_STOP_AT_END: !0,
            /**
   * Default buffer goal in seconds.
   * Once enough content has been downloaded to fill the buffer up to
   * ``current position + DEFAULT_WANTED_BUFFER_AHEAD", we will stop downloading
   * content.
   * @type {Number}
   */
            DEFAULT_WANTED_BUFFER_AHEAD: 30,
            /**
   * Default max buffer size ahead of the current position in seconds.
   * The buffer _after_ this limit will be garbage collected.
   * Set to Infinity for no limit.
   * @type {Number}
   */
            DEFAULT_MAX_BUFFER_AHEAD: Infinity,
            /**
   * Default max buffer size ahead of the current position in seconds.
   * The buffer _before_ this limit will be garbage collected.
   * Set to Infinity for no limit.
   * @type {Number}
   */
            DEFAULT_MAX_BUFFER_BEHIND: Infinity,
            /* tslint:disable no-object-literal-type-assertion */
            /**
   * Maximum possible buffer ahead for each type of buffer, to avoid too much
   * memory usage when playing for a long time.
   * Equal to Infinity if not defined here.
   * @type {Object}
   */
            MAXIMUM_MAX_BUFFER_AHEAD: {
                text: 18e3
            },
            /* tslint:enable no-object-literal-type-assertion */
            /* tslint:disable no-object-literal-type-assertion */
            /**
   * Maximum possible buffer behind for each type of buffer, to avoid too much
   * memory usage when playing for a long time.
   * Equal to Infinity if not defined here.
   * @type {Object}
   */
            MAXIMUM_MAX_BUFFER_BEHIND: {
                text: 18e3
            },
            /* tslint:enable no-object-literal-type-assertion */
            /**
   * Default bitrate ceils initially set as the first content begins.
   *
   * If no track is found with a bitrate inferior or equal to the
   * bitrate there, the one with the lowest bitrate will be taken instead.
   *
   * Set to 0 for the lowest bitrate, Infinity for the highest.
   *
   * These values are only useful for the first content played, as consecutive
   * play will always take the last set one.
   * @type {Object}
   */
            DEFAULT_INITIAL_BITRATES: {
                audio: 0,
                video: 0,
                other: 0
            },
            /* tslint:disable no-object-literal-type-assertion */
            /**
   * Default bitrate ceil initially set to dictate the maximum bitrate the
   * ABR manager can automatically switch to.
   *
   * If no track is found with a quality inferior or equal to the
   * bitrate there, the lowest bitrate will be taken instead.
   *
   * Set to Infinity to discard any limit in the ABR strategy.
   * @type {Object}
   */
            DEFAULT_MAX_BITRATES: {
                audio: Infinity,
                video: Infinity,
                other: Infinity
            },
            /* tslint:enable no-object-literal-type-assertion */
            /**
   * Delay after which, if the page is hidden, the user is considered inactive
   * on the current video.
   *
   * Allow to enforce specific optimizations when the page is not shown.
   * @see DEFAULT_THROTTLE_WHEN_HIDDEN
   * @type {Number}
   */
            INACTIVITY_DELAY: 6e4,
            /**
   * If true, if the player is in a "hidden" state for a delay specified by the
   * INACTIVITY DELAY config property, we throttle automatically to the video
   * representation with the lowest bitrate.
   * @type {Boolean}
   */
            DEFAULT_THROTTLE_WHEN_HIDDEN: !1,
            /**
   * If true, the video representations you can switch to in adaptive mode
   * are limited by the video element's width.
   *
   * Basically in that case, we won't switch to a video Representation with
   * a width higher than the current width of the video HTMLElement.
   * @type {Boolean}
   */
            DEFAULT_LIMIT_VIDEO_WIDTH: !1,
            /**
   * Default initial live gap considered if no presentation delay has been
   * suggested, in seconds.
   * @type {Number}
   */
            DEFAULT_LIVE_GAP: 10,
            /**
   * Default value for a manifest's suggested presentation delay if not
   * specified in the manifest.
   * @type {Object}
   */
            DEFAULT_SUGGESTED_PRESENTATION_DELAY: {
                SMOOTH: 10,
                DASH: 10
            },
            /**
   * Maximum time, in seconds, the player should automatically skip when stalled
   * because of a discontinuity in the downloaded range.
   * @type {Number}
   */
            DISCONTINUITY_THRESHOLD: 1,
            /**
   * Ratio used to know if an already loaded segment should be re-buffered.
   * We re-load the given segment if the current one times that ratio is
   * inferior to the new one.
   * @type {Number}
   */
            BITRATE_REBUFFERING_RATIO: 1.5,
            /**
   * Those are used when a "QuotaExceededError" error is received after
   * appending a new segment in the SourceBuffer.
   *
   * This error can arise when the browser's buffer is considered full.
   * In this case, the player goes into manual garbage collection (GC) mode.
   * @type {Object}
   */
            BUFFER_GC_GAPS: {
                /**
     * _Low_ gap (from current position) from which the buffer will be _garbage
     * collected_ (read removed from the buffer) when a QuotaExceededError is
     * received.
     * In seconds.
     * @type {Number}
     */
                CALM: 240,
                /**
     * _High_ gap (from current position) from which the buffer will be _garbage
     * collected_ (read removed from the buffer) when a QuotaExceededError is
     * received, if the low one does not clean up any buffer.
     * In seconds.
     * @type {Number}
     */
                BEEFY: 30
            },
            /**
   * The default number of times a manifest request will be re-performed
   * when loaded/refreshed if the request finishes on an error which
   * justify an retry.
   *
   * Note that some errors do not use this counter:
   *   - if the error is not due to the xhr, no retry will be peformed
   *   - if the error is an HTTP error code, but not a 500-smthg or a 404, no
   *     retry will be performed.
   *   - if it has a high chance of being due to the user being offline, a
   *     separate counter is used (see DEFAULT_MAX_PIPELINES_RETRY_ON_OFFLINE).
   * @type Number
   */
            DEFAULT_MAX_MANIFEST_REQUEST_RETRY: 4,
            /**
   * The default number of times a pipeline request will be re-performed when
   * on error which justify a retry.
   *
   * Note that some errors do not use this counter:
   *   - if the error is not due to the xhr, no retry will be peformed
   *   - if the error is an HTTP error code, but not a 500-smthg or a 404, no
   *     retry will be performed.
   *   - if it has a high chance of being due to the user being offline, a
   *     separate counter is used (see DEFAULT_MAX_PIPELINES_RETRY_ON_OFFLINE).
   * @type Number
   */
            DEFAULT_MAX_PIPELINES_RETRY_ON_ERROR: 4,
            /**
   * Under some circonstances, we're able to tell that the user is offline (see
   * the compat files).
   * When this happens, and xhr requests fails due to an error event (you might
   * still be able to perform xhr offline, e.g. on localhost), you might want to
   * retry indefinitely or with a higher number of retry than if the error is
   * due to a CDN problem.
   *
   * A capped exponential backoff will still be used (like for an error code).
   * @type {Number}
   */
            DEFAULT_MAX_PIPELINES_RETRY_ON_OFFLINE: Infinity,
            /**
   * Initial backoff delay when a segment / manifest download fails, in
   * milliseconds.
   *
   * This delay will then grow exponentally by power of twos (200, 400, 800
   * etc.)
   *
   * Please note that this delay is not exact, as it will be fuzzed.
   * @type {Number}
   */
            INITIAL_BACKOFF_DELAY_BASE: 200,
            /**
   * Maximum backoff delay when a segment / manifest download fails, in
   * milliseconds.
   *
   * Please note that this delay is not exact, as it will be fuzzed.
   * @type {Number}
   */
            MAX_BACKOFF_DELAY_BASE: 3e3,
            /**
   * Minimum interval at which timeupdate events will be "constructed". This
   * variable is for the "regular" mediasource strategy (that is, not for the
   * directfile API.
   *
   * Those events are the base of various important mechanisms in the player:
   *   - set the clock for the buffer.
   *   - set the clock for the ABR strategy.
   *   - used to trigger positionUpdate events.
   *
   * This common logic is for performance reasons, as we call multiple browser's
   * APIs which are useful for most of these.
   *
   * Keep in mind this is the minimum interval. This logic will also be
   * triggered when various events of the media element are received.
   * @type {Number}
   */
            SAMPLING_INTERVAL_MEDIASOURCE: 1e3,
            /**
   * Same than SAMPLING_INTERVAL_MEDIASOURCE but for the directfile API.
   * @type {Number}
   */
            SAMPLING_INTERVAL_NO_MEDIASOURCE: 500,
            /**
   * Minimum number of bytes sampled before we trust the estimate.
   * If we have not sampled much data, our estimate may not be accurate
   * enough to trust.
   * If the total of bytes sampled is less than this value, we use a
   * default estimate.
   * This specific value is based on experimentations.
   * @type {Number}
   */
            ABR_MINIMUM_TOTAL_BYTES: 15e4,
            /**
   * Minimum number of bytes, under which samples are discarded.
   * Our models do not include latency information, so connection startup time
   * (time to first byte) is considered part of the download time.
   * Because of this, we should ignore very small downloads which would cause
   * our estimate to be too low.
   * This specific value is based on experimentation.
   * @type {Number}
   */
            ABR_MINIMUM_CHUNK_SIZE: 16e3,
            /**
   * Factor with which is multiplied the bandwidth estimate when the ABR is in
   * starvation mode.
   * @type {Number}
   */
            ABR_STARVATION_FACTOR: .72,
            /**
   * Factor with which is multiplied the bandwidth estimate when the ABR is not
   * in starvation mode.
   * @type {Number}
   */
            ABR_REGULAR_FACTOR: .9,
            /**
   * If a SourceBuffer has less than ABR_STARVATION_GAP in seconds ahead of the
   * current position in its buffer, the ABR manager will go into starvation
   * mode.
   *
   * It gets out of starvation mode when the OUT_OF_STARVATION_GAP value is
   * reached.
   *
   * Under this starvation mode:
   *
   *   - the bandwidth considered will be a little lower than the one estimated
   *
   *   - the time the next important request take will be checked
   *     multiple times to detect when/if it takes too much time.
   *     If the request is considered too long, the bitrate will be hastily
   *     re-calculated from this single request.
   *
   * @type {Number}
   */
            ABR_STARVATION_GAP: 5,
            OUT_OF_STARVATION_GAP: 7,
            /**
   * This is a security to avoid going into starvation mode when the content is
   * ending (@see ABR_STARVATION_GAP).
   * Basically, we subtract that value from the global duration of the content
   * and we never enter "starvation mode" if the currently available buffer
   * (which equals to the current position + the available buffer ahead of it)
   * is equal or higher than this value.
   * @type {Number}
   */
            ABR_STARVATION_DURATION_DELTA: .1,
            /**
   * Half-life, in seconds for a fastly-evolving exponential weighted moving
   * average.
   * The lower it is, the faster the ABR logic will react to the bandwidth
   * falling quickly.
   * Should be kept to a lower number than ABR_SLOW_EMA for coherency reasons.
   * @type {Number}
   */
            ABR_FAST_EMA: 2,
            /**
   * Half-life, in seconds for a slowly-evolving exponential weighted moving
   * average.
   * The lower it is, the faster the ABR logic is going to react to recent
   * bandwidth variation, on the higher and on the lower side.
   * Should be kept to a higher number than ABR_FAST_EMA for coherency reasons.
   * @type {Number}
   */
            ABR_SLOW_EMA: 10,
            /**
   * Number of seconds ahead in the buffer after which playback will resume when
   * seeking on an unbuffered part of the content.
   * @type {Number}
   */
            RESUME_GAP_AFTER_SEEKING: 1.5,
            /**
   * Number of seconds ahead in the buffer after which playback will resume when
   * the player was stalled due to a low readyState.
   * @type {Number}
   */
            RESUME_GAP_AFTER_NOT_ENOUGH_DATA: .5,
            /**
   * Number of seconds ahead in the buffer after which playback will resume
   * after the player went through a buffering step.
   * @type {Number}
   */
            RESUME_GAP_AFTER_BUFFERING: 5,
            /**
   * Maximum number of seconds in the buffer based on which a "stalling"
   * strategy will be considered:
   * The player will pause playback to get enough time building a sufficient
   * buffer. This mostly happen when seeking in an unbuffered part or when
   * buffering.
   * @type {Number}
   */
            STALL_GAP: .5,
            /**
   * Maximum difference allowed between a segment _announced_ start (what the
   * rx-player infers to be the starting time) and its _real_  current starting
   * time in the SourceBuffer, in seconds, until the segment is considered
   * "incomplete".
   * Same for the ending time announced and its effective end time in the source
   * buffer.
   *
   * If the difference is bigger than this value, the segment will be considered
   * incomplete (e.g. considered as partially garbage-collected) and as such
   * might be re-downloaded.
   *
   * Keeping a too high value might lead to incomplete segments being wrongly
   * considered as complete (and thus not be re-downloaded, this could lead the
   * player to stall).
   * Note that in a worst-case scenario this can happen for the end of a segment
   * and the start of the contiguous segment, leading to a discontinuity two
   * times this value.
   *
   * Keeping a too low value might lead to re-downloading the same segment
   * multiple times (when the start and end times are badly estimated) as they
   * will wrongly believed to be partially garbage-collected.
   *
   * If a segment has a perfect continuity with a previous/following one in the
   * SourceBuffer the start/end of it will not be checked. This allows to limit
   * the number of time this error-prone logic is applied.
   *
   * Note that in most cases, the rx-player's start and end times estimations
   * are __really__ close to what they really are in the sourcebuffer (we
   * usually have a difference in the order of 10^-7), as time information is
   * most of the time directly parsed from the media container.
   *
   * @type {Number}
   */
            MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT: .12,
            /**
   * The maximum time, in seconds, the real buffered time in the sourcebuffer
   * can be superior to the time inferred by the rx-player (the "real" buffered
   * start inferior to the inferred start and the "real" buffered end superior
   * to the inferred end).
   * This limit allows to avoid resizing too much downloaded segments because
   * no other segment is linked to a buffered part.
   *
   * Setting a value too high can lead to parts of the SourceBuffer being
   * linked to the wrong segments.
   * Setting a value too low can lead to parts of the SourceBuffer not being
   * linked to the concerned segment.
   * @type {Number}
   */
            MAX_BUFFERED_DISTANCE: .1,
            /**
   * Minimum duration in seconds a segment should be into a buffered range to be
   * considered as part of that range.
   * Segments which have less than this amount of time "linked" to a buffered
   * range will be deleted.
   *
   * Setting a value too low can lead in worst-case scenarios to segments being
   * wrongly linked to the next or previous range it is truly linked too (if
   * those ranges are too close).
   *
   * Setting a value too high can lead to part of the buffer not being assigned
   * any segment. It also limits the minimum duration a segment can be.
   *
   * TODO As of now, this limits the minimum size a complete segment can be. A
   * better logic would be to also consider the duration of a segment. Though
   * this logic could lead to bugs with the current code.
   * @type {Number}
   */
            MINIMUM_SEGMENT_SIZE: .2,
            /**
   * Maximum interval at which text tracks are refreshed in an "html"
   * textTrackMode.
   *
   * The text tracks are also refreshed on various video events, this interval
   * will only trigger a refresh if none of those events was received during
   * that timespan.
   *
   * Note that if the TextTrack cue did not change between two intervals or
   * events, the DOM won't be refreshed.
   * The TextTrack cues structure is also optimized for fast retrieval.
   * We should thus not have much of a performance impact here if we set a low
   * interval.
   *
   * @type {Number}
   */
            MAXIMUM_HTML_TEXT_TRACK_UPDATE_INTERVAL: 50,
            /**
   * The Buffer padding is a time offset from the current time that affects
   * the buffer.
   *
   * Basically, from a given time, if the current buffer gap number (time
   * between the current time and the end of the downloaded buffer) is between
   * the "high" and "low" described here (of the corresponding type), we won't
   * reschedule segments for that range.
   *
   * This is to avoid excessive re-buffering.
   *
   * Keeping the "high"s too low would increase the risk of re-bufferings.
   *
   * Keeping the "high"s too high would delay visible quality increase.
   *
   * @type {Object}
   */
            BUFFER_PADDING: {
                audio: {
                    high: 1,
                    low: 1
                },
                video: {
                    high: 3,
                    low: 2
                },
                other: {
                    high: 1,
                    low: 1
                }
            },
            /**
   * Segments of different types are downloaded by steps:
   *
   *   - first the audio/video/text Segments which are immediately needed
   *
   *   - then once every of those Segments have been downloaded, less-needed
   *     Segments
   *
   *   - then once every of those less-needed Segments have been downloaded,
   *     even less-needed Segments
   *
   *   - etc.
   *
   * This stepped download strategy allows to make a better use of network
   * ressources.
   *
   * For example, if more than sufficient audio buffer has been downloaded but
   * the immediately-needed video Segment is still pending its request, we might
   * be in a situation of rebuffering.
   * In that case, a better strategy would be to make sure every network
   * ressource is allocated for this video Segment before rebuffering happens.
   *
   * This is where those steps become useful.
   *
   * --
   *
   * The numbers defined in this Array describe what the steps are.
   *
   * Each number is linked to a distance from the current playing position, in
   * seconds.
   * Distances which will be used as limit points, from which a new step is
   * reached (see example).
   *
   * Note: You can set an empty array to deactivate the steps feature (every
   * Segments have the same priority).
   *
   * @example
   *
   * let's imagine the following SEGMENT_PRIORITIES_STEPS array:
   * [5, 11, 17, 25]
   *
   * To link each Segments to a corresponding priority (and thus to a specific
   * step), we have to consider the distance d between the current position and
   * the start time of the Segment.
   *
   * We have in our example 5 groups, which correspond to the following possible
   * d values:
   *   1. inferior to 5
   *   2. between 5 and 11
   *   3. between 11 and 17
   *   4. between 17 and 25
   *   5. superior to 25
   *
   * Segments corresponding to a lower-step will need to all be downloaded
   * before Segments of a newer step begin.
   *
   * @type {Array.<Number>}
   */
            SEGMENT_PRIORITIES_STEPS: [ 6, 14 ],
            /**
   * Robustnesses used in the {audio,video}Capabilities of the
   * MediaKeySystemConfiguration (EME).
   *
   * Only used for widevine keysystems.
   *
   * Defined in order of importance (first will be tested first etc.)
   * @type {Array.<string>}
   */
            EME_DEFAULT_WIDEVINE_ROBUSTNESSES: [ "HW_SECURE_ALL", "HW_SECURE_DECODE", "HW_SECURE_CRYPTO", "SW_SECURE_DECODE", "SW_SECURE_CRYPTO" ],
            /**
   * Link canonical key systems names to their respective reverse domain name,
   * used in the EME APIs.
   * This allows to have a simpler API, where users just need to set "widevine"
   * or "playready" as a keySystem.
   * @type {Object}
   */
            /* tslint:disable no-object-literal-type-assertion */
            EME_KEY_SYSTEMS: {
                clearkey: [ "webkit-org.w3.clearkey", "org.w3.clearkey" ],
                widevine: [ "com.widevine.alpha" ],
                playready: [ "com.microsoft.playready", "com.chromecast.playready", "com.youtube.playready" ]
            },
            /* tslint:enable no-object-literal-type-assertion */
            /**
   * Max simultaneous MediaKeySessions that will be kept as a cache to avoid
   * doing superfluous license requests.
   * If this number is reached, any new session creation will close the oldest
   * one.
   * @type {Number}
   */
            EME_MAX_SIMULTANEOUS_MEDIA_KEY_SESSIONS: 50,
            /**
   * The player relies on browser events and properties to update its status to
   * "ENDED".
   *
   * Sadly in some cases, like in Chrome 54, this event is never triggered on
   * some contents probably due to a browser bug.
   *
   * This threshold resolves this issue by forcing the status to "ENDED" when:
   *   1. the player is stalling
   *   2. the absolute difference between current playback time and duration is
   *      under this value
   *
   * If set to null, this workaround is disabled and the player only relies on
   * browser events.
   *
   * @type {Number|null}
   */
            FORCED_ENDED_THRESHOLD: .001,
            /**
   * Maximum duration from the current position we will let in the buffer when
   * switching an Adaptation of a given type.
   *
   * For example, if we have ``text: { before: 1, after: 4 }``, it means that
   * when switching subtitles, we will let 1 second before and 4 second after
   * the current position in the previous language (until the new segments
   * overwrite it).
   * This is to allow smooth transitions and avoid de-synchronization that
   * can happen when removing the content being decoded.
   * @type {Object}
   */
            ADAPTATION_SWITCH_BUFFER_PADDINGS: {
                video: {
                    before: .5,
                    after: 1
                },
                audio: {
                    before: .5,
                    after: 2
                },
                text: {
                    before: 0,
                    after: 0
                },
                image: {
                    before: 0,
                    after: 0
                }
            }
        };
    }, 
    /* 3 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return __extends;
        });
        /* unused harmony export __assign */
        /* unused harmony export __rest */
        /* unused harmony export __decorate */
        /* unused harmony export __param */
        /* unused harmony export __metadata */
        /* unused harmony export __awaiter */
        /* unused harmony export __generator */
        /* unused harmony export __exportStar */
        /* unused harmony export __values */
        /* unused harmony export __read */
        /* unused harmony export __spread */
        /* unused harmony export __await */
        /* unused harmony export __asyncGenerator */
        /* unused harmony export __asyncDelegator */
        /* unused harmony export __asyncValues */
        /* unused harmony export __makeTemplateObject */
        /* unused harmony export __importStar */
        /* unused harmony export __importDefault */
        /*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
        /* global Reflect, Promise */
        var extendStatics = function(d, b) {
            return (extendStatics = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(d, b) {
                d.__proto__ = b;
            } || function(d, b) {
                for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
            })(d, b);
        };
        function __extends(d, b) {
            function __() {
                this.constructor = d;
            }
            extendStatics(d, b), d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, 
            new __());
        }
    }, 
    /* 4 */ 
    /* 5 */ , 
    /* 6 */
    /***/ , 
    /* 6 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subscriber.js
                var Subscriber = __webpack_require__(8);
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/util/canReportError.js
        /** PURE_IMPORTS_START _Subscriber PURE_IMPORTS_END */        function canReportError(observer) {
            for (;observer; ) {
                var _a = observer, closed_1 = _a.closed, destination = _a.destination, isStopped = _a.isStopped;
                if (closed_1 || isStopped) return !1;
                observer = destination && destination instanceof Subscriber.a ? destination : null;
            }
            return !0;
        }
        //# sourceMappingURL=canReportError.js.map
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/symbol/rxSubscriber.js
                var rxSubscriber = __webpack_require__(61), Observer = __webpack_require__(69);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Observer.js
                // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/util/toSubscriber.js
        /** PURE_IMPORTS_START _Subscriber,_symbol_rxSubscriber,_Observer PURE_IMPORTS_END */
        function toSubscriber(nextOrObserver, error, complete) {
            if (nextOrObserver) {
                if (nextOrObserver instanceof Subscriber.a) return nextOrObserver;
                if (nextOrObserver[rxSubscriber.a]) return nextOrObserver[rxSubscriber.a]();
            }
            return nextOrObserver || error || complete ? new Subscriber.a(nextOrObserver, error, complete) : new Subscriber.a(Observer.a);
        }
        //# sourceMappingURL=toSubscriber.js.map
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/symbol/observable.js
                var observable = __webpack_require__(46), noop = __webpack_require__(37);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/noop.js
                function pipeFromArray(fns) {
            return fns ? 1 === fns.length ? fns[0] : function piped(input) {
                return fns.reduce(function(prev, fn) {
                    return fn(prev);
                }, input);
            } : noop.a;
        }
        //# sourceMappingURL=pipe.js.map
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/config.js
                var config = __webpack_require__(35);
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/Observable.js
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return Observable_Observable;
        });
        /** PURE_IMPORTS_START _util_canReportError,_util_toSubscriber,_internal_symbol_observable,_util_pipe,_config PURE_IMPORTS_END */
        var Observable_Observable = /* */ function() {
            function Observable(subscribe) {
                this._isScalar = !1, subscribe && (this._subscribe = subscribe);
            }
            return Observable.prototype.lift = function(operator) {
                var observable = new Observable();
                return observable.source = this, observable.operator = operator, observable;
            }, Observable.prototype.subscribe = function(observerOrNext, error, complete) {
                var operator = this.operator, sink = toSubscriber(observerOrNext, error, complete);
                if (operator ? sink.add(operator.call(sink, this.source)) : sink.add(this.source || config.a.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable ? this._subscribe(sink) : this._trySubscribe(sink)), 
                config.a.useDeprecatedSynchronousErrorHandling && sink.syncErrorThrowable && (sink.syncErrorThrowable = !1, 
                sink.syncErrorThrown)) throw sink.syncErrorValue;
                return sink;
            }, Observable.prototype._trySubscribe = function(sink) {
                try {
                    return this._subscribe(sink);
                } catch (err) {
                    config.a.useDeprecatedSynchronousErrorHandling && (sink.syncErrorThrown = !0, sink.syncErrorValue = err), 
                    canReportError(sink) ? sink.error(err) : console.warn(err);
                }
            }, Observable.prototype.forEach = function(next, promiseCtor) {
                var _this = this;
                return new (promiseCtor = getPromiseCtor(promiseCtor))(function(resolve, reject) {
                    var subscription;
                    subscription = _this.subscribe(function(value) {
                        try {
                            next(value);
                        } catch (err) {
                            reject(err), subscription && subscription.unsubscribe();
                        }
                    }, reject, resolve);
                });
            }, Observable.prototype._subscribe = function(subscriber) {
                var source = this.source;
                return source && source.subscribe(subscriber);
            }, Observable.prototype[observable.a] = function() {
                return this;
            }, Observable.prototype.pipe = function() {
                for (var operations = [], _i = 0; _i < arguments.length; _i++) operations[_i] = arguments[_i];
                return 0 === operations.length ? this : pipeFromArray(operations)(this);
            }, Observable.prototype.toPromise = function(promiseCtor) {
                var _this = this;
                return new (promiseCtor = getPromiseCtor(promiseCtor))(function(resolve, reject) {
                    var value;
                    _this.subscribe(function(x) {
                        return value = x;
                    }, function(err) {
                        return reject(err);
                    }, function() {
                        return resolve(value);
                    });
                });
            }, Observable.create = function(subscribe) {
                return new Observable(subscribe);
            }, Observable;
        }();
        function getPromiseCtor(promiseCtor) {
            if (promiseCtor || (promiseCtor = config.a.Promise || Promise), !promiseCtor) throw new Error("no Promise impl found");
            return promiseCtor;
        }
        //# sourceMappingURL=Observable.js.map
        /***/    }, 
    /* 7 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // EXTERNAL MODULE: ./src/compat/event_listeners.ts + 2 modules
                var event_listeners = __webpack_require__(44), next_tick = __webpack_require__(60), next_tick_default = /* */ __webpack_require__.n(next_tick), event_emitter = __webpack_require__(33);
        // EXTERNAL MODULE: ./node_modules/next-tick/index.js
                // CONCATENATED MODULE: ./src/compat/index.ts
        /* concated harmony reexport events */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return event_listeners;
        }), 
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        // TODO TO REMOVE
        // CONCATENATED MODULE: ./src/compat/patch_webkit_source_buffer.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        // TODO This is the last ugly side-effect here.
        // Either remove it or find the best way to implement that
        function patchWebkitSourceBuffer() {
            // old WebKit SourceBuffer implementation,
            // where a synchronous append is used instead of appendBuffer
            if (window.WebKitSourceBuffer && !window.WebKitSourceBuffer.prototype.addEventListener) {
                var sourceBufferWebkitProto = window.WebKitSourceBuffer.prototype;
                for (var fnName in event_emitter.a.prototype) event_emitter.a.prototype.hasOwnProperty(fnName) && (sourceBufferWebkitProto[fnName] = event_emitter.a.prototype[fnName]);
                sourceBufferWebkitProto._listeners = [], sourceBufferWebkitProto.__emitUpdate = function(eventName, val) {
                    var _this = this;
                    next_tick_default()(function() {
                        /* tslint:disable no-invalid-this */
                        _this.trigger(eventName, val), _this.updating = !1, _this.trigger("updateend");
                    });
                }, sourceBufferWebkitProto.appendBuffer = function(data) {
                    /* tslint:disable no-invalid-this */
                    if (this.updating) throw new Error("updating");
                    this.trigger("updatestart"), this.updating = !0;
                    try {
                        this.append(data);
                    } catch (error) {
                        return void this.__emitUpdate("error", error);
                    }
                    this.__emitUpdate("update");
                };
            }
        }();
    }, 
    /* 8 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return Subscriber;
        });
        /* unused harmony export SafeSubscriber */
        /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3), _util_isFunction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(51), _Observer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(69), _Subscription__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(14), _internal_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(61), _config__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(35), _util_hostReportError__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(54), Subscriber = /* */ function(_super) {
            function Subscriber(destinationOrNext, error, complete) {
                var _this = _super.call(this) || this;
                switch (_this.syncErrorValue = null, _this.syncErrorThrown = !1, _this.syncErrorThrowable = !1, 
                _this.isStopped = !1, arguments.length) {
                  case 0:
                    _this.destination = _Observer__WEBPACK_IMPORTED_MODULE_2__.a;
                    break;

                  case 1:
                    if (!destinationOrNext) {
                        _this.destination = _Observer__WEBPACK_IMPORTED_MODULE_2__.a;
                        break;
                    }
                    if ("object" == typeof destinationOrNext) {
                        destinationOrNext instanceof Subscriber ? (_this.syncErrorThrowable = destinationOrNext.syncErrorThrowable, 
                        (_this.destination = destinationOrNext).add(_this)) : (_this.syncErrorThrowable = !0, 
                        _this.destination = new SafeSubscriber(_this, destinationOrNext));
                        break;
                    }

                  default:
                    _this.syncErrorThrowable = !0, _this.destination = new SafeSubscriber(_this, destinationOrNext, error, complete);
                }
                return _this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(Subscriber, _super), Subscriber.prototype[_internal_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_4__.a] = function() {
                return this;
            }, Subscriber.create = function(next, error, complete) {
                var subscriber = new Subscriber(next, error, complete);
                return subscriber.syncErrorThrowable = !1, subscriber;
            }, Subscriber.prototype.next = function(value) {
                this.isStopped || this._next(value);
            }, Subscriber.prototype.error = function(err) {
                this.isStopped || (this.isStopped = !0, this._error(err));
            }, Subscriber.prototype.complete = function() {
                this.isStopped || (this.isStopped = !0, this._complete());
            }, Subscriber.prototype.unsubscribe = function() {
                this.closed || (this.isStopped = !0, _super.prototype.unsubscribe.call(this));
            }, Subscriber.prototype._next = function(value) {
                this.destination.next(value);
            }, Subscriber.prototype._error = function(err) {
                this.destination.error(err), this.unsubscribe();
            }, Subscriber.prototype._complete = function() {
                this.destination.complete(), this.unsubscribe();
            }, Subscriber.prototype._unsubscribeAndRecycle = function() {
                var _parent = this._parent, _parents = this._parents;
                return this._parent = null, this._parents = null, this.unsubscribe(), this.closed = !1, 
                this.isStopped = !1, this._parent = _parent, this._parents = _parents, this;
            }, Subscriber;
        }(_Subscription__WEBPACK_IMPORTED_MODULE_3__.a), SafeSubscriber = /* */ function(_super) {
            function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {
                var next, _this = _super.call(this) || this;
                _this._parentSubscriber = _parentSubscriber;
                var context = _this;
                return Object(_util_isFunction__WEBPACK_IMPORTED_MODULE_1__.a)(observerOrNext) ? next = observerOrNext : observerOrNext && (next = observerOrNext.next, 
                error = observerOrNext.error, complete = observerOrNext.complete, observerOrNext !== _Observer__WEBPACK_IMPORTED_MODULE_2__.a && (context = Object.create(observerOrNext), 
                Object(_util_isFunction__WEBPACK_IMPORTED_MODULE_1__.a)(context.unsubscribe) && _this.add(context.unsubscribe.bind(context)), 
                context.unsubscribe = _this.unsubscribe.bind(_this))), _this._context = context, 
                _this._next = next, _this._error = error, _this._complete = complete, _this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(SafeSubscriber, _super), SafeSubscriber.prototype.next = function(value) {
                if (!this.isStopped && this._next) {
                    var _parentSubscriber = this._parentSubscriber;
                    _config__WEBPACK_IMPORTED_MODULE_5__.a.useDeprecatedSynchronousErrorHandling && _parentSubscriber.syncErrorThrowable ? this.__tryOrSetError(_parentSubscriber, this._next, value) && this.unsubscribe() : this.__tryOrUnsub(this._next, value);
                }
            }, SafeSubscriber.prototype.error = function(err) {
                if (!this.isStopped) {
                    var _parentSubscriber = this._parentSubscriber, useDeprecatedSynchronousErrorHandling = _config__WEBPACK_IMPORTED_MODULE_5__.a.useDeprecatedSynchronousErrorHandling;
                    if (this._error) useDeprecatedSynchronousErrorHandling && _parentSubscriber.syncErrorThrowable ? this.__tryOrSetError(_parentSubscriber, this._error, err) : this.__tryOrUnsub(this._error, err), 
                    this.unsubscribe(); else if (_parentSubscriber.syncErrorThrowable) useDeprecatedSynchronousErrorHandling ? (_parentSubscriber.syncErrorValue = err, 
                    _parentSubscriber.syncErrorThrown = !0) : Object(_util_hostReportError__WEBPACK_IMPORTED_MODULE_6__.a)(err), 
                    this.unsubscribe(); else {
                        if (this.unsubscribe(), useDeprecatedSynchronousErrorHandling) throw err;
                        Object(_util_hostReportError__WEBPACK_IMPORTED_MODULE_6__.a)(err);
                    }
                }
            }, SafeSubscriber.prototype.complete = function() {
                var _this = this;
                if (!this.isStopped) {
                    var _parentSubscriber = this._parentSubscriber;
                    if (this._complete) {
                        var wrappedComplete = function() {
                            return _this._complete.call(_this._context);
                        };
                        _config__WEBPACK_IMPORTED_MODULE_5__.a.useDeprecatedSynchronousErrorHandling && _parentSubscriber.syncErrorThrowable ? this.__tryOrSetError(_parentSubscriber, wrappedComplete) : this.__tryOrUnsub(wrappedComplete), 
                        this.unsubscribe();
                    } else this.unsubscribe();
                }
            }, SafeSubscriber.prototype.__tryOrUnsub = function(fn, value) {
                try {
                    fn.call(this._context, value);
                } catch (err) {
                    if (this.unsubscribe(), _config__WEBPACK_IMPORTED_MODULE_5__.a.useDeprecatedSynchronousErrorHandling) throw err;
                    Object(_util_hostReportError__WEBPACK_IMPORTED_MODULE_6__.a)(err);
                }
            }, SafeSubscriber.prototype.__tryOrSetError = function(parent, fn, value) {
                if (!_config__WEBPACK_IMPORTED_MODULE_5__.a.useDeprecatedSynchronousErrorHandling) throw new Error("bad call");
                try {
                    fn.call(this._context, value);
                } catch (err) {
                    return _config__WEBPACK_IMPORTED_MODULE_5__.a.useDeprecatedSynchronousErrorHandling ? (parent.syncErrorValue = err, 
                    parent.syncErrorThrown = !0) : (Object(_util_hostReportError__WEBPACK_IMPORTED_MODULE_6__.a)(err), 
                    !0);
                }
                return !1;
            }, SafeSubscriber.prototype._unsubscribe = function() {
                var _parentSubscriber = this._parentSubscriber;
                this._context = null, this._parentSubscriber = null, _parentSubscriber.unsubscribe();
            }, SafeSubscriber;
        }(Subscriber);
        /* harmony import */    }, 
    /* 9 */
    /***/ function(module, exports, __webpack_require__) {
        "use strict";
        /*
object-assign
(c) Sindre Sorhus
@license MIT
*/
        /* eslint-disable no-unused-vars */        var getOwnPropertySymbols = Object.getOwnPropertySymbols, hasOwnProperty = Object.prototype.hasOwnProperty, propIsEnumerable = Object.prototype.propertyIsEnumerable;
        function toObject(val) {
            if (null == val) throw new TypeError("Object.assign cannot be called with null or undefined");
            return Object(val);
        }
        module.exports = function shouldUseNative() {
            try {
                if (!Object.assign) return !1;
                // Detect buggy property enumeration order in older V8 versions.
                // https://bugs.chromium.org/p/v8/issues/detail?id=4118
                                var test1 = new String("abc");
 // eslint-disable-line no-new-wrappers
                                if (test1[5] = "de", "5" === Object.getOwnPropertyNames(test1)[0]) return !1;
                // https://bugs.chromium.org/p/v8/issues/detail?id=3056
                                for (var test2 = {}, i = 0; i < 10; i++) test2["_" + String.fromCharCode(i)] = i;
                if ("0123456789" !== Object.getOwnPropertyNames(test2).map(function(n) {
                    return test2[n];
                }).join("")) return !1;
                // https://bugs.chromium.org/p/v8/issues/detail?id=3056
                                var test3 = {};
                return "abcdefghijklmnopqrst".split("").forEach(function(letter) {
                    test3[letter] = letter;
                }), "abcdefghijklmnopqrst" === Object.keys(Object.assign({}, test3)).join("");
            } catch (err) {
                // We don't expect any of the above to throw, but better to be safe.
                return !1;
            }
        }() ? Object.assign : function(target, source) {
            for (var from, symbols, to = toObject(target), s = 1; s < arguments.length; s++) {
                for (var key in from = Object(arguments[s])) hasOwnProperty.call(from, key) && (to[key] = from[key]);
                if (getOwnPropertySymbols) {
                    symbols = getOwnPropertySymbols(from);
                    for (var i = 0; i < symbols.length; i++) propIsEnumerable.call(from, symbols[i]) && (to[symbols[i]] = from[symbols[i]]);
                }
            }
            return to;
        };
    }, 
    /* 10 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * File allowing feature-switching.
 *
 * Every optional feature is included here.
 * They all should subsequently be accessed in the code through the exported
 * `features` object.
 *
 * The then exported features object will be used dynamically to know which
 * features are activated.
 *
 * This also lazy-feature loading, where this exported object can be updated
 * at runtime, to allow some new features even if the player instance has
 * already have been instanciated.
 */
        /**
 * Initial features object, with no feature activated by default.
 * @type {Object}
 */        
        /* harmony default export */ __webpack_exports__.a = {
            transports: {},
            imageBuffer: null,
            imageParser: null,
            nativeTextTracksBuffer: null,
            nativeTextTracksParsers: {},
            htmlTextTracksBuffer: null,
            htmlTextTracksParsers: {},
            emeManager: null,
            directfile: null
        };
    }, 
    /* 11 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Array.prototype.find ponyfill.
 * @param {Array} arr
 * @param {Function} predicate
 * @param {*} context
 * @returns {boolean}
 */
        function arrayFind(arr, predicate, thisArg) {
            if ("function" == typeof Array.prototype.find) 
            /* tslint:disable ban */
            return arr.find(predicate, thisArg);
            /* tslint:enable ban */            for (var len = arr.length >>> 0, i = 0; i < len; i++) {
                var val = arr[i];
                if (predicate.call(thisArg, val, i, arr)) return val;
            }
        }
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return arrayFind;
        });
    }, 
    /* 12 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Array.prototype.includes ponyfill.
 * Returns ``true`` if the given array ``arr`` contains the element
 * ``searchElement``. false ``otherwise``.
 *
 * Inspired from MDN polyfill, but ponyfilled instead
 *
 * @example
 * ```js
 * arrayIncludes([1, 2, 3], 3);
 * // => true
 *
 * arrayIncludes([1, 2, 3], 7);
 * // => false
 *
 * const obj = { a: 4 };
 * arrayIncludes([obj, { b: 7 }, { a: 3 }, obj);
 * // => true
 *
 * // does not perform deep equality
 * arrayIncludes([{ a: 4 }, { b: 7 }, { a: 3 }, { a: 4 });
 * // => false
 *
 * // the third argument state the starting index. 0 if not set.
 *
 * arrayIncludes([1, 2, 3], 2, 1);
 * // => true
 *
 * arrayIncludes([1, 2, 3], 2, 2);
 * // => false
 * ```
 *
 * @param {Array} arr
 * @param {*} searchElement
 * @param {number} [fromIndex]
 * @returns {boolean}
 */
        function arrayIncludes(arr, searchElement, fromIndex) {
            /* tslint:disable no-unbound-method */
            if ("function" == typeof Array.prototype.includes) 
            /* tslint:enable no-unbound-method */
            /* tslint:disable ban */
            return arr.includes(searchElement, fromIndex);
            /* tslint:enable ban */            var len = arr.length >>> 0;
            if (0 === len) return !1;
            for (var n = 0 | fromIndex, k = 0 <= n ? Math.min(n, len - 1) : Math.max(len + n, 0), areTheSame = function areTheSame(x, y) {
                return x === y || // Viva las JavaScriptas!
                "number" == typeof x && "number" == typeof y && isNaN(x) && isNaN(y);
            }; k < len; ) {
                if (areTheSame(arr[k], searchElement)) return !0;
                k++;
            }
            return !1;
        }
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return arrayIncludes;
        });
    }, 
    /* 13 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return convertToRanges;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() {
            return getInnerAndOuterTimeRanges;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() {
            return getLeftSizeOfRange;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() {
            return getNextRangeGap;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() {
            return getPlayedSizeOfRange;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() {
            return getRange;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() {
            return getSizeOfRange;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() {
            return insertInto;
        }), 
        /* unused harmony export isAfter */
        /* unused harmony export isBefore */
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() {
            return isTimeInRange;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() {
            return keepRangeIntersection;
        });
        /* unused harmony export mergeContiguousRanges */
        /* unused harmony export removeEmptyRanges */
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * This file contains functions helping with TimeRanges management.
 *
 * For simplicity/performance reasons, many of those work with a simplified
 * "Range" object, which is an object with two keys:
 *   - start {Number}
 *   - end {Number}
 *
 * Those two corresponds to what is returned by the start and end methods of a
 * TimeRanges Object.
 *
 * You can convert from TimeRanges to Range object(s) with the getRange/
 * convertToRanges methods.
 */
        // Factor for rounding errors
        var EPSILON = 1 / 60;
        /**
 * Check equality with a tolerance of EPSILON.
 * Used for various functions with this sort of tolerance regarding the
 * start/end of contiguous ranges.
 * @param {Number} a
 * @param {Number} b
 * @returns {Boolean}
 */        function nearlyEqual(a, b) {
            return Math.abs(a - b) < EPSILON;
        }
        /**
 * Construct a new range which will have, as start/end, the min/max
 * of both the range given, and the given bitrate.
 * @param {Object} range1
 * @param {Object} range2
 * @returns {Object}
 */        function createRangeUnion(range1, range2) {
            return {
                start: Math.min(range1.start, range2.start),
                end: Math.max(range1.end, range2.end)
            };
        }
        /**
 * Clean array ranges from "empty" ranges.
 * That is, range objects which have their start equal to their end.
 * /!\ Mutate the array of ranges.
 * @param {Array<Object>} ranges
 * @returns {Array<Object>}
 */        function removeEmptyRanges(ranges) {
            for (var index = 0; index < ranges.length; index++) {
                var range = ranges[index];
                range.start === range.end && ranges.splice(index++, 1);
            }
            return ranges;
        }
        /**
 * /!\ Mutate the array of ranges.
 * @param {Array<Object>} ranges
 * @returns {Array<Object>}
 */        function mergeContiguousRanges(ranges) {
            for (var index = 1; index < ranges.length; index++) {
                var prevRange = ranges[index - 1], currRange = ranges[index];
                if (areRangesNearlyContiguous(prevRange, currRange)) {
                    var unionRange = createRangeUnion(prevRange, currRange);
                    ranges.splice(--index, 2, unionRange);
                }
            }
            return ranges;
        }
        /**
 * True if range1 is considered _after_ range2.
 * @param {Object} range1
 * @param {Object} range2
 * @returns {Boolean}
 */        
        /**
 * True if range1 is considered _before_ range2.
 * @param {Object} range1
 * @param {Object} range2
 * @returns {Boolean}
 */
        function isBefore(range1, range2) {
            return range1.end <= range2.start;
        }
        /**
 * Returns true if the time given can be considered as part of the given range.
 * @param {Object} range1
 * @param {Number} Time
 * @returns {Boolean}
 */        function isTimeInRange(_ref, time) {
            var start = _ref.start, end = _ref.end;
            return start <= time && time < end;
        }
        /**
 * Returns true if the two ranges given are overlapping.
 * @param {Object} range1
 * @param {Object} range2
 * @returns {Boolean}
 */        function areRangesOverlapping(range1, range2) {
            return isTimeInRange(range1, range2.start) || range1.start < range2.end && range2.end < range1.end || isTimeInRange(range2, range1.start);
        }
        /**
 * Returns true if the two ranges given can be considered contiguous.
 * @param {Object} range1
 * @param {Object} range2
 * @returns {Boolean}
 */        function areRangesNearlyContiguous(range1, range2) {
            return nearlyEqual(range2.start, range1.end) || nearlyEqual(range2.end, range1.start);
        }
        /**
 * Convert from a TimeRanges object to an array of Ranges.
 * @param {TimeRanges} timeRanges
 * @returns {Array.<Object>}
 */        function convertToRanges(timeRanges) {
            for (var ranges = [], i = 0; i < timeRanges.length; i++) ranges.push({
                start: timeRanges.start(i),
                end: timeRanges.end(i)
            });
            return ranges;
        }
        /**
 * Get range object of a specific time in a TimeRanges object.
 * @param {TimeRanges} timeRanges
 * @returns {Object}
 */        function getRange(timeRanges, time) {
            for (var i = timeRanges.length - 1; 0 <= i; i--) {
                var start = timeRanges.start(i);
                if (start <= time) {
                    var end = timeRanges.end(i);
                    if (time < end) return {
                        start: start,
                        end: end
                    };
                }
            }
            return null;
        }
        /**
 * Get gap from a specific time until the start of the next Range.
 * @param {TimeRanges} timeRanges
 * @param {Number} time
 * @returns {Number}
 */        function getNextRangeGap(timeRanges, time) {
            for (var len = timeRanges.length, i = 0; i < len; i++) {
                var start = timeRanges.start(i);
                if (time < start) return start - time;
            }
            return Infinity;
        }
        /**
 * @param {TimeRanges} timeRanges
 * @param {Number} time
 * @returns {Object} - Object with two properties:
 *   - outerRanges {Array.<Object>}: every ranges which does not contain the
 *     given time.
 *   - innerRange {Object|null}: the range which contain the given time.
 */        function getInnerAndOuterTimeRanges(timeRanges, time) {
            for (var innerRange = null, outerRanges = [], i = 0; i < timeRanges.length; i++) {
                var start = timeRanges.start(i), end = timeRanges.end(i);
                time < start || end <= time ? outerRanges.push({
                    start: start,
                    end: end
                }) : innerRange = {
                    start: start,
                    end: end
                };
            }
            return {
                outerRanges: outerRanges,
                innerRange: innerRange
            };
        }
        /**
 * Get "size" (difference between end and start) of the range containing the
 * given time. 0 if the range is not found.
 * @param {TimeRanges} timeRanges
 * @param {Number} currentTime
 * @returns {Number}
 */        function getSizeOfRange(timeRanges, currentTime) {
            var range = getRange(timeRanges, currentTime);
            return range ? range.end - range.start : 0;
        }
        /**
 * Get "currently played" (difference between time given and start) of the
 * range containing the given time. 0 if the range is not found.
 * @param {TimeRanges} timeRanges
 * @param {Number} currentTime
 * @returns {Number}
 */        function getPlayedSizeOfRange(timeRanges, currentTime) {
            var range = getRange(timeRanges, currentTime);
            return range ? currentTime - range.start : 0;
        }
        /**
 * Get "left to play" (difference between end and time given) of the range
 * containing the given time. Infinity if the range is not found.
 * @param {TimeRanges} timeRanges
 * @param {Number} currentTime
 * @returns {Number}
 */        function getLeftSizeOfRange(timeRanges, currentTime) {
            var range = getRange(timeRanges, currentTime);
            return range ? range.end - currentTime : Infinity;
        }
        /**
 * Insert a range object into an array of ranges objects, at the right place.
 * /!\ Mutate the array of ranges.
 * @param {Array.<Object>} ranges
 * @param {Object} rangeToAddArg
 * @returns {Array.<Object>}
 */        function insertInto(ranges, rangeToAddArg) {
            if (rangeToAddArg.start === rangeToAddArg.end) return ranges;
            for (var rangeToAdd = rangeToAddArg, index = 0 // For each present range check if we need to:
            // - In case we are overlapping or contiguous:
            //   - if added range has the same bitrate as the overlapped or
            //     contiguous one, we can merge themcurrentRange
            //   - if added range has a different bitrate we need to insert it
            //     in place
            // - Need to insert in place, we we are completely, not overlapping
            //   and not contiguous in between two ranges.
            ; index < ranges.length; index++) {
                var range = ranges[index], overlapping = areRangesOverlapping(rangeToAdd, range), contiguous = areRangesNearlyContiguous(rangeToAdd, range);
                // We assume ranges are ordered and two ranges can not be
                // completely overlapping.
                if (overlapping || contiguous) rangeToAdd = createRangeUnion(rangeToAdd, range), 
                ranges.splice(index--, 1); else 
                // Check the case for which there is no more to do
                if (0 === index) {
                    if (isBefore(rangeToAdd, ranges[0])) 
                    // First index, and we are completely before that range (and
                    // not contiguous, nor overlapping). We just need to be
                    // inserted here.
                    break;
                } else if (isBefore(ranges[index - 1], rangeToAdd) && isBefore(rangeToAdd, range)) 
                // We are exactly after the current previous range, and
                // before the current range, while not overlapping with none
                // of them. Insert here.
                break;
            }
 // Now that we are sure we don't overlap with any range, just add it.
                        return ranges.splice(index, 0, rangeToAdd), mergeContiguousRanges(removeEmptyRanges(ranges));
        }
        /**
 * Returns range, from a range objects array overlapping with a range given
 * in argument. null if none is found.
 * @param {Object} range
 * @param {Array.<Object>} ranges
 * @returns {Array.<Object>}
 */        function findOverlappingRanges(range, ranges) {
            for (var resultingRanges = [], i = 0; i < ranges.length; i++) areRangesOverlapping(range, ranges[i]) && resultingRanges.push(ranges[i]);
            return resultingRanges;
        }
        /**
 * Returns only the intersection between the two ranges, from the first
 * ranges argument given.
 * @param {Array.<Range>} ranges1
 * @param {Array.<Range>} ranges2
 * @returns {Array.<Range>}
 */        function keepRangeIntersection(ranges1, ranges2) {
            for (var result = [], i = 0; i < ranges1.length; i++) {
                var range = ranges1[i], overlappingRanges = findOverlappingRanges(range, ranges2);
                if (overlappingRanges.length) for (var j = 0; j < overlappingRanges.length; j++) {
                    var overlappingRange = overlappingRanges[j];
                    result.push({
                        start: Math.max(range.start, overlappingRange.start),
                        end: Math.min(range.end, overlappingRange.end)
                    });
                }
            }
            return result;
        }
        /***/    }, 
    /* 14 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/isArray.js
                var isArray = __webpack_require__(45), isObject = __webpack_require__(79), isFunction = __webpack_require__(51);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/isObject.js
                // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/util/UnsubscriptionError.js
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        function UnsubscriptionErrorImpl(errors) {
            return Error.call(this), this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i) {
                return i + 1 + ") " + err.toString();
            }).join("\n  ") : "", this.name = "UnsubscriptionError", this.errors = errors, this;
        }
        UnsubscriptionErrorImpl.prototype = /* */ Object.create(Error.prototype);
        var UnsubscriptionError = UnsubscriptionErrorImpl;
        //# sourceMappingURL=UnsubscriptionError.js.map
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/Subscription.js
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return Subscription_Subscription;
        });
        /** PURE_IMPORTS_START _util_isArray,_util_isObject,_util_isFunction,_util_UnsubscriptionError PURE_IMPORTS_END */
        var Subscription_Subscription = /* */ function() {
            function Subscription(unsubscribe) {
                this.closed = !1, this._parent = null, this._parents = null, this._subscriptions = null, 
                unsubscribe && (this._unsubscribe = unsubscribe);
            }
            return Subscription.prototype.unsubscribe = function() {
                var errors, hasErrors = !1;
                if (!this.closed) {
                    var _parent = this._parent, _parents = this._parents, _unsubscribe = this._unsubscribe, _subscriptions = this._subscriptions;
                    this.closed = !0, this._parent = null, this._parents = null, this._subscriptions = null;
                    for (var index = -1, len = _parents ? _parents.length : 0; _parent; ) _parent.remove(this), 
                    _parent = ++index < len && _parents[index] || null;
                    if (Object(isFunction.a)(_unsubscribe)) try {
                        _unsubscribe.call(this);
                    } catch (e) {
                        hasErrors = !0, errors = e instanceof UnsubscriptionError ? flattenUnsubscriptionErrors(e.errors) : [ e ];
                    }
                    if (Object(isArray.a)(_subscriptions)) for (index = -1, len = _subscriptions.length; ++index < len; ) {
                        var sub = _subscriptions[index];
                        if (Object(isObject.a)(sub)) try {
                            sub.unsubscribe();
                        } catch (e) {
                            hasErrors = !0, errors = errors || [], e instanceof UnsubscriptionError ? errors = errors.concat(flattenUnsubscriptionErrors(e.errors)) : errors.push(e);
                        }
                    }
                    if (hasErrors) throw new UnsubscriptionError(errors);
                }
            }, Subscription.prototype.add = function(teardown) {
                var subscription = teardown;
                switch (typeof teardown) {
                  case "function":
                    subscription = new Subscription(teardown);

                  case "object":
                    if (subscription === this || subscription.closed || "function" != typeof subscription.unsubscribe) return subscription;
                    if (this.closed) return subscription.unsubscribe(), subscription;
                    if (!(subscription instanceof Subscription)) {
                        var tmp = subscription;
                        (subscription = new Subscription())._subscriptions = [ tmp ];
                    }
                    break;

                  default:
                    if (!teardown) return Subscription.EMPTY;
                    throw new Error("unrecognized teardown " + teardown + " added to Subscription.");
                }
                if (subscription._addParent(this)) {
                    var subscriptions = this._subscriptions;
                    subscriptions ? subscriptions.push(subscription) : this._subscriptions = [ subscription ];
                }
                return subscription;
            }, Subscription.prototype.remove = function(subscription) {
                var subscriptions = this._subscriptions;
                if (subscriptions) {
                    var subscriptionIndex = subscriptions.indexOf(subscription);
                    -1 !== subscriptionIndex && subscriptions.splice(subscriptionIndex, 1);
                }
            }, Subscription.prototype._addParent = function(parent) {
                var _parent = this._parent, _parents = this._parents;
                return _parent !== parent && (_parent ? _parents ? -1 === _parents.indexOf(parent) && (_parents.push(parent), 
                !0) : (this._parents = [ parent ], !0) : (this._parent = parent, !0));
            }, Subscription.EMPTY = function(empty) {
                return empty.closed = !0, empty;
            }(new Subscription()), Subscription;
        }();
        function flattenUnsubscriptionErrors(errors) {
            return errors.reduce(function(errs, err) {
                return errs.concat(err instanceof UnsubscriptionError ? err.errors : err);
            }, []);
        }
        //# sourceMappingURL=Subscription.js.map
        /***/    }, 
    /* 15 */ 
    /* 16 */
    /***/ , 
    /* 16 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // CONCATENATED MODULE: ./src/errors/assertion_error.ts
                function _assertThisInitialized(self) {
            if (void 0 === self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return self;
        }
        function _inheritsLoose(subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype), (subClass.prototype.constructor = subClass).__proto__ = superClass;
        }
        function _wrapNativeSuper(Class) {
            var _cache = "function" == typeof Map ? new Map() : void 0;
            return (_wrapNativeSuper = function _wrapNativeSuper(Class) {
                if (null === Class || !_isNativeFunction(Class)) return Class;
                if ("function" != typeof Class) throw new TypeError("Super expression must either be null or a function");
                if (void 0 !== _cache) {
                    if (_cache.has(Class)) return _cache.get(Class);
                    _cache.set(Class, Wrapper);
                }
                function Wrapper() {
                    return _construct(Class, arguments, _getPrototypeOf(this).constructor);
                }
                return Wrapper.prototype = Object.create(Class.prototype, {
                    constructor: {
                        value: Wrapper,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }), _setPrototypeOf(Wrapper, Class);
            })(Class);
        }
        function isNativeReflectConstruct() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function() {})), 
                !0;
            } catch (e) {
                return !1;
            }
        }
        function _construct(Parent, args, Class) {
            return (_construct = isNativeReflectConstruct() ? Reflect.construct : function _construct(Parent, args, Class) {
                var a = [ null ];
                a.push.apply(a, args);
                var instance = new (Function.bind.apply(Parent, a))();
                return Class && _setPrototypeOf(instance, Class.prototype), instance;
            }).apply(null, arguments);
        }
        function _isNativeFunction(fn) {
            return -1 !== Function.toString.call(fn).indexOf("[native code]");
        }
        function _setPrototypeOf(o, p) {
            return (_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
                return o.__proto__ = p, o;
            })(o, p);
        }
        function _getPrototypeOf(o) {
            return (_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
                return o.__proto__ || Object.getPrototypeOf(o);
            })(o);
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Error due to an abnormal assertion fails.
 *
 * @class AssertionError
 * @extends Error
 */        var AssertionError = 
        /* */
        function(_Error) {
            /**
   * @param {string} message
   */
            function AssertionError(message) {
                var _this;
                return _this = _Error.call(this) || this, // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class
                Object.setPrototypeOf(_assertThisInitialized(_this), AssertionError.prototype), 
                _this.name = "AssertionError", _this.message = message, _this;
            }
            return _inheritsLoose(AssertionError, _Error), AssertionError;
        }(_wrapNativeSuper(Error));
        // CONCATENATED MODULE: ./src/utils/assert.ts
        /* harmony export (binding) */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Throw an AssertionError if the given assertion is false.
 * @param {boolean} assertion
 * @param {string} [message] - Optional message property for the AssertionError.
 * @throws AssertionError - Throws if the assertion given is false
 */
        function assert(assertion, message) {
            if (!assertion) throw new AssertionError(message || "invalid assertion");
        }
        /**
 * Throws if the given Object does not respect the interface.
 * @param {Object} o
 * @param {Object} iface - Contains the checked keynames of o and link them
 * to their types (obtained through the typeof operator).
 * @param {string} [name="object"] - name of the _interface_
 * @throws AssertionError - The argument o given is not an object
 * @throws AssertionError - The _interface_ is not respected.
 */        function assertInterface(o, iface, name) {
            for (var k in void 0 === name && (name = "object"), assert(null != o, name + " should be an object"), 
            iface) iface.hasOwnProperty(k) && 
            /* tslint:disable:max-line-length */
            assert(typeof o[k] === iface[k], name + " should have property " + k + " as a " + iface[k]);
        }
        /***/        __webpack_require__.d(__webpack_exports__, "b", function() {
            return assert;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return assertInterface;
        });
    }, 
    /* 17 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony import */        var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6), rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(53), rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(30);
        /* harmony import */        
        /* harmony default export */ __webpack_exports__.a = 
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        function castToObservable(value) {
            if (value instanceof rxjs__WEBPACK_IMPORTED_MODULE_0__.a) return value;
            if (value && "function" == typeof value.subscribe) {
                var valObsLike = value;
                return new rxjs__WEBPACK_IMPORTED_MODULE_0__.a(function(obs) {
                    var sub = valObsLike.subscribe(function(val) {
                        obs.next(val);
                    }, function(err) {
                        obs.error(err);
                    }, function() {
                        obs.complete();
                    });
                    return function() {
                        sub && sub.dispose ? sub.dispose() : sub && sub.unsubscribe && sub.unsubscribe();
                    };
                });
            }
            return value && "function" == typeof value.then ? Object(rxjs__WEBPACK_IMPORTED_MODULE_1__.a)(value) : Object(rxjs__WEBPACK_IMPORTED_MODULE_2__.a)(value);
        };
    }, 
    /* 18 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "c", function() {
            return REGXP_PERCENT_VALUES;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() {
            return REGXP_TIME_COLON;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() {
            return REGXP_TIME_COLON_FRAMES;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() {
            return REGXP_TIME_COLON_MS;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() {
            return REGXP_TIME_FRAMES;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() {
            return REGXP_TIME_HMS;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() {
            return REGXP_TIME_TICK;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return REGXP_4_HEX_COLOR;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() {
            return REGXP_8_HEX_COLOR;
        });
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        // examples: 00:00:40:07 (7 frames) or 00:00:40:07.1 (7 frames, 1 subframe)
        var REGXP_TIME_COLON_FRAMES = /^(\d{2,}):(\d{2}):(\d{2}):(\d{2})\.?(\d+)?$/, REGXP_TIME_COLON = /^(?:(\d{2,}):)?(\d{2}):(\d{2})$/, REGXP_TIME_COLON_MS = /^(?:(\d{2,}):)?(\d{2}):(\d{2}\.\d{2,})$/, REGXP_TIME_FRAMES = /^(\d*\.?\d*)f$/, REGXP_TIME_TICK = /^(\d*\.?\d*)t$/, REGXP_TIME_HMS = /^(?:(\d*\.?\d*)h)?(?:(\d*\.?\d*)m)?(?:(\d*\.?\d*)s)?(?:(\d*\.?\d*)ms)?$/, REGXP_PERCENT_VALUES = /^(\d{1,2}|100)% (\d{1,2}|100)%$/, REGXP_8_HEX_COLOR = /^#([0-9A-f]{2})([0-9A-f]{2})([0-9A-f]{2})([0-9A-f]{2})$/, REGXP_4_HEX_COLOR = /^#([0-9A-f])([0-9A-f])([0-9A-f])([0-9A-f])$/;
 // examples: 00:00:40:07 (7 frames) or 00:00:40:07.1 (7 frames, 1 subframe)
        }, 
    /* 19 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return HTMLElement_;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() {
            return MediaKeys_;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() {
            return MediaSource_;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() {
            return READY_STATES;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() {
            return VTTCue_;
        });
        /* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(58), win = window, HTMLElement_ = win.HTMLElement, VTTCue_ = win.VTTCue || win.TextTrackCue, MediaSource_ = win.MediaSource || win.MozMediaSource || win.WebKitMediaSource || win.MSMediaSource, MediaKeys_ = win.MediaKeys || win.MozMediaKeys || win.WebKitMediaKeys || win.MSMediaKeys || 
        /* */
        function() {
            return function _class() {
                var noMediaKeys = function noMediaKeys() {
                    throw new _errors__WEBPACK_IMPORTED_MODULE_0__.a("MEDIA_KEYS_NOT_SUPPORTED", "No `MediaKeys` implementation found in the current browser.", !0);
                };
                this.create = noMediaKeys, this.createSession = noMediaKeys, this.isTypeSupported = noMediaKeys, 
                this.setServerCertificate = noMediaKeys;
            };
        }(), READY_STATES = {
            HAVE_NOTHING: 0,
            HAVE_METADATA: 1,
            HAVE_CURRENT_DATA: 2,
            HAVE_FUTURE_DATA: 3,
            HAVE_ENOUGH_DATA: 4
        };
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */    }, 
    /* 20 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "b", function() {
            return isIE11;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() {
            return isIEOrEdge;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return isFirefox;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() {
            return isSamsungBrowser;
        });
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        // true on IE11
        // false on Edge and other IEs/browsers.
        var isIE11 = !!window.MSInputMethodContext && !!document.documentMode, isIEOrEdge = "Microsoft Internet Explorer" === navigator.appName || "Netscape" === navigator.appName && /(Trident|Edge)\//.test(navigator.userAgent), isFirefox = -1 !== navigator.userAgent.toLowerCase().indexOf("firefox"), isSamsungBrowser = /SamsungBrowser/.test(navigator.userAgent);
 // true for IE / Edge
        }, 
    /* 21 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "b", function() {
            return ErrorTypes;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() {
            return RequestErrorTypes;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return ErrorCodes;
        });
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        var ErrorTypes = {
            NETWORK_ERROR: "NETWORK_ERROR",
            MEDIA_ERROR: "MEDIA_ERROR",
            ENCRYPTED_MEDIA_ERROR: "ENCRYPTED_MEDIA_ERROR",
            OTHER_ERROR: "OTHER_ERROR"
        }, RequestErrorTypes = {
            TIMEOUT: "TIMEOUT",
            ERROR_EVENT: "ERROR_EVENT",
            ERROR_HTTP_CODE: "ERROR_HTTP_CODE",
            PARSE_ERROR: "PARSE_ERROR"
        }, ErrorCodes = {
            PIPELINE_RESOLVE_ERROR: "PIPELINE_RESOLVE_ERROR",
            PIPELINE_LOAD_ERROR: "PIPELINE_LOAD_ERROR",
            PIPELINE_PARSING_ERROR: "PIPELINE_PARSING_ERROR",
            MANIFEST_PARSE_ERROR: "MANIFEST_PARSE_ERROR",
            MANIFEST_INCOMPATIBLE_CODECS_ERROR: "MANIFEST_INCOMPATIBLE_CODECS_ERROR",
            MANIFEST_UNSUPPORTED_ADAPTATION_TYPE: "MANIFEST_UNSUPPORTED_ADAPTATION_TYPE",
            MEDIA_STARTING_TIME_NOT_FOUND: "MEDIA_STARTING_TIME_NOT_FOUND",
            MEDIA_TIME_BEFORE_MANIFEST: "MEDIA_TIME_BEFORE_MANIFEST",
            MEDIA_TIME_AFTER_MANIFEST: "MEDIA_TIME_AFTER_MANIFEST",
            MEDIA_TIME_NOT_FOUND: "MEDIA_TIME_NOT_FOUND",
            MEDIA_IS_ENCRYPTED_ERROR: "MEDIA_IS_ENCRYPTED_ERROR",
            KEY_ERROR: "KEY_ERROR",
            KEY_STATUS_CHANGE_ERROR: "KEY_STATUS_CHANGE_ERROR",
            KEY_UPDATE_ERROR: "KEY_UPDATE_ERROR",
            KEY_LOAD_ERROR: "KEY_LOAD_ERROR",
            KEY_LOAD_TIMEOUT: "KEY_LOAD_TIMEOUT",
            KEY_GENERATE_REQUEST_ERROR: "KEY_GENERATE_REQUEST_ERROR",
            INCOMPATIBLE_KEYSYSTEMS: "INCOMPATIBLE_KEYSYSTEMS",
            LICENSE_SERVER_CERTIFICATE_ERROR: "LICENSE_SERVER_CERTIFICATE_ERROR",
            BUFFER_APPEND_ERROR: "BUFFER_APPEND_ERROR",
            BUFFER_FULL_ERROR: "BUFFER_FULL_ERROR",
            BUFFER_TYPE_UNKNOWN: "BUFFER_TYPE_UNKNOWN",
            MEDIA_ERR_BLOCKED_AUTOPLAY: "MEDIA_ERR_BLOCKED_AUTOPLAY",
            MEDIA_ERR_PLAY_NOT_ALLOWED: "MEDIA_ERR_PLAY_NOT_ALLOWED",
            MEDIA_ERR_NOT_LOADED_METADATA: "MEDIA_ERR_NOT_LOADED_METADATA",
            MEDIA_ERR_ABORTED: "MEDIA_ERR_ABORTED",
            MEDIA_ERR_NETWORK: "MEDIA_ERR_NETWORK",
            MEDIA_ERR_DECODE: "MEDIA_ERR_DECODE",
            MEDIA_ERR_SRC_NOT_SUPPORTED: "MEDIA_ERR_SRC_NOT_SUPPORTED",
            MEDIA_ERR_UNKNOWN: "MEDIA_ERR_UNKNOWN",
            MEDIA_SOURCE_NOT_SUPPORTED: "MEDIA_SOURCE_NOT_SUPPORTED",
            MEDIA_KEYS_NOT_SUPPORTED: "MEDIA_KEYS_NOT_SUPPORTED"
        };
    }, 
    /* 22 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Construct a "loaded" event.
 * @returns {Object}
 */        var INIT_EVENTS = {
            loaded: function loaded() {
                return {
                    type: "loaded",
                    value: !0
                };
            }
            /**
 * Construct a "stalled" event.
 * @param {Object|null} stalling
 * @returns {Object}
 */ ,
            manifestReady: 
            /**
 * Construct a "manifestReady" event.
 * @param {Object} abrManager
 * @param {Object} manifest
 * @returns {Object}
 */
            function manifestReady(abrManager, manifest) {
                return {
                    type: "manifestReady",
                    value: {
                        abrManager: abrManager,
                        manifest: manifest
                    }
                };
            }
            /**
 * Construct a "speedChanged" event.
 * @param {Number} speed
 * @returns {Object}
 */ ,
            nullRepresentation: 
            /**
 * Construct a "representationChange" event.
 * @param {string} type
 * @param {Object} period
 * @returns {Object}
 */
            function nullRepresentation(type, period) {
                return {
                    type: "representationChange",
                    value: {
                        type: type,
                        representation: null,
                        period: period
                    }
                };
            }
            /**
 * Construct a "warning" event.
 * @param {Error} value
 * @returns {Object}
 */ ,
            reloadingMediaSource: function reloadingMediaSource() {
                return {
                    type: "reloading-media-source",
                    value: void 0
                };
            },
            speedChanged: function speedChanged(speed) {
                return {
                    type: "speedChanged",
                    value: speed
                };
            },
            stalled: function stalled(stalling) {
                return {
                    type: "stalled",
                    value: stalling
                };
            },
            warning: function warning(value) {
                return {
                    type: "warning",
                    value: value
                };
            }
        };
        /* harmony default export */        __webpack_exports__.a = INIT_EVENTS;
    }, 
    /* 23 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Observable.js + 3 modules
                var Observable = __webpack_require__(6), config = __webpack_require__(2), error_codes = __webpack_require__(21), request_error = __webpack_require__(182), DEFAULT_REQUEST_TIMEOUT = config.a.DEFAULT_REQUEST_TIMEOUT;
        // EXTERNAL MODULE: ./src/config.ts
                /**
 * @param {string} data
 * @returns {Object|null}
 */
        function toJSONForIE(data) {
            try {
                return JSON.parse(data);
            } catch (e) {
                return null;
            }
        }
        /* harmony default export */ var xhr_request = function request(options) {
            var requestOptions = {
                url: options.url,
                headers: options.headers,
                responseType: null == options.responseType ? "json" : options.responseType,
                timeout: null == options.timeout ? DEFAULT_REQUEST_TIMEOUT : options.timeout
            };
            return new Observable.a(function(obs) {
                var url = requestOptions.url, headers = requestOptions.headers, responseType = requestOptions.responseType, timeout = requestOptions.timeout, xhr = new XMLHttpRequest();
                if (xhr.open("GET", url, !0), 0 <= timeout && (xhr.timeout = timeout), xhr.responseType = responseType, 
                "document" === xhr.responseType && xhr.overrideMimeType("text/xml"), headers) {
                    var _headers = headers;
                    for (var key in _headers) _headers.hasOwnProperty(key) && xhr.setRequestHeader(key, _headers[key]);
                }
                var sendingTime = performance.now();
                return xhr.onerror = function onXHRError() {
                    var errorCode = error_codes.c.ERROR_EVENT;
                    obs.error(new request_error.a(xhr, url, errorCode));
                }, xhr.ontimeout = function onXHRTimeout() {
                    var errorCode = error_codes.c.TIMEOUT;
                    obs.error(new request_error.a(xhr, url, errorCode));
                }, options.ignoreProgressEvents || (xhr.onprogress = function onXHRProgress(event) {
                    var currentTime = performance.now();
                    obs.next({
                        type: "progress",
                        value: {
                            url: url,
                            duration: currentTime - sendingTime,
                            sendingTime: sendingTime,
                            currentTime: currentTime,
                            size: event.loaded,
                            totalSize: event.total
                        }
                    });
                }), xhr.onload = function onXHRLoad(event) {
                    if (4 === xhr.readyState) if (200 <= xhr.status && xhr.status < 300) {
                        var responseData, receivedTime = performance.now(), totalSize = xhr.response instanceof ArrayBuffer ? xhr.response.byteLength : event.total, status = xhr.status, loadedResponseType = xhr.responseType, _url = xhr.responseURL || url;
                        if (null == (
                        // IE bug where response is string with responseType json
                        responseData = "json" === loadedResponseType ? "string" !== xhr.response ? xhr.response : toJSONForIE(xhr.responseText) : xhr.response)) {
                            var errorCode = error_codes.c.PARSE_ERROR;
                            return void obs.error(new request_error.a(xhr, _url, errorCode));
                        }
                        obs.next({
                            type: "response",
                            value: {
                                status: status,
                                url: _url,
                                responseType: loadedResponseType,
                                sendingTime: sendingTime,
                                receivedTime: receivedTime,
                                duration: receivedTime - sendingTime,
                                size: totalSize,
                                responseData: responseData
                            }
                        }), obs.complete();
                    } else {
                        var _errorCode = error_codes.c.ERROR_HTTP_CODE;
                        obs.error(new request_error.a(xhr, url, _errorCode));
                    }
                }, xhr.send(), function() {
                    xhr && 4 !== xhr.readyState && xhr.abort();
                };
            });
        };
        // CONCATENATED MODULE: ./src/utils/request/index.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /* harmony default export */        __webpack_exports__.a = xhr_request;
    }, 
    /* 24 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return subscribeToResult;
        });
        /* harmony import */ var _InnerSubscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(47), _subscribeTo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(80);
        /* harmony import */        
        /** PURE_IMPORTS_START _InnerSubscriber,_subscribeTo PURE_IMPORTS_END */
        function subscribeToResult(outerSubscriber, result, outerValue, outerIndex, destination) {
            if (void 0 === destination && (destination = new _InnerSubscriber__WEBPACK_IMPORTED_MODULE_0__.a(outerSubscriber, outerValue, outerIndex)), 
            !destination.closed) return Object(_subscribeTo__WEBPACK_IMPORTED_MODULE_1__.a)(result)(destination);
        }
        //# sourceMappingURL=subscribeToResult.js.map
        /***/    }, 
    /* 25 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return OuterSubscriber;
        });
        /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3), OuterSubscriber = /* */ function(_super) {
            function OuterSubscriber() {
                return null !== _super && _super.apply(this, arguments) || this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(OuterSubscriber, _super), OuterSubscriber.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
                this.destination.next(innerValue);
            }, OuterSubscriber.prototype.notifyError = function(error, innerSub) {
                this.destination.error(error);
            }, OuterSubscriber.prototype.notifyComplete = function(innerSub) {
                this.destination.complete();
            }, OuterSubscriber;
        }(__webpack_require__(8).a);
        /* harmony import */    }, 
    /* 26 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return warnOnce;
        });
        /* harmony import */ var _array_includes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12), WARNED_MESSAGES = [];
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        
        /**
 * Perform a console.warn only once in the application lifetime.
 *
 * Useful for deprecated messages, for example.
 *
 * @param {string} message
 */
        function warnOnce(message) {
            Object(_array_includes__WEBPACK_IMPORTED_MODULE_0__.a)(WARNED_MESSAGES, message) || (
            /* tslint:disable no-console */
            console.warn(message), 
            /* tslint:enable no-console */
            WARNED_MESSAGES.push(message));
        }
        /***/    }, 
    /* 27 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Do nothing (but do it well).
 *
 * Having this definition here allow to use the same reference each time a noop
 * is needed.
 * Also, it allows to avoid telling tslint to ignore empty blocks everywhere.
 */
        /* tslint:disable:no-empty */
        /* harmony default export */        __webpack_exports__.a = function() {};
    }, 
    /* 28 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony import */        var pinkie__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(135), pinkie__WEBPACK_IMPORTED_MODULE_0___default = /* */ __webpack_require__.n(pinkie__WEBPACK_IMPORTED_MODULE_0__);
        /* harmony import */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /* harmony default export */ __webpack_exports__.a = "function" == typeof Promise ? Promise : pinkie__WEBPACK_IMPORTED_MODULE_0___default.a;
    }, 
    /* 29 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // EXTERNAL MODULE: ./src/utils/array_find.ts
                var array_find = __webpack_require__(11), array_includes = __webpack_require__(12);
        // EXTERNAL MODULE: ./src/utils/array_includes.ts
                // CONCATENATED MODULE: ./src/utils/starts_with.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * String.prototype.startsWith ponyfill.
 * Indicates Whether a string starts with another substring.
 *
 * Inspired from MDN polyfill, but ponyfilled instead.
 * @param {string} completeString
 * @param {string} searchString
 * @param {number} [position]
 * @returns {boolean}
 */
        function startsWith(completeString, searchString, position) {
            /* tslint:disable no-unbound-method */
            if ("function" == typeof String.prototype.startsWith) 
            /* tslint:enable no-unbound-method */
            /* tslint:disable ban */
            return completeString.startsWith(searchString, position);
            /* tslint:enable ban */            var initialPosition = "number" == typeof position ? Math.max(position, 0) : 0;
            return completeString.substring(initialPosition, initialPosition + searchString.length) === searchString;
        }
        // CONCATENATED MODULE: ./src/parsers/texttracks/ttml/get_styling.ts
        /* harmony export (binding) */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Retrieve the attributes given in arguments in the given nodes and their
 * associated style(s)/region.
 * The first notion of the attribute encountered will be taken (by looping
 * through the given nodes in order).
 *
 * TODO manage IDREFS (plural) for styles and regions, that is, multiple one
 * @param {Array.<string>} attributes
 * @param {Array.<Node>} nodes
 * @param {Array.<Object>} styles
 * @param {Array.<Object>} regions
 * @returns {Object}
 */
        function getStylingAttributes(attributes, nodes, styles, regions) {
            for (var currentStyle = {}, leftAttributes = attributes.slice(), i = 0; i <= nodes.length - 1; i++) {
                var node = nodes[i];
                if (node) {
                    var _ret = function() {
                        var styleID = void 0, regionID = void 0;
                        // 1. the style is directly set on a "tts:" attribute
                        if (node.nodeType === Node.ELEMENT_NODE) for (var element = node, j = 0; j <= element.attributes.length - 1; j++) {
                            var attribute = element.attributes[j], name = attribute.name;
                            if ("style" === name) styleID = attribute.value; else if ("region" === name) regionID = attribute.value; else {
                                var nameWithoutTTS = name.substring(4);
                                if (Object(array_includes.a)(leftAttributes, nameWithoutTTS) && (currentStyle[nameWithoutTTS] = attribute.value, 
                                leftAttributes.splice(j, 1), !leftAttributes.length)) return {
                                    v: currentStyle
                                };
                            }
                        }
 // 2. the style is referenced on a "style" attribute
                                                if (styleID) {
                            var style = Object(array_find.a)(styles, function(x) {
                                return x.id === styleID;
                            });
                            if (style) for (var _j = 0; _j <= leftAttributes.length - 1; _j++) {
                                var _attribute = leftAttributes[_j];
                                if (!currentStyle[_attribute] && style.style[_attribute]) {
                                    if (currentStyle[_attribute] = style.style[_attribute], leftAttributes.splice(_j, 1), 
                                    !leftAttributes.length) return {
                                        v: currentStyle
                                    };
                                    _j--;
                                }
                            }
                        }
 // 3. the node reference a region (which can have a value for the
                        //    corresponding style)
                                                if (regionID) {
                            var region = Object(array_find.a)(regions, function(x) {
                                return x.id === regionID;
                            });
                            if (region) for (var _j2 = 0; _j2 <= leftAttributes.length - 1; _j2++) {
                                var _attribute2 = leftAttributes[_j2];
                                if (!currentStyle[_attribute2] && region.style[_attribute2]) {
                                    if (currentStyle[_attribute2] = region.style[_attribute2], leftAttributes.splice(_j2, 1), 
                                    !leftAttributes.length) return {
                                        v: currentStyle
                                    };
                                    _j2--;
                                }
                            }
                        }
                    }();
                    if ("object" == typeof _ret) return _ret.v;
                }
            }
            return currentStyle;
        }
        /**
 * Returns the styling directly linked to an element.
 * @param {Node} node
 * @returns {Object}
 */        function getStylingFromElement(node) {
            if (node.nodeType !== Node.ELEMENT_NODE) return {};
            for (var element = node, currentStyle = {}, i = 0; i <= element.attributes.length - 1; i++) {
                var styleAttribute = element.attributes[i];
                if (startsWith(styleAttribute.name, "tts")) currentStyle[styleAttribute.name.substring(4)] = styleAttribute.value;
            }
            return currentStyle;
        }
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return getStylingAttributes;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() {
            return getStylingFromElement;
        });
    }, 
    /* 30 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return of;
        });
        /* harmony import */ var _util_isScheduler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40), _fromArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(36), _empty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(38), _scalar__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(87);
        /* harmony import */        
        /** PURE_IMPORTS_START _util_isScheduler,_fromArray,_empty,_scalar PURE_IMPORTS_END */
        function of() {
            for (var args = [], _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
            var scheduler = args[args.length - 1];
            switch (Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_0__.a)(scheduler) ? args.pop() : scheduler = void 0, 
            args.length) {
              case 0:
                return Object(_empty__WEBPACK_IMPORTED_MODULE_2__.b)(scheduler);

              case 1:
                return scheduler ? Object(_fromArray__WEBPACK_IMPORTED_MODULE_1__.a)(args, scheduler) : Object(_scalar__WEBPACK_IMPORTED_MODULE_3__.a)(args[0]);

              default:
                return Object(_fromArray__WEBPACK_IMPORTED_MODULE_1__.a)(args, scheduler);
            }
        }
        //# sourceMappingURL=of.js.map
        /***/    }, 
    /* 31 */ 
    /* 32 */
    /***/ , 
    /* 32 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return resolveURL;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() {
            return normalizeBaseURL;
        });
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        // Scheme part of an url (e.g. "http://").
        var schemeRe = /^(?:[a-z]+:)?\/\//i, selfDirRe = /\/\.{1,2}\//;
 // Captures "/../" or "/./".
                /**
 * Resolve self directory and previous directory references to obtain a
 * "normalized" url.
 * @example "https://foo.bar/baz/booz/../biz" => "https://foo.bar/baz/biz"
 * @param {string} url
 * @returns {string}
 */
        function _normalizeUrl(url) {
            // fast path if no ./ or ../ are present in the url
            if (!selfDirRe.test(url)) return url;
            for (var newUrl = [], oldUrl = url.split("/"), i = 0, l = oldUrl.length; i < l; i++) if (".." === oldUrl[i]) newUrl.pop(); else {
                if ("." === oldUrl[i]) continue;
                newUrl.push(oldUrl[i]);
            }
            return newUrl.join("/");
        }
        /**
 * Construct an url from the arguments given.
 * Basically:
 *   - The last arguments that contains a scheme (e.g. "http://") is the base
 *     of the url.
 *   - every subsequent string arguments are concatened to it.
 * @param {...string|undefined} args
 * @returns {string}
 */        function resolveURL() {
            var len = arguments.length;
            if (0 === len) return "";
            for (var base = "", i = 0; i < len; i++) {
                var part = i < 0 || arguments.length <= i ? void 0 : arguments[i];
                "string" == typeof part && "" !== part && (base = schemeRe.test(part) ? part : (
                // trim if begins with "/"
                "/" === part[0] && (part = part.substring(1)), // trim if ends with "/"
                "/" === base[base.length - 1] && (base = base.substring(0, base.length - 1)), base + "/" + part));
            }
            return _normalizeUrl(base);
        }
        /**
 * Remove string after the last '/'.
 * @param {string} url
 * @returns {string}
 */        function normalizeBaseURL(url) {
            var slash = url.lastIndexOf("/");
            return 0 <= slash ? url.substring(0, slash + 1) : url;
        }
        /***/    }, 
    /* 33 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return EventEmitter;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() {
            return fromEvent;
        });
        /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6), _log__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(0), EventEmitter = 
        /* */
        function() {
            function EventEmitter() {
                this._listeners = {};
            }
            /**
   * Register a new callback for an event.
   *
   * @param {string} evt - The event to register a callback to
   * @param {Function} fn - The callback to call as that event is triggered.
   * The callback will take as argument the eventual payload of the event
   * (single argument).
   */            var _proto = EventEmitter.prototype;
            return _proto.addEventListener = function addEventListener(evt, fn) {
                var listeners = this._listeners[evt];
                listeners ? listeners.push(fn) : this._listeners[evt] = [ fn ];
            }
            /**
   * Unregister callbacks linked to events.
   * @param {string} [evt] - The event for which the callback[s] should be
   * unregistered. Set it to null or undefined to remove all callbacks
   * currently registered (for any event).
   * @param {Function} [fn] - The callback to unregister. If set to null
   * or undefined while the evt argument is set, all callbacks linked to that
   * event will be unregistered.
   */ , _proto.removeEventListener = function removeEventListener(evt, fn) {
                if (null != evt) {
                    var listeners = this._listeners[evt];
                    if (listeners) if (null != fn) {
                        var index = listeners.indexOf(fn);
                        ~index && listeners.splice(index, 1), listeners.length || delete this._listeners[evt];
                    } else delete this._listeners[evt];
                } else this._listeners = {};
            }
            /**
   * Trigger every registered callbacks for a given event
   * @param {string} evt - The event to trigger
   * @param {*} arg - The eventual payload for that event. All triggered
   * callbacks will recieve this payload as argument.
   */ , _proto.trigger = function trigger(evt, arg) {
                var listeners = this._listeners[evt];
                listeners && listeners.slice().forEach(function(listener) {
                    try {
                        listener(arg);
                    } catch (e) {
                        _log__WEBPACK_IMPORTED_MODULE_1__.a.error(e, e.stack);
                    }
                });
            }, EventEmitter;
        }();
        /* harmony import */        
        /**
 * Simple redefinition of the fromEvent from rxjs to also work on our
 * implementation of EventEmitter with type-checked strings
 * @param {Object} target
 * @param {string} eventName
 * @returns {Observable}
 */
        function fromEvent(target, eventName) {
            return new rxjs__WEBPACK_IMPORTED_MODULE_0__.a(function(obs) {
                function handler(event) {
                    obs.next(event);
                }
                return target.addEventListener(eventName, handler), function() {
                    target.removeEventListener(eventName, handler);
                };
            });
        }
        /***/    }, 
    /* 34 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return map;
        });
        /* unused harmony export MapOperator */
        /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3), _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8);
        /* harmony import */        
        /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
        function map(project, thisArg) {
            return function mapOperation(source) {
                if ("function" != typeof project) throw new TypeError("argument is not a function. Are you looking for `mapTo()`?");
                return source.lift(new MapOperator(project, thisArg));
            };
        }
        var MapOperator = /* */ function() {
            function MapOperator(project, thisArg) {
                this.project = project, this.thisArg = thisArg;
            }
            return MapOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
            }, MapOperator;
        }(), MapSubscriber = /* */ function(_super) {
            function MapSubscriber(destination, project, thisArg) {
                var _this = _super.call(this, destination) || this;
                return _this.project = project, _this.count = 0, _this.thisArg = thisArg || _this, 
                _this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(MapSubscriber, _super), MapSubscriber.prototype._next = function(value) {
                var result;
                try {
                    result = this.project.call(this.thisArg, value, this.count++);
                } catch (err) {
                    return void this.destination.error(err);
                }
                this.destination.next(result);
            }, MapSubscriber;
        }(_Subscriber__WEBPACK_IMPORTED_MODULE_1__.a);
    }, 
    /* 35 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return config;
        });
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        var _enable_super_gross_mode_that_will_cause_bad_things = !1, config = {
            Promise: void 0,
            set useDeprecatedSynchronousErrorHandling(value) {
                value && /* */ new Error().stack;
                _enable_super_gross_mode_that_will_cause_bad_things = value;
            },
            get useDeprecatedSynchronousErrorHandling() {
                return _enable_super_gross_mode_that_will_cause_bad_things;
            }
        };
    }, 
    /* 36 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return fromArray;
        });
        /* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6), _Subscription__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(14), _util_subscribeToArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(83);
        /* harmony import */        
        /** PURE_IMPORTS_START _Observable,_Subscription,_util_subscribeToArray PURE_IMPORTS_END */
        function fromArray(input, scheduler) {
            return scheduler ? new _Observable__WEBPACK_IMPORTED_MODULE_0__.a(function(subscriber) {
                var sub = new _Subscription__WEBPACK_IMPORTED_MODULE_1__.a(), i = 0;
                return sub.add(scheduler.schedule(function() {
                    i !== input.length ? (subscriber.next(input[i++]), subscriber.closed || sub.add(this.schedule())) : subscriber.complete();
                })), sub;
            }) : new _Observable__WEBPACK_IMPORTED_MODULE_0__.a(Object(_util_subscribeToArray__WEBPACK_IMPORTED_MODULE_2__.a)(input));
        }
        //# sourceMappingURL=fromArray.js.map
        /***/    }, 
    /* 37 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        function noop() {}
        //# sourceMappingURL=noop.js.map
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return noop;
        });
    }, 
    /* 38 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return EMPTY;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() {
            return empty;
        });
        /* unused harmony export emptyScheduled */
        /* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6), EMPTY = /* */ new _Observable__WEBPACK_IMPORTED_MODULE_0__.a(function(subscriber) {
            return subscriber.complete();
        });
        /** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */        function empty(scheduler) {
            return scheduler ? emptyScheduled(scheduler) : EMPTY;
        }
        function emptyScheduled(scheduler) {
            return new _Observable__WEBPACK_IMPORTED_MODULE_0__.a(function(subscriber) {
                return scheduler.schedule(function() {
                    return subscriber.complete();
                });
            });
        }
        //# sourceMappingURL=empty.js.map
        /***/    }, 
    /* 39 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return mergeMap;
        });
        /* unused harmony export MergeMapOperator */
        /* unused harmony export MergeMapSubscriber */
        /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3), _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(24), _OuterSubscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(25), _InnerSubscriber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(47), _map__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(34), _observable_from__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(53);
        /* harmony import */        
        /** PURE_IMPORTS_START tslib,_util_subscribeToResult,_OuterSubscriber,_InnerSubscriber,_map,_observable_from PURE_IMPORTS_END */
        function mergeMap(project, resultSelector, concurrent) {
            return void 0 === concurrent && (concurrent = Number.POSITIVE_INFINITY), "function" == typeof resultSelector ? function(source) {
                return source.pipe(mergeMap(function(a, i) {
                    return Object(_observable_from__WEBPACK_IMPORTED_MODULE_5__.a)(project(a, i)).pipe(Object(_map__WEBPACK_IMPORTED_MODULE_4__.a)(function(b, ii) {
                        return resultSelector(a, b, i, ii);
                    }));
                }, concurrent));
            } : ("number" == typeof resultSelector && (concurrent = resultSelector), function(source) {
                return source.lift(new MergeMapOperator(project, concurrent));
            });
        }
        var MergeMapOperator = /* */ function() {
            function MergeMapOperator(project, concurrent) {
                void 0 === concurrent && (concurrent = Number.POSITIVE_INFINITY), this.project = project, 
                this.concurrent = concurrent;
            }
            return MergeMapOperator.prototype.call = function(observer, source) {
                return source.subscribe(new MergeMapSubscriber(observer, this.project, this.concurrent));
            }, MergeMapOperator;
        }(), MergeMapSubscriber = /* */ function(_super) {
            function MergeMapSubscriber(destination, project, concurrent) {
                void 0 === concurrent && (concurrent = Number.POSITIVE_INFINITY);
                var _this = _super.call(this, destination) || this;
                return _this.project = project, _this.concurrent = concurrent, _this.hasCompleted = !1, 
                _this.buffer = [], _this.active = 0, _this.index = 0, _this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(MergeMapSubscriber, _super), MergeMapSubscriber.prototype._next = function(value) {
                this.active < this.concurrent ? this._tryNext(value) : this.buffer.push(value);
            }, MergeMapSubscriber.prototype._tryNext = function(value) {
                var result, index = this.index++;
                try {
                    result = this.project(value, index);
                } catch (err) {
                    return void this.destination.error(err);
                }
                this.active++, this._innerSub(result, value, index);
            }, MergeMapSubscriber.prototype._innerSub = function(ish, value, index) {
                var innerSubscriber = new _InnerSubscriber__WEBPACK_IMPORTED_MODULE_3__.a(this, void 0, void 0);
                this.destination.add(innerSubscriber), Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__.a)(this, ish, value, index, innerSubscriber);
            }, MergeMapSubscriber.prototype._complete = function() {
                this.hasCompleted = !0, 0 === this.active && 0 === this.buffer.length && this.destination.complete(), 
                this.unsubscribe();
            }, MergeMapSubscriber.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
                this.destination.next(innerValue);
            }, MergeMapSubscriber.prototype.notifyComplete = function(innerSub) {
                var buffer = this.buffer;
                this.remove(innerSub), this.active--, 0 < buffer.length ? this._next(buffer.shift()) : 0 === this.active && this.hasCompleted && this.destination.complete();
            }, MergeMapSubscriber;
        }(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_2__.a);
    }, 
    /* 40 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        function isScheduler(value) {
            return value && "function" == typeof value.schedule;
        }
        //# sourceMappingURL=isScheduler.js.map
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return isScheduler;
        });
    }, 
    /* 41 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return async;
        });
        /* harmony import */ var _AsyncAction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(68), async = /* */ new (__webpack_require__(67).a)(_AsyncAction__WEBPACK_IMPORTED_MODULE_0__.a);
        /* harmony import */    }, 
    /* 42 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "b", function() {
            return SubjectSubscriber;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return Subject;
        });
        /* unused harmony export AnonymousSubject */
        /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3), _Observable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6), _Subscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(8), _Subscription__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(14), _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(49), _SubjectSubscription__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(88), _internal_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(61), SubjectSubscriber = /* */ function(_super) {
            function SubjectSubscriber(destination) {
                var _this = _super.call(this, destination) || this;
                return _this.destination = destination, _this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(SubjectSubscriber, _super), SubjectSubscriber;
        }(_Subscriber__WEBPACK_IMPORTED_MODULE_2__.a), Subject = /* */ function(_super) {
            function Subject() {
                var _this = _super.call(this) || this;
                return _this.observers = [], _this.closed = !1, _this.isStopped = !1, _this.hasError = !1, 
                _this.thrownError = null, _this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(Subject, _super), Subject.prototype[_internal_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_6__.a] = function() {
                return new SubjectSubscriber(this);
            }, Subject.prototype.lift = function(operator) {
                var subject = new AnonymousSubject(this, this);
                return subject.operator = operator, subject;
            }, Subject.prototype.next = function(value) {
                if (this.closed) throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_4__.a();
                if (!this.isStopped) for (var observers = this.observers, len = observers.length, copy = observers.slice(), i = 0; i < len; i++) copy[i].next(value);
            }, Subject.prototype.error = function(err) {
                if (this.closed) throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_4__.a();
                this.hasError = !0, this.thrownError = err, this.isStopped = !0;
                for (var observers = this.observers, len = observers.length, copy = observers.slice(), i = 0; i < len; i++) copy[i].error(err);
                this.observers.length = 0;
            }, Subject.prototype.complete = function() {
                if (this.closed) throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_4__.a();
                this.isStopped = !0;
                for (var observers = this.observers, len = observers.length, copy = observers.slice(), i = 0; i < len; i++) copy[i].complete();
                this.observers.length = 0;
            }, Subject.prototype.unsubscribe = function() {
                this.isStopped = !0, this.closed = !0, this.observers = null;
            }, Subject.prototype._trySubscribe = function(subscriber) {
                if (this.closed) throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_4__.a();
                return _super.prototype._trySubscribe.call(this, subscriber);
            }, Subject.prototype._subscribe = function(subscriber) {
                if (this.closed) throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_4__.a();
                return this.hasError ? (subscriber.error(this.thrownError), _Subscription__WEBPACK_IMPORTED_MODULE_3__.a.EMPTY) : this.isStopped ? (subscriber.complete(), 
                _Subscription__WEBPACK_IMPORTED_MODULE_3__.a.EMPTY) : (this.observers.push(subscriber), 
                new _SubjectSubscription__WEBPACK_IMPORTED_MODULE_5__.a(this, subscriber));
            }, Subject.prototype.asObservable = function() {
                var observable = new _Observable__WEBPACK_IMPORTED_MODULE_1__.a();
                return observable.source = this, observable;
            }, Subject.create = function(destination, source) {
                return new AnonymousSubject(destination, source);
            }, Subject;
        }(_Observable__WEBPACK_IMPORTED_MODULE_1__.a), AnonymousSubject = /* */ function(_super) {
            function AnonymousSubject(destination, source) {
                var _this = _super.call(this) || this;
                return _this.destination = destination, _this.source = source, _this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(AnonymousSubject, _super), AnonymousSubject.prototype.next = function(value) {
                var destination = this.destination;
                destination && destination.next && destination.next(value);
            }, AnonymousSubject.prototype.error = function(err) {
                var destination = this.destination;
                destination && destination.error && this.destination.error(err);
            }, AnonymousSubject.prototype.complete = function() {
                var destination = this.destination;
                destination && destination.complete && this.destination.complete();
            }, AnonymousSubject.prototype._subscribe = function(subscriber) {
                return this.source ? this.source.subscribe(subscriber) : _Subscription__WEBPACK_IMPORTED_MODULE_3__.a.EMPTY;
            }, AnonymousSubject;
        }(Subject);
        /* harmony import */    }, 
    /* 43 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return tryCatch;
        });
        /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74);
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {Function} func - A function you want to execute
 * @param {*} args - The function's argument
 * @returns {*} - If it fails, returns a throwing Observable, else the
 * function's result (which should be, in most cases, an Observable).
 */        function tryCatch(func, args) {
            try {
                return func(args);
            } catch (e) {
                return Object(rxjs__WEBPACK_IMPORTED_MODULE_0__.a)(e);
            }
        }
        /***/    }, 
    /* 44 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/fromEvent.js
        var fromEvent = __webpack_require__(166), Observable = __webpack_require__(6), noop = __webpack_require__(37), NEVER = /* */ new Observable.a(noop.a);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Observable.js + 3 modules
                //# sourceMappingURL=never.js.map
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/merge.js
        var merge = __webpack_require__(112), interval = __webpack_require__(177), map = __webpack_require__(34), filter = __webpack_require__(139), tslib_es6 = __webpack_require__(3), Subscriber = __webpack_require__(8), scheduler_async = __webpack_require__(41);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/interval.js
                // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/debounceTime.js
        /** PURE_IMPORTS_START tslib,_Subscriber,_scheduler_async PURE_IMPORTS_END */
        function debounceTime(dueTime, scheduler) {
            return void 0 === scheduler && (scheduler = scheduler_async.a), function(source) {
                return source.lift(new DebounceTimeOperator(dueTime, scheduler));
            };
        }
        var DebounceTimeOperator = /* */ function() {
            function DebounceTimeOperator(dueTime, scheduler) {
                this.dueTime = dueTime, this.scheduler = scheduler;
            }
            return DebounceTimeOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new debounceTime_DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));
            }, DebounceTimeOperator;
        }(), debounceTime_DebounceTimeSubscriber = /* */ function(_super) {
            function DebounceTimeSubscriber(destination, dueTime, scheduler) {
                var _this = _super.call(this, destination) || this;
                return _this.dueTime = dueTime, _this.scheduler = scheduler, _this.debouncedSubscription = null, 
                _this.lastValue = null, _this.hasValue = !1, _this;
            }
            return tslib_es6.a(DebounceTimeSubscriber, _super), DebounceTimeSubscriber.prototype._next = function(value) {
                this.clearDebounce(), this.lastValue = value, this.hasValue = !0, this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));
            }, DebounceTimeSubscriber.prototype._complete = function() {
                this.debouncedNext(), this.destination.complete();
            }, DebounceTimeSubscriber.prototype.debouncedNext = function() {
                if (this.clearDebounce(), this.hasValue) {
                    var lastValue = this.lastValue;
                    this.lastValue = null, this.hasValue = !1, this.destination.next(lastValue);
                }
            }, DebounceTimeSubscriber.prototype.clearDebounce = function() {
                var debouncedSubscription = this.debouncedSubscription;
                null !== debouncedSubscription && (this.remove(debouncedSubscription), debouncedSubscription.unsubscribe(), 
                this.debouncedSubscription = null);
            }, DebounceTimeSubscriber;
        }(Subscriber.a);
        function dispatchNext(subscriber) {
            subscriber.debouncedNext();
        }
        //# sourceMappingURL=debounceTime.js.map
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/startWith.js
                var startWith = __webpack_require__(176), distinctUntilChanged = __webpack_require__(167), config = __webpack_require__(2), browser_compatibility_types = __webpack_require__(19);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/distinctUntilChanged.js
                // CONCATENATED MODULE: ./src/compat/event_listeners.ts
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isInBackground$", function() {
            return isInBackground$;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "videoWidth$", function() {
            return videoWidth$;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onPlayPause$", function() {
            return event_listeners_onPlayPause$;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onTextTrackChanges$", function() {
            return event_listeners_onTextTrackChanges$;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onLoadedMetadata$", function() {
            return onLoadedMetadata$;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onSeeking$", function() {
            return onSeeking$;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onSeeked$", function() {
            return onSeeked$;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onEnded$", function() {
            return onEnded$;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onTimeUpdate$", function() {
            return onTimeUpdate$;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onFullscreenChange$", function() {
            return onFullscreenChange$;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onSourceOpen$", function() {
            return onSourceOpen$;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onUpdate$", function() {
            return onUpdate$;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onRemoveSourceBuffers$", function() {
            return onRemoveSourceBuffers$;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onEncrypted$", function() {
            return onEncrypted$;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onKeyMessage$", function() {
            return onKeyMessage$;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onKeyAdded$", function() {
            return onKeyAdded$;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onKeyError$", function() {
            return onKeyError$;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onKeyStatusesChange$", function() {
            return onKeyStatusesChange$;
        });
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * This file provides browser-agnostic event listeners under the form of
 * RxJS Observables
 */
        var BROWSER_PREFIXES = [ "", "webkit", "moz", "ms" ], INACTIVITY_DELAY = config.a.INACTIVITY_DELAY, pixelRatio = window.devicePixelRatio || 1;
        /**
 * Find the first supported event from the list given.
 * @param {HTMLElement} element
 * @param {string} eventNameSuffix
 * @returns {Boolean}
 */
        function isEventSupported(element, eventNameSuffix) {
            var clone = document.createElement(element.tagName), eventName = "on" + eventNameSuffix;
            return eventName in clone || (clone.setAttribute(eventName, "return;"), "function" == typeof clone[eventName]);
        }
        /**
 * Find the first supported event from the list given.
 * @param {HTMLElement} element
 * @param {Array.<string>} eventNames
 * @returns {string|undefined}
 */        function findSupportedEvent(element, eventNames) {
            return eventNames.filter(function(name) {
                return isEventSupported(element, name);
            })[0];
        }
        /**
 * @param {Array.<string>} eventNames
 * @param {Array.<string>|undefined} prefixes
 * @returns {Array.<string>}
 */        function eventPrefixed(eventNames, prefixes) {
            return eventNames.reduce(function(parent, name) {
                return parent.concat((prefixes || BROWSER_PREFIXES).map(function(p) {
                    return p + name;
                }));
            }, []);
        }
        /**
 * @param {Array.<string>} eventNames
 * @param {Array.<string>|undefined} prefixes
 * @returns {Observable}
 */        function compatibleListener(eventNames, prefixes) {
            var mem, prefixedEvents = eventPrefixed(eventNames, prefixes);
            return function(element) {
                // if the element is a HTMLElement we can detect
                // the supported event, and memoize it in `mem`
                return element instanceof browser_compatibility_types.a ? (void 0 === mem && (mem = findSupportedEvent(element, prefixedEvents)), 
                mem ? Object(fromEvent.a)(element, mem) : NEVER) : merge.a.apply(void 0, prefixedEvents.map(function(eventName) {
                    return Object(fromEvent.a)(element, eventName);
                }));
 // otherwise, we need to listen to all the events
                // and merge them into one observable sequence
                        };
        }
        /**
 * Returns an observable:
 *   - emitting true when the visibility of document changes to hidden
 *   - emitting false when the visibility of document changes to visible
 * @returns {Observable}
 */        function visibilityChange() {
            var prefix, doc = document;
            null != doc.hidden ? prefix = "" : null != doc.mozHidden ? prefix = "moz" : null != doc.msHidden ? prefix = "ms" : null != doc.webkitHidden && (prefix = "webkit");
            var hidden = prefix ? prefix + "Hidden" : "hidden", visibilityChangeEvent = prefix + "visibilitychange";
            return Object(fromEvent.a)(document, visibilityChangeEvent).pipe(Object(map.a)(function() {
                return document[hidden];
            }));
        }
        /**
 * @returns {Observable}
 */        function videoSizeChange() {
            return Object(fromEvent.a)(window, "resize");
        }
        var isVisible$ = visibilityChange().pipe(Object(filter.a)(function(x) {
            return !x;
        })), isHidden$ = visibilityChange().pipe(debounceTime(INACTIVITY_DELAY), Object(filter.a)(function(x) {
            return x;
        }));
 // emit false when visible
        // Emit true if the visibility changed to hidden since 60s
                /**
 * @returns {Observable}
 */
        function isInBackground$() {
            return Object(merge.a)(isVisible$, isHidden$).pipe(Object(startWith.a)(!1));
        }
        /**
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */        function videoWidth$(mediaElement) {
            return Object(merge.a)(Object(interval.a)(2e4), videoSizeChange().pipe(debounceTime(500))).pipe(Object(startWith.a)(null), // emit on subscription
            Object(map.a)(function() {
                return mediaElement.clientWidth * pixelRatio;
            }), Object(distinctUntilChanged.a)());
        }
        /**
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */        var onLoadedMetadata$ = compatibleListener([ "loadedmetadata" ]), onSeeking$ = compatibleListener([ "seeking" ]), onSeeked$ = compatibleListener([ "seeked" ]), onEnded$ = compatibleListener([ "ended" ]), onTimeUpdate$ = compatibleListener([ "timeupdate" ]), onFullscreenChange$ = compatibleListener([ "fullscreenchange", "FullscreenChange" ], // On IE11, fullscreen change events is called MSFullscreenChange
        BROWSER_PREFIXES.concat("MS")), event_listeners_onPlayPause$ = function onPlayPause$(mediaElement) {
            return Object(merge.a)(compatibleListener([ "play" ])(mediaElement), compatibleListener([ "pause" ])(mediaElement));
        }, event_listeners_onTextTrackChanges$ = function onTextTrackChanges$(textTrackList) {
            return Object(merge.a)(compatibleListener([ "addtrack" ])(textTrackList), compatibleListener([ "removetrack" ])(textTrackList));
        }, onSourceOpen$ = compatibleListener([ "sourceopen", "webkitsourceopen" ]), onUpdate$ = compatibleListener([ "update" ]), onRemoveSourceBuffers$ = compatibleListener([ "onremovesourcebuffer" ]), onEncrypted$ = compatibleListener([ "encrypted", "needkey" ]), onKeyMessage$ = compatibleListener([ "keymessage", "message" ]), onKeyAdded$ = compatibleListener([ "keyadded", "ready" ]), onKeyError$ = compatibleListener([ "keyerror", "error" ]), onKeyStatusesChange$ = compatibleListener([ "keystatuseschange" ]);
        /**
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */    }, 
    /* 45 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return isArray;
        });
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        var isArray = Array.isArray || function(x) {
            return x && "number" == typeof x.length;
        };
        //# sourceMappingURL=isArray.js.map
        /***/    }, 
    /* 46 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return observable;
        });
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        var observable = "function" == typeof Symbol && Symbol.observable || "@@observable";
        //# sourceMappingURL=observable.js.map
        /***/    }, 
    /* 47 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return InnerSubscriber;
        });
        /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3), InnerSubscriber = /* */ function(_super) {
            function InnerSubscriber(parent, outerValue, outerIndex) {
                var _this = _super.call(this) || this;
                return _this.parent = parent, _this.outerValue = outerValue, _this.outerIndex = outerIndex, 
                _this.index = 0, _this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(InnerSubscriber, _super), InnerSubscriber.prototype._next = function(value) {
                this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
            }, InnerSubscriber.prototype._error = function(error) {
                this.parent.notifyError(error, this), this.unsubscribe();
            }, InnerSubscriber.prototype._complete = function() {
                this.parent.notifyComplete(this), this.unsubscribe();
            }, InnerSubscriber;
        }(__webpack_require__(8).a);
        /* harmony import */    }, 
    /* 48 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Creates an ID generator which generates an ID each time you call it.
 * @returns {Function}
 */
        function idGenerator() {
            var lastID = 0;
            return function generateNewId() {
                return "" + lastID++;
            };
        }
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return idGenerator;
        });
    }, 
    /* 49 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        function ObjectUnsubscribedErrorImpl() {
            return Error.call(this), this.message = "object unsubscribed", this.name = "ObjectUnsubscribedError", 
            this;
        }
        __webpack_require__.d(__webpack_exports__, "a", function() {
            return ObjectUnsubscribedError;
        }), ObjectUnsubscribedErrorImpl.prototype = /* */ Object.create(Error.prototype);
        var ObjectUnsubscribedError = ObjectUnsubscribedErrorImpl;
        //# sourceMappingURL=ObjectUnsubscribedError.js.map
        /***/    }, 
    /* 50 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {Element} tt
 * @returns {Element}
 */
        function getBodyNode(tt) {
            return tt.getElementsByTagName("body")[0];
        }
        /**
 * @param {Element} tt - <tt> node
 * @returns {Array.<Element>}
 */        function getStyleNodes(tt) {
            return tt.getElementsByTagName("style");
        }
        /**
 * @param {Element} tt - <tt> node
 * @returns {Array.<Element>}
 */        function getRegionNodes(tt) {
            return tt.getElementsByTagName("region");
        }
        /**
 * @param {Element} tt - <tt> node
 * @returns {Array.<Element>}
 */        function getTextNodes(tt) {
            return tt.getElementsByTagName("p");
        }
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return getBodyNode;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() {
            return getStyleNodes;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() {
            return getRegionNodes;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() {
            return getTextNodes;
        });
    }, 
    /* 51 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        function isFunction(x) {
            return "function" == typeof x;
        }
        //# sourceMappingURL=isFunction.js.map
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return isFunction;
        });
    }, 
    /* 52 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Returns first line after the WEBVTT header.
 * That is, the line after the first blank line after the first line!
 * @param {Array.<string>} linified
 * @returns {Number}
 */
        function getFirstLineAfterHeader(linified) {
            for (var i = 0; i < linified.length; ) {
                if ("" === linified[i]) return i + 1;
                i++;
            }
            return i;
        }
        /**
 * Returns true if the given line looks like the beginning of a Style block.
 * @param {string} text
 * @returns {Boolean}
 */        function isStartOfStyleBlock(lines, index) {
            return !!lines[index] && /^STYLE( .*)?$/g.test(lines[index]) && (// A cue identifer can also contain "STYLe". Check that we have no timings
            // on the second line
            !lines[index + 1] || lines[index + 1].indexOf("--\x3e") < 0);
        }
        /**
 * Returns true if the given line looks like the beginning of a comment block.
 * @param {string} text
 * @returns {Boolean}
 */        function isStartOfNoteBlock(lines, index) {
            return !!lines[index] && /^NOTE( .*)?$/g.test(lines[index]) && (// A cue identifer can also contain "NOTE". Check that we have no timings
            // on the second line
            !lines[index + 1] || lines[index + 1].indexOf("--\x3e") < 0);
        }
        /**
 * Returns true if the given line looks like the beginning of a region block.
 * @param {string} text
 * @returns {Boolean}
 */        function isStartOfRegionBlock(lines, index) {
            return !!lines[index] && /^REGION( .*)?$/g.test(lines[index]) && (// A cue identifer can also contain "REGION". Check that we have no timings
            // on the second line
            !lines[index + 1] || lines[index + 1].indexOf("--\x3e") < 0);
        }
        /**
 * Returns true if the line given looks like the beginning of a cue.
 * You should provide to this function only lines following "empty" lines.
 * @param {Array.<string>} lines
 * @param {number} index
 * @returns {Boolean}
 */        function isStartOfCueBlock(lines, index) {
            // checked cases:
            //   - empty lines
            //   - start of a comment
            //   - start of a region
            //   - start of a style
            // Anything else whose first or second line is a timestamp line is a cue.
            var firstLine = lines[index];
            if (!firstLine || isStartOfStyleBlock(lines, index) || isStartOfRegionBlock(lines, index) || isStartOfNoteBlock(lines, index)) return !1;
            if (0 <= firstLine.indexOf("--\x3e")) return !0;
            var secondLine = lines[index + 1];
            return !!secondLine && 0 <= secondLine.indexOf("--\x3e");
        }
        /**
 * Find end of current WebVTT cue block.
 * @param {Array<string>} linified
 * @param {number} startOfCueBlock
 * @returns {number}
 */        function findEndOfCueBlock(linified, startOfCueBlock) {
            // continue incrementing i until either:
            //   - empty line
            //   - end
            for (var firstEmptyLineIndex = startOfCueBlock + 1; linified[firstEmptyLineIndex]; ) firstEmptyLineIndex++;
            return firstEmptyLineIndex;
        }
        /***/        __webpack_require__.d(__webpack_exports__, "b", function() {
            return getFirstLineAfterHeader;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() {
            return isStartOfCueBlock;
        }), 
        /* unused harmony export isStartOfNoteBlock */
        /* unused harmony export isStartOfRegionBlock */
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() {
            return isStartOfStyleBlock;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return findEndOfCueBlock;
        });
    }, 
    /* 53 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Observable.js + 3 modules
                var Observable = __webpack_require__(6), isPromise = __webpack_require__(84), isArrayLike = __webpack_require__(82), symbol_observable = __webpack_require__(46);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/isPromise.js
                // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/util/isInteropObservable.js
        /** PURE_IMPORTS_START _symbol_observable PURE_IMPORTS_END */
        function isInteropObservable(input) {
            return input && "function" == typeof input[symbol_observable.a];
        }
        //# sourceMappingURL=isInteropObservable.js.map
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/symbol/iterator.js
                var symbol_iterator = __webpack_require__(56);
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/util/isIterable.js
        /** PURE_IMPORTS_START _symbol_iterator PURE_IMPORTS_END */        function isIterable(input) {
            return input && "function" == typeof input[symbol_iterator.a];
        }
        //# sourceMappingURL=isIterable.js.map
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/fromArray.js
                var fromArray = __webpack_require__(36), Subscription = __webpack_require__(14), subscribeToPromise = __webpack_require__(85);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subscription.js + 1 modules
                // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/observable/fromPromise.js
        /** PURE_IMPORTS_START _Observable,_Subscription,_util_subscribeToPromise PURE_IMPORTS_END */
        function fromPromise(input, scheduler) {
            return scheduler ? new Observable.a(function(subscriber) {
                var sub = new Subscription.a();
                return sub.add(scheduler.schedule(function() {
                    return input.then(function(value) {
                        sub.add(scheduler.schedule(function() {
                            subscriber.next(value), sub.add(scheduler.schedule(function() {
                                return subscriber.complete();
                            }));
                        }));
                    }, function(err) {
                        sub.add(scheduler.schedule(function() {
                            return subscriber.error(err);
                        }));
                    });
                })), sub;
            }) : new Observable.a(Object(subscribeToPromise.a)(input));
        }
        //# sourceMappingURL=fromPromise.js.map
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/subscribeToIterable.js
                var subscribeToIterable = __webpack_require__(86);
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/observable/fromIterable.js
        /** PURE_IMPORTS_START _Observable,_Subscription,_symbol_iterator,_util_subscribeToIterable PURE_IMPORTS_END */        function fromIterable(input, scheduler) {
            if (!input) throw new Error("Iterable cannot be null");
            return scheduler ? new Observable.a(function(subscriber) {
                var iterator, sub = new Subscription.a();
                return sub.add(function() {
                    iterator && "function" == typeof iterator.return && iterator.return();
                }), sub.add(scheduler.schedule(function() {
                    iterator = input[symbol_iterator.a](), sub.add(scheduler.schedule(function() {
                        if (!subscriber.closed) {
                            var value, done;
                            try {
                                var result = iterator.next();
                                value = result.value, done = result.done;
                            } catch (err) {
                                return void subscriber.error(err);
                            }
                            done ? subscriber.complete() : (subscriber.next(value), this.schedule());
                        }
                    }));
                })), sub;
            }) : new Observable.a(Object(subscribeToIterable.a)(input));
        }
        //# sourceMappingURL=fromIterable.js.map
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/subscribeToObservable.js
                var subscribeToObservable = __webpack_require__(81);
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/observable/fromObservable.js
        /** PURE_IMPORTS_START _Observable,_Subscription,_symbol_observable,_util_subscribeToObservable PURE_IMPORTS_END */        function fromObservable(input, scheduler) {
            return scheduler ? new Observable.a(function(subscriber) {
                var sub = new Subscription.a();
                return sub.add(scheduler.schedule(function() {
                    var observable = input[symbol_observable.a]();
                    sub.add(observable.subscribe({
                        next: function(value) {
                            sub.add(scheduler.schedule(function() {
                                return subscriber.next(value);
                            }));
                        },
                        error: function(err) {
                            sub.add(scheduler.schedule(function() {
                                return subscriber.error(err);
                            }));
                        },
                        complete: function() {
                            sub.add(scheduler.schedule(function() {
                                return subscriber.complete();
                            }));
                        }
                    }));
                })), sub;
            }) : new Observable.a(Object(subscribeToObservable.a)(input));
        }
        //# sourceMappingURL=fromObservable.js.map
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/subscribeTo.js
                var subscribeTo = __webpack_require__(80);
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/observable/from.js
        /* harmony export (binding) */        
        /** PURE_IMPORTS_START _Observable,_util_isPromise,_util_isArrayLike,_util_isInteropObservable,_util_isIterable,_fromArray,_fromPromise,_fromIterable,_fromObservable,_util_subscribeTo PURE_IMPORTS_END */
        function from(input, scheduler) {
            if (!scheduler) return input instanceof Observable.a ? input : new Observable.a(Object(subscribeTo.a)(input));
            if (null != input) {
                if (isInteropObservable(input)) return fromObservable(input, scheduler);
                if (Object(isPromise.a)(input)) return fromPromise(input, scheduler);
                if (Object(isArrayLike.a)(input)) return Object(fromArray.a)(input, scheduler);
                if (isIterable(input) || "string" == typeof input) return fromIterable(input, scheduler);
            }
            throw new TypeError((null !== input && typeof input || input) + " is not observable");
        }
        //# sourceMappingURL=from.js.map
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return from;
        });
    }, 
    /* 54 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        function hostReportError(err) {
            setTimeout(function() {
                throw err;
            });
        }
        //# sourceMappingURL=hostReportError.js.map
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return hostReportError;
        });
    }, 
    /* 55 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Generate a normalized error message.
 * @param {string} name
 * @param {string} code
 * @param {Error|string|Event|null} [reason]
 * @returns {string}
 */
        function errorMessage(name, code, reason) {
            return name + " (" + code + ") " + reason;
        }
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return errorMessage;
        });
    }, 
    /* 56 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* unused harmony export getSymbolIterator */
        /* harmony export (binding) */        
        /* unused harmony export $$iterator */
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        function getSymbolIterator() {
            return "function" == typeof Symbol && Symbol.iterator ? Symbol.iterator : "@@iterator";
        }
        __webpack_require__.d(__webpack_exports__, "a", function() {
            return iterator;
        });
        var iterator = /* */ getSymbolIterator();
    }, 
    /* 57 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Returns text-formatted byteRange (`bytes=$start-$end?)`
 * @param {Array.<string|Number>} arr
 * @returns {string}
 */
        function byteRange(_ref) {
            var start = _ref[0], end = _ref[1];
            return Infinity === end ? "bytes=" + +start + "-" : "bytes=" + +start + "-" + +end;
        }
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return byteRange;
        });
    }, 
    /* 58 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return MediaError;
        });
        /* harmony import */ var _error_codes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21), _error_message__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(55);
        /* harmony import */        function _assertThisInitialized(self) {
            if (void 0 === self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return self;
        }
        function _inheritsLoose(subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype), (subClass.prototype.constructor = subClass).__proto__ = superClass;
        }
        function _wrapNativeSuper(Class) {
            var _cache = "function" == typeof Map ? new Map() : void 0;
            return (_wrapNativeSuper = function _wrapNativeSuper(Class) {
                if (null === Class || !_isNativeFunction(Class)) return Class;
                if ("function" != typeof Class) throw new TypeError("Super expression must either be null or a function");
                if (void 0 !== _cache) {
                    if (_cache.has(Class)) return _cache.get(Class);
                    _cache.set(Class, Wrapper);
                }
                function Wrapper() {
                    return _construct(Class, arguments, _getPrototypeOf(this).constructor);
                }
                return Wrapper.prototype = Object.create(Class.prototype, {
                    constructor: {
                        value: Wrapper,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }), _setPrototypeOf(Wrapper, Class);
            })(Class);
        }
        function isNativeReflectConstruct() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function() {})), 
                !0;
            } catch (e) {
                return !1;
            }
        }
        function _construct(Parent, args, Class) {
            return (_construct = isNativeReflectConstruct() ? Reflect.construct : function _construct(Parent, args, Class) {
                var a = [ null ];
                a.push.apply(a, args);
                var instance = new (Function.bind.apply(Parent, a))();
                return Class && _setPrototypeOf(instance, Class.prototype), instance;
            }).apply(null, arguments);
        }
        function _isNativeFunction(fn) {
            return -1 !== Function.toString.call(fn).indexOf("[native code]");
        }
        function _setPrototypeOf(o, p) {
            return (_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
                return o.__proto__ = p, o;
            })(o, p);
        }
        function _getPrototypeOf(o) {
            return (_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
                return o.__proto__ || Object.getPrototypeOf(o);
            })(o);
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Error linked to the media Playback.
 *
 * @class MediaError
 * @extends Error
 */        var MediaError = 
        /* */
        function(_Error) {
            /**
   * @param {string} code
   * @param {string} reason
   * @param {Boolean} fatal
   */
            function MediaError(code, reason, fatal) {
                var _this;
                return _this = _Error.call(this) || this, // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class
                Object.setPrototypeOf(_assertThisInitialized(_this), MediaError.prototype), _this.name = "MediaError", 
                _this.type = _error_codes__WEBPACK_IMPORTED_MODULE_0__.b.MEDIA_ERROR, _this.code = _error_codes__WEBPACK_IMPORTED_MODULE_0__.a.hasOwnProperty(code) ? _error_codes__WEBPACK_IMPORTED_MODULE_0__.a[code] : "", 
                _this.fatal = !!fatal, _this.message = Object(_error_message__WEBPACK_IMPORTED_MODULE_1__.a)(_this.name, _this.code, reason), 
                _this;
            }
            return _inheritsLoose(MediaError, _Error), MediaError;
        }(_wrapNativeSuper(Error));
        /***/    }, 
    /* 59 */ 
    /* 60 */
    /***/ , 
    /* 60 */
    /***/ function(module, exports, __webpack_require__) {
        "use strict";
        var callable, byObserver;
        callable = function(fn) {
            if ("function" != typeof fn) throw new TypeError(fn + " is not a function");
            return fn;
        }, byObserver = function(Observer) {
            var queue, currentQueue, node = document.createTextNode(""), i = 0;
            return new Observer(function() {
                var callback;
                if (queue) currentQueue && (queue = currentQueue.concat(queue)); else {
                    if (!currentQueue) return;
                    queue = currentQueue;
                }
                if (currentQueue = queue, queue = null, "function" == typeof currentQueue) return callback = currentQueue, 
                currentQueue = null, void callback();
                // Invoke other batch, to handle leftover callbacks in case of crash
                for (node.data = i = ++i % 2; currentQueue; ) callback = currentQueue.shift(), currentQueue.length || (currentQueue = null), 
                callback();
            }).observe(node, {
                characterData: !0
            }), function(fn) {
                callable(fn), queue ? "function" == typeof queue ? queue = [ queue, fn ] : queue.push(fn) : (queue = fn, 
                node.data = i = ++i % 2);
            };
        }, module.exports = function() {
            // Node.js
            if ("object" == typeof process && process && "function" == typeof process.nextTick) return process.nextTick;
            // MutationObserver
                        if ("object" == typeof document && document) {
                if ("function" == typeof MutationObserver) return byObserver(MutationObserver);
                if ("function" == typeof WebKitMutationObserver) return byObserver(WebKitMutationObserver);
            }
            // W3C Draft
            // http://dvcs.w3.org/hg/webperf/raw-file/tip/specs/setImmediate/Overview.html
                        return "function" == typeof setImmediate ? function(cb) {
                setImmediate(callable(cb));
            } : 
            // Wide available standard
            "function" == typeof setTimeout || "object" == typeof setTimeout ? function(cb) {
                setTimeout(callable(cb), 0);
            } : null;
        }();
    }, 
    /* 61 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return rxSubscriber;
        });
        /* unused harmony export $$rxSubscriber */
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        var rxSubscriber = "function" == typeof Symbol ? /* */ Symbol("rxSubscriber") : "@@rxSubscriber_" + /* */ Math.random();
    }, 
    /* 62 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return SimpleSet;
        });
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Simple hash-based set.
 * @class SimpleSet
 */
        var SimpleSet = 
        /* */
        function() {
            function SimpleSet() {
                this._hashes = {};
            }
            /**
   * Add a new hash entry in the set.
   * Do not have any effect on already-added hashes
   * @param {string|number} x
   */            var _proto = SimpleSet.prototype;
            return _proto.add = function add(x) {
                this._hashes[x] = !0;
            }
            /**
   * Remove an hash entry from the set.
   * Do not have any effect on already-removed or inexistant hashes
   * @param {string|number} x
   */ , _proto.remove = function remove(x) {
                delete this._hashes[x];
            }
            /**
   * Test if the given hash has an entry in the set.
   * @param {string|number} x
   * @returns {boolean}
   */ , _proto.test = function test(x) {
                return !!this._hashes[x];
            }
            /**
   * Returns true if there's currently no hash in this set.
   * @returns {boolean}
   */ , _proto.isEmpty = function isEmpty() {
                return !Object.keys(this._hashes).length;
            }, SimpleSet;
        }();
        /***/    }, 
    /* 63 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return getBox;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() {
            return getBoxContent;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() {
            return getBoxOffsets;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() {
            return getUuidContent;
        });
        /* harmony import */ var _utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Returns the content of a box based on its name.
 * `null` if not found.
 * /!\ does not work with UUID boxes
 * @param {Uint8Array} buf - the isobmff structure
 * @param {Number} boxName - the 4-letter 'name' of the box (e.g. 'sidx' or
 * 'moov'), hexa encoded
 * @returns {UInt8Array|null}
 */        function getBoxContent(buf, boxName) {
            var offsets = getBoxOffsets(buf, boxName);
            return null != offsets ? buf.subarray(offsets[0] + 8, offsets[1]) : null;
        }
        /**
 * Returns an ISOBMFF box based on its name.
 * `null` if not found.
 * /!\ does not work with UUID boxes
 * @param {Uint8Array} buf - the isobmff structure
 * @param {Number} boxName - the 4-letter 'name' of the box (e.g. 'sidx' or
 * 'moov'), hexa encoded
 * @returns {UInt8Array|null}
 */        function getBox(buf, boxName) {
            var offsets = getBoxOffsets(buf, boxName);
            return null != offsets ? buf.subarray(offsets[0], offsets[1]) : null;
        }
        /**
 * Returns start and end offset for a given box.
 * `null` if not found.
 * /!\ does not work with UUID boxes
 * @param {Uint8Array} buf - the isobmff structure
 * @param {Number} boxName - the 4-letter 'name' of the box (e.g. 'sidx' or
 * 'moov'), hexa encoded
 * @returns {Array.<number>|null}
 */        function getBoxOffsets(buf, boxName) {
            for (var name, l = buf.length, i = 0, size = 0; i + 8 < l; ) {
                if (size = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__.c)(buf, i), name = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__.c)(buf, i + 4), 
                size <= 0) throw new Error("ISOBMFF: Size out of range");
                if (name === boxName) break;
                i += size;
            }
            return i < l ? [ i, i + size ] : null;
        }
        /**
 * Gives the content of a specific UUID with its attached ID
 * @param {Uint8Array} buf
 * @param {Number} id1
 * @param {Number} id2
 * @param {Number} id3
 * @param {Number} id4
 * @returns {Uint8Array|undefined}
 */        function getUuidContent(buf, id1, id2, id3, id4) {
            for (var len, l = buf.length, i = 0; i < l; i += len) if (len = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__.c)(buf, i), 
            1970628964
            /* === "uuid" */ === Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__.c)(buf, i + 4) && Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__.c)(buf, i + 8) === id1 && Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__.c)(buf, i + 12) === id2 && Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__.c)(buf, i + 16) === id3 && Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__.c)(buf, i + 20) === id4) return buf.subarray(i + 24, i + len);
        }
        /***/    }, 
    /* 64 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony import */        var _normalize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(78);
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /* harmony default export */        __webpack_exports__.a = _normalize__WEBPACK_IMPORTED_MODULE_0__.a;
    }, 
    /* 65 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Returns the parent elements which have the given tagName, by order of
 * closeness relative to our element.
 * @param {Element|Node} element
 * @param {string} tagName
 * @returns {Array.<Element>}
 */
        function getParentElementsByTagName(element, tagName) {
            if (!(element.parentNode instanceof Element)) return [];
            return function constructArray(_element) {
                var elements = [];
                _element.tagName.toLowerCase() === tagName.toLowerCase() && elements.push(_element);
                var parentNode = _element.parentNode;
                return parentNode instanceof Element && elements.push.apply(elements, constructArray(parentNode)), 
                elements;
            }(element.parentNode);
        }
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return getParentElementsByTagName;
        });
    }, 
    /* 66 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // EXTERNAL MODULE: ./node_modules/next-tick/index.js
                var next_tick = __webpack_require__(60), next_tick_default = /* */ __webpack_require__.n(next_tick), of = __webpack_require__(30), event_emitter = __webpack_require__(33), rx_try_catch = __webpack_require__(43), ranges = __webpack_require__(13), time_ranges_ManualTimeRanges = 
        /* */
        function() {
            function ManualTimeRanges() {
                this._ranges = [], this.length = 0;
            }
            var _proto = ManualTimeRanges.prototype;
            return _proto.insert = function insert(start, end) {
                Object(ranges.h)(this._ranges, {
                    start: start,
                    end: end
                }), this.length = this._ranges.length;
            }, _proto.remove = function remove(start, end) {
                var rangesToIntersect = [];
                0 < start && rangesToIntersect.push({
                    start: 0,
                    end: start
                }), end < Infinity && rangesToIntersect.push({
                    start: end,
                    end: Infinity
                }), this._ranges = Object(ranges.j)(this._ranges, rangesToIntersect), this.length = this._ranges.length;
            }, _proto.start = function start(index) {
                if (index >= this._ranges.length) throw new Error("INDEX_SIZE_ERROR");
                return this._ranges[index].start;
            }, _proto.end = function end(index) {
                if (index >= this._ranges.length) throw new Error("INDEX_SIZE_ERROR");
                return this._ranges[index].end;
            }, ManualTimeRanges;
        }();
        function _inheritsLoose(subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype), (subClass.prototype.constructor = subClass).__proto__ = superClass;
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Abstract class for a custom SourceBuffer implementation.
 * @class AbstractSourceBuffer
 * @extends EventEmitter
 */        
        // CONCATENATED MODULE: ./src/core/source_buffers/abstract_source_buffer.ts
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return abstract_source_buffer_AbstractSourceBuffer;
        });
        var abstract_source_buffer_AbstractSourceBuffer = 
        /* */
        function(_EventEmitter) {
            function AbstractSourceBuffer() {
                var _this;
                return (_this = _EventEmitter.call(this) || this).updating = !1, _this.readyState = "opened", 
                _this.buffered = new time_ranges_ManualTimeRanges(), _this.timestampOffset = 0, 
                _this;
            }
            /**
   * Mimic the SourceBuffer _appendBuffer_ method: Append a segment to the
   * buffer.
   * @param {*} data
   */            _inheritsLoose(AbstractSourceBuffer, _EventEmitter);
            var _proto = AbstractSourceBuffer.prototype;
            return _proto.appendBuffer = function appendBuffer(data) {
                var _this2 = this;
                this._lock(function() {
                    return _this2._append(data);
                });
            }
            /**
   * Mimic the SourceBuffer _remove_ method: remove buffered segments.
   * @param {Number} from
   * @param {Number} to
   */ , _proto.remove = function remove(from, to) {
                var _this3 = this;
                this._lock(function() {
                    return _this3._remove(from, to);
                });
            }
            /**
   * Mimic the SourceBuffer _abort_ method.
   */ , _proto.abort = function abort() {
                this.updating = !1, this.readyState = "closed", this._abort();
            }
            /**
   * Active a lock, execute the given function, unlock when finished (on
   * nextTick).
   * Throws if multiple lock are active at the same time.
   * Also triggers the right events on start, error and end
   * @param {Function} func
   */ , _proto._lock = function _lock(func) {
                var _this4 = this;
                if (this.updating) throw new Error("SourceBuffer: SourceBuffer already updating.");
                this.updating = !0, this.trigger("updatestart", void 0), Object(rx_try_catch.a)(function() {
                    return func(), Object(of.a)(void 0);
                }, void 0).subscribe(function() {
                    return next_tick_default()(function() {
                        _this4.updating = !1, _this4.trigger("update", void 0), _this4.trigger("updateend", void 0);
                    });
                }, function(e) {
                    return next_tick_default()(function() {
                        _this4.updating = !1, _this4.trigger("error", e), _this4.trigger("updateend", void 0);
                    });
                });
            }, AbstractSourceBuffer;
        }(event_emitter.a);
        /***/    }, 
    /* 67 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js
                var tslib_es6 = __webpack_require__(3), Scheduler = /* */ function() {
            function Scheduler(SchedulerAction, now) {
                void 0 === now && (now = Scheduler.now), this.SchedulerAction = SchedulerAction, 
                this.now = now;
            }
            return Scheduler.prototype.schedule = function(work, delay, state) {
                return void 0 === delay && (delay = 0), new this.SchedulerAction(this, work).schedule(state, delay);
            }, Scheduler.now = function() {
                return Date.now();
            }, Scheduler;
        }();
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/Scheduler.js
                //# sourceMappingURL=Scheduler.js.map
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/scheduler/AsyncScheduler.js
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return AsyncScheduler_AsyncScheduler;
        });
        /** PURE_IMPORTS_START tslib,_Scheduler PURE_IMPORTS_END */
        var AsyncScheduler_AsyncScheduler = /* */ function(_super) {
            function AsyncScheduler(SchedulerAction, now) {
                void 0 === now && (now = Scheduler.now);
                var _this = _super.call(this, SchedulerAction, function() {
                    return AsyncScheduler.delegate && AsyncScheduler.delegate !== _this ? AsyncScheduler.delegate.now() : now();
                }) || this;
                return _this.actions = [], _this.active = !1, _this.scheduled = void 0, _this;
            }
            return tslib_es6.a(AsyncScheduler, _super), AsyncScheduler.prototype.schedule = function(work, delay, state) {
                return void 0 === delay && (delay = 0), AsyncScheduler.delegate && AsyncScheduler.delegate !== this ? AsyncScheduler.delegate.schedule(work, delay, state) : _super.prototype.schedule.call(this, work, delay, state);
            }, AsyncScheduler.prototype.flush = function(action) {
                var actions = this.actions;
                if (this.active) actions.push(action); else {
                    var error;
                    this.active = !0;
                    do {
                        if (error = action.execute(action.state, action.delay)) break;
                    } while (action = actions.shift());
                    if (this.active = !1, error) {
                        for (;action = actions.shift(); ) action.unsubscribe();
                        throw error;
                    }
                }
            }, AsyncScheduler;
        }(Scheduler);
        //# sourceMappingURL=AsyncScheduler.js.map
        /***/    }, 
    /* 68 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js
                var tslib_es6 = __webpack_require__(3), Action_Action = /* */ function(_super) {
            function Action(scheduler, work) {
                return _super.call(this) || this;
            }
            return tslib_es6.a(Action, _super), Action.prototype.schedule = function(state, delay) {
                return void 0 === delay && (delay = 0), this;
            }, Action;
        }(__webpack_require__(14).a);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subscription.js + 1 modules
                //# sourceMappingURL=Action.js.map
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/scheduler/AsyncAction.js
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return AsyncAction_AsyncAction;
        });
        /** PURE_IMPORTS_START tslib,_Action PURE_IMPORTS_END */
        var AsyncAction_AsyncAction = /* */ function(_super) {
            function AsyncAction(scheduler, work) {
                var _this = _super.call(this, scheduler, work) || this;
                return _this.scheduler = scheduler, _this.work = work, _this.pending = !1, _this;
            }
            return tslib_es6.a(AsyncAction, _super), AsyncAction.prototype.schedule = function(state, delay) {
                if (void 0 === delay && (delay = 0), this.closed) return this;
                this.state = state;
                var id = this.id, scheduler = this.scheduler;
                return null != id && (this.id = this.recycleAsyncId(scheduler, id, delay)), this.pending = !0, 
                this.delay = delay, this.id = this.id || this.requestAsyncId(scheduler, this.id, delay), 
                this;
            }, AsyncAction.prototype.requestAsyncId = function(scheduler, id, delay) {
                return void 0 === delay && (delay = 0), setInterval(scheduler.flush.bind(scheduler, this), delay);
            }, AsyncAction.prototype.recycleAsyncId = function(scheduler, id, delay) {
                if (void 0 === delay && (delay = 0), null !== delay && this.delay === delay && !1 === this.pending) return id;
                clearInterval(id);
            }, AsyncAction.prototype.execute = function(state, delay) {
                if (this.closed) return new Error("executing a cancelled action");
                this.pending = !1;
                var error = this._execute(state, delay);
                if (error) return error;
                !1 === this.pending && null != this.id && (this.id = this.recycleAsyncId(this.scheduler, this.id, null));
            }, AsyncAction.prototype._execute = function(state, delay) {
                var errored = !1, errorValue = void 0;
                try {
                    this.work(state);
                } catch (e) {
                    errored = !0, errorValue = !!e && e || new Error(e);
                }
                if (errored) return this.unsubscribe(), errorValue;
            }, AsyncAction.prototype._unsubscribe = function() {
                var id = this.id, scheduler = this.scheduler, actions = scheduler.actions, index = actions.indexOf(this);
                this.work = null, this.state = null, this.pending = !1, this.scheduler = null, -1 !== index && actions.splice(index, 1), 
                null != id && (this.id = this.recycleAsyncId(scheduler, id, null)), this.delay = null;
            }, AsyncAction;
        }(Action_Action);
        //# sourceMappingURL=AsyncAction.js.map
        /***/    }, 
    /* 69 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return empty;
        });
        /* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(35), _util_hostReportError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(54), empty = {
            closed: !0,
            next: function(value) {},
            error: function(err) {
                if (_config__WEBPACK_IMPORTED_MODULE_0__.a.useDeprecatedSynchronousErrorHandling) throw err;
                Object(_util_hostReportError__WEBPACK_IMPORTED_MODULE_1__.a)(err);
            },
            complete: function() {}
        };
        /* harmony import */    }, 
    /* 70 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/defer.js
                var defer = __webpack_require__(168), empty = __webpack_require__(38), combineLatest = __webpack_require__(179), merge = __webpack_require__(112), concat = __webpack_require__(76), of = __webpack_require__(30), ignoreElements = __webpack_require__(170), shareReplay = __webpack_require__(141), mapTo = __webpack_require__(140), mergeMap = __webpack_require__(39), map = __webpack_require__(34), tap = __webpack_require__(123), catchError = __webpack_require__(171), filter = __webpack_require__(139), compat = __webpack_require__(7), should_unset_media_keys = __webpack_require__(126), log = __webpack_require__(0), byte_parsing = __webpack_require__(1), cast_to_observable = __webpack_require__(17), browser_detection = __webpack_require__(20), PSSH_TO_INTEGER = Object(byte_parsing.c)(Object(byte_parsing.p)("pssh"), 0);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/empty.js
                // CONCATENATED MODULE: ./src/compat/eme/generate_key_request.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Some browsers have problems when the CENC PSSH box is the first managed PSSH
 * encountered (for the moment just Edge was noted with this behavior).
 *
 * This function tries to move CENC PSSH boxes at the end of the given init
 * data.
 *
 * If the initData is unrecognized or if a CENC PSSH is not found, this function
 * throws.
 * @param {Uint8Array} initData
 * @returns {Uint8Array}
 */
        function patchInitData(initData) {
            var initialLength = initData.byteLength;
            log.a.info("Compat: Trying to move CENC PSSH from init data at the end of it.");
            for (var cencs = new Uint8Array(), resInitData = new Uint8Array(), offset = 0; offset < initData.length; ) {
                if (initData.length < offset + 8 || Object(byte_parsing.c)(initData, offset + 4) !== PSSH_TO_INTEGER) throw log.a.warn("Compat: unrecognized initialization data. Cannot patch it."), 
                new Error("Compat: unrecognized initialization data. Cannot patch it.");
                var len = Object(byte_parsing.c)(new Uint8Array(initData), offset);
                if (offset + len > initData.length) throw log.a.warn("Compat: unrecognized initialization data. Cannot patch it."), 
                new Error("Compat: unrecognized initialization data. Cannot patch it.");
                var currentPSSH = initData.subarray(offset, offset + len);
                // yep
                16 === initData[offset + 12] && 119 === initData[offset + 13] && 239 === initData[offset + 14] && 236 === initData[offset + 15] && 192 === initData[offset + 16] && 178 === initData[offset + 17] && 77 === initData[offset + 18] && 2 === initData[offset + 19] && 172 === initData[offset + 20] && 227 === initData[offset + 21] && 60 === initData[offset + 22] && 30 === initData[offset + 23] && 82 === initData[offset + 24] && 226 === initData[offset + 25] && 251 === initData[offset + 26] && 75 === initData[offset + 27] ? (log.a.info("Compat: CENC PSSH found."), 
                cencs = Object(byte_parsing.h)(cencs, currentPSSH)) : resInitData = Object(byte_parsing.h)(resInitData, currentPSSH), 
                offset += len;
            }
            if (offset !== initData.length) throw log.a.warn("Compat: unrecognized initialization data. Cannot patch it."), 
            new Error("Compat: unrecognized initialization data. Cannot patch it.");
            if (resInitData.byteLength === initialLength) throw log.a.warn("Compat: CENC PSSH not found. Cannot patch it"), 
            new Error("Compat: unrecognized initialization data. Cannot patch it.");
            return Object(byte_parsing.h)(resInitData, cencs);
        }
        /**
 * Generate a request from session.
 * @param {MediaKeySession} session
 * @param {Uint8Array} initData
 * @param {string} initDataType
 * @param {string} sessionType
 * @returns {Observable}
 */        function generateKeyRequest(session, initData, initDataType) {
            return Object(defer.a)(function() {
                var patchedInit;
                if (log.a.debug("Compat: Calling generateRequest on the MediaKeySession"), browser_detection.c) try {
                    patchedInit = patchInitData(initData);
                } catch (_e) {
                    patchedInit = initData;
                } else patchedInit = initData;
                return Object(cast_to_observable.a)(session.generateRequest(initDataType || "", patchedInit));
            });
        }
        // EXTERNAL MODULE: ./src/errors/encrypted_media_error.ts
                var encrypted_media_error = __webpack_require__(122), noop = __webpack_require__(27), mergeMapTo = __webpack_require__(169), custom_media_keys = __webpack_require__(121);
        // EXTERNAL MODULE: ./src/utils/noop.ts
                // CONCATENATED MODULE: ./src/compat/eme/set_media_keys.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Set the MediaKeys given on the media element.
 * @param {HTMLMediaElement} elt
 * @param {Object} mediaKeys
 * @returns {*}
 */
        function _setMediaKeys(elt, mediaKeys) {
            return mediaKeys instanceof custom_media_keys.b ? mediaKeys._setVideo(elt) : elt.setMediaKeys ? elt.setMediaKeys(mediaKeys) : null !== mediaKeys ? elt.WebkitSetMediaKeys ? elt.WebkitSetMediaKeys(mediaKeys) : elt.mozSetMediaKeys ? elt.mozSetMediaKeys(mediaKeys) : elt.msSetMediaKeys ? elt.msSetMediaKeys(mediaKeys) : void 0 : void 0;
        }
        /**
 * Set the given MediaKeys on the given HTMLMediaElement.
 * Emits null when done then complete.
 * @param {HTMLMediaElement} elt
 * @param {Object} mediaKeys
 * @returns {Observable}
 */        function setMediaKeys$(elt, mediaKeys) {
            return Object(defer.a)(function() {
                return Object(cast_to_observable.a)(_setMediaKeys(elt, mediaKeys));
            });
        }
        // CONCATENATED MODULE: ./src/core/eme/dispose_media_keys.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {Object} mediaKeysInfos
 * @returns {Observable}
 */        function disposeMediaKeys(mediaElement, mediaKeysInfos) {
            return Object(defer.a)(function() {
                var currentState = mediaKeysInfos.getState(mediaElement);
                if (!currentState) return Object(of.a)(null);
                log.a.debug("EME: Disposing of the current MediaKeys");
                var sessionsStore = currentState.sessionsStore;
                return mediaKeysInfos.clearState(mediaElement), sessionsStore.closeAllSessions().pipe(Object(mergeMapTo.a)(setMediaKeys$(mediaElement, null)));
            });
        }
        // CONCATENATED MODULE: ./src/utils/hash_buffer.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Convert given buffer to a 32bit integer hash
 * @param {Array.<number>|TypedArray} buffer
 * @returns {number}
 */        function hashBuffer(buffer) {
            for (var hash = 0, i = 0; i < buffer.length; i++) hash = (hash << 5) - hash + buffer[i], 
            hash &= hash;
            return hash;
        }
        // EXTERNAL MODULE: ./src/utils/simple_set.ts
                var simple_set = __webpack_require__(62);
        // CONCATENATED MODULE: ./src/compat/eme/get_init_data.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * As we observed on some browsers (IE and Edge), the initialization data on
 * some segments have sometimes duplicated PSSH when sent through an encrypted
 * event (but not when pushed to the SourceBuffer).
 *
 * This function tries to guess if the initialization data contains only PSSHs
 * concatenated (as it is usually the case).
 * If that's the case, it will filter duplicated PSSHs from it.
 *
 * @param {Uint8Array} initData
 * @returns {Uint8Array}
 */        function cleanEncryptedEvent(initData) {
            for (var resInitData = new Uint8Array(), currentHashes = new simple_set.a(), offset = 0; offset < initData.length; ) {
                if (initData.length < offset + 8 || Object(byte_parsing.c)(initData, offset + 4) !== PSSH_TO_INTEGER) return log.a.warn("Compat: Unrecognized initialization data. Use as is."), 
                initData;
                var len = Object(byte_parsing.c)(new Uint8Array(initData), offset);
                if (offset + len > initData.length) return log.a.warn("Compat: Unrecognized initialization data. Use as is."), 
                initData;
                var currentPSSH = initData.subarray(offset, offset + len), currentPSSHHash = hashBuffer(currentPSSH);
                currentHashes.test(currentPSSHHash) ? log.a.warn("Compat: Duplicated PSSH found in initialization data, removing it.") : (currentHashes.add(currentPSSHHash), 
                resInitData = Object(byte_parsing.h)(resInitData, currentPSSH)), offset += len;
            }
            return offset !== initData.length ? (log.a.warn("Compat: Unrecognized initialization data. Use as is."), 
            initData) : resInitData;
        }
        /**
 * Take out the two things we need on an encryptedEvent:
 *   - the initialization Data
 *   - the initialization Data type
 *
 * @param {MediaEncryptedEvent} encryptedEvent
 * @returns {Object}
 * @throws {EncryptedMediaError} - Throws if no initialization data is
 * encountered in the given event.
 */        function getInitData(encryptedEvent) {
            var initData = encryptedEvent.initData;
            if (null == initData) throw new encrypted_media_error.a("INVALID_ENCRYPTED_EVENT", "Compat: No init data found on media encrypted event.", !0);
            return {
                initData: cleanEncryptedEvent(new Uint8Array(initData)),
                initDataType: encryptedEvent.initDataType
            };
        }
        // EXTERNAL MODULE: ./src/config.ts
                var config = __webpack_require__(2), array_includes = __webpack_require__(12);
        // EXTERNAL MODULE: ./src/utils/array_includes.ts
                // CONCATENATED MODULE: ./src/core/eme/utils/is_session_usable.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * If all key statuses attached to session are valid (either not
 * "expired" or "internal-error"), return true.
 * If not, return false.
 * @param {Uint8Array} initData
 * @param {MediaKeySession} loadedSession
 * @returns {MediaKeySession}
 */
        function isSessionUsable(loadedSession) {
            if ("" === loadedSession.sessionId) return !1;
 // TODO TypeScript f*cked something up, normally there should be no need to
            // add this "as".
                        var keyStatusesMap = loadedSession.keyStatuses, keyStatuses = [];
            return keyStatusesMap.forEach(function(keyStatus) {
                keyStatuses.push(keyStatus);
            }), 0 < keyStatuses.length && !Object(array_includes.a)(keyStatuses, "expired") && !Object(array_includes.a)(keyStatuses, "internal-error") && (log.a.debug("EME: Reuse loaded session", loadedSession.sessionId), 
            !0);
        }
        // CONCATENATED MODULE: ./src/core/eme/create_session.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * If session creating fails, retry once session creation/loading.
 * Emit true, if it has succeeded to load, false if there is no data for the
 * given sessionId.
 * @param {string} sessionId
 * @param {MediaKeySession} session
 * @returns {Observable}
 */        function loadPersistentSession(sessionId, session) {
            return Object(defer.a)(function() {
                return log.a.debug("EME: Load persisted session", sessionId), Object(cast_to_observable.a)(session.load(sessionId));
            });
        }
        /**
 * Create a new Session on the given MediaKeys, corresponding to the given
 * initializationData.
 * If session creating fails, remove the oldest MediaKeySession loaded and
 * retry.
 *
 * /!\ This only creates new sessions.
 * It will fail if sessionsStore already has a MediaKeySession with
 * the given initializationData.
 * @param {Uint8Array} initData
 * @param {string|undefined} initDataType
 * @param {Object} mediaKeysInfos
 * @returns {Observable}
 */        function create_session_createSession(initData, initDataType, mediaKeysInfos) {
            return Object(defer.a)(function() {
                var keySystemOptions = mediaKeysInfos.keySystemOptions, mediaKeySystemAccess = mediaKeysInfos.mediaKeySystemAccess, sessionsStore = mediaKeysInfos.sessionsStore, sessionStorage = mediaKeysInfos.sessionStorage, sessionTypes = mediaKeySystemAccess.getConfiguration().sessionTypes, hasPersistence = sessionTypes && Object(array_includes.a)(sessionTypes, "persistent-license"), sessionType = hasPersistence && sessionStorage && keySystemOptions.persistentLicense ? "persistent-license" : "temporary";
                log.a.debug("EME: Create a new " + sessionType + " session");
                var session = sessionsStore.createSession(initData, initDataType, sessionType);
 // Re-check for Dumb typescript
                                if (!hasPersistence || !sessionStorage || !keySystemOptions.persistentLicense) return Object(of.a)({
                    type: "created-session",
                    value: {
                        mediaKeySession: session,
                        sessionType: sessionType
                    }
                });
                var storedEntry = sessionStorage.get(initData, initDataType);
                if (!storedEntry) return Object(of.a)({
                    type: "created-session",
                    value: {
                        mediaKeySession: session,
                        sessionType: sessionType
                    }
                });
                /**
     * Helper function to close and restart the current persistent session
     * considered, and re-create it from scratch.
     * @returns {Observable}
     */                var recreatePersistentSession = function recreatePersistentSession() {
                    return log.a.info("EME: Removing previous persistent session."), null !== sessionStorage.get(initData, initDataType) && sessionStorage.delete(initData, initDataType), 
                    sessionsStore.deleteAndCloseSession(session).pipe(Object(map.a)(function() {
                        return {
                            type: "created-session",
                            value: {
                                mediaKeySession: sessionsStore.createSession(initData, initDataType, sessionType),
                                sessionType: sessionType
                            }
                        };
                    }));
                };
                return loadPersistentSession(storedEntry.sessionId, session).pipe(Object(mergeMap.a)(function(hasLoadedSession) {
                    return hasLoadedSession ? hasLoadedSession && isSessionUsable(session) ? (sessionStorage.add(initData, initDataType, session), 
                    log.a.info("EME: Succeeded to load persistent session."), Object(of.a)({
                        type: "loaded-persistent-session",
                        value: {
                            mediaKeySession: session,
                            sessionType: sessionType
                        }
                    })) : (// Unusable persistent session: recreate a new session from scratch.
                    log.a.warn("EME: Previous persistent session not usable anymore."), recreatePersistentSession()) : (log.a.warn("EME: No data stored for the loaded session"), 
                    sessionStorage.delete(initData, initDataType), Object(of.a)({
                        type: "created-session",
                        value: {
                            mediaKeySession: session,
                            sessionType: sessionType
                        }
                    }));
                }), Object(catchError.a)(function() {
                    return log.a.warn("EME: Unable to load persistent session."), recreatePersistentSession();
                }));
            });
        }
        // CONCATENATED MODULE: ./src/core/eme/get_session.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        var MAX_SESSIONS = config.a.EME_MAX_SIMULTANEOUS_MEDIA_KEY_SESSIONS;
        /**
 * Handle MediaEncryptedEvents sent by a HTMLMediaElement:
 * Either create a session, skip the event if it is already handled or
 * recuperate a previous session and returns it.
 * @param {Event} encryptedEvent
 * @param {Object} handledInitData
 * @param {Object} mediaKeysInfos
 * @returns {Observable}
 */        function getSession(encryptedEvent, handledInitData, mediaKeysInfos) {
            return Object(defer.a)(function() {
                var _getInitData = getInitData(encryptedEvent), initData = _getInitData.initData, initDataType = _getInitData.initDataType;
                if (handledInitData.has(initData, initDataType)) return log.a.debug("EME: Init data already received. Skipping it."), 
                empty.a;
 // Already handled, quit
                                handledInitData.add(initData, initDataType);
                // possible previous loaded session with the same initialization data
                var previousLoadedSession = null, sessionsStore = mediaKeysInfos.sessionsStore, entry = sessionsStore.get(initData, initDataType);
                if (null != entry) {
                    if (isSessionUsable(previousLoadedSession = entry.session)) return log.a.debug("EME: Reuse loaded session", previousLoadedSession.sessionId), 
                    Object(of.a)({
                        type: "loaded-open-session",
                        value: {
                            mediaKeySession: previousLoadedSession,
                            sessionType: entry.sessionType,
                            initData: initData,
                            initDataType: initDataType
                        }
                    });
                    mediaKeysInfos.sessionStorage && mediaKeysInfos.sessionStorage.delete(new Uint8Array(initData), initDataType);
                }
                return (previousLoadedSession ? sessionsStore.deleteAndCloseSession(previousLoadedSession) : Object(of.a)(null)).pipe(Object(mergeMap.a)(function() {
                    var cleaningOldSessions$ = [], entries = sessionsStore.getAll().slice();
                    if (0 < MAX_SESSIONS && MAX_SESSIONS <= entries.length) for (var i = 0; i < MAX_SESSIONS - entries.length + 1; i++) cleaningOldSessions$.push(sessionsStore.deleteAndCloseSession(entries[i].session));
                    return Object(concat.a)(merge.a.apply(void 0, cleaningOldSessions$).pipe(Object(ignoreElements.a)()), create_session_createSession(initData, initDataType, mediaKeysInfos).pipe(Object(map.a)(function(evt) {
                        return {
                            type: evt.type,
                            value: {
                                mediaKeySession: evt.value.mediaKeySession,
                                sessionType: evt.value.sessionType,
                                initData: initData,
                                initDataType: initDataType
                            }
                        };
                    })));
                }));
            });
        }
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subject.js
                var Subject = __webpack_require__(42);
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/util/TimeoutError.js
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */        function TimeoutErrorImpl() {
            return Error.call(this), this.message = "Timeout has occurred", this.name = "TimeoutError", 
            this;
        }
        TimeoutErrorImpl.prototype = /* */ Object.create(Error.prototype);
        var TimeoutError = TimeoutErrorImpl, scheduler_async = __webpack_require__(41), tslib_es6 = __webpack_require__(3);
        //# sourceMappingURL=TimeoutError.js.map
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/scheduler/async.js
                // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/util/isDate.js
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        function isDate(value) {
            return value instanceof Date && !isNaN(+value);
        }
        //# sourceMappingURL=isDate.js.map
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/OuterSubscriber.js
                var OuterSubscriber = __webpack_require__(25), subscribeToResult = __webpack_require__(24);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/subscribeToResult.js
                // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/timeoutWith.js
        /** PURE_IMPORTS_START tslib,_scheduler_async,_util_isDate,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
        function timeoutWith(due, withObservable, scheduler) {
            return void 0 === scheduler && (scheduler = scheduler_async.a), function(source) {
                var absoluteTimeout = isDate(due), waitFor = absoluteTimeout ? +due - scheduler.now() : Math.abs(due);
                return source.lift(new TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler));
            };
        }
        var TimeoutWithOperator = /* */ function() {
            function TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler) {
                this.waitFor = waitFor, this.absoluteTimeout = absoluteTimeout, this.withObservable = withObservable, 
                this.scheduler = scheduler;
            }
            return TimeoutWithOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new timeoutWith_TimeoutWithSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));
            }, TimeoutWithOperator;
        }(), timeoutWith_TimeoutWithSubscriber = /* */ function(_super) {
            function TimeoutWithSubscriber(destination, absoluteTimeout, waitFor, withObservable, scheduler) {
                var _this = _super.call(this, destination) || this;
                return _this.absoluteTimeout = absoluteTimeout, _this.waitFor = waitFor, _this.withObservable = withObservable, 
                _this.scheduler = scheduler, _this.action = null, _this.scheduleTimeout(), _this;
            }
            return tslib_es6.a(TimeoutWithSubscriber, _super), TimeoutWithSubscriber.dispatchTimeout = function(subscriber) {
                var withObservable = subscriber.withObservable;
                subscriber._unsubscribeAndRecycle(), subscriber.add(Object(subscribeToResult.a)(subscriber, withObservable));
            }, TimeoutWithSubscriber.prototype.scheduleTimeout = function() {
                var action = this.action;
                action ? this.action = action.schedule(this, this.waitFor) : this.add(this.action = this.scheduler.schedule(TimeoutWithSubscriber.dispatchTimeout, this.waitFor, this));
            }, TimeoutWithSubscriber.prototype._next = function(value) {
                this.absoluteTimeout || this.scheduleTimeout(), _super.prototype._next.call(this, value);
            }, TimeoutWithSubscriber.prototype._unsubscribe = function() {
                this.action = null, this.scheduler = null, this.withObservable = null;
            }, TimeoutWithSubscriber;
        }(OuterSubscriber.a), throwError = __webpack_require__(74);
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/timeout.js
        /** PURE_IMPORTS_START _scheduler_async,_util_TimeoutError,_timeoutWith,_observable_throwError PURE_IMPORTS_END */
        function timeout(due, scheduler) {
            return void 0 === scheduler && (scheduler = scheduler_async.a), timeoutWith(due, Object(throwError.a)(new TimeoutError()), scheduler);
        }
        //# sourceMappingURL=timeout.js.map
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/concatMap.js
        /** PURE_IMPORTS_START _mergeMap PURE_IMPORTS_END */        function concatMap(project, resultSelector) {
            return Object(mergeMap.a)(project, resultSelector, 1);
        }
        //# sourceMappingURL=concatMap.js.map
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/takeUntil.js
                var takeUntil = __webpack_require__(178), is_known_error = __webpack_require__(180), error_codes = __webpack_require__(21), timer = __webpack_require__(181), backoff_delay = __webpack_require__(89);
        // EXTERNAL MODULE: ./src/errors/is_known_error.ts
                // CONCATENATED MODULE: ./src/utils/rx-retry_with_backoff.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Simple debounce implementation.
 * @param {Function} fn
 * @param {Number} delay - delay in ms
 * @returns {Function}
 */
        function debounce(fn, delay) {
            var timer = 0;
            return function() {
                timer && clearTimeout(timer), timer = window.setTimeout(fn, delay);
            };
        }
        /**
 * Retry the given observable (if it triggers an error) with an exponential
 * backoff.
 * The backoff behavior can be tweaked through the options given.
 *
 * @param {Observable} obs$
 * @param {Object} options - Configuration object.
 * This object contains the following properties:
 *
 *   - retryDelay {Number} - The initial delay, in ms.
 *     This delay will be fuzzed to fall under the range +-30% each time a new
 *     retry is done.
 *     Then, this delay will be multiplied by 2^(n-1), n being the counter of
 *     retry we performed (beginning at 1 for the first retry).
 *
 *   - totalRetry {Number} - The amount of time we should retry. 0
 *     means no retry, 1 means a single retry, Infinity means infinite retry
 *     etc.
 *     If the observable still fails after this number of retry, the error will
 *     be throwed through this observable.
 *
 *   - resetDelay {Number|undefined} - Delay in ms since a retry after which the
 *     counter of retry will be reset if the observable wasn't retried a new
 *     time. 0 / undefined means no delay will be applied.
 *
 *   - shouldRetry {Function|undefined} -  Function which will receive the
 *     observable error each time it fails, and should return a boolean. If this
 *     boolean is false, the error will be directly thrown (without anymore
 *     retry).
 *
 *   - onRetry {Function|undefined} - Function which will be triggered at
 *     each retry. Will receive two arguments:
 *       1. The observable error
 *       2. The current retry count, beginning at 1 for the first retry
 *
 *   - errorSelector {Function|undefined} - If and when the observable will
 *     definitely throw (without retrying), this function will be called with
 *     two arguments:
 *       1. The observable error
 *       2. The final retry count, beginning at 1 for the first retry
 *     The returned value will be what will be thrown by the observable.
 *
 * @returns {Observable}
 * TODO Take errorSelector out. Should probably be entirely managed in the
 * calling code via a catch (much simpler to use and to understand).
 */        function retryObsWithBackoff(obs$, options) {
            var debounceRetryCount, retryDelay = options.retryDelay, totalRetry = options.totalRetry, shouldRetry = options.shouldRetry, resetDelay = options.resetDelay, errorSelector = options.errorSelector, onRetry = options.onRetry, retryCount = 0;
            return null != resetDelay && 0 < resetDelay && (debounceRetryCount = debounce(function() {
                retryCount = 0;
            }, resetDelay)), obs$.pipe(Object(catchError.a)(function(error, source) {
                if (!(!shouldRetry || shouldRetry(error)) || retryCount++ >= totalRetry) throw errorSelector ? errorSelector(error, retryCount) : error;
                onRetry && onRetry(error, retryCount);
                var fuzzedDelay = Object(backoff_delay.a)(retryDelay, retryCount);
                return Object(timer.a)(fuzzedDelay).pipe(Object(mergeMap.a)(function() {
                    return debounceRetryCount && debounceRetryCount(), source;
                }));
            }));
        }
        // EXTERNAL MODULE: ./src/utils/rx-try_catch.ts
                var rx_try_catch = __webpack_require__(43), types = __webpack_require__(71), onKeyError$ = compat.a.onKeyError$, onKeyMessage$ = compat.a.onKeyMessage$, onKeyStatusesChange$ = compat.a.onKeyStatusesChange$, KEY_STATUS_EXPIRED = "expired";
        // EXTERNAL MODULE: ./src/core/eme/types.ts
                /**
 * @param {Error|Object} error
 * @param {Boolean} fatal
 * @returns {Error|Object}
 */
        function licenseErrorSelector(error, fatal) {
            return Object(is_known_error.a)(error) && error.type === error_codes.b.ENCRYPTED_MEDIA_ERROR ? (error.fatal = fatal, 
            error) : new encrypted_media_error.a("KEY_LOAD_ERROR", error.toString(), fatal);
        }
        /**
 * listen to "message" events from session containing a challenge
 * blob and map them to licenses using the getLicense method from
 * selected keySystem.
 * @param {MediaKeySession} session
 * @param {Object} keySystem
 * @returns {Observable}
 */        function handleSessionEvents(session, keySystem) {
            log.a.debug("EME: Handle message events", session);
            var sessionWarningSubject$ = new Subject.a(), getLicenseRetryOptions = {
                totalRetry: 2,
                retryDelay: 200,
                errorSelector: function errorSelector(error) {
                    return licenseErrorSelector(error, !0);
                },
                onRetry: function onRetry(error) {
                    return sessionWarningSubject$.next({
                        type: "warning",
                        value: licenseErrorSelector(error, !1)
                    });
                }
            }, keyErrors = onKeyError$(session).pipe(Object(map.a)(function(error) {
                throw new encrypted_media_error.a("KEY_ERROR", error.type, !0);
            })), keyStatusesChanges = onKeyStatusesChange$(session).pipe(Object(mergeMap.a)(function(keyStatusesEvent) {
                log.a.debug("EME: keystatuseschange event", session, keyStatusesEvent);
                // find out possible errors associated with this event
                var warnings = [];
                session.keyStatuses.forEach(function(keyStatus, keyId) {
                    // Hack present because the order of the arguments has changed in spec
                    // and is not the same between some versions of Edge and Chrome.
                    if (keyStatus === KEY_STATUS_EXPIRED || keyId === KEY_STATUS_EXPIRED) {
                        var throwOnLicenseExpiration = keySystem.throwOnLicenseExpiration, error = new encrypted_media_error.a("KEY_STATUS_CHANGE_ERROR", "A decryption key expired", !1);
                        if (!1 !== throwOnLicenseExpiration) throw error;
                        warnings.push({
                            type: "warning",
                            value: error
                        });
                    }
                    if (types.a[keyId]) throw new encrypted_media_error.a("KEY_STATUS_CHANGE_ERROR", "An invalid key status has been encountered: " + keyId, !0);
                    if (types.a[keyStatus]) throw new encrypted_media_error.a("KEY_STATUS_CHANGE_ERROR", "An invalid key status has been encountered: " + keyStatus, !0);
                });
                var warnings$ = warnings.length ? of.a.apply(void 0, warnings) : empty.a, handledKeyStatusesChange$ = Object(rx_try_catch.a)(function() {
                    return keySystem && keySystem.onKeyStatusesChange ? Object(cast_to_observable.a)(keySystem.onKeyStatusesChange(keyStatusesEvent, session)) : empty.a;
                }, void 0).pipe().pipe(Object(catchError.a)(function(error) {
                    throw new encrypted_media_error.a("KEY_STATUS_CHANGE_ERROR", error.toString(), !0);
                }), Object(map.a)(function(licenseObject) {
                    return {
                        type: "key-status-change",
                        value: {
                            license: licenseObject
                        }
                    };
                }));
                return Object(concat.a)(warnings$, handledKeyStatusesChange$);
            })), keyMessages$ = onKeyMessage$(session).pipe(Object(mergeMap.a)(function(messageEvent) {
                var message = new Uint8Array(messageEvent.message), messageType = messageEvent.messageType || "license-request";
                return log.a.debug("EME: Event message type " + messageType, session, messageEvent), 
                retryObsWithBackoff(Object(defer.a)(function() {
                    var getLicense = keySystem.getLicense(message, messageType);
                    return Object(cast_to_observable.a)(getLicense).pipe(timeout(1e4), Object(catchError.a)(function(error) {
                        throw error instanceof TimeoutError ? new encrypted_media_error.a("KEY_LOAD_TIMEOUT", "The license server took more than 10 seconds to respond.", !1) : error;
                    }));
                }), getLicenseRetryOptions).pipe(Object(map.a)(function(license) {
                    return {
                        type: messageType,
                        value: {
                            license: license
                        }
                    };
                }));
            })), sessionUpdates = Object(merge.a)(keyMessages$, keyStatusesChanges).pipe(concatMap(function(evt) {
                if ("warning" === evt.type) return Object(of.a)(evt);
                var license = evt.value.license;
                return null == license ? (log.a.info("EME: No license given, skipping session.update"), 
                empty.a) : (log.a.debug("EME: Update session", evt), Object(cast_to_observable.a)(session.update(license)).pipe(Object(catchError.a)(function(error) {
                    throw new encrypted_media_error.a("KEY_UPDATE_ERROR", error.toString(), !0);
                }), Object(mapTo.a)({
                    type: evt.type,
                    value: {
                        session: session,
                        license: license
                    }
                })));
            })), sessionEvents = Object(merge.a)(sessionUpdates, keyErrors, sessionWarningSubject$);
            return session.closed ? sessionEvents.pipe(Object(takeUntil.a)(Object(cast_to_observable.a)(session.closed))) : sessionEvents;
        }
        // CONCATENATED MODULE: ./src/core/eme/attach_media_keys.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Set the MediaKeys object on the HTMLMediaElement if it is not already on the
 * element.
 * If a MediaKeys was already set on it, dispose of it before setting the new
 * one.
 *
 * /!\ Mutates heavily currentMediaKeysInfos
 * @param {Object} mediaKeysInfos
 * @param {HTMLMediaElement} mediaElement
 * @param {Object} currentMediaKeysInfos
 * @returns {Observable}
 */        function attachMediaKeys(mediaKeysInfos, mediaElement, currentMediaKeysInfos) {
            return Object(defer.a)(function() {
                var previousState = currentMediaKeysInfos.getState(mediaElement), keySystemOptions = mediaKeysInfos.keySystemOptions, mediaKeySystemAccess = mediaKeysInfos.mediaKeySystemAccess, mediaKeys = mediaKeysInfos.mediaKeys, sessionsStore = mediaKeysInfos.sessionsStore;
                return currentMediaKeysInfos.setState(mediaElement, {
                    keySystemOptions: keySystemOptions,
                    mediaKeySystemAccess: mediaKeySystemAccess,
                    mediaKeys: mediaKeys,
                    sessionsStore: sessionsStore
                }), (previousState && previousState.sessionsStore !== sessionsStore ? previousState.sessionsStore.closeAllSessions() : Object(of.a)(null)).pipe(Object(mergeMap.a)(function() {
                    return mediaElement.mediaKeys === mediaKeys ? Object(of.a)(null) : (log.a.debug("EME: Setting MediaKeys"), 
                    setMediaKeys$(mediaElement, mediaKeys));
                }));
            });
        }
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Observable.js + 3 modules
                var Observable = __webpack_require__(6), should_renew_media_keys = __webpack_require__(127), EME_DEFAULT_WIDEVINE_ROBUSTNESSES = config.a.EME_DEFAULT_WIDEVINE_ROBUSTNESSES, EME_KEY_SYSTEMS = config.a.EME_KEY_SYSTEMS;
        // EXTERNAL MODULE: ./src/compat/should_renew_media_keys.ts
                /**
 * @param {Array.<Object>} keySystems
 * @param {Object} currentMediaKeysInfos
 * @returns {null|Object}
 */
        function checkCachedMediaKeySystemAccess(keySystems, currentKeySystemAccess, currentKeySystemOptions) {
            var mksConfiguration = currentKeySystemAccess.getConfiguration();
            if (Object(should_renew_media_keys.a)() || !mksConfiguration) return null;
            var firstCompatibleOption = keySystems.filter(function(ks) {
                // TODO Do it with MediaKeySystemAccess.prototype.keySystem instead
                return ks.type === currentKeySystemOptions.type && ((!ks.persistentLicense || "required" === mksConfiguration.persistentState) && (!ks.distinctiveIdentifierRequired || "required" === mksConfiguration.distinctiveIdentifier));
            })[0];
            return firstCompatibleOption ? {
                keySystemOptions: firstCompatibleOption,
                keySystemAccess: currentKeySystemAccess
            } : null;
        }
        /**
 * Find key system canonical name from key system type.
 * @param {string} ksType - Obtained via inversion
 * @returns {string|undefined} - Either the canonical name, or undefined.
 */        function findKeySystemCanonicalName(ksType) {
            for (var _arr = Object.keys(EME_KEY_SYSTEMS), _i = 0; _i < _arr.length; _i++) {
                var ksName = _arr[_i];
                if (Object(array_includes.a)(EME_KEY_SYSTEMS[ksName], ksType)) return ksName;
            }
        }
        /**
 * Build configuration for the requestMediaKeySystemAccess EME API, based
 * on the current keySystem object.
 * @param {string} [ksName] - Generic name for the key system. e.g. "clearkey",
 * "widevine", "playready". Can be used to make exceptions depending on it.
 * @param {Object} keySystem
 * @returns {Array.<Object>} - Configuration to give to the
 * requestMediaKeySystemAccess API.
 */        function buildKeySystemConfigurations(ksName, keySystem) {
            var sessionTypes = [ "temporary" ], persistentState = "optional", distinctiveIdentifier = "optional";
            keySystem.persistentLicense && (persistentState = "required", sessionTypes.push("persistent-license")), 
            keySystem.persistentStateRequired && (persistentState = "required"), keySystem.distinctiveIdentifierRequired && (distinctiveIdentifier = "required");
            // Set robustness, in order of consideration:
            //   1. the user specified its own robustnesses
            //   2. a "widevine" key system is used, in that case set the default widevine
            //      robustnesses as defined in the config
            //   3. set an undefined robustness
            var videoRobustnesses = keySystem.videoRobustnesses || ("widevine" === ksName ? EME_DEFAULT_WIDEVINE_ROBUSTNESSES : []), audioRobustnesses = keySystem.audioRobustnesses || ("widevine" === ksName ? EME_DEFAULT_WIDEVINE_ROBUSTNESSES : []);
            // TODO Re-test with a set contentType but an undefined robustness on the
            // STBs on which this problem was found.
            //
            // add another with no {audio,video}Capabilities for some legacy browsers.
            // As of today's spec, this should return NotSupported but the first
            // candidate configuration should be good, so we should have no downside
            // doing that.
            // initDataTypes: ["cenc"],
            // videoCapabilities: undefined,
            // audioCapabilities: undefined,
            // distinctiveIdentifier,
            // persistentState,
            // sessionTypes,
            return videoRobustnesses.length || videoRobustnesses.push(void 0), audioRobustnesses.length || audioRobustnesses.push(void 0), 
            [ {
                initDataTypes: [ "cenc" ],
                videoCapabilities: videoRobustnesses.map(function(robustness) {
                    return {
                        contentType: 'video/mp4;codecs="avc1.4d401e"',
                        robustness: robustness
                    };
                }),
                audioCapabilities: audioRobustnesses.map(function(robustness) {
                    return {
                        contentType: 'audio/mp4;codecs="mp4a.40.2"',
                        robustness: robustness
                    };
                }),
                distinctiveIdentifier: distinctiveIdentifier,
                persistentState: persistentState,
                sessionTypes: sessionTypes
            } ];
        }
        /**
 * Try to find a compatible key system from the keySystems array given.
 *
 * Returns an Observable which, when subscribed to, will request a
 * MediaKeySystemAccess based on the various keySystems provided. This
 * Observable will:
 *   - emit the MediaKeySystemAccess and the keySystems as an object, when
 *     found. The object is under this form:
 *     {
 *       keySystemAccess {MediaKeySystemAccess}
 *       keySystem {Object}
 *     }
 *   - complete immediately after emitting.
 *   - throw if no  compatible key system has been found.
 *
 * @param {Array.<Object>} keySystems - The keySystems you want to test.
 * @param {Object} currentMediaKeysInfos
 * @returns {Observable}
 */        function getMediaKeySystemAccess(mediaElement, keySystemsConfigs, currentMediaKeysInfos) {
            return Object(defer.a)(function() {
                var currentState = currentMediaKeysInfos.getState(mediaElement);
                if (currentState) {
                    // Fast way to find a compatible keySystem if the currently loaded
                    // one as exactly the same compatibility options.
                    var cachedKeySystemAccess = checkCachedMediaKeySystemAccess(keySystemsConfigs, currentState.mediaKeySystemAccess, currentState.keySystemOptions);
                    if (cachedKeySystemAccess) return log.a.debug("EME: Found cached compatible keySystem", cachedKeySystemAccess), 
                    Object(of.a)({
                        type: "reuse-media-key-system-access",
                        value: {
                            mediaKeySystemAccess: cachedKeySystemAccess.keySystemAccess,
                            options: cachedKeySystemAccess.keySystemOptions
                        }
                    });
                }
                /**
     * Array of set keySystems for this content.
     * Each item of this array is an object containing the following keys:
     *   - keyName {string}: keySystem canonical name (e.g. "widevine")
     *   - keyType {string}: keySystem type (e.g. "com.widevine.alpha")
     *   - keySystem {Object}: the original keySystem object
     * @type {Array.<Object>}
     */                var keySystemsType = keySystemsConfigs.reduce(function(arr, keySystemOptions) {
                    var ksType, managedRDNs = EME_KEY_SYSTEMS[keySystemOptions.type];
                    null != managedRDNs ? ksType = managedRDNs.map(function(keyType) {
                        return {
                            keyName: keySystemOptions.type,
                            keyType: keyType,
                            keySystemOptions: keySystemOptions
                        };
                    }) : ksType = [ {
                        keyName: findKeySystemCanonicalName(keySystemOptions.type) || "",
                        keyType: keySystemOptions.type,
                        keySystemOptions: keySystemOptions
                    } ];
                    return arr.concat(ksType);
                }, []);
                return new Observable.a(function(obs) {
                    var sub, disposed = !1;
                    /**
       * Test the key system as defined in keySystemsType[index].
       * @param {Number} index
       */
                    return function testKeySystem(index) {
                        // completely quit the loop if unsubscribed
                        if (!disposed) // if we iterated over the whole keySystemsType Array, quit on error
                        if (index >= keySystemsType.length) obs.error(new encrypted_media_error.a("INCOMPATIBLE_KEYSYSTEMS", "No key system compatible with your wanted configuration has been found in the current browser.", !0)); else {
                            var _keySystemsType$index = keySystemsType[index], keyName = _keySystemsType$index.keyName, keyType = _keySystemsType$index.keyType, keySystemOptions = _keySystemsType$index.keySystemOptions, keySystemConfigurations = buildKeySystemConfigurations(keyName, keySystemOptions);
                            if (log.a.debug("EME: Request keysystem access " + keyType + "," + (index + 1) + " of " + keySystemsType.length, keySystemConfigurations), 
                            null == custom_media_keys.c) throw new Error("requestMediaKeySystemAccess is not implemented in your browser.");
                            sub = Object(custom_media_keys.c)(keyType, keySystemConfigurations).subscribe(function(keySystemAccess) {
                                log.a.info("EME: Found compatible keysystem", keyType, keySystemConfigurations), 
                                obs.next({
                                    type: "create-media-key-system-access",
                                    value: {
                                        options: keySystemOptions,
                                        mediaKeySystemAccess: keySystemAccess
                                    }
                                }), obs.complete();
                            }, function() {
                                log.a.debug("EME: Rejected access to keysystem", keyType, keySystemConfigurations), 
                                sub = null, testKeySystem(index + 1);
                            });
                        }
                    }(0), function() {
                        disposed = !0, sub && sub.unsubscribe();
                    };
                });
            });
        }
        // EXTERNAL MODULE: ./src/utils/array_find.ts
                var array_find = __webpack_require__(11), open_sessions_store_MediaKeySessionsStore = 
        /* */
        function() {
            function MediaKeySessionsStore(mediaKeys) {
                this._mediaKeys = mediaKeys, this._entries = [];
            }
            /**
   * @returns {Array.<Object>}
   */            var _proto = MediaKeySessionsStore.prototype;
            return _proto.getAll = function getAll() {
                return this._entries.map(function(entry) {
                    return {
                        session: entry.session,
                        sessionType: entry.sessionType
                    };
                });
            }
            /**
   * Returns an entry in this cache with the initData and initDataType given.
   * null if no such session is stored.
   *
   * @param {Uint8Array} initData
   * @param {string|undefined} initDataType
   * @returns {Object|null}
   */ , _proto.get = function get(initData, initDataType) {
                var initDataHash = hashBuffer(initData), foundEntry = Object(array_find.a)(this._entries, function(entry) {
                    return entry.initData === initDataHash && entry.initDataType === initDataType;
                });
                return foundEntry ? {
                    session: foundEntry.session,
                    sessionType: foundEntry.sessionType
                } : null;
            }
            /**
   * @param {Uint8Array} initData
   * @param {string|undefined} initDataType
   * @param {string} sessionType
   * @returns {MediaKeySession}
   * @throws {EncryptedMediaError}
   */ , _proto.createSession = function createSession(initData, initDataType, sessionType) {
                var _this = this;
                if (this.get(initData, initDataType)) throw new encrypted_media_error.a("MULTIPLE_SESSIONS_SAME_INIT_DATA", "This initialization data was already stored.", !0);
                var session = Object(custom_media_keys.a)(this._mediaKeys, sessionType), entry = {
                    session: session,
                    sessionType: sessionType,
                    initData: hashBuffer(initData),
                    initDataType: initDataType
                };
                return null !== session.closed && session.closed.then(function() {
                    _this._delete(session);
                }).catch(function(e) {
                    log.a.warn("EME-MKSS: session.closed rejected: " + e);
                }), log.a.debug("EME-MKSS: Add session", entry), this._entries.push(entry), session;
            }
            /**
   * Close a MediaKeySession and remove its entry if it's found in the store.
   * @param {MediaKeySession} session
   * @returns {Observable}
   */ , _proto.deleteAndCloseSession = function deleteAndCloseSession(session) {
                var _this2 = this;
                return Object(defer.a)(function() {
                    return _this2._delete(session), log.a.debug("EME-MKSS: Close session", session), 
                    Object(cast_to_observable.a)(session.close()).pipe(Object(catchError.a)(function() {
                        return Object(of.a)(null);
                    }));
                });
            }
            /**
   * Close all sessions in this store.
   * Emit null when done
   * @returns {Observable}
   */ , _proto.closeAllSessions = function closeAllSessions() {
                var _this3 = this;
                return Object(defer.a)(function() {
                    var previousEntries = _this3._entries;
                    _this3._entries = [];
                    // clean completely the cache first
                    var disposed = previousEntries.map(function(entry) {
                        return _this3.deleteAndCloseSession(entry.session);
                    });
                    return Object(concat.a)(merge.a.apply(void 0, disposed).pipe(Object(ignoreElements.a)()), Object(of.a)(null));
                });
            }
            /**
   * Remove a MediaKeySession from the Cache, without closing it.
   * Returns the entry if found, null otherwise.
   * @param {MediaKeySession} session
   * @returns {number} - index of the session in the cache. -1 of not found.
   */ , _proto._delete = function _delete(session) {
                var entry = Object(array_find.a)(this._entries, function(e) {
                    return e.session === session;
                });
                if (!entry) return -1;
                log.a.debug("EME-MKSS: delete session", entry);
                var idx = this._entries.indexOf(entry);
                return this._entries.splice(idx, 1), idx;
            }, MediaKeySessionsStore;
        }(), assert = __webpack_require__(16);
        // CONCATENATED MODULE: ./src/core/eme/utils/open_sessions_store.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Create and store MediaKeySessions linked to a single MediaKeys
 * instance.
 *
 * Keep track of sessionTypes and of the initialization data each
 * MediaKeySession is created for.
 * @class MediaKeySessionsStore
 */        
        // CONCATENATED MODULE: ./src/core/eme/utils/persisted_session_store.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        function checkStorage(storage) {
            Object(assert.a)(storage, {
                save: "function",
                load: "function"
            }, "licenseStorage");
        }
        /**
 * Set representing persisted licenses. Depends on a simple local-
 * storage implementation with a `save`/`load` synchronous interface
 * to persist informations on persisted sessions.
 *
 * This set is used only for a cdm/keysystem with license persistency
 * supported.
 * @class PersistedSessionsStore
 */        var persisted_session_store_PersistedSessionsStore = 
        /* */
        function() {
            /**
   * @param {Object} storage
   */
            function PersistedSessionsStore(storage) {
                checkStorage(storage), this._entries = [], this._storage = storage;
                try {
                    this._entries = this._storage.load(), Array.isArray(this._entries) || (this._entries = []);
                } catch (e) {
                    log.a.warn("EME-PSS: Could not get entries from license storage", e), this.dispose();
                }
            }
            /**
   * Retrieve entry (sessionId + initData) based on its initData.
   * @param {Uint8Array}  initData
   * @param {string|undefined} initDataType
   * @returns {Object|null}
   */            var _proto = PersistedSessionsStore.prototype;
            return _proto.get = function get(initData, initDataType) {
                var hash = hashBuffer(initData);
                return Object(array_find.a)(this._entries, function(e) {
                    return e.initData === hash && e.initDataType === initDataType;
                }) || null;
            }
            /**
   * Add a new entry in the storage.
   * @param {Uint8Array}  initData
   * @param {string|undefined} initDataType
   * @param {MediaKeySession} session
   */ , _proto.add = function add(initData, initDataType, session) {
                var sessionId = session && session.sessionId;
                if (sessionId) {
                    var currentEntry = this.get(initData, initDataType);
                    currentEntry && currentEntry.sessionId === sessionId || (currentEntry && 
                    // currentEntry has a different sessionId
                    this.delete(initData, initDataType), log.a.info("EME-PSS: Add new session", sessionId, session), 
                    this._entries.push({
                        sessionId: sessionId,
                        initData: hashBuffer(initData),
                        initDataType: initDataType
                    }), this._save());
                }
            }
            /**
   * Delete entry (sessionId + initData) based on its initData.
   * @param {Uint8Array}  initData
   * @param {string|undefined} initDataType
   */ , _proto.delete = function _delete(initData, initDataType) {
                var hash = hashBuffer(initData), entry = Object(array_find.a)(this._entries, function(e) {
                    return e.initData === hash && e.initDataType === initDataType;
                });
                if (entry) {
                    log.a.warn("EME-PSS: Delete session from store", entry);
                    var idx = this._entries.indexOf(entry);
                    this._entries.splice(idx, 1), this._save();
                }
            }
            /**
   * Delete all saved entries.
   */ , _proto.dispose = function dispose() {
                this._entries = [], this._save();
            }
            /**
   * Use the given storage to store the current entries.
   */ , _proto._save = function _save() {
                try {
                    this._storage.save(this._entries);
                } catch (e) {
                    log.a.warn("EME-PSS: Could not save licenses in localStorage");
                }
            }, PersistedSessionsStore;
        }();
        // CONCATENATED MODULE: ./src/core/eme/get_media_keys.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {Object} keySystemOptions
 * @returns {Object|null}
 * @throws {EncryptedMediaError}
 */        function createSessionStorage(keySystemOptions) {
            if (!keySystemOptions.persistentLicense) return null;
            var licenseStorage = keySystemOptions.licenseStorage;
            if (!licenseStorage) throw new encrypted_media_error.a("INVALID_KEY_SYSTEM", "No license storage found for persistent license.", !0);
            return log.a.info("EME: Set the given license storage"), new persisted_session_store_PersistedSessionsStore(licenseStorage);
        }
        function getMediaKeysInfos(mediaElement, keySystemsConfigs, currentMediaKeysInfos) {
            return getMediaKeySystemAccess(mediaElement, keySystemsConfigs, currentMediaKeysInfos).pipe(Object(mergeMap.a)(function(evt) {
                var _evt$value = evt.value, options = _evt$value.options, mediaKeySystemAccess = _evt$value.mediaKeySystemAccess, currentState = currentMediaKeysInfos.getState(mediaElement), sessionStorage = createSessionStorage(options);
                if (null == currentState || "reuse-media-key-system-access" !== evt.type) return log.a.debug("EME: Calling createMediaKeys on the MediaKeySystemAccess"), 
                Object(cast_to_observable.a)(mediaKeySystemAccess.createMediaKeys()).pipe(Object(map.a)(function(mediaKeys) {
                    return {
                        mediaKeys: mediaKeys,
                        sessionsStore: new open_sessions_store_MediaKeySessionsStore(mediaKeys),
                        mediaKeySystemAccess: mediaKeySystemAccess,
                        keySystemOptions: options,
                        sessionStorage: sessionStorage
                    };
                }));
                var mediaKeys = currentState.mediaKeys, sessionsStore = currentState.sessionsStore;
                return Object(of.a)({
                    mediaKeys: mediaKeys,
                    sessionsStore: sessionsStore,
                    mediaKeySystemAccess: mediaKeySystemAccess,
                    keySystemOptions: options,
                    sessionStorage: sessionStorage
                });
            }));
        }
        // CONCATENATED MODULE: ./src/core/eme/init_media_keys.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Get media keys infos from key system configs then attach media keys to media element.
 * @param {HTMLMediaElement} mediaElement
 * @param {Array.<Object>} keySystemsConfigs
 * @param {Object} currentMediaKeysInfos
 * @returns {Observable}
 */        function initMediaKeys(mediaElement, keySystemsConfigs, currentMediaKeysInfos) {
            return getMediaKeysInfos(mediaElement, keySystemsConfigs, currentMediaKeysInfos).pipe(Object(mergeMap.a)(function(mediaKeysInfos) {
                return attachMediaKeys(mediaKeysInfos, mediaElement, currentMediaKeysInfos).pipe(Object(mapTo.a)(mediaKeysInfos));
            }));
        }
        // CONCATENATED MODULE: ./src/core/eme/media_keys_infos_store.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Store the MediaKeys infos attached to a media element.
 * @class MediaKeysInfosStore
 */        var MediaKeysInfosStore = 
        /* */
        function() {
            function MediaKeysInfosStore() {
                this._state = new WeakMap();
            }
            var _proto = MediaKeysInfosStore.prototype;
            return _proto.setState = function setState(mediaElement, state) {
                this._state.set(mediaElement, state);
            }, _proto.getState = function getState(mediaElement) {
                return this._state.get(mediaElement) || null;
            }, _proto.clearState = function clearState(mediaElement) {
                this._state.set(mediaElement, null);
            }, MediaKeysInfosStore;
        }();
        // CONCATENATED MODULE: ./src/core/eme/set_server_certificate.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Call the setServerCertificate API with the given certificate.
 * Complete when worked, throw when failed.
 *
 * TODO Manage success?
 * From the spec:
 *   - setServerCertificate resolves with true if everything worked
 *   - it resolves with false if the CDM does not support server
 *     certificates.
 *
 * @param {MediaKeys} mediaKeys
 * @param {ArrayBuffer} serverCertificate
 * @returns {Observable}
 */        function setServerCertificate(mediaKeys, serverCertificate) {
            return Object(defer.a)(function() {
                return Object(cast_to_observable.a)(mediaKeys.setServerCertificate(serverCertificate)).pipe(Object(catchError.a)(function(error) {
                    throw log.a.warn("EME: mediaKeys.setServerCertificate returned an error", error), 
                    new encrypted_media_error.a("LICENSE_SERVER_CERTIFICATE_ERROR", error.toString(), !0);
                }));
            });
        }
        /**
 * Call the setCertificate API. If it fails just emit the error as warning
 * and complete.
 * @param {MediaKeys} mediaKeys
 * @param {ArrayBuffer} serverCertificate
 * @returns {Observable}
 */        function trySettingServerCertificate(mediaKeys, serverCertificate) {
            return "function" == typeof mediaKeys.setServerCertificate ? (log.a.debug("EME: Setting server certificate on the MediaKeys"), 
            setServerCertificate(mediaKeys, serverCertificate).pipe(Object(ignoreElements.a)(), Object(catchError.a)(function(error) {
                return error.fatal = !1, Object(of.a)({
                    type: "warning",
                    value: error
                });
            }))) : (log.a.warn("EME: Could not set the server certificate. mediaKeys.setServerCertificate is not a function"), 
            empty.a);
        }
        // CONCATENATED MODULE: ./src/core/eme/utils/init_data_store.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Memorize initialization data with straightforward methods.
 * @class InitDataStore
 */        var init_data_store_InitDataStore = 
        /* */
        function() {
            function InitDataStore() {
                this._namedTypeData = {}, this._unnamedTypeData = new simple_set.a();
            }
            /**
   * Returns true if this instance has the given initData stored.
   * @param {Uint8Array} initData
   * @param {string|undefined} initDataType
   * @returns {boolean}
   */            var _proto = InitDataStore.prototype;
            return _proto.has = function has(initData, initDataType) {
                return initDataType ? !!this._namedTypeData[initDataType] && this._namedTypeData[initDataType].test(hashBuffer(initData)) : this._unnamedTypeData.test(hashBuffer(initData));
            }
            /**
   * Add initialization data to this memory.
   * @param {Uint8Array} initData
   * @param {string|undefined} initDataType
   */ , _proto.add = function add(initData, initDataType) {
                this.has(initData, initDataType) || (initDataType ? (this._namedTypeData[initDataType] || (this._namedTypeData[initDataType] = new simple_set.a()), 
                this._namedTypeData[initDataType].add(hashBuffer(initData))) : this._unnamedTypeData.add(hashBuffer(initData)));
            }
            /**
   * Remove the initialization data from this memory.
   * Returns true if this instance had the given initData stored.
   * @param {Uint8Array} initData
   * @param {string|undefined} initDataType
   * @returns {boolean}
   */ , _proto.remove = function remove(initData, initDataType) {
                if (initDataType) {
                    if (!this._namedTypeData[initDataType]) return !1;
                    var _hashed = hashBuffer(initData), simpleSet = this._namedTypeData[initDataType];
                    return !!simpleSet.test(_hashed) && (simpleSet.remove(_hashed), !0);
                }
                var hashed = hashBuffer(initData);
                return !!this._unnamedTypeData.test(hashed) && (this._unnamedTypeData.remove(hashed), 
                !0);
            }, InitDataStore;
        }();
        // CONCATENATED MODULE: ./src/core/eme/eme_manager.ts
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "b", function() {
            return EMEManager;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return clearEMESession;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() {
            return disposeEME;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() {
            return getCurrentKeySystem;
        });
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        var onEncrypted$ = compat.a.onEncrypted$, attachedMediaKeysInfos = new MediaKeysInfosStore();
        /**
 * Clear EME ressources that should be cleared when the current content stops
 * its playback.
 * @returns {Observable}
 */
        function clearEMESession(mediaElement) {
            return Object(defer.a)(function() {
                if (Object(should_unset_media_keys.a)()) return disposeMediaKeys(mediaElement, attachedMediaKeysInfos).pipe(Object(ignoreElements.a)());
                var currentState = attachedMediaKeysInfos.getState(mediaElement);
                return currentState && currentState.keySystemOptions.closeSessionsOnStop ? currentState.sessionsStore.closeAllSessions().pipe(Object(ignoreElements.a)()) : empty.a;
            });
        }
        /**
 * EME abstraction and event handler used to communicate with the Content-
 * Description-Module (CDM).
 *
 * The EME handler can be given one or multiple systems and will choose the
 * appropriate one supported by the user's browser.
 * @param {HTMLMediaElement} mediaElement
 * @param {Array.<Object>} keySystems
 * @returns {Observable}
 */        function EMEManager(mediaElement, keySystemsConfigs) {
            // Keep track of all initialization data handled here.
            // This is to avoid handling multiple times the same encrypted events.
            var handledInitData = new init_data_store_InitDataStore(), mediaKeysInfos$ = // store the mediaKeys when ready
            initMediaKeys(mediaElement, keySystemsConfigs, attachedMediaKeysInfos).pipe(Object(shareReplay.a)()), initEvent$ = mediaKeysInfos$.pipe(Object(mapTo.a)({
                type: "eme-init"
            })), startEME$ = Object(combineLatest.a)(onEncrypted$(mediaElement), mediaKeysInfos$).pipe(
            /* Attach server certificate and create/reuse MediaKeySession */
            Object(mergeMap.a)(function(_ref, i) {
                var encryptedEvent = _ref[0], mediaKeysInfos = _ref[1];
                log.a.debug("EME: encrypted event received", encryptedEvent);
                var keySystemOptions = mediaKeysInfos.keySystemOptions, mediaKeys = mediaKeysInfos.mediaKeys, serverCertificate = keySystemOptions.serverCertificate, session$ = getSession(encryptedEvent, handledInitData, mediaKeysInfos).pipe(Object(map.a)(function(evt) {
                    return {
                        type: evt.type,
                        value: {
                            initData: evt.value.initData,
                            initDataType: evt.value.initDataType,
                            mediaKeySession: evt.value.mediaKeySession,
                            sessionType: evt.value.sessionType,
                            keySystemOptions: mediaKeysInfos.keySystemOptions,
                            sessionStorage: mediaKeysInfos.sessionStorage
                        }
                    };
                }));
                return 0 === i ? Object(merge.a)(null != serverCertificate ? Object(concat.a)(trySettingServerCertificate(mediaKeys, serverCertificate), session$) : session$) : session$;
            }), 
            /* Trigger license request and manage MediaKeySession events */
            Object(mergeMap.a)(function(sessionInfosEvt) {
                if ("warning" === sessionInfosEvt.type) return Object(of.a)(sessionInfosEvt);
                var _sessionInfosEvt$valu = sessionInfosEvt.value, initData = _sessionInfosEvt$valu.initData, initDataType = _sessionInfosEvt$valu.initDataType, mediaKeySession = _sessionInfosEvt$valu.mediaKeySession, sessionType = _sessionInfosEvt$valu.sessionType, keySystemOptions = _sessionInfosEvt$valu.keySystemOptions, sessionStorage = _sessionInfosEvt$valu.sessionStorage;
                return Object(merge.a)(handleSessionEvents(mediaKeySession, keySystemOptions), // only perform generate request on new sessions
                "created-session" === sessionInfosEvt.type ? generateKeyRequest(mediaKeySession, initData, initDataType).pipe(Object(tap.a)(function() {
                    "persistent-license" === sessionType && null != sessionStorage && sessionStorage.add(initData, initDataType, mediaKeySession);
                }), Object(catchError.a)(function(error) {
                    throw new encrypted_media_error.a("KEY_GENERATE_REQUEST_ERROR", error.toString(), !1);
                }), Object(ignoreElements.a)()) : empty.a).pipe(Object(filter.a)(function(sessionEvent) {
                    return "warning" === sessionEvent.type;
                }));
            }));
            return Object(merge.a)(initEvent$, startEME$);
        }
        /**
 * Free up all ressources taken by the EME management.
 */        function disposeEME(mediaElement) {
            disposeMediaKeys(mediaElement, attachedMediaKeysInfos).subscribe(noop.a);
        }
        /**
 * Returns the name of the current key system used.
 * @returns {string}
 */        function getCurrentKeySystem(mediaElement) {
            var currentState = attachedMediaKeysInfos.getState(mediaElement);
            return currentState && currentState.keySystemOptions.type;
        }
        /***/    }, 
    /* 71 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return KEY_STATUS_ERRORS;
        });
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        // Keys are the different key statuses possible.
        // Values are ``true`` if such key status defines an error
        /* tslint:disable no-object-literal-type-assertion */
        var KEY_STATUS_ERRORS = {
            "internal-error": !0,
            expired: !1,
            released: !1,
            "output-restricted": !1,
            "output-downscaled": !1,
            "status-pending": !1
        };
        /* tslint:enable no-object-literal-type-assertion */
        /***/    }, 
    /* 72 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return clearElementSrc;
        });
        /* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0), _browser_detection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(20);
        /* harmony import */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Clear element's src attribute.
 *
 * On IE11, element.src = "" is not sufficient as it
 * does not clear properly the current MediaKey Session.
 * Microsoft recommended to use element.removeAttr("src").
 * @param {HTMLMediaElement} element
 */
        function clearElementSrc(element) {
            if (_browser_detection__WEBPACK_IMPORTED_MODULE_1__.a) {
                for (var textTracks = element.textTracks, i = 0; i < textTracks.length; i++) textTracks[i].mode = "disabled";
                if (element.hasChildNodes()) for (var childNodes = element.childNodes, j = childNodes.length - 1; 0 <= j; j--) if ("track" === childNodes[j].nodeName) try {
                    element.removeChild(childNodes[j]);
                } catch (err) {
                    _log__WEBPACK_IMPORTED_MODULE_0__.a.warn("Could not remove text track child from element.");
                }
            }
            element.src = "", element.removeAttribute("src");
        }
        /***/    }, 
    /* 73 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return isNumeric;
        });
        /* harmony import */ var _isArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(45);
        /** PURE_IMPORTS_START _isArray PURE_IMPORTS_END */        function isNumeric(val) {
            return !Object(_isArray__WEBPACK_IMPORTED_MODULE_0__.a)(val) && 0 <= val - parseFloat(val) + 1;
        }
        //# sourceMappingURL=isNumeric.js.map
        /***/    }, 
    /* 74 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return throwError;
        });
        /* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);
        /** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */        function throwError(error, scheduler) {
            return scheduler ? new _Observable__WEBPACK_IMPORTED_MODULE_0__.a(function(subscriber) {
                return scheduler.schedule(dispatch, 0, {
                    error: error,
                    subscriber: subscriber
                });
            }) : new _Observable__WEBPACK_IMPORTED_MODULE_0__.a(function(subscriber) {
                return subscriber.error(error);
            });
        }
        function dispatch(_a) {
            var error = _a.error;
            _a.subscriber.error(error);
        }
        //# sourceMappingURL=throwError.js.map
        /***/    }, 
    /* 75 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js
                var tslib_es6 = __webpack_require__(3), Subject = __webpack_require__(42), Observable = __webpack_require__(6), Subscriber = __webpack_require__(8), Subscription = __webpack_require__(14), refCount = __webpack_require__(101), connectableProto = /* */ function(_super) {
            function ConnectableObservable(source, subjectFactory) {
                var _this = _super.call(this) || this;
                return _this.source = source, _this.subjectFactory = subjectFactory, _this._refCount = 0, 
                _this._isComplete = !1, _this;
            }
            return tslib_es6.a(ConnectableObservable, _super), ConnectableObservable.prototype._subscribe = function(subscriber) {
                return this.getSubject().subscribe(subscriber);
            }, ConnectableObservable.prototype.getSubject = function() {
                var subject = this._subject;
                return subject && !subject.isStopped || (this._subject = this.subjectFactory()), 
                this._subject;
            }, ConnectableObservable.prototype.connect = function() {
                var connection = this._connection;
                return connection || (this._isComplete = !1, (connection = this._connection = new Subscription.a()).add(this.source.subscribe(new ConnectableObservable_ConnectableSubscriber(this.getSubject(), this))), 
                connection.closed ? (this._connection = null, connection = Subscription.a.EMPTY) : this._connection = connection), 
                connection;
            }, ConnectableObservable.prototype.refCount = function() {
                return Object(refCount.a)()(this);
            }, ConnectableObservable;
        }(Observable.a).prototype, connectableObservableDescriptor = {
            operator: {
                value: null
            },
            _refCount: {
                value: 0,
                writable: !0
            },
            _subject: {
                value: null,
                writable: !0
            },
            _connection: {
                value: null,
                writable: !0
            },
            _subscribe: {
                value: connectableProto._subscribe
            },
            _isComplete: {
                value: connectableProto._isComplete,
                writable: !0
            },
            getSubject: {
                value: connectableProto.getSubject
            },
            connect: {
                value: connectableProto.connect
            },
            refCount: {
                value: connectableProto.refCount
            }
        }, ConnectableObservable_ConnectableSubscriber = /* */ function(_super) {
            function ConnectableSubscriber(destination, connectable) {
                var _this = _super.call(this, destination) || this;
                return _this.connectable = connectable, _this;
            }
            return tslib_es6.a(ConnectableSubscriber, _super), ConnectableSubscriber.prototype._error = function(err) {
                this._unsubscribe(), _super.prototype._error.call(this, err);
            }, ConnectableSubscriber.prototype._complete = function() {
                this.connectable._isComplete = !0, this._unsubscribe(), _super.prototype._complete.call(this);
            }, ConnectableSubscriber.prototype._unsubscribe = function() {
                var connectable = this.connectable;
                if (connectable) {
                    this.connectable = null;
                    var connection = connectable._connection;
                    connectable._refCount = 0, connectable._subject = null, connectable._connection = null, 
                    connection && connection.unsubscribe();
                }
            }, ConnectableSubscriber;
        }(Subject.b);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subject.js
                Subscriber.a;
        /* unused harmony export MulticastOperator */
        /** PURE_IMPORTS_START _observable_ConnectableObservable PURE_IMPORTS_END */
        function multicast(subjectOrSubjectFactory, selector) {
            return function multicastOperatorFunction(source) {
                var subjectFactory;
                if (subjectFactory = "function" == typeof subjectOrSubjectFactory ? subjectOrSubjectFactory : function subjectFactory() {
                    return subjectOrSubjectFactory;
                }, "function" == typeof selector) return source.lift(new MulticastOperator(subjectFactory, selector));
                var connectable = Object.create(source, connectableObservableDescriptor);
                return connectable.source = source, connectable.subjectFactory = subjectFactory, 
                connectable;
            };
        }
        //# sourceMappingURL=ConnectableObservable.js.map
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/multicast.js
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return multicast;
        });
        var MulticastOperator = /* */ function() {
            function MulticastOperator(subjectFactory, selector) {
                this.subjectFactory = subjectFactory, this.selector = selector;
            }
            return MulticastOperator.prototype.call = function(subscriber, source) {
                var selector = this.selector, subject = this.subjectFactory(), subscription = selector(subject).subscribe(subscriber);
                return subscription.add(source.subscribe(subject)), subscription;
            }, MulticastOperator;
        }();
        //# sourceMappingURL=multicast.js.map
        /***/    }, 
    /* 76 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return concat;
        });
        /* harmony import */ var _of__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(30), _operators_concatAll__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(134);
        /* harmony import */        
        /** PURE_IMPORTS_START _of,_operators_concatAll PURE_IMPORTS_END */
        function concat() {
            for (var observables = [], _i = 0; _i < arguments.length; _i++) observables[_i] = arguments[_i];
            return Object(_operators_concatAll__WEBPACK_IMPORTED_MODULE_1__.a)()(_of__WEBPACK_IMPORTED_MODULE_0__.a.apply(void 0, observables));
        }
        //# sourceMappingURL=concat.js.map
        /***/    }, 
    /* 77 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Request fullScreen action on a given element.
 * @param {HTMLElement} elt
 * rs-detect)
 */
        function requestFullscreen(element) {
            if (!isFullscreen()) {
                var elt = element;
                elt.requestFullscreen ? 
                /* tslint:disable no-floating-promises */
                elt.requestFullscreen() : elt.msRequestFullscreen ? elt.msRequestFullscreen() : elt.mozRequestFullScreen ? elt.mozRequestFullScreen() : elt.webkitRequestFullscreen && elt.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
            }
        }
        /**
 * Exit fullscreen if an element is currently in fullscreen.
 */        function exitFullscreen() {
            if (isFullscreen()) {
                var doc = document;
                doc.exitFullscreen ? 
                /* tslint:disable no-floating-promises */
                doc.exitFullscreen() : doc.msExitFullscreen ? doc.msExitFullscreen() : doc.mozCancelFullScreen ? doc.mozCancelFullScreen() : doc.webkitExitFullscreen && doc.webkitExitFullscreen();
            }
        }
        /**
 * Returns true if an element in the document is being displayed in fullscreen
 * mode;
 * otherwise it's false.
 * @returns {boolean}
 */        function isFullscreen() {
            var doc = document;
            return !!(doc.fullscreenElement || doc.mozFullScreenElement || doc.webkitFullscreenElement || doc.msFullscreenElement);
        }
        /***/        __webpack_require__.d(__webpack_exports__, "c", function() {
            return requestFullscreen;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return exitFullscreen;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() {
            return isFullscreen;
        });
    }, 
    /* 78 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // CONCATENATED MODULE: ./src/utils/languages/ISO_639-1_to_ISO_639-3.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Translate ISO 639-1 language codes into ISO 639-3 ones.
 */        var ISO_639_1_to_ISO_639_3 = {
            aa: "aar",
            ab: "abk",
            ae: "ave",
            af: "afr",
            ak: "aka",
            am: "amh",
            an: "arg",
            ar: "ara",
            as: "asm",
            av: "ava",
            ay: "aym",
            az: "aze",
            ba: "bak",
            be: "bel",
            bg: "bul",
            bi: "bis",
            bm: "bam",
            bn: "ben",
            bo: "bod",
            br: "bre",
            bs: "bos",
            ca: "cat",
            ce: "che",
            ch: "cha",
            co: "cos",
            cr: "cre",
            cs: "ces",
            cu: "chu",
            // Old Slavonic, Old Bulgarian
            cv: "chv",
            cy: "cym",
            da: "dan",
            de: "deu",
            dv: "div",
            dz: "dzo",
            ee: "ewe",
            el: "ell",
            en: "eng",
            eo: "epo",
            es: "spa",
            et: "est",
            eu: "eus",
            fa: "fas",
            ff: "ful",
            fi: "fin",
            fj: "fij",
            fo: "fao",
            fr: "fra",
            fy: "fry",
            ga: "gle",
            gd: "gla",
            gl: "glg",
            gn: "grn",
            gu: "guj",
            gv: "glv",
            ha: "hau",
            he: "heb",
            hi: "hin",
            ho: "hmo",
            hr: "hrv",
            ht: "hat",
            hu: "hun",
            hy: "hye",
            hz: "her",
            ia: "ina",
            id: "ind",
            ie: "ile",
            ig: "ibo",
            ii: "iii",
            ik: "ipk",
            io: "ido",
            is: "isl",
            it: "ita",
            iu: "iku",
            ja: "jpn",
            jv: "jav",
            ka: "kat",
            kg: "kon",
            ki: "kik",
            kj: "kua",
            kk: "kaz",
            kl: "kal",
            km: "khm",
            kn: "kan",
            ko: "kor",
            kr: "kau",
            ks: "kas",
            ku: "kur",
            kv: "kom",
            kw: "cor",
            ky: "kir",
            la: "lat",
            lb: "ltz",
            lg: "lug",
            li: "lim",
            ln: "lin",
            lo: "lao",
            lt: "lit",
            lu: "lub",
            lv: "lav",
            mg: "mlg",
            mh: "mah",
            mi: "mri",
            mk: "mkd",
            ml: "mal",
            mn: "mon",
            mr: "mar",
            ms: "msa",
            mt: "mlt",
            my: "mya",
            na: "nau",
            nb: "nob",
            nd: "nde",
            ne: "nep",
            ng: "ndo",
            nl: "nld",
            nn: "nno",
            no: "nor",
            nr: "nbl",
            nv: "nav",
            ny: "nya",
            oc: "oci",
            oj: "oji",
            om: "orm",
            or: "ori",
            os: "oss",
            pa: "pan",
            pi: "pli",
            pl: "pol",
            ps: "pus",
            pt: "por",
            qu: "que",
            rm: "roh",
            rn: "run",
            ro: "ron",
            ru: "rus",
            rw: "kin",
            sa: "san",
            sc: "srd",
            sd: "snd",
            se: "sme",
            sg: "sag",
            si: "sin",
            sk: "slk",
            sl: "slv",
            sm: "smo",
            sn: "sna",
            so: "som",
            sq: "sqi",
            sr: "srp",
            ss: "ssw",
            st: "sot",
            su: "sun",
            sv: "swe",
            sw: "swa",
            ta: "tam",
            te: "tel",
            tg: "tgk",
            th: "tha",
            ti: "tir",
            tk: "tuk",
            tl: "tgl",
            tn: "tsn",
            to: "ton",
            tr: "tur",
            ts: "tso",
            tt: "tat",
            tw: "twi",
            ty: "tah",
            ug: "uig",
            uk: "ukr",
            ur: "urd",
            uz: "uzb",
            ve: "ven",
            vi: "vie",
            vo: "vol",
            wa: "wln",
            wo: "wol",
            xh: "xho",
            yi: "yid",
            yo: "yor",
            za: "zha",
            zh: "zho",
            zu: "zul"
        }, ISO_639_2_to_ISO_639_3 = {
            alb: "sqi",
            arm: "hye",
            baq: "eus",
            bur: "mya",
            chi: "zho",
            cze: "ces",
            dut: "nld",
            fre: "fra",
            geo: "kat",
            ger: "deu",
            gre: "ell",
            ice: "isl",
            mac: "mkd",
            mao: "mri",
            may: "msa",
            per: "fas",
            slo: "slk",
            rum: "ron",
            tib: "bod",
            wel: "cym"
        };
        /* harmony default export */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Normalize language given.
 * Basically:
 *   - converts it to lowercase.
 *   - normalize "base" (what is before the possible first "-") to an ISO639-3
 *     compatible string.
 * @param {string} _language
 * @returns {string}
 */
        function normalizeLanguage(_language) {
            if (null == _language || "" === _language) return "";
            var normalizedBase = normalizeBase(("" + _language).toLowerCase().split("-")[0]);
            return normalizedBase || _language;
        }
        /**
 * Normalize language into an ISO639-3 format.
 * Returns undefined if it failed to do so
 * @param {string} base
 * @returns {string}
 */        function normalizeBase(base) {
            var result;
            switch (base.length) {
              case 2:
                result = ISO_639_1_to_ISO_639_3[base];
                break;

              case 3:
                result = ISO_639_2_to_ISO_639_3[base];
            }
            return result;
        }
        /**
 * Normalize text track from a user given input into an object
 * with three properties:
 *   - language {string}: The language the user gave us
 *   - normalized {string}: An attempt to normalize the language into an
 *     ISO 639-3 code
 *   - closedCaption {Boolean}: Whether the track is a closed caption track
 * @param {Object|string|null|undefined} _language
 * @returns {Object|null|undefined}
 */        function normalizeTextTrack(_language) {
            return null == _language ? _language : (closedCaption = "string" == typeof _language ? (language = _language, 
            !1) : (language = _language.language, !!_language.closedCaption), {
                language: language,
                closedCaption: closedCaption,
                normalized: normalizeLanguage(language)
            });
            var language, closedCaption;
        }
        /**
 * Normalize audio track from a user given input into an object
 * with three properties:
 *   - language {string}: The language the user gave us
 *   - normalized {string}: An attempt to normalize the language into an
 *     ISO 639-3 code
 *   - audioDescription {Boolean}: Whether the track is a closed caption track
 * @param {Object|string|null|undefined} _language
 * @returns {Object|null|undefined}
 */        function normalizeAudioTrack(_language) {
            return null == _language ? _language : (audioDescription = "string" == typeof _language ? (language = _language, 
            !1) : (language = _language.language, !!_language.audioDescription), {
                language: language,
                audioDescription: audioDescription,
                normalized: normalizeLanguage(language)
            });
            var language, audioDescription;
        }
        /* harmony default export */        
        // CONCATENATED MODULE: ./src/utils/languages/normalize.ts
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() {
            return normalizeAudioTrack;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() {
            return normalizeTextTrack;
        });
        __webpack_exports__.a = normalizeLanguage;
        /***/    }, 
    /* 79 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        function isObject(x) {
            return null !== x && "object" == typeof x;
        }
        //# sourceMappingURL=isObject.js.map
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return isObject;
        });
    }, 
    /* 80 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return subscribeTo;
        });
        /* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6), _subscribeToArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(83), _subscribeToPromise__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(85), _subscribeToIterable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(86), _subscribeToObservable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(81), _isArrayLike__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(82), _isPromise__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(84), _isObject__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(79), _symbol_iterator__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(56), _symbol_observable__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(46), subscribeTo = function(result) {
            if (result instanceof _Observable__WEBPACK_IMPORTED_MODULE_0__.a) return function(subscriber) {
                return result._isScalar ? (subscriber.next(result.value), void subscriber.complete()) : result.subscribe(subscriber);
            };
            if (result && "function" == typeof result[_symbol_observable__WEBPACK_IMPORTED_MODULE_9__.a]) return Object(_subscribeToObservable__WEBPACK_IMPORTED_MODULE_4__.a)(result);
            if (Object(_isArrayLike__WEBPACK_IMPORTED_MODULE_5__.a)(result)) return Object(_subscribeToArray__WEBPACK_IMPORTED_MODULE_1__.a)(result);
            if (Object(_isPromise__WEBPACK_IMPORTED_MODULE_6__.a)(result)) return Object(_subscribeToPromise__WEBPACK_IMPORTED_MODULE_2__.a)(result);
            if (result && "function" == typeof result[_symbol_iterator__WEBPACK_IMPORTED_MODULE_8__.a]) return Object(_subscribeToIterable__WEBPACK_IMPORTED_MODULE_3__.a)(result);
            var value = Object(_isObject__WEBPACK_IMPORTED_MODULE_7__.a)(result) ? "an invalid object" : "'" + result + "'";
            throw new TypeError("You provided " + value + " where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.");
        };
        /* harmony import */    }, 
    /* 81 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return subscribeToObservable;
        });
        /* harmony import */ var _symbol_observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(46), subscribeToObservable = function(obj) {
            return function(subscriber) {
                var obs = obj[_symbol_observable__WEBPACK_IMPORTED_MODULE_0__.a]();
                if ("function" != typeof obs.subscribe) throw new TypeError("Provided object does not correctly implement Symbol.observable");
                return obs.subscribe(subscriber);
            };
        };
        /** PURE_IMPORTS_START _symbol_observable PURE_IMPORTS_END */    }, 
    /* 82 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return isArrayLike;
        });
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        var isArrayLike = function(x) {
            return x && "number" == typeof x.length && "function" != typeof x;
        };
        //# sourceMappingURL=isArrayLike.js.map
        /***/    }, 
    /* 83 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return subscribeToArray;
        });
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        var subscribeToArray = function(array) {
            return function(subscriber) {
                for (var i = 0, len = array.length; i < len && !subscriber.closed; i++) subscriber.next(array[i]);
                subscriber.closed || subscriber.complete();
            };
        };
        //# sourceMappingURL=subscribeToArray.js.map
        /***/    }, 
    /* 84 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        function isPromise(value) {
            return !!value && "function" != typeof value.subscribe && "function" == typeof value.then;
        }
        //# sourceMappingURL=isPromise.js.map
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return isPromise;
        });
    }, 
    /* 85 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return subscribeToPromise;
        });
        /* harmony import */ var _hostReportError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(54), subscribeToPromise = function(promise) {
            return function(subscriber) {
                return promise.then(function(value) {
                    subscriber.closed || (subscriber.next(value), subscriber.complete());
                }, function(err) {
                    return subscriber.error(err);
                }).then(null, _hostReportError__WEBPACK_IMPORTED_MODULE_0__.a), subscriber;
            };
        };
        /** PURE_IMPORTS_START _hostReportError PURE_IMPORTS_END */    }, 
    /* 86 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return subscribeToIterable;
        });
        /* harmony import */ var _symbol_iterator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(56), subscribeToIterable = function(iterable) {
            return function(subscriber) {
                for (var iterator = iterable[_symbol_iterator__WEBPACK_IMPORTED_MODULE_0__.a](); ;) {
                    var item = iterator.next();
                    if (item.done) {
                        subscriber.complete();
                        break;
                    }
                    if (subscriber.next(item.value), subscriber.closed) break;
                }
                return "function" == typeof iterator.return && subscriber.add(function() {
                    iterator.return && iterator.return();
                }), subscriber;
            };
        };
        /** PURE_IMPORTS_START _symbol_iterator PURE_IMPORTS_END */    }, 
    /* 87 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return scalar;
        });
        /* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);
        /** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */        function scalar(value) {
            var result = new _Observable__WEBPACK_IMPORTED_MODULE_0__.a(function(subscriber) {
                subscriber.next(value), subscriber.complete();
            });
            return result._isScalar = !0, result.value = value, result;
        }
        //# sourceMappingURL=scalar.js.map
        /***/    }, 
    /* 88 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return SubjectSubscription;
        });
        /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3), SubjectSubscription = /* */ function(_super) {
            function SubjectSubscription(subject, subscriber) {
                var _this = _super.call(this) || this;
                return _this.subject = subject, _this.subscriber = subscriber, _this.closed = !1, 
                _this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(SubjectSubscription, _super), SubjectSubscription.prototype.unsubscribe = function() {
                if (!this.closed) {
                    this.closed = !0;
                    var subject = this.subject, observers = subject.observers;
                    if (this.subject = null, observers && 0 !== observers.length && !subject.isStopped && !subject.closed) {
                        var subscriberIndex = observers.indexOf(this.subscriber);
                        -1 !== subscriberIndex && observers.splice(subscriberIndex, 1);
                    }
                }
            }, SubjectSubscription;
        }(__webpack_require__(14).a);
        /* harmony import */    }, 
    /* 89 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "b", function() {
            return getFuzzedDelay;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return getBackedoffDelay;
        });
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        var FUZZ_FACTOR = .3;
        /**
 * Perform "fuzzing" on the delay given.
 * @param {Number} retryDelay
 * @returns {Number}
 */        function getFuzzedDelay(retryDelay) {
            return retryDelay * ((2 * Math.random() - 1) * FUZZ_FACTOR + 1);
 // Max 1.3 Min 0.7
                }
        /**
 * Calculate a "backed off" fuzzed delay.
 * That is, a delay augmented depending on the current retry count.
 * @param {Number} retryDelay
 * @param {Number} [retryCount=1]
 * @returns {Number}
 */        function getBackedoffDelay(retryDelay, retryCount) {
            return void 0 === retryCount && (retryCount = 1), getFuzzedDelay(retryDelay * Math.pow(2, retryCount - 1));
        }
        /***/    }, 
    /* 90 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return checkManifestIDs;
        });
        /* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0), _utils_array_includes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(12);
        /* harmony import */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Ensure that no two periods, adaptations from the same period and
 * representations from the same adaptation, have the same ID.
 *
 * Log and mutate their ID if not until this is verified.
 *
 * @param {Object} manifest
 */
        function checkManifestIDs(manifest) {
            var periodIDS = [];
            manifest.periods.forEach(function(period) {
                var periodID = period.id;
                if (Object(_utils_array_includes__WEBPACK_IMPORTED_MODULE_1__.a)(periodIDS, periodID)) {
                    _log__WEBPACK_IMPORTED_MODULE_0__.a.warn("Two periods with the same ID found. Updating.");
                    var newID = periodID + "-dup";
                    period.id = newID, checkManifestIDs(manifest), periodIDS.push(newID);
                } else periodIDS.push(periodID);
                var adaptations = period.adaptations, adaptationIDs = [];
                Object.keys(adaptations).forEach(function(type) {
                    (adaptations[type] || []).forEach(function(adaptation) {
                        var adaptationID = adaptation.id;
                        if (Object(_utils_array_includes__WEBPACK_IMPORTED_MODULE_1__.a)(adaptationIDs, adaptationID)) {
                            _log__WEBPACK_IMPORTED_MODULE_0__.a.warn("Two adaptations with the same ID found. Updating.", adaptationID);
                            var _newID = adaptationID + "-dup";
                            adaptation.id = _newID, checkManifestIDs(manifest), adaptationIDs.push(_newID);
                        } else adaptationIDs.push(adaptationID);
                        var representationIDs = [];
                        adaptation.representations.forEach(function(representation) {
                            var representationID = representation.id;
                            if (Object(_utils_array_includes__WEBPACK_IMPORTED_MODULE_1__.a)(representationIDs, representationID)) {
                                _log__WEBPACK_IMPORTED_MODULE_0__.a.warn("Two representations with the same ID found. Updating.", representationID);
                                var _newID2 = representationID + "-dup";
                                representation.id = _newID2, checkManifestIDs(manifest), representationIDs.push(_newID2);
                            } else representationIDs.push(representationID);
                        });
                    });
                });
            });
        }
        /***/    }, 
    /* 91 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony import */        var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6), _utils_request__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(23);
        /* harmony import */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Manifest loader triggered if there was no custom-defined one in the API.
 * @param {string} url
 */
        function regularManifestLoader(url, ignoreProgressEvents) {
            return Object(_utils_request__WEBPACK_IMPORTED_MODULE_1__.a)({
                url: url,
                responseType: "document",
                ignoreProgressEvents: ignoreProgressEvents
            });
        }
        /**
 * Generate a manifest loader for the application
 * @param {Function} [customManifestLoader]
 * @returns {Function}
 */        
        /* harmony default export */ __webpack_exports__.a = function manifestPreLoader(options) {
            return function(url) {
                var customManifestLoader = options.customManifestLoader, ignoreProgressEvents = options.ignoreProgressEvents;
                return customManifestLoader ? new rxjs__WEBPACK_IMPORTED_MODULE_0__.a(function(obs) {
                    var hasFinished = !1, hasFallbacked = !1, abort = customManifestLoader(url, {
                        reject: function reject(err) {
                            void 0 === err && (err = {}), hasFallbacked || (hasFinished = !0, obs.error(err));
                        },
                        resolve: function resolve(_args) {
                            hasFallbacked || (hasFinished = !0, obs.next({
                                type: "response",
                                value: {
                                    responseData: _args.data,
                                    size: _args.size,
                                    duration: _args.duration
                                }
                            }), obs.complete());
                        },
                        fallback: function fallback() {
                            hasFallbacked = !0, regularManifestLoader(url).subscribe(obs);
                        }
                    });
                    return function() {
                        hasFinished || hasFallbacked || "function" != typeof abort || abort();
                    };
                }) : regularManifestLoader(url, ignoreProgressEvents);
            };
        };
    }, 
    /* 92 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* unused harmony export objectValues */
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {Object|Array} o
 * @returns {Array.<*>}
 */        
        /* tslint:disable no-unbound-method */
        /* harmony default export */ __webpack_exports__.a = "function" == typeof Object.values ? Object.values : function objectValues(o) {
            return Object.keys(o).map(function(k) {
                return o[k];
            });
        };
    }, 
    /* 93 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Creates a new string from the given array of char codes.
 *
 * @param {Uint8Array} args
 * @returns {string}
 */
        function stringFromCharCode(args) {
            for (var ret = "", i = 0; i < args.length; i += 16e3) {
                var subArray = args.subarray(i, i + 16e3);
 // NOTE: ugly I know, but TS is problematic here (you can try)
                                ret += String.fromCharCode.apply(null, subArray);
            }
            return ret;
        }
        /**
 * Creates a string from the given buffer as UTF-8 encoding.
 * @param {BufferSource} [data]
 * @returns {string}
 * @throws {Error}
 * @export
 */        function stringFromUTF8(data) {
            if (!data) return "";
            var uint8 = new Uint8Array(data);
 // If present, strip off the UTF-8 BOM.
                        239 === uint8[0] && 187 === uint8[1] && 191 === uint8[2] && (uint8 = uint8.subarray(3));
 // http://stackoverflow.com/a/13691499
                        var utf8 = stringFromCharCode(uint8), escaped = escape(utf8);
 // This converts each character in the string to an escape sequence.  If the
            // character is in the ASCII range, it is not converted; otherwise it is
            // converted to a URI escape sequence.
            // Example: "\x67\x35\xe3\x82\xac" -> "g#%E3%82%AC"
            // TODO "escape" is deprecated, provide a ponyfill?
                        // Decode the escaped sequence.  This will interpret UTF-8 sequences into the
            // correct character.
            // Example: "g#%E3%82%AC" -> "g#€"
            return decodeURIComponent(escaped);
        }
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return stringFromUTF8;
        });
    }, 
    /* 94 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return getCueBlocks;
        });
        /* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(52);
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Get cue blocks from a WebVTT file.
 * @param {Array.<string>} linified - Whole WebVTT file. Each new element in
 * this array is a new line.
 * @param {number} headerOffset - index of the first line after the header.
 * Used to avoid taking the header into consideration.
 * @returns {Array.<Array.<string>>}
 */        function getCueBlocks(linified, headerOffset) {
            for (var cueBlocks = [], i = headerOffset; i < linified.length; i++) 
            //
            if (Object(_utils__WEBPACK_IMPORTED_MODULE_0__.c)(linified, i)) {
                var endOfCue = Object(_utils__WEBPACK_IMPORTED_MODULE_0__.a)(linified, i);
                cueBlocks.push(linified.slice(i, endOfCue)), i = endOfCue;
            } else if (linified[i]) 
            // continue incrementing i until either:
            //   - empty line
            //   - end
            for (;linified[i]; ) i++;
            return cueBlocks;
        }
        /***/    }, 
    /* 95 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return makeCue;
        });
        /* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0), _browser_compatibility_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(19);
        /* harmony import */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Creates a cue using the best platform-specific interface available.
 *
 * @param {Number} startTime
 * @param {Number} endTime
 * @param {string} payload
 * @returns {VTTCue|TextTrackCue|null} Text track cue or null if the parameters
 * were invalid.
 */
        function makeCue(startTime, endTime, payload) {
            if (!_browser_compatibility_types__WEBPACK_IMPORTED_MODULE_1__.e) throw new Error("VTT cues not supported in your target");
            return endTime <= startTime ? (
            // IE/Edge will throw in this case.
            // See issue #501
            _log__WEBPACK_IMPORTED_MODULE_0__.a.warn("Compat: Invalid cue times: " + startTime + " - " + endTime), 
            null) : new _browser_compatibility_types__WEBPACK_IMPORTED_MODULE_1__.e(startTime, endTime, payload);
        }
        /***/    }, 
    /* 96 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Returns global parameters from a TTML Document
 * @param {Element} tt - <tt> node
 * @throws Error - Throws if the spacing style is invalid.
 * @returns {Object}
 */
        function getParameters(tt) {
            var parsedFrameRate = tt.getAttribute("ttp:frameRate"), parsedSubFrameRate = tt.getAttribute("ttp:subFramRate"), parsedTickRate = tt.getAttribute("ttp:tickRate"), parsedFrameRateMultiplier = tt.getAttribute("ttp:frameRateMultiplier"), parsedSpaceStyle = tt.getAttribute("xml:space");
            if (parsedSpaceStyle && "default" !== parsedSpaceStyle && "preserve" !== parsedSpaceStyle) throw new Error("Invalid spacing style");
            var nbFrameRate = Number(parsedFrameRate) || 30, nbSubFrameRate = Number(parsedSubFrameRate) || 1, nbTickRate = Number(parsedTickRate) || 0, tickRate = nbTickRate, frameRate = nbFrameRate, subFrameRate = null != nbSubFrameRate ? nbSubFrameRate : 1, spaceStyle = parsedSpaceStyle || "default";
            if (0 === nbTickRate && (tickRate = parsedFrameRate ? nbFrameRate * nbSubFrameRate : 1), 
            parsedFrameRateMultiplier) {
                var multiplierResults = /^(\d+) (\d+)$/g.exec(parsedFrameRateMultiplier);
                if (multiplierResults) frameRate = nbFrameRate * (Number(multiplierResults[1]) / Number(multiplierResults[2]));
            }
            return {
                tickRate: tickRate,
                frameRate: frameRate,
                subFrameRate: subFrameRate,
                spaceStyle: spaceStyle
            };
        }
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return getParameters;
        });
    }, 
    /* 97 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return seekAndLoadOnMediaEvents;
        });
        /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(76), rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(30), rxjs_operators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(139), rxjs_operators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(113), rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(140), rxjs_operators__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(171), rxjs_operators__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(123), rxjs_operators__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(141), rxjs_operators__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(39), _compat__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(98), _compat__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(115), _compat__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(116), _log__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(0);
        /* harmony import */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Emit once a "can-play" message as soon as the clock$ anounce that the content
 * can begin to be played.
 *
 * Warn you if the metadata is not yet loaded metadata by emitting a
 * "not-loaded-metadata" message first.
 * @param {Observable} clock$
 * @returns {Observable}
 */
        function canPlay(clock$, mediaElement) {
            var isLoaded$ = clock$.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.a)(function(tick) {
                var seeking = tick.seeking, stalled = tick.stalled, readyState = tick.readyState, currentRange = tick.currentRange;
                return !seeking && null == stalled && (4 === readyState || 3 === readyState && null != currentRange) && (!Object(_compat__WEBPACK_IMPORTED_MODULE_9__.a)() || 0 < mediaElement.duration);
            }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.a)(1), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.a)("can-play"));
            return Object(_compat__WEBPACK_IMPORTED_MODULE_9__.a)() && 0 === mediaElement.duration ? Object(rxjs__WEBPACK_IMPORTED_MODULE_0__.a)(Object(rxjs__WEBPACK_IMPORTED_MODULE_1__.a)("not-loaded-metadata"), isLoaded$) : isLoaded$;
        }
        /**
 * Try to play content then handle autoplay errors.
 * @param {HTMLMediaElement} - mediaElement
 * @returns {Observable}
 */        function autoPlay$(mediaElement) {
            return Object(_compat__WEBPACK_IMPORTED_MODULE_10__.a)(mediaElement).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.a)("autoplay"), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__.a)(function(error) {
                if ("NotAllowedError" === error.name) 
                // auto-play was probably prevented.
                return _log__WEBPACK_IMPORTED_MODULE_12__.a.warn("Init: Media element can't play. It may be due to browser auto-play policies."), 
                Object(rxjs__WEBPACK_IMPORTED_MODULE_1__.a)("autoplay-blocked");
                throw error;
            }));
        }
        /**
 * Returns two Observables:
 *
 *   - seek$: when subscribed, will seek to the wanted started time as soon as
 *     it can. Emit and complete when done.
 *
 *   - load$: when subscribed, will play if and only if the `mustAutoPlay`
 *     option is set as soon as it can. Emit and complete when done.
 *     When this observable emits, it also means that the content is `loaded`
 *     and can begin to play the current content.
 *
 * @param {HTMLMediaElement} mediaElement
 * @param {number|Function} startTime - Initial starting position. As seconds
 * or as a function returning seconds.
 * @param {boolean} autoPlay - Whether the player should auto-play
 * @returns {object}
 */        function seekAndLoadOnMediaEvents(clock$, mediaElement, startTime, mustAutoPlay) {
            var seek$ = Object(_compat__WEBPACK_IMPORTED_MODULE_11__.a)(mediaElement).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.a)(1), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_6__.a)(function() {
                _log__WEBPACK_IMPORTED_MODULE_12__.a.info("Init: Set initial time", startTime), 
                mediaElement.currentTime = "function" == typeof startTime ? startTime() : startTime;
            }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_7__.a)({
                refCount: !0
            })), load$ = seek$.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_8__.a)(function() {
                return canPlay(clock$, mediaElement).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_6__.a)(function() {
                    return _log__WEBPACK_IMPORTED_MODULE_12__.a.info("Init: Can begin to play content");
                }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_8__.a)(function(evt) {
                    return "can-play" === evt ? mustAutoPlay ? autoPlay$(mediaElement) : Object(rxjs__WEBPACK_IMPORTED_MODULE_1__.a)("loaded") : Object(rxjs__WEBPACK_IMPORTED_MODULE_1__.a)(evt);
                }));
            }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_7__.a)({
                refCount: !0
            }));
            return {
                seek$: seek$,
                load$: load$
            };
        }
        /***/    }, 
    /* 98 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return shouldValidateMetadata;
        });
        /* harmony import */ var _browser_detection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(20);
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Returns true if the metadata received after a "loadedmetadata" event has
 * to be validated in the current browser (which means that we do not trust
 * this event on these browsers).
 * @returns {boolean}
 */        function shouldValidateMetadata() {
            return _browser_detection__WEBPACK_IMPORTED_MODULE_0__.d;
        }
        /***/    }, 
    /* 99 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        function ArgumentOutOfRangeErrorImpl() {
            return Error.call(this), this.message = "argument out of range", this.name = "ArgumentOutOfRangeError", 
            this;
        }
        __webpack_require__.d(__webpack_exports__, "a", function() {
            return ArgumentOutOfRangeError;
        }), ArgumentOutOfRangeErrorImpl.prototype = /* */ Object.create(Error.prototype);
        var ArgumentOutOfRangeError = ArgumentOutOfRangeErrorImpl;
        //# sourceMappingURL=ArgumentOutOfRangeError.js.map
        /***/    }, 
    /* 100 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return createEMEManager;
        });
        /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(112), rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(30), rxjs_operators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(34), _compat___WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7), _compat___WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(117), _errors__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(122), _features__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(10), _log__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(0), onEncrypted$ = _compat___WEBPACK_IMPORTED_MODULE_3__.a.onEncrypted$;
        /* harmony import */        
        /**
 * Create EMEManager if possible (has the APIs and configuration).
 * Else, return an Observable throwing at the next encrypted event encountered.
 * @param {HTMLMediaElement} mediaElement
 * @param {Array.<Object>} keySystems
 * @returns {Observable}
 */
        function createEMEManager(mediaElement, keySystems) {
            return null == _features__WEBPACK_IMPORTED_MODULE_6__.a.emeManager ? Object(rxjs__WEBPACK_IMPORTED_MODULE_0__.a)(onEncrypted$(mediaElement).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.a)(function() {
                throw _log__WEBPACK_IMPORTED_MODULE_7__.a.error("Init: Encrypted event but EME feature not activated"), 
                new _errors__WEBPACK_IMPORTED_MODULE_5__.a("MEDIA_IS_ENCRYPTED_ERROR", "EME feature not activated.", !0);
            })), Object(rxjs__WEBPACK_IMPORTED_MODULE_1__.a)({
                type: "eme-disabled"
            })) : keySystems && keySystems.length ? Object(_compat___WEBPACK_IMPORTED_MODULE_4__.a)() ? (_log__WEBPACK_IMPORTED_MODULE_7__.a.debug("Init: Creating EMEManager"), 
            _features__WEBPACK_IMPORTED_MODULE_6__.a.emeManager(mediaElement, keySystems)) : Object(rxjs__WEBPACK_IMPORTED_MODULE_0__.a)(onEncrypted$(mediaElement).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.a)(function() {
                throw _log__WEBPACK_IMPORTED_MODULE_7__.a.error("Init: Encrypted event but no EME API available"), 
                new _errors__WEBPACK_IMPORTED_MODULE_5__.a("MEDIA_IS_ENCRYPTED_ERROR", "Encryption APIs not found.", !0);
            })), Object(rxjs__WEBPACK_IMPORTED_MODULE_1__.a)({
                type: "eme-disabled"
            })) : Object(rxjs__WEBPACK_IMPORTED_MODULE_0__.a)(onEncrypted$(mediaElement).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.a)(function() {
                throw _log__WEBPACK_IMPORTED_MODULE_7__.a.error("Init: Ciphered media and no keySystem passed"), 
                new _errors__WEBPACK_IMPORTED_MODULE_5__.a("MEDIA_IS_ENCRYPTED_ERROR", "Media is encrypted and no `keySystems` given", !0);
            })), Object(rxjs__WEBPACK_IMPORTED_MODULE_1__.a)({
                type: "eme-disabled"
            }));
        }
        /***/    }, 
    /* 101 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return refCount;
        });
        /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3), _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8);
        /* harmony import */        
        /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
        function refCount() {
            return function refCountOperatorFunction(source) {
                return source.lift(new RefCountOperator(source));
            };
        }
        var RefCountOperator = /* */ function() {
            function RefCountOperator(connectable) {
                this.connectable = connectable;
            }
            return RefCountOperator.prototype.call = function(subscriber, source) {
                var connectable = this.connectable;
                connectable._refCount++;
                var refCounter = new RefCountSubscriber(subscriber, connectable), subscription = source.subscribe(refCounter);
                return refCounter.closed || (refCounter.connection = connectable.connect()), subscription;
            }, RefCountOperator;
        }(), RefCountSubscriber = /* */ function(_super) {
            function RefCountSubscriber(destination, connectable) {
                var _this = _super.call(this, destination) || this;
                return _this.connectable = connectable, _this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(RefCountSubscriber, _super), RefCountSubscriber.prototype._unsubscribe = function() {
                var connectable = this.connectable;
                if (connectable) {
                    this.connectable = null;
                    var refCount = connectable._refCount;
                    if (refCount <= 0) this.connection = null; else if (connectable._refCount = refCount - 1, 
                    1 < refCount) this.connection = null; else {
                        var connection = this.connection, sharedConnection = connectable._connection;
                        this.connection = null, !sharedConnection || connection && sharedConnection !== connection || sharedConnection.unsubscribe();
                    }
                } else this.connection = null;
            }, RefCountSubscriber;
        }(_Subscriber__WEBPACK_IMPORTED_MODULE_1__.a);
    }, 
    /* 102 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return throwOnMediaError;
        });
        /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(166), rxjs_operators__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(39), _errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(58);
        /* harmony import */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Returns an observable which throws the right MediaError as soon an "error"
 * event is received through the media element.
 * @see MediaError
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */
        function throwOnMediaError(mediaElement) {
            return Object(rxjs__WEBPACK_IMPORTED_MODULE_0__.a)(mediaElement, "error").pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_1__.a)(function() {
                switch (mediaElement.error && mediaElement.error.code) {
                  case 1:
                    throw new _errors__WEBPACK_IMPORTED_MODULE_2__.a("MEDIA_ERR_ABORTED", "The fetching of the associated resource was aborted by the user's request.", !0);

                  case 2:
                    throw new _errors__WEBPACK_IMPORTED_MODULE_2__.a("MEDIA_ERR_NETWORK", "A network error occurred which prevented the media from being successfully fetched", !0);

                  case 3:
                    throw new _errors__WEBPACK_IMPORTED_MODULE_2__.a("MEDIA_ERR_DECODE", "An error occurred while trying to decode the media resource", !0);

                  case 4:
                    throw new _errors__WEBPACK_IMPORTED_MODULE_2__.a("MEDIA_ERR_SRC_NOT_SUPPORTED", "The media resource has been found to be unsuitable.", !0);

                  default:
                    throw new _errors__WEBPACK_IMPORTED_MODULE_2__.a("MEDIA_ERR_UNKNOWN", "The HTMLMediaElement errored due to an unknown reason.", !0);
                }
            }));
        }
        /***/    }, 
    /* 103 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return getStalledEvents;
        });
        /* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(123), rxjs_operators__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(142), rxjs_operators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(34), rxjs_operators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(167), _compat__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(118), _config__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(2), _log__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(0), _utils_ranges__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(13), DISCONTINUITY_THRESHOLD = _config__WEBPACK_IMPORTED_MODULE_5__.a.DISCONTINUITY_THRESHOLD;
        /* harmony import */        
        /**
 * Receive "stalling" events from the clock, try to get out of it, and re-emit
 * them for the player if the stalling status changed.
 * @param {HTMLMediaElement} mediaElement
 * @param {Observable} clock$
 * @returns {Observable}
 */
        function getStalledEvents(mediaElement, clock$) {
            return clock$.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_0__.a)(function(tick) {
                if (tick.stalled) {
                    // Perform various checks to try to get out of the stalled state:
                    //   1. is it a browser bug? -> force seek at the same current time
                    //   2. is it a short discontinuity? -> Seek at the beginning of the
                    //                                      next range
                    var buffered = tick.buffered, currentTime = tick.currentTime, nextRangeGap = Object(_utils_ranges__WEBPACK_IMPORTED_MODULE_7__.d)(buffered, currentTime);
                    // Discontinuity check in case we are close a buffered range but still
                    // calculate a stalled state. This is useful for some
                    // implementation that might drop an injected segment, or in
                    // case of small discontinuity in the content.
                    if (Object(_compat__WEBPACK_IMPORTED_MODULE_4__.a)(tick.currentTime, tick.currentRange, tick.state, !!tick.stalled)) _log__WEBPACK_IMPORTED_MODULE_6__.a.warn("Init: After freeze seek", currentTime, tick.currentRange), 
                    mediaElement.currentTime = currentTime; else if (nextRangeGap < DISCONTINUITY_THRESHOLD) {
                        var seekTo = currentTime + nextRangeGap + 1 / 60;
                        _log__WEBPACK_IMPORTED_MODULE_6__.a.warn("Init: Discontinuity seek", currentTime, nextRangeGap, seekTo), 
                        mediaElement.currentTime = seekTo;
                    }
                }
            }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_1__.a)(), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.a)(function(tick) {
                return tick.stalled;
            }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.a)(function(wasStalled, isStalled) {
                return !wasStalled && !isStalled || !!wasStalled && !!isStalled && wasStalled.reason === isStalled.reason;
            }));
        }
        /***/    }, 
    /* 104 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // EXTERNAL MODULE: ./src/log.ts + 1 modules
                var log = __webpack_require__(0), array_find = __webpack_require__(11), event_emitter = __webpack_require__(33), id_generator = __webpack_require__(48), warn_once = __webpack_require__(26), media_error = __webpack_require__(58), utils_languages = __webpack_require__(64);
        // EXTERNAL MODULE: ./src/utils/array_find.ts
                /**
 * Returns the input array without duplicates values.
 * All values are unique.
 * @param {Array.<*>} arr
 * @returns {Array.<*>}
 */
        /* harmony default export */ var uniq = "function" == typeof window.Set ? 
        /**
 * Uniq implementation by using the Set browser API.
 * @param {Array.<*>} arr
 * @returns {Array.<*>}
 */
        function uniqFromSet(arr) {
            return Array.from(new Set(arr));
        } : 
        // CONCATENATED MODULE: ./src/utils/uniq.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Uniq implementation by combining a filter and an indexOf.
 * @param {Array.<*>} arr
 * @returns {Array.<*>}
 */
        function uniqFromFilter(arr) {
            return arr.filter(function(val, i, self) {
                return self.indexOf(val) === i;
            });
        }, is_codec_supported = __webpack_require__(128);
        // EXTERNAL MODULE: ./src/compat/is_codec_supported.ts
                // CONCATENATED MODULE: ./src/manifest/filter_supported_representations.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Only keep Representations for which the codec is currently supported.
 * @param {string} adaptationType
 * @param {Array.<Object>} representations
 * @returns {Array.<Object>}
 */
        function filterSupportedRepresentations(adaptationType, representations) {
            return "audio" === adaptationType || "video" === adaptationType ? representations.filter(function(representation) {
                return Object(is_codec_supported.a)(getCodec(representation));
            }) : representations;
        }
        /**
 * Construct the codec string from given codecs and mimetype.
 * @param {Object} representation
 * @returns {string}
 */        function getCodec(representation) {
            var _representation$codec = representation.codecs, codecs = void 0 === _representation$codec ? "" : _representation$codec, _representation$mimeT = representation.mimeType;
            return (void 0 === _representation$mimeT ? "" : _representation$mimeT) + ';codecs="' + codecs + '"';
        }
        // CONCATENATED MODULE: ./src/manifest/representation.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Normalized Representation structure.
 * @class Representation
 */        var manifest_representation = 
        /* */
        function() {
            /**
   * @constructor
   * @param {Object} args
   */
            function Representation(args) {
                this.id = args.id, this.bitrate = args.bitrate, this.codec = args.codecs, null != args.height && (this.height = args.height), 
                null != args.width && (this.width = args.width), null != args.mimeType && (this.mimeType = args.mimeType), 
                args.contentProtections && (this.contentProtections = args.contentProtections), 
                args.frameRate && (this.frameRate = args.frameRate), this.index = args.index;
            }
            /**
   * Returns "mime-type string" which includes both the mime-type and the codec,
   * which is often needed when interacting with the browser's APIs.
   * @returns {string}
   */            return Representation.prototype.getMimeTypeString = function getMimeTypeString() {
                return this.mimeType + ';codecs="' + this.codec + '"';
            }, Representation;
        }(), SUPPORTED_ADAPTATIONS_TYPE = [ "audio", "video", "text", "image" ], adaptation_Adaptation = 
        /* */
        function() {
            /**
   * @constructor
   * @param {Object} args
   * @param {Function|undefined} [representationFilter]
   */
            function Adaptation(args, representationFilter) {
                var _this = this;
                this.parsingErrors = [], this.id = args.id, this.type = args.type;
                var hadRepresentations = !!args.representations.length, argsRepresentations = filterSupportedRepresentations(args.type, args.representations);
                if (hadRepresentations && 0 === argsRepresentations.length) {
                    log.a.warn("Incompatible codecs for adaptation", args);
                    var error = new media_error.a("MANIFEST_INCOMPATIBLE_CODECS_ERROR", "An Adaptation contains only incompatible codecs.", !1);
                    this.parsingErrors.push(error);
                }
                null != args.language && (this.language = args.language, this.normalizedLanguage = Object(utils_languages.a)(args.language)), 
                null != args.closedCaption && (this.isClosedCaption = args.closedCaption), null != args.audioDescription && (this.isAudioDescription = args.audioDescription), 
                this.representations = argsRepresentations.map(function(representation) {
                    return new manifest_representation(representation);
                }).sort(function(a, b) {
                    return a.bitrate - b.bitrate;
                }).filter(function(representation) {
                    return null == representationFilter || representationFilter(representation, {
                        bufferType: _this.type,
                        language: _this.language,
                        normalizedLanguage: _this.normalizedLanguage,
                        isClosedCaption: _this.isClosedCaption,
                        isAudioDescription: _this.isAudioDescription
                    });
                }), // for manuallyAdded adaptations (not in the manifest)
                this.manuallyAdded = !!args.manuallyAdded;
            }
            /**
   * Returns unique bitrate for every Representation in this Adaptation.
   * @returns {Array.<Number>}
   */            var _proto = Adaptation.prototype;
            return _proto.getAvailableBitrates = function getAvailableBitrates() {
                var bitrates = this.representations.map(function(representation) {
                    return representation.bitrate;
                });
                return uniq(bitrates);
            }
            /**
   * Returns the Representation linked to the given ID.
   * @param {number|string} wantedId
   * @returns {Object|undefined}
   */ , _proto.getRepresentation = function getRepresentation(wantedId) {
                return Object(array_find.a)(this.representations, function(_ref) {
                    var id = _ref.id;
                    return wantedId === id;
                });
            }, Adaptation;
        }(), array_includes = __webpack_require__(12), object_values = __webpack_require__(92), period_Period = 
        /* */
        function() {
            /**
   * @constructor
   * @param {Object} args
   * @param {function|undefined} [representationFilter]
   */
            function Period(args, representationFilter) {
                var _this = this;
                if (this.parsingErrors = [], this.id = args.id, this.adaptations = Object.keys(args.adaptations).reduce(function(acc, type) {
                    var adaptationsForType = args.adaptations[type];
                    if (!adaptationsForType) return acc;
                    var filteredAdaptations = adaptationsForType.filter(function(adaptation) {
                        if (Object(array_includes.a)(SUPPORTED_ADAPTATIONS_TYPE, adaptation.type)) return !0;
                        log.a.info("not supported adaptation type", adaptation.type);
                        var error = new media_error.a("MANIFEST_UNSUPPORTED_ADAPTATION_TYPE", "An Adaptation has an unknown and unsupported type: " + adaptation.type, !1);
                        return _this.parsingErrors.push(error), !1;
                    }).map(function(adaptation) {
                        var _this$parsingErrors, newAdaptation = new adaptation_Adaptation(adaptation, representationFilter);
                        return (_this$parsingErrors = _this.parsingErrors).push.apply(_this$parsingErrors, newAdaptation.parsingErrors), 
                        newAdaptation;
                    }).filter(function(adaptation) {
                        return adaptation.representations.length;
                    });
                    if (0 === filteredAdaptations.length && 0 < adaptationsForType.length && ("video" === type || "audio" === type)) throw new media_error.a("MANIFEST_PARSE_ERROR", "No supported " + type + " adaptations", !0);
                    return filteredAdaptations.length && (acc[type] = filteredAdaptations), acc;
                }, {}), !this.adaptations.video && !this.adaptations.audio) throw new media_error.a("MANIFEST_PARSE_ERROR", "No supported audio and video tracks.", !0);
                this.duration = args.duration, this.start = args.start, null != this.duration && null != this.start && (this.end = this.start + this.duration);
            }
            /**
   * Returns every `Adaptations` (or `tracks`) linked to that Period, in an
   * Array.
   * @returns {Array.<Object>}
   */            var _proto = Period.prototype;
            return _proto.getAdaptations = function getAdaptations() {
                var adaptationsByType = this.adaptations;
                return Object(object_values.a)(adaptationsByType).reduce(function(acc, adaptations) {
                    // Note: the second case cannot happen. TS is just being dumb here
                    return null != adaptations ? acc.concat(adaptations) : acc;
                }, []);
            }
            /**
   * Returns every `Adaptations` (or `tracks`) linked to that Period for a
   * given type.
   * @param {string} adaptationType
   * @returns {Array.<Object>}
   */ , _proto.getAdaptationsForType = function getAdaptationsForType(adaptationType) {
                return this.adaptations[adaptationType] || [];
            }
            /**
   * Returns the Adaptation linked to the given ID.
   * @param {number|string} wantedId
   * @returns {Object|undefined}
   */ , _proto.getAdaptation = function getAdaptation(wantedId) {
                return Object(array_find.a)(this.getAdaptations(), function(_ref) {
                    var id = _ref.id;
                    return wantedId === id;
                });
            }, Period;
        }(), static_StaticRepresentationIndex = 
        /* */
        function() {
            /**
   * @param {Object} infos
   */
            function StaticRepresentationIndex(infos) {
                this._media = infos.media;
            }
            /**
   * Static contents do not have any initialization segments.
   * Just return null.
   * @returns {null}
   */            var _proto = StaticRepresentationIndex.prototype;
            return _proto.getInitSegment = function getInitSegment() {
                return null;
            }
            /**
   * Returns the only Segment available here.
   * @returns {Array.<Object>}
   */ , _proto.getSegments = function getSegments() {
                return [ {
                    id: "0",
                    isInit: !1,
                    number: 0,
                    time: 0,
                    duration: Number.MAX_VALUE,
                    timescale: 1,
                    mediaURL: this._media
                } ];
            }
            /**
   * Returns first position in index.
   * @returns {undefined}
   */ , _proto.getFirstPosition = function getFirstPosition() {
                /* tslint:enable return-undefined */}
            /**
   * Returns last position in index.
   * @returns {undefined}
   */ , _proto.getLastPosition = function getLastPosition() {}
            /**
   * Returns false as a static file never need to be refreshed.
   * @returns {Boolean}
   */ , _proto.shouldRefresh = function shouldRefresh() {
                return !1;
            }
            /**
   * @returns {Number}
   */ , _proto.checkDiscontinuity = function checkDiscontinuity() {
                return -1;
            }, _proto._addSegments = function _addSegments() {
                log.a.warn("Tried add Segments to a static RepresentationIndex");
            }, _proto._update = function _update() {
                log.a.warn("Tried to update a static RepresentationIndex");
            }, StaticRepresentationIndex;
        }();
        /* harmony default export */        
        // CONCATENATED MODULE: ./src/manifest/update_period.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Update oldPeriod attributes with the one from newPeriod (e.g. when updating
 * the Manifest).
 * @param {Object} oldPeriod
 * @param {Object} newPeriod
 */
        function updatePeriodInPlace(oldPeriod, newPeriod) {
            oldPeriod.start = newPeriod.start, oldPeriod.end = newPeriod.end, oldPeriod.duration = newPeriod.duration;
            for (var oldAdaptations = oldPeriod.getAdaptations(), newAdaptations = newPeriod.getAdaptations(), _loop = function _loop(j) {
                var oldAdaptation = oldAdaptations[j], newAdaptation = Object(array_find.a)(newAdaptations, function(a) {
                    return a.id === oldAdaptation.id;
                });
                if (newAdaptation) for (var oldRepresentations = oldAdaptations[j].representations, newRepresentations = newAdaptation.representations, _loop2 = function _loop2(k) {
                    var oldRepresentation = oldRepresentations[k], newRepresentation = Object(array_find.a)(newRepresentations, function(representation) {
                        return representation.id === oldRepresentation.id;
                    });
                    newRepresentation ? oldRepresentation.index._update(newRepresentation.index) : 
                    /* tslint:disable:max-line-length */
                    log.a.warn('Manifest: Representation "' + oldRepresentations[k].id + '" not found when merging.');
                }, k = 0; k < oldRepresentations.length; k++) _loop2(k); else log.a.warn('Manifest: Adaptation "' + oldAdaptations[j].id + '" not found when merging.');
            }, j = 0; j < oldAdaptations.length; j++) _loop(j);
        }
        // CONCATENATED MODULE: ./src/manifest/manifest.ts
                function _inheritsLoose(subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype), (subClass.prototype.constructor = subClass).__proto__ = superClass;
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        var generateNewId = Object(id_generator.a)(), manifest_Manifest = 
        /* */
        function(_EventEmitter) {
            /**
   * @constructor
   * @param {Object} args
   */
            function Manifest(args, options) {
                var _this;
                _this = _EventEmitter.call(this) || this;
                var _options$supplementar = options.supplementaryTextTracks, supplementaryTextTracks = void 0 === _options$supplementar ? [] : _options$supplementar, _options$supplementar2 = options.supplementaryImageTracks, supplementaryImageTracks = void 0 === _options$supplementar2 ? [] : _options$supplementar2, representationFilter = options.representationFilter;
                return _this.parsingErrors = [], _this.id = args.id, _this.transport = args.transportType, 
                _this.periods = args.periods.map(function(period) {
                    var _this$parsingErrors, parsedPeriod = new period_Period(period, representationFilter);
                    return (_this$parsingErrors = _this.parsingErrors).push.apply(_this$parsingErrors, parsedPeriod.parsingErrors), 
                    parsedPeriod;
                }).sort(function(a, b) {
                    return a.start - b.start;
                }), 
                /**
     * @deprecated It is here to ensure compatibility with the way the
     * v3.x.x manages adaptations at the Manifest level
     */
                /* tslint:disable:deprecation */
                _this.adaptations = _this.periods[0] && _this.periods[0].adaptations || {}, 
                /* tslint:enable:deprecation */
                _this.minimumTime = args.minimumTime, _this.isLive = args.isLive, _this.uris = args.uris || [], 
                _this.lifetime = args.lifetime, _this.suggestedPresentationDelay = args.suggestedPresentationDelay, 
                _this.availabilityStartTime = args.availabilityStartTime, _this.presentationLiveGap = args.presentationLiveGap, 
                _this.timeShiftBufferDepth = args.timeShiftBufferDepth, _this.baseURL = args.baseURL, 
                args.isLive || null != args.duration || log.a.warn("Manifest: non live content and duration is null."), 
                _this._duration = args.duration, supplementaryImageTracks.length && _this.addSupplementaryImageAdaptations(supplementaryImageTracks), 
                supplementaryTextTracks.length && _this.addSupplementaryTextAdaptations(supplementaryTextTracks), 
                _this;
            }
            /**
   * Returns Period encountered at the given time.
   * Returns undefined if there is no Period exactly at the given time.
   * @param {number} time
   * @returns {Period|undefined}
   */            _inheritsLoose(Manifest, _EventEmitter);
            var _proto = Manifest.prototype;
            return _proto.getPeriodForTime = function getPeriodForTime(time) {
                return Object(array_find.a)(this.periods, function(period) {
                    return time >= period.start && (null == period.end || period.end > time);
                });
            }
            /**
   * Returns period coming just after a given period.
   * Returns undefined if not found.
   * @param {Period} period
   * @returns {Period|null}
   */ , _proto.getPeriodAfter = function getPeriodAfter(period) {
                var endOfPeriod = period.end;
                return null == endOfPeriod ? null : Object(array_find.a)(this.periods, function(_period) {
                    return null == _period.end || endOfPeriod < _period.end;
                }) || null;
            }
            /**
   * Returns the duration of the whole content described by that Manifest.
   * @returns {Number}
   */ , _proto.getDuration = function getDuration() {
                return this._duration;
            }
            /**
   * Returns the most important URL from which the Manifest can be refreshed.
   * @returns {string|undefined}
   */ , _proto.getUrl = function getUrl() {
                return this.uris[0];
            }
            /**
   * @deprecated only returns adaptations for the first period
   * @returns {Array.<Object>}
   */ , _proto.getAdaptations = function getAdaptations() {
                Object(warn_once.a)("manifest.getAdaptations() is deprecated. Please use manifest.period[].getAdaptations() instead");
                var firstPeriod = this.periods[0];
                if (!firstPeriod) return [];
                var adaptationsByType = firstPeriod.adaptations, adaptationsList = [];
                for (var adaptationType in adaptationsByType) if (adaptationsByType.hasOwnProperty(adaptationType)) {
                    var adaptations = adaptationsByType[adaptationType];
                    adaptationsList.push.apply(adaptationsList, adaptations);
                }
                return adaptationsList;
            }
            /**
   * @deprecated only returns adaptations for the first period
   * @returns {Array.<Object>}
   */ , _proto.getAdaptationsForType = function getAdaptationsForType(adaptationType) {
                Object(warn_once.a)("manifest.getAdaptationsForType(type) is deprecated. Please use manifest.period[].getAdaptationsForType(type) instead");
                var firstPeriod = this.periods[0];
                return firstPeriod && firstPeriod.adaptations[adaptationType] || [];
            }
            /**
   * @deprecated only returns adaptations for the first period
   * @returns {Array.<Object>}
   */ , _proto.getAdaptation = function getAdaptation(wantedId) {
                /* tslint:disable:deprecation */
                return Object(warn_once.a)("manifest.getAdaptation(id) is deprecated. Please use manifest.period[].getAdaptation(id) instead"), 
                Object(array_find.a)(this.getAdaptations(), function(_ref) {
                    var id = _ref.id;
                    return wantedId === id;
                });
                /* tslint:enable:deprecation */            }
            /**
   * Update the current manifest properties
   * @param {Object} Manifest
   */ , _proto.update = function update(newManifest) {
                this._duration = newManifest.getDuration(), 
                /* tslint:disable:deprecation */
                this.adaptations = newManifest.adaptations, 
                /* tslint:enable:deprecation */
                this.availabilityStartTime = newManifest.availabilityStartTime, this.baseURL = newManifest.baseURL, 
                this.id = newManifest.id, this.isLive = newManifest.isLive, this.lifetime = newManifest.lifetime, 
                this.minimumTime = newManifest.minimumTime, this.parsingErrors = newManifest.parsingErrors, 
                this.presentationLiveGap = newManifest.presentationLiveGap, this.suggestedPresentationDelay = newManifest.suggestedPresentationDelay, 
                this.timeShiftBufferDepth = newManifest.timeShiftBufferDepth, this.transport = newManifest.transport, 
                this.uris = newManifest.uris;
                // 2 - Update Periods in both Manifests
                for (var _this$periods, oldPeriods = this.periods, newPeriods = newManifest.periods, oldPeriodCounter = 0, newPeriodCounter = 0; oldPeriodCounter < oldPeriods.length; ) {
                    var newPeriod = newPeriods[newPeriodCounter], oldPeriod = oldPeriods[oldPeriodCounter];
                    null == newPeriod ? (log.a.info("Manifest: Period " + oldPeriod.id + " not found after update. Removing."), 
                    oldPeriods.splice(oldPeriodCounter, 1), oldPeriodCounter--) : newPeriod.id === oldPeriod.id ? updatePeriodInPlace(oldPeriod, newPeriod) : (log.a.info("Manifest: Adding new Period " + newPeriod.id + " after update."), 
                    this.periods.splice(oldPeriodCounter, 0, newPeriod)), oldPeriodCounter++, newPeriodCounter++;
                }
 // adding - perhaps - new Period[s]
                                newPeriodCounter < newPeriods.length && (log.a.info("Manifest: Adding new periods after update."), 
                (_this$periods = this.periods).push.apply(_this$periods, newPeriods.slice(newPeriodCounter)));
                this.trigger("manifestUpdate", null);
            }
            /**
   * Get minimum position currently defined by the Manifest, in seconds.
   * @returns {number}
   */ , _proto.getMinimumPosition = function getMinimumPosition() {
                return this.getCurrentPositionLimits()[0];
            }
            /**
   * Get maximum position currently defined by the Manifest, in seconds.
   * @returns {number}
   */ , _proto.getMaximumPosition = function getMaximumPosition() {
                if (!this.isLive) {
                    var duration = this.getDuration();
                    return null == duration ? Infinity : duration;
                }
                var ast = this.availabilityStartTime || 0, plg = this.presentationLiveGap || 0;
                return Date.now() / 1e3 - ast - plg;
            }
            /**
   * Get minimum AND maximum positions currently defined by the manifest, in
   * seconds.
   * @returns {Array.<number>}
   */ , _proto.getCurrentPositionLimits = function getCurrentPositionLimits() {
                // TODO use RTT for the manifest request? (+ 3 or something)
                var ast = this.availabilityStartTime || 0, minimumTime = null != this.minimumTime ? this.minimumTime : 0;
                if (!this.isLive) {
                    var duration = this.getDuration();
                    return [ minimumTime, null == duration ? Infinity : duration ];
                }
                var plg = this.presentationLiveGap || 0, tsbd = this.timeShiftBufferDepth || 0, max = Date.now() / 1e3 - ast - plg;
                return [ Math.min(max, Math.max(minimumTime, max - tsbd + 5)), max ];
            }
            /**
   * Add supplementary image Adaptation(s) to the manifest.
   * @private
   * @param {Object|Array.<Object>} imageTracks
   */ , _proto.addSupplementaryImageAdaptations = function addSupplementaryImageAdaptations(imageTracks) {
                var _this2 = this, newImageTracks = (Array.isArray(imageTracks) ? imageTracks : [ imageTracks ]).map(function(_ref2) {
                    var _this2$parsingErrors, mimeType = _ref2.mimeType, url = _ref2.url, adaptationID = "gen-image-ada-" + generateNewId(), representationID = "gen-image-rep-" + generateNewId(), newAdaptation = new adaptation_Adaptation({
                        id: adaptationID,
                        type: "image",
                        manuallyAdded: !0,
                        representations: [ {
                            bitrate: 0,
                            id: representationID,
                            mimeType: mimeType,
                            index: new static_StaticRepresentationIndex({
                                media: url
                            })
                        } ]
                    });
                    return (_this2$parsingErrors = _this2.parsingErrors).push.apply(_this2$parsingErrors, newAdaptation.parsingErrors), 
                    newAdaptation;
                });
                if (newImageTracks.length && this.periods.length) {
                    var adaptations = this.periods[0].adaptations;
                    adaptations.image = adaptations.image ? adaptations.image.concat(newImageTracks) : newImageTracks;
                }
            }
            /**
   * Add supplementary text Adaptation(s) to the manifest.
   * @private
   * @param {Object|Array.<Object>} textTracks
   */ , _proto.addSupplementaryTextAdaptations = function addSupplementaryTextAdaptations(textTracks) {
                var _this3 = this, newTextAdaptations = (Array.isArray(textTracks) ? textTracks : [ textTracks ]).reduce(function(allSubs, _ref3) {
                    var mimeType = _ref3.mimeType, codecs = _ref3.codecs, url = _ref3.url, language = _ref3.language, languages = _ref3.languages, closedCaption = _ref3.closedCaption, langsToMapOn = language ? [ language ] : languages || [];
                    return allSubs.concat(langsToMapOn.map(function(_language) {
                        var _this3$parsingErrors, adaptationID = "gen-text-ada-" + generateNewId(), representationID = "gen-text-rep-" + generateNewId(), newAdaptation = new adaptation_Adaptation({
                            id: adaptationID,
                            type: "text",
                            language: _language,
                            closedCaption: closedCaption,
                            manuallyAdded: !0,
                            representations: [ {
                                bitrate: 0,
                                id: representationID,
                                mimeType: mimeType,
                                codecs: codecs,
                                index: new static_StaticRepresentationIndex({
                                    media: url
                                })
                            } ]
                        });
                        return (_this3$parsingErrors = _this3.parsingErrors).push.apply(_this3$parsingErrors, newAdaptation.parsingErrors), 
                        newAdaptation;
                    }));
                }, []);
                if (newTextAdaptations.length && this.periods.length) {
                    var adaptations = this.periods[0].adaptations;
                    adaptations.text = adaptations.text ? adaptations.text.concat(newTextAdaptations) : newTextAdaptations;
                }
            }, Manifest;
        }(event_emitter.a);
        /**
 * Normalized Manifest structure.
 * @class Manifest
 */        __webpack_exports__.a = manifest_Manifest;
    }, 
    /* 105 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // CONCATENATED MODULE: ./src/parsers/texttracks/srt/find_end_of_cue_block.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Returns the first line that is not apart of the given cue block.
 * The index given can be anywhere in a known cue block.
 *
 * This function is extra-resilient due to observed real-life malformed
 * subtitles.
 * Basically, it allows some deviation from the specification as long as the
 * intent is pretty clear.
 * @param {Array<string>} linified - Whole srt. Line by line.
 * @param {number} startIndex - Index in `linified` of the first line within the
 * block.
 * @returns {number}
 */        function findEndOfCueBlock(linified, startIndex) {
            // continue incrementing i until either:
            //   - an empty line
            //   - the end
            for (var firstEmptyLineIndex = startIndex + 1; linified[firstEmptyLineIndex]; ) firstEmptyLineIndex++;
            return firstEmptyLineIndex;
        }
        // CONCATENATED MODULE: ./src/parsers/texttracks/srt/get_cue_blocks.ts
        /* harmony export (binding) */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Get cue blocks from a srt file.
 * @param {Array.<string>} linified - Whole srt file. Each new element in this
 * array is a new line.
 * @returns {Array.<Array.<string>>}
 */
        function getCueBlocks(linified) {
            for (var cueBlocks = [], i = 0; i < linified.length; i++) if (linified[i]) {
                var endOfCue = findEndOfCueBlock(linified, i), cueBlockCandidate = linified.slice(i, endOfCue);
                0 < cueBlockCandidate.length && (1 === cueBlockCandidate.length ? 0 <= cueBlockCandidate[0].indexOf("--\x3e") && cueBlocks.push(cueBlockCandidate) : (0 <= cueBlockCandidate[1].indexOf("--\x3e") || 0 <= cueBlockCandidate[0].indexOf("--\x3e")) && cueBlocks.push(cueBlockCandidate)), 
                i = endOfCue;
            }
            return cueBlocks;
        }
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return getCueBlocks;
        });
    }, 
    /* 106 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // CONCATENATED MODULE: ./src/parsers/texttracks/srt/parse_timestamp.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Parse a single srt timestamp into seconds
 * @param {string} timestampString
 * @returns {Number|undefined}
 */        function parseTimestamp(timestampString) {
            var splittedTS = timestampString.split(":");
            if (splittedTS[2]) {
                var hours = parseInt(splittedTS[0], 10), minutes = parseInt(splittedTS[1], 10), seconds = parseFloat(splittedTS[2].replace(",", "."));
                if (isNaN(hours) || isNaN(minutes) || isNaN(seconds)) return;
                return 60 * hours * 60 + 60 * minutes + seconds;
            }
        }
        // CONCATENATED MODULE: ./src/parsers/texttracks/srt/parse_cue.ts
        /* harmony export (binding) */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Parse cue block into a cue object which contains:
 *   - start {number}: the start of the cue as a timestamp in seconds
 *   - end {number}: the end of the cue as a timestamp in seconds
 *   - payload {Array.<string>}: the payload of the cue
 * @param {Array.<string>} cueLines
 * @param {Number} timeOffset
 * @returns {Object}
 */
        function parseCueBlock(cueLines, timeOffset) {
            if (0 === cueLines.length) return null;
            var startTimeString, endTimeString, payload = [];
            // normally in srt, the timing is at second position.
            // We still authorize to put it in the first position for resilience
            if (cueLines[1] && cueLines[1].indexOf("--\x3e")) {
                var _cueLines$1$split$map = cueLines[1].split("--\x3e").map(function(s) {
                    return s.trim();
                });
                startTimeString = _cueLines$1$split$map[0], endTimeString = _cueLines$1$split$map[1], 
                payload = cueLines.slice(2, cueLines.length);
            }
            if (!startTimeString || !endTimeString) {
                // Try to see if we find them in the first position
                var _cueLines$0$split$map = cueLines[0].split("--\x3e").map(function(s) {
                    return s.trim();
                });
                startTimeString = _cueLines$0$split$map[0], endTimeString = _cueLines$0$split$map[1], 
                payload = cueLines.slice(1, cueLines.length);
            }
            if (!startTimeString || !endTimeString) 
            // if the time is still not found, exit
            return null;
            var start = parseTimestamp(startTimeString), end = parseTimestamp(endTimeString);
            return null == start || null == end ? null : {
                start: start + timeOffset,
                end: end + timeOffset,
                payload: payload
            };
        }
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return parseCueBlock;
        });
    }, 
    /* 107 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/of.js
                var of = __webpack_require__(30), defer = __webpack_require__(168), tslib_es6 = __webpack_require__(3), Subscriber = __webpack_require__(8);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/defer.js
                // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/pairwise.js
        /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
        function pairwise() {
            return function(source) {
                return source.lift(new PairwiseOperator());
            };
        }
        var PairwiseOperator = /* */ function() {
            function PairwiseOperator() {}
            return PairwiseOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new pairwise_PairwiseSubscriber(subscriber));
            }, PairwiseOperator;
        }(), pairwise_PairwiseSubscriber = /* */ function(_super) {
            function PairwiseSubscriber(destination) {
                var _this = _super.call(this, destination) || this;
                return _this.hasPrev = !1, _this;
            }
            return tslib_es6.a(PairwiseSubscriber, _super), PairwiseSubscriber.prototype._next = function(value) {
                this.hasPrev ? this.destination.next([ this.prev, value ]) : this.hasPrev = !0, 
                this.prev = value;
            }, PairwiseSubscriber;
        }(Subscriber.a), map = __webpack_require__(34), filter = __webpack_require__(139), startWith = __webpack_require__(176), switchMap = __webpack_require__(119), tap = __webpack_require__(123), log = __webpack_require__(0);
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Manage playback speed.
 * Set playback rate set by the user, pause playback when the player appear to
 * stall and restore the speed once it appears to un-stall.
 *
 * @param {HTMLMediaElement} mediaElement
 * @param {Observable} speed$ - emit speed set by the user
 * @param {Observable} clock$
 * @param {Object} options - Contains the following properties:
 *   - pauseWhenStalled {Boolean|undefined} - true if the player
 *     stalling should lead to a pause until it un-stalls. True by default.
 * @returns {Observable}
 */
        function updatePlaybackRate(mediaElement, speed$, clock$, _ref) {
            var forcePause$, _ref$pauseWhenStalled = _ref.pauseWhenStalled;
            void 0 === _ref$pauseWhenStalled || _ref$pauseWhenStalled ? forcePause$ = clock$.pipe(pairwise()).pipe(Object(map.a)(function(_ref2) {
                var prevTiming = _ref2[0], isStalled = _ref2[1].stalled, wasStalled = prevTiming.stalled;
                if (!wasStalled != !isStalled || // xor
                wasStalled && isStalled && wasStalled.reason !== isStalled.reason) return !wasStalled;
            }), Object(filter.a)(function(val) {
                return null != val;
            }), Object(startWith.a)(!1)) : forcePause$ = Object(of.a)(!1);
            return forcePause$.pipe(Object(switchMap.a)(function(shouldForcePause) {
                return shouldForcePause ? Object(defer.a)(function() {
                    return log.a.info("Init: Pause playback to build buffer"), mediaElement.playbackRate = 0, 
                    Object(of.a)(0);
                }) : speed$.pipe(Object(tap.a)(function(speed) {
                    log.a.info("Init: Resume playback speed", speed), mediaElement.playbackRate = speed;
                }));
            }));
        }
        /***/        
        // CONCATENATED MODULE: ./src/core/init/update_playback_rate.ts
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return updatePlaybackRate;
        });
    }, 
    /* 108 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/mergeMap.js
                var mergeMap = __webpack_require__(39);
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/util/identity.js
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */        function identity(x) {
            return x;
        }
        //# sourceMappingURL=identity.js.map
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/mergeAll.js
        /* harmony export (binding) */        
        /** PURE_IMPORTS_START _mergeMap,_util_identity PURE_IMPORTS_END */
        function mergeAll(concurrent) {
            return void 0 === concurrent && (concurrent = Number.POSITIVE_INFINITY), Object(mergeMap.a)(identity, concurrent);
        }
        //# sourceMappingURL=mergeAll.js.map
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return mergeAll;
        });
    }, 
    /* 109 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/parse_timestamp.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Parse a single webvtt timestamp into seconds
 * @param {string} timestampString
 * @returns {Number|undefined}
 */        function parseTimestamp(timestampString) {
            var splittedTS = timestampString.split(":").reverse();
            if (splittedTS[2] || splittedTS[1]) {
                var hours = splittedTS[2] ? parseInt(splittedTS[2], 10) : 0, minutes = parseInt(splittedTS[1], 10), seconds = parseFloat(splittedTS[0].replace(",", "."));
                if (isNaN(hours) || isNaN(minutes) || isNaN(seconds)) return;
                return 60 * hours * 60 + 60 * minutes + seconds;
            }
        }
        // CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/parse_cue_block.ts
        /* harmony export (binding) */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Parse the settings part of a cue, into key-value object.
 * @param {string} settingsString
 * @returns {Object}
 */
        function parseSettings(settingsString) {
            return settingsString.split(/ |\t/).reduce(function(acc, setting) {
                var splittedSetting = setting.split(":");
                return 2 === splittedSetting.length && (acc[splittedSetting[0]] = splittedSetting[1]), 
                acc;
            }, {});
        }
        /**
 * Parse the line containing the timestamp and settings in a cue.
 * The returned object has the following properties:
 *   - start {Number}: start of the cue, in seconds
 *   - end {Number}: end of the cue, in seconds
 *   - settings {Object}: settings for the cue as a key-value object.
 * @param {string} timeString
 * @returns {Object|null}
 */        function parseTimeAndSettings(timeString) {
            /**
   * RegExp for the timestamps + settings line.
   *
   * Capture groups:
   *   1 -> start timestamp
   *   2 -> end timestamp
   *   3 - settings
   * @type {RegExp}
   */
            var matches = timeString.match(/^([\d:.]+)[ |\t]+-->[ |\t]+([\d:.]+)[ |\t]*(.*)$/);
            if (!matches) return null;
            var start = parseTimestamp(matches[1]), end = parseTimestamp(matches[2]);
            return null == start || null == end ? null : {
                start: start,
                end: end,
                settings: parseSettings(matches[3])
            };
        }
        /**
 * Parse cue block into a cue object which contains:
 *   - start {number}: the start of the cue as a timestamp in seconds
 *   - end {number}: the end of the cue as a timestamp in seconds
 *   - header {string|undefined}: The optional cue identifier
 *   - payload {Array.<string>}: the payload of the cue
 * @param {Array.<string>} cueLines
 * @param {Number} timeOffset
 * @returns {Object}
 */        function parseCueBlock(cueLines, timeOffset) {
            var timeString, payload, header, timingRegexp = /-->/;
            if (timingRegexp.test(cueLines[0])) timeString = cueLines[0], payload = cueLines.slice(1, cueLines.length); else {
                if (!timingRegexp.test(cueLines[1])) 
                // not a cue
                return null;
                header = cueLines[0], timeString = cueLines[1], payload = cueLines.slice(2, cueLines.length);
            }
            var timeAndSettings = parseTimeAndSettings(timeString);
            return timeAndSettings ? {
                start: timeAndSettings.start + timeOffset,
                end: timeAndSettings.end + timeOffset,
                settings: timeAndSettings.settings,
                payload: payload,
                header: header
            } : null;
        }
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return parseCueBlock;
        });
    }, 
    /* 110 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // EXTERNAL MODULE: ./src/parsers/texttracks/ttml/regexps.ts
                var regexps = __webpack_require__(18);
        // CONCATENATED MODULE: ./src/parsers/texttracks/ttml/time_parsing.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Parses a TTML time into seconds.
 * @param {string} text
 * @param {Object} ttParams
 * @returns {Number|undefined}
 */        
        /**
 * Parses a TTML time in frame format
 * @param {Object} ttParams
 * @param {string} text
 * @returns {Number}
 */
        function parseFramesTime(ttParams, text) {
            // 75f or 75.5f
            // (We cast as we're sure the regexp is respected here)
            var results = regexps.g.exec(text);
            return Number(results[1]) / ttParams.frameRate;
        }
        /**
 * Parses a TTML time in tick format
 * @param {Object} ttParams
 * @param {string} text
 * @returns {Number}
 */        function parseTickTime(ttParams, text) {
            // 50t or 50.5t
            // (We cast as we're sure the regexp is respected here)
            var results = regexps.i.exec(text);
            return Number(results[1]) / ttParams.tickRate;
        }
        /**
 * Parses a TTML colon formatted time containing frames
 * @param {Object} ttParams
 * @param {string} text
 * @returns {Number}
 */        function parseColonTimeWithFrames(ttParams, text) {
            // 01:02:43:07 ("07" is frames) or 01:02:43:07.1 (subframes)
            // (We cast as we're sure the regexp is respected here)
            var results = regexps.e.exec(text), hours = Number(results[1]), minutes = Number(results[2]), seconds = Number(results[3]), frames = Number(results[4]);
            return (seconds += (frames += (Number(results[5]) || 0) / ttParams.subFrameRate) / ttParams.frameRate) + 60 * minutes + 3600 * hours;
        }
        /**
 * Parses a TTML time with a given regex. Expects regex to be some
 * sort of a time-matcher to match hours, minutes, seconds and milliseconds
 *
 * @param {RegExp} regex
 * @param {string} text
 * @returns {number|null}
 */        function parseTimeFromRegExp(regex, text) {
            var results = regex.exec(text);
            if (null === results || "" === results[0]) return null;
 // This capture is optional, but will still be in the array as undefined,
            // default to 0.
                        var hours = Number(results[1]) || 0, minutes = Number(results[2]) || 0, seconds = Number(results[3]) || 0;
            return (Number(results[4]) || 0) / 1e3 + seconds + 60 * minutes + 3600 * hours;
        }
        /* harmony default export */        var time_parsing = function parseTime(text, ttParams) {
            return regexps.e.test(text) ? parseColonTimeWithFrames(ttParams, text) : regexps.d.test(text) ? parseTimeFromRegExp(regexps.d, text) : regexps.f.test(text) ? parseTimeFromRegExp(regexps.f, text) : regexps.g.test(text) ? parseFramesTime(ttParams, text) : regexps.i.test(text) ? parseTickTime(ttParams, text) : regexps.h.test(text) ? parseTimeFromRegExp(regexps.h, text) : void 0;
        };
        // CONCATENATED MODULE: ./src/parsers/texttracks/ttml/get_time_delimiters.ts
        /* harmony export (binding) */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Get start and end time of an element.
 * @param {Element} element
 * @param {Object} ttParams
 * @returns {Object}
 */
        function getTimeDelimiters(element, ttParams) {
            var beginAttr = element.getAttribute("begin"), durationAttr = element.getAttribute("dur"), endAttr = element.getAttribute("end"), start = beginAttr ? time_parsing(beginAttr, ttParams) : null, duration = durationAttr ? time_parsing(durationAttr, ttParams) : null, parsedEnd = endAttr ? time_parsing(endAttr, ttParams) : null;
            if (null == start || null == parsedEnd && null == duration) throw new Error("Invalid text cue");
 // Huh? Is TypeScript that dumb here?
                        return {
                start: start,
                end: null == parsedEnd ? start + duration : parsedEnd
            };
        }
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return getTimeDelimiters;
        });
    }, 
    /* 111 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "c", function() {
            return getTRAF;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return getMDAT;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() {
            return getMDIA;
        });
        /* harmony import */ var _get_box__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(63);
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Returns TRAF Box from the whole ISOBMFF File.
 * Returns null if not found.
 * @param {Uint8Array} buffer
 * @returns {Uint8Array|null}
 */        function getTRAF(buffer) {
            var moof = Object(_get_box__WEBPACK_IMPORTED_MODULE_0__.b)(buffer, 1836019558
            /* moof */);
            return moof ? Object(_get_box__WEBPACK_IMPORTED_MODULE_0__.b)(moof, 1953653094
            /* traf */) : null;
        }
        /**
 * Returns MDAT Box from the whole ISOBMFF File.
 * Returns null if not found.
 * @param {Uint8Array} buffer
 * @returns {Uint8Array|null}
 */        function getMDAT(buf) {
            return Object(_get_box__WEBPACK_IMPORTED_MODULE_0__.b)(buf, 1835295092
            /* "mdat" */);
        }
        /**
 * Returns MDIA Box from the whole ISOBMFF File.
 * Returns null if not found.
 * @param {Uint8Array} buffer
 * @returns {Uint8Array|null}
 */        function getMDIA(buf) {
            var moov = Object(_get_box__WEBPACK_IMPORTED_MODULE_0__.b)(buf, 1836019574
            /* moov */);
            if (!moov) return null;
            var trak = Object(_get_box__WEBPACK_IMPORTED_MODULE_0__.b)(moov, 1953653099
            /* "trak" */);
            return trak ? Object(_get_box__WEBPACK_IMPORTED_MODULE_0__.b)(trak, 1835297121
            /* "mdia" */) : null;
        }
        /***/    }, 
    /* 112 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return merge;
        });
        /* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6), _util_isScheduler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(40), _operators_mergeAll__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(108), _fromArray__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(36);
        /* harmony import */        
        /** PURE_IMPORTS_START _Observable,_util_isScheduler,_operators_mergeAll,_fromArray PURE_IMPORTS_END */
        function merge() {
            for (var observables = [], _i = 0; _i < arguments.length; _i++) observables[_i] = arguments[_i];
            var concurrent = Number.POSITIVE_INFINITY, scheduler = null, last = observables[observables.length - 1];
            return Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_1__.a)(last) ? (scheduler = observables.pop(), 
            1 < observables.length && "number" == typeof observables[observables.length - 1] && (concurrent = observables.pop())) : "number" == typeof last && (concurrent = observables.pop()), 
            null === scheduler && 1 === observables.length && observables[0] instanceof _Observable__WEBPACK_IMPORTED_MODULE_0__.a ? observables[0] : Object(_operators_mergeAll__WEBPACK_IMPORTED_MODULE_2__.a)(concurrent)(Object(_fromArray__WEBPACK_IMPORTED_MODULE_3__.a)(observables, scheduler));
        }
        //# sourceMappingURL=merge.js.map
        /***/    }, 
    /* 113 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return take;
        });
        /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3), _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8), _util_ArgumentOutOfRangeError__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(99), _observable_empty__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(38);
        /* harmony import */        
        /** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError,_observable_empty PURE_IMPORTS_END */
        function take(count) {
            return function(source) {
                return 0 === count ? Object(_observable_empty__WEBPACK_IMPORTED_MODULE_3__.b)() : source.lift(new TakeOperator(count));
            };
        }
        var TakeOperator = /* */ function() {
            function TakeOperator(total) {
                if (this.total = total, this.total < 0) throw new _util_ArgumentOutOfRangeError__WEBPACK_IMPORTED_MODULE_2__.a();
            }
            return TakeOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new TakeSubscriber(subscriber, this.total));
            }, TakeOperator;
        }(), TakeSubscriber = /* */ function(_super) {
            function TakeSubscriber(destination, total) {
                var _this = _super.call(this, destination) || this;
                return _this.total = total, _this.count = 0, _this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(TakeSubscriber, _super), TakeSubscriber.prototype._next = function(value) {
                var total = this.total, count = ++this.count;
                count <= total && (this.destination.next(value), count === total && (this.destination.complete(), 
                this.unsubscribe()));
            }, TakeSubscriber;
        }(_Subscriber__WEBPACK_IMPORTED_MODULE_1__.a);
    }, 
    /* 114 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return setElementSrc$;
        });
        /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6), _log__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(0), _clear_element_src__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(72);
        /* harmony import */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Set an URL to the element's src.
 * Emit ``undefined`` when done.
 * Unlink src on unsubscription.
 *
 * @param {HTMLMediaElement} mediaElement
 * @param {string} url
 * @returns {Observable}
 */
        function setElementSrc$(mediaElement, url) {
            return new rxjs__WEBPACK_IMPORTED_MODULE_0__.a(function(observer) {
                return _log__WEBPACK_IMPORTED_MODULE_1__.a.info("Setting URL to Element", url, mediaElement), 
                mediaElement.src = url, observer.next(void 0), function() {
                    Object(_clear_element_src__WEBPACK_IMPORTED_MODULE_2__.a)(mediaElement);
                };
            });
        }
        /***/    }, 
    /* 115 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return play$;
        });
        /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(168), _utils_cast_to_observable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(17), _utils_rx_try_catch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(43);
        /* harmony import */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Call play on the media element on subscription and return the response as an
 * observable.
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */
        function play$(mediaElement) {
            return Object(rxjs__WEBPACK_IMPORTED_MODULE_0__.a)(function() {
                // mediaElement.play is not always a Promise. In the improbable case it
                // throws, I prefer still to catch to return the error wrapped in an
                // Observable
                return Object(_utils_rx_try_catch__WEBPACK_IMPORTED_MODULE_2__.a)(function() {
                    return Object(_utils_cast_to_observable__WEBPACK_IMPORTED_MODULE_1__.a)(mediaElement.play());
                }, void 0);
            });
        }
        /***/    }, 
    /* 116 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return whenLoadedMetadata$;
        });
        /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(30), rxjs_operators__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(113), _browser_compatibility_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(19), _event_listeners__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(44);
        /* harmony import */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Returns an observable emitting a single time, as soon as a seek is possible
 * (the metadata are loaded).
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */
        function whenLoadedMetadata$(mediaElement) {
            return mediaElement.readyState >= _browser_compatibility_types__WEBPACK_IMPORTED_MODULE_2__.d.HAVE_METADATA ? Object(rxjs__WEBPACK_IMPORTED_MODULE_0__.a)(null) : Object(_event_listeners__WEBPACK_IMPORTED_MODULE_3__.onLoadedMetadata$)(mediaElement).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_1__.a)(1));
        }
        /***/    }, 
    /* 117 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return hasEMEAPIs;
        });
        /* harmony import */ var _eme__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(121);
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Returns true if the browser has the minimum needed EME APIs to decrypt a
 * content.
 * @returns {Boolean}
 */        function hasEMEAPIs() {
            return "function" == typeof _eme__WEBPACK_IMPORTED_MODULE_0__.c;
        }
        /***/    }, 
    /* 118 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return isPlaybackStuck;
        });
        /* harmony import */ var _browser_detection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(20);
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * firefox fix: sometimes playback can be stalled, even if we are in a buffer.
 * TODO This seems to be about an old Firefox version. Delete it?
 * @param {number} time
 * @param {Object|null} currentRange
 * @param {string} state
 * @param {Boolean} isStalled
 * @returns {Boolean}
 */        function isPlaybackStuck(time, currentRange, state, isStalled) {
            // freeze threshold in seconds
            return _browser_detection__WEBPACK_IMPORTED_MODULE_0__.a && isStalled && "timeupdate" === state && !!currentRange && 10 < currentRange.end - time;
        }
        /***/    }, 
    /* 119 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return switchMap;
        });
        /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3), _OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(25), _InnerSubscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(47), _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(24), _map__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(34), _observable_from__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(53);
        /* harmony import */        
        /** PURE_IMPORTS_START tslib,_OuterSubscriber,_InnerSubscriber,_util_subscribeToResult,_map,_observable_from PURE_IMPORTS_END */
        function switchMap(project, resultSelector) {
            return "function" == typeof resultSelector ? function(source) {
                return source.pipe(switchMap(function(a, i) {
                    return Object(_observable_from__WEBPACK_IMPORTED_MODULE_5__.a)(project(a, i)).pipe(Object(_map__WEBPACK_IMPORTED_MODULE_4__.a)(function(b, ii) {
                        return resultSelector(a, b, i, ii);
                    }));
                }));
            } : function(source) {
                return source.lift(new SwitchMapOperator(project));
            };
        }
        var SwitchMapOperator = /* */ function() {
            function SwitchMapOperator(project) {
                this.project = project;
            }
            return SwitchMapOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new SwitchMapSubscriber(subscriber, this.project));
            }, SwitchMapOperator;
        }(), SwitchMapSubscriber = /* */ function(_super) {
            function SwitchMapSubscriber(destination, project) {
                var _this = _super.call(this, destination) || this;
                return _this.project = project, _this.index = 0, _this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(SwitchMapSubscriber, _super), SwitchMapSubscriber.prototype._next = function(value) {
                var result, index = this.index++;
                try {
                    result = this.project(value, index);
                } catch (error) {
                    return void this.destination.error(error);
                }
                this._innerSub(result, value, index);
            }, SwitchMapSubscriber.prototype._innerSub = function(result, value, index) {
                var innerSubscription = this.innerSubscription;
                innerSubscription && innerSubscription.unsubscribe();
                var innerSubscriber = new _InnerSubscriber__WEBPACK_IMPORTED_MODULE_2__.a(this, void 0, void 0);
                this.destination.add(innerSubscriber), this.innerSubscription = Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_3__.a)(this, result, value, index, innerSubscriber);
            }, SwitchMapSubscriber.prototype._complete = function() {
                var innerSubscription = this.innerSubscription;
                innerSubscription && !innerSubscription.closed || _super.prototype._complete.call(this), 
                this.unsubscribe();
            }, SwitchMapSubscriber.prototype._unsubscribe = function() {
                this.innerSubscription = null;
            }, SwitchMapSubscriber.prototype.notifyComplete = function(innerSub) {
                this.destination.remove(innerSub), this.innerSubscription = null, this.isStopped && _super.prototype._complete.call(this);
            }, SwitchMapSubscriber.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
                this.destination.next(innerValue);
            }, SwitchMapSubscriber;
        }(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__.a);
    }, 
    /* 120 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js
                var NotificationKind, tslib_es6 = __webpack_require__(3), Subscriber = __webpack_require__(8), empty = __webpack_require__(38), of = __webpack_require__(30), throwError = __webpack_require__(74);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subscriber.js
                NotificationKind || (NotificationKind = {});
        var Notification_Notification = /* */ function() {
            function Notification(kind, value, error) {
                this.kind = kind, this.value = value, this.error = error, this.hasValue = "N" === kind;
            }
            return Notification.prototype.observe = function(observer) {
                switch (this.kind) {
                  case "N":
                    return observer.next && observer.next(this.value);

                  case "E":
                    return observer.error && observer.error(this.error);

                  case "C":
                    return observer.complete && observer.complete();
                }
            }, Notification.prototype.do = function(next, error, complete) {
                switch (this.kind) {
                  case "N":
                    return next && next(this.value);

                  case "E":
                    return error && error(this.error);

                  case "C":
                    return complete && complete();
                }
            }, Notification.prototype.accept = function(nextOrObserver, error, complete) {
                return nextOrObserver && "function" == typeof nextOrObserver.next ? this.observe(nextOrObserver) : this.do(nextOrObserver, error, complete);
            }, Notification.prototype.toObservable = function() {
                switch (this.kind) {
                  case "N":
                    return Object(of.a)(this.value);

                  case "E":
                    return Object(throwError.a)(this.error);

                  case "C":
                    return Object(empty.b)();
                }
                throw new Error("unexpected notification kind value");
            }, Notification.createNext = function(value) {
                return void 0 !== value ? new Notification("N", value) : Notification.undefinedValueNotification;
            }, Notification.createError = function(err) {
                return new Notification("E", void 0, err);
            }, Notification.createComplete = function() {
                return Notification.completeNotification;
            }, Notification.completeNotification = new Notification("C"), Notification.undefinedValueNotification = new Notification("N", void 0), 
            Notification;
        }();
        //# sourceMappingURL=Notification.js.map
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/observeOn.js
        /* harmony export (binding) */        
        /* unused harmony export ObserveOnMessage */
        /** PURE_IMPORTS_START tslib,_Subscriber,_Notification PURE_IMPORTS_END */
        function observeOn(scheduler, delay) {
            return void 0 === delay && (delay = 0), function observeOnOperatorFunction(source) {
                return source.lift(new ObserveOnOperator(scheduler, delay));
            };
        }
        __webpack_require__.d(__webpack_exports__, "b", function() {
            return observeOn;
        }), 
        /* unused harmony export ObserveOnOperator */
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return observeOn_ObserveOnSubscriber;
        });
        var ObserveOnOperator = /* */ function() {
            function ObserveOnOperator(scheduler, delay) {
                void 0 === delay && (delay = 0), this.scheduler = scheduler, this.delay = delay;
            }
            return ObserveOnOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new observeOn_ObserveOnSubscriber(subscriber, this.scheduler, this.delay));
            }, ObserveOnOperator;
        }(), observeOn_ObserveOnSubscriber = /* */ function(_super) {
            function ObserveOnSubscriber(destination, scheduler, delay) {
                void 0 === delay && (delay = 0);
                var _this = _super.call(this, destination) || this;
                return _this.scheduler = scheduler, _this.delay = delay, _this;
            }
            return tslib_es6.a(ObserveOnSubscriber, _super), ObserveOnSubscriber.dispatch = function(arg) {
                var notification = arg.notification, destination = arg.destination;
                notification.observe(destination), this.unsubscribe();
            }, ObserveOnSubscriber.prototype.scheduleMessage = function(notification) {
                this.destination.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));
            }, ObserveOnSubscriber.prototype._next = function(value) {
                this.scheduleMessage(Notification_Notification.createNext(value));
            }, ObserveOnSubscriber.prototype._error = function(err) {
                this.scheduleMessage(Notification_Notification.createError(err)), this.unsubscribe();
            }, ObserveOnSubscriber.prototype._complete = function() {
                this.scheduleMessage(Notification_Notification.createComplete()), this.unsubscribe();
            }, ObserveOnSubscriber;
        }(Subscriber.a), ObserveOnMessage = /* */ function() {
            return function ObserveOnMessage(notification, destination) {
                this.notification = notification, this.destination = destination;
            };
        }();
    }, 
    /* 121 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subject.js
                var Subject = __webpack_require__(42), merge = __webpack_require__(112), throwError = __webpack_require__(74), of = __webpack_require__(30), takeUntil = __webpack_require__(178), byte_parsing = __webpack_require__(1), cast_to_observable = __webpack_require__(17), event_emitter = __webpack_require__(33), promise = __webpack_require__(28), browser_compatibility_types = __webpack_require__(19), browser_detection = __webpack_require__(20), event_listeners = __webpack_require__(44);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/merge.js
                // CONCATENATED MODULE: ./src/compat/eme/custom_key_system_access.ts
        function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        function _createClass(Constructor, protoProps, staticProps) {
            return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), 
            Constructor;
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        // XXX TODO remove when the issue is resolved
        // https://github.com/Microsoft/TypeScript/issues/19189
        /**
 * Simple implementation of the MediaKeySystemAccess EME API.
 *
 * All needed arguments are given to the constructor
 * @class CustomMediaKeySystemAccess
 */        var custom_key_system_access_CustomMediaKeySystemAccess = 
        /* */
        function() {
            /**
   * @param {string} _keyType
   * @param {Object} _mediaKeys
   * @param {Object} _configuration
   */
            function CustomMediaKeySystemAccess(_keyType, _mediaKeys, _configuration) {
                this._keyType = _keyType, this._mediaKeys = _mediaKeys, this._configuration = _configuration;
            }
            /**
   * @returns {string}
   */            var _proto = CustomMediaKeySystemAccess.prototype;
            /**
   * @returns {Promise}
   */            return _proto.createMediaKeys = function createMediaKeys() {
                var _this = this;
                return new promise.a(function(res) {
                    return res(_this._mediaKeys);
                });
            }
            /**
   * @returns {Object}
   */ , _proto.getConfiguration = function getConfiguration() {
                return this._configuration;
            }, _createClass(CustomMediaKeySystemAccess, [ {
                key: "keySystem",
                get: function get() {
                    return this._keyType;
                }
            } ]), CustomMediaKeySystemAccess;
        }();
        // CONCATENATED MODULE: ./src/compat/eme/custom_media_keys.ts
        /* harmony export (binding) */        function _inheritsLoose(subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype), (subClass.prototype.constructor = subClass).__proto__ = superClass;
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return createSession;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() {
            return custom_media_keys_requestMediaKeySystemAccess;
        });
        var custom_media_keys_requestMediaKeySystemAccess = null, createSession = function createMediaKeysSession(mediaKeys, sessionType) {
            return mediaKeys.createSession(sessionType);
        }, CustomMediaKeys = 
        /* */
        function() {
            function CustomMediaKeys() {}
            var _proto = CustomMediaKeys.prototype;
            return _proto._setVideo = function _setVideo() {
                throw new Error("MediaKeys is not implemented in your browser");
            }, _proto.createSession = function createSession() {
                throw new Error("MediaKeys is not implemented in your browser");
            }, _proto.setServerCertificate = function setServerCertificate() {
                throw new Error("MediaKeys is not implemented in your browser");
            }, CustomMediaKeys;
        }();
        if (navigator.requestMediaKeySystemAccess) custom_media_keys_requestMediaKeySystemAccess = function requestMediaKeySystemAccess(a, b) {
            return Object(cast_to_observable.a)(navigator.requestMediaKeySystemAccess(a, b));
        }; else {
            // Wrap "MediaKeys.prototype.update" form an event based system to a
            // Promise based function.
            var custom_media_keys_wrapUpdate = function wrapUpdate(memUpdate) {
                return function(license, sessionId) {
                    var _this = this;
                    return new promise.a(function(resolve, reject) {
                        try {
                            memUpdate.call(_this, license, sessionId || ""), resolve();
                        } catch (e) {
                            reject(e);
                        }
                    });
                };
            }, isOldWebkitMediaElement = function isOldWebkitMediaElement(element) {
                return "function" == typeof element.webkitGenerateKeyRequest;
            };
            /**
   * Returns true if the given media element has old webkit methods
   * corresponding to the IOldWebkitHTMLMediaElement interface.
   * @param {HTMLMediaElement} element
   * @returns {Boolean}
   */            // This is for Chrome with unprefixed EME api
            if (isOldWebkitMediaElement(HTMLVideoElement.prototype)) {
                var custom_media_keys_WebkitMediaKeySession = 
                /* */
                function(_EventEmitter) {
                    function WebkitMediaKeySession(mediaElement, keySystem) {
                        var _this2;
                        return (_this2 = _EventEmitter.call(this) || this)._closeSession$ = new Subject.a(), 
                        _this2._vid = mediaElement, _this2._key = keySystem, _this2.sessionId = "", _this2.closed = new promise.a(function(resolve) {
                            _this2._closeSession$.subscribe(resolve);
                        }), _this2.keyStatuses = new Map(), _this2.expiration = NaN, Object(merge.a)(event_listeners.onKeyMessage$(mediaElement), event_listeners.onKeyAdded$(mediaElement), event_listeners.onKeyError$(mediaElement)).pipe(Object(takeUntil.a)(_this2._closeSession$)).subscribe(function(evt) {
                            return _this2.trigger(evt.type, evt);
                        }), _this2.update = custom_media_keys_wrapUpdate(function(license, sessionId) {
                            if (!isOldWebkitMediaElement(_this2._vid)) throw new Error("impossible to add a new key");
                            if (0 <= _this2._key.indexOf("clearkey")) {
                                var licenseTypedArray = license instanceof ArrayBuffer ? new Uint8Array(license) : license, json = JSON.parse(Object(byte_parsing.f)(licenseTypedArray)), key = Object(byte_parsing.p)(atob(json.keys[0].k)), kid = Object(byte_parsing.p)(atob(json.keys[0].kid));
                                _this2._vid.webkitAddKey(_this2._key, key, kid, sessionId);
                            } else _this2._vid.webkitAddKey(_this2._key, license, null, sessionId);
                            _this2.sessionId = sessionId;
                        }), _this2;
                    }
                    _inheritsLoose(WebkitMediaKeySession, _EventEmitter);
                    var _proto2 = WebkitMediaKeySession.prototype;
                    return _proto2.generateRequest = function generateRequest(_initDataType, initData) {
                        var _this3 = this;
                        return new promise.a(function(resolve) {
                            if (!isOldWebkitMediaElement(_this3._vid)) throw new Error("impossible to generate a key request");
                            _this3._vid.webkitGenerateKeyRequest(_this3._key, initData), resolve();
                        });
                    }, _proto2.close = function close() {
                        var _this4 = this;
                        return new promise.a(function(resolve) {
                            _this4._closeSession$.next(), _this4._closeSession$.complete(), resolve();
                        });
                    }, _proto2.load = function load() {
                        return promise.a.resolve(!1);
                    }, _proto2.remove = function remove() {
                        return promise.a.resolve();
                    }, WebkitMediaKeySession;
                }(event_emitter.a);
                CustomMediaKeys = 
                /* */
                function() {
                    function CustomMediaKeys(keySystem) {
                        this.ks_ = keySystem;
                    }
                    var _proto3 = CustomMediaKeys.prototype;
                    return _proto3._setVideo = function _setVideo(vid) {
                        this._vid = vid;
                    }, _proto3.createSession = function createSession() {
                        if (!this._vid) throw new Error("Video not attached to the MediaKeys");
                        return new custom_media_keys_WebkitMediaKeySession(this._vid, this.ks_);
                    }, _proto3.setServerCertificate = function setServerCertificate() {
                        throw new Error("Server certificate is not implemented in your browser");
                    }, CustomMediaKeys;
                }();
                var isTypeSupported = function isTypeSupported(keyType) {
                    // get any <video> element from the DOM or create one
                    // and try the `canPlayType` method
                    var videoElement = document.querySelector("video") || document.createElement("video");
                    return !(!videoElement || !videoElement.canPlayType) && !!videoElement.canPlayType("video/mp4", keyType);
                };
                custom_media_keys_requestMediaKeySystemAccess = function requestMediaKeySystemAccess(keyType, keySystemConfigurations) {
                    if (!isTypeSupported(keyType)) return Object(throwError.a)(void 0);
                    for (var i = 0; i < keySystemConfigurations.length; i++) {
                        var keySystemConfiguration = keySystemConfigurations[i], videoCapabilities = keySystemConfiguration.videoCapabilities, audioCapabilities = keySystemConfiguration.audioCapabilities, initDataTypes = keySystemConfiguration.initDataTypes, sessionTypes = keySystemConfiguration.sessionTypes, distinctiveIdentifier = keySystemConfiguration.distinctiveIdentifier, persistentState = keySystemConfiguration.persistentState, supported = !0;
                        if (supported = (supported = (supported = (supported = supported && (!initDataTypes || !!initDataTypes.filter(function(initDataType) {
                            return "cenc" === initDataType;
                        })[0])) && (!sessionTypes || sessionTypes.filter(function(sessionType) {
                            return "temporary" === sessionType;
                        }).length === sessionTypes.length)) && "required" !== distinctiveIdentifier) && "required" !== persistentState) {
                            var keySystemConfigurationResponse = {
                                videoCapabilities: videoCapabilities,
                                audioCapabilities: audioCapabilities,
                                initDataTypes: [ "cenc" ],
                                sessionTypes: [ "temporary" ],
                                distinctiveIdentifier: "not-allowed",
                                persistentState: "not-allowed"
                            };
                            return Object(of.a)(new custom_key_system_access_CustomMediaKeySystemAccess(keyType, new CustomMediaKeys(keyType), keySystemConfigurationResponse));
                        }
                    }
                    return Object(throwError.a)(void 0);
                };
            } else if (browser_compatibility_types.b && browser_compatibility_types.b.prototype && "function" == typeof browser_compatibility_types.b.isTypeSupported && (custom_media_keys_requestMediaKeySystemAccess = function requestMediaKeySystemAccess(keyType, keySystemConfigurations) {
                // TODO Why TS Do not understand that isTypeSupported exists here?
                if (!browser_compatibility_types.b.isTypeSupported(keyType)) return Object(throwError.a)(void 0);
                for (var i = 0; i < keySystemConfigurations.length; i++) {
                    var keySystemConfiguration = keySystemConfigurations[i], videoCapabilities = keySystemConfiguration.videoCapabilities, audioCapabilities = keySystemConfiguration.audioCapabilities, initDataTypes = keySystemConfiguration.initDataTypes, distinctiveIdentifier = keySystemConfiguration.distinctiveIdentifier, supported = !0;
                    if (supported = (supported = supported && (!initDataTypes || !!initDataTypes.filter(function(idt) {
                        return "cenc" === idt;
                    })[0])) && "required" !== distinctiveIdentifier) {
                        var keySystemConfigurationResponse = {
                            videoCapabilities: videoCapabilities,
                            audioCapabilities: audioCapabilities,
                            initDataTypes: [ "cenc" ],
                            distinctiveIdentifier: "not-allowed",
                            persistentState: "required",
                            sessionTypes: [ "temporary", "persistent-license" ]
                        };
                        return Object(of.a)(new custom_key_system_access_CustomMediaKeySystemAccess(keyType, new browser_compatibility_types.b(keyType), keySystemConfigurationResponse));
                    }
                }
                return Object(throwError.a)(void 0);
            }, browser_detection.b && "function" == typeof browser_compatibility_types.b.prototype.createSession)) {
                var custom_media_keys_IE11MediaKeySession = 
                /* */
                function(_EventEmitter2) {
                    function IE11MediaKeySession(mk) {
                        var _this5;
                        return (_this5 = _EventEmitter2.call(this) || this).sessionId = "", _this5.expiration = NaN, 
                        _this5.keyStatuses = new Map(), _this5._mk = mk, _this5._closeSession$ = new Subject.a(), 
                        _this5.closed = new promise.a(function(resolve) {
                            _this5._closeSession$.subscribe(resolve);
                        }), _this5.update = custom_media_keys_wrapUpdate(function(license, sessionId) {
                            if (!_this5._ss) throw new Error("MediaKeySession not set");
                            _this5._ss.update(license, sessionId), _this5.sessionId = sessionId;
                        }), _this5;
                    }
                    _inheritsLoose(IE11MediaKeySession, _EventEmitter2);
                    var _proto4 = IE11MediaKeySession.prototype;
                    return _proto4.generateRequest = function generateRequest(_initDataType, initData) {
                        var _this6 = this;
                        return new promise.a(function(resolve) {
                            _this6._ss = _this6._mk.createSession("video/mp4", initData), Object(merge.a)(event_listeners.onKeyMessage$(_this6._ss), event_listeners.onKeyAdded$(_this6._ss), event_listeners.onKeyError$(_this6._ss)).pipe(Object(takeUntil.a)(_this6._closeSession$)).subscribe(function(evt) {
                                return _this6.trigger(evt.type, evt);
                            }), resolve();
                        });
                    }, _proto4.close = function close() {
                        var _this7 = this;
                        return new promise.a(function(resolve) {
                            _this7._ss && (
                            /* tslint:disable no-floating-promises */
                            _this7._ss.close(), 
                            /* tslint:enable no-floating-promises */
                            _this7._ss = void 0), _this7._closeSession$.next(), _this7._closeSession$.complete(), 
                            resolve();
                        });
                    }, _proto4.load = function load() {
                        return promise.a.resolve(!1);
                    }, _proto4.remove = function remove() {
                        return promise.a.resolve();
                    }, IE11MediaKeySession;
                }(event_emitter.a);
                createSession = function createIE11MediaKeySession(mediaKeys) {
                    return new custom_media_keys_IE11MediaKeySession(mediaKeys);
                };
            }
        }
        /* harmony default export */        __webpack_exports__.b = CustomMediaKeys;
        /***/    }, 
    /* 122 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return EncryptedMediaError;
        });
        /* harmony import */ var _error_codes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21), _error_message__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(55);
        /* harmony import */        function _assertThisInitialized(self) {
            if (void 0 === self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return self;
        }
        function _inheritsLoose(subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype), (subClass.prototype.constructor = subClass).__proto__ = superClass;
        }
        function _wrapNativeSuper(Class) {
            var _cache = "function" == typeof Map ? new Map() : void 0;
            return (_wrapNativeSuper = function _wrapNativeSuper(Class) {
                if (null === Class || !_isNativeFunction(Class)) return Class;
                if ("function" != typeof Class) throw new TypeError("Super expression must either be null or a function");
                if (void 0 !== _cache) {
                    if (_cache.has(Class)) return _cache.get(Class);
                    _cache.set(Class, Wrapper);
                }
                function Wrapper() {
                    return _construct(Class, arguments, _getPrototypeOf(this).constructor);
                }
                return Wrapper.prototype = Object.create(Class.prototype, {
                    constructor: {
                        value: Wrapper,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }), _setPrototypeOf(Wrapper, Class);
            })(Class);
        }
        function isNativeReflectConstruct() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function() {})), 
                !0;
            } catch (e) {
                return !1;
            }
        }
        function _construct(Parent, args, Class) {
            return (_construct = isNativeReflectConstruct() ? Reflect.construct : function _construct(Parent, args, Class) {
                var a = [ null ];
                a.push.apply(a, args);
                var instance = new (Function.bind.apply(Parent, a))();
                return Class && _setPrototypeOf(instance, Class.prototype), instance;
            }).apply(null, arguments);
        }
        function _isNativeFunction(fn) {
            return -1 !== Function.toString.call(fn).indexOf("[native code]");
        }
        function _setPrototypeOf(o, p) {
            return (_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
                return o.__proto__ = p, o;
            })(o, p);
        }
        function _getPrototypeOf(o) {
            return (_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
                return o.__proto__ || Object.getPrototypeOf(o);
            })(o);
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Error linked to the encryption of the media.
 *
 * @class EncryptedMediaError
 * @extends Error
 */        var EncryptedMediaError = 
        /* */
        function(_Error) {
            /**
   * @param {string} code
   * @param {string} reason
   * @Param {Boolean} fatal
   */
            function EncryptedMediaError(code, reason, fatal) {
                var _this;
                return _this = _Error.call(this) || this, // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class
                Object.setPrototypeOf(_assertThisInitialized(_this), EncryptedMediaError.prototype), 
                _this.name = "EncryptedMediaError", _this.type = _error_codes__WEBPACK_IMPORTED_MODULE_0__.b.ENCRYPTED_MEDIA_ERROR, 
                _this.code = _error_codes__WEBPACK_IMPORTED_MODULE_0__.a.hasOwnProperty(code) ? _error_codes__WEBPACK_IMPORTED_MODULE_0__.a[code] : "", 
                _this.fatal = !!fatal, _this.message = Object(_error_message__WEBPACK_IMPORTED_MODULE_1__.a)(_this.name, _this.code, reason), 
                _this;
            }
            return _inheritsLoose(EncryptedMediaError, _Error), EncryptedMediaError;
        }(_wrapNativeSuper(Error));
        /***/    }, 
    /* 123 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return tap;
        });
        /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3), _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8), _util_noop__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(37), _util_isFunction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(51);
        /* harmony import */        
        /** PURE_IMPORTS_START tslib,_Subscriber,_util_noop,_util_isFunction PURE_IMPORTS_END */
        function tap(nextOrObserver, error, complete) {
            return function tapOperatorFunction(source) {
                return source.lift(new DoOperator(nextOrObserver, error, complete));
            };
        }
        var DoOperator = /* */ function() {
            function DoOperator(nextOrObserver, error, complete) {
                this.nextOrObserver = nextOrObserver, this.error = error, this.complete = complete;
            }
            return DoOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new TapSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));
            }, DoOperator;
        }(), TapSubscriber = /* */ function(_super) {
            function TapSubscriber(destination, observerOrNext, error, complete) {
                var _this = _super.call(this, destination) || this;
                return _this._tapNext = _util_noop__WEBPACK_IMPORTED_MODULE_2__.a, _this._tapError = _util_noop__WEBPACK_IMPORTED_MODULE_2__.a, 
                _this._tapComplete = _util_noop__WEBPACK_IMPORTED_MODULE_2__.a, _this._tapError = error || _util_noop__WEBPACK_IMPORTED_MODULE_2__.a, 
                _this._tapComplete = complete || _util_noop__WEBPACK_IMPORTED_MODULE_2__.a, Object(_util_isFunction__WEBPACK_IMPORTED_MODULE_3__.a)(observerOrNext) ? (_this._context = _this)._tapNext = observerOrNext : observerOrNext && (_this._context = observerOrNext, 
                _this._tapNext = observerOrNext.next || _util_noop__WEBPACK_IMPORTED_MODULE_2__.a, 
                _this._tapError = observerOrNext.error || _util_noop__WEBPACK_IMPORTED_MODULE_2__.a, 
                _this._tapComplete = observerOrNext.complete || _util_noop__WEBPACK_IMPORTED_MODULE_2__.a), 
                _this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(TapSubscriber, _super), TapSubscriber.prototype._next = function(value) {
                try {
                    this._tapNext.call(this._context, value);
                } catch (err) {
                    return void this.destination.error(err);
                }
                this.destination.next(value);
            }, TapSubscriber.prototype._error = function(err) {
                try {
                    this._tapError.call(this._context, err);
                } catch (err) {
                    return void this.destination.error(err);
                }
                this.destination.error(err);
            }, TapSubscriber.prototype._complete = function() {
                try {
                    this._tapComplete.call(this._context);
                } catch (err) {
                    return void this.destination.error(err);
                }
                return this.destination.complete();
            }, TapSubscriber;
        }(_Subscriber__WEBPACK_IMPORTED_MODULE_1__.a);
    }, 
    /* 124 */ 
    /* 125 */
    /***/ , 
    /* 125 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        /* harmony import */ var _eme_manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(70);
        /* harmony reexport (safe) */        __webpack_require__.d(__webpack_exports__, "clearEMESession", function() {
            return _eme_manager__WEBPACK_IMPORTED_MODULE_0__.a;
        }), 
        /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "disposeEME", function() {
            return _eme_manager__WEBPACK_IMPORTED_MODULE_0__.c;
        }), 
        /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getCurrentKeySystem", function() {
            return _eme_manager__WEBPACK_IMPORTED_MODULE_0__.d;
        });
        /* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(71);
        /* harmony reexport (safe) */        __webpack_require__.d(__webpack_exports__, "KEY_STATUS_ERRORS", function() {
            return _types__WEBPACK_IMPORTED_MODULE_1__.a;
        }), 
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */
        /* harmony default export */ __webpack_exports__.default = _eme_manager__WEBPACK_IMPORTED_MODULE_0__.b;
    }, 
    /* 126 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return shouldUnsetMediaKeys;
        });
        /* harmony import */ var _browser_detection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(20);
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Returns true if the mediakeys associated to a media element should be
 * unset once the content is stopped.
 * Depends on the target.
 * @returns {Boolean}
 */        function shouldUnsetMediaKeys() {
            return _browser_detection__WEBPACK_IMPORTED_MODULE_0__.b;
        }
        /***/    }, 
    /* 127 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return shouldRenewMediaKeys;
        });
        /* harmony import */ var _browser_detection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(20);
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Returns true if the current target require the media keys to be renewed on
 * each content.
 * @returns {Boolean}
 */        function shouldRenewMediaKeys() {
            return _browser_detection__WEBPACK_IMPORTED_MODULE_0__.b;
        }
        /***/    }, 
    /* 128 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return isCodecSupported;
        });
        /* harmony import */ var _browser_compatibility_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(19);
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Returns true if the given codec is supported by the browser's MediaSource
 * implementation.
 * @returns {Boolean}
 */        function isCodecSupported(codec) {
            return !!_browser_compatibility_types__WEBPACK_IMPORTED_MODULE_0__.c && (
            /* tslint:disable no-unbound-method */
            "function" != typeof _browser_compatibility_types__WEBPACK_IMPORTED_MODULE_0__.c.isTypeSupported || _browser_compatibility_types__WEBPACK_IMPORTED_MODULE_0__.c.isTypeSupported(codec));
        }
        /***/    }, 
    /* 129 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return canPatchISOBMFFSegment;
        });
        /* harmony import */ var _browser_detection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(20);
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * TODO(pierre): fix patchSegmentInPlace to work with IE11. Maybe
 * try to put free atom inside traf children
 *
 * Returns true if the current target is tolerant enough for us to
 * simply be able to "patch" an ISOBMFF segment or if we have to create a
 * new one from scratch instead.
 *
 * TODO understand what the fudge Pierre meant here
 * @returns {Boolean}
 */        function canPatchISOBMFFSegment() {
            return !_browser_detection__WEBPACK_IMPORTED_MODULE_0__.c;
        }
        /***/    }, 
    /* 130 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return addTextTrack;
        });
        /* harmony import */ var _browser_detection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(20);
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Add text track to the given media element.
 * Returns an object with the following properties:
 *   - track {TextTrack}: the added text track
 *   - trackElement {HTMLElement|undefined}: the added <track> element.
 *     undefined if no trackElement was added.
 * @param {HTMLMediaElement} mediaElement
 * @param {Boolean} hidden
 * @returns {Object}
 */        function addTextTrack(mediaElement, hidden) {
            var track, trackElement;
            if (_browser_detection__WEBPACK_IMPORTED_MODULE_0__.c) {
                var tracksLength = mediaElement.textTracks.length;
                (track = 0 < tracksLength ? mediaElement.textTracks[tracksLength - 1] : mediaElement.addTextTrack("subtitles")).mode = hidden ? track.HIDDEN : track.SHOWING;
            } else trackElement = document.createElement("track"), mediaElement.appendChild(trackElement), 
            track = trackElement.track, trackElement.kind = "subtitles", track.mode = hidden ? "hidden" : "showing";
            return {
                track: track,
                trackElement: trackElement
            };
        }
        /***/    }, 
    /* 131 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Returns true if the given cue is an instance of a VTTCue.
 * @param {*} cue
 * @returns {boolean}
 */
        function isVTTCue(cue) {
            return "function" == typeof window.VTTCue && cue instanceof window.VTTCue;
        }
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return isVTTCue;
        });
    }, 
    /* 132 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Some browsers have a builtin API to know if it's connected at least to a
 * LAN network, at most to the internet.
 *
 * /!\ This feature can be dangerous as you can both have false positives and
 * false negatives.
 *
 * False positives:
 *   - you can still play local contents (on localhost) if isOffline == true
 *   - on some browsers isOffline might be true even if we're connected to a LAN
 *     or a router (it would mean we're just not able to connect to the
 *     Internet). So we can eventually play LAN contents if isOffline == true
 *
 * False negatives:
 *   - in some cases, we even might have isOffline at false when we do not have
 *     any connection:
 *       - in browsers that do not support the feature
 *       - in browsers running in some virtualization softwares where the
 *         network adapters are always connected.
 *
 * Use with these cases in mind.
 * @returns {Boolean}
 */
        function isOffline() {
            /* tslint:disable no-boolean-literal-compare */
            return !1 === navigator.onLine;
            /* tslint:enable no-boolean-literal-compare */        }
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return isOffline;
        });
    }, 
    /* 133 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return tryToChangeSourceBufferType;
        });
        /* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * If the changeType MSE API is implemented, update the current codec of the
 * SourceBuffer and return true if it succeeded.
 * In any other cases, return false.
 * @param {Object} sourceBuffer
 * @param {string} codec
 * @returns {boolean}
 */        function tryToChangeSourceBufferType(sourceBuffer, codec) {
            if ("function" != typeof sourceBuffer.changeType) return !1;
            try {
                sourceBuffer.changeType(codec);
            } catch (e) {
                return _log__WEBPACK_IMPORTED_MODULE_0__.a.warn("Could not call 'changeType' on the given SourceBuffer:", e), 
                !1;
            }
            return !0;
        }
        /***/    }, 
    /* 134 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return concatAll;
        });
        /* harmony import */ var _mergeAll__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(108);
        /** PURE_IMPORTS_START _mergeAll PURE_IMPORTS_END */        function concatAll() {
            return Object(_mergeAll__WEBPACK_IMPORTED_MODULE_0__.a)(1);
        }
        //# sourceMappingURL=concatAll.js.map
        /***/    }, 
    /* 135 */
    /***/ function(module, exports, __webpack_require__) {
        "use strict";
        /* WEBPACK VAR INJECTION */        
        /* WEBPACK VAR INJECTION */ (function(global) {
            var asyncTimer, PENDING = "pending", SETTLED = "settled", FULFILLED = "fulfilled", REJECTED = "rejected", NOOP = function() {}, isNode = void 0 !== global && void 0 !== global.process && "function" == typeof global.process.emit, asyncSetTimer = "undefined" == typeof setImmediate ? setTimeout : setImmediate, asyncQueue = [];
            function asyncFlush() {
                // run promise callbacks
                for (var i = 0; i < asyncQueue.length; i++) asyncQueue[i][0](asyncQueue[i][1]);
                // reset async asyncQueue
                                asyncTimer = !(asyncQueue = []);
            }
            function asyncCall(callback, arg) {
                asyncQueue.push([ callback, arg ]), asyncTimer || (asyncTimer = !0, asyncSetTimer(asyncFlush, 0));
            }
            function invokeResolver(resolver, promise) {
                function rejectPromise(reason) {
                    reject(promise, reason);
                }
                try {
                    resolver(function resolvePromise(value) {
                        resolve(promise, value);
                    }, rejectPromise);
                } catch (e) {
                    rejectPromise(e);
                }
            }
            function invokeCallback(subscriber) {
                var owner = subscriber.owner, settled = owner._state, value = owner._data, callback = subscriber[settled], promise = subscriber.then;
                if ("function" == typeof callback) {
                    settled = FULFILLED;
                    try {
                        value = callback(value);
                    } catch (e) {
                        reject(promise, e);
                    }
                }
                handleThenable(promise, value) || (settled === FULFILLED && resolve(promise, value), 
                settled === REJECTED && reject(promise, value));
            }
            function handleThenable(promise, value) {
                var resolved;
                try {
                    if (promise === value) throw new TypeError("A promises callback cannot return that same promise.");
                    if (value && ("function" == typeof value || "object" == typeof value)) {
                        // then should be retrieved only once
                        var then = value.then;
                        if ("function" == typeof then) return then.call(value, function(val) {
                            resolved || (resolved = !0, value === val ? fulfill(promise, val) : resolve(promise, val));
                        }, function(reason) {
                            resolved || (resolved = !0, reject(promise, reason));
                        }), !0;
                    }
                } catch (e) {
                    return resolved || reject(promise, e), !0;
                }
                return !1;
            }
            function resolve(promise, value) {
                promise !== value && handleThenable(promise, value) || fulfill(promise, value);
            }
            function fulfill(promise, value) {
                promise._state === PENDING && (promise._state = SETTLED, promise._data = value, 
                asyncCall(publishFulfillment, promise));
            }
            function reject(promise, reason) {
                promise._state === PENDING && (promise._state = SETTLED, promise._data = reason, 
                asyncCall(publishRejection, promise));
            }
            function publish(promise) {
                promise._then = promise._then.forEach(invokeCallback);
            }
            function publishFulfillment(promise) {
                promise._state = FULFILLED, publish(promise);
            }
            function publishRejection(promise) {
                promise._state = REJECTED, publish(promise), !promise._handled && isNode && global.process.emit("unhandledRejection", promise._data, promise);
            }
            function notifyRejectionHandled(promise) {
                global.process.emit("rejectionHandled", promise);
            }
            /**
 * @class
 */            function Promise(resolver) {
                if ("function" != typeof resolver) throw new TypeError("Promise resolver " + resolver + " is not a function");
                if (this instanceof Promise == !1) throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
                this._then = [], invokeResolver(resolver, this);
            }
            Promise.prototype = {
                constructor: Promise,
                _state: PENDING,
                _then: null,
                _data: void 0,
                _handled: !1,
                then: function(onFulfillment, onRejection) {
                    var subscriber = {
                        owner: this,
                        then: new this.constructor(NOOP),
                        fulfilled: onFulfillment,
                        rejected: onRejection
                    };
                    return !onRejection && !onFulfillment || this._handled || (this._handled = !0, this._state === REJECTED && isNode && asyncCall(notifyRejectionHandled, this)), 
                    this._state === FULFILLED || this._state === REJECTED ? 
                    // already resolved, call callback async
                    asyncCall(invokeCallback, subscriber) : 
                    // subscribe
                    this._then.push(subscriber), subscriber.then;
                },
                catch: function(onRejection) {
                    return this.then(null, onRejection);
                }
            }, Promise.all = function(promises) {
                if (!Array.isArray(promises)) throw new TypeError("You must pass an array to Promise.all().");
                return new Promise(function(resolve, reject) {
                    var results = [], remaining = 0;
                    function resolver(index) {
                        return remaining++, function(value) {
                            results[index] = value, --remaining || resolve(results);
                        };
                    }
                    for (var promise, i = 0; i < promises.length; i++) (promise = promises[i]) && "function" == typeof promise.then ? promise.then(resolver(i), reject) : results[i] = promise;
                    remaining || resolve(results);
                });
            }, Promise.race = function(promises) {
                if (!Array.isArray(promises)) throw new TypeError("You must pass an array to Promise.race().");
                return new Promise(function(resolve, reject) {
                    for (var promise, i = 0; i < promises.length; i++) (promise = promises[i]) && "function" == typeof promise.then ? promise.then(resolve, reject) : resolve(promise);
                });
            }, Promise.resolve = function(value) {
                return value && "object" == typeof value && value.constructor === Promise ? value : new Promise(function(resolve) {
                    resolve(value);
                });
            }, Promise.reject = function(reason) {
                return new Promise(function(resolve, reject) {
                    reject(reason);
                });
            }, module.exports = Promise;
        }).call(this, __webpack_require__(147))
        /***/;
    }, 
    /* 136 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return createBox;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() {
            return createBoxWithChildren;
        });
        /* harmony import */ var _utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1), boxNamesMem = {};
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Speed up string to bytes conversion by memorizing the result
 *
 * The keys here are ISOBMFF box names. The values are the corresponding
 * bytes conversion for putting as an ISOBMFF boxes.
 *
 * Used by the boxName method.
 * @type {Object}
 */        
        /**
 * Convert the string name of an ISOBMFF box into the corresponding bytes.
 * Has a memorization mechanism to speed-up if you want to translate the
 * same string multiple times.
 * @param {string} str
 * @returns {Uint8Array}
 */
        function boxName(str) {
            if (boxNamesMem[str]) return boxNamesMem[str];
            var nameInBytes = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__.p)(str);
            return boxNamesMem[str] = nameInBytes;
        }
        /**
 * Create a new ISOBMFF "box" with the given name.
 * @param {string} name - name of the box you want to create, must always
 * be 4 characters (uuid boxes not supported)
 * @param {Uint8Array} buff - content of the box
 * @returns {Uint8Array} - The entire ISOBMFF box (length+name+content)
 */        function createBox(name, buff) {
            var len = buff.length + 8;
            return Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__.h)(Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__.l)(len), boxName(name), buff);
        }
        /**
 * @param {string} name
 * @param {Array.<Uint8Array>} children
 * @returns {Uint8Array}
 */        function createBoxWithChildren(name, children) {
            return createBox(name, _utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__.h.apply(void 0, children));
        }
        /***/    }, 
    /* 137 */
    /***/ function(module, exports, __webpack_require__) {
        var pSlice = Array.prototype.slice, objectKeys = __webpack_require__(154), isArguments = __webpack_require__(155), deepEqual = module.exports = function(actual, expected, opts) {
            // 7.1. All identical values are equivalent, as determined by ===.
            return opts || (opts = {}), actual === expected || (actual instanceof Date && expected instanceof Date ? actual.getTime() === expected.getTime() : !actual || !expected || "object" != typeof actual && "object" != typeof expected ? opts.strict ? actual === expected : actual == expected : objEquiv(actual, expected, opts));
        };
        function isUndefinedOrNull(value) {
            return null == value;
        }
        function isBuffer(x) {
            return !(!x || "object" != typeof x || "number" != typeof x.length) && ("function" == typeof x.copy && "function" == typeof x.slice && !(0 < x.length && "number" != typeof x[0]));
        }
        function objEquiv(a, b, opts) {
            var i, key;
            if (isUndefinedOrNull(a) || isUndefinedOrNull(b)) return !1;
            // an identical 'prototype' property.
                        if (a.prototype !== b.prototype) return !1;
            //~~~I've managed to break Object.keys through screwy arguments passing.
            //   Converting to array solves the problem.
                        if (isArguments(a)) return !!isArguments(b) && (a = pSlice.call(a), 
            b = pSlice.call(b), deepEqual(a, b, opts));
            if (isBuffer(a)) {
                if (!isBuffer(b)) return !1;
                if (a.length !== b.length) return !1;
                for (i = 0; i < a.length; i++) if (a[i] !== b[i]) return !1;
                return !0;
            }
            try {
                var ka = objectKeys(a), kb = objectKeys(b);
            } catch (e) {
                //happens when one is a string literal and the other isn't
                return !1;
            }
            // having the same number of owned properties (keys incorporates
            // hasOwnProperty)
                        if (ka.length != kb.length) return !1;
            //the same set of keys (although not necessarily the same order),
                        //~~~cheap key test
            for (ka.sort(), kb.sort(), i = ka.length - 1; 0 <= i; i--) if (ka[i] != kb[i]) return !1;
            //equivalent values for every corresponding key, and
            //~~~possibly expensive deep test
                        for (i = ka.length - 1; 0 <= i; i--) if (key = ka[i], !deepEqual(a[key], b[key], opts)) return !1;
            return typeof a == typeof b;
        }
        /***/    }, 
    /* 138 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js
                var tslib_es6 = __webpack_require__(3), Subject = __webpack_require__(42), QueueAction_QueueAction = /* */ function(_super) {
            function QueueAction(scheduler, work) {
                var _this = _super.call(this, scheduler, work) || this;
                return _this.scheduler = scheduler, _this.work = work, _this;
            }
            return tslib_es6.a(QueueAction, _super), QueueAction.prototype.schedule = function(state, delay) {
                return void 0 === delay && (delay = 0), 0 < delay ? _super.prototype.schedule.call(this, state, delay) : (this.delay = delay, 
                this.state = state, this.scheduler.flush(this), this);
            }, QueueAction.prototype.execute = function(state, delay) {
                return 0 < delay || this.closed ? _super.prototype.execute.call(this, state, delay) : this._execute(state, delay);
            }, QueueAction.prototype.requestAsyncId = function(scheduler, id, delay) {
                return void 0 === delay && (delay = 0), null !== delay && 0 < delay || null === delay && 0 < this.delay ? _super.prototype.requestAsyncId.call(this, scheduler, id, delay) : scheduler.flush(this);
            }, QueueAction;
        }(__webpack_require__(68).a), queue = /* */ new (/* */ function(_super) {
            function QueueScheduler() {
                return null !== _super && _super.apply(this, arguments) || this;
            }
            return tslib_es6.a(QueueScheduler, _super), QueueScheduler;
        }(__webpack_require__(67).a))(QueueAction_QueueAction), Subscription = __webpack_require__(14), observeOn = __webpack_require__(120), ObjectUnsubscribedError = __webpack_require__(49), SubjectSubscription = __webpack_require__(88);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subject.js
                // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/ReplaySubject.js
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return ReplaySubject_ReplaySubject;
        });
        /** PURE_IMPORTS_START tslib,_Subject,_scheduler_queue,_Subscription,_operators_observeOn,_util_ObjectUnsubscribedError,_SubjectSubscription PURE_IMPORTS_END */
        var ReplaySubject_ReplaySubject = /* */ function(_super) {
            function ReplaySubject(bufferSize, windowTime, scheduler) {
                void 0 === bufferSize && (bufferSize = Number.POSITIVE_INFINITY), void 0 === windowTime && (windowTime = Number.POSITIVE_INFINITY);
                var _this = _super.call(this) || this;
                return _this.scheduler = scheduler, _this._events = [], _this._infiniteTimeWindow = !1, 
                _this._bufferSize = bufferSize < 1 ? 1 : bufferSize, _this._windowTime = windowTime < 1 ? 1 : windowTime, 
                windowTime === Number.POSITIVE_INFINITY ? (_this._infiniteTimeWindow = !0, _this.next = _this.nextInfiniteTimeWindow) : _this.next = _this.nextTimeWindow, 
                _this;
            }
            return tslib_es6.a(ReplaySubject, _super), ReplaySubject.prototype.nextInfiniteTimeWindow = function(value) {
                var _events = this._events;
                _events.push(value), _events.length > this._bufferSize && _events.shift(), _super.prototype.next.call(this, value);
            }, ReplaySubject.prototype.nextTimeWindow = function(value) {
                this._events.push(new ReplayEvent(this._getNow(), value)), this._trimBufferThenGetEvents(), 
                _super.prototype.next.call(this, value);
            }, ReplaySubject.prototype._subscribe = function(subscriber) {
                var subscription, _infiniteTimeWindow = this._infiniteTimeWindow, _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents(), scheduler = this.scheduler, len = _events.length;
                if (this.closed) throw new ObjectUnsubscribedError.a();
                if (subscription = this.isStopped || this.hasError ? Subscription.a.EMPTY : (this.observers.push(subscriber), 
                new SubjectSubscription.a(this, subscriber)), scheduler && subscriber.add(subscriber = new observeOn.a(subscriber, scheduler)), 
                _infiniteTimeWindow) for (var i = 0; i < len && !subscriber.closed; i++) subscriber.next(_events[i]); else for (i = 0; i < len && !subscriber.closed; i++) subscriber.next(_events[i].value);
                return this.hasError ? subscriber.error(this.thrownError) : this.isStopped && subscriber.complete(), 
                subscription;
            }, ReplaySubject.prototype._getNow = function() {
                return (this.scheduler || queue).now();
            }, ReplaySubject.prototype._trimBufferThenGetEvents = function() {
                for (var now = this._getNow(), _bufferSize = this._bufferSize, _windowTime = this._windowTime, _events = this._events, eventsCount = _events.length, spliceCount = 0; spliceCount < eventsCount && !(now - _events[spliceCount].time < _windowTime); ) spliceCount++;
                return _bufferSize < eventsCount && (spliceCount = Math.max(spliceCount, eventsCount - _bufferSize)), 
                0 < spliceCount && _events.splice(0, spliceCount), _events;
            }, ReplaySubject;
        }(Subject.a), ReplayEvent = /* */ function() {
            return function ReplayEvent(time, value) {
                this.time = time, this.value = value;
            };
        }();
    }, 
    /* 139 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return filter;
        });
        /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3), _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8);
        /* harmony import */        
        /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
        function filter(predicate, thisArg) {
            return function filterOperatorFunction(source) {
                return source.lift(new FilterOperator(predicate, thisArg));
            };
        }
        var FilterOperator = /* */ function() {
            function FilterOperator(predicate, thisArg) {
                this.predicate = predicate, this.thisArg = thisArg;
            }
            return FilterOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
            }, FilterOperator;
        }(), FilterSubscriber = /* */ function(_super) {
            function FilterSubscriber(destination, predicate, thisArg) {
                var _this = _super.call(this, destination) || this;
                return _this.predicate = predicate, _this.thisArg = thisArg, _this.count = 0, _this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(FilterSubscriber, _super), FilterSubscriber.prototype._next = function(value) {
                var result;
                try {
                    result = this.predicate.call(this.thisArg, value, this.count++);
                } catch (err) {
                    return void this.destination.error(err);
                }
                result && this.destination.next(value);
            }, FilterSubscriber;
        }(_Subscriber__WEBPACK_IMPORTED_MODULE_1__.a);
    }, 
    /* 140 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return mapTo;
        });
        /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3), _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8);
        /* harmony import */        
        /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
        function mapTo(value) {
            return function(source) {
                return source.lift(new MapToOperator(value));
            };
        }
        var MapToOperator = /* */ function() {
            function MapToOperator(value) {
                this.value = value;
            }
            return MapToOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new MapToSubscriber(subscriber, this.value));
            }, MapToOperator;
        }(), MapToSubscriber = /* */ function(_super) {
            function MapToSubscriber(destination, value) {
                var _this = _super.call(this, destination) || this;
                return _this.value = value, _this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(MapToSubscriber, _super), MapToSubscriber.prototype._next = function(x) {
                this.destination.next(this.value);
            }, MapToSubscriber;
        }(_Subscriber__WEBPACK_IMPORTED_MODULE_1__.a);
    }, 
    /* 141 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return shareReplay;
        });
        /* harmony import */ var _ReplaySubject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(138);
        /** PURE_IMPORTS_START _ReplaySubject PURE_IMPORTS_END */        function shareReplay(configOrBufferSize, windowTime, scheduler) {
            var config;
            return config = configOrBufferSize && "object" == typeof configOrBufferSize ? configOrBufferSize : {
                bufferSize: configOrBufferSize,
                windowTime: windowTime,
                refCount: !1,
                scheduler: scheduler
            }, function(source) {
                return source.lift(shareReplayOperator(config));
            };
        }
        function shareReplayOperator(_a) {
            var subject, subscription, _b = _a.bufferSize, bufferSize = void 0 === _b ? Number.POSITIVE_INFINITY : _b, _c = _a.windowTime, windowTime = void 0 === _c ? Number.POSITIVE_INFINITY : _c, useRefCount = _a.refCount, scheduler = _a.scheduler, refCount = 0, hasError = !1, isComplete = !1;
            return function shareReplayOperation(source) {
                refCount++, subject && !hasError || (hasError = !1, subject = new _ReplaySubject__WEBPACK_IMPORTED_MODULE_0__.a(bufferSize, windowTime, scheduler), 
                subscription = source.subscribe({
                    next: function(value) {
                        subject.next(value);
                    },
                    error: function(err) {
                        hasError = !0, subject.error(err);
                    },
                    complete: function() {
                        isComplete = !0, subject.complete();
                    }
                }));
                var innerSub = subject.subscribe(this);
                this.add(function() {
                    refCount--, innerSub.unsubscribe(), subscription && !isComplete && useRefCount && 0 === refCount && (subscription.unsubscribe(), 
                    subject = subscription = void 0);
                });
            };
        }
        //# sourceMappingURL=shareReplay.js.map
        /***/    }, 
    /* 142 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return share;
        });
        /* harmony import */ var _multicast__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(75), _refCount__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(101), _Subject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(42);
        /* harmony import */        
        /** PURE_IMPORTS_START _multicast,_refCount,_Subject PURE_IMPORTS_END */
        function shareSubjectFactory() {
            return new _Subject__WEBPACK_IMPORTED_MODULE_2__.a();
        }
        function share() {
            return function(source) {
                return Object(_refCount__WEBPACK_IMPORTED_MODULE_1__.a)()(Object(_multicast__WEBPACK_IMPORTED_MODULE_0__.a)(shareSubjectFactory)(source));
            };
        }
        //# sourceMappingURL=share.js.map
        /***/    }, 
    /* 143 */ 
    /* 144 */
    /***/ , 
    /* 144 */
    /***/ function(module, exports, __webpack_require__) {
        "use strict";
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        // ugly but working webpack workaround to be able to import the library in
        // CommonJS mode.
        // TODO investigate
        /* tslint:disable no-var-requires */        module.exports = __webpack_require__(156).default;
    }, 
    /* 145 */ 
    /* 146 */ , 
    /* 147 */
    /***/ , 
    /* 147 */
    /***/ function(module, exports) {
        var g;
        // This works in non-strict mode
                g = function() {
            return this;
        }();
        try {
            // This works if eval is allowed (see CSP)
            g = g || new Function("return this")();
        } catch (e) {
            // This works if the window reference is available
            "object" == typeof window && (g = window);
        }
        // g can still be undefined, but nothing to do about it...
        // We return undefined, instead of nothing here, so it's
        // easier to handle this case. if(!global) { ...}
                module.exports = g;
    }, 
    /* 148 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        /* harmony import */ var _utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */
        /**
 * @param {UInt8Array} buf
 * @returns {Object}
 */        
        /* harmony default export */ __webpack_exports__.default = function parseBif(buf) {
            var pos = 0, length = buf.length, fileFormat = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__.f)(buf.subarray(pos, pos + 8)), minorVersion = buf[pos += 8], majorVersion = buf[pos += 1], patchVersion = buf[pos += 1], increVersion = buf[pos += 1];
            pos += 1;
            var version = [ minorVersion, majorVersion, patchVersion, increVersion ].join("."), imageCount = buf[pos] + Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__.o)(buf, pos + 1);
            pos += 4;
            var timescale = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__.o)(buf, pos);
            pos += 4;
            var format = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__.f)(buf.subarray(pos, pos + 4));
            pos += 4;
            var width = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__.n)(buf, pos);
            pos += 2;
            var height = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__.n)(buf, pos), aspectRatio = [ buf[pos += 2], buf[pos + 1] ].join(":"), isVod = 1 === buf[pos += 2];
            pos += 1, // bytes 0x1F to 0x40 is unused data for now
            pos = 64;
            var currentImage, thumbs = [], currentTs = 0;
            if (!imageCount) throw new Error("bif: no images to parse");
            for (;pos < length; ) {
                var currentImageIndex = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__.o)(buf, pos);
                pos += 4;
                var currentImageOffset = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__.o)(buf, pos);
                if (pos += 4, currentImage) {
                    var index = currentImage.index, duration = timescale, ts = currentTs, data = buf.subarray(currentImage.offset, currentImageOffset);
                    thumbs.push({
                        index: index,
                        duration: duration,
                        ts: ts,
                        data: data
                    }), currentTs += timescale;
                }
                if (4294967295 === currentImageIndex) break;
                currentImage = {
                    index: currentImageIndex,
                    offset: currentImageOffset
                };
            }
            return {
                fileFormat: fileFormat,
                version: version,
                imageCount: imageCount,
                timescale: timescale,
                format: format,
                width: width,
                height: height,
                aspectRatio: aspectRatio,
                isVod: isVod,
                thumbs: thumbs
            };
        };
    }, 
    /* 149 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        /* harmony import */ var _compat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(95), _utils_assert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(16), HTML_ENTITIES = /&#([0-9]+);/g, BR = /<br>/gi, STYLE = /<style[^>]*>([\s\S]*?)<\/style[^>]*>/i, PARAG = /\s*<p class=([^>]+)>(.*)/i, START = /<sync[^>]+?start="?([0-9]*)"?[^0-9]/i;
        /* harmony import */        
        /**
 * Creates an array of VTTCue/TextTrackCue from a given array of cue objects.
 * @param {Array.<Object>} cuesArray - Objects containing the start, end and
 * text.
 * @returns {Array.<VTTCue>}
 */
        function createCuesFromArray(cuesArray) {
            for (var nativeCues = [], i = 0; i < cuesArray.length; i++) {
                var _cuesArray$i = cuesArray[i], start = _cuesArray$i.start, end = _cuesArray$i.end, text = _cuesArray$i.text;
                if (text && null != end) {
                    var cue = Object(_compat__WEBPACK_IMPORTED_MODULE_0__.a)(start, end, text);
                    null != cue && nativeCues.push(cue);
                }
            }
            return nativeCues;
        }
        /**
 * Returns classnames for every languages.
 * @param {string} str
 * @returns {Object}
 */        function getClassNameByLang(str) {
            for (var m, ruleRe = /\.(\S+)\s*{([^}]*)}/gi, langs = {}; m = ruleRe.exec(str); ) {
                var name = m[1], lang = getCSSProperty(m[2], "lang");
                null != name && null != lang && (langs[lang] = name);
            }
            return langs;
        }
        /**
 * @param {string} str - entire CSS rule
 * @param {string} name - name of the property
 * @returns {string|null} - value of the property. Null if not found.
 */        function getCSSProperty(str, name) {
            var matches = str.match(new RegExp("\\s*" + name + ":\\s*(\\S+);", "i"));
            return matches ? matches[1] : null;
        }
        /**
 * Decode HMTL formatting into a string.
 * @param {string} text
 * @returns {string}
 */        function decodeEntities(text) {
            return text.replace(BR, "\n").replace(HTML_ENTITIES, function(_, $1) {
                return String.fromCharCode($1);
            });
        }
        /**
 * Because sami is not really html... we have to use
 * some kind of regular expressions to parse it...
 * the cthulhu way :)
 * The specification being quite clunky, this parser
 * may not work for every sami input.
 *
 * @param {string} smi
 * @param {Number} timeOffset
 * @param {string} lang
 * @returns {Array.<VTTCue|TextTrackCue>}
 */        
        /* harmony default export */ __webpack_exports__.default = function parseSami(smi, timeOffset, lang) {
            var up, to, syncOpen = /<sync[ >]/gi, syncClose = /<sync[ >]|<\/body>/gi, subs = [], styleMatches = smi.match(STYLE), css = styleMatches ? styleMatches[1] : "";
            // FIXME Is that wanted?
            // previously written as let to = SyncClose.exec(smi); but never used
            syncClose.exec(smi);
            var langs = getClassNameByLang(css), klass = lang && langs[lang];
            for (Object(_utils_assert__WEBPACK_IMPORTED_MODULE_1__.b)(!!klass, "sami: could not find lang " + lang + " in CSS"); up = syncOpen.exec(smi), 
            to = syncClose.exec(smi), up || to; ) {
                if (!up || !to || up.index >= to.index) throw new Error("parse error");
                var str = smi.slice(up.index, to.index), tim = str.match(START);
                if (!tim) throw new Error("parse error (sync time attribute)");
                var start = +tim[1];
                if (isNaN(start)) throw new Error("parse error (sync time attribute NaN)");
                appendToSubs(str.split("\n"), start / 1e3);
            }
            return createCuesFromArray(subs);
            function appendToSubs(lines, start) {
                for (var m, i = lines.length; 0 <= --i; ) if (m = lines[i].match(PARAG)) {
                    var _m = m, kl = _m[1], txt = _m[2];
                    klass === kl && ("&nbsp;" === txt ? subs[subs.length - 1].end = start : subs.push({
                        text: decodeEntities(txt),
                        start: start + timeOffset
                    }));
                }
            }
        };
    }, 
    /* 150 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() {
            return parseSRTStringToVTTCues;
        });
        /* harmony import */ var _compat_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(95), _get_cue_blocks__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(105), _parse_cue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(106);
        /* harmony import */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */
        // srt to VTTCue parser, Done for fun.
        // Heavily inspired from the WebVTT implementation
        /**
 * Parse whole srt file into an array of cues, to be inserted in a video's
 * TrackElement.
 * @param {string} srtStr
 * @param {Number} timeOffset
 * @returns {Array.<VTTCue|TextTrackCue>}
 */
        function parseSRTStringToVTTCues(srtStr, timeOffset) {
            for (
            // Even if srt only authorize CRLF, we will also take LF or CR as line
            // terminators for resilience
            var lines = srtStr.split(/\r\n|\n|\r/), cueBlocks = Object(_get_cue_blocks__WEBPACK_IMPORTED_MODULE_1__.a)(lines), cues = [], i = 0; i < cueBlocks.length; i++) {
                var cueObject = Object(_parse_cue__WEBPACK_IMPORTED_MODULE_2__.a)(cueBlocks[i], timeOffset);
                if (cueObject) {
                    var nativeCue = toNativeCue(cueObject);
                    nativeCue && cues.push(nativeCue);
                }
            }
            return cues;
        }
        /**
 * @param {Object} cue Object
 * @returns {TextTrackCue|VTTCue|null}
 */        function toNativeCue(cueObj) {
            var start = cueObj.start, end = cueObj.end, text = cueObj.payload.join("\n");
            return Object(_compat_index__WEBPACK_IMPORTED_MODULE_0__.a)(start, end, text);
        }
        /***/    }, 
    /* 151 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        /* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(16), HTML_ENTITIES = /&#([0-9]+);/g, BR = /<br>/gi, STYLE = /<style[^>]*>([\s\S]*?)<\/style[^>]*>/i, PARAG = /\s*<p class=([^>]+)>(.*)/i, START = /<sync[^>]+?start="?([0-9]*)"?[^0-9]/i;
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        // __VERY__ simple SAMI parser, based on ugly-but-working REGEXP:
        //   - the text, start and end times are correctly parsed.
        //   - only text for the given language is parsed.
        //   - only the CSS style associated to the P element is set.
        //   - we should be safe for any XSS.
        // The language indicated to the parser should be present in the CSS and the
        // corresponding Class should be on the P elements. If we fail to find the
        // language in a "lang" property of a CSS class, the parser will throw.
        /**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */        
        /**
 * Returns classnames for every languages.
 * @param {string} str
 * @returns {Object}
 */
        function getClassNameByLang(str) {
            for (var m, ruleRe = /\.(\S+)\s*{([^}]*)}/gi, langs = {}; m = ruleRe.exec(str); ) {
                var name = m[1], lang = getCSSProperty(m[2], "lang");
                null != name && null != lang && (langs[lang] = name);
            }
            return langs;
        }
        /**
 * Returns the rules defined for the P element.
 * Empty string if not found.
 * @param {string} str - The entire styling part.
 * @returns {string}
 */        function getPCSSRules(str) {
            var rule = /p\s*{([^}]*)}/gi.exec(str);
            return rule ? rule[1] : "";
        }
        /**
 * @param {string} str - entire CSS rule
 * @param {string} name - name of the property
 * @returns {string|null} - value of the property. Null if not found.
 */        function getCSSProperty(str, name) {
            var matches = str.match(new RegExp("\\s*" + name + ":\\s*(\\S+);", "i"));
            return matches ? matches[1] : null;
        }
        /**
 * @param {string} text
 * @returns {string}
 */        function decodeEntities(text) {
            return text.replace(HTML_ENTITIES, function(_, $1) {
                return String.fromCharCode($1);
            });
        }
        /**
 * Because sami is not really html... we have to use
 * some kind of regular expressions to parse it...
 * the cthulhu way :)
 * The specification being quite clunky, this parser
 * may not work for every sami input.
 *
 * @param {string} smi
 * @param {Number} timeOffset
 * @param {string} lang
 */        
        /* harmony default export */ __webpack_exports__.default = function parseSami(smi, timeOffset, lang) {
            var up, to, syncOpen = /<sync[ >]/gi, syncClose = /<sync[ >]|<\/body>/gi, subs = [], styleMatches = smi.match(STYLE), css = styleMatches ? styleMatches[1] : "";
            // FIXME Is that wanted?
            // previously written as let to = SyncClose.exec(smi); but never used
            syncClose.exec(smi);
            var langs = getClassNameByLang(css), pCSS = getPCSSRules(css), klass = lang && langs[lang];
            for (Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__.b)(!!klass, "sami: could not find lang " + lang + " in CSS"); up = syncOpen.exec(smi), 
            to = syncClose.exec(smi), up || to; ) {
                if (!up || !to || up.index >= to.index) throw new Error("parse error");
                var str = smi.slice(up.index, to.index), tim = str.match(START);
                if (!tim) throw new Error("parse error (sync time attribute)");
                var start = +tim[1];
                if (isNaN(start)) throw new Error("parse error (sync time attribute NaN)");
                appendToSubs(str.split("\n"), start / 1e3);
            }
            return subs;
            function appendToSubs(lines, start) {
                for (var i = lines.length; 0 <= --i; ) {
                    var paragraphInfos = lines[i].match(PARAG);
                    if (paragraphInfos) {
                        var className = paragraphInfos[1], txt = paragraphInfos[2];
                        if (klass === className) if ("&nbsp;" === txt) subs[subs.length - 1].end = start; else {
                            var wrapperEl = document.createElement("DIV");
                            wrapperEl.className = "rxp-texttrack-region";
                            var divEl = document.createElement("DIV");
                            divEl.className = "rxp-texttrack-div", divEl.style.position = "absolute", divEl.style.bottom = "0", 
                            divEl.style.width = "100%", divEl.style.color = "#fff", divEl.style.textShadow = "-1px -1px 0 #000,1px -1px 0 #000,-1px 1px 0 #000,1px 1px 0 #000";
                            var pEl = document.createElement("div");
                            pEl.className = "rxp-texttrack-p", pCSS && (pEl.style.cssText = pCSS);
                            for (var textEls = txt.split(BR), j = 0; j < textEls.length; j++) {
                                j && pEl.appendChild(document.createElement("BR"));
                                var spanEl = document.createElement("SPAN");
                                spanEl.className = "rxp-texttrack-span", spanEl.textContent = decodeEntities(textEls[j]), 
                                pEl.appendChild(spanEl);
                            }
                            divEl.appendChild(pEl), wrapperEl.appendChild(divEl), subs.push({
                                element: wrapperEl,
                                start: start + timeOffset,
                                end: -1
                            });
                        }
                    }
                }
            }
        };
    }, 
    /* 152 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() {
            return parseSRTStringToHTML;
        });
        /* harmony import */ var _get_cue_blocks__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(105), _parse_cue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(106);
        /* harmony import */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */
        // Parse SRT subtitles into HTML.
        // Done for fun. Understand <b>, <i>, <u> and <font color="#ff0000" /> type
        // of tags.
        /**
 * @param {string} srtStr
 * @param {Number} timeOffset
 * @returns {Array.<Object>}
 */
        function parseSRTStringToHTML(srtStr, timeOffset) {
            for (
            // Even if srt only authorize CRLF, we will also take LF or CR as line
            // terminators for resilience
            var lines = srtStr.split(/\r\n|\n|\r/), cueBlocks = Object(_get_cue_blocks__WEBPACK_IMPORTED_MODULE_0__.a)(lines), cues = [], i = 0; i < cueBlocks.length; i++) {
                var cueObject = Object(_parse_cue__WEBPACK_IMPORTED_MODULE_1__.a)(cueBlocks[i], timeOffset);
                if (null != cueObject) {
                    var htmlCue = toHTML(cueObject);
                    null != htmlCue && cues.push(htmlCue);
                }
            }
            return cues;
        }
        /**
 * @param {Array.<string>} cueLines
 * @param {Number} timeOffset
 * @returns {Object|null}
 */        function toHTML(cueObj) {
            var start = cueObj.start, end = cueObj.end, payload = cueObj.payload, pEl = document.createElement("div");
            pEl.className = "rxp-texttrack-p", pEl.style.fontSize = "28px", pEl.style.position = "absolute", 
            pEl.style.bottom = "5%", pEl.style.width = "100%", pEl.style.textAlign = "center", 
            pEl.style.color = "#fff", pEl.style.textShadow = "-1px -1px 2px #000,1px -1px 2px #000,-1px 1px 2px #000,1px 1px 2px #000";
            for (var i = 0; i < payload.length; i++) {
                i && pEl.appendChild(document.createElement("br"));
                var span = generateSpansFromSRTText(payload[i]);
                pEl.appendChild(span);
            }
            return {
                start: start,
                end: end,
                element: pEl
            };
        }
        /**
 * Take a single srt line and convert it into a span with the right style while
 * avoiding XSS.
 * What we do is set a whitelist of authorized tags, and recreate the
 * corresponding tag from scratch.
 * Supported tags:
 *   - <b>: make content bold
 *   - <i>: make content italic
 *   - <u>: draw underline on content
 *   - <font color="x">: add color x to the content
 * @param {string} text
 * @returns {HTMLElement}
 */        function generateSpansFromSRTText(text) {
            var secureDiv = document.createElement("div");
            secureDiv.innerHTML = text;
            return function _loop(node) {
                var childNodes = node.childNodes, span = document.createElement("span");
                span.className = "rxp-texttrack-span";
                for (var i = 0; i < childNodes.length; i++) {
                    var currentNode = childNodes[i];
                    if ("#text" === currentNode.nodeName) {
                        for (var linifiedText = currentNode.wholeText.split("\n"), line = 0; line < linifiedText.length; line++) if (line && span.appendChild(document.createElement("br")), 
                        0 < linifiedText[line].length) {
                            var textNode = document.createTextNode(linifiedText[line]);
                            span.appendChild(textNode);
                        }
                    } else if ("B" === currentNode.nodeName) {
                        var spanChild = _loop(currentNode);
                        spanChild.style.fontWeight = "bold", span.appendChild(spanChild);
                    } else if ("I" === currentNode.nodeName) {
                        var _spanChild = _loop(currentNode);
                        _spanChild.style.fontStyle = "italic", span.appendChild(_spanChild);
                    } else if ("U" === currentNode.nodeName) {
                        var _spanChild2 = _loop(currentNode);
                        _spanChild2.style.textDecoration = "underline", span.appendChild(_spanChild2);
                    } else if ("FONT" === currentNode.nodeName && null != currentNode.color) {
                        // TODO loop through attributes to find color?
                        var _spanChild3 = _loop(currentNode);
                        _spanChild3.style.color = currentNode.color, span.appendChild(_spanChild3);
                    } else {
                        var _spanChild4 = _loop(currentNode);
                        span.appendChild(_spanChild4);
                    }
                }
                return span;
            }(secureDiv);
        }
        /***/    }, 
    /* 153 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() {
            return initializeDirectfileContent;
        });
        /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(172), rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(30), rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(112), rxjs_operators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(39), rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(120), rxjs_operators__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(142), rxjs_operators__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(34), rxjs_operators__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(139), rxjs_operators__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(113), rxjs_operators__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(169), rxjs_operators__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(170), _compat__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(72), _compat__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(114), _errors__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(58), _log__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(0), _create_eme_manager__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(100), _events_generators__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(22), _get_stalled_events__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(103), _initial_seek_and_play__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(97), _throw_on_media_error__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(102), _update_playback_rate__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(107);
        /* harmony import */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */
        /**
 * calculate initial time as a position in seconds.
 * @param {HTMLMediaElement} mediaElement
 * @param {Object|undefined} startAt
 * @returns {number}
 */
        function getDirectFileInitialTime(mediaElement, startAt) {
            if (!startAt) return 0;
            if (null != startAt.position) return startAt.position;
            if (null != startAt.wallClockTime) return startAt.wallClockTime;
            if (null != startAt.fromFirstPosition) return startAt.fromFirstPosition;
            var duration = mediaElement.duration;
            if (!duration || !isFinite(duration)) return _log__WEBPACK_IMPORTED_MODULE_14__.a.warn("startAt.fromLastPosition set but no known duration, beginning at 0."), 
            0;
            if (startAt.fromLastPosition) return Math.max(0, duration + startAt.fromLastPosition);
            if (null == startAt.percentage) return 0;
            var percentage = startAt.percentage;
            return 100 <= percentage ? duration : percentage <= 0 ? 0 : duration * (+percentage / 100);
        }
        /**
 * Launch a content in "Directfile mode".
 * @param {Object} directfileOptions
 * @returns {Observable}
 */        function initializeDirectfileContent(_ref) {
            var autoPlay = _ref.autoPlay, clock$ = _ref.clock$, keySystems = _ref.keySystems, mediaElement = _ref.mediaElement, speed$ = _ref.speed$, startAt = _ref.startAt, url = _ref.url;
            Object(_compat__WEBPACK_IMPORTED_MODULE_11__.a)(mediaElement);
            // Start everything! (Just put the URL in the element's src).
            var linkURL$ = Object(_compat__WEBPACK_IMPORTED_MODULE_12__.a)(mediaElement, url);
            _log__WEBPACK_IMPORTED_MODULE_14__.a.debug("Init: Calculating initial time");
            var initialTime = function initialTime() {
                return getDirectFileInitialTime(mediaElement, startAt);
            };
            _log__WEBPACK_IMPORTED_MODULE_14__.a.debug("Init: Initial time calculated:", initialTime);
            var _seekAndLoadOnMediaEv = Object(_initial_seek_and_play__WEBPACK_IMPORTED_MODULE_18__.a)(clock$, mediaElement, initialTime, autoPlay), seek$ = _seekAndLoadOnMediaEv.seek$, load$ = _seekAndLoadOnMediaEv.load$, emeManager$ = linkURL$.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.a)(function() {
                return Object(_create_eme_manager__WEBPACK_IMPORTED_MODULE_15__.a)(mediaElement, keySystems);
            }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.b)(rxjs__WEBPACK_IMPORTED_MODULE_0__.a), // multiple Observables here are based on this one
            Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__.a)()), mediaError$ = Object(_throw_on_media_error__WEBPACK_IMPORTED_MODULE_19__.a)(mediaElement), playbackRate$ = Object(_update_playback_rate__WEBPACK_IMPORTED_MODULE_20__.a)(mediaElement, speed$, clock$, {
                pauseWhenStalled: !0
            }).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_6__.a)(_events_generators__WEBPACK_IMPORTED_MODULE_16__.a.speedChanged)), stalled$ = Object(_get_stalled_events__WEBPACK_IMPORTED_MODULE_17__.a)(mediaElement, clock$).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_6__.a)(_events_generators__WEBPACK_IMPORTED_MODULE_16__.a.stalled)), loadedEvent$ = emeManager$.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_7__.a)(function(_ref2) {
                var type = _ref2.type;
                return "eme-init" === type || "eme-disabled" === type;
            }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_8__.a)(1), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_9__.a)(load$), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.a)(function(evt) {
                if ("autoplay-blocked" === evt) {
                    var error = new _errors__WEBPACK_IMPORTED_MODULE_13__.a("MEDIA_ERR_BLOCKED_AUTOPLAY", "Cannot trigger auto-play automatically: your browser does not allow it.", !1);
                    return Object(rxjs__WEBPACK_IMPORTED_MODULE_1__.a)(_events_generators__WEBPACK_IMPORTED_MODULE_16__.a.warning(error), _events_generators__WEBPACK_IMPORTED_MODULE_16__.a.loaded());
                }
                if ("not-loaded-metadata" !== evt) return Object(rxjs__WEBPACK_IMPORTED_MODULE_1__.a)(_events_generators__WEBPACK_IMPORTED_MODULE_16__.a.loaded());
                var _error = new _errors__WEBPACK_IMPORTED_MODULE_13__.a("MEDIA_ERR_NOT_LOADED_METADATA", "Cannot load automatically: your browser falsely announced having loaded the content.", !1);
                return Object(rxjs__WEBPACK_IMPORTED_MODULE_1__.a)(_events_generators__WEBPACK_IMPORTED_MODULE_16__.a.warning(_error));
            })), initialSeek$ = seek$.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__.a)());
 // Create EME Manager, an observable which will manage every EME-related
            // issue.
                        return Object(rxjs__WEBPACK_IMPORTED_MODULE_2__.a)(loadedEvent$, initialSeek$, emeManager$, mediaError$, playbackRate$, stalled$);
        }
        /***/    }, 
    /* 154 */
    /***/ function(module, exports) {
        function shim(obj) {
            var keys = [];
            for (var key in obj) keys.push(key);
            return keys;
        }
        /***/        (module.exports = "function" == typeof Object.keys ? Object.keys : shim).shim = shim;
    }, 
    /* 155 */
    /***/ function(module, exports) {
        var supportsArgumentsClass = "[object Arguments]" == function() {
            return Object.prototype.toString.call(arguments);
        }();
        function supported(object) {
            return "[object Arguments]" == Object.prototype.toString.call(object);
        }
        function unsupported(object) {
            return object && "object" == typeof object && "number" == typeof object.length && Object.prototype.hasOwnProperty.call(object, "callee") && !Object.prototype.propertyIsEnumerable.call(object, "callee") || !1;
        }
        (exports = module.exports = supportsArgumentsClass ? supported : unsupported).supported = supported, 
        exports.unsupported = unsupported;
    }, 
    /* 156 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        // EXTERNAL MODULE: ./node_modules/deep-equal/index.js
        var deep_equal = __webpack_require__(137), deep_equal_default = /* */ __webpack_require__.n(deep_equal), object_assign = __webpack_require__(9), object_assign_default = /* */ __webpack_require__.n(object_assign), Subject = __webpack_require__(42), ReplaySubject = __webpack_require__(138), tslib_es6 = __webpack_require__(3), ObjectUnsubscribedError = __webpack_require__(49), BehaviorSubject_BehaviorSubject = /* */ function(_super) {
            function BehaviorSubject(_value) {
                var _this = _super.call(this) || this;
                return _this._value = _value, _this;
            }
            return tslib_es6.a(BehaviorSubject, _super), Object.defineProperty(BehaviorSubject.prototype, "value", {
                get: function() {
                    return this.getValue();
                },
                enumerable: !0,
                configurable: !0
            }), BehaviorSubject.prototype._subscribe = function(subscriber) {
                var subscription = _super.prototype._subscribe.call(this, subscriber);
                return subscription && !subscription.closed && subscriber.next(this._value), subscription;
            }, BehaviorSubject.prototype.getValue = function() {
                if (this.hasError) throw this.thrownError;
                if (this.closed) throw new ObjectUnsubscribedError.a();
                return this._value;
            }, BehaviorSubject.prototype.next = function(value) {
                _super.prototype.next.call(this, this._value = value);
            }, BehaviorSubject;
        }(Subject.a), merge = __webpack_require__(112), empty = __webpack_require__(38), combineLatest = __webpack_require__(179), concat = __webpack_require__(76), of = __webpack_require__(30), takeUntil = __webpack_require__(178), map = __webpack_require__(34), distinctUntilChanged = __webpack_require__(167), take = __webpack_require__(113), multicast = __webpack_require__(75);
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/publish.js
        /** PURE_IMPORTS_START _Subject,_multicast PURE_IMPORTS_END */
        function publish(selector) {
            return selector ? Object(multicast.a)(function() {
                return new Subject.a();
            }, selector) : Object(multicast.a)(new Subject.a());
        }
        //# sourceMappingURL=publish.js.map
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/filter.js
                var filter = __webpack_require__(139), share = __webpack_require__(142), startWith = __webpack_require__(176), mapTo = __webpack_require__(140), Subscriber = __webpack_require__(8);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/share.js
                // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/skipWhile.js
        /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
        function skipWhile(predicate) {
            return function(source) {
                return source.lift(new SkipWhileOperator(predicate));
            };
        }
        var SkipWhileOperator = /* */ function() {
            function SkipWhileOperator(predicate) {
                this.predicate = predicate;
            }
            return SkipWhileOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new skipWhile_SkipWhileSubscriber(subscriber, this.predicate));
            }, SkipWhileOperator;
        }(), skipWhile_SkipWhileSubscriber = /* */ function(_super) {
            function SkipWhileSubscriber(destination, predicate) {
                var _this = _super.call(this, destination) || this;
                return _this.predicate = predicate, _this.skipping = !0, _this.index = 0, _this;
            }
            return tslib_es6.a(SkipWhileSubscriber, _super), SkipWhileSubscriber.prototype._next = function(value) {
                var destination = this.destination;
                this.skipping && this.tryCallPredicate(value), this.skipping || destination.next(value);
            }, SkipWhileSubscriber.prototype.tryCallPredicate = function(value) {
                try {
                    var result = this.predicate(value, this.index++);
                    this.skipping = Boolean(result);
                } catch (err) {
                    this.destination.error(err);
                }
            }, SkipWhileSubscriber;
        }(Subscriber.a), switchMapTo = __webpack_require__(184), mergeMapTo = __webpack_require__(169), catchError = __webpack_require__(171), config = __webpack_require__(2), log = __webpack_require__(0), event_emitter = __webpack_require__(33), noop = __webpack_require__(27), promise = __webpack_require__(28), utils_ranges = __webpack_require__(13), warn_once = __webpack_require__(26), compat = __webpack_require__(7), fullscreen = __webpack_require__(77), error_codes = __webpack_require__(21), media_error = __webpack_require__(58), features = __webpack_require__(10), eme_manager = __webpack_require__(70), asap = __webpack_require__(172), timer = __webpack_require__(181), observeOn = __webpack_require__(120), mergeMap = __webpack_require__(39), tap = __webpack_require__(123), ignoreElements = __webpack_require__(170), switchMap = __webpack_require__(119), Observable = __webpack_require__(6);
        // CONCATENATED MODULE: ./src/utils/rx-throttle.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Throttle an asynchronous function returning an Observable to drop calls done
 * before a previous one has finished or failed.
 *
 * @example
 * ```js
 * const fn = (time) => Observable.timer(time);
 * const throttled = throttle(fn);
 *
 * const Obs1 = throttled(2000); // -> call fn(2000) and returns its Observable
 * const Obs2 = throttled(1000); // -> won't do anything, Obs2 is an empty
 *                               //    observable (it directly completes)
 * setTimeout(() => {
 *   const Obs3 = throttled(1000); // -> will call fn(1000)
 * }, 2001);
 * ```
 *
 * @param {Function} func
 * @returns {Function} - Function taking in argument the arguments you want
 * to give your function, and returning an Observable.
 */
        function throttle(func) {
            var isPending = !1;
            return function() {
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                return new Observable.a(function(obs) {
                    var hasErroredOrCompleted = !1;
                    return isPending ? (hasErroredOrCompleted = !0, void obs.complete()) : (isPending = !0, 
                    func.apply(void 0, args).subscribe(function(i) {
                        obs.next(i);
                    }, function(e) {
                        isPending = !(hasErroredOrCompleted = !0), obs.error(e);
                    }, function() {
                        isPending = !(hasErroredOrCompleted = !0), obs.complete();
                    }), function() {
                        // handle unsubscription
                        hasErroredOrCompleted || (isPending = !1);
                    });
                });
            };
        }
        // EXTERNAL MODULE: ./src/utils/array_find.ts
                var array_find = __webpack_require__(11), object_values = __webpack_require__(92), EWMA = 
        /* */
        function() {
            /**
   * @param {number} halfLife
   */
            function EWMA(halfLife) {
                // (half-life = log(1/2) / log(Decay Factor)
                this._alpha = Math.exp(Math.log(.5) / halfLife), this._lastEstimate = 0, this._totalWeight = 0;
            }
            /**
   * @param {number} weight
   * @param {number} value
   */            var _proto = EWMA.prototype;
            return _proto.addSample = function addSample(weight, value) {
                var adjAlpha = Math.pow(this._alpha, weight), newEstimate = value * (1 - adjAlpha) + adjAlpha * this._lastEstimate;
                isNaN(newEstimate) || (this._lastEstimate = newEstimate, this._totalWeight += weight);
            }
            /**
   * @returns {number} value
   */ , _proto.getEstimate = function getEstimate() {
                var zeroFactor = 1 - Math.pow(this._alpha, this._totalWeight);
                return this._lastEstimate / zeroFactor;
            }, EWMA;
        }(), ABR_MINIMUM_TOTAL_BYTES = config.a.ABR_MINIMUM_TOTAL_BYTES, ABR_MINIMUM_CHUNK_SIZE = config.a.ABR_MINIMUM_CHUNK_SIZE, ABR_FAST_EMA = config.a.ABR_FAST_EMA, ABR_SLOW_EMA = config.a.ABR_SLOW_EMA, bandwidth_estimator_BandwidthEstimator = 
        /* */
        function() {
            function BandwidthEstimator() {
                /**
     * A fast-moving average.
     * @private
     */
                this._fastEWMA = new EWMA(ABR_FAST_EMA), 
                /**
     * A slow-moving average.
     * @private
     */
                this._slowEWMA = new EWMA(ABR_SLOW_EMA), 
                /**
     * Number of bytes sampled.
     * @private
     */
                this._bytesSampled = 0;
            }
            /**
   * Takes a bandwidth sample.
   * @param {number} durationMs - The amount of time, in milliseconds, for a
   *   particular request.
   * @param {number} numBytes - The total number of bytes transferred in that
   *   request.
   */            var _proto = BandwidthEstimator.prototype;
            return _proto.addSample = function addSample(durationInMs, numberOfBytes) {
                if (!(numberOfBytes < ABR_MINIMUM_CHUNK_SIZE)) {
                    var bandwidth = 8e3 * numberOfBytes / durationInMs, weight = durationInMs / 1e3;
                    this._bytesSampled += numberOfBytes, this._fastEWMA.addSample(weight, bandwidth), 
                    this._slowEWMA.addSample(weight, bandwidth);
                }
            }
            /**
   * Get estimate of the bandwidth, in bits per seconds.
   * @returns {Number|undefined}
   */ , _proto.getEstimate = function getEstimate() {
                if (!(this._bytesSampled < ABR_MINIMUM_TOTAL_BYTES)) // Take the minimum of these two estimates.  This should have the effect of
                // adapting down quickly, but up more slowly.
                return Math.min(this._fastEWMA.getEstimate(), this._slowEWMA.getEstimate());
            }
            /**
   * Reset the bandwidth estimation.
   */ , _proto.reset = function reset() {
                this._fastEWMA = new EWMA(ABR_FAST_EMA), this._slowEWMA = new EWMA(ABR_SLOW_EMA), 
                this._bytesSampled = 0;
            }, BandwidthEstimator;
        }();
        // EXTERNAL MODULE: ./src/utils/object_values.ts
                // CONCATENATED MODULE: ./src/utils/array_find_index.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Array.prototype.find ponyfill.
 * @param {Array} arr
 * @param {Function} predicate
 * @param {*} context
 * @returns {boolean}
 */
        function arrayFindIndex(arr, predicate, thisArg) {
            if ("function" == typeof Array.prototype.findIndex) 
            /* tslint:disable ban */
            return arr.findIndex(predicate, thisArg);
            /* tslint:enable ban */            for (var len = arr.length >>> 0, i = 0; i < len; i++) if (predicate.call(thisArg, arr[i], i, arr)) return i;
            return -1;
        }
        // CONCATENATED MODULE: ./src/core/abr/filter_by_bitrate.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Get only representations lower than a given bitrate.
 * @param {Array.<Object>} representations - The representations array
 * @param {Number} bitrate
 * @returns {Array.<Object>}
 */        function filterByBitrate(representations, bitrate) {
            var firstSuperiorBitrate = arrayFindIndex(representations, function(representation) {
                return representation.bitrate > bitrate;
            });
            return -1 === firstSuperiorBitrate ? representations : representations.slice(0, firstSuperiorBitrate);
        }
        // CONCATENATED MODULE: ./src/core/abr/filter_by_width.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Filter representations based on their width:
 *   - the highest width considered will be the one linked to the first
 *     representation which has a superior width to the one given.
 * @param {Array.<Object>} representations - The representations array
 * @param {Number} width
 * @returns {Array.<Object>}
 */        function filterByWidth(representations, width) {
            var sortedRepsByWidth = representations.slice().sort(function(a, b) {
                return (a.width || 0) - (b.width || 0);
            }), repWithMaxWidth = Object(array_find.a)(sortedRepsByWidth, function(representation) {
                return (representation.width || 0) >= width;
            });
            if (repWithMaxWidth) {
                var maxWidth = repWithMaxWidth.width || 0;
                return representations.filter(function(representation) {
                    return (representation.width || 0) <= maxWidth;
                });
            }
            return representations;
        }
        // CONCATENATED MODULE: ./src/core/abr/from_bitrate_ceil.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {Array.<Representation>} representations - The representations array
 * @param {Number} bitrate
 * @returns {Representation}
 */        function fromBitrateCeil(representations, bitrate) {
            var tooHighIndex = arrayFindIndex(representations, function(representation) {
                return representation.bitrate > bitrate;
            });
            return -1 === tooHighIndex ? representations[representations.length - 1] : representations[tooHighIndex - 1];
        }
        // CONCATENATED MODULE: ./src/core/abr/representation_chooser.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        var ABR_REGULAR_FACTOR = config.a.ABR_REGULAR_FACTOR, ABR_STARVATION_DURATION_DELTA = config.a.ABR_STARVATION_DURATION_DELTA, ABR_STARVATION_FACTOR = config.a.ABR_STARVATION_FACTOR, ABR_STARVATION_GAP = config.a.ABR_STARVATION_GAP, OUT_OF_STARVATION_GAP = config.a.OUT_OF_STARVATION_GAP;
        /**
 * Get the pending request starting with the asked segment position.
 * @param {Object} requests
 * @param {number} position
 * @returns {IRequestInfo|undefined}
 */        function getConcernedRequest(requests, neededPosition) {
            for (var currentRequestIds = Object.keys(requests), len = currentRequestIds.length, i = 0; i < len; i++) {
                var request = requests[currentRequestIds[i]];
                if (null != request && 0 < request.duration) if (neededPosition < request.time + request.duration && -.3 < neededPosition - request.time) return request;
            }
        }
        /**
 * Estimate the __VERY__ recent bandwidth based on a single unfinished request.
 * Useful when the current bandwidth seemed to have fallen quickly.
 *
 * @param {Object} request
 * @returns {number|undefined}
 */        function estimateRequestBandwidth(request) {
            if (!(request.progress.length < 2)) {
                for (// try to infer quickly the current bitrate based on the
                // progress events
                var ewma1 = new EWMA(2), progress = request.progress, i = 1; i < progress.length; i++) {
                    var bytesDownloaded = progress[i].size - progress[i - 1].size, timeElapsed = progress[i].timestamp - progress[i - 1].timestamp, reqBitrate = 8 * bytesDownloaded / (timeElapsed / 1e3);
                    ewma1.addSample(timeElapsed / 1e3, reqBitrate);
                }
                return ewma1.getEstimate();
            }
        }
        /**
 * Filter representations given through filters options.
 * @param {Array.<Representation>} representations
 * @param {Object} filters - Filter Object.
 * _Can_ contain each of the following properties:
 *   - bitrate {Number} - max bitrate authorized (included).
 *   - width {Number} - max width authorized (included).
 * @returns {Array.<Representation>}
 */        function getFilteredRepresentations(representations, filters) {
            var _representations = representations;
            return null != filters.bitrate && (_representations = filterByBitrate(_representations, filters.bitrate)), 
            null != filters.width && (_representations = filterByWidth(_representations, filters.width)), 
            _representations;
        }
        /**
 * Estimate remaining time for a pending request from a progress event.
 * @param {Object} lastProgressEvent
 * @param {number} bandwidthEstimate
 * @returns {number}
 */        function estimateRemainingTime(lastProgressEvent, bandwidthEstimate) {
            var remainingData = 8 * (lastProgressEvent.totalSize - lastProgressEvent.size);
            return Math.max(remainingData / bandwidthEstimate, 0);
        }
        /**
 * Check if the request for the most needed segment is too slow.
 * If that's the case, re-calculate the bandwidth urgently based on
 * this single request.
 * @param {Object} pendingRequests - Current pending requests.
 * @param {Object} clock - Informations on the current playback.
 * @param {Number} lastEstimatedBitrate - Last bitrate estimation emitted.
 * @returns {Number|undefined}
 */        function estimateStarvationModeBitrate(pendingRequests, clock, lastEstimatedBitrate) {
            var concernedRequest = getConcernedRequest(pendingRequests, clock.currentTime + clock.bufferGap);
            if (concernedRequest) {
                var chunkDuration = concernedRequest.duration, now = performance.now(), lastProgressEvent = concernedRequest.progress ? concernedRequest.progress[concernedRequest.progress.length - 1] : null, bandwidthEstimate = estimateRequestBandwidth(concernedRequest);
                if (null != lastProgressEvent && null != bandwidthEstimate) {
                    var remainingTime = 1.2 * estimateRemainingTime(lastProgressEvent, bandwidthEstimate);
 // if this remaining time is reliable and is not enough to avoid buffering
                                        if ((now - lastProgressEvent.timestamp) / 1e3 <= remainingTime && remainingTime > clock.bufferGap / clock.speed) return bandwidthEstimate;
                }
                var requestElapsedTime = (now - concernedRequest.requestTimestamp) / 1e3, currentBitrate = clock.downloadBitrate;
                if (!(null == currentBitrate || requestElapsedTime <= (1.5 * chunkDuration + 1) / clock.speed)) {
                    // calculate a reduced bitrate from the current one
                    var reducedBitrate = .7 * currentBitrate;
                    return null == lastEstimatedBitrate || reducedBitrate < lastEstimatedBitrate ? reducedBitrate : void 0;
                }
            }
        }
        /**
 * Returns true if, based on the current requests, it seems that the ABR should
 * switch immediately if a lower bitrate is more adapted.
 * Returns false if it estimates that you have time before switching to a lower
 * bitrate.
 * @param {Object} pendingRequests
 * @param {Object} clock
 */        function shouldDirectlySwitchToLowBitrate(pendingRequests, clock) {
            var nextNeededPosition = clock.currentTime + clock.bufferGap, requests = Object(object_values.a)(pendingRequests).filter(function(a) {
                return !!a;
            }).sort(function(a, b) {
                return a.time - b.time;
            }), nextNeededRequest = Object(array_find.a)(requests, function(r) {
                return r.time + r.duration > nextNeededPosition;
            });
            if (!nextNeededRequest) return !0;
            var now = performance.now(), lastProgressEvent = nextNeededRequest.progress ? nextNeededRequest.progress[nextNeededRequest.progress.length - 1] : null, bandwidthEstimate = estimateRequestBandwidth(nextNeededRequest);
            if (null == lastProgressEvent || null == bandwidthEstimate) return !0;
            var remainingTime = estimateRemainingTime(lastProgressEvent, bandwidthEstimate);
            return !((now - lastProgressEvent.timestamp) / 1e3 <= 1.2 * remainingTime && remainingTime < clock.bufferGap / clock.speed + ABR_STARVATION_GAP);
        }
        /**
 * Choose the right representation based on multiple parameters given, such as:
 *   - the current user's bandwidth
 *   - the max bitrate authorized
 *   - the size of the video element
 *
 * Those parameters can be set through different subjects and methods.
 * The subjects (undocumented here are):
 *
 *   - manualBitrate$ {Subject}: Set the bitrate manually, if no representation
 *     is found with the given bitrate. An immediately inferior one will be
 *     taken instead. If still, none are found, the representation with the
 *     minimum bitrate will be taken.
 *     Set it to a negative value to go into automatic bitrate mode.
 *
 *   - maxBitrate$ {Subject}: Set the maximum automatic bitrate. If the manual
 *     bitrate is not set / set to a negative value, this will be the maximum
 *     switch-able bitrate. If no representation is found inferior or equal to
 *     this bitrate, the representation with the minimum bitrate will be taken.
 *
 * @class RepresentationChooser
 */        var representation_chooser_RepresentationChooser = 
        /* */
        function() {
            /**
   * @param {Object} options
   */
            function RepresentationChooser(options) {
                this._dispose$ = new Subject.a(), this.manualBitrate$ = new BehaviorSubject_BehaviorSubject(null != options.manualBitrate ? options.manualBitrate : -1), 
                this.maxAutoBitrate$ = new BehaviorSubject_BehaviorSubject(null != options.maxAutoBitrate ? options.maxAutoBitrate : Infinity), 
                this.estimator = new bandwidth_estimator_BandwidthEstimator(), this._currentRequests = {}, 
                this._initialBitrate = options.initialBitrate || 0, this._limitWidth$ = options.limitWidth$, 
                this._throttle$ = options.throttle$, this._reEstimate$ = new Subject.a();
            }
            /**
   * @param {Observable} clock$
   * @param {Array.<Object>} representations
   * @returns {Observable}
   */            var _proto = RepresentationChooser.prototype;
            return _proto.get$ = function get$(clock$, representations) {
                var _this = this;
                if (!representations.length) throw new Error("ABRManager: no representation choice given");
                if (1 === representations.length) return Object(of.a)({
                    bitrate: void 0,
                    representation: representations[0],
                    manual: !1,
                    urgent: !0
                });
                var manualBitrate$ = this.manualBitrate$, maxAutoBitrate$ = this.maxAutoBitrate$, _initialBitrate = this._initialBitrate, _deviceEventsArray = [];
                this._limitWidth$ && _deviceEventsArray.push(this._limitWidth$.pipe(Object(map.a)(function(width) {
                    return {
                        width: width
                    };
                }))), this._throttle$ && _deviceEventsArray.push(this._throttle$.pipe(Object(map.a)(function(bitrate) {
                    return {
                        bitrate: bitrate
                    };
                })));
                // Emit restrictions on the pools of available Representations to choose
                // from.
                var lastEstimatedBitrate, deviceEvents$ = _deviceEventsArray.length ? combineLatest.a.apply(void 0, _deviceEventsArray).pipe(Object(map.a)(function(args) {
                    return object_assign_default.a.apply(void 0, [ {} ].concat(args));
                })) : Object(of.a)({});
 // Store the last client's bitrate generated by our estimation algorithms.
                                return manualBitrate$.pipe(Object(switchMap.a)(function(manualBitrate) {
                    if (0 <= manualBitrate) 
                    // -- MANUAL mode --
                    return Object(of.a)({
                        bitrate: void 0,
                        representation: fromBitrateCeil(representations, manualBitrate) || representations[0],
                        manual: !0,
                        urgent: !0
                    });
 // -- AUTO mode --
                                        var inStarvationMode = !1;
 // == buffer gap too low == panic mode
                                        return Object(combineLatest.a)(clock$, maxAutoBitrate$, deviceEvents$, _this._reEstimate$.pipe(Object(startWith.a)(null))).pipe(Object(map.a)(function(_ref) {
                        var newBitrateCeil, bandwidthEstimate, nextEstimate, clock = _ref[0], maxAutoBitrate = _ref[1], deviceEvents = _ref[2], bufferGap = clock.bufferGap;
                        // If in starvation mode, check if a quick new estimate can be done
                        // from the last requests.
                        // If so, cancel previous estimations and replace it by the new one
                        if (// check if should get in/out of starvation mode
                        bufferGap + clock.currentTime < clock.duration - ABR_STARVATION_DURATION_DELTA ? !inStarvationMode && bufferGap <= ABR_STARVATION_GAP ? (log.a.info("ABR: enter starvation mode."), 
                        inStarvationMode = !0) : inStarvationMode && OUT_OF_STARVATION_GAP <= bufferGap && (log.a.info("ABR: exit starvation mode."), 
                        inStarvationMode = !1) : inStarvationMode && (log.a.info("ABR: exit starvation mode."), 
                        inStarvationMode = !1), inStarvationMode && null != (bandwidthEstimate = estimateStarvationModeBitrate(_this._currentRequests, clock, lastEstimatedBitrate))) {
                            log.a.info("ABR: starvation mode emergency estimate:", bandwidthEstimate), _this.estimator.reset();
                            var currentBitrate = clock.downloadBitrate;
                            newBitrateCeil = null == currentBitrate ? Math.min(bandwidthEstimate, maxAutoBitrate) : Math.min(bandwidthEstimate, maxAutoBitrate, currentBitrate);
                        }
 // if newBitrateCeil is not yet defined, do the normal estimation
                                                null == newBitrateCeil && (nextEstimate = null != (bandwidthEstimate = _this.estimator.getEstimate()) ? inStarvationMode ? bandwidthEstimate * ABR_STARVATION_FACTOR : bandwidthEstimate * ABR_REGULAR_FACTOR : null != lastEstimatedBitrate ? inStarvationMode ? lastEstimatedBitrate * ABR_STARVATION_FACTOR : lastEstimatedBitrate * ABR_REGULAR_FACTOR : _initialBitrate, 
                        newBitrateCeil = Math.min(nextEstimate, maxAutoBitrate));
                        1 < clock.speed && (newBitrateCeil /= clock.speed);
                        var chosenRepresentation = fromBitrateCeil(getFilteredRepresentations(representations, deviceEvents), newBitrateCeil) || representations[0], urgent = function() {
                            return null == clock.downloadBitrate || chosenRepresentation.bitrate !== clock.downloadBitrate && (chosenRepresentation.bitrate > clock.downloadBitrate ? !inStarvationMode : shouldDirectlySwitchToLowBitrate(_this._currentRequests, clock));
                        }();
                        return {
                            bitrate: bandwidthEstimate,
                            representation: chosenRepresentation,
                            manual: !1,
                            urgent: urgent
                        };
                    }), Object(tap.a)(function(_ref2) {
                        var bitrate = _ref2.bitrate;
                        null != bitrate && (lastEstimatedBitrate = bitrate);
                    }), Object(takeUntil.a)(_this._dispose$));
                }));
            }
            /**
   * Add a bandwidth estimate by giving:
   *   - the duration of the request, in s
   *   - the size of the request in bytes
   * @param {number} duration
   * @param {number} size
   */ , _proto.addEstimate = function addEstimate(duration, size) {
                null != duration && null != size && (this.estimator.addSample(duration, size), this._reEstimate$.next());
            }
            /**
   * Add informations about a new pending request.
   * This can be useful if the network bandwidth drastically changes to infer
   * a new bandwidth through this single request.
   * @param {string|number} id
   * @param {Object} payload
   */ , _proto.addPendingRequest = function addPendingRequest(id, payload) {
                if (this._currentRequests[id]) log.a.warn("ABR: request already added."); else {
                    var _payload$value = payload.value, time = _payload$value.time, duration = _payload$value.duration, requestTimestamp = _payload$value.requestTimestamp;
                    this._currentRequests[id] = {
                        time: time,
                        duration: duration,
                        requestTimestamp: requestTimestamp,
                        progress: []
                    };
                }
            }
            /**
   * Add progress informations to a pending request.
   * Progress objects are a key part to calculate the bandwidth from a single
   * request, in the case the user's bandwidth changes drastically while doing
   * it.
   * @param {string|number} id
   * @param {Object} progress
   */ , _proto.addRequestProgress = function addRequestProgress(id, progress) {
                var request = this._currentRequests[id];
                request ? request.progress.push(progress.value) : log.a.warn("ABR: progress for a request not added");
            }
            /**
   * Remove a request previously set as pending through the addPendingRequest
   * method.
   * @param {string|number} id
   */ , _proto.removePendingRequest = function removePendingRequest(id) {
                this._currentRequests[id] || log.a.warn("ABR: can't remove unknown request"), delete this._currentRequests[id];
            }
            /**
   * Free up the resources used by the RepresentationChooser.
   */ , _proto.dispose = function dispose() {
                this._dispose$.next(), this._dispose$.complete(), this._reEstimate$.next(), this._reEstimate$.complete(), 
                this.manualBitrate$.complete(), this.maxAutoBitrate$.complete();
            }, RepresentationChooser;
        }(), defaultChooserOptions = {
            limitWidth: {},
            throttle: {},
            initialBitrates: {},
            manualBitrates: {},
            maxAutoBitrates: {}
        }, abr_manager_createChooser = function createChooser(type, options) {
            return new representation_chooser_RepresentationChooser({
                limitWidth$: options.limitWidth[type],
                throttle$: options.throttle[type],
                initialBitrate: options.initialBitrates[type],
                manualBitrate: options.manualBitrates[type],
                maxAutoBitrate: options.maxAutoBitrates[type]
            });
        }, abr = 
        /* */
        function() {
            /**
   * @param {Observable} requests$ - Emit requests infos as they begin, progress
   * and end.
   * Allows to know if a request take too much time to be finished in
   * emergency times (e.g. when the user's bandwidth falls very quickly).
   *
   * The items emitted are Observables which each emit infos about a SINGLE
   * request. These infos are under the form of objects with the following keys:
   *   - type {string}: the buffer type (example: "video")
   *
   *   - event {string}: Wether the request started, is progressing or has
   *     ended. Should be either one of these three strings:
   *       1. "requestBegin": The request has just begun.
   *
   *       2. "progress": Informations about the request progress were received
   *          (basically the amount of bytes currently received).
   *
   *       2. "requestEnd": The request just ended (successfully/on error/was
   *          canceled)
   *
   *     Note that it should ALWAYS happen in the following order:
   *     1 requestBegin -> 0+ progress -> 1 requestEnd
   *
   *     Also note that EVERY requestBegin should eventually be followed by a
   *     requestEnd at some point. If that's not the case, a memory leak
   *     can happen.
   *
   *   - value {Object|undefined}: The value depends on the type of event
   *     received:
   *       - for "requestBegin" events, it should be an object with the
   *         following keys:
   *           - id {number|String}: The id of this particular request.
   *           - duration {number}: duration, in seconds of the asked segment.
   *           - time {number}: The start time, in seconds of the asked segment.
   *           - requestTimestamp {number}: the timestamp at which the request
   *             was sent, in ms.
   *
   *       - for "progress" events, it should be an object with the following
   *         keys:
   *           - id {number|String}: The id of this particular request.
   *           - size {number}: amount currently downloaded, in bytes
   *           - timestamp {number}: timestamp at which the progress event was
   *             received, in ms
   *         Those events SHOULD be received in order (that is, in increasing
   *         order for both size and timestamp).
   *
   *       - for "requestEnd" events:
   *           - id {number|String}: The id of this particular request.
   *
   * @param {Observable} metrics$ - Emit each times the network downloaded
   * a new segment for a given buffer type. Allows to obtain informations about
   * the user's bitrate.
   *
   * The items emitted are object with the following keys:
   *   - type {string}: the buffer type (example: "video")
   *   - value {Object}:
   *     - duration {number}: duration of the request, in seconds.
   *     - size {number}: size of the downloaded chunks, in bytes.
   *
   * @param {Object|undefined} options
   */
            function ABRManager(requests$, metrics$, options) {
                var _this = this;
                void 0 === options && (options = defaultChooserOptions), 
                // Subject emitting and completing on dispose.
                // Used to clean up every created observables.
                this._dispose$ = new Subject.a(), // Will contain every RepresentationChooser attached to the ABRManager,
                // by type ("audio"/"video" etc.)
                this._choosers = {}, // -- OPTIONS --
                // Will contain options used when (lazily) instantiating a
                // RepresentationChooser
                this._chooserInstanceOptions = {
                    initialBitrates: options.initialBitrates || {},
                    manualBitrates: options.manualBitrates || {},
                    maxAutoBitrates: options.maxAutoBitrates || {},
                    throttle: options.throttle || {},
                    limitWidth: options.limitWidth || {}
                }, metrics$.pipe(Object(takeUntil.a)(this._dispose$)).subscribe(function(_ref) {
                    var type = _ref.type, value = _ref.value, chooser = _this._lazilyCreateChooser(type), duration = value.duration, size = value.size;
                    chooser.addEstimate(duration, size);
                }), requests$.pipe(// requests$ emits observables which are subscribed to
                Object(mergeMap.a)(function(request$) {
                    return request$;
                }), Object(takeUntil.a)(this._dispose$)).subscribe(function(request) {
                    var type = request.type, value = request.value, chooser = _this._lazilyCreateChooser(type);
                    switch (request.event) {
                      case "requestBegin":
                        // use the id of the segment as in any case, we should only have at
                        // most one active download for the same segment.
                        // This might be not optimal if this changes however. The best I think
                        // for now is to just throw/warn in DEV mode when two pending ids
                        // are identical
                        chooser.addPendingRequest(value.id, request);
                        break;

                      case "requestEnd":
                        chooser.removePendingRequest(value.id);
                        break;

                      case "progress":
                        chooser.addRequestProgress(value.id, request);
                    }
                });
            }
            /**
   * Take type and an array of the available representations, spit out an
   * observable emitting the best representation (given the network/buffer
   * state).
   * @param {string} type
   * @param {Observable<Object>} clock$
   * @param {Array.<Representation>|undefined} representations
   * @returns {Observable}
   */            var _proto = ABRManager.prototype;
            return _proto.get$ = function get$(type, clock$, representations) {
                return void 0 === representations && (representations = []), this._lazilyCreateChooser(type).get$(clock$, representations);
            }
            /**
   * Set manually the bitrate for a given type.
   *
   * The given number will act as a ceil.
   * If no representation is found with the given bitrate, we will consider:
   *   1. The representation just lower than it
   *   2. If no representation is found in the previous step, the representation
   *   with the lowest bitrate.
   *
   * @param {string} type
   * @param {number} bitrate
   */ , _proto.setManualBitrate = function setManualBitrate(type, bitrate) {
                log.a.info("ABR: Setting manual bitrate");
                var chooser = this._choosers[type];
                chooser ? chooser.manualBitrate$.next(bitrate) : 
                // if no chooser yet, store as a chooser option for when it will be
                // effectively instantiated
                this._chooserInstanceOptions.initialBitrates[type] = bitrate;
            }
            /**
   * Set a maximum bitrate a given type will be able to automatically switch to.
   * The chooser for the given type can still emit higher bitrates with the
   * setManualBitrate method.
   * @param {string} supportedBufferTypes
   * @param {number} bitrate
   */ , _proto.setMaxAutoBitrate = function setMaxAutoBitrate(type, bitrate) {
                log.a.info("ABR: Setting maximum auto bitrate");
                var chooser = this._choosers[type];
                chooser ? chooser.maxAutoBitrate$.next(bitrate) : 
                // if no chooser yet, store as a chooser option for when it will be
                // effectively instantiated
                this._chooserInstanceOptions.maxAutoBitrates[type] = bitrate;
            }
            /**
   * Returns the set (and active) manual bitrate for the given type.
   * @param {string} supportedBufferTypes
   * @returns {number|undefined}
   */ , _proto.getManualBitrate = function getManualBitrate(type) {
                var chooser = this._choosers[type];
                return chooser ? chooser.manualBitrate$.getValue() : this._chooserInstanceOptions.manualBitrates[type];
            }
            /**
   * Returns the set (and active) maximum auto bitrate for the given type.
   * @param {string} supportedBufferTypes
   * @returns {number|undefined}
   */ , _proto.getMaxAutoBitrate = function getMaxAutoBitrate(type) {
                var chooser = this._choosers[type];
                return chooser ? chooser.maxAutoBitrate$.getValue() : this._chooserInstanceOptions.maxAutoBitrates[type];
            }
            /**
   * Clean every ressources linked to the ABRManager.
   * The ABRManager is unusable after calling this method.
   */ , _proto.dispose = function dispose() {
                var _this2 = this;
                log.a.debug("ABR: Freeing up ressources"), Object.keys(this._choosers).forEach(function(type) {
                    _this2._choosers[type].dispose();
                }), this._chooserInstanceOptions = defaultChooserOptions, this._choosers = {}, this._dispose$.next(), 
                this._dispose$.complete();
            }
            /**
   * If it doesn't exist, create a RepresentationChooser under the
   * _choosers[bufferType] property.
   * @param {string} bufferType
   * @returns {Object}
   */ , _proto._lazilyCreateChooser = function _lazilyCreateChooser(bufferType) {
                return this._choosers[bufferType] || (log.a.debug("ABR: Creating new buffer for ", bufferType), 
                this._choosers[bufferType] = abr_manager_createChooser(bufferType, this._chooserInstanceOptions)), 
                this._choosers[bufferType];
            }, ABRManager;
        }(), is_known_error = __webpack_require__(180), request_error = __webpack_require__(182), error_message = __webpack_require__(55);
        // CONCATENATED MODULE: ./src/core/abr/abr_manager.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        
        // CONCATENATED MODULE: ./src/errors/network_error.ts
        function _assertThisInitialized(self) {
            if (void 0 === self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return self;
        }
        function _inheritsLoose(subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype), (subClass.prototype.constructor = subClass).__proto__ = superClass;
        }
        function _wrapNativeSuper(Class) {
            var _cache = "function" == typeof Map ? new Map() : void 0;
            return (_wrapNativeSuper = function _wrapNativeSuper(Class) {
                if (null === Class || !_isNativeFunction(Class)) return Class;
                if ("function" != typeof Class) throw new TypeError("Super expression must either be null or a function");
                if (void 0 !== _cache) {
                    if (_cache.has(Class)) return _cache.get(Class);
                    _cache.set(Class, Wrapper);
                }
                function Wrapper() {
                    return _construct(Class, arguments, _getPrototypeOf(this).constructor);
                }
                return Wrapper.prototype = Object.create(Class.prototype, {
                    constructor: {
                        value: Wrapper,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }), _setPrototypeOf(Wrapper, Class);
            })(Class);
        }
        function isNativeReflectConstruct() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function() {})), 
                !0;
            } catch (e) {
                return !1;
            }
        }
        function _construct(Parent, args, Class) {
            return (_construct = isNativeReflectConstruct() ? Reflect.construct : function _construct(Parent, args, Class) {
                var a = [ null ];
                a.push.apply(a, args);
                var instance = new (Function.bind.apply(Parent, a))();
                return Class && _setPrototypeOf(instance, Class.prototype), instance;
            }).apply(null, arguments);
        }
        function _isNativeFunction(fn) {
            return -1 !== Function.toString.call(fn).indexOf("[native code]");
        }
        function _setPrototypeOf(o, p) {
            return (_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
                return o.__proto__ = p, o;
            })(o, p);
        }
        function _getPrototypeOf(o) {
            return (_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
                return o.__proto__ || Object.getPrototypeOf(o);
            })(o);
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Error linked to network interactions (requests).
 *
 * @class NetworkError
 * @extends Error
 */        var network_error_NetworkError = 
        /* */
        function(_Error) {
            /**
   * @param {string} code
   * @param {Error} requestError
   * @param {Boolean} fatal
   */
            function NetworkError(code, requestError, fatal) {
                var _this;
                return _this = _Error.call(this) || this, // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class
                Object.setPrototypeOf(_assertThisInitialized(_this), NetworkError.prototype), _this.name = "NetworkError", 
                _this.type = error_codes.b.NETWORK_ERROR, _this.xhr = requestError.xhr, _this.url = requestError.url, 
                _this.status = requestError.status, _this.errorType = requestError.type, _this.code = error_codes.a.hasOwnProperty(code) ? error_codes.a[code] : "", 
                _this.fatal = !!fatal, _this.message = Object(error_message.a)(_this.name, _this.code, requestError.message), 
                _this;
            }
            /**
   * Returns true if the NetworkError is due to the given http error code
   * @param {number} httpErrorCode
   * @returns {Boolean}
   */            return _inheritsLoose(NetworkError, _Error), NetworkError.prototype.isHttpError = function isHttpError(httpErrorCode) {
                return this.errorType === error_codes.c.ERROR_HTTP_CODE && this.status === httpErrorCode;
            }, NetworkError;
        }(_wrapNativeSuper(Error));
        // CONCATENATED MODULE: ./src/errors/other_error.ts
                function other_error_assertThisInitialized(self) {
            if (void 0 === self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return self;
        }
        function other_error_inheritsLoose(subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype), (subClass.prototype.constructor = subClass).__proto__ = superClass;
        }
        function other_error_wrapNativeSuper(Class) {
            var _cache = "function" == typeof Map ? new Map() : void 0;
            return (other_error_wrapNativeSuper = function _wrapNativeSuper(Class) {
                if (null === Class || !other_error_isNativeFunction(Class)) return Class;
                if ("function" != typeof Class) throw new TypeError("Super expression must either be null or a function");
                if (void 0 !== _cache) {
                    if (_cache.has(Class)) return _cache.get(Class);
                    _cache.set(Class, Wrapper);
                }
                function Wrapper() {
                    return other_error_construct(Class, arguments, other_error_getPrototypeOf(this).constructor);
                }
                return Wrapper.prototype = Object.create(Class.prototype, {
                    constructor: {
                        value: Wrapper,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }), other_error_setPrototypeOf(Wrapper, Class);
            })(Class);
        }
        function other_error_isNativeReflectConstruct() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function() {})), 
                !0;
            } catch (e) {
                return !1;
            }
        }
        function other_error_construct(Parent, args, Class) {
            return (other_error_construct = other_error_isNativeReflectConstruct() ? Reflect.construct : function _construct(Parent, args, Class) {
                var a = [ null ];
                a.push.apply(a, args);
                var instance = new (Function.bind.apply(Parent, a))();
                return Class && other_error_setPrototypeOf(instance, Class.prototype), instance;
            }).apply(null, arguments);
        }
        function other_error_isNativeFunction(fn) {
            return -1 !== Function.toString.call(fn).indexOf("[native code]");
        }
        function other_error_setPrototypeOf(o, p) {
            return (other_error_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
                return o.__proto__ = p, o;
            })(o, p);
        }
        function other_error_getPrototypeOf(o) {
            return (other_error_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
                return o.__proto__ || Object.getPrototypeOf(o);
            })(o);
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @class OtherError
 * @extends Error
 */        var other_error_OtherError = 
        /* */
        function(_Error) {
            /**
   * @param {string} code
   * @param {string} reason
   * @param {Boolean} fatal
   */
            function OtherError(code, reason, fatal) {
                var _this;
                return _this = _Error.call(this) || this, // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class
                Object.setPrototypeOf(other_error_assertThisInitialized(_this), OtherError.prototype), 
                _this.name = "OtherError", _this.type = error_codes.b.OTHER_ERROR, _this.code = error_codes.a.hasOwnProperty(code) ? error_codes.a[code] : "", 
                _this.fatal = !!fatal, _this.message = Object(error_message.a)(_this.name, _this.code, reason), 
                _this;
            }
            return other_error_inheritsLoose(OtherError, _Error), OtherError;
        }(other_error_wrapNativeSuper(Error)), rx_try_catch = __webpack_require__(43), is_offline = __webpack_require__(132), backoff_delay = __webpack_require__(89);
        // EXTERNAL MODULE: ./src/utils/rx-try_catch.ts
                // CONCATENATED MODULE: ./src/core/pipelines/utils/backoff.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Called on a pipeline's loader error.
 * Returns whether the loader request should be retried.
 * @param {Error} error
 * @returns {Boolean}
 */
        function shouldRetry(error) {
            return error instanceof request_error.a && (error.type === error_codes.c.ERROR_HTTP_CODE ? 500 <= error.status || 404 === error.status || 412 === error.status : error.type === error_codes.c.TIMEOUT || error.type === error_codes.c.ERROR_EVENT);
        }
        /**
 * Returns true if we're pretty sure that the current error is due to the
 * user being offline.
 * @param {Error} error
 * @returns {Boolean}
 */        function isOfflineRequestError(error) {
            return error.type === error_codes.c.ERROR_EVENT && Object(is_offline.a)();
        }
        /**
 * Specific exponential backoff algorithm used for segments/manifest
 * downloading.
 *
 * The specificty here in comparaison to a "regular" backoff algorithm is
 * the separation between type of errors:
 *   - "offline" errors
 *   - other xhr errors
 * Both have their own counters which are resetted if the error type changes.
 * @param {Observable} obs$
 * @param {Object} options - Configuration options.
 * @returns {Observable}
 */        
        /* harmony default export */ var backoff = function downloadingBackoff(obs$, options) {
            var baseDelay = options.baseDelay, maxDelay = options.maxDelay, maxRetryRegular = options.maxRetryRegular, maxRetryOffline = options.maxRetryOffline, onRetry = options.onRetry, retryCount = 0, ERROR_TYPES_REGULAR = 1, ERROR_TYPES_OFFLINE = 2, lastError = 0;
            return obs$.pipe(Object(catchError.a)(function(error, source) {
                if (!shouldRetry(error)) throw error;
                var currentError = error instanceof request_error.a && isOfflineRequestError(error) ? ERROR_TYPES_OFFLINE : ERROR_TYPES_REGULAR;
                if (currentError !== lastError && (retryCount = 0, lastError = currentError), ++retryCount > (currentError === ERROR_TYPES_OFFLINE ? maxRetryOffline : maxRetryRegular)) throw error;
                onRetry && onRetry(error, retryCount);
                var delay = Math.min(baseDelay * Math.pow(2, retryCount - 1), maxDelay), fuzzedDelay = Object(backoff_delay.b)(delay);
                return Object(timer.a)(fuzzedDelay).pipe(Object(mergeMap.a)(function() {
                    return source;
                }));
            }));
        }, Subscription = __webpack_require__(14);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subscription.js + 1 modules
                // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/finalize.js
        /** PURE_IMPORTS_START tslib,_Subscriber,_Subscription PURE_IMPORTS_END */
        function finalize(callback) {
            return function(source) {
                return source.lift(new FinallyOperator(callback));
            };
        }
        var FinallyOperator = /* */ function() {
            function FinallyOperator(callback) {
                this.callback = callback;
            }
            return FinallyOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new finalize_FinallySubscriber(subscriber, this.callback));
            }, FinallyOperator;
        }(), finalize_FinallySubscriber = /* */ function(_super) {
            function FinallySubscriber(destination, callback) {
                var _this = _super.call(this, destination) || this;
                return _this.add(new Subscription.a(callback)), _this;
            }
            return tslib_es6.a(FinallySubscriber, _super), FinallySubscriber;
        }(Subscriber.a), cast_to_observable = __webpack_require__(17), MAX_BACKOFF_DELAY_BASE = config.a.MAX_BACKOFF_DELAY_BASE, INITIAL_BACKOFF_DELAY_BASE = config.a.INITIAL_BACKOFF_DELAY_BASE;
        /**
 * Generate a new error from the infos given.
 * @param {string} code
 * @param {Error} error
 * @param {Boolean} fatal - Whether the error is fatal to the content's
 * playback.
 * @returns {Error}
 */
        function errorSelector(code, error, fatal) {
            return Object(is_known_error.a)(error) ? error : error instanceof request_error.a ? new network_error_NetworkError(code, error, fatal) : new other_error_OtherError(code, error.toString(), fatal);
        }
        /**
 * Returns function allowing to download the wanted data through a
 * resolver -> loader pipeline.
 *
 * (The data can be for example: the manifest, audio and video segments, text,
 * images...)
 *
 * The function returned takes the initial data in arguments and returns an
 * Observable which will emit:
 *
 *   - each time a request begins (type "request").
 *     This is not emitted if the value is retrieved from a local js cache.
 *     This one emit the payload as a value.
 *
 *   - as the request progresses (type "progress").
 *
 *   - each time a request ends (type "metrics").
 *     This one contains informations about the metrics of the request.
 *
 *   - each time a minor request error is encountered (type "error").
 *     With the error as a value.
 *
 *   - Lastly, with the fetched data (type "response").
 *
 *
 * Each of these but "error" can be emitted at most one time.
 *
 * This observable will throw if, following the options given, the request and
 * possible retry all failed.
 *
 * This observable will complete after emitting the data.
 *
 * Type parameters:
 *   T: Argument given to the loader
 *   U: ResponseType of the request
 *
 * @param {Object} transportPipeline
 * @param {Object} options
 * @returns {Function}
 */        function createLoader(transportPipeline, options) {
            var cache = options.cache, maxRetry = options.maxRetry, maxRetryOffline = options.maxRetryOffline, loader = transportPipeline.loader, resolver = null != transportPipeline.resolver ? transportPipeline.resolver : of.a.bind(Observable.a), retryErrorSubject = new Subject.a(), backoffOptions = {
                baseDelay: INITIAL_BACKOFF_DELAY_BASE,
                maxDelay: MAX_BACKOFF_DELAY_BASE,
                maxRetryRegular: maxRetry,
                maxRetryOffline: maxRetryOffline,
                onRetry: function onRetry(error) {
                    retryErrorSubject.next(errorSelector("PIPELINE_LOAD_ERROR", error, !1));
                }
            };
            /**
   * Call the transport's resolver - if it exists - with the given data.
   *
   * Throws with the right error if it fails.
   * @param {Object} resolverArgument
   * @returns {Observable}
   */
            function callResolver(resolverArgument) {
                return Object(rx_try_catch.a)(resolver, resolverArgument).pipe().pipe(Object(catchError.a)(function(error) {
                    throw errorSelector("PIPELINE_RESOLVE_ERROR", error, !0);
                }));
            }
            /**
   * Load wanted data:
   *   - get it from cache if present
   *   - call the transport loader - with an exponential backoff - if not
   *
   * @param {Object} loaderArgument - Input given to the loader
   * @returns {Observable}
   */            function loadData(loaderArgument) {
                /**
     * Call the Pipeline's loader with an exponential Backoff.
     * @returns {Observable}
     */
                function startLoaderWithBackoff() {
                    var request$ = backoff(Object(rx_try_catch.a)(loader, loaderArgument), backoffOptions).pipe(Object(catchError.a)(function(error) {
                        throw errorSelector("PIPELINE_LOAD_ERROR", error, !0);
                    }), Object(tap.a)(function(arg) {
                        "response" === arg.type && cache && cache.add(loaderArgument, arg.value);
                    }));
                    return Object(concat.a)(Object(of.a)({
                        type: "request",
                        value: loaderArgument
                    }), request$);
                }
                var dataFromCache = cache ? cache.get(loaderArgument) : null;
                return null != dataFromCache ? Object(cast_to_observable.a)(dataFromCache).pipe(Object(map.a)(function(response) {
                    return {
                        type: "cache",
                        value: response
                    };
                }), Object(catchError.a)(startLoaderWithBackoff)) : startLoaderWithBackoff();
            }
            /**
   * Load the corresponding data.
   * @param {Object} pipelineInputData
   * @returns {Observable}
   */            return function startPipeline(pipelineInputData) {
                var pipeline$ = callResolver(pipelineInputData).pipe(Object(mergeMap.a)(function(resolverResponse) {
                    return loadData(resolverResponse).pipe(Object(mergeMap.a)(function(arg) {
                        // "cache": data taken from cache by the pipeline
                        // "data": the data is available but no request has been done
                        // "response": data received through a request
                        switch (arg.type) {
                          case "cache":
                          case "data":
                          case "response":
                            var response$ = Object(of.a)({
                                type: "response",
                                value: object_assign_default()({}, resolverResponse, {
                                    url: "response" === arg.type ? arg.value.url : void 0,
                                    responseData: arg.value.responseData,
                                    sendingTime: "response" === arg.type ? arg.value.sendingTime : void 0,
                                    receivedTime: "response" === arg.type ? arg.value.receivedTime : void 0
                                })
                            }), metrics$ = "response" !== arg.type ? empty.a : Object(of.a)({
                                type: "metrics",
                                value: {
                                    size: arg.value.size,
                                    duration: arg.value.duration
                                }
                            });
                            return Object(concat.a)(response$, metrics$);

                          default:
                            return Object(of.a)(arg);
                        }
                    }));
                }), finalize(function() {
                    retryErrorSubject.complete();
                })), retryError$ = retryErrorSubject.pipe(Object(map.a)(function(error) {
                    return {
                        type: "error",
                        value: error
                    };
                }));
                return Object(merge.a)(pipeline$, retryError$);
            };
        }
        // CONCATENATED MODULE: ./src/core/pipelines/manifest/create_manifest_pipeline.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        var create_manifest_pipeline_MAX_BACKOFF_DELAY_BASE = config.a.MAX_BACKOFF_DELAY_BASE, create_manifest_pipeline_INITIAL_BACKOFF_DELAY_BASE = config.a.INITIAL_BACKOFF_DELAY_BASE;
        /**
 * Generate a new error from the infos given.
 * @param {string} code
 * @param {Error} error
 * @param {Boolean} fatal - Whether the error is fatal to the content's
 * playback.
 * @returns {Error}
 */        function create_manifest_pipeline_errorSelector(code, error, fatal) {
            return Object(is_known_error.a)(error) ? error : error instanceof request_error.a ? new network_error_NetworkError(code, error, fatal) : new other_error_OtherError(code, error.toString(), fatal);
        }
        /**
 * Create function allowing to easily fetch and parse the manifest from its URL.
 *
 * @example
 * ```js
 * const manifestPipeline = createManifestPipeline(transport, options, warning$);
 * manifestPipeline(manifestURL)
 *  .subscribe(manifest => console.log("Manifest:", manifest));
 * ```
 *
 * @param {Object} transport
 * @param {Subject} warning$
 * @param {Array.<Object>|undefined} supplementaryTextTracks
 * @param {Array.<Object>|undefined} supplementaryImageTrack
 * @returns {Function}
 */        
        // CONCATENATED MODULE: ./src/core/pipelines/manifest/index.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /* harmony default export */ var pipelines_manifest = function createManifestPipeline(pipelines, pipelineOptions, warning$) {
            var loader = createLoader(pipelines.manifest, pipelineOptions), parser = pipelines.manifest.parser;
            /**
   * Allow the parser to schedule a new request.
   * @param {Object} transportPipeline
   * @param {Object} options
   * @returns {Function}
   */
            function scheduleRequest(request) {
                var maxRetry = pipelineOptions.maxRetry, maxRetryOffline = pipelineOptions.maxRetryOffline, backoffOptions = {
                    baseDelay: create_manifest_pipeline_INITIAL_BACKOFF_DELAY_BASE,
                    maxDelay: create_manifest_pipeline_MAX_BACKOFF_DELAY_BASE,
                    maxRetryRegular: maxRetry,
                    maxRetryOffline: maxRetryOffline,
                    onRetry: function onRetry(error) {
                        warning$.next(create_manifest_pipeline_errorSelector("PIPELINE_LOAD_ERROR", error, !1));
                    }
                };
                return backoff(Object(rx_try_catch.a)(request, void 0), backoffOptions).pipe(Object(catchError.a)(function(error) {
                    throw create_manifest_pipeline_errorSelector("PIPELINE_LOAD_ERROR", error, !0);
                }));
            }
            /**
   * Fetch and parse the manifest corresponding to the URL given.
   * @param {string} url - URL of the manifest
   * @returns {Observable}
   */            return function fetchManifest(url) {
                return loader({
                    url: url
                }).pipe(Object(tap.a)(function(arg) {
                    "error" === arg.type && warning$.next(arg.value);
                }), Object(filter.a)(function(arg) {
                    return "response" === arg.type;
                }), Object(mergeMap.a)(function(_ref) {
                    var value = _ref.value, sendingTime = value.sendingTime;
                    return parser({
                        response: value,
                        url: url,
                        scheduleRequest: scheduleRequest
                    }).pipe(Object(catchError.a)(function(error) {
                        throw Object(is_known_error.a)(error) ? error : new other_error_OtherError("PIPELINE_PARSING_ERROR", error.toString(), !0);
                    }), Object(map.a)(function(_ref2) {
                        for (var manifest = _ref2.manifest, warnings = manifest.parsingErrors, i = 0; i < warnings.length; i++) warning$.next(warnings[i]);
 // TODO not through warning$
                                                return {
                            manifest: manifest,
                            sendingTime: sendingTime
                        };
                    }));
                }), Object(share.a)());
            };
        };
        // CONCATENATED MODULE: ./src/core/pipelines/segment/prioritized_segment_fetcher.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * This function basically put in relation:
 *   - a SegmentFetcher, which will be used to perform the segment request
 *   - a prioritizer, which will handle the priority of a segment request
 *
 * and returns functions to fetch segments with a given priority.
 * @param {Object} prioritizer
 * @param {Object} fetcher
 * @returns {Object}
 */        function applyPrioritizerToSegmentFetcher(prioritizer, fetcher) {
            return {
                /**
     * Create a Segment request with a given priority.
     * @param {Object} content - content to request
     * @param {Number} priority - priority at which the content should be
     * requested.
     * @returns {Observable}
     */
                createRequest: function createRequest(content, priority) {
                    return void 0 === priority && (priority = 0), prioritizer.create(fetcher(content), priority);
                },
                /**
     * Update the priority of a pending request, created through createRequest.
     * @param {Observable} observable - the corresponding request
     * @param {Number} priority
     */
                updatePriority: function updatePriority(observable, priority) {
                    prioritizer.updatePriority(observable, priority);
                }
            };
        }
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/defer.js
                var defer = __webpack_require__(168), prioritizer_ObservablePrioritizer = 
        /* */
        function() {
            function ObservablePrioritizer() {
                this._pendingPriority = null, this._numberOfPendingObservables = 0, this._queue = [];
            }
            /**
   * Create a priorized Observable from a base Observable.
   *
   * When subscribed to, this Observable will have its priority compared to
   * all the already-running Observables created from this class.
   * Only if this number is inferior or equal to the priority of the
   * currently-running Observables will it be immediately started.
   * In the opposite case, we will wait for higher-priority Observables to
   * finish before starting it.
   *
   * Note that while this Observable is waiting for its turn, it is possible
   * to update its property through the updatePriority method, by providing
   * the Observable returned by this function and its new priority number.
   *
   * @param {Observable} obs
   * @param {number} priority
   * @returns {Observable}
   */            var _proto = ObservablePrioritizer.prototype;
            return _proto.create = function create(obs, priority) {
                var _this = this, pObs$ = Object(defer.a)(function() {
                    if (null == _this._pendingPriority || _this._pendingPriority >= priority) 
                    // Update the priority and start immediately the Observable
                    return _this._pendingPriority = priority, _this._startObservable(obs);
                    var trigger = new Subject.a();
                    return _this._queue.push({
                        observable: pObs$,
                        priority: priority,
                        trigger: trigger
                    }), trigger.pipe(Object(mergeMap.a)(function() {
                        return _this._startObservable(obs);
                    }));
                });
                return pObs$;
            }
            /**
   * Update the priority of an Observable created through the create method.
   *
   * Note that this will only have an effect on Observable which are not yet
   * started.
   * This means it will only have an effect on:
   *   - unsubscribed Observables
   *   - Observables waiting for Observables with an higher priority to
   *     finish
   *
   * @param {Observable} obs
   * @param {number} priority
   */ , _proto.updatePriority = function updatePriority(obs, priority) {
                var index = arrayFindIndex(this._queue, function(elt) {
                    return elt.observable === obs;
                });
                if (!(index < 0)) {
                    var queueElement = this._queue[index];
                    queueElement.priority = priority, (null == this._pendingPriority || this._pendingPriority >= priority) && (this._queue.splice(index, 1), 
                    queueElement.trigger.next(), queueElement.trigger.complete());
                }
            }, _proto._startObservable = function _startObservable(obs) {
                var _this2 = this;
                return this._numberOfPendingObservables++, obs.pipe(finalize(function onObservableFinish() {
                    if (_this2._numberOfPendingObservables--, !(0 < _this2._numberOfPendingObservables) && (_this2._pendingPriority = null, 
                    0 !== _this2._queue.length)) {
                        _this2._pendingPriority = _this2._queue.reduce(function(acc, elt) {
                            return null == acc || acc > elt.priority ? elt.priority : acc;
                        }, null);
                        for (var i = 0; i < _this2._queue.length; i++) {
                            var elt = _this2._queue[i];
                            elt.priority === _this2._pendingPriority && (_this2._queue.splice(i, 1), i--, elt.trigger.next(), 
                            elt.trigger.complete());
                        }
                    }
                }));
            }, ObservablePrioritizer;
        }(), id_generator = __webpack_require__(48), generateRequestID = Object(id_generator.a)();
        // CONCATENATED MODULE: ./src/core/pipelines/segment/prioritizer.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Create Observables which can be priorized between one another.
 *
 * With this class, you can create Observables with linked priority numbers.
 * The lower this number is, the more priority the resulting Observable will
 * have.
 *
 * Such Observable will then basically wait for pending Observables with more
 * priority to finish before "starting".
 *
 * You can also update the priority of an already-created Observable.
 * This will only have an effect if the Observable is currently "waiting" for
 * its turn (started observable won't be canceled if their priority were
 * lowered).
 *
 * ```js
 * const prioritizer = new ObservablePrioritizer();
 *
 * const observable1 = Observable.of(1);
 * const observable2 = Observable.of(2);
 * const observable3 = Observable.of(3);
 * const observable4 = Observable.of(4);
 * const observable5 = Observable.of(5);
 *
 * const pObservable1 = prioritizer.create(observable1, 4);
 * const pObservable2 = prioritizer.create(observable2, 2);
 * const pObservable3 = prioritizer.create(observable3, 1);
 * const pObservable4 = prioritizer.create(observable4, 3);
 * const pObservable5 = prioritizer.create(observable5, 2);
 *
 * // start every Observables at the same time
 * observableMerge(
 *   pObservable1,
 *   pObservable2,
 *   pObservable3,
 *   pObservable4,
 *   pObservable5
 * ).subscribe((i) => {
 *   // To spice things up, update pObservable1 priority to go before
 *   // pObservable4
 *   if (i === 5) { // if pObservable5 is currently emitting
 *     prioritizer.updatePriority(pObservable1, 1);
 *   }
 *   console.log(i);
 * });
 *
 * // Result:
 * // 3
 * // 2
 * // 5
 * // 1
 * // 4
 *
 * // Note: here "1" goes before "4" only because the former's priority has been
 * // updated before the latter was started.
 * // It would be the other way around if not.
 * ```
 *
 * @class ObservablePrioritizer
 */        
        /**
 * Create a function which will fetch segments.
 *
 * This function will:
 *   - only emit the resulting data
 *   - dispatch the other infos through the right subjects.
 *
 * @param {string} bufferType
 * @param {Object} transport
 * @param {Subject} network$ - Subject through which network metrics will be
 * sent, for the ABR.
 * @param {Subject} requests$ - Subject through which requests infos will be
 * sent, for the ABR.
 * @param {Subject} warning$ - Subject through which minor requests error will
 * be sent.
 * @param {Object} options
 * @returns {Function}
 */
        function createSegmentFetcher(bufferType, transport, network$, requests$, warning$, options) {
            var request$, id, segmentLoader = createLoader(transport[bufferType], options), segmentParser = transport[bufferType].parser;
            /**
   * Process a pipeline observable to adapt it to the the rest of the code:
   *   - use the network$ subject for network metrics (bandwitdh mesure)
   *   - use the requests subject for network requests and their progress
   *   - use the warning$ subject for retries' error messages
   *   - only emit the data
   * @param {string} pipelineType
   * @param {Observable} pipeline$
   * @returns {Observable}
   */
            return function fetchSegment(content) {
                return segmentLoader(content).pipe(Object(tap.a)(function(arg) {
                    switch (arg.type) {
                      case "error":
                        warning$.next(object_assign_default()(arg.value, {
                            pipelineType: bufferType
                        }));
                        break;

                      case "metrics":
                        var value = arg.value, size = value.size, duration = value.duration;
                        // unwrapping for TS
                        // format it for ABR Handling
                        null != size && null != duration && network$.next({
                            type: bufferType,
                            value: {
                                size: size,
                                duration: duration
                            }
                        });
                        break;

                      case "request":
                        var _value = arg.value, segment = _value && _value.segment;
 // format it for ABR Handling
                                                if (null != segment && null != segment.duration) {
                            request$ = new Subject.a(), requests$.next(request$);
                            var _duration = segment.duration / segment.timescale, time = segment.time / segment.timescale;
                            id = generateRequestID(), request$.next({
                                type: bufferType,
                                event: "requestBegin",
                                value: {
                                    duration: _duration,
                                    time: time,
                                    requestTimestamp: performance.now(),
                                    id: id
                                }
                            });
                        }
                        break;

                      case "progress":
                        var _value2 = arg.value;
                        null != _value2.totalSize && _value2.size < _value2.totalSize && null != id && null != request$ && request$.next({
                            type: bufferType,
                            event: "progress",
                            value: {
                                duration: _value2.duration,
                                size: _value2.size,
                                totalSize: _value2.totalSize,
                                timestamp: performance.now(),
                                id: id
                            }
                        });
                    }
                }), Object(filter.a)(function(arg) {
                    return "response" === arg.type;
                }), finalize(function() {
                    null != request$ && (null != id && request$.next({
                        type: bufferType,
                        event: "requestEnd",
                        value: {
                            id: id
                        }
                    }), request$.complete());
                }), Object(map.a)(function(response) {
                    return {
                        /**
         * Parse the loaded data.
         * @param {Object} [init]
         * @returns {Observable}
         */
                        parse: function parse(init) {
                            var parserArg = object_assign_default()({
                                response: response.value,
                                init: init
                            }, content);
                            return segmentParser(parserArg).pipe(Object(catchError.a)(function(error) {
                                throw Object(is_known_error.a)(error) ? error : new other_error_OtherError("PIPELINE_PARSING_ERROR", error.toString(), !0);
                            }));
                        }
                    };
                }), Object(share.a)());
            };
        }
        // CONCATENATED MODULE: ./src/core/pipelines/segment/segment_pipelines_manager.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Interact with the networking pipelines to download segments and dispatch
 * the related events to the right subjects.
 *
 * @class SegmentPipelinesManager
 *
 * @example
 * ```js
 * const requests$ = new Subject();
 * const metrics$ = new Subject();
 * const warnings$ = new Subject();
 *
 * // 1 - create the manager
 * const segmentPipelinesManager =
 *   new SegmentPipelinesManager(transport, requests$, metrics$, warnings$);
 *
 * // Note:
 * // You can create an ABRManager with the same requests$ and metrics$ subjects.
 * // It will then be informed of when the SegmentPipelinesManager downloads
 * // segments and with which metrics.
 * // The format of those events is kept the same for ease of use.
 * const abrManager = new ABRManager(requests$, metrics$);
 *
 * // 2 - create a new pipeline with its own options
 * const pipeline = segmentPipelinesManager.createPipeline("audio", {
 *   maxRetry: Infinity,
 *   maxRetryOffline: Infinity,
 * });
 *
 * // 3 - load a segment with a given priority
 * pipeline.createRequest(myContent, 1)
 *
 *   // 4 - parse it
 *   .pipe(mergeMap(fetchedSegment => fetchedSegment.parse()))
 *
 *   // 5 - use it
 *   .subscribe((res) => console.log("audio segment downloaded:", res));
 * ```
 */        var pipelines_segment = 
        /* */
        function() {
            /**
   * @param {Object} transport
   * @param {Subject} requestsInfos$
   * @param {Subject} metrics$
   * @param {Subject} warning
   */
            function SegmentPipelinesManager(transport, requestsInfos$, metrics$, warning) {
                this._transport = transport, this._metrics$ = metrics$, this._requestsInfos$ = requestsInfos$, 
                this._warning$ = warning, this._prioritizer = new prioritizer_ObservablePrioritizer();
            }
            /**
   * Create a segment pipeline, allowing to easily perform segment requests.
   * @param {string} bufferType
   * @param {Object} options
   * @returns {Object}
   */            return SegmentPipelinesManager.prototype.createPipeline = function createPipeline(bufferType, options) {
                var segmentFetcher = createSegmentFetcher(bufferType, this._transport, this._metrics$, this._requestsInfos$, this._warning$, options);
                return applyPrioritizerToSegmentFetcher(this._prioritizer, segmentFetcher);
            }, SegmentPipelinesManager;
        }(), create_eme_manager = __webpack_require__(100), clear_element_src = __webpack_require__(72), browser_compatibility_types = __webpack_require__(19), onSourceOpen$ = compat.a.onSourceOpen$;
        // CONCATENATED MODULE: ./src/core/pipelines/segment/index.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /* harmony default export */        
        /**
 * Set the media duration in the mediaSource.
 * @param {MediaSource} mediaSource
 * @param {number} duration
 */
        function setDurationToMediaSource(mediaSource, duration) {
            var newDuration = Infinity === duration ? Number.MAX_VALUE : duration;
            mediaSource.duration !== newDuration && (log.a.info("Init: Setting duration", newDuration), 
            mediaSource.duration = newDuration);
        }
        /**
 * Dispose of ressources taken by the MediaSource:
 *   - Clear the MediaSource' SourceBuffers
 *   - Clear the mediaElement's src (stop the mediaElement)
 *   - Revoke MediaSource' URL
 * @param {HTMLMediaElement} mediaElement
 * @param {MediaSource|null|undefined} mediaSource
 * @param {string|null|undefined} mediaSourceURL
 */        function resetMediaSource(mediaElement, mediaSource, mediaSourceURL) {
            if (mediaSource && "closed" !== mediaSource.readyState) {
                for (var readyState = mediaSource.readyState, sourceBuffers = mediaSource.sourceBuffers, i = sourceBuffers.length - 1; 0 <= i; i--) {
                    var sourceBuffer = sourceBuffers[i];
                    try {
                        "open" === readyState && (log.a.info("Init: Removing SourceBuffer from mediaSource", sourceBuffer), 
                        sourceBuffer.abort()), mediaSource.removeSourceBuffer(sourceBuffer);
                    } catch (e) {
                        log.a.warn("Init: Error while disposing SourceBuffer", e);
                    }
                }
                sourceBuffers.length && log.a.warn("Init: Not all SourceBuffers could have been removed.");
            }
            if (Object(clear_element_src.a)(mediaElement), mediaSourceURL) try {
                log.a.debug("Init: Revoking previous URL"), URL.revokeObjectURL(mediaSourceURL);
            } catch (e) {
                log.a.warn("Init: Error while revoking the media source URL", e);
            }
        }
        /**
 * Create, on subscription, a MediaSource instance and attach it to the given
 * mediaElement element's src attribute.
 *
 * Returns an Observable which emits the MediaSource when created and attached
 * to the mediaElement element.
 * This Observable never completes. It can throw if MediaSource is not
 * available in the current environment.
 *
 * On unsubscription, the mediaElement.src is cleaned, MediaSource sourceBuffers
 * and customBuffers are aborted and some minor cleaning is done.
 *
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */        function createMediaSource(mediaElement) {
            return new Observable.a(function(observer) {
                if (!browser_compatibility_types.c) throw new media_error.a("MEDIA_SOURCE_NOT_SUPPORTED", "No MediaSource Object was found in the current browser.", !0);
 // make sure the media has been correctly reset
                                resetMediaSource(mediaElement, null, mediaElement.src || null), 
                log.a.info("Init: Creating MediaSource");
                var mediaSource = new browser_compatibility_types.c(), objectURL = URL.createObjectURL(mediaSource);
                return log.a.info("Init: Attaching MediaSource URL to the media element", objectURL), 
                mediaElement.src = objectURL, observer.next(mediaSource), function() {
                    resetMediaSource(mediaElement, mediaSource, objectURL);
                };
            });
        }
        /**
 * Create and open a new MediaSource object on the given media element.
 * Emit the MediaSource when done.
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */        function openMediaSource(mediaElement) {
            return createMediaSource(mediaElement).pipe(Object(mergeMap.a)(function(mediaSource) {
                return onSourceOpen$(mediaSource).pipe(Object(take.a)(1), Object(mapTo.a)(mediaSource));
            }));
        }
        // EXTERNAL MODULE: ./src/core/init/events_generators.ts
                var events_generators = __webpack_require__(22), DEFAULT_LIVE_GAP = config.a.DEFAULT_LIVE_GAP;
        // CONCATENATED MODULE: ./src/core/init/get_initial_time.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        
        /**
 * Returns the calculated initial time for the content described by the given
 * Manifest:
 *   1. if a start time is defined by user, calculate starting time from the
 *      manifest informations
 *   2. else if the media is live, use the live edge and suggested delays from
 *      it
 *   3. else returns the minimum time announced in the manifest
 * @param {Manifest} manifest
 * @param {Object} startAt
 * @returns {Number}
 */
        function getInitialTime(manifest, startAt) {
            if (startAt) {
                var _manifest$getCurrentP = manifest.getCurrentPositionLimits(), min = _manifest$getCurrentP[0], max = _manifest$getCurrentP[1];
                if (null != startAt.position) return Math.max(Math.min(startAt.position, max), min);
                if (null != startAt.wallClockTime) {
                    var position = manifest.isLive ? startAt.wallClockTime - (manifest.availabilityStartTime || 0) : startAt.wallClockTime;
                    return Math.max(Math.min(position, max), min);
                }
                if (null != startAt.fromFirstPosition) {
                    var fromFirstPosition = startAt.fromFirstPosition;
                    return fromFirstPosition <= 0 ? min : Math.min(min + fromFirstPosition, max);
                }
                if (null != startAt.fromLastPosition) {
                    var fromLastPosition = startAt.fromLastPosition;
                    return 0 <= fromLastPosition ? max : Math.max(min, max + fromLastPosition);
                }
                if (null != startAt.percentage) {
                    var percentage = startAt.percentage;
                    return 100 < percentage ? max : percentage < 0 ? min : min + (max - min) * (+percentage / 100);
                }
            }
            if (manifest.isLive) {
                var sgp = manifest.suggestedPresentationDelay;
                return manifest.getMaximumPosition() - (null == sgp ? DEFAULT_LIVE_GAP : sgp);
            }
            return manifest.getMinimumPosition();
        }
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/OuterSubscriber.js
                var OuterSubscriber = __webpack_require__(25), InnerSubscriber = __webpack_require__(47), subscribeToResult = __webpack_require__(24), from = __webpack_require__(53);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/InnerSubscriber.js
                // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/exhaustMap.js
        /** PURE_IMPORTS_START tslib,_OuterSubscriber,_InnerSubscriber,_util_subscribeToResult,_map,_observable_from PURE_IMPORTS_END */
        function exhaustMap(project, resultSelector) {
            return resultSelector ? function(source) {
                return source.pipe(exhaustMap(function(a, i) {
                    return Object(from.a)(project(a, i)).pipe(Object(map.a)(function(b, ii) {
                        return resultSelector(a, b, i, ii);
                    }));
                }));
            } : function(source) {
                return source.lift(new ExhaustMapOperator(project));
            };
        }
        var ExhaustMapOperator = /* */ function() {
            function ExhaustMapOperator(project) {
                this.project = project;
            }
            return ExhaustMapOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new exhaustMap_ExhaustMapSubscriber(subscriber, this.project));
            }, ExhaustMapOperator;
        }(), exhaustMap_ExhaustMapSubscriber = /* */ function(_super) {
            function ExhaustMapSubscriber(destination, project) {
                var _this = _super.call(this, destination) || this;
                return _this.project = project, _this.hasSubscription = !1, _this.hasCompleted = !1, 
                _this.index = 0, _this;
            }
            return tslib_es6.a(ExhaustMapSubscriber, _super), ExhaustMapSubscriber.prototype._next = function(value) {
                this.hasSubscription || this.tryNext(value);
            }, ExhaustMapSubscriber.prototype.tryNext = function(value) {
                var result, index = this.index++;
                try {
                    result = this.project(value, index);
                } catch (err) {
                    return void this.destination.error(err);
                }
                this.hasSubscription = !0, this._innerSub(result, value, index);
            }, ExhaustMapSubscriber.prototype._innerSub = function(result, value, index) {
                var innerSubscriber = new InnerSubscriber.a(this, void 0, void 0);
                this.destination.add(innerSubscriber), Object(subscribeToResult.a)(this, result, value, index, innerSubscriber);
            }, ExhaustMapSubscriber.prototype._complete = function() {
                this.hasCompleted = !0, this.hasSubscription || this.destination.complete(), this.unsubscribe();
            }, ExhaustMapSubscriber.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
                this.destination.next(innerValue);
            }, ExhaustMapSubscriber.prototype.notifyError = function(err) {
                this.destination.error(err);
            }, ExhaustMapSubscriber.prototype.notifyComplete = function(innerSub) {
                this.destination.remove(innerSub), this.hasSubscription = !1, this.hasCompleted && this.destination.complete();
            }, ExhaustMapSubscriber;
        }(OuterSubscriber.a), array_includes = __webpack_require__(12), sorted_list_SortedList = 
        /* */
        function() {
            /**
   * @param {Function} sortingFunction
   */
            function SortedList(sortingFunction) {
                this._array = [], this._sortingFn = sortingFunction;
            }
            /**
   * Add a new element to the List at the right place for the List to stay
   * sorted.
   *
   * /!\ The added Element will share the same reference than the given
   * argument, any mutation on your part can lead to an un-sorted SortedList.
   * You can still re-force the sorting to happen by calling forceSort.
   * @param {...*} elements
   */            var _proto = SortedList.prototype;
            return _proto.add = function add() {
                for (var _len = arguments.length, elements = new Array(_len), _key = 0; _key < _len; _key++) elements[_key] = arguments[_key];
                elements.sort(this._sortingFn);
                for (var j = 0, i = 0; i < elements.length; i++) {
                    for (var element = elements[i], inserted = !1; !inserted && j < this._array.length; ) this._sortingFn(element, this._array[j]) < 0 ? (this._array.splice(j, 0, element), 
                    inserted = !0) : j++;
                    inserted || this._array.push(element);
                }
            }
            /**
   * Returns the current length of the list.
   * @returns {number}
   */ , _proto.length = function length() {
                return this._array.length;
            }
            /**
   * Returns the nth element. Throws if the index does not exist.
   *
   * /!\ The returned Element shares the same reference with what is used
   * internally, any mutation on your part can lead to an un-sorted SortedList.
   * You can still re-force the sorting to happen by calling forceSort.
   * @throws Error - Throws if the given index is negative or superior to the
   * array's length.
   * @param {number} index
   * @returns {*}
   */ , _proto.get = function get(index) {
                if (index < 0 || index >= this._array.length) throw new Error("Invalid index.");
                return this._array[index];
            }
            /**
   * Find the first element corresponding to the given predicate.
   *
   * /!\ The returned element shares the same reference with what is used
   * internally, any mutation on your part can lead to an un-sorted SortedList.
   * You can still re-force the sorting to happen by calling forceSort.
   * @param {Function} fn
   * @returns {*}
   */ , _proto.findFirst = function findFirst(fn) {
                return Object(array_find.a)(this._array, fn);
            }
            /**
   * Returns true if the List contains the given element.
   * @param {*} element
   * @returns {Boolean}
   */ , _proto.has = function has(element) {
                return Object(array_includes.a)(this._array, element);
            }
            /**
   * Remove the first occurence of the given element.
   * Returns the index of the removed element. Undefined if not found.
   * @returns {number|undefined}
   */ , _proto.removeElement = function removeElement(element) {
                var indexOf = this._array.indexOf(element);
                if (0 <= indexOf) return this._array.splice(indexOf, 1), indexOf;
            }
            /**
   * Returns the first element.
   *
   * /!\ The returned Element shares the same reference with what is used
   * internally, any mutation on your part can lead to an un-sorted SortedList.
   * You can still re-force the sorting to happen by calling forceSort.
   * @returns {*}
   */ , _proto.head = function head() {
                return this._array[0];
            }
            /**
   * Returns the last element.
   *
   * /!\ The returned Element shares the same reference with what is used
   * internally, any mutation on your part can lead to an un-sorted SortedList.
   * You can still re-force the sorting to happen by calling forceSort.
   * @returns {*}
   */ , _proto.last = function last() {
                return this._array[this._array.length - 1];
            }
            /**
   * Remove the first element.
   * Returns the element removed or undefined if no element were removed.
   * @returns {*}
   */ , _proto.shift = function shift() {
                return this._array.shift();
            }
            /**
   * Remove the last element.
   * Returns the element removed or undefined if no element were removed.
   * @returns {*}
   */ , _proto.pop = function pop() {
                return this._array.pop();
            }, SortedList;
        }(), WeakMapMemory = 
        /* */
        function() {
            /**
   * @param {Function}
   */
            function WeakMapMemory(fn) {
                this._weakMap = new WeakMap(), this._fn = fn;
            }
            /**
   * @param {Object} obj
   * @returns {*}
   */            var _proto = WeakMapMemory.prototype;
            return _proto.get = function get(obj) {
                var fromMemory = this._weakMap.get(obj);
                if (void 0 !== fromMemory) return fromMemory;
                var newElement = this._fn(obj);
                return this._weakMap.set(obj, newElement), newElement;
            }
            /**
   * @param {Object} obj
   */ , _proto.destroy = function destroy(obj) {
                this._weakMap.delete(obj);
            }, WeakMapMemory;
        }(), concatAll = __webpack_require__(134);
        // CONCATENATED MODULE: ./src/core/source_buffers/garbage_collector.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Perform cleaning of the buffer according to the values set by the user
 * at each clock tick and each times the maxBufferBehind/maxBufferAhead values
 * change.
 *
 * @param {Object} opt
 * @returns {Observable}
 */
        function BufferGarbageCollector(_ref) {
            var queuedSourceBuffer = _ref.queuedSourceBuffer, clock$ = _ref.clock$, maxBufferBehind$ = _ref.maxBufferBehind$, maxBufferAhead$ = _ref.maxBufferAhead$;
            return Object(combineLatest.a)(clock$, maxBufferBehind$, maxBufferAhead$).pipe(Object(mergeMap.a)(function(_ref2) {
                var currentTime = _ref2[0], maxBufferBehind = _ref2[1], maxBufferAhead = _ref2[2];
                return clearBuffer(queuedSourceBuffer, currentTime, maxBufferBehind, maxBufferAhead);
            }));
        }
        /**
 * Remove buffer from the browser's memory based on the user's
 * maxBufferAhead / maxBufferBehind settings.
 *
 * Normally, the browser garbage-collect automatically old-added chunks of
 * buffer date when memory is scarce. However, you might want to control
 * the size of memory allocated. This function takes the current position
 * and a "depth" behind and ahead wanted for the buffer, in seconds.
 *
 * Anything older than the depth will be removed from the buffer.
 * @param {QueuedSourceBuffer} qSourceBuffer
 * @param {Number} position - The current position
 * @param {Number} maxBufferBehind
 * @param {Number} maxBufferAhead
 * @returns {Observable}
 */        function clearBuffer(qSourceBuffer, position, maxBufferBehind, maxBufferAhead) {
            if (!isFinite(maxBufferBehind) && !isFinite(maxBufferAhead)) return empty.a;
            var cleanedupRanges = [], _getInnerAndOuterTime = Object(utils_ranges.b)(qSourceBuffer.getBuffered(), position), innerRange = _getInnerAndOuterTime.innerRange, outerRanges = _getInnerAndOuterTime.outerRanges;
            return function collectBufferBehind() {
                if (isFinite(maxBufferBehind)) {
                    // begin from the oldest
                    for (var i = 0; i < outerRanges.length; i++) {
                        var outerRange = outerRanges[i];
                        position - maxBufferBehind >= outerRange.end ? cleanedupRanges.push(outerRange) : position >= outerRange.end && position - maxBufferBehind > outerRange.start && position - maxBufferBehind < outerRange.end && cleanedupRanges.push({
                            start: outerRange.start,
                            end: position - maxBufferBehind
                        });
                    }
                    innerRange && position - maxBufferBehind > innerRange.start && cleanedupRanges.push({
                        start: innerRange.start,
                        end: position - maxBufferBehind
                    });
                }
            }(), function collectBufferAhead() {
                if (isFinite(maxBufferAhead)) {
                    // begin from the oldest
                    for (var i = 0; i < outerRanges.length; i++) {
                        var outerRange = outerRanges[i];
                        position + maxBufferAhead <= outerRange.start ? cleanedupRanges.push(outerRange) : position <= outerRange.start && position + maxBufferAhead < outerRange.end && position + maxBufferAhead > outerRange.start && cleanedupRanges.push({
                            start: position + maxBufferAhead,
                            end: outerRange.end
                        });
                    }
                    innerRange && position + maxBufferAhead < innerRange.end && cleanedupRanges.push({
                        start: position + maxBufferAhead,
                        end: innerRange.end
                    });
                }
            }(), Object(from.a)(cleanedupRanges.map(function(range) {
                return log.a.debug("GC: cleaning range from SourceBuffer", range), qSourceBuffer.removeBuffer(range.start, range.end);
            })).pipe(Object(concatAll.a)(), Object(ignoreElements.a)());
        }
        // EXTERNAL MODULE: ./src/compat/change_source_buffer_type.ts
                var SourceBufferAction, change_source_buffer_type = __webpack_require__(133);
        // CONCATENATED MODULE: ./src/core/source_buffers/queued_source_buffer.ts
                function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        function _createClass(Constructor, protoProps, staticProps) {
            return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), 
            Constructor;
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        !function(SourceBufferAction) {
            SourceBufferAction[SourceBufferAction.Append = 0] = "Append", SourceBufferAction[SourceBufferAction.Remove = 1] = "Remove";
        }(SourceBufferAction || (SourceBufferAction = {}));
        /**
 * Wrap a SourceBuffer and append/remove segments in it in a queue.
 *
 * Wait for the previous buffer action to be finished (updateend event) to
 * perform the next in the queue.
 *
 * To work correctly, only a single QueuedSourceBuffer per SourceBuffer should
 * be created.
 *
 * @class QueuedSourceBuffer
 */
        var queued_source_buffer_QueuedSourceBuffer = 
        /* */
        function() {
            /**
   * @constructor
   * @param {SourceBuffer} sourceBuffer
   */
            function QueuedSourceBuffer(bufferType, codec, sourceBuffer) {
                this.bufferType = bufferType, this._sourceBuffer = sourceBuffer, this._queue = [], 
                this._currentOrder = null, this._lastInitSegment = null, this._currentCodec = codec, 
                this.__onErrorEvent = this._onErrorEvent.bind(this), this.__onUpdateEnd = this._onUpdateEnd.bind(this), 
                this._sourceBuffer.addEventListener("error", this.__onErrorEvent), this._sourceBuffer.addEventListener("updateend", this.__onUpdateEnd);
            }
            /**
   * Public access to the SourceBuffer's current codec.
   * @returns {string}
   */            var _proto = QueuedSourceBuffer.prototype;
            /**
   * Append media segment to the attached SourceBuffer, in a FIFO queue.
   *
   * Depending on the type of data appended, this might need an associated
   * initialization segment.
   *
   * Such initialization segment will be pushed in the SourceBuffer if the
   * last segment pushed was associated to another initialization segment.
   * This detection is entirely reference-based so make sure that the same
   * initSegment argument given share the same reference.
   *
   * You can deactivate the usage of initialization segment by setting the
   * infos.initSegment argument to null.
   *
   * You can also only push an initialization segment by setting the
   * infos.segment argument to null.
   *
   * @param {string} codec
   * @param {Object} infos
   * @returns {Observable}
   */            return _proto.appendBuffer = function appendBuffer(infos) {
                return this._addToQueue({
                    type: SourceBufferAction.Append,
                    value: infos
                });
            }
            /**
   * Remove data from the attached SourceBuffer, in a FIFO queue.
   * @param {number} start - start position, in seconds
   * @param {number} end - end position, in seconds
   * @returns {Observable}
   */ , _proto.removeBuffer = function removeBuffer(start, end) {
                return this._addToQueue({
                    type: SourceBufferAction.Remove,
                    value: {
                        start: start,
                        end: end
                    }
                });
            }
            /**
   * Returns the currently buffered data, in a TimeRanges object.
   * @returns {TimeRanges}
   */ , _proto.getBuffered = function getBuffered() {
                return this._sourceBuffer.buffered;
            }
            /**
   * Dispose of the resources used by this QueuedSourceBuffer.
   *
   * /!\ You won't be able to use the QueuedSourceBuffer after calling this
   * function.
   * @private
   */ , _proto.dispose = function dispose() {
                for (this._sourceBuffer.removeEventListener("error", this.__onErrorEvent), this._sourceBuffer.removeEventListener("updateend", this.__onUpdateEnd), 
                null != this._currentOrder && (this._currentOrder.subject.complete(), this._currentOrder = null); this._queue.length; ) {
                    var nextElement = this._queue.shift();
                    null != nextElement && nextElement.subject.complete();
                }
            }
            /**
   * Abort the linked SourceBuffer.
   *
   * /!\ You won't be able to use the QueuedSourceBuffer after calling this
   * function.
   * @private
   */ , _proto.abort = function abort() {
                this._sourceBuffer.abort();
            }
            /**
   * Callback used for the 'updateend' event, as a segment has been added/removed.
   * @private
   */ , _proto._onUpdateEnd = function _onUpdateEnd() {
                this._flush();
            }
            /**
   * Callback used for the 'error' event from the SourceBuffer.
   * @private
   * @param {Event} error
   */ , _proto._onError = function _onError(error) {
                // initialize init segment as a security
                (this._lastInitSegment = null) != this._currentOrder && this._currentOrder.subject.error(error);
            }
            /**
   * Handle error events from SourceBuffers.
   * @private
   * @param {Error|Event} err
   */ , _proto._onErrorEvent = function _onErrorEvent(err) {
                this._onError(err instanceof Error ? err : // According to w3c, these events are emitted when an error occurred during
                // the append.
                new Error("An unknown error occured when appending buffer"));
            }
            /**
   * When the returned observable is subscribed:
   *   1. Add your order to the queue.
   *   2. Begin the queue if not pending.
   *
   * Cancel queued order on unsubscription.
   * @private
   * @param {Object} order
   * @returns {Observable}
   */ , _proto._addToQueue = function _addToQueue(order) {
                var _this = this;
                return new Observable.a(function(obs) {
                    var queueItem, shouldRestartQueue = 0 === _this._queue.length && null == _this._currentOrder, subject = new Subject.a();
                    if (order.type === SourceBufferAction.Append) {
                        var _order$value = order.value, segment = _order$value.segment, initSegment = _order$value.initSegment, timestampOffset = _order$value.timestampOffset, codec = _order$value.codec;
                        if (null === initSegment && null === segment) return log.a.warn("QSB: no segment to append.", _this.bufferType), 
                        obs.next(null), void obs.complete();
                        queueItem = {
                            type: SourceBufferAction.Append,
                            value: {
                                initSegment: initSegment,
                                segment: segment,
                                timestampOffset: timestampOffset,
                                codec: codec
                            },
                            subject: subject
                        };
                    } else {
                        if (order.type !== SourceBufferAction.Remove) throw new Error("QSB: unrecognized order");
                        queueItem = {
                            type: SourceBufferAction.Remove,
                            value: order.value,
                            subject: subject
                        };
                    }
                    _this._queue.push(queueItem);
                    var subscription = subject.subscribe(obs);
                    return shouldRestartQueue && _this._flush(), function() {
                        subscription.unsubscribe();
                        var index = _this._queue.indexOf(queueItem);
                        0 <= index && _this._queue.splice(index, 1);
                    };
                });
            }
            /**
   * Perform next task if one.
   * @private
   */ , _proto._flush = function _flush() {
                if (!this._sourceBuffer.updating) {
                    if (null == this._currentOrder) {
                        if (0 === this._queue.length) return;
 // TODO TypeScrypt do not get the previous length check? Find solution /
                        // open issue
                                                var newQueueItem = this._queue.shift(), tasks = [];
                        newQueueItem.type === SourceBufferAction.Append ? (null !== newQueueItem.value.initSegment ? tasks.push({
                            type: SourceBufferAction.Append,
                            value: {
                                isInit: !0,
                                segment: newQueueItem.value.initSegment,
                                codec: newQueueItem.value.codec,
                                timestampOffset: newQueueItem.value.timestampOffset
                            }
                        }) : null === newQueueItem.value.segment && (newQueueItem.subject.next(), newQueueItem.subject.complete()), 
                        null !== newQueueItem.value.segment && tasks.push({
                            type: SourceBufferAction.Append,
                            value: {
                                segment: newQueueItem.value.segment,
                                isInit: !1,
                                codec: newQueueItem.value.codec,
                                timestampOffset: newQueueItem.value.timestampOffset
                            }
                        })) : tasks.push({
                            type: SourceBufferAction.Remove,
                            value: newQueueItem.value
                        }), this._currentOrder = {
                            tasks: tasks,
                            subject: newQueueItem.subject
                        };
                    }
                    var task = this._currentOrder.tasks.shift();
                    if (null == task) {
                        var subject = this._currentOrder.subject;
                        return this._currentOrder = null, subject.next(), subject.complete(), void (0 < this._queue.length && this._flush());
                    }
                    try {
                        switch (task.type) {
                          case SourceBufferAction.Append:
                            var _task$value = task.value, segment = _task$value.segment, isInit = _task$value.isInit, _task$value$timestamp = _task$value.timestampOffset, timestampOffset = void 0 === _task$value$timestamp ? 0 : _task$value$timestamp, codec = _task$value.codec;
                            if (isInit && this._lastInitSegment === segment) // nothing to do
                            return void this._flush();
                            if (this._currentCodec !== codec) log.a.debug("QSB: updating codec"), Object(change_source_buffer_type.a)(this._sourceBuffer, codec) ? this._currentCodec = codec : log.a.warn("QSB: could not update codec", codec, this._currentCodec);
                            if (this._sourceBuffer.timestampOffset !== timestampOffset) {
                                var newTimestampOffset = timestampOffset || 0;
                                log.a.debug("QSB: updating timestampOffset", this.bufferType, this._sourceBuffer.timestampOffset, newTimestampOffset), 
                                this._sourceBuffer.timestampOffset = newTimestampOffset;
                            }
                            log.a.debug("QSB: pushing new data to SourceBuffer", this.bufferType), isInit && (this._lastInitSegment = segment), 
                            this._sourceBuffer.appendBuffer(segment);
                            break;

                          case SourceBufferAction.Remove:
                            var _task$value2 = task.value, start = _task$value2.start, end = _task$value2.end;
                            log.a.debug("QSB: removing data from SourceBuffer", this.bufferType, start, end), 
                            this._sourceBuffer.remove(start, end);
                        }
                    } catch (e) {
                        this._onError(e);
                    }
                }
            }, _createClass(QueuedSourceBuffer, [ {
                key: "codec",
                get: function get() {
                    return this._currentCodec;
                }
            } ]), QueuedSourceBuffer;
        }(), POSSIBLE_BUFFER_TYPES = [ "audio", "video", "text", "image" ];
        // CONCATENATED MODULE: ./src/core/source_buffers/source_buffers_manager.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        
        /**
 * Get all currently available buffer types.
 * /!\ This list can evolve at runtime depending on feature switching.
 * @returns {Array.<string>}
 */
        function getBufferTypes() {
            var bufferTypes = [ "audio", "video" ];
            return null == features.a.nativeTextTracksBuffer && null == features.a.htmlTextTracksBuffer || bufferTypes.push("text"), 
            null != features.a.imageBuffer && bufferTypes.push("image"), bufferTypes;
        }
        /**
 * Allows to easily create and dispose SourceBuffers.
 *
 * Only one SourceBuffer per type is allowed at the same time:
 *
 *   - source buffers for native types (which depends on the native
 *     SourceBuffer implementation), are reused if one is re-created.
 *
 *   - source buffers for custom types are aborted each time a new one of the
 *     same type is created.
 *
 * The returned SourceBuffer is actually a QueuedSourceBuffer instance which
 * wrap a SourceBuffer implementation to queue all its actions.
 *
 * @class SourceBuffersManager
 */        var source_buffers_manager_SourceBuffersManager = 
        /* */
        function() {
            function SourceBuffersManager(mediaElement, mediaSource) {
                this._mediaElement = mediaElement, this._mediaSource = mediaSource, this._initializedSourceBuffers = {};
            }
            /**
   * Returns the created QueuedSourceBuffer for the given type.
   * Returns null if no QueuedSourceBuffer were created for the given type.
   *
   * @param {string} bufferType
   * @returns {QueuedSourceBuffer|null}
   */            
            /**
   * Returns true if the SourceBuffer is "native" (has to be attached to the
   * mediaSource before playback).
   * @static
   * @param {string} bufferType
   * @returns {Boolean}
   */
            SourceBuffersManager.isNative = function isNative(bufferType) {
                return shouldHaveNativeSourceBuffer(bufferType);
            }
            /**
   * @param {HTMLMediaElement} mediaElement
   * @param {MediaSource} mediaSource
   * @constructor
   */;
            var _proto = SourceBuffersManager.prototype;
            return _proto.get = function get(bufferType) {
                return this._initializedSourceBuffers[bufferType] || null;
            }
            /**
   * Creates a new QueuedSourceBuffer for the SourceBuffer type.
   * Reuse an already created one if a QueuedSourceBuffer for the given type
   * already exists.
   * @param {string} bufferType
   * @param {string} codec
   * @param {Object|undefined} options
   * @returns {QueuedSourceBuffer}
   */ , _proto.createSourceBuffer = function createSourceBuffer(bufferType, codec, options) {
                void 0 === options && (options = {});
                var memorizedSourceBuffer = this._initializedSourceBuffers[bufferType];
                if (shouldHaveNativeSourceBuffer(bufferType)) {
                    if (memorizedSourceBuffer) return memorizedSourceBuffer.codec !== codec ? log.a.warn("SB: Reusing native SourceBuffer with codec", memorizedSourceBuffer.codec, "for codec", codec) : log.a.info("SB: Reusing native SourceBuffer with codec", codec), 
                    memorizedSourceBuffer;
                    log.a.info("SB: Adding native SourceBuffer with codec", codec);
                    var nativeSourceBuffer = createNativeQueuedSourceBuffer(bufferType, this._mediaSource, codec);
                    return this._initializedSourceBuffers[bufferType] = nativeSourceBuffer;
                }
                if (memorizedSourceBuffer) return log.a.info("SB: Reusing a previous custom SourceBuffer for the type", bufferType), 
                memorizedSourceBuffer;
                if ("text" === bufferType) {
                    var sourceBuffer;
                    if (log.a.info("SB: Creating a new text SourceBuffer with codec", codec), "html" === options.textTrackMode) {
                        if (null == features.a.htmlTextTracksBuffer) throw new Error("HTML Text track feature not activated");
                        sourceBuffer = new features.a.htmlTextTracksBuffer(this._mediaElement, options.textTrackElement);
                    } else {
                        if (null == features.a.nativeTextTracksBuffer) throw new Error("Native Text track feature not activated");
                        sourceBuffer = new features.a.nativeTextTracksBuffer(this._mediaElement, !!options.hideNativeSubtitle);
                    }
                    var queuedSourceBuffer = new queued_source_buffer_QueuedSourceBuffer("text", codec, sourceBuffer);
                    return this._initializedSourceBuffers.text = queuedSourceBuffer;
                }
                if ("image" !== bufferType) throw log.a.error("SB: Unknown buffer type:", bufferType), 
                new media_error.a("BUFFER_TYPE_UNKNOWN", "The player wants to create a SourceBuffer of an unknown type.", !0);
                if (null == features.a.imageBuffer) throw new Error("Image buffer feature not activated");
                log.a.info("SB: Creating a new image SourceBuffer with codec", codec);
                var _sourceBuffer = new features.a.imageBuffer(), _queuedSourceBuffer = new queued_source_buffer_QueuedSourceBuffer("image", codec, _sourceBuffer);
                return this._initializedSourceBuffers.image = _queuedSourceBuffer;
            }
            /**
   * Dispose of the active SourceBuffer for the given type.
   * @param {string} bufferType
   */ , _proto.disposeSourceBuffer = function disposeSourceBuffer(bufferType) {
                var memorizedSourceBuffer = this._initializedSourceBuffers[bufferType];
                if (null != memorizedSourceBuffer) {
                    if (log.a.info("SB: Aborting SourceBuffer", bufferType), memorizedSourceBuffer.dispose(), 
                    !shouldHaveNativeSourceBuffer(bufferType) || "open" === this._mediaSource.readyState) try {
                        memorizedSourceBuffer.abort();
                    } catch (e) {
                        log.a.warn("SB: Failed to abort a " + bufferType + " SourceBuffer:", e);
                    }
                    delete this._initializedSourceBuffers[bufferType];
                } else log.a.warn("SB: Trying to dispose a SourceBuffer that does not exist");
            }
            /**
   * Dispose of all QueuedSourceBuffer created on this SourceBuffersManager.
   */ , _proto.disposeAll = function disposeAll() {
                var _this = this;
                POSSIBLE_BUFFER_TYPES.forEach(function(bufferType) {
                    null != _this.get(bufferType) && _this.disposeSourceBuffer(bufferType);
                });
            }, SourceBuffersManager;
        }();
        /**
 * Adds a SourceBuffer to the MediaSource.
 * @param {MediaSource} mediaSource
 * @param {string} codec
 * @returns {SourceBuffer}
 */        function createNativeQueuedSourceBuffer(bufferType, mediaSource, codec) {
            var sourceBuffer = mediaSource.addSourceBuffer(codec);
            return new queued_source_buffer_QueuedSourceBuffer(bufferType, codec, sourceBuffer);
        }
        /**
 * Returns true if the given buffeType is a native buffer, false otherwise.
 * "Native" SourceBuffers are directly added to the MediaSource.
 * @param {string} bufferType
 * @returns {Boolean}
 */        function shouldHaveNativeSourceBuffer(bufferType) {
            return "audio" === bufferType || "video" === bufferType;
        }
        // CONCATENATED MODULE: ./src/core/buffers/active_period_emitter.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * This file helps to keep track of the currently active Periods.
 * That is, Periods for which at least a single Buffer is currently active.
 *
 * It also keep track of the currently active period:
 * The first chronological period for which all types of buffers are active.
 */
        /**
 * Emit the active Period each times it changes.
 *
 * The active Period is the first Period (in chronological order) which has
 * a PeriodBuffer for every defined BUFFER_TYPES.
 *
 * Emit null if no Period has PeriodBuffers for all types.
 *
 * @example
 * For 4 BUFFER_TYPES: "AUDIO", "VIDEO", "TEXT" and "IMAGE":
 * ```
 *                     +-------------+
 *         Period 1    | Period 2    | Period 3
 * AUDIO   |=========| | |===      | |
 * VIDEO               | |=====    | |
 * TEXT    |(NO TEXT)| | |(NO TEXT)| | |====    |
 * IMAGE   |=========| | |=        | |
 *                     +-------------+
 *
 * The active Period here is Period 2 as Period 1 has no video PeriodBuffer.
 *
 * If we are missing a or multiple PeriodBuffers in the first chronological
 * Period, like that is the case here, it generally means that we are
 * currently switching between Periods.
 *
 * For here we are surely switching from Period 1 to Period 2 beginning by the
 * video PeriodBuffer. As every PeriodBuffer is ready for Period 2, we can
 * already inform that it is the current Period.
 * ```
 *
 * @param {Array.<string>} bufferTypes - Every buffer types in the content.
 * @param {Observable} addPeriodBuffer$ - Emit PeriodBuffer informations when
 * one is added.
 * @param {Observable} removePeriodBuffer$ - Emit PeriodBuffer informations when
 * one is removed.
 * @returns {Observable}
 */        function ActivePeriodEmitter(bufferTypes, addPeriodBuffer$, removePeriodBuffer$) {
            var periodsList = new sorted_list_SortedList(function(a, b) {
                return a.period.start - b.period.start;
            }), onItemAdd$ = addPeriodBuffer$.pipe(Object(tap.a)(function(_ref) {
                var period = _ref.period, type = _ref.type, periodItem = periodsList.findFirst(function(p) {
                    return p.period === period;
                });
                // add or update the periodItem
                                periodItem || (periodItem = {
                    period: period,
                    buffers: new Set()
                }, periodsList.add(periodItem)), periodItem.buffers.has(type) && log.a.warn("ActivePeriodEmitter: Buffer type " + type + " already added to the period"), 
                periodItem.buffers.add(type);
            })), onItemRemove$ = removePeriodBuffer$.pipe(Object(tap.a)(function(_ref2) {
                var period = _ref2.period, type = _ref2.type;
                if (periodsList && 0 !== periodsList.length()) {
                    var periodItem = periodsList.findFirst(function(p) {
                        return p.period === period;
                    });
                    periodItem ? (periodItem.buffers.delete(type), periodItem.buffers.size || periodsList.removeElement(periodItem)) : log.a.error("ActivePeriodEmitter: cannot remove, unknown period.");
                } else log.a.error("ActivePeriodEmitter: cannot remove, no period is active.");
            }));
            return Object(merge.a)(onItemAdd$, onItemRemove$).pipe(Object(map.a)(function() {
                if (!periodsList.head()) return null;
                var periodItem = periodsList.findFirst(function(p) {
                    return isBufferListFull(bufferTypes, p.buffers);
                });
                return null != periodItem ? periodItem.period : null;
            }), Object(distinctUntilChanged.a)());
        }
        /**
 * Returns true if the set of given buffer types is complete (has all possible
 * types).
 * @param {Array.<string>} bufferTypes - Every buffer types in the content.
 * @param {Set.<string>} bufferList
 * @returns {Boolean}
 */        function isBufferListFull(bufferTypes, bufferList) {
            return bufferList.size >= bufferTypes.length;
        }
        // CONCATENATED MODULE: ./src/core/buffers/are_buffers_complete.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Returns an Observable which emits ``true`` when all PeriodBuffers given are
 * _complete_.
 * Returns false otherwise.
 *
 * A PeriodBuffer for a given type is considered _complete_ when both of these
 * conditions are true:
 *   - it is the last PeriodBuffer in the content for the given type
 *   - it has finished downloading segments (it is _full_)
 *
 * Simply put a _complete_ PeriodBuffer for a given type means that every
 * segments needed for this Buffer have been downloaded.
 *
 * When the Observable returned here emits, every Buffer are finished.
 * @param {...Observable} buffers
 * @returns {Observable}
 */        function areBuffersComplete() {
            for (var _len = arguments.length, buffers = new Array(_len), _key = 0; _key < _len; _key++) buffers[_key] = arguments[_key];
            /**
   * Array of Observables linked to the Array of Buffers which emit:
   *   - true when the corresponding buffer is considered _complete_.
   *   - false when the corresponding buffer is considered _active_.
   * @type {Array.<Observable>}
   */            var isCompleteArray = buffers.map(function(buffer) {
                return buffer.pipe(Object(filter.a)(function(evt) {
                    return "complete-buffer" === evt.type || "active-buffer" === evt.type;
                }), Object(map.a)(function(evt) {
                    return "complete-buffer" === evt.type;
                }), Object(startWith.a)(!1), Object(distinctUntilChanged.a)());
            });
            return combineLatest.a.apply(void 0, isCompleteArray).pipe(Object(map.a)(function(areComplete) {
                return areComplete.every(function(isComplete) {
                    return isComplete;
                });
            }), Object(distinctUntilChanged.a)());
        }
        // CONCATENATED MODULE: ./src/core/buffers/events_generators.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        var buffers_events_generators = {
            activeBuffer: function activeBuffer(bufferType) {
                return {
                    type: "active-buffer",
                    value: {
                        bufferType: bufferType
                    }
                };
            },
            activePeriodChanged: function activePeriodChanged(period) {
                return {
                    type: "activePeriodChanged",
                    value: {
                        period: period
                    }
                };
            },
            adaptationChange: function adaptationChange(bufferType, adaptation, period) {
                return {
                    type: "adaptationChange",
                    value: {
                        type: bufferType,
                        adaptation: adaptation,
                        period: period
                    }
                };
            },
            addedSegment: function addedSegment(bufferType, segment, segmentData) {
                return {
                    type: "added-segment",
                    value: {
                        bufferType: bufferType,
                        segment: segment,
                        segmentData: segmentData
                    }
                };
            },
            bitrateEstimationChange: function bitrateEstimationChange(type, bitrate) {
                return {
                    type: "bitrateEstimationChange",
                    value: {
                        type: type,
                        bitrate: bitrate
                    }
                };
            },
            bufferComplete: function bufferComplete(bufferType) {
                return {
                    type: "complete-buffer",
                    value: {
                        type: bufferType
                    }
                };
            },
            discontinuityEncountered: function discontinuityEncountered(bufferType, nextTime) {
                return {
                    type: "discontinuity-encountered",
                    value: {
                        bufferType: bufferType,
                        nextTime: nextTime
                    }
                };
            },
            endOfStream: function endOfStream() {
                return {
                    type: "end-of-stream",
                    value: void 0
                };
            },
            fullBuffer: function fullBuffer(bufferType) {
                return {
                    type: "full-buffer",
                    value: {
                        bufferType: bufferType
                    }
                };
            },
            needsManifestRefresh: function needsManifestRefresh(bufferType) {
                return {
                    type: "needs-manifest-refresh",
                    value: {
                        bufferType: bufferType
                    }
                };
            },
            needsMediaSourceReload: function needsMediaSourceReload() {
                return {
                    type: "needs-media-source-reload",
                    value: void 0
                };
            },
            periodBufferReady: function periodBufferReady(type, period, adaptation$) {
                return {
                    type: "periodBufferReady",
                    value: {
                        type: type,
                        period: period,
                        adaptation$: adaptation$
                    }
                };
            },
            periodBufferCleared: function periodBufferCleared(type, period) {
                return {
                    type: "periodBufferCleared",
                    value: {
                        type: type,
                        period: period
                    }
                };
            },
            representationChange: function representationChange(type, period, representation) {
                return {
                    type: "representationChange",
                    value: {
                        type: type,
                        period: period,
                        representation: representation
                    }
                };
            },
            resumeStream: function resumeStream() {
                return {
                    type: "resume-stream",
                    value: void 0
                };
            },
            warning: function warning(value) {
                return {
                    type: "warning",
                    value: value
                };
            }
        }, initialization_segment_cache = 
        /* */
        function() {
            function InitializationSegmentCache() {
                this._cache = new WeakMap();
            }
            /**
   * @param {Object} obj
   * @param {*} response
   */            var _proto = InitializationSegmentCache.prototype;
            return _proto.add = function add(_ref, response) {
                var representation = _ref.representation;
                _ref.segment.isInit && this._cache.set(representation, response);
            }
            /**
   * @param {Object} obj
   * @returns {*} response
   */ , _proto.get = function get(_ref2) {
                var representation = _ref2.representation;
                if (_ref2.segment.isInit) {
                    var value = this._cache.get(representation);
                    if (null != value) return value;
                }
                return null;
            }, InitializationSegmentCache;
        }(), source_buffers = source_buffers_manager_SourceBuffersManager;
        /* harmony default export */        
        // CONCATENATED MODULE: ./src/utils/concat_map_latest.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Same as concatMap, but get last emitted value from source instead of unstack
 * inner values.
 * @param {function} callback
 * @returns {function}
 */
        function concatMapLatest(callback) {
            return function(source) {
                return Object(defer.a)(function() {
                    var valuePending, counter = 0, hasValuePending = !1, isExhausting = !1;
                    return source.pipe(Object(mergeMap.a)(function next(value) {
                        return Object(defer.a)(function() {
                            return isExhausting ? (valuePending = value, hasValuePending = !0, empty.a) : (isExhausting = !(hasValuePending = !1), 
                            callback(value, counter++).pipe(Object(tap.a)({
                                complete: function complete() {
                                    return isExhausting = !1;
                                }
                            }), function(s) {
                                return Object(concat.a)(s, Object(defer.a)(function() {
                                    return hasValuePending ? next(valuePending) : empty.a;
                                }));
                            }));
                        });
                    }));
                });
            };
        }
        // EXTERNAL MODULE: ./node_modules/next-tick/index.js
                var next_tick = __webpack_require__(60), next_tick_default = /* */ __webpack_require__.n(next_tick);
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/takeWhile.js
        /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
        function takeWhile(predicate, inclusive) {
            return void 0 === inclusive && (inclusive = !1), function(source) {
                return source.lift(new TakeWhileOperator(predicate, inclusive));
            };
        }
        var TakeWhileOperator = /* */ function() {
            function TakeWhileOperator(predicate, inclusive) {
                this.predicate = predicate, this.inclusive = inclusive;
            }
            return TakeWhileOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new takeWhile_TakeWhileSubscriber(subscriber, this.predicate, this.inclusive));
            }, TakeWhileOperator;
        }(), takeWhile_TakeWhileSubscriber = /* */ function(_super) {
            function TakeWhileSubscriber(destination, predicate, inclusive) {
                var _this = _super.call(this, destination) || this;
                return _this.predicate = predicate, _this.inclusive = inclusive, _this.index = 0, 
                _this;
            }
            return tslib_es6.a(TakeWhileSubscriber, _super), TakeWhileSubscriber.prototype._next = function(value) {
                var result, destination = this.destination;
                try {
                    result = this.predicate(value, this.index++);
                } catch (err) {
                    return void destination.error(err);
                }
                this.nextOrComplete(value, result);
            }, TakeWhileSubscriber.prototype.nextOrComplete = function(value, predicateResult) {
                var destination = this.destination;
                Boolean(predicateResult) ? destination.next(value) : (this.inclusive && destination.next(value), 
                destination.complete());
            }, TakeWhileSubscriber;
        }(Subscriber.a), simple_set = __webpack_require__(62), GC_GAP_CALM = config.a.BUFFER_GC_GAPS.CALM, GC_GAP_BEEFY = config.a.BUFFER_GC_GAPS.BEEFY;
        /**
 * Run the garbage collector.
 *
 * Try to clean up buffered ranges from a low gcGap at first.
 * If it does not succeed to clean up space, use a higher gcCap.
 *
 * @param {Observable} timings$
 * @param {Object} bufferingQueue
 * @returns {Observable}
 */
        function forceGarbageCollection(timings$, bufferingQueue) {
            // wait for next timing event
            return timings$.pipe(Object(take.a)(1), Object(mergeMap.a)(function(timing) {
                log.a.warn("Buffer: Running garbage collector");
                var buffered = bufferingQueue.getBuffered(), cleanedupRanges = selectGCedRanges(timing.currentTime, buffered, GC_GAP_CALM);
                // more aggressive GC if we could not find any range to clean
                return 0 === cleanedupRanges.length && (cleanedupRanges = selectGCedRanges(timing.currentTime, buffered, GC_GAP_BEEFY)), 
                log.a.debug("Buffer: GC cleaning", cleanedupRanges), Object(from.a)(cleanedupRanges.map(function(_ref) {
                    var start = _ref.start, end = _ref.end;
                    return bufferingQueue.removeBuffer(start, end);
                })).pipe(Object(concatAll.a)());
            }));
        }
        /**
 * Buffer garbage collector algorithm.
 *
 * Tries to free up some part of the ranges that are distant from the current
 * playing time.
 * See: https://w3c.github.io/media-source/#sourcebuffer-prepare-append
 *
 * @param {Number} currentTime
 * @param {TimeRanges} buffered - current buffered ranges
 * @param {Number} gcGap - delta gap from current timestamp from which we
 * should consider cleaning up.
 * @returns {Array.<Object>} - Ranges selected for clean up
 */        function selectGCedRanges(currentTime, buffered, gcGap) {
            // start by trying to remove all ranges that do not contain the
            // current time and respect the gcGap
            // respect the gcGap? FIXME?
            for (var _getInnerAndOuterTime = Object(utils_ranges.b)(buffered, currentTime), innerRange = _getInnerAndOuterTime.innerRange, outerRanges = _getInnerAndOuterTime.outerRanges, cleanedupRanges = [], i = 0; i < outerRanges.length; i++) {
                var outerRange = outerRanges[i];
                currentTime - gcGap < outerRange.end ? cleanedupRanges.push(outerRange) : currentTime + gcGap > outerRange.start && cleanedupRanges.push(outerRange);
            }
 // try to clean up some space in the current range
                        return innerRange && (log.a.debug("Buffer: GC removing part of inner range", cleanedupRanges), 
            currentTime - gcGap > innerRange.start && cleanedupRanges.push({
                start: innerRange.start,
                end: currentTime - gcGap
            }), currentTime + gcGap < innerRange.end && cleanedupRanges.push({
                start: currentTime + gcGap,
                end: innerRange.end
            })), cleanedupRanges;
        }
        // CONCATENATED MODULE: ./src/core/buffers/representation/append_data.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Append buffer to the queuedSourceBuffer.
 * If it leads to a QuotaExceededError, try to run our custom range
 * _garbage collector_.
 *
 * @param {Observable} clock$
 * @param {Object} queuedSourceBuffer
 * @param {Object} dataInfos
 * @returns {Observable}
 */        function appendDataToSourceBufferWithRetries(clock$, queuedSourceBuffer, dataInfos) {
            var append$ = queuedSourceBuffer.appendBuffer(dataInfos);
            return append$.pipe(Object(catchError.a)(function(appendError) {
                if ("QuotaExceededError" !== appendError.name) throw new media_error.a("BUFFER_APPEND_ERROR", appendError.toString(), !0);
                return forceGarbageCollection(clock$, queuedSourceBuffer).pipe(Object(mergeMapTo.a)(append$), Object(catchError.a)(function(forcedGCError) {
                    // (weird Typing either due to TypeScript or RxJS bug)
                    throw new media_error.a("BUFFER_FULL_ERROR", forcedGCError.toString(), !0);
                }));
            }));
        }
        // CONCATENATED MODULE: ./src/core/buffers/representation/get_buffer_paddings.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        var BUFFER_PADDING = config.a.BUFFER_PADDING;
        /**
 * Get safety paddings (low and high) for the size of buffer that won't
 * be flushed when switching representation for smooth transitions
 * and avoiding buffer underflows.
 *
 * @param {Object} adaptation
 * @returns {Object}
 */        function getBufferPaddings(adaptation) {
            switch (adaptation.type) {
              case "audio":
              case "video":
                return BUFFER_PADDING[adaptation.type];

              default:
                return BUFFER_PADDING.other;
            }
        }
        // CONCATENATED MODULE: ./src/core/buffers/representation/get_segment_priority.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        var SEGMENT_PRIORITIES_STEPS = config.a.SEGMENT_PRIORITIES_STEPS;
        /**
 * Calculate the priority number of the Segment, in function of the distance
 * with the current time.
 *
 * The lower is this number, the higher should be the priority of the request.
 *
 * @param {Object} segment
 * @param {Object} clockTick
 * @returns {number}
 */        function getSegmentPriority(segment, clockTick) {
            for (var currentTime = clockTick.currentTime + clockTick.wantedTimeOffset, distance = segment.time / segment.timescale - currentTime, priority = 0; priority < SEGMENT_PRIORITIES_STEPS.length; priority++) if (distance < SEGMENT_PRIORITIES_STEPS[priority]) return priority;
            return SEGMENT_PRIORITIES_STEPS.length;
        }
        // CONCATENATED MODULE: ./src/core/buffers/representation/get_segments_needed.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Returns every segments currently wanted.
 * @param {Object} representation - The representation of the chosen
 * adaptation
 * @param {Object} range
 * @returns {Array.<Object>}
 */        function getSegmentsNeeded(representation, range) {
            var start = range.start, duration = range.end - start;
            // given the current timestamp and the previously calculated time gap and
            // wanted buffer size, we can retrieve the list of segments to inject in
            // our pipelines.
            return representation.index.getSegments(start, duration);
        }
        // CONCATENATED MODULE: ./src/core/buffers/representation/get_wanted_range.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Returns the range of segments needed for a particular point in time.
 *
 * @param {Object} hardLimits
 * @param {TimeRanges} buffered
 * @param {Object} timing
 * @param {number} bufferGoal
 * @param {Object} paddings
 * @returns {Object}
 */        function getWantedRange(hardLimits, buffered, timing, bufferGoal, paddings) {
            var currentTime = timing.currentTime + timing.wantedTimeOffset, limitEnd = null == timing.liveGap ? hardLimits.end : Math.min(hardLimits.end || Infinity, timing.currentTime + timing.liveGap), boundedLimits = {
                start: Math.max(hardLimits.start || 0, currentTime),
                end: limitEnd
            }, lowPadding = paddings.low, highPadding = paddings.high, bufferGap = Object(utils_ranges.c)(buffered, currentTime), timestampPadding = lowPadding < bufferGap && bufferGap < Infinity ? Math.min(bufferGap, highPadding) : 0;
            return {
                start: Math.min(Math.max(currentTime + timestampPadding, boundedLimits.start), boundedLimits.end || Infinity),
                end: Math.min(Math.max(currentTime + bufferGoal, boundedLimits.start), boundedLimits.end || Infinity)
            };
        }
        // CONCATENATED MODULE: ./src/core/buffers/representation/segment_filter.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        var BITRATE_REBUFFERING_RATIO = config.a.BITRATE_REBUFFERING_RATIO, MINIMUM_SEGMENT_SIZE = config.a.MINIMUM_SEGMENT_SIZE;
        /**
 * Returns true if the given Segment should be downloaded.
 * false otherwise.
 *
 * @param {Object} segment
 * @param {Object} content - The content the Segment depends on.
 * @param {Object} segmentBookkeeper
 * @param {Object} wantedRange
 * @param {Object} segmentIDsToIgnore
 * @returns {boolean}
 */        function segment_filter_shouldDownloadSegment(segment, content, segmentBookkeeper, wantedRange, segmentIDsToIgnore) {
            var period = content.period, adaptation = content.adaptation, representation = content.representation;
            if (segmentIDsToIgnore.test(segment.id)) return !1;
 // segment without time info are usually init segments or some
            // kind of metadata segment that we never filter out
                        if (segment.isInit || segment.time < 0) return !0;
            var time = segment.time, duration = segment.duration, timescale = segment.timescale;
            if (!duration) return !0;
            if (duration / timescale < MINIMUM_SEGMENT_SIZE) return !1;
            var currentSegment = segmentBookkeeper.hasPlayableSegment(wantedRange, {
                time: time,
                duration: duration,
                timescale: timescale
            });
            if (!currentSegment) return !0;
            if (currentSegment.infos.period.id !== period.id) 
            // segments for later periods have the advantage here
            return period.start >= currentSegment.infos.period.start;
            if (currentSegment.infos.adaptation.id !== adaptation.id) return !0;
 // only re-load comparatively-poor bitrates for the same adaptation.
                        var bitrateCeil = currentSegment.infos.representation.bitrate * BITRATE_REBUFFERING_RATIO;
            return representation.bitrate > bitrateCeil;
        }
        // CONCATENATED MODULE: ./src/core/buffers/representation/representation_buffer.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * This file allows to create RepresentationBuffers.
 *
 * A RepresentationBuffer downloads and push segment for a single
 * Representation (e.g. a single video stream of a given quality).
 * It chooses which segments should be downloaded according to the current
 * position and what is currently buffered.
 */
        /**
 * Build up buffer for a single Representation.
 *
 * Download and push segments linked to the given Representation according
 * to what is already in the SourceBuffer and where the playback currently is.
 *
 * Multiple RepresentationBuffer observables can run on the same SourceBuffer.
 * This allows for example smooth transitions between multiple periods.
 *
 * @param {Object} args
 * @returns {Observable}
 */        
        // CONCATENATED MODULE: ./src/core/buffers/representation/index.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /* harmony default export */ var buffers_representation = function RepresentationBuffer(_ref) {
            var clock$ = _ref.clock$, content = _ref.content, queuedSourceBuffer = _ref.queuedSourceBuffer, segmentBookkeeper = _ref.segmentBookkeeper, segmentFetcher = _ref.segmentFetcher, terminate$ = _ref.terminate$, wantedBufferAhead$ = _ref.wantedBufferAhead$, manifest = content.manifest, period = content.period, adaptation = content.adaptation, representation = content.representation, codec = representation.getMimeTypeString(), bufferType = adaptation.type, initSegment = representation.index.getInitSegment(), paddings = getBufferPaddings(adaptation), initSegmentObject = null == initSegment ? {
                segmentData: null,
                segmentInfos: null,
                segmentOffset: 0
            } : null, startQueue$ = new ReplaySubject.a(1), downloadQueue = [], finishedDownloadQueue$ = new Subject.a(), currentSegmentRequest = null, sourceBufferWaitingQueue = new simple_set.a(), status$ = Object(combineLatest.a)(clock$, wantedBufferAhead$, terminate$.pipe(Object(take.a)(1), Object(mapTo.a)(!0), Object(startWith.a)(!1)), finishedDownloadQueue$.pipe(Object(startWith.a)(void 0))).pipe(Object(map.a)(function getCurrentStatus(_ref2) {
                var timing = _ref2[0], bufferGoal = _ref2[1], terminate = _ref2[2], buffered = queuedSourceBuffer.getBuffered();
                segmentBookkeeper.synchronizeBuffered(buffered);
                var neededRange = getWantedRange(period, buffered, timing, bufferGoal, paddings), discontinuity = timing.stalled && manifest.isLive ? representation.index.checkDiscontinuity(timing.currentTime) : -1, shouldRefreshManifest = representation.index.shouldRefresh(neededRange.start, neededRange.end), neededSegments = getSegmentsNeeded(representation, neededRange).filter(function(segment) {
                    return shouldDownloadSegment(segment, neededRange);
                }).map(function(segment) {
                    return {
                        priority: getSegmentPriority(segment, timing),
                        segment: segment
                    };
                });
                return null != initSegment && null == initSegmentObject && (neededSegments = [ {
                    segment: initSegment,
                    priority: getSegmentPriority(initSegment, timing)
                } ].concat(neededSegments)), {
                    discontinuity: discontinuity,
                    isFull: !neededSegments.length && null != period.end && neededRange.end >= period.end,
                    terminate: terminate,
                    neededSegments: neededSegments,
                    shouldRefreshManifest: shouldRefreshManifest
                };
            }), Object(mergeMap.a)(function handleStatus(status) {
                var neededSegments = status.neededSegments, mostNeededSegment = neededSegments[0];
                if (status.terminate) {
                    if (downloadQueue = [], null == currentSegmentRequest) // complete the downloading queue
                    return log.a.debug("Buffer: no request, terminate.", bufferType), startQueue$.complete(), 
                    Object(of.a)({
                        type: "terminated"
                    });
                    if (null == mostNeededSegment || currentSegmentRequest.segment.id !== mostNeededSegment.segment.id) // complete the downloading queue
                    return log.a.debug("Buffer: cancel request and terminate.", bufferType), startQueue$.next(), 
                    // interrupt the current request
                    startQueue$.complete(), Object(of.a)({
                        type: "terminated"
                    });
                    if (currentSegmentRequest.priority !== mostNeededSegment.priority) {
                        var request$ = currentSegmentRequest.request$;
                        segmentFetcher.updatePriority(request$, mostNeededSegment.priority), currentSegmentRequest.priority = mostNeededSegment.priority;
                    }
                    return log.a.debug("Buffer: terminate after request.", bufferType), empty.a;
                }
                var neededActions = [];
                if (1 < status.discontinuity && neededActions.push(buffers_events_generators.discontinuityEncountered(bufferType, status.discontinuity + 1)), 
                status.shouldRefreshManifest && neededActions.push(buffers_events_generators.needsManifestRefresh(bufferType)), 
                null == mostNeededSegment) // (re-)start with an empty queue
                return currentSegmentRequest && log.a.debug("Buffer: interrupt segment request.", bufferType), 
                downloadQueue = [], startQueue$.next(), Object(concat.a)(of.a.apply(void 0, neededActions), status.isFull ? Object(of.a)(buffers_events_generators.fullBuffer(bufferType)) : empty.a);
                if (currentSegmentRequest) if (currentSegmentRequest.segment.id !== mostNeededSegment.segment.id) log.a.debug("Buffer: restart download queue.", bufferType), 
                downloadQueue = neededSegments, startQueue$.next(); else if (currentSegmentRequest.priority !== mostNeededSegment.priority) {
                    log.a.debug("Buffer: update request priority.", bufferType);
                    var _request$ = currentSegmentRequest.request$;
                    segmentFetcher.updatePriority(_request$, mostNeededSegment.priority), currentSegmentRequest.priority = mostNeededSegment.priority;
                } else log.a.debug("Buffer: update downloading queue", bufferType), // Update the previous queue to be all needed segments but the first one,
                // for which a request is already pending
                downloadQueue = neededSegments.slice().splice(1, neededSegments.length); else log.a.debug("Buffer: start downloading queue.", bufferType), 
                downloadQueue = neededSegments, startQueue$.next();
                return Object(concat.a)(of.a.apply(void 0, neededActions), Object(of.a)(buffers_events_generators.activeBuffer(bufferType)));
            }), takeWhile(function(e) {
                return "terminated" !== e.type;
            })), bufferQueue$ = startQueue$.pipe(Object(switchMap.a)(function() {
                return downloadQueue.length ? loadSegmentsFromQueue() : empty.a;
            }), Object(mergeMap.a)(
            /**
   * Append the given segment to the SourceBuffer.
   * Emit the right event when it succeeds.
   * @param {Object} loadedSegment
   * @returns {Observable}
   */
            function appendSegment(loadedSegment) {
                return Object(defer.a)(function() {
                    var segment = loadedSegment.segment;
                    segment.isInit && (initSegmentObject = loadedSegment.value);
                    var _loadedSegment$value = loadedSegment.value, segmentInfos = _loadedSegment$value.segmentInfos, segmentData = _loadedSegment$value.segmentData, segmentOffset = _loadedSegment$value.segmentOffset;
                    if (null == segmentData) 
                    // no segmentData to add here (for example, a text init segment)
                    // just complete directly without appending anything
                    return empty.a;
                    var append$ = appendDataToSourceBufferWithRetries(clock$, queuedSourceBuffer, {
                        initSegment: initSegmentObject && initSegmentObject.segmentData,
                        segment: segment.isInit ? null : segmentData,
                        timestampOffset: segmentOffset,
                        codec: codec
                    });
                    return sourceBufferWaitingQueue.add(segment.id), append$.pipe(Object(mapTo.a)(buffers_events_generators.addedSegment(bufferType, segment, segmentData)), Object(tap.a)(function() {
                        if (!segment.isInit) {
                            var _ref3 = null != segmentInfos ? segmentInfos : segment, time = _ref3.time, duration = _ref3.duration, timescale = _ref3.timescale, start = time / timescale, end = duration && (time + duration) / timescale;
                            segmentBookkeeper.insert(period, adaptation, representation, segment, start, end);
                        }
                    }), finalize(function() {
                        sourceBufferWaitingQueue.remove(segment.id);
                    }));
                });
            }
            /**
   * Return true if the given segment should be downloaded. false otherwise.
   * @param {Object} segment
   * @param {Array.<Object>} neededRange
   * @returns {Boolean}
   */));
            return Object(merge.a)(status$, bufferQueue$).pipe(Object(share.a)());
            /**
   * Request every Segment in the ``downloadQueue`` on subscription.
   * Emit the data of a segment when a request succeeded.
   *
   * Important side-effects:
   *   - Mutates `currentSegmentRequest` when doing and finishing a request.
   *   - Will emit from finishedDownloadQueue$ Subject after it's done.
   * @returns {Observable}
   */            function loadSegmentsFromQueue() {
                var requestNextSegment$ = Object(defer.a)(function() {
                    var currentNeededSegment = downloadQueue.shift();
                    if (null == currentNeededSegment) return next_tick_default()(function() {
                        finishedDownloadQueue$.next();
                    }), empty.a;
                    var segment = currentNeededSegment.segment, priority = currentNeededSegment.priority, context = {
                        manifest: manifest,
                        period: period,
                        adaptation: adaptation,
                        representation: representation,
                        segment: segment
                    }, request$ = segmentFetcher.createRequest(context, priority);
                    currentSegmentRequest = {
                        segment: segment,
                        priority: priority,
                        request$: request$
                    };
                    var response$ = request$.pipe(Object(mergeMap.a)(function(fetchedSegment) {
                        currentSegmentRequest = null;
                        var initInfos = initSegmentObject && initSegmentObject.segmentInfos || void 0;
                        return fetchedSegment.parse(initInfos);
                    }), Object(map.a)(function(args) {
                        return {
                            segment: segment,
                            value: args
                        };
                    }));
                    return Object(concat.a)(response$, requestNextSegment$);
                });
                return requestNextSegment$.pipe(finalize(function() {
                    currentSegmentRequest = null;
                }));
            }
            function shouldDownloadSegment(segment, neededRange) {
                return segment_filter_shouldDownloadSegment(segment, content, segmentBookkeeper, neededRange, sourceBufferWaitingQueue);
            }
        };
        // CONCATENATED MODULE: ./src/core/buffers/adaptation/adaptation_buffer.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * This file allows to create AdaptationBuffers.
 *
 * An AdaptationBuffer downloads and push segment for a single Adaptation (e.g.
 * a single audio or text track).
 * It chooses which Representation to download mainly thanks to the
 * ABRManager, and orchestrates the various RepresentationBuffer, which will
 * download and push segments for a single Representation.
 */
        /**
 * Create new Buffer Observable linked to the given Adaptation.
 *
 * It will rely on the ABRManager to choose at any time the best Representation
 * for this Adaptation and then run the logic to download and push the
 * corresponding segments in the SourceBuffer.
 *
 * It will emit various events to report its status to the caller.
 *
 * @param {Observable} clock$ - Clock at which the Buffer will check for
 * segments download
 * @param {QueuedSourceBuffer} queuedSourceBuffer - QueuedSourceBuffer used
 * to push segments and know about the current real buffer's health.
 * @param {SegmentBookkeeper} segmentBookkeeper - Used to synchronize and
 * retrieve the Segments currently present in the QueuedSourceBuffer
 * @param {Function} segmentFetcher - Function used to download segments
 * @param {Observable} wantedBufferAhead$ - Emits the buffer goal
 * @param {Object} content - Content to download
 * @param {Object} abrManager
 * @returns {Observable}
 */        
        // CONCATENATED MODULE: ./src/core/buffers/adaptation/index.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /* harmony default export */ var buffers_adaptation = function AdaptationBuffer(clock$, queuedSourceBuffer, segmentBookkeeper, segmentFetcher, wantedBufferAhead$, content, abrManager, options) {
            var directManualBitrateSwitching = "direct" === options.manualBitrateSwitchingMode, manifest = content.manifest, period = content.period, adaptation = content.adaptation, currentRepresentation = null, abrClock$ = clock$.pipe(Object(map.a)(function(tick) {
                var downloadBitrate = currentRepresentation ? currentRepresentation.bitrate : void 0;
                return object_assign_default()({
                    downloadBitrate: downloadBitrate
                }, tick);
            })), abr$ = abrManager.get$(adaptation.type, abrClock$, adaptation.representations).pipe(Object(observeOn.b)(asap.a), Object(share.a)()), killCurrentBuffer$ = new Subject.a(), terminateCurrentBuffer$ = new Subject.a(), bitrateEstimate$ = abr$.pipe(Object(filter.a)(function(_ref) {
                return null != _ref.bitrate;
            }), Object(distinctUntilChanged.a)(function(old, current) {
                return old.bitrate === current.bitrate;
            }), Object(map.a)(function(_ref2) {
                var bitrate = _ref2.bitrate;
                return log.a.debug("Buffer: new " + adaptation.type + " bitrate estimation", bitrate), 
                buffers_events_generators.bitrateEstimationChange(adaptation.type, bitrate);
            })), newRepresentation$ = abr$.pipe(Object(distinctUntilChanged.a)(function(a, b) {
                return a.manual === b.manual && a.representation.id === b.representation.id;
            })), adaptationBuffer$ = Object(merge.a)(newRepresentation$.pipe(concatMapLatest(function(estimate, i) {
                var representation = estimate.representation;
                // Manual switch needs an immediate feedback.
                // To do that properly, we need to reload the MediaSource
                if (currentRepresentation = representation, directManualBitrateSwitching && estimate.manual && 0 !== i) return Object(of.a)(buffers_events_generators.needsMediaSourceReload());
                var representationChange$ = Object(of.a)(buffers_events_generators.representationChange(adaptation.type, period, representation)), representationBuffer$ = createRepresentationBuffer(representation).pipe(Object(takeUntil.a)(killCurrentBuffer$));
                return Object(concat.a)(representationChange$, representationBuffer$);
            })), newRepresentation$.pipe(Object(map.a)(function(estimation, i) {
                0 !== i && (estimation.urgent ? (log.a.info("Buffer: urgent Representation switch", adaptation.type), 
                // kill current buffer after concatMapLatest has been called
                killCurrentBuffer$.next()) : (log.a.info("Buffer: slow Representation switch", adaptation.type), 
                // terminate current buffer after concatMapLatest has been called
                terminateCurrentBuffer$.next()));
            }), Object(ignoreElements.a)()));
            return Object(merge.a)(adaptationBuffer$, bitrateEstimate$);
            /**
   * Create and returns a new RepresentationBuffer Observable, linked to the
   * given Representation.
   * @param {Representation} representation
   * @returns {Observable}
   */            function createRepresentationBuffer(representation) {
                return Object(defer.a)(function() {
                    return log.a.info("Buffer: changing representation", adaptation.type, representation), 
                    buffers_representation({
                        clock$: clock$,
                        content: {
                            representation: representation,
                            adaptation: adaptation,
                            period: period,
                            manifest: manifest
                        },
                        queuedSourceBuffer: queuedSourceBuffer,
                        segmentBookkeeper: segmentBookkeeper,
                        segmentFetcher: segmentFetcher,
                        terminate$: terminateCurrentBuffer$,
                        wantedBufferAhead$: wantedBufferAhead$
                    });
                });
            }
        };
        // CONCATENATED MODULE: ./src/core/buffers/period/create_fake_buffer.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Create empty AdaptationBuffer Observable, linked to a Period.
 *
 * This observable will never download any segment and just emit a "full"
 * event when reaching the end.
 *
 * @param {Observable} bufferClock$
 * @param {Observable} wantedBufferAhead$
 * @param {string} bufferType
 * @param {Object} content
 * @returns {Observable}
 */        function createFakeAdaptationBuffer(bufferClock$, wantedBufferAhead$, bufferType, content) {
            var period = content.period;
            return Object(combineLatest.a)(bufferClock$, wantedBufferAhead$).pipe(Object(filter.a)(function(_ref) {
                var clockTick = _ref[0], wantedBufferAhead = _ref[1];
                return null != period.end && clockTick.currentTime + wantedBufferAhead >= period.end;
            }), Object(map.a)(function() {
                return log.a.debug("Buffer: full FakeBuffer", bufferType), {
                    type: "full-buffer",
                    value: {
                        bufferType: bufferType
                    }
                };
            }));
        }
        // CONCATENATED MODULE: ./src/core/buffers/period/get_adaptation_switch_strategy.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        var ADAPTATION_SWITCH_BUFFER_PADDINGS = config.a.ADAPTATION_SWITCH_BUFFER_PADDINGS;
        /**
 * Find out what to do when switching adaptation, based on the current
 * situation.
 * @param {TimeRanges} buffered
 * @param {Object} period
 * @param {string} bufferType
 * @param {Object} clockTick
 * @returns {Object}
 */        function getAdaptationSwitchStrategy(buffered, period, bufferType, clockTick) {
            if (!buffered.length) return {
                type: "continue",
                value: void 0
            };
            var bufferedRanges = Object(utils_ranges.a)(buffered), start = period.start, end = period.end || Infinity;
            if (!Object(utils_ranges.j)(bufferedRanges, [ {
                start: start,
                end: end
            } ]).length) return {
                type: "continue",
                value: void 0
            };
            var currentTime = clockTick.currentTime;
            if ("video" === bufferType && 1 < clockTick.readyState && Object(utils_ranges.i)({
                start: start,
                end: end
            }, currentTime)) return {
                type: "needs-reload",
                value: void 0
            };
            var paddingBefore = ADAPTATION_SWITCH_BUFFER_PADDINGS[bufferType].before || 0, paddingAfter = ADAPTATION_SWITCH_BUFFER_PADDINGS[bufferType].after || 0;
            return !paddingAfter && !paddingBefore || end <= currentTime - paddingBefore || currentTime + paddingAfter <= start ? {
                type: "clean-buffer",
                value: [ {
                    start: start,
                    end: end
                } ]
            } : currentTime - paddingBefore <= start ? {
                type: "clean-buffer",
                value: [ {
                    start: currentTime + paddingAfter,
                    end: end
                } ]
            } : end <= currentTime + paddingAfter ? {
                type: "clean-buffer",
                value: [ {
                    start: start,
                    end: currentTime - paddingBefore
                } ]
            } : {
                type: "clean-buffer",
                value: [ {
                    start: start,
                    end: currentTime - paddingBefore
                }, {
                    start: currentTime + paddingAfter,
                    end: end
                } ]
            };
        }
        // CONCATENATED MODULE: ./src/core/buffers/period/period_buffer.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        var DEFAULT_MAX_PIPELINES_RETRY_ON_ERROR = config.a.DEFAULT_MAX_PIPELINES_RETRY_ON_ERROR, DEFAULT_MAX_PIPELINES_RETRY_ON_OFFLINE = config.a.DEFAULT_MAX_PIPELINES_RETRY_ON_OFFLINE;
        /**
 * Create single PeriodBuffer Observable:
 *   - Lazily create (or reuse) a SourceBuffer for the given type.
 *   - Create a Buffer linked to an Adaptation each time it changes, to
 *     download and append the corresponding Segments in the SourceBuffer.
 *   - Announce when the Buffer is full or is awaiting new Segments through
 *     events
 * @returns {Observable}
 */        
        /**
 * @param {string} bufferType
 * @param {Object} adaptation
 * @returns {Object}
 */
        function createOrReuseQueuedSourceBuffer(sourceBuffersManager, bufferType, adaptation, options) {
            var currentQSourceBuffer = sourceBuffersManager.get(bufferType);
            if (null != currentQSourceBuffer) return log.a.info("Buffer: Reusing a previous SourceBuffer for the type", bufferType), 
            currentQSourceBuffer;
            var codec = getFirstDeclaredMimeType(adaptation), sbOptions = "text" === bufferType ? options.textTrackOptions : void 0;
            return sourceBuffersManager.createSourceBuffer(bufferType, codec, sbOptions);
        }
        /**
 * @param {string} bufferType
 * @param {number|undefined} retry
 * @param {number|undefined} offlineRetry
 * @returns {Object} - Options to give to the Pipeline
 */        function getPipelineOptions(bufferType, retry, offlineRetry) {
            return {
                cache: Object(array_includes.a)([ "audio", "video" ], bufferType) ? new initialization_segment_cache() : void 0,
                maxRetry: "image" === bufferType ? 0 : null != retry ? retry : DEFAULT_MAX_PIPELINES_RETRY_ON_ERROR,
                maxRetryOffline: null != offlineRetry ? offlineRetry : DEFAULT_MAX_PIPELINES_RETRY_ON_OFFLINE
            };
        }
        /**
 * Get mimetype string of the first representation declared in the given
 * adaptation.
 * @param {Adaptation} adaptation
 * @returns {string}
 */        function getFirstDeclaredMimeType(adaptation) {
            var representations = adaptation.representations;
            return representations[0] && representations[0].getMimeTypeString() || "";
        }
        // CONCATENATED MODULE: ./src/core/buffers/period/index.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /* harmony default export */        var buffers_period = function PeriodBuffer(_ref) {
            var abrManager = _ref.abrManager, bufferType = _ref.bufferType, clock$ = _ref.clock$, content = _ref.content, garbageCollectors = _ref.garbageCollectors, segmentBookkeepers = _ref.segmentBookkeepers, segmentPipelinesManager = _ref.segmentPipelinesManager, sourceBuffersManager = _ref.sourceBuffersManager, options = _ref.options, period = content.period, wantedBufferAhead$ = options.wantedBufferAhead$, adaptation$ = new ReplaySubject.a(1);
            return adaptation$.pipe(Object(switchMap.a)(function(adaptation) {
                if (null == adaptation) {
                    log.a.info("Buffer: Set no " + bufferType + " Adaptation", period);
                    var cleanBuffer$, previousQSourceBuffer = sourceBuffersManager.get(bufferType);
                    return cleanBuffer$ = null != previousQSourceBuffer ? (log.a.info("Buffer: Clearing previous " + bufferType + " SourceBuffer"), 
                    previousQSourceBuffer.removeBuffer(period.start, period.end || Infinity)) : Object(of.a)(null), 
                    Object(concat.a)(cleanBuffer$.pipe(Object(mapTo.a)(buffers_events_generators.adaptationChange(bufferType, null, period))), createFakeAdaptationBuffer(clock$, wantedBufferAhead$, bufferType, {
                        period: period
                    }));
                }
                log.a.info("Buffer: Updating " + bufferType + " adaptation", adaptation, period);
                var newBuffer$ = clock$.pipe(Object(take.a)(1), Object(mergeMap.a)(function(tick) {
                    var qSourceBuffer = createOrReuseQueuedSourceBuffer(sourceBuffersManager, bufferType, adaptation, options), strategy = getAdaptationSwitchStrategy(qSourceBuffer.getBuffered(), period, bufferType, tick);
                    if ("needs-reload" === strategy.type) return Object(of.a)(buffers_events_generators.needsMediaSourceReload());
                    var cleanBuffer$ = "clean-buffer" === strategy.type ? concat.a.apply(void 0, strategy.value.map(function(_ref2) {
                        var start = _ref2.start, end = _ref2.end;
                        return qSourceBuffer.removeBuffer(start, end);
                    })).pipe(Object(ignoreElements.a)()) : empty.a, bufferGarbageCollector$ = garbageCollectors.get(qSourceBuffer), adaptationBuffer$ = createAdaptationBuffer(adaptation, qSourceBuffer);
                    return Object(concat.a)(cleanBuffer$, Object(merge.a)(adaptationBuffer$, bufferGarbageCollector$));
                }));
                return Object(concat.a)(Object(of.a)(buffers_events_generators.adaptationChange(bufferType, adaptation, period)), newBuffer$);
            }), Object(startWith.a)(buffers_events_generators.periodBufferReady(bufferType, period, adaptation$)));
            /**
   * @param {string} bufferType
   * @param {Object} period
   * @param {Object} adaptation
   * @param {Object} qSourceBuffer
   * @returns {Observable}
   */            function createAdaptationBuffer(adaptation, qSourceBuffer) {
                var manifest = content.manifest, segmentBookkeeper = segmentBookkeepers.get(qSourceBuffer), pipelineOptions = getPipelineOptions(bufferType, options.segmentRetry, options.offlineRetry), pipeline = segmentPipelinesManager.createPipeline(bufferType, pipelineOptions), adaptationBufferClock$ = clock$.pipe(Object(map.a)(function(tick) {
                    var buffered = qSourceBuffer.getBuffered();
                    return object_assign_default()({}, tick, {
                        bufferGap: Object(utils_ranges.c)(buffered, tick.currentTime)
                    });
                }));
                return buffers_adaptation(adaptationBufferClock$, qSourceBuffer, segmentBookkeeper, pipeline, wantedBufferAhead$, {
                    manifest: manifest,
                    period: period,
                    adaptation: adaptation
                }, abrManager, options).pipe(Object(catchError.a)(function(error) {
                    // non native buffer should not impact the stability of the
                    // player. ie: if a text buffer sends an error, we want to
                    // continue playing without any subtitles
                    if (!source_buffers.isNative(bufferType)) return log.a.error("Buffer: Custom " + bufferType + " buffer crashed. Aborting it.", error), 
                    sourceBuffersManager.disposeSourceBuffer(bufferType), Object(concat.a)(Object(of.a)(buffers_events_generators.warning(error)), createFakeAdaptationBuffer(clock$, wantedBufferAhead$, bufferType, {
                        period: period
                    }));
                    throw log.a.error("Buffer: Native " + bufferType + " buffer crashed. Stopping playback.", error), 
                    error;
                }));
            }
        };
        // CONCATENATED MODULE: ./src/utils/take_first_set.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Returns the first argument given different from undefined or null.
 * @param {...*} args
 * @returns {*}
 */        function takeFirstSet() {
            for (var i = 0, len = arguments.length; i < len; ) {
                if (null != (i < 0 || arguments.length <= i ? void 0 : arguments[i])) return i < 0 || arguments.length <= i ? void 0 : arguments[i];
                i++;
            }
        }
        // CONCATENATED MODULE: ./src/core/buffers/segment_bookkeeper.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        var MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT = config.a.MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT, MAX_BUFFERED_DISTANCE = config.a.MAX_BUFFERED_DISTANCE, segment_bookkeeper_MINIMUM_SEGMENT_SIZE = config.a.MINIMUM_SEGMENT_SIZE, segment_bookkeeper_SegmentBookkeeper = 
        /* */
        function() {
            function SegmentBookkeeper() {
                /**
     * The inventory keep track of all the segments which should be currently
     * in the browser's memory.
     * This array contains objects, each being related to a single downloaded
     * segment which is at least partially added in a SourceBuffer.
     * @type {Array.<Object>}
     */
                this.inventory = [];
            }
            /**
   * Infer each segment's bufferedStart and bufferedEnd from the TimeRanges
   * given (coming from the SourceBuffer).
   * @param {TimeRanges}
   *
   * TODO implement management of segments whose end is not known
   */            var _proto = SegmentBookkeeper.prototype;
            return _proto.synchronizeBuffered = function synchronizeBuffered(buffered) {
                for (var inventory = this.inventory, ranges = Object(utils_ranges.a)(buffered), inventoryIndex = 0, thisSegment = inventory[0], rangesLength = ranges.length, i = 0; i < rangesLength; i++) {
                    if (null == thisSegment) 
                    // If thisSegment is not set, it means that we arrived at the end of
                    // our inventory.
                    // This TimeRange do not link to any segment and neither will any
                    // subsequent one.
                    // (It may be linked to another adaptation, for example)
                    return;
                    var _ranges$i = ranges[i], rangeStart = _ranges$i.start, rangeEnd = _ranges$i.end;
 // if current TimeRange is too small to contain a segment, go to next one
                                        if (!(rangeEnd - rangeStart < segment_bookkeeper_MINIMUM_SEGMENT_SIZE)) {
                        // Find the first segment either within this TimeRange or past it:
                        // skip until first segment with at least MINIMUM_SEGMENT_SIZE past the
                        // start of that range.
                        for (// Inventory index of the last segment not contained in the current range.
                        // Will be used to know how many segments have been garbage collected.
                        var indexBefore = inventoryIndex; thisSegment && // TODO better way to indicate to typescript that all is well here
                        takeFirstSet(thisSegment.bufferedEnd, thisSegment.end) - rangeStart < segment_bookkeeper_MINIMUM_SEGMENT_SIZE; ) thisSegment = inventory[++inventoryIndex];
 // Contains the end of the last garbage-collected segment before
                        // thisSegment.
                        // Might be useful to infer later the bufferedStart of thisSegment.
                        //
                        // -1 if no segment have been garbage-collected before thisSegment.
                                                var lastDeletedSegmentEnd = -1, numberOfSegmentToDelete = inventoryIndex - indexBefore;
 // remove garbage-collected segments
                        // (not in that TimeRange nor in the previous one)
                                                if (0 < numberOfSegmentToDelete) {
                            // last garbage-collected segment
                            var lastDeletedSegment = inventory[indexBefore + numberOfSegmentToDelete - 1];
 // TODO better way to indicate to typescript that all is well here
                                                        lastDeletedSegmentEnd = takeFirstSet(lastDeletedSegment.bufferedEnd, lastDeletedSegment.end), 
                            // mutate inventory
                            inventory.splice(indexBefore, numberOfSegmentToDelete), inventoryIndex = indexBefore;
                        }
 // if no segment is left for that range (or any other one), quit
                                                if (null == thisSegment) return;
 // Infer the bufferedStart for this segment, and the bufferedStart and
                        // bufferedEnd for the following segments included in that range.
                        //
                        // If the current segment is actually completely outside that range (it
                        // is contained in one of the next one), skip that part.
                                                if (rangeEnd - // TODO better way to indicate to typescript that all is well here
                        takeFirstSet(thisSegment.bufferedStart, thisSegment.start) >= segment_bookkeeper_MINIMUM_SEGMENT_SIZE) // Make contiguous until first segment outside that range
                        // (i.e until the start of the next segment can not constitute a segment
                        // in that range == less than MINIMUM_SEGMENT_SIZE into that range)
                        for (
                        // set the bufferedStart of the first segment in that range
                        null != thisSegment.bufferedStart && thisSegment.bufferedStart < rangeStart ? 
                        // the segment appears to have been partially garbage collected:
                        // Update bufferedStart
                        thisSegment.bufferedStart = rangeStart : null == thisSegment.bufferedStart && (-1 !== lastDeletedSegmentEnd && rangeStart < lastDeletedSegmentEnd && thisSegment.start - lastDeletedSegmentEnd <= MAX_BUFFERED_DISTANCE ? thisSegment.bufferedStart = lastDeletedSegmentEnd : thisSegment.start - rangeStart <= MAX_BUFFERED_DISTANCE ? thisSegment.bufferedStart = rangeStart : thisSegment.bufferedStart = thisSegment.start), 
                        thisSegment = inventory[++inventoryIndex]; thisSegment && rangeEnd - // TODO better way to indicate to typescript that all is well here
                        takeFirstSet(thisSegment.bufferedStart, thisSegment.start) >= segment_bookkeeper_MINIMUM_SEGMENT_SIZE; ) {
                            var prevSegment = inventory[inventoryIndex - 1];
 // those segments are contiguous, we have no way to infer their real
                            // end
                                                        null == prevSegment.bufferedEnd && (prevSegment.bufferedEnd = prevSegment.end), 
                            thisSegment.bufferedStart = prevSegment.bufferedEnd, thisSegment = inventory[++inventoryIndex];
                        }
 // update the bufferedEnd of the last segment in that range
                                                var lastSegmentInRange = inventory[inventoryIndex - 1];
                        lastSegmentInRange && (null != lastSegmentInRange.bufferedEnd && lastSegmentInRange.bufferedEnd > rangeEnd ? 
                        // the segment appears to have been partially garbage collected:
                        // Update bufferedEnd
                        lastSegmentInRange.bufferedEnd = rangeEnd : null == lastSegmentInRange.bufferedEnd && (lastSegmentInRange.bufferedEnd = rangeEnd - lastSegmentInRange.end <= MAX_BUFFERED_DISTANCE ? rangeEnd : lastSegmentInRange.end));
                    }
                }
 // if we still have segments left, they are not affiliated to any range.
                // They might have been garbage collected, delete them from here.
                                thisSegment && inventory.splice(inventoryIndex, inventory.length - inventoryIndex);
            }
            /**
   * Add a new segment in the inventory.
   *
   * Note: As new segments can "replace" partially or completely old ones, we
   * have to perform a complex logic and might update previously added segments.
   *
   * @param {Object} period
   * @param {Object} adaptation
   * @param {Object} representation
   * @param {Object} segment
   * @param {Number} start - start time of the segment, in seconds
   * @param {Number|undefined} end - end time of the segment, in seconds. Can
   * be undefined in some rare cases
   */ , _proto.insert = function insert(period, adaptation, representation, segment, start, end) {
                // TODO (*very* low-priority) manage segments whose end is unknown (rare but
                // could eventually happen).
                // This should be properly managed in this method, but it is not in some
                // other methods of this class, so I decided to not one of those to the
                // inventory by security
                if (null != end) {
                    // begin by the end as in most use cases this will be faster
                    for (var inventory = this.inventory, newSegment = {
                        start: start,
                        end: end,
                        bufferedStart: void 0,
                        bufferedEnd: void 0,
                        infos: {
                            segment: segment,
                            period: period,
                            adaptation: adaptation,
                            representation: representation
                        }
                    }, i = inventory.length - 1 // infer start and end from the segment data
                    // /!\ Can be a little different than their real start/end time in the
                    // sourcebuffer.
                    // const start = segment.time / segment.timescale;
                    // const end = (segment.time + segment.duration) / segment.timescale;
                    ; 0 <= i; i--) {
                        var segmentI = inventory[i];
                        if (segmentI.start <= start) return segmentI.end <= start ? 
                        // our segment is after, push it after this one
                        //
                        // Case 1:
                        //   segmentI     : |------|
                        //   newSegment   :        |------|
                        //
                        // Case 2:
                        //   segmentI     : |------|
                        //   newSegment   :          |------|
                        void this.inventory.splice(i + 1, 0, newSegment) : 
                        // /!\ also goes here if end is undefined
                        segmentI.start >= start ? 
                        // In those cases, replace
                        // Case 1:
                        //  segmentI     : |-------|
                        //  newSegment   : |-------|
                        //
                        // Case 2:
                        //  segmentI     : |-------|
                        //  newSegment   : |----------|
                        //
                        // Case 3:
                        //  segmentI     : |-------|
                        //  newSegment   : |???*
                        //
                        // Case 4:
                        //  segmentI     : |???*
                        //  newSegment   : |------|
                        //
                        // Case 5:
                        //  segmentI     : |???*
                        //  newSegment   : |???*
                        //
                        // *|??? - unknown end
                        void this.inventory.splice(i, 1, newSegment) : (
                        // our segment has a "complex" relation with this one,
                        // update the old one end and add this one after it.
                        //
                        // Case 1:
                        //  segmentI     : |-------|
                        //  newSegment   :    |------|
                        //
                        // Case 2:
                        //  segmentI     : |-------|
                        //  newSegment   :    |----|
                        //
                        // Case 3:
                        //  segmentI     : |-------|
                        //  newSegment   :    |???*
                        //
                        // Case 4:
                        //  segmentI     : |???*
                        //  newSegment   :    |----|
                        //
                        // Case 5:
                        //  segmentI     : |???*
                        //  newSegment   :    |???*
                        //
                        // *|??? - unknown end
                        // (if segment's end is not known yet, it could perfectly
                        // end before the one we're adding now)
                        null != segmentI.end && (segmentI.end = start), void this.inventory.splice(i + 1, 0, newSegment));
                    }
 // if we got here, we are the first segment
                    // check bounds of the previous first segment
                                        var firstSegment = this.inventory[0];
                    firstSegment ? null != end ? firstSegment.start >= end ? 
                    // our segment is before, put it before
                    // Case 1:
                    //  firstSegment :      |----|
                    //  newSegment   : |----|
                    //
                    // Case 2:
                    //  firstSegment :        |----|
                    //  newSegment   : |----|
                    //
                    // Case 3:
                    //  firstSegment :        |???*
                    //  newSegment   : |----|
                    //
                    // Case 4:
                    //  firstSegment :      |???*
                    //  newSegment   : |----|
                    //
                    // *|??? - unknown end
                    this.inventory.splice(0, 0, newSegment) : firstSegment.end <= end ? 
                    // Our segment is bigger, replace the first
                    // Case 1:
                    //  firstSegment :   |---|
                    //  newSegment   : |-------|
                    //
                    // Case 2:
                    //  firstSegment :   |-----|
                    //  newSegment   : |-------|
                    this.inventory.splice(0, 1, newSegment) : (
                    // our segment has a "complex" relation with the first one,
                    // update the old one start and add this one before it.
                    // Case 1:
                    //  firstSegment :    |------|
                    //  newSegment   : |------|
                    //
                    // Case 2:
                    // firstSegment :   |???*
                    // newSegment   : |-----|
                    //
                    // *|??? - unknown end
                    firstSegment.start = end, this.inventory.splice(0, 0, newSegment)) : firstSegment.start === start ? 
                    // same beginning, unknown end, just replace
                    // Case 1:
                    //  firstSegment : |-------|
                    //  newSegment   : |???*
                    //
                    // Case 2:
                    //  firstSegment : |???*
                    //  newSegment   : |???*
                    //
                    // *|??? - unknown end
                    this.inventory.splice(0, 1, newSegment) : 
                    // our segment begins before this one, push at the beginning
                    // Case 1:
                    // firstSegment :   |-------|
                    // newSegment   : |???*
                    //
                    // Case 2:
                    // firstSegment :   |???*
                    // newSegment   : |???*
                    //
                    // *|??? - unknown end
                    this.inventory.splice(0, 0, newSegment) : 
                    // we do not have any segment yet
                    this.inventory.push(newSegment);
                } else // This leads to excessive re-downloads of segment without an ending time.
                log.a.warn("SB: ending time of the segment not defined");
            }
            /**
   * Returns segment infos for a segment corresponding to the given time,
   * duration and timescale.
   *
   * Returns null if either:
   *   - no segment can be linked exactly to the given time/duration
   *   - a segment is linked to this information, but is currently considered
   *     "incomplete" to be playable, in the sourceBuffer. We check if all
   *     needed data for playback (from wanted range) is loaded.
   *
   * The main purpose of this method is to know if the segment asked should be
   * downloaded (or re-downloaded).
   *
   * /!\ Make sure that this class is synchronized with the sourceBuffer
   * (see addBufferedInfos method of the same class) before calling this method,
   * as it depends on it to categorize "incomplete" from "complete" segments.
   *
   * @param {Object} wantedRange
   * @param {Object} segmentInfos
   * @returns {Object|null}
   */ , _proto.hasPlayableSegment = function hasPlayableSegment(wantedRange, segmentInfos) {
                for (var time = segmentInfos.time, duration = segmentInfos.duration, timescale = segmentInfos.timescale, inventory = this.inventory, i = inventory.length - 1; 0 <= i; i--) {
                    var currentSegmentI = inventory[i], prevSegmentI = inventory[i - 1], nextSegmentI = inventory[i + 1], segment = currentSegmentI.infos.segment, _time = time, _duration = duration;
                    if (segment.timescale !== timescale && (
                    // Note: we could get rounding errors here
                    _time = time * segment.timescale / timescale, _duration = duration * segment.timescale / timescale), 
                    segment.time === _time && segment.duration === _duration && hasEnoughInfos(currentSegmentI, prevSegmentI, nextSegmentI) && hasWantedRange(wantedRange, currentSegmentI, prevSegmentI, nextSegmentI)) return currentSegmentI;
                }
                return null;
 // -- Helpers
                /**
     * Check if segment can be evaluated.
     * @param {Object} currentSegmentI
     * @param {Object} prevSegmentI
     * @param {Object} nextSegmentI
     * @returns {Boolean}
     */                function hasEnoughInfos(currentSegmentI, prevSegmentI, nextSegmentI) {
                    return !(prevSegmentI && null == prevSegmentI.bufferedEnd || null == currentSegmentI.bufferedStart) && !(nextSegmentI && null == nextSegmentI.bufferedStart || null == currentSegmentI.bufferedEnd);
                }
                /**
     * Returns true if the segment given can be played for the wanted range.
     * @param {Object} _wantedRange
     * @param {Object} currentSegmentI
     * @param {Object} prevSegmentI
     * @param {Object} nextSegmentI
     * @returns {Boolean}
     */                function hasWantedRange(_wantedRange, currentSegmentI, prevSegmentI, nextSegmentI) {
                    if (!prevSegmentI || null == prevSegmentI.bufferedEnd || null == currentSegmentI.bufferedStart || prevSegmentI.bufferedEnd < currentSegmentI.bufferedStart) {
                        if (null == currentSegmentI.bufferedStart) return !1;
                        var timeDiff = currentSegmentI.bufferedStart - currentSegmentI.start;
                        if (_wantedRange.start > currentSegmentI.start) {
                            if (0 < currentSegmentI.bufferedStart - _wantedRange.start && MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT < timeDiff) return log.a.debug("SB: The wanted segment has been garbage collected", currentSegmentI), 
                            !1;
                        } else if (MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT < timeDiff) return log.a.debug("SB: The wanted segment has been garbage collected", currentSegmentI), 
                        !1;
                    }
                    if (null === currentSegmentI.end) return !1;
                    if (!nextSegmentI || null == nextSegmentI.bufferedStart || null == currentSegmentI.bufferedEnd || nextSegmentI.bufferedStart > currentSegmentI.bufferedEnd) {
                        if (null == currentSegmentI.bufferedEnd) return !1;
                        var _timeDiff = currentSegmentI.end - currentSegmentI.bufferedEnd;
                        if (_wantedRange.end < currentSegmentI.end) {
                            if (0 < _wantedRange.end - currentSegmentI.bufferedEnd && MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT < _timeDiff) return log.a.debug("SB: The wanted segment has been garbage collected", currentSegmentI), 
                            !1;
                        } else if (MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT < _timeDiff) return log.a.debug("SB: The wanted segment has been garbage collected", currentSegmentI), 
                        !1;
                    }
                    return !0;
                }
            }
            /**
   * Empty the current inventory
   */ , _proto.reset = function reset() {
                this.inventory = [];
            }, SegmentBookkeeper;
        }(), MAXIMUM_MAX_BUFFER_AHEAD = config.a.MAXIMUM_MAX_BUFFER_AHEAD, MAXIMUM_MAX_BUFFER_BEHIND = config.a.MAXIMUM_MAX_BUFFER_BEHIND;
        /**
 * Keep track of every segment downloaded and currently in the browser's memory.
 *
 * The main point of this class is to know which CDN segments are already
 * pushed to the SourceBuffer, at which bitrate, and which have been
 * garbage-collected since by the browser (and thus should be re-downloaded).
 * @class SegmentBookkeeper
 */        
        // CONCATENATED MODULE: ./src/core/buffers/index.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /* harmony default export */ var core_buffers = 
        /**
 * Create and manage the various Buffer Observables needed for the content to
 * play:
 *
 *   - Create or dispose SourceBuffers depending on the chosen adaptations.
 *
 *   - Push the right segments to those SourceBuffers depending on the user's
 *     preferences, the current position, the bandwidth, the decryption
 *     conditions...
 *
 *   - Concatenate Buffers for adaptation from separate Periods at the right
 *     time, to allow smooth transitions between periods.
 *
 *   - Emit various events to notify of its health and issues
 *
 * Here multiple buffers can be created at the same time to allow smooth
 * transitions between periods.
 * To do this, we dynamically create or destroy buffers as they are needed.
 * @param {Object} content
 * @param {Observable} clock$ - Emit position informations
 * @param {Object} abrManager - Emit bitrate estimation and best Representation
 * to play.
 * @param {Object} sourceBuffersManager - Will be used to lazily create
 * SourceBuffer instances associated with the current content.
 * @param {Object} segmentPipelinesManager - Download segments
 * @param {Object} options
 * @returns {Observable}
 *
 * TODO Special case for image Buffer, where we want data for EVERY active
 * periods.
 */
        function BufferOrchestrator(content, clock$, abrManager, sourceBuffersManager, segmentPipelinesManager, options) {
            var manifest = content.manifest, initialPeriod = content.initialPeriod, maxBufferAhead$ = options.maxBufferAhead$, maxBufferBehind$ = options.maxBufferBehind$, garbageCollectors = new WeakMapMemory(function(qSourceBuffer) {
                var bufferType = qSourceBuffer.bufferType, defaultMaxBehind = null != MAXIMUM_MAX_BUFFER_BEHIND[bufferType] ? MAXIMUM_MAX_BUFFER_BEHIND[bufferType] : Infinity, defaultMaxAhead = null != MAXIMUM_MAX_BUFFER_AHEAD[bufferType] ? MAXIMUM_MAX_BUFFER_AHEAD[bufferType] : Infinity;
                return BufferGarbageCollector({
                    queuedSourceBuffer: qSourceBuffer,
                    clock$: clock$.pipe(Object(map.a)(function(tick) {
                        return tick.currentTime;
                    })),
                    maxBufferBehind$: maxBufferBehind$.pipe(Object(map.a)(function(val) {
                        return Math.min(val, defaultMaxBehind);
                    })),
                    maxBufferAhead$: maxBufferAhead$.pipe(Object(map.a)(function(val) {
                        return Math.min(val, defaultMaxAhead);
                    }))
                });
            }), segmentBookkeepers = new WeakMapMemory(function() {
                return new segment_bookkeeper_SegmentBookkeeper();
            }), outOfManifest$ = clock$.pipe(Object(mergeMap.a)(function(_ref) {
                var currentTime = _ref.currentTime, position = _ref.wantedTimeOffset + currentTime;
                if (position < manifest.getMinimumPosition()) {
                    var warning = new media_error.a("MEDIA_TIME_BEFORE_MANIFEST", "The current position is behind the earliest time announced in the Manifest.", !1);
                    return Object(of.a)(buffers_events_generators.warning(warning));
                }
                if (position > manifest.getMaximumPosition()) {
                    var _warning = new media_error.a("MEDIA_TIME_AFTER_MANIFEST", "The current position is after the latest time announced in the Manifest.", !1);
                    return Object(of.a)(buffers_events_generators.warning(_warning));
                }
                return empty.a;
            })), addPeriodBuffer$ = new Subject.a(), removePeriodBuffer$ = new Subject.a(), bufferTypes = getBufferTypes(), buffersArray = bufferTypes.map(function(bufferType) {
                return manageEveryBuffers(bufferType, initialPeriod).pipe(Object(tap.a)(function(evt) {
                    "periodBufferReady" === evt.type ? addPeriodBuffer$.next(evt.value) : "periodBufferCleared" === evt.type && removePeriodBuffer$.next(evt.value);
                }), Object(share.a)());
            }), activePeriodChanged$ = ActivePeriodEmitter(bufferTypes, addPeriodBuffer$, removePeriodBuffer$).pipe(Object(filter.a)(function(period) {
                return !!period;
            }), Object(map.a)(function(period) {
                return log.a.info("Buffer: New active period", period), buffers_events_generators.activePeriodChanged(period);
            })), endOfStream$ = areBuffersComplete.apply(void 0, buffersArray).pipe(Object(map.a)(function(areComplete) {
                return areComplete ? buffers_events_generators.endOfStream() : buffers_events_generators.resumeStream();
            }));
            return merge.a.apply(void 0, [ activePeriodChanged$ ].concat(buffersArray, [ endOfStream$, outOfManifest$ ]));
            /**
   * Manage creation and removal of Buffers for every Periods.
   *
   * Works by creating consecutive buffers through the
   * manageConsecutivePeriodBuffers function, and restarting it when the clock
   * goes out of the bounds of these buffers.
   * @param {string} bufferType - e.g. "audio" or "video"
   * @param {Period} basePeriod - Initial Period downloaded.
   * @returns {Observable}
   */            function manageEveryBuffers(bufferType, basePeriod) {
                // Each Period for which there is currently a Buffer, chronologically
                var periodList = new sorted_list_SortedList(function(a, b) {
                    return a.start - b.start;
                }), destroyBuffers$ = new Subject.a(), hasLoadedABuffer = !1;
                // true after the first PeriodBuffer is ready
                /**
     * @param {Object} period
     * @returns {Observable}
     */
                function launchConsecutiveBuffersForPeriod(period) {
                    return manageConsecutivePeriodBuffers(bufferType, period, destroyBuffers$).pipe(Object(tap.a)(function(message) {
                        "periodBufferReady" === message.type ? (hasLoadedABuffer || (hasLoadedABuffer = !0), 
                        periodList.add(message.value.period)) : "periodBufferCleared" === message.type && periodList.removeElement(message.value.period);
                    }), Object(share.a)());
                }
                /**
     * Returns true if the given time is either:
     *   - less than the start of the chronologically first Period
     *   - more than the end of the chronologically last Period
     * @param {number} time
     * @returns {boolean}
     */                function isOutOfPeriodList(time) {
                    var head = periodList.head(), last = periodList.last();
                    return null == head || null == last || head.start > time || (last.end || Infinity) < time;
                }
 // Restart the current buffer when the wanted time is in another period
                // than the ones already considered
                                var restartBuffersWhenOutOfBounds$ = clock$.pipe(Object(filter.a)(function(_ref2) {
                    var currentTime = _ref2.currentTime, wantedTimeOffset = _ref2.wantedTimeOffset;
                    return hasLoadedABuffer && !!manifest.getPeriodForTime(wantedTimeOffset + currentTime) && isOutOfPeriodList(wantedTimeOffset + currentTime);
                }), Object(tap.a)(function(_ref3) {
                    var currentTime = _ref3.currentTime, wantedTimeOffset = _ref3.wantedTimeOffset;
                    log.a.info("Buffer: Current position out of the bounds of the active periods,re-creating buffers.", bufferType, currentTime + wantedTimeOffset), 
                    hasLoadedABuffer = !1, destroyBuffers$.next();
                }), Object(mergeMap.a)(function(_ref4) {
                    var currentTime = _ref4.currentTime, wantedTimeOffset = _ref4.wantedTimeOffset, newInitialPeriod = manifest.getPeriodForTime(currentTime + wantedTimeOffset);
                    if (null == newInitialPeriod) throw new media_error.a("MEDIA_TIME_NOT_FOUND", "The wanted position is not found in the Manifest.", !0);
                    return launchConsecutiveBuffersForPeriod(newInitialPeriod);
                }));
                return Object(merge.a)(launchConsecutiveBuffersForPeriod(basePeriod), restartBuffersWhenOutOfBounds$);
            }
            /**
   * Create lazily consecutive PeriodBuffers:
   *
   * It first creates the PeriodBuffer for `basePeriod` and - once it becomes
   * full - automatically creates the next chronological one.
   * This process repeats until the PeriodBuffer linked to the last Period is
   * full.
   *
   * If an "old" PeriodBuffer becomes active again, it destroys all PeriodBuffer
   * coming after it (from the last chronological one to the first).
   *
   * To clean-up PeriodBuffers, each one of them are also automatically
   * destroyed once the clock anounce a time superior or equal to the end of
   * the concerned Period.
   *
   * A "periodBufferReady" event is sent each times a new PeriodBuffer is
   * created. The first one (for `basePeriod`) should be sent synchronously on
   * subscription.
   *
   * A "periodBufferCleared" event is sent each times a PeriodBuffer is
   * destroyed.
   * @param {string} bufferType - e.g. "audio" or "video"
   * @param {Period} basePeriod - Initial Period downloaded.
   * @param {Observable} destroy$ - Emit when/if all created Buffers from this
   * point should be destroyed.
   * @returns {Observable}
   */            function manageConsecutivePeriodBuffers(bufferType, basePeriod, destroy$) {
                log.a.info("Buffer: Creating new Buffer for", bufferType, basePeriod);
                // Emits the Period of the next Period Buffer when it can be created.
                var createNextPeriodBuffer$ = new Subject.a(), destroyNextBuffers$ = new Subject.a(), endOfCurrentBuffer$ = clock$.pipe(Object(filter.a)(function(_ref5) {
                    var currentTime = _ref5.currentTime, wantedTimeOffset = _ref5.wantedTimeOffset;
                    return !!basePeriod.end && currentTime + wantedTimeOffset >= basePeriod.end;
                })), nextPeriodBuffer$ = createNextPeriodBuffer$.pipe(exhaustMap(function(nextPeriod) {
                    return manageConsecutivePeriodBuffers(bufferType, nextPeriod, destroyNextBuffers$);
                })), destroyAll$ = destroy$.pipe(Object(take.a)(1), Object(tap.a)(function() {
                    // first complete createNextBuffer$ to allow completion of the
                    // nextPeriodBuffer$ observable once every further Buffers have been
                    // cleared.
                    createNextPeriodBuffer$.complete(), // emit destruction signal to the next Buffer first
                    destroyNextBuffers$.next(), destroyNextBuffers$.complete();
                }), Object(share.a)()), killCurrentBuffer$ = Object(merge.a)(endOfCurrentBuffer$, destroyAll$), periodBuffer$ = buffers_period({
                    abrManager: abrManager,
                    bufferType: bufferType,
                    clock$: clock$,
                    content: {
                        manifest: manifest,
                        period: basePeriod
                    },
                    garbageCollectors: garbageCollectors,
                    segmentBookkeepers: segmentBookkeepers,
                    segmentPipelinesManager: segmentPipelinesManager,
                    sourceBuffersManager: sourceBuffersManager,
                    options: options
                }).pipe(Object(mergeMap.a)(function(evt) {
                    var type = evt.type;
                    if ("full-buffer" === type) {
                        var nextPeriod = manifest.getPeriodAfter(basePeriod);
                        if (null == nextPeriod) return Object(of.a)(buffers_events_generators.bufferComplete(bufferType));
                        // current buffer is full, create the next one if not
                        createNextPeriodBuffer$.next(nextPeriod);
                    } else "active-buffer" === type && 
                    // current buffer is active, destroy next buffer if created
                    destroyNextBuffers$.next();
                    return Object(of.a)(evt);
                }), Object(share.a)()), currentBuffer$ = Object(concat.a)(periodBuffer$.pipe(Object(takeUntil.a)(killCurrentBuffer$)), Object(of.a)(buffers_events_generators.periodBufferCleared(bufferType, basePeriod)).pipe(Object(tap.a)(function() {
                    log.a.info("Buffer: Destroying buffer for", bufferType, basePeriod);
                })));
 // Emits when the Buffers for the next Periods should be destroyed, if
                // created.
                                return Object(merge.a)(currentBuffer$, nextPeriodBuffer$, destroyAll$.pipe(Object(ignoreElements.a)()));
            }
        };
        // CONCATENATED MODULE: ./src/core/init/create_buffer_clock.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Create clock Observable for the Buffers part of the code.
 * @param {Object} manifest
 * @param {Observable} initClock$
 * @param {Observable} initialSeek$
 * @param {Number} startTime
 * @returns {Observable}
 */        function createBufferClock(manifest, initClock$, initialSeek$, speed$, startTime) {
            var initialSeekPerformed = !1, updateTimeOffset$ = initialSeek$.pipe(Object(tap.a)(function() {
                initialSeekPerformed = !0;
            }), Object(ignoreElements.a)()), clock$ = Object(combineLatest.a)(initClock$, speed$).pipe(Object(map.a)(function(_ref) {
                var tick = _ref[0], speed = _ref[1];
                return object_assign_default()({
                    isLive: manifest.isLive,
                    liveGap: manifest.isLive ? manifest.getMaximumPosition() - tick.currentTime : Infinity,
                    // wantedTimeOffset is an offset to add to the timing's current time to have
                    // the "real" wanted position.
                    // For now, this is seen when the media element has not yet seeked to its
                    // initial position, the currentTime will most probably be 0 where the
                    // effective starting position will be _startTime_.
                    // Thus we initially set a wantedTimeOffset equal to startTime.
                    wantedTimeOffset: initialSeekPerformed ? 0 : startTime - tick.currentTime,
                    speed: speed
                }, tick);
            }));
            return Object(merge.a)(clock$, updateTimeOffset$);
        }
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/isArray.js
                var isArray = __webpack_require__(45), fromArray = __webpack_require__(36);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/fromArray.js
                // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/observable/race.js
        /** PURE_IMPORTS_START tslib,_util_isArray,_fromArray,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
        function race() {
            for (var observables = [], _i = 0; _i < arguments.length; _i++) observables[_i] = arguments[_i];
            if (1 === observables.length) {
                if (!Object(isArray.a)(observables[0])) return observables[0];
                observables = observables[0];
            }
            return Object(fromArray.a)(observables, void 0).lift(new RaceOperator());
        }
        var RaceOperator = /* */ function() {
            function RaceOperator() {}
            return RaceOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new race_RaceSubscriber(subscriber));
            }, RaceOperator;
        }(), race_RaceSubscriber = /* */ function(_super) {
            function RaceSubscriber(destination) {
                var _this = _super.call(this, destination) || this;
                return _this.hasFirst = !1, _this.observables = [], _this.subscriptions = [], _this;
            }
            return tslib_es6.a(RaceSubscriber, _super), RaceSubscriber.prototype._next = function(observable) {
                this.observables.push(observable);
            }, RaceSubscriber.prototype._complete = function() {
                var observables = this.observables, len = observables.length;
                if (0 === len) this.destination.complete(); else {
                    for (var i = 0; i < len && !this.hasFirst; i++) {
                        var observable = observables[i], subscription = Object(subscribeToResult.a)(this, observable, observable, i);
                        this.subscriptions && this.subscriptions.push(subscription), this.add(subscription);
                    }
                    this.observables = null;
                }
            }, RaceSubscriber.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
                if (!this.hasFirst) {
                    this.hasFirst = !0;
                    for (var i = 0; i < this.subscriptions.length; i++) if (i !== outerIndex) {
                        var subscription = this.subscriptions[i];
                        subscription.unsubscribe(), this.remove(subscription);
                    }
                    this.subscriptions = null;
                }
                this.destination.next(innerValue);
            }, RaceSubscriber;
        }(OuterSubscriber.a), ArgumentOutOfRangeError = __webpack_require__(99);
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/takeLast.js
        /** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError,_observable_empty PURE_IMPORTS_END */
        function takeLast(count) {
            return function takeLastOperatorFunction(source) {
                return 0 === count ? Object(empty.b)() : source.lift(new takeLast_TakeLastOperator(count));
            };
        }
        var takeLast_TakeLastOperator = /* */ function() {
            function TakeLastOperator(total) {
                if (this.total = total, this.total < 0) throw new ArgumentOutOfRangeError.a();
            }
            return TakeLastOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new takeLast_TakeLastSubscriber(subscriber, this.total));
            }, TakeLastOperator;
        }(), takeLast_TakeLastSubscriber = /* */ function(_super) {
            function TakeLastSubscriber(destination, total) {
                var _this = _super.call(this, destination) || this;
                return _this.total = total, _this.ring = new Array(), _this.count = 0, _this;
            }
            return tslib_es6.a(TakeLastSubscriber, _super), TakeLastSubscriber.prototype._next = function(value) {
                var ring = this.ring, total = this.total, count = this.count++;
                ring.length < total ? ring.push(value) : ring[count % total] = value;
            }, TakeLastSubscriber.prototype._complete = function() {
                var destination = this.destination, count = this.count;
                if (0 < count) for (var total = this.count >= this.total ? this.total : this.count, ring = this.ring, i = 0; i < total; i++) {
                    var idx = count++ % total;
                    destination.next(ring[idx]);
                }
                destination.complete();
            }, TakeLastSubscriber;
        }(Subscriber.a), onRemoveSourceBuffers$ = compat.a.onRemoveSourceBuffers$, end_of_stream_onSourceOpen$ = compat.a.onSourceOpen$, onUpdate$ = compat.a.onUpdate$;
        /**
 * Get "updating" SourceBuffers from a SourceBufferList.
 * @param {SourceBufferList} sourceBuffers
 * @returns {Array.<SourceBuffer>}
 */
        function getUpdatingSourceBuffers(sourceBuffers) {
            for (var updatingSourceBuffers = [], i = 0; i < sourceBuffers.length; i++) {
                var SourceBuffer = sourceBuffers[i];
                SourceBuffer.updating && updatingSourceBuffers.push(SourceBuffer);
            }
            return updatingSourceBuffers;
        }
        /**
 * Trigger the `endOfStream` method of a MediaSource.
 *
 * If the MediaSource is ended/closed, do not call this method.
 * If SourceBuffers are updating, wait for them to be updated before closing
 * it.
 * @param {MediaSource} mediaSource
 * @returns {Observable}
 */        function triggerEndOfStream(mediaSource) {
            return Object(defer.a)(function() {
                if (log.a.debug("Init: Trying to call endOfStream"), "open" !== mediaSource.readyState) return log.a.debug("Init: MediaSource not open, cancel endOfStream"), 
                Object(of.a)(null);
                var sourceBuffers = mediaSource.sourceBuffers, updatingSourceBuffers = getUpdatingSourceBuffers(sourceBuffers);
                if (!updatingSourceBuffers.length) return log.a.info("Init: Triggering end of stream"), 
                mediaSource.endOfStream(), Object(of.a)(null);
                log.a.debug("Init: Waiting SourceBuffers to be updated before calling endOfStream.");
                var updatedSourceBuffers$ = updatingSourceBuffers.map(function(sourceBuffer) {
                    return onUpdate$(sourceBuffer).pipe(Object(take.a)(1));
                });
                return race(merge.a.apply(void 0, updatedSourceBuffers$).pipe(takeLast(1)), onRemoveSourceBuffers$(sourceBuffers).pipe(Object(take.a)(1))).pipe(Object(mergeMap.a)(function() {
                    return triggerEndOfStream(mediaSource);
                }));
            });
        }
        /**
 * Trigger the `endOfStream` method of a MediaSource each times it opens.
 * @see triggerEndOfStream
 * @param {MediaSource} mediaSource
 * @returns {Observable}
 */        function maintainEndOfStream(mediaSource) {
            return end_of_stream_onSourceOpen$(mediaSource).pipe(Object(startWith.a)(null), Object(switchMap.a)(function() {
                return triggerEndOfStream(mediaSource);
            }));
        }
        // EXTERNAL MODULE: ./src/core/init/get_stalled_events.ts
                var get_stalled_events = __webpack_require__(103), initial_seek_and_play = __webpack_require__(97), update_playback_rate = __webpack_require__(107);
        // EXTERNAL MODULE: ./src/core/init/initial_seek_and_play.ts
                // CONCATENATED MODULE: ./src/core/init/load_on_media_source.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Returns a function allowing to load or reload the content in arguments into
 * a single or multiple MediaSources.
 * @param {Object} args
 * @returns {Observable}
 */
        function createMediaSourceLoader(_ref) {
            var mediaElement = _ref.mediaElement, manifest = _ref.manifest, clock$ = _ref.clock$, speed$ = _ref.speed$, bufferOptions = _ref.bufferOptions, abrManager = _ref.abrManager, segmentPipelinesManager = _ref.segmentPipelinesManager;
            /**
   * Load the content on the given MediaSource.
   * @param {MediaSource} mediaSource
   * @param {number} initialTime
   * @param {boolean} autoPlay
   */            return function loadContentOnMediaSource(mediaSource, initialTime, autoPlay) {
                // TODO Update the duration if it evolves?
                var duration = manifest.getDuration();
                setDurationToMediaSource(mediaSource, null == duration ? Infinity : duration);
                var initialPeriod = manifest.getPeriodForTime(initialTime);
                if (null == initialPeriod) throw new media_error.a("MEDIA_STARTING_TIME_NOT_FOUND", "Wanted starting time not found in the Manifest.", !0);
 // Creates SourceBuffersManager allowing to create and keep track of a
                // single SourceBuffer per type.
                                var sourceBuffersManager = new source_buffers(mediaElement, mediaSource);
 // Initialize all native source buffers from the first period at the same
                // time.
                // We cannot lazily create native sourcebuffers since the spec does not
                // allow adding them during playback.
                //
                // From https://w3c.github.io/media-source/#methods
                //    For example, a user agent may throw a QuotaExceededError
                //    exception if the media element has reached the HAVE_METADATA
                //    readyState. This can occur if the user agent's media engine
                //    does not support adding more tracks during playback.
                                createNativeSourceBuffersForPeriod(sourceBuffersManager, initialPeriod);
                var _seekAndLoadOnMediaEv = Object(initial_seek_and_play.a)(clock$, mediaElement, initialTime, autoPlay), seek$ = _seekAndLoadOnMediaEv.seek$, load$ = _seekAndLoadOnMediaEv.load$, bufferClock$ = createBufferClock(manifest, clock$, seek$, speed$, initialTime), cancelEndOfStream$ = new Subject.a(), buffers$ = core_buffers({
                    manifest: manifest,
                    initialPeriod: initialPeriod
                }, bufferClock$, abrManager, sourceBuffersManager, segmentPipelinesManager, bufferOptions).pipe(Object(mergeMap.a)(function(evt) {
                    switch (evt.type) {
                      case "end-of-stream":
                        return log.a.debug("Init: end-of-stream order received."), maintainEndOfStream(mediaSource).pipe(Object(ignoreElements.a)(), Object(takeUntil.a)(cancelEndOfStream$));

                      case "resume-stream":
                        return log.a.debug("Init: resume-stream order received."), cancelEndOfStream$.next(null), 
                        empty.a;

                      case "discontinuity-encountered":
                        return source_buffers.isNative(evt.value.bufferType) && (log.a.warn("Init: Explicit discontinuity seek", evt.value.nextTime), 
                        mediaElement.currentTime = evt.value.nextTime), empty.a;

                      default:
                        return Object(of.a)(evt);
                    }
                })), playbackRate$ = Object(update_playback_rate.a)(mediaElement, speed$, clock$, {
                    pauseWhenStalled: !0
                }).pipe(Object(map.a)(events_generators.a.speedChanged)), stalled$ = Object(get_stalled_events.a)(mediaElement, clock$).pipe(Object(map.a)(events_generators.a.stalled)), loadedEvent$ = load$.pipe(Object(mergeMap.a)(function(evt) {
                    if ("autoplay-blocked" === evt) {
                        var error = new media_error.a("MEDIA_ERR_BLOCKED_AUTOPLAY", "Cannot trigger auto-play automatically: your browser does not allow it.", !1);
                        return Object(of.a)(events_generators.a.warning(error), events_generators.a.loaded());
                    }
                    if ("not-loaded-metadata" !== evt) return log.a.debug("Init: The current content is loaded."), 
                    Object(of.a)(events_generators.a.loaded());
                    var _error = new media_error.a("MEDIA_ERR_NOT_LOADED_METADATA", "Cannot load automatically: your browser falsely announced having loaded the content.", !1);
                    return Object(of.a)(events_generators.a.warning(_error));
                }));
                return Object(merge.a)(loadedEvent$, playbackRate$, stalled$, buffers$).pipe(finalize(function() {
                    // clean-up every created SourceBuffers
                    sourceBuffersManager.disposeAll();
                }));
            };
        }
        /**
 * Create all native SourceBuffers needed for a given Period.
 *
 * Native Buffers have the particulary to need to be created at the beginning of
 * the content.
 * Custom source buffers (entirely managed in JS) can generally be created and
 * disposed at will during the lifecycle of the content.
 * @param {SourceBuffersManager} sourceBuffersManager
 * @param {Period} period
 */        function createNativeSourceBuffersForPeriod(sourceBuffersManager, period) {
            Object.keys(period.adaptations).forEach(function(bufferType) {
                if (source_buffers.isNative(bufferType)) {
                    var adaptations = period.adaptations[bufferType] || [], representations = null != adaptations && adaptations.length ? adaptations[0].representations : [];
                    if (representations.length) {
                        var codec = representations[0].getMimeTypeString();
                        sourceBuffersManager.createSourceBuffer(bufferType, codec);
                    }
                }
            });
        }
        // EXTERNAL MODULE: ./src/core/init/throw_on_media_error.ts
                var throw_on_media_error = __webpack_require__(102);
        // CONCATENATED MODULE: ./src/core/init/initialize_media_source.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Returns pipeline options based on the global config and the user config.
 * @param {Object} networkConfig
 * @returns {Object}
 */        function getManifestPipelineOptions(networkConfig) {
            return {
                maxRetry: null != networkConfig.manifestRetry ? networkConfig.manifestRetry : config.a.DEFAULT_MAX_MANIFEST_REQUEST_RETRY,
                maxRetryOffline: null != networkConfig.offlineRetry ? networkConfig.offlineRetry : config.a.DEFAULT_MAX_PIPELINES_RETRY_ON_ERROR
            };
        }
        /**
 * Central part of the player.
 *
 * Play a content described by the given Manifest.
 *
 * On subscription:
 *  - Creates the MediaSource and attached sourceBuffers instances.
 *  - download the content's manifest
 *  - Perform EME management if needed
 *  - get Buffers for each active adaptations.
 *  - give choice of the adaptation to the caller (e.g. to choose a language)
 *  - returns Observable emitting notifications about the content lifecycle.
 * @param {Object} args
 * @returns {Observable}
 */        
        /**
 * Generate function reacting to playback events.
 * @param {Subject} reloadMediaSource$
 * @param {Function} refreshManifest
 * @returns {Function}
 */
        function createEventListener(reloadMediaSource$, refreshManifest) {
            /**
   * React to playback events.
   * @param {Object} evt
   * @returns {Observable}
   */
            return function onEvent(evt) {
                switch (evt.type) {
                  case "needs-media-source-reload":
                    reloadMediaSource$.next();
                    break;

                  case "needs-manifest-refresh":
                    return refreshManifest();
                }
                return Object(of.a)(evt);
            };
        }
        // CONCATENATED MODULE: ./src/core/init/index.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /* harmony default export */        var core_init = function InitializeOnMediaSource(_ref) {
            var adaptiveOptions = _ref.adaptiveOptions, autoPlay = _ref.autoPlay, bufferOptions = _ref.bufferOptions, clock$ = _ref.clock$, keySystems = _ref.keySystems, mediaElement = _ref.mediaElement, networkConfig = _ref.networkConfig, speed$ = _ref.speed$, startAt = _ref.startAt, textTrackOptions = _ref.textTrackOptions, pipelines = _ref.pipelines, url = _ref.url, warning$ = new Subject.a(), fetchManifest = throttle(pipelines_manifest(pipelines, getManifestPipelineOptions(networkConfig), warning$)), network$ = new Subject.a(), requestsInfos$ = new Subject.a(), segmentPipelinesManager = new pipelines_segment(pipelines, requestsInfos$, network$, warning$), abrManager = new abr(requestsInfos$, network$, adaptiveOptions), openMediaSource$ = openMediaSource(mediaElement).pipe(Object(observeOn.b)(asap.a), // to launch subscriptions only when all
            Object(share.a)()), emeManager$ = openMediaSource$.pipe(Object(mergeMap.a)(function() {
                return Object(create_eme_manager.a)(mediaElement, keySystems);
            }), Object(observeOn.b)(asap.a), // to launch subscriptions only when all
            Object(share.a)()), mediaError$ = Object(throw_on_media_error.a)(mediaElement), manifestRefreshed$ = new ReplaySubject.a(1), emeInitialized$ = emeManager$.pipe(Object(filter.a)(function(_ref2) {
                var type = _ref2.type;
                return "eme-init" === type || "eme-disabled" === type;
            }), Object(take.a)(1)), loadContent$ = Object(combineLatest.a)(openMediaSource$, fetchManifest(url), emeInitialized$).pipe(Object(mergeMap.a)(function(_ref3) {
                var mediaSource = _ref3[0], _ref3$ = _ref3[1], manifest = _ref3$.manifest, sendingTime = _ref3$.sendingTime;
                /**
     * Refresh the manifest on subscription.
     * @returns {Observable}
     */                function refreshManifest() {
                    var refreshURL = manifest.getUrl();
                    return refreshURL ? fetchManifest(refreshURL).pipe(Object(tap.a)(function(_ref4) {
                        var newManifest = _ref4.manifest, newSendingTime = _ref4.sendingTime;
                        manifest.update(newManifest), manifestRefreshed$.next({
                            manifest: manifest,
                            sendingTime: newSendingTime
                        });
                    }), Object(ignoreElements.a)(), Object(share.a)()) : (log.a.warn("Init: Cannot refresh the manifest: no url"), 
                    empty.a);
                }
                var loadOnMediaSource = createMediaSourceLoader({
                    mediaElement: mediaElement,
                    manifest: manifest,
                    clock$: clock$,
                    speed$: speed$,
                    abrManager: abrManager,
                    segmentPipelinesManager: segmentPipelinesManager,
                    bufferOptions: object_assign_default()({
                        textTrackOptions: textTrackOptions,
                        offlineRetry: networkConfig.offlineRetry,
                        segmentRetry: networkConfig.segmentRetry
                    }, bufferOptions)
                });
                log.a.debug("Init: Calculating initial time");
                var initialTime = getInitialTime(manifest, startAt);
                log.a.debug("Init: Initial time calculated:", initialTime);
                var reloadMediaSource$ = new Subject.a(), onEvent = createEventListener(reloadMediaSource$, refreshManifest), handleReloads$ = reloadMediaSource$.pipe(Object(switchMap.a)(function() {
                    var currentPosition = mediaElement.currentTime, isPaused = mediaElement.paused;
                    return openMediaSource(mediaElement).pipe(Object(mergeMap.a)(function(newMS) {
                        return loadOnMediaSource(newMS, currentPosition, !isPaused);
                    }), Object(mergeMap.a)(onEvent), Object(startWith.a)(events_generators.a.reloadingMediaSource()));
                })), loadOnMediaSource$ = Object(concat.a)(Object(of.a)(events_generators.a.manifestReady(abrManager, manifest)), loadOnMediaSource(mediaSource, initialTime, autoPlay).pipe(Object(takeUntil.a)(reloadMediaSource$), Object(mergeMap.a)(onEvent))), manifestAutoRefresh$ = manifestRefreshed$.pipe(Object(startWith.a)({
                    manifest: manifest,
                    sendingTime: sendingTime
                }), Object(switchMap.a)(function(_ref5) {
                    var newManifest = _ref5.manifest, newSendingTime = _ref5.sendingTime;
                    if (newManifest.lifetime) {
                        var timeSinceRequest = null == newSendingTime ? 0 : performance.now() - newSendingTime, updateTimeout = 1e3 * newManifest.lifetime - timeSinceRequest;
                        return Object(timer.a)(updateTimeout);
                    }
                    return empty.a;
                })).pipe(Object(mergeMap.a)(refreshManifest));
                return Object(merge.a)(loadOnMediaSource$, handleReloads$, manifestAutoRefresh$);
            }));
            return Object(merge.a)(loadContent$, mediaError$, emeManager$, warning$.pipe(Object(map.a)(events_generators.a.warning)));
        }, refCount = __webpack_require__(101);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/refCount.js
                // CONCATENATED MODULE: ./src/core/api/clock.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * This file defines a global clock for the RxPlayer.
 *
 * Each clock tick also pass informations about the current state of the
 * media element to sub-parts of the player.
 */
        function isMediaInfoState(state) {
            return "init" === state || "canplay" === state || "play" === state || "progress" === state || "seeking" === state || "seeked" === state || "loadedmetadata" === state || "ratechange" === state || "timeupdate" === state;
        }
        var SAMPLING_INTERVAL_MEDIASOURCE = config.a.SAMPLING_INTERVAL_MEDIASOURCE, SAMPLING_INTERVAL_NO_MEDIASOURCE = config.a.SAMPLING_INTERVAL_NO_MEDIASOURCE, RESUME_GAP_AFTER_SEEKING = config.a.RESUME_GAP_AFTER_SEEKING, RESUME_GAP_AFTER_NOT_ENOUGH_DATA = config.a.RESUME_GAP_AFTER_NOT_ENOUGH_DATA, RESUME_GAP_AFTER_BUFFERING = config.a.RESUME_GAP_AFTER_BUFFERING, STALL_GAP = config.a.STALL_GAP, SCANNED_MEDIA_ELEMENTS_EVENTS = [ "canplay", "play", "progress", "seeking", "seeked", "loadedmetadata", "ratechange" ];
        /**
 * HTMLMediaElement Events for which timings are calculated and emitted.
 * @type {Array.<string>}
 */        
        /**
 * Returns the amount of time in seconds the buffer should have ahead of the
 * current position before resuming playback. Based on the infos of the stall.
 * Waiting time differs between a "seeking" stall and a buffering stall.
 * @param {Object|null} stalled
 * @returns {Number}
 */
        function getResumeGap(stalled) {
            if (!stalled) return 0;
            switch (stalled.reason) {
              case "seeking":
                return RESUME_GAP_AFTER_SEEKING;

              case "not-ready":
                return RESUME_GAP_AFTER_NOT_ENOUGH_DATA;

              default:
                return RESUME_GAP_AFTER_BUFFERING;
            }
        }
        /**
 * @param {Object} currentRange
 * @param {Number} duration
 * @returns {Boolean}
 */        function hasLoadedUntilTheEnd(currentRange, duration) {
            return null != currentRange && duration - currentRange.end <= STALL_GAP;
        }
        /**
 * Generate a basic timings object from the media element and the eventName
 * which triggered the request.
 * @param {HTMLMediaElement} mediaElement
 * @param {string} currentState
 * @returns {Object}
 */        function getMediaInfos(mediaElement, currentState) {
            var buffered = mediaElement.buffered, currentTime = mediaElement.currentTime, duration = mediaElement.duration, ended = mediaElement.ended, paused = mediaElement.paused, playbackRate = mediaElement.playbackRate, readyState = mediaElement.readyState, seeking = mediaElement.seeking;
            return {
                bufferGap: Object(utils_ranges.c)(buffered, currentTime),
                buffered: buffered,
                currentRange: Object(utils_ranges.f)(buffered, currentTime),
                currentTime: currentTime,
                duration: duration,
                ended: ended,
                paused: paused,
                playbackRate: playbackRate,
                readyState: readyState,
                seeking: seeking,
                state: currentState
            };
        }
        /**
 * Infer stalled status of the media based on:
 *   - the return of the function getMediaInfos
 *   - the previous timings object.
 *
 * @param {Object} prevTimings - Previous timings object. See function to know
 * the different properties needed.
 * @param {Object} currentTimings - Current timings object. This does not need
 * to have every single infos, see function to know which properties are needed.
 * @param {Boolean} withMediaSource - False if the directfile API is used.
 * @returns {Object|null}
 */        function getStalledStatus(prevTimings, currentTimings, withMediaSource) {
            var shouldStall, shouldUnstall, currentState = currentTimings.state, currentTime = currentTimings.currentTime, bufferGap = currentTimings.bufferGap, currentRange = currentTimings.currentRange, duration = currentTimings.duration, paused = currentTimings.paused, readyState = currentTimings.readyState, ended = currentTimings.ended, prevStalled = prevTimings.stalled, prevState = prevTimings.state, prevTime = prevTimings.currentTime, fullyLoaded = hasLoadedUntilTheEnd(currentRange, duration), canStall = 1 <= readyState && "loadedmetadata" !== currentState && !prevStalled && !(fullyLoaded || ended);
            return withMediaSource ? canStall && (bufferGap <= STALL_GAP || Infinity === bufferGap || 1 === readyState) ? shouldStall = !0 : prevStalled && 1 < readyState && bufferGap < Infinity && (bufferGap > getResumeGap(prevStalled) || fullyLoaded || ended) && (shouldUnstall = !0) : canStall && (!paused && "timeupdate" === currentState && "timeupdate" === prevState && currentTime === prevTime || "seeking" === currentState && Infinity === bufferGap) ? shouldStall = !0 : prevStalled && ("seeking" !== currentState && currentTime !== prevTime || "canplay" === currentState || bufferGap < Infinity && (bufferGap > getResumeGap(prevStalled) || fullyLoaded || ended)) && (shouldUnstall = !0), 
            shouldStall ? {
                reason: "seeking" === currentState || currentTimings.seeking ? "seeking" : 1 === readyState ? "not-ready" : "buffering",
                timestamp: performance.now()
            } : shouldUnstall ? null : prevStalled;
        }
        /**
 * Timings observable.
 *
 * This Observable samples snapshots of player's current state:
 *   * time position
 *   * playback rate
 *   * current buffered range
 *   * gap with current buffered range ending
 *   * media duration
 *
 * In addition to sampling, this Observable also reacts to "seeking" and "play"
 * events.
 *
 * Observable is shared for performance reason: reduces the number of event
 * listeners and intervals/timeouts but also limit access to the media element
 * properties and gap calculations.
 *
 * The sampling is manual instead of based on "timeupdate" to reduce the
 * number of events.
 * @param {HTMLMediaElement} mediaElement
 * @param {Object} options
 * @returns {Observable}
 */        
        /* harmony default export */ var api_clock = function createClock(mediaElement, _ref) {
            var withMediaSource = _ref.withMediaSource;
            return new Observable.a(function(obs) {
                var lastTimings = object_assign_default()(getMediaInfos(mediaElement, "init"), {
                    stalled: null
                });
                /**
     * Emit timings sample.
     * Meant to be used as a callback on various async events.
     * @param {Event} [evt] - The Event which triggered the callback, if one.
     */                function emitSample(evt) {
                    var state = evt && isMediaInfoState(evt.type) ? evt.type : "timeupdate", mediaTimings = getMediaInfos(mediaElement, state), stalledState = getStalledStatus(lastTimings, mediaTimings, withMediaSource);
                    // /!\ Mutate mediaTimings
                    lastTimings = object_assign_default()(mediaTimings, {
                        stalled: stalledState
                    }), log.a.debug("API: new clock tick", lastTimings), obs.next(lastTimings);
                }
                var intervalID = setInterval(emitSample, withMediaSource ? SAMPLING_INTERVAL_MEDIASOURCE : SAMPLING_INTERVAL_NO_MEDIASOURCE);
                return SCANNED_MEDIA_ELEMENTS_EVENTS.forEach(function(eventName) {
                    return mediaElement.addEventListener(eventName, emitSample);
                }), obs.next(lastTimings), function() {
                    clearInterval(intervalID), SCANNED_MEDIA_ELEMENTS_EVENTS.forEach(function(eventName) {
                        return mediaElement.removeEventListener(eventName, emitSample);
                    });
                };
            }).pipe(Object(multicast.a)(function() {
                return new ReplaySubject.a(1);
            }), // Always emit the last
            Object(refCount.a)());
        };
        // CONCATENATED MODULE: ./src/core/api/from_wallclock_time.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Translate "wall-clock time" in ms (time since unix epoch without counting
 * leap seconds a.k.a. unix time a.k.a. Date.now()), into the real media time of
 * the content.
 * @param {number} timeInMs - Wall-clock time in milliseconds
 * @param {Object} manifest - Manifest describing the current content
 * @returns {number} - Real media time you can seek to to be at that wall-clock
 * time.
 */        function fromWallClockTime(timeInMs, manifest) {
            return normalizeWallClockTime(timeInMs, manifest) / 1e3 - (manifest.availabilityStartTime || 0);
        }
        /**
 * Bound the given "wall-clock time" in ms (unix time) to the time limits of the
 * content as described by the Manifest.
 * @param {number}
 * @param {Object} manifest - Manifest describing the current content
 * @returns {number}
 */        function normalizeWallClockTime(timeInMs, manifest) {
            if (!manifest.isLive) return +timeInMs;
            var spd = manifest.suggestedPresentationDelay || 0, plg = manifest.presentationLiveGap || 0, tsbd = manifest.timeShiftBufferDepth, now = Date.now(), max = now - 1e3 * (plg + spd), min = null == tsbd ? manifest.minimumTime || manifest.availabilityStartTime || 0 : now - 1e3 * tsbd;
            return Math.max(Math.min(timeInMs, max), min);
        }
        // CONCATENATED MODULE: ./src/core/api/get_player_state.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        var FORCED_ENDED_THRESHOLD = config.a.FORCED_ENDED_THRESHOLD, PLAYER_STATES_STOPPED = "STOPPED", PLAYER_STATES_LOADED = "LOADED", PLAYER_STATES_LOADING = "LOADING", PLAYER_STATES_PLAYING = "PLAYING", PLAYER_STATES_PAUSED = "PAUSED", PLAYER_STATES_ENDED = "ENDED", PLAYER_STATES_BUFFERING = "BUFFERING", PLAYER_STATES_SEEKING = "SEEKING", PLAYER_STATES_RELOADING = "RELOADING";
        /**
 * Player state dictionnary
 * @type {Object}
 */        
        /**
 * Get state string for a _loaded_ content.
 * @param {HTMLMediaElement} mediaElement
 * @param {boolean} isPlaying - false when the player is paused. true otherwise.
 * @param {Object} stalledStatus - Current stalled state:
 *   - null when not stalled
 *   - an object with a description of the situation if stalled.
 * @returns {string}
 */
        function getLoadedContentState(mediaElement, isPlaying, stalledStatus) {
            if (mediaElement.ended) return PLAYER_STATES_ENDED;
            if (stalledStatus) {
                // On some old browsers (e.g. Chrome 54), the browser does not
                // emit an 'ended' event in some conditions. Detect if we
                // reached the end by comparing the current position and the
                // duration instead.
                var gapBetweenDurationAndCurrentTime = Math.abs(mediaElement.duration - mediaElement.currentTime);
                return null != FORCED_ENDED_THRESHOLD && gapBetweenDurationAndCurrentTime < FORCED_ENDED_THRESHOLD ? PLAYER_STATES_ENDED : "seeking" === stalledStatus.reason ? PLAYER_STATES_SEEKING : PLAYER_STATES_BUFFERING;
            }
            return isPlaying ? PLAYER_STATES_PLAYING : PLAYER_STATES_PAUSED;
        }
        // EXTERNAL MODULE: ./src/utils/languages/normalize.ts + 2 modules
                var normalize = __webpack_require__(78), DEFAULT_AUTO_PLAY = config.a.DEFAULT_AUTO_PLAY, DEFAULT_INITIAL_BITRATES = config.a.DEFAULT_INITIAL_BITRATES, DEFAULT_LIMIT_VIDEO_WIDTH = config.a.DEFAULT_LIMIT_VIDEO_WIDTH, DEFAULT_MANUAL_BITRATE_SWITCHING_MODE = config.a.DEFAULT_MANUAL_BITRATE_SWITCHING_MODE, DEFAULT_MAX_BITRATES = config.a.DEFAULT_MAX_BITRATES, DEFAULT_MAX_BUFFER_AHEAD = config.a.DEFAULT_MAX_BUFFER_AHEAD, DEFAULT_MAX_BUFFER_BEHIND = config.a.DEFAULT_MAX_BUFFER_BEHIND, DEFAULT_SHOW_NATIVE_SUBTITLE = config.a.DEFAULT_SHOW_NATIVE_SUBTITLE, DEFAULT_STOP_AT_END = config.a.DEFAULT_STOP_AT_END, DEFAULT_TEXT_TRACK_MODE = config.a.DEFAULT_TEXT_TRACK_MODE, DEFAULT_THROTTLE_WHEN_HIDDEN = config.a.DEFAULT_THROTTLE_WHEN_HIDDEN, DEFAULT_WANTED_BUFFER_AHEAD = config.a.DEFAULT_WANTED_BUFFER_AHEAD;
        // CONCATENATED MODULE: ./src/core/api/option_parsers.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * This file exports various helpers to parse options given to various APIs,
 * throw if something is wrong, and return a normalized option object.
 */        
        /**
 * Parse options given to the API constructor and set default options as found
 * in the config.
 *
 * Do not mutate anything, only cross the given options and sane default options
 * (most coming from the config).
 * @param {Object|undefined} options
 * @returns {Object}
 */
        function parseConstructorOptions(options) {
            var maxBufferAhead, maxBufferBehind, wantedBufferAhead, limitVideoWidth, throttleWhenHidden, preferredAudioTracks, preferredTextTracks, videoElement, initialVideoBitrate, initialAudioBitrate, maxAudioBitrate, maxVideoBitrate;
            if (null == options.maxBufferAhead) maxBufferAhead = DEFAULT_MAX_BUFFER_AHEAD; else if (maxBufferAhead = Number(options.maxBufferAhead), 
            isNaN(maxBufferAhead)) throw new Error("Invalid maxBufferAhead parameter. Should be a number.");
            if (null == options.maxBufferBehind) maxBufferBehind = DEFAULT_MAX_BUFFER_BEHIND; else if (maxBufferBehind = Number(options.maxBufferBehind), 
            isNaN(maxBufferBehind)) throw new Error("Invalid maxBufferBehind parameter. Should be a number.");
            if (null == options.wantedBufferAhead) wantedBufferAhead = DEFAULT_WANTED_BUFFER_AHEAD; else if (wantedBufferAhead = Number(options.wantedBufferAhead), 
            isNaN(wantedBufferAhead)) 
            /* tslint:disable:max-line-length */
            throw new Error("Invalid wantedBufferAhead parameter. Should be a number.");
            /* tslint:enable:max-line-length */            if (limitVideoWidth = null == options.limitVideoWidth ? DEFAULT_LIMIT_VIDEO_WIDTH : !!options.limitVideoWidth, 
            throttleWhenHidden = null == options.throttleWhenHidden ? DEFAULT_THROTTLE_WHEN_HIDDEN : !!options.throttleWhenHidden, 
            preferredAudioTracks = null == options.preferredAudioTracks ? [] : options.preferredAudioTracks, 
            preferredTextTracks = null == options.preferredTextTracks ? [] : options.preferredTextTracks, 
            null == options.videoElement) videoElement = document.createElement("video"); else {
                if (!(options.videoElement instanceof HTMLMediaElement)) 
                /* tslint:disable:max-line-length */
                throw new Error("Invalid videoElement parameter. Should be a HTMLMediaElement.");
                /* tslint:enable:max-line-length */                videoElement = options.videoElement;
            }
            if (null == options.initialVideoBitrate) initialVideoBitrate = DEFAULT_INITIAL_BITRATES.video; else if (initialVideoBitrate = Number(options.initialVideoBitrate), 
            isNaN(initialVideoBitrate)) 
            /* tslint:disable:max-line-length */
            throw new Error("Invalid initialVideoBitrate parameter. Should be a number.");
            /* tslint:enable:max-line-length */            if (null == options.initialAudioBitrate) initialAudioBitrate = DEFAULT_INITIAL_BITRATES.audio; else if (initialAudioBitrate = Number(options.initialAudioBitrate), 
            isNaN(initialAudioBitrate)) 
            /* tslint:disable:max-line-length */
            throw new Error("Invalid initialAudioBitrate parameter. Should be a number.");
            /* tslint:enable:max-line-length */            if (null == options.maxVideoBitrate) maxVideoBitrate = DEFAULT_MAX_BITRATES.video; else if (maxVideoBitrate = Number(options.maxVideoBitrate), 
            isNaN(maxVideoBitrate)) throw new Error("Invalid maxVideoBitrate parameter. Should be a number.");
            if (null == options.maxAudioBitrate) maxAudioBitrate = DEFAULT_MAX_BITRATES.audio; else if (maxAudioBitrate = Number(options.maxAudioBitrate), 
            isNaN(maxAudioBitrate)) throw new Error("Invalid maxAudioBitrate parameter. Should be a number.");
            return {
                maxBufferAhead: maxBufferAhead,
                maxBufferBehind: maxBufferBehind,
                limitVideoWidth: limitVideoWidth,
                videoElement: videoElement,
                wantedBufferAhead: wantedBufferAhead,
                throttleWhenHidden: throttleWhenHidden,
                preferredAudioTracks: preferredAudioTracks,
                preferredTextTracks: preferredTextTracks,
                initialAudioBitrate: initialAudioBitrate,
                initialVideoBitrate: initialVideoBitrate,
                maxAudioBitrate: maxAudioBitrate,
                maxVideoBitrate: maxVideoBitrate,
                stopAtEnd: null == options.stopAtEnd ? DEFAULT_STOP_AT_END : !!options.stopAtEnd
            };
        }
        /**
 * Parse options given to loadVideo and set default options as found
 * in the config.
 *
 * Do not mutate anything, only cross the given options and sane default options
 * (most coming from the config).
 *
 * Throws if any mandatory option is not set.
 * @param {Object|undefined} options
 * @param {Object} ctx - The player context, needed for some default values.
 * @returns {Object}
 */        function parseLoadVideoOptions(options) {
            var url, transport, keySystems, supplementaryTextTracks, supplementaryImageTracks, textTrackMode, textTrackElement, startAt;
            if (!options || null == options.url) throw new Error("No url set on loadVideo");
            if (url = String(options.url), null == options.transport) throw new Error("No transport set on loadVideo");
            transport = String(options.transport);
            var autoPlay = null == options.autoPlay ? DEFAULT_AUTO_PLAY : !!options.autoPlay;
            if (null == options.keySystems) keySystems = []; else {
                var _iterator = keySystems = Array.isArray(options.keySystems) ? options.keySystems : [ options.keySystems ], _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    var keySystem = _ref;
                    if ("string" != typeof keySystem.type || "function" != typeof keySystem.getLicense) throw new Error("Invalid key system given: Missing type string or getLicense callback");
                }
            }
            var transportOptions = options.transportOptions || {};
            if (null == options.supplementaryTextTracks) supplementaryTextTracks = []; else {
                var _iterator2 = supplementaryTextTracks = Array.isArray(options.supplementaryTextTracks) ? options.supplementaryTextTracks : [ options.supplementaryTextTracks ], _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                    var _ref2;
                    if (_isArray2) {
                        if (_i2 >= _iterator2.length) break;
                        _ref2 = _iterator2[_i2++];
                    } else {
                        if ((_i2 = _iterator2.next()).done) break;
                        _ref2 = _i2.value;
                    }
                    var supplementaryTextTrack = _ref2;
                    if ("boolean" != typeof supplementaryTextTrack.closedCaption && (supplementaryTextTrack.closedCaption = !!supplementaryTextTrack.closedCaption), 
                    "string" != typeof supplementaryTextTrack.language || "string" != typeof supplementaryTextTrack.mimeType || "string" != typeof supplementaryTextTrack.url) 
                    /* tslint:disable:max-line-length */
                    throw new Error("Invalid supplementary text track given. Missing either language, mimetype or url");
                    /* tslint:enable:max-line-length */                }
            }
            if (null == options.supplementaryImageTracks) supplementaryImageTracks = []; else {
                var _iterator3 = supplementaryImageTracks = Array.isArray(options.supplementaryImageTracks) ? options.supplementaryImageTracks : [ options.supplementaryImageTracks ], _isArray3 = Array.isArray(_iterator3), _i3 = 0;
                for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                    var _ref3;
                    if (_isArray3) {
                        if (_i3 >= _iterator3.length) break;
                        _ref3 = _iterator3[_i3++];
                    } else {
                        if ((_i3 = _iterator3.next()).done) break;
                        _ref3 = _i3.value;
                    }
                    var supplementaryImageTrack = _ref3;
                    if ("string" != typeof supplementaryImageTrack.mimeType || "string" != typeof supplementaryImageTrack.url) 
                    /* tslint:disable:max-line-length */
                    throw new Error("Invalid supplementary image track given. Missing either mimetype or url");
                    /* tslint:enable:max-line-length */                }
            }
            if (null == options.textTrackMode) textTrackMode = DEFAULT_TEXT_TRACK_MODE; else {
                if ("native" !== options.textTrackMode && "html" !== options.textTrackMode) throw new Error("Invalid textTrackMode.");
                textTrackMode = options.textTrackMode;
            }
            null != options.defaultAudioTrack && Object(warn_once.a)("The `defaultAudioTrack` loadVideo option is deprecated.\nPlease use the `preferredAudioTracks` constructor option or the`setPreferredAudioTracks` method instead");
            var defaultAudioTrack = Object(normalize.b)(options.defaultAudioTrack);
            null != options.defaultTextTrack && Object(warn_once.a)("The `defaultTextTrack` loadVideo option is deprecated.\nPlease use the `preferredTextTracks` constructor option or the`setPreferredTextTracks` method instead");
            var defaultTextTrack = Object(normalize.c)(options.defaultTextTrack), hideNativeSubtitle = null == options.hideNativeSubtitle ? !DEFAULT_SHOW_NATIVE_SUBTITLE : !!options.hideNativeSubtitle, manualBitrateSwitchingMode = null == options.manualBitrateSwitchingMode ? !DEFAULT_MANUAL_BITRATE_SWITCHING_MODE : options.manualBitrateSwitchingMode;
            if ("html" === textTrackMode) {
                // TODO Better way to express that in TypeScript?
                if (null == options.textTrackElement) 
                /* tslint:disable:max-line-length */
                throw new Error('You have to provide a textTrackElement in "html" textTrackMode.');
                /* tslint:enable:max-line-length */                if (!(options.textTrackElement instanceof HTMLElement)) throw new Error("textTrackElement should be an HTMLElement.");
                textTrackElement = options.textTrackElement;
            } else null != options.textTrackElement && 
            /* tslint:disable:max-line-length */
            log.a.warn('API: You have set a textTrackElement without being in an "html" textTrackMode. It will be ignored.');
            if (null != options.startAt) 
            // TODO Better way to express that in TypeScript?
            if (options.startAt.wallClockTime instanceof Date) {
                var wallClockTime = options.startAt.wallClockTime.getTime() / 1e3;
                startAt = object_assign_default()({}, options.startAt, {
                    wallClockTime: wallClockTime
                });
            } else startAt = options.startAt;
            // TODO without cast
            /* tslint:disable no-object-literal-type-assertion */
            return {
                autoPlay: autoPlay,
                defaultAudioTrack: defaultAudioTrack,
                defaultTextTrack: defaultTextTrack,
                hideNativeSubtitle: hideNativeSubtitle,
                keySystems: keySystems,
                manualBitrateSwitchingMode: manualBitrateSwitchingMode,
                networkConfig: null == options.networkConfig ? {} : {
                    manifestRetry: options.networkConfig.manifestRetry,
                    offlineRetry: options.networkConfig.offlineRetry,
                    segmentRetry: options.networkConfig.segmentRetry
                },
                startAt: startAt,
                supplementaryImageTracks: supplementaryImageTracks,
                supplementaryTextTracks: supplementaryTextTracks,
                textTrackElement: textTrackElement,
                textTrackMode: textTrackMode,
                transport: transport,
                transportOptions: transportOptions,
                url: url
            };
            /* tslint:enable no-object-literal-type-assertion */        }
        // EXTERNAL MODULE: ./src/utils/languages/index.ts
                var languages = __webpack_require__(64);
        // CONCATENATED MODULE: ./src/core/api/track_manager.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {Array.<Object>}
 * @returns {Array.<Object>}
 */        function normalizeAudioTracks(tracks) {
            return tracks.map(function(t) {
                return t && {
                    normalized: Object(languages.a)(t.language),
                    audioDescription: t.audioDescription
                };
            });
        }
        /**
 * @param {Array.<Object>}
 * @returns {Array.<Object>}
 */        function normalizeTextTracks(tracks) {
            return tracks.map(function(t) {
                return t && {
                    normalized: Object(languages.a)(t.language),
                    closedCaption: t.closedCaption
                };
            });
        }
        /**
 * Manage audio and text tracks for all active periods.
 * Chose the audio and text tracks for each period and record this choice.
 * @class TrackManager
 */        var track_manager_TrackManager = 
        /* */
        function() {
            /**
   * @param {Object} defaults
   */
            function TrackManager(defaults) {
                var preferredAudioTracks = defaults.preferredAudioTracks, preferredTextTracks = defaults.preferredTextTracks;
                this._periods = new sorted_list_SortedList(function(a, b) {
                    return a.period.start - b.period.start;
                }), this._audioChoiceMemory = new WeakMap(), this._textChoiceMemory = new WeakMap(), 
                this._videoChoiceMemory = new WeakMap(), this._preferredAudioTracks = preferredAudioTracks, 
                this._preferredTextTracks = preferredTextTracks;
            }
            /**
   * Add Subject to choose Adaptation for new "audio" or "text" Period.
   * @param {string} bufferType
   * @param {Period} period
   * @param {Subject} adaptations
   */            var _proto = TrackManager.prototype;
            return _proto.addPeriod = function addPeriod(bufferType, period, adaptation$) {
                var periodItem = getPeriodItem(this._periods, period);
                if (null != periodItem) {
                    if (null != periodItem[bufferType]) return void log.a.warn("TrackManager: " + bufferType + " already added for period", period);
                    periodItem[bufferType] = {
                        adaptations: period.adaptations[bufferType] || [],
                        adaptation$: adaptation$
                    };
                } else {
                    var _this$_periods$add;
                    this._periods.add(((_this$_periods$add = {
                        period: period
                    })[bufferType] = {
                        adaptations: period.adaptations[bufferType] || [],
                        adaptation$: adaptation$
                    }, _this$_periods$add));
                }
            }
            /**
   * Remove Subject to choose an "audio" or "text" Adaptation for a Period.
   * @param {string} bufferType
   * @param {Period} period
   */ , _proto.removePeriod = function removePeriod(bufferType, period) {
                var periodIndex = findPeriodIndex(this._periods, period);
                if (null != periodIndex) {
                    var periodItem = this._periods.get(periodIndex);
                    null != periodItem[bufferType] ? (delete periodItem[bufferType], null == periodItem.audio && null == periodItem.text && this._periods.removeElement(periodItem)) : log.a.warn("TrackManager: " + bufferType + " already removed for period", period);
                } else log.a.warn("TrackManager: " + bufferType + " not found for period", period);
            }, _proto.resetPeriods = function resetPeriods() {
                for (;0 < this._periods.length(); ) this._periods.pop();
            }
            /**
   * Update the choice of all added Periods based on:
   *   1. What was the last chosen adaptation
   *   2. If not found, the preferences
   */ , _proto.update = function update() {
                this._updateAudioTrackChoices(), this._updateTextTrackChoices(), this._updateVideoTrackChoices();
            }
            /**
   * Emit initial audio Adaptation through the given Subject based on:
   *   - the preferred audio tracks
   *   - the last choice for this period, if one
   * @param {Period} period
   *
   * @throws Error - Throws if the period given has not been added
   */ , _proto.setInitialAudioTrack = function setInitialAudioTrack(period) {
                var periodItem = getPeriodItem(this._periods, period), audioInfos = periodItem && periodItem.audio;
                if (!audioInfos || !periodItem) throw new Error("TrackManager: Given Period not found.");
                var preferredAudioTracks = this._preferredAudioTracks.getValue(), audioAdaptations = period.adaptations.audio || [], chosenAudioAdaptation = this._audioChoiceMemory.get(period);
                if (void 0 !== chosenAudioAdaptation && Object(array_includes.a)(audioAdaptations, chosenAudioAdaptation)) audioInfos.adaptation$.next(chosenAudioAdaptation); else {
                    var optimalAdaptation = findFirstOptimalAudioAdaptation(audioAdaptations, normalizeAudioTracks(preferredAudioTracks));
                    this._audioChoiceMemory.set(period, optimalAdaptation), audioInfos.adaptation$.next(optimalAdaptation);
                }
            }
            /**
   * Emit initial text Adaptation through the given Subject based on:
   *   - the preferred text tracks
   *   - the last choice for this period, if one
   * @param {Period} period
   *
   * @throws Error - Throws if the period given has not been added
   */ , _proto.setInitialTextTrack = function setInitialTextTrack(period) {
                var periodItem = getPeriodItem(this._periods, period), textInfos = periodItem && periodItem.text;
                if (!textInfos || !periodItem) throw new Error("TrackManager: Given Period not found.");
                var preferredTextTracks = this._preferredTextTracks.getValue(), textAdaptations = period.adaptations.text || [], chosenTextAdaptation = this._textChoiceMemory.get(period);
                if (void 0 !== chosenTextAdaptation && Object(array_includes.a)(textAdaptations, chosenTextAdaptation)) textInfos.adaptation$.next(chosenTextAdaptation); else {
                    var optimalAdaptation = findFirstOptimalTextAdaptation(textAdaptations, normalizeTextTracks(preferredTextTracks));
                    this._textChoiceMemory.set(period, optimalAdaptation), textInfos.adaptation$.next(optimalAdaptation);
                }
            }
            /**
   * Emit initial video Adaptation through the given Subject based on:
   *   - the preferred video tracks
   *   - the last choice for this period, if one
   * @param {Period} period
   *
   * @throws Error - Throws if the period given has not been added
   */ , _proto.setInitialVideoTrack = function setInitialVideoTrack(period) {
                var periodItem = getPeriodItem(this._periods, period), videoInfos = periodItem && periodItem.video;
                if (!videoInfos || !periodItem) throw new Error("TrackManager: Given Period not found.");
                var videoAdaptations = period.adaptations.video || [], chosenVideoAdaptation = this._videoChoiceMemory.get(period);
                if (void 0 !== chosenVideoAdaptation && Object(array_includes.a)(videoAdaptations, chosenVideoAdaptation)) videoInfos.adaptation$.next(chosenVideoAdaptation); else {
                    var optimalAdaptation = videoAdaptations[0];
                    this._videoChoiceMemory.set(period, optimalAdaptation), videoInfos.adaptation$.next(optimalAdaptation);
                }
            }
            /**
   * Set audio track based on the ID of its adaptation for a given added Period.
   *
   * @param {Period} period - The concerned Period.
   * @param {string} wantedId - adaptation id of the wanted track
   *
   * @throws Error - Throws if the period given has not been added
   * @throws Error - Throws if the given id is not found in any audio adaptation
   * of the given Period.
   */ , _proto.setAudioTrackByID = function setAudioTrackByID(period, wantedId) {
                var periodItem = getPeriodItem(this._periods, period), audioInfos = periodItem && periodItem.audio;
                if (!audioInfos) throw new Error("TrackManager: Given Period not found.");
                var wantedAdaptation = Object(array_find.a)(audioInfos.adaptations, function(_ref) {
                    return _ref.id === wantedId;
                });
                if (void 0 === wantedAdaptation) throw new Error("Audio Track not found.");
                this._audioChoiceMemory.get(period) !== wantedAdaptation && (this._audioChoiceMemory.set(period, wantedAdaptation), 
                audioInfos.adaptation$.next(wantedAdaptation));
            }
            /**
   * Set text track based on the ID of its adaptation for a given added Period.
   *
   * @param {Period} period - The concerned Period.
   * @param {string} wantedId - adaptation id of the wanted track
   *
   * @throws Error - Throws if the period given has not been added
   * @throws Error - Throws if the given id is not found in any text adaptation
   * of the given Period.
   */ , _proto.setTextTrackByID = function setTextTrackByID(period, wantedId) {
                var periodItem = getPeriodItem(this._periods, period), textInfos = periodItem && periodItem.text;
                if (!textInfos) throw new Error("TrackManager: Given Period not found.");
                var wantedAdaptation = Object(array_find.a)(textInfos.adaptations, function(_ref2) {
                    return _ref2.id === wantedId;
                });
                if (void 0 === wantedAdaptation) throw new Error("Text Track not found.");
                this._textChoiceMemory.get(period) !== wantedAdaptation && (this._textChoiceMemory.set(period, wantedAdaptation), 
                textInfos.adaptation$.next(wantedAdaptation));
            }
            /**
   * Set video track based on the ID of its adaptation for a given added Period.
   *
   * @param {Period} period - The concerned Period.
   * @param {string} wantedId - adaptation id of the wanted track
   *
   * @throws Error - Throws if the period given has not been added
   * @throws Error - Throws if the given id is not found in any video adaptation
   * of the given Period.
   */ , _proto.setVideoTrackByID = function setVideoTrackByID(period, wantedId) {
                var periodItem = getPeriodItem(this._periods, period), videoInfos = periodItem && periodItem.video;
                if (!videoInfos) throw new Error("LanguageManager: Given Period not found.");
                var wantedAdaptation = Object(array_find.a)(videoInfos.adaptations, function(_ref3) {
                    return _ref3.id === wantedId;
                });
                if (void 0 === wantedAdaptation) throw new Error("Video Track not found.");
                this._videoChoiceMemory.get(period) !== wantedAdaptation && (this._videoChoiceMemory.set(period, wantedAdaptation), 
                videoInfos.adaptation$.next(wantedAdaptation));
            }
            /**
   * Disable the given audio track for a given Period.
   *
   * @param {Period} period - The concerned Period.
   *
   * @throws Error - Throws if the period given has not been added
   */ , _proto.disableAudioTrack = function disableAudioTrack(period) {
                var periodItem = getPeriodItem(this._periods, period), audioInfos = periodItem && periodItem.audio;
                if (!audioInfos) throw new Error("TrackManager: Given Period not found.");
                null !== this._audioChoiceMemory.get(period) && (this._audioChoiceMemory.set(period, null), 
                audioInfos.adaptation$.next(null));
            }
            /**
   * Disable the current text track for a given period.
   *
   * @param {Period} period - The concerned Period.
   *
   * @throws Error - Throws if the period given has not been added
   */ , _proto.disableTextTrack = function disableTextTrack(period) {
                var periodItem = getPeriodItem(this._periods, period), textInfos = periodItem && periodItem.text;
                if (!textInfos) throw new Error("TrackManager: Given Period not found.");
                null !== this._textChoiceMemory.get(period) && (this._textChoiceMemory.set(period, null), 
                textInfos.adaptation$.next(null));
            }
            /**
   * Returns an object describing the chosen audio track for the given audio
   * Period.
   *
   * Returns null is the the current audio track is disabled or not
   * set yet.
   *
   * @param {Period} period
   * @returns {Object|null}
   */ , _proto.getChosenAudioTrack = function getChosenAudioTrack(period) {
                var periodItem = getPeriodItem(this._periods, period);
                if (null == (periodItem && periodItem.audio)) return null;
                var chosenAudioAdaptation = this._audioChoiceMemory.get(period);
                return chosenAudioAdaptation ? {
                    language: chosenAudioAdaptation.language || "",
                    normalized: chosenAudioAdaptation.normalizedLanguage || "",
                    audioDescription: !!chosenAudioAdaptation.isAudioDescription,
                    id: chosenAudioAdaptation.id
                } : null;
            }
            /**
   * Returns an object describing the chosen text track for the given text
   * Period.
   *
   * Returns null is the the current text track is disabled or not
   * set yet.
   *
   * @param {Period} period
   * @returns {Object|null}
   */ , _proto.getChosenTextTrack = function getChosenTextTrack(period) {
                var periodItem = getPeriodItem(this._periods, period);
                if (null == (periodItem && periodItem.text)) return null;
                var chosenTextAdaptation = this._textChoiceMemory.get(period);
                return chosenTextAdaptation ? {
                    language: chosenTextAdaptation.language || "",
                    normalized: chosenTextAdaptation.normalizedLanguage || "",
                    closedCaption: !!chosenTextAdaptation.isClosedCaption,
                    id: chosenTextAdaptation.id
                } : null;
            }
            /**
   * Returns an object describing the chosen video track for the given video
   * Period.
   *
   * Returns null is the the current video track is disabled or not
   * set yet.
   *
   * @param {Period} period
   * @returns {Object|null}
   */ , _proto.getChosenVideoTrack = function getChosenVideoTrack(period) {
                var periodItem = getPeriodItem(this._periods, period);
                if (null == (periodItem && periodItem.video)) return null;
                var chosenVideoAdaptation = this._videoChoiceMemory.get(period);
                return chosenVideoAdaptation ? {
                    id: chosenVideoAdaptation.id,
                    representations: chosenVideoAdaptation.representations.map(parseVideoRepresentation)
                } : null;
            }
            /**
   * Returns all available audio tracks for a given Period, as an array of
   * objects.
   *
   * @returns {Array.<Object>}
   */ , _proto.getAvailableAudioTracks = function getAvailableAudioTracks(period) {
                var periodItem = getPeriodItem(this._periods, period), audioInfos = periodItem && periodItem.audio;
                if (null == audioInfos) return [];
                var chosenAudioAdaptation = this._audioChoiceMemory.get(period), currentId = chosenAudioAdaptation && chosenAudioAdaptation.id;
                return audioInfos.adaptations.map(function(adaptation) {
                    return {
                        language: adaptation.language || "",
                        normalized: adaptation.normalizedLanguage || "",
                        audioDescription: !!adaptation.isAudioDescription,
                        id: adaptation.id,
                        active: null != currentId && currentId === adaptation.id
                    };
                });
            }
            /**
   * Returns all available text tracks for a given Period, as an array of
   * objects.
   *
   * @param {Period} period
   * @returns {Array.<Object>}
   */ , _proto.getAvailableTextTracks = function getAvailableTextTracks(period) {
                var periodItem = getPeriodItem(this._periods, period), textInfos = periodItem && periodItem.text;
                if (null == textInfos) return [];
                var chosenTextAdaptation = this._textChoiceMemory.get(period), currentId = chosenTextAdaptation && chosenTextAdaptation.id;
                return textInfos.adaptations.map(function(adaptation) {
                    return {
                        language: adaptation.language || "",
                        normalized: adaptation.normalizedLanguage || "",
                        closedCaption: !!adaptation.isClosedCaption,
                        id: adaptation.id,
                        active: null != currentId && currentId === adaptation.id
                    };
                });
            }
            /**
   * Returns all available video tracks for a given Period, as an array of
   * objects.
   *
   * @returns {Array.<Object>}
   */ , _proto.getAvailableVideoTracks = function getAvailableVideoTracks(period) {
                var periodItem = getPeriodItem(this._periods, period), videoInfos = periodItem && periodItem.video;
                if (null == videoInfos) return [];
                var chosenVideoAdaptation = this._videoChoiceMemory.get(period), currentId = chosenVideoAdaptation && chosenVideoAdaptation.id;
                return videoInfos.adaptations.map(function(adaptation) {
                    return {
                        id: adaptation.id,
                        active: null != currentId && currentId === adaptation.id,
                        representations: adaptation.representations.map(parseVideoRepresentation)
                    };
                });
            }, _proto._updateAudioTrackChoices = function _updateAudioTrackChoices() {
                var _this = this, normalizedTracks = normalizeAudioTracks(this._preferredAudioTracks.getValue());
                !function recursiveUpdateAudioTrack(index) {
                    if (!(index >= _this._periods.length())) {
                        var periodItem = _this._periods.get(index);
                        if (null != periodItem.audio) {
                            var period = periodItem.period, audioItem = periodItem.audio, audioAdaptations = period.adaptations.audio || [], chosenAudioAdaptation = _this._audioChoiceMemory.get(period);
                            if (null === chosenAudioAdaptation || void 0 !== chosenAudioAdaptation && Object(array_includes.a)(audioAdaptations, chosenAudioAdaptation)) 
                            // Already best audio for this Buffer, check next one
                            recursiveUpdateAudioTrack(index + 1); else {
                                var optimalAdaptation = findFirstOptimalAudioAdaptation(audioAdaptations, normalizedTracks);
                                _this._audioChoiceMemory.set(period, optimalAdaptation), audioItem.adaptation$.next(optimalAdaptation), 
                                // previous "next" call could have changed everything, start over
                                recursiveUpdateAudioTrack(0);
                            }
                        } else 
                        // No audio Buffer for this period, check next one
                        recursiveUpdateAudioTrack(index + 1);
                    }
                }(0);
            }, _proto._updateTextTrackChoices = function _updateTextTrackChoices() {
                var _this2 = this, normalizedTracks = normalizeTextTracks(this._preferredTextTracks.getValue());
                !function recursiveUpdateTextTrack(index) {
                    if (!(index >= _this2._periods.length())) {
                        var periodItem = _this2._periods.get(index);
                        if (null != periodItem.text) {
                            var period = periodItem.period, textItem = periodItem.text, textAdaptations = period.adaptations.text || [], chosenTextAdaptation = _this2._textChoiceMemory.get(period);
                            if (null === chosenTextAdaptation || void 0 !== chosenTextAdaptation && Object(array_includes.a)(textAdaptations, chosenTextAdaptation)) 
                            // Already best text for this Buffer, check next one
                            recursiveUpdateTextTrack(index + 1); else {
                                var optimalAdaptation = findFirstOptimalTextAdaptation(textAdaptations, normalizedTracks);
                                _this2._textChoiceMemory.set(period, optimalAdaptation), textItem.adaptation$.next(optimalAdaptation), 
                                // previous "next" call could have changed everything, start over
                                recursiveUpdateTextTrack(0);
                            }
                        } else 
                        // No text Buffer for this period, check next one
                        recursiveUpdateTextTrack(index + 1);
                    }
                }(0);
            }, _proto._updateVideoTrackChoices = function _updateVideoTrackChoices() {
                var _this3 = this;
                !function recursiveUpdateVideoTrack(index) {
                    if (!(index >= _this3._periods.length())) {
                        var periodItem = _this3._periods.get(index);
                        if (null != periodItem.video) {
                            var period = periodItem.period, videoItem = periodItem.video, videoAdaptations = period.adaptations.video || [], chosenVideoAdaptation = _this3._videoChoiceMemory.get(period);
                            if (null === chosenVideoAdaptation || void 0 !== chosenVideoAdaptation && Object(array_includes.a)(videoAdaptations, chosenVideoAdaptation)) 
                            // Already best video for this Buffer, check next one
                            recursiveUpdateVideoTrack(index + 1); else {
                                var optimalAdaptation = videoAdaptations[0];
                                _this3._videoChoiceMemory.set(period, optimalAdaptation), videoItem.adaptation$.next(optimalAdaptation), 
                                // previous "next" call could have changed everything, start over
                                recursiveUpdateVideoTrack(0);
                            }
                        } else 
                        // No video Buffer for this period, check next one
                        recursiveUpdateVideoTrack(index + 1);
                    }
                }(0);
            }, TrackManager;
        }();
        /**
 * Find an optimal audio adaptation given their list and the array of preferred
 * audio tracks sorted from the most preferred to the least preferred.
 *
 * null if the most optimal audio adaptation is no audio adaptation.
 * @param {Array.<Adaptation>} audioAdaptations
 * @returns {Adaptation|null}
 */        function findFirstOptimalAudioAdaptation(audioAdaptations, preferredAudioTracks) {
            if (!audioAdaptations.length) return null;
            for (var _loop = function _loop(i) {
                var preferredAudioTrack = preferredAudioTracks[i];
                if (null === preferredAudioTrack) return {
                    v: null
                };
                var foundAdaptation = Object(array_find.a)(audioAdaptations, function(audioAdaptation) {
                    return (audioAdaptation.normalizedLanguage || "") === preferredAudioTrack.normalized && !!audioAdaptation.isAudioDescription === preferredAudioTrack.audioDescription;
                });
                return void 0 !== foundAdaptation ? {
                    v: foundAdaptation
                } : void 0;
            }, i = 0; i < preferredAudioTracks.length; i++) {
                var _ret = _loop(i);
                if ("object" == typeof _ret) return _ret.v;
            }
 // no optimal adaptation, just return the first one
                        return audioAdaptations[0];
        }
        /**
 * Find an optimal text adaptation given their list and the array of preferred
 * text tracks sorted from the most preferred to the least preferred.
 *
 * null if the most optimal text adaptation is no text adaptation.
 * @param {Array.<Adaptation>} audioAdaptations
 * @returns {Adaptation|null}
 */        function findFirstOptimalTextAdaptation(textAdaptations, preferredTextTracks) {
            if (!textAdaptations.length) return null;
            for (var _loop2 = function _loop2(i) {
                var preferredTextTrack = preferredTextTracks[i];
                if (null === preferredTextTrack) return {
                    v: null
                };
                var foundAdaptation = Object(array_find.a)(textAdaptations, function(textAdaptation) {
                    return (textAdaptation.normalizedLanguage || "") === preferredTextTrack.normalized && !!textAdaptation.isClosedCaption === preferredTextTrack.closedCaption;
                });
                return void 0 !== foundAdaptation ? {
                    v: foundAdaptation
                } : void 0;
            }, i = 0; i < preferredTextTracks.length; i++) {
                var _ret2 = _loop2(i);
                if ("object" == typeof _ret2) return _ret2.v;
            }
 // no optimal adaptation
                        return null;
        }
        function findPeriodIndex(periods, period) {
            for (var i = 0; i < periods.length(); i++) {
                if (periods.get(i).period.id === period.id) return i;
            }
        }
        function getPeriodItem(periods, period) {
            for (var i = 0; i < periods.length(); i++) {
                var periodI = periods.get(i);
                if (periodI.period.id === period.id) return periodI;
            }
        }
        /**
 * Parse video Representation into a ITMVideoRepresentation.
 * @param {Object} representation
 * @returns {Object}
 */        function parseVideoRepresentation(_ref4) {
            return {
                id: _ref4.id,
                bitrate: _ref4.bitrate,
                frameRate: _ref4.frameRate,
                width: _ref4.width,
                height: _ref4.height,
                codec: _ref4.codec
            };
        }
        // CONCATENATED MODULE: ./src/core/api/public_api.ts
                function public_api_defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        function public_api_createClass(Constructor, protoProps, staticProps) {
            return protoProps && public_api_defineProperties(Constructor.prototype, protoProps), 
            staticProps && public_api_defineProperties(Constructor, staticProps), Constructor;
        }
        function public_api_inheritsLoose(subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype), (subClass.prototype.constructor = subClass).__proto__ = superClass;
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * This file defines the public API for the RxPlayer.
 * It also starts the different sub-parts of the player on various API calls.
 */        var DEFAULT_UNMUTED_VOLUME = config.a.DEFAULT_UNMUTED_VOLUME, isInBackground$ = compat.a.isInBackground$, onEnded$ = compat.a.onEnded$, onFullscreenChange$ = compat.a.onFullscreenChange$, onPlayPause$ = compat.a.onPlayPause$, onSeeking$ = compat.a.onSeeking$, onTextTrackChanges$ = compat.a.onTextTrackChanges$, videoWidth$ = compat.a.videoWidth$, public_api_Player = 
        /* */
        function(_EventEmitter) {
            function Player(options) {
                var _this;
                void 0 === options && (options = {}), _this = _EventEmitter.call(this) || this;
                var _parseConstructorOpti = parseConstructorOptions(options), initialAudioBitrate = _parseConstructorOpti.initialAudioBitrate, initialVideoBitrate = _parseConstructorOpti.initialVideoBitrate, limitVideoWidth = _parseConstructorOpti.limitVideoWidth, maxAudioBitrate = _parseConstructorOpti.maxAudioBitrate, maxBufferAhead = _parseConstructorOpti.maxBufferAhead, maxBufferBehind = _parseConstructorOpti.maxBufferBehind, maxVideoBitrate = _parseConstructorOpti.maxVideoBitrate, preferredAudioTracks = _parseConstructorOpti.preferredAudioTracks, preferredTextTracks = _parseConstructorOpti.preferredTextTracks, throttleWhenHidden = _parseConstructorOpti.throttleWhenHidden, videoElement = _parseConstructorOpti.videoElement, wantedBufferAhead = _parseConstructorOpti.wantedBufferAhead, stopAtEnd = _parseConstructorOpti.stopAtEnd;
 // Workaround to support Firefox autoplay on FF 42.
                // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1194624
                                return videoElement.preload = "auto", _this.version = 
                /*PLAYER_VERSION*/
                "3.11.1", _this.log = log.a, _this.state = "STOPPED", _this.videoElement = videoElement, 
                _this._priv_destroy$ = new Subject.a(), 
                /** @deprecated */
                onFullscreenChange$(videoElement).pipe(Object(takeUntil.a)(_this._priv_destroy$))
                /* tslint:disable deprecation */ .subscribe(function() {
                    return _this.trigger("fullscreenChange", _this.isFullscreen());
                }), 
                /* tslint:enable deprecation */
                /** @deprecated */
                onTextTrackChanges$(videoElement.textTracks).pipe(Object(takeUntil.a)(_this._priv_destroy$), Object(map.a)(function(evt) {
                    for (var target = evt.target, arr = [], i = 0; i < target.length; i++) {
                        var textTrack = target[i];
                        arr.push(textTrack);
                    }
                    return arr;
                }), // We can have two consecutive textTrackChanges with the exact same
                // payload when we perform multiple texttrack operations before the event
                // loop is freed.
                // In that case we only want to fire one time the observable.
                Object(distinctUntilChanged.a)(function(textTracksA, textTracksB) {
                    if (textTracksA.length !== textTracksB.length) return !1;
                    for (var i = 0; i < textTracksA.length; i++) if (textTracksA[i] !== textTracksB[i]) return !1;
                    return !0;
                })).subscribe(function(x) {
                    return _this._priv_onNativeTextTracksNext(x);
                }), _this._priv_playing$ = new ReplaySubject.a(1), _this._priv_speed$ = new BehaviorSubject_BehaviorSubject(videoElement.playbackRate), 
                _this._priv_stopCurrentContent$ = new Subject.a(), _this._priv_contentLock$ = new BehaviorSubject_BehaviorSubject(!1), 
                _this._priv_bufferOptions = {
                    wantedBufferAhead$: new BehaviorSubject_BehaviorSubject(wantedBufferAhead),
                    maxBufferAhead$: new BehaviorSubject_BehaviorSubject(maxBufferAhead),
                    maxBufferBehind$: new BehaviorSubject_BehaviorSubject(maxBufferBehind)
                }, _this._priv_bitrateInfos = {
                    lastBitrates: {
                        audio: initialAudioBitrate,
                        video: initialVideoBitrate
                    },
                    initialMaxAutoBitrates: {
                        audio: maxAudioBitrate,
                        video: maxVideoBitrate
                    },
                    manualBitrates: {
                        audio: -1,
                        video: -1
                    }
                }, _this._priv_throttleWhenHidden = throttleWhenHidden, _this._priv_limitVideoWidth = limitVideoWidth, 
                _this._priv_mutedMemory = DEFAULT_UNMUTED_VOLUME, _this._priv_trackManager = null, 
                _this._priv_abrManager = null, _this._priv_currentError = null, _this._priv_contentInfos = null, 
                _this._priv_contentEventsMemory = {}, _this._priv_stopAtEnd = stopAtEnd, _this._priv_setPlayerState(PLAYER_STATES_STOPPED), 
                _this._priv_preferredAudioTracks = new BehaviorSubject_BehaviorSubject(preferredAudioTracks), 
                _this._priv_preferredTextTracks = new BehaviorSubject_BehaviorSubject(preferredTextTracks), 
                _this;
            }
            /**
   * Stop the playback for the current content.
   */            public_api_inheritsLoose(Player, _EventEmitter), public_api_createClass(Player, null, [ {
                key: "ErrorTypes",
                /**
     * All possible Error types emitted by the RxPlayer.
     * @type {Object}
     */
                get: function get() {
                    return error_codes.b;
                }
                /**
     * All possible Error codes emitted by the RxPlayer.
     * @type {Object}
     */            }, {
                key: "ErrorCodes",
                get: function get() {
                    return error_codes.a;
                }
                /**
     * Current log level.
     * Update current log level.
     * Should be either (by verbosity ascending):
     *   - "NONE"
     *   - "ERROR"
     *   - "WARNING"
     *   - "INFO"
     *   - "DEBUG"
     * Any other value will be translated to "NONE".
     * @type {string}
     */            }, {
                key: "LogLevel",
                get: function get() {
                    return log.a.getLevel();
                },
                set: function set(logLevel) {
                    log.a.setLevel(logLevel);
                }
                /**
     * @constructor
     * @param {Object} options
     */            } ]);
            var _proto = Player.prototype;
            return _proto.stop = function stop() {
                this.state !== PLAYER_STATES_STOPPED && (this._priv_stopCurrentContent$.next(), 
                this._priv_cleanUpCurrentContentState(), this._priv_setPlayerState(PLAYER_STATES_STOPPED));
            }
            /**
   * Free the resources used by the player.
   * /!\ The player cannot be "used" anymore after this method has been called.
   */ , _proto.dispose = function dispose() {
                // free resources linked to the loaded content
                this.stop(), this.videoElement && 
                // free resources used for EME management
                Object(eme_manager.c)(this.videoElement), // free Observables linked to the Player instance
                this._priv_destroy$.next(), this._priv_destroy$.complete(), // Complete all subjects
                this._priv_stopCurrentContent$.complete(), this._priv_playing$.complete(), this._priv_speed$.complete(), 
                this._priv_contentLock$.complete(), this._priv_bufferOptions.wantedBufferAhead$.complete(), 
                this._priv_bufferOptions.maxBufferAhead$.complete(), this._priv_bufferOptions.maxBufferBehind$.complete(), 
                // un-attach video element
                this.videoElement = null;
            }
            /**
   * Load a new video.
   * @param {Object} opts
   * @returns {Observable}
   * @throws Error - throws if no url is given.
   * @throws Error - throws if no transport is given and no default transport
   * has been set.
   * @throws Error - throws if the asked transport does not exist
   */ , _proto.loadVideo = function loadVideo(opts) {
                var _this2 = this, options = parseLoadVideoOptions(opts);
                log.a.info("API: Calling loadvideo", options);
                var autoPlay = options.autoPlay, defaultAudioTrack = options.defaultAudioTrack, defaultTextTrack = options.defaultTextTrack, keySystems = options.keySystems, manualBitrateSwitchingMode = options.manualBitrateSwitchingMode, networkConfig = options.networkConfig, startAt = options.startAt, supplementaryImageTracks = options.supplementaryImageTracks, supplementaryTextTracks = options.supplementaryTextTracks, transport = options.transport, transportOptions = options.transportOptions, url = options.url;
 // Perform multiple checks on the given options
                                if (!this.videoElement) throw new Error("the attached video element is disposed");
 // now that every check has passed, stop previous content
                                this.stop();
                var isDirectFile = "directfile" === transport;
                this._priv_currentError = null, this._priv_contentInfos = {
                    url: url,
                    isDirectFile: isDirectFile,
                    thumbnails: null,
                    manifest: null,
                    currentPeriod: null,
                    activeAdaptations: null,
                    activeRepresentations: null,
                    initialAudioTrack: defaultAudioTrack,
                    initialTextTrack: defaultTextTrack
                }, // inilialize to false
                this._priv_playing$.next(!1);
                // get every properties used from context for clarity
                var playback$, videoElement = this.videoElement, clock$ = api_clock(videoElement, {
                    withMediaSource: !isDirectFile
                }), contentIsStopped$ = Object(merge.a)(this._priv_stopCurrentContent$, this._priv_stopAtEnd ? onEnded$(videoElement) : empty.a).pipe(Object(take.a)(1));
 // Global clock used for the whole application.
                                if (isDirectFile) {
                    if (null == features.a.directfile) throw new Error("DirectFile feature not activated in your build.");
                    playback$ = features.a.directfile({
                        autoPlay: autoPlay,
                        clock$: clock$,
                        keySystems: keySystems,
                        mediaElement: videoElement,
                        speed$: this._priv_speed$,
                        startAt: startAt,
                        url: url
                    }).pipe(Object(takeUntil.a)(contentIsStopped$)).pipe(publish());
                } // Emit an object when the player stalls and null when it unstall
                 else {
                    var transportFn = features.a.transports[transport];
                    if (!transportFn) throw new Error('transport "' + transport + '" not supported');
                    var pipelines = transportFn(object_assign_default()({
                        supplementaryTextTracks: supplementaryTextTracks,
                        supplementaryImageTracks: supplementaryImageTracks
                    }, transportOptions)), adaptiveOptions = {
                        initialBitrates: this._priv_bitrateInfos.lastBitrates,
                        manualBitrates: this._priv_bitrateInfos.manualBitrates,
                        maxAutoBitrates: this._priv_bitrateInfos.initialMaxAutoBitrates,
                        throttle: this._priv_throttleWhenHidden ? {
                            video: isInBackground$().pipe(Object(map.a)(function(isBg) {
                                return isBg ? 0 : Infinity;
                            }), Object(takeUntil.a)(this._priv_stopCurrentContent$))
                        } : {},
                        limitWidth: this._priv_limitVideoWidth ? {
                            video: videoWidth$(videoElement).pipe(Object(takeUntil.a)(this._priv_stopCurrentContent$))
                        } : {}
                    }, textTrackOptions = "native" === options.textTrackMode ? {
                        textTrackMode: "native",
                        hideNativeSubtitle: options.hideNativeSubtitle
                    } : {
                        textTrackMode: "html",
                        textTrackElement: options.textTrackElement
                    };
 // Options used by the ABR Manager.
                                        // playback$ Observable, through which the content will be launched.
                    playback$ = core_init({
                        adaptiveOptions: adaptiveOptions,
                        autoPlay: autoPlay,
                        bufferOptions: object_assign_default()({
                            manualBitrateSwitchingMode: manualBitrateSwitchingMode
                        }, this._priv_bufferOptions),
                        clock$: clock$,
                        keySystems: keySystems,
                        mediaElement: videoElement,
                        networkConfig: networkConfig,
                        pipelines: pipelines,
                        speed$: this._priv_speed$,
                        startAt: startAt,
                        textTrackOptions: textTrackOptions,
                        url: url
                    }).pipe(Object(takeUntil.a)(contentIsStopped$)).pipe(publish());
                }
                var playbackSubscription, stalled$ = playback$.pipe(Object(filter.a)(function(evt) {
                    return "stalled" === evt.type;
                }), Object(map.a)(function(x) {
                    return x.value;
                })), loaded$ = playback$.pipe(Object(filter.a)(function(evt) {
                    return "loaded" === evt.type;
                }), Object(share.a)()), reloading$ = playback$.pipe(Object(filter.a)(function(evt) {
                    return "reloading-media-source" === evt.type;
                }), Object(share.a)()), endedEvent$ = onEnded$(videoElement), seekingEvent$ = onSeeking$(videoElement), loadedStateUpdates$ = Object(combineLatest.a)(this._priv_playing$, stalled$.pipe(Object(startWith.a)(null)), endedEvent$.pipe(Object(startWith.a)(null)), seekingEvent$.pipe(Object(startWith.a)(null))).pipe(Object(takeUntil.a)(this._priv_stopCurrentContent$), Object(map.a)(function(_ref) {
                    var isPlaying = _ref[0], stalledStatus = _ref[1];
                    return getLoadedContentState(videoElement, isPlaying, stalledStatus);
                })), playerState$ = Object(concat.a)(Object(of.a)(PLAYER_STATES_LOADING), // Begin with LOADING
                // LOADED as soon as the first "loaded" event is sent
                loaded$.pipe(Object(take.a)(1), Object(mapTo.a)(PLAYER_STATES_LOADED)), Object(merge.a)(loadedStateUpdates$.pipe(// From the first reload onward, we enter another dynamic (below)
                Object(takeUntil.a)(reloading$), skipWhile(function(state) {
                    return state === PLAYER_STATES_PAUSED;
                })), // when reloading
                reloading$.pipe(Object(switchMapTo.a)(loaded$.pipe(Object(take.a)(1), // wait for the next loaded event
                Object(mergeMapTo.a)(loadedStateUpdates$), // to update the state as usual
                Object(startWith.a)(PLAYER_STATES_RELOADING)))))).pipe(Object(distinctUntilChanged.a)());
 // Emit when the content is considered "loaded".
                                this._priv_stopCurrentContent$.pipe(Object(take.a)(1)).subscribe(function() {
                    playbackSubscription && playbackSubscription.unsubscribe();
                }), onPlayPause$(videoElement).pipe(Object(takeUntil.a)(this._priv_stopCurrentContent$)).subscribe(function(e) {
                    return _this2._priv_onPlayPauseNext("play" === e.type);
                }, noop.a), clock$.pipe(Object(takeUntil.a)(this._priv_stopCurrentContent$)).subscribe(function(x) {
                    return _this2._priv_triggerTimeChange(x);
                }, noop.a), playerState$.pipe(Object(takeUntil.a)(this._priv_stopCurrentContent$)).subscribe(function(x) {
                    return _this2._priv_setPlayerState(x);
                }, noop.a), playback$.subscribe(function(x) {
                    return _this2._priv_onPlaybackEvent(x);
                }, function(err) {
                    return _this2._priv_onPlaybackError(err);
                }, function() {
                    return _this2._priv_onPlaybackFinished();
                }), // initialize the content only when the lock is inactive
                this._priv_contentLock$.pipe(Object(filter.a)(function(isLocked) {
                    return !isLocked;
                }), Object(take.a)(1), Object(takeUntil.a)(this._priv_stopCurrentContent$)).subscribe(function() {
                    playbackSubscription = playback$.connect();
                });
            }
            /**
   * Returns fatal error if one for the current content.
   * null otherwise.
   * @returns {Object|null}
   */ , _proto.getError = function getError() {
                return this._priv_currentError;
            }
            /**
   * Returns manifest/playlist object.
   * null if the player is STOPPED.
   * @returns {Manifest|null}
   */ , _proto.getManifest = function getManifest() {
                return this._priv_contentInfos && this._priv_contentInfos.manifest;
            }
            /**
   * Returns adaptations (tracks) for every currently playing type
   * (audio/video/text...).
   * @returns {Object|null}
   */ , _proto.getCurrentAdaptations = function getCurrentAdaptations() {
                if (!this._priv_contentInfos) return null;
                var _this$_priv_contentIn = this._priv_contentInfos, currentPeriod = _this$_priv_contentIn.currentPeriod, activeAdaptations = _this$_priv_contentIn.activeAdaptations;
                return currentPeriod && activeAdaptations && activeAdaptations[currentPeriod.id] || null;
            }
            /**
   * Returns representations (qualities) for every currently playing type
   * (audio/video/text...).
   * @returns {Object|null}
   */ , _proto.getCurrentRepresentations = function getCurrentRepresentations() {
                if (!this._priv_contentInfos) return null;
                var _this$_priv_contentIn2 = this._priv_contentInfos, currentPeriod = _this$_priv_contentIn2.currentPeriod, activeRepresentations = _this$_priv_contentIn2.activeRepresentations;
                return currentPeriod && activeRepresentations && activeRepresentations[currentPeriod.id] || null;
            }
            /**
   * Returns the media DOM element used by the player.
   * You should not its HTML5 API directly and use the player's method instead,
   * to ensure a well-behaved player.
   * @returns {HTMLMediaElement|null}
   */ , _proto.getVideoElement = function getVideoElement() {
                return this.videoElement;
            }
            /**
   * If one returns the first native text-track element attached to the media element.
   * @deprecated
   * @returns {TextTrack}
   */ , _proto.getNativeTextTrack = function getNativeTextTrack() {
                if (Object(warn_once.a)("getNativeTextTrack is deprecated. Please open an issue if you used this API."), 
                !this.videoElement) throw new Error("Disposed player");
                var videoElement = this.videoElement;
                return 0 < videoElement.textTracks.length ? videoElement.textTracks[0] : null;
            }
            /**
   * Returns the player's current state.
   * @returns {string}
   */ , _proto.getPlayerState = function getPlayerState() {
                return this.state;
            }
            /**
   * Returns true if both:
   *   - a content is loaded
   *   - the content loaded is a live content
   * @returns {Boolean}
   */ , _proto.isLive = function isLive() {
                if (!this._priv_contentInfos) return !1;
                var _this$_priv_contentIn3 = this._priv_contentInfos, isDirectFile = _this$_priv_contentIn3.isDirectFile, manifest = _this$_priv_contentIn3.manifest;
                return !isDirectFile && null != manifest && manifest.isLive;
            }
            /**
   * Returns the url of the content's manifest
   * @returns {string|undefined}
   */ , _proto.getUrl = function getUrl() {
                if (this._priv_contentInfos) {
                    var _this$_priv_contentIn4 = this._priv_contentInfos, isDirectFile = _this$_priv_contentIn4.isDirectFile, manifest = _this$_priv_contentIn4.manifest, url = _this$_priv_contentIn4.url;
                    return isDirectFile ? url : null != manifest ? manifest.getUrl() : void 0;
                }
            }
            /**
   * Returns the video duration, in seconds.
   * NaN if no video is playing.
   * @returns {Number}
   */ , _proto.getVideoDuration = function getVideoDuration() {
                if (!this.videoElement) throw new Error("Disposed player");
                return this.videoElement.duration;
            }
            /**
   * Returns in seconds the difference between:
   *   - the end of the current contiguous loaded range.
   *   - the current time
   * @returns {Number}
   */ , _proto.getVideoBufferGap = function getVideoBufferGap() {
                if (!this.videoElement) throw new Error("Disposed player");
                var videoElement = this.videoElement;
                return Object(utils_ranges.c)(videoElement.buffered, videoElement.currentTime);
            }
            /**
   * Returns in seconds the difference between:
   *   - the end of the current contiguous loaded range.
   *   - the start of the current contiguous loaded range.
   * @returns {Number}
   */ , _proto.getVideoLoadedTime = function getVideoLoadedTime() {
                if (!this.videoElement) throw new Error("Disposed player");
                var videoElement = this.videoElement;
                return Object(utils_ranges.g)(videoElement.buffered, videoElement.currentTime);
            }
            /**
   * Returns in seconds the difference between:
   *   - the current time.
   *   - the start of the current contiguous loaded range.
   * @returns {Number}
   */ , _proto.getVideoPlayedTime = function getVideoPlayedTime() {
                if (!this.videoElement) throw new Error("Disposed player");
                var videoElement = this.videoElement;
                return Object(utils_ranges.e)(videoElement.buffered, videoElement.currentTime);
            }
            /**
   * Get the current position, in s, in wall-clock time.
   * That is:
   *   - for live content, get a timestamp, in s, of the current played content.
   *   - for static content, returns the position from beginning in s.
   *
   * If you do not know if you want to use this method or getPosition:
   *   - If what you want is to display the current time to the user, use this
   *     one.
   *   - If what you want is to interact with the player's API or perform other
   *     actions (like statistics) with the real player data, use getPosition.
   *
   * @returns {Number}
   */ , _proto.getWallClockTime = function getWallClockTime() {
                if (!this.videoElement) throw new Error("Disposed player");
                if (!this._priv_contentInfos) return this.videoElement.currentTime;
                var _this$_priv_contentIn5 = this._priv_contentInfos, isDirectFile = _this$_priv_contentIn5.isDirectFile, manifest = _this$_priv_contentIn5.manifest;
                if (isDirectFile) return this.videoElement.currentTime;
                if (null == manifest) return 0;
                var currentTime = this.videoElement.currentTime;
                return this.isLive() ? currentTime + (manifest.availabilityStartTime || 0) : currentTime;
            }
            /**
   * Get the current position, in seconds, of the video element.
   *
   * If you do not know if you want to use this method or getWallClockTime:
   *   - If what you want is to display the current time to the user, use
   *     getWallClockTime.
   *   - If what you want is to interact with the player's API or perform other
   *     actions (like statistics) with the real player data, use this one.
   *
   * @returns {Number}
   */ , _proto.getPosition = function getPosition() {
                if (!this.videoElement) throw new Error("Disposed player");
                return this.videoElement.currentTime;
            }
            /**
   * Returns the current speed at which the video plays.
   * @returns {Number}
   */ , _proto.getPlaybackRate = function getPlaybackRate() {
                return this._priv_speed$.getValue();
            }
            /**
   * Update the playback rate of the video.
   * @param {Number} rate
   */ , _proto.setPlaybackRate = function setPlaybackRate(rate) {
                this._priv_speed$.next(rate);
            }
            /**
   * Returns all available bitrates for the current video Adaptation.
   * @returns {Array.<Number>}
   */ , _proto.getAvailableVideoBitrates = function getAvailableVideoBitrates() {
                if (!this._priv_contentInfos) return [];
                var _this$_priv_contentIn6 = this._priv_contentInfos, currentPeriod = _this$_priv_contentIn6.currentPeriod, activeAdaptations = _this$_priv_contentIn6.activeAdaptations;
                if (!currentPeriod || !activeAdaptations) return [];
                var adaptations = activeAdaptations[currentPeriod.id], videoAdaptation = adaptations && adaptations.video;
                return videoAdaptation ? videoAdaptation.getAvailableBitrates() : [];
            }
            /**
   * Returns all available bitrates for the current audio Adaptation.
   * @returns {Array.<Number>}
   */ , _proto.getAvailableAudioBitrates = function getAvailableAudioBitrates() {
                if (!this._priv_contentInfos) return [];
                var _this$_priv_contentIn7 = this._priv_contentInfos, currentPeriod = _this$_priv_contentIn7.currentPeriod, activeAdaptations = _this$_priv_contentIn7.activeAdaptations;
                if (!currentPeriod || !activeAdaptations) return [];
                var adaptations = activeAdaptations[currentPeriod.id], audioAdaptation = adaptations && adaptations.audio;
                return audioAdaptation ? audioAdaptation.getAvailableBitrates() : [];
            }
            /**
   * Returns the manual audio bitrate set. -1 if in AUTO mode.
   * @returns {Number}
   */ , _proto.getManualAudioBitrate = function getManualAudioBitrate() {
                return this._priv_bitrateInfos.manualBitrates.audio;
            }
            /**
   * Returns the manual video bitrate set. -1 if in AUTO mode.
   * @returns {Number}
   */ , _proto.getManualVideoBitrate = function getManualVideoBitrate() {
                return this._priv_bitrateInfos.manualBitrates.video;
            }
            /**
   * Returns currently considered bitrate for video segments.
   * @returns {Number|undefined}
   */ , _proto.getVideoBitrate = function getVideoBitrate() {
                var representations = this.getCurrentRepresentations();
                if (representations && representations.video) return representations.video.bitrate;
            }
            /**
   * Returns currently considered bitrate for audio segments.
   * @returns {Number|undefined}
   */ , _proto.getAudioBitrate = function getAudioBitrate() {
                var representations = this.getCurrentRepresentations();
                if (representations && representations.audio) return representations.audio.bitrate;
            }
            /**
   * Returns max wanted video bitrate currently set.
   * @returns {Number}
   */ , _proto.getMaxVideoBitrate = function getMaxVideoBitrate() {
                return this._priv_abrManager ? this._priv_abrManager.getMaxAutoBitrate("video") : this._priv_bitrateInfos.initialMaxAutoBitrates.video;
            }
            /**
   * Returns max wanted audio bitrate currently set.
   * @returns {Number}
   */ , _proto.getMaxAudioBitrate = function getMaxAudioBitrate() {
                return this._priv_abrManager ? this._priv_abrManager.getMaxAutoBitrate("audio") : this._priv_bitrateInfos.initialMaxAutoBitrates.audio;
            }
            /**
   * Play/Resume the current video.
   * @returns {Promise}
   */ , _proto.play = function play() {
                var _this3 = this;
                if (!this.videoElement) throw new Error("Disposed player");
                var playPromise = this.videoElement.play();
                /* tslint:disable no-unbound-method */                return null == playPromise || "function" != typeof playPromise.catch ? promise.a.resolve() : playPromise.catch(function(error) {
                    if ("NotAllowedError" === error.name) {
                        var warning = new media_error.a("MEDIA_ERR_PLAY_NOT_ALLOWED", error.toString(), !1);
                        _this3.trigger("warning", warning);
                    }
                    throw error;
                });
            }
            /**
   * Pause the current video.
   */ , _proto.pause = function pause() {
                if (!this.videoElement) throw new Error("Disposed player");
                this.videoElement.pause();
            }
            /**
   * Seek to a given absolute position.
   * @param {Number|Object} time
   * @returns {Number} - The time the player has seek to
   */ , _proto.seekTo = function seekTo(time) {
                if (!this.videoElement) throw new Error("Disposed player");
                if (!this._priv_contentInfos) throw new Error("player: no content loaded");
                var positionWanted, _this$_priv_contentIn8 = this._priv_contentInfos, isDirectFile = _this$_priv_contentIn8.isDirectFile, manifest = _this$_priv_contentIn8.manifest;
                if (!isDirectFile && null == manifest) throw new Error("player: the content did not load yet");
                var typeOf = typeof time;
                if ("number" === typeOf) positionWanted = time; else if ("object" === typeOf) {
                    var currentTs = this.videoElement.currentTime;
                    if (null != time.relative) positionWanted = currentTs + time.relative; else if (null != time.position) positionWanted = time.position; else {
                        if (null == time.wallClockTime) throw new Error('invalid time object. You must set one of the following properties: "relative", "position" or "wallClockTime"');
                        positionWanted = isDirectFile ? time.wallClockTime : fromWallClockTime(1e3 * time.wallClockTime, manifest);
                    }
                }
                if (void 0 === positionWanted) throw new Error("invalid time given");
                return this.videoElement.currentTime = positionWanted;
            }
            /**
   * Returns true if the media element is full screen.
   * @deprecated
   * @returns {Boolean}
   */ , _proto.isFullscreen = function isFullscreen() {
                return Object(warn_once.a)("isFullscreen is deprecated. Fullscreen management should now be managed by the application"), 
                Object(fullscreen.b)();
            }
            /**
   * Set/exit fullScreen.
   * @deprecated
   * @param {Boolean} [goFull=true] - if false, exit full screen.
   */ , _proto.setFullscreen = function setFullscreen(goFull) {
                if (void 0 === goFull && (goFull = !0), Object(warn_once.a)("setFullscreen is deprecated. Fullscreen management should now be managed by the application"), 
                !this.videoElement) throw new Error("Disposed player");
                goFull ? Object(fullscreen.c)(this.videoElement) : Object(fullscreen.a)();
            }
            /**
   * Exit from full screen mode.
   * @deprecated
   */ , _proto.exitFullscreen = function exitFullscreen() {
                Object(warn_once.a)("exitFullscreen is deprecated. Fullscreen management should now be managed by the application"), 
                Object(fullscreen.a)();
            }
            /**
   * Returns the current player's audio volume on the media element.
   * From 0 (no audio) to 1 (maximum volume).
   * @returns {Number}
   */ , _proto.getVolume = function getVolume() {
                if (!this.videoElement) throw new Error("Disposed player");
                return this.videoElement.volume;
            }
            /**
   * Set the player's audio volume. From 0 (no volume) to 1 (maximum volume).
   * @param {Number} volume
   */ , _proto.setVolume = function setVolume(volume) {
                if (!this.videoElement) throw new Error("Disposed player");
                var videoElement = this.videoElement;
                volume !== videoElement.volume && (videoElement.volume = volume, this.trigger("volumeChange", volume));
            }
            /**
   * Returns true if the volume is set to 0. false otherwise.
   * @returns {Boolean}
   */ , _proto.isMute = function isMute() {
                return !this.getVolume();
            }
            /**
   * Set the volume to 0 and save current one for when unmuted.
   */ , _proto.mute = function mute() {
                this._priv_mutedMemory = this.getVolume(), this.setVolume(0);
            }
            /**
   * Set the volume back to when it was when mute was last called.
   * If the volume was set to 0, set a default volume instead (see config).
   */ , _proto.unMute = function unMute() {
                0 === this.getVolume() && this.setVolume(this._priv_mutedMemory || DEFAULT_UNMUTED_VOLUME);
            }
            /**
   * Force the video bitrate to a given value. Act as a ceil.
   * -1 to set it on AUTO Mode
   * @param {Number} btr
   */ , _proto.setVideoBitrate = function setVideoBitrate(btr) {
                this._priv_bitrateInfos.manualBitrates.video = btr, this._priv_abrManager && this._priv_abrManager.setManualBitrate("video", btr);
            }
            /**
   * Force the audio bitrate to a given value. Act as a ceil.
   * -1 to set it on AUTO Mode
   * @param {Number} btr
   */ , _proto.setAudioBitrate = function setAudioBitrate(btr) {
                this._priv_bitrateInfos.manualBitrates.audio = btr, this._priv_abrManager && this._priv_abrManager.setManualBitrate("audio", btr);
            }
            /**
   * Update the maximum video bitrate the user can switch to.
   * @param {Number} btr
   */ , _proto.setMaxVideoBitrate = function setMaxVideoBitrate(btr) {
                // set it for the next content loaded
                this._priv_bitrateInfos.initialMaxAutoBitrates.video = btr, // set it for the current if one is loaded
                this._priv_abrManager && this._priv_abrManager.setMaxAutoBitrate("video", btr);
            }
            /**
   * Update the maximum video bitrate the user can switch to.
   * @param {Number} btr
   */ , _proto.setMaxAudioBitrate = function setMaxAudioBitrate(btr) {
                // set it for the next content loaded
                this._priv_bitrateInfos.initialMaxAutoBitrates.audio = btr, // set it for the current if one is loaded
                this._priv_abrManager && this._priv_abrManager.setMaxAutoBitrate("audio", btr);
            }
            /**
   * Set the max buffer size for the buffer behind the current position.
   * Every buffer data before will be removed.
   * @param {Number} depthInSeconds
   */ , _proto.setMaxBufferBehind = function setMaxBufferBehind(depthInSeconds) {
                this._priv_bufferOptions.maxBufferBehind$.next(depthInSeconds);
            }
            /**
   * Set the max buffer size for the buffer behind the current position.
   * Every buffer data before will be removed.
   * @param {Number} depthInSeconds
   */ , _proto.setMaxBufferAhead = function setMaxBufferAhead(depthInSeconds) {
                this._priv_bufferOptions.maxBufferAhead$.next(depthInSeconds);
            }
            /**
   * Set the max buffer size for the buffer ahead of the current position.
   * The player will stop downloading chunks when this size is reached.
   * @param {Number} sizeInSeconds
   */ , _proto.setWantedBufferAhead = function setWantedBufferAhead(sizeInSeconds) {
                this._priv_bufferOptions.wantedBufferAhead$.next(sizeInSeconds);
            }
            /**
   * Returns the max buffer size for the buffer behind the current position.
   * @returns {Number}
   */ , _proto.getMaxBufferBehind = function getMaxBufferBehind() {
                return this._priv_bufferOptions.maxBufferBehind$.getValue();
            }
            /**
   * Returns the max buffer size for the buffer behind the current position.
   * @returns {Number}
   */ , _proto.getMaxBufferAhead = function getMaxBufferAhead() {
                return this._priv_bufferOptions.maxBufferAhead$.getValue();
            }
            /**
   * Returns the max buffer size for the buffer ahead of the current position.
   * @returns {Number}
   */ , _proto.getWantedBufferAhead = function getWantedBufferAhead() {
                return this._priv_bufferOptions.wantedBufferAhead$.getValue();
            }
            /**
   * Returns type of current keysystem (e.g. playready, widevine) if the content
   * is encrypted. null otherwise.
   * @returns {string|null}
   */ , _proto.getCurrentKeySystem = function getCurrentKeySystem() {
                if (!this.videoElement) throw new Error("Disposed player");
                return Object(eme_manager.d)(this.videoElement);
            }
            /**
   * Returns every available audio tracks for the current Period.
   * @returns {Array.<Object>|null}
   */ , _proto.getAvailableAudioTracks = function getAvailableAudioTracks() {
                if (!this._priv_contentInfos) return [];
                var currentPeriod = this._priv_contentInfos.currentPeriod;
                return this._priv_trackManager && currentPeriod ? this._priv_trackManager.getAvailableAudioTracks(currentPeriod) : [];
            }
            /**
   * Returns every available text tracks for the current Period.
   * @returns {Array.<Object>|null}
   */ , _proto.getAvailableTextTracks = function getAvailableTextTracks() {
                if (!this._priv_contentInfos) return [];
                var currentPeriod = this._priv_contentInfos.currentPeriod;
                return this._priv_trackManager && currentPeriod ? this._priv_trackManager.getAvailableTextTracks(currentPeriod) : [];
            }
            /**
   * Returns every available video tracks for the current Period.
   * @returns {Array.<Object>|null}
   */ , _proto.getAvailableVideoTracks = function getAvailableVideoTracks() {
                if (!this._priv_contentInfos) return [];
                var currentPeriod = this._priv_contentInfos.currentPeriod;
                return this._priv_trackManager && currentPeriod ? this._priv_trackManager.getAvailableVideoTracks(currentPeriod) : [];
            }
            /**
   * Returns currently chosen audio language for the current Period.
   * @returns {string}
   */ , _proto.getAudioTrack = function getAudioTrack() {
                if (this._priv_contentInfos) {
                    var currentPeriod = this._priv_contentInfos.currentPeriod;
                    if (this._priv_trackManager && currentPeriod) return this._priv_trackManager.getChosenAudioTrack(currentPeriod);
                }
            }
            /**
   * Returns currently chosen subtitle for the current Period.
   * @returns {string}
   */ , _proto.getTextTrack = function getTextTrack() {
                if (this._priv_contentInfos) {
                    var currentPeriod = this._priv_contentInfos.currentPeriod;
                    if (this._priv_trackManager && currentPeriod) return this._priv_trackManager.getChosenTextTrack(currentPeriod);
                }
            }
            /**
   * Returns currently chosen video track for the current Period.
   * @returns {string}
   */ , _proto.getVideoTrack = function getVideoTrack() {
                if (this._priv_contentInfos) {
                    var currentPeriod = this._priv_contentInfos.currentPeriod;
                    if (this._priv_trackManager && currentPeriod) return this._priv_trackManager.getChosenVideoTrack(currentPeriod);
                }
            }
            /**
   * Update the audio language for the current Period.
   * @param {string} audioId
   * @throws Error - the current content has no TrackManager.
   * @throws Error - the given id is linked to no audio track.
   */ , _proto.setAudioTrack = function setAudioTrack(audioId) {
                if (!this._priv_contentInfos) throw new Error("No content loaded");
                var currentPeriod = this._priv_contentInfos.currentPeriod;
                if (!this._priv_trackManager || !currentPeriod) throw new Error("No compatible content launched.");
                try {
                    this._priv_trackManager.setAudioTrackByID(currentPeriod, audioId);
                } catch (e) {
                    throw new Error("player: unknown audio track");
                }
            }
            /**
   * Update the text language for the current Period.
   * @param {string} sub
   * @throws Error - the current content has no TrackManager.
   * @throws Error - the given id is linked to no text track.
   */ , _proto.setTextTrack = function setTextTrack(textId) {
                if (!this._priv_contentInfos) throw new Error("No content loaded");
                var currentPeriod = this._priv_contentInfos.currentPeriod;
                if (!this._priv_trackManager || !currentPeriod) throw new Error("No compatible content launched.");
                try {
                    this._priv_trackManager.setTextTrackByID(currentPeriod, textId);
                } catch (e) {
                    throw new Error("player: unknown text track");
                }
            }
            /**
   * Disable subtitles for the current content.
   */ , _proto.disableTextTrack = function disableTextTrack() {
                if (this._priv_contentInfos) {
                    var currentPeriod = this._priv_contentInfos.currentPeriod;
                    if (this._priv_trackManager && currentPeriod) return this._priv_trackManager.disableTextTrack(currentPeriod);
                }
            }
            /**
   * Update the video track for the current Period.
   * @param {string} videoId
   * @throws Error - the current content has no TrackManager.
   * @throws Error - the given id is linked to no video track.
   */ , _proto.setVideoTrack = function setVideoTrack(videoId) {
                if (!this._priv_contentInfos) throw new Error("No content loaded");
                var currentPeriod = this._priv_contentInfos.currentPeriod;
                if (!this._priv_trackManager || !currentPeriod) throw new Error("No compatible content launched.");
                try {
                    this._priv_trackManager.setVideoTrackByID(currentPeriod, videoId);
                } catch (e) {
                    throw new Error("player: unknown video track");
                }
            }
            /**
   * Returns the current list of preferred audio tracks, in preference order.
   * @returns {Array.<Object>}
   */ , _proto.getPreferredAudioTracks = function getPreferredAudioTracks() {
                return this._priv_preferredAudioTracks.getValue();
            }
            /**
   * Returns the current list of preferred text tracks, in preference order.
   * @returns {Array.<Object>}
   */ , _proto.getPreferredTextTracks = function getPreferredTextTracks() {
                return this._priv_preferredTextTracks.getValue();
            }
            /**
   * Set the list of preferred audio tracks, in preference order.
   * @param {Array.<Object>} tracks
   */ , _proto.setPreferredAudioTracks = function setPreferredAudioTracks(tracks) {
                return this._priv_preferredAudioTracks.next(tracks);
            }
            /**
   * Set the list of preferred text tracks, in preference order.
   * @param {Array.<Object>} tracks
   */ , _proto.setPreferredTextTracks = function setPreferredTextTracks(tracks) {
                return this._priv_preferredTextTracks.next(tracks);
            }
            /**
   * @returns {Array.<Object>|null}
   */ , _proto.getImageTrackData = function getImageTrackData() {
                return this._priv_contentInfos && this._priv_contentInfos.thumbnails;
            }
            /**
   * Get minimum seek-able position.
   * @returns {number}
   */ , _proto.getMinimumPosition = function getMinimumPosition() {
                if (!this._priv_contentInfos) return null;
                if (this._priv_contentInfos.isDirectFile) return 0;
                var manifest = this._priv_contentInfos.manifest;
                return null != manifest ? manifest.getMinimumPosition() : null;
            }
            /**
   * Get maximum seek-able position.
   * @returns {number}
   */ , _proto.getMaximumPosition = function getMaximumPosition() {
                if (!this._priv_contentInfos) return null;
                var _this$_priv_contentIn9 = this._priv_contentInfos, isDirectFile = _this$_priv_contentIn9.isDirectFile, manifest = _this$_priv_contentIn9.manifest;
                if (isDirectFile) {
                    if (!this.videoElement) throw new Error("Disposed player");
                    return this.videoElement.duration;
                }
                return null != manifest ? manifest.getMaximumPosition() : null;
            }
            /**
   * Reset all state properties relative to a playing content.
   * @private
   */ , _proto._priv_cleanUpCurrentContentState = function _priv_cleanUpCurrentContentState() {
                var _this4 = this;
                // lock playback of new contents while cleaning up is pending
                                this._priv_contentLock$.next(!0), this._priv_contentInfos = null, 
                this._priv_trackManager = null, this._priv_abrManager && (this._priv_abrManager.dispose(), 
                this._priv_abrManager = null), this._priv_contentEventsMemory = {};
                // EME cleaning
                var freeUpContentLock = function freeUpContentLock() {
                    _this4._priv_contentLock$.next(!1);
                };
                this.videoElement ? Object(eme_manager.a)(this.videoElement).pipe(Object(catchError.a)(function() {
                    return empty.a;
                })).subscribe(noop.a, freeUpContentLock, freeUpContentLock) : freeUpContentLock();
            }
            /**
   * Store and emit new player state (e.g. text track, videoBitrate...).
   * We check for deep equality to avoid emitting 2 consecutive times the same
   * state.
   * @param {string} eventName
   * @param {*} value - its new value
   * @private
   */ , _proto._priv_triggerContentEvent = function _priv_triggerContentEvent(eventName, value) {
                var prev = this._priv_contentEventsMemory[eventName];
                deep_equal_default()(prev, value) || (this._priv_contentEventsMemory[eventName] = value, 
                this.trigger(eventName, value));
            }
            /**
   * Triggered each time the playback Observable emits.
   *
   * React to various events.
   *
   * @param {Object} event - payload emitted
   * @private
   */ , _proto._priv_onPlaybackEvent = function _priv_onPlaybackEvent(event) {
                switch (event.type) {
                  case "activePeriodChanged":
                    this._priv_onActivePeriodChanged(event.value);
                    break;

                  case "periodBufferReady":
                    this._priv_onPeriodBufferReady(event.value);
                    break;

                  case "periodBufferCleared":
                    this._priv_onPeriodBufferCleared(event.value);
                    break;

                  case "reloading-media-source":
                    this._priv_onReloadingMediaSource();
                    break;

                  case "representationChange":
                    this._priv_onRepresentationChange(event.value);
                    break;

                  case "adaptationChange":
                    this._priv_onAdaptationChange(event.value);
                    break;

                  case "bitrateEstimationChange":
                    this._priv_onBitrateEstimationChange(event.value);
                    break;

                  case "manifestReady":
                    this._priv_onManifestReady(event.value);
                    break;

                  case "warning":
                    this._priv_onPlaybackWarning(event.value);
                    break;

                  case "added-segment":
                    if (!this._priv_contentInfos) return void log.a.error("API: Added segment while no content is loaded");
 // Manage image tracks
                    // TODO Better way? Perhaps linked to an ImageSourceBuffer
                    // implementation
                                        var _event$value = event.value, bufferType = _event$value.bufferType, segmentData = _event$value.segmentData;
                    if ("image" === bufferType && null != segmentData && "bif" === segmentData.type) {
                        var imageData = segmentData.data;
 // TODO merge multiple data from the same track together
                                                this._priv_contentInfos.thumbnails = imageData, this.trigger("imageTrackUpdate", {
                            data: this._priv_contentInfos.thumbnails
                        });
                    }
                }
            }
            /**
   * Triggered when we received a fatal error.
   * Clean-up ressources and signal that the content has stopped on error.
   * @param {Error} error
   * @private
   */ , _proto._priv_onPlaybackError = function _priv_onPlaybackError(error) {
                this._priv_stopCurrentContent$.next(), this._priv_cleanUpCurrentContentState(), 
                this._priv_currentError = error, log.a.error("API: The player stopped because of an error:", error), 
                this._priv_setPlayerState(PLAYER_STATES_STOPPED), // TODO This condition is here because the eventual callback called when the
                // player state is updated can launch a new content, thus the error will not
                // be here anymore, in which case triggering the "error" event is unwanted.
                // This is very ugly though, and we should probable have a better solution
                this._priv_currentError === error && this.trigger("error", error);
            }
            /**
   * Triggered when the playback Observable completes.
   * Clean-up ressources and signal that the content has ended.
   * @private
   */ , _proto._priv_onPlaybackFinished = function _priv_onPlaybackFinished() {
                this._priv_stopCurrentContent$.next(), this._priv_cleanUpCurrentContentState(), 
                this._priv_setPlayerState(PLAYER_STATES_ENDED);
            }
            /**
   * Triggered when we received a warning event during playback.
   * Trigger the right API event.
   * @param {Error} error
   * @private
   */ , _proto._priv_onPlaybackWarning = function _priv_onPlaybackWarning(error) {
                log.a.warn("API: Sending warning:", error), this.trigger("warning", error);
            }
            /**
   * Triggered when the Manifest has been loaded for the current content.
   * Initialize various private properties and emit initial event.
   * @param {Object} value
   * @private
   */ , _proto._priv_onManifestReady = function _priv_onManifestReady(value) {
                var _this5 = this;
                if (this._priv_contentInfos) {
                    var manifest = value.manifest, abrManager = value.abrManager;
                    this._priv_contentInfos.manifest = manifest, this._priv_abrManager = abrManager;
                    var _this$_priv_contentIn10 = this._priv_contentInfos, initialAudioTrack = _this$_priv_contentIn10.initialAudioTrack, initialTextTrack = _this$_priv_contentIn10.initialTextTrack;
                    this._priv_trackManager = new track_manager_TrackManager({
                        preferredAudioTracks: void 0 === initialAudioTrack ? this._priv_preferredAudioTracks : new BehaviorSubject_BehaviorSubject([ initialAudioTrack ]),
                        preferredTextTracks: void 0 === initialTextTrack ? this._priv_preferredTextTracks : new BehaviorSubject_BehaviorSubject([ initialTextTrack ])
                    }), Object(event_emitter.b)(manifest, "manifestUpdate").pipe(Object(takeUntil.a)(this._priv_stopCurrentContent$)).subscribe(function() {
                        // Update the tracks chosen if it changed
                        _this5._priv_trackManager && _this5._priv_trackManager.update();
                    });
                } else log.a.error("API: The manifest is loaded but no content is.");
            }
            /**
   * Triggered each times the current Period Changed.
   * Store and emit initial state for the Period.
   *
   * @param {Object} value
   * @private
   */ , _proto._priv_onActivePeriodChanged = function _priv_onActivePeriodChanged(_ref2) {
                var period = _ref2.period;
                if (this._priv_contentInfos) {
                    // Emit intial events for the Period
                    if (this._priv_contentInfos.currentPeriod = period, this._priv_triggerContentEvent("periodChange", period), 
                    this._priv_triggerContentEvent("availableAudioTracksChange", this.getAvailableAudioTracks()), 
                    this._priv_triggerContentEvent("availableTextTracksChange", this.getAvailableTextTracks()), 
                    this._priv_triggerContentEvent("availableVideoTracksChange", this.getAvailableVideoTracks()), 
                    this._priv_trackManager) {
                        var audioTrack = this._priv_trackManager.getChosenAudioTrack(period), textTrack = this._priv_trackManager.getChosenTextTrack(period), videoTrack = this._priv_trackManager.getChosenVideoTrack(period);
                        this._priv_triggerContentEvent("audioTrackChange", audioTrack), this._priv_triggerContentEvent("textTrackChange", textTrack), 
                        this._priv_triggerContentEvent("videoTrackChange", videoTrack);
                    } else this._priv_triggerContentEvent("audioTrackChange", null), this._priv_triggerContentEvent("textTrackChange", null), 
                    this._priv_triggerContentEvent("videoTrackChange", null);
                    this._priv_triggerContentEvent("availableAudioBitratesChange", this.getAvailableAudioBitrates()), 
                    this._priv_triggerContentEvent("availableVideoBitratesChange", this.getAvailableVideoBitrates());
                    var activeAudioRepresentations = this.getCurrentRepresentations();
                    if (activeAudioRepresentations && null != activeAudioRepresentations.audio) {
                        var bitrate = activeAudioRepresentations.audio.bitrate;
                        this._priv_triggerContentEvent("audioBitrateChange", null != bitrate ? bitrate : -1);
                    } else this._priv_triggerContentEvent("audioBitrateChange", -1);
                    var activeVideoRepresentations = this.getCurrentRepresentations();
                    if (activeVideoRepresentations && null != activeVideoRepresentations.video) {
                        var _bitrate = activeVideoRepresentations.video.bitrate;
                        this._priv_triggerContentEvent("videoBitrateChange", null != _bitrate ? _bitrate : -1);
                    } else this._priv_triggerContentEvent("videoBitrateChange", -1);
                } else log.a.error("API: The active period changed but no content is loaded");
            }
            /**
   * Triggered each times a new "PeriodBuffer" is ready.
   * Choose the right Adaptation for the Period and emit it.
   * @param {Object} value
   * @private
   */ , _proto._priv_onPeriodBufferReady = function _priv_onPeriodBufferReady(value) {
                var type = value.type, period = value.period, adaptation$ = value.adaptation$;
                switch (type) {
                  case "video":
                    this._priv_trackManager ? (this._priv_trackManager.addPeriod(type, period, adaptation$), 
                    this._priv_trackManager.setInitialVideoTrack(period)) : (log.a.error("API: TrackManager not instanciated for a new video period"), 
                    adaptation$.next(null));
                    break;

                  case "audio":
                    this._priv_trackManager ? (this._priv_trackManager.addPeriod(type, period, adaptation$), 
                    this._priv_trackManager.setInitialAudioTrack(period)) : (log.a.error("API: TrackManager not instanciated for a new " + type + " period"), 
                    adaptation$.next(null));
                    break;

                  case "text":
                    this._priv_trackManager ? (this._priv_trackManager.addPeriod(type, period, adaptation$), 
                    this._priv_trackManager.setInitialTextTrack(period)) : (log.a.error("API: TrackManager not instanciated for a new " + type + " period"), 
                    adaptation$.next(null));
                    break;

                  default:
                    var adaptations = period.adaptations[type];
                    adaptations && adaptations.length ? adaptation$.next(adaptations[0]) : adaptation$.next(null);
                }
            }
            /**
   * Triggered each times the we "remove" a PeriodBuffer.
   * @param {Object} value
   * @private
   */ , _proto._priv_onPeriodBufferCleared = function _priv_onPeriodBufferCleared(value) {
                var type = value.type, period = value.period;
 // Clean-up track choice from TrackManager
                                switch (type) {
                  case "audio":
                  case "text":
                  case "video":
                    this._priv_trackManager && this._priv_trackManager.removePeriod(type, period);
                }
 // Clean-up stored Representation and Adaptation information
                                if (null != this._priv_contentInfos) {
                    var _this$_priv_contentIn11 = this._priv_contentInfos, activeAdaptations = _this$_priv_contentIn11.activeAdaptations, activeRepresentations = _this$_priv_contentIn11.activeRepresentations;
                    activeAdaptations && activeAdaptations[period.id] && delete activeAdaptations[period.id], 
                    activeRepresentations && activeRepresentations[period.id] && delete activeRepresentations[period.id];
                }
            }
            /**
   * Triggered each time the content is re-loaded on the MediaSource.
   */ , _proto._priv_onReloadingMediaSource = function _priv_onReloadingMediaSource() {
                this._priv_trackManager && this._priv_trackManager.resetPeriods();
            }
            /**
   * Triggered each times a new Adaptation is considered for the current
   * content.
   * Store given Adaptation and emit it if from the current Period.
   * @param {Object} value
   * @private
   */ , _proto._priv_onAdaptationChange = function _priv_onAdaptationChange(_ref3) {
                var type = _ref3.type, adaptation = _ref3.adaptation, period = _ref3.period;
                if (this._priv_contentInfos) {
                    // lazily create this._priv_contentInfos.activeAdaptations
                    this._priv_contentInfos.activeAdaptations || (this._priv_contentInfos.activeAdaptations = {});
                    var _activeAdaptations$pe, _this$_priv_contentIn12 = this._priv_contentInfos, activeAdaptations = _this$_priv_contentIn12.activeAdaptations, currentPeriod = _this$_priv_contentIn12.currentPeriod, activePeriodAdaptations = activeAdaptations[period.id];
                    if (activePeriodAdaptations) activePeriodAdaptations[type] = adaptation; else activeAdaptations[period.id] = ((_activeAdaptations$pe = {})[type] = adaptation, 
                    _activeAdaptations$pe);
                    if (this._priv_trackManager && null != currentPeriod && null != period && period.id === currentPeriod.id) switch (type) {
                      case "audio":
                        var audioTrack = this._priv_trackManager.getChosenAudioTrack(currentPeriod);
                        this._priv_triggerContentEvent("audioTrackChange", audioTrack), this._priv_triggerContentEvent("availableAudioBitratesChange", this.getAvailableVideoBitrates());
                        break;

                      case "text":
                        var textTrack = this._priv_trackManager.getChosenTextTrack(currentPeriod);
                        this._priv_triggerContentEvent("textTrackChange", textTrack);
                        break;

                      case "video":
                        var videoTrack = this._priv_trackManager.getChosenVideoTrack(currentPeriod);
                        this._priv_triggerContentEvent("videoTrackChange", videoTrack), this._priv_triggerContentEvent("availableVideoBitratesChange", this.getAvailableVideoBitrates());
                    }
                } else log.a.error("API: The adaptations changed but no content is loaded");
            }
            /**
   * Triggered each times a new Representation is considered during playback.
   *
   * Store given Representation and emit it if from the current Period.
   *
   * @param {Object} obj
   * @private
   */ , _proto._priv_onRepresentationChange = function _priv_onRepresentationChange(_ref4) {
                var type = _ref4.type, period = _ref4.period, representation = _ref4.representation;
                if (this._priv_contentInfos) {
                    // lazily create this._priv_contentInfos.activeRepresentations
                    this._priv_contentInfos.activeRepresentations || (this._priv_contentInfos.activeRepresentations = {});
                    var _activeRepresentation, _this$_priv_contentIn13 = this._priv_contentInfos, activeRepresentations = _this$_priv_contentIn13.activeRepresentations, currentPeriod = _this$_priv_contentIn13.currentPeriod, activePeriodRepresentations = activeRepresentations[period.id];
                    if (activePeriodRepresentations) activePeriodRepresentations[type] = representation; else activeRepresentations[period.id] = ((_activeRepresentation = {})[type] = representation, 
                    _activeRepresentation);
                    var bitrate = representation && representation.bitrate;
                    null != bitrate && (this._priv_bitrateInfos.lastBitrates[type] = bitrate), null != period && null != currentPeriod && currentPeriod.id === period.id && ("video" === type ? this._priv_triggerContentEvent("videoBitrateChange", null != bitrate ? bitrate : -1) : "audio" === type && this._priv_triggerContentEvent("audioBitrateChange", null != bitrate ? bitrate : -1));
                } else log.a.error("API: The representations changed but no content is loaded");
            }
            /**
   * Triggered each time a bitrate estimate is calculated.
   *
   * Emit it.
   *
   * @param {Object} value
   * @private
   */ , _proto._priv_onBitrateEstimationChange = function _priv_onBitrateEstimationChange(_ref5) {
                var type = _ref5.type, bitrate = _ref5.bitrate;
                this._priv_triggerContentEvent("bitrateEstimationChange", {
                    type: type,
                    bitrate: bitrate
                });
            }
            /**
   * Triggered each time the videoElement alternates between play and pause.
   *
   * Emit the info through the right Subject.
   *
   * @param {Boolean} isPlaying
   * @private
   */ , _proto._priv_onPlayPauseNext = function _priv_onPlayPauseNext(isPlaying) {
                if (!this.videoElement) throw new Error("Disposed player");
                this._priv_playing$.next(isPlaying);
            }
            /**
   * Triggered each time a textTrack is added to the video DOM Element.
   *
   * Trigger the right Player Event.
   *
   * @param {Array.<TextTrackElement>} tracks
   * @private
   */ , _proto._priv_onNativeTextTracksNext = function _priv_onNativeTextTracksNext(tracks) {
                this.trigger("nativeTextTracksChange", tracks);
            }
            /**
   * Triggered each time the player state updates.
   *
   * Trigger the right Player Event.
   *
   * @param {string} newState
   * @private
   */ , _proto._priv_setPlayerState = function _priv_setPlayerState(newState) {
                this.state !== newState && (this.state = newState, log.a.info("API: playerStateChange event", newState), 
                this.trigger("playerStateChange", newState));
            }
            /**
   * Triggered each time a new clock tick object is emitted.
   *
   * Trigger the right Player Event
   *
   * @param {Object} clockTick
   * @private
   */ , _proto._priv_triggerTimeChange = function _priv_triggerTimeChange(clockTick) {
                if (this._priv_contentInfos) {
                    if (this.state !== PLAYER_STATES_RELOADING) {
                        var _this$_priv_contentIn14 = this._priv_contentInfos, isDirectFile = _this$_priv_contentIn14.isDirectFile, manifest = _this$_priv_contentIn14.manifest;
                        if ((isDirectFile || null != manifest) && clockTick) {
                            var positionData = {
                                position: clockTick.currentTime,
                                duration: clockTick.duration,
                                playbackRate: clockTick.playbackRate,
                                // TODO fix higher up?
                                bufferGap: isFinite(clockTick.bufferGap) ? clockTick.bufferGap : 0
                            };
                            null != manifest && manifest.isLive && 0 < clockTick.currentTime && (positionData.wallClockTime = clockTick.currentTime + (manifest.availabilityStartTime || 0), 
                            positionData.liveGap = manifest.getMaximumPosition() - clockTick.currentTime), this.trigger("positionUpdate", positionData);
                        }
                    }
                } else log.a.warn("API: Cannot perform time update: no content loaded.");
            }, Player;
        }(event_emitter.a);
        public_api_Player.version = 
        /*PLAYER_VERSION*/
        "3.11.1";
        /* harmony default export */ var api = public_api_Player;
        // CONCATENATED MODULE: ./src/core/api/index.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /* harmony default export */        
        // CONCATENATED MODULE: ./src/index.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * This file exports a Player class with a default feature set (depends on the
 * environment variables set at build).
 *
 * This is the class used from a regular build.
 */
        // set initial features according to environment variables
        !
        // CONCATENATED MODULE: ./src/features/initialize_features.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Selects the features to include based on environment variables.
 *
 * @param {Object} features
 */
        function initializeFeaturesObject() {
            features.a.emeManager = __webpack_require__(125).default, features.a.imageBuffer = __webpack_require__(164).default, 
            features.a.imageParser = __webpack_require__(148).default, features.a.transports.smooth = __webpack_require__(158).default, 
            features.a.transports.dash = __webpack_require__(157).default, features.a.nativeTextTracksBuffer = __webpack_require__(162).default, 
            features.a.nativeTextTracksParsers.vtt = __webpack_require__(163).default, features.a.nativeTextTracksParsers.ttml = __webpack_require__(165).default, 
            features.a.nativeTextTracksParsers.sami = __webpack_require__(149).default, features.a.nativeTextTracksParsers.srt = __webpack_require__(150).default, 
            features.a.htmlTextTracksBuffer = __webpack_require__(161).default, features.a.htmlTextTracksParsers.sami = __webpack_require__(151).default, 
            features.a.htmlTextTracksParsers.ttml = __webpack_require__(160).default, features.a.htmlTextTracksParsers.srt = __webpack_require__(152).default, 
            features.a.htmlTextTracksParsers.vtt = __webpack_require__(159).default, features.a.directfile = __webpack_require__(153).default;
        }();
        /* harmony default export */ __webpack_exports__.default = api;
        /***/    }, 
    /* 157 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/of.js
        var of = __webpack_require__(30), combineLatest = __webpack_require__(179), filter = __webpack_require__(139), map = __webpack_require__(34), mergeMap = __webpack_require__(39), features = __webpack_require__(10), src_manifest = __webpack_require__(104), utils = __webpack_require__(183), log = __webpack_require__(0), SEGMENT_ID = 408125543, INFO_ID = 357149030, TIMECODESCALE_ID = 2807729, DURATION_ID = 17545;
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/combineLatest.js
                /**
 * Find the offsets of the value linked to the given element ID.
 * @param {number} elementID - ID for the searched element.
 * @param {Array.<number>} parents - eventual IDs of the parent elements. From
 * top level to lower level (from the furthest to the closest).
 * @param {Uint8Array} buffer - buffer where the ID will be searched
 * @param {Array.<number>} range - start and end offsets in the buffer where the
 * ID will be searched.
 * @returns {Array.<number>|null}
 */
        function findNextElement(elementID, parents, buffer, _ref) {
            for (var initialOffset = _ref[0], maxOffset = _ref[1], currentOffset = initialOffset; currentOffset < maxOffset; ) {
                var parsedID = getEBMLID(buffer, currentOffset);
                if (null == parsedID) return null;
                var ebmlTagID = parsedID.value, sizeOffset = currentOffset + parsedID.length, parsedValue = getEBMLValue(buffer, sizeOffset);
                if (null == parsedValue) return null;
                var valueOffset = sizeOffset + parsedValue.length, valueEndOffset = valueOffset + parsedValue.value;
                if (ebmlTagID === elementID) return [ valueOffset, valueEndOffset ];
                if (parents.length) for (var i = 0; i < parents.length; i++) {
                    if (ebmlTagID === parents[i]) return findNextElement(elementID, parents.slice(i + 1, parents.length), buffer, [ valueOffset, valueEndOffset ]);
                }
                currentOffset = valueEndOffset;
            }
            return null;
        }
        /**
 * Return the timecode scale (basically timescale) of the whole file.
 * @param {Uint8Array} buffer
 * @param {number} initialOffset
 * @returns {number|null}
 */        function getTimeCodeScale(buffer, initialOffset) {
            var timeCodeScaleOffsets = findNextElement(TIMECODESCALE_ID, [ SEGMENT_ID, INFO_ID ], buffer, [ initialOffset, buffer.length ]);
            if (null == timeCodeScaleOffsets) return null;
            var length = timeCodeScaleOffsets[1] - timeCodeScaleOffsets[0];
            return 1e9 / bytesToNumber(buffer, timeCodeScaleOffsets[0], length);
        }
        /**
 * Return the duration of the concerned media.
 * @param {Uint8Array} buffer
 * @param {number} initialOffset
 * @returns {number|null}
 */        function getDuration(buffer, initialOffset) {
            var timeCodeScaleOffsets = findNextElement(DURATION_ID, [ SEGMENT_ID, INFO_ID ], buffer, [ initialOffset, buffer.length ]);
            if (null == timeCodeScaleOffsets) return null;
            var length = timeCodeScaleOffsets[1] - timeCodeScaleOffsets[0];
            return 4 === length ? get_IEEE754_32Bits(buffer, timeCodeScaleOffsets[0]) : 8 === length ? get_IEEE754_64Bits(buffer, timeCodeScaleOffsets[0]) : null;
        }
        /**
 * @param {Uint8Array} buffer
 * @param {number} initialOffset
 * @returns {Array.<Object>|null}
 */        function getSegmentsFromCues(buffer, initialOffset) {
            var segmentRange = findNextElement(SEGMENT_ID, [], buffer, [ initialOffset, buffer.length ]);
            if (null == segmentRange) return null;
            var segmentRangeStart = segmentRange[0], segmentRangeEnd = segmentRange[1], timescale = getTimeCodeScale(buffer, segmentRangeStart);
            if (null == timescale) return null;
            var duration = getDuration(buffer, segmentRangeStart);
            if (null == duration) return null;
            var cuesRange = findNextElement(475249515, [], buffer, [ segmentRangeStart, segmentRangeEnd ]);
            if (null == cuesRange) return null;
            for (var rawInfos = [], currentOffset = cuesRange[0]; currentOffset < cuesRange[1]; ) {
                var cuePointRange = findNextElement(187, [], buffer, [ currentOffset, cuesRange[1] ]);
                if (null == cuePointRange) break;
                var cueTimeRange = findNextElement(179, [], buffer, [ cuePointRange[0], cuePointRange[1] ]);
                if (null == cueTimeRange) return null;
                var time = bytesToNumber(buffer, cueTimeRange[0], cueTimeRange[1] - cueTimeRange[0]), cueOffsetRange = findNextElement(241, [ 183 ], buffer, [ cuePointRange[0], cuePointRange[1] ]);
                if (null == cueOffsetRange) return null;
                var rangeStart = bytesToNumber(buffer, cueOffsetRange[0], cueOffsetRange[1] - cueOffsetRange[0]) + segmentRangeStart;
                rawInfos.push({
                    time: time,
                    rangeStart: rangeStart
                }), currentOffset = cuePointRange[1];
            }
            for (var segments = [], i = 0; i < rawInfos.length; i++) {
                var currentSegment = rawInfos[i];
                i === rawInfos.length - 1 ? segments.push({
                    time: currentSegment.time,
                    count: 0,
                    timescale: timescale,
                    duration: 0 === i ? duration : duration - currentSegment.time,
                    range: [ currentSegment.rangeStart, Infinity ]
                }) : segments.push({
                    time: currentSegment.time,
                    count: 0,
                    timescale: timescale,
                    duration: rawInfos[i + 1].time - currentSegment.time,
                    range: [ currentSegment.rangeStart, rawInfos[i + 1].rangeStart - 1 ]
                });
            }
            return segments;
        }
        function getLength(buffer, offset) {
            for (var length = 1; length <= 8; length++) if (buffer[offset] >= Math.pow(2, 8 - length)) return length;
        }
        function getEBMLID(buffer, offset) {
            var length = getLength(buffer, offset);
            if (null == length) return log.a.warn("webm: unrepresentable length"), null;
            if (offset + length > buffer.length) return log.a.warn("webm: impossible length"), 
            null;
            for (var value = 0, i = 0; i < length; i++) value = buffer[offset + i] * Math.pow(2, 8 * (length - i - 1)) + value;
            return {
                length: length,
                value: value
            };
        }
        function getEBMLValue(buffer, offset) {
            var length = getLength(buffer, offset);
            if (null == length) return log.a.warn("webm: unrepresentable length"), null;
            if (offset + length > buffer.length) return log.a.warn("webm: impossible length"), 
            null;
            for (var value = (buffer[offset] & (1 << 8 - length) - 1) * Math.pow(2, 8 * (length - 1)), i = 1; i < length; i++) value = buffer[offset + i] * Math.pow(2, 8 * (length - i - 1)) + value;
            return {
                length: length,
                value: value
            };
        }
        /**
 * Convert a IEEE754 32 bits floating number as an Uint8Array into its
 * corresponding Number.
 * @param {Uint8Array} buffer
 * @param {number} offset
 * @returns {number}
 */        function get_IEEE754_32Bits(buffer, offset) {
            return new DataView(buffer.buffer).getFloat32(offset);
        }
        /**
 * Convert a IEEE754 64 bits floating number as an Uint8Array into its
 * corresponding Number.
 * @param {Uint8Array} buffer
 * @param {number} offset
 * @returns {number}
 */        function get_IEEE754_64Bits(buffer, offset) {
            return new DataView(buffer.buffer).getFloat64(offset);
        }
        function bytesToNumber(buffer, offset, length) {
            for (var value = 0, i = 0; i < length; i++) value = buffer[offset + i] * Math.pow(2, 8 * (length - i - 1)) + value;
            return value;
        }
        // EXTERNAL MODULE: ./src/config.ts
                var config = __webpack_require__(2), id_generator = __webpack_require__(48), resolve_url = __webpack_require__(32), check_manifest_ids = __webpack_require__(90);
        // EXTERNAL MODULE: ./src/utils/id_generator.ts
                // CONCATENATED MODULE: ./src/parsers/manifest/dash/get_presentation_live_gap.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Returns "last time of reference" from the adaptation given, considering a
 * live content.
 * Undefined if a time could not be found.
 *
 * We consider the earliest last time from every representations in the given
 * adaptation.
 * @param {Object} adaptation
 * @returns {Number|undefined}
 */
        function getLastLiveTimeReference(adaptation) {
            // Here's how we do, for each possibility:
            //
            //  1. every representations have an index:
            //    - returns minimum for every representations
            //
            //  2. no index for 1+ representation(s):
            //    - returns undefined
            //
            //  3. Invalid index found somewhere:
            //    - returns undefined
            if (adaptation) {
                var lastLiveTimeReferences = (adaptation.representations || []).map(function(representation) {
                    var lastPosition = representation.index.getLastPosition();
                    return null != lastPosition ? lastPosition : void 0;
                });
                if (!lastLiveTimeReferences.some(function(x) {
                    return null == x;
                })) {
                    var representationsMin = Math.min.apply(Math, lastLiveTimeReferences);
                    return isNaN(representationsMin) ? void 0 : representationsMin;
                }
            }
        }
        /**
 * Get presentation live gap from manifest informations.
 * @param {Object} manifest
 * @returns {number}
 */        function getPresentationLiveGap(manifest) {
            if (0 === manifest.periods.length) throw new Error("DASH Parser: no period available for a live content");
            var lastPeriodAdaptations = manifest.periods[manifest.periods.length - 1].adaptations, firstAdaptationsFromLastPeriod = lastPeriodAdaptations.video || lastPeriodAdaptations.audio;
            if (!firstAdaptationsFromLastPeriod || !firstAdaptationsFromLastPeriod.length) throw new Error("DASH Parser: Can't find first adaptation from last period");
            var lastRef = getLastLiveTimeReference(firstAdaptationsFromLastPeriod[0]), ast = manifest.availabilityStartTime || 0;
            return null != lastRef ? Date.now() / 1e3 - (lastRef + ast) : 10;
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/ContentComponent.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Parse a "ContentComponent" Element in a DASH MPD.
 * @param {Element} root
 * @returns {Object}
 */        function parseContentComponent(root) {
            for (var ret = {}, i = 0; i < root.attributes.length; i++) {
                var attribute = root.attributes[i];
                switch (attribute.name) {
                  case "id":
                    ret.id = attribute.value;
                    break;

                  case "lang":
                    ret.language = attribute.value;
                    break;

                  case "contentType":
                    ret.contentType = attribute.value;
                    break;

                  case "par":
                    ret.par = attribute.value;
                }
            }
            return ret;
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/ContentProtection.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Parse the "ContentProtection" node of a MPD.
 * @param {Element} root
 * @returns {Object}
 */        function parseContentProtection(root) {
            for (var schemeIdUri, value, i = 0; i < root.attributes.length; i++) {
                var attribute = root.attributes[i];
                switch (attribute.name) {
                  case "schemeIdUri":
                    schemeIdUri = attribute.value;
                    break;

                  case "value":
                    value = attribute.value;
                }
            }
 // TODO Take systemId from PSSH?
            // for (let i = 0; i < root.childElementCount; i++) {
            //   const child = root.children[i];
            //   if (child.nodeName === "cenc:pssh" && child.textContent) {
            //     pssh = atob(child.textContent);
            //   }
            // }
                        return {
                schemeIdUri: schemeIdUri,
                value: value
            };
        }
        // EXTERNAL MODULE: ./node_modules/object-assign/index.js
                var object_assign = __webpack_require__(9), object_assign_default = /* */ __webpack_require__.n(object_assign), iso8601Duration = /^P(([\d.]*)Y)?(([\d.]*)M)?(([\d.]*)D)?T?(([\d.]*)H)?(([\d.]*)M)?(([\d.]*)S)?/, rangeRe = /([0-9]+)-([0-9]+)/;
        /**
 * Parse MPD boolean attributes.
 * @param {string} str
 * @returns {Boolean}
 */
        function parseBoolean(str) {
            return "true" === str;
        }
        /**
 * Parse some MPD attributes.
 * @param {string} str
 * @returns {Boolean|Number}
 */        function parseIntOrBoolean(str) {
            return "true" === str || "false" !== str && parseInt(str, 10);
        }
        /**
 * Parse MPD date attributes.
 * @param {string} str
 * @returns {Date}
 */        function parseDateTime(str) {
            return new Date(Date.parse(str)).getTime() / 1e3;
        }
        /**
 * Parse MPD ISO8601 duration attributes into seconds.
 * @param {string} date
 * @returns {Number}
 */        function parseDuration(date) {
            if (!date) return 0;
            var match = iso8601Duration.exec(date);
            if (null == match) throw new Error(date + " is not a valid ISO8601 duration");
            return 365 * parseFloat(match[2] || "0") * 24 * 60 * 60 + 30 * parseFloat(match[4] || "0") * 24 * 60 * 60 + // not precise +
            24 * parseFloat(match[6] || "0") * 60 * 60 + 60 * parseFloat(match[8] || "0") * 60 + 60 * parseFloat(match[10] || "0") + parseFloat(match[12] || "0");
        }
        /**
 * Parse MPD byterange attributes into arrays of two elements: the start and
 * the end.
 * @param {string} str
 * @returns {Array.<Number>}
 */        function parseByteRange(str) {
            var match = rangeRe.exec(str);
            return match ? [ +match[1], +match[2] ] : null;
        }
        /**
 * @param {Element} root
 * @returns {Object}
 */        function parseScheme(root) {
            for (var schemeIdUri, value, i = 0; i < root.attributes.length; i++) {
                var attribute = root.attributes[i];
                switch (attribute.name) {
                  case "schemeIdUri":
                    schemeIdUri = attribute.value;
                    break;

                  case "value":
                    value = attribute.value;
                }
            }
            return {
                schemeIdUri: schemeIdUri,
                value: value
            };
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/Initialization.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {Element} root
 * @returns {Object}
 */        function parseInitialization(root) {
            for (var parsedInitialization = {}, i = 0; i < root.attributes.length; i++) {
                var attribute = root.attributes[i];
                switch (attribute.name) {
                  case "range":
                    var range = parseByteRange(attribute.value);
                    null == range ? log.a.warn('DASH: invalid range ("' + attribute.value + '")') : parsedInitialization.range = range;
                    break;

                  case "sourceURL":
                    parsedInitialization.media = attribute.value;
                }
            }
            return parsedInitialization;
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/SegmentBase.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {Element} root
 * @returns {Object}
 */        function parseSegmentBase(root) {
            for (var attributes = {}, segmentBaseChildren = root.childNodes, i = 0; i < segmentBaseChildren.length; i++) if (segmentBaseChildren[i].nodeType === Node.ELEMENT_NODE) {
                var currentNode = segmentBaseChildren[i];
                "Initialization" === currentNode.nodeName && (attributes.initialization = parseInitialization(currentNode));
            }
            for (var _i = 0; _i < root.attributes.length; _i++) {
                var attribute = root.attributes[_i];
                switch (attribute.name) {
                  case "timescale":
                    var _timescale = parseInt(attribute.value, 10);
                    isNaN(_timescale) ? log.a.warn('DASH: invalid timescale ("' + attribute.value + '")') : attributes.timescale = _timescale;
                    break;

                  case "timeShiftBufferDepth":
                    var timeShiftBufferDepth = parseDuration(attribute.value);
                    isNaN(timeShiftBufferDepth) ? log.a.warn('DASH: invalid timeShiftBufferDepth ("' + attribute.value + '")') : attributes.timeShiftBufferDepth = timeShiftBufferDepth;
                    break;

                  case "presentationTimeOffset":
                    var _presentationTimeOffset = parseFloat(attribute.value);
                    isNaN(_presentationTimeOffset) ? log.a.warn('DASH: invalid presentationTimeOffset ("' + attribute.value + '")') : attributes.presentationTimeOffset = _presentationTimeOffset;
                    break;

                  case "indexRange":
                    attributes.indexRange = parseByteRange(attribute.value) || void 0;
                    break;

                  case "indexRangeExact":
                    attributes.indexRangeExact = parseBoolean(attribute.value);
                    break;

                  case "availabilityTimeOffset":
                    var availabilityTimeOffset = parseFloat(attribute.value);
                    isNaN(availabilityTimeOffset) ? log.a.warn('DASH: invalid availabilityTimeOffset ("' + attribute.value + '")') : attributes.availabilityTimeOffset = availabilityTimeOffset;
                    break;

                  case "availabilityTimeComplete":
                    attributes.availabilityTimeComplete = parseBoolean(attribute.value);
                    break;

                  case "duration":
                    var duration = parseInt(attribute.value, 10);
                    isNaN(duration) ? log.a.warn('DASH: invalid duration ("' + attribute.value + '")') : attributes.duration = duration;
                    break;

                  case "startNumber":
                    var startNumber = parseInt(attribute.value, 10);
                    isNaN(startNumber) ? log.a.warn('DASH: invalid startNumber ("' + attribute.value + '")') : attributes.startNumber = startNumber;
                }
            }
            var timescale = null == attributes.timescale ? 1 : attributes.timescale, indexRangeExact = !!attributes.indexRangeExact, availabilityTimeComplete = null == attributes.availabilityTimeComplete || attributes.availabilityTimeComplete;
            return object_assign_default()(attributes, {
                availabilityTimeComplete: availabilityTimeComplete,
                indexRangeExact: indexRangeExact,
                timeline: [],
                timescale: timescale
            });
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/SegmentURL.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {Element} root
 * @returns {Object}
 */        function parseSegmentURL(root) {
            for (var parsedSegmentURL = {}, i = 0; i < root.attributes.length; i++) {
                var attribute = root.attributes[i];
                switch (attribute.name) {
                  case "media":
                    parsedSegmentURL.media = attribute.value;
                    break;

                  case "indexRange":
                    var indexRange = parseByteRange(attribute.value) || void 0;
                    indexRange ? parsedSegmentURL.indexRange = indexRange : log.a.warn('DASH: invalid indexRange ("' + attribute.value + '")');
                    break;

                  case "index":
                    parsedSegmentURL.index = attribute.value;
                    break;

                  case "mediaRange":
                    var mediaRange = parseByteRange(attribute.value) || void 0;
                    mediaRange ? parsedSegmentURL.mediaRange = mediaRange : log.a.warn('DASH: invalid mediaRange ("' + attribute.value + '")');
                }
            }
            return parsedSegmentURL;
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/SegmentList.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {Element} root
 * @returns {Object}
 */        function parseSegmentList(root) {
            for (var base = parseSegmentBase(root), list = [], segmentListChildren = root.childNodes, i = 0; i < segmentListChildren.length; i++) if (segmentListChildren[i].nodeType === Node.ELEMENT_NODE) {
                var currentNode = segmentListChildren[i];
                if ("SegmentURL" === currentNode.nodeName) {
                    var segmentURL = parseSegmentURL(currentNode);
                    list.push(segmentURL);
                }
            }
            var baseDuration = base.duration;
            if (null == baseDuration) throw new Error("Invalid SegmentList: no duration");
            return object_assign_default()(base, {
                list: list,
                duration: baseDuration
            });
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/S.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {Element} root
 * @returns {Object}
 */        function parseS(root) {
            for (var parsedS = {}, j = 0; j < root.attributes.length; j++) {
                var attribute = root.attributes[j];
                switch (attribute.name) {
                  case "t":
                    var start = parseInt(attribute.value, 10);
                    isNaN(start) ? log.a.warn('DASH: invalid t ("' + attribute.value + '")') : parsedS.start = start;
                    break;

                  case "d":
                    var duration = parseInt(attribute.value, 10);
                    isNaN(duration) ? log.a.warn('DASH: invalid d ("' + attribute.value + '")') : parsedS.duration = duration;
                    break;

                  case "r":
                    var repeatCount = parseInt(attribute.value, 10);
                    isNaN(repeatCount) ? log.a.warn('DASH: invalid r ("' + attribute.value + '")') : parsedS.repeatCount = repeatCount;
                }
            }
            return parsedS;
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/SegmentTimeline.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {Element} root
 * @returns {Array.<Object>}
 */        function parseSegmentTimeline(root) {
            for (var parsedS = [], timelineChildren = root.childNodes, i = 0; i < timelineChildren.length; i++) if (timelineChildren[i].nodeType === Node.ELEMENT_NODE) {
                var currentElement = timelineChildren[i];
                if ("S" === currentElement.nodeName) {
                    var s = parseS(currentElement);
                    parsedS.push(s);
                }
            }
            return parsedS;
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/SegmentTemplate.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Parse initialization attribute found in segment Template to
 * correspond to the initialization found in a regular segmentBase.
 * @param {string} attrValue
 * @returns {Object}
 */        function parseInitializationAttribute(attrValue) {
            return {
                media: attrValue
            };
        }
        /**
 * @param {Element} root
 * @returns {Object}
 */        function parseSegmentTemplate(root) {
            for (var ret, index, media, bitstreamSwitching, timeline, base = parseSegmentBase(root), i = 0; i < root.childNodes.length; i++) if (root.childNodes[i].nodeType === Node.ELEMENT_NODE) {
                var currentNode = root.childNodes[i];
                "SegmentTimeline" === currentNode.nodeName && (timeline = parseSegmentTimeline(currentNode));
            }
            for (var _i = 0; _i < root.attributes.length; _i++) {
                var attribute = root.attributes[_i];
                switch (attribute.nodeName) {
                  case "initialization":
                    null == base.initialization && (base.initialization = parseInitializationAttribute(attribute.value));
                    break;

                  case "index":
                    index = attribute.value;
                    break;

                  case "media":
                    media = attribute.value;
                    break;

                  case "bitstreamSwitching":
                    bitstreamSwitching = parseBoolean(attribute.value);
                }
            }
            if (null != timeline) ret = object_assign_default()({}, base, {
                indexType: "timeline",
                timeline: timeline
            }); else {
                var segmentDuration = base.duration;
                if (null == segmentDuration) throw new Error("Invalid SegmentTemplate: no duration");
                ret = object_assign_default()({}, base, {
                    indexType: "template",
                    duration: segmentDuration
                });
            }
            return null != index && (ret.index = index), null != media && (ret.media = media), 
            null != bitstreamSwitching && (ret.bitstreamSwitching = bitstreamSwitching), ret;
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/Representation.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {NodeList} representationChildren
 * @returns {Object}
 */        function parseRepresentationChildren(representationChildren) {
            for (var children = {
                baseURL: ""
            }, i = 0; i < representationChildren.length; i++) if (representationChildren[i].nodeType === Node.ELEMENT_NODE) {
                var currentElement = representationChildren[i];
                switch (currentElement.nodeName) {
                  case "BaseURL":
                    children.baseURL = currentElement.textContent || "";
                    break;

                  case "SegmentBase":
                    children.segmentBase = parseSegmentBase(currentElement);
                    break;

                  case "SegmentList":
                    children.segmentList = parseSegmentList(currentElement);
                    break;

                  case "SegmentTemplate":
                    children.segmentTemplate = parseSegmentTemplate(currentElement);
                }
            }
            return children;
        }
        /**
 * @param {Element} representationElement
 * @returns {Object}
 */        function parseRepresentationAttributes(representationElement) {
            for (var attributes = {}, i = 0; i < representationElement.attributes.length; i++) {
                var attribute = representationElement.attributes[i];
                switch (attribute.name) {
                  case "audioSamplingRate":
                    attributes.audioSamplingRate = attribute.value;
                    break;

                  case "bandwidth":
                    var bitrate = parseInt(attribute.value, 10);
                    isNaN(bitrate) ? log.a.warn('DASH: invalid bandwidth ("' + attribute.value + '")') : attributes.bitrate = bitrate;
                    break;

                  case "codecs":
                    attributes.codecs = attribute.value;
                    break;

                  case "codingDependency":
                    attributes.codingDependency = parseBoolean(attribute.value);
                    break;

                  case "frameRate":
                    attributes.frameRate = attribute.value;
                    break;

                  case "height":
                    var height = parseInt(attribute.value, 10);
                    isNaN(height) ? log.a.warn('DASH: invalid height ("' + attribute.value + '")') : attributes.height = height;
                    break;

                  case "id":
                    attributes.id = attribute.value;
                    break;

                  case "maxPlayoutRate":
                    var maxPlayoutRate = parseFloat(attribute.value);
                    isNaN(maxPlayoutRate) ? log.a.warn('DASH: invalid maxPlayoutRate ("' + attribute.value + '")') : attributes.maxPlayoutRate = maxPlayoutRate;
                    break;

                  case "maximumSAPPeriod":
                    var maximumSAPPeriod = parseFloat(attribute.value);
                    isNaN(maximumSAPPeriod) ? log.a.warn('DASH: invalid maximumSAPPeriod ("' + attribute.value + '")') : attributes.maximumSAPPeriod = maximumSAPPeriod;
                    break;

                  case "mimeType":
                    attributes.mimeType = attribute.value;
                    break;

                  case "profiles":
                    attributes.profiles = attribute.value;
                    break;

                  case "qualityRanking":
                    var qualityRanking = parseInt(attribute.value, 10);
                    isNaN(qualityRanking) ? log.a.warn('DASH: invalid qualityRanking ("' + attribute.value + '")') : attributes.qualityRanking = qualityRanking;
                    break;

                  case "segmentProfiles":
                    attributes.segmentProfiles = attribute.value;
                    break;

                  case "width":
                    var width = parseInt(attribute.value, 10);
                    isNaN(width) ? log.a.warn('DASH: invalid width ("' + attribute.value + '")') : attributes.width = width;
                }
            }
            return attributes;
        }
        function createRepresentationIntermediateRepresentation(representationElement) {
            return {
                children: parseRepresentationChildren(representationElement.childNodes),
                attributes: parseRepresentationAttributes(representationElement)
            };
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/AdaptationSet.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        function parseAdaptationSetChildren(adaptationSetChildren) {
            for (var children = {
                baseURL: "",
                representations: []
            }, contentProtections = [], i = 0; i < adaptationSetChildren.length; i++) if (adaptationSetChildren[i].nodeType === Node.ELEMENT_NODE) {
                var currentElement = adaptationSetChildren[i];
                switch (currentElement.nodeName) {
                  case "Accessibility":
                    children.accessibility = parseScheme(currentElement);
                    break;

                  case "BaseURL":
                    children.baseURL = currentElement.textContent || "";
                    break;

                  case "ContentComponent":
                    children.contentComponent = parseContentComponent(currentElement);
                    break;

                  case "Representation":
                    var representation = createRepresentationIntermediateRepresentation(currentElement);
                    children.representations.push(representation);
                    break;

                  case "Role":
                    null == children.roles ? children.roles = [ parseScheme(currentElement) ] : children.roles.push(parseScheme(currentElement));
                    break;

                  case "SupplementalProperty":
                    null == children.supplementalProperties ? children.supplementalProperties = [ parseScheme(currentElement) ] : children.supplementalProperties.push(parseScheme(currentElement));
                    break;

                  case "SegmentBase":
                    children.segmentBase = parseSegmentBase(currentElement);
                    break;

                  case "SegmentList":
                    children.segmentList = parseSegmentList(currentElement);
                    break;

                  case "SegmentTemplate":
                    children.segmentTemplate = parseSegmentTemplate(currentElement);
                    break;

                  case "ContentProtection":
                    var contentProtection = parseContentProtection(currentElement);
                    contentProtection && contentProtections.push(contentProtection);
 // case "Rating":
                    //   children.rating = currentElement;
                    //   break;
                    // case "Viewpoint":
                    //   children.viewpoint = currentElement;
                    //   break;
                                }
            }
            return contentProtections.length && (children.contentProtections = contentProtections), 
            children;
        }
        function parseAdaptationSetAttributes(root) {
            for (var parsedAdaptation = {}, i = 0; i < root.attributes.length; i++) {
                var attribute = root.attributes[i];
                switch (attribute.name) {
                  case "id":
                    parsedAdaptation.id = attribute.value;
                    break;

                  case "group":
                    var group = parseInt(attribute.value, 10);
                    isNaN(group) ? log.a.warn('DASH: invalid group ("' + attribute.value + '")') : parsedAdaptation.group = group;
                    break;

                  case "lang":
                    parsedAdaptation.language = attribute.value;
                    break;

                  case "contentType":
                    parsedAdaptation.contentType = attribute.value;
                    break;

                  case "par":
                    parsedAdaptation.par = attribute.value;
                    break;

                  case "minBandwidth":
                    var minBitrate = parseInt(attribute.value, 10);
                    isNaN(minBitrate) ? log.a.warn('DASH: invalid minBandwidth ("' + attribute.value + '")') : parsedAdaptation.minBitrate = minBitrate;
                    break;

                  case "maxBandwidth":
                    var maxBitrate = parseInt(attribute.value, 10);
                    isNaN(maxBitrate) ? log.a.warn('DASH: invalid maxBandwidth ("' + attribute.value + '")') : parsedAdaptation.maxBitrate = maxBitrate;
                    break;

                  case "minWidth":
                    var minWidth = parseInt(attribute.value, 10);
                    isNaN(minWidth) ? log.a.warn('DASH: invalid minWidth ("' + attribute.value + '")') : parsedAdaptation.minWidth = minWidth;
                    break;

                  case "maxWidth":
                    var maxWidth = parseInt(attribute.value, 10);
                    isNaN(maxWidth) ? log.a.warn('DASH: invalid maxWidth ("' + attribute.value + '")') : parsedAdaptation.maxWidth = maxWidth;
                    break;

                  case "minHeight":
                    var minHeight = parseInt(attribute.value, 10);
                    isNaN(minHeight) ? log.a.warn('DASH: invalid minHeight ("' + attribute.value + '")') : parsedAdaptation.minHeight = minHeight;
                    break;

                  case "maxHeight":
                    var maxHeight = parseInt(attribute.value, 10);
                    isNaN(maxHeight) ? log.a.warn('DASH: invalid maxHeight ("' + attribute.value + '")') : parsedAdaptation.maxHeight = maxHeight;
                    break;

                  case "minFrameRate":
                    parsedAdaptation.minFrameRate = attribute.value;
                    break;

                  case "maxFrameRate":
                    parsedAdaptation.maxFrameRate = attribute.value;
                    break;

                  case "segmentAlignment":
                    var segmentAlignment = parseIntOrBoolean(attribute.value);
                    "number" == typeof segmentAlignment && isNaN(segmentAlignment) ? log.a.warn('DASH: invalid segmentAlignment ("' + attribute.value + '")') : parsedAdaptation.segmentAlignment = segmentAlignment;
                    break;

                  case "subsegmentAlignment":
                    var subsegmentAlignment = parseIntOrBoolean(attribute.value);
                    "number" == typeof subsegmentAlignment && isNaN(subsegmentAlignment) ? log.a.warn('DASH: invalid subsegmentAlignment ("' + attribute.value + '")') : parsedAdaptation.subsegmentAlignment = subsegmentAlignment;
                    break;

                  case "bitstreamSwitching":
                    parsedAdaptation.bitstreamSwitching = parseBoolean(attribute.value);
                    break;

                  case "audioSamplingRate":
                    parsedAdaptation.audioSamplingRate = attribute.value;
                    break;

                  case "codecs":
                    parsedAdaptation.codecs = attribute.value;
                    break;

                  case "codingDependency":
                    parsedAdaptation.codingDependency = parseBoolean(attribute.value);
                    break;

                  case "frameRate":
                    parsedAdaptation.frameRate = attribute.value;
                    break;

                  case "height":
                    var height = parseInt(attribute.value, 10);
                    isNaN(height) ? log.a.warn('DASH: invalid height ("' + attribute.value + '")') : parsedAdaptation.height = height;
                    break;

                  case "maxPlayoutRate":
                    var maxPlayoutRate = parseFloat(attribute.value);
                    isNaN(maxPlayoutRate) ? log.a.warn('DASH: invalid maxPlayoutRate ("' + attribute.value + '")') : parsedAdaptation.maxPlayoutRate = maxPlayoutRate;
                    break;

                  case "maximumSAPPeriod":
                    var maximumSAPPeriod = parseFloat(attribute.value);
                    isNaN(maximumSAPPeriod) ? log.a.warn('DASH: invalid maximumSAPPeriod ("' + attribute.value + '")') : parsedAdaptation.maximumSAPPeriod = maximumSAPPeriod;
                    break;

                  case "mimeType":
                    parsedAdaptation.mimeType = attribute.value;
                    break;

                  case "profiles":
                    parsedAdaptation.profiles = attribute.value;
                    break;

                  case "segmentProfiles":
                    parsedAdaptation.segmentProfiles = attribute.value;
                    break;

                  case "width":
                    var width = parseInt(attribute.value, 10);
                    isNaN(width) ? log.a.warn('DASH: invalid width ("' + attribute.value + '")') : parsedAdaptation.width = width;
                }
            }
            return parsedAdaptation;
        }
        function createAdaptationSetIntermediateRepresentation(adaptationSetElement) {
            return {
                children: parseAdaptationSetChildren(adaptationSetElement.childNodes),
                attributes: parseAdaptationSetAttributes(adaptationSetElement)
            };
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/Period.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {NodeList} periodChildren
 * @returns {Object}
 */        function parsePeriodChildren(periodChildren) {
            for (var baseURL = "", adaptations = [], i = 0; i < periodChildren.length; i++) if (periodChildren[i].nodeType === Node.ELEMENT_NODE) {
                var currentElement = periodChildren[i];
                switch (currentElement.nodeName) {
                  case "BaseURL":
                    baseURL = currentElement.textContent || "";
                    break;

                  case "AdaptationSet":
                    var adaptation = createAdaptationSetIntermediateRepresentation(currentElement);
                    adaptations.push(adaptation);
                }
            }
            return {
                baseURL: baseURL,
                adaptations: adaptations
            };
        }
        /**
 * @param {Element} periodElement
 * @returns {Object}
 */        function parsePeriodAttributes(periodElement) {
            for (var res = {}, i = 0; i < periodElement.attributes.length; i++) {
                var attribute = periodElement.attributes[i];
                switch (attribute.name) {
                  case "id":
                    res.id = attribute.value;
                    break;

                  case "start":
                    var tempStart = parseDuration(attribute.value);
                    isNaN(tempStart) ? log.a.warn("DASH: Unrecognized start in the mpd:", attribute.value) : res.start = tempStart;
                    break;

                  case "duration":
                    var tempDuration = parseDuration(attribute.value);
                    isNaN(tempDuration) ? log.a.warn("DASH: Unrecognized duration in the mpd:", attribute.value) : res.duration = tempDuration;
                    break;

                  case "bitstreamSwitching":
                    res.bitstreamSwitching = parseBoolean(attribute.value);
                    break;

                  case "xlink:href":
                    res.xlinkHref = attribute.value;
                    break;

                  case "xlink:actuate":
                    res.xlinkActuate = attribute.value;
                }
            }
            return res;
        }
        function createPeriodIntermediateRepresentation(periodElement) {
            return {
                children: parsePeriodChildren(periodElement.childNodes),
                attributes: parsePeriodAttributes(periodElement)
            };
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/MPD.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Parse children of the MPD's root into a simple object.
 * @param {NodeList} mpdChildren
 * @returns {Object}
 */        function parseMPDChildren(mpdChildren) {
            for (var baseURL = "", locations = [], periods = [], i = 0; i < mpdChildren.length; i++) if (mpdChildren[i].nodeType === Node.ELEMENT_NODE) {
                var currentNode = mpdChildren[i];
                switch (currentNode.nodeName) {
                  case "BaseURL":
                    baseURL = currentNode.textContent || "";
                    break;

                  case "Location":
                    locations.push(currentNode.textContent || "");
                    break;

                  case "Period":
                    var period = createPeriodIntermediateRepresentation(currentNode);
                    periods.push(period);
                }
            }
            return {
                baseURL: baseURL,
                locations: locations,
                periods: periods
            };
        }
        /**
 * @param {Element} root
 * @returns {Object}
 */        function parseMPDAttributes(root) {
            for (var res = {}, i = 0; i < root.attributes.length; i++) {
                var attribute = root.attributes[i];
                switch (attribute.name) {
                  case "id":
                    res.id = attribute.value;
                    break;

                  case "profiles":
                    res.profiles = attribute.value;
                    break;

                  case "type":
                    res.type = attribute.value;
                    break;

                  case "availabilityStartTime":
                    res.availabilityStartTime = +parseDateTime(attribute.value);
                    break;

                  case "availabilityEndTime":
                    res.availabilityEndTime = +parseDateTime(attribute.value);
                    break;

                  case "publishTime":
                    res.publishTime = +parseDateTime(attribute.value);
                    break;

                  case "mediaPresentationDuration":
                    res.duration = parseDuration(attribute.value);
                    break;

                  case "minimumUpdatePeriod":
                    res.minimumUpdatePeriod = parseDuration(attribute.value);
                    break;

                  case "minBufferTime":
                    res.minBufferTime = parseDuration(attribute.value);
                    break;

                  case "timeShiftBufferDepth":
                    res.timeShiftBufferDepth = parseDuration(attribute.value);
                    break;

                  case "suggestedPresentationDelay":
                    res.suggestedPresentationDelay = parseDuration(attribute.value);
                    break;

                  case "maxSegmentDuration":
                    res.maxSegmentDuration = parseDuration(attribute.value);
                    break;

                  case "maxSubsegmentDuration":
                    res.maxSubsegmentDuration = parseDuration(attribute.value);
                }
            }
            return res;
        }
        function createMPDIntermediateRepresentation(root) {
            return {
                children: parseMPDChildren(root.childNodes),
                attributes: parseMPDAttributes(root)
            };
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/flatten_overlapping_periods.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Avoid periods to overlap.
 *
 * According to DASH guidelines, if a period has media duration longer than
 * the distance between the start of this period and the start of the next period,
 * use of start times implies that the client will start the playout of the next
 * period at the time stated, rather than finishing the playout of the last period.
 *
 * Even if that case if defined when period last(s) segment(s) is/are a bit longer,
 * it can be meaningful when two periods are overlapping. We will always shorten
 * the first period, and even erase it if its duration is equal to zero.
 *
 * Example (Periods are numbered under their manifest order) :
 *
 * [ Period 1 ][ Period 2 ]       ------>  [ Period 1 ][ Period 3 ]
 *             [ Period 3 ]
 *
 * [ Period 1 ][ Period 2 ]       ------>  [ Period 1 ][  2  ][ Period 3 ]
 *                  [ Period 3 ]
 *
 * [ Period 1 ][ Period 2 ]       ------>  [  1  ][      Period 3     ]
 *        [      Period 3     ]
 *
 * @param {Array.<Object>} parsedPeriods
 * @return {Array.<Object>}
 */        function flattenOverlappingPeriods(parsedPeriods) {
            if (0 === parsedPeriods.length) return [];
            for (var flattenedPeriods = [ parsedPeriods[0] ], i = 1; i < parsedPeriods.length; i++) {
                for (var parsedPeriod = parsedPeriods[i], lastFlattenedPeriod = flattenedPeriods[flattenedPeriods.length - 1]; null == lastFlattenedPeriod.duration || lastFlattenedPeriod.start + lastFlattenedPeriod.duration > parsedPeriod.start; ) log.a.warn("DASH: Updating overlapping Periods.", lastFlattenedPeriod, parsedPeriod), 
                lastFlattenedPeriod.duration = parsedPeriod.start - lastFlattenedPeriod.start, lastFlattenedPeriod.end = parsedPeriod.start, 
                lastFlattenedPeriod.duration <= 0 && (flattenedPeriods.pop(), lastFlattenedPeriod = flattenedPeriods[flattenedPeriods.length - 1]);
                flattenedPeriods.push(parsedPeriod);
            }
            return flattenedPeriods;
        }
        // EXTERNAL MODULE: ./src/utils/array_find.ts
                var array_find = __webpack_require__(11), array_includes = __webpack_require__(12), KNOWN_ADAPTATION_TYPES = [ "audio", "video", "text", "image" ], SUPPORTED_TEXT_TYPES = [ "subtitle", "caption" ];
        // EXTERNAL MODULE: ./src/utils/array_includes.ts
                /**
 * Infers the type of adaptation from codec and mimetypes found in it.
 *
 * This follows the guidelines defined by the DASH-IF IOP:
 *   - one adaptation set contains a single media type
 *   - The order of verifications are:
 *       1. mimeType
 *       2. Role
 *       3. codec
 *
 * Note: This is based on DASH-IF-IOP-v4.0 with some more freedom.
 * @param {Object} adaptation
 * @returns {string} - "audio"|"video"|"text"|"image"|"metadata"|"unknown"
 */
        function inferAdaptationType(adaptationMimeType, representationMimeTypes, adaptationCodecs, representationCodecs, adaptationRoles) {
            function fromMimeType(mimeType, roles) {
                var topLevel = mimeType.split("/")[0];
                return Object(array_includes.a)(KNOWN_ADAPTATION_TYPES, topLevel) ? topLevel : "application/bif" === mimeType ? "image" : "application/ttml+xml" === mimeType ? "text" : // manage DASH-IF mp4-embedded subtitles and metadata
                "application/mp4" === mimeType ? null != roles && null != Object(array_find.a)(roles, function(role) {
                    return "urn:mpeg:dash:role:2011" === role.schemeIdUri && Object(array_includes.a)(SUPPORTED_TEXT_TYPES, role.value);
                }) ? "text" : "metadata" : void 0;
            }
            function fromCodecs(codecs) {
                switch (codecs.substring(0, 3)) {
                  case "avc":
                  case "hev":
                  case "hvc":
                  case "vp8":
                  case "vp9":
                  case "av1":
                    return "video";

                  case "vtt":
                    return "text";

                  case "bif":
                    return "image";
                }
                switch (codecs.substring(0, 4)) {
                  case "mp4a":
                    return "audio";

                  case "wvtt":
                  case "stpp":
                    return "text";
                }
            }
            if (null != adaptationMimeType) {
                var typeFromMimeType = fromMimeType(adaptationMimeType, adaptationRoles);
                if (null != typeFromMimeType) return typeFromMimeType;
            }
            if (null != adaptationCodecs) {
                var typeFromCodecs = fromCodecs(adaptationCodecs);
                if (null != typeFromCodecs) return typeFromCodecs;
            }
            for (var i = 0; i < representationMimeTypes.length; i++) {
                var representationMimeType = representationMimeTypes[i];
                if (null != representationMimeType) {
                    var _typeFromMimeType = fromMimeType(representationMimeType, adaptationRoles);
                    if (null != _typeFromMimeType) return _typeFromMimeType;
                }
            }
            for (var _i = 0; _i < representationCodecs.length; _i++) {
                var codecs = representationCodecs[_i];
                if (null != codecs) {
                    var _typeFromMimeType2 = fromCodecs(codecs);
                    if (null != _typeFromMimeType2) return _typeFromMimeType2;
                }
            }
            return "unknown";
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/indexes/helpers.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Calculate the number of times a timeline element repeat.
 * @param {Object} element
 * @param {Object} nextElement
 * @param {number} timelineEnd
 * @returns {Number}
 */        function calculateRepeat(element, nextElement, timelineEnd) {
            var segmentEnd, repeatCount = element.repeatCount;
            return 0 <= repeatCount ? repeatCount : (segmentEnd = null != nextElement ? nextElement.start : null != timelineEnd ? timelineEnd : Number.MAX_VALUE, 
            Math.ceil((segmentEnd - element.start) / element.duration) - 1);
 // A negative value of the @r attribute of the S element indicates
            // that the duration indicated in @d attribute repeats until the
            // start of the next S element, the end of the Period or until the
            // next MPD update.
                }
        /**
 * Convert from `presentationTime`, the time of the segment at the moment it
 * is decoded to `mediaTime`, the original time the segments point at.
 * @param {Object} index
 * @param {number} time
 * @returns {number}
 */        function toIndexTime(index, time) {
            return time * index.timescale + index.indexTimeOffset;
        }
        /**
 * Convert from `mediaTime`, the original time the segments point at to
 * `presentationTime`, the time of the segment at the moment it is decoded.
 * @param {Object} index
 * @param {number} time
 * @returns {number}
 */        function fromIndexTime(index, time) {
            return (time - index.indexTimeOffset) / index.timescale;
        }
        /**
 * @param {Object} index
 * @param {Number} start
 * @param {Number} duration
 * @returns {Object} - Object with two properties:
 *   - up {Number}: timescaled timestamp of the beginning time
 *   - to {Number}: timescaled timestamp of the end time (start time + duration)
 */        function getTimescaledRange(index, start, duration) {
            var timescale = index.timescale || 1;
            return {
                up: start * timescale,
                to: (start + duration) * timescale
            };
        }
        /**
 * @param {Object} segment
 * @param {Object|null} [nextSegment]
 * @param {number} timelineEnd
 * @returns {Number}
 */        function getIndexSegmentEnd(segment, nextSegment, timelineEnd) {
            var start = segment.start, duration = segment.duration;
            return -1 === duration ? start : start + (calculateRepeat(segment, nextSegment, timelineEnd) + 1) * duration;
        }
        /**
 * Construct init segment for the given index.
 * @param {Object} index
 * @returns {Object}
 */        function helpers_getInitSegment(index) {
            var initialization = index.initialization;
            return {
                id: "init",
                isInit: !0,
                time: 0,
                range: initialization && initialization.range || void 0,
                indexRange: index.indexRange || void 0,
                mediaURL: initialization ? initialization.mediaURL : null,
                timescale: index.timescale,
                timestampOffset: -index.indexTimeOffset / index.timescale
            };
        }
        /**
 * For the given start time and duration of a timeline element, calculate how
 * much this element should be repeated to contain the time given.
 * 0 being the same element, 1 being the next one etc.
 * @param {Number} segmentStartTime
 * @param {Number} segmentDuration
 * @param {Number} wantedTime
 * @returns {Number}
 */        function getWantedRepeatIndex(segmentStartTime, segmentDuration, wantedTime) {
            var diff = wantedTime - segmentStartTime;
            return 0 < diff ? Math.floor(diff / segmentDuration) : 0;
        }
        /**
 * Get a list of Segments for the time range wanted.
 * @param {Object} index - index object, constructed by parsing the manifest.
 * @param {number} from - starting timestamp wanted, in seconds
 * @param {number} durationWanted - duration wanted, in seconds
 * @returns {Array.<Object>}
 */        function getSegmentsFromTimeline(index, from, durationWanted) {
            for (var scaledUp = toIndexTime(index, from), scaledTo = toIndexTime(index, from + durationWanted), timeline = index.timeline, timescale = index.timescale, mediaURL = index.mediaURL, startNumber = index.startNumber, timelineEnd = index.timelineEnd, currentNumber = null != startNumber ? startNumber : void 0, segments = [], timelineLength = timeline.length, maxEncounteredDuration = timeline.length && timeline[0].duration || 0, i = 0; i < timelineLength; i++) {
                var timelineItem = timeline[i], duration = timelineItem.duration, start = timelineItem.start, range = timelineItem.range;
                // live-added segments have @d attribute equals to -1
                if (maxEncounteredDuration = Math.max(maxEncounteredDuration, duration), duration < 0) {
                    // what? May be to play it safe and avoid adding segments which are
                    // not completely generated
                    if (start + maxEncounteredDuration < scaledTo) {
                        var segmentNumber = null != currentNumber ? currentNumber : void 0, segment = {
                            id: "" + start,
                            time: start - index.indexTimeOffset,
                            isInit: !1,
                            range: range,
                            duration: void 0,
                            timescale: timescale,
                            mediaURL: replaceSegmentDASHTokens(mediaURL, start, segmentNumber),
                            number: segmentNumber,
                            timestampOffset: -index.indexTimeOffset / timescale
                        };
                        segments.push(segment);
                    }
                    return segments;
                }
                for (var repeat = calculateRepeat(timelineItem, timeline[i + 1], timelineEnd), segmentNumberInCurrentRange = getWantedRepeatIndex(start, duration, scaledUp), segmentTime = start + segmentNumberInCurrentRange * duration; segmentTime < scaledTo && segmentNumberInCurrentRange <= repeat; ) {
                    var _segmentNumber = null != currentNumber ? currentNumber + segmentNumberInCurrentRange : void 0, _segment = {
                        id: "" + segmentTime,
                        time: segmentTime - index.indexTimeOffset,
                        isInit: !1,
                        range: range,
                        duration: duration,
                        timescale: timescale,
                        mediaURL: replaceSegmentDASHTokens(mediaURL, segmentTime, _segmentNumber),
                        number: _segmentNumber,
                        timestampOffset: -index.indexTimeOffset / timescale
                    };
                    segments.push(_segment), segmentTime = start + // update segment number and segment time for the next segment
                    ++segmentNumberInCurrentRange * duration;
                }
                if (scaledTo <= segmentTime) 
                // we reached ``scaledTo``, we're done
                return segments;
                null != currentNumber && (currentNumber += repeat + 1);
            }
            return segments;
        }
        /**
 * Pad with 0 in the left of the given n argument to reach l length
 * @param {Number|string} n
 * @param {Number} l
 * @returns {string}
 */        function padLeft(n, l) {
            var nToString = n.toString();
            return nToString.length >= l ? nToString : (new Array(l + 1).join("0") + nToString).slice(-l);
        }
        function processFormatedToken(replacer) {
            return function(_match, _format, widthStr) {
                var width = widthStr ? parseInt(widthStr, 10) : 1;
                return padLeft("" + replacer, width);
            };
        }
        /**
 * @param {string} representationURL
 * @param {string|undefined} media
 * @param {string|undefined} id
 * @param {number|undefined} bitrate
 * @returns {string}
 */        function createIndexURL(representationURL, media, id, bitrate) {
            return replaceRepresentationDASHTokens(Object(resolve_url.a)(representationURL, media), id, bitrate);
        }
        /**
 * Replace "tokens" written in a given path (e.g. $RepresentationID$) by the corresponding
 * infos, taken from the given segment.
 * @param {string} path
 * @param {string|undefined} id
 * @param {number|undefined} bitrate
 * @returns {string}
 */        function replaceRepresentationDASHTokens(path, id, bitrate) {
            return -1 === path.indexOf("$") ? path : path.replace(/\$\$/g, "$").replace(/\$RepresentationID\$/g, String(id)).replace(/\$Bandwidth(|\%0(\d+)d)\$/g, processFormatedToken(bitrate || 0));
        }
        /**
 * Replace "tokens" written in a given path (e.g. $Time$) by the corresponding
 * infos, taken from the given segment.
 * @param {string} path
 * @param {number} time
 * @param {number} number
 * @returns {string}
 *
 * @throws Error - Throws if we do not have enough data to construct the URL
 */        function replaceSegmentDASHTokens(path, time, number) {
            return -1 === path.indexOf("$") ? path : path.replace(/\$\$/g, "$").replace(/\$Number(|\%0(\d+)d)\$/g, function(_x, _y, widthStr) {
                if (null == number) throw new Error("Segment number not defined in a $Number$ scheme");
                return processFormatedToken(number)(_x, _y, widthStr);
            }).replace(/\$Time(|\%0(\d+)d)\$/g, function(_x, _y, widthStr) {
                if (null == time) throw new Error("Segment time not defined in a $Time$ scheme");
                return processFormatedToken(time)(_x, _y, widthStr);
            });
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/indexes/base.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Add a new segment to the index.
 *
 * /!\ Mutate the given index
 * @param {Object} index
 * @param {Object} segmentInfos
 * @returns {Boolean} - true if the segment has been added
 */        function _addSegmentInfos(index, segmentInfos) {
            if (segmentInfos.timescale !== index.timescale) {
                var timescale = index.timescale;
                index.timeline.push({
                    start: segmentInfos.time / segmentInfos.timescale * timescale,
                    duration: segmentInfos.duration / segmentInfos.timescale * timescale,
                    repeatCount: segmentInfos.count || 0,
                    range: segmentInfos.range
                });
            } else index.timeline.push({
                start: segmentInfos.time,
                duration: segmentInfos.duration,
                repeatCount: segmentInfos.count || 0,
                range: segmentInfos.range
            });
            return !0;
        }
        /**
 * Provide helpers for SegmentBase-based indexes.
 * @type {Object}
 */        var base_BaseRepresentationIndex = 
        /* */
        function() {
            /**
   * @param {Object} index
   * @param {Object} context
   */
            function BaseRepresentationIndex(index, context) {
                var periodStart = context.periodStart, periodEnd = context.periodEnd, representationBaseURL = context.representationBaseURL, representationId = context.representationId, representationBitrate = context.representationBitrate, timescale = index.timescale, indexTimeOffset = (null != index.presentationTimeOffset ? index.presentationTimeOffset : 0) - periodStart * timescale;
                this._index = {
                    duration: index.duration,
                    indexRange: index.indexRange,
                    indexTimeOffset: indexTimeOffset,
                    initialization: index.initialization && {
                        mediaURL: createIndexURL(representationBaseURL, index.initialization.media, representationId, representationBitrate),
                        range: index.initialization.range
                    },
                    mediaURL: createIndexURL(representationBaseURL, index.media, representationId, representationBitrate),
                    startNumber: index.startNumber,
                    timeline: index.timeline,
                    timelineEnd: null == periodEnd ? void 0 : periodEnd * timescale,
                    timescale: timescale
                };
            }
            /**
   * Construct init Segment.
   * @returns {Object}
   */            var _proto = BaseRepresentationIndex.prototype;
            return _proto.getInitSegment = function getInitSegment() {
                return helpers_getInitSegment(this._index);
            }
            /**
   * @param {Number} _up
   * @param {Number} _to
   * @returns {Array.<Object>}
   */ , _proto.getSegments = function getSegments(_up, _to) {
                return getSegmentsFromTimeline(this._index, _up, _to);
            }
            /**
   * Returns false as no Segment-Base based index should need to be refreshed.
   * @returns {Boolean}
   */ , _proto.shouldRefresh = function shouldRefresh() {
                return !1;
            }
            /**
   * Returns first position in index.
   * @returns {Number|undefined}
   */ , _proto.getFirstPosition = function getFirstPosition() {
                var index = this._index;
                if (0 !== index.timeline.length) return fromIndexTime(index, index.timeline[0].start);
            }
            /**
   * Returns last position in index.
   * @returns {Number|undefined}
   */ , _proto.getLastPosition = function getLastPosition() {
                var _this$_index = this._index, timeline = _this$_index.timeline, timelineEnd = _this$_index.timelineEnd;
                if (0 !== timeline.length) {
                    var lastTime = getIndexSegmentEnd(timeline[timeline.length - 1], null, timelineEnd);
                    return fromIndexTime(this._index, lastTime);
                }
            }
            /**
   * We do not check for discontinuity in SegmentBase-based indexes.
   * @returns {Number}
   */ , _proto.checkDiscontinuity = function checkDiscontinuity() {
                return -1;
            }
            /**
   * @param {Array.<Object>} nextSegments
   * @returns {Array.<Object>}
   */ , _proto._addSegments = function _addSegments(nextSegments) {
                for (var i = 0; i < nextSegments.length; i++) _addSegmentInfos(this._index, nextSegments[i]);
            }
            /**
   * @param {Object} newIndex
   */ , _proto._update = function _update(newIndex) {
                this._index = newIndex._index;
            }, BaseRepresentationIndex;
        }(), list_ListRepresentationIndex = 
        /* */
        function() {
            /**
   * @param {Object} index
   * @param {Object} context
   */
            function ListRepresentationIndex(index, context) {
                var periodStart = context.periodStart, representationBaseURL = context.representationBaseURL, representationId = context.representationId, representationBitrate = context.representationBitrate;
                this._periodStart = periodStart;
                var indexTimeOffset = (null != index.presentationTimeOffset ? index.presentationTimeOffset : 0) - periodStart * index.timescale;
                this._index = {
                    list: index.list.map(function(lItem) {
                        return {
                            mediaURL: createIndexURL(representationBaseURL, lItem.media, representationId, representationBitrate),
                            mediaRange: lItem.mediaRange
                        };
                    }),
                    timescale: index.timescale,
                    duration: index.duration,
                    indexTimeOffset: indexTimeOffset,
                    indexRange: index.indexRange,
                    initialization: index.initialization && {
                        mediaURL: createIndexURL(representationBaseURL, index.initialization.media, representationId, representationBitrate),
                        range: index.initialization.range
                    }
                };
            }
            /**
   * Construct init Segment.
   * @returns {Object}
   */            var _proto = ListRepresentationIndex.prototype;
            return _proto.getInitSegment = function getInitSegment() {
                return helpers_getInitSegment(this._index);
            }
            /**
   * @param {Number} fromTime
   * @param {Number} duration
   * @returns {Array.<Object>}
   */ , _proto.getSegments = function getSegments(fromTime, dur) {
                for (var index = this._index, _getTimescaledRange = getTimescaledRange(index, fromTime + this._periodStart, dur), up = _getTimescaledRange.up, to = _getTimescaledRange.to, duration = index.duration, list = index.list, timescale = index.timescale, length = Math.min(list.length - 1, Math.floor(to / duration)), segments = [], i = Math.floor(up / duration); i <= length; ) {
                    var args = {
                        id: "" + i,
                        time: i * duration,
                        isInit: !1,
                        range: list[i].mediaRange,
                        duration: duration,
                        timescale: timescale,
                        mediaURL: list[i].mediaURL,
                        timestampOffset: -index.indexTimeOffset / timescale
                    };
                    segments.push(args), i++;
                }
                return segments;
            }
            /**
   * Returns true if, based on the arguments, the index should be refreshed.
   * (If we should re-fetch the manifest)
   * @param {Number} _fromTime
   * @param {Number} toTime
   * @returns {Boolean}
   */ , _proto.shouldRefresh = function shouldRefresh(_fromTime, toTime) {
                var _this$_index = this._index, timescale = _this$_index.timescale, duration = _this$_index.duration, list = _this$_index.list, scaledTo = toTime * timescale, i = Math.floor(scaledTo / duration);
                return !(0 <= i && i < list.length);
            }
            /**
   * Returns first position in index.
   * @returns {Number}
   */ , _proto.getFirstPosition = function getFirstPosition() {
                return this._periodStart;
            }
            /**
   * Returns last position in index.
   * @returns {Number}
   */ , _proto.getLastPosition = function getLastPosition() {
                var index = this._index, duration = index.duration;
                return index.list.length * duration / index.timescale + this._periodStart;
            }
            /**
   * We do not check for discontinuity in SegmentList-based indexes.
   * @returns {Number}
   */ , _proto.checkDiscontinuity = function checkDiscontinuity() {
                return -1;
            }
            /**
   * @param {Object} newIndex
   */ , _proto._update = function _update(newIndex) {
                this._index = newIndex._index;
            }
            /**
   * We do not have to add new segments to SegmentList-based indexes.
   * @returns {Array}
   */ , _proto._addSegments = function _addSegments() {
                0;
            }, ListRepresentationIndex;
        }(), template_TemplateRepresentationIndex = 
        /* */
        function() {
            /**
   * @param {Object} index
   * @param {Object} context
   */
            function TemplateRepresentationIndex(index, context) {
                var periodStart = context.periodStart, representationBaseURL = context.representationBaseURL, representationId = context.representationId, representationBitrate = context.representationBitrate;
                this._periodStart = periodStart;
                var presentationTimeOffset = null != index.presentationTimeOffset ? index.presentationTimeOffset : 0, indexTimeOffset = presentationTimeOffset - periodStart * index.timescale;
                this._index = {
                    duration: index.duration,
                    timescale: index.timescale,
                    indexRange: index.indexRange,
                    indexTimeOffset: indexTimeOffset,
                    initialization: index.initialization && {
                        mediaURL: createIndexURL(representationBaseURL, index.initialization.media, representationId, representationBitrate),
                        range: index.initialization.range
                    },
                    mediaURL: createIndexURL(representationBaseURL, index.media, representationId, representationBitrate),
                    presentationTimeOffset: presentationTimeOffset,
                    startNumber: index.startNumber
                };
            }
            /**
   * Construct init Segment.
   * @returns {Object}
   */            var _proto = TemplateRepresentationIndex.prototype;
            return _proto.getInitSegment = function getInitSegment() {
                return helpers_getInitSegment(this._index);
            }
            /**
   * @param {Number} fromTime
   * @param {Number} dur
   * @returns {Array.<Object>}
   */ , _proto.getSegments = function getSegments(fromTime, dur) {
                var index = this._index, _getTimescaledRange = getTimescaledRange(index, fromTime, dur), up = _getTimescaledRange.up, to = _getTimescaledRange.to;
                if (to <= up) return [];
                for (var duration = index.duration, startNumber = index.startNumber, timescale = index.timescale, mediaURL = index.mediaURL, segments = [], baseTime = up; baseTime <= to; baseTime += duration) {
                    var periodRelativeStart = baseTime - this._periodStart * timescale, baseNumber = Math.floor(periodRelativeStart / duration), number = baseNumber + (null == startNumber ? 1 : startNumber), manifestTime = baseNumber * duration + (this._index.presentationTimeOffset || 0), args = {
                        id: "" + number,
                        number: number,
                        time: baseNumber * duration + this._periodStart * this._index.timescale,
                        isInit: !1,
                        duration: duration,
                        timescale: timescale,
                        mediaURL: replaceSegmentDASHTokens(mediaURL, manifestTime, number),
                        timestampOffset: -index.indexTimeOffset / timescale
                    };
                    segments.push(args);
                }
                return segments;
            }
            /**
   * Returns first position in index.
   * @returns {undefined}
   */ , _proto.getFirstPosition = function getFirstPosition() {}
            /**
   * Returns last position in index.
   * @returns {undefined}
   */ , _proto.getLastPosition = function getLastPosition() {}
            /**
   * Returns true if, based on the arguments, the index should be refreshed.
   * We never have to refresh a SegmentTemplate-based manifest.
   * @returns {Boolean}
   */ , _proto.shouldRefresh = function shouldRefresh() {
                return !1;
            }
            /**
   * We cannot check for discontinuity in SegmentTemplate-based indexes.
   * @returns {Number}
   */ , _proto.checkDiscontinuity = function checkDiscontinuity() {
                return -1;
            }
            /**
   * We do not have to add new segments to SegmentList-based indexes.
   * @returns {Array}
   */ , _proto._addSegments = function _addSegments() {
                0;
            }
            /**
   * @param {Object} newIndex
   */ , _proto._update = function _update(newIndex) {
                this._index = newIndex._index;
            }, TemplateRepresentationIndex;
        }();
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/indexes/list.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Provide helpers for SegmentList-based DASH indexes.
 * @type {Object}
 */        
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/indexes/timeline.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Translate parsed `S` node into Segment compatible with this index:
 * Find out the start, repeatCount and duration of each of these.
 *
 * @param {Object} item - parsed `S` node
 * @param {Object|null} previousItem - the previously parsed Segment (related
 * to the `S` node coming just before). If `null`, we're talking about the first
 * segment.
 * @param {Object|null} nextItem - the `S` node coming next. If `null`, we're
 * talking about the last segment.
 * @param {number} timelineStart - Absolute start for the timeline. In the same
 * timescale than the given `S` nodes.
 * @returns {Object|null}
 */
        function fromParsedSToIndexSegment(item, previousItem, nextItem, timelineStart) {
            var start = item.start, duration = item.duration, repeatCount = item.repeatCount;
            return null == start && (null == previousItem ? start = timelineStart : null != previousItem.duration && (start = previousItem.start + previousItem.duration * (previousItem.repeatCount + 1))), 
            null != duration && !isNaN(duration) || !nextItem || null == nextItem.start || isNaN(nextItem.start) || null == start || isNaN(start) || (duration = nextItem.start - start), 
            null == start || isNaN(start) || null == duration || isNaN(duration) || null != repeatCount && isNaN(repeatCount) ? (log.a.warn('DASH: A "S" Element could not have been parsed.'), 
            null) : {
                start: start,
                duration: duration,
                repeatCount: repeatCount || 0
            };
        }
        /**
 * Get index of the segment containing the given timescaled timestamp.
 * @param {Object} index
 * @param {Number} start
 * @returns {Number}
 */        function getSegmentIndex(index, start) {
            for (var timeline = index.timeline, low = 0, high = timeline.length; low < high; ) {
                var mid = low + high >>> 1;
                timeline[mid].start < start ? low = mid + 1 : high = mid;
            }
            return 0 < low ? low - 1 : low;
        }
        /**
 * Add a new segment to the index.
 *
 * /!\ Mutate the given index
 * @param {Object} index
 * @param {Object} newSegment
 * @param {Object} currentSegmentInfos
 * @param {Number} indexTimeOffset
 * @returns {Boolean} - true if the segment has been added
 */        function timeline_addSegmentInfos(index, newSegment, currentSegmentInfos, timelineEnd) {
            var scaledCurrentTime, timeline = index.timeline, timescale = index.timescale, timelineLength = timeline.length, lastItem = timeline[timelineLength - 1], scaledNewSegment = newSegment.timescale === timescale ? {
                time: newSegment.time,
                duration: newSegment.duration
            } : {
                time: newSegment.time / newSegment.timescale * timescale,
                duration: newSegment.duration / newSegment.timescale * timescale
            };
            if (currentSegmentInfos && currentSegmentInfos.timescale && (scaledCurrentTime = (currentSegmentInfos.timescale === timescale ? currentSegmentInfos.time : currentSegmentInfos.time / currentSegmentInfos.timescale * timescale) + index.indexTimeOffset), 
            null == scaledCurrentTime || scaledNewSegment.time !== scaledCurrentTime) return scaledNewSegment.time >= getIndexSegmentEnd(lastItem, null, timelineEnd) && (lastItem.duration === scaledNewSegment.duration ? lastItem.repeatCount++ : index.timeline.push({
                duration: scaledNewSegment.duration,
                start: scaledNewSegment.time,
                repeatCount: 0
            }), !0);
            var newSegmentStart = scaledNewSegment.time + scaledNewSegment.duration, startDiff = newSegmentStart - (lastItem.start + lastItem.duration * lastItem.repeatCount);
            if (startDiff <= 0) 
            // same segment / behind the lastItem
            return !1;
 // try to use the compact notation with @r attribute on the lastItem
            // to elements of the timeline if we find out they have the same
            // duration
                        if (-1 === lastItem.duration) {
                var prev = timeline[timelineLength - 2];
                prev && prev.duration === startDiff ? (prev.repeatCount++, timeline.pop()) : lastItem.duration = startDiff;
            }
            return index.timeline.push({
                duration: -1,
                start: newSegmentStart,
                repeatCount: 0
            }), !0;
        }
        var timeline_TimelineRepresentationIndex = 
        /* */
        function() {
            /**
   * @param {Object} index
   * @param {Object} context
   */
            function TimelineRepresentationIndex(index, context) {
                for (var isDynamic = context.isDynamic, representationBaseURL = context.representationBaseURL, representationId = context.representationId, representationBitrate = context.representationBitrate, periodStart = context.periodStart, periodEnd = context.periodEnd, timescale = index.timescale, scaledStart = periodStart * timescale, indexTimeOffset = (null != index.presentationTimeOffset ? index.presentationTimeOffset : 0) - scaledStart, initialTimeline = index.timeline, timeline = [], i = 0; i < initialTimeline.length; i++) {
                    var timelineElement = fromParsedSToIndexSegment(initialTimeline[i], timeline[timeline.length - 1] || null, initialTimeline[i + 1] || null, scaledStart);
                    timelineElement && timeline.push(timelineElement);
                }
                this._index = {
                    duration: index.duration,
                    indexRange: index.indexRange,
                    indexTimeOffset: indexTimeOffset,
                    initialization: index.initialization && {
                        mediaURL: createIndexURL(representationBaseURL, index.initialization.media, representationId, representationBitrate),
                        range: index.initialization.range
                    },
                    isDynamic: isDynamic,
                    mediaURL: createIndexURL(representationBaseURL, index.media, representationId, representationBitrate),
                    startNumber: index.startNumber,
                    timeline: timeline,
                    timelineEnd: null == periodEnd ? void 0 : periodEnd * timescale,
                    timescale: timescale
                };
            }
            /**
   * Construct init Segment.
   * @returns {Object}
   */            var _proto = TimelineRepresentationIndex.prototype;
            return _proto.getInitSegment = function getInitSegment() {
                return helpers_getInitSegment(this._index);
            }
            /**
   * Asks for segments to download for a given time range.
   * @param {Number} from - Beginning of the time wanted, in seconds
   * @param {Number} duration - duration wanted, in seconds
   * @returns {Array.<Object>}
   */ , _proto.getSegments = function getSegments(from, duration) {
                return getSegmentsFromTimeline(this._index, from, duration);
            }
            /**
   * Returns true if, based on the arguments, the index should be refreshed.
   * @param {Number} _start
   * @param {Number} end
   * @returns {Boolean}
   */ , _proto.shouldRefresh = function shouldRefresh(_start, end) {
                if (!this._index.isDynamic || 0 === this._index.timeline.length) return !1;
                var timeline = this._index.timeline, lastItem = timeline[timeline.length - 1];
                if (null == lastItem || lastItem.repeatCount < 0) return !1;
                lastItem.duration < 0 && (lastItem = {
                    start: lastItem.start,
                    duration: 0,
                    repeatCount: lastItem.repeatCount
                });
                var scaledStart = toIndexTime(this._index, _start), indexEnd = getIndexSegmentEnd(lastItem, null, this._index.timelineEnd);
                return indexEnd <= scaledStart || toIndexTime(this._index, end) - lastItem.duration > indexEnd;
            }
            /**
   * Returns first position in index.
   * @returns {Number|undefined}
   */ , _proto.getFirstPosition = function getFirstPosition() {
                var index = this._index;
                if (0 !== index.timeline.length) return fromIndexTime(index, index.timeline[0].start);
            }
            /**
   * Returns lastItem position in index.
   * @returns {Number|undefined}
   */ , _proto.getLastPosition = function getLastPosition() {
                var _this$_index = this._index, timeline = _this$_index.timeline, timelineEnd = _this$_index.timelineEnd;
                if (0 !== timeline.length) {
                    var lastTime = getIndexSegmentEnd(timeline[timeline.length - 1], null, timelineEnd);
                    return fromIndexTime(this._index, lastTime);
                }
            }
            /**
   * Checks if the time given is in a discontinuity. That is:
   *   - We're on the upper bound of the current range (end of the range - time
   *     is inferior to the timescale)
   *   - The next range starts after the end of the current range.
   * @param {Number} _time
   * @returns {Number} - If a discontinuity is present, this is the Starting
   * time for the next (discontinuited) range. If not this is equal to -1.
   */ , _proto.checkDiscontinuity = function checkDiscontinuity(_time) {
                var _this$_index2 = this._index, timeline = _this$_index2.timeline, timescale = _this$_index2.timescale, timelineEnd = _this$_index2.timelineEnd, scaledTime = toIndexTime(this._index, _time);
                if (scaledTime <= 0) return -1;
                var segmentIndex = getSegmentIndex(this._index, scaledTime);
                if (segmentIndex < 0 || segmentIndex >= timeline.length - 1) return -1;
                var timelineItem = timeline[segmentIndex];
                if (-1 === timelineItem.duration) return -1;
                var nextTimelineItem = timeline[segmentIndex + 1];
                if (null == nextTimelineItem) return -1;
                var rangeUp = timelineItem.start, rangeTo = getIndexSegmentEnd(timelineItem, nextTimelineItem, timelineEnd);
                // when we are actually inside the found range and this range has
                // an explicit discontinuity with the next one
                return rangeTo !== nextTimelineItem.start && rangeUp <= scaledTime && scaledTime <= rangeTo && rangeTo - scaledTime < timescale ? fromIndexTime(this._index, nextTimelineItem.start) : -1;
            }
            /**
   * @param {Object} newIndex
   */ , _proto._update = function _update(newIndex) {
                this._index = newIndex._index;
            }
            /**
   * We do not have to add new segments to SegmentList-based indexes.
   * @param {Array.<Object>} nextSegments
   * @param {Object|undefined} currentSegmentInfos
   * @returns {Array}
   */ , _proto._addSegments = function _addSegments(nextSegments, currentSegmentInfos) {
                for (var i = 0; i < nextSegments.length; i++) timeline_addSegmentInfos(this._index, nextSegments[i], currentSegmentInfos);
            }, TimelineRepresentationIndex;
        }();
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/parse_representations.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Find and parse RepresentationIndex located in an AdaptationSet node.
 * Returns a generic parsed SegmentTemplate with a single element if not found.
 * @param {Object} adaptation
 * @param {Object} context
 */        function findAdaptationIndex(adaptation, context) {
            var adaptationIndex, adaptationChildren = adaptation.children;
            if (null != adaptationChildren.segmentBase) {
                var segmentBase = adaptationChildren.segmentBase;
                adaptationIndex = new base_BaseRepresentationIndex(segmentBase, context);
            } else if (null != adaptationChildren.segmentList) {
                var segmentList = adaptationChildren.segmentList;
                adaptationIndex = new list_ListRepresentationIndex(segmentList, context);
            } else if (null != adaptationChildren.segmentTemplate) {
                var segmentTemplate = adaptationChildren.segmentTemplate;
                adaptationIndex = "timeline" === segmentTemplate.indexType ? new timeline_TimelineRepresentationIndex(segmentTemplate, context) : new template_TemplateRepresentationIndex(segmentTemplate, context);
            } else adaptationIndex = new template_TemplateRepresentationIndex({
                duration: Number.MAX_VALUE,
                timescale: 1,
                startNumber: 0,
                initialization: {
                    media: ""
                },
                media: ""
            }, context);
            return adaptationIndex;
        }
        /**
 * Process intermediate periods to create final parsed periods.
 * @param {Array.<Object>} periodsIR
 * @param {Object} manifestInfos
 * @returns {Array.<Object>}
 */        function parseRepresentations(representationsIR, adaptation, adaptationInfos) {
            return representationsIR.map(function(representation) {
                var representationIndex, baseURL = representation.children.baseURL, representationBaseURL = Object(resolve_url.a)(adaptationInfos.baseURL, baseURL), context = {
                    periodStart: adaptationInfos.start,
                    periodEnd: adaptationInfos.end,
                    isDynamic: adaptationInfos.isDynamic,
                    representationBaseURL: representationBaseURL,
                    representationId: representation.attributes.id,
                    representationBitrate: representation.attributes.bitrate
                };
                if (null != representation.children.segmentBase) {
                    var segmentBase = representation.children.segmentBase;
                    representationIndex = new base_BaseRepresentationIndex(segmentBase, context);
                } else if (null != representation.children.segmentList) {
                    var segmentList = representation.children.segmentList;
                    representationIndex = new list_ListRepresentationIndex(segmentList, context);
                } else if (null != representation.children.segmentTemplate) {
                    var segmentTemplate = representation.children.segmentTemplate;
                    representationIndex = "timeline" === segmentTemplate.indexType ? new timeline_TimelineRepresentationIndex(segmentTemplate, context) : new template_TemplateRepresentationIndex(segmentTemplate, context);
                } else representationIndex = findAdaptationIndex(adaptation, context);
 // 4-2-2. Find bitrate
                                // 4-2-3. Set ID
                var codecs, parsedRepresentation = {
                    bitrate: null == representation.attributes.bitrate ? (log.a.warn("DASH: No usable bitrate found in the Representation."), 
                    0) : representation.attributes.bitrate,
                    index: representationIndex,
                    id: null != representation.attributes.id ? representation.attributes.id : representation.attributes.bitrate + (null != representation.attributes.height ? "-" + representation.attributes.height : "") + (null != representation.attributes.width ? "-" + representation.attributes.width : "") + (null != representation.attributes.mimeType ? "-" + representation.attributes.mimeType : "") + (null != representation.attributes.codecs ? "-" + representation.attributes.codecs : "")
                };
 // 4-2-4. Construct Representation Base
                                return null != representation.attributes.codecs ? codecs = representation.attributes.codecs : null != adaptation.attributes.codecs && (codecs = adaptation.attributes.codecs), 
                null != codecs && (codecs = "mp4a.40.02" === codecs ? "mp4a.40.2" : codecs, parsedRepresentation.codecs = codecs), 
                null != representation.attributes.frameRate ? parsedRepresentation.frameRate = representation.attributes.frameRate : null != adaptation.attributes.frameRate && (parsedRepresentation.frameRate = adaptation.attributes.frameRate), 
                null != representation.attributes.height ? parsedRepresentation.height = representation.attributes.height : null != adaptation.attributes.height && (parsedRepresentation.height = adaptation.attributes.height), 
                null != representation.attributes.mimeType ? parsedRepresentation.mimeType = representation.attributes.mimeType : null != adaptation.attributes.mimeType && (parsedRepresentation.mimeType = adaptation.attributes.mimeType), 
                null != representation.attributes.width ? parsedRepresentation.width = representation.attributes.width : null != adaptation.attributes.width && (parsedRepresentation.width = adaptation.attributes.width), 
                parsedRepresentation;
            });
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/parse_adaptation_sets.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Detect if the accessibility given defines an adaptation for the visually
 * impaired.
 * Based on DVB Document A168 (DVB-DASH).
 * @param {Object} accessibility
 * @returns {Boolean}
 */        function isVisuallyImpaired(accessibility) {
            return !!accessibility && ("urn:tva:metadata:cs:AudioPurposeCS:2007" === accessibility.schemeIdUri && "1" === accessibility.value);
        }
        /**
 * Detect if the accessibility given defines an adaptation for the hard of
 * hearing.
 * Based on DVB Document A168 (DVB-DASH).
 * @param {Object} accessibility
 * @returns {Boolean}
 */        function isHardOfHearing(accessibility) {
            return !!accessibility && ("urn:tva:metadata:cs:AudioPurposeCS:2007" === accessibility.schemeIdUri && "2" === accessibility.value);
        }
        /**
 * Contruct Adaptation ID from the informations we have.
 * @param {Object} adaptation
 * @param {Array.<Object>} representations
 * @param {Object} infos
 * @returns {string}
 */        function getAdaptationID(adaptation, representations, infos) {
            if (adaptation.attributes.id) return adaptation.attributes.id;
            var idString = infos.type;
            return adaptation.attributes.language && (idString += "-" + adaptation.attributes.language), 
            infos.isClosedCaption && (idString += "-cc"), infos.isAudioDescription && (idString += "-ad"), 
            adaptation.attributes.contentType && (idString += "-" + adaptation.attributes.contentType), 
            adaptation.attributes.codecs && (idString += "-" + adaptation.attributes.codecs), 
            adaptation.attributes.mimeType && (idString += "-" + adaptation.attributes.mimeType), 
            adaptation.attributes.frameRate && (idString += "-" + adaptation.attributes.frameRate), 
            idString.length === infos.type.length && (idString += representations.length ? "-" + representations[0].id : "-empty"), 
            "adaptation-" + idString;
        }
        /**
 * Returns a list of ID this adaptation can be seamlessly switched to
 * @param {Object} adaptation
 * @returns {Array.<string>}
 */        function getAdaptationSetSwitchingIDs(adaptation) {
            if (null != adaptation.children.supplementalProperties) for (var supplementalProperties = adaptation.children.supplementalProperties, j = 0; j < supplementalProperties.length; j++) {
                var supplementalProperty = supplementalProperties[j];
                if ("urn:mpeg:dash:adaptation-set-switching:2016" === supplementalProperty.schemeIdUri && null != supplementalProperty.value) return supplementalProperty.value.split(",").map(function(id) {
                    return id.trim();
                }).filter(function(id) {
                    return id;
                });
            }
            return [];
        }
        /**
 * Process intermediate periods to create final parsed periods.
 * @param {Array.<Object>} periodsIR
 * @param {Object} manifestInfos
 * @returns {Array.<Object>}
 */        function parseAdaptationSets(adaptationsIR, periodInfos) {
            return adaptationsIR.reduce(function(acc, adaptation) {
                var newID, adaptationChildren = adaptation.children, parsedAdaptations = acc.adaptations, representations = parseRepresentations(adaptation.children.representations, adaptation, {
                    isDynamic: periodInfos.isDynamic,
                    start: periodInfos.start,
                    end: periodInfos.end,
                    baseURL: Object(resolve_url.a)(periodInfos.baseURL, adaptationChildren.baseURL)
                }), adaptationMimeType = adaptation.attributes.mimeType, adaptationCodecs = adaptation.attributes.codecs, type = inferAdaptationType(adaptationMimeType || null, representations.map(function(representation) {
                    return representation.mimeType;
                }).filter(function(mimeType) {
                    return null != mimeType;
                }), adaptationCodecs || null, representations.map(function(representation) {
                    return representation.codecs;
                }).filter(function(codecs) {
                    return null != codecs;
                }), adaptationChildren.roles || null), originalID = adaptation.attributes.id, adaptationSetSwitchingIDs = getAdaptationSetSwitchingIDs(adaptation), roles = adaptationChildren.roles, isMainAdaptation = !!roles && !!Object(array_find.a)(roles, function(role) {
                    return "main" === role.value;
                }) && !!Object(array_find.a)(roles, function(role) {
                    return "urn:mpeg:dash:role:2011" === role.schemeIdUri;
                }), videoMainAdaptation = acc.videoMainAdaptation;
                if ("video" === type && null !== videoMainAdaptation && isMainAdaptation) {
                    var _videoMainAdaptation$;
                    (_videoMainAdaptation$ = videoMainAdaptation.representations).push.apply(_videoMainAdaptation$, representations), 
                    newID = videoMainAdaptation.id;
                } else {
                    var isClosedCaption = !("text" !== type || !adaptationChildren.accessibility || !isHardOfHearing(adaptationChildren.accessibility)) || void 0, isAudioDescription = !("audio" !== type || !adaptationChildren.accessibility || !isVisuallyImpaired(adaptationChildren.accessibility)) || void 0, parsedAdaptationSet = {
                        id: newID = getAdaptationID(adaptation, representations, {
                            isClosedCaption: isClosedCaption,
                            isAudioDescription: isAudioDescription,
                            type: type
                        }),
                        representations: representations,
                        type: type
                    };
                    null != adaptation.attributes.language && (parsedAdaptationSet.language = adaptation.attributes.language), 
                    null != isClosedCaption && (parsedAdaptationSet.closedCaption = isClosedCaption), 
                    null != isAudioDescription && (parsedAdaptationSet.audioDescription = isAudioDescription);
                    var adaptationsOfTheSameType = parsedAdaptations[type];
                    if (adaptationsOfTheSameType) {
                        for (var mergedInto = null, _loop = function _loop(k) {
                            var id = adaptationSetSwitchingIDs[k], switchingInfos = acc.adaptationSwitchingInfos[id];
                            if (null != switchingInfos && switchingInfos.newID !== newID && Object(array_includes.a)(switchingInfos.adaptationSetSwitchingIDs, originalID)) {
                                var _adaptationToMergeInt, adaptationToMergeInto = Object(array_find.a)(adaptationsOfTheSameType, function(a) {
                                    return a.id === id;
                                });
                                if (null != adaptationToMergeInto && adaptationToMergeInto.audioDescription === parsedAdaptationSet.audioDescription && adaptationToMergeInto.closedCaption === parsedAdaptationSet.closedCaption && adaptationToMergeInto.language === parsedAdaptationSet.language) log.a.info('DASH Parser: merging "switchable" AdaptationSets', originalID, id), 
                                (_adaptationToMergeInt = adaptationToMergeInto.representations).push.apply(_adaptationToMergeInt, parsedAdaptationSet.representations), 
                                mergedInto = adaptationToMergeInto;
                            }
                        }, k = 0 // look if we have to merge this into another Adaptation
                        ; k < adaptationSetSwitchingIDs.length; k++) _loop(k);
                        if (isMainAdaptation && "video" === type) if (null == mergedInto) 
                        // put "main" adaptation as the first
                        adaptationsOfTheSameType.unshift(parsedAdaptationSet), acc.videoMainAdaptation = parsedAdaptationSet; else {
                            // put the resulting adaptation first instead
                            var indexOf = adaptationsOfTheSameType.indexOf(mergedInto);
                            indexOf < 0 ? adaptationsOfTheSameType.unshift(parsedAdaptationSet) : 0 !== indexOf && (adaptationsOfTheSameType.splice(indexOf, 1), 
                            adaptationsOfTheSameType.unshift(mergedInto)), acc.videoMainAdaptation = mergedInto;
                        } else null === mergedInto && adaptationsOfTheSameType.push(parsedAdaptationSet);
                    } else parsedAdaptations[type] = [ parsedAdaptationSet ], isMainAdaptation && "video" === type && (acc.videoMainAdaptation = parsedAdaptationSet);
                }
                return null != originalID && null == acc.adaptationSwitchingInfos[originalID] && (acc.adaptationSwitchingInfos[originalID] = {
                    newID: newID,
                    adaptationSetSwitchingIDs: adaptationSetSwitchingIDs
                }), {
                    adaptations: parsedAdaptations,
                    adaptationSwitchingInfos: acc.adaptationSwitchingInfos,
                    videoMainAdaptation: acc.videoMainAdaptation
                };
            }, {
                adaptations: {},
                videoMainAdaptation: null,
                adaptationSwitchingInfos: {}
            }).adaptations;
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/parse_periods.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        var generatePeriodID = Object(id_generator.a)();
        /**
 * Process intermediate periods to create final parsed periods.
 * @param {Array.<Object>} periodsIR
 * @param {Object} manifestInfos
 * @returns {Array.<Object>}
 */        function parsePeriods(periodsIR, manifestInfos) {
            for (var parsedPeriods = [], i = 0; i < periodsIR.length; i++) {
                var period = periodsIR[i], periodBaseURL = Object(resolve_url.a)(manifestInfos.baseURL, period.children.baseURL), periodID = void 0;
                periodID = null == period.attributes.id ? (log.a.warn("DASH: No usable id found in the Period. Generating one."), 
                "gen-dash-period-" + generatePeriodID()) : period.attributes.id;
 // 3. Find the start of the Period (required)
                                var periodStart = void 0;
                if (null != period.attributes.start) periodStart = period.attributes.start; else if (0 === i) periodStart = manifestInfos.isDynamic && null != manifestInfos.availabilityStartTime ? manifestInfos.availabilityStartTime : 0; else {
                    var prevPeriod = parsedPeriods[i - 1];
                    if (!prevPeriod || null == prevPeriod.duration || null == prevPeriod.start) throw new Error("Missing start time when parsing periods.");
                    periodStart = prevPeriod.start + prevPeriod.duration;
                }
                0 < i && void 0 === parsedPeriods[i - 1].duration && (parsedPeriods[i - 1].duration = periodStart - parsedPeriods[i - 1].start);
                var periodDuration = void 0;
                null != period.attributes.duration ? periodDuration = period.attributes.duration : 0 === i && manifestInfos.duration && (periodDuration = manifestInfos.duration);
                var periodEnd = null != periodDuration ? periodStart + periodDuration : void 0, parsedPeriod = {
                    id: periodID,
                    start: periodStart,
                    end: periodEnd,
                    duration: periodDuration,
                    adaptations: parseAdaptationSets(period.children.adaptations, {
                        isDynamic: manifestInfos.isDynamic,
                        start: periodStart,
                        end: periodEnd,
                        baseURL: periodBaseURL
                    })
                };
                parsedPeriods.push(parsedPeriod);
            }
            return flattenOverlappingPeriods(parsedPeriods);
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/parse_mpd.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        var generateManifestID = Object(id_generator.a)();
        /**
 * @param {Element} root - The MPD root.
 * @param {string} url - The url where the MPD is located
 * @returns {Object}
 */        function parseMPD(root, uri) {
            return loadExternalRessourcesAndParse(createMPDIntermediateRepresentation(root), uri);
        }
        /**
 * Checks if xlinks needs to be loaded before actually parsing the manifest.
 * @param {Object} mpdIR
 * @param {string} uri
 * @returns {Object}
 */        function loadExternalRessourcesAndParse(mpdIR, uri) {
            for (var xlinksToLoad = [], i = 0; i < mpdIR.children.periods.length; i++) {
                var _mpdIR$children$perio = mpdIR.children.periods[i].attributes, xlinkHref = _mpdIR$children$perio.xlinkHref, xlinkActuate = _mpdIR$children$perio.xlinkActuate;
                null != xlinkHref && "onLoad" === xlinkActuate && xlinksToLoad.push({
                    index: i,
                    ressource: xlinkHref
                });
            }
            return 0 !== xlinksToLoad.length ? {
                type: "needs-ressources",
                value: {
                    ressources: xlinksToLoad.map(function(_ref) {
                        return _ref.ressource;
                    }),
                    continue: function continueParsingMPD(loadedRessources) {
                        if (loadedRessources.length !== xlinksToLoad.length) throw new Error("DASH parser: wrong number of loaded ressources.");
 // Note: It is important to go from the last index to the first index in
                        // the resulting array, as we will potentially add elements to the array
                                                for (var _i = loadedRessources.length - 1; 0 <= _i; _i--) {
                            var _mpdIR$children$perio2, index = xlinksToLoad[_i].index, wrappedData = "<root>" + loadedRessources[_i] + "</root>", dataAsXML = new DOMParser().parseFromString(wrappedData, "text/xml");
                            if (!dataAsXML || 0 === dataAsXML.children.length) throw new Error("DASH parser: Invalid external ressources");
                            for (var periods = dataAsXML.children[0].children, periodsIR = [], j = 0; j < periods.length; j++) periods[j].nodeType === Node.ELEMENT_NODE && periodsIR.push(createPeriodIntermediateRepresentation(periods[j]));
 // replace original "xlinked" periods by the real deal
                                                        // replace original "xlinked" periods by the real deal
                            (_mpdIR$children$perio2 = mpdIR.children.periods).splice.apply(_mpdIR$children$perio2, [ index, 1 ].concat(periodsIR));
                        }
                        return loadExternalRessourcesAndParse(mpdIR, uri);
                    }
                }
            } : {
                type: "done",
                value: parseCompleteIntermediateRepresentation(mpdIR, uri)
            };
        }
        /**
 * Parse the MPD intermediate representation into a regular Manifest.
 * @param {Object} mpdIR
 * @param {string} uri
 * @returns {Object}
 */        function parseCompleteIntermediateRepresentation(mpdIR, uri) {
            var rootChildren = mpdIR.children, rootAttributes = mpdIR.attributes, baseURL = Object(resolve_url.a)(Object(resolve_url.b)(uri), rootChildren.baseURL), isDynamic = "dynamic" === rootAttributes.type, availabilityStartTime = "static" === rootAttributes.type || null == rootAttributes.availabilityStartTime ? 0 : rootAttributes.availabilityStartTime, parsedPeriods = parsePeriods(rootChildren.periods, {
                availabilityStartTime: availabilityStartTime,
                duration: rootAttributes.duration,
                isDynamic: isDynamic,
                baseURL: baseURL
            }), parsedMPD = {
                availabilityStartTime: availabilityStartTime,
                baseURL: baseURL,
                duration: function() {
                    if (null != rootAttributes.duration) return rootAttributes.duration;
                    if (!isDynamic && parsedPeriods.length) {
                        var lastPeriod = parsedPeriods[parsedPeriods.length - 1];
                        if (null != lastPeriod.end) return lastPeriod.end;
                        if (null != lastPeriod.duration) return lastPeriod.start + lastPeriod.duration;
                    }
                }(),
                id: null != rootAttributes.id ? rootAttributes.id : "gen-dash-manifest-" + generateManifestID(),
                periods: parsedPeriods,
                transportType: "dash",
                isLive: isDynamic,
                uris: [ uri ].concat(rootChildren.locations),
                suggestedPresentationDelay: null != rootAttributes.suggestedPresentationDelay ? rootAttributes.suggestedPresentationDelay : config.a.DEFAULT_SUGGESTED_PRESENTATION_DELAY.DASH
            };
            // -- add optional fields --
            return "static" !== rootAttributes.type && null != rootAttributes.availabilityEndTime && (parsedMPD.availabilityEndTime = rootAttributes.availabilityEndTime), 
            null != rootAttributes.timeShiftBufferDepth && (parsedMPD.timeShiftBufferDepth = rootAttributes.timeShiftBufferDepth), 
            null != rootAttributes.minimumUpdatePeriod && 0 < rootAttributes.minimumUpdatePeriod && (parsedMPD.lifetime = rootAttributes.minimumUpdatePeriod), 
            Object(check_manifest_ids.a)(parsedMPD), parsedMPD.isLive && (parsedMPD.presentationLiveGap = getPresentationLiveGap(parsedMPD)), 
            parsedMPD;
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/parse_from_document.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {Document} manifest - Original manifest as returned by the server
 * @param {string} uri
 * @returns {Object} - parsed manifest
 */        
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/index.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /* harmony default export */ var dash = function parseFromDocument(document, uri) {
            var root = document.documentElement;
            if (!root || "MPD" !== root.nodeName) throw new Error("DASH Parser: document root should be MPD");
            return parseMPD(root, uri);
        }, request = __webpack_require__(23), manifest_loader = __webpack_require__(91);
        // EXTERNAL MODULE: ./src/utils/request/index.ts + 1 modules
                /* harmony default export */ var isobmff_timing_infos = 
        // CONCATENATED MODULE: ./src/transports/dash/isobmff_timing_infos.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Get precize start and duration of a segment from ISOBMFF.
 *   1. get start from tfdt
 *   2. get duration from trun
 *   3. if at least one is missing, get both informations from sidx
 *   4. As a fallback take segment infos.
 * @param {Object} segment
 * @param {UInt8Array} buffer - The entire isobmff container
 * @param {Array.<Object>|undefined} sidxSegments - Segments from sidx. Here
 * pre-parsed for performance reasons as it is usually available when
 * this function is called.
 * @param {Object} initInfos
 * @returns {Object}
 */
        function getISOBMFFTimingInfos(segment, buffer, sidxSegments, initInfos) {
            var startTime, duration, maxDecodeTimeDelta, segmentDuration, segmentStart, _sidxSegments = sidxSegments || [], baseDecodeTime = Object(utils.d)(buffer), trunDuration = Object(utils.a)(buffer), timescale = initInfos && initInfos.timescale ? initInfos.timescale : segment.timescale;
            if (segmentDuration = timescale === segment.timescale ? (maxDecodeTimeDelta = Math.min(.9 * timescale, null != segment.duration ? segment.duration / 4 : .25), 
            segmentStart = segment.time, segment.duration) : (maxDecodeTimeDelta = Math.min(.9 * timescale, null != segment.duration ? segment.duration / segment.timescale * timescale / 4 : .25), 
            segmentStart = (segment.time || 0) / segment.timescale * timescale, null != segment.duration ? segment.duration / segment.timescale * timescale : void 0), 
            0 <= baseDecodeTime && (startTime = null != segment.timestampOffset ? baseDecodeTime + segment.timestampOffset * timescale : baseDecodeTime), 
            0 <= trunDuration && (null == segmentDuration || Math.abs(trunDuration - segmentDuration) <= maxDecodeTimeDelta) && (duration = trunDuration), 
            null == startTime) if (0 === _sidxSegments.length) startTime = segmentStart; else {
                var sidxStart = _sidxSegments[0].time;
                if (0 <= sidxStart) {
                    var sidxTimescale = _sidxSegments[0].timescale, baseStartTime = null != sidxTimescale && sidxTimescale !== timescale ? sidxStart / sidxTimescale * timescale : sidxStart;
                    startTime = null != segment.timestampOffset ? baseStartTime + segment.timestampOffset * timescale : baseStartTime;
                } else startTime = segmentStart;
            }
            if (null == duration) if (_sidxSegments.length) {
                var sidxDuration = _sidxSegments.reduce(function(a, b) {
                    return a + (b.duration || 0);
                }, 0);
                duration = 0 <= sidxDuration ? sidxDuration : segmentDuration;
            } else duration = segmentDuration;
            return {
                timescale: timescale,
                time: startTime || 0,
                duration: duration || 0
            };
        }, assert = __webpack_require__(16), string_from_utf8 = __webpack_require__(93), read = __webpack_require__(111), byte_range = __webpack_require__(57);
        // EXTERNAL MODULE: ./src/utils/assert.ts + 1 modules
                // CONCATENATED MODULE: ./src/transports/dash/is_mp4_embedded_track.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Returns true if the given texttrack segment represents a textrack embedded
 * in a mp4 file.
 * @param {Representation} representation
 * @returns {Boolean}
 */
        function isMP4EmbeddedTrack(representation) {
            return "application/mp4" === representation.mimeType;
        }
        // CONCATENATED MODULE: ./src/transports/dash/pipelines_text.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Perform requests for "text" segments
 * @param {Object} infos
 * @returns {Observable.<Object>}
 */        function TextTrackLoader(_ref) {
            var segment = _ref.segment, representation = _ref.representation, mediaURL = segment.mediaURL, range = segment.range, indexRange = segment.indexRange, responseType = isMP4EmbeddedTrack(representation) ? "arraybuffer" : "text";
            // init segment without initialization media/range/indexRange:
            // we do nothing on the network
            return null == mediaURL ? Object(of.a)({
                type: "data",
                value: {
                    responseData: null
                }
            }) : // fire a single time for init and index ranges
            null != range && null != indexRange ? Object(request.a)({
                url: mediaURL,
                responseType: responseType,
                headers: {
                    Range: Object(byte_range.a)([ Math.min(range[0], indexRange[0]), Math.max(range[1], indexRange[1]) ])
                }
            }) : Object(request.a)({
                url: mediaURL,
                responseType: responseType,
                headers: range ? {
                    Range: Object(byte_range.a)(range)
                } : null
            });
        }
        /**
 * Parse TextTrack data.
 * @param {Object} infos
 * @returns {Observable.<Object>}
 */        function TextTrackParser(_ref2) {
            var responseData, nextSegments, segmentInfos, segmentData, response = _ref2.response, segment = _ref2.segment, adaptation = _ref2.adaptation, representation = _ref2.representation, init = _ref2.init, language = adaptation.language, isInit = segment.isInit, indexRange = segment.indexRange;
            if (null == response.responseData) return Object(of.a)({
                segmentData: null,
                segmentInfos: 0 < segment.timescale ? {
                    duration: segment.isInit ? 0 : segment.duration,
                    time: segment.isInit ? -1 : segment.time,
                    timescale: segment.timescale
                } : null,
                segmentOffset: segment.timestampOffset || 0
            });
            var isMP4 = isMP4EmbeddedTrack(representation);
            if (isMP4) {
                Object(assert.b)(response.responseData instanceof ArrayBuffer), responseData = new Uint8Array(response.responseData);
                var sidxSegments = Object(utils.c)(responseData, indexRange ? indexRange[0] : 0);
                sidxSegments && (nextSegments = sidxSegments), segmentInfos = isInit ? {
                    time: -1,
                    duration: 0,
                    timescale: segment.timescale
                } : isobmff_timing_infos(segment, responseData, sidxSegments, init);
            } else 
            // if not MP4
            Object(assert.b)("string" == typeof response.responseData), responseData = response.responseData, 
            segmentInfos = isInit ? {
                time: -1,
                duration: 0,
                timescale: segment.timescale
            } : {
                time: segment.time,
                duration: segment.duration,
                timescale: segment.timescale
            };
            if (isInit) {
                if (isMP4) {
                    var timescale = Object(utils.b)(responseData);
                    0 < timescale && (segmentInfos = {
                        time: -1,
                        duration: 0,
                        timescale: timescale
                    });
                }
                segmentData = null;
            } else {
                // if not init
                Object(assert.b)(null != segmentInfos);
                var segmentDataBase = {
                    start: segmentInfos.time,
                    end: segmentInfos.time + (segmentInfos.duration || 0),
                    language: language,
                    timescale: segmentInfos.timescale
                };
                if (isMP4) {
                    var type, _representation$codec = representation.codec, codec = void 0 === _representation$codec ? "" : _representation$codec;
                    switch (codec.toLowerCase()) {
                      case "stpp":
 // stpp === TTML in MP4
                                              case "stpp.ttml.im1t":
                        type = "ttml";
                        break;

                      case "wvtt":
                        // wvtt === WebVTT in MP4
                        type = "vtt";
                    }
                    if (!type) throw new Error('The codec used for the subtitles, "' + codec + '", is not managed yet.');
                    segmentData = object_assign_default()({
                        data: Object(string_from_utf8.a)(Object(read.a)(responseData)),
                        type: type
                    }, {
                        timescale: 1
                    }, segmentDataBase);
                } else {
                    // not MP4: check for plain text subtitles
                    var _type, _representation$mimeT = representation.mimeType, mimeType = void 0 === _representation$mimeT ? "" : _representation$mimeT;
                    switch (representation.mimeType) {
                      case "application/ttml+xml":
                        _type = "ttml";
                        break;

                      case "application/x-sami":
                      case "application/smil":
                        _type = "sami";
                        break;

                      case "text/vtt":
                        _type = "vtt";
                    }
                    if (!_type) {
                        var _representation$codec2 = representation.codec;
                        if ("srt" !== (void 0 === _representation$codec2 ? "" : _representation$codec2).toLowerCase()) throw new Error("could not find a text-track parser for the type " + mimeType);
                        _type = "srt";
                    }
                    segmentData = object_assign_default()({
                        data: responseData,
                        type: _type
                    }, {
                        timescale: 1
                    }, segmentDataBase);
                }
            }
            return nextSegments && representation.index._addSegments(nextSegments, segmentInfos), 
            Object(of.a)({
                segmentData: segmentData,
                segmentInfos: segmentInfos,
                segmentOffset: segment.timestampOffset || 0
            });
        }
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Observable.js + 3 modules
                var Observable = __webpack_require__(6);
        // CONCATENATED MODULE: ./src/transports/dash/segment_loader.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Segment loader triggered if there was no custom-defined one in the API.
 * @param {Object} opt
 * @returns {Observable}
 */        function regularSegmentLoader(_ref) {
            var url = _ref.url, segment = _ref.segment, range = segment.range, indexRange = segment.indexRange;
            // fire a single time for init and index ranges
            return null != range && null != indexRange ? Object(request.a)({
                url: url,
                responseType: "arraybuffer",
                headers: {
                    Range: Object(byte_range.a)([ Math.min(range[0], indexRange[0]), Math.max(range[1], indexRange[1]) ])
                }
            }) : Object(request.a)({
                url: url,
                responseType: "arraybuffer",
                headers: range ? {
                    Range: Object(byte_range.a)(range)
                } : null
            });
        }
        /**
 * Generate a segment loader for the application
 * @param {Function} [customSegmentLoader]
 * @returns {Function}
 */        var segment_loader = function segmentPreLoader(customSegmentLoader) {
            return function(_ref2) {
                var adaptation = _ref2.adaptation, manifest = _ref2.manifest, period = _ref2.period, representation = _ref2.representation, segment = _ref2.segment, mediaURL = segment.mediaURL;
                if (null == mediaURL) return Object(of.a)({
                    type: "data",
                    value: {
                        responseData: null
                    }
                });
                var args = {
                    adaptation: adaptation,
                    manifest: manifest,
                    period: period,
                    representation: representation,
                    segment: segment,
                    transport: "dash",
                    url: mediaURL
                };
                return customSegmentLoader ? new Observable.a(function(obs) {
                    var hasFinished = !1, hasFallbacked = !1, abort = customSegmentLoader(args, {
                        reject: function reject(err) {
                            void 0 === err && (err = {}), hasFallbacked || (hasFinished = !0, obs.error(err));
                        },
                        resolve: function resolve(_args) {
                            hasFallbacked || (hasFinished = !0, obs.next({
                                type: "response",
                                value: {
                                    responseData: _args.data,
                                    size: _args.size,
                                    duration: _args.duration
                                }
                            }), obs.complete());
                        },
                        fallback: function fallback() {
                            hasFallbacked = !0, regularSegmentLoader(args).subscribe(obs);
                        }
                    });
                    return function() {
                        hasFinished || hasFallbacked || "function" != typeof abort || abort();
                    };
                }) : regularSegmentLoader(args);
            };
        };
        /* harmony default export */        
        // CONCATENATED MODULE: ./src/transports/dash/pipelines.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Request external "xlink" ressource from a MPD.
 * @param {string} xlinkURL
 * @returns {Observable}
 */
        function requestXLink(xlinkURL) {
            return Object(request.a)({
                url: xlinkURL,
                responseType: "text",
                ignoreProgressEvents: !0
            }).pipe(Object(filter.a)(function(e) {
                return "response" === e.type;
            }), Object(map.a)(function(e) {
                return e.value.responseData;
            }));
        }
        /**
 * Returns pipelines used for DASH streaming.
 * @param {Object} options
 * implementation. Used for each generated http request.
 * @returns {Object}
 */
        /* harmony default export */        __webpack_exports__.default = function(options) {
            void 0 === options && (options = {});
            var manifestLoader = Object(manifest_loader.a)({
                customManifestLoader: options.manifestLoader
            }), segmentLoader = segment_loader(options.segmentLoader), segmentPipeline = {
                loader: function loader(_ref3) {
                    var adaptation = _ref3.adaptation, manifest = _ref3.manifest, period = _ref3.period, representation = _ref3.representation, segment = _ref3.segment;
                    return segmentLoader({
                        adaptation: adaptation,
                        manifest: manifest,
                        period: period,
                        representation: representation,
                        segment: segment
                    });
                },
                parser: function parser(_ref4) {
                    var segment = _ref4.segment, representation = _ref4.representation, response = _ref4.response, init = _ref4.init, responseData = response.responseData;
                    if (null == responseData) return Object(of.a)({
                        segmentData: null,
                        segmentInfos: null,
                        segmentOffset: 0
                    });
                    var segmentData = responseData instanceof Uint8Array ? responseData : new Uint8Array(responseData), indexRange = segment.indexRange, isWEBM = "video/webm" === representation.mimeType || "audio/webm" === representation.mimeType, nextSegments = isWEBM ? getSegmentsFromCues(segmentData, 0) : Object(utils.c)(segmentData, indexRange ? indexRange[0] : 0);
                    if (!segment.isInit) {
                        var segmentInfos = isWEBM ? {
                            time: segment.time,
                            duration: segment.duration,
                            timescale: segment.timescale
                        } : isobmff_timing_infos(segment, segmentData, nextSegments, init), segmentOffset = segment.timestampOffset || 0;
                        return Object(of.a)({
                            segmentData: segmentData,
                            segmentInfos: segmentInfos,
                            segmentOffset: segmentOffset
                        });
                    }
                    nextSegments && representation.index._addSegments(nextSegments);
                    var timescale = isWEBM ? getTimeCodeScale(segmentData, 0) : Object(utils.b)(segmentData);
                    return Object(of.a)({
                        segmentData: segmentData,
                        segmentInfos: timescale && 0 < timescale ? {
                            time: -1,
                            duration: 0,
                            timescale: timescale
                        } : null,
                        segmentOffset: segment.timestampOffset || 0
                    });
                }
            };
            return {
                manifest: {
                    loader: function loader(_ref) {
                        var url = _ref.url;
                        return manifestLoader(url);
                    },
                    parser: function parser(_ref2) {
                        var response = _ref2.response, loaderURL = _ref2.url, scheduleRequest = _ref2.scheduleRequest, url = null == response.url ? loaderURL : response.url, data = "string" == typeof response.responseData ? new DOMParser().parseFromString(response.responseData, "text/xml") : response.responseData;
                        return function loadExternalRessources(parserResponse) {
                            if ("done" === parserResponse.type) {
                                var manifest = new src_manifest.a(parserResponse.value, options);
                                return Object(of.a)({
                                    manifest: manifest,
                                    url: url
                                });
                            }
                            var _parserResponse$value = parserResponse.value, ressources = _parserResponse$value.ressources, continueParsing = _parserResponse$value.continue, externalXlinks$ = ressources.map(function(ressourceURL) {
                                return scheduleRequest(function() {
                                    return requestXLink(ressourceURL);
                                });
                            });
                            return Object(combineLatest.a)(externalXlinks$).pipe(Object(mergeMap.a)(function(loadedRessources) {
                                return loadExternalRessources(continueParsing(loadedRessources));
                            }));
                        }(dash(data, url));
                    }
                },
                audio: segmentPipeline,
                video: segmentPipeline,
                text: {
                    loader: TextTrackLoader,
                    parser: TextTrackParser
                },
                image: {
                    loader: function loader(_ref5) {
                        var segment = _ref5.segment;
                        if (segment.isInit || null == segment.mediaURL) return Object(of.a)({
                            type: "data",
                            value: {
                                responseData: null
                            }
                        });
                        var mediaURL = segment.mediaURL;
                        return Object(request.a)({
                            url: mediaURL,
                            responseType: "arraybuffer"
                        });
                    },
                    parser: function parser(_ref6) {
                        var response = _ref6.response, segment = _ref6.segment, responseData = response.responseData;
                        // TODO image Parsing should be more on the sourceBuffer side, no?
                        if (null === responseData || null == features.a.imageParser) return Object(of.a)({
                            segmentData: null,
                            segmentInfos: 0 < segment.timescale ? {
                                duration: segment.isInit ? 0 : segment.duration,
                                time: segment.isInit ? -1 : segment.time,
                                timescale: segment.timescale
                            } : null,
                            segmentOffset: segment.timestampOffset || 0
                        });
                        var bifObject = features.a.imageParser(new Uint8Array(responseData)), data = bifObject.thumbs;
                        return Object(of.a)({
                            segmentData: {
                                data: data,
                                start: 0,
                                end: Number.MAX_VALUE,
                                timescale: 1,
                                type: "bif"
                            },
                            segmentInfos: {
                                time: 0,
                                duration: Number.MAX_VALUE,
                                timescale: bifObject.timescale
                            },
                            segmentOffset: segment.timestampOffset || 0
                        });
                    }
                }
            };
        };
        // CONCATENATED MODULE: ./src/transports/dash/index.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */
        /* harmony default export */    }, 
    /* 158 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/of.js
        var of = __webpack_require__(30), map = __webpack_require__(34), features = __webpack_require__(10), log = __webpack_require__(0), src_manifest = __webpack_require__(104), read = __webpack_require__(111), object_assign = __webpack_require__(9), object_assign_default = /* */ __webpack_require__.n(object_assign), config = __webpack_require__(2), assert = __webpack_require__(16), id_generator = __webpack_require__(48), resolve_url = __webpack_require__(32), check_manifest_ids = __webpack_require__(90);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/map.js
                // CONCATENATED MODULE: ./src/parsers/manifest/smooth/get_codecs.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {string} fourCC
 * @param {string} codecPrivateData
 * @returns {string}
 */
        function getAudioCodecs(fourCC, codecPrivateData) {
            var mpProfile;
            return (mpProfile = "AACH" === fourCC ? 5 : codecPrivateData ? (248 & parseInt(codecPrivateData.substring(0, 2), 16)) >> 3 : 2) ? "mp4a.40." + mpProfile : "";
        }
        /**
 * @param {string} codecPrivateData
 * @returns {string}
 */        function getVideoCodecs(codecPrivateData) {
            // we can extract codes only if fourCC is on of "H264", "X264", "DAVC", "AVC1"
            var _ref$ = (/00000001\d7([0-9a-fA-F]{6})/.exec(codecPrivateData) || [])[1], avcProfile = void 0 === _ref$ ? "" : _ref$;
            return avcProfile && "avc1." + avcProfile;
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/smooth/parse_C_nodes.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Parse C nodes to build index timeline.
 * @param {Element} nodes
 */        function parseCNodes(nodes) {
            return nodes.reduce(function(timeline, node, i) {
                var dAttr = node.getAttribute("d"), tAttr = node.getAttribute("t"), rAttr = node.getAttribute("r"), repeatCount = rAttr ? +rAttr - 1 : 0, start = tAttr ? +tAttr : void 0, duration = dAttr ? +dAttr : void 0;
                if (0 === i) 
                // first node
                start = start || 0; else {
                    // from second node to the end
                    var prev = timeline[i - 1];
                    if (null == start || isNaN(start)) {
                        if (null == prev.duration || isNaN(prev.duration)) throw new Error("Smooth: Invalid CNodes. Missing timestamp.");
                        start = prev.start + prev.duration * (prev.repeatCount + 1);
                    }
                }
                if (null == duration || isNaN(duration)) {
                    var nextNode = nodes[i + 1];
                    if (!nextNode) return timeline;
                    var nextTAttr = nextNode.getAttribute("t"), nextStart = nextTAttr ? +nextTAttr : null;
                    if (null === nextStart) throw new Error("Can't build index timeline from Smooth Manifest.");
                    duration = nextStart - start;
                }
                return timeline.push({
                    duration: duration,
                    start: start,
                    repeatCount: repeatCount
                }), timeline;
            }, []);
        }
        // EXTERNAL MODULE: ./src/utils/byte_parsing.ts
                var byte_parsing = __webpack_require__(1);
        // CONCATENATED MODULE: ./src/parsers/containers/isobmff/drm/playready.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Parse PlayReady privateData to get its Hexa-coded KeyID.
 * @param {Uint8Array} privateData
 * @returns {string}
 */        function getPlayReadyKIDFromPrivateData(data) {
            var xmlLength = Object(byte_parsing.n)(data, 8), xml = Object(byte_parsing.g)(data.subarray(10, xmlLength + 10)), kidElement = new DOMParser().parseFromString(xml, "application/xml").querySelector("KID");
            if (!kidElement) throw new Error("Cannot parse PlayReady private data: invalid XML");
            var kid = kidElement.textContent || "";
            return Object(byte_parsing.i)(atob(kid)).toLowerCase();
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/smooth/parse_protection_node.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {Uint8Array} keyIdBytes
 * @returns {Array.<Object>}
 */        function createWidevineKeySystem(keyIdBytes) {
            return [ {
                systemId: "edef8ba9-79d6-4ace-a3c8-27dcd51d21ed",
                privateData: Object(byte_parsing.h)([ 8, 1, 18, 16 ], keyIdBytes)
            } ];
        }
        /**
 * Parse "Protection" Node, which contains DRM informations
 * @param {Element} protectionNode
 * @returns {Object}
 */        function parseProtectionNode(protectionNode, keySystemCreator) {
            if (void 0 === keySystemCreator && (keySystemCreator = createWidevineKeySystem), 
            !protectionNode.firstElementChild || "ProtectionHeader" !== protectionNode.firstElementChild.nodeName) throw new Error("Protection should have ProtectionHeader child");
            var header = protectionNode.firstElementChild, privateData = Object(byte_parsing.p)(atob(header.textContent || "")), keyIdHex = getPlayReadyKIDFromPrivateData(privateData), keyIdBytes = Object(byte_parsing.j)(keyIdHex);
            return {
                keyId: keyIdHex,
                keySystems: [ {
                    systemId: (header.getAttribute("SystemID") || "").toLowerCase().replace(/\{|\}/g, ""),
                    privateData: privateData
                } ].concat(keySystemCreator(keyIdBytes))
            };
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/smooth/utils/tokens.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {string} url
 * @param {string|number} bitrate
 * @returns {string}
 */        function replaceRepresentationSmoothTokens(url, bitrate) {
            return url.replace(/\{bitrate\}/g, String(bitrate));
        }
        /**
 * @param {string} url
 * @param {number} time
 * @returns {string}
 */        function replaceSegmentSmoothTokens(url, time) {
            return url.replace(/\{start time\}/g, String(time));
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/smooth/representation_index.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Add a new segment to the index.
 *
 * /!\ Mutate the given index
 * @param {Object} index
 * @param {Object} newSegment
 * @param {Object} currentSegment
 * @returns {Boolean} - true if the segment has been added
 */        function _addSegmentInfos(index, newSegment, currentSegment) {
            var scaledCurrentTime, timeline = index.timeline, timescale = index.timescale, timelineLength = timeline.length, last = timeline[timelineLength - 1], scaledNewSegment = newSegment.timescale === timescale ? {
                time: newSegment.time,
                duration: newSegment.duration
            } : {
                time: newSegment.time / newSegment.timescale * timescale,
                duration: newSegment.duration / newSegment.timescale * timescale
            };
            if (currentSegment && currentSegment.timescale && (scaledCurrentTime = currentSegment.timescale === timescale ? currentSegment.time : currentSegment.time / currentSegment.timescale * timescale), 
            null == scaledCurrentTime || scaledNewSegment.time !== scaledCurrentTime) return scaledNewSegment.time >= getTimelineRangeEnd(last) && (last.duration === scaledNewSegment.duration ? last.repeatCount++ : index.timeline.push({
                duration: scaledNewSegment.duration,
                start: scaledNewSegment.time,
                repeatCount: 0
            }), !0);
            var newSegmentStart = scaledNewSegment.time + scaledNewSegment.duration, startDiff = newSegmentStart - (last.start + (last.duration || 0) * last.repeatCount);
            if (startDiff <= 0) 
            // same segment / behind the last
            return !1;
 // try to use the compact notation with @r attribute on the last
            // to elements of the timeline if we find out they have the same
            // duration
                        if (-1 === last.duration) {
                var prev = timeline[timelineLength - 2];
                prev && prev.duration === startDiff ? (prev.repeatCount++, timeline.pop()) : last.duration = startDiff;
            }
            return index.timeline.push({
                duration: -1,
                start: newSegmentStart,
                repeatCount: 0
            }), !0;
        }
        /**
 * Get index of the segment containing the given timescaled timestamp.
 * @param {Object} index
 * @param {Number} start
 * @returns {Number}
 */        function getSegmentIndex(index, start) {
            for (var timeline = index.timeline, low = 0, high = timeline.length; low < high; ) {
                var mid = low + high >>> 1;
                timeline[mid].start < start ? low = mid + 1 : high = mid;
            }
            return 0 < low ? low - 1 : low;
        }
        /**
 * @param {Number} start
 * @param {Number} up
 * @param {Number} duration
 * @returns {Number}
 */        function getSegmentNumber(start, up, duration) {
            if (!duration) return 0;
            var diff = up - start;
            return 0 < diff ? Math.floor(diff / duration) : 0;
        }
        /**
 * Get end of the given index range, timescaled.
 * @param {Object} range
 * @returns {Number} - absolute end time of the range
 */        function getTimelineRangeEnd(_ref) {
            var start = _ref.start, duration = _ref.duration, repeatCount = _ref.repeatCount;
            return null == duration || -1 === duration ? start : start + (repeatCount + 1) * duration;
        }
 // interface ISmoothIndex {
        //   presentationTimeOffset? : number;
        //   timescale : number;
        //   media? : string;
        //   timeline : IIndexSegment[];
        //   startNumber? : number;
        // }
        /**
 * Convert second-based start time and duration to the timescale of the
 * manifest's index.
 * @param {Object} index
 * @param {Number} start
 * @param {Number} duration
 * @returns {Object} - Object with two properties:
 *   - up {Number}: timescaled timestamp of the beginning time
 *   - to {Number}: timescaled timestamp of the end time (start time + duration)
 */        function normalizeRange(index, start, duration) {
            var timescale = index.timescale || 1;
            return {
                up: start * timescale,
                to: (start + duration) * timescale
            };
        }
        /**
 * Calculate the number of times a segment repeat based on the next segment.
 * @param {Object} segment
 * @param {Object} nextSegment
 * @returns {Number}
 */        function calculateRepeat(segment, nextSegment) {
            var repeatCount = segment.repeatCount || 0;
 // A negative value of the @r attribute of the S element indicates
            // that the duration indicated in @d attribute repeats until the
            // start of the next S element, the end of the Period or until the
            // next MPD update.
            // TODO Also for SMOOTH????
                        if (null != segment.duration && repeatCount < 0) {
                var repeatEnd = nextSegment ? nextSegment.start : Infinity;
                repeatCount = Math.ceil((repeatEnd - segment.start) / segment.duration) - 1;
            }
            return repeatCount;
        }
        /**
 * RepresentationIndex implementation for Smooth Manifests.
 *
 * Allows to interact with the index to create new Segments.
 *
 * @class SmoothRepresentationIndex
 */        var representation_index_SmoothRepresentationIndex = 
        /* */
        function() {
            function SmoothRepresentationIndex(index, infos) {
                var estimatedReceivedTime = null == index.manifestReceivedTime ? performance.now() : index.manifestReceivedTime;
                if (this._index = index, this._indexValidityTime = estimatedReceivedTime, this._bitsPerSample = infos.bitsPerSample, 
                this._channels = infos.channels, this._codecPrivateData = infos.codecPrivateData, 
                this._packetSize = infos.packetSize, this._samplingRate = infos.samplingRate, this._protection = infos.protection, 
                index.timeline.length) {
                    var scaledEnd = getTimelineRangeEnd(index.timeline[index.timeline.length - 1]);
                    if (this._initialLastPosition = scaledEnd / index.timescale, index.isLive) {
                        var scaledReceivedTime = estimatedReceivedTime / 1e3 * index.timescale;
                        this._scaledLiveGap = scaledReceivedTime - scaledEnd;
                    }
                }
            }
            /**
   * Construct init Segment compatible with a Smooth Manifest.
   * @returns {Object}
   */            var _proto = SmoothRepresentationIndex.prototype;
            return _proto.getInitSegment = function getInitSegment() {
                return {
                    id: "init",
                    isInit: !0,
                    time: 0,
                    timescale: this._index.timescale,
                    privateInfos: {
                        smoothInit: {
                            bitsPerSample: this._bitsPerSample,
                            channels: this._channels,
                            codecPrivateData: this._codecPrivateData,
                            packetSize: this._packetSize,
                            samplingRate: this._samplingRate,
                            protection: this._protection
                        }
                    },
                    mediaURL: null
                };
            }
            /**
   * Generate a list of Segments for a particular period of time.
   *
   * @param {Number} _up
   * @param {Number} _to
   * @returns {Array.<Object>}
   */ , _proto.getSegments = function getSegments(_up, _to) {
                for (var currentNumber, index = this._index, _normalizeRange = normalizeRange(index, _up, _to), up = _normalizeRange.up, to = _normalizeRange.to, timeline = index.timeline, timescale = index.timescale, media = index.media, segments = [], timelineLength = timeline.length, maxEncounteredDuration = timeline.length && timeline[0].duration || 0, estimatedEnd = null == this._scaledLiveGap ? void 0 : performance.now() / 1e3 * timescale - this._scaledLiveGap, i = 0; i < timelineLength; i++) {
                    var segmentRange = timeline[i], duration = segmentRange.duration, start = segmentRange.start;
                    // live-added segments have @d attribute equals to -1
                    if (maxEncounteredDuration = Math.max(maxEncounteredDuration, duration || 0), null != duration && duration < 0) {
                        var approximateEnd = start + maxEncounteredDuration;
                        if (approximateEnd < to && (null == estimatedEnd || approximateEnd <= estimatedEnd)) {
                            var segment = {
                                id: "" + start,
                                time: start,
                                isInit: !1,
                                timescale: timescale,
                                number: null != currentNumber ? currentNumber : void 0,
                                mediaURL: replaceSegmentSmoothTokens(media, start)
                            };
                            segments.push(segment);
                        }
                        return segments;
                    }
                    for (var repeat = calculateRepeat(segmentRange, timeline[i + 1]), segmentNumberInCurrentRange = getSegmentNumber(start, up, duration), segmentTime = start + segmentNumberInCurrentRange * (null == duration ? 0 : duration); segmentTime < to && segmentNumberInCurrentRange <= repeat && (null == estimatedEnd || segmentTime + duration <= estimatedEnd); ) {
                        var _segment = {
                            id: "" + segmentTime,
                            time: segmentTime,
                            isInit: !1,
                            duration: duration,
                            timescale: timescale,
                            number: null != currentNumber ? currentNumber + segmentNumberInCurrentRange : void 0,
                            mediaURL: replaceSegmentSmoothTokens(media, segmentTime)
                        };
                        segments.push(_segment), segmentTime = start + // update segment number and segment time for the next segment
                        ++segmentNumberInCurrentRange * duration;
                    }
                    if (to <= segmentTime) 
                    // we reached ``to``, we're done
                    return segments;
                    null != currentNumber && (currentNumber += repeat + 1);
                }
                return segments;
            }
            /**
   * Returns true if, based on the arguments, the index should be refreshed.
   * (If we should re-fetch the manifest)
   * @param {Number} from
   * @param {Number} to
   * @returns {Boolean}
   */ , _proto.shouldRefresh = function shouldRefresh(up, to) {
                if (!this._index.isLive) return !1;
                var _this$_index = this._index, timeline = _this$_index.timeline, timescale = _this$_index.timescale, lastSegmentInCurrentTimeline = timeline[timeline.length - 1];
                if (!lastSegmentInCurrentTimeline) return !1;
                var repeat = lastSegmentInCurrentTimeline.repeatCount || 0, endOfLastSegmentInCurrentTimeline = lastSegmentInCurrentTimeline.start + (repeat + 1) * lastSegmentInCurrentTimeline.duration;
                return !(to * timescale < endOfLastSegmentInCurrentTimeline) && (endOfLastSegmentInCurrentTimeline <= up * timescale || lastSegmentInCurrentTimeline.start + repeat * lastSegmentInCurrentTimeline.duration < up * timescale);
            }
            /**
   * Returns first position available in the index.
   *
   * @param {Object} index
   * @returns {Number}
   */ , _proto.getFirstPosition = function getFirstPosition() {
                var index = this._index;
                if (index.timeline.length) return index.timeline[0].start / index.timescale;
            }
            /**
   * Returns last position available in the index.
   * @param {Object} index
   * @returns {Number}
   */ , _proto.getLastPosition = function getLastPosition() {
                for (var index = this._index, i = index.timeline.length - 1; 0 <= i; i--) {
                    var lastTimelineElement = index.timeline[i];
                    if (null == this._scaledLiveGap) return getTimelineRangeEnd(lastTimelineElement) / index.timescale;
                    for (var timescaledNow = performance.now() / 1e3 * index.timescale, start = lastTimelineElement.start, duration = lastTimelineElement.duration, j = lastTimelineElement.repeatCount; 0 <= j; j--) {
                        var end = start + duration * (j + 1);
                        if (end <= timescaledNow - this._scaledLiveGap) return end / index.timescale;
                    }
                }
            }
            /**
   * Checks if the time given is in a discontinuity. That is:
   *   - We're on the upper bound of the current range (end of the range - time
   *     is inferior to the timescale)
   *   - The next range starts after the end of the current range.
   *
   * @param {Number} _time
   * @returns {Number} - If a discontinuity is present, this is the Starting
   * time for the next (discontinuited) range. If not this is equal to -1.
   */ , _proto.checkDiscontinuity = function checkDiscontinuity(_time) {
                var index = this._index, timeline = index.timeline, _index$timescale = index.timescale, timescale = void 0 === _index$timescale ? 1 : _index$timescale, time = _time * timescale;
                if (time <= 0) return -1;
                var segmentIndex = getSegmentIndex(index, time);
                if (segmentIndex < 0 || segmentIndex >= timeline.length - 1) return -1;
                var range = timeline[segmentIndex];
                if (-1 === range.duration) return -1;
                var rangeUp = range.start, rangeTo = getTimelineRangeEnd(range), nextRange = timeline[segmentIndex + 1];
                // when we are actually inside the found range and this range has
                // an explicit discontinuity with the next one
                return rangeTo !== nextRange.start && rangeUp <= time && time <= rangeTo && rangeTo - time < timescale ? nextRange.start / timescale : -1;
            }
            /**
   * Update this RepresentationIndex by a newly downloaded one.
   * Check if the old index had more informations about new segments and
   * re-add them if that's the case.
   * @param {Object} newIndex
   */ , _proto._update = function _update(newIndex) {
                var oldTimeline = this._index.timeline, newTimeline = newIndex._index.timeline, oldTimescale = this._index.timescale, newTimescale = newIndex._index.timescale;
                if (this._index = newIndex._index, this._initialLastPosition = newIndex._initialLastPosition, 
                this._indexValidityTime = newIndex._indexValidityTime, this._scaledLiveGap = newIndex._scaledLiveGap, 
                oldTimeline.length && newTimeline.length && oldTimescale === newTimescale) {
                    var lastOldTimelineElement = oldTimeline[oldTimeline.length - 1], lastNewTimelineElement = newTimeline[newTimeline.length - 1], newEnd = getTimelineRangeEnd(lastNewTimelineElement);
                    if (!(getTimelineRangeEnd(lastOldTimelineElement) <= newEnd)) for (var i = 0; i < oldTimeline.length; i++) {
                        var oldTimelineRange = oldTimeline[i], oldEnd = getTimelineRangeEnd(oldTimelineRange);
                        if (oldEnd === newEnd) 
                        // just add the supplementary segments
                        return void (this._index.timeline = this._index.timeline.concat(oldTimeline.slice(i + 1)));
                        if (newEnd < oldEnd) {
                            // adjust repeatCount + add supplementary segments
                            if (oldTimelineRange.duration !== lastNewTimelineElement.duration) return;
                            var rangeDuration = newEnd - oldTimelineRange.start;
                            if (0 === rangeDuration) return log.a.warn("Smooth Parser: a discontinuity detected in the previous manifest has been resolved."), 
                            void (this._index.timeline = this._index.timeline.concat(oldTimeline.slice(i)));
                            if (rangeDuration < 0 || rangeDuration % oldTimelineRange.duration != 0) return;
                            var repeatWithOld = rangeDuration / oldTimelineRange.duration - 1, relativeRepeat = oldTimelineRange.repeatCount - repeatWithOld;
                            if (relativeRepeat < 0) return;
                            lastNewTimelineElement.repeatCount += relativeRepeat;
                            var supplementarySegments = oldTimeline.slice(i + 1);
                            return void (this._index.timeline = this._index.timeline.concat(supplementarySegments));
                        }
                    }
                }
            }, _proto._addSegments = function _addSegments(nextSegments, currentSegment) {
                for (var i = 0; i < nextSegments.length; i++) _addSegmentInfos(this._index, nextSegments[i], currentSegment);
 // clean segments before time shift buffer depth
                                if (null != this._initialLastPosition) {
                    var timeShiftBufferDepth = this._index.timeShiftBufferDepth, lastPositionEstimate = (performance.now() - this._indexValidityTime) / 1e3 + this._initialLastPosition;
                    if (null != timeShiftBufferDepth) for (var threshold = (lastPositionEstimate - timeShiftBufferDepth) * this._index.timescale, _i = 0; _i < this._index.timeline.length; _i++) {
                        var segment = this._index.timeline[_i];
                        if (segment.start + segment.duration >= threshold) {
                            this._index.timeline = this._index.timeline.slice(_i, this._index.timeline.length);
                            break;
                        }
                    }
                }
            }, SmoothRepresentationIndex;
        }();
        // CONCATENATED MODULE: ./src/parsers/manifest/smooth/utils/parseBoolean.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {*} parseBoolean
 * @returns {Boolean}
 */        function parseBoolean(val) {
            return "boolean" == typeof val ? val : "string" == typeof val && "TRUE" === val.toUpperCase();
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/smooth/utils/reduceChildren.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Reduce implementation for the children of the given element.
 * @param {Element} root
 * @param {Function} fn
 * @param {*} init
 * @returns {*}
 */        function reduceChildren(root, fn, init) {
            for (var node = root.firstElementChild, accumulator = init; node; ) accumulator = fn(accumulator, node.nodeName, node), 
            node = node.nextElementSibling;
            return accumulator;
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/smooth/create_parser.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        var generateManifestID = Object(id_generator.a)(), DEFAULT_MIME_TYPES = {
            audio: "audio/mp4",
            video: "video/mp4",
            text: "application/ttml+xml"
        }, DEFAULT_CODECS = {
            audio: "mp4a.40.2",
            video: "avc1.4D401E"
        }, MIME_TYPES = {
            AACL: "audio/mp4",
            AVC1: "video/mp4",
            H264: "video/mp4",
            TTML: "application/ttml+xml+mp4"
        };
        /* harmony default export */ var smooth = 
        /**
 * @param {Object|undefined} parserOptions
 * @returns {Function}
 */
        function createSmoothStreamingParser(parserOptions) {
            void 0 === parserOptions && (parserOptions = {});
            var SUGGESTED_PERSENTATION_DELAY = null == parserOptions.suggestedPresentationDelay ? config.a.DEFAULT_SUGGESTED_PRESENTATION_DELAY.SMOOTH : parserOptions.suggestedPresentationDelay, REFERENCE_DATE_TIME = parserOptions.referenceDateTime || Date.UTC(1970, 0, 1, 0, 0, 0, 0) / 1e3, MIN_REPRESENTATION_BITRATE = parserOptions.minRepresentationBitrate || 0;
            /**
   * @param {Element} q
   * @param {string} streamType
   * @return {Object}
   */
            function parseQualityLevel(q, streamType) {
                /**
     * @param {string} name
     * @returns {string|undefined}
     */
                function getAttribute(name) {
                    var attr = q.getAttribute(name);
                    return null == attr ? void 0 : attr;
                }
                switch (streamType) {
                  case "audio":
                    var audiotag = getAttribute("AudioTag"), bitrate = getAttribute("Bitrate"), bitsPerSample = getAttribute("BitsPerSample"), channels = getAttribute("Channels"), codecPrivateData = getAttribute("CodecPrivateData"), fourCC = getAttribute("FourCC"), packetSize = getAttribute("PacketSize"), samplingRate = getAttribute("SamplingRate");
                    return {
                        audiotag: void 0 !== audiotag ? parseInt(audiotag, 10) : audiotag,
                        bitrate: bitrate && parseInt(bitrate, 10) || 0,
                        bitsPerSample: void 0 !== bitsPerSample ? parseInt(bitsPerSample, 10) : bitsPerSample,
                        channels: void 0 !== channels ? parseInt(channels, 10) : channels,
                        codecPrivateData: codecPrivateData || "",
                        mimeType: void 0 !== fourCC ? MIME_TYPES[fourCC] : fourCC,
                        packetSize: void 0 !== packetSize ? parseInt(packetSize, 10) : packetSize,
                        samplingRate: void 0 !== samplingRate ? parseInt(samplingRate, 10) : samplingRate
                    };

                  case "video":
                    var _bitrate = getAttribute("Bitrate"), _codecPrivateData = getAttribute("CodecPrivateData"), _fourCC = getAttribute("FourCC"), width = getAttribute("MaxWidth"), height = getAttribute("MaxHeight");
                    return {
                        bitrate: _bitrate && parseInt(_bitrate, 10) || 0,
                        mimeType: void 0 !== _fourCC ? MIME_TYPES[_fourCC] : _fourCC,
                        codecPrivateData: _codecPrivateData || "",
                        codecs: getVideoCodecs(_codecPrivateData || ""),
                        width: void 0 !== width ? parseInt(width, 10) : void 0,
                        height: void 0 !== height ? parseInt(height, 10) : void 0
                    };

                  case "text":
                    var _bitrate2 = getAttribute("Bitrate"), _codecPrivateData2 = getAttribute("CodecPrivateData"), _fourCC2 = getAttribute("FourCC");
                    return {
                        bitrate: _bitrate2 && parseInt(_bitrate2, 10) || 0,
                        mimeType: void 0 !== _fourCC2 ? MIME_TYPES[_fourCC2] : _fourCC2,
                        codecPrivateData: _codecPrivateData2 || ""
                    };

                  default:
                    throw new Error("Unrecognized StreamIndex type: " + streamType);
                }
            }
            /**
   * Parse the adaptations (<StreamIndex>) tree containing
   * representations (<QualityLevels>) and timestamp indexes (<c>).
   * Indexes can be quite huge, and this function needs to
   * to be optimized.
   * @param {Object} args
   * @returns {Object}
   */            function parseAdaptation(args) {
                var root = args.root, timescale = args.timescale, rootURL = args.rootURL, protections = args.protections, timeShiftBufferDepth = args.timeShiftBufferDepth, manifestReceivedTime = args.manifestReceivedTime, isLive = args.isLive, _timescale = root.hasAttribute("Timescale") ? +(root.getAttribute("Timescale") || 0) : timescale, adaptationType = root.getAttribute("Type");
                if (null == adaptationType) throw new Error("StreamIndex without type.");
                var subType = root.getAttribute("Subtype"), language = root.getAttribute("Language"), baseURL = root.getAttribute("Url") || "", _reduceChildren = reduceChildren(root, function(res, _name, node) {
                    switch (_name) {
                      case "QualityLevel":
                        var qualityLevel = parseQualityLevel(node, adaptationType);
                        if ("audio" === adaptationType) {
                            var fourCC = node.getAttribute("FourCC") || "";
                            qualityLevel.codecs = getAudioCodecs(fourCC, qualityLevel.codecPrivateData);
                        }
 // filter out video qualityLevels with small bitrates
                                                ("video" !== adaptationType || qualityLevel.bitrate > MIN_REPRESENTATION_BITRATE) && res.qualityLevels.push(qualityLevel);
                        break;

                      case "c":
                        res.cNodes.push(node);
                    }
                    return res;
                }, {
                    qualityLevels: [],
                    cNodes: []
                }), qualityLevels = _reduceChildren.qualityLevels, index = {
                    timeline: parseCNodes(_reduceChildren.cNodes),
                    timescale: _timescale
                };
                // we assume that all qualityLevels have the same
                // codec and mimeType
                Object(assert.b)(0 !== qualityLevels.length, "adaptation should have at least one representation");
                var adaptationID = adaptationType + (language ? "_" + language : ""), representations = qualityLevels.map(function(qualityLevel) {
                    var firstProtection, path = Object(resolve_url.a)(rootURL, baseURL), repIndex = {
                        timeline: index.timeline,
                        timescale: index.timescale,
                        media: replaceRepresentationSmoothTokens(path, qualityLevel.bitrate),
                        isLive: isLive,
                        timeShiftBufferDepth: timeShiftBufferDepth,
                        manifestReceivedTime: manifestReceivedTime
                    }, mimeType = qualityLevel.mimeType || DEFAULT_MIME_TYPES[adaptationType], codecs = qualityLevel.codecs || DEFAULT_CODECS[adaptationType], id = adaptationID + "_" + adaptationType + "-" + mimeType + "-" + codecs + "-" + qualityLevel.bitrate, contentProtections = [];
                    protections.length && (firstProtection = protections[0], protections.forEach(function(protection) {
                        var keyId = protection.keyId;
                        protection.keySystems.forEach(function(keySystem) {
                            contentProtections.push({
                                keyId: keyId,
                                systemId: keySystem.systemId
                            });
                        });
                    }));
                    var initSegmentInfos = {
                        bitsPerSample: qualityLevel.bitsPerSample,
                        channels: qualityLevel.channels,
                        codecPrivateData: qualityLevel.codecPrivateData || "",
                        packetSize: qualityLevel.packetSize,
                        samplingRate: qualityLevel.samplingRate,
                        // TODO set multiple protections here instead of the first one
                        protection: null != firstProtection ? {
                            keyId: firstProtection.keyId,
                            keySystems: firstProtection.keySystems
                        } : void 0
                    }, representation = object_assign_default()({}, qualityLevel, {
                        index: new representation_index_SmoothRepresentationIndex(repIndex, initSegmentInfos),
                        mimeType: mimeType,
                        codecs: codecs,
                        id: id
                    });
                    return contentProtections.length && (representation.contentProtections = contentProtections), 
                    representation;
                });
                // TODO(pierre): real ad-insert support
                if ("ADVT" === subType) return null;
                var parsedAdaptation = {
                    id: adaptationID,
                    type: adaptationType,
                    representations: representations,
                    language: null == language ? void 0 : language
                };
                return "text" === adaptationType && "DESC" === subType && (parsedAdaptation.closedCaption = !0), 
                parsedAdaptation;
            }
            return function parseFromDocument(doc, url, manifestReceivedTime) {
                var rootURL = Object(resolve_url.b)(url), root = doc.documentElement;
                if (!root || "SmoothStreamingMedia" !== root.nodeName) throw new Error("document root should be SmoothStreamingMedia");
                if (!/^[2]-[0-2]$/.test(root.getAttribute("MajorVersion") + "-" + root.getAttribute("MinorVersion"))) throw new Error("Version should be 2.0, 2.1 or 2.2");
                var suggestedPresentationDelay, presentationLiveGap, availabilityStartTime, firstTimeReference, lastTimeReference, duration, timescale = +(root.getAttribute("Timescale") || 1e7), _reduceChildren2 = reduceChildren(root, function(res, name, node) {
                    switch (name) {
                      case "Protection":
                        res.protections.push(parseProtectionNode(node, parserOptions.keySystems));
                        break;

                      case "StreamIndex":
                        res.adaptationNodes.push(node);
                    }
                    return res;
                }, {
                    adaptationNodes: [],
                    protections: []
                }), protections = _reduceChildren2.protections, adaptationNodes = _reduceChildren2.adaptationNodes, isLive = parseBoolean(root.getAttribute("IsLive")), timeShiftBufferDepth = isLive ? +(root.getAttribute("DVRWindowLength") || 0) / timescale : void 0, adaptations = adaptationNodes.map(function(node) {
                    return parseAdaptation({
                        root: node,
                        rootURL: rootURL,
                        timescale: timescale,
                        protections: protections,
                        isLive: isLive,
                        timeShiftBufferDepth: timeShiftBufferDepth,
                        manifestReceivedTime: manifestReceivedTime
                    });
                }).filter(function(adaptation) {
                    return null != adaptation;
                }).reduce(function(acc, adaptation) {
                    var type = adaptation.type;
                    return void 0 === acc[type] ? acc[type] = [ adaptation ] : (acc[type] || []).push(adaptation), 
                    acc;
                }, {}), firstVideoAdaptation = adaptations.video ? adaptations.video[0] : void 0, firstAudioAdaptation = adaptations.audio ? adaptations.audio[0] : void 0;
                if (firstVideoAdaptation || firstAudioAdaptation) {
                    var firstTimeReferences = [], lastTimeReferences = [];
                    if (firstVideoAdaptation) {
                        var firstVideoRepresentation = firstVideoAdaptation.representations[0];
                        if (firstVideoRepresentation) {
                            var firstVideoTimeReference = firstVideoRepresentation.index.getFirstPosition(), lastVideoTimeReference = firstVideoRepresentation.index.getLastPosition();
                            null != firstVideoTimeReference && firstTimeReferences.push(firstVideoTimeReference), 
                            null != lastVideoTimeReference && lastTimeReferences.push(lastVideoTimeReference);
                        }
                    }
                    if (firstAudioAdaptation) {
                        var firstAudioRepresentation = firstAudioAdaptation.representations[0];
                        if (firstAudioRepresentation) {
                            var firstAudioTimeReference = firstAudioRepresentation.index.getFirstPosition(), lastAudioTimeReference = firstAudioRepresentation.index.getLastPosition();
                            null != firstAudioTimeReference && firstTimeReferences.push(firstAudioTimeReference), 
                            null != lastAudioTimeReference && lastTimeReferences.push(lastAudioTimeReference);
                        }
                    }
                    firstTimeReferences.length && (firstTimeReference = Math.max.apply(Math, firstTimeReferences)), 
                    lastTimeReferences.length && (lastTimeReference = Math.max.apply(Math, lastTimeReferences));
                }
                if (isLive) {
                    suggestedPresentationDelay = SUGGESTED_PERSENTATION_DELAY, availabilityStartTime = REFERENCE_DATE_TIME, 
                    presentationLiveGap = Date.now() / 1e3 - (null != lastTimeReference ? lastTimeReference + availabilityStartTime : 10);
                    var manifestDuration = root.getAttribute("Duration");
                    duration = null != manifestDuration && 0 != +manifestDuration ? +manifestDuration / timescale : void 0;
                } else {
                    // if non-live and first time reference different than 0. Add first time reference
                    // to duration
                    var _manifestDuration = root.getAttribute("Duration");
                    duration = null != _manifestDuration && 0 != +_manifestDuration ? null == lastTimeReference ? +_manifestDuration / timescale + (firstTimeReference || 0) : lastTimeReference : void 0;
                }
                var minimumTime = null != firstTimeReference ? firstTimeReference : void 0, manifest = {
                    id: "gen-smooth-manifest-" + generateManifestID(),
                    availabilityStartTime: availabilityStartTime || 0,
                    duration: duration,
                    presentationLiveGap: presentationLiveGap,
                    suggestedPresentationDelay: suggestedPresentationDelay,
                    timeShiftBufferDepth: timeShiftBufferDepth,
                    transportType: "smooth",
                    isLive: isLive,
                    uris: [ url ],
                    minimumTime: minimumTime,
                    periods: [ {
                        id: "gen-smooth-period-0",
                        duration: duration,
                        adaptations: adaptations,
                        start: 0
                    } ]
                };
                return Object(check_manifest_ids.a)(manifest), manifest;
            };
        }, request = __webpack_require__(23), string_from_utf8 = __webpack_require__(93), warn_once = __webpack_require__(26), manifest_loader = __webpack_require__(91), utils = __webpack_require__(183), get_box = __webpack_require__(63);
        // CONCATENATED MODULE: ./src/parsers/manifest/smooth/index.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /* harmony default export */        
        // CONCATENATED MODULE: ./src/transports/smooth/isobmff/parse_tfrf.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {Uint8Array} traf
 * @returns {Array.<Object>}
 */
        function parseTfrf(traf) {
            var tfrf = Object(get_box.d)(traf, 3565190898, 3392751253, 2387879627, 2655430559);
            if (!tfrf) return [];
            for (var frags = [], version = tfrf[0], fragCount = tfrf[4], i = 0; i < fragCount; i++) {
                var duration = void 0, time = void 0;
                duration = 1 === version ? (time = Object(byte_parsing.d)(tfrf, 16 * i + 5), Object(byte_parsing.d)(tfrf, 16 * i + 5 + 8)) : (time = Object(byte_parsing.c)(tfrf, 8 * i + 5), 
                Object(byte_parsing.c)(tfrf, 8 * i + 5 + 4)), frags.push({
                    time: time,
                    duration: duration
                });
            }
            return frags;
        }
        // CONCATENATED MODULE: ./src/transports/smooth/isobmff/parse_tfxd.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {Uint8Array} traf
 * @returns {Object|undefined}
 */        function parseTfxd(traf) {
            var tfxd = Object(get_box.d)(traf, 1830656773, 1121273062, 2162299933, 2952222642);
            if (null != tfxd) return {
                duration: Object(byte_parsing.d)(tfxd, 12),
                time: Object(byte_parsing.d)(tfxd, 4)
            };
        }
        // CONCATENATED MODULE: ./src/transports/smooth/extract_timings_infos.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        function extractTimingsInfos(responseData, segment, isLive) {
            var segmentInfos, tfxdSegment, tfrfSegments, nextSegments = [];
            if (isLive) {
                var traf = Object(read.c)(responseData);
                traf ? (tfrfSegments = parseTfrf(traf), tfxdSegment = parseTfxd(traf)) : log.a.warn("smooth: could not find traf atom");
            }
            if (tfxdSegment) segmentInfos = {
                time: tfxdSegment.time,
                duration: tfxdSegment.duration,
                timescale: segment.timescale
            }; else {
                // we could always make a mistake when reading a container.
                // If the estimate is too far from what the segment seems to imply, take
                // the segment infos instead.
                var maxDecodeTimeDelta = Math.min(.9 * segment.timescale, null != segment.duration ? segment.duration / 4 : .25), trunDuration = Object(utils.a)(responseData);
                segmentInfos = 0 <= trunDuration && (null == segment.duration || Math.abs(trunDuration - segment.duration) <= maxDecodeTimeDelta) ? {
                    time: segment.time,
                    duration: trunDuration,
                    timescale: segment.timescale
                } : {
                    time: segment.time,
                    duration: segment.duration,
                    timescale: segment.timescale
                };
            }
            if (tfrfSegments) for (var i = 0; i < tfrfSegments.length; i++) nextSegments.push({
                time: tfrfSegments[i].time,
                duration: tfrfSegments[i].duration,
                timescale: segment.timescale
            });
            return {
                nextSegments: nextSegments,
                segmentInfos: segmentInfos
            };
        }
        // EXTERNAL MODULE: ./src/parsers/containers/isobmff/create_box.ts
                var create_box = __webpack_require__(136);
        // CONCATENATED MODULE: ./src/transports/smooth/isobmff/add_data_offset_flag_in_trun.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Update `trun` box given to add a data offset flag and the corresponding space
 * to set a data offset.
 * Do not do anything if the flag is already set.
 * @param {Uint8Array} trun
 * @returns {Uint8Array}
 */        function addDataOffsetFlagInTrun(trun) {
            if (1 & trun[11]) return trun;
 // If no dataoffset is present, we add one
                        var newTrun = new Uint8Array(trun.length + 4);
            return newTrun.set(Object(byte_parsing.l)(trun.length + 4), 0), // original length + data_offset size
            newTrun.set(trun.subarray(4, 16), 4), // name + (version + flags) + samplecount
            newTrun[11] = 1 | newTrun[11], // add data_offset flag
            newTrun.set([ 0, 0, 0, 0 ], 16), // add data offset
            newTrun.set(trun.subarray(16, trun.length), 20), newTrun;
        }
        // CONCATENATED MODULE: ./src/transports/smooth/isobmff/create_boxes.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {Number} width
 * @param {Number} height
 * @param {Number} hRes - horizontal resolution, eg 72
 * @param {Number} vRes - vertical resolution, eg 72
 * @param {string} encDepth
 * @param {Number} colorDepth - eg 24
 * @param {Uint8Array} avcc - Uint8Array representing the avcC atom
 * @returns {Uint8Array}
 */        function createAVC1Box(width, height, hRes, vRes, encName, colorDepth, avcc) {
            return Object(create_box.a)("avc1", Object(byte_parsing.h)(6, // 6 bytes reserved
            Object(byte_parsing.k)(1), 16, // drefIdx + QuickTime reserved, zeroes
            Object(byte_parsing.k)(width), // size 2 w
            Object(byte_parsing.k)(height), // size 2 h
            Object(byte_parsing.k)(hRes), 2, // reso 4 h
            Object(byte_parsing.k)(vRes), 6, // reso 4 v + QuickTime reserved, zeroes
            [ 0, 1, encName.length ], // frame count (default 1)
            Object(byte_parsing.p)(encName), // 1byte len + encoder name str
            31 - encName.length, // + padding
            Object(byte_parsing.k)(colorDepth), // color depth
            [ 255, 255 ], // reserved ones
            avcc));
        }
        /**
 * @param {Number} width
 * @param {Number} height
 * @param {Number} hRes - horizontal resolution, eg 72
 * @param {Number} vRes - vertical resolution, eg 72
 * @param {string} encDepth
 * @param {Number} colorDepth - eg 24
 * @param {Uint8Array} avcc - Uint8Array representing the avcC atom
 * @param {Uint8Array} sinf - Uint8Array representing the sinf atom
 * @returns {Uint8Array}
 */        function createENCVBox(width, height, hRes, vRes, encName, colorDepth, avcc, sinf) {
            return Object(create_box.a)("encv", Object(byte_parsing.h)(6, // 6 bytes reserved
            Object(byte_parsing.k)(1), 16, // drefIdx + QuickTime reserved, zeroes
            Object(byte_parsing.k)(width), // size 2 w
            Object(byte_parsing.k)(height), // size 2 h
            Object(byte_parsing.k)(hRes), 2, // reso 4 h
            Object(byte_parsing.k)(vRes), 6, // reso 4 v + QuickTime reserved, zeroes
            [ 0, 1, encName.length ], // frame count (default 1)
            Object(byte_parsing.p)(encName), // 1byte len + encoder name str
            31 - encName.length, // + padding
            Object(byte_parsing.k)(colorDepth), // color depth
            [ 255, 255 ], // reserved ones
            avcc, // avcc atom,
            sinf));
        }
        /**
 * @param {Number} drefIdx
 * @param {Number} channelsCount
 * @param {Number} sampleSize
 * @param {Number} packetSize
 * @param {Number} sampleRate
 * @param {Uint8Array} esds - Uint8Array representing the esds atom
 * @param {Uint8Array} [sinf] - Uint8Array representing the sinf atom,
 * only if name == "enca"
 * @returns {Uint8Array}
 */        function createMP4ABox(drefIdx, channelsCount, sampleSize, packetSize, sampleRate, esds) {
            return Object(create_box.a)("mp4a", Object(byte_parsing.h)(6, Object(byte_parsing.k)(drefIdx), 8, Object(byte_parsing.k)(channelsCount), Object(byte_parsing.k)(sampleSize), 2, Object(byte_parsing.k)(packetSize), Object(byte_parsing.k)(sampleRate), 2, esds));
        }
        /**
 * @param {Number} drefIdx
 * @param {Number} channelsCount
 * @param {Number} sampleSize
 * @param {Number} packetSize
 * @param {Number} sampleRate
 * @param {Uint8Array} esds - Uint8Array representing the esds atom
 * @param {Uint8Array} [sinf] - Uint8Array representing the sinf atom,
 * only if name == "enca"
 * @returns {Uint8Array}
 */        function createENCABox(drefIdx, channelsCount, sampleSize, packetSize, sampleRate, esds, sinf) {
            return Object(create_box.a)("enca", Object(byte_parsing.h)(6, Object(byte_parsing.k)(drefIdx), 8, Object(byte_parsing.k)(channelsCount), Object(byte_parsing.k)(sampleSize), 2, Object(byte_parsing.k)(packetSize), Object(byte_parsing.k)(sampleRate), 2, esds, sinf));
        }
        /**
 * @param {url} Uint8Array
 * @returns {Uint8Array}
 */        function createDREFBox(url) {
            // only one description here... FIXME
            return Object(create_box.a)("dref", Object(byte_parsing.h)(7, [ 1 ], url));
        }
        /**
 * @param {string} majorBrand
 * @param {Array.<string>} brands
 * @returns {Uint8Array}
 */        function createFTYPBox(majorBrand, brands) {
            return Object(create_box.a)("ftyp", byte_parsing.h.apply(null, [ Object(byte_parsing.p)(majorBrand), [ 0, 0, 0, 1 ] ].concat(brands.map(byte_parsing.p))));
        }
        /**
 * @param {string} schemeType - four letters (eg "cenc" for Common Encryption)
 * @param {Number} schemeVersion - eg 65536
 * @returns {Uint8Array}
 */        function createSCHMBox(schemeType, schemeVersion) {
            return Object(create_box.a)("schm", Object(byte_parsing.h)(4, Object(byte_parsing.p)(schemeType), Object(byte_parsing.l)(schemeVersion)));
        }
        /**
 * Create tfdt box from a decoding time.
 * @param {number} decodeTime
 * @returns {Uint8Array}
 */        function createTfdtBox(decodeTime) {
            return Object(create_box.a)("tfdt", Object(byte_parsing.h)([ 1, 0, 0, 0 ], Object(byte_parsing.m)(decodeTime)));
        }
        /**
 * @returns {Uint8Array}
 */        function createVMHDBox() {
            var arr = new Uint8Array(12);
            // QuickTime...
            return arr[3] = 1, Object(create_box.a)("vmhd", arr);
        }
        /**
 * @param {Number} trackId
 * @returns {Uint8Array}
 */        function createTREXBox(trackId) {
            // default sample desc idx = 1
            return Object(create_box.a)("trex", Object(byte_parsing.h)(4, Object(byte_parsing.l)(trackId), [ 0, 0, 0, 1 ], 12));
        }
        /**
 * @param {Number} length
 * @returns {Uint8Array}
 */        function createFreeBox(length) {
            return Object(create_box.a)("free", new Uint8Array(length - 8));
        }
        /**
 * @param {Number} stream
 * @param {string} codecPrivateData - hex string
 * @returns {Uint8Array}
 */        function createESDSBox(stream, codecPrivateData) {
            return Object(create_box.a)("esds", Object(byte_parsing.h)(4, [ 3, 25 ], Object(byte_parsing.k)(stream), [ 0, 4, 17, 64, 21 ], 11, [ 5, 2 ], Object(byte_parsing.j)(codecPrivateData), [ 6, 1, 2 ]));
        }
        /**
 * @param {string} dataFormat - four letters (eg "avc1")
 * @returns {Uint8Array}
 */        function createFRMABox(dataFormat) {
            return Object(create_box.a)("frma", Object(byte_parsing.p)(dataFormat));
        }
        /**
 * @param {Uint8Array} sps
 * @param {Uint8Array} pps
 * @param {Number} nalLen - NAL Unit length: 1, 2 or 4 bytes
 * eg: avcc(0x4d, 0x40, 0x0d, 4, 0xe1, "674d400d96560c0efcb80a70505050a0",
 * 1, "68ef3880")
 * @returns {Uint8Array}
 */        function createAVCCBox(sps, pps, nalLen) {
            var nal = 2 === nalLen ? 1 : 4 === nalLen ? 3 : 0, h264Profile = sps[1], h264CompatibleProfile = sps[2], h264Level = sps[3];
 // Deduce AVC Profile from SPS
                        return Object(create_box.a)("avcC", Object(byte_parsing.h)([ 1, h264Profile, h264CompatibleProfile, h264Level, 252 | nal, 225 ], Object(byte_parsing.k)(sps.length), sps, [ 1 ], Object(byte_parsing.k)(pps.length), pps));
        }
        /**
 * @param {string} type - "video"/"audio"/"hint"
 * @returns {Uint8Array}
 */        function createHDLRBox(type) {
            var name, handlerName;
            switch (type) {
              case "video":
                name = "vide", handlerName = "VideoHandler";
                break;

              case "audio":
                name = "soun", handlerName = "SoundHandler";
                break;

              default:
                name = "hint", handlerName = "";
            }
            return Object(create_box.a)("hdlr", Object(byte_parsing.h)(8, Object(byte_parsing.p)(name), 12, Object(byte_parsing.p)(handlerName), 1));
        }
        /**
 * @param {number} timescale
 * @returns {Uint8Array}
 */        function createMDHDBox(timescale) {
            return Object(create_box.a)("mdhd", Object(byte_parsing.h)(12, Object(byte_parsing.l)(timescale), 8));
        }
        /**
 * @param {Number} timescale
 * @param {Number} trackId
 * @returns {Uint8Array}
 */        function createMVHDBox(timescale, trackId) {
            return Object(create_box.a)("mvhd", Object(byte_parsing.h)(12, Object(byte_parsing.l)(timescale), 4, [ 0, 1 ], 2, // we assume rate = 1;
            [ 1, 0 ], 10, // we assume volume = 100%;
            [ 0, 1 ], 14, // default matrix
            [ 0, 1 ], 14, // default matrix
            [ 64, 0, 0, 0 ], 26, Object(byte_parsing.k)(trackId + 1)));
        }
        /**
 * @param {string} systemId - Hex string representing the CDM, 16 bytes.
 * @param {Uint8Array|undefined} privateData - Data associated to protection
 * specific system.
 * @param {Array.<Uint8Array>} keyIds - List of key ids contained in the PSSH
 * @returns {Uint8Array}
 */        function createPSSHBox(systemId, privateData, keyIds) {
            void 0 === privateData && (privateData = new Uint8Array(0)), void 0 === keyIds && (keyIds = new Uint8Array(0));
            var version, kidList, _systemId = systemId.replace(/-/g, "");
            if (32 !== _systemId.length) throw new Error("HSS: wrong system id length");
            var kidCount = keyIds.length;
            return kidList = 0 < kidCount ? (version = 1, byte_parsing.h.apply(void 0, [ Object(byte_parsing.l)(kidCount) ].concat(keyIds))) : (version = 0, 
            []), Object(create_box.a)("pssh", Object(byte_parsing.h)([ version, 0, 0, 0 ], Object(byte_parsing.j)(_systemId), kidList, Object(byte_parsing.l)(privateData.length), privateData));
        }
        /**
 * @param {Uint8Array} mfhd
 * @param {Uint8Array} tfhd
 * @param {Uint8Array} tfdt
 * @param {Uint8Array} trun
 * @returns {Uint8Array}
 */        function createSAIOBox(mfhd, tfhd, tfdt, trun) {
            return Object(create_box.a)("saio", Object(byte_parsing.h)(4, [ 0, 0, 0, 1 ], // ??
            Object(byte_parsing.l)(mfhd.length + tfhd.length + tfdt.length + trun.length + 8 + 8 + 8 + 8)));
        }
        /**
 * @param {Uint8Array} sencContent - including 8 bytes flags and entries count
 * @returns {Uint8Array}
 */        function createSAIZBox(sencContent) {
            if (0 === sencContent.length) return Object(create_box.a)("saiz", new Uint8Array(0));
            var flags = Object(byte_parsing.c)(sencContent, 0), entries = Object(byte_parsing.c)(sencContent, 4), arr = new Uint8Array(entries + 9);
            arr.set(Object(byte_parsing.l)(entries), 5);
            for (var pairsCnt, pairsLen, i = 9, j = 8; j < sencContent.length; ) j += 8, // assuming IV is 8 bytes TODO handle 16 bytes IV
            // if we have extradata for each entry
            2 == (2 & flags) ? (pairsLen = 2, j += 6 * (pairsCnt = Object(byte_parsing.a)(sencContent, j)) + 2) : pairsLen = pairsCnt = 0, 
            arr[i] = 6 * pairsCnt + 8 + pairsLen, i++;
            return Object(create_box.a)("saiz", arr);
        }
        /**
 * @returns {Uint8Array}
 */        function createSMHDBox() {
            return Object(create_box.a)("smhd", new Uint8Array(8));
        }
        /**
 * @param {Array.<Uint8Array>} representations - arrays of Uint8Array,
 * typically [avc1] or [encv, avc1]
 * @returns {Uint8Array}
 */        function createSTSDBox(reps) {
            // only one description here... FIXME
            var arrBase = [ 7, [ reps.length ] ];
            return Object(create_box.a)("stsd", byte_parsing.h.apply(void 0, arrBase.concat(reps)));
        }
        /**
 * @param {Number} width
 * @param {Number} height
 * @param {Number} trackId
 * @returns {Uint8Array}
 */        function createTKHDBox(width, height, trackId) {
            return Object(create_box.a)("tkhd", Object(byte_parsing.h)(Object(byte_parsing.l)(7), 8, // we assume track is enabled,
            // in media and in preview.
            Object(byte_parsing.l)(trackId), 20, // we assume trackId = 1;
            [ 1, 0, 0, 0 ], // we assume volume = 100%;
            [ 0, 1, 0, 0 ], 12, // default matrix
            [ 0, 1, 0, 0 ], 12, // default matrix
            [ 64, 0, 0, 0 ], // ??
            Object(byte_parsing.k)(width), 2, // width (TODO handle fixed)
            Object(byte_parsing.k)(height), 2));
        }
        /**
 * @param {Number} algId - eg 1
 * @param {Number} ivSize - eg 8
 * @param {string} keyId - Hex KID 93789920e8d6520098577df8f2dd5546
 * @returns {Uint8Array}
 */        function createTENCBox(algId, ivSize, keyId) {
            return Object(create_box.a)("tenc", Object(byte_parsing.h)(6, [ algId, ivSize ], Object(byte_parsing.j)(keyId)));
        }
        // CONCATENATED MODULE: ./src/transports/smooth/isobmff/create_traf_box.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        function createTrafBox(tfhd, tfdt, trun, mfhd, senc) {
            var trafs = [ tfhd, tfdt, trun ];
            return senc && trafs.push(Object(create_box.a)("senc", senc), createSAIZBox(senc), createSAIOBox(mfhd, tfhd, tfdt, trun)), 
            Object(create_box.b)("traf", trafs);
        }
        // EXTERNAL MODULE: ./src/compat/can_patch_isobmff.ts
                var can_patch_isobmff = __webpack_require__(129);
        // CONCATENATED MODULE: ./src/transports/smooth/isobmff/replace_moof.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Replace a moof in a segment by a new one.
 * @param {Uint8Array} segment
 * @param {Uint8Array} newMoof
 * @param {Array.<number>} moofOffsets
 * @param {number} trunOffsetInMoof
 * @returns {Uint8Array}
 */        function replaceMoofInSegment(segment, newMoof, moofOffsets, trunOffsetInMoof) {
            var oldMoofLength = moofOffsets[1] - moofOffsets[0], moofDelta = newMoof.length - oldMoofLength, mdatOffsets = Object(get_box.c)(segment, 1835295092
            /* "mdat" */);
            if (null == mdatOffsets) throw new Error("Smooth: Invalid ISOBMFF given");
            if (Object(can_patch_isobmff.a)() && (0 === moofDelta || moofDelta <= -8)) 
            // patch trun data_offset
            return newMoof.set(Object(byte_parsing.l)(mdatOffsets[0] + 8), trunOffsetInMoof + 16), 
            segment.set(newMoof, moofOffsets[0]), moofDelta <= -8 && segment.set(createFreeBox(-moofDelta), newMoof.length), 
            segment;
 // patch trun data_offset
                        newMoof.set(Object(byte_parsing.l)(mdatOffsets[0] + moofDelta + 8), trunOffsetInMoof + 16);
            var newSegment = new Uint8Array(segment.length + moofDelta), beforeMoof = segment.subarray(0, moofOffsets[0]), afterMoof = segment.subarray(moofOffsets[1], segment.length);
            return newSegment.set(beforeMoof, 0), newSegment.set(newMoof, beforeMoof.length), 
            newSegment.set(afterMoof, beforeMoof.length + newMoof.length), newSegment;
        }
        // CONCATENATED MODULE: ./src/transports/smooth/isobmff/patch_segment.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Patch ISOBMFF Segment downloaded in Smooth Streaming.
 * @param {Uint8Array} segment
 * @param {Number} decodeTime
 * @return {Uint8Array}
 */        function patchSegment(segment, decodeTime) {
            var moofOffsets = Object(get_box.c)(segment, 1836019558
            /* moof */);
            if (null == moofOffsets) throw new Error("Smooth: Invalid ISOBMFF given");
            var moofContent = segment.subarray(moofOffsets[0] + 8, moofOffsets[1]), mfhdBox = Object(get_box.a)(moofContent, 1835427940
            /* mfhd */), trafContent = Object(get_box.b)(moofContent, 1953653094
            /* traf */);
            if (null == trafContent || null == mfhdBox) throw new Error("Smooth: Invalid ISOBMFF given");
            var tfhdBox = Object(get_box.a)(trafContent, 1952868452
            /* tfhd */), trunBox = Object(get_box.a)(trafContent, 1953658222
            /* trun */);
            if (null == tfhdBox || null == trunBox) throw new Error("Smooth: Invalid ISOBMFF given");
 // force trackId=1 since trackIds are not always reliable...
                        tfhdBox.set([ 0, 0, 0, 1 ], 12);
            var tfdtBox = createTfdtBox(decodeTime), newTrafBox = createTrafBox(tfhdBox, tfdtBox, addDataOffsetFlagInTrun(trunBox), mfhdBox, Object(get_box.d)(trafContent, 2721664850, 1520127764, 2722393154, 2086964724));
            return replaceMoofInSegment(segment, Object(create_box.b)("moof", [ mfhdBox, newTrafBox ]), moofOffsets, mfhdBox.length + tfhdBox.length + tfdtBox.length + 8
            /* moof size + name */ + 8
            /* traf size + name */);
        }
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Observable.js + 3 modules
                var Observable = __webpack_require__(6), byte_range = __webpack_require__(57);
        // EXTERNAL MODULE: ./src/transports/utils/byte_range.ts
                // CONCATENATED MODULE: ./src/transports/smooth/isobmff/create_init_segment.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {Uint8Array} mvhd
 * @param {Uint8Array} mvex
 * @param {Uint8Array} trak
 * @param {Object} pssList
 * @returns {Array.<Uint8Array>}
 */
        function createMOOVBox(mvhd, mvex, trak, pssList) {
            var children = [ mvhd, mvex, trak ];
            return pssList.forEach(function(pss) {
                var pssh = createPSSHBox(pss.systemId, pss.privateData, pss.keyIds);
                children.push(pssh);
            }), Object(create_box.b)("moov", children);
        }
        /**
 * Create an initialization segment with the informations given.
 * @param {Number} timescale
 * @param {string} type
 * @param {Uint8Array} stsd
 * @param {Uint8Array} mhd
 * @param {Number} width
 * @param {Number} height
 * @param {Array.<Object>} pssList - List of dict, example:
 * {systemId: "DEADBEEF", codecPrivateData: "DEAFBEEF}
 * @returns {Uint8Array}
 */        function createInitSegment(timescale, type, stsd, mhd, width, height, pssList) {
            var stbl = Object(create_box.b)("stbl", [ stsd, Object(create_box.a)("stts", new Uint8Array(8)), Object(create_box.a)("stsc", new Uint8Array(8)), Object(create_box.a)("stsz", new Uint8Array(12)), Object(create_box.a)("stco", new Uint8Array(8)) ]), dref = createDREFBox(Object(create_box.a)("url ", new Uint8Array([ 0, 0, 0, 1 ]))), dinf = Object(create_box.b)("dinf", [ dref ]), minf = Object(create_box.b)("minf", [ mhd, dinf, stbl ]), hdlr = createHDLRBox(type), mdhd = createMDHDBox(timescale), mdia = Object(create_box.b)("mdia", [ mdhd, hdlr, minf ]), tkhd = createTKHDBox(width, height, 1), trak = Object(create_box.b)("trak", [ tkhd, mdia ]), trex = createTREXBox(1), mvex = Object(create_box.b)("mvex", [ trex ]), moov = createMOOVBox(createMVHDBox(timescale, 1), mvex, trak, pssList), ftyp = createFTYPBox("isom", [ "isom", "iso2", "iso6", "avc1", "dash" ]);
            return Object(byte_parsing.h)(ftyp, moov);
        }
        // CONCATENATED MODULE: ./src/transports/smooth/isobmff/create_video_init_segment.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Return full video Init segment as Uint8Array
 * @param {Number} timescale - lowest number, this one will be set into mdhd
 * *10000 in mvhd, e.g. 1000
 * @param {Number} width
 * @param {Number} height
 * @param {Number} hRes
 * @param {Number} vRes
 * @param {Number} nalLength (1, 2 or 4)
 * @param {string} codecPrivateData
 * @param {string} keyId - hex string representing the key Id,
 * 32 chars. eg. a800dbed49c12c4cb8e0b25643844b9b
 * @param {Array.<Object>} [pssList] - List of dict, example:
 * {systemId: "DEADBEEF", codecPrivateData: "DEAFBEEF}
 * @returns {Uint8Array}
 */        function createVideoInitSegment(timescale, width, height, hRes, vRes, nalLength, codecPrivateData, keyId, pssList) {
            var stsd, _pssList = pssList || [], _codecPrivateData$spl = codecPrivateData.split("00000001"), spsHex = _codecPrivateData$spl[1], ppsHex = _codecPrivateData$spl[2], avcc = createAVCCBox(Object(byte_parsing.j)(spsHex), Object(byte_parsing.j)(ppsHex), nalLength);
            if (_pssList.length && null != keyId) {
                var tenc = createTENCBox(1, 8, keyId), schi = Object(create_box.b)("schi", [ tenc ]), schm = createSCHMBox("cenc", 65536), frma = createFRMABox("avc1");
                stsd = createSTSDBox([ createENCVBox(width, height, hRes, vRes, "AVC Coding", 24, avcc, Object(create_box.b)("sinf", [ frma, schm, schi ])) ]);
            } else {
                stsd = createSTSDBox([ createAVC1Box(width, height, hRes, vRes, "AVC Coding", 24, avcc) ]);
            }
            return createInitSegment(timescale, "video", stsd, createVMHDBox(), width, height, _pssList);
        }
        // CONCATENATED MODULE: ./src/transports/smooth/isobmff/get_aaces_header.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Sampling frequencies defined in MPEG-4 Audio.
 * @type {Array.<Number>}
 */        var SAMPLING_FREQUENCIES = [ 96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350 ];
        /**
 * Return AAC ES Header (hexstr form)
 *
 * @param {Number} type
 *          1 = AAC Main
 *          2 = AAC LC
 *          cf http://wiki.multimedia.cx/index.php?title=MPEG-4_Audio
 * @param {Number} frequency
 * @param {Number} chans (1 or 2)
 * @returns {string}
 */        function getAacesHeader(type, frequency, chans) {
            var val;
 // TODO : handle Idx = 15...
                        return val = ((val = ((val = (63 & type) << 4) | 31 & SAMPLING_FREQUENCIES.indexOf(frequency)) << 4) | 31 & chans) << 3, 
            Object(byte_parsing.e)(Object(byte_parsing.k)(val));
        }
        // CONCATENATED MODULE: ./src/transports/smooth/isobmff/create_audio_init_segment.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Return full audio initialization segment as Uint8Array.
 * @param {Number} timescale
 * @param {Number} channelsCount
 * @param {Number} sampleSize
 * @param {Number} packetSize
 * @param {Number} sampleRate
 * @param {string} codecPrivateData
 * @param {string} keyId - hex string representing the key Id, 32 chars.
 * eg. a800dbed49c12c4cb8e0b25643844b9b
 * @param {Array.<Object>} [pssList]
 * @returns {Uint8Array}
 */        function createAudioInitSegment(timescale, channelsCount, sampleSize, packetSize, sampleRate, codecPrivateData, keyId, pssList) {
            void 0 === pssList && (pssList = []);
            var esds = createESDSBox(1, codecPrivateData || getAacesHeader(2, sampleRate, channelsCount));
            return createInitSegment(timescale, "audio", function() {
                if (!pssList.length || null == keyId) return createSTSDBox([ createMP4ABox(1, channelsCount, sampleSize, packetSize, sampleRate, esds) ]);
                var tenc = createTENCBox(1, 8, keyId), schi = Object(create_box.b)("schi", [ tenc ]), schm = createSCHMBox("cenc", 65536), frma = createFRMABox("mp4a"), sinf = Object(create_box.b)("sinf", [ frma, schm, schi ]);
                return createSTSDBox([ createENCABox(1, channelsCount, sampleSize, packetSize, sampleRate, esds, sinf) ]);
            }(), createSMHDBox(), 0, 0, pssList);
        }
        // CONCATENATED MODULE: ./src/transports/smooth/segment_loader.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Segment loader triggered if there was no custom-defined one in the API.
 * @param {Object} opt
 * @returns {Observable}
 */        function regularSegmentLoader(_ref) {
            var headers, url = _ref.url, range = _ref.segment.range;
            return range && (headers = {
                Range: Object(byte_range.a)(range)
            }), Object(request.a)({
                url: url,
                responseType: "arraybuffer",
                headers: headers
            });
        }
        /**
 * Defines the url for the request, load the right loader (custom/default
 * one).
 */        var segment_loader = function generateSegmentLoader(customSegmentLoader) {
            return function(_ref2) {
                var segment = _ref2.segment, representation = _ref2.representation, adaptation = _ref2.adaptation, period = _ref2.period, manifest = _ref2.manifest;
                if (segment.isInit) {
                    if (!segment.privateInfos || null == segment.privateInfos.smoothInit) throw new Error("Smooth: Invalid segment format");
                    var responseData, smoothInitPrivateInfos = segment.privateInfos.smoothInit, protection = smoothInitPrivateInfos.protection;
                    switch (adaptation.type) {
                      case "video":
                        responseData = createVideoInitSegment(segment.timescale, representation.width || 0, representation.height || 0, 72, 72, 4, // vRes, hRes, nal
                        smoothInitPrivateInfos.codecPrivateData || "", protection && protection.keyId, // keyId
                        protection && protection.keySystems);
                        break;

                      case "audio":
                        responseData = createAudioInitSegment(segment.timescale, smoothInitPrivateInfos.channels || 0, smoothInitPrivateInfos.bitsPerSample || 0, smoothInitPrivateInfos.packetSize || 0, smoothInitPrivateInfos.samplingRate || 0, smoothInitPrivateInfos.codecPrivateData || "", protection && protection.keyId, // keyId
                        protection && protection.keySystems);
                        break;

                      default:
                        responseData = new Uint8Array(0);
                    }
                    return Object(of.a)({
                        type: "data",
                        value: {
                            responseData: responseData
                        }
                    });
                }
                if (null == segment.mediaURL) return Object(of.a)({
                    type: "data",
                    value: {
                        responseData: null
                    }
                });
                var args = {
                    adaptation: adaptation,
                    manifest: manifest,
                    period: period,
                    representation: representation,
                    segment: segment,
                    transport: "smooth",
                    url: segment.mediaURL
                };
                return customSegmentLoader ? new Observable.a(function(obs) {
                    var hasFinished = !1, hasFallbacked = !1, abort = customSegmentLoader(args, {
                        reject: function reject(err) {
                            void 0 === err && (err = {}), hasFallbacked || (hasFinished = !0, obs.error(err));
                        },
                        resolve: function resolve(_args) {
                            hasFallbacked || (hasFinished = !0, obs.next({
                                type: "response",
                                value: {
                                    responseData: _args.data,
                                    size: _args.size,
                                    duration: _args.duration
                                }
                            }), obs.complete());
                        },
                        fallback: function fallback() {
                            hasFallbacked = !0, regularSegmentLoader(args).subscribe(obs);
                        }
                    });
                    return function() {
                        hasFinished || hasFallbacked || "function" != typeof abort || abort();
                    };
                }) : regularSegmentLoader(args);
            };
        }, ISM_REG = /(\.isml?)(\?token=\S+)?$/, TOKEN_REG = /\?token=(\S+)/;
        /* harmony default export */        
        /**
 * TODO Remove this logic completely from the player
 * @param {Document} doc
 * @returns {string|null}
 */
        function extractISML(doc) {
            return doc.getElementsByTagName("media")[0].getAttribute("src");
        }
        /**
 * Returns string corresponding to the token contained in the url's querystring.
 * Empty string if no token is found.
 * @param {string} url
 * @returns {string}
 */        function extractToken(url) {
            var tokenMatch = url.match(TOKEN_REG);
            return tokenMatch && tokenMatch[1] || "";
        }
        /**
 * Replace/Remove token from the url's querystring
 * @param {string} url
 * @param {string} [token]
 * @returns {string}
 */        function replaceToken(url, token) {
            return token ? url.replace(TOKEN_REG, "?token=" + token) : url.replace(TOKEN_REG, "");
        }
        /**
 * @param {string} url
 * @returns {string}
 */        function resolveManifest(url) {
            return ISM_REG.test(url) ? (Object(warn_once.a)("Giving a isml URL to loadVideo is deprecated. Please give the Manifest URL directly"), 
            url.replace(ISM_REG, "$1/manifest$2")) : url;
        }
        // CONCATENATED MODULE: ./src/transports/smooth/pipelines.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        var WSX_REG = /\.wsx?(\?token=\S+)?/;
        /**
 * @param {Object} adaptation
 * @param {Object} dlSegment
 * @param {Object} nextSegments
 */        function addNextSegments(adaptation, nextSegments, dlSegment) {
            log.a.debug("Smooth Parser: update segments informations.");
            for (var representations = adaptation.representations, i = 0; i < representations.length; i++) {
                representations[i].index._addSegments(nextSegments, dlSegment);
            }
        }
        /* harmony default export */        
        /**
 * Returns true if the given texttrack segment represents a textrack embedded
 * in a mp4 file.
 * @param {Representation} representation
 * @returns {Boolean}
 */
        function isMP4EmbeddedTrack(representation) {
            return !!representation.mimeType && 0 <= representation.mimeType.indexOf("mp4");
        }
        // CONCATENATED MODULE: ./src/transports/smooth/index.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */
        /* harmony default export */        __webpack_exports__.default = function(options) {
            void 0 === options && (options = {});
            var smoothManifestParser = smooth(options), segmentLoader = segment_loader(options.segmentLoader), manifestLoaderOptions = {
                customManifestLoader: options.manifestLoader,
                ignoreProgressEvents: !0
            }, manifestLoader = Object(manifest_loader.a)(manifestLoaderOptions), segmentPipeline = {
                loader: function loader(_ref5) {
                    var adaptation = _ref5.adaptation, manifest = _ref5.manifest, period = _ref5.period, representation = _ref5.representation, segment = _ref5.segment;
                    return segmentLoader({
                        adaptation: adaptation,
                        manifest: manifest,
                        period: period,
                        representation: representation,
                        segment: segment
                    });
                },
                parser: function parser(_ref6) {
                    var segment = _ref6.segment, response = _ref6.response, adaptation = _ref6.adaptation, manifest = _ref6.manifest, responseData = response.responseData;
                    if (null == responseData) return Object(of.a)({
                        segmentData: null,
                        segmentInfos: null,
                        segmentOffset: 0
                    });
                    if (segment.isInit) {
                        // smooth init segments are crafted by hand. Their timescale is the one
                        // from the manifest.
                        var initSegmentInfos = {
                            timescale: segment.timescale,
                            time: -1,
                            duration: 0
                        };
                        return Object(of.a)({
                            segmentData: responseData,
                            segmentInfos: initSegmentInfos,
                            segmentOffset: 0
                        });
                    }
                    var responseBuffer = responseData instanceof Uint8Array ? responseData : new Uint8Array(responseData), _extractTimingsInfos = extractTimingsInfos(responseBuffer, segment, manifest.isLive), nextSegments = _extractTimingsInfos.nextSegments, segmentInfos = _extractTimingsInfos.segmentInfos, segmentData = patchSegment(responseBuffer, segmentInfos.time);
                    return nextSegments && addNextSegments(adaptation, nextSegments, segmentInfos), 
                    Object(of.a)({
                        segmentData: segmentData,
                        segmentInfos: segmentInfos,
                        segmentOffset: 0
                    });
                }
            };
            return {
                manifest: {
                    resolver: function resolver(_ref) {
                        var url = _ref.url, token = extractToken(url);
                        // TODO Remove WSX logic
                        return (WSX_REG.test(url) ? (Object(warn_once.a)("Giving WSX URL to loadVideo is deprecated. You should only give Manifest URLs."), 
                        Object(request.a)({
                            url: replaceToken(url, ""),
                            responseType: "document",
                            ignoreProgressEvents: !0
                        }).pipe(Object(map.a)(function(_ref2) {
                            var extractedURL = extractISML(_ref2.value.responseData);
                            if (!extractedURL) throw new Error("Invalid ISML");
                            return extractedURL;
                        }))) : Object(of.a)(url)).pipe(Object(map.a)(function(_url) {
                            return {
                                url: replaceToken(resolveManifest(_url), token)
                            };
                        }));
                    },
                    loader: function loader(_ref3) {
                        var url = _ref3.url;
                        return manifestLoader(url);
                    },
                    parser: function parser(_ref4) {
                        var response = _ref4.response, reqURL = _ref4.url, url = null == response.url ? reqURL : response.url, data = "string" == typeof response.responseData ? new DOMParser().parseFromString(response.responseData, "text/xml") : response.responseData, manifestReceivedTime = response.receivedTime, parserResult = smoothManifestParser(data, url, manifestReceivedTime), manifest = new src_manifest.a(parserResult, {
                            representationFilter: options.representationFilter,
                            supplementaryImageTracks: options.supplementaryImageTracks,
                            supplementaryTextTracks: options.supplementaryTextTracks
                        });
                        return Object(of.a)({
                            manifest: manifest,
                            url: url
                        });
                    }
                },
                audio: segmentPipeline,
                video: segmentPipeline,
                text: {
                    loader: function loader(_ref7) {
                        var segment = _ref7.segment, representation = _ref7.representation;
                        if (segment.isInit || null == segment.mediaURL) return Object(of.a)({
                            type: "data",
                            value: {
                                responseData: null
                            }
                        });
                        var responseType = isMP4EmbeddedTrack(representation) ? "arraybuffer" : "text";
                        return Object(request.a)({
                            url: segment.mediaURL,
                            responseType: responseType
                        });
                    },
                    parser: function parser(_ref8) {
                        var parsedResponse, nextSegments, response = _ref8.response, segment = _ref8.segment, representation = _ref8.representation, adaptation = _ref8.adaptation, manifest = _ref8.manifest, language = adaptation.language, _representation$mimeT = representation.mimeType, mimeType = void 0 === _representation$mimeT ? "" : _representation$mimeT, _representation$codec = representation.codec, codec = void 0 === _representation$codec ? "" : _representation$codec, responseData = response.responseData;
                        if (null === responseData) return Object(of.a)({
                            segmentData: null,
                            segmentInfos: 0 < segment.timescale ? {
                                duration: segment.isInit ? 0 : segment.duration,
                                time: segment.isInit ? -1 : segment.time,
                                timescale: segment.timescale
                            } : null,
                            segmentOffset: 0
                        });
                        var _sdStart, _sdEnd, _sdTimescale, _sdData, _sdType, segmentInfos = null, isMP4 = 0 <= mimeType.indexOf("mp4");
                        if (isMP4) {
                            var timings = extractTimingsInfos(parsedResponse = new Uint8Array(responseData), segment, manifest.isLive);
                            nextSegments = timings.nextSegments, _sdStart = (segmentInfos = timings.segmentInfos).time, 
                            _sdEnd = null != segmentInfos.duration ? segmentInfos.time + segmentInfos.duration : void 0, 
                            _sdTimescale = segmentInfos.timescale;
                        } else {
                            parsedResponse = responseData;
                            var segmentTime = segment.time || 0;
 // vod is simple WebVTT or TTML text
                                                        _sdStart = segmentTime, _sdEnd = null != segment.duration ? segmentTime + segment.duration : void 0, 
                            _sdTimescale = segment.timescale;
                        }
                        if (isMP4) {
                            var lcCodec = codec.toLowerCase();
                            if ("application/ttml+xml+mp4" === mimeType || "stpp" === lcCodec || "stpp.ttml.im1t" === lcCodec) _sdType = "ttml"; else {
                                if ("wvtt" !== lcCodec) throw new Error("could not find a text-track parser for the type " + mimeType);
                                _sdType = "vtt";
                            }
                            var mdat = Object(read.a)(parsedResponse);
                            _sdData = Object(string_from_utf8.a)(mdat);
                        } else {
                            switch (mimeType) {
                              case "application/x-sami":
                              case "application/smil":
                                // TODO SMIL should be its own format, no?
                                _sdType = "sami";
                                break;

                              case "application/ttml+xml":
                                _sdType = "ttml";
                                break;

                              case "text/vtt":
                                _sdType = "vtt";
                            }
                            if (!_sdType) {
                                if ("srt" !== codec.toLowerCase()) throw new Error("could not find a text-track parser for the type " + mimeType);
                                _sdType = "srt";
                            }
                            _sdData = responseData;
                        }
                        return null != segmentInfos && nextSegments && addNextSegments(adaptation, nextSegments, segmentInfos), 
                        Object(of.a)({
                            segmentData: {
                                type: _sdType,
                                data: _sdData,
                                language: language,
                                timescale: _sdTimescale,
                                start: _sdStart,
                                end: _sdEnd
                            },
                            segmentInfos: segmentInfos,
                            segmentOffset: _sdStart / _sdTimescale
                        });
                    }
                },
                image: {
                    loader: function loader(_ref9) {
                        var segment = _ref9.segment;
                        return segment.isInit || null == segment.mediaURL ? Object(of.a)({
                            type: "data",
                            value: {
                                responseData: null
                            }
                        }) : Object(request.a)({
                            url: segment.mediaURL,
                            responseType: "arraybuffer"
                        });
                    },
                    parser: function parser(_ref10) {
                        var response = _ref10.response, segment = _ref10.segment, responseData = response.responseData;
                        // TODO image Parsing should be more on the sourceBuffer side, no?
                        if (null === responseData || null == features.a.imageParser) return Object(of.a)({
                            segmentData: null,
                            segmentInfos: 0 < segment.timescale ? {
                                duration: segment.isInit ? 0 : segment.duration,
                                time: segment.isInit ? -1 : segment.time,
                                timescale: segment.timescale
                            } : null,
                            segmentOffset: 0
                        });
                        var bifObject = features.a.imageParser(new Uint8Array(responseData)), data = bifObject.thumbs;
                        return Object(of.a)({
                            segmentData: {
                                data: data,
                                start: 0,
                                end: Number.MAX_VALUE,
                                timescale: 1,
                                type: "bif"
                            },
                            segmentInfos: {
                                time: 0,
                                duration: Number.MAX_VALUE,
                                timescale: bifObject.timescale
                            },
                            segmentOffset: 0
                        });
                    }
                }
            };
        };
        /***/    }, 
    /* 159 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        // EXTERNAL MODULE: ./src/parsers/texttracks/webvtt/get_cue_blocks.ts
        var get_cue_blocks = __webpack_require__(94), utils = __webpack_require__(52);
        // EXTERNAL MODULE: ./src/parsers/texttracks/webvtt/utils.ts
                // CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/get_style_blocks.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Get cue blocks from a WebVTT file.
 * @param {Array.<string>} linified - Whole WebVTT file. Each new element in
 * this array is a new line.
 * @param {number} headerOffset - index of the first line after the header.
 * Used to avoid taking the header into consideration.
 * @returns {Array.<Array.<string>>}
 */
        function getStyleBlocks(linified, headerOffset) {
            for (var styleBlocks = [], i = headerOffset; i < linified.length; i++) 
            //
            if (Object(utils.d)(linified, i)) {
                var startOfStyleBlock = i;
                // continue incrementing i until either:
                //   - empty line
                //   - end of file
                for (i++; linified[i]; ) i++;
                var styleBlock = linified.slice(startOfStyleBlock, i);
                styleBlocks.push(styleBlock);
            } else if (linified[i]) 
            // continue incrementing i until either:
            //   - empty line
            //   - end
            for (;linified[i]; ) i++;
            return styleBlocks;
        }
        // EXTERNAL MODULE: ./src/parsers/texttracks/webvtt/parse_cue_block.ts + 1 modules
                var parse_cue_block = __webpack_require__(109), colorMap = {
            white: "#ffffff",
            lime: "#00ff00",
            cyan: "#00ffff",
            red: "#ff0000",
            yellow: "#ffff00",
            magenta: "#ff00ff",
            blue: "#0000ff",
            black: "#000000"
        };
        // CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/html/create_default_style_elements.ts
        /**
 * Creates default classes defined in the W3 specification
 *
 * https://www.w3.org/TR/webvtt1/#default-classes
 */        function createDefaultStyleElements() {
            return Object.keys(colorMap).reduce(function(result, key) {
                return result[key] = "color: " + colorMap[key] + ";", result["bg_" + key] = "background-color: " + colorMap[key] + ";", 
                result;
            }, {});
        }
        // CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/html/parse_style_block.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 *
 * Parse style element from WebVTT.
 * @param {Array.<string>} styleBlock
 * @param {Object} baseStyleElements
 * @return {Array.<Object>} classes
 */        function parseStyleBlocks(styleBlocks) {
            var classes = createDefaultStyleElements(), global = "";
            return styleBlocks.forEach(function(styleBlock) {
                if (2 <= styleBlock.length) for (var index = 1; index < styleBlock.length; index++) {
                    var line = styleBlock[index];
                    if (line.match(/::cue {/)) for (line = styleBlock[++index]; line && !line.match(/}/) && 0 !== line.length; ) global += line, 
                    line = styleBlock[++index]; else !function() {
                        for (var classNames = [], cueClassLine = void 0; line && (cueClassLine = line.match(/::cue\(\.?(.*?)\)(?:,| {)/)); ) classNames.push(cueClassLine[1]), 
                        line = styleBlock[++index];
                        for (var styleContent = ""; line && !line.match(/}/) && 0 !== line.length; ) styleContent += line, 
                        line = styleBlock[++index];
                        classNames.forEach(function(className) {
                            classes[className] ? classes[className] += styleContent : classes[className] = styleContent;
                        });
                    }();
                }
            }), {
                classes: classes,
                global: global
            };
        }
        // EXTERNAL MODULE: ./src/utils/array_includes.ts
                var array_includes = __webpack_require__(12);
        // CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/html/create_styled_element.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Construct an HTMLElement/TextNode representing the given node and apply
 * the right styling on it.
 * @param {Node} baseNode
 * @param {Array.<Object>} styleElements
 * @param {Array.<string>} styleClasses
 * @returns {Node}
 */        function createStyledElement(baseNode, styleElements) {
            var nodeWithStyle, HTMLTags = [ "u", "i", "b" ], mainNodeName = baseNode.nodeName.toLowerCase().split(".")[0];
            if (Object(array_includes.a)([ "u", "i", "b", "c", "#text" ], mainNodeName)) if ("#text" === mainNodeName) {
                var linifiedText = baseNode.wholeText.split("\n");
                nodeWithStyle = document.createElement("span");
                for (var i = 0; i < linifiedText.length; i++) if (i && nodeWithStyle.appendChild(document.createElement("br")), 
                0 < linifiedText[i].length) {
                    var textNode = document.createTextNode(linifiedText[i]);
                    nodeWithStyle.appendChild(textNode);
                }
            } else {
                var nodeClasses = baseNode.nodeName.toLowerCase().split("."), styleContents = [];
                if (nodeClasses.forEach(function(nodeClass) {
                    styleElements[nodeClass] && styleContents.push(styleElements[nodeClass]);
                }), 0 !== styleContents.length) {
                    // If style must be applied
                    var attr = document.createAttribute("style");
                    styleContents.forEach(function(styleContent) {
                        attr.value += styleContent;
                    });
                    var nameClass = Object(array_includes.a)(HTMLTags, mainNodeName) ? mainNodeName : "span";
                    (nodeWithStyle = document.createElement(nameClass)).setAttributeNode(attr);
                } else {
                    // If style mustn't be applied. Rebuild element with tag name
                    var elementTag = Object(array_includes.a)(HTMLTags, mainNodeName) ? mainNodeName : "span";
                    nodeWithStyle = document.createElement(elementTag);
                }
                for (var j = 0; j < baseNode.childNodes.length; j++) {
                    var child = createStyledElement(baseNode.childNodes[j], styleElements);
                    nodeWithStyle.appendChild(child);
                }
            } else {
                nodeWithStyle = document.createElement("span");
                for (var _j = 0; _j < baseNode.childNodes.length; _j++) {
                    var _child = createStyledElement(baseNode.childNodes[_j], styleElements);
                    nodeWithStyle.appendChild(_child);
                }
            }
            return nodeWithStyle;
        }
        // CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/html/convert_payload_to_html.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {string} text
 * @param {Array.<Object>} styleElements
 * @returns {Array.<HTMLElement>}
 */        function convertPayloadToHTML(text, styleElements) {
            for (var filteredText = text.replace(/<[0-9]{2}:[0-9]{2}.[0-9]{3}>/, "").replace(/<([u,i,b,c])(\..*?)?(?: .*?)?>(.*?)<\/\1>/g, "<$1$2>$3</$1$2>"), nodes = new DOMParser().parseFromString(filteredText, "text/html").body.childNodes, styledElements = [], i = 0; i < nodes.length; i++) styledElements.push(createStyledElement(nodes[i], styleElements));
            return styledElements;
        }
        // CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/html/to_html.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Parse cue block into an object with the following properties:
 *   - start {number}: start time at which the cue should be displayed
 *   - end {number}: end time at which the cue should be displayed
 *   - element {HTMLElement}: the cue text, translated into an HTMLElement
 *
 * Returns undefined if the cue block could not be parsed.
 * @param {Array.<string>} cueBlock
 * @param {Number} timeOffset
 * @param {Array.<Object>} classes
 * @returns {Object|undefined}
 */        function toHTML(cueObj, styling) {
            var start = cueObj.start, end = cueObj.end, header = cueObj.header, payload = cueObj.payload, region = document.createElement("div"), regionAttr = document.createAttribute("style");
            regionAttr.value = "width:100%;height:100%;display:flex;flex-direction:column;justify-content:flex-end;align-items:center;", 
            region.setAttributeNode(regionAttr);
            // Get content, format and apply style.
            var pElement = document.createElement("p"), pAttr = document.createAttribute("style");
            pAttr.value = "text-align:center", pElement.setAttributeNode(pAttr);
            var spanElement = document.createElement("span"), attr = document.createAttribute("style");
            // set color and background-color default values, as indicated in:
            // https://www.w3.org/TR/webvtt1/#applying-css-properties
            attr.value = "background-color:rgba(0,0,0,0.8);color:white;", spanElement.setAttributeNode(attr);
            var global = styling.global, classes = styling.classes, styles = [ global, header ? classes[header] : void 0 ].filter(function(s) {
                return !!s;
            }).join("");
            return attr.value += styles, spanElement.setAttributeNode(attr), convertPayloadToHTML(payload.join("\n"), classes).forEach(function(element) {
                spanElement.appendChild(element);
            }), region.appendChild(pElement), pElement.appendChild(spanElement), {
                start: start,
                end: end,
                element: region
            };
        }
        // CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/html/parse_webvtt_to_div.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Parse WebVTT from text. Returns an array with:
 * - start : start of current cue, in seconds
 * - end : end of current cue, in seconds
 * - content : HTML formatted cue.
 *
 * Global style is parsed and applied to div element.
 * Specific style is parsed and applied to class element.
 *
 * @throws Error - Throws if the given WebVTT string is invalid.
 * @param {string} text - The whole webvtt subtitles to parse
 * @param {Number} timeOffset - Offset to add to start and end times, in seconds
 * @return {Array.<Object>}
 */        
        // CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/html/index.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */
        /* harmony default export */ __webpack_exports__.default = function parseWebVTT(text, timeOffset) {
            var linified = text.split(/\r\n|\n|\r/g), cuesArray = [];
 // CRLF|LF|CR
                        if (!linified[0].match(/^WEBVTT( |\t|\n|\r|$)/)) throw new Error("Can't parse WebVTT: Invalid File.");
            for (var firstLineAfterHeader = Object(utils.b)(linified), styleBlocks = getStyleBlocks(linified, firstLineAfterHeader), cueBlocks = Object(get_cue_blocks.a)(linified, firstLineAfterHeader), styles = parseStyleBlocks(styleBlocks), i = 0; i < cueBlocks.length; i++) {
                var cueObject = Object(parse_cue_block.a)(cueBlocks[i], timeOffset);
                if (null != cueObject) {
                    var htmlCue = toHTML(cueObject, styles);
                    cuesArray.push(htmlCue);
                }
            }
            return cuesArray;
        };
        /***/    }, 
    /* 160 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        // EXTERNAL MODULE: ./node_modules/object-assign/index.js
        var object_assign = __webpack_require__(9), object_assign_default = /* */ __webpack_require__.n(object_assign), array_find = __webpack_require__(11), get_parameters = __webpack_require__(96), get_parent_elements_by_tag_name = __webpack_require__(65), get_styling = __webpack_require__(29), nodes = __webpack_require__(50), get_time_delimiters = __webpack_require__(110), regexps = __webpack_require__(18);
        // CONCATENATED MODULE: ./src/parsers/texttracks/ttml/html/generate_css_test_outline.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Try to replicate the textOutline TTML style property into CSS.
 *
 * We mock it throught the text-shadow property, translating the TTML thickness
 * into blur radius and the blur-radius into... nothing.
 *
 * @param {string} color
 * @param {string|number} thickness
 * @returns {string}
 */
        function generateCSSTextOutline(color, thickness) {
            return "-1px -1px " + thickness + " " + color + ",1px -1px " + thickness + " " + color + ",-1px 1px " + thickness + " " + color + ",1px 1px " + thickness + " " + color;
        }
        // CONCATENATED MODULE: ./src/parsers/texttracks/ttml/html/ttml_color_to_css_color.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Translate a color indicated in TTML-style to a CSS-style color.
 * @param {string} color
 * @returns {string} color
 */        function ttmlColorToCSSColor(color) {
            // TODO check all possible color fomats
            var regRes;
            return null != (regRes = regexps.b.exec(color)) ? "rgba(" + parseInt(regRes[1], 16) + "," + parseInt(regRes[2], 16) + "," + parseInt(regRes[3], 16) + "," + parseInt(regRes[4], 16) / 255 + ")" : null != (regRes = regexps.a.exec(color)) ? "rgba(" + parseInt(regRes[1] + regRes[1], 16) + "," + parseInt(regRes[2] + regRes[2], 16) + "," + parseInt(regRes[3] + regRes[3], 16) + "," + parseInt(regRes[4] + regRes[4], 16) / 255 + ")" : color;
        }
        // CONCATENATED MODULE: ./src/parsers/texttracks/ttml/html/create_element.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        // Styling which can be applied to <span> from any level upper.
        // Added here as an optimization
                var SPAN_LEVEL_ATTRIBUTES = [ "color", "direction", "display", "fontFamily", "fontSize", "fontStyle", "fontWeight", "textDecoration", "textOutline", "unicodeBidi", "visibility", "wrapOption" ];
 // TODO
        // tts:showBackground (applies to region)
        // tts:zIndex (applies to region)
        /**
 * Apply style set for a singular text span of the current cue.
 * @param {HTMLElement} element - The text span
 * @param {Object} style - The style to apply
 */        function applyTextStyle(element, style, shouldTrimWhiteSpace) {
            // applies to span
            var color = style.color;
            color && (element.style.color = ttmlColorToCSSColor(color));
 // applies to body, div, p, region, span
                        var backgroundColor = style.backgroundColor;
            backgroundColor && (element.style.backgroundColor = ttmlColorToCSSColor(backgroundColor));
 // applies to span
                        var textOutline = style.textOutline;
            if (textOutline) {
                var outlineData = textOutline.trim().replace(/\s+/g, " ").split(" "), len = outlineData.length;
                if (3 === len) {
                    var outlineColor = ttmlColorToCSSColor(outlineData[0]), thickness = outlineData[1];
                    element.style.textShadow = generateCSSTextOutline(outlineColor, thickness);
                } else if (color && 1 === len) {
                    var _thickness = outlineData[0];
                    element.style.textShadow = generateCSSTextOutline(color, _thickness);
                } else if (2 === len) {
                    var isFirstArgAColor = /^[#A-Z]/i.test(outlineData[0]);
                    // XOR-ing to be sure we get what we have
                    if (isFirstArgAColor !== /^[0-9]/.test(outlineData[0])) if (isFirstArgAColor) {
                        var _outlineColor = ttmlColorToCSSColor(outlineData[0]), _thickness2 = outlineData[1];
                        element.style.textShadow = generateCSSTextOutline(_outlineColor, _thickness2);
                    } else if (color) {
                        var _thickness3 = outlineData[0];
                        element.style.textShadow = generateCSSTextOutline(color, _thickness3);
                    }
                }
            }
 // applies to span
                        var textDecoration = style.textDecoration;
            if (textDecoration) switch (textDecoration) {
              case "noUnderline":
              case "noLineThrough":
              case "noOverline":
                element.style.textDecoration = "none";
                break;

              case "lineThrough":
                element.style.textDecoration = "line-through";
                break;

              default:
                element.style.textDecoration = textDecoration;
            }
 // applies to span
                        var fontFamily = style.fontFamily;
            if (fontFamily) switch (fontFamily) {
              case "proportionalSansSerif":
                element.style.fontFamily = "Arial, Helvetica, Liberation Sans, sans-serif";
                break;

                // TODO monospace or sans-serif or font with both?
                              case "monospaceSansSerif":
              case "sansSerif":
                element.style.fontFamily = "sans-serif";
                break;

              case "monospaceSerif":
              case "default":
                element.style.fontFamily = "Courier New, Liberation Mono, monospace";
                break;

                // TODO font with both?
                              case "proportionalSerif":
                element.style.fontFamily = "serif";
                break;

              default:
                element.style.fontFamily = fontFamily;
            }
 // applies to span
                        var fontStyle = style.fontStyle;
            fontStyle && (element.style.fontStyle = fontStyle);
 // applies to span
                        var fontWeight = style.fontWeight;
            fontWeight && (element.style.fontWeight = fontWeight);
 // applies to span
                        var fontSize = style.fontSize;
            fontSize && (
            // TODO Check if formats are always really 1:1
            element.style.fontSize = fontSize);
 // applies to p, span
                        var direction = style.direction;
            direction && (element.style.direction = direction);
 // applies to p, span
                        var unicodeBidi = style.unicodeBidi;
            if (unicodeBidi) switch (unicodeBidi) {
              case "bidiOverride":
                element.style.unicodeBidi = "bidi-override";
                break;

              case "embed":
                element.style.unicodeBidi = "embed";
                break;

              default:
                element.style.unicodeBidi = "normal";
            }
 // applies to body, div, p, region, span
                        var visibility = style.visibility;
            visibility && (element.style.visibility = visibility), "none" === style.display && (element.style.display = "none");
 // applies to body, div, p, region, span
                        // applies to body, div, p, region, span
            var wrapOption = style.wrapOption;
            element.style.whiteSpace = "noWrap" === wrapOption ? shouldTrimWhiteSpace ? "nowrap" : "pre" : shouldTrimWhiteSpace ? "normal" : "pre-wrap";
        }
        /**
 * Apply style for the general text track div.
 * @param {HTMLElement} element - The <div> the style will be applied on.
 * @param {Object} style - The general style object of the paragraph.
 */        function applyGeneralStyle(element, style) {
            // applies to tt, region
            var extent = style.extent;
            if (extent) {
                var results = regexps.c.exec(extent);
                null != results && (element.style.width = results[1] + "%", element.style.height = results[2] + "%");
            }
 // applies to region
                        style.writingMode;
            var overflow = style.overflow;
            element.style.overflow = overflow || "hidden";
            // applies to region
            var padding = style.padding;
            padding && (element.style.padding = padding);
 // applies to region
                        var origin = style.origin;
            if (origin) {
                var resultsPercent = regexps.c.exec(origin);
                null != resultsPercent && (element.style.position = "relative", element.style.left = resultsPercent[1] + "%", 
                element.style.top = resultsPercent[2] + "%");
            }
 // applies to region
                        var displayAlign = style.displayAlign;
            if (element.style.display = "flex", element.style.flexDirection = "column", displayAlign) switch (displayAlign) {
              case "before":
                element.style.justifyContent = "flex-start";
                break;

              case "center":
                element.style.justifyContent = "center";
                break;

              case "after":
                element.style.justifyContent = "flex-end";
            }
 // applies to region
                        var opacity = style.opacity;
            opacity && (element.style.opacity = opacity);
 // applies to body, div, p, region, span
                        var visibility = style.visibility;
            visibility && (element.style.visibility = visibility), "none" === style.display && (element.style.display = "none");
 // applies to body, div, p, region, span
                }
        /**
 * Apply style set for a <p> element
 * @param {HTMLElement} element - The <p> element
 * @param {Object} style - The general style object of the paragraph.
 */        function applyPStyle(element, style) {
            // applies to body, div, p, region, span
            var paragraphBackgroundColor = style.backgroundColor;
            paragraphBackgroundColor && (element.style.backgroundColor = ttmlColorToCSSColor(paragraphBackgroundColor));
 // applies to p
                        var lineHeight = style.lineHeight;
            lineHeight && (element.style.lineHeight = lineHeight);
 // applies to p
                        var textAlign = style.textAlign;
            if (textAlign) switch (textAlign) {
              case "center":
                element.style.textAlign = "center";
                break;

              case "left":
              case "start":
                // TODO check what start means (difference with left, writing direction?)
                element.style.textAlign = "left";
                break;

              case "right":
              case "end":
                // TODO check what end means (difference with right, writing direction?)
                element.style.textAlign = "right";
            }
        }
        /**
 * Creates span of text for the given #text element, with the right style.
 *
 * TODO create text elements as string? Might help performances.
 * @param {Element} el - the #text element, which text content should be
 * displayed
 * @param {Object} style - the style object for the given text
 * @param {Boolean} shouldTrimWhiteSpace - True if the space should be
 * trimmed.
 * @returns {HTMLElement}
 */        function createTextElement(el, style, shouldTrimWhiteSpace) {
            var textElement = document.createElement("span"), textContent = el.textContent || "";
            if (shouldTrimWhiteSpace) {
                // 1. Trim leading and trailing whitespace.
                // 2. Collapse multiple spaces into one.
                var trimmed = textContent.trim();
                textContent = trimmed = trimmed.replace(/\s+/g, " ");
            }
            return textElement.innerHTML = textContent, textElement.className = "rxp-texttrack-span", 
            applyTextStyle(textElement, style, shouldTrimWhiteSpace), textElement;
        }
        /**
 * Generate every text elements to display in a given paragraph.
 * @param {Element} paragraph - The <p> tag.
 * @param {Array.<Object>} regions
 * @param {Array.<Object>} styles
 * @param {Object} paragraphStyle - The general style object of the paragraph.
 * @param {Boolean} shouldTrimWhiteSpace
 * @returns {Array.<HTMLElement>}
 */        function generateTextContent(paragraph, regions, styles, paragraphStyle, shouldTrimWhiteSpace) {
            /**
   * Recursive function, taking a node in argument and returning the
   * corresponding array of HTMLElement in order.
   * @param {Node} node - the node in question
   * @param {Object} style - the current state of the style for the node.
   * /!\ The style object can be mutated, provide a copy of it.
   * @param {Array.<Element>} spans - The spans parent of this node.
   * @param {Boolean} shouldTrimWhiteSpaceFromParent - True if the space should be
   * trimmed by default. From the parent xml:space parameter.
   * @returns {Array.<HTMLElement>}
   */
            return function loop(node, style, spans, shouldTrimWhiteSpaceFromParent) {
                for (var childNodes = node.childNodes, elements = [], i = 0; i < childNodes.length; i++) {
                    var currentNode = childNodes[i];
                    if ("#text" === currentNode.nodeName) {
                        var backgroundColor = Object(get_styling.a)([ "backgroundColor" ], spans, styles, regions).backgroundColor;
                        backgroundColor ? style.backgroundColor = backgroundColor : delete style.backgroundColor;
                        var el = createTextElement(currentNode, style, shouldTrimWhiteSpaceFromParent);
                        elements.push(el);
                    } else if ("br" === currentNode.nodeName) {
                        var br = document.createElement("BR");
                        elements.push(br);
                    } else if ("span" === currentNode.nodeName && currentNode.nodeType === Node.ELEMENT_NODE && 0 < currentNode.childNodes.length) {
                        var spaceAttribute = currentNode.getAttribute("xml:space"), shouldTrimWhiteSpaceOnSpan = spaceAttribute ? "default" === spaceAttribute : shouldTrimWhiteSpaceFromParent, newStyle = object_assign_default()({}, style, Object(get_styling.a)(SPAN_LEVEL_ATTRIBUTES, [ currentNode ], styles, regions));
                        elements.push.apply(elements, loop(currentNode, newStyle, [ currentNode ].concat(spans), shouldTrimWhiteSpaceOnSpan));
                    }
                }
                return elements;
            }(paragraph, object_assign_default()({}, paragraphStyle), [], shouldTrimWhiteSpace);
        }
        /**
 * @param {Element} paragraph
 * @param {Element} body
 * @param {Array.<Object>} regions
 * @param {Array.<Object>} styles
 * @param {Object} paragraphStyle
 * @param {Boolean} shouldTrimWhiteSpaceOnParagraph
 * @returns {HTMLElement}
 */        function createElement(paragraph, body, regions, styles, paragraphStyle, shouldTrimWhiteSpace) {
            var divs = Object(get_parent_elements_by_tag_name.a)(paragraph, "div"), parentElement = document.createElement("DIV");
            if (parentElement.className = "rxp-texttrack-region", applyGeneralStyle(parentElement, paragraphStyle), 
            body) {
                // applies to body, div, p, region, span
                var bodyBackgroundColor = Object(get_styling.a)([ "backgroundColor" ], [].concat(divs, [ body ]), styles, regions).bodyBackgroundColor;
                bodyBackgroundColor && (parentElement.style.backgroundColor = ttmlColorToCSSColor(bodyBackgroundColor));
            }
            var pElement = document.createElement("p");
            pElement.className = "rxp-texttrack-p", applyPStyle(pElement, paragraphStyle);
            for (var textContent = generateTextContent(paragraph, regions, styles, paragraphStyle, shouldTrimWhiteSpace), i = 0; i < textContent.length; i++) pElement.appendChild(textContent[i]);
 // NOTE:
            // The following code is for the inclusion of div elements. This has no
            // advantage for now, and might only with future evolutions.
            // (This is only an indication of what the base of the code could look like).
            // if (divs.length) {
            //   let container = parentElement;
            //   for (let i = divs.length - 1; i >= 0; i--) {
            //     // TODO manage style at div level?
            //     // They are: visibility, display and backgroundColor
            //     // All these do not have any difference if applied to the <p> element
            //     // instead of the div.
            //     // The advantage might only be for multiple <p> elements dispatched
            //     // in multiple div Which we do not manage anyway for now.
            //     const divEl = document.createElement("DIV");
            //     divEl.className = "rxp-texttrack-div";
            //     container.appendChild(divEl);
            //     container = divEl;
            //   }
            //   container.appendChild(pElement);
            //   parentElement.appendChild(container);
            // } else {
            //   parentElement.appendChild(pElement);
            // }
                        return parentElement.appendChild(pElement), parentElement;
        }
        // CONCATENATED MODULE: ./src/parsers/texttracks/ttml/html/parse_cue.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {Element} paragraph
 * @param {Number} offset
 * @param {Array.<Object>} styles
 * @param {Array.<Object>} regions
 * @param {Element} body
 * @param {Object} styleBase
 * @param {Object} ttParams
 * @param {Boolean} shouldTrimWhiteSpaceOnParagraph
 * @returns {Object|null}
 */        function parseCue(paragraph, offset, styles, regions, body, styleBase, ttParams, shouldTrimWhiteSpace) {
            // Disregard empty elements:
            // TTML allows for empty elements like <div></div>.
            // If paragraph has neither time attributes, nor
            // non-whitespace text, don't try to make a cue out of it.
            if (!paragraph.hasAttribute("begin") && !paragraph.hasAttribute("end") && /^\s*$/.test(paragraph.textContent || "")) return null;
            var _getTimeDelimiters = Object(get_time_delimiters.a)(paragraph, ttParams);
            return {
                start: _getTimeDelimiters.start + offset,
                end: _getTimeDelimiters.end + offset,
                element: createElement(paragraph, body, regions, styles, styleBase, shouldTrimWhiteSpace)
            };
        }
        // CONCATENATED MODULE: ./src/parsers/texttracks/ttml/html/parse_ttml_to_div.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        var STYLE_ATTRIBUTES = [ "backgroundColor", "color", "direction", "display", "displayAlign", "extent", "fontFamily", "fontSize", "fontStyle", "fontWeight", "lineHeight", "opacity", "origin", "overflow", "padding", "textAlign", "textDecoration", "textOutline", "unicodeBidi", "visibility", "wrapOption", "writingMode" ];
        /**
 * Create array of objects which should represent the given TTML text track.
 * These objects have the following structure
 *   - start {Number}: start time, in seconds, at which the cue should
 *     be displayed
 *   - end {Number}: end time, in seconds, at which the cue should
 *     be displayed
 *   - element {HTMLElement}: <div> element representing the cue, with the
 *     right style. This div should then be appended to an element having
 *     the exact size of the wanted region the text track provide cues for.
 *
 * TODO TTML parsing is still pretty heavy on the CPU.
 * Optimizations have been done, principally to avoid using too much XML APIs,
 * but we can still do better.
 * @param {string} str
 * @param {Number} timeOffset
 * @returns {Array.<Object>}
 */        
        // CONCATENATED MODULE: ./src/parsers/texttracks/ttml/html/index.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */
        /* harmony default export */ __webpack_exports__.default = function parseTTMLStringToDIV(str, timeOffset) {
            var ret = [], xml = new DOMParser().parseFromString(str, "text/xml");
            if (xml) {
                var tt = xml.getElementsByTagName("tt")[0];
                if (!tt) throw new Error("invalid XML");
                for (var body = Object(nodes.a)(tt), styleNodes = Object(nodes.c)(tt), regionNodes = Object(nodes.b)(tt), paragraphNodes = Object(nodes.d)(tt), params = Object(get_parameters.a)(tt), styles = [], i = 0; i <= styleNodes.length - 1; i++) {
                    var styleNode = styleNodes[i];
                    if (styleNode instanceof Element) {
                        var styleID = styleNode.getAttribute("xml:id");
                        null !== styleID && 
                        // TODO styles referencing other styles
                        styles.push({
                            id: styleID,
                            style: Object(get_styling.b)(styleNode)
                        });
                    }
                }
 // construct regions array based on the xml as an optimization
                                for (var regions = [], _i = 0; _i <= regionNodes.length - 1; _i++) {
                    var regionNode = regionNodes[_i];
                    if (regionNode instanceof Element) {
                        var regionID = regionNode.getAttribute("xml:id");
                        null !== regionID && function() {
                            var regionStyle = Object(get_styling.b)(regionNode), associatedStyle = regionNode.getAttribute("style");
                            if (associatedStyle) {
                                var style = Object(array_find.a)(styles, function(x) {
                                    return x.id === associatedStyle;
                                });
                                style && (regionStyle = object_assign_default()({}, style.style, regionStyle));
                            }
                            regions.push({
                                id: regionID,
                                style: regionStyle
                            });
                        }();
                    }
                }
 // Computing the style takes a lot of ressources.
                // To avoid too much re-computation, let's compute the body style right
                // now and do the rest progressively.
                // TODO Compute corresponding CSS style here (as soon as we now the TTML
                // style) to speed up the process even
                // more.
                                for (var bodyStyle = null !== body ? Object(get_styling.a)(STYLE_ATTRIBUTES, [ body ], styles, regions) : Object(get_styling.a)(STYLE_ATTRIBUTES, [], styles, regions), shouldTrimWhiteSpaceOnBody = "default" === (body ? body.getAttribute("xml:space") : void 0) || "default" === params.spaceStyle, _i2 = 0; _i2 < paragraphNodes.length; _i2++) {
                    var paragraph = paragraphNodes[_i2];
                    if (paragraph instanceof Element) {
                        var divs = Object(get_parent_elements_by_tag_name.a)(paragraph, "div"), paragraphStyle = object_assign_default()({}, bodyStyle, Object(get_styling.a)(STYLE_ATTRIBUTES, [ paragraph ].concat(divs), styles, regions)), paragraphSpaceAttribute = paragraph.getAttribute("xml:space"), cue = parseCue(paragraph, timeOffset, styles, regions, body, paragraphStyle, params, paragraphSpaceAttribute ? "default" === paragraphSpaceAttribute : shouldTrimWhiteSpaceOnBody);
                        cue && ret.push(cue);
                    }
                }
            }
            return ret;
        };
        /***/    }, 
    /* 161 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/merge.js
        var merge = __webpack_require__(112), interval = __webpack_require__(177), concat = __webpack_require__(76), of = __webpack_require__(30), Subject = __webpack_require__(42), startWith = __webpack_require__(176), switchMapTo = __webpack_require__(184), mapTo = __webpack_require__(140), takeUntil = __webpack_require__(178), compat = __webpack_require__(7), config = __webpack_require__(2), log = __webpack_require__(0), abstract_source_buffer = __webpack_require__(66), MAX_DELTA_BUFFER_TIME = .2;
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/interval.js
                /**
 * @see MAX_DELTA_BUFFER_TIME
 * @param {Number} a
 * @param {Number} b
 * @returns {Boolean}
 */
        function areNearlyEqual(a, b) {
            return Math.abs(a - b) <= MAX_DELTA_BUFFER_TIME;
        }
        /**
 * Get all cues strictly before the given time.
 * @param {Object} cues
 * @param {Number} time
 * @returns {Array.<Object>}
 */        function getCuesBefore(cues, time) {
            for (var i = 0; i < cues.length; i++) {
                if (time < cues[i].end) return cues.slice(0, i);
            }
            return cues.slice();
        }
        /**
 * Get all cues strictly after the given time.
 * @param {Object} cues
 * @param {Number} time
 * @returns {Array.<Object>}
 */        function getCuesAfter(cues, time) {
            for (var i = 0; i < cues.length; i++) {
                if (cues[i].start > time) return cues.slice(i, cues.length);
            }
            return [];
        }
        /**
 * @param {Object} cuesInfos
 * @param {Number} start
 * @param {Number} end
 * @returns {Array.<Object>}
 */        function removeCuesInfosBetween(cuesInfos, start, end) {
            var end1 = Math.max(cuesInfos.start, start);
            return [ {
                start: cuesInfos.start,
                end: end1,
                cues: getCuesBefore(cuesInfos.cues, start)
            }, {
                start: Math.min(end, cuesInfos.end),
                end: cuesInfos.end,
                cues: getCuesAfter(cuesInfos.cues, end)
            } ];
        }
        // CONCATENATED MODULE: ./src/core/source_buffers/text/html/buffer_manager.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Manage the buffer of the HTML text Sourcebuffer.
 * Allows to add, remove and recuperate cues at given times.
 * @class TextBufferManager
 */        var buffer_manager_TextBufferManager = 
        /* */
        function() {
            function TextBufferManager() {
                this._cuesBuffer = [];
            }
            /**
   * Get corresponding cue for the given time.
   * A cue is an object with three properties:
   *   - start {Number}: start time for which the cue should be displayed.
   *   - end {Number}: end time for which the cue should be displayed.
   *   - element {HTMLElement}: The cue to diplay
   *
   * We do not mutate individual cue here.
   * That is, if the ``get`` method returns the same cue's reference than a
   * previous ``get`` call, its properties are guaranteed to have the exact same
   * values than before, if you did not mutate it on your side.
   * The inverse is true, if the values are the same than before, the reference
   * will stay the same (this is useful to easily check if the DOM should be
   * updated, for example).
   *
   * @param {Number} time
   * @returns {HTMLElement|undefined} - The cue to display
   */            var _proto = TextBufferManager.prototype;
            return _proto.get = function get(time) {
                // begins at the end as most of the time the player will ask for the last
                // CuesGroup
                for (var cuesBuffer = this._cuesBuffer, i = cuesBuffer.length - 1; 0 <= i; i--) for (var cues = cuesBuffer[i].cues, j = cues.length - 1; 0 <= j; j--) {
                    var cue = cues[j];
                    if (time >= cue.start) return time < cue.end ? cue : void 0;
                }
            }
            /**
   * Remove cue from a certain range of time.
   * @param {Number} from
   * @param {Number} to
   */ , _proto.remove = function remove(from, _to) {
                for (var to = Math.max(from, _to), cuesBuffer = this._cuesBuffer, len = cuesBuffer.length, i = 0; i < len; i++) if (cuesBuffer[i].end > from) {
                    var startCuesInfos = cuesBuffer[i];
                    if (startCuesInfos.start >= to) 
                    // our cue is strictly after this interval, we have nothing to do
                    return;
 // ``to`` is within this segment
                                        if (startCuesInfos.end >= to) {
                        var _removeCuesInfosBetwe = removeCuesInfosBetween(startCuesInfos, from, to), cuesInfos1 = _removeCuesInfosBetwe[0], cuesInfos2 = _removeCuesInfosBetwe[1];
                        return this._cuesBuffer[i] = cuesInfos1, void cuesBuffer.splice(i + 1, 0, cuesInfos2);
                    }
 // Else remove the part of the segment after ``from``, and the concerned
                    // segments after that
                                        startCuesInfos.cues = getCuesBefore(startCuesInfos.cues, from), 
                    startCuesInfos.end = Math.max(from, startCuesInfos.start);
                    for (var j = i + 1; j < len; j++) {
                        var endCuesInfos = cuesBuffer[i];
                        if (to <= endCuesInfos.end) 
                        // remove all cues from the start to this one non-included
                        return cuesBuffer.splice(i + 1, j - (i + 1)), void (// if ``to`` is in the middle of the last segment
                        to > endCuesInfos.start && (endCuesInfos.cues = getCuesAfter(endCuesInfos.cues, to), 
                        endCuesInfos.start = to));
                    }
                    return void cuesBuffer.splice(i + 1, cuesBuffer.length - (i + 1));
                }
            }
            /**
   * Insert new cues in our text buffer.
   * cues is an array of objects with three properties:
   *   - start {Number}: start time for which the cue should be displayed.
   *   - end {Number}: end time for which the cue should be displayed.
   *   - element {HTMLElement}: The cue to diplay
   *
   * @param {Array.<Object>} cues - CuesGroups, array of objects with the
   * following properties:
   *   - start {Number}: the time at which the cue will start to be displayed
   *   - end {Number}: the time at which the cue will end to be displayed
   *   - cue {HTMLElement}: The cue
   * @param {Number} start - Start time at which the CuesGroup applies.
   * This is different than the start of the first cue to display in it, this
   * has more to do with the time at which the _text segment_ starts.
   * @param {Number} end - End time at which the CuesGroup applies.
   * This is different than the end of the last cue to display in it, this
   * has more to do with the time at which the _text segment_ ends.
   *
   * TODO add securities to ensure that:
   *   - the start of a CuesGroup is inferior or equal to the start of the first
   *     cue in it
   *   - the end of a CuesGroup is superior or equal to the end of the last
   *     cue in it
   * If those requirements are not met, we could delete some cues when adding
   * a CuesGroup before/after. Find a solution.
   */ , _proto.insert = function insert(cues, start, end) {
                for (var cuesBuffer = this._cuesBuffer, cuesInfosToInsert = {
                    start: start,
                    end: end,
                    cues: cues
                }, i = 0; i < cuesBuffer.length; i++) {
                    var cuesInfos = cuesBuffer[i];
                    if (start < cuesInfos.end) {
                        if (areNearlyEqual(start, cuesInfos.start)) {
                            if (areNearlyEqual(end, cuesInfos.end)) 
                            // exact same segment
                            //   ours:            |AAAAA|
                            //   the current one: |BBBBB|
                            //   Result:          |AAAAA|
                            // Which means:
                            //   1. replace the current cue with ours
                            return void (cuesBuffer[i] = cuesInfosToInsert);
 // our cue goes beyond the current one:
                            //   ours:            |AAAAAAA|
                            //   the current one: |BBBB|
                            //   Result:          |AAAAAAA|
                            // Here we have to delete any cuesInfos which end before ours end,
                            // and see about the following one.
                                                        if (end < cuesInfos.end) 
                            // our cue overlaps with the current one:
                            //   ours:            |AAAAA|
                            //   the current one: |BBBBBBBB|
                            //   Result:          |AAAAABBB|
                            // Which means:
                            //   1. remove some cues at the start of the current one
                            //   2. update start of current one
                            //   3. add ours before the current one
                            return cuesInfos.cues = getCuesAfter(cuesInfos.cues, end), cuesInfos.start = end, 
                            void cuesBuffer.splice(i, 0, cuesInfosToInsert);
                            for (;cuesBuffer.splice(i, 1), (cuesInfos = cuesBuffer[i]) && end > cuesInfos.end; ) ;
                            return !cuesInfos || // There is no cue here
                            areNearlyEqual(end, cuesInfos.end) ? 
                            // put in place
                            void (cuesBuffer[i] = cuesInfosToInsert) : (// else -> end < cuesInfos.end (overlapping case)
                            //   ours:            |AAAAA|
                            //   the current one: |BBBBBBBB|
                            //   Result:          |AAAAABBB|
                            cuesInfos.cues = getCuesAfter(cuesInfos.cues, end), cuesInfos.start = end, void cuesBuffer.splice(i, 0, cuesInfosToInsert));
                        }
 // else -> start > cuesInfos.start
                                                if (start < cuesInfos.start) return end < cuesInfos.start || (areNearlyEqual(end, cuesInfos.start) || (// our cue overlaps the current one:
                        //   ours:            |AAAAAAA|
                        //   the current one:     |BBBBB|
                        //   Result:          |AAAAAAABB|
                        // Which means:
                        //   1. remove some cues at the start of the current one
                        //   2. update start of current one
                        //   3. add ours before the current one
                        cuesInfos.cues = getCuesAfter(cuesInfos.cues, end)), 
                        // our cue goes just before the current one:
                        //   ours:            |AAAAAAA|
                        //   the current one:         |BBBB|
                        //   Result:          |AAAAAAA|BBBB|
                        // Which means:
                        //   - update start time of the current one to be sure
                        //   - add ours before the current one
                        cuesInfos.start = end), 
                        // our cue goes strictly before the current one:
                        //   ours:            |AAAAAAA|
                        //   the current one:           |BBBB|
                        //   Result:          |AAAAAAA| |BBBB|
                        // Which means:
                        //   - add ours before the current one
                        void cuesBuffer.splice(i, 0, cuesInfosToInsert);
                        if (end > cuesInfos.end || areNearlyEqual(end, cuesInfos.end)) 
                        // our cue overlaps the current one:
                        //   ours:              |AAAAAA|
                        //   the current one: |BBBBB|
                        //   Result:          |BBAAAAAA|
                        //   - or -
                        //   ours:              |AAAA|
                        //   the current one: |BBBBBB|
                        //   Result:          |BBAAAA|
                        // Which means:
                        //   1. remove some cues at the end of the current one
                        //   2. update end of current one
                        //   3. add ours after current one
                        return cuesInfos.cues = getCuesBefore(cuesInfos.cues, start), cuesInfos.end = start, 
                        void cuesBuffer.splice(i + 1, 0, cuesInfosToInsert);
 // else -> end < cuesInfos.end
                        // our cue is in the current one:
                        //   ours:              |AAA|
                        //   the current one: |BBBBBBB|
                        //   Result:          |BBAAABB|
                        // Which means:
                        //   1. split current one in two parts based on our cue.
                        //   2. insert our cue into it.
                                                var _removeCuesInfosBetwe2 = removeCuesInfosBetween(cuesInfos, start, end), cuesInfos1 = _removeCuesInfosBetwe2[0], cuesInfos2 = _removeCuesInfosBetwe2[1];
                        return this._cuesBuffer[i] = cuesInfos1, cuesBuffer.splice(i + 1, 0, cuesInfosToInsert), 
                        void cuesBuffer.splice(i + 2, 0, cuesInfos2);
                    }
                }
 // no cues group has the end after our current start.
                // These cues should be the last one
                                cuesBuffer.push(cuesInfosToInsert);
            }, TextBufferManager;
        }(), features = __webpack_require__(10);
        // EXTERNAL MODULE: ./src/features/index.ts
                // CONCATENATED MODULE: ./src/core/source_buffers/text/html/parsers.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Convert text track data into timed HTML Cues.
 * @param {string} type - Text track format wanted
 * @param {string} data - Text track data
 * @param {Number} timestampOffset - offset to apply to every timed text
 * @param {string} [language] - language of the text tracks
 * @returns {Array.<Object>}
 * @throws Error - Throw if no parser is found for the given type
 */
        function parseTextTrackToElements(type, data, timestampOffset, language) {
            log.a.debug("HTSB: Finding parser for html text tracks:", type);
            var parser = features.a.htmlTextTracksParsers[type];
            if (!parser) throw new Error("no parser found for the given text track");
            log.a.debug("HTSB: Parser found, parsing...");
            var parsed = parser(data, timestampOffset, language);
            return log.a.debug("HTTB: Parsed successfully!", parsed), parsed;
        }
        // CONCATENATED MODULE: ./src/core/source_buffers/text/html/html_text_source_buffer.ts
                function _inheritsLoose(subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype), (subClass.prototype.constructor = subClass).__proto__ = superClass;
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        var onEnded$ = compat.a.onEnded$, onSeeked$ = compat.a.onSeeked$, onSeeking$ = compat.a.onSeeking$, MAXIMUM_HTML_TEXT_TRACK_UPDATE_INTERVAL = config.a.MAXIMUM_HTML_TEXT_TRACK_UPDATE_INTERVAL;
        /**
 * Generate the clock at which TextTrack HTML Cues should be refreshed.
 * @param {HTMLMediaElement} videoElement
 * @returns {Observable}
 */
        function generateClock(videoElement) {
            var seeking$ = onSeeking$(videoElement), seeked$ = onSeeked$(videoElement), ended$ = onEnded$(videoElement), manualRefresh$ = Object(merge.a)(seeked$, ended$), autoRefresh$ = Object(interval.a)(MAXIMUM_HTML_TEXT_TRACK_UPDATE_INTERVAL).pipe(Object(startWith.a)(null));
            return manualRefresh$.pipe(Object(startWith.a)(null), Object(switchMapTo.a)(Object(concat.a)(autoRefresh$.pipe(Object(mapTo.a)(!0), Object(takeUntil.a)(seeking$)), Object(of.a)(!1))));
        }
        /**
 * @param {Element} element
 * @param {Element|null} [child]
 */        function safelyRemoveChild(element, child) {
            if (child) try {
                element.removeChild(child);
            } catch (e) {
                log.a.warn("HTSB: Can't remove text track: not in the element.");
            }
        }
        /**
 * SourceBuffer to display TextTracks in the given HTML element.
 * @class HTMLTextSourceBuffer
 */        var html_text_source_buffer_HTMLTextSourceBuffer = 
        /* */
        function(_AbstractSourceBuffer) {
            /**
   * @param {HTMLMediaElement} videoElement
   * @param {HTMLElement} textTrackElement
   */
            function HTMLTextSourceBuffer(videoElement, textTrackElement) {
                var _this;
                return log.a.debug("HTSB: Creating html text track SourceBuffer"), (_this = _AbstractSourceBuffer.call(this) || this)._videoElement = videoElement, 
                _this._textTrackElement = textTrackElement, _this._destroy$ = new Subject.a(), _this._buffer = new buffer_manager_TextBufferManager(), 
                _this._currentElement = null, generateClock(_this._videoElement).pipe(Object(takeUntil.a)(_this._destroy$)).subscribe(function(shouldDisplay) {
                    if (!shouldDisplay) return safelyRemoveChild(textTrackElement, _this._currentElement), 
                    void (_this._currentElement = null);
 // to spread the time error, we divide the regular chosen interval.
                    // As the clock is also based on real video events, we cannot just
                    // divide by two the regular interval.
                                        var time = Math.max(_this._videoElement.currentTime - MAXIMUM_HTML_TEXT_TRACK_UPDATE_INTERVAL / 2e3, 0), cue = _this._buffer.get(time);
                    if (!cue) return safelyRemoveChild(textTrackElement, _this._currentElement), void (_this._currentElement = null);
                    _this._currentElement !== cue.element && (safelyRemoveChild(textTrackElement, _this._currentElement), 
                    _this._currentElement = cue.element, textTrackElement.appendChild(_this._currentElement));
                }), _this;
            }
            /**
   * Append text tracks.
   * @param {Object} data
   */            _inheritsLoose(HTMLTextSourceBuffer, _AbstractSourceBuffer);
            var _proto = HTMLTextSourceBuffer.prototype;
            return _proto._append = function _append(data) {
                log.a.debug("HTSB: Appending new html text tracks", data);
                var timescale = data.timescale, timescaledStart = data.start, timescaledEnd = data.end, dataString = data.data, type = data.type, language = data.language;
                if (timescaledEnd && timescaledEnd - timescaledStart <= 0) 
                // this is accepted for error resilience, just skip that case.
                /* tslint:disable:max-line-length */
                log.a.warn("HTSB: Invalid text track appended: the start time is inferior or equal to the end time."); else {
                    var startTime = timescaledStart / timescale, endTime = null != timescaledEnd ? timescaledEnd / timescale : void 0, cues = parseTextTrackToElements(type, dataString, this.timestampOffset, language), start = startTime, end = null != endTime ? endTime : cues[cues.length - 1].end;
                    this._buffer.insert(cues, start, end), this.buffered.insert(start, end);
                }
            }
            /**
   * @param {Number} from
   * @param {Number} to
   */ , _proto._remove = function _remove(from, to) {
                log.a.debug("HTSB: Removing html text track data", from, to), this._buffer.remove(from, to), 
                this.buffered.remove(from, to);
            }
            /**
   * Free up ressources from this sourceBuffer
   */ , _proto._abort = function _abort() {
                log.a.debug("HTSB: Aborting html text track SourceBuffer"), this._remove(0, Infinity), 
                this._destroy$.next(), this._destroy$.complete(), safelyRemoveChild(this._textTrackElement, this._currentElement);
            }, HTMLTextSourceBuffer;
        }(abstract_source_buffer.a);
        // CONCATENATED MODULE: ./src/core/source_buffers/text/html/index.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */
        /* harmony default export */        __webpack_exports__.default = html_text_source_buffer_HTMLTextSourceBuffer;
    }, 
    /* 162 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        // EXTERNAL MODULE: ./src/compat/add_text_track.ts
        var add_text_track = __webpack_require__(130), log = __webpack_require__(0), browser_detection = __webpack_require__(20);
        // EXTERNAL MODULE: ./src/log.ts + 1 modules
                // CONCATENATED MODULE: ./src/compat/remove_cue.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Return true if given cue is active.
 * @param {TextTrack} track
 * @param {TextTrackCue} cue
 * @returns {boolean}
 */
        function isActiveCue(track, cue) {
            for (var activeCues = track.activeCues, i = 0; i < activeCues.length; i++) if (activeCues[i] === cue) return !0;
            return !1;
        }
        /**
 * Remove cue from text track.
 * @param {TextTrack} track
 * @param {TextTrackCue} cue
 */        function removeCue(track, cue) {
            // On Firefox, cue doesn't dissapear when it is removed from track. Track
            // should be hidden, and shown again after removing cue, in order to
            // definitely clean the cue.
            if (browser_detection.a && isActiveCue(track, cue)) {
                var trackMode = track.mode;
                track.mode = "hidden";
                try {
                    track.removeCue(cue);
                } catch (err) {
                    log.a.warn("Compat: Could not remove cue from text track.");
                }
                track.mode = trackMode;
            } else try {
                track.removeCue(cue);
            } catch (err) {
                log.a.warn("Compat: Could not remove cue from text track.");
            }
        }
        // EXTERNAL MODULE: ./src/core/source_buffers/abstract_source_buffer.ts + 1 modules
                var abstract_source_buffer = __webpack_require__(66), features = __webpack_require__(10);
        // EXTERNAL MODULE: ./src/features/index.ts
                // CONCATENATED MODULE: ./src/core/source_buffers/text/native/parsers.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Convert text track data into timed VTT Cues.
 * @param {string} type - Text track format wanted
 * @param {string} data - Text track data
 * @param {Number} timestampOffset - offset to apply to every timed text
 * @param {string} [language] - language of the text tracks
 * @returns {Array.<VTTCue>}
 * @throws Error - Throw if no parser is found for the given type
 */
        function parseTextTrackToCues(type, data, timestampOffset, language) {
            log.a.debug("NTSB: Finding parser for native text tracks:", type);
            var parser = features.a.nativeTextTracksParsers[type];
            if (!parser) throw new Error("no parser found for the given text track");
            log.a.debug("NTSB: Parser found, parsing...");
            var parsed = parser(data, timestampOffset, language);
            return log.a.debug("NTSB: Parsed successfully!", parsed), parsed;
        }
        // CONCATENATED MODULE: ./src/core/source_buffers/text/native/native_text_source_buffer.ts
                function _inheritsLoose(subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype), (subClass.prototype.constructor = subClass).__proto__ = superClass;
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * SourceBuffer to display TextTracks in a <track> element, in the given
 * video element.
 * @class NativeTextSourceBuffer
 * @extends AbstractSourceBuffer
 */        var native_text_source_buffer_NativeTextSourceBuffer = 
        /* */
        function(_AbstractSourceBuffer) {
            /**
   * @param {HTMLMediaElement} videoElement
   * @param {Boolean} hideNativeSubtitle
   */
            function NativeTextSourceBuffer(videoElement, hideNativeSubtitle) {
                var _this;
                log.a.debug("NTSB: Creating native text track SourceBuffer"), _this = _AbstractSourceBuffer.call(this) || this;
                var _addTextTrack = Object(add_text_track.a)(videoElement, hideNativeSubtitle), track = _addTextTrack.track, trackElement = _addTextTrack.trackElement;
                return _this._videoElement = videoElement, _this._track = track, _this._trackElement = trackElement, 
                _this;
            }
            /**
   * Append text tracks.
   * @param {Object} data
   */            _inheritsLoose(NativeTextSourceBuffer, _AbstractSourceBuffer);
            var _proto = NativeTextSourceBuffer.prototype;
            return _proto._append = function _append(data) {
                log.a.debug("NTSB: Appending new native text tracks", data);
                var timescale = data.timescale, timescaledStart = data.start, timescaledEnd = data.end, dataString = data.data, type = data.type, language = data.language;
                if (null != timescaledEnd && timescaledEnd - timescaledStart <= 0) 
                // this is accepted for error resilience, just skip that case.
                log.a.warn("NTSB: Invalid subtitles appended"); else {
                    var startTime = timescaledStart / timescale, endTime = null != timescaledEnd ? timescaledEnd / timescale : void 0, cues = parseTextTrackToCues(type, dataString, this.timestampOffset, language);
                    if (0 < cues.length) {
                        var firstCue = cues[0], currentCues = this._track.cues;
 // NOTE(compat): cleanup all current cues if the newly added
                        // ones are in the past. this is supposed to fix an issue on
                        // IE/Edge.
                                                0 < currentCues.length && firstCue.startTime < currentCues[currentCues.length - 1].startTime && this._remove(firstCue.startTime, Infinity);
                        for (var i = 0; i < cues.length; i++) this._track.addCue(cues[i]);
                        this.buffered.insert(startTime, null != endTime ? endTime : cues[cues.length - 1].endTime);
                    } else null != endTime && this.buffered.insert(startTime, endTime);
                }
            }
            /**
   * @param {Number} from
   * @param {Number} to
   */ , _proto._remove = function _remove(from, to) {
                log.a.debug("NTSB: Removing native text track data", from, to);
                var track = this._track, cues = track.cues;
                if (null != cues) for (var i = cues.length - 1; 0 <= i; i--) {
                    var cue = cues[i], startTime = cue.startTime, endTime = cue.endTime;
                    from <= startTime && startTime <= to && endTime <= to && removeCue(track, cue);
                }
                this.buffered.remove(from, to);
            }, _proto._abort = function _abort() {
                log.a.debug("NTSB: Aborting native text track SourceBuffer"), this._remove(0, Infinity);
                var _trackElement = this._trackElement, _videoElement = this._videoElement;
                if (_trackElement && _videoElement && _videoElement.hasChildNodes()) try {
                    _videoElement.removeChild(_trackElement);
                } catch (e) {
                    log.a.warn("NTSB: Can't remove track element from the video");
                }
                this._track && (this._track.mode = "disabled"), this._trackElement && (this._trackElement.innerHTML = "");
            }, NativeTextSourceBuffer;
        }(abstract_source_buffer.a);
        // CONCATENATED MODULE: ./src/core/source_buffers/text/native/index.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */
        /* harmony default export */        __webpack_exports__.default = native_text_source_buffer_NativeTextSourceBuffer;
    }, 
    /* 163 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        // EXTERNAL MODULE: ./src/compat/is_vtt_cue.ts
        var is_vtt_cue = __webpack_require__(131), get_cue_blocks = __webpack_require__(94), parse_cue_block = __webpack_require__(109), utils = __webpack_require__(52), array_includes = __webpack_require__(12);
        // EXTERNAL MODULE: ./src/parsers/texttracks/webvtt/get_cue_blocks.ts
                // CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/native/set_settings_on_cue.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Add the corresponding settings on the given cue.
 * /!\ Mutates the cue given.
 * @param {Object} settings - settings for the cue, as a key-value object.
 * @param {ICompatVTTCue|TextTrackCue} cue
 */
        function setSettingsOnCue(settings, cue) {
            if (!settings.vertical || "rl" !== settings.vertical && "lr" !== settings.vertical || (cue.vertical = settings.vertical), 
            settings.line) {
                /**
     * Capture groups:
     *   1 -> percentage position
     *   2 -> optional decimals from percentage position
     *   3 -> optional follow-up of the string indicating alignment value
     *   4 -> alignment value
     * @type {RegExp}
     */
                var percentageMatches = settings.line.match(/^(\d+(\.\d+)?)%(,([a-z]+))?/);
                if (percentageMatches) cue.line = Number(percentageMatches[1]), cue.snapToLines = !1, 
                Object(array_includes.a)([ "start", "center", "end" ], percentageMatches[4]) && (cue.lineAlign = percentageMatches[4]); else {
                    /**
       * Capture groups:
       *   1 -> line number
       *   2 -> optional follow-up of the string indicating alignment value
       *   3 -> alignment value
       * @type {RegExp}
       */
                    var lineMatches = settings.line.match(/^(-?\d+)(,([a-z]+))?/);
                    lineMatches && (cue.line = Number(lineMatches[1]), cue.snapToLines = !0, Object(array_includes.a)([ "start", "center", "end" ], lineMatches[3]) && (cue.lineAlign = lineMatches[3]));
                }
            }
            if (settings.position) {
                var positionArr = /^([\d\.]+)%(?:,(line-left|line-right|center))?$/.exec(settings.position);
                if (positionArr && 2 <= positionArr.length) {
                    var position = parseInt(positionArr[1], 10);
                    isNaN(position) || (cue.position = position, null != positionArr[2] && (cue.positionAlign = positionArr[2]));
                }
            }
            settings.size && (cue.size = settings.size), settings.align && Object(array_includes.a)([ "start", "center", "end", "left" ], settings.align) && (cue.align = settings.align);
        }
        // EXTERNAL MODULE: ./src/compat/make_vtt_cue.ts
                var make_vtt_cue = __webpack_require__(95);
        // CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/native/to_native_cue.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {Object} cue Object
 * @returns {TextTrackCue|ICompatVTTCue|null}
 */        function toNativeCue(cueObj) {
            var start = cueObj.start, end = cueObj.end, text = cueObj.payload.join("\n");
            return Object(make_vtt_cue.a)(start, end, text);
        }
        // CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/native/parse_vtt_to_cues.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */
        // Simple VTT to ICompatVTTCue parser:
        // Just parse cues and associated settings.
        // Does not take into consideration STYLE and REGION blocks.
        /**
 * Parse whole WEBVTT file into an array of cues, to be inserted in a video's
 * TrackElement.
 * @param {string} vttStr
 * @param {Number} timeOffset
 * @returns {Array.<ICompatVTTCue|TextTrackCue>}
 */        
        // CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/native/index.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */
        /* harmony default export */ __webpack_exports__.default = function parseVTTStringToVTTCues(vttStr, timeOffset) {
            // WEBVTT authorize CRLF, LF or CR as line terminators
            var lines = vttStr.split(/\r\n|\n|\r/);
            if (!/^WEBVTT($| |\t)/.test(lines[0])) throw new Error("Can't parse WebVTT: Invalid file.");
            for (var firstLineAfterHeader = Object(utils.b)(lines), cueBlocks = Object(get_cue_blocks.a)(lines, firstLineAfterHeader), cues = [], i = 0; i < cueBlocks.length; i++) {
                var cueObject = Object(parse_cue_block.a)(cueBlocks[i], timeOffset);
                if (null != cueObject) {
                    var nativeCue = toNativeCue(cueObject);
                    null != nativeCue && (Object(is_vtt_cue.a)(nativeCue) && setSettingsOnCue(cueObject.settings, nativeCue), 
                    cues.push(nativeCue));
                }
            }
            return cues;
        };
        /***/    }, 
    /* 164 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        // EXTERNAL MODULE: ./src/log.ts + 1 modules
        var log = __webpack_require__(0);
        // EXTERNAL MODULE: ./src/core/source_buffers/abstract_source_buffer.ts + 1 modules
                // CONCATENATED MODULE: ./src/core/source_buffers/image/image_source_buffer.ts
        function _inheritsLoose(subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype), (subClass.prototype.constructor = subClass).__proto__ = superClass;
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */
        /**
 * Image SourceBuffer implementation.
 * @class ImageSourceBuffer
 */        var image_source_buffer = 
        /* */
        function(_AbstractSourceBuffer) {
            function ImageSourceBuffer() {
                return _AbstractSourceBuffer.apply(this, arguments) || this;
            }
            _inheritsLoose(ImageSourceBuffer, _AbstractSourceBuffer);
            var _proto = ImageSourceBuffer.prototype;
            /**
   * @param {Object} data
   */            return _proto._append = function _append(data) {
                log.a.debug("ImageSourceBuffer: appending new data.");
                var start = data.start, end = data.end, timescale = data.timescale;
                this.buffered.insert(start / timescale, null == end ? Number.MAX_VALUE : end / timescale);
            }
            /**
   * @param {Number} from
   * @param {Number} to
   */ , _proto._remove = function _remove(from, to) {
                log.a.info("ImageSourceBuffer: ignored image data remove order", from, to);
 // TODO once a better strategy for image cleaning has been set (surely done
                // when we will work for live thumbnails), restore this implementation.
                // log.debug("ImageSourceBuffer: removing image data", from, to);
                // this.buffered.remove(from, to);
                        }, _proto._abort = function _abort() {
                log.a.debug("ImageSourceBuffer: aborting image SourceBuffer"), this._remove(0, Infinity);
            }, ImageSourceBuffer;
        }(__webpack_require__(66).a);
        /* harmony default export */        __webpack_exports__.default = image_source_buffer;
    }, 
    /* 165 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        // EXTERNAL MODULE: ./node_modules/object-assign/index.js
        var object_assign = __webpack_require__(9), object_assign_default = /* */ __webpack_require__.n(object_assign), make_vtt_cue = __webpack_require__(95), is_vtt_cue = __webpack_require__(131), array_find = __webpack_require__(11), get_parameters = __webpack_require__(96), get_parent_elements_by_tag_name = __webpack_require__(65), get_styling = __webpack_require__(29), get_time_delimiters = __webpack_require__(110), nodes = __webpack_require__(50), regexps = __webpack_require__(18), WANTED_STYLE_ATTRIBUTES = [ "extent", "writingMode", "origin", "align" ], TEXT_ALIGN_TO_LIGN_ALIGN = {
            left: "start",
            center: "center",
            right: "end",
            start: "start",
            end: "end"
        }, TEXT_ALIGN_TO_POSITION_ALIGN = {
            left: "line-left",
            center: "center",
            right: "line-right"
        };
        /**
 * Parses an Element into a TextTrackCue or VTTCue.
 * /!\ Mutates the given cueElement Element
 * @param {Element} paragraph
 * @param {Number} offset
 * @param {Array.<Object>} styles
 * @param {Array.<Object>} regions
 * @param {Object} paragraphStyle
 * @param {Object} params
 * @param {Boolean} shouldTrimWhiteSpaceOnParagraph
 * @returns {TextTrackCue|null}
 */
        function parseCue(paragraph, offset, _styles, _regions, paragraphStyle, params, shouldTrimWhiteSpace) {
            // Disregard empty elements:
            // TTML allows for empty elements like <div></div>.
            // If paragraph has neither time attributes, nor
            // non-whitespace text, don't try to make a cue out of it.
            if (!paragraph.hasAttribute("begin") && !paragraph.hasAttribute("end") && /^\s*$/.test(paragraph.textContent || "")) return null;
            var _getTimeDelimiters = Object(get_time_delimiters.a)(paragraph, params), start = _getTimeDelimiters.start, end = _getTimeDelimiters.end, text = generateTextContent(paragraph, shouldTrimWhiteSpace), cue = Object(make_vtt_cue.a)(start + offset, end + offset, text);
            return cue ? (Object(is_vtt_cue.a)(cue) && addStyle(cue, paragraphStyle), cue) : null;
        }
        /**
 * Generate text to display for a given paragraph.
 * @param {Element} paragraph - The <p> tag.
 * @param {Boolean} shouldTrimWhiteSpaceForParagraph
 * @returns {string}
 */        function generateTextContent(paragraph, shouldTrimWhiteSpaceForParagraph) {
            /**
   * Recursive function, taking a node in argument and returning the
   * corresponding string.
   * @param {Node} node - the node in question
   * @returns {string}
   */
            return function loop(node, shouldTrimWhiteSpaceFromParent) {
                for (var childNodes = node.childNodes, text = "", i = 0; i < childNodes.length; i++) {
                    var currentNode = childNodes[i];
                    if ("#text" === currentNode.nodeName) {
                        var textContent = currentNode.textContent || "";
                        if (shouldTrimWhiteSpaceFromParent) {
                            // 1. Trim leading and trailing whitespace.
                            // 2. Collapse multiple spaces into one.
                            var trimmed = textContent.trim();
                            textContent = trimmed = trimmed.replace(/\s+/g, " ");
                        }
 // DOM Parser turns HTML escape caracters into caracters,
                        // that may be misinterpreted by VTTCue API (typically, less-than sign
                        // and greater-than sign can be interpreted as HTML tags signs).
                        // Original escaped caracters must be conserved.
                                                text += textContent.replace(/&|\u0026/g, "&amp;").replace(/<|\u003C/g, "&lt;").replace(/>|\u2265/g, "&gt;").replace(/\u200E/g, "&lrm;").replace(/\u200F/g, "&rlm;").replace(/\u00A0/g, "&nbsp;");
                    } else if ("br" === currentNode.nodeName) text += "\n"; else if ("span" === currentNode.nodeName && currentNode.nodeType === Node.ELEMENT_NODE && 0 < currentNode.childNodes.length) {
                        var spaceAttribute = currentNode.getAttribute("xml:space");
                        text += loop(currentNode, spaceAttribute ? "default" === spaceAttribute : shouldTrimWhiteSpaceFromParent);
                    }
                }
                return text;
            }(paragraph, shouldTrimWhiteSpaceForParagraph);
        }
        /**
 * Adds applicable style properties to a cue.
 * /!\ Mutates cue argument.
 * @param {VTTCue} cue
 * @param {Object} style
 */        function addStyle(cue, style) {
            var extent = style.extent;
            if (extent) {
                var results = regexps.c.exec(extent);
                null != results && (
                // Use width value of the extent attribute for size.
                // Height value is ignored.
                cue.size = Number(results[1]));
            }
            // let isVerticalText = true;
            switch (style.writingMode) {
              case "tb":
              case "tblr":
                cue.vertical = "lr";
                break;

              case "tbrl":
                cue.vertical = "rl";
            }
            var origin = style.origin;
            if (origin) regexps.c.exec(origin);
            var align = style.align;
            align && ("center" === (cue.align = align) && ("center" !== cue.align && (
            // Workaround for a Chrome bug http://crbug.com/663797
            // Chrome does not support align = "center"
            cue.align = "middle"), cue.position = "auto"), cue.positionAlign = TEXT_ALIGN_TO_POSITION_ALIGN[align] || "", 
            cue.lineAlign = TEXT_ALIGN_TO_LIGN_ALIGN[align] || "");
        }
        /* harmony default export */        var parse_ttml_to_vtt = 
        /**
 * @param {string} str
 * @param {Number} timeOffset
 * @returns {Array.<VTTCue|TextTrackCue>}
 */
        function parseTTMLStringToVTT(str, timeOffset) {
            var ret = [], xml = new DOMParser().parseFromString(str, "text/xml");
            if (xml) {
                var tt = xml.getElementsByTagName("tt")[0];
                if (!tt) throw new Error("invalid XML");
                for (var body = Object(nodes.a)(tt), styleNodes = Object(nodes.c)(tt), regionNodes = Object(nodes.b)(tt), paragraphNodes = Object(nodes.d)(tt), params = Object(get_parameters.a)(tt), styles = [], i = 0; i <= styleNodes.length - 1; i++) {
                    // TODO styles referencing other styles
                    var styleNode = styleNodes[i];
                    if (styleNode instanceof Element) {
                        var styleID = styleNode.getAttribute("xml:id");
                        null != styleID && styles.push({
                            id: styleID,
                            style: Object(get_styling.b)(styleNode)
                        });
                    }
                }
 // construct regions array based on the xml as an optimization
                                for (var regions = [], _i = 0; _i <= regionNodes.length - 1; _i++) {
                    var regionNode = regionNodes[_i];
                    if (regionNode instanceof Element) {
                        var regionID = regionNode.getAttribute("xml:id");
                        null != regionID && function() {
                            var regionStyle = Object(get_styling.b)(regionNode), associatedStyle = regionNode.getAttribute("style");
                            if (associatedStyle) {
                                var style = Object(array_find.a)(styles, function(x) {
                                    return x.id === associatedStyle;
                                });
                                style && (regionStyle = object_assign_default()({}, style.style, regionStyle));
                            }
                            regions.push({
                                id: regionID,
                                style: regionStyle
                            });
                        }();
                    }
                }
 // Computing the style takes a lot of ressources.
                // To avoid too much re-computation, let's compute the body style right
                // now and do the rest progressively.
                                for (var bodyStyle = body ? Object(get_styling.a)(WANTED_STYLE_ATTRIBUTES, [ body ], styles, regions) : Object(get_styling.a)(WANTED_STYLE_ATTRIBUTES, [], styles, regions), shouldTrimWhiteSpaceOnBody = "default" === (body ? body.getAttribute("xml:space") : void 0) || "default" === params.spaceStyle, _i2 = 0; _i2 < paragraphNodes.length; _i2++) {
                    var paragraph = paragraphNodes[_i2];
                    if (paragraph instanceof Element) {
                        var divs = Object(get_parent_elements_by_tag_name.a)(paragraph, "div"), paragraphStyle = object_assign_default()({}, bodyStyle, Object(get_styling.a)(WANTED_STYLE_ATTRIBUTES, [ paragraph ].concat(divs), styles, regions)), paragraphSpaceAttribute = paragraph.getAttribute("xml:space"), cue = parseCue(paragraph, timeOffset, 0, 0, paragraphStyle, params, paragraphSpaceAttribute ? "default" === paragraphSpaceAttribute : shouldTrimWhiteSpaceOnBody);
                        cue && ret.push(cue);
                    }
                }
            }
            return ret;
        };
        // CONCATENATED MODULE: ./src/parsers/texttracks/ttml/native/index.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */
        /* harmony default export */        __webpack_exports__.default = parse_ttml_to_vtt;
    }, 
    /* 166 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return fromEvent;
        });
        /* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6), _util_isArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(45), _util_isFunction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(51), _operators_map__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(34);
        /* harmony import */        Object.prototype.toString;
        function fromEvent(target, eventName, options, resultSelector) {
            return Object(_util_isFunction__WEBPACK_IMPORTED_MODULE_2__.a)(options) && (resultSelector = options, 
            options = void 0), resultSelector ? fromEvent(target, eventName, options).pipe(Object(_operators_map__WEBPACK_IMPORTED_MODULE_3__.a)(function(args) {
                return Object(_util_isArray__WEBPACK_IMPORTED_MODULE_1__.a)(args) ? resultSelector.apply(void 0, args) : resultSelector(args);
            })) : new _Observable__WEBPACK_IMPORTED_MODULE_0__.a(function(subscriber) {
                setupSubscription(target, eventName, function handler(e) {
                    1 < arguments.length ? subscriber.next(Array.prototype.slice.call(arguments)) : subscriber.next(e);
                }, subscriber, options);
            });
        }
        function setupSubscription(sourceObj, eventName, handler, subscriber, options) {
            var unsubscribe;
            if (isEventTarget(sourceObj)) {
                var source_1 = sourceObj;
                sourceObj.addEventListener(eventName, handler, options), unsubscribe = function() {
                    return source_1.removeEventListener(eventName, handler, options);
                };
            } else if (isJQueryStyleEventEmitter(sourceObj)) {
                var source_2 = sourceObj;
                sourceObj.on(eventName, handler), unsubscribe = function() {
                    return source_2.off(eventName, handler);
                };
            } else if (isNodeStyleEventEmitter(sourceObj)) {
                var source_3 = sourceObj;
                sourceObj.addListener(eventName, handler), unsubscribe = function() {
                    return source_3.removeListener(eventName, handler);
                };
            } else {
                if (!sourceObj || !sourceObj.length) throw new TypeError("Invalid event target");
                for (var i = 0, len = sourceObj.length; i < len; i++) setupSubscription(sourceObj[i], eventName, handler, subscriber, options);
            }
            subscriber.add(unsubscribe);
        }
        function isNodeStyleEventEmitter(sourceObj) {
            return sourceObj && "function" == typeof sourceObj.addListener && "function" == typeof sourceObj.removeListener;
        }
        function isJQueryStyleEventEmitter(sourceObj) {
            return sourceObj && "function" == typeof sourceObj.on && "function" == typeof sourceObj.off;
        }
        function isEventTarget(sourceObj) {
            return sourceObj && "function" == typeof sourceObj.addEventListener && "function" == typeof sourceObj.removeEventListener;
        }
        //# sourceMappingURL=fromEvent.js.map
        /***/    }, 
    /* 167 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return distinctUntilChanged;
        });
        /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3), _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8);
        /* harmony import */        
        /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
        function distinctUntilChanged(compare, keySelector) {
            return function(source) {
                return source.lift(new DistinctUntilChangedOperator(compare, keySelector));
            };
        }
        var DistinctUntilChangedOperator = /* */ function() {
            function DistinctUntilChangedOperator(compare, keySelector) {
                this.compare = compare, this.keySelector = keySelector;
            }
            return DistinctUntilChangedOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));
            }, DistinctUntilChangedOperator;
        }(), DistinctUntilChangedSubscriber = /* */ function(_super) {
            function DistinctUntilChangedSubscriber(destination, compare, keySelector) {
                var _this = _super.call(this, destination) || this;
                return _this.keySelector = keySelector, _this.hasKey = !1, "function" == typeof compare && (_this.compare = compare), 
                _this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(DistinctUntilChangedSubscriber, _super), 
            DistinctUntilChangedSubscriber.prototype.compare = function(x, y) {
                return x === y;
            }, DistinctUntilChangedSubscriber.prototype._next = function(value) {
                var key;
                try {
                    var keySelector = this.keySelector;
                    key = keySelector ? keySelector(value) : value;
                } catch (err) {
                    return this.destination.error(err);
                }
                var result = !1;
                if (this.hasKey) try {
                    result = (0, this.compare)(this.key, key);
                } catch (err) {
                    return this.destination.error(err);
                } else this.hasKey = !0;
                result || (this.key = key, this.destination.next(value));
            }, DistinctUntilChangedSubscriber;
        }(_Subscriber__WEBPACK_IMPORTED_MODULE_1__.a);
    }, 
    /* 168 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return defer;
        });
        /* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6), _from__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(53), _empty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(38);
        /* harmony import */        
        /** PURE_IMPORTS_START _Observable,_from,_empty PURE_IMPORTS_END */
        function defer(observableFactory) {
            return new _Observable__WEBPACK_IMPORTED_MODULE_0__.a(function(subscriber) {
                var input;
                try {
                    input = observableFactory();
                } catch (err) {
                    return void subscriber.error(err);
                }
                return (input ? Object(_from__WEBPACK_IMPORTED_MODULE_1__.a)(input) : Object(_empty__WEBPACK_IMPORTED_MODULE_2__.b)()).subscribe(subscriber);
            });
        }
        //# sourceMappingURL=defer.js.map
        /***/    }, 
    /* 169 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return mergeMapTo;
        });
        /* harmony import */ var _mergeMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(39);
        /** PURE_IMPORTS_START _mergeMap PURE_IMPORTS_END */        function mergeMapTo(innerObservable, resultSelector, concurrent) {
            return void 0 === concurrent && (concurrent = Number.POSITIVE_INFINITY), "function" == typeof resultSelector ? Object(_mergeMap__WEBPACK_IMPORTED_MODULE_0__.a)(function() {
                return innerObservable;
            }, resultSelector, concurrent) : ("number" == typeof resultSelector && (concurrent = resultSelector), 
            Object(_mergeMap__WEBPACK_IMPORTED_MODULE_0__.a)(function() {
                return innerObservable;
            }, concurrent));
        }
        //# sourceMappingURL=mergeMapTo.js.map
        /***/    }, 
    /* 170 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return ignoreElements;
        });
        /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3), _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8);
        /* harmony import */        
        /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
        function ignoreElements() {
            return function ignoreElementsOperatorFunction(source) {
                return source.lift(new IgnoreElementsOperator());
            };
        }
        var IgnoreElementsOperator = /* */ function() {
            function IgnoreElementsOperator() {}
            return IgnoreElementsOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new IgnoreElementsSubscriber(subscriber));
            }, IgnoreElementsOperator;
        }(), IgnoreElementsSubscriber = /* */ function(_super) {
            function IgnoreElementsSubscriber() {
                return null !== _super && _super.apply(this, arguments) || this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(IgnoreElementsSubscriber, _super), IgnoreElementsSubscriber.prototype._next = function(unused) {}, 
            IgnoreElementsSubscriber;
        }(_Subscriber__WEBPACK_IMPORTED_MODULE_1__.a);
    }, 
    /* 171 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return catchError;
        });
        /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3), _OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(25), _InnerSubscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(47), _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(24);
        /* harmony import */        
        /** PURE_IMPORTS_START tslib,_OuterSubscriber,_InnerSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
        function catchError(selector) {
            return function catchErrorOperatorFunction(source) {
                var operator = new CatchOperator(selector), caught = source.lift(operator);
                return operator.caught = caught;
            };
        }
        var CatchOperator = /* */ function() {
            function CatchOperator(selector) {
                this.selector = selector;
            }
            return CatchOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));
            }, CatchOperator;
        }(), CatchSubscriber = /* */ function(_super) {
            function CatchSubscriber(destination, selector, caught) {
                var _this = _super.call(this, destination) || this;
                return _this.selector = selector, _this.caught = caught, _this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(CatchSubscriber, _super), CatchSubscriber.prototype.error = function(err) {
                if (!this.isStopped) {
                    var result = void 0;
                    try {
                        result = this.selector(err, this.caught);
                    } catch (err2) {
                        return void _super.prototype.error.call(this, err2);
                    }
                    this._unsubscribeAndRecycle();
                    var innerSubscriber = new _InnerSubscriber__WEBPACK_IMPORTED_MODULE_2__.a(this, void 0, void 0);
                    this.add(innerSubscriber), Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_3__.a)(this, result, void 0, void 0, innerSubscriber);
                }
            }, CatchSubscriber;
        }(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__.a);
    }, 
    /* 172 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js
                var tslib_es6 = __webpack_require__(3), nextHandle = 1, tasksByHandle = {};
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/util/Immediate.js
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */        function runIfPresent(handle) {
            var cb = tasksByHandle[handle];
            cb && cb();
        }
        var Immediate_setImmediate = function(cb) {
            var handle = nextHandle++;
            return tasksByHandle[handle] = cb, Promise.resolve().then(function() {
                return runIfPresent(handle);
            }), handle;
        }, Immediate_clearImmediate = function(handle) {
            delete tasksByHandle[handle];
        }, AsapAction_AsapAction = /* */ function(_super) {
            function AsapAction(scheduler, work) {
                var _this = _super.call(this, scheduler, work) || this;
                return _this.scheduler = scheduler, _this.work = work, _this;
            }
            return tslib_es6.a(AsapAction, _super), AsapAction.prototype.requestAsyncId = function(scheduler, id, delay) {
                return void 0 === delay && (delay = 0), null !== delay && 0 < delay ? _super.prototype.requestAsyncId.call(this, scheduler, id, delay) : (scheduler.actions.push(this), 
                scheduler.scheduled || (scheduler.scheduled = Immediate_setImmediate(scheduler.flush.bind(scheduler, null))));
            }, AsapAction.prototype.recycleAsyncId = function(scheduler, id, delay) {
                if (void 0 === delay && (delay = 0), null !== delay && 0 < delay || null === delay && 0 < this.delay) return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
                0 === scheduler.actions.length && (Immediate_clearImmediate(id), scheduler.scheduled = void 0);
            }, AsapAction;
        }(__webpack_require__(68).a), AsapScheduler_AsapScheduler = /* */ function(_super) {
            function AsapScheduler() {
                return null !== _super && _super.apply(this, arguments) || this;
            }
            return tslib_es6.a(AsapScheduler, _super), AsapScheduler.prototype.flush = function(action) {
                this.active = !0, this.scheduled = void 0;
                var error, actions = this.actions, index = -1, count = actions.length;
                action = action || actions.shift();
                do {
                    if (error = action.execute(action.state, action.delay)) break;
                } while (++index < count && (action = actions.shift()));
                if (this.active = !1, error) {
                    for (;++index < count && (action = actions.shift()); ) action.unsubscribe();
                    throw error;
                }
            }, AsapScheduler;
        }(__webpack_require__(67).a);
        //# sourceMappingURL=Immediate.js.map
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/scheduler/AsyncAction.js + 1 modules
                //# sourceMappingURL=AsapScheduler.js.map
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/scheduler/asap.js
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return asap;
        });
        /** PURE_IMPORTS_START _AsapAction,_AsapScheduler PURE_IMPORTS_END */
        var asap = /* */ new AsapScheduler_AsapScheduler(AsapAction_AsapAction);
        //# sourceMappingURL=asap.js.map
        /***/    }, 
    /* 173 */ 
    /* 174 */ , 
    /* 175 */ , 
    /* 176 */
    /***/ , 
    /* 176 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return startWith;
        });
        /* harmony import */ var _observable_fromArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(36), _observable_scalar__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(87), _observable_empty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(38), _observable_concat__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(76), _util_isScheduler__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(40);
        /* harmony import */        
        /** PURE_IMPORTS_START _observable_fromArray,_observable_scalar,_observable_empty,_observable_concat,_util_isScheduler PURE_IMPORTS_END */
        function startWith() {
            for (var array = [], _i = 0; _i < arguments.length; _i++) array[_i] = arguments[_i];
            return function(source) {
                var scheduler = array[array.length - 1];
                Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_4__.a)(scheduler) ? array.pop() : scheduler = null;
                var len = array.length;
                return 1 !== len || scheduler ? 0 < len ? Object(_observable_concat__WEBPACK_IMPORTED_MODULE_3__.a)(Object(_observable_fromArray__WEBPACK_IMPORTED_MODULE_0__.a)(array, scheduler), source) : Object(_observable_concat__WEBPACK_IMPORTED_MODULE_3__.a)(Object(_observable_empty__WEBPACK_IMPORTED_MODULE_2__.b)(scheduler), source) : Object(_observable_concat__WEBPACK_IMPORTED_MODULE_3__.a)(Object(_observable_scalar__WEBPACK_IMPORTED_MODULE_1__.a)(array[0]), source);
            };
        }
        //# sourceMappingURL=startWith.js.map
        /***/    }, 
    /* 177 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return interval;
        });
        /* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6), _scheduler_async__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(41), _util_isNumeric__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(73);
        /* harmony import */        
        /** PURE_IMPORTS_START _Observable,_scheduler_async,_util_isNumeric PURE_IMPORTS_END */
        function interval(period, scheduler) {
            return void 0 === period && (period = 0), void 0 === scheduler && (scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_1__.a), 
            (!Object(_util_isNumeric__WEBPACK_IMPORTED_MODULE_2__.a)(period) || period < 0) && (period = 0), 
            scheduler && "function" == typeof scheduler.schedule || (scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_1__.a), 
            new _Observable__WEBPACK_IMPORTED_MODULE_0__.a(function(subscriber) {
                return subscriber.add(scheduler.schedule(dispatch, period, {
                    subscriber: subscriber,
                    counter: 0,
                    period: period
                })), subscriber;
            });
        }
        function dispatch(state) {
            var subscriber = state.subscriber, counter = state.counter, period = state.period;
            subscriber.next(counter), this.schedule({
                subscriber: subscriber,
                counter: counter + 1,
                period: period
            }, period);
        }
        //# sourceMappingURL=interval.js.map
        /***/    }, 
    /* 178 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return takeUntil;
        });
        /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3), _OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(25), _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(24);
        /* harmony import */        
        /** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
        function takeUntil(notifier) {
            return function(source) {
                return source.lift(new TakeUntilOperator(notifier));
            };
        }
        var TakeUntilOperator = /* */ function() {
            function TakeUntilOperator(notifier) {
                this.notifier = notifier;
            }
            return TakeUntilOperator.prototype.call = function(subscriber, source) {
                var takeUntilSubscriber = new TakeUntilSubscriber(subscriber), notifierSubscription = Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__.a)(takeUntilSubscriber, this.notifier);
                return notifierSubscription && !takeUntilSubscriber.seenValue ? (takeUntilSubscriber.add(notifierSubscription), 
                source.subscribe(takeUntilSubscriber)) : takeUntilSubscriber;
            }, TakeUntilOperator;
        }(), TakeUntilSubscriber = /* */ function(_super) {
            function TakeUntilSubscriber(destination) {
                var _this = _super.call(this, destination) || this;
                return _this.seenValue = !1, _this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(TakeUntilSubscriber, _super), TakeUntilSubscriber.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
                this.seenValue = !0, this.complete();
            }, TakeUntilSubscriber.prototype.notifyComplete = function() {}, TakeUntilSubscriber;
        }(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__.a);
    }, 
    /* 179 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return combineLatest;
        });
        /* unused harmony export CombineLatestOperator */
        /* unused harmony export CombineLatestSubscriber */
        /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3), _util_isScheduler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(40), _util_isArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(45), _OuterSubscriber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(25), _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(24), _fromArray__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(36), NONE = {};
        /* harmony import */        function combineLatest() {
            for (var observables = [], _i = 0; _i < arguments.length; _i++) observables[_i] = arguments[_i];
            var resultSelector = null, scheduler = null;
            return Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_1__.a)(observables[observables.length - 1]) && (scheduler = observables.pop()), 
            "function" == typeof observables[observables.length - 1] && (resultSelector = observables.pop()), 
            1 === observables.length && Object(_util_isArray__WEBPACK_IMPORTED_MODULE_2__.a)(observables[0]) && (observables = observables[0]), 
            Object(_fromArray__WEBPACK_IMPORTED_MODULE_5__.a)(observables, scheduler).lift(new CombineLatestOperator(resultSelector));
        }
        var CombineLatestOperator = /* */ function() {
            function CombineLatestOperator(resultSelector) {
                this.resultSelector = resultSelector;
            }
            return CombineLatestOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new CombineLatestSubscriber(subscriber, this.resultSelector));
            }, CombineLatestOperator;
        }(), CombineLatestSubscriber = /* */ function(_super) {
            function CombineLatestSubscriber(destination, resultSelector) {
                var _this = _super.call(this, destination) || this;
                return _this.resultSelector = resultSelector, _this.active = 0, _this.values = [], 
                _this.observables = [], _this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(CombineLatestSubscriber, _super), CombineLatestSubscriber.prototype._next = function(observable) {
                this.values.push(NONE), this.observables.push(observable);
            }, CombineLatestSubscriber.prototype._complete = function() {
                var observables = this.observables, len = observables.length;
                if (0 === len) this.destination.complete(); else {
                    this.active = len, this.toRespond = len;
                    for (var i = 0; i < len; i++) {
                        var observable = observables[i];
                        this.add(Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_4__.a)(this, observable, observable, i));
                    }
                }
            }, CombineLatestSubscriber.prototype.notifyComplete = function(unused) {
                0 == (this.active -= 1) && this.destination.complete();
            }, CombineLatestSubscriber.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
                var values = this.values, oldVal = values[outerIndex], toRespond = this.toRespond ? oldVal === NONE ? --this.toRespond : this.toRespond : 0;
                values[outerIndex] = innerValue, 0 === toRespond && (this.resultSelector ? this._tryResultSelector(values) : this.destination.next(values.slice()));
            }, CombineLatestSubscriber.prototype._tryResultSelector = function(values) {
                var result;
                try {
                    result = this.resultSelector.apply(this, values);
                } catch (err) {
                    return void this.destination.error(err);
                }
                this.destination.next(result);
            }, CombineLatestSubscriber;
        }(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_3__.a);
    }, 
    /* 180 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return isKnownError;
        });
        /* harmony import */ var _error_codes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21);
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Whether the error given is a ICustomError.
 * @param {Error} error
 * @returns {Boolean}
 */        function isKnownError(error) {
            return !!error && !!error.type && 0 <= Object.keys(_error_codes__WEBPACK_IMPORTED_MODULE_0__.b).indexOf(error.type);
        }
        /***/    }, 
    /* 181 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return timer;
        });
        /* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6), _scheduler_async__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(41), _util_isNumeric__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(73), _util_isScheduler__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(40);
        /* harmony import */        
        /** PURE_IMPORTS_START _Observable,_scheduler_async,_util_isNumeric,_util_isScheduler PURE_IMPORTS_END */
        function timer(dueTime, periodOrScheduler, scheduler) {
            void 0 === dueTime && (dueTime = 0);
            var period = -1;
            return Object(_util_isNumeric__WEBPACK_IMPORTED_MODULE_2__.a)(periodOrScheduler) ? period = Number(periodOrScheduler) < 1 ? 1 : Number(periodOrScheduler) : Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_3__.a)(periodOrScheduler) && (scheduler = periodOrScheduler), 
            Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_3__.a)(scheduler) || (scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_1__.a), 
            new _Observable__WEBPACK_IMPORTED_MODULE_0__.a(function(subscriber) {
                var due = Object(_util_isNumeric__WEBPACK_IMPORTED_MODULE_2__.a)(dueTime) ? dueTime : +dueTime - scheduler.now();
                return scheduler.schedule(dispatch, due, {
                    index: 0,
                    period: period,
                    subscriber: subscriber
                });
            });
        }
        function dispatch(state) {
            var index = state.index, period = state.period, subscriber = state.subscriber;
            if (subscriber.next(index), !subscriber.closed) {
                if (-1 === period) return subscriber.complete();
                state.index = index + 1, this.schedule(state, period);
            }
        }
        //# sourceMappingURL=timer.js.map
        /***/    }, 
    /* 182 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        function _assertThisInitialized(self) {
            if (void 0 === self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return self;
        }
        function _inheritsLoose(subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype), (subClass.prototype.constructor = subClass).__proto__ = superClass;
        }
        function _wrapNativeSuper(Class) {
            var _cache = "function" == typeof Map ? new Map() : void 0;
            return (_wrapNativeSuper = function _wrapNativeSuper(Class) {
                if (null === Class || !_isNativeFunction(Class)) return Class;
                if ("function" != typeof Class) throw new TypeError("Super expression must either be null or a function");
                if (void 0 !== _cache) {
                    if (_cache.has(Class)) return _cache.get(Class);
                    _cache.set(Class, Wrapper);
                }
                function Wrapper() {
                    return _construct(Class, arguments, _getPrototypeOf(this).constructor);
                }
                return Wrapper.prototype = Object.create(Class.prototype, {
                    constructor: {
                        value: Wrapper,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }), _setPrototypeOf(Wrapper, Class);
            })(Class);
        }
        function isNativeReflectConstruct() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function() {})), 
                !0;
            } catch (e) {
                return !1;
            }
        }
        function _construct(Parent, args, Class) {
            return (_construct = isNativeReflectConstruct() ? Reflect.construct : function _construct(Parent, args, Class) {
                var a = [ null ];
                a.push.apply(a, args);
                var instance = new (Function.bind.apply(Parent, a))();
                return Class && _setPrototypeOf(instance, Class.prototype), instance;
            }).apply(null, arguments);
        }
        function _isNativeFunction(fn) {
            return -1 !== Function.toString.call(fn).indexOf("[native code]");
        }
        function _setPrototypeOf(o, p) {
            return (_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
                return o.__proto__ = p, o;
            })(o, p);
        }
        function _getPrototypeOf(o) {
            return (_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
                return o.__proto__ || Object.getPrototypeOf(o);
            })(o);
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Errors linked to the XHR implentation done in the RxPlayer.
 *
 * @class RequestError
 * @extends Error
 */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return RequestError;
        });
        var RequestError = 
        /* */
        function(_Error) {
            /**
   * @param {XMLHttpRequest} xhr
   * @param {string} url
   * @param {string} type
   */
            function RequestError(xhr, url, type) {
                var _this;
                return _this = _Error.call(this) || this, // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class
                Object.setPrototypeOf(_assertThisInitialized(_this), RequestError.prototype), _this.name = "RequestError", 
                _this.url = url, _this.xhr = xhr, _this.status = xhr.status, _this.type = type, 
                _this.message = type, _this;
            }
            return _inheritsLoose(RequestError, _Error), RequestError;
        }(_wrapNativeSuper(Error));
        /***/    }, 
    /* 183 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "b", function() {
            return getMDHDTimescale;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() {
            return getTrackFragmentDecodeTime;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return getDurationFromTrun;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() {
            return getSegmentsFromSidx;
        });
        /* unused harmony export patchPssh */
        /* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0), _utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__ = (__webpack_require__(16), 
        __webpack_require__(1)), _read__WEBPACK_IMPORTED_MODULE_4__ = (__webpack_require__(136), 
        __webpack_require__(111));
        /* harmony import */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Find the right box in an isobmff.
 * @param {Uint8Array} buf - the isobmff
 * @param {Number} wantedName
 * @returns {Number} - Offset where the box begins. -1 if not found.
 */
        function findBox(buf, wantedName) {
            for (var len = buf.length, i = 0; i + 8 < len; ) {
                var size = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__.c)(buf, i);
                if (size <= 0) return _log__WEBPACK_IMPORTED_MODULE_0__.a.error("ISOBMFF: size out of range"), 
                -1;
                if (Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__.c)(buf, i + 4) === wantedName) return i + size <= len ? i : (_log__WEBPACK_IMPORTED_MODULE_0__.a.error("ISOBMFF: box out of range"), 
                -1);
                i += size;
            }
            return -1;
        }
        /**
 * Parse the sidx part (segment index) of the isobmff.
 * Returns null if not found.
 *
 * @param {Uint8Array} buf
 * @param {Number} initialOffset
 * @returns {Object|null} {Array.<Object>} - Informations about each subsegment.
 * Contains those keys:
 *   - time {Number}: starting _presentation time_ for the subsegment,
 *     timescaled
 *   - duration {Number}: duration of the subsegment, timescaled
 *   - timescale {Number}: the timescale in which the time and duration are set
 *   - count {Number}: always at 0
 *   - range {Array.<Number>}: first and last bytes in the media file
 *     from the anchor point (first byte after the sidx box) for the
 *     concerned subsegment.
 */        function getSegmentsFromSidx(buf, initialOffset) {
            var index = findBox(buf, 1936286840
            /* "sidx" */);
            if (-1 === index) return null;
            var offset = initialOffset, size = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__.c)(buf, index), pos = index + 
            /* size */
            4 + 
            /* name */
            4, version = buf[pos];
            pos += 8;
            var time, timescale = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__.c)(buf, pos);
            if (pos += 4, 0 === version) time = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__.c)(buf, pos), 
            pos += 4, offset += Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__.c)(buf, pos) + size, 
            pos += 4; else {
                if (1 !== version) return null;
                time = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__.d)(buf, pos), pos += 8, 
                offset += Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__.d)(buf, pos) + size, 
                pos += 8;
            }
            var segments = [];
            /* reserved(16) */
            /* reference_count(16) */            pos += 2;
            var count = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__.a)(buf, pos);
            for (pos += 2; 0 <= --count; ) {
                /* reference_type(1) */
                /* reference_size(31) */
                /* segment_duration(32) */
                /* sap..(32) */
                var refChunk = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__.c)(buf, pos);
                pos += 4;
                var refSize = 2147483647 & refChunk;
                // when set to 1 indicates that the reference is to a sidx, else to media
                if (1 === (2147483648 & refChunk) >>> 31) throw new Error("not implemented");
                var duration = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__.c)(buf, pos);
                pos += 4, // let sapChunk = be4toi(buf, pos + 8);
                pos += 4, // TODO(pierre): handle sap
                // let startsWithSap = (sapChunk & 0x80000000) >>> 31;
                // let sapType = (sapChunk & 0x70000000) >>> 28;
                // let sapDelta = sapChunk & 0x0FFFFFFF;
                segments.push({
                    time: time,
                    duration: duration,
                    count: 0,
                    timescale: timescale,
                    range: [ offset, offset + refSize - 1 ]
                }), time += duration, offset += refSize;
            }
            return segments;
        }
        /**
 * Parse track Fragment Decode Time to get a precize initial time for this
 * segment (in the media timescale).
 * Stops at the first tfdt encountered from the beginning of the file.
 * Returns this time. -1 if not found.
 * @param {Uint8Array} buffer
 * @returns {Number}
 */        function getTrackFragmentDecodeTime(buffer) {
            var traf = Object(_read__WEBPACK_IMPORTED_MODULE_4__.c)(buffer);
            if (!traf) return -1;
            var index = findBox(traf, 1952867444
            /* tfdt */);
            if (-1 === index) return -1;
            var pos = index + 
            /* size */
            4 + 
            /* name */
            4, version = traf[pos];
            return pos += 4, 1 < version ? -1 : version ? Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__.d)(traf, pos) : Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__.c)(traf, pos);
        }
        /**
 * @param {Uint8Array} traf
 * @returns {number}
 */        function getDefaultDurationFromTFHDInTRAF(traf) {
            var index = findBox(traf, 1952868452
            /* tfhd */);
            if (-1 === index) return -1;
            var pos = index + 
            /* size */
            4 + 
            /* name */
            4 + 
            /* version */
            1, flags = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__.b)(traf, pos);
            return pos += 3, 8 & flags ? (pos += 4, 1 & flags && (pos += 8), 2 & flags && (pos += 4), 
            Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__.c)(traf, pos)) : -1;
        }
        /**
 * @param {Uint8Array} buffer
 * @returns {number}
 */        function getDurationFromTrun(buffer) {
            var traf = Object(_read__WEBPACK_IMPORTED_MODULE_4__.c)(buffer);
            if (!traf) return -1;
            var index = findBox(traf, 1953658222
            /* trun */);
            if (-1 === index) return -1;
            var pos = index + 
            /* size */
            4 + 
            /* name */
            4, version = traf[pos];
            if (pos += 1, 1 < version) return -1;
            var flags = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__.b)(traf, pos);
            pos += 3;
            var hasSampleDuration = 256 & flags, defaultDuration = 0;
            if (!hasSampleDuration && (defaultDuration = getDefaultDurationFromTFHDInTRAF(traf)) < 0) return -1;
            var hasDataOffset = 1 & flags, hasFirstSampleFlags = 4 & flags, hasSampleSize = 512 & flags, hasSampleFlags = 1024 & flags, hasSampleCompositionOffset = 2048 & flags, sampleCounts = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__.c)(traf, pos);
            pos += 4, hasDataOffset && (pos += 4), hasFirstSampleFlags && (pos += 4);
            for (var i = sampleCounts, duration = 0; i--; ) hasSampleDuration ? (duration += Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__.c)(traf, pos), 
            pos += 4) : duration += defaultDuration, hasSampleSize && (pos += 4), hasSampleFlags && (pos += 4), 
            hasSampleCompositionOffset && (pos += 4);
            return duration;
        }
        /**
 * Get various informations from a movie header box. Found in init segments.
 * null if not found or not parsed.
 *
 * This timescale is the default timescale used for segments.
 * @param {Uint8Array} buffer
 * @returns {Number}
 */        function getMDHDTimescale(buffer) {
            var mdia = Object(_read__WEBPACK_IMPORTED_MODULE_4__.b)(buffer);
            if (!mdia) return -1;
            var index = findBox(mdia, 1835296868
            /* "mdhd" */);
            if (-1 === index) return -1;
            var pos = index + 
            /* size */
            4 + 
            /* name */
            4, version = mdia[pos];
            return pos += 4, 1 === version ? (pos += 16, Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__.c)(mdia, pos)) : 0 === version ? (pos += 8, 
            Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__.c)(mdia, pos)) : -1;
        }
        /**
 * Returns a PSSH box from a systemId and private data.
 * @param {Array.<Object>} pssList - The content protections under the form of
 * object containing two properties:
 *   - systemId {string}: The uuid code. Should only contain 32 hexadecimal
 *     numbers and hyphens
 *   - privateData {Uint8Array} private data associated.
 * @returns {Uint8Array}
 */    }, 
    /* 184 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return switchMapTo;
        });
        /* harmony import */ var _switchMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(119);
        /** PURE_IMPORTS_START _switchMap PURE_IMPORTS_END */        function switchMapTo(innerObservable, resultSelector) {
            return resultSelector ? Object(_switchMap__WEBPACK_IMPORTED_MODULE_0__.a)(function() {
                return innerObservable;
            }, resultSelector) : Object(_switchMap__WEBPACK_IMPORTED_MODULE_0__.a)(function() {
                return innerObservable;
            });
        }
        //# sourceMappingURL=switchMapTo.js.map
        /***/    }
    /******/ ]);
});