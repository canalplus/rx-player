!function webpackUniversalModuleDefinition(root, factory) {
    "object" == typeof exports && "object" == typeof module ? module.exports = factory() : "function" == typeof define && define.amd ? define([], factory) : "object" == typeof exports ? exports.RxPlayer = factory() : root.RxPlayer = factory();
}(window, function() {
    /******/
    return function(modules) {
        // webpackBootstrap
        /******/ // The module cache
        /******/ var installedModules = {};
        /******/
        /******/ // The require function
        /******/        function __webpack_require__(moduleId) {
            /******/
            /******/ // Check if module is in cache
            /******/ if (installedModules[moduleId]) 
            /******/ return installedModules[moduleId].exports;
            /******/
            /******/ // Create a new module (and put it into the cache)
            /******/            var module = installedModules[moduleId] = {
                /******/ i: moduleId,
                /******/ l: !1,
                /******/ exports: {}
                /******/            };
            /******/
            /******/ // Execute the module function
            /******/            
            /******/
            /******/ // Return the exports of the module
            /******/ return modules[moduleId].call(module.exports, module, module.exports, __webpack_require__), 
            /******/
            /******/ // Flag the module as loaded
            /******/ module.l = !0, module.exports;
            /******/        }
        /******/
        /******/
        /******/ // expose the modules object (__webpack_modules__)
        /******/        
        /******/
        /******/
        /******/ // Load entry module and return exports
        /******/ return __webpack_require__.m = modules, 
        /******/
        /******/ // expose the module cache
        /******/ __webpack_require__.c = installedModules, 
        /******/
        /******/ // define getter function for harmony exports
        /******/ __webpack_require__.d = function(exports, name, getter) {
            /******/ __webpack_require__.o(exports, name) || 
            /******/ Object.defineProperty(exports, name, {
                enumerable: !0,
                get: getter
            })
            /******/;
        }, 
        /******/
        /******/ // define __esModule on exports
        /******/ __webpack_require__.r = function(exports) {
            /******/ "undefined" != typeof Symbol && Symbol.toStringTag && 
            /******/ Object.defineProperty(exports, Symbol.toStringTag, {
                value: "Module"
            })
            /******/ , Object.defineProperty(exports, "__esModule", {
                value: !0
            });
        }, 
        /******/
        /******/ // create a fake namespace object
        /******/ // mode & 1: value is a module id, require it
        /******/ // mode & 2: merge all properties of value into the ns
        /******/ // mode & 4: return value when already ns object
        /******/ // mode & 8|1: behave like require
        /******/ __webpack_require__.t = function(value, mode) {
            /******/ if (
            /******/ 1 & mode && (value = __webpack_require__(value)), 8 & mode) return value;
            /******/            if (4 & mode && "object" == typeof value && value && value.__esModule) return value;
            /******/            var ns = Object.create(null);
            /******/            
            /******/ if (__webpack_require__.r(ns), 
            /******/ Object.defineProperty(ns, "default", {
                enumerable: !0,
                value: value
            }), 2 & mode && "string" != typeof value) for (var key in value) __webpack_require__.d(ns, key, function(key) {
                return value[key];
            }.bind(null, key));
            /******/            return ns;
            /******/        }, 
        /******/
        /******/ // getDefaultExport function for compatibility with non-harmony modules
        /******/ __webpack_require__.n = function(module) {
            /******/ var getter = module && module.__esModule ? 
            /******/ function getDefault() {
                return module.default;
            } : 
            /******/ function getModuleExports() {
                return module;
            };
            /******/            
            /******/ return __webpack_require__.d(getter, "a", getter), getter;
            /******/        }, 
        /******/
        /******/ // Object.prototype.hasOwnProperty.call
        /******/ __webpack_require__.o = function(object, property) {
            return Object.prototype.hasOwnProperty.call(object, property);
        }, 
        /******/
        /******/ // __webpack_public_path__
        /******/ __webpack_require__.p = "", __webpack_require__(__webpack_require__.s = 104);
        /******/    }
    /************************************************************************/
    /******/ ([ 
    /* 0 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // EXTERNAL MODULE: ./src/utils/noop.ts
                var noop = __webpack_require__(29);
        // CONCATENATED MODULE: ./src/utils/logger.ts
                function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        var DEFAULT_LOG_LEVEL = "NONE", log_logger = new (function() {
            function Logger() {
                _classCallCheck(this, Logger), this.error = noop.a, this.warn = noop.a, this.info = noop.a, 
                this.debug = noop.a, this.LEVELS = {
                    NONE: 0,
                    ERROR: 1,
                    WARNING: 2,
                    INFO: 3,
                    DEBUG: 4
                }, this.currentLevel = DEFAULT_LOG_LEVEL;
            }
            return Logger.prototype.setLevel = function setLevel(levelStr) {
                var level = void 0, foundLevel = this.LEVELS[levelStr];
                foundLevel ? (
                // levelStr is a ILoggerLevel
                level = foundLevel, this.currentLevel = levelStr) : (
                // either 0 or not found
                level = 0, this.currentLevel = "NONE")
                /* tslint:disable no-invalid-this */
                /* tslint:disable no-console */ , this.error = level >= this.LEVELS.ERROR ? console.error.bind(console) : noop.a, 
                this.warn = level >= this.LEVELS.WARNING ? console.warn.bind(console) : noop.a, 
                this.info = level >= this.LEVELS.INFO ? console.info.bind(console) : noop.a, this.debug = level >= this.LEVELS.DEBUG ? console.log.bind(console) : noop.a;
            }, Logger.prototype.getLevel = function getLevel() {
                return this.currentLevel;
            }, Logger;
        }())();
        __webpack_exports__.a = log_logger;
    }, 
    /* 1 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "p", function() {
            return strToBytes;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() {
            return bytesToStr;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() {
            return bytesToUTF16Str;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() {
            return hexToBytes;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() {
            return bytesToHex;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() {
            return concat;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return be2toi;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() {
            return be3toi;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() {
            return be4toi;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() {
            return be8toi;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() {
            return le2toi;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "o", function() {
            return le4toi;
        }), 
        /* unused harmony export le8toi */
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() {
            return itobe2;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() {
            return itobe4;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() {
            return itobe8;
        }), 
        /* unused harmony export itole2 */
        /* unused harmony export itole4 */
        /* unused harmony export itole8 */
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() {
            return guidToUuid;
        });
        /* unused harmony export toBase64URL */
        /* harmony import */ var _assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9);
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Returns Uint8Array from UTF16 string.
 * /!\ Take only the first byte from each UTF16 code.
 * @param {string} str
 * @returns {Uint8Array}
 */        function strToBytes(str) {
            for (var len = str.length, arr = new Uint8Array(len), i = 0; i < len; i++) arr[i] = 255 & str.charCodeAt(i);
            return arr;
        }
        /**
 * construct string from unicode values.
 * /!\ does not support non-UCS-2 values
 * @param {Uint8Array} bytes
 * @returns {string}
 */        function bytesToStr(bytes) {
            return String.fromCharCode.apply(null, bytes);
        }
        /**
 * construct string from unicode values.
 * Only use every other byte for each UTF-16 character.
 * /!\ does not support non-UCS-2 values
 * @param {Uint8Array} bytes
 * @returns {string}
 */        function bytesToUTF16Str(bytes) {
            for (var str = "", len = bytes.length, i = 0; i < len; i += 2) str += String.fromCharCode(bytes[i]);
            return str;
        }
        /**
 * Convert hex codes in a string form into the corresponding bytes.
 * @param {string} str
 * @returns {Uint8Array}
 * @throws TypeError - str.length is odd
 */        function hexToBytes(str) {
            for (var len = str.length, arr = new Uint8Array(len / 2), i = 0, j = 0; i < len; i += 2, 
            j++) arr[j] = 255 & parseInt(str.substr(i, 2), 16);
            return arr;
        }
        /**
 * Convert bytes into the corresponding hex string, with the possibility
 * to add a separator.
 * @param {Uint8Array} bytes
 * @param {string} [sep=""] - separator. Separate each two hex character.
 * @returns {string}
 */        function bytesToHex(bytes) {
            for (var sep = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "", hex = "", i = 0; i < bytes.byteLength; i++) hex += (bytes[i] >>> 4).toString(16), 
            hex += (15 & bytes[i]).toString(16), sep.length && i < bytes.byteLength - 1 && (hex += sep);
            return hex;
        }
        /**
 * Returns a Uint8Array from the arguments given, in order:
 *   - if the next argument given is a number N set the N next bytes to 0.
 *   - else set the next bytes to the argument given.
 * @param {...(Number|Uint8Array)} args
 * @returns {Uint8Array}
 */        function concat() {
            for (var l = arguments.length, i = -1, len = 0, arg = void 0; ++i < l; ) len += "number" == typeof (arg = arguments.length <= i ? void 0 : arguments[i]) ? arg : arg.length;
            var arr = new Uint8Array(len), offset = 0;
            for (i = -1; ++i < l; ) "number" == typeof (arg = arguments.length <= i ? void 0 : arguments[i]) ? offset += arg : arg.length > 0 && (arr.set(arg, offset), 
            offset += arg.length);
            return arr;
        }
        /**
 * Translate groups of 2 big-endian bytes to Integer (from 0 up to 65535).
 * @param {Uint8Array} bytes
 * @param {Number} offset - The offset (from the start of the given array)
 * @returns {Number}
 */        function be2toi(bytes, offset) {
            return (bytes[offset + 0] << 8) + (bytes[offset + 1] << 0);
        }
        /**
 * Translate groups of 3 big-endian bytes to Integer.
 * @param {Uint8Array} bytes
 * @param {Number} offset - The offset (from the start of the given array)
 * @returns {Number}
 */        function be3toi(bytes, offset) {
            return 65536 * bytes[offset + 0] + 256 * bytes[offset + 1] + bytes[offset + 2];
        }
        /**
 * Translate groups of 4 big-endian bytes to Integer.
 * @param {Uint8Array} bytes
 * @param {Number} offset - The offset (from the start of the given array)
 * @returns {Number}
 */        function be4toi(bytes, offset) {
            return 16777216 * bytes[offset + 0] + 65536 * bytes[offset + 1] + 256 * bytes[offset + 2] + bytes[offset + 3];
        }
        /**
 * Translate groups of 8 big-endian bytes to Integer.
 * @param {Uint8Array} bytes
 * @param {Number} offset - The offset (from the start of the given array)
 * @returns {Number}
 */        function be8toi(bytes, offset) {
            return 4294967296 * (16777216 * bytes[offset + 0] + 65536 * bytes[offset + 1] + 256 * bytes[offset + 2] + bytes[offset + 3]) + 16777216 * bytes[offset + 4] + 65536 * bytes[offset + 5] + 256 * bytes[offset + 6] + bytes[offset + 7];
        }
        /**
 * Translate Integer (from 0 up to 65535) to a Uint8Array of length 2 of
 * the corresponding big-endian bytes.
 * @param {Number} num
 * @returns {Uint8Array}
 */        function itobe2(num) {
            return new Uint8Array([ num >>> 8 & 255, 255 & num ]);
        }
        /**
 * Translate Integer to a Uint8Array of length 4 of the corresponding big-endian
 * bytes.
 * @param {Number} num
 * @returns {Uint8Array}
 */        function itobe4(num) {
            return new Uint8Array([ num >>> 24 & 255, num >>> 16 & 255, num >>> 8 & 255, 255 & num ]);
        }
        /**
 * Translate Integer to a Uint8Array of length 8 of the corresponding big-endian
 * bytes.
 * /!\ If the top-most bytes are set, this might go over MAX_SAFE_INTEGER, thus
 * leading to a "bad" value.
 * @param {Number} num
 * @returns {Uint8Array}
 */        function itobe8(num) {
            var l = num % 4294967296, h = (num - l) / 4294967296;
            return new Uint8Array([ h >>> 24 & 255, h >>> 16 & 255, h >>> 8 & 255, 255 & h, l >>> 24 & 255, l >>> 16 & 255, l >>> 8 & 255, 255 & l ]);
        }
        /**
 * Translate groups of 2 little-endian bytes to Integer (from 0 up to 65535).
 * @param {Uint8Array} bytes
 * @param {Number} offset - The offset (from the start of the given array)
 * @returns {Number}
 */        function le2toi(bytes, offset) {
            return (bytes[offset + 0] << 0) + (bytes[offset + 1] << 8);
        }
        /**
 * Translate groups of 4 little-endian bytes to Integer.
 * @param {Uint8Array} bytes
 * @param {Number} offset - The offset (from the start of the given array)
 * @returns {Number}
 */        function le4toi(bytes, offset) {
            return bytes[offset + 0] + 256 * bytes[offset + 1] + 65536 * bytes[offset + 2] + 16777216 * bytes[offset + 3];
        }
        /**
 * Translate groups of 8 little-endian bytes to Integer.
 * @param {Uint8Array} bytes
 * @param {Number} offset - The offset (from the start of the given array)
 * @returns {Number}
 */        
        /**
 * @param {string} uuid
 * @returns {string}
 * @throws AssertionError - The uuid length is not 16
 */
        function guidToUuid(uuid) {
            Object(_assert__WEBPACK_IMPORTED_MODULE_0__.b)(16 === uuid.length, "UUID length should be 16");
            var buf = strToBytes(uuid), p1A = buf[0], p1B = buf[1], p1C = buf[2], p1D = buf[3], p2A = buf[4], p2B = buf[5], p3A = buf[6], p3B = buf[7], p4 = buf.subarray(8, 10), p5 = buf.subarray(10, 16), ord = new Uint8Array(16);
            return ord[0] = p1D, ord[1] = p1C, ord[2] = p1B, ord[3] = p1A, // swap32 BE -> LE
            ord[4] = p2B, ord[5] = p2A, // swap16 BE -> LE
            ord[6] = p3B, ord[7] = p3A, // swap16 BE -> LE
            ord.set(p4, 8), ord.set(p5, 10), bytesToHex(ord);
        }
        /**
 * Creates a base-64 encoded ASCII string from a string of binary data, with
 * possible trailing equal sign(s) stripped.
 * @param {string} str
 * @returns {string}
 */    }, 
    /* 2 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return __extends;
        });
        /* unused harmony export __assign */
        /* unused harmony export __rest */
        /* unused harmony export __decorate */
        /* unused harmony export __param */
        /* unused harmony export __metadata */
        /* unused harmony export __awaiter */
        /* unused harmony export __generator */
        /* unused harmony export __exportStar */
        /* unused harmony export __values */
        /* unused harmony export __read */
        /* unused harmony export __spread */
        /* unused harmony export __await */
        /* unused harmony export __asyncGenerator */
        /* unused harmony export __asyncDelegator */
        /* unused harmony export __asyncValues */
        /* unused harmony export __makeTemplateObject */
        /* unused harmony export __importStar */
        /* unused harmony export __importDefault */
        /*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
        /* global Reflect, Promise */
        var extendStatics = Object.setPrototypeOf || {
            __proto__: []
        } instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
        };
        function __extends(d, b) {
            function __() {
                this.constructor = d;
            }
            extendStatics(d, b), d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, 
            new __());
        }
        Object.assign;
    }, 
    /* 3 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Configuration file for the whole player.
 * Feel free to tweak those values if you know what you're doing.
 *
 * Please not that you will need to re-build the whole project to take these
 * modifications into account.
 *
 * @type {Object}
 */
        /* harmony default export */        __webpack_exports__.a = {
            /**
   * Volume set on unMute if the volume is set to 0 and either:
   *   - mute has never been called before
   *   - mute has last been called while the volume was already set to 0 (either
   *     via setVolume, or a previous mute call)
   * @type {Number}
   */
            DEFAULT_UNMUTED_VOLUME: .1,
            /**
   * Can be either:
   *   - "native": Subtitles are all displayed in a <track> element
   *   - "html": Subtitles are all displayed in a <div> separated from the video
   *     element. Can be useful to display richer TTML subtitles, for example.
   * @type {Object|null}
   */
            // TODO ugly TypeScript workaround. Find better way
            DEFAULT_TEXT_TRACK_MODE: "native",
            /**
   * If set to true, video through loadVideo will auto play by default
   * @type {Boolean}
   */
            DEFAULT_AUTO_PLAY: !1,
            /**
   * If set to false, "native" subtitles (in a <track> element) will be hidden
   * by default.
   * @type {Boolean}
   */
            DEFAULT_SHOW_NATIVE_SUBTITLE: !0,
            /**
   * Default buffer goal in seconds.
   * Once enough content has been downloaded to fill the buffer up to
   * ``current position + DEFAULT_WANTED_BUFFER_AHEAD", we will stop downloading
   * content.
   * @type {Number}
   */
            DEFAULT_WANTED_BUFFER_AHEAD: 30,
            /**
   * Default max buffer size ahead of the current position in seconds.
   * The buffer _after_ this limit will be garbage collected.
   * Set to Infinity for no limit.
   * @type {Number}
   */
            DEFAULT_MAX_BUFFER_AHEAD: Infinity,
            /**
   * Default max buffer size ahead of the current position in seconds.
   * The buffer _before_ this limit will be garbage collected.
   * Set to Infinity for no limit.
   * @type {Number}
   */
            DEFAULT_MAX_BUFFER_BEHIND: Infinity,
            /**
   * Default bitrate ceils initially set as the first content begins.
   *
   * If no track is found with a bitrate inferior or equal to the
   * bitrate there, the one with the lowest bitrate will be taken instead.
   *
   * Set to 0 for the lowest bitrate, Infinity for the highest.
   *
   * These values are only useful for the first content played, as consecutive
   * play will always take the last set one.
   * @type {Object}
   */
            DEFAULT_INITIAL_BITRATES: {
                audio: 0,
                video: 0,
                other: 0
            },
            /* tslint:disable no-object-literal-type-assertion */
            /**
   * Default bitrate ceil initially set to dictate the maximum bitrate the
   * ABR manager can automatically switch to.
   *
   * If no track is found with a quality inferior or equal to the
   * bitrate there, the lowest bitrate will be taken instead.
   *
   * Set to Infinity to discard any limit in the ABR strategy.
   * @type {Object}
   */
            DEFAULT_MAX_BITRATES: {
                audio: Infinity,
                video: Infinity,
                other: Infinity
            },
            /* tslint:enable no-object-literal-type-assertion */
            /**
   * Delay after which, if the page is hidden, the user is considered inactive
   * on the current video.
   *
   * Allow to enforce specific optimizations when the page is not shown.
   * @see DEFAULT_THROTTLE_WHEN_HIDDEN
   * @type {Number}
   */
            INACTIVITY_DELAY: 6e4,
            /**
   * If true, if the player is in a "hidden" state for a delay specified by the
   * INACTIVITY DELAY config property, we throttle automatically to the video
   * representation with the lowest bitrate.
   * @type {Boolean}
   */
            DEFAULT_THROTTLE_WHEN_HIDDEN: !1,
            /**
   * If true, the video representations you can switch to in adaptive mode
   * are limited by the video element's width.
   *
   * Basically in that case, we won't switch to a video Representation with
   * a width higher than the current width of the video HTMLElement.
   * @type {Boolean}
   */
            DEFAULT_LIMIT_VIDEO_WIDTH: !1,
            /**
   * Default initial live gap considered if no presentation delay has been
   * suggested, in seconds.
   * @type {Number}
   */
            DEFAULT_LIVE_GAP: 10,
            /**
   * Default value for a manifest's suggested presentation delay if not
   * specified in the manifest.
   * @type {Object}
   */
            DEFAULT_SUGGESTED_PRESENTATION_DELAY: {
                SMOOTH: 10,
                DASH: 10
            },
            /**
   * Maximum time, in seconds, the player should automatically skip when stalled
   * because of a discontinuity in the downloaded range.
   * @type {Number}
   */
            DISCONTINUITY_THRESHOLD: 1,
            /**
   * Ratio used to know if an already loaded segment should be re-buffered.
   * We re-load the given segment if the current one times that ratio is
   * inferior to the new one.
   * @type {Number}
   */
            BITRATE_REBUFFERING_RATIO: 1.5,
            /**
   * Those are used when a "QuotaExceededError" error is received after
   * appending a new segment in the source buffer.
   *
   * This error can arise when the browser's buffer is considered full.
   * In this case, the player goes into manual garbage collection (GC) mode.
   * @type {Object}
   */
            BUFFER_GC_GAPS: {
                /**
     * _Low_ gap (from current position) from which the buffer will be _garbage
     * collected_ (read removed from the buffer) when a QuotaExceededError is
     * received.
     * In seconds.
     * @type {Number}
     */
                CALM: 240,
                /**
     * _High_ gap (from current position) from which the buffer will be _garbage
     * collected_ (read removed from the buffer) when a QuotaExceededError is
     * received, if the low one does not clean up any buffer.
     * In seconds.
     * @type {Number}
     */
                BEEFY: 30
            },
            /**
   * The default number of times a manifest request will be re-performed
   * when loaded/refreshed if the request finishes on an error which
   * justify an retry.
   *
   * Note that some errors do not use this counter:
   *   - if the error is not due to the xhr, no retry will be peformed
   *   - if the error is an HTTP error code, but not a 500-smthg or a 404, no
   *     retry will be performed.
   *   - if it has a high chance of being due to the user being offline, a
   *     separate counter is used (see DEFAULT_MAX_PIPELINES_RETRY_ON_OFFLINE).
   * @type Number
   */
            DEFAULT_MAX_MANIFEST_REQUEST_RETRY: 4,
            /**
   * The default number of times a pipeline request will be re-performed when
   * on error which justify a retry.
   *
   * Note that some errors do not use this counter:
   *   - if the error is not due to the xhr, no retry will be peformed
   *   - if the error is an HTTP error code, but not a 500-smthg or a 404, no
   *     retry will be performed.
   *   - if it has a high chance of being due to the user being offline, a
   *     separate counter is used (see DEFAULT_MAX_PIPELINES_RETRY_ON_OFFLINE).
   * @type Number
   */
            DEFAULT_MAX_PIPELINES_RETRY_ON_ERROR: 4,
            /**
   * Under some circonstances, we're able to tell that the user is offline (see
   * the compat files).
   * When this happens, and xhr requests fails due to an error event (you might
   * still be able to perform xhr offline, e.g. on localhost), you might want to
   * retry indefinitely or with a higher number of retry than if the error is
   * due to a CDN problem.
   *
   * A capped exponential backoff will still be used (like for an error code).
   * @type {Number}
   */
            DEFAULT_MAX_PIPELINES_RETRY_ON_OFFLINE: Infinity,
            /**
   * Initial backoff delay when a segment / manifest download fails, in
   * milliseconds.
   *
   * This delay will then grow exponentally by power of twos (200, 400, 800
   * etc.)
   *
   * Please note that this delay is not exact, as it will be fuzzed.
   * @type {Number}
   */
            INITIAL_BACKOFF_DELAY_BASE: 200,
            /**
   * Maximum backoff delay when a segment / manifest download fails, in
   * milliseconds.
   *
   * Please note that this delay is not exact, as it will be fuzzed.
   * @type {Number}
   */
            MAX_BACKOFF_DELAY_BASE: 3e3,
            /**
   * Minimum interval at which timeupdate events will be "constructed". This
   * variable is for the "regular" mediasource strategy (that is, not for the
   * directfile API.
   *
   * Those events are the base of various important mechanisms in the player:
   *   - set the clock for the buffer.
   *   - set the clock for the ABR strategy.
   *   - used to trigger positionUpdate events.
   *
   * This common logic is for performance reasons, as we call multiple browser's
   * APIs which are useful for most of these.
   *
   * Keep in mind this is the minimum interval. This logic will also be
   * triggered when various events of the media element are received.
   * @type {Number}
   */
            SAMPLING_INTERVAL_MEDIASOURCE: 1e3,
            /**
   * Same than SAMPLING_INTERVAL_MEDIASOURCE but for the directfile API.
   * @type {Number}
   */
            SAMPLING_INTERVAL_NO_MEDIASOURCE: 500,
            /**
   * Minimum number of bytes sampled before we trust the estimate.
   * If we have not sampled much data, our estimate may not be accurate
   * enough to trust.
   * If bytesSampled_ is less than minTotalBytes_, we use defaultEstimate_.
   * This specific value is based on experimentation.
   * @type {Number}
   */
            ABR_MINIMUM_TOTAL_BYTES: 35e4,
            /**
   * Minimum number of bytes, under which samples are discarded.
   * Our models do not include latency information, so connection startup time
   * (time to first byte) is considered part of the download time.
   * Because of this, we should ignore very small downloads which would cause
   * our estimate to be too low.
   * This specific value is based on experimentation.
   * @type {Number}
   */
            ABR_MINIMUM_CHUNK_SIZE: 16e3,
            /**
   * Factor with which is multiplied the bandwidth estimate when the ABR is in
   * starvation mode.
   * @type {Number}
   */
            ABR_STARVATION_FACTOR: .72,
            /**
   * Factor with which is multiplied the bandwidth estimate when the ABR is not
   * in starvation mode.
   * @type {Number}
   */
            ABR_REGULAR_FACTOR: .9,
            /**
   * If a SourceBuffer has less than ABR_STARVATION_GAP in seconds ahead of the
   * current position in its buffer, the ABR manager will go into starvation
   * mode.
   *
   * It gets out of starvation mode when the OUT_OF_STARVATION_GAP value is
   * reached.
   *
   * Under this starvation mode:
   *
   *   - the bandwidth considered will be a little lower than the one estimated
   *
   *   - the time the next important request take will be checked
   *     multiple times to detect when/if it takes too much time.
   *     If the request is considered too long, the bitrate will be hastily
   *     re-calculated from this single request.
   *
   * @type {Number}
   */
            ABR_STARVATION_GAP: 5,
            OUT_OF_STARVATION_GAP: 7,
            /**
   * Half-life, in seconds for a fastly-evolving exponential weighted moving
   * average.
   * The lower it is, the faster the ABR logic will react to the bandwidth
   * falling quickly.
   * Should be kept to a lower number than ABR_SLOW_EMA for coherency reasons.
   * @type {Number}
   */
            ABR_FAST_EMA: 2,
            /**
   * Half-life, in seconds for a slowly-evolving exponential weighted moving
   * average.
   * The lower it is, the faster the ABR logic is going to react to recent
   * bandwidth variation, on the higher and on the lower side.
   * Should be kept to a higher number than ABR_FAST_EMA for coherency reasons.
   * @type {Number}
   */
            ABR_SLOW_EMA: 10,
            /**
   * Number of seconds ahead in the buffer after which playback will resume when
   * seeking on an unbuffered part of the stream.
   * @type {Number}
   */
            RESUME_GAP_AFTER_SEEKING: 1.5,
            /**
   * Number of seconds ahead in the buffer after which playback will resume when
   * the player was stalled due to a low readyState.
   * @type {Number}
   */
            RESUME_GAP_AFTER_NOT_ENOUGH_DATA: .5,
            /**
   * Number of seconds ahead in the buffer after which playback will resume
   * after the player went through a buffering step.
   * @type {Number}
   */
            RESUME_GAP_AFTER_BUFFERING: 5,
            /**
   * Maximum number of seconds in the buffer based on which a "stalling"
   * strategy will be considered:
   * The player will pause playback to get enough time building a sufficient
   * buffer. This mostly happen when seeking in an unbuffered part or when
   * buffering.
   * @type {Number}
   */
            STALL_GAP: .5,
            /**
   * Maximum difference allowed between a segment _announced_ start (what the
   * rx-player infers to be the starting time) and its _real_  current starting
   * time in the source buffer, in seconds, until the segment is considered
   * "incomplete".
   * Same for the ending time announced and its effective end time in the source
   * buffer.
   *
   * If the difference is bigger than this value, the segment will be considered
   * incomplete (e.g. considered as partially garbage-collected) and as such
   * might be re-downloaded.
   *
   * Keeping a too high value might lead to incomplete segments being wrongly
   * considered as complete (and thus not be re-downloaded, this could lead the
   * player to stall).
   * Note that in a worst-case scenario this can happen for the end of a segment
   * and the start of the contiguous segment, leading to a discontinuity two
   * times this value.
   *
   * Keeping a too low value might lead to re-downloading the same segment
   * multiple times (when the start and end times are badly estimated) as they
   * will wrongly believed to be partially garbage-collected.
   *
   * If a segment has a perfect continuity with a previous/following one in the
   * source buffer the start/end of it will not be checked. This allows to limit
   * the number of time this error-prone logic is applied.
   *
   * Note that in most cases, the rx-player's start and end times estimations
   * are __really__ close to what they really are in the sourcebuffer (we
   * usually have a difference in the order of 10^-7), as time information is
   * most of the time directly parsed from the media container.
   *
   * @type {Number}
   */
            MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT: .12,
            /**
   * The maximum time, in seconds, the real buffered time in the sourcebuffer
   * can be superior to the time inferred by the rx-player (the "real" buffered
   * start inferior to the inferred start and the "real" buffered end superior
   * to the inferred end).
   * This limit allows to avoid resizing too much downloaded segments because
   * no other segment is linked to a buffered part.
   *
   * Setting a value too high can lead to parts of the source buffer being
   * linked to the wrong segments.
   * Setting a value too low can lead to parts of the source buffer not being
   * linked to the concerned segment.
   * @type {Number}
   */
            MAX_BUFFERED_DISTANCE: .1,
            /**
   * Minimum duration in seconds a segment should be into a buffered range to be
   * considered as part of that range.
   * Segments which have less than this amount of time "linked" to a buffered
   * range will be deleted.
   *
   * Setting a value too low can lead in worst-case scenarios to segments being
   * wrongly linked to the next or previous range it is truly linked too (if
   * those ranges are too close).
   *
   * Setting a value too high can lead to part of the buffer not being assigned
   * any segment. It also limits the minimum duration a segment can be.
   *
   * TODO As of now, this limits the minimum size a complete segment can be. A
   * better logic would be to also consider the duration of a segment. Though
   * this logic could lead to bugs with the current code.
   * @type {Number}
   */
            MINIMUM_SEGMENT_SIZE: .2,
            /**
   * Maximum interval at which text tracks are refreshed in an "html"
   * textTrackMode.
   *
   * The text tracks are also refreshed on various video events, this interval
   * will only trigger a refresh if none of those events was received during
   * that timespan.
   *
   * Note that if the TextTrack cue did not change between two intervals or
   * events, the DOM won't be refreshed.
   * The TextTrack cues structure is also optimized for fast retrieval.
   * We should thus not have much of a performance impact here if we set a low
   * interval.
   *
   * @type {Number}
   */
            MAXIMUM_HTML_TEXT_TRACK_UPDATE_INTERVAL: 50,
            /**
   * The Buffer padding is a time offset from the current time that affects
   * the buffer.
   *
   * Basically, from a given time, if the current buffer gap number (time
   * between the current time and the end of the downloaded buffer) is between
   * the "high" and "low" described here (of the corresponding type), we won't
   * reschedule segments for that range.
   *
   * This is to avoid excessive re-buffering.
   *
   * Keeping the "high"s too low would increase the risk of re-bufferings.
   *
   * Keeping the "high"s too high would delay visible quality increase.
   *
   * @type {Object}
   */
            BUFFER_PADDING: {
                audio: {
                    high: 1,
                    low: 1
                },
                video: {
                    high: 8,
                    low: 2
                },
                other: {
                    high: 1,
                    low: 1
                }
            },
            /**
   * Segments of different types are downloaded by steps:
   *
   *   - first the audio/video/text Segments which are immediately needed
   *
   *   - then once every of those Segments have been downloaded, less-needed
   *     Segments
   *
   *   - then once every of those less-needed Segments have been downloaded,
   *     even less-needed Segments
   *
   *   - etc.
   *
   * This stepped download strategy allows to make a better use of network
   * ressources.
   *
   * For example, if more than sufficient audio buffer has been downloaded but
   * the immediately-needed video Segment is still pending its request, we might
   * be in a situation of rebuffering.
   * In that case, a better strategy would be to make sure every network
   * ressource is allocated for this video Segment before rebuffering happens.
   *
   * This is where those steps become useful.
   *
   * --
   *
   * The numbers defined in this Array describe what the steps are.
   *
   * Each number is linked to a distance from the current playing position, in
   * seconds.
   * Distances which will be used as limit points, from which a new step is
   * reached (see example).
   *
   * Note: You can set an empty array to deactivate the steps feature (every
   * Segments have the same priority).
   *
   * @example
   *
   * let's imagine the following SEGMENT_PRIORITIES_STEPS array:
   * [5, 11, 17, 25]
   *
   * To link each Segments to a corresponding priority (and thus to a specific
   * step), we have to consider the distance d between the current position and
   * the start time of the Segment.
   *
   * We have in our example 5 groups, which correspond to the following possible
   * d values:
   *   1. inferior to 5
   *   2. between 5 and 11
   *   3. between 11 and 17
   *   4. between 17 and 25
   *   5. superior to 25
   *
   * Segments corresponding to a lower-step will need to all be downloaded
   * before Segments of a newer step begin.
   *
   * @type {Array.<Number>}
   */
            SEGMENT_PRIORITIES_STEPS: [ 6, 14 ],
            /**
   * Robustnesses used in the {audio,video}Capabilities of the
   * MediaKeySystemConfiguration (EME).
   *
   * Only used for widevine keysystems.
   *
   * Defined in order of importance (first will be tested first etc.)
   * @type {Array.<string>}
   */
            EME_DEFAULT_WIDEVINE_ROBUSTNESSES: [ "HW_SECURE_ALL", "HW_SECURE_DECODE", "HW_SECURE_CRYPTO", "SW_SECURE_DECODE", "SW_SECURE_CRYPTO" ],
            /**
   * Link canonical key systems names to their respective reverse domain name,
   * used in the EME APIs.
   * This allows to have a simpler API, where users just need to set "widevine"
   * or "playready" as a keySystem.
   * @type {Object}
   */
            /* tslint:disable no-object-literal-type-assertion */
            EME_KEY_SYSTEMS: {
                clearkey: [ "webkit-org.w3.clearkey", "org.w3.clearkey" ],
                widevine: [ "com.widevine.alpha" ],
                playready: [ "com.microsoft.playready", "com.chromecast.playready", "com.youtube.playready" ]
            },
            /* tslint:enable no-object-literal-type-assertion */
            /**
   * Max simultaneous MediaKeySessions that will be kept as a cache to avoid
   * doing superfluous license requests.
   * If this number is reached, any new session creation will close the oldest
   * one.
   * @type {Number}
   */
            EME_MAX_SIMULTANEOUS_MEDIA_KEY_SESSIONS: 50,
            /**
   * The player relies on browser events and properties to update its status to
   * "ENDED".
   *
   * Sadly in some cases, like in Chrome 54, this event is never triggered on
   * some contents probably due to a browser bug.
   *
   * This threshold resolves this issue by forcing the status to "ENDED" when:
   *   1. the player is stalling
   *   2. the absolute difference between current playback time and duration is
   *      under this value
   *
   * If set to null, this workaround is disabled and the player only relies on
   * browser events.
   *
   * @type {Number|null}
   */
            FORCED_ENDED_THRESHOLD: .001
        };
    }, 
    /* 4 */ 
    /* 5 */ , 
    /* 6 */
    /***/ , 
    /* 6 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subscriber.js
                var Subscriber = __webpack_require__(10), rxSubscriber = __webpack_require__(50), Observer = __webpack_require__(62);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/symbol/rxSubscriber.js
                // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/util/toSubscriber.js
        /** PURE_IMPORTS_START _Subscriber,_symbol_rxSubscriber,_Observer PURE_IMPORTS_END */
        function toSubscriber(nextOrObserver, error, complete) {
            if (nextOrObserver) {
                if (nextOrObserver instanceof Subscriber.a) return nextOrObserver;
                if (nextOrObserver[rxSubscriber.a]) return nextOrObserver[rxSubscriber.a]();
            }
            return nextOrObserver || error || complete ? new Subscriber.a(nextOrObserver, error, complete) : new Subscriber.a(Observer.a);
        }
        //# sourceMappingURL=toSubscriber.js.map
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/symbol/observable.js
                var observable = __webpack_require__(43), noop = __webpack_require__(37);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/noop.js
                function pipeFromArray(fns) {
            return fns ? 1 === fns.length ? fns[0] : function piped(input) {
                return fns.reduce(function(prev, fn) {
                    return fn(prev);
                }, input);
            } : noop.a;
        }
        //# sourceMappingURL=pipe.js.map
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/config.js
                var config = __webpack_require__(32);
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/Observable.js
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return Observable_Observable;
        });
        /** PURE_IMPORTS_START _util_toSubscriber,_internal_symbol_observable,_util_pipe,_config PURE_IMPORTS_END */
        var Observable_Observable = /* */ function() {
            function Observable(subscribe) {
                this._isScalar = !1, subscribe && (this._subscribe = subscribe);
            }
            return Observable.prototype.lift = function(operator) {
                var observable = new Observable();
                return observable.source = this, observable.operator = operator, observable;
            }, Observable.prototype.subscribe = function(observerOrNext, error, complete) {
                var operator = this.operator, sink = toSubscriber(observerOrNext, error, complete);
                if (operator ? operator.call(sink, this.source) : sink.add(this.source || config.a.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable ? this._subscribe(sink) : this._trySubscribe(sink)), 
                config.a.useDeprecatedSynchronousErrorHandling && sink.syncErrorThrowable && (sink.syncErrorThrowable = !1, 
                sink.syncErrorThrown)) throw sink.syncErrorValue;
                return sink;
            }, Observable.prototype._trySubscribe = function(sink) {
                try {
                    return this._subscribe(sink);
                } catch (err) {
                    config.a.useDeprecatedSynchronousErrorHandling && (sink.syncErrorThrown = !0, sink.syncErrorValue = err), 
                    sink.error(err);
                }
            }, Observable.prototype.forEach = function(next, promiseCtor) {
                var _this = this;
                return new (promiseCtor = getPromiseCtor(promiseCtor))(function(resolve, reject) {
                    var subscription;
                    subscription = _this.subscribe(function(value) {
                        try {
                            next(value);
                        } catch (err) {
                            reject(err), subscription && subscription.unsubscribe();
                        }
                    }, reject, resolve);
                });
            }, Observable.prototype._subscribe = function(subscriber) {
                var source = this.source;
                return source && source.subscribe(subscriber);
            }, Observable.prototype[observable.a] = function() {
                return this;
            }, Observable.prototype.pipe = function() {
                for (var operations = [], _i = 0; _i < arguments.length; _i++) operations[_i] = arguments[_i];
                return 0 === operations.length ? this : pipeFromArray(operations)(this);
            }, Observable.prototype.toPromise = function(promiseCtor) {
                var _this = this;
                return new (promiseCtor = getPromiseCtor(promiseCtor))(function(resolve, reject) {
                    var value;
                    _this.subscribe(function(x) {
                        return value = x;
                    }, function(err) {
                        return reject(err);
                    }, function() {
                        return resolve(value);
                    });
                });
            }, Observable.create = function(subscribe) {
                return new Observable(subscribe);
            }, Observable;
        }();
        function getPromiseCtor(promiseCtor) {
            if (promiseCtor || (promiseCtor = config.a.Promise || Promise), !promiseCtor) throw new Error("no Promise impl found");
            return promiseCtor;
        }
        //# sourceMappingURL=Observable.js.map
        /***/    }, 
    /* 7 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Initial features object, with no feature activated by default.
 * @type {Object}
 */        
        /* harmony default export */ __webpack_exports__.a = {
            transports: {},
            imageBuffer: null,
            imageParser: null,
            nativeTextTracksBuffer: null,
            nativeTextTracksParsers: {},
            htmlTextTracksBuffer: null,
            htmlTextTracksParsers: {},
            emeManager: null,
            directfile: null
        };
    }, 
    /* 8 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/fromEvent.js
                var fromEvent = __webpack_require__(135), Observable = __webpack_require__(6), noop = __webpack_require__(37), NEVER = /* */ new Observable.a(noop.a);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Observable.js + 2 modules
                //# sourceMappingURL=never.js.map
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/merge.js
        var merge = __webpack_require__(134), interval = __webpack_require__(139), map = __webpack_require__(54), mapTo = __webpack_require__(136), filter = __webpack_require__(137), tslib_es6 = __webpack_require__(2), Subscriber = __webpack_require__(10), scheduler_async = __webpack_require__(39);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/interval.js
                // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/debounceTime.js
        /** PURE_IMPORTS_START tslib,_Subscriber,_scheduler_async PURE_IMPORTS_END */
        function debounceTime(dueTime, scheduler) {
            return void 0 === scheduler && (scheduler = scheduler_async.a), function(source) {
                return source.lift(new DebounceTimeOperator(dueTime, scheduler));
            };
        }
        var DebounceTimeOperator = /* */ function() {
            function DebounceTimeOperator(dueTime, scheduler) {
                this.dueTime = dueTime, this.scheduler = scheduler;
            }
            return DebounceTimeOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new debounceTime_DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));
            }, DebounceTimeOperator;
        }(), debounceTime_DebounceTimeSubscriber = /* */ function(_super) {
            function DebounceTimeSubscriber(destination, dueTime, scheduler) {
                var _this = _super.call(this, destination) || this;
                return _this.dueTime = dueTime, _this.scheduler = scheduler, _this.debouncedSubscription = null, 
                _this.lastValue = null, _this.hasValue = !1, _this;
            }
            return tslib_es6.a(DebounceTimeSubscriber, _super), DebounceTimeSubscriber.prototype._next = function(value) {
                this.clearDebounce(), this.lastValue = value, this.hasValue = !0, this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));
            }, DebounceTimeSubscriber.prototype._complete = function() {
                this.debouncedNext(), this.destination.complete();
            }, DebounceTimeSubscriber.prototype.debouncedNext = function() {
                if (this.clearDebounce(), this.hasValue) {
                    var lastValue = this.lastValue;
                    this.lastValue = null, this.hasValue = !1, this.destination.next(lastValue);
                }
            }, DebounceTimeSubscriber.prototype.clearDebounce = function() {
                var debouncedSubscription = this.debouncedSubscription;
                null !== debouncedSubscription && (this.remove(debouncedSubscription), debouncedSubscription.unsubscribe(), 
                this.debouncedSubscription = null);
            }, DebounceTimeSubscriber;
        }(Subscriber.a);
        function dispatchNext(subscriber) {
            subscriber.debouncedNext();
        }
        //# sourceMappingURL=debounceTime.js.map
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/startWith.js
                var startWith = __webpack_require__(138), distinctUntilChanged = __webpack_require__(140), config = __webpack_require__(3), constants = __webpack_require__(25);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/distinctUntilChanged.js
                // CONCATENATED MODULE: ./src/compat/events.ts
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return events_isInBackground$;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "q", function() {
            return videoWidth$;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() {
            return events_onPlayPause$;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "o", function() {
            return events_onTextTrackChanges$;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() {
            return onLoadedMetadata$;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() {
            return onSeeking$;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() {
            return onSeeked$;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() {
            return onEnded$;
        }), 
        /* unused harmony export onTimeUpdate$ */
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() {
            return onFullscreenChange$;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() {
            return onSourceOpen$;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "p", function() {
            return onUpdate$;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() {
            return onRemoveSourceBuffers$;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() {
            return onEncrypted$;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() {
            return onKeyMessage$;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() {
            return onKeyAdded$;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() {
            return onKeyError$;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() {
            return onKeyStatusesChange$;
        });
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * This file provides browser-agnostic event listeners under the form of
 * RxJS Observables
 */
        var INACTIVITY_DELAY = config.a.INACTIVITY_DELAY, pixelRatio = window.devicePixelRatio || 1;
        /**
 * Find the first supported event from the list given.
 * @param {Element} element
 * @param {string} eventNameSuffix
 * @returns {Boolean}
 */
        function isEventSupported(element, eventNameSuffix) {
            var clone = document.createElement(element.tagName), eventName = "on" + eventNameSuffix;
            return eventName in clone || (clone.setAttribute(eventName, "return;"), "function" == typeof clone[eventName]);
        }
        /**
 * Find the first supported event from the list given.
 * @param {Element} element
 * @param {Array.<string>} eventNames
 * @returns {string}
 */        function findSupportedEvent(element, eventNames) {
            return eventNames.filter(function(name) {
                return isEventSupported(element, name);
            })[0];
        }
        function eventPrefixed(eventNames, prefixes) {
            return eventNames.reduce(function(parent, name) {
                return parent.concat((prefixes || constants.a).map(function(p) {
                    return p + name;
                }));
            }, []);
        }
        /**
 * @param {Array.<string>} eventNames
 * @param {Array.<string>} prefixes
 * @returns {Observable}
 */        function compatibleListener(eventNames, prefixes) {
            var mem = void 0, prefixedEvents = eventPrefixed(eventNames, prefixes);
            return function(element) {
                // if the element is a HTMLElement we can detect
                // the supported event, and memoize it in `mem`
                return element instanceof constants.b ? (void 0 === mem && (mem = findSupportedEvent(element, prefixedEvents)), 
                mem ? Object(fromEvent.a)(element, mem) : NEVER) : merge.a.apply(void 0, prefixedEvents.map(function(eventName) {
                    return Object(fromEvent.a)(element, eventName);
                }));
                // otherwise, we need to listen to all the events
                // and merge them into one observable sequence
                        };
        }
        /**
 * Returns an observable:
 *   - emitting true when the visibility of document changes to hidden
 *   - emitting false when the visibility of document changes to visible
 * @returns {Observable}
 */        function visibilityChange() {
            var prefix = void 0;
            null != document.hidden ? prefix = "" : null != document.mozHidden ? prefix = "moz" : null != document.msHidden ? prefix = "ms" : null != document.webkitHidden && (prefix = "webkit");
            var hidden = prefix ? prefix + "Hidden" : "hidden", visibilityChangeEvent = prefix + "visibilitychange";
            return Object(fromEvent.a)(document, visibilityChangeEvent).pipe(Object(map.a)(function() {
                return document[hidden];
            }));
        }
        function videoSizeChange() {
            return Object(fromEvent.a)(window, "resize").pipe(Object(mapTo.a)(null));
        }
        var isVisible = visibilityChange().pipe(Object(filter.a)(function(x) {
            return !x;
        })), isHidden = visibilityChange().pipe(debounceTime(INACTIVITY_DELAY), Object(filter.a)(function(x) {
            return x;
        })), events_isInBackground$ = function isInBackground$() {
            return Object(merge.a)(isVisible, isHidden).pipe(Object(startWith.a)(!1));
        };
 // emit false when visible
        // Emit true if the visibility changed to hidden since 60s
                function videoWidth$(videoElement) {
            return Object(merge.a)(Object(interval.a)(2e4).pipe(Object(mapTo.a)(null)), videoSizeChange().pipe(debounceTime(500))).pipe(Object(startWith.a)(null), // emit on subscription
            Object(map.a)(function() {
                return videoElement.clientWidth * pixelRatio;
            }), Object(distinctUntilChanged.a)());
        }
        var onLoadedMetadata$ = compatibleListener([ "loadedmetadata" ]), onSeeking$ = compatibleListener([ "seeking" ]), onSeeked$ = compatibleListener([ "seeked" ]), onEnded$ = compatibleListener([ "ended" ]), onFullscreenChange$ = (compatibleListener([ "timeupdate" ]), 
        compatibleListener([ "fullscreenchange", "FullscreenChange" ], 
        // On IE11, fullscreen change events is called MSFullscreenChange
        constants.a.concat("MS"))), events_onPlayPause$ = function onPlayPause$(videoElement) {
            return Object(merge.a)(compatibleListener([ "play" ])(videoElement), compatibleListener([ "pause" ])(videoElement));
        }, events_onTextTrackChanges$ = function onTextTrackChanges$(textTrackList) {
            return Object(merge.a)(compatibleListener([ "addtrack" ])(textTrackList), compatibleListener([ "removetrack" ])(textTrackList));
        }, onSourceOpen$ = compatibleListener([ "sourceopen", "webkitsourceopen" ]), onUpdate$ = compatibleListener([ "update" ]), onRemoveSourceBuffers$ = compatibleListener([ "onremovesourcebuffer" ]), onEncrypted$ = compatibleListener([ "encrypted", "needkey" ]), onKeyMessage$ = compatibleListener([ "keymessage", "message" ]), onKeyAdded$ = compatibleListener([ "keyadded", "ready" ]), onKeyError$ = compatibleListener([ "keyerror", "error" ]), onKeyStatusesChange$ = compatibleListener([ "keystatuseschange" ]);
    }, 
    /* 9 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // CONCATENATED MODULE: ./src/errors/AssertionError.ts
                function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        function _possibleConstructorReturn(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" != typeof call && "function" != typeof call ? self : call;
        }
        function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Error due to an abnormal assertion fails.
 *
 * @class AssertionError
 * @extends Error
 */        var errors_AssertionError = function(_Error) {
            function AssertionError(message) {
                _classCallCheck(this, AssertionError);
                // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class
                var _this = _possibleConstructorReturn(this, _Error.call(this));
                return Object.setPrototypeOf(_this, AssertionError.prototype), _this.name = "AssertionError", 
                _this.message = message, Error.captureStackTrace && Error.captureStackTrace(_this, AssertionError), 
                _this;
            }
            return _inherits(AssertionError, _Error), AssertionError;
        }(Error);
        /* harmony default export */        
        // CONCATENATED MODULE: ./src/utils/assert.ts
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() {
            return assert;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return assertInterface;
        });
        var _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
            return typeof obj;
        } : function(obj) {
            return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Throw an AssertionError if the given assertion is false.
 * @param {boolean} assertion
 * @param {string} message - Optional message property for the AssertionError.
 * @throws AssertionError - Throws if the assertion given is false
 */        function assert(assertion, message) {
            if (!assertion) throw new errors_AssertionError(message || "invalid assertion");
        }
        /**
 * Throws if the given Object does not respect the interface.
 * @param {Object} o
 * @param {Object} iface - Contains the checked keynames of o and link them
 * to their types (obtained through the typeof operator).
 * @param {string} [name="object"] - name of the _interface_
 * @throws AssertionError - The argument o given is not an object
 * @throws AssertionError - The _interface_ is not respected.
 */        function assertInterface(o, iface) {
            var name = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "object";
            for (var k in assert(null != o, name + " should be an object"), iface) iface.hasOwnProperty(k) && 
            /* tslint:disable:max-line-length */
            assert(_typeof(o[k]) === iface[k], name + " should have property " + k + " as a " + iface[k]);
        }
        /***/    }, 
    /* 10 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return Subscriber;
        });
        /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2), _util_isFunction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(47), _Observer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(62), _Subscription__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(16), _internal_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(50), _config__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(32), _util_hostReportError__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(49), Subscriber = /* */ function(_super) {
            function Subscriber(destinationOrNext, error, complete) {
                var _this = _super.call(this) || this;
                switch (_this.syncErrorValue = null, _this.syncErrorThrown = !1, _this.syncErrorThrowable = !1, 
                _this.isStopped = !1, arguments.length) {
                  case 0:
                    _this.destination = _Observer__WEBPACK_IMPORTED_MODULE_2__.a;
                    break;

                  case 1:
                    if (!destinationOrNext) {
                        _this.destination = _Observer__WEBPACK_IMPORTED_MODULE_2__.a;
                        break;
                    }
                    if ("object" == typeof destinationOrNext) {
                        if (isTrustedSubscriber(destinationOrNext)) {
                            var trustedSubscriber = destinationOrNext[_internal_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_4__.a]();
                            _this.syncErrorThrowable = trustedSubscriber.syncErrorThrowable, _this.destination = trustedSubscriber, 
                            trustedSubscriber.add(_this);
                        } else _this.syncErrorThrowable = !0, _this.destination = new SafeSubscriber(_this, destinationOrNext);
                        break;
                    }

                  default:
                    _this.syncErrorThrowable = !0, _this.destination = new SafeSubscriber(_this, destinationOrNext, error, complete);
                }
                return _this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(Subscriber, _super), Subscriber.prototype[_internal_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_4__.a] = function() {
                return this;
            }, Subscriber.create = function(next, error, complete) {
                var subscriber = new Subscriber(next, error, complete);
                return subscriber.syncErrorThrowable = !1, subscriber;
            }, Subscriber.prototype.next = function(value) {
                this.isStopped || this._next(value);
            }, Subscriber.prototype.error = function(err) {
                this.isStopped || (this.isStopped = !0, this._error(err));
            }, Subscriber.prototype.complete = function() {
                this.isStopped || (this.isStopped = !0, this._complete());
            }, Subscriber.prototype.unsubscribe = function() {
                this.closed || (this.isStopped = !0, _super.prototype.unsubscribe.call(this));
            }, Subscriber.prototype._next = function(value) {
                this.destination.next(value);
            }, Subscriber.prototype._error = function(err) {
                this.destination.error(err), this.unsubscribe();
            }, Subscriber.prototype._complete = function() {
                this.destination.complete(), this.unsubscribe();
            }, Subscriber.prototype._unsubscribeAndRecycle = function() {
                var _parent = this._parent, _parents = this._parents;
                return this._parent = null, this._parents = null, this.unsubscribe(), this.closed = !1, 
                this.isStopped = !1, this._parent = _parent, this._parents = _parents, this;
            }, Subscriber;
        }(_Subscription__WEBPACK_IMPORTED_MODULE_3__.a), SafeSubscriber = /* */ function(_super) {
            function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {
                var next, _this = _super.call(this) || this;
                _this._parentSubscriber = _parentSubscriber;
                var context = _this;
                return Object(_util_isFunction__WEBPACK_IMPORTED_MODULE_1__.a)(observerOrNext) ? next = observerOrNext : observerOrNext && (next = observerOrNext.next, 
                error = observerOrNext.error, complete = observerOrNext.complete, observerOrNext !== _Observer__WEBPACK_IMPORTED_MODULE_2__.a && (context = Object.create(observerOrNext), 
                Object(_util_isFunction__WEBPACK_IMPORTED_MODULE_1__.a)(context.unsubscribe) && _this.add(context.unsubscribe.bind(context)), 
                context.unsubscribe = _this.unsubscribe.bind(_this))), _this._context = context, 
                _this._next = next, _this._error = error, _this._complete = complete, _this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(SafeSubscriber, _super), SafeSubscriber.prototype.next = function(value) {
                if (!this.isStopped && this._next) {
                    var _parentSubscriber = this._parentSubscriber;
                    _config__WEBPACK_IMPORTED_MODULE_5__.a.useDeprecatedSynchronousErrorHandling && _parentSubscriber.syncErrorThrowable ? this.__tryOrSetError(_parentSubscriber, this._next, value) && this.unsubscribe() : this.__tryOrUnsub(this._next, value);
                }
            }, SafeSubscriber.prototype.error = function(err) {
                if (!this.isStopped) {
                    var _parentSubscriber = this._parentSubscriber, useDeprecatedSynchronousErrorHandling = _config__WEBPACK_IMPORTED_MODULE_5__.a.useDeprecatedSynchronousErrorHandling;
                    if (this._error) useDeprecatedSynchronousErrorHandling && _parentSubscriber.syncErrorThrowable ? (this.__tryOrSetError(_parentSubscriber, this._error, err), 
                    this.unsubscribe()) : (this.__tryOrUnsub(this._error, err), this.unsubscribe()); else if (_parentSubscriber.syncErrorThrowable) useDeprecatedSynchronousErrorHandling ? (_parentSubscriber.syncErrorValue = err, 
                    _parentSubscriber.syncErrorThrown = !0) : Object(_util_hostReportError__WEBPACK_IMPORTED_MODULE_6__.a)(err), 
                    this.unsubscribe(); else {
                        if (this.unsubscribe(), useDeprecatedSynchronousErrorHandling) throw err;
                        Object(_util_hostReportError__WEBPACK_IMPORTED_MODULE_6__.a)(err);
                    }
                }
            }, SafeSubscriber.prototype.complete = function() {
                var _this = this;
                if (!this.isStopped) {
                    var _parentSubscriber = this._parentSubscriber;
                    if (this._complete) {
                        var wrappedComplete = function() {
                            return _this._complete.call(_this._context);
                        };
                        _config__WEBPACK_IMPORTED_MODULE_5__.a.useDeprecatedSynchronousErrorHandling && _parentSubscriber.syncErrorThrowable ? (this.__tryOrSetError(_parentSubscriber, wrappedComplete), 
                        this.unsubscribe()) : (this.__tryOrUnsub(wrappedComplete), this.unsubscribe());
                    } else this.unsubscribe();
                }
            }, SafeSubscriber.prototype.__tryOrUnsub = function(fn, value) {
                try {
                    fn.call(this._context, value);
                } catch (err) {
                    if (this.unsubscribe(), _config__WEBPACK_IMPORTED_MODULE_5__.a.useDeprecatedSynchronousErrorHandling) throw err;
                    Object(_util_hostReportError__WEBPACK_IMPORTED_MODULE_6__.a)(err);
                }
            }, SafeSubscriber.prototype.__tryOrSetError = function(parent, fn, value) {
                if (!_config__WEBPACK_IMPORTED_MODULE_5__.a.useDeprecatedSynchronousErrorHandling) throw new Error("bad call");
                try {
                    fn.call(this._context, value);
                } catch (err) {
                    return _config__WEBPACK_IMPORTED_MODULE_5__.a.useDeprecatedSynchronousErrorHandling ? (parent.syncErrorValue = err, 
                    parent.syncErrorThrown = !0, !0) : (Object(_util_hostReportError__WEBPACK_IMPORTED_MODULE_6__.a)(err), 
                    !0);
                }
                return !1;
            }, SafeSubscriber.prototype._unsubscribe = function() {
                var _parentSubscriber = this._parentSubscriber;
                this._context = null, this._parentSubscriber = null, _parentSubscriber.unsubscribe();
            }, SafeSubscriber;
        }(Subscriber);
        /* harmony import */        function isTrustedSubscriber(obj) {
            return obj instanceof Subscriber || "syncErrorThrowable" in obj && obj[_internal_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_4__.a];
        }
        //# sourceMappingURL=Subscriber.js.map
        /***/    }, 
    /* 11 */
    /***/ function(module, exports, __webpack_require__) {
        "use strict";
        /*
object-assign
(c) Sindre Sorhus
@license MIT
*/
        /* eslint-disable no-unused-vars */        var getOwnPropertySymbols = Object.getOwnPropertySymbols, hasOwnProperty = Object.prototype.hasOwnProperty, propIsEnumerable = Object.prototype.propertyIsEnumerable;
        function toObject(val) {
            if (null === val || void 0 === val) throw new TypeError("Object.assign cannot be called with null or undefined");
            return Object(val);
        }
        module.exports = function shouldUseNative() {
            try {
                if (!Object.assign) return !1;
                // Detect buggy property enumeration order in older V8 versions.
                // https://bugs.chromium.org/p/v8/issues/detail?id=4118
                                var test1 = new String("abc");
 // eslint-disable-line no-new-wrappers
                                if (test1[5] = "de", "5" === Object.getOwnPropertyNames(test1)[0]) return !1;
                // https://bugs.chromium.org/p/v8/issues/detail?id=3056
                                for (var test2 = {}, i = 0; i < 10; i++) test2["_" + String.fromCharCode(i)] = i;
                if ("0123456789" !== Object.getOwnPropertyNames(test2).map(function(n) {
                    return test2[n];
                }).join("")) return !1;
                // https://bugs.chromium.org/p/v8/issues/detail?id=3056
                                var test3 = {};
                return "abcdefghijklmnopqrst".split("").forEach(function(letter) {
                    test3[letter] = letter;
                }), "abcdefghijklmnopqrst" === Object.keys(Object.assign({}, test3)).join("");
            } catch (err) {
                // We don't expect any of the above to throw, but better to be safe.
                return !1;
            }
        }() ? Object.assign : function(target, source) {
            for (var from, symbols, to = toObject(target), s = 1; s < arguments.length; s++) {
                for (var key in from = Object(arguments[s])) hasOwnProperty.call(from, key) && (to[key] = from[key]);
                if (getOwnPropertySymbols) {
                    symbols = getOwnPropertySymbols(from);
                    for (var i = 0; i < symbols.length; i++) propIsEnumerable.call(from, symbols[i]) && (to[symbols[i]] = from[symbols[i]]);
                }
            }
            return to;
        };
    }, 
    /* 12 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* unused harmony export play$ */
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "j", function() {
            return playUnlessAutoPlayPolicy$;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return addTextTrack;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() {
            return canPlay;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() {
            return hasLoadedMetadata;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() {
            return clearElementSrc;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() {
            return hasEMEAPIs;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() {
            return isCodecSupported;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() {
            return isOffline;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() {
            return isPlaybackStuck;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() {
            return makeCue;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() {
            return setElementSrc$;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() {
            return shouldRenewMediaKeys;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() {
            return shouldUnsetMediaKeys;
        });
        /* unused harmony export onSourceOpen$ */
        /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(75), rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(135), rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6), rxjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(133), rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(142), rxjs_operators__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(136), rxjs_operators__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(143), _log__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(0), _utils_castToObservable__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(15), _utils_eventemitter__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(41), _utils_rx_tryCatch__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(45), _constants__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(25), _events__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(8), _eme__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(131);
        /* harmony import */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Returns true if the given codec is supported by the browser's MediaSource
 * implementation.
 * @returns {Boolean}
 */
        function isCodecSupported(codec) {
            return !!_constants__WEBPACK_IMPORTED_MODULE_11__.d && ("function" != typeof _constants__WEBPACK_IMPORTED_MODULE_11__.d.isTypeSupported || _constants__WEBPACK_IMPORTED_MODULE_11__.d.isTypeSupported(codec));
        }
        /**
 * Returns true if the browser has the minimum needed EME APIs to decrypt a
 * content.
 * @returns {Boolean}
 */        function hasEMEAPIs() {
            return "function" == typeof _eme__WEBPACK_IMPORTED_MODULE_13__.b;
        }
        /**
 * Returns true if the current target require the media keys to be renewed on
 * each content.
 * @returns {Boolean}
 */        function shouldRenewMediaKeys() {
            return _constants__WEBPACK_IMPORTED_MODULE_11__.h;
        }
        /**
 * Returns true if the mediakeys associated to a media element should be
 * unset once the content is stopped.
 * Depends on the target.
 * @returns {Boolean}
 */        function shouldUnsetMediaKeys() {
            return _constants__WEBPACK_IMPORTED_MODULE_11__.h;
        }
        /**
 * Wait for the MediaSource's sourceopen event and emit. Emit immediatelly if
 * already received.
 * @param {MediaSource} mediaSource
 * @returns {Observable}
 */        
        /**
 * Returns an observable emitting a single time, as soon as a seek is possible
 * (the metatada are loaded).
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */
        function hasLoadedMetadata(mediaElement) {
            return mediaElement.readyState >= _constants__WEBPACK_IMPORTED_MODULE_11__.e.HAVE_METADATA ? Object(rxjs__WEBPACK_IMPORTED_MODULE_0__.a)(void 0) : _events__WEBPACK_IMPORTED_MODULE_12__.i(mediaElement).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.a)(1), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__.a)(void 0));
        }
        /**
 * Returns ane observable emitting a single time, as soon as a play is possible.
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */        function canPlay(mediaElement) {
            return mediaElement.readyState >= _constants__WEBPACK_IMPORTED_MODULE_11__.e.HAVE_ENOUGH_DATA ? Object(rxjs__WEBPACK_IMPORTED_MODULE_0__.a)(void 0) : Object(rxjs__WEBPACK_IMPORTED_MODULE_1__.a)(mediaElement, "canplay").pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.a)(1), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__.a)(void 0));
        }
        // old WebKit SourceBuffer implementation,
        // where a synchronous append is used instead of appendBuffer
                if (window.WebKitSourceBuffer && !window.WebKitSourceBuffer.prototype.addEventListener) {
            var sourceBufferWebkitProto = window.WebKitSourceBuffer.prototype;
            for (var fnName in _utils_eventemitter__WEBPACK_IMPORTED_MODULE_9__.a.prototype) _utils_eventemitter__WEBPACK_IMPORTED_MODULE_9__.a.prototype.hasOwnProperty(fnName) && (sourceBufferWebkitProto[fnName] = _utils_eventemitter__WEBPACK_IMPORTED_MODULE_9__.a.prototype[fnName]);
            sourceBufferWebkitProto._listeners = [], sourceBufferWebkitProto.__emitUpdate = function(eventName, val) {
                var _this = this;
                setTimeout(function() {
                    /* tslint:disable no-invalid-this */
                    _this.trigger(eventName, val), _this.updating = !1, _this.trigger("updateend");
                }, 0);
            }, sourceBufferWebkitProto.appendBuffer = function(data) {
                /* tslint:disable no-invalid-this */
                if (this.updating) throw new Error("updating");
                this.trigger("updatestart"), this.updating = !0;
                try {
                    this.append(data);
                } catch (error) {
                    return void this.__emitUpdate("error", error);
                }
                this.__emitUpdate("update");
            };
        }
        /**
 * Add text track to the given media element.
 * Returns an object with the following properties:
 *   - track {TextTrack}: the added text track
 *   - trackElement {HTMLElement|undefined}: the added <track> element.
 *     undefined if no trackElement was added.
 * @param {HTMLMediaElement} mediaElement
 * @param {Boolean} hidden
 * @returns {Object}
 */        function addTextTrack(mediaElement, hidden) {
            var track = void 0, trackElement = void 0;
            if (_constants__WEBPACK_IMPORTED_MODULE_11__.h) {
                var tracksLength = mediaElement.textTracks.length;
                (track = tracksLength > 0 ? mediaElement.textTracks[tracksLength - 1] : mediaElement.addTextTrack("subtitles")).mode = hidden ? track.HIDDEN : track.SHOWING;
            } else 
            // there is no removeTextTrack method... so we need to reuse old
            // text-tracks objects and clean all its pending cues
            trackElement = document.createElement("track"), mediaElement.appendChild(trackElement), 
            track = trackElement.track, trackElement.kind = "subtitles", track.mode = hidden ? "hidden" : "showing";
            return {
                track: track,
                trackElement: trackElement
            };
        }
        /**
 * firefox fix: sometimes the stream can be stalled, even if we are in a
 * buffer.
 *
 * TODO This seems to be about an old Firefox version. Delete it?
 * @param {Object} timing
 * @returns {Boolean}
 */        function isPlaybackStuck(time, currentRange, state, isStalled) {
            // freeze threshold in seconds
            return _constants__WEBPACK_IMPORTED_MODULE_11__.g && isStalled && "timeupdate" === state && !!currentRange && currentRange.end - time > 10;
        }
        /**
 * Clear element's src attribute.
 *
 * On IE11, element.src = "" is not sufficient as it
 * does not clear properly the current MediaKey Session.
 * Microsoft recommended to use element.removeAttr("src").
 * @param {HTMLMediaElement} element
 */        function clearElementSrc(element) {
            element.src = "", element.removeAttribute("src");
        }
        /**
 * Set an URL to the element's src.
 * Emit ``undefined`` when done.
 * Unlink src on unsubscription.
 *
 * @param {HTMLMediaElement} mediaElement
 * @param {string} url
 * @returns {Observable}
 */        function setElementSrc$(mediaElement, url) {
            return rxjs__WEBPACK_IMPORTED_MODULE_2__.a.create(function(observer) {
                return _log__WEBPACK_IMPORTED_MODULE_7__.a.info("Setting URL to Element", url, mediaElement), 
                mediaElement.src = url, observer.next(void 0), function() {
                    clearElementSrc(mediaElement);
                };
            });
        }
        /**
 * Some browsers have a builtin API to know if it's connected at least to a
 * LAN network, at most to the internet.
 *
 * /!\ This feature can be dangerous as you can both have false positives and
 * false negatives.
 *
 * False positives:
 *   - you can still play local contents (on localhost) if isOffline == true
 *   - on some browsers isOffline might be true even if we're connected to a LAN
 *     or a router (it would mean we're just not able to connect to the
 *     Internet). So we can eventually play LAN contents if isOffline == true
 *
 * False negatives:
 *   - in some cases, we even might have isOffline at false when we do not have
 *     any connection:
 *       - in browsers that do not support the feature
 *       - in browsers running in some virtualization softwares where the
 *         network adapters are always connected.
 *
 * Use with these cases in mind.
 * @returns {Boolean}
 */        function isOffline() {
            /* tslint:disable no-boolean-literal-compare */
            return !1 === navigator.onLine;
            /* tslint:enable no-boolean-literal-compare */        }
        /**
 * Creates a cue using the best platform-specific interface available.
 *
 * @param {Number} startTime
 * @param {Number} endTime
 * @param {string} payload
 * @returns {TextTrackCue} or null if the parameters were invalid.
 */        function makeCue(startTime, endTime, payload) {
            if (!_constants__WEBPACK_IMPORTED_MODULE_11__.f) throw new Error("VTT cues not supported in your target");
            return startTime >= endTime ? (
            // IE/Edge will throw in this case.
            // See issue #501
            _log__WEBPACK_IMPORTED_MODULE_7__.a.warn("Invalid cue times: " + startTime + " - " + endTime), 
            null) : new _constants__WEBPACK_IMPORTED_MODULE_11__.f(startTime, endTime, payload);
        }
        /**
 * Call play on the media element on subscription and return the response as an
 * observable.
 * @param {HTMLMediaElement} videoElement
 * @returns {Observable}
 */        function play$(mediaElement) {
            return Object(rxjs__WEBPACK_IMPORTED_MODULE_3__.a)(function() {
                // mediaElement.play is not always a Promise. In the improbable case it
                // throws, I prefer still to catch to return the error wrapped in an
                // Observable
                return Object(_utils_rx_tryCatch__WEBPACK_IMPORTED_MODULE_10__.a)(function() {
                    return Object(_utils_castToObservable__WEBPACK_IMPORTED_MODULE_8__.a)(mediaElement.play());
                }).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__.a)(void 0));
            });
        }
        /**
 * Try to call play on the given media element:
 *
 *   - If it works emit `undefined` through the returned Observable, then
 *     complete it.
 *
 *   - If it fails probably because of an auto-play policy, warn through the
 *     logger then emit `undefined` through the returned Observable then
 *     complete it.
 *
 *   - if it fails for any other reason, throw through the Observable.
 * @param {HTMLMediaElement} videoElement
 * @returns {Observable}
 */        function playUnlessAutoPlayPolicy$(mediaElement) {
            return play$(mediaElement).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_6__.a)(function(error) {
                if ("NotAllowedError" === error.name) 
                // auto-play was probably prevented.
                return _log__WEBPACK_IMPORTED_MODULE_7__.a.warn("Media element can't play. It may be due to browser auto-play policies."), 
                Object(rxjs__WEBPACK_IMPORTED_MODULE_0__.a)(void 0);
                throw error;
            }));
        }
        /***/    }, 
    /* 13 */
    /***/ function(module, exports, __webpack_require__) {
        "use strict";
        module.exports = function find(array, predicate, context) {
            if ("function" == typeof Array.prototype.find) return array.find(predicate, context);
            context = context || this;
            var i, length = array.length;
            if ("function" != typeof predicate) throw new TypeError(predicate + " is not a function");
            for (i = 0; i < length; i++) if (predicate.call(context, array[i], i, array)) return array[i];
        };
    }, 
    /* 14 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Array.prototype.includes ponyfill.
 * Returns ``true`` if the given array ``arr`` contains the element
 * ``searchElement``. false ``otherwise``.
 *
 * Inspired from MDN polyfill, but ponyfilled instead
 *
 * @example
 * ```js
 * arrayIncludes([1, 2, 3], 3);
 * // => true
 *
 * arrayIncludes([1, 2, 3], 7);
 * // => false
 *
 * const obj = { a: 4 };
 * arrayIncludes([obj, { b: 7 }, { a: 3 }, obj);
 * // => true
 *
 * // does not perform deep equality
 * arrayIncludes([{ a: 4 }, { b: 7 }, { a: 3 }, { a: 4 });
 * // => false
 *
 * // the third argument state the starting index. 0 if not set.
 *
 * arrayIncludes([1, 2, 3], 2, 1);
 * // => true
 *
 * arrayIncludes([1, 2, 3], 2, 2);
 * // => false
 * ```
 *
 * @param {Array} arr
 * @param {*} searchElement
 * @param {number} [fromIndex]
 * @returns {boolean}
 */
        function arrayIncludes(arr, searchElement, fromIndex) {
            /* tslint:disable no-unbound-method */
            if ("function" == typeof Array.prototype.includes) 
            /* tslint:enable no-unbound-method */
            return arr.includes(searchElement, fromIndex);
            var len = arr.length >>> 0;
            if (0 === len) return !1;
            for (var n = 0 | fromIndex, k = Math.max(n >= 0 ? n : len - Math.abs(n), 0), areTheSame = function areTheSame(x, y) {
                return x === y || 
                // Viva las JavaScriptas!
                "number" == typeof x && "number" == typeof y && isNaN(x) && isNaN(y);
            }; k < len; ) {
                if (areTheSame(arr[k], searchElement)) return !0;
                k++;
            }
            return !1;
        }
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return arrayIncludes;
        });
    }, 
    /* 15 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony import */        var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6), rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(44), rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(75);
        /* harmony import */        
        /* harmony default export */ __webpack_exports__.a = 
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        function castToObservable(value) {
            if (value instanceof rxjs__WEBPACK_IMPORTED_MODULE_0__.a) return value;
            if (value && "function" == typeof value.subscribe) {
                var valObsLike = value;
                return new rxjs__WEBPACK_IMPORTED_MODULE_0__.a(function(obs) {
                    var sub = valObsLike.subscribe(function(val) {
                        obs.next(val);
                    }, function(err) {
                        obs.error(err);
                    }, function() {
                        obs.complete();
                    });
                    return function() {
                        sub && sub.dispose ? sub.dispose() : sub && sub.unsubscribe && sub.unsubscribe();
                    };
                });
            }
            return value && "function" == typeof value.then ? Object(rxjs__WEBPACK_IMPORTED_MODULE_1__.a)(value) : Object(rxjs__WEBPACK_IMPORTED_MODULE_2__.a)(value);
        };
    }, 
    /* 16 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/isArray.js
                var isArray = __webpack_require__(42), isObject = __webpack_require__(67), isFunction = __webpack_require__(47), tryCatch = __webpack_require__(63), errorObject = __webpack_require__(31), tslib_es6 = __webpack_require__(2), UnsubscriptionError_UnsubscriptionError = /* */ function(_super) {
            function UnsubscriptionError(errors) {
                var _this = _super.call(this, errors ? errors.length + " errors occurred during unsubscription:\n  " + errors.map(function(err, i) {
                    return i + 1 + ") " + err.toString();
                }).join("\n  ") : "") || this;
                return _this.errors = errors, _this.name = "UnsubscriptionError", Object.setPrototypeOf(_this, UnsubscriptionError.prototype), 
                _this;
            }
            return tslib_es6.a(UnsubscriptionError, _super), UnsubscriptionError;
        }(Error);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/isObject.js
                //# sourceMappingURL=UnsubscriptionError.js.map
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/Subscription.js
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return Subscription_Subscription;
        });
        /** PURE_IMPORTS_START _util_isArray,_util_isObject,_util_isFunction,_util_tryCatch,_util_errorObject,_util_UnsubscriptionError PURE_IMPORTS_END */
        var Subscription_Subscription = /* */ function() {
            function Subscription(unsubscribe) {
                this.closed = !1, this._parent = null, this._parents = null, this._subscriptions = null, 
                unsubscribe && (this._unsubscribe = unsubscribe);
            }
            return Subscription.prototype.unsubscribe = function() {
                var errors, hasErrors = !1;
                if (!this.closed) {
                    var _parent = this._parent, _parents = this._parents, _unsubscribe = this._unsubscribe, _subscriptions = this._subscriptions;
                    this.closed = !0, this._parent = null, this._parents = null, this._subscriptions = null;
                    for (var index = -1, len = _parents ? _parents.length : 0; _parent; ) _parent.remove(this), 
                    _parent = ++index < len && _parents[index] || null;
                    if (Object(isFunction.a)(_unsubscribe)) Object(tryCatch.a)(_unsubscribe).call(this) === errorObject.a && (hasErrors = !0, 
                    errors = errors || (errorObject.a.e instanceof UnsubscriptionError_UnsubscriptionError ? flattenUnsubscriptionErrors(errorObject.a.e.errors) : [ errorObject.a.e ]));
                    if (Object(isArray.a)(_subscriptions)) for (index = -1, len = _subscriptions.length; ++index < len; ) {
                        var sub = _subscriptions[index];
                        if (Object(isObject.a)(sub)) if (Object(tryCatch.a)(sub.unsubscribe).call(sub) === errorObject.a) {
                            hasErrors = !0, errors = errors || [];
                            var err = errorObject.a.e;
                            err instanceof UnsubscriptionError_UnsubscriptionError ? errors = errors.concat(flattenUnsubscriptionErrors(err.errors)) : errors.push(err);
                        }
                    }
                    if (hasErrors) throw new UnsubscriptionError_UnsubscriptionError(errors);
                }
            }, Subscription.prototype.add = function(teardown) {
                if (!teardown || teardown === Subscription.EMPTY) return Subscription.EMPTY;
                if (teardown === this) return this;
                var subscription = teardown;
                switch (typeof teardown) {
                  case "function":
                    subscription = new Subscription(teardown);

                  case "object":
                    if (subscription.closed || "function" != typeof subscription.unsubscribe) return subscription;
                    if (this.closed) return subscription.unsubscribe(), subscription;
                    if ("function" != typeof subscription._addParent) {
                        var tmp = subscription;
                        (subscription = new Subscription())._subscriptions = [ tmp ];
                    }
                    break;

                  default:
                    throw new Error("unrecognized teardown " + teardown + " added to Subscription.");
                }
                return (this._subscriptions || (this._subscriptions = [])).push(subscription), subscription._addParent(this), 
                subscription;
            }, Subscription.prototype.remove = function(subscription) {
                var subscriptions = this._subscriptions;
                if (subscriptions) {
                    var subscriptionIndex = subscriptions.indexOf(subscription);
                    -1 !== subscriptionIndex && subscriptions.splice(subscriptionIndex, 1);
                }
            }, Subscription.prototype._addParent = function(parent) {
                var _parent = this._parent, _parents = this._parents;
                _parent && _parent !== parent ? _parents ? -1 === _parents.indexOf(parent) && _parents.push(parent) : this._parents = [ parent ] : this._parent = parent;
            }, Subscription.EMPTY = function(empty) {
                return empty.closed = !0, empty;
            }(new Subscription()), Subscription;
        }();
        function flattenUnsubscriptionErrors(errors) {
            return errors.reduce(function(errs, err) {
                return errs.concat(err instanceof UnsubscriptionError_UnsubscriptionError ? err.errors : err);
            }, []);
        }
        //# sourceMappingURL=Subscription.js.map
        /***/    }, 
    /* 17 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "b", function() {
            return ErrorTypes;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() {
            return RequestErrorTypes;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return ErrorCodes;
        });
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        var ErrorTypes = {
            NETWORK_ERROR: "NETWORK_ERROR",
            MEDIA_ERROR: "MEDIA_ERROR",
            ENCRYPTED_MEDIA_ERROR: "ENCRYPTED_MEDIA_ERROR",
            INDEX_ERROR: "INDEX_ERROR",
            OTHER_ERROR: "OTHER_ERROR"
        }, RequestErrorTypes = {
            TIMEOUT: "TIMEOUT",
            ERROR_EVENT: "ERROR_EVENT",
            ERROR_HTTP_CODE: "ERROR_HTTP_CODE",
            PARSE_ERROR: "PARSE_ERROR"
        }, ErrorCodes = {
            PIPELINE_RESOLVE_ERROR: "PIPELINE_RESOLVE_ERROR",
            PIPELINE_LOAD_ERROR: "PIPELINE_LOAD_ERROR",
            PIPELINE_PARSING_ERROR: "PIPELINE_PARSING_ERROR",
            MANIFEST_PARSE_ERROR: "MANIFEST_PARSE_ERROR",
            MANIFEST_INCOMPATIBLE_CODECS_ERROR: "MANIFEST_INCOMPATIBLE_CODECS_ERROR",
            MANIFEST_UNSUPPORTED_ADAPTATION_TYPE: "MANIFEST_UNSUPPORTED_ADAPTATION_TYPE",
            UNAVAILABLE_MEDIA_SOURCE: "UNAVAILABLE_MEDIA_SOURCE",
            MEDIA_STARTING_TIME_NOT_FOUND: "MEDIA_STARTING_TIME_NOT_FOUND",
            MEDIA_TIME_NOT_FOUND: "MEDIA_TIME_NOT_FOUND",
            MEDIA_IS_ENCRYPTED_ERROR: "MEDIA_IS_ENCRYPTED_ERROR",
            KEY_ERROR: "KEY_ERROR",
            KEY_STATUS_CHANGE_ERROR: "KEY_STATUS_CHANGE_ERROR",
            KEY_UPDATE_ERROR: "KEY_UPDATE_ERROR",
            KEY_LOAD_ERROR: "KEY_LOAD_ERROR",
            KEY_LOAD_TIMEOUT: "KEY_LOAD_TIMEOUT",
            KEY_GENERATE_REQUEST_ERROR: "KEY_GENERATE_REQUEST_ERROR",
            INCOMPATIBLE_KEYSYSTEMS: "INCOMPATIBLE_KEYSYSTEMS",
            LICENSE_SERVER_CERTIFICATE_ERROR: "LICENSE_SERVER_CERTIFICATE_ERROR",
            BUFFER_APPEND_ERROR: "BUFFER_APPEND_ERROR",
            BUFFER_FULL_ERROR: "BUFFER_FULL_ERROR",
            BUFFER_TYPE_UNKNOWN: "BUFFER_TYPE_UNKNOWN",
            MEDIA_ERR_ABORTED: "MEDIA_ERR_ABORTED",
            MEDIA_ERR_NETWORK: "MEDIA_ERR_NETWORK",
            MEDIA_ERR_DECODE: "MEDIA_ERR_DECODE",
            MEDIA_ERR_SRC_NOT_SUPPORTED: "MEDIA_ERR_SRC_NOT_SUPPORTED",
            MEDIA_ERR_UNKNOWN: "MEDIA_ERR_UNKNOWN",
            MEDIA_SOURCE_NOT_SUPPORTED: "MEDIA_SOURCE_NOT_SUPPORTED",
            MEDIA_KEYS_NOT_SUPPORTED: "MEDIA_KEYS_NOT_SUPPORTED",
            OUT_OF_INDEX_ERROR: "OUT_OF_INDEX_ERROR",
            UNKNOWN_INDEX: "UNKNOWN_INDEX",
            UNKNOWN_ERROR: "UNKNOWN_ERROR"
        };
    }, 
    /* 18 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return generateNewId;
        });
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        var _lastId = 0;
        /**
 * @returns {string}
 */        function generateNewId() {
            var newId = 0;
            return _lastId < Number.MAX_VALUE && (newId = _lastId + 1), _lastId = newId, "" + newId;
        }
        /***/    }, 
    /* 19 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        var STREAM_EVENTS = {
            activePeriodChanged: function activePeriodChanged(period) {
                return {
                    type: "activePeriodChanged",
                    value: {
                        period: period
                    }
                };
            },
            adaptationChange: function adaptationChange(bufferType, adaptation, period) {
                return {
                    type: "adaptationChange",
                    value: {
                        type: bufferType,
                        adaptation: adaptation,
                        period: period
                    }
                };
            },
            bufferComplete: function bufferComplete(bufferType) {
                return {
                    type: "complete-buffer",
                    value: {
                        type: bufferType
                    }
                };
            },
            endOfStream: function endOfStream() {
                return {
                    type: "end-of-stream",
                    value: void 0
                };
            },
            resumeStream: function resumeStream() {
                return {
                    type: "resume-stream",
                    value: void 0
                };
            },
            loaded: function loaded() {
                return {
                    type: "loaded",
                    value: !0
                };
            },
            manifestReady: function manifestReady(abrManager, manifest) {
                return {
                    type: "manifestReady",
                    value: {
                        abrManager: abrManager,
                        manifest: manifest
                    }
                };
            },
            manifestUpdate: function manifestUpdate(manifest) {
                return {
                    type: "manifestUpdate",
                    value: {
                        manifest: manifest
                    }
                };
            },
            nullRepresentation: function nullRepresentation(type, period) {
                return {
                    type: "representationChange",
                    value: {
                        type: type,
                        representation: null,
                        period: period
                    }
                };
            },
            periodBufferCleared: function periodBufferCleared(type, period) {
                return {
                    type: "periodBufferCleared",
                    value: {
                        type: type,
                        period: period
                    }
                };
            },
            periodBufferReady: function periodBufferReady(type, period, adaptation$) {
                return {
                    type: "periodBufferReady",
                    value: {
                        type: type,
                        period: period,
                        adaptation$: adaptation$
                    }
                };
            },
            speedChanged: function speedChanged(speed) {
                return {
                    type: "speed",
                    value: speed
                };
            },
            stalled: function stalled(stalling) {
                return {
                    type: "stalled",
                    value: stalling
                };
            },
            warning: function warning(value) {
                return {
                    type: "warning",
                    value: value
                };
            }
        };
        /* harmony default export */        __webpack_exports__.a = STREAM_EVENTS;
    }, 
    /* 20 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "c", function() {
            return REGXP_PERCENT_VALUES;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() {
            return REGXP_TIME_COLON;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() {
            return REGXP_TIME_COLON_FRAMES;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() {
            return REGXP_TIME_COLON_MS;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() {
            return REGXP_TIME_FRAMES;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() {
            return REGXP_TIME_HMS;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() {
            return REGXP_TIME_TICK;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return REGXP_4_HEX_COLOR;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() {
            return REGXP_8_HEX_COLOR;
        });
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @type {RegExp}
 * @example 00:00:40:07 (7 frames) or 00:00:40:07.1 (7 frames, 1 subframe)
 */
        var REGXP_TIME_COLON_FRAMES = /^(\d{2,}):(\d{2}):(\d{2}):(\d{2})\.?(\d+)?$/, REGXP_TIME_COLON = /^(?:(\d{2,}):)?(\d{2}):(\d{2})$/, REGXP_TIME_COLON_MS = /^(?:(\d{2,}):)?(\d{2}):(\d{2}\.\d{2,})$/, REGXP_TIME_FRAMES = /^(\d*\.?\d*)f$/, REGXP_TIME_TICK = /^(\d*\.?\d*)t$/, REGXP_TIME_HMS = /^(?:(\d*\.?\d*)h)?(?:(\d*\.?\d*)m)?(?:(\d*\.?\d*)s)?(?:(\d*\.?\d*)ms)?$/, REGXP_PERCENT_VALUES = /^(\d{1,2}|100)% (\d{1,2}|100)%$/, REGXP_8_HEX_COLOR = /^#([0-9A-f]{2})([0-9A-f]{2})([0-9A-f]{2})([0-9A-f]{2})$/, REGXP_4_HEX_COLOR = /^#([0-9A-f])([0-9A-f])([0-9A-f])([0-9A-f])$/;
        /**
 * @type {RegExp}
 * @example 00:00:40:07 (7 frames) or 00:00:40:07.1 (7 frames, 1 subframe)
 */    }, 
    /* 21 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* unused harmony export createRange */
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return convertToRanges;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() {
            return getInnerAndOuterTimeRanges;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() {
            return getLeftSizeOfRange;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() {
            return getNextRangeGap;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() {
            return getPlayedSizeOfRange;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() {
            return getRange;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() {
            return getSizeOfRange;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() {
            return insertInto;
        }), 
        /* unused harmony export isAfter */
        /* unused harmony export isBefore */
        /* unused harmony export isTimeInRange */
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() {
            return keepRangeIntersection;
        });
        /* unused harmony export mergeContiguousRanges */
        /* unused harmony export removeEmptyRanges */
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * This file contains functions helping with TimeRanges management.
 *
 * For simplicity/performance reasons, many of those work with a simplified
 * "Range" object, which is an object with two keys:
 *   - start {Number}
 *   - end {Number}
 *
 * Those two corresponds to what is returned by the start and end methods of a
 * TimeRanges Object.
 *
 * You can convert from TimeRanges to Range object(s) with the getRange/
 * convertToRanges methods.
 */
        // Factor for rounding errors
        var EPSILON = 1 / 60;
        /**
 * @param {number} start
 * @param {number} end
 * @returns {Object}
 */        
        /**
 * Check equality with a tolerance of EPSILON.
 * Used for various functions with this sort of tolerance regarding the
 * start/end of contiguous ranges.
 * @param {Number} a
 * @param {Number} b
 * @returns {Boolean}
 */
        function nearlyEqual(a, b) {
            return Math.abs(a - b) < EPSILON;
        }
        /**
 * Construct a new range which will have, as start/end, the min/max
 * of both the range given, and the given bitrate.
 * @param {Object} range1
 * @param {Object} range2
 * @returns {Object}
 */        function createRangeUnion(range1, range2) {
            return {
                start: Math.min(range1.start, range2.start),
                end: Math.max(range1.end, range2.end)
            };
        }
        /**
 * Clean array ranges from "empty" ranges.
 * That is, range objects which have their start equal to their end.
 * /!\ Mutate the array of ranges.
 * @param {Array<Object>} ranges
 * @returns {Array<Object>}
 */        function removeEmptyRanges(ranges) {
            for (var index = 0; index < ranges.length; index++) {
                var range = ranges[index];
                range.start === range.end && ranges.splice(index++, 1);
            }
            return ranges;
        }
        /**
 * /!\ Mutate the array of ranges.
 * @param {Array<Object>} ranges
 * @returns {Array<Object>}
 */        function mergeContiguousRanges(ranges) {
            for (var index = 1; index < ranges.length; index++) {
                var prevRange = ranges[index - 1], currRange = ranges[index];
                if (areRangesNearlyContiguous(prevRange, currRange)) {
                    var unionRange = createRangeUnion(prevRange, currRange);
                    ranges.splice(--index, 2, unionRange);
                }
            }
            return ranges;
        }
        /**
 * True if range1 is considered _after_ range2.
 * @param {Object} range1
 * @param {Object} range2
 * @returns {Boolean}
 */        
        /**
 * True if range1 is considered _before_ range2.
 * @param {Object} range1
 * @param {Object} range2
 * @returns {Boolean}
 */
        function isBefore(range1, range2) {
            return range1.end <= range2.start;
        }
        /**
 * Returns true if the time given can be considered as part of the given range.
 * @param {Object} range1
 * @param {Number} Time
 * @returns {Boolean}
 */        function isTimeInRange(_ref, time) {
            var start = _ref.start, end = _ref.end;
            return start <= time && time < end;
        }
        /**
 * Returns true if the two ranges given are overlapping.
 * @param {Object} range1
 * @param {Object} range2
 * @returns {Boolean}
 */        function areRangesOverlapping(range1, range2) {
            return isTimeInRange(range1, range2.start) || range1.start < range2.end && range2.end < range1.end || isTimeInRange(range2, range1.start);
        }
        /**
 * Returns true if the two ranges given can be considered contiguous.
 * @param {Object} range1
 * @param {Object} range2
 * @returns {Boolean}
 */        function areRangesNearlyContiguous(range1, range2) {
            return nearlyEqual(range2.start, range1.end) || nearlyEqual(range2.end, range1.start);
        }
        /**
 * Convert from a TimeRanges object to an array of Ranges.
 * @param {TimeRanges} timeRanges
 * @returns {Array.<Object>}
 */        function convertToRanges(timeRanges) {
            for (var ranges = [], i = 0; i < timeRanges.length; i++) ranges.push({
                start: timeRanges.start(i),
                end: timeRanges.end(i)
            });
            return ranges;
        }
        /**
 * Get range object of a specific time in a TimeRanges object.
 * @param {TimeRanges} timeRanges
 * @returns {Object}
 */        function getRange(timeRanges, time) {
            for (var i = timeRanges.length - 1; i >= 0; i--) {
                var start = timeRanges.start(i);
                if (time >= start) {
                    var end = timeRanges.end(i);
                    if (time < end) return {
                        start: start,
                        end: end
                    };
                }
            }
            return null;
        }
        /**
 * Get gap from a specific time until the start of the next Range.
 * @param {TimeRanges} timeRanges
 * @param {Number} time
 * @returns {Number}
 */        function getNextRangeGap(timeRanges, time) {
            for (var len = timeRanges.length, i = 0; i < len; i++) {
                var start = timeRanges.start(i);
                if (time < start) return start - time;
            }
            return Infinity;
        }
        /**
 * @param {TimeRanges} timeRanges
 * @param {Number} time
 * @returns {Object} - Object with two properties:
 *   - outerRanges {Array.<Object>}: every ranges which does not contain the
 *     given time.
 *   - innerRange {Object|null}: the range which contain the given time.
 */        function getInnerAndOuterTimeRanges(timeRanges, time) {
            for (var innerRange = null, outerRanges = [], i = 0; i < timeRanges.length; i++) {
                var start = timeRanges.start(i), end = timeRanges.end(i);
                time < start || time >= end ? outerRanges.push({
                    start: start,
                    end: end
                }) : innerRange = {
                    start: start,
                    end: end
                };
            }
            return {
                outerRanges: outerRanges,
                innerRange: innerRange
            };
        }
        /**
 * Get "size" (difference between end and start) of the range containing the
 * given time. 0 if the range is not found.
 * @param {TimeRanges} timeRanges
 * @param {Number} currentTime
 * @returns {Number}
 */        function getSizeOfRange(timeRanges, currentTime) {
            var range = getRange(timeRanges, currentTime);
            return range ? range.end - range.start : 0;
        }
        /**
 * Get "currently played" (difference between time given and start) of the
 * range containing the given time. 0 if the range is not found.
 * @param {TimeRanges} timeRanges
 * @param {Number} currentTime
 * @returns {Number}
 */        function getPlayedSizeOfRange(timeRanges, currentTime) {
            var range = getRange(timeRanges, currentTime);
            return range ? currentTime - range.start : 0;
        }
        /**
 * Get "left to play" (difference between end and time given) of the range
 * containing the given time. Infinity if the range is not found.
 * @param {TimeRanges} timeRanges
 * @param {Number} currentTime
 * @returns {Number}
 */        function getLeftSizeOfRange(timeRanges, currentTime) {
            var range = getRange(timeRanges, currentTime);
            return range ? range.end - currentTime : Infinity;
        }
        /**
 * Insert a range object into an array of ranges objects, at the right place.
 * /!\ Mutate the array of ranges.
 * @param {Array.<Object>} ranges
 * @param {Object} rangeToAddArg
 * @returns {Array.<Object>}
 */        function insertInto(ranges, rangeToAddArg) {
            if (rangeToAddArg.start === rangeToAddArg.end) return ranges;
            for (var rangeToAdd = rangeToAddArg, index = 0
            // For each present range check if we need to:
            // - In case we are overlapping or contiguous:
            //   - if added range has the same bitrate as the overlapped or
            //     contiguous one, we can merge themcurrentRange
            //   - if added range has a different bitrate we need to insert it
            //     in place
            // - Need to insert in place, we we are completely, not overlapping
            //   and not contiguous in between two ranges.
            ; index < ranges.length; index++) {
                var range = ranges[index], overlapping = areRangesOverlapping(rangeToAdd, range), contiguous = areRangesNearlyContiguous(rangeToAdd, range);
                // We assume ranges are ordered and two ranges can not be
                // completely overlapping.
                if (overlapping || contiguous) rangeToAdd = createRangeUnion(rangeToAdd, range), 
                ranges.splice(index--, 1); else 
                // Check the case for which there is no more to do
                if (0 === index) {
                    if (isBefore(rangeToAdd, ranges[0])) 
                    // First index, and we are completely before that range (and
                    // not contiguous, nor overlapping). We just need to be
                    // inserted here.
                    break;
                } else if (isBefore(ranges[index - 1], rangeToAdd) && isBefore(rangeToAdd, range)) 
                // We are exactly after the current previous range, and
                // before the current range, while not overlapping with none
                // of them. Insert here.
                break;
            }
            // Now that we are sure we don't overlap with any range, just add it.
                        return ranges.splice(index, 0, rangeToAdd), mergeContiguousRanges(removeEmptyRanges(ranges));
        }
        /**
 * Returns range, from a range objects array overlapping with a range given
 * in argument. null if none is found.
 * @param {Object} range
 * @param {Array.<Object>} ranges
 * @returns {Object|null}
 */        function findOverlappingRange(range, ranges) {
            for (var i = 0; i < ranges.length; i++) if (areRangesOverlapping(range, ranges[i])) return ranges[i];
            return null;
        }
        /**
 * Returns only the intersection between the two ranges, from the first
 * ranges argument given.
 * /!\ Mutates the ranges1 array given
 * @param {Array.<Range>} ranges1
 * @param {Array.<Range>} ranges2
 * @returns {Array.<Range>}
 */        function keepRangeIntersection(ranges1, ranges2) {
            for (var i = 0; i < ranges1.length; i++) {
                var range = ranges1[i], overlappingRange = findOverlappingRange(range, ranges2);
                overlappingRange ? overlappingRange.start > range.start ? range.start = overlappingRange.start : overlappingRange.end < range.end && (range.end = overlappingRange.end) : ranges1.splice(i--, 1);
            }
            return ranges1;
        }
        /***/    }, 
    /* 22 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return isKnownError;
        });
        /* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17);
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        // Custom Errors
        // Error used for XHRs
        /**
 * Whether the error given is a ICustomError.
 * @param {Error} error
 * @returns {Boolean}
 */        function isKnownError(error) {
            return !!error && !!error.type && Object.keys(_constants__WEBPACK_IMPORTED_MODULE_0__.b).indexOf(error.type) >= 0;
        }
        /***/    }, 
    /* 23 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return OuterSubscriber;
        });
        /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2), OuterSubscriber = /* */ function(_super) {
            function OuterSubscriber() {
                return null !== _super && _super.apply(this, arguments) || this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(OuterSubscriber, _super), OuterSubscriber.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
                this.destination.next(innerValue);
            }, OuterSubscriber.prototype.notifyError = function(error, innerSub) {
                this.destination.error(error);
            }, OuterSubscriber.prototype.notifyComplete = function(innerSub) {
                this.destination.complete();
            }, OuterSubscriber;
        }(__webpack_require__(10).a);
        /* harmony import */    }, 
    /* 24 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js
                var tslib_es6 = __webpack_require__(2), InnerSubscriber_InnerSubscriber = /* */ function(_super) {
            function InnerSubscriber(parent, outerValue, outerIndex) {
                var _this = _super.call(this) || this;
                return _this.parent = parent, _this.outerValue = outerValue, _this.outerIndex = outerIndex, 
                _this.index = 0, _this;
            }
            return tslib_es6.a(InnerSubscriber, _super), InnerSubscriber.prototype._next = function(value) {
                this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
            }, InnerSubscriber.prototype._error = function(error) {
                this.parent.notifyError(error, this), this.unsubscribe();
            }, InnerSubscriber.prototype._complete = function() {
                this.parent.notifyComplete(this), this.unsubscribe();
            }, InnerSubscriber;
        }(__webpack_require__(10).a), subscribeTo = __webpack_require__(68);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subscriber.js
                /** PURE_IMPORTS_START _InnerSubscriber,_subscribeTo PURE_IMPORTS_END */
        function subscribeToResult(outerSubscriber, result, outerValue, outerIndex) {
            var destination = new InnerSubscriber_InnerSubscriber(outerSubscriber, outerValue, outerIndex);
            return Object(subscribeTo.a)(result)(destination);
        }
        //# sourceMappingURL=subscribeToResult.js.map
        /***/        
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/util/subscribeToResult.js
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return subscribeToResult;
        });
    }, 
    /* 25 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return BROWSER_PREFIXES;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() {
            return HTMLElement_;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() {
            return MediaSource_;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() {
            return MediaKeys_;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() {
            return isIE;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() {
            return isFirefox;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() {
            return READY_STATES;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() {
            return VTTCue_;
        });
        /* harmony import */ var _errors_MediaError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27);
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        var BROWSER_PREFIXES = [ "", "webkit", "moz", "ms" ], HTMLElement_ = window.HTMLElement, VTTCue_ = window.VTTCue || window.TextTrackCue, MediaSource_ = window.MediaSource || window.MozMediaSource || window.WebKitMediaSource || window.MSMediaSource, MediaKeys_ = window.MediaKeys || window.MozMediaKeys || window.WebKitMediaKeys || window.MSMediaKeys;
        if (!MediaKeys_) {
            var noMediaKeys = function noMediaKeys() {
                throw new _errors_MediaError__WEBPACK_IMPORTED_MODULE_0__.a("MEDIA_KEYS_NOT_SUPPORTED", null, !0);
            };
            MediaKeys_ = function MediaKeys_() {
                _classCallCheck(this, MediaKeys_), this.create = noMediaKeys, this.createSession = noMediaKeys, 
                this.isTypeSupported = noMediaKeys, this.setServerCertificate = noMediaKeys;
            };
        }
        // true for IE / Edge
                var isIE = "Microsoft Internet Explorer" === navigator.appName || "Netscape" === navigator.appName && /(Trident|Edge)\//.test(navigator.userAgent), isFirefox = -1 !== navigator.userAgent.toLowerCase().indexOf("firefox"), READY_STATES = {
            HAVE_NOTHING: 0,
            HAVE_METADATA: 1,
            HAVE_CURRENT_DATA: 2,
            HAVE_FUTURE_DATA: 3,
            HAVE_ENOUGH_DATA: 4
        };
    }, 
    /* 26 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return EMPTY;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() {
            return empty;
        });
        /* unused harmony export emptyScheduled */
        /* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6), EMPTY = /* */ new _Observable__WEBPACK_IMPORTED_MODULE_0__.a(function(subscriber) {
            return subscriber.complete();
        });
        /** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */        function empty(scheduler) {
            return scheduler ? emptyScheduled(scheduler) : EMPTY;
        }
        function emptyScheduled(scheduler) {
            return new _Observable__WEBPACK_IMPORTED_MODULE_0__.a(function(subscriber) {
                return scheduler.schedule(function() {
                    return subscriber.complete();
                });
            });
        }
        //# sourceMappingURL=empty.js.map
        /***/    }, 
    /* 27 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony import */        var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17), _errorMessage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(52);
        /* harmony import */        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        function _possibleConstructorReturn(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" != typeof call && "function" != typeof call ? self : call;
        }
        function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Error linked to the media Playback.
 *
 * @class MediaError
 * @extends Error
 */        var MediaError = function(_Error) {
            function MediaError(code, reason, fatal) {
                _classCallCheck(this, MediaError);
                // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class
                var _this = _possibleConstructorReturn(this, _Error.call(this));
                return Object.setPrototypeOf(_this, MediaError.prototype), _this.name = "MediaError", 
                _this.type = _constants__WEBPACK_IMPORTED_MODULE_0__.b.MEDIA_ERROR, _this.reason = reason, 
                _this.code = _constants__WEBPACK_IMPORTED_MODULE_0__.a.hasOwnProperty(code) ? _constants__WEBPACK_IMPORTED_MODULE_0__.a[code] : "", 
                _this.fatal = !!fatal, _this.message = Object(_errorMessage__WEBPACK_IMPORTED_MODULE_1__.a)(_this.name, _this.code, _this.reason), 
                _this;
            }
            return _inherits(MediaError, _Error), MediaError;
        }(Error);
        /* harmony default export */        __webpack_exports__.a = MediaError;
    }, 
    /* 28 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony import */        var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6), _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(17), _errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(81), DEFAULT_RESPONSE_TYPE = "json", DEFAULT_REQUEST_TIMEOUT = 3e4;
        /* harmony import */        // TODO move to config?
        function toJSONForIE(data) {
            try {
                return JSON.parse(data);
            } catch (e) {
                return null;
            }
        }
        /* harmony default export */ __webpack_exports__.a = function request(options) {
            var requestOptions = {
                url: options.url,
                body: options.body,
                headers: options.headers,
                method: null == options.method ? "GET" : options.method,
                responseType: null == options.responseType ? DEFAULT_RESPONSE_TYPE : options.responseType,
                timeout: null == options.timeout ? DEFAULT_REQUEST_TIMEOUT : options.timeout
            };
            return rxjs__WEBPACK_IMPORTED_MODULE_0__.a.create(function(obs) {
                var url = requestOptions.url, headers = requestOptions.headers, method = requestOptions.method, responseType = requestOptions.responseType, timeout = requestOptions.timeout, body = requestOptions.body, xhr = new XMLHttpRequest();
                if (xhr.open(method, url, !0), timeout >= 0 && (xhr.timeout = timeout), xhr.responseType = responseType, 
                "document" === xhr.responseType && xhr.overrideMimeType("text/xml"), headers) {
                    var _headers = headers;
                    for (var key in _headers) _headers.hasOwnProperty(key) && xhr.setRequestHeader(key, _headers[key]);
                }
                var sentTime = Date.now();
                return xhr.onerror = function onXHRError() {
                    var errorCode = _errors__WEBPACK_IMPORTED_MODULE_1__.c.ERROR_EVENT;
                    obs.error(new _errors__WEBPACK_IMPORTED_MODULE_2__.a(xhr, url, errorCode));
                }, xhr.ontimeout = function onXHRTimeout() {
                    var errorCode = _errors__WEBPACK_IMPORTED_MODULE_1__.c.TIMEOUT;
                    obs.error(new _errors__WEBPACK_IMPORTED_MODULE_2__.a(xhr, url, errorCode));
                }, options.ignoreProgressEvents || (xhr.onprogress = function onXHRProgress(event) {
                    var currentTime = Date.now();
                    obs.next({
                        type: "progress",
                        value: {
                            url: url,
                            duration: currentTime - sentTime,
                            sentTime: sentTime,
                            currentTime: currentTime,
                            size: event.loaded,
                            totalSize: event.total
                        }
                    });
                }), 
                // XXX TODO:
                // Waiting for https://github.com/Microsoft/TypeScript/issues/19830
                xhr.onload = function onXHRLoad(event) {
                    if (4 === xhr.readyState) if (xhr.status >= 200 && xhr.status < 300) {
                        var receivedTime = Date.now(), totalSize = event.total, status = xhr.status, loadedResponseType = xhr.responseType, _url = xhr.responseURL || url, responseData = void 0;
                        if (null == (
                        // IE bug where response is string with responseType json
                        responseData = "json" === loadedResponseType ? "string" !== xhr.response ? xhr.response : toJSONForIE(xhr.responseText) : xhr.response)) {
                            var errorCode = _errors__WEBPACK_IMPORTED_MODULE_1__.c.PARSE_ERROR;
                            return void obs.error(new _errors__WEBPACK_IMPORTED_MODULE_2__.a(xhr, _url, errorCode));
                        }
                        obs.next({
                            type: "response",
                            value: {
                                status: status,
                                url: _url,
                                responseType: loadedResponseType,
                                sentTime: sentTime,
                                receivedTime: receivedTime,
                                duration: receivedTime - sentTime,
                                size: totalSize,
                                responseData: responseData
                            }
                        }), obs.complete();
                    } else {
                        var _errorCode = _errors__WEBPACK_IMPORTED_MODULE_1__.c.ERROR_HTTP_CODE;
                        obs.error(new _errors__WEBPACK_IMPORTED_MODULE_2__.a(xhr, url, _errorCode));
                    }
                }, void 0 !== body ? xhr.send(body) : xhr.send(), function() {
                    xhr && 4 !== xhr.readyState && xhr.abort();
                };
            });
        };
    }, 
    /* 29 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Do nothing, well.
 */
        /* tslint:disable:no-empty */
        /* harmony default export */        __webpack_exports__.a = function() {};
    }, 
    /* 30 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // EXTERNAL MODULE: ./node_modules/array-find/find.js
                var find = __webpack_require__(13), find_default = /* */ __webpack_require__.n(find), array_includes = __webpack_require__(14);
        // CONCATENATED MODULE: ./src/utils/starts-with.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * String.prototype.startsWith ponyfill.
 * Indicates Whether a string starts with another substring.
 *
 * Inspired from MDN polyfill, but ponyfilled instead.
 * @param {string} completeString
 * @param {string} searchString
 * @param {number} [position]
 * @returns {boolean}
 */
        function startsWith(completeString, searchString, position) {
            /* tslint:disable no-unbound-method */
            return "function" == typeof String.prototype.startsWith ? completeString.startsWith(searchString, position) : completeString.substr(position || 0, searchString.length) === searchString;
        }
        // CONCATENATED MODULE: ./src/parsers/texttracks/ttml/style.ts
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return getStylingAttributes;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() {
            return getStylingFromElement;
        });
        var _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
            return typeof obj;
        } : function(obj) {
            return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Retrieve the attributes given in arguments in the given nodes and their
 * associated style(s)/region.
 * The first notion of the attribute encountered will be taken (by looping
 * through the given nodes in order).
 *
 * TODO manage IDREFS (plural) for styles and regions, that is, multiple one
 * @param {Array.<string>} attributes
 * @param {Array.<Node>} nodes
 * @param {Array.<Object>} styles
 * @param {Array.<Object>} regions
 * @returns {Object}
 */        function getStylingAttributes(attributes, nodes, styles, regions) {
            for (var currentStyle = {}, leftAttributes = attributes.slice(), i = 0; i <= nodes.length - 1; i++) {
                var node = nodes[i];
                if (node) {
                    var _ret = function() {
                        var styleID = void 0, regionID = void 0;
                        // 1. the style is directly set on a "tts:" attribute
                        if (node.nodeType === Node.ELEMENT_NODE) for (var element = node, j = 0; j <= element.attributes.length - 1; j++) {
                            var attribute = element.attributes[j], name = attribute.name;
                            if ("style" === name) styleID = attribute.value; else if ("region" === name) regionID = attribute.value; else {
                                var nameWithoutTTS = name.substr(4);
                                if (Object(array_includes.a)(leftAttributes, nameWithoutTTS) && (currentStyle[nameWithoutTTS] = attribute.value, 
                                leftAttributes.splice(j, 1), !leftAttributes.length)) return {
                                    v: currentStyle
                                };
                            }
                        }
                        // 2. the style is referenced on a "style" attribute
                                                if (styleID) {
                            var style = find_default()(styles, function(x) {
                                return x.id === styleID;
                            });
                            if (style) for (var _j = 0; _j <= leftAttributes.length - 1; _j++) {
                                var _attribute = leftAttributes[_j];
                                if (!currentStyle[_attribute] && style.style[_attribute]) {
                                    if (currentStyle[_attribute] = style.style[_attribute], leftAttributes.splice(_j, 1), 
                                    !leftAttributes.length) return {
                                        v: currentStyle
                                    };
                                    _j--;
                                }
                            }
                        }
                        // 3. the node reference a region (which can have a value for the
                        //    corresponding style)
                                                if (regionID) {
                            var region = find_default()(regions, function(x) {
                                return x.id === regionID;
                            });
                            if (region) for (var _j2 = 0; _j2 <= leftAttributes.length - 1; _j2++) {
                                var _attribute2 = leftAttributes[_j2];
                                if (!currentStyle[_attribute2] && region.style[_attribute2]) {
                                    if (currentStyle[_attribute2] = region.style[_attribute2], leftAttributes.splice(_j2, 1), 
                                    !leftAttributes.length) return {
                                        v: currentStyle
                                    };
                                    _j2--;
                                }
                            }
                        }
                    }();
                    if ("object" === (void 0 === _ret ? "undefined" : _typeof(_ret))) return _ret.v;
                }
            }
            return currentStyle;
        }
        /**
 * Returns the styling directly linked to an element.
 * @param {Node} node
 * @returns {Object}
 */        function getStylingFromElement(node) {
            if (node.nodeType !== Node.ELEMENT_NODE) return {};
            for (var element = node, currentStyle = {}, i = 0; i <= element.attributes.length - 1; i++) {
                var styleAttribute = element.attributes[i];
                if (startsWith(styleAttribute.name, "tts")) currentStyle[styleAttribute.name.substr(4)] = styleAttribute.value;
            }
            return currentStyle;
        }
        /***/    }, 
    /* 31 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return errorObject;
        });
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        var errorObject = {
            e: {}
        };
        //# sourceMappingURL=errorObject.js.map
        /***/    }, 
    /* 32 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return config;
        });
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        var _enable_super_gross_mode_that_will_cause_bad_things = !1, config = {
            Promise: void 0,
            set useDeprecatedSynchronousErrorHandling(value) {
                value && /* */ new Error().stack;
                _enable_super_gross_mode_that_will_cause_bad_things = value;
            },
            get useDeprecatedSynchronousErrorHandling() {
                return _enable_super_gross_mode_that_will_cause_bad_things;
            }
        };
    }, 
    /* 33 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return fromArray;
        });
        /* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6), _Subscription__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(16), _util_subscribeToArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(71);
        /* harmony import */        
        /** PURE_IMPORTS_START _Observable,_Subscription,_util_subscribeToArray PURE_IMPORTS_END */
        function fromArray(input, scheduler) {
            return scheduler ? new _Observable__WEBPACK_IMPORTED_MODULE_0__.a(function(subscriber) {
                var sub = new _Subscription__WEBPACK_IMPORTED_MODULE_1__.a(), i = 0;
                return sub.add(scheduler.schedule(function() {
                    i !== input.length ? (subscriber.next(input[i++]), subscriber.closed || sub.add(this.schedule())) : subscriber.complete();
                })), sub;
            }) : new _Observable__WEBPACK_IMPORTED_MODULE_0__.a(Object(_util_subscribeToArray__WEBPACK_IMPORTED_MODULE_2__.a)(input));
        }
        //# sourceMappingURL=fromArray.js.map
        /***/    }, 
    /* 34 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        function isScheduler(value) {
            return value && "function" == typeof value.schedule;
        }
        //# sourceMappingURL=isScheduler.js.map
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return isScheduler;
        });
    }, 
    /* 35 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "b", function() {
            return getMDHDTimescale;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() {
            return parseTfdt;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return getDurationFromTrun;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() {
            return parseSidx;
        });
        /* unused harmony export patchPssh */
        /* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9), _utils_bytes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1), _read__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55);
        /* harmony import */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Find the right atom (box) in an isobmff file from its hexa-encoded name.
 * @param {Uint8Array} buf - the isobmff structure
 * @param {Number} atomName - the 'name' of the box (e.g. 'sidx' or 'moov'),
 * hexa encoded
 * @returns {Number} - offset where the corresponding box is (starting with its
 * size), 0 if not found.
 */
        function findAtom(buf, atomName) {
            for (var l = buf.length, i = 0, name = void 0, size = 0; i + 8 < l && (size = Object(_utils_bytes__WEBPACK_IMPORTED_MODULE_1__.c)(buf, i), 
            name = Object(_utils_bytes__WEBPACK_IMPORTED_MODULE_1__.c)(buf, i + 4), Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__.b)(size > 0, "out of range size"), 
            name !== atomName); ) i += size;
            return i >= l ? -1 : (Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__.b)(i + size <= l, "atom out of range"), 
            i);
        }
        /**
 * Parse the sidx part (segment index) of the isobmff.
 * Returns null if not found.
 *
 * @param {Uint8Array} buf
 * @param {Number} initialOffset
 * @returns {Object|null} {Array.<Object>} - Informations about each subsegment.
 * Contains those keys:
 *   - time {Number}: starting _presentation time_ for the subsegment,
 *     timescaled
 *   - duration {Number}: duration of the subsegment, timescaled
 *   - timescale {Number}: the timescale in which the time and duration are set
 *   - count {Number}: always at 0
 *   - range {Array.<Number>}: first and last bytes in the media file
 *     from the anchor point (first byte after the sidx box) for the
 *     concerned subsegment.
 */        function parseSidx(buf, initialOffset) {
            var index = findAtom(buf, 1936286840 /* "sidx" */);
            if (-1 === index) return null;
            var offset = initialOffset, size = Object(_utils_bytes__WEBPACK_IMPORTED_MODULE_1__.c)(buf, index), pos = index + /* size */ 4 + /* name */ 4, version = buf[pos];
            pos += 8;
            var timescale = Object(_utils_bytes__WEBPACK_IMPORTED_MODULE_1__.c)(buf, pos);
            pos += 4;
            /* earliest_presentation_time(32 / 64) */
            /* first_offset(32 / 64) */
            var time = void 0;
            if (0 === version) time = Object(_utils_bytes__WEBPACK_IMPORTED_MODULE_1__.c)(buf, pos), 
            pos += 4, offset += Object(_utils_bytes__WEBPACK_IMPORTED_MODULE_1__.c)(buf, pos) + size, 
            pos += 4; else {
                if (1 !== version) return null;
                time = Object(_utils_bytes__WEBPACK_IMPORTED_MODULE_1__.d)(buf, pos), pos += 8, 
                offset += Object(_utils_bytes__WEBPACK_IMPORTED_MODULE_1__.d)(buf, pos) + size, 
                pos += 8;
            }
            var segments = [];
            /* reserved(16) */
            /* reference_count(16) */            pos += 2;
            var count = Object(_utils_bytes__WEBPACK_IMPORTED_MODULE_1__.a)(buf, pos);
            for (pos += 2; --count >= 0; ) {
                /* reference_type(1) */
                /* reference_size(31) */
                /* segment_duration(32) */
                /* sap..(32) */
                var refChunk = Object(_utils_bytes__WEBPACK_IMPORTED_MODULE_1__.c)(buf, pos);
                pos += 4;
                var refSize = 2147483647 & refChunk;
                // when set to 1 indicates that the reference is to a sidx, else to media
                if (1 === (2147483648 & refChunk) >>> 31) throw new Error("not implemented");
                var d = Object(_utils_bytes__WEBPACK_IMPORTED_MODULE_1__.c)(buf, pos);
                pos += 4, 
                // let sapChunk = be4toi(buf, pos + 8);
                pos += 4, 
                // TODO(pierre): handle sap
                // let startsWithSap = (sapChunk & 0x80000000) >>> 31;
                // let sapType = (sapChunk & 0x70000000) >>> 28;
                // let sapDelta = sapChunk & 0x0FFFFFFF;
                segments.push({
                    time: time,
                    duration: d,
                    count: 0,
                    timescale: timescale,
                    range: [ offset, offset + refSize - 1 ]
                }), time += d, offset += refSize;
            }
            return segments;
        }
        /**
 * Parse track Fragment Decode Time to get a precize initial time for this
 * segment (in the media timescale).
 * Stops at the first tfdt encountered from the beginning of the file.
 * Returns this time. -1 if not found.
 * @param {Uint8Array} buffer
 * @returns {Number}
 */        function parseTfdt(buffer) {
            var traf = Object(_read__WEBPACK_IMPORTED_MODULE_2__.c)(buffer);
            if (!traf) return -1;
            var index = findAtom(traf, 1952867444 /* tfdt */);
            if (-1 === index) return -1;
            var pos = index + /* size */ 4 + /* name */ 4, version = traf[pos];
            return pos += 4, version > 1 ? -1 : version ? Object(_utils_bytes__WEBPACK_IMPORTED_MODULE_1__.d)(traf, pos) : Object(_utils_bytes__WEBPACK_IMPORTED_MODULE_1__.c)(traf, pos);
        }
        /**
 * @param {Uint8Array} traf
 * @returns {number}
 */        function getDefaultDurationFromTFHDInTRAF(traf) {
            var index = findAtom(traf, 1952868452 /* tfhd */);
            if (-1 === index) return -1;
            var pos = index + /* size */ 4 + /* name */ 4 + /* version */ 1, flags = Object(_utils_bytes__WEBPACK_IMPORTED_MODULE_1__.b)(traf, pos);
            return 8 & flags ? (pos += 4, 1 & flags && (pos += 8), 2 & flags && (pos += 4), 
            Object(_utils_bytes__WEBPACK_IMPORTED_MODULE_1__.c)(traf, pos)) : -1;
        }
        /**
 * @param {Uint8Array} buffer
 * @returns {number}
 */        function getDurationFromTrun(buffer) {
            var traf = Object(_read__WEBPACK_IMPORTED_MODULE_2__.c)(buffer);
            if (!traf) return -1;
            var index = findAtom(traf, 1953658222 /* tfdt */);
            if (-1 === index) return -1;
            var pos = index + /* size */ 4 + /* name */ 4, version = traf[pos];
            if (pos += 1, version > 1) return -1;
            var flags = Object(_utils_bytes__WEBPACK_IMPORTED_MODULE_1__.b)(traf, pos);
            pos += 3;
            var hasSampleDuration = 256 & flags, defaultDuration = 0;
            if (!hasSampleDuration) return (defaultDuration = getDefaultDurationFromTFHDInTRAF(traf)) >= 0 ? defaultDuration : -1;
            var hasDataOffset = 1 & flags, hasFirstSampleFlags = 4 & flags, hasSampleSize = 512 & flags, hasSampleFlags = 1024 & flags, hasSampleCompositionOffset = 2048 & flags, sampleCounts = Object(_utils_bytes__WEBPACK_IMPORTED_MODULE_1__.c)(traf, pos);
            pos += 4, hasDataOffset && (pos += 4), hasFirstSampleFlags && (pos += 4);
            for (var i = sampleCounts, duration = 0; i--; ) hasSampleDuration ? (duration += Object(_utils_bytes__WEBPACK_IMPORTED_MODULE_1__.c)(traf, pos), 
            pos += 4) : duration += defaultDuration, hasSampleSize && (pos += 4), hasSampleFlags && (pos += 4), 
            hasSampleCompositionOffset && (pos += 4);
            return duration;
        }
        /**
 * Get various informations from a movie header box. Found in init segments.
 * null if not found or not parsed.
 *
 * This timescale is the default timescale used for segments.
 * @param {Uint8Array} buffer
 * @returns {Number}
 */        function getMDHDTimescale(buffer) {
            var mdia = Object(_read__WEBPACK_IMPORTED_MODULE_2__.b)(buffer);
            if (!mdia) return -1;
            var index = findAtom(mdia, 1835296868 /* "mdhd" */);
            if (-1 === index) return -1;
            var pos = index + /* size */ 4 + /* name */ 4, version = mdia[pos];
            return pos += 4, 1 === version ? (pos += 16, Object(_utils_bytes__WEBPACK_IMPORTED_MODULE_1__.c)(mdia, pos)) : 0 === version ? (pos += 8, 
            Object(_utils_bytes__WEBPACK_IMPORTED_MODULE_1__.c)(mdia, pos)) : -1;
        }
        /**
 * Create a new _Atom_ (isobmff box).
 * @param {string} name - The box name (e.g. sidx, moov, pssh etc.)
 * @param {Uint8Array} buff - The box's content
 */    }, 
    /* 36 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "b", function() {
            return SubjectSubscriber;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return Subject;
        });
        /* unused harmony export AnonymousSubject */
        /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2), _Observable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6), _Subscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(10), _Subscription__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(16), _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(46), _SubjectSubscription__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(77), _internal_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(50), SubjectSubscriber = /* */ function(_super) {
            function SubjectSubscriber(destination) {
                var _this = _super.call(this, destination) || this;
                return _this.destination = destination, _this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(SubjectSubscriber, _super), SubjectSubscriber;
        }(_Subscriber__WEBPACK_IMPORTED_MODULE_2__.a), Subject = /* */ function(_super) {
            function Subject() {
                var _this = _super.call(this) || this;
                return _this.observers = [], _this.closed = !1, _this.isStopped = !1, _this.hasError = !1, 
                _this.thrownError = null, _this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(Subject, _super), Subject.prototype[_internal_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_6__.a] = function() {
                return new SubjectSubscriber(this);
            }, Subject.prototype.lift = function(operator) {
                var subject = new AnonymousSubject(this, this);
                return subject.operator = operator, subject;
            }, Subject.prototype.next = function(value) {
                if (this.closed) throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_4__.a();
                if (!this.isStopped) for (var observers = this.observers, len = observers.length, copy = observers.slice(), i = 0; i < len; i++) copy[i].next(value);
            }, Subject.prototype.error = function(err) {
                if (this.closed) throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_4__.a();
                this.hasError = !0, this.thrownError = err, this.isStopped = !0;
                for (var observers = this.observers, len = observers.length, copy = observers.slice(), i = 0; i < len; i++) copy[i].error(err);
                this.observers.length = 0;
            }, Subject.prototype.complete = function() {
                if (this.closed) throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_4__.a();
                this.isStopped = !0;
                for (var observers = this.observers, len = observers.length, copy = observers.slice(), i = 0; i < len; i++) copy[i].complete();
                this.observers.length = 0;
            }, Subject.prototype.unsubscribe = function() {
                this.isStopped = !0, this.closed = !0, this.observers = null;
            }, Subject.prototype._trySubscribe = function(subscriber) {
                if (this.closed) throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_4__.a();
                return _super.prototype._trySubscribe.call(this, subscriber);
            }, Subject.prototype._subscribe = function(subscriber) {
                if (this.closed) throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_4__.a();
                return this.hasError ? (subscriber.error(this.thrownError), _Subscription__WEBPACK_IMPORTED_MODULE_3__.a.EMPTY) : this.isStopped ? (subscriber.complete(), 
                _Subscription__WEBPACK_IMPORTED_MODULE_3__.a.EMPTY) : (this.observers.push(subscriber), 
                new _SubjectSubscription__WEBPACK_IMPORTED_MODULE_5__.a(this, subscriber));
            }, Subject.prototype.asObservable = function() {
                var observable = new _Observable__WEBPACK_IMPORTED_MODULE_1__.a();
                return observable.source = this, observable;
            }, Subject.create = function(destination, source) {
                return new AnonymousSubject(destination, source);
            }, Subject;
        }(_Observable__WEBPACK_IMPORTED_MODULE_1__.a), AnonymousSubject = /* */ function(_super) {
            function AnonymousSubject(destination, source) {
                var _this = _super.call(this) || this;
                return _this.destination = destination, _this.source = source, _this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(AnonymousSubject, _super), AnonymousSubject.prototype.next = function(value) {
                var destination = this.destination;
                destination && destination.next && destination.next(value);
            }, AnonymousSubject.prototype.error = function(err) {
                var destination = this.destination;
                destination && destination.error && this.destination.error(err);
            }, AnonymousSubject.prototype.complete = function() {
                var destination = this.destination;
                destination && destination.complete && this.destination.complete();
            }, AnonymousSubject.prototype._subscribe = function(subscriber) {
                return this.source ? this.source.subscribe(subscriber) : _Subscription__WEBPACK_IMPORTED_MODULE_3__.a.EMPTY;
            }, AnonymousSubject;
        }(Subject);
        /* harmony import */    }, 
    /* 37 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        function noop() {}
        //# sourceMappingURL=noop.js.map
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return noop;
        });
    }, 
    /* 38 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "b", function() {
            return resolveURL;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return normalizeBaseURL;
        });
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Scheme part of an url (e.g. "http://").
 */
        var schemeRe = /^(?:[a-z]+:)?\/\//i, selfDirRe = /\/\.{1,2}\//;
        /**
 * Captures "/../" or "/./".
 */        
        /**
 * Resolve self directory and previous directory references to obtain a
 * "normalized" url.
 * @example "https://foo.bar/baz/booz/../biz" => "https://foo.bar/baz/biz"
 * @param {string} url
 * @returns {string}
 */
        function _normalizeUrl(url) {
            // fast path if no ./ or ../ are present in the url
            if (!selfDirRe.test(url)) return url;
            for (var newUrl = [], oldUrl = url.split("/"), i = 0, l = oldUrl.length; i < l; i++) if (".." === oldUrl[i]) newUrl.pop(); else {
                if ("." === oldUrl[i]) continue;
                newUrl.push(oldUrl[i]);
            }
            return newUrl.join("/");
        }
        /**
 * Construct an url from the arguments given.
 * Basically:
 *   - The last arguments that contains a scheme (e.g. "http://") is the base
 *     of the url.
 *   - every subsequent string arguments are concatened to it.
 * @param {...string|undefined} args
 * @returns {string}
 */        function resolveURL() {
            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            var len = args.length;
            if (0 === len) return "";
            for (var base = "", i = 0; i < len; i++) {
                var part = args[i];
                "string" == typeof part && "" !== part && (schemeRe.test(part) ? base = part : (
                // trim if begins with "/"
                "/" === part[0] && (part = part.substr(1)), 
                // trim if ends with "/"
                "/" === base[base.length - 1] && (base = base.substr(0, base.length - 1)), base = base + "/" + part));
            }
            return _normalizeUrl(base);
        }
        /**
 * Remove string after the last '/'.
 * @param {string} url
 * @returns {string}
 */        function normalizeBaseURL(url) {
            var slash = url.lastIndexOf("/");
            return slash >= 0 ? url.substring(0, slash + 1) : url;
        }
        /***/    }, 
    /* 39 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return async;
        });
        /* harmony import */ var _AsyncAction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(100), async = /* */ new (__webpack_require__(101).a)(_AsyncAction__WEBPACK_IMPORTED_MODULE_0__.a);
        /* harmony import */    }, 
    /* 40 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // CONCATENATED MODULE: ./src/utils/languages/ISO_639-1_to_ISO_639-3.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Translate ISO 639-1 language codes into ISO 639-3 ones.
 */        var ISO_639_1_to_ISO_639_3 = {
            aa: "aar",
            ab: "abk",
            ae: "ave",
            af: "afr",
            ak: "aka",
            am: "amh",
            an: "arg",
            ar: "ara",
            as: "asm",
            av: "ava",
            ay: "aym",
            az: "aze",
            ba: "bak",
            be: "bel",
            bg: "bul",
            bi: "bis",
            bm: "bam",
            bn: "ben",
            bo: "bod",
            br: "bre",
            bs: "bos",
            ca: "cat",
            ce: "che",
            ch: "cha",
            co: "cos",
            cr: "cre",
            cs: "ces",
            cu: "chu",
            // Old Slavonic, Old Bulgarian
            cv: "chv",
            cy: "cym",
            da: "dan",
            de: "deu",
            dv: "div",
            dz: "dzo",
            ee: "ewe",
            el: "ell",
            en: "eng",
            eo: "epo",
            es: "spa",
            et: "est",
            eu: "eus",
            fa: "fas",
            ff: "ful",
            fi: "fin",
            fj: "fij",
            fo: "fao",
            fr: "fra",
            fy: "fry",
            ga: "gle",
            gd: "gla",
            gl: "glg",
            gn: "grn",
            gu: "guj",
            gv: "glv",
            ha: "hau",
            he: "heb",
            hi: "hin",
            ho: "hmo",
            hr: "hrv",
            ht: "hat",
            hu: "hun",
            hy: "hye",
            hz: "her",
            ia: "ina",
            id: "ind",
            ie: "ile",
            ig: "ibo",
            ii: "iii",
            ik: "ipk",
            io: "ido",
            is: "isl",
            it: "ita",
            iu: "iku",
            ja: "jpn",
            jv: "jav",
            ka: "kat",
            kg: "kon",
            ki: "kik",
            kj: "kua",
            kk: "kaz",
            kl: "kal",
            km: "khm",
            kn: "kan",
            ko: "kor",
            kr: "kau",
            ks: "kas",
            ku: "kur",
            kv: "kom",
            kw: "cor",
            ky: "kir",
            la: "lat",
            lb: "ltz",
            lg: "lug",
            li: "lim",
            ln: "lin",
            lo: "lao",
            lt: "lit",
            lu: "lub",
            lv: "lav",
            mg: "mlg",
            mh: "mah",
            mi: "mri",
            mk: "mkd",
            ml: "mal",
            mn: "mon",
            mr: "mar",
            ms: "msa",
            mt: "mlt",
            my: "mya",
            na: "nau",
            nb: "nob",
            nd: "nde",
            ne: "nep",
            ng: "ndo",
            nl: "nld",
            nn: "nno",
            no: "nor",
            nr: "nbl",
            nv: "nav",
            ny: "nya",
            oc: "oci",
            oj: "oji",
            om: "orm",
            or: "ori",
            os: "oss",
            pa: "pan",
            pi: "pli",
            pl: "pol",
            ps: "pus",
            pt: "por",
            qu: "que",
            rm: "roh",
            rn: "run",
            ro: "ron",
            ru: "rus",
            rw: "kin",
            sa: "san",
            sc: "srd",
            sd: "snd",
            se: "sme",
            sg: "sag",
            si: "sin",
            sk: "slk",
            sl: "slv",
            sm: "smo",
            sn: "sna",
            so: "som",
            sq: "sqi",
            sr: "srp",
            ss: "ssw",
            st: "sot",
            su: "sun",
            sv: "swe",
            sw: "swa",
            ta: "tam",
            te: "tel",
            tg: "tgk",
            th: "tha",
            ti: "tir",
            tk: "tuk",
            tl: "tgl",
            tn: "tsn",
            to: "ton",
            tr: "tur",
            ts: "tso",
            tt: "tat",
            tw: "twi",
            ty: "tah",
            ug: "uig",
            uk: "ukr",
            ur: "urd",
            uz: "uzb",
            ve: "ven",
            vi: "vie",
            vo: "vol",
            wa: "wln",
            wo: "wol",
            xh: "xho",
            yi: "yid",
            yo: "yor",
            za: "zha",
            zh: "zho",
            zu: "zul"
        }, ISO_639_2_to_ISO_639_3 = {
            alb: "sqi",
            arm: "hye",
            baq: "eus",
            bur: "mya",
            chi: "zho",
            cze: "ces",
            dut: "nld",
            fre: "fra",
            geo: "kat",
            ger: "deu",
            gre: "ell",
            ice: "isl",
            mac: "mkd",
            mao: "mri",
            may: "msa",
            per: "fas",
            slo: "slk",
            rum: "ron",
            tib: "bod",
            wel: "cym"
        };
        /* harmony default export */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Normalize language given.
 * Basically:
 *   - converts it to lowercase.
 *   - normalize "base" (what is before the possible first "-") to an ISO639-3
 *     compatible string.
 * @param {string} _language
 * @returns {string}
 */
        function normalize(_language) {
            if (null == _language || "" === _language) return "";
            var fields = ("" + _language).toLowerCase().split("-"), normalizedBase = normalizeBase(fields[0]);
            return normalizedBase && (fields[0] = normalizedBase), fields.join("-");
        }
        /**
 * Normalize language into an ISO639-3 format.
 * @param {string} base
 * @returns {string}
 */        function normalizeBase(base) {
            var result = void 0;
            switch (base.length) {
              case 2:
                result = ISO_639_1_to_ISO_639_3[base];
                break;

              case 3:
                result = ISO_639_2_to_ISO_639_3[base];
            }
            return result || base;
        }
        /**
 * Normalize text track from a user given input into an object
 * with three properties:
 *   - language {string}: The language the user gave us
 *   - normalized {string}: An attempt to normalize the language into an
 *     ISO 639-3 code
 *   - closedCaption {Boolean}: Whether the track is a closed caption track
 * @param {Object|string} _language
 * @returns {Object|null|undefined}
 */        function normalizeTextTrack(_language) {
            if (null != _language) {
                var language = void 0, closedCaption = void 0;
                return "string" == typeof _language ? (language = _language, closedCaption = !1) : (language = _language.language, 
                closedCaption = !!_language.closedCaption), {
                    language: language,
                    closedCaption: closedCaption,
                    normalized: normalize(language)
                };
            }
            return _language;
        }
        /**
 * Normalize audio track from a user given input into an object
 * with three properties:
 *   - language {string}: The language the user gave us
 *   - normalized {string}: An attempt to normalize the language into an
 *     ISO 639-3 code
 *   - audioDescription {Boolean}: Whether the track is a closed caption track
 * @param {Object|string} _language
 * @returns {Object|null|undefined}
 */        function normalizeAudioTrack(_language) {
            if (null != _language) {
                var language = void 0, audioDescription = void 0;
                return "string" == typeof _language ? (language = _language, audioDescription = !1) : (language = _language.language, 
                audioDescription = !!_language.audioDescription), {
                    language: language,
                    audioDescription: audioDescription,
                    normalized: normalize(language)
                };
            }
            return _language;
        }
        /***/        
        // CONCATENATED MODULE: ./src/utils/languages/index.ts
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return normalize;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() {
            return normalizeAudioTrack;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() {
            return normalizeTextTrack;
        });
    }, 
    /* 41 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony import */        var _log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        var EventEmitter = function() {
            function EventEmitter() {
                _classCallCheck(this, EventEmitter), this._listeners = {};
            }
            /**
     * Register a new callback for an event.
     *
     * @param {string} evt - The event to register a callback to
     * @param {Function} fn - The callback to call as that event is triggered.
     * The callback will take as argument the eventual payload of the event
     * (single argument).
     */            return EventEmitter.prototype.addEventListener = function addEventListener(evt, fn) {
                var listeners = this._listeners[evt];
                listeners ? listeners.push(fn) : 
                // TS Bug?
                this._listeners[evt] = [ fn ];
            }, 
            /**
     * Unregister callbacks linked to events.
     * @param {string} [evt] - The event for which the callback[s] should be
     * unregistered. Set it to null or undefined to remove all callbacks
     * currently registered (for any event).
     * @param {Function} [fn] - The callback to unregister. If set to null
     * or undefined while the evt argument is set, all callbacks linked to that
     * event will be unregistered.
     */
            EventEmitter.prototype.removeEventListener = function removeEventListener(evt, fn) {
                if (null != evt) {
                    var listeners = this._listeners[evt];
                    if (listeners) if (null != fn) {
                        var index = listeners.indexOf(fn);
                        ~index && listeners.splice(index, 1), listeners.length || delete this._listeners[evt];
                    } else delete this._listeners[evt];
                } else this._listeners = {};
            }, 
            /**
     * Trigger every registered callbacks for a given event
     * @param {string} evt - The event to trigger
     * @param {*} arg - The eventual payload for that event. All triggered
     * callbacks will recieve this payload as argument.
     */
            EventEmitter.prototype.trigger = function trigger(evt, arg) {
                var listeners = this._listeners[evt];
                listeners && listeners.slice().forEach(function(listener) {
                    try {
                        listener(arg);
                    } catch (e) {
                        _log__WEBPACK_IMPORTED_MODULE_0__.a.error(e, e.stack);
                    }
                });
            }, EventEmitter;
        }();
        /* harmony default export */        __webpack_exports__.a = EventEmitter;
    }, 
    /* 42 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return isArray;
        });
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        var isArray = Array.isArray || function(x) {
            return x && "number" == typeof x.length;
        };
        //# sourceMappingURL=isArray.js.map
        /***/    }, 
    /* 43 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return observable;
        });
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        var observable = "function" == typeof Symbol && Symbol.observable || "@@observable";
        //# sourceMappingURL=observable.js.map
        /***/    }, 
    /* 44 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Observable.js + 2 modules
                var Observable = __webpack_require__(6), isPromise = __webpack_require__(72), isArrayLike = __webpack_require__(70), symbol_observable = __webpack_require__(43);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/isPromise.js
                // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/util/isInteropObservable.js
        /** PURE_IMPORTS_START _symbol_observable PURE_IMPORTS_END */
        function isInteropObservable(input) {
            return input && "function" == typeof input[symbol_observable.a];
        }
        //# sourceMappingURL=isInteropObservable.js.map
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/symbol/iterator.js
                var symbol_iterator = __webpack_require__(51);
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/util/isIterable.js
        /** PURE_IMPORTS_START _symbol_iterator PURE_IMPORTS_END */        function isIterable(input) {
            return input && "function" == typeof input[symbol_iterator.a];
        }
        //# sourceMappingURL=isIterable.js.map
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/fromArray.js
                var fromArray = __webpack_require__(33), Subscription = __webpack_require__(16), subscribeToPromise = __webpack_require__(73);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subscription.js + 1 modules
                // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/observable/fromPromise.js
        /** PURE_IMPORTS_START _Observable,_Subscription,_util_subscribeToPromise PURE_IMPORTS_END */
        function fromPromise(input, scheduler) {
            return scheduler ? new Observable.a(function(subscriber) {
                var sub = new Subscription.a();
                return sub.add(scheduler.schedule(function() {
                    return input.then(function(value) {
                        sub.add(scheduler.schedule(function() {
                            subscriber.next(value), sub.add(scheduler.schedule(function() {
                                return subscriber.complete();
                            }));
                        }));
                    }, function(err) {
                        sub.add(scheduler.schedule(function() {
                            return subscriber.error(err);
                        }));
                    });
                })), sub;
            }) : new Observable.a(Object(subscribeToPromise.a)(input));
        }
        //# sourceMappingURL=fromPromise.js.map
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/subscribeToIterable.js
                var subscribeToIterable = __webpack_require__(74);
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/observable/fromIterable.js
        /** PURE_IMPORTS_START _Observable,_Subscription,_symbol_iterator,_util_subscribeToIterable PURE_IMPORTS_END */        function fromIterable(input, scheduler) {
            if (!input) throw new Error("Iterable cannot be null");
            return scheduler ? new Observable.a(function(subscriber) {
                var iterator, sub = new Subscription.a();
                return sub.add(function() {
                    iterator && "function" == typeof iterator.return && iterator.return();
                }), sub.add(scheduler.schedule(function() {
                    iterator = input[symbol_iterator.a](), sub.add(scheduler.schedule(function() {
                        if (!subscriber.closed) {
                            var value, done;
                            try {
                                var result = iterator.next();
                                value = result.value, done = result.done;
                            } catch (err) {
                                return void subscriber.error(err);
                            }
                            done ? subscriber.complete() : (subscriber.next(value), this.schedule());
                        }
                    }));
                })), sub;
            }) : new Observable.a(Object(subscribeToIterable.a)(input));
        }
        //# sourceMappingURL=fromIterable.js.map
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/subscribeToObservable.js
                var subscribeToObservable = __webpack_require__(69);
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/observable/fromObservable.js
        /** PURE_IMPORTS_START _Observable,_Subscription,_symbol_observable,_util_subscribeToObservable PURE_IMPORTS_END */        function fromObservable(input, scheduler) {
            return scheduler ? new Observable.a(function(subscriber) {
                var sub = new Subscription.a();
                return sub.add(scheduler.schedule(function() {
                    var observable = input[symbol_observable.a]();
                    sub.add(observable.subscribe({
                        next: function(value) {
                            sub.add(scheduler.schedule(function() {
                                return subscriber.next(value);
                            }));
                        },
                        error: function(err) {
                            sub.add(scheduler.schedule(function() {
                                return subscriber.error(err);
                            }));
                        },
                        complete: function() {
                            sub.add(scheduler.schedule(function() {
                                return subscriber.complete();
                            }));
                        }
                    }));
                })), sub;
            }) : new Observable.a(Object(subscribeToObservable.a)(input));
        }
        //# sourceMappingURL=fromObservable.js.map
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/subscribeTo.js
                var subscribeTo = __webpack_require__(68);
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/observable/from.js
        /* harmony export (binding) */        
        /** PURE_IMPORTS_START _Observable,_util_isPromise,_util_isArrayLike,_util_isInteropObservable,_util_isIterable,_fromArray,_fromPromise,_fromIterable,_fromObservable,_util_subscribeTo PURE_IMPORTS_END */
        function from(input, scheduler) {
            if (!scheduler) return input instanceof Observable.a ? input : new Observable.a(Object(subscribeTo.a)(input));
            if (null != input) {
                if (isInteropObservable(input)) return fromObservable(input, scheduler);
                if (Object(isPromise.a)(input)) return fromPromise(input, scheduler);
                if (Object(isArrayLike.a)(input)) return Object(fromArray.a)(input, scheduler);
                if (isIterable(input) || "string" == typeof input) return fromIterable(input, scheduler);
            }
            throw new TypeError((null !== input && typeof input || input) + " is not observable");
        }
        //# sourceMappingURL=from.js.map
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return from;
        });
    }, 
    /* 45 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return tryCatch;
        });
        /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(78);
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {Function} func - A function you want to execute
 * @param {*} args - The function's argument
 * @returns {*} - If it fails, returns a throwing Observable, else the
 * function's result (which should be, in most cases, an Observable).
 */        function tryCatch(func, args) {
            try {
                return func(args);
            } catch (e) {
                return Object(rxjs__WEBPACK_IMPORTED_MODULE_0__.a)(e);
            }
        }
        /***/    }, 
    /* 46 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return ObjectUnsubscribedError;
        });
        /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2), ObjectUnsubscribedError = /* */ function(_super) {
            function ObjectUnsubscribedError() {
                var _this = _super.call(this, "object unsubscribed") || this;
                return _this.name = "ObjectUnsubscribedError", Object.setPrototypeOf(_this, ObjectUnsubscribedError.prototype), 
                _this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(ObjectUnsubscribedError, _super), ObjectUnsubscribedError;
        }(Error);
        /** PURE_IMPORTS_START tslib PURE_IMPORTS_END */    }, 
    /* 47 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        function isFunction(x) {
            return "function" == typeof x;
        }
        //# sourceMappingURL=isFunction.js.map
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return isFunction;
        });
    }, 
    /* 48 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Returns first line after the WEBVTT header.
 * That is, the line after the first blank line after the first line!
 * @param {Array.<string>} linified
 * @returns {Number}
 */
        function getFirstLineAfterHeader(linified) {
            for (var i = 0; i < linified.length; ) {
                if ("" === linified[i]) return i + 1;
                i++;
            }
            return i;
        }
        /**
 * Returns true if the given line looks like the beginning of a Style block.
 * @param {string} text
 * @returns {Boolean}
 */        function isStartOfStyleBlock(lines, index) {
            return !!lines[index] && /^STYLE( .*)?$/g.test(lines[index]) && (
            // A cue identifer can also contain "STYLe". Check that we have no timings
            // on the second line
            !lines[index + 1] || lines[index + 1].indexOf("--\x3e") < 0);
        }
        /**
 * Returns true if the given line looks like the beginning of a comment block.
 * @param {string} text
 * @returns {Boolean}
 */        function isStartOfNoteBlock(lines, index) {
            return !!lines[index] && /^NOTE( .*)?$/g.test(lines[index]) && (
            // A cue identifer can also contain "NOTE". Check that we have no timings
            // on the second line
            !lines[index + 1] || lines[index + 1].indexOf("--\x3e") < 0);
        }
        /**
 * Returns true if the given line looks like the beginning of a region block.
 * @param {string} text
 * @returns {Boolean}
 */        function isStartOfRegionBlock(lines, index) {
            return !!lines[index] && /^REGION( .*)?$/g.test(lines[index]) && (
            // A cue identifer can also contain "REGION". Check that we have no timings
            // on the second line
            !lines[index + 1] || lines[index + 1].indexOf("--\x3e") < 0);
        }
        /**
 * Returns true if the line given looks like the beginning of a cue.
 * You should provide to this function only lines following "empty" lines.
 * @param {Array.<string>} lines
 * @param {number} index
 * @returns {Boolean}
 */        function isStartOfCueBlock(lines, index) {
            // checked cases:
            //   - empty lines
            //   - start of a comment
            //   - start of a region
            //   - start of a style
            // Anything else whose first or second line is a timestamp line is a cue.
            var firstLine = lines[index];
            if (!firstLine || isStartOfStyleBlock(lines, index) || isStartOfRegionBlock(lines, index) || isStartOfNoteBlock(lines, index)) return !1;
            if (firstLine.indexOf("--\x3e") >= 0) return !0;
            var secondLine = lines[index + 1];
            return !!secondLine && secondLine.indexOf("--\x3e") >= 0;
        }
        /**
 * Find end of current WebVTT cue block.
 * @param {Array<string>} linified
 * @param {number} startOfCueBlock
 * @returns {number}
 */        function findEndOfCueBlock(linified, startOfCueBlock) {
            // continue incrementing i until either:
            //   - empty line
            //   - end
            for (var firstEmptyLineIndex = startOfCueBlock + 1; linified[firstEmptyLineIndex]; ) firstEmptyLineIndex++;
            return firstEmptyLineIndex;
        }
        /***/        __webpack_require__.d(__webpack_exports__, "b", function() {
            return getFirstLineAfterHeader;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() {
            return isStartOfCueBlock;
        }), 
        /* unused harmony export isStartOfNoteBlock */
        /* unused harmony export isStartOfRegionBlock */
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() {
            return isStartOfStyleBlock;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return findEndOfCueBlock;
        });
    }, 
    /* 49 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        function hostReportError(err) {
            setTimeout(function() {
                throw err;
            });
        }
        //# sourceMappingURL=hostReportError.js.map
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return hostReportError;
        });
    }, 
    /* 50 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return rxSubscriber;
        });
        /* unused harmony export $$rxSubscriber */
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        var rxSubscriber = "function" == typeof Symbol && "function" == typeof Symbol.for ? /* */ Symbol.for("rxSubscriber") : "@@rxSubscriber";
    }, 
    /* 51 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* unused harmony export getSymbolIterator */
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return iterator;
        });
        var iterator = /* */ 
        /* unused harmony export $$iterator */
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        function getSymbolIterator() {
            return "function" == typeof Symbol && Symbol.iterator ? Symbol.iterator : "@@iterator";
        }();
    }, 
    /* 52 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Generate a normalized error message.
 * @param {string} name
 * @param {string} code
 * @param {Error|string} [reason]
 * @returns {string}
 */
        function errorMessage(name, code, reason) {
            return null == reason ? name + " (" + code + ")" : "string" == typeof reason ? name + " (" + code + ") " + reason : name + " (" + code + ") " + (reason instanceof Event ? reason.type : reason.message);
        }
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return errorMessage;
        });
    }, 
    /* 53 */ 
    /* 54 */
    /***/ , 
    /* 54 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return map;
        });
        /* unused harmony export MapOperator */
        /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2), _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);
        /* harmony import */        
        /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
        function map(project, thisArg) {
            return function mapOperation(source) {
                if ("function" != typeof project) throw new TypeError("argument is not a function. Are you looking for `mapTo()`?");
                return source.lift(new MapOperator(project, thisArg));
            };
        }
        var MapOperator = /* */ function() {
            function MapOperator(project, thisArg) {
                this.project = project, this.thisArg = thisArg;
            }
            return MapOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
            }, MapOperator;
        }(), MapSubscriber = /* */ function(_super) {
            function MapSubscriber(destination, project, thisArg) {
                var _this = _super.call(this, destination) || this;
                return _this.project = project, _this.count = 0, _this.thisArg = thisArg || _this, 
                _this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(MapSubscriber, _super), MapSubscriber.prototype._next = function(value) {
                var result;
                try {
                    result = this.project.call(this.thisArg, value, this.count++);
                } catch (err) {
                    return void this.destination.error(err);
                }
                this.destination.next(result);
            }, MapSubscriber;
        }(_Subscriber__WEBPACK_IMPORTED_MODULE_1__.a);
    }, 
    /* 55 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "c", function() {
            return getTRAF;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return getMDAT;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() {
            return getMDIA;
        });
        /* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9), _utils_bytes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1);
        /* harmony import */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {Uint8Array} buf - the isobmff structure
 * @param {Number} boxName - the 'name' of the box (e.g. 'sidx' or 'moov'),
 * hexa encoded
 * @returns {UInt8Array|null}
 */
        function getBox(buf, boxName) {
            for (var l = buf.length, i = 0, name = void 0, size = 0; i + 8 < l && (size = Object(_utils_bytes__WEBPACK_IMPORTED_MODULE_1__.c)(buf, i), 
            name = Object(_utils_bytes__WEBPACK_IMPORTED_MODULE_1__.c)(buf, i + 4), Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__.b)(size > 0, "out of range size"), 
            name !== boxName); ) i += size;
            return i < l ? buf.subarray(i + 8, i + size) : null;
        }
        /**
 * Returns TRAF Box from the whole ISOBMFF File.
 * Returns null if not found.
 * @param {Uint8Array} buffer
 * @returns {Uint8Array|null}
 */        function getTRAF(buffer) {
            var moof = getBox(buffer, 1836019558 /* moof */);
            return moof ? getBox(moof, 1953653094 /* traf */) : null;
        }
        /**
 * Returns MDAT Box from the whole ISOBMFF File.
 * Returns null if not found.
 * @param {Uint8Array} buffer
 * @returns {Uint8Array|null}
 */        function getMDAT(buf) {
            return getBox(buf, 1835295092 /* "mdat" */);
        }
        /**
 * Returns MDIA Box from the whole ISOBMFF File.
 * Returns null if not found.
 * @param {Uint8Array} buffer
 * @returns {Uint8Array|null}
 */        function getMDIA(buf) {
            var moov = getBox(buf, 1836019574 /* moov */);
            if (!moov) return null;
            var trak = getBox(moov, 1953653099 /* "trak" */);
            return trak ? getBox(trak, 1835297121 /* "mdia" */) : null;
        }
        /***/    }, 
    /* 56 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Request fullScreen action on a given element.
 * @param {HTMLElement} elt
 * rs-detect)
 */
        function requestFullscreen(elt) {
            isFullscreen() || (elt.requestFullscreen ? elt.requestFullscreen() : elt.msRequestFullscreen ? elt.msRequestFullscreen() : elt.mozRequestFullScreen ? elt.mozRequestFullScreen() : elt.webkitRequestFullscreen && 
            // TODO Open issue in TypeScript?
            elt.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT));
        }
        /**
 * Exit fullscreen if an element is currently in fullscreen.
 * TODO this exit fullscreen mode even if any element in the document is in
 * fullscreen, is it really what we want?
 */        function exitFullscreen() {
            isFullscreen() && (document.exitFullscreen ? document.exitFullscreen() : document.msExitFullscreen ? document.msExitFullscreen() : document.mozCancelFullScreen ? document.mozCancelFullScreen() : document.webkitExitFullscreen && document.webkitExitFullscreen());
        }
        /**
 * Returns true if an element in the document is being displayed in fullscreen
 * mode;
 * otherwise it's false.
 * @returns {boolean}
 */        function isFullscreen() {
            return !!(document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement);
        }
        /***/        __webpack_require__.d(__webpack_exports__, "c", function() {
            return requestFullscreen;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return exitFullscreen;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() {
            return isFullscreen;
        });
    }, 
    /* 57 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return mergeMap;
        });
        /* unused harmony export MergeMapOperator */
        /* unused harmony export MergeMapSubscriber */
        /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2), _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(24), _OuterSubscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(23), _map__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(54), _observable_from__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(44);
        /* harmony import */        
        /** PURE_IMPORTS_START tslib,_util_subscribeToResult,_OuterSubscriber,_map,_observable_from PURE_IMPORTS_END */
        function mergeMap(project, resultSelector, concurrent) {
            return void 0 === concurrent && (concurrent = Number.POSITIVE_INFINITY), "function" == typeof resultSelector ? function(source) {
                return source.pipe(mergeMap(function(a, i) {
                    return Object(_observable_from__WEBPACK_IMPORTED_MODULE_4__.a)(project(a, i)).pipe(Object(_map__WEBPACK_IMPORTED_MODULE_3__.a)(function(b, ii) {
                        return resultSelector(a, b, i, ii);
                    }));
                }, concurrent));
            } : ("number" == typeof resultSelector && (concurrent = resultSelector), function(source) {
                return source.lift(new MergeMapOperator(project, concurrent));
            });
        }
        var MergeMapOperator = /* */ function() {
            function MergeMapOperator(project, concurrent) {
                void 0 === concurrent && (concurrent = Number.POSITIVE_INFINITY), this.project = project, 
                this.concurrent = concurrent;
            }
            return MergeMapOperator.prototype.call = function(observer, source) {
                return source.subscribe(new MergeMapSubscriber(observer, this.project, this.concurrent));
            }, MergeMapOperator;
        }(), MergeMapSubscriber = /* */ function(_super) {
            function MergeMapSubscriber(destination, project, concurrent) {
                void 0 === concurrent && (concurrent = Number.POSITIVE_INFINITY);
                var _this = _super.call(this, destination) || this;
                return _this.project = project, _this.concurrent = concurrent, _this.hasCompleted = !1, 
                _this.buffer = [], _this.active = 0, _this.index = 0, _this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(MergeMapSubscriber, _super), MergeMapSubscriber.prototype._next = function(value) {
                this.active < this.concurrent ? this._tryNext(value) : this.buffer.push(value);
            }, MergeMapSubscriber.prototype._tryNext = function(value) {
                var result, index = this.index++;
                try {
                    result = this.project(value, index);
                } catch (err) {
                    return void this.destination.error(err);
                }
                this.active++, this._innerSub(result, value, index);
            }, MergeMapSubscriber.prototype._innerSub = function(ish, value, index) {
                this.add(Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__.a)(this, ish, value, index));
            }, MergeMapSubscriber.prototype._complete = function() {
                this.hasCompleted = !0, 0 === this.active && 0 === this.buffer.length && this.destination.complete();
            }, MergeMapSubscriber.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
                this.destination.next(innerValue);
            }, MergeMapSubscriber.prototype.notifyComplete = function(innerSub) {
                var buffer = this.buffer;
                this.remove(innerSub), this.active--, buffer.length > 0 ? this._next(buffer.shift()) : 0 === this.active && this.hasCompleted && this.destination.complete();
            }, MergeMapSubscriber;
        }(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_2__.a);
    }, 
    /* 58 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {Element} tt
 * @returns {Element}
 */
        function getBodyNode(tt) {
            return tt.getElementsByTagName("body")[0];
        }
        /**
 * @param {Element} tt - <tt> node
 * @returns {Array.<Element>}
 */        function getStyleNodes(tt) {
            return tt.getElementsByTagName("style");
        }
        /**
 * @param {Element} tt - <tt> node
 * @returns {Array.<Element>}
 */        function getRegionNodes(tt) {
            return tt.getElementsByTagName("region");
        }
        /**
 * @param {Element} tt - <tt> node
 * @returns {Array.<Element>}
 */        function getTextNodes(tt) {
            return tt.getElementsByTagName("p");
        }
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return getBodyNode;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() {
            return getStyleNodes;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() {
            return getRegionNodes;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() {
            return getTextNodes;
        });
    }, 
    /* 59 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Simple hash-based set.
 * @class SimpleSet
 */        var SimpleSet = function() {
            function SimpleSet() {
                _classCallCheck(this, SimpleSet), this._hashes = {};
            }
            /**
   * Add a new hash entry in the set.
   * Do not have any effect on already-added hashes
   * @param {string|number} x
   */            return SimpleSet.prototype.add = function add(x) {
                this._hashes[x] = !0;
            }, 
            /**
   * Remove an hash entry from the set.
   * Do not have any effect on already-removed or inexistant hashes
   * @param {string|number} x
   */
            SimpleSet.prototype.remove = function remove(x) {
                delete this._hashes[x];
            }, 
            /**
   * Test if the given hash has an entry in the set.
   * @param {string|number} x
   * @returns {boolean}
   */
            SimpleSet.prototype.test = function test(x) {
                return !!this._hashes[x];
            }, 
            /**
   * Returns true if there's currently no hash in this set.
   * @returns {boolean}
   */
            SimpleSet.prototype.isEmpty = function isEmpty() {
                return !Object.keys(this._hashes).length;
            }, SimpleSet;
        }();
        /* harmony default export */        __webpack_exports__.a = SimpleSet;
    }, 
    /* 60 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Returns the parent elements which have the given tagName, by order of
 * closeness relative to our element.
 * @param {Element|Node} element
 * @param {string} tagName
 * @returns {Array.<Element>}
 */
        function getParentElementsByTagName(element, tagName) {
            if (!(element.parentNode instanceof Element)) return [];
            return function constructArray(_element) {
                var elements = [];
                _element.tagName.toLowerCase() === tagName.toLowerCase() && elements.push(_element);
                var parentNode = _element.parentNode;
                return parentNode instanceof Element && elements.push.apply(elements, constructArray(parentNode)), 
                elements;
            }(element.parentNode);
        }
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return getParentElementsByTagName;
        });
    }, 
    /* 61 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/of.js
                var of = __webpack_require__(75), assert = __webpack_require__(9), eventemitter = __webpack_require__(41), rx_tryCatch = __webpack_require__(45), ranges = __webpack_require__(21);
        // EXTERNAL MODULE: ./src/utils/assert.ts + 1 modules
                // CONCATENATED MODULE: ./src/core/source_buffers/time_ranges.ts
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Simulate TimeRanges as returned by SourceBuffer.prototype.buffered.
 * Add an "insert" and "remove" methods to manually update it.
 * @class ManualTimeRanges
 */        var time_ranges = function() {
            function ManualTimeRanges() {
                _classCallCheck(this, ManualTimeRanges), this._ranges = [], this.length = 0;
            }
            return ManualTimeRanges.prototype.insert = function insert(start, end) {
                Object(ranges.h)(this._ranges, {
                    start: start,
                    end: end
                }), this.length = this._ranges.length;
            }, ManualTimeRanges.prototype.remove = function remove(start, end) {
                var rangesToIntersect = [];
                start > 0 && rangesToIntersect.push({
                    start: 0,
                    end: start
                }), end < Infinity && rangesToIntersect.push({
                    start: end,
                    end: Infinity
                }), Object(ranges.i)(this._ranges, rangesToIntersect), this.length = this._ranges.length;
            }, ManualTimeRanges.prototype.start = function start(index) {
                if (index >= this._ranges.length) throw new Error("INDEX_SIZE_ERROR");
                return this._ranges[index].start;
            }, ManualTimeRanges.prototype.end = function end(index) {
                if (index >= this._ranges.length) throw new Error("INDEX_SIZE_ERROR");
                return this._ranges[index].end;
            }, ManualTimeRanges;
        }();
        /* harmony default export */        
        // CONCATENATED MODULE: ./src/core/source_buffers/abstract_source_buffer.ts
        function abstract_source_buffer_classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        function _possibleConstructorReturn(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" != typeof call && "function" != typeof call ? self : call;
        }
        function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Abstract class for a custom SourceBuffer implementation.
 * @class AbstractSourceBuffer
 * @extends EventEmitter
 */        var abstract_source_buffer_AbstractSourceBuffer = function(_EventEmitter) {
            function AbstractSourceBuffer() {
                abstract_source_buffer_classCallCheck(this, AbstractSourceBuffer);
                var _this = _possibleConstructorReturn(this, _EventEmitter.call(this));
                return _this.updating = !1, _this.readyState = "opened", _this.buffered = new time_ranges(), 
                _this.timestampOffset = 0, _this;
            }
            /**
     * Mimic the SourceBuffer _appendBuffer_ method: Append segment.
     * @param {*} data
     */            return _inherits(AbstractSourceBuffer, _EventEmitter), AbstractSourceBuffer.prototype.appendBuffer = function appendBuffer(data) {
                var _this2 = this;
                this._lock(function() {
                    return _this2._append(data);
                });
            }, 
            /**
     * Mimic the SourceBuffer _remove_ method: remove segment.
     * @param {Number} from
     * @param {Number} to
     */
            AbstractSourceBuffer.prototype.remove = function remove(from, to) {
                var _this3 = this;
                this._lock(function() {
                    return _this3._remove(from, to);
                });
            }, 
            /**
     * Mimic the SourceBuffer _abort_ method.
     */
            AbstractSourceBuffer.prototype.abort = function abort() {
                this.remove(0, Infinity), this.updating = !1, this.readyState = "closed", this._abort();
            }, 
            /**
     * Active a lock, execute the given function, unlock when finished (on
     * nextTick).
     * Throws if multiple lock are active at the same time.
     * Also triggers the right events on start, error and end
     * @param {Function} func
     */
            AbstractSourceBuffer.prototype._lock = function _lock(func) {
                var _this4 = this;
                Object(assert.b)(!this.updating, "updating"), this.updating = !0, this.trigger("updatestart", void 0), 
                Object(rx_tryCatch.a)(function() {
                    return func(), Object(of.a)(void 0);
                }).subscribe(function() {
                    return setTimeout(function() {
                        _this4._unlock("update");
                    }, 0);
                }, function(e) {
                    return setTimeout(function() {
                        _this4._unlock("error", e);
                    }, 0);
                });
            }, 
            /**
     * Free the lock and trigger the right events.
     * @param {string} eventName
     * @param {*} value - value sent with the given event.
     */
            AbstractSourceBuffer.prototype._unlock = function _unlock(eventName, value) {
                this.updating = !1, this.trigger(eventName, value), this.trigger("updateend", void 0);
            }, AbstractSourceBuffer;
        }(eventemitter.a);
        /* harmony default export */        __webpack_exports__.a = abstract_source_buffer_AbstractSourceBuffer;
    }, 
    /* 62 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return empty;
        });
        /* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(32), _util_hostReportError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(49), empty = {
            closed: !0,
            next: function(value) {},
            error: function(err) {
                if (_config__WEBPACK_IMPORTED_MODULE_0__.a.useDeprecatedSynchronousErrorHandling) throw err;
                Object(_util_hostReportError__WEBPACK_IMPORTED_MODULE_1__.a)(err);
            },
            complete: function() {}
        };
        /* harmony import */    }, 
    /* 63 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return tryCatch;
        });
        /* harmony import */ var tryCatchTarget, _errorObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(31);
        /** PURE_IMPORTS_START _errorObject PURE_IMPORTS_END */        function tryCatcher() {
            try {
                return tryCatchTarget.apply(this, arguments);
            } catch (e) {
                return _errorObject__WEBPACK_IMPORTED_MODULE_0__.a.e = e, _errorObject__WEBPACK_IMPORTED_MODULE_0__.a;
            }
        }
        function tryCatch(fn) {
            return tryCatchTarget = fn, tryCatcher;
        }
        //# sourceMappingURL=tryCatch.js.map
        /***/    }, 
    /* 64 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "b", function() {
            return getFuzzedDelay;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return getBackedoffDelay;
        });
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        var FUZZ_FACTOR = .3;
        /**
 * Perform "fuzzing" on the delay given.
 * @param {Number} retryDelay
 * @returns {Number}
 */        function getFuzzedDelay(retryDelay) {
            return retryDelay * ((2 * Math.random() - 1) * FUZZ_FACTOR + 1);
 // Max 1.3 Min 0.7
                }
        /**
 * Calculate a "backed off" fuzzed delay.
 * That is, a delay augmented depending on the current retry count.
 * @param {Number} retryDelay
 * @param {Number|undefined} retryCount
 * @returns {Number}
 */        function getBackedoffDelay(retryDelay) {
            var retryCount = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
            return getFuzzedDelay(retryDelay * Math.pow(2, retryCount - 1));
        }
        /***/    }, 
    /* 65 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return isNumeric;
        });
        /* harmony import */ var _isArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(42);
        /** PURE_IMPORTS_START _isArray PURE_IMPORTS_END */        function isNumeric(val) {
            return !Object(_isArray__WEBPACK_IMPORTED_MODULE_0__.a)(val) && val - parseFloat(val) + 1 >= 0;
        }
        //# sourceMappingURL=isNumeric.js.map
        /***/    }, 
    /* 66 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/defer.js
        var defer = __webpack_require__(133), empty = __webpack_require__(26), combineLatest = __webpack_require__(146), merge = __webpack_require__(134), ignoreElements = __webpack_require__(145), mergeMap = __webpack_require__(57), map = __webpack_require__(54), tap = __webpack_require__(148), compat = __webpack_require__(12), events = __webpack_require__(8), noop = __webpack_require__(29), of = __webpack_require__(75), mapTo = __webpack_require__(136), castToObservable = __webpack_require__(15), MediaKeys = __webpack_require__(131);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/empty.js
                // CONCATENATED MODULE: ./src/compat/eme/setMediaKeys.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Set the MediaKeys given on the media element.
 * @param {HTMLMediaElement} elt
 * @param {Object} mediaKeys
 * @returns {*}
 */
        function _setMediaKeys(elt, mediaKeys) {
            return mediaKeys instanceof MediaKeys.a ? mediaKeys._setVideo(elt) : elt.setMediaKeys ? elt.setMediaKeys(mediaKeys) : null !== mediaKeys ? elt.WebkitSetMediaKeys ? elt.WebkitSetMediaKeys(mediaKeys) : elt.mozSetMediaKeys ? elt.mozSetMediaKeys(mediaKeys) : elt.msSetMediaKeys ? elt.msSetMediaKeys(mediaKeys) : void 0 : void 0;
        }
        /**
 * Set the given MediaKeys on the given HTMLMediaElement.
 * Emits null when done then complete.
 * @param {HTMLMediaElement} elt
 * @param {Object} mediaKeys
 * @returns {Observable}
 */        function setMediaKeys$(elt, mediaKeys) {
            return Object(defer.a)(function() {
                return Object(castToObservable.a)(_setMediaKeys(elt, mediaKeys)).pipe(Object(mapTo.a)(null));
            });
        }
        // EXTERNAL MODULE: ./src/log.ts + 1 modules
                var log = __webpack_require__(0);
        // CONCATENATED MODULE: ./src/core/eme/attach_media_keys.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Set the MediaKeys object on the HTMLMediaElement if it is not already on the
 * element.
 * If a MediaKeys was already set on it, dispose of it before setting the new
 * one.
 *
 * /!\ Mutates heavily currentMediaKeysInfos
 * @param {Object} mediaKeysInfos
 * @param {HTMLMediaElement} mediaElement
 * @param {Object} currentMediaKeysInfos
 * @returns {Observable}
 */        function attachMediaKeys(mediaKeysInfos, mediaElement, currentMediaKeysInfos) {
            return Object(defer.a)(function() {
                var previousState = currentMediaKeysInfos.getState(mediaElement), keySystemOptions = mediaKeysInfos.keySystemOptions, mediaKeySystemAccess = mediaKeysInfos.mediaKeySystemAccess, mediaKeys = mediaKeysInfos.mediaKeys, sessionsStore = mediaKeysInfos.sessionsStore;
                return currentMediaKeysInfos.setState(mediaElement, {
                    keySystemOptions: keySystemOptions,
                    mediaKeySystemAccess: mediaKeySystemAccess,
                    mediaKeys: mediaKeys,
                    sessionsStore: sessionsStore
                }), (previousState && previousState.sessionsStore !== sessionsStore ? previousState.sessionsStore.closeAllSessions() : Object(of.a)(null)).pipe(Object(mergeMap.a)(function() {
                    return mediaElement.mediaKeys === mediaKeys ? Object(of.a)(null) : (log.a.debug("eme: set mediakeys"), 
                    setMediaKeys$(mediaElement, mediaKeys));
                }));
            });
        }
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/mergeMapTo.js
                var mergeMapTo = __webpack_require__(144);
        // CONCATENATED MODULE: ./src/core/eme/dispose_media_keys.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {Object} mediaKeysInfos
 * @returns {Observable}
 */        function disposeMediaKeys(mediaElement, mediaKeysInfos) {
            return Object(defer.a)(function() {
                var currentState = mediaKeysInfos.getState(mediaElement);
                if (!currentState) return Object(of.a)(null);
                var sessionsStore = currentState.sessionsStore;
                return mediaKeysInfos.clearState(mediaElement), sessionsStore.closeAllSessions().pipe(Object(mergeMapTo.a)(setMediaKeys$(mediaElement, null)));
            });
        }
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/catchError.js
                var catchError = __webpack_require__(143), EncryptedMediaError = __webpack_require__(80);
        // EXTERNAL MODULE: ./src/errors/EncryptedMediaError.ts
                // CONCATENATED MODULE: ./src/core/eme/generate_key_request.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Generate a request from session.
 * @param {MediaKeySession} session
 * @param {Uint8Array} initData
 * @param {string} initDataType
 * @param {string} sessionType
 * @returns {Observable}
 */
        function generateKeyRequest(session, initData, initDataType) {
            return Object(defer.a)(function() {
                return Object(castToObservable.a)(session.generateRequest(initDataType || "", initData)).pipe(Object(catchError.a)(function(error) {
                    throw new EncryptedMediaError.a("KEY_GENERATE_REQUEST_ERROR", error, !1);
                }), Object(mapTo.a)(null));
            });
        }
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Observable.js + 2 modules
                var Observable = __webpack_require__(6), config = __webpack_require__(3), array_includes = __webpack_require__(14), EME_DEFAULT_WIDEVINE_ROBUSTNESSES = config.a.EME_DEFAULT_WIDEVINE_ROBUSTNESSES, EME_KEY_SYSTEMS = config.a.EME_KEY_SYSTEMS;
        // EXTERNAL MODULE: ./src/config.ts
                /**
 * @param {Array.<Object>} keySystems
 * @param {Object} currentMediaKeysInfos
 * @returns {null|Object}
 */
        function checkCachedMediaKeySystemAccess(keySystems, currentKeySystemAccess, currentKeySystemOptions) {
            var mksConfiguration = currentKeySystemAccess.getConfiguration();
            // NOTE(pierre): alwaysRenew flag is used for IE11 which require the
            // creation of a new MydiaKeys instance for each session creation
                        if (Object(compat.l)() || !mksConfiguration) return null;
            var firstCompatibleOption = keySystems.filter(function(ks) {
                // XXX TODO Do it with MediaKeySystemAccess.prototype.keySystem instead
                return ks.type === currentKeySystemOptions.type && ((!ks.persistentLicense || "required" === mksConfiguration.persistentState) && (!ks.distinctiveIdentifierRequired || "required" === mksConfiguration.distinctiveIdentifier));
            })[0];
            return firstCompatibleOption ? {
                keySystemOptions: firstCompatibleOption,
                keySystemAccess: currentKeySystemAccess
            } : null;
        }
        /**
 * Find key system canonical name from key system type.
 * @param {string} ksType - Obtained via inversion
 * @returns {string|undefined} - Either the canonical name, or undefined.
 */        function findKeySystemCanonicalName(ksType) {
            var _iterator = Object.keys(EME_KEY_SYSTEMS), _isArray = Array.isArray(_iterator), _i = 0;
            for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                var _ref;
                if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                } else {
                    if ((_i = _iterator.next()).done) break;
                    _ref = _i.value;
                }
                var ksName = _ref;
                if (Object(array_includes.a)(EME_KEY_SYSTEMS[ksName], ksType)) return ksName;
            }
        }
        /**
 * Build configuration for the requestMediaKeySystemAccess EME API, based
 * on the current keySystem object.
 * @param {string} [ksName] - Generic name for the key system. e.g. "clearkey",
 * "widevine", "playready". Can be used to make exceptions depending on it.
 * @param {Object} keySystem
 * @returns {Array.<Object>} - Configuration to give to the
 * requestMediaKeySystemAccess API.
 */        function buildKeySystemConfigurations(ksName, keySystem) {
            var sessionTypes = [ "temporary" ], persistentState = "optional", distinctiveIdentifier = "optional";
            keySystem.persistentLicense && (persistentState = "required", sessionTypes.push("persistent-license")), 
            keySystem.persistentStateRequired && (persistentState = "required"), keySystem.distinctiveIdentifierRequired && (distinctiveIdentifier = "required");
            // Set robustness, in order of consideration:
            //   1. the user specified its own robustnesses
            //   2. a "widevine" key system is used, in that case set the default widevine
            //      robustnesses as defined in the config
            //   3. set an undefined robustness
            var videoRobustnesses = keySystem.videoRobustnesses || ("widevine" === ksName ? EME_DEFAULT_WIDEVINE_ROBUSTNESSES : []), audioRobustnesses = keySystem.audioRobustnesses || ("widevine" === ksName ? EME_DEFAULT_WIDEVINE_ROBUSTNESSES : []);
            // TODO Re-test with a set contentType but an undefined robustness on the
            // STBs on which this problem was found.
            //
            // add another with no {audio,video}Capabilities for some legacy browsers.
            // As of today's spec, this should return NotSupported but the first
            // candidate configuration should be good, so we should have no downside
            // doing that.
            // initDataTypes: ["cenc"],
            // videoCapabilities: undefined,
            // audioCapabilities: undefined,
            // distinctiveIdentifier,
            // persistentState,
            // sessionTypes,
            return videoRobustnesses.length || videoRobustnesses.push(void 0), audioRobustnesses.length || audioRobustnesses.push(void 0), 
            [ {
                initDataTypes: [ "cenc" ],
                videoCapabilities: videoRobustnesses.map(function(robustness) {
                    return {
                        contentType: 'video/mp4;codecs="avc1.4d401e"',
                        robustness: robustness
                    };
                }),
                audioCapabilities: audioRobustnesses.map(function(robustness) {
                    return {
                        contentType: 'audio/mp4;codecs="mp4a.40.2"',
                        robustness: robustness
                    };
                }),
                distinctiveIdentifier: distinctiveIdentifier,
                persistentState: persistentState,
                sessionTypes: sessionTypes
            } ];
        }
        /**
 * Try to find a compatible key system from the keySystems array given.
 *
 * Returns an Observable which, when subscribed to, will request a
 * MediaKeySystemAccess based on the various keySystems provided. This
 * Observable will:
 *   - emit the MediaKeySystemAccess and the keySystems as an object, when
 *     found. The object is under this form:
 *     {
 *       keySystemAccess {MediaKeySystemAccess}
 *       keySystem {Object}
 *     }
 *   - complete immediately after emitting.
 *   - throw if no  compatible key system has been found.
 *
 * @param {Array.<Object>} keySystems - The keySystems you want to test.
 * @param {Object} currentMediaKeysInfos
 * @returns {Observable}
 */        function getMediaKeySystemAccess(mediaElement, keySystemsConfigs, currentMediaKeysInfos) {
            return Object(defer.a)(function() {
                var currentState = currentMediaKeysInfos.getState(mediaElement);
                if (currentState) {
                    // Fast way to find a compatible keySystem if the currently loaded
                    // one as exactly the same compatibility options.
                    var cachedKeySystemAccess = checkCachedMediaKeySystemAccess(keySystemsConfigs, currentState.mediaKeySystemAccess, currentState.keySystemOptions);
                    if (cachedKeySystemAccess) return log.a.debug("eme: found cached compatible keySystem", cachedKeySystemAccess), 
                    Object(of.a)({
                        type: "reuse-media-key-system-access",
                        value: {
                            mediaKeySystemAccess: cachedKeySystemAccess.keySystemAccess,
                            options: cachedKeySystemAccess.keySystemOptions
                        }
                    });
                }
                /**
         * Array of set keySystems for this content.
         * Each item of this array is an object containing the following keys:
         *   - keyName {string}: keySystem canonical name (e.g. "widevine")
         *   - keyType {string}: keySystem type (e.g. "com.widevine.alpha")
         *   - keySystem {Object}: the original keySystem object
         * @type {Array.<Object>}
         */                var keySystemsType = keySystemsConfigs.reduce(function(arr, keySystemOptions) {
                    var managedRDNs = EME_KEY_SYSTEMS[keySystemOptions.type], ksType = void 0;
                    null != managedRDNs ? ksType = managedRDNs.map(function(keyType) {
                        return {
                            keyName: keySystemOptions.type,
                            keyType: keyType,
                            keySystemOptions: keySystemOptions
                        };
                    }) : ksType = [ {
                        keyName: findKeySystemCanonicalName(keySystemOptions.type) || "",
                        keyType: keySystemOptions.type,
                        keySystemOptions: keySystemOptions
                    } ];
                    return arr.concat(ksType);
                }, []);
                return Observable.a.create(function(obs) {
                    var disposed = !1, sub = void 0;
                    /**
             * Test the key system as defined in keySystemsType[index].
             * @param {Number} index
             */
                    return function testKeySystem(index) {
                        // completely quit the loop if unsubscribed
                        if (!disposed) 
                        // if we iterated over the whole keySystemsType Array, quit on error
                        if (index >= keySystemsType.length) obs.error(new EncryptedMediaError.a("INCOMPATIBLE_KEYSYSTEMS", null, !0)); else {
                            var _keySystemsType$index = keySystemsType[index], keyName = _keySystemsType$index.keyName, keyType = _keySystemsType$index.keyType, keySystemOptions = _keySystemsType$index.keySystemOptions, keySystemConfigurations = buildKeySystemConfigurations(keyName, keySystemOptions);
                            if (log.a.debug("eme: request keysystem access " + keyType + "," + (index + 1) + " of " + keySystemsType.length, keySystemConfigurations), 
                            null == MediaKeys.b) throw new Error("requestMediaKeySystemAccess is not implemented in your browser.");
                            sub = Object(MediaKeys.b)(keyType, keySystemConfigurations).subscribe(function(keySystemAccess) {
                                log.a.info("eme: found compatible keysystem", keyType, keySystemConfigurations), 
                                obs.next({
                                    type: "create-media-key-system-access",
                                    value: {
                                        options: keySystemOptions,
                                        mediaKeySystemAccess: keySystemAccess
                                    }
                                }), obs.complete();
                            }, function() {
                                log.a.debug("eme: rejected access to keysystem", keyType, keySystemConfigurations), 
                                sub = null, testKeySystem(index + 1);
                            });
                        }
                    }(0), function() {
                        disposed = !0, sub && sub.unsubscribe();
                    };
                });
            });
        }
        // CONCATENATED MODULE: ./src/core/eme/set_server_certificate.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Call the setServerCertificate API with the given certificate.
 * Complete when worked, throw when failed.
 *
 * TODO Manage success?
 * From the spec:
 *   - setServerCertificate resolves with true if everything worked
 *   - it resolves with false if the CDM does not support server
 *     certificates.
 *
 * @param {MediaKeys} mediaKeys
 * @param {ArrayBuffer} serverCertificate
 * @returns {Observable}
 */        function setServerCertificate(mediaKeys, serverCertificate) {
            return Object(defer.a)(function() {
                return Object(castToObservable.a)(mediaKeys.setServerCertificate(serverCertificate)).pipe(Object(catchError.a)(function(error) {
                    throw new EncryptedMediaError.a("LICENSE_SERVER_CERTIFICATE_ERROR", error, !0);
                }));
            }).pipe(Object(mapTo.a)(null));
        }
        /**
 * Call the setCertificate API. If it fails just emit the error through the
 * errorStream and complete.
 * @param {MediaKeys} mediaKeys
 * @param {ArrayBuffer} serverCertificate
 * @returns {Observable}
 */        function trySettingServerCertificate(mediaKeys, serverCertificate, errorStream) {
            return "function" == typeof mediaKeys.setServerCertificate ? setServerCertificate(mediaKeys, serverCertificate).pipe(Object(catchError.a)(function(error) {
                return error.fatal = !1, errorStream.next(error), Object(of.a)(null);
            })) : Object(of.a)(null);
        }
        // EXTERNAL MODULE: ./node_modules/array-find/find.js
                var find = __webpack_require__(13), find_default = /* */ __webpack_require__.n(find), concat = __webpack_require__(107);
        // CONCATENATED MODULE: ./src/utils/hash_buffer.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Convert given buffer to a 32bit integer hash
 * @param {Array|TypedArray} buffer
 * @returns {Number}
 */
        function hashBuffer(buffer) {
            for (var hash = 0, i = 0; i < buffer.length; i++) hash = (hash << 5) - hash + buffer[i], 
            hash &= hash;
            return hash;
        }
        // CONCATENATED MODULE: ./src/core/eme/utils/open_sessions_store.ts
                function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Create and store MediaKeySessions linked to a single MediaKeys
 * instance.
 *
 * Keep track of sessionTypes and of the initialization data each
 * MediaKeySession is created for.
 * @class MediaKeySessionsStore
 */        var open_sessions_store = function() {
            function MediaKeySessionsStore(mediaKeys) {
                _classCallCheck(this, MediaKeySessionsStore), this._mediaKeys = mediaKeys, this._entries = [];
            }
            /**
     * @returns {Array.<Object>}
     */            return MediaKeySessionsStore.prototype.getAll = function getAll() {
                return this._entries.map(function(entry) {
                    return {
                        session: entry.session,
                        sessionType: entry.sessionType
                    };
                });
            }, 
            /**
     * Returns an entry in this cache with the initData and initDataType given.
     * null if no such session is stored.
     *
     * @param {Uint8Array} initData
     * @param {string|undefined} initDataType
     * @returns {Object|null}
     */
            MediaKeySessionsStore.prototype.get = function get(initData, initDataType) {
                var initDataHash = hashBuffer(initData), foundEntry = find_default()(this._entries, function(entry) {
                    return entry.initData === initDataHash && entry.initDataType === initDataType;
                });
                return foundEntry ? {
                    session: foundEntry.session,
                    sessionType: foundEntry.sessionType
                } : null;
            }, 
            /**
     * @param {Uint8Array} initData
     * @param {string|undefined} initDataType
     * @param {string} sessionType
     * @returns {MediaKeySession}
     * @throws {EncryptedMediaError}
     */
            MediaKeySessionsStore.prototype.createSession = function createSession(initData, initDataType, sessionType) {
                var _this = this;
                if (this.get(initData, initDataType)) {
                    var error = new Error("This initialization data was already stored.");
                    throw new EncryptedMediaError.a("MULTIPLE_SESSIONS_SAME_INIT_DATA", error, !0);
                }
                var session = this._mediaKeys /* TS bug */ .createSession(sessionType), entry = {
                    session: session,
                    sessionType: sessionType,
                    initData: hashBuffer(initData),
                    initDataType: initDataType
                };
                return null !== session.closed && session.closed.then(function() {
                    _this._delete(session);
                }).catch(function(e) {
                    log.a.warn("session.closed rejected: " + e);
                }), log.a.debug("eme-mem-store: add session", entry), this._entries.push(entry), 
                session;
            }, 
            /**
     * Close a MediaKeySession stored here and remove its entry in the store.
     * @param {MediaKeySession} session_
     * @returns {Observable}
     */
            MediaKeySessionsStore.prototype.closeSession = function closeSession(session_) {
                var _this2 = this;
                return Object(defer.a)(function() {
                    var session = _this2._delete(session_);
                    return null == session ? Object(of.a)(null) : (log.a.debug("eme-mem-store: close session", session), 
                    Object(castToObservable.a)(session.close()).pipe(Object(mapTo.a)(null), Object(catchError.a)(function() {
                        return Object(of.a)(null);
                    })));
                });
            }, 
            /**
     * Close all sessions in this store.
     * Emit null when done
     * @returns {Observable}
     */
            MediaKeySessionsStore.prototype.closeAllSessions = function closeAllSessions() {
                var _this3 = this;
                return Object(defer.a)(function() {
                    var disposed = _this3._entries.map(function(e) {
                        return _this3.closeSession(e.session);
                    });
                    return _this3._entries = [], Object(concat.a)(merge.a.apply(void 0, disposed).pipe(Object(ignoreElements.a)()), Object(of.a)(null));
                });
            }, 
            /**
     * Remove a MediaKeySession from the Cache, without closing it.
     * Returns the entry if found, null otherwise.
     * @param {MediaKeySession} session_
     * @returns {MediaKeySession|null}
     */
            MediaKeySessionsStore.prototype._delete = function _delete(session_) {
                var entry = find_default()(this._entries, function(e) {
                    return e.session === session_;
                });
                if (!entry) return null;
                var session = entry.session;
                log.a.debug("eme-mem-store: delete session", entry);
                var idx = this._entries.indexOf(entry);
                return this._entries.splice(idx, 1), session;
            }, MediaKeySessionsStore;
        }(), assert = __webpack_require__(9);
        /* harmony default export */        
        // CONCATENATED MODULE: ./src/core/eme/utils/persisted_session_store.ts
        function persisted_session_store_classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        function checkStorage(storage) {
            Object(assert.b)(null != storage, "no licenseStorage given for keySystem with persistentLicense"), 
            Object(assert.a)(storage, {
                save: "function",
                load: "function"
            }, "licenseStorage");
        }
        /**
 * Set representing persisted licenses. Depends on a simple local-
 * storage implementation with a `save`/`load` synchronous interface
 * to persist informations on persisted sessions.
 *
 * This set is used only for a cdm/keysystem with license persistency
 * supported.
 * @class PersistedSessionsStore
 */        var persisted_session_store = function() {
            /**
     * @param {Object} storage
     */
            function PersistedSessionsStore(storage) {
                persisted_session_store_classCallCheck(this, PersistedSessionsStore), checkStorage(storage), 
                this._entries = [], this._storage = storage;
                try {
                    this._entries = this._storage.load(), Object(assert.b)(Array.isArray(this._entries));
                } catch (e) {
                    log.a.warn("eme-persitent-store: could not get entries from license storage", e), 
                    this.dispose();
                }
            }
            /**
     * Retrieve entry (sessionId + initData) based on its initData.
     * @param {Uint8Array}  initData
     * @param {string|undefined} initDataType
     * @returns {Object|null}
     */            return PersistedSessionsStore.prototype.get = function get(initData, initDataType) {
                var hash = hashBuffer(initData);
                return find_default()(this._entries, function(e) {
                    return e.initData === hash && e.initDataType === initDataType;
                }) || null;
            }, 
            /**
     * Add a new entry in the storage.
     * @param {Uint8Array}  initData
     * @param {string|undefined} initDataType
     * @param {MediaKeySession} session
     */
            PersistedSessionsStore.prototype.add = function add(initData, initDataType, session) {
                var sessionId = session && session.sessionId;
                if (sessionId) {
                    var currentEntry = this.get(initData, initDataType);
                    currentEntry && currentEntry.sessionId === sessionId || (currentEntry && 
                    // currentEntry has a different sessionId
                    this.delete(initData, initDataType), log.a.info("eme-persitent-store: add new session", sessionId, session), 
                    this._entries.push({
                        sessionId: sessionId,
                        initData: hashBuffer(initData),
                        initDataType: initDataType
                    }), this._save());
                }
            }, 
            /**
     * Delete entry (sessionId + initData) based on its initData.
     * @param {Uint8Array}  initData
     * @param {string|undefined} initDataType
     */
            PersistedSessionsStore.prototype.delete = function _delete(initData, initDataType) {
                var hash = hashBuffer(initData), entry = find_default()(this._entries, function(e) {
                    return e.initData === hash && e.initDataType === initDataType;
                });
                if (entry) {
                    log.a.warn("eme-persitent-store: delete session from store", entry);
                    var idx = this._entries.indexOf(entry);
                    this._entries.splice(idx, 1), this._save();
                }
            }, 
            /**
     * Delete all saved entries.
     */
            PersistedSessionsStore.prototype.dispose = function dispose() {
                this._entries = [], this._save();
            }, 
            /**
     * Use the given storage to store the current entries.
     */
            PersistedSessionsStore.prototype._save = function _save() {
                try {
                    this._storage.save(this._entries);
                } catch (e) {
                    log.a.warn("eme-persitent-store: could not save licenses in localStorage");
                }
            }, PersistedSessionsStore;
        }();
        /* harmony default export */        
        // CONCATENATED MODULE: ./src/core/eme/get_media_keys.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {Object} keySystemOptions
 * @returns {Object|null}
 * @throws {EncryptedMediaError}
 */
        function createSessionStorage(keySystemOptions) {
            if (!keySystemOptions.persistentLicense) return null;
            var licenseStorage = keySystemOptions.licenseStorage;
            if (!licenseStorage) {
                var error = new Error("no license storage found for persistent license.");
                throw new EncryptedMediaError.a("INVALID_KEY_SYSTEM", error, !0);
            }
            return log.a.info("set the given license storage"), new persisted_session_store(licenseStorage);
        }
        function getMediaKeysInfos(mediaElement, keySystemsConfigs, currentMediaKeysInfos, errorStream) {
            return getMediaKeySystemAccess(mediaElement, keySystemsConfigs, currentMediaKeysInfos).pipe(Object(mergeMap.a)(function(evt) {
                var _evt$value = evt.value, options = _evt$value.options, mediaKeySystemAccess = _evt$value.mediaKeySystemAccess, currentState = currentMediaKeysInfos.getState(mediaElement), mediaKeys$ = void 0;
                if (null != currentState && "reuse-media-key-system-access" === evt.type) {
                    var mediaKeys = currentState.mediaKeys, sessionsStore = currentState.sessionsStore;
                    mediaKeys$ = Object(of.a)({
                        mediaKeys: mediaKeys,
                        sessionsStore: sessionsStore
                    });
                } else mediaKeys$ = Object(castToObservable.a)(mediaKeySystemAccess.createMediaKeys()).pipe(Object(map.a)(function(mediaKeys) {
                    return {
                        mediaKeys: mediaKeys,
                        sessionsStore: new open_sessions_store(mediaKeys)
                    };
                }));
                return mediaKeys$.pipe(Object(mergeMap.a)(function(_ref) {
                    var mediaKeys = _ref.mediaKeys, sessionsStore = _ref.sessionsStore, serverCertificate = options.serverCertificate;
                    return (null != serverCertificate ? trySettingServerCertificate(mediaKeys, serverCertificate, errorStream) : Object(of.a)(null)).pipe(Object(mapTo.a)({
                        mediaKeySystemAccess: mediaKeySystemAccess,
                        keySystemOptions: options,
                        mediaKeys: mediaKeys,
                        sessionsStore: sessionsStore,
                        sessionStorage: createSessionStorage(options)
                    }));
                }));
            }));
        }
        // EXTERNAL MODULE: ./src/utils/bytes.ts
                var bytes = __webpack_require__(1), simple_set = __webpack_require__(59), PSSH_TO_INTEGER = Object(bytes.c)(Object(bytes.p)("pssh"), 0);
        // EXTERNAL MODULE: ./src/utils/simple_set.ts
                /**
 * As we observed on some browsers (IE and Edge), the initialization data on
 * some segments have sometimes duplicated PSSH when sent through an encrypted
 * event (but not when pushed to the source buffer).
 *
 * This function tries to guess if the initialization data contains only PSSHs
 * concatenated (as it is usually the case).
 * If that's the case, it will filter duplicated PSSHs from it.
 *
 * @param {Uint8Array} initData
 * @returns {Uint8Array}
 */
        function cleanEncryptedEvent(initData) {
            for (var resInitData = new Uint8Array(), currentHashes = new simple_set.a(), offset = 0; offset < initData.length; ) {
                if (initData.length < offset + 8 || Object(bytes.c)(initData, offset + 4) !== PSSH_TO_INTEGER) return log.a.warn("unrecognized initialization data. Use as is."), 
                initData;
                var len = Object(bytes.c)(new Uint8Array(initData), offset);
                if (offset + len > initData.length) return log.a.warn("unrecognized initialization data. Use as is."), 
                initData;
                var currentPSSH = initData.subarray(offset, offset + len), currentPSSHHash = hashBuffer(currentPSSH);
                currentHashes.test(currentPSSHHash) ? log.a.warn("Duplicated PSSH found in initialization data, removing it.") : (currentHashes.add(currentPSSHHash), 
                resInitData = Object(bytes.h)(resInitData, currentPSSH)), offset += len;
            }
            return offset !== initData.length ? (log.a.warn("unrecognized initialization data. Use as is."), 
            initData) : resInitData;
        }
        /**
 * Take out the two things we need on an encryptedEvent:
 *   - the initialization Data
 *   - the initialization Data type
 *
 * @param {MediaEncryptedEvent} encryptedEvent
 * @returns {Object}
 * @throws {EncryptedMediaError} - Throws if no initialization data is
 * encountered in the given event.
 */        function getInitData(encryptedEvent) {
            var initData = encryptedEvent.initData;
            if (null == initData) {
                var error = new Error("no init data found on media encrypted event.");
                throw new EncryptedMediaError.a("INVALID_ENCRYPTED_EVENT", error, !0);
            }
            return {
                initData: cleanEncryptedEvent(new Uint8Array(initData)),
                initDataType: encryptedEvent.initDataType
            };
        }
        // CONCATENATED MODULE: ./src/core/eme/utils/is_session_usable.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * If all key statuses attached to session are valid (either not
 * "expired" or "internal-error"), return true.
 * If not, return false.
 * @param {Uint8Array} initData
 * @param {MediaKeySession} loadedSession
 * @returns {MediaKeySession}
 */        function isSessionUsable(loadedSession) {
            if ("" === loadedSession.sessionId) return !1;
            var keyStatuses = [];
            return loadedSession.keyStatuses.forEach(function(keyStatus) {
                keyStatuses.push(keyStatus);
            }), keyStatuses.length > 0 && !Object(array_includes.a)(keyStatuses, "expired") && !Object(array_includes.a)(keyStatuses, "internal-error") && (log.a.debug("eme: reuse loaded session", loadedSession.sessionId), 
            !0);
        }
        // CONCATENATED MODULE: ./src/core/eme/create_session.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * If session creating fails, retry once session creation/loading.
 * Emit true, if it has succeeded to load, false if there is no data for the
 * given sessionId.
 * @param {string} sessionId
 * @param {MediaKeySession} session
 * @returns {Observable}
 */        function loadPersistentSession(sessionId, session) {
            return Object(defer.a)(function() {
                return log.a.debug("eme: load persisted session", sessionId), Object(castToObservable.a)(session.load(sessionId));
            });
        }
        /**
 * Create a new Session on the given MediaKeys, corresponding to the given
 * initializationData.
 * If session creating fails, remove the oldest MediaKeySession loaded and
 * retry.
 *
 * /!\ This only creates new sessions.
 * It will fail if sessionsStore already has a MediaKeySession with
 * the given initializationData.
 * @param {Uint8Array} initData
 * @param {string|undefined} initDataType
 * @param {Object} mediaKeysInfos
 * @returns {Observable}
 */        function create_session_createSession(initData, initDataType, mediaKeysInfos) {
            return Object(defer.a)(function() {
                var keySystemOptions = mediaKeysInfos.keySystemOptions, mediaKeySystemAccess = mediaKeysInfos.mediaKeySystemAccess, sessionsStore = mediaKeysInfos.sessionsStore, sessionStorage = mediaKeysInfos.sessionStorage, sessionTypes = mediaKeySystemAccess.getConfiguration().sessionTypes, hasPersistence = sessionTypes && Object(array_includes.a)(sessionTypes, "persistent-license"), sessionType = hasPersistence && sessionStorage && keySystemOptions.persistentLicense ? "persistent-license" : "temporary";
                log.a.debug("eme: create a new " + sessionType + " session");
                var session = sessionsStore.createSession(initData, initDataType, sessionType);
                // Re-check for Dumb typescript
                                if (!hasPersistence || !sessionStorage || !keySystemOptions.persistentLicense) return Object(of.a)({
                    type: "created-session",
                    value: {
                        mediaKeySession: session,
                        sessionType: sessionType
                    }
                });
                var storedEntry = sessionStorage.get(initData, initDataType);
                if (!storedEntry) return Object(of.a)({
                    type: "created-session",
                    value: {
                        mediaKeySession: session,
                        sessionType: sessionType
                    }
                });
                /**
         * Helper function to close and restart the current persistent session
         * considered, and re-create it from scratch.
         * @returns {Observable}
         */                var recreatePersistentSession = function recreatePersistentSession() {
                    return log.a.info("eme: removing previous persistent session."), null !== sessionStorage.get(initData, initDataType) && sessionStorage.delete(initData, initDataType), 
                    sessionsStore.closeSession(session).pipe(Object(map.a)(function() {
                        return {
                            type: "created-session",
                            value: {
                                mediaKeySession: sessionsStore.createSession(initData, initDataType, sessionType),
                                sessionType: sessionType
                            }
                        };
                    }));
                };
                return loadPersistentSession(storedEntry.sessionId, session).pipe(Object(mergeMap.a)(function(hasLoadedSession) {
                    return hasLoadedSession ? hasLoadedSession && isSessionUsable(session) ? (sessionStorage.add(initData, initDataType, session), 
                    log.a.info("eme: succeeded to load persistent session."), Object(of.a)({
                        type: "loaded-persistent-session",
                        value: {
                            mediaKeySession: session,
                            sessionType: sessionType
                        }
                    })) : (
                    // Unusable persistent session: recreate a new session from scratch.
                    log.a.warn("eme: previous persistent session not usable anymore."), recreatePersistentSession()) : (log.a.warn("eme: no data stored for the loaded session"), 
                    sessionStorage.delete(initData, initDataType), Object(of.a)({
                        type: "created-session",
                        value: {
                            mediaKeySession: session,
                            sessionType: sessionType
                        }
                    }));
                }), Object(catchError.a)(function() {
                    return log.a.warn("eme: unable to load persistent session."), recreatePersistentSession();
                }));
            });
        }
        // CONCATENATED MODULE: ./src/core/eme/handle_encrypted_event.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        var MAX_SESSIONS = config.a.EME_MAX_SIMULTANEOUS_MEDIA_KEY_SESSIONS;
        /**
 * Handle MediaEncryptedEvents sent by a HTMLMediaElement:
 * Either create a session, skip the event if it is already handled or
 * recuperate a previous session and returns it.
 * @param {Event} encryptedEvent
 * @param {Object} handledInitData
 * @param {Object} mediaKeysInfos
 * @returns {Observable}
 */        function handleEncryptedEvent(encryptedEvent, handledInitData, mediaKeysInfos) {
            return Object(defer.a)(function() {
                var _getInitData = getInitData(encryptedEvent), initData = _getInitData.initData, initDataType = _getInitData.initDataType;
                if (handledInitData.has(initData, initDataType)) return log.a.debug("init data already received. Skipping it."), 
                empty.a;
 // Already handled, quit
                                handledInitData.add(initData, initDataType);
                // possible previous loaded session with the same initialization data
                var previousLoadedSession = null, sessionsStore = mediaKeysInfos.sessionsStore, entry = sessionsStore.get(initData, initDataType);
                if (null != entry) {
                    if (isSessionUsable(previousLoadedSession = entry.session)) return log.a.debug("eme: reuse loaded session", previousLoadedSession.sessionId), 
                    Object(of.a)({
                        type: "loaded-open-session",
                        value: {
                            mediaKeySession: previousLoadedSession,
                            sessionType: entry.sessionType,
                            initData: initData,
                            initDataType: initDataType
                        }
                    });
                    mediaKeysInfos.sessionStorage && mediaKeysInfos.sessionStorage.delete(new Uint8Array(initData), initDataType);
                }
                return (previousLoadedSession ? sessionsStore.closeSession(previousLoadedSession) : Object(of.a)(null)).pipe(Object(mergeMap.a)(function() {
                    var cleaningOldSessions$ = [], entries = sessionsStore.getAll().slice();
                    if (MAX_SESSIONS > 0 && MAX_SESSIONS <= entries.length) for (var i = 0; i < MAX_SESSIONS - entries.length + 1; i++) cleaningOldSessions$.push(sessionsStore.closeSession(entries[i].session));
                    return Object(concat.a)(merge.a.apply(void 0, cleaningOldSessions$).pipe(Object(ignoreElements.a)()), create_session_createSession(initData, initDataType, mediaKeysInfos).pipe(Object(map.a)(function(evt) {
                        return {
                            type: evt.type,
                            value: {
                                mediaKeySession: evt.value.mediaKeySession,
                                sessionType: evt.value.sessionType,
                                initData: initData,
                                initDataType: initDataType
                            }
                        };
                    })));
                }));
            });
        }
        // EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js
                var tslib_es6 = __webpack_require__(2), TimeoutError_TimeoutError = /* */ function(_super) {
            function TimeoutError() {
                var _this = _super.call(this, "Timeout has occurred") || this;
                return _this.name = "TimeoutError", Object.setPrototypeOf(_this, TimeoutError.prototype), 
                _this;
            }
            return tslib_es6.a(TimeoutError, _super), TimeoutError;
        }(Error), scheduler_async = __webpack_require__(39);
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/util/TimeoutError.js
        /** PURE_IMPORTS_START tslib PURE_IMPORTS_END */        
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/util/isDate.js
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        function isDate(value) {
            return value instanceof Date && !isNaN(+value);
        }
        //# sourceMappingURL=isDate.js.map
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/OuterSubscriber.js
                var OuterSubscriber = __webpack_require__(23), subscribeToResult = __webpack_require__(24);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/subscribeToResult.js + 1 modules
                // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/timeoutWith.js
        /** PURE_IMPORTS_START tslib,_scheduler_async,_util_isDate,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
        function timeoutWith(due, withObservable, scheduler) {
            return void 0 === scheduler && (scheduler = scheduler_async.a), function(source) {
                var absoluteTimeout = isDate(due), waitFor = absoluteTimeout ? +due - scheduler.now() : Math.abs(due);
                return source.lift(new TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler));
            };
        }
        var TimeoutWithOperator = /* */ function() {
            function TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler) {
                this.waitFor = waitFor, this.absoluteTimeout = absoluteTimeout, this.withObservable = withObservable, 
                this.scheduler = scheduler;
            }
            return TimeoutWithOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new timeoutWith_TimeoutWithSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));
            }, TimeoutWithOperator;
        }(), timeoutWith_TimeoutWithSubscriber = /* */ function(_super) {
            function TimeoutWithSubscriber(destination, absoluteTimeout, waitFor, withObservable, scheduler) {
                var _this = _super.call(this, destination) || this;
                return _this.absoluteTimeout = absoluteTimeout, _this.waitFor = waitFor, _this.withObservable = withObservable, 
                _this.scheduler = scheduler, _this.action = null, _this.scheduleTimeout(), _this;
            }
            return tslib_es6.a(TimeoutWithSubscriber, _super), TimeoutWithSubscriber.dispatchTimeout = function(subscriber) {
                var withObservable = subscriber.withObservable;
                subscriber._unsubscribeAndRecycle(), subscriber.add(Object(subscribeToResult.a)(subscriber, withObservable));
            }, TimeoutWithSubscriber.prototype.scheduleTimeout = function() {
                var action = this.action;
                action ? this.action = action.schedule(this, this.waitFor) : this.add(this.action = this.scheduler.schedule(TimeoutWithSubscriber.dispatchTimeout, this.waitFor, this));
            }, TimeoutWithSubscriber.prototype._next = function(value) {
                this.absoluteTimeout || this.scheduleTimeout(), _super.prototype._next.call(this, value);
            }, TimeoutWithSubscriber.prototype._unsubscribe = function() {
                this.action = null, this.scheduler = null, this.withObservable = null;
            }, TimeoutWithSubscriber;
        }(OuterSubscriber.a), throwError = __webpack_require__(78);
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/timeout.js
        /** PURE_IMPORTS_START _scheduler_async,_util_TimeoutError,_timeoutWith,_observable_throwError PURE_IMPORTS_END */
        function timeout(due, scheduler) {
            return void 0 === scheduler && (scheduler = scheduler_async.a), timeoutWith(due, Object(throwError.a)(new TimeoutError_TimeoutError()), scheduler);
        }
        //# sourceMappingURL=timeout.js.map
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/concatMap.js
                var concatMap = __webpack_require__(109), takeUntil = __webpack_require__(141), errors = __webpack_require__(22), constants = __webpack_require__(17), timer = __webpack_require__(147), backoff = __webpack_require__(64);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/takeUntil.js
                // CONCATENATED MODULE: ./src/utils/retry.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Simple debounce implementation.
 * @param {Function} fn
 * @param {Number} delay - delay in ms
 * @returns {Function}
 */
        function debounce(fn, delay) {
            var timer = 0;
            return function() {
                timer && clearTimeout(timer), timer = window.setTimeout(fn, delay);
            };
        }
        /**
 * Retry the given observable (if it triggers an error) with an exponential
 * backoff.
 * The backoff behavior can be tweaked through the options given.
 *
 * @param {Observable} obs$
 * @param {Object} options - Configuration object.
 * This object contains the following properties:
 *
 *   - retryDelay {Number} - The initial delay, in ms.
 *     This delay will be fuzzed to fall under the range +-30% each time a new
 *     retry is done.
 *     Then, this delay will be multiplied by 2^(n-1), n being the counter of
 *     retry we performed (beginning at 1 for the first retry).
 *
 *   - totalRetry {Number} - The amount of time we should retry. 0
 *     means no retry, 1 means a single retry, Infinity means infinite retry
 *     etc.
 *     If the observable still fails after this number of retry, the error will
 *     be throwed through this observable.
 *
 *   - resetDelay {Number|undefined} - Delay in ms since a retry after which the
 *     counter of retry will be reset if the observable wasn't retried a new
 *     time. 0 / undefined means no delay will be applied.
 *
 *   - shouldRetry {Function|undefined} -  Function which will receive the
 *     observable error each time it fails, and should return a boolean. If this
 *     boolean is false, the error will be directly thrown (without anymore
 *     retry).
 *
 *   - onRetry {Function|undefined} - Function which will be triggered at
 *     each retry. Will receive two arguments:
 *       1. The observable error
 *       2. The current retry count, beginning at 1 for the first retry
 *
 *   - errorSelector {Function|undefined} - If and when the observable will
 *     definitely throw (without retrying), this function will be called with
 *     two arguments:
 *       1. The observable error
 *       2. The final retry count, beginning at 1 for the first retry
 *     The returned value will be what will be thrown by the observable.
 *
 * @returns {Observable}
 * TODO Take errorSelector out. Should probably be entirely managed in the
 * calling code via a catch (much simpler to use and to understand).
 */        function retryObsWithBackoff(obs$, options) {
            var retryDelay = options.retryDelay, totalRetry = options.totalRetry, shouldRetry = options.shouldRetry, resetDelay = options.resetDelay, errorSelector = options.errorSelector, onRetry = options.onRetry, retryCount = 0, debounceRetryCount = void 0;
            return null != resetDelay && resetDelay > 0 && (debounceRetryCount = debounce(function() {
                retryCount = 0;
            }, resetDelay)), obs$.pipe(Object(catchError.a)(function(error, source) {
                if (!(!shouldRetry || shouldRetry(error)) || retryCount++ >= totalRetry) throw errorSelector ? errorSelector(error, retryCount) : error;
                onRetry && onRetry(error, retryCount);
                var fuzzedDelay = Object(backoff.a)(retryDelay, retryCount);
                return Object(timer.a)(fuzzedDelay).pipe(Object(mergeMap.a)(function() {
                    return debounceRetryCount && debounceRetryCount(), source;
                }));
            }));
        }
        /**
 * Retry the given function (if it triggers an error) with an exponential
 * backoff.
 * The backoff behavior can be tweaked through the options given.
 *
 * @param {Object} options - Configuration object. @see retryObsWithBackoff
 * @returns {Observable}
 */        
        // EXTERNAL MODULE: ./src/utils/rx-tryCatch.ts
        var rx_tryCatch = __webpack_require__(45), KEY_STATUS_ERRORS = {
            expired: !0,
            "internal-error": !0
        };
        // CONCATENATED MODULE: ./src/core/eme/types.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        // Keys are the different key statuses possible.
        // Values are ``true`` if such key status defines an error
        /* tslint:disable no-object-literal-type-assertion */        
        /* tslint:enable no-object-literal-type-assertion */
        // CONCATENATED MODULE: ./src/core/eme/handle_session_events.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * listen to "message" events from session containing a challenge
 * blob and map them to licenses using the getLicense method from
 * selected keySystem.
 * @param {MediaKeySession} session
 * @param {Object} keySystem
 * @param {Subject} errorStream
 * @returns {Observable}
 */
        function handleSessionEvents(session, keySystem, errorStream) {
            /**
     * @param {Error|Object} error
     * @param {Boolean} fatal
     * @returns {Error|Object}
     */
            function licenseErrorSelector(error, fatal) {
                return Object(errors.a)(error) && error.type === constants.b.ENCRYPTED_MEDIA_ERROR ? (error.fatal = fatal, 
                error) : new EncryptedMediaError.a("KEY_LOAD_ERROR", error, fatal);
            }
            log.a.debug("eme: handle message events", session);
            var getLicenseRetryOptions = {
                totalRetry: 2,
                retryDelay: 200,
                errorSelector: function errorSelector(error) {
                    return licenseErrorSelector(error, !0);
                },
                onRetry: function onRetry(error) {
                    return errorStream.next(licenseErrorSelector(error, !1));
                }
            }, keyErrors = Object(events.f)(session).pipe(Object(map.a)(function(error) {
                throw new EncryptedMediaError.a("KEY_ERROR", error, !0);
            })), keyStatusesChanges = Object(events.h)(session).pipe(Object(mergeMap.a)(function(keyStatusesEvent) {
                return log.a.debug("eme: keystatuseschange event", session, keyStatusesEvent), 
                // find out possible errors associated with this event
                session.keyStatuses.forEach(function(keyStatus, keyId) {
                    // Hack present because the order of the arguments has changed in spec
                    // and is not the same between some versions of Edge and Chrome.
                    if (KEY_STATUS_ERRORS[keyId]) throw new EncryptedMediaError.a("KEY_STATUS_CHANGE_ERROR", keyId, !0);
                    if (KEY_STATUS_ERRORS[keyStatus]) throw new EncryptedMediaError.a("KEY_STATUS_CHANGE_ERROR", keyStatus, !0);
                }), Object(rx_tryCatch.a)(function() {
                    return keySystem && keySystem.onKeyStatusesChange ? Object(castToObservable.a)(keySystem.onKeyStatusesChange(keyStatusesEvent, session)) : empty.a;
                }).pipe().pipe(Object(catchError.a)(function(error) {
                    throw new EncryptedMediaError.a("KEY_STATUS_CHANGE_ERROR", error, !0);
                }), Object(map.a)(function(licenseObject) {
                    return {
                        type: "key-status-change",
                        value: {
                            license: licenseObject
                        }
                    };
                }));
            })), keyMessages$ = Object(events.g)(session).pipe(Object(mergeMap.a)(function(messageEvent) {
                var message = new Uint8Array(messageEvent.message), messageType = messageEvent.messageType || "license-request";
                /* tslint:enable no-unnecessary-type-assertion */
                return log.a.debug("eme: event message type " + messageType, session, messageEvent), 
                retryObsWithBackoff(Object(defer.a)(function() {
                    var getLicense = keySystem.getLicense(message, messageType);
                    return Object(castToObservable.a)(getLicense).pipe(timeout(1e4), Object(catchError.a)(function(error) {
                        throw error instanceof TimeoutError_TimeoutError ? new EncryptedMediaError.a("KEY_LOAD_TIMEOUT", null, !1) : error;
                    }));
                    // TODO TypeScript/tslint/RxJS bug?
                    /* tslint:disable no-unnecessary-type-assertion */                }), getLicenseRetryOptions).pipe(Object(map.a)(function(license) {
                    return {
                        type: messageType,
                        value: {
                            license: license
                        }
                    };
                }));
            })), sessionUpdates = Object(merge.a)(keyMessages$, keyStatusesChanges).pipe(Object(concatMap.a)(function(evt) {
                log.a.debug("eme: update session", evt);
                var license = evt.value.license;
                return Object(castToObservable.a)(session.update(license)).pipe(Object(catchError.a)(function(error) {
                    throw new EncryptedMediaError.a("KEY_UPDATE_ERROR", error, !0);
                }), Object(mapTo.a)({
                    type: evt.type,
                    value: {
                        session: session,
                        license: license
                    }
                }));
            })), sessionEvents = Object(merge.a)(sessionUpdates, keyErrors);
            return session.closed ? sessionEvents.pipe(Object(takeUntil.a)(Object(castToObservable.a)(session.closed))) : sessionEvents;
        }
        // CONCATENATED MODULE: ./src/core/eme/media_keys_infos_store.ts
                function media_keys_infos_store_classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Store the MediaKeys infos attached to a media element.
 * @class MediaKeysInfosStore
 */        var media_keys_infos_store = function() {
            function MediaKeysInfosStore() {
                media_keys_infos_store_classCallCheck(this, MediaKeysInfosStore), this._state = new WeakMap();
            }
            return MediaKeysInfosStore.prototype.setState = function setState(mediaElement, state) {
                this._state.set(mediaElement, state);
            }, MediaKeysInfosStore.prototype.getState = function getState(mediaElement) {
                return this._state.get(mediaElement) || null;
            }, MediaKeysInfosStore.prototype.clearState = function clearState(mediaElement) {
                this._state.set(mediaElement, null);
            }, MediaKeysInfosStore;
        }();
        /* harmony default export */        
        // CONCATENATED MODULE: ./src/core/eme/utils/init_data_store.ts
        function init_data_store_classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Memorize initialization data with straightforward methods.
 * @class InitDataStore
 */        var init_data_store = function() {
            function InitDataStore() {
                init_data_store_classCallCheck(this, InitDataStore), this._namedTypeData = {}, this._unnamedTypeData = new simple_set.a();
            }
            /**
     * Returns true if this instance has the given initData stored.
     * @param {Uint8Array} initData
     * @param {string|undefined} initDataType
     * @returns {boolean}
     */            return InitDataStore.prototype.has = function has(initData, initDataType) {
                return initDataType ? !!this._namedTypeData[initDataType] && this._namedTypeData[initDataType].test(hashBuffer(initData)) : this._unnamedTypeData.test(hashBuffer(initData));
            }, 
            /**
     * Add initialization data to this memory.
     * @param {Uint8Array} initData
     * @param {string|undefined} initDataType
     */
            InitDataStore.prototype.add = function add(initData, initDataType) {
                this.has(initData, initDataType) || (initDataType ? (this._namedTypeData[initDataType] || (this._namedTypeData[initDataType] = new simple_set.a()), 
                this._namedTypeData[initDataType].add(hashBuffer(initData))) : this._unnamedTypeData.add(hashBuffer(initData)));
            }, 
            /**
     * Remove the initialization data from this memory.
     * Returns true if this instance had the given initData stored.
     * @param {Uint8Array} initData
     * @param {string|undefined} initDataType
     * @returns {boolean}
     */
            InitDataStore.prototype.remove = function remove(initData, initDataType) {
                if (initDataType) {
                    if (!this._namedTypeData[initDataType]) return !1;
                    var _hashed = hashBuffer(initData), simpleSet = this._namedTypeData[initDataType];
                    return !!simpleSet.test(_hashed) && (simpleSet.remove(_hashed), !0);
                }
                var hashed = hashBuffer(initData);
                return !!this._unnamedTypeData.test(hashed) && (this._unnamedTypeData.remove(hashed), 
                !0);
            }, InitDataStore;
        }();
        /* harmony default export */        
        // CONCATENATED MODULE: ./src/core/eme/index.ts
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() {
            return EMEManager;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clearEMESession", function() {
            return clearEMESession;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "disposeEME", function() {
            return disposeEME;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCurrentKeySystem", function() {
            return getCurrentKeySystem;
        });
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */
        var attachedMediaKeysInfos = new media_keys_infos_store();
        /**
 * Clear EME ressources that should be cleared when the current content stops
 * its playback.
 * @returns {Observable}
 */        function clearEMESession(mediaElement) {
            return Object(defer.a)(function() {
                if (Object(compat.m)()) return disposeMediaKeys(mediaElement, attachedMediaKeysInfos).pipe(Object(ignoreElements.a)());
                var currentState = attachedMediaKeysInfos.getState(mediaElement);
                return currentState && currentState.keySystemOptions.closeSessionsOnStop ? currentState.sessionsStore.closeAllSessions().pipe(Object(ignoreElements.a)()) : empty.a;
            });
        }
        /**
 * EME abstraction and event handler used to communicate with the Content-
 * Description-Module (CDM).
 *
 * The EME handler can be given one or multiple systems and will choose the
 * appropriate one supported by the user's browser.
 * @param {HTMLMediaElement} mediaElement
 * @param {Array.<Object>} keySystems
 * @param {Subject} errorStream
 * @returns {Observable}
 */        function EMEManager(mediaElement, keySystemsConfigs, errorStream) {
            // Keep track of all initialization data handled here.
            // This is to avoid handling multiple times the same encrypted events.
            var handledInitData = new init_data_store();
            return Object(combineLatest.a)(Object(events.b)(mediaElement), getMediaKeysInfos(mediaElement, keySystemsConfigs, attachedMediaKeysInfos, errorStream)).pipe(Object(mergeMap.a)(function(_ref, i) {
                var encryptedEvent = _ref[0], mediaKeysInfos = _ref[1];
                return Object(merge.a)(
                // create a new MediaKeySession if needed
                handleEncryptedEvent(encryptedEvent, handledInitData, mediaKeysInfos).pipe(Object(map.a)(function(evt) {
                    return {
                        type: evt.type,
                        value: {
                            initData: evt.value.initData,
                            initDataType: evt.value.initDataType,
                            mediaKeySession: evt.value.mediaKeySession,
                            sessionType: evt.value.sessionType,
                            keySystemOptions: mediaKeysInfos.keySystemOptions,
                            sessionStorage: mediaKeysInfos.sessionStorage
                        }
                    };
                })), 
                // attach MediaKeys if we're handling the first event
                0 === i ? attachMediaKeys(mediaKeysInfos, mediaElement, attachedMediaKeysInfos).pipe(Object(ignoreElements.a)()) : empty.a);
            }), Object(mergeMap.a)(function(handledEncryptedEvent) {
                var _handledEncryptedEven = handledEncryptedEvent.value, initData = _handledEncryptedEven.initData, initDataType = _handledEncryptedEven.initDataType, mediaKeySession = _handledEncryptedEven.mediaKeySession, sessionType = _handledEncryptedEven.sessionType, keySystemOptions = _handledEncryptedEven.keySystemOptions, sessionStorage = _handledEncryptedEven.sessionStorage;
                return Object(merge.a)(handleSessionEvents(mediaKeySession, keySystemOptions, errorStream), 
                // only perform generate request on new sessions
                "created-session" === handledEncryptedEvent.type ? generateKeyRequest(mediaKeySession, initData, initDataType).pipe(Object(tap.a)(function() {
                    "persistent-license" === sessionType && null != sessionStorage && sessionStorage.add(initData, initDataType, mediaKeySession);
                })) : empty.a).pipe(Object(ignoreElements.a)());
            }));
        }
        /**
 * Free up all ressources taken by the EME management.
 */        function disposeEME(mediaElement) {
            disposeMediaKeys(mediaElement, attachedMediaKeysInfos).subscribe(noop.a);
        }
        /**
 * Returns the name of the current key system used.
 * @returns {string}
 */        function getCurrentKeySystem(mediaElement) {
            var currentState = attachedMediaKeysInfos.getState(mediaElement);
            return currentState && currentState.keySystemOptions.type;
        }
        /***/    }, 
    /* 67 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        function isObject(x) {
            return null != x && "object" == typeof x;
        }
        //# sourceMappingURL=isObject.js.map
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return isObject;
        });
    }, 
    /* 68 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return subscribeTo;
        });
        /* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6), _subscribeToArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(71), _subscribeToPromise__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(73), _subscribeToIterable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(74), _subscribeToObservable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(69), _isArrayLike__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(70), _isPromise__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(72), _isObject__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(67), _symbol_iterator__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(51), _symbol_observable__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(43), subscribeTo = function(result) {
            if (result instanceof _Observable__WEBPACK_IMPORTED_MODULE_0__.a) return function(subscriber) {
                return result._isScalar ? (subscriber.next(result.value), void subscriber.complete()) : result.subscribe(subscriber);
            };
            if (result && "function" == typeof result[_symbol_observable__WEBPACK_IMPORTED_MODULE_9__.a]) return Object(_subscribeToObservable__WEBPACK_IMPORTED_MODULE_4__.a)(result);
            if (Object(_isArrayLike__WEBPACK_IMPORTED_MODULE_5__.a)(result)) return Object(_subscribeToArray__WEBPACK_IMPORTED_MODULE_1__.a)(result);
            if (Object(_isPromise__WEBPACK_IMPORTED_MODULE_6__.a)(result)) return Object(_subscribeToPromise__WEBPACK_IMPORTED_MODULE_2__.a)(result);
            if (result && "function" == typeof result[_symbol_iterator__WEBPACK_IMPORTED_MODULE_8__.a]) return Object(_subscribeToIterable__WEBPACK_IMPORTED_MODULE_3__.a)(result);
            var value = Object(_isObject__WEBPACK_IMPORTED_MODULE_7__.a)(result) ? "an invalid object" : "'" + result + "'";
            throw new TypeError("You provided " + value + " where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.");
        };
        /* harmony import */    }, 
    /* 69 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return subscribeToObservable;
        });
        /* harmony import */ var _symbol_observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(43), subscribeToObservable = function(obj) {
            return function(subscriber) {
                var obs = obj[_symbol_observable__WEBPACK_IMPORTED_MODULE_0__.a]();
                if ("function" != typeof obs.subscribe) throw new TypeError("Provided object does not correctly implement Symbol.observable");
                return obs.subscribe(subscriber);
            };
        };
        /** PURE_IMPORTS_START _symbol_observable PURE_IMPORTS_END */    }, 
    /* 70 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return isArrayLike;
        });
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        var isArrayLike = function(x) {
            return x && "number" == typeof x.length && "function" != typeof x;
        };
        //# sourceMappingURL=isArrayLike.js.map
        /***/    }, 
    /* 71 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return subscribeToArray;
        });
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        var subscribeToArray = function(array) {
            return function(subscriber) {
                for (var i = 0, len = array.length; i < len && !subscriber.closed; i++) subscriber.next(array[i]);
                subscriber.closed || subscriber.complete();
            };
        };
        //# sourceMappingURL=subscribeToArray.js.map
        /***/    }, 
    /* 72 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        function isPromise(value) {
            return value && "function" != typeof value.subscribe && "function" == typeof value.then;
        }
        //# sourceMappingURL=isPromise.js.map
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return isPromise;
        });
    }, 
    /* 73 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return subscribeToPromise;
        });
        /* harmony import */ var _hostReportError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(49), subscribeToPromise = function(promise) {
            return function(subscriber) {
                return promise.then(function(value) {
                    subscriber.closed || (subscriber.next(value), subscriber.complete());
                }, function(err) {
                    return subscriber.error(err);
                }).then(null, _hostReportError__WEBPACK_IMPORTED_MODULE_0__.a), subscriber;
            };
        };
        /** PURE_IMPORTS_START _hostReportError PURE_IMPORTS_END */    }, 
    /* 74 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return subscribeToIterable;
        });
        /* harmony import */ var _symbol_iterator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(51), subscribeToIterable = function(iterable) {
            return function(subscriber) {
                for (var iterator = iterable[_symbol_iterator__WEBPACK_IMPORTED_MODULE_0__.a](); ;) {
                    var item = iterator.next();
                    if (item.done) {
                        subscriber.complete();
                        break;
                    }
                    if (subscriber.next(item.value), subscriber.closed) break;
                }
                return "function" == typeof iterator.return && subscriber.add(function() {
                    iterator.return && iterator.return();
                }), subscriber;
            };
        };
        /** PURE_IMPORTS_START _symbol_iterator PURE_IMPORTS_END */    }, 
    /* 75 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return of;
        });
        /* harmony import */ var _util_isScheduler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(34), _fromArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(33), _empty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(26), _scalar__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(76);
        /* harmony import */        
        /** PURE_IMPORTS_START _util_isScheduler,_fromArray,_empty,_scalar PURE_IMPORTS_END */
        function of() {
            for (var args = [], _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
            var scheduler = args[args.length - 1];
            switch (Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_0__.a)(scheduler) ? args.pop() : scheduler = void 0, 
            args.length) {
              case 0:
                return Object(_empty__WEBPACK_IMPORTED_MODULE_2__.b)(scheduler);

              case 1:
                return scheduler ? Object(_fromArray__WEBPACK_IMPORTED_MODULE_1__.a)(args, scheduler) : Object(_scalar__WEBPACK_IMPORTED_MODULE_3__.a)(args[0]);

              default:
                return Object(_fromArray__WEBPACK_IMPORTED_MODULE_1__.a)(args, scheduler);
            }
        }
        //# sourceMappingURL=of.js.map
        /***/    }, 
    /* 76 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return scalar;
        });
        /* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);
        /** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */        function scalar(value) {
            var result = new _Observable__WEBPACK_IMPORTED_MODULE_0__.a(function(subscriber) {
                subscriber.next(value), subscriber.complete();
            });
            return result._isScalar = !0, result.value = value, result;
        }
        //# sourceMappingURL=scalar.js.map
        /***/    }, 
    /* 77 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return SubjectSubscription;
        });
        /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2), SubjectSubscription = /* */ function(_super) {
            function SubjectSubscription(subject, subscriber) {
                var _this = _super.call(this) || this;
                return _this.subject = subject, _this.subscriber = subscriber, _this.closed = !1, 
                _this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(SubjectSubscription, _super), SubjectSubscription.prototype.unsubscribe = function() {
                if (!this.closed) {
                    this.closed = !0;
                    var subject = this.subject, observers = subject.observers;
                    if (this.subject = null, observers && 0 !== observers.length && !subject.isStopped && !subject.closed) {
                        var subscriberIndex = observers.indexOf(this.subscriber);
                        -1 !== subscriberIndex && observers.splice(subscriberIndex, 1);
                    }
                }
            }, SubjectSubscription;
        }(__webpack_require__(16).a);
        /* harmony import */    }, 
    /* 78 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return throwError;
        });
        /* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);
        /** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */        function throwError(error, scheduler) {
            return scheduler ? new _Observable__WEBPACK_IMPORTED_MODULE_0__.a(function(subscriber) {
                return scheduler.schedule(dispatch, 0, {
                    error: error,
                    subscriber: subscriber
                });
            }) : new _Observable__WEBPACK_IMPORTED_MODULE_0__.a(function(subscriber) {
                return subscriber.error(error);
            });
        }
        function dispatch(_a) {
            var error = _a.error;
            _a.subscriber.error(error);
        }
        //# sourceMappingURL=throwError.js.map
        /***/    }, 
    /* 79 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return ArgumentOutOfRangeError;
        });
        /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2), ArgumentOutOfRangeError = /* */ function(_super) {
            function ArgumentOutOfRangeError() {
                var _this = _super.call(this, "argument out of range") || this;
                return _this.name = "ArgumentOutOfRangeError", Object.setPrototypeOf(_this, ArgumentOutOfRangeError.prototype), 
                _this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(ArgumentOutOfRangeError, _super), ArgumentOutOfRangeError;
        }(Error);
        /** PURE_IMPORTS_START tslib PURE_IMPORTS_END */    }, 
    /* 80 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony import */        var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17), _errorMessage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(52);
        /* harmony import */        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        function _possibleConstructorReturn(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" != typeof call && "function" != typeof call ? self : call;
        }
        function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Error linked to the encryption of the media.
 *
 * @class EncryptedMediaError
 * @extends Error
 */        var EncryptedMediaError = function(_Error) {
            function EncryptedMediaError(code, reason, fatal) {
                _classCallCheck(this, EncryptedMediaError);
                // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class
                var _this = _possibleConstructorReturn(this, _Error.call(this));
                return Object.setPrototypeOf(_this, EncryptedMediaError.prototype), _this.name = "EncryptedMediaError", 
                _this.type = _constants__WEBPACK_IMPORTED_MODULE_0__.b.ENCRYPTED_MEDIA_ERROR, _this.reason = reason, 
                _this.code = _constants__WEBPACK_IMPORTED_MODULE_0__.a.hasOwnProperty(code) ? _constants__WEBPACK_IMPORTED_MODULE_0__.a[code] : "", 
                _this.fatal = !!fatal, _this.message = Object(_errorMessage__WEBPACK_IMPORTED_MODULE_1__.a)(_this.name, _this.code, _this.reason), 
                _this;
            }
            return _inherits(EncryptedMediaError, _Error), EncryptedMediaError;
        }(Error);
        /* harmony default export */        __webpack_exports__.a = EncryptedMediaError;
    }, 
    /* 81 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        function _possibleConstructorReturn(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" != typeof call && "function" != typeof call ? self : call;
        }
        function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Errors linked to the XHR implentation done in the RxPlayer.
 *
 * @class RequestError
 * @extends Error
 */        var RequestError = function(_Error) {
            function RequestError(xhr, url, type) {
                _classCallCheck(this, RequestError);
                // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class
                var _this = _possibleConstructorReturn(this, _Error.call(this));
                return Object.setPrototypeOf(_this, RequestError.prototype), _this.name = "RequestError", 
                _this.url = url, _this.xhr = xhr, _this.status = xhr.status, _this.type = type, 
                _this.message = type, _this;
            }
            return _inherits(RequestError, _Error), RequestError;
        }(Error);
        /* harmony default export */        __webpack_exports__.a = RequestError;
    }, 
    /* 82 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony import */        var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6), _utils_request__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(28);
        /* harmony import */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Manifest loader triggered if there was no custom-defined one in the API.
 * @param {string} url
 */
        function regularManifestLoader(url, ignoreProgressEvents) {
            return Object(_utils_request__WEBPACK_IMPORTED_MODULE_1__.a)({
                url: url,
                responseType: "document",
                ignoreProgressEvents: ignoreProgressEvents
            });
        }
        /**
 * Generate a manifest loader for the application
 * @param {Function} [customManifestLoader]
 * @returns {Function}
 */        
        /* harmony default export */ __webpack_exports__.a = function manifestPreLoader(options) {
            return function(url) {
                var customManifestLoader = options.customManifestLoader, ignoreProgressEvents = options.ignoreProgressEvents;
                return customManifestLoader ? rxjs__WEBPACK_IMPORTED_MODULE_0__.a.create(function(obs) {
                    var hasFinished = !1, hasFallbacked = !1, abort = customManifestLoader(url, {
                        reject: function reject() {
                            var err = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                            hasFallbacked || (hasFinished = !0, obs.error(err));
                        },
                        resolve: function resolve(_args) {
                            hasFallbacked || (hasFinished = !0, obs.next({
                                type: "response",
                                value: {
                                    responseData: _args.data,
                                    size: _args.size,
                                    duration: _args.duration
                                }
                            }), obs.complete());
                        },
                        fallback: function fallback() {
                            hasFallbacked = !0, regularManifestLoader(url).subscribe(obs);
                        }
                    });
                    return function() {
                        hasFinished || hasFallbacked || "function" != typeof abort || abort();
                    };
                }) : regularManifestLoader(url, ignoreProgressEvents);
            };
        };
    }, 
    /* 83 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* unused harmony export stringFromCharCode */
        /* harmony export (binding) */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Creates a new string from the given array of char codes.
 *
 * @param {Uint8Array} args
 * @returns {string}
 */
        function stringFromCharCode(args) {
            for (var ret = "", i = 0; i < args.length; i += 16e3) {
                var subArray = args.subarray(i, i + 16e3);
                ret += String.fromCharCode.apply(null, subArray);
            }
            return ret;
        }
        /**
 * Creates a string from the given buffer as UTF-8 encoding.
 * @param {BufferSource} [data]
 * @returns {string}
 * @throws {Error}
 * @export
 */        function stringFromUTF8(data) {
            if (!data) return "";
            var uint8 = new Uint8Array(data);
            // If present, strip off the UTF-8 BOM.
                        239 === uint8[0] && 187 === uint8[1] && 191 === uint8[2] && (uint8 = uint8.subarray(3));
            // http://stackoverflow.com/a/13691499
                        var utf8 = stringFromCharCode(uint8), escaped = escape(utf8);
            // This converts each character in the string to an escape sequence.  If the
            // character is in the ASCII range, it is not converted; otherwise it is
            // converted to a URI escape sequence.
            // Example: "\x67\x35\xe3\x82\xac" -> "g#%E3%82%AC"
            // TODO "escape" is deprecated, provide a ponyfill?
                        // Decode the escaped sequence.  This will interpret UTF-8 sequences into the
            // correct character.
            // Example: "g#%E3%82%AC" -> "g#€"
            return decodeURIComponent(escaped);
        }
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return stringFromUTF8;
        });
    }, 
    /* 84 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return getCueBlocks;
        });
        /* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(48);
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Get cue blocks from a WebVTT file.
 * @param {Array.<string>} linified - Whole WebVTT file. Each new element in
 * this array is a new line.
 * @param {number} headerOffset - index of the first line after the header.
 * Used to avoid taking the header into consideration.
 * @returns {Array.<Array.<string>>}
 */        function getCueBlocks(linified, headerOffset) {
            for (var cueBlocks = [], i = headerOffset; i < linified.length; i++) 
            //
            if (Object(_utils__WEBPACK_IMPORTED_MODULE_0__.c)(linified, i)) {
                var endOfCue = Object(_utils__WEBPACK_IMPORTED_MODULE_0__.a)(linified, i);
                cueBlocks.push(linified.slice(i, endOfCue)), i = endOfCue;
            } else if (linified[i]) 
            // continue incrementing i until either:
            //   - empty line
            //   - end
            for (;linified[i]; ) i++;
            return cueBlocks;
        }
        /***/    }, 
    /* 85 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Returns global parameters from a TTML Document
 * TODO Missing parameters.
 * @param {Element} tt - <tt> node
 * @throws Error - Throws if the spacing style is invalid.
 * @returns {Object}
 */
        function getParameters(tt) {
            var parsedFrameRate = tt.getAttribute("ttp:frameRate"), parsedSubFrameRate = tt.getAttribute("ttp:subFramRate"), parsedTickRate = tt.getAttribute("ttp:tickRate"), parsedFrameRateMultiplier = tt.getAttribute("ttp:frameRateMultiplier"), parsedSpaceStyle = tt.getAttribute("xml:space");
            if (parsedSpaceStyle && "default" !== parsedSpaceStyle && "preserve" !== parsedSpaceStyle) throw new Error("Invalid spacing style");
            var nbFrameRate = Number(parsedFrameRate) || 30, nbSubFrameRate = Number(parsedSubFrameRate) || 1, nbTickRate = Number(parsedTickRate) || 0, tickRate = nbTickRate, frameRate = nbFrameRate, subFrameRate = null != nbSubFrameRate ? nbSubFrameRate : 1, spaceStyle = parsedSpaceStyle || "default";
            if (0 === nbTickRate && (tickRate = parsedFrameRate ? nbFrameRate * nbSubFrameRate : 1), 
            parsedFrameRateMultiplier) {
                var multiplierResults = /^(\d+) (\d+)$/g.exec(parsedFrameRateMultiplier);
                if (multiplierResults) frameRate = nbFrameRate * (Number(multiplierResults[1]) / Number(multiplierResults[2]));
            }
            return {
                tickRate: tickRate,
                frameRate: frameRate,
                subFrameRate: subFrameRate,
                spaceStyle: spaceStyle
            };
        }
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return getParameters;
        });
    }, 
    /* 86 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return handleVideoEvents;
        });
        /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(146), rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(75), rxjs_operators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(148), rxjs_operators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(149), rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(144), _compat__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(12), _log__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(0);
        /* harmony import */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Set the initial time given as soon as possible on the video element.
 * Emit when done.
 * @param {HMTLMediaElement} videoElement
 * @param {number|Function} startTime
 * @returns {Observable}
 */
        function doInitialSeek(videoElement, startTime) {
            return Object(_compat__WEBPACK_IMPORTED_MODULE_5__.e)(videoElement).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.a)(function() {
                _log__WEBPACK_IMPORTED_MODULE_6__.a.info("set initial time", startTime), 
                // reset playbackRate to 1 in case we were at 0 (from a stalled
                // retry for instance)
                videoElement.playbackRate = 1, videoElement.currentTime = "function" == typeof startTime ? startTime() : startTime;
            }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.a)());
        }
        /**
 * @param {HTMLMediaElement} videoElement
 * @param {number|Function} startTime
 * @param {boolean} autoPlay
 * @returns {object}
 */        function handleVideoEvents(videoElement, startTime, mustAutoPlay) {
            var initialSeek$ = doInitialSeek(videoElement, startTime), handledCanPlay$ = Object(_compat__WEBPACK_IMPORTED_MODULE_5__.b)(videoElement).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.a)(function() {
                return _log__WEBPACK_IMPORTED_MODULE_6__.a.info("canplay event");
            }));
            return {
                initialSeek$: initialSeek$,
                loadAndPlay$: Object(rxjs__WEBPACK_IMPORTED_MODULE_0__.a)(initialSeek$, handledCanPlay$).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.a)(mustAutoPlay ? Object(_compat__WEBPACK_IMPORTED_MODULE_5__.j)(videoElement) : Object(rxjs__WEBPACK_IMPORTED_MODULE_1__.a)(void 0)), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.a)())
            };
        }
        /***/    }, 
    /* 87 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return createEMEManager;
        });
        /* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(54), _compat___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(12), _compat_events__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(8), _errors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(80), _features__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(7), _log__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(0);
        /* harmony import */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        function createEMEManager(mediaElement, keySystems, errorStream) {
            return null == _features__WEBPACK_IMPORTED_MODULE_4__.a.emeManager ? Object(_compat_events__WEBPACK_IMPORTED_MODULE_2__.b)(mediaElement).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_0__.a)(function() {
                throw _log__WEBPACK_IMPORTED_MODULE_5__.a.error("eme: encrypted event but EME feature not activated"), 
                new _errors__WEBPACK_IMPORTED_MODULE_3__.a("MEDIA_IS_ENCRYPTED_ERROR", null, !0);
            })) : keySystems && keySystems.length ? Object(_compat___WEBPACK_IMPORTED_MODULE_1__.d)() ? _features__WEBPACK_IMPORTED_MODULE_4__.a.emeManager(mediaElement, keySystems, errorStream) : Object(_compat_events__WEBPACK_IMPORTED_MODULE_2__.b)(mediaElement).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_0__.a)(function() {
                throw _log__WEBPACK_IMPORTED_MODULE_5__.a.error("eme: encrypted event but no EME API available"), 
                new _errors__WEBPACK_IMPORTED_MODULE_3__.a("MEDIA_IS_ENCRYPTED_ERROR", null, !0);
            })) : Object(_compat_events__WEBPACK_IMPORTED_MODULE_2__.b)(mediaElement).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_0__.a)(function() {
                throw _log__WEBPACK_IMPORTED_MODULE_5__.a.error("eme: ciphered media and no keySystem passed"), 
                new _errors__WEBPACK_IMPORTED_MODULE_3__.a("MEDIA_IS_ENCRYPTED_ERROR", null, !0);
            }));
        }
        /***/    }, 
    /* 88 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return createMediaErrorHandler;
        });
        /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(135), rxjs_operators__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(57), _errors_MediaError__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(27), _log__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(0);
        /* harmony import */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Returns an observable which throws the right MediaError as soon an "error"
 * event is received through the videoElement.
 * @see MediaError
 * @returns {Observable}
 */
        function createMediaErrorHandler(videoElement) {
            return Object(rxjs__WEBPACK_IMPORTED_MODULE_0__.a)(videoElement, "error").pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_1__.a)(function() {
                var errorDetail = void 0;
                switch (videoElement.error && videoElement.error.code) {
                  case 1:
                    errorDetail = "MEDIA_ERR_ABORTED";
                    break;

                  case 2:
                    errorDetail = "MEDIA_ERR_NETWORK";
                    break;

                  case 3:
                    errorDetail = "MEDIA_ERR_DECODE";
                    break;

                  case 4:
                    errorDetail = "MEDIA_ERR_SRC_NOT_SUPPORTED";
                    break;

                  default:
                    errorDetail = "MEDIA_ERR_UNKNOWN";
                }
                throw _log__WEBPACK_IMPORTED_MODULE_3__.a.error("stream: video element MEDIA_ERR(" + errorDetail + ")"), 
                new _errors_MediaError__WEBPACK_IMPORTED_MODULE_2__.a(errorDetail, null, !0);
            }));
        }
        /***/    }, 
    /* 89 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony import */        var rxjs_operators__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(148), rxjs_operators__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(150), rxjs_operators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(54), rxjs_operators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(140), _compat__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(12), _config__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(3), _log__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(0), _utils_ranges__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(21), DISCONTINUITY_THRESHOLD = _config__WEBPACK_IMPORTED_MODULE_5__.a.DISCONTINUITY_THRESHOLD;
        /* harmony import */        
        /* harmony default export */ __webpack_exports__.a = 
        /**
 * Receive "stalling" events from the clock, try to get out of it, and re-emit
 * them for the player if the stalling status changed.
 * @param {HTMLMediaElement} videoElement
 * @param {Observable} timings$
 * @returns {Observable}
 */
        function StallingManager(videoElement, timings$) {
            return timings$.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_0__.a)(function(timing) {
                if (timing.stalled) {
                    // Perform various checks to try to get out of the stalled state:
                    //   1. is it a browser bug? -> force seek at the same current time
                    //   2. is it a short discontinuity? -> Seek at the beginning of the
                    //                                      next range
                    var buffered = timing.buffered, currentTime = timing.currentTime, nextRangeGap = Object(_utils_ranges__WEBPACK_IMPORTED_MODULE_7__.d)(buffered, currentTime);
                    // Discontinuity check in case we are close a buffer but still
                    // calculate a stalled state. This is useful for some
                    // implementation that might drop an injected segment, or in
                    // case of small discontinuity in the stream.
                    if (Object(_compat__WEBPACK_IMPORTED_MODULE_4__.h)(timing.currentTime, timing.currentRange, timing.state, !!timing.stalled)) _log__WEBPACK_IMPORTED_MODULE_6__.a.warn("after freeze seek", currentTime, timing.currentRange), 
                    videoElement.currentTime = currentTime; else if (nextRangeGap < DISCONTINUITY_THRESHOLD) {
                        var seekTo = currentTime + nextRangeGap + 1 / 60;
                        _log__WEBPACK_IMPORTED_MODULE_6__.a.warn("discontinuity seek", currentTime, nextRangeGap, seekTo), 
                        videoElement.currentTime = seekTo;
                    }
                }
            }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_1__.a)(), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.a)(function(timing) {
                return timing.stalled;
            }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.a)(function(wasStalled, isStalled) {
                return !wasStalled && !isStalled || !!wasStalled && !!isStalled && wasStalled.reason === isStalled.reason;
            }));
        };
    }, 
    /* 90 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return refCount;
        });
        /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2), _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);
        /* harmony import */        
        /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
        function refCount() {
            return function refCountOperatorFunction(source) {
                return source.lift(new RefCountOperator(source));
            };
        }
        var RefCountOperator = /* */ function() {
            function RefCountOperator(connectable) {
                this.connectable = connectable;
            }
            return RefCountOperator.prototype.call = function(subscriber, source) {
                var connectable = this.connectable;
                connectable._refCount++;
                var refCounter = new RefCountSubscriber(subscriber, connectable), subscription = source.subscribe(refCounter);
                return refCounter.closed || (refCounter.connection = connectable.connect()), subscription;
            }, RefCountOperator;
        }(), RefCountSubscriber = /* */ function(_super) {
            function RefCountSubscriber(destination, connectable) {
                var _this = _super.call(this, destination) || this;
                return _this.connectable = connectable, _this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(RefCountSubscriber, _super), RefCountSubscriber.prototype._unsubscribe = function() {
                var connectable = this.connectable;
                if (connectable) {
                    this.connectable = null;
                    var refCount = connectable._refCount;
                    if (refCount <= 0) this.connection = null; else if (connectable._refCount = refCount - 1, 
                    refCount > 1) this.connection = null; else {
                        var connection = this.connection, sharedConnection = connectable._connection;
                        this.connection = null, !sharedConnection || connection && sharedConnection !== connection || sharedConnection.unsubscribe();
                    }
                } else this.connection = null;
            }, RefCountSubscriber;
        }(_Subscriber__WEBPACK_IMPORTED_MODULE_1__.a);
    }, 
    /* 91 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony import */        var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17), _errorMessage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(52);
        /* harmony import */        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        function _possibleConstructorReturn(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" != typeof call && "function" != typeof call ? self : call;
        }
        function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Error linked to network interactions (requests).
 *
 * @class NetworkError
 * @extends Error
 */        var NetworkError = function(_Error) {
            function NetworkError(code, requestError, fatal) {
                _classCallCheck(this, NetworkError);
                // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class
                var _this = _possibleConstructorReturn(this, _Error.call(this));
                return Object.setPrototypeOf(_this, NetworkError.prototype), _this.name = "NetworkError", 
                _this.type = _constants__WEBPACK_IMPORTED_MODULE_0__.b.NETWORK_ERROR, _this.xhr = requestError.xhr, 
                _this.url = requestError.url, _this.status = requestError.status, _this.errorType = requestError.type, 
                _this.reason = requestError, _this.code = _constants__WEBPACK_IMPORTED_MODULE_0__.a.hasOwnProperty(code) ? _constants__WEBPACK_IMPORTED_MODULE_0__.a[code] : "", 
                _this.fatal = !!fatal, _this.message = Object(_errorMessage__WEBPACK_IMPORTED_MODULE_1__.a)(_this.name, _this.code, _this.reason), 
                _this;
            }
            /**
     * Returns true if the NetworkError is due to the given http error code
     * @param {number} httpErrorCode
     * @returns {Boolean}
     */            return _inherits(NetworkError, _Error), NetworkError.prototype.isHttpError = function isHttpError(httpErrorCode) {
                return this.errorType === _constants__WEBPACK_IMPORTED_MODULE_0__.c.ERROR_HTTP_CODE && this.status === httpErrorCode;
            }, NetworkError;
        }(Error);
        /* harmony default export */        __webpack_exports__.a = NetworkError;
    }, 
    /* 92 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony import */        var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17), _errorMessage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(52);
        /* harmony import */        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        function _possibleConstructorReturn(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" != typeof call && "function" != typeof call ? self : call;
        }
        function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        // TODO https://stackoverflow.com/questions/41102060/typescript-extending-error-class
        /**
 * @class OtherError
 * @extends Error
 */        var OtherError = function(_Error) {
            function OtherError(code, reason, fatal) {
                _classCallCheck(this, OtherError);
                // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class
                var _this = _possibleConstructorReturn(this, _Error.call(this));
                return Object.setPrototypeOf(_this, OtherError.prototype), _this.name = "OtherError", 
                _this.type = _constants__WEBPACK_IMPORTED_MODULE_0__.b.OTHER_ERROR, _this.reason = reason, 
                _this.code = _constants__WEBPACK_IMPORTED_MODULE_0__.a.hasOwnProperty(code) ? _constants__WEBPACK_IMPORTED_MODULE_0__.a[code] : "", 
                _this.fatal = !!fatal, _this.message = Object(_errorMessage__WEBPACK_IMPORTED_MODULE_1__.a)(_this.name, _this.code, _this.reason), 
                _this;
            }
            return _inherits(OtherError, _Error), OtherError;
        }(Error);
        /* harmony default export */        __webpack_exports__.a = OtherError;
    }, 
    /* 93 */
    /***/ function(module, exports, __webpack_require__) {
        "use strict";
        module.exports = function(arr, predicate, ctx) {
            if ("function" == typeof Array.prototype.findIndex) return arr.findIndex(predicate, ctx);
            if ("function" != typeof predicate) throw new TypeError("predicate must be a function");
            var list = Object(arr), len = list.length;
            if (0 === len) return -1;
            for (var i = 0; i < len; i++) if (predicate.call(ctx, list[i], i, list)) return i;
            return -1;
        };
    }, 
    /* 94 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js
                var tslib_es6 = __webpack_require__(2), Subject = __webpack_require__(36), Observable = __webpack_require__(6), Subscriber = __webpack_require__(10), Subscription = __webpack_require__(16), refCount = __webpack_require__(90), connectableProto = /* */ function(_super) {
            function ConnectableObservable(source, subjectFactory) {
                var _this = _super.call(this) || this;
                return _this.source = source, _this.subjectFactory = subjectFactory, _this._refCount = 0, 
                _this._isComplete = !1, _this;
            }
            return tslib_es6.a(ConnectableObservable, _super), ConnectableObservable.prototype._subscribe = function(subscriber) {
                return this.getSubject().subscribe(subscriber);
            }, ConnectableObservable.prototype.getSubject = function() {
                var subject = this._subject;
                return subject && !subject.isStopped || (this._subject = this.subjectFactory()), 
                this._subject;
            }, ConnectableObservable.prototype.connect = function() {
                var connection = this._connection;
                return connection || (this._isComplete = !1, (connection = this._connection = new Subscription.a()).add(this.source.subscribe(new ConnectableObservable_ConnectableSubscriber(this.getSubject(), this))), 
                connection.closed ? (this._connection = null, connection = Subscription.a.EMPTY) : this._connection = connection), 
                connection;
            }, ConnectableObservable.prototype.refCount = function() {
                return Object(refCount.a)()(this);
            }, ConnectableObservable;
        }(Observable.a).prototype, connectableObservableDescriptor = {
            operator: {
                value: null
            },
            _refCount: {
                value: 0,
                writable: !0
            },
            _subject: {
                value: null,
                writable: !0
            },
            _connection: {
                value: null,
                writable: !0
            },
            _subscribe: {
                value: connectableProto._subscribe
            },
            _isComplete: {
                value: connectableProto._isComplete,
                writable: !0
            },
            getSubject: {
                value: connectableProto.getSubject
            },
            connect: {
                value: connectableProto.connect
            },
            refCount: {
                value: connectableProto.refCount
            }
        }, ConnectableObservable_ConnectableSubscriber = /* */ function(_super) {
            function ConnectableSubscriber(destination, connectable) {
                var _this = _super.call(this, destination) || this;
                return _this.connectable = connectable, _this;
            }
            return tslib_es6.a(ConnectableSubscriber, _super), ConnectableSubscriber.prototype._error = function(err) {
                this._unsubscribe(), _super.prototype._error.call(this, err);
            }, ConnectableSubscriber.prototype._complete = function() {
                this.connectable._isComplete = !0, this._unsubscribe(), _super.prototype._complete.call(this);
            }, ConnectableSubscriber.prototype._unsubscribe = function() {
                var connectable = this.connectable;
                if (connectable) {
                    this.connectable = null;
                    var connection = connectable._connection;
                    connectable._refCount = 0, connectable._subject = null, connectable._connection = null, 
                    connection && connection.unsubscribe();
                }
            }, ConnectableSubscriber;
        }(Subject.b);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subject.js
                Subscriber.a;
        /* unused harmony export MulticastOperator */
        /** PURE_IMPORTS_START _observable_ConnectableObservable PURE_IMPORTS_END */
        function multicast(subjectOrSubjectFactory, selector) {
            return function multicastOperatorFunction(source) {
                var subjectFactory;
                if (subjectFactory = "function" == typeof subjectOrSubjectFactory ? subjectOrSubjectFactory : function subjectFactory() {
                    return subjectOrSubjectFactory;
                }, "function" == typeof selector) return source.lift(new MulticastOperator(subjectFactory, selector));
                var connectable = Object.create(source, connectableObservableDescriptor);
                return connectable.source = source, connectable.subjectFactory = subjectFactory, 
                connectable;
            };
        }
        //# sourceMappingURL=ConnectableObservable.js.map
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/multicast.js
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return multicast;
        });
        var MulticastOperator = /* */ function() {
            function MulticastOperator(subjectFactory, selector) {
                this.subjectFactory = subjectFactory, this.selector = selector;
            }
            return MulticastOperator.prototype.call = function(subscriber, source) {
                var selector = this.selector, subject = this.subjectFactory(), subscription = selector(subject).subscribe(subscriber);
                return subscription.add(source.subscribe(subject)), subscription;
            }, MulticastOperator;
        }();
        //# sourceMappingURL=multicast.js.map
        /***/    }, 
    /* 95 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/of.js
                var of = __webpack_require__(75), defer = __webpack_require__(133), tslib_es6 = __webpack_require__(2), Subscriber = __webpack_require__(10);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/defer.js
                // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/pairwise.js
        /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
        function pairwise() {
            return function(source) {
                return source.lift(new PairwiseOperator());
            };
        }
        var PairwiseOperator = /* */ function() {
            function PairwiseOperator() {}
            return PairwiseOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new pairwise_PairwiseSubscriber(subscriber));
            }, PairwiseOperator;
        }(), pairwise_PairwiseSubscriber = /* */ function(_super) {
            function PairwiseSubscriber(destination) {
                var _this = _super.call(this, destination) || this;
                return _this.hasPrev = !1, _this;
            }
            return tslib_es6.a(PairwiseSubscriber, _super), PairwiseSubscriber.prototype._next = function(value) {
                this.hasPrev ? this.destination.next([ this.prev, value ]) : this.hasPrev = !0, 
                this.prev = value;
            }, PairwiseSubscriber;
        }(Subscriber.a), map = __webpack_require__(54), filter = __webpack_require__(137), startWith = __webpack_require__(138), switchMap = __webpack_require__(117), tap = __webpack_require__(148), log = __webpack_require__(0);
        __webpack_exports__.a = function speedManager(videoElement, speed$, clock$, _ref) {
            var _ref$pauseWhenStalled = _ref.pauseWhenStalled, forcePause$ = void 0;
            forcePause$ = void 0 === _ref$pauseWhenStalled || _ref$pauseWhenStalled ? clock$.pipe(pairwise()).pipe(Object(map.a)(function(_ref2) {
                var prevTiming = _ref2[0], isStalled = _ref2[1].stalled, wasStalled = prevTiming.stalled;
                if (!wasStalled != !isStalled || // xor
                wasStalled && isStalled && wasStalled.reason !== isStalled.reason) return !wasStalled;
            }), Object(filter.a)(function(val) {
                return null != val;
            }), Object(startWith.a)(!1)) : Object(of.a)(!1);
            return forcePause$.pipe(Object(switchMap.a)(function(shouldForcePause) {
                return shouldForcePause ? Object(defer.a)(function() {
                    return log.a.info("pause playback to build buffer"), videoElement.playbackRate = 0, 
                    Object(of.a)(0);
                }) : speed$.pipe(Object(tap.a)(function(speed) {
                    log.a.info("resume playback speed", speed), videoElement.playbackRate = speed;
                }));
            }));
        };
    }, 
    /* 96 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // CONCATENATED MODULE: ./src/parsers/texttracks/srt/parseTimestamp.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Parse a single srt timestamp into seconds
 * @param {string} timestampString
 * @returns {Number|undefined}
 */        function parseTimestamp(timestampString) {
            var splittedTS = timestampString.split(":");
            if (splittedTS[2]) {
                var hours = parseInt(splittedTS[0], 10), minutes = parseInt(splittedTS[1], 10), seconds = parseFloat(splittedTS[2].replace(",", "."));
                if (isNaN(hours) || isNaN(minutes) || isNaN(seconds)) return;
                return 60 * hours * 60 + 60 * minutes + seconds;
            }
        }
        // CONCATENATED MODULE: ./src/parsers/texttracks/srt/parseCue.ts
        /* harmony export (binding) */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Parse cue block into a cue object which contains:
 *   - start {number}: the start of the cue as a timestamp in seconds
 *   - end {number}: the end of the cue as a timestamp in seconds
 *   - payload {Array.<string>}: the payload of the cue
 * @param {Array.<string>} cueLines
 * @param {Number} timeOffset
 * @returns {Object}
 */
        function parseCueBlock(cueLines, timeOffset) {
            if (0 === cueLines.length) return null;
            var startTimeString = void 0, endTimeString = void 0, payload = [];
            // normally in srt, the timing is at second position.
            // We still authorize to put it in the first position for resilience
            if (cueLines[1] && cueLines[1].indexOf("--\x3e")) {
                var _cueLines$1$split$map = cueLines[1].split("--\x3e").map(function(s) {
                    return s.trim();
                });
                startTimeString = _cueLines$1$split$map[0], endTimeString = _cueLines$1$split$map[1], 
                payload = cueLines.slice(2, cueLines.length);
            }
            if (!startTimeString || !endTimeString) {
                var _cueLines$0$split$map = cueLines[0].split("--\x3e").map(function(s) {
                    return s.trim();
                });
                // Try to see if we find them in the first position
                                startTimeString = _cueLines$0$split$map[0], endTimeString = _cueLines$0$split$map[1], 
                payload = cueLines.slice(1, cueLines.length);
            }
            if (!startTimeString || !endTimeString) 
            // if the time is still not found, exit
            return null;
            var start = parseTimestamp(startTimeString), end = parseTimestamp(endTimeString);
            return null == start || null == end ? null : {
                start: start + timeOffset,
                end: end + timeOffset,
                payload: payload
            };
        }
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return parseCueBlock;
        });
    }, 
    /* 97 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // CONCATENATED MODULE: ./src/parsers/texttracks/srt/findEndOfCueBlock.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Returns the first line that is not apart of the given cue block.
 * The index given can be anywhere in a known cue block.
 *
 * This function is extra-resilient due to observed real-life malformed
 * subtitles.
 * Basically, it allows some deviation from the specification as long as the
 * intent is pretty clear.
 * @param {Array<string>} linified - Whole srt. Line by line.
 * @param {number} startIndex - Index in `linified` of the first line within the
 * block.
 * @returns {number}
 */        function findEndOfCueBlock(linified, startIndex) {
            // continue incrementing i until either:
            //   - an empty line
            //   - the end
            for (var firstEmptyLineIndex = startIndex + 1; linified[firstEmptyLineIndex]; ) firstEmptyLineIndex++;
            return firstEmptyLineIndex;
        }
        // CONCATENATED MODULE: ./src/parsers/texttracks/srt/getCueBlocks.ts
        /* harmony export (binding) */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Get cue blocks from a srt file.
 * @param {Array.<string>} linified - Whole srt file. Each new element in this
 * array is a new line.
 * @returns {Array.<Array.<string>>}
 */
        function getCueBlocks(linified) {
            for (var cueBlocks = [], i = 0; i < linified.length; i++) if (linified[i]) {
                var endOfCue = findEndOfCueBlock(linified, i), cueBlockCandidate = linified.slice(i, endOfCue);
                cueBlockCandidate.length > 0 && (1 === cueBlockCandidate.length ? cueBlockCandidate[0].indexOf("--\x3e") >= 0 && cueBlocks.push(cueBlockCandidate) : (cueBlockCandidate[1].indexOf("--\x3e") >= 0 || cueBlockCandidate[0].indexOf("--\x3e") >= 0) && cueBlocks.push(cueBlockCandidate)), 
                i = endOfCue;
            }
            return cueBlocks;
        }
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return getCueBlocks;
        });
    }, 
    /* 98 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // EXTERNAL MODULE: ./src/parsers/texttracks/ttml/regexps.ts
                var regexps = __webpack_require__(20);
        // CONCATENATED MODULE: ./src/parsers/texttracks/ttml/time_parsing.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Parses a TTML time into seconds.
 * @param {string} text
 * @param {Object} ttParams
 * @returns {Number|undefined}
 */        
        /**
 * Parses a TTML time in frame format
 * @param {Object} ttParams
 * @param {string} text
 * @returns {Number}
 */
        function parseFramesTime(ttParams, text) {
            // 75f or 75.5f
            // (We cast as we're sure the regexp is respected here)
            var results = regexps.g.exec(text);
            return Number(results[1]) / ttParams.frameRate;
        }
        /**
 * Parses a TTML time in tick format
 * @param {Object} ttParams
 * @param {string} text
 * @returns {Number}
 */        function parseTickTime(ttParams, text) {
            // 50t or 50.5t
            // (We cast as we're sure the regexp is respected here)
            var results = regexps.i.exec(text);
            return Number(results[1]) / ttParams.tickRate;
        }
        /**
 * Parses a TTML colon formatted time containing frames
 * @param {Object} ttParams
 * @param {string} text
 * @returns {Number}
 */        function parseColonTimeWithFrames(ttParams, text) {
            // 01:02:43:07 ("07" is frames) or 01:02:43:07.1 (subframes)
            // (We cast as we're sure the regexp is respected here)
            var results = regexps.e.exec(text), hours = Number(results[1]), minutes = Number(results[2]), seconds = Number(results[3]), frames = Number(results[4]);
            return (seconds += (frames += (Number(results[5]) || 0) / ttParams.subFrameRate) / ttParams.frameRate) + 60 * minutes + 3600 * hours;
        }
        /**
 * Parses a TTML time with a given regex. Expects regex to be some
 * sort of a time-matcher to match hours, minutes, seconds and milliseconds
 *
 * @param {RegExp} regex
 * @param {string} text
 * @returns {number|null}
 */        function parseTimeFromRegExp(regex, text) {
            var results = regex.exec(text);
            if (null === results || "" === results[0]) return null;
            // This capture is optional, but will still be in the array as undefined,
            // default to 0.
                        var hours = Number(results[1]) || 0, minutes = Number(results[2]) || 0, seconds = Number(results[3]) || 0;
            return (Number(results[4]) || 0) / 1e3 + seconds + 60 * minutes + 3600 * hours;
        }
        /* harmony default export */        var time_parsing = function parseTime(text, ttParams) {
            return regexps.e.test(text) ? parseColonTimeWithFrames(ttParams, text) : regexps.d.test(text) ? parseTimeFromRegExp(regexps.d, text) : regexps.f.test(text) ? parseTimeFromRegExp(regexps.f, text) : regexps.g.test(text) ? parseFramesTime(ttParams, text) : regexps.i.test(text) ? parseTickTime(ttParams, text) : regexps.h.test(text) ? parseTimeFromRegExp(regexps.h, text) : void 0;
        };
        // CONCATENATED MODULE: ./src/parsers/texttracks/ttml/getTimeDelimiters.ts
        /* harmony export (binding) */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Get start and end time of an element.
 * @param {Element} element
 * @param {Object} ttParams
 * @returns {Object}
 */
        function getTimeDelimiters(element, ttParams) {
            var beginAttr = element.getAttribute("begin"), durationAttr = element.getAttribute("dur"), endAttr = element.getAttribute("end"), start = beginAttr ? time_parsing(beginAttr, ttParams) : null, duration = durationAttr ? time_parsing(durationAttr, ttParams) : null, parsedEnd = endAttr ? time_parsing(endAttr, ttParams) : null;
            if (null == start || null == parsedEnd && null == duration) throw new Error("Invalid text cue");
            // TODO Huh? Is TypeScript that dumb here?
                        return {
                start: start,
                end: null == parsedEnd ? start + duration : parsedEnd
            };
        }
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return getTimeDelimiters;
        });
    }, 
    /* 99 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/parseTimestamp.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Parse a single webvtt timestamp into seconds
 * @param {string} timestampString
 * @returns {Number|undefined}
 */        function parseTimestamp(timestampString) {
            var splittedTS = timestampString.split(":").reverse();
            if (splittedTS[2] || splittedTS[1]) {
                var hours = splittedTS[2] ? parseInt(splittedTS[2], 10) : 0, minutes = parseInt(splittedTS[1], 10), seconds = parseFloat(splittedTS[0].replace(",", "."));
                if (isNaN(hours) || isNaN(minutes) || isNaN(seconds)) return;
                return 60 * hours * 60 + 60 * minutes + seconds;
            }
        }
        // CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/parseCueBlock.ts
        /* harmony export (binding) */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Parse the settings part of a cue, into key-value object.
 * @param {string} settingsString
 * @returns {Object}
 */
        function parseSettings(settingsString) {
            return settingsString.split(/ |\t/).reduce(function(acc, setting) {
                var splittedSetting = setting.split(":");
                return 2 === splittedSetting.length && (acc[splittedSetting[0]] = splittedSetting[1]), 
                acc;
            }, {});
        }
        /**
 * Parse the line containing the timestamp and settings in a cue.
 * The returned object has the following properties:
 *   - start {Number}: start of the cue, in seconds
 *   - end {Number}: end of the cue, in seconds
 *   - settings {Object}: settings for the cue as a key-value object.
 * @param {string} timeString
 * @returns {Object|null}
 */        function parseTimeAndSettings(timeString) {
            /**
     * RegExp for the timestamps + settings line.
     *
     * Capture groups:
     *   1 -> start timestamp
     *   2 -> end timestamp
     *   3 - settings
     * @type {RegExp}
     */
            var matches = timeString.match(/^([\d:.]+)[ |\t]+-->[ |\t]+([\d:.]+)[ |\t]*(.*)$/);
            if (!matches) return null;
            var start = parseTimestamp(matches[1]), end = parseTimestamp(matches[2]);
            return null == start || null == end ? null : {
                start: start,
                end: end,
                settings: parseSettings(matches[3])
            };
        }
        /**
 * Parse cue block into a cue object which contains:
 *   - start {number}: the start of the cue as a timestamp in seconds
 *   - end {number}: the end of the cue as a timestamp in seconds
 *   - header {string|undefined}: The optional cue identifier
 *   - payload {Array.<string>}: the payload of the cue
 * @param {Array.<string>} cueLines
 * @param {Number} timeOffset
 * @returns {Object}
 */        function parseCueBlock(cueLines, timeOffset) {
            var timingRegexp = /-->/, timeString = void 0, payload = void 0, header = void 0;
            if (timingRegexp.test(cueLines[0])) timeString = cueLines[0], payload = cueLines.slice(1, cueLines.length); else {
                if (!timingRegexp.test(cueLines[1])) 
                // not a cue
                return null;
                header = cueLines[0], timeString = cueLines[1], payload = cueLines.slice(2, cueLines.length);
            }
            if (!timeString) return null;
            var timeAndSettings = parseTimeAndSettings(timeString);
            return timeAndSettings ? {
                start: timeAndSettings.start + timeOffset,
                end: timeAndSettings.end + timeOffset,
                settings: timeAndSettings.settings,
                payload: payload,
                header: header
            } : null;
        }
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return parseCueBlock;
        });
    }, 
    /* 100 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js
                var tslib_es6 = __webpack_require__(2), Action_Action = /* */ function(_super) {
            function Action(scheduler, work) {
                return _super.call(this) || this;
            }
            return tslib_es6.a(Action, _super), Action.prototype.schedule = function(state, delay) {
                return void 0 === delay && (delay = 0), this;
            }, Action;
        }(__webpack_require__(16).a);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subscription.js + 1 modules
                //# sourceMappingURL=Action.js.map
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/scheduler/AsyncAction.js
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return AsyncAction_AsyncAction;
        });
        /** PURE_IMPORTS_START tslib,_Action PURE_IMPORTS_END */
        var AsyncAction_AsyncAction = /* */ function(_super) {
            function AsyncAction(scheduler, work) {
                var _this = _super.call(this, scheduler, work) || this;
                return _this.scheduler = scheduler, _this.work = work, _this.pending = !1, _this;
            }
            return tslib_es6.a(AsyncAction, _super), AsyncAction.prototype.schedule = function(state, delay) {
                if (void 0 === delay && (delay = 0), this.closed) return this;
                this.state = state;
                var id = this.id, scheduler = this.scheduler;
                return null != id && (this.id = this.recycleAsyncId(scheduler, id, delay)), this.pending = !0, 
                this.delay = delay, this.id = this.id || this.requestAsyncId(scheduler, this.id, delay), 
                this;
            }, AsyncAction.prototype.requestAsyncId = function(scheduler, id, delay) {
                return void 0 === delay && (delay = 0), setInterval(scheduler.flush.bind(scheduler, this), delay);
            }, AsyncAction.prototype.recycleAsyncId = function(scheduler, id, delay) {
                if (void 0 === delay && (delay = 0), null !== delay && this.delay === delay && !1 === this.pending) return id;
                clearInterval(id);
            }, AsyncAction.prototype.execute = function(state, delay) {
                if (this.closed) return new Error("executing a cancelled action");
                this.pending = !1;
                var error = this._execute(state, delay);
                if (error) return error;
                !1 === this.pending && null != this.id && (this.id = this.recycleAsyncId(this.scheduler, this.id, null));
            }, AsyncAction.prototype._execute = function(state, delay) {
                var errored = !1, errorValue = void 0;
                try {
                    this.work(state);
                } catch (e) {
                    errored = !0, errorValue = !!e && e || new Error(e);
                }
                if (errored) return this.unsubscribe(), errorValue;
            }, AsyncAction.prototype._unsubscribe = function() {
                var id = this.id, scheduler = this.scheduler, actions = scheduler.actions, index = actions.indexOf(this);
                this.work = null, this.state = null, this.pending = !1, this.scheduler = null, -1 !== index && actions.splice(index, 1), 
                null != id && (this.id = this.recycleAsyncId(scheduler, id, null)), this.delay = null;
            }, AsyncAction;
        }(Action_Action);
        //# sourceMappingURL=AsyncAction.js.map
        /***/    }, 
    /* 101 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js
                var tslib_es6 = __webpack_require__(2), Scheduler = /* */ function() {
            function Scheduler(SchedulerAction, now) {
                void 0 === now && (now = Scheduler.now), this.SchedulerAction = SchedulerAction, 
                this.now = now;
            }
            return Scheduler.prototype.schedule = function(work, delay, state) {
                return void 0 === delay && (delay = 0), new this.SchedulerAction(this, work).schedule(state, delay);
            }, Scheduler.now = Date.now ? Date.now : function() {
                return +new Date();
            }, Scheduler;
        }();
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/Scheduler.js
                //# sourceMappingURL=Scheduler.js.map
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/scheduler/AsyncScheduler.js
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return AsyncScheduler_AsyncScheduler;
        });
        /** PURE_IMPORTS_START tslib,_Scheduler PURE_IMPORTS_END */
        var AsyncScheduler_AsyncScheduler = /* */ function(_super) {
            function AsyncScheduler(SchedulerAction, now) {
                void 0 === now && (now = Scheduler.now);
                var _this = _super.call(this, SchedulerAction, function() {
                    return AsyncScheduler.delegate && AsyncScheduler.delegate !== _this ? AsyncScheduler.delegate.now() : now();
                }) || this;
                return _this.actions = [], _this.active = !1, _this.scheduled = void 0, _this;
            }
            return tslib_es6.a(AsyncScheduler, _super), AsyncScheduler.prototype.schedule = function(work, delay, state) {
                return void 0 === delay && (delay = 0), AsyncScheduler.delegate && AsyncScheduler.delegate !== this ? AsyncScheduler.delegate.schedule(work, delay, state) : _super.prototype.schedule.call(this, work, delay, state);
            }, AsyncScheduler.prototype.flush = function(action) {
                var actions = this.actions;
                if (this.active) actions.push(action); else {
                    var error;
                    this.active = !0;
                    do {
                        if (error = action.execute(action.state, action.delay)) break;
                    } while (action = actions.shift());
                    if (this.active = !1, error) {
                        for (;action = actions.shift(); ) action.unsubscribe();
                        throw error;
                    }
                }
            }, AsyncScheduler;
        }(Scheduler);
        //# sourceMappingURL=AsyncScheduler.js.map
        /***/    }, 
    /* 102 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/mergeMap.js
                var mergeMap = __webpack_require__(57);
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/util/identity.js
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */        function identity(x) {
            return x;
        }
        //# sourceMappingURL=identity.js.map
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/mergeAll.js
        /* harmony export (binding) */        
        /** PURE_IMPORTS_START _mergeMap,_util_identity PURE_IMPORTS_END */
        function mergeAll(concurrent) {
            return void 0 === concurrent && (concurrent = Number.POSITIVE_INFINITY), Object(mergeMap.a)(identity, concurrent);
        }
        //# sourceMappingURL=mergeAll.js.map
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return mergeAll;
        });
    }, 
    /* 103 */ 
    /* 104 */
    /***/ , 
    /* 104 */
    /***/ function(module, exports, __webpack_require__) {
        "use strict";
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        // ugly webpack workaround to export require-style
        /* tslint:disable no-var-requires */        module.exports = __webpack_require__(123).default;
    }, 
    /* 105 */ 
    /* 106 */ , 
    /* 107 */
    /***/ , 
    /* 107 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return concat;
        });
        /* harmony import */ var _util_isScheduler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(34), _of__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(75), _from__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(44), _operators_concatAll__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(108);
        /* harmony import */        
        /** PURE_IMPORTS_START _util_isScheduler,_of,_from,_operators_concatAll PURE_IMPORTS_END */
        function concat() {
            for (var observables = [], _i = 0; _i < arguments.length; _i++) observables[_i] = arguments[_i];
            return 1 === observables.length || 2 === observables.length && Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_0__.a)(observables[1]) ? Object(_from__WEBPACK_IMPORTED_MODULE_2__.a)(observables[0]) : Object(_operators_concatAll__WEBPACK_IMPORTED_MODULE_3__.a)()(_of__WEBPACK_IMPORTED_MODULE_1__.a.apply(void 0, observables));
        }
        //# sourceMappingURL=concat.js.map
        /***/    }, 
    /* 108 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return concatAll;
        });
        /* harmony import */ var _mergeAll__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(102);
        /** PURE_IMPORTS_START _mergeAll PURE_IMPORTS_END */        function concatAll() {
            return Object(_mergeAll__WEBPACK_IMPORTED_MODULE_0__.a)(1);
        }
        //# sourceMappingURL=concatAll.js.map
        /***/    }, 
    /* 109 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return concatMap;
        });
        /* harmony import */ var _mergeMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(57);
        /** PURE_IMPORTS_START _mergeMap PURE_IMPORTS_END */        function concatMap(project, resultSelector) {
            return Object(_mergeMap__WEBPACK_IMPORTED_MODULE_0__.a)(project, resultSelector, 1);
        }
        //# sourceMappingURL=concatMap.js.map
        /***/    }, 
    /* 110 */
    /***/ function(module, exports, __webpack_require__) {
        var pSlice = Array.prototype.slice, objectKeys = __webpack_require__(121), isArguments = __webpack_require__(122), deepEqual = module.exports = function(actual, expected, opts) {
            // 7.1. All identical values are equivalent, as determined by ===.
            return opts || (opts = {}), actual === expected || (actual instanceof Date && expected instanceof Date ? actual.getTime() === expected.getTime() : !actual || !expected || "object" != typeof actual && "object" != typeof expected ? opts.strict ? actual === expected : actual == expected : objEquiv(actual, expected, opts));
        };
        function isUndefinedOrNull(value) {
            return null === value || void 0 === value;
        }
        function isBuffer(x) {
            return !(!x || "object" != typeof x || "number" != typeof x.length) && ("function" == typeof x.copy && "function" == typeof x.slice && !(x.length > 0 && "number" != typeof x[0]));
        }
        function objEquiv(a, b, opts) {
            var i, key;
            if (isUndefinedOrNull(a) || isUndefinedOrNull(b)) return !1;
            // an identical 'prototype' property.
                        if (a.prototype !== b.prototype) return !1;
            //~~~I've managed to break Object.keys through screwy arguments passing.
            //   Converting to array solves the problem.
                        if (isArguments(a)) return !!isArguments(b) && (a = pSlice.call(a), 
            b = pSlice.call(b), deepEqual(a, b, opts));
            if (isBuffer(a)) {
                if (!isBuffer(b)) return !1;
                if (a.length !== b.length) return !1;
                for (i = 0; i < a.length; i++) if (a[i] !== b[i]) return !1;
                return !0;
            }
            try {
                var ka = objectKeys(a), kb = objectKeys(b);
            } catch (e) {
                //happens when one is a string literal and the other isn't
                return !1;
            }
            // having the same number of owned properties (keys incorporates
            // hasOwnProperty)
                        if (ka.length != kb.length) return !1;
            //the same set of keys (although not necessarily the same order),
                        //~~~cheap key test
            for (ka.sort(), kb.sort(), i = ka.length - 1; i >= 0; i--) if (ka[i] != kb[i]) return !1;
            //equivalent values for every corresponding key, and
            //~~~possibly expensive deep test
                        for (i = ka.length - 1; i >= 0; i--) if (key = ka[i], !deepEqual(a[key], b[key], opts)) return !1;
            return typeof a == typeof b;
        }
        /***/    }, 
    /* 111 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        function _possibleConstructorReturn(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" != typeof call && "function" != typeof call ? self : call;
        }
        function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        // TODO
                __webpack_require__.r(__webpack_exports__);
        var ImageSourceBuffer = function(_AbstractSourceBuffer) {
            function ImageSourceBuffer() {
                return _classCallCheck(this, ImageSourceBuffer), _possibleConstructorReturn(this, _AbstractSourceBuffer.apply(this, arguments));
            }
            /**
   * @param {Object} data
   */            return _inherits(ImageSourceBuffer, _AbstractSourceBuffer), ImageSourceBuffer.prototype._append = function _append(data) {
                var start = data.start, end = data.end, timescale = data.timescale;
                this.buffered.insert(start / timescale, null == end ? Number.MAX_VALUE : end / timescale);
            }, 
            // TODO
            /* tslint:disable no-empty */
            ImageSourceBuffer.prototype._remove = function _remove() {}, 
            /* tslint:enable no-empty */
            // TODO
            /* tslint:disable no-empty */
            ImageSourceBuffer.prototype._abort = function _abort() {}, ImageSourceBuffer;
        }(__webpack_require__(61).a);
        /* harmony default export */        __webpack_exports__.default = ImageSourceBuffer;
    }, 
    /* 112 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        /* harmony import */ var _utils_bytes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */
        /**
 * @param {UInt8Array} buf
 * @returns {Object}
 */        
        /* harmony default export */ __webpack_exports__.default = function parseBif(buf) {
            var pos = 0, length = buf.length, fileFormat = Object(_utils_bytes__WEBPACK_IMPORTED_MODULE_0__.f)(buf.subarray(pos, pos + 8)), minorVersion = buf[pos += 8], majorVersion = buf[pos += 1], patchVersion = buf[pos += 1], increVersion = buf[pos += 1];
            pos += 1;
            var version = [ minorVersion, majorVersion, patchVersion, increVersion ].join("."), imageCount = buf[pos] + Object(_utils_bytes__WEBPACK_IMPORTED_MODULE_0__.o)(buf, pos + 1);
            pos += 4;
            var timescale = Object(_utils_bytes__WEBPACK_IMPORTED_MODULE_0__.o)(buf, pos);
            pos += 4;
            var format = Object(_utils_bytes__WEBPACK_IMPORTED_MODULE_0__.f)(buf.subarray(pos, pos + 4));
            pos += 4;
            var width = Object(_utils_bytes__WEBPACK_IMPORTED_MODULE_0__.n)(buf, pos);
            pos += 2;
            var height = Object(_utils_bytes__WEBPACK_IMPORTED_MODULE_0__.n)(buf, pos), aspectRatio = [ buf[pos += 2], buf[pos + 1] ].join(":"), isVod = 1 === buf[pos += 2];
            pos += 1, 
            // bytes 0x1F to 0x40 is unused data for now
            pos = 64;
            var thumbs = [], currentImage = void 0, currentTs = 0;
            if (!imageCount) throw new Error("bif: no images to parse");
            for (;pos < length; ) {
                var currentImageIndex = Object(_utils_bytes__WEBPACK_IMPORTED_MODULE_0__.o)(buf, pos);
                pos += 4;
                var currentImageOffset = Object(_utils_bytes__WEBPACK_IMPORTED_MODULE_0__.o)(buf, pos);
                if (pos += 4, currentImage) {
                    var index = currentImage.index, duration = timescale, ts = currentTs, data = buf.subarray(currentImage.offset, currentImageOffset);
                    thumbs.push({
                        index: index,
                        duration: duration,
                        ts: ts,
                        data: data
                    }), currentTs += timescale;
                }
                if (4294967295 === currentImageIndex) break;
                currentImage = {
                    index: currentImageIndex,
                    offset: currentImageOffset
                };
            }
            return {
                fileFormat: fileFormat,
                version: version,
                imageCount: imageCount,
                timescale: timescale,
                format: format,
                width: width,
                height: height,
                aspectRatio: aspectRatio,
                isVod: isVod,
                thumbs: thumbs
            };
        };
    }, 
    /* 113 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() {
            return parseVTTStringToVTTCues;
        });
        /* harmony import */ var _compat_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12), _utils_array_includes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(14), _getCueBlocks__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(84), _parseCueBlock__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(99), _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(48);
        /* harmony import */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */
        // Simple VTT to VTTCue parser:
        // Just parse cues and associated settings.
        // Does not take into consideration STYLE and REGION blocks.
        /**
 * Parse whole WEBVTT file into an array of cues, to be inserted in a video's
 * TrackElement.
 * @param {string} vttStr
 * @param {Number} timeOffset
 * @returns {Array.<VTTCue|TextTrackCue>}
 */
        function parseVTTStringToVTTCues(vttStr, timeOffset) {
            // WEBVTT authorize CRLF, LF or CR as line terminators
            var lines = vttStr.split(/\r\n|\n|\r/);
            if (!/^WEBVTT($| |\t)/.test(lines[0])) throw new Error("Can't parse WebVTT: Invalid file.");
            for (var firstLineAfterHeader = Object(_utils__WEBPACK_IMPORTED_MODULE_4__.b)(lines), cueBlocks = Object(_getCueBlocks__WEBPACK_IMPORTED_MODULE_2__.a)(lines, firstLineAfterHeader), cues = [], i = 0; i < cueBlocks.length; i++) {
                var cueObject = Object(_parseCueBlock__WEBPACK_IMPORTED_MODULE_3__.a)(cueBlocks[i], timeOffset);
                if (null != cueObject) {
                    var nativeCue = toNativeCue(cueObject);
                    null != nativeCue && (nativeCue instanceof VTTCue && setSettingsOnCue(cueObject.settings, nativeCue), 
                    cues.push(nativeCue));
                }
            }
            return cues;
        }
        /**
 * @param {Object} cue Object
 * @returns {TextTrackCue|VTTCue|null}
 */        function toNativeCue(cueObj) {
            var start = cueObj.start, end = cueObj.end, text = cueObj.payload.join("\n");
            return Object(_compat_index__WEBPACK_IMPORTED_MODULE_0__.i)(start, end, text);
        }
        /**
 * Add the corresponding settings on the given cue.
 * /!\ Mutates the cue given.
 * @param {Object} settings - settings for the cue, as a key-value object.
 * @param {VTTCue|TextTrackCue} cue
 */        function setSettingsOnCue(settings, cue) {
            if (!settings.vertical || "rl" !== settings.vertical && "lr" !== settings.vertical || (cue.vertical = settings.vertical), 
            settings.line) {
                /**
         * Capture groups:
         *   1 -> percentage position
         *   2 -> optional decimals from percentage position
         *   3 -> optional follow-up of the string indicating alignment value
         *   4 -> alignment value
         * @type {RegExp}
         */
                var percentageMatches = settings.line.match(/^(\d+(\.\d+)?)%(,([a-z]+))?/);
                if (percentageMatches) cue.line = Number(percentageMatches[1]), cue.snapToLines = !1, 
                Object(_utils_array_includes__WEBPACK_IMPORTED_MODULE_1__.a)([ "start", "center", "end" ], percentageMatches[4]) && (cue.lineAlign = percentageMatches[4]); else {
                    /**
             * Capture groups:
             *   1 -> line number
             *   2 -> optional follow-up of the string indicating alignment value
             *   3 -> alignment value
             * @type {RegExp}
             */
                    var lineMatches = settings.line.match(/^(-?\d+)(,([a-z]+))?/);
                    lineMatches && (cue.line = Number(lineMatches[1]), cue.snapToLines = !0, Object(_utils_array_includes__WEBPACK_IMPORTED_MODULE_1__.a)([ "start", "center", "end" ], lineMatches[3]) && (cue.lineAlign = lineMatches[3]));
                }
            }
            if (settings.position) {
                var positionArr = /^([\d\.]+)%(?:,(line-left|line-right|center))?$/.exec(settings.position);
                if (positionArr && positionArr.length >= 2) {
                    var position = parseInt(positionArr[1], 10);
                    isNaN(position) || (cue.position = position, null != positionArr[2] && (cue.positionAlign = positionArr[2]));
                }
            }
            settings.size && (cue.size = settings.size), settings.align && Object(_utils_array_includes__WEBPACK_IMPORTED_MODULE_1__.a)([ "start", "center", "end", "left" ], settings.align) && (cue.align = settings.align);
        }
        /***/    }, 
    /* 114 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        /* harmony import */ var array_find__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(13), array_find__WEBPACK_IMPORTED_MODULE_0___default = /* */ __webpack_require__.n(array_find__WEBPACK_IMPORTED_MODULE_0__), object_assign__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(11), object_assign__WEBPACK_IMPORTED_MODULE_1___default = /* */ __webpack_require__.n(object_assign__WEBPACK_IMPORTED_MODULE_1__), _compat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(12), _getParameters__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(85), _getParentElementsByTagName__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(60), _getTimeDelimiters__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(98), _nodes__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(58), _regexps__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(20), _style__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(30), WANTED_STYLE_ATTRIBUTES = [ "extent", "writingMode", "origin", "align" ], TEXT_ALIGN_TO_LIGN_ALIGN = {
            left: "start",
            center: "center",
            right: "end",
            start: "start",
            end: "end"
        }, TEXT_ALIGN_TO_POSITION_ALIGN = {
            left: "line-left",
            center: "center",
            right: "line-right"
        };
        /* harmony import */        
        /**
 * Parses an Element into a TextTrackCue or VTTCue.
 * /!\ Mutates the given cueElement Element
 * @param {Element} paragraph
 * @param {Number} offset
 * @param {Array.<Object>} styles
 * @param {Array.<Object>} regions
 * @param {Object} paragraphStyle
 * @param {Object} params
 * @returns {TextTrackCue|null}
 */
        function parseCue(paragraph, offset, _styles, _regions, paragraphStyle, params) {
            // Disregard empty elements:
            // TTML allows for empty elements like <div></div>.
            // If paragraph has neither time attributes, nor
            // non-whitespace text, don't try to make a cue out of it.
            if (!paragraph.hasAttribute("begin") && !paragraph.hasAttribute("end") && /^\s*$/.test(paragraph.textContent || "")) return null;
            var _getTimeDelimiters = Object(_getTimeDelimiters__WEBPACK_IMPORTED_MODULE_5__.a)(paragraph, params), start = _getTimeDelimiters.start, end = _getTimeDelimiters.end, text = generateTextContent(paragraph, "default" === params.spaceStyle), cue = Object(_compat__WEBPACK_IMPORTED_MODULE_2__.i)(start + offset, end + offset, text);
            return cue ? (cue instanceof VTTCue && addStyle(cue, paragraphStyle), cue) : null;
        }
        /**
 * Generate text to display for a given paragraph.
 * @param {Element} paragraph - The <p> tag.
 * @param {Boolean} shouldTrimWhiteSpace
 * @returns {string}
 */        function generateTextContent(paragraph, shouldTrimWhiteSpace) {
            /**
     * Recursive function, taking a node in argument and returning the
     * corresponding string.
     * @param {Node} node - the node in question
     * @returns {string}
     */
            return function loop(node) {
                for (var childNodes = node.childNodes, text = "", i = 0; i < childNodes.length; i++) {
                    var currentNode = childNodes[i];
                    if ("#text" === currentNode.nodeName) {
                        var textContent = currentNode.textContent || "";
                        // TODO Also parse it from parent elements
                        // const spaceAttr = getAttribute("xml:space", [
                        //   ...spans, p, ...divs, body,
                        // ]);
                        // const shouldTrimWhiteSpace = spaceAttr ?
                        //   spaceAttr === "default" : shouldTrimWhiteSpaceParam;
                                                if (shouldTrimWhiteSpace) {
                            // 1. Trim leading and trailing whitespace.
                            // 2. Collapse multiple spaces into one.
                            var trimmed = textContent.trim();
                            textContent = trimmed = trimmed.replace(/\s+/g, " ");
                        }
                        text += textContent;
                    } else "br" === currentNode.nodeName ? text += "\n" : "span" === currentNode.nodeName && currentNode.childNodes.length > 0 && (text += loop(currentNode));
                }
                return text;
            }(paragraph);
        }
        /**
 * Adds applicable style properties to a cue.
 * /!\ Mutates cue argument.
 * @param {VTTCue} cue
 * @param {Object} style
 */        function addStyle(cue, style) {
            var extent = style.extent;
            if (extent) {
                var results = _regexps__WEBPACK_IMPORTED_MODULE_7__.c.exec(extent);
                null != results && (
                // Use width value of the extent attribute for size.
                // Height value is ignored.
                cue.size = Number(results[1]));
            }
            // let isVerticalText = true;
            switch (style.writingMode) {
              case "tb":
              case "tblr":
                cue.vertical = "lr";
                break;

              case "tbrl":
                cue.vertical = "rl";
            }
            var origin = style.origin;
            if (origin) _regexps__WEBPACK_IMPORTED_MODULE_7__.c.exec(origin);
            var align = style.align;
            align && (cue.align = align, "center" === align && ("center" !== cue.align && (
            // Workaround for a Chrome bug http://crbug.com/663797
            // Chrome does not support align = "center"
            cue.align = "middle"), cue.position = "auto"), cue.positionAlign = TEXT_ALIGN_TO_POSITION_ALIGN[align] || "", 
            cue.lineAlign = TEXT_ALIGN_TO_LIGN_ALIGN[align] || "");
        }
        /* harmony default export */        __webpack_exports__.default = 
        /**
 * @param {string} str
 * @param {Number} timeOffset
 * @returns {Array.<VTTCue|TextTrackCue>}
 */
        function parseTTMLStringToVTT(str, timeOffset) {
            var ret = [], xml = new DOMParser().parseFromString(str, "text/xml");
            if (xml) {
                var tt = xml.getElementsByTagName("tt")[0];
                if (!tt) throw new Error("invalid XML");
                for (var body = Object(_nodes__WEBPACK_IMPORTED_MODULE_6__.a)(tt), styleNodes = Object(_nodes__WEBPACK_IMPORTED_MODULE_6__.c)(tt), regionNodes = Object(_nodes__WEBPACK_IMPORTED_MODULE_6__.b)(tt), textNodes = Object(_nodes__WEBPACK_IMPORTED_MODULE_6__.d)(tt), params = Object(_getParameters__WEBPACK_IMPORTED_MODULE_3__.a)(tt), styles = [], i = 0; i <= styleNodes.length - 1; i++) {
                    // TODO styles referencing other styles
                    var styleNode = styleNodes[i];
                    if (styleNode instanceof Element) {
                        var styleID = styleNode.getAttribute("xml:id");
                        null != styleID && styles.push({
                            id: styleID,
                            style: Object(_style__WEBPACK_IMPORTED_MODULE_8__.b)(styleNode)
                        });
                    }
                }
                // construct regions array based on the xml as an optimization
                                for (var regions = [], _i = 0; _i <= regionNodes.length - 1; _i++) {
                    var regionNode = regionNodes[_i];
                    if (regionNode instanceof Element) {
                        var regionID = regionNode.getAttribute("xml:id");
                        null != regionID && function() {
                            var regionStyle = Object(_style__WEBPACK_IMPORTED_MODULE_8__.b)(regionNode), associatedStyle = regionNode.getAttribute("style");
                            if (associatedStyle) {
                                var style = array_find__WEBPACK_IMPORTED_MODULE_0___default()(styles, function(x) {
                                    return x.id === associatedStyle;
                                });
                                style && (regionStyle = object_assign__WEBPACK_IMPORTED_MODULE_1___default()({}, style.style, regionStyle));
                            }
                            regions.push({
                                id: regionID,
                                style: regionStyle
                            });
                        }();
                    }
                }
                // Computing the style takes a lot of ressources.
                // To avoid too much re-computation, let's compute the body style right
                // now and do the rest progressively.
                                for (var bodyStyle = body ? Object(_style__WEBPACK_IMPORTED_MODULE_8__.a)(WANTED_STYLE_ATTRIBUTES, [ body ], styles, regions) : Object(_style__WEBPACK_IMPORTED_MODULE_8__.a)(WANTED_STYLE_ATTRIBUTES, [], styles, regions), _i2 = 0; _i2 < textNodes.length; _i2++) {
                    var paragraph = textNodes[_i2];
                    if (paragraph instanceof Element) {
                        var divs = Object(_getParentElementsByTagName__WEBPACK_IMPORTED_MODULE_4__.a)(paragraph, "div"), paragraphStyle = object_assign__WEBPACK_IMPORTED_MODULE_1___default()({}, bodyStyle, Object(_style__WEBPACK_IMPORTED_MODULE_8__.a)(WANTED_STYLE_ATTRIBUTES, [ paragraph ].concat(divs), styles, regions)), cue = parseCue(paragraph, timeOffset, 0, 0, paragraphStyle, params);
                        cue && ret.push(cue);
                    }
                }
            }
            return ret;
        };
    }, 
    /* 115 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        /* harmony import */ var _compat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12), _utils_assert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9), HTML_ENTITIES = /&#([0-9]+);/g, BR = /<br>/gi, STYLE = /<style[^>]*>([\s\S]*?)<\/style[^>]*>/i, PARAG = /\s*<p class=([^>]+)>(.*)/i, START = /<sync[^>]+?start="?([0-9]*)"?[^0-9]/i;
        /* harmony import */        
        /**
 * Creates an array of VTTCue/TextTrackCue from a given array of cue objects.
 * @param {Array.<Object>} cuesArray - Objects containing the start, end and
 * text.
 * @returns {Array.<VTTCue>}
 */
        function createCuesFromArray(cuesArray) {
            for (var nativeCues = [], i = 0; i < cuesArray.length; i++) {
                var _cuesArray$i = cuesArray[i], start = _cuesArray$i.start, end = _cuesArray$i.end, text = _cuesArray$i.text;
                if (text && null != end) {
                    var cue = Object(_compat__WEBPACK_IMPORTED_MODULE_0__.i)(start, end, text);
                    null != cue && nativeCues.push(cue);
                }
            }
            return nativeCues;
        }
        /**
 * Returns classnames for every languages.
 * @param {string} str
 * @returns {Object}
 */        function getClassNameByLang(str) {
            for (var ruleRe = /\.(\S+)\s*{([^}]*)}/gi, langs = {}, m = void 0; m = ruleRe.exec(str); ) {
                var name = m[1], lang = getCSSProperty(m[2], "lang");
                null != name && null != lang && (langs[lang] = name);
            }
            return langs;
        }
        /**
 * @param {string} str - entire CSS rule
 * @param {string} name - name of the property
 * @returns {string|null} - value of the property. Null if not found.
 */        function getCSSProperty(str, name) {
            var matches = str.match(new RegExp("\\s*" + name + ":\\s*(\\S+);", "i"));
            return matches ? matches[1] : null;
        }
        /**
 * Decode HMTL formatting into a string.
 * @param {string} text
 * @returns {string}
 */        function decodeEntities(text) {
            return text.replace(BR, "\n").replace(HTML_ENTITIES, function(_, $1) {
                return String.fromCharCode($1);
            });
        }
        /**
 * Because sami is not really html... we have to use
 * some kind of regular expressions to parse it...
 * the cthulhu way :)
 * The specification being quite clunky, this parser
 * may not work for every sami input.
 *
 * @param {string} smi
 * @param {Number} timeOffset
 * @param {string} lang
 * @returns {Array.<VTTCue|TextTrackCue>}
 */        
        /* harmony default export */ __webpack_exports__.default = function parseSami(smi, timeOffset, lang) {
            var syncOpen = /<sync[ >]/gi, syncClose = /<sync[ >]|<\/body>/gi, subs = [], styleMatches = smi.match(STYLE), css = styleMatches ? styleMatches[1] : "", up = void 0, to = void 0;
            // XXX TODO FIXME Is that wanted?
            // previously written as let to = SyncClose.exec(smi); but never used
            syncClose.exec(smi);
            var langs = getClassNameByLang(css), klass = lang && langs[lang];
            for (Object(_utils_assert__WEBPACK_IMPORTED_MODULE_1__.b)(!!klass, "sami: could not find lang " + lang + " in CSS"); up = syncOpen.exec(smi), 
            to = syncClose.exec(smi), up || to; ) {
                if (!up || !to || up.index >= to.index) throw new Error("parse error");
                var str = smi.slice(up.index, to.index), tim = str.match(START);
                if (!tim) throw new Error("parse error (sync time attribute)");
                var start = +tim[1];
                if (isNaN(start)) throw new Error("parse error (sync time attribute NaN)");
                appendToSubs(str.split("\n"), start / 1e3);
            }
            return createCuesFromArray(subs);
            function appendToSubs(lines, start) {
                for (var i = lines.length, m = void 0; --i >= 0; ) if (m = lines[i].match(PARAG)) {
                    var _m = m, kl = _m[1], txt = _m[2];
                    klass === kl && ("&nbsp;" === txt ? subs[subs.length - 1].end = start : subs.push({
                        text: decodeEntities(txt),
                        start: start + timeOffset
                    }));
                }
            }
        };
    }, 
    /* 116 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() {
            return parseSRTStringToVTTCues;
        });
        /* harmony import */ var _compat_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12), _getCueBlocks__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(97), _parseCue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(96);
        /* harmony import */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */
        // srt to VTTCue parser, Done for fun.
        // Heavily inspired from the WebVTT implementation
        /**
 * Parse whole srt file into an array of cues, to be inserted in a video's
 * TrackElement.
 * @param {string} srtStr
 * @param {Number} timeOffset
 * @returns {Array.<VTTCue|TextTrackCue>}
 */
        function parseSRTStringToVTTCues(srtStr, timeOffset) {
            for (
            // Even if srt only authorize CRLF, we will also take LF or CR as line
            // terminators for resilience
            var lines = srtStr.split(/\r\n|\n|\r/), cueBlocks = Object(_getCueBlocks__WEBPACK_IMPORTED_MODULE_1__.a)(lines), cues = [], i = 0; i < cueBlocks.length; i++) {
                var cueObject = Object(_parseCue__WEBPACK_IMPORTED_MODULE_2__.a)(cueBlocks[i], timeOffset);
                if (cueObject) {
                    var nativeCue = toNativeCue(cueObject);
                    nativeCue && cues.push(nativeCue);
                }
            }
            return cues;
        }
        /**
 * @param {Object} cue Object
 * @returns {TextTrackCue|VTTCue|null}
 */        function toNativeCue(cueObj) {
            var start = cueObj.start, end = cueObj.end, text = cueObj.payload.join("\n");
            return Object(_compat_index__WEBPACK_IMPORTED_MODULE_0__.i)(start, end, text);
        }
        /***/    }, 
    /* 117 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return switchMap;
        });
        /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2), _OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(23), _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(24), _map__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(54), _observable_from__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(44);
        /* harmony import */        
        /** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult,_map,_observable_from PURE_IMPORTS_END */
        function switchMap(project, resultSelector) {
            return "function" == typeof resultSelector ? function(source) {
                return source.pipe(switchMap(function(a, i) {
                    return Object(_observable_from__WEBPACK_IMPORTED_MODULE_4__.a)(project(a, i)).pipe(Object(_map__WEBPACK_IMPORTED_MODULE_3__.a)(function(b, ii) {
                        return resultSelector(a, b, i, ii);
                    }));
                }));
            } : function(source) {
                return source.lift(new SwitchMapOperator(project));
            };
        }
        var SwitchMapOperator = /* */ function() {
            function SwitchMapOperator(project) {
                this.project = project;
            }
            return SwitchMapOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new SwitchMapSubscriber(subscriber, this.project));
            }, SwitchMapOperator;
        }(), SwitchMapSubscriber = /* */ function(_super) {
            function SwitchMapSubscriber(destination, project) {
                var _this = _super.call(this, destination) || this;
                return _this.project = project, _this.index = 0, _this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(SwitchMapSubscriber, _super), SwitchMapSubscriber.prototype._next = function(value) {
                var result, index = this.index++;
                try {
                    result = this.project(value, index);
                } catch (error) {
                    return void this.destination.error(error);
                }
                this._innerSub(result, value, index);
            }, SwitchMapSubscriber.prototype._innerSub = function(result, value, index) {
                var innerSubscription = this.innerSubscription;
                innerSubscription && innerSubscription.unsubscribe(), this.add(this.innerSubscription = Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__.a)(this, result, value, index));
            }, SwitchMapSubscriber.prototype._complete = function() {
                var innerSubscription = this.innerSubscription;
                innerSubscription && !innerSubscription.closed || _super.prototype._complete.call(this);
            }, SwitchMapSubscriber.prototype._unsubscribe = function() {
                this.innerSubscription = null;
            }, SwitchMapSubscriber.prototype.notifyComplete = function(innerSub) {
                this.remove(innerSub), this.innerSubscription = null, this.isStopped && _super.prototype._complete.call(this);
            }, SwitchMapSubscriber.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
                this.destination.next(innerValue);
            }, SwitchMapSubscriber;
        }(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__.a);
    }, 
    /* 118 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        /* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9), HTML_ENTITIES = /&#([0-9]+);/g, BR = /<br>/gi, STYLE = /<style[^>]*>([\s\S]*?)<\/style[^>]*>/i, PARAG = /\s*<p class=([^>]+)>(.*)/i, START = /<sync[^>]+?start="?([0-9]*)"?[^0-9]/i;
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        // __VERY__ simple SAMI parser, based on ugly-but-working REGEXP:
        //   - the text, start and end times are correctly parsed.
        //   - only text for the given language is parsed.
        //   - only the CSS style associated to the P element is set.
        //   - we should be safe for any XSS.
        // The language indicated to the parser should be present in the CSS and the
        // corresponding Class should be on the P elements. If we fail to find the
        // language in a "lang" property of a CSS class, the parser will throw.
        /**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */        
        /**
 * Returns classnames for every languages.
 * @param {string} str
 * @returns {Object}
 */
        function getClassNameByLang(str) {
            for (var ruleRe = /\.(\S+)\s*{([^}]*)}/gi, langs = {}, m = void 0; m = ruleRe.exec(str); ) {
                var name = m[1], lang = getCSSProperty(m[2], "lang");
                null != name && null != lang && (langs[lang] = name);
            }
            return langs;
        }
        /**
 * Returns the rules defined for the P element.
 * Empty string if not found.
 * @param {string} str - The entire styling part.
 * @returns {string}
 */        function getPCSSRules(str) {
            var rule = /p\s*{([^}]*)}/gi.exec(str);
            return rule ? rule[1] : "";
        }
        /**
 * @param {string} str - entire CSS rule
 * @param {string} name - name of the property
 * @returns {string|null} - value of the property. Null if not found.
 */        function getCSSProperty(str, name) {
            var matches = str.match(new RegExp("\\s*" + name + ":\\s*(\\S+);", "i"));
            return matches ? matches[1] : null;
        }
        /**
 * @param {string} text
 * @returns {string}
 */        function decodeEntities(text) {
            return text.replace(HTML_ENTITIES, function(_, $1) {
                return String.fromCharCode($1);
            });
        }
        /**
 * Because sami is not really html... we have to use
 * some kind of regular expressions to parse it...
 * the cthulhu way :)
 * The specification being quite clunky, this parser
 * may not work for every sami input.
 *
 * @param {string} smi
 * @param {Number} timeOffset
 * @param {string} lang
 */        
        /* harmony default export */ __webpack_exports__.default = function parseSami(smi, timeOffset, lang) {
            var syncOpen = /<sync[ >]/gi, syncClose = /<sync[ >]|<\/body>/gi, subs = [], styleMatches = smi.match(STYLE), css = styleMatches ? styleMatches[1] : "", up = void 0, to = void 0;
            // XXX TODO FIXME Is that wanted?
            // previously written as let to = SyncClose.exec(smi); but never used
            syncClose.exec(smi);
            var langs = getClassNameByLang(css), pCSS = getPCSSRules(css), klass = lang && langs[lang];
            for (Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__.b)(!!klass, "sami: could not find lang " + lang + " in CSS"); up = syncOpen.exec(smi), 
            to = syncClose.exec(smi), up || to; ) {
                if (!up || !to || up.index >= to.index) throw new Error("parse error");
                var str = smi.slice(up.index, to.index), tim = str.match(START);
                if (!tim) throw new Error("parse error (sync time attribute)");
                var start = +tim[1];
                if (isNaN(start)) throw new Error("parse error (sync time attribute NaN)");
                appendToSubs(str.split("\n"), start / 1e3);
            }
            return subs;
            function appendToSubs(lines, start) {
                for (var i = lines.length; --i >= 0; ) {
                    var paragraphInfos = lines[i].match(PARAG);
                    if (paragraphInfos) {
                        var className = paragraphInfos[1], txt = paragraphInfos[2];
                        if (klass === className) if ("&nbsp;" === txt) subs[subs.length - 1].end = start; else {
                            var wrapperEl = document.createElement("DIV");
                            wrapperEl.className = "rxp-texttrack-region";
                            var divEl = document.createElement("DIV");
                            divEl.className = "rxp-texttrack-div", divEl.style.position = "absolute", divEl.style.bottom = "0", 
                            divEl.style.width = "100%", divEl.style.color = "#fff", divEl.style.textShadow = "-1px -1px 0 #000,1px -1px 0 #000,-1px 1px 0 #000,1px 1px 0 #000";
                            var pEl = document.createElement("div");
                            pEl.className = "rxp-texttrack-p", pCSS && (pEl.style.cssText = pCSS);
                            for (var textEls = txt.split(BR), j = 0; j < textEls.length; j++) {
                                j && pEl.appendChild(document.createElement("BR"));
                                var spanEl = document.createElement("SPAN");
                                spanEl.className = "rxp-texttrack-span", spanEl.textContent = decodeEntities(textEls[j]), 
                                pEl.appendChild(spanEl);
                            }
                            divEl.appendChild(pEl), wrapperEl.appendChild(divEl), subs.push({
                                element: wrapperEl,
                                start: start + timeOffset,
                                end: -1
                            });
                        }
                    }
                }
            }
        };
    }, 
    /* 119 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() {
            return parseSRTStringToHTML;
        });
        /* harmony import */ var _getCueBlocks__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(97), _parseCue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96);
        /* harmony import */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */
        // Parse SRT subtitles into HTML.
        // Done for fun. Understand <b>, <i>, <u> and <font color="#ff0000" /> type
        // of tags.
        /**
 * @param {string} srtStr
 * @param {Number} timeOffset
 * @returns {Array.<Object>}
 */
        function parseSRTStringToHTML(srtStr, timeOffset) {
            for (
            // Even if srt only authorize CRLF, we will also take LF or CR as line
            // terminators for resilience
            var lines = srtStr.split(/\r\n|\n|\r/), cueBlocks = Object(_getCueBlocks__WEBPACK_IMPORTED_MODULE_0__.a)(lines), cues = [], i = 0; i < cueBlocks.length; i++) {
                var cueObject = Object(_parseCue__WEBPACK_IMPORTED_MODULE_1__.a)(cueBlocks[i], timeOffset);
                if (null != cueObject) {
                    var htmlCue = toHTML(cueObject);
                    null != htmlCue && cues.push(htmlCue);
                }
            }
            return cues;
        }
        /**
 * @param {Array.<string>} cueLines
 * @param {Number} timeOffset
 * @returns {Object|null}
 */        function toHTML(cueObj) {
            var start = cueObj.start, end = cueObj.end, payload = cueObj.payload, pEl = document.createElement("div");
            pEl.className = "rxp-texttrack-p", pEl.style.fontSize = "28px", pEl.style.position = "absolute", 
            pEl.style.bottom = "5%", pEl.style.width = "100%", pEl.style.textAlign = "center", 
            pEl.style.color = "#fff", pEl.style.textShadow = "-1px -1px 2px #000,1px -1px 2px #000,-1px 1px 2px #000,1px 1px 2px #000";
            for (var i = 0; i < payload.length; i++) {
                i && pEl.appendChild(document.createElement("br"));
                var span = generateSpansFromSRTText(payload[i]);
                pEl.appendChild(span);
            }
            return {
                start: start,
                end: end,
                element: pEl
            };
        }
        /**
 * Take a single srt line and convert it into a span with the right style while
 * avoiding XSS.
 * What we do is set a whitelist of authorized tags, and recreate the
 * corresponding tag from scratch.
 * Supported tags:
 *   - <b>: make content bold
 *   - <i>: make content italic
 *   - <u>: draw underline on content
 *   - <font color="x">: add color x to the content
 * @param {string} text
 * @returns {HTMLElement}
 */        function generateSpansFromSRTText(text) {
            var secureDiv = document.createElement("div");
            secureDiv.innerHTML = text;
            return function _loop(node) {
                var childNodes = node.childNodes, span = document.createElement("span");
                span.className = "rxp-texttrack-span";
                for (var i = 0; i < childNodes.length; i++) {
                    var currentNode = childNodes[i];
                    if ("#text" === currentNode.nodeName) {
                        for (var linifiedText = currentNode.wholeText.split("\n"), line = 0; line < linifiedText.length; line++) if (line && span.appendChild(document.createElement("br")), 
                        linifiedText[line].length > 0) {
                            var textNode = document.createTextNode(linifiedText[line]);
                            span.appendChild(textNode);
                        }
                    } else if ("B" === currentNode.nodeName) {
                        var spanChild = _loop(currentNode);
                        spanChild.style.fontWeight = "bold", span.appendChild(spanChild);
                    } else if ("I" === currentNode.nodeName) {
                        var _spanChild = _loop(currentNode);
                        _spanChild.style.fontStyle = "italic", span.appendChild(_spanChild);
                    } else if ("U" === currentNode.nodeName) {
                        var _spanChild2 = _loop(currentNode);
                        _spanChild2.style.textDecoration = "underline", span.appendChild(_spanChild2);
                    } else if ("FONT" === currentNode.nodeName && null != currentNode.color) {
                        // TODO loop through attributes to find color?
                        var _spanChild3 = _loop(currentNode);
                        _spanChild3.style.color = currentNode.color, span.appendChild(_spanChild3);
                    } else {
                        var _spanChild4 = _loop(currentNode);
                        span.appendChild(_spanChild4);
                    }
                }
                return span;
            }(secureDiv);
        }
        /***/    }, 
    /* 120 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() {
            return StreamDirectFile;
        });
        /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(36), rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(134), rxjs_operators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(54), rxjs_operators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(136), rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(145), _compat__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(12), _log__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(0), _create_eme_manager__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(87), _media_error_handler__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(88), _speed_manager__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(95), _stalling_manager__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(89), _stream_events__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(19), _video_events__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(86);
        /* harmony import */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */
        /**
 * @param {HTMLMediaElement} mediaElement
 * @returns {number}
 */
        function getDirectFileInitialTime(mediaElement, startAt) {
            if (!startAt) return 0;
            if (null != startAt.position) return startAt.position;
            if (null != startAt.wallClockTime) return startAt.wallClockTime;
            if (null != startAt.fromFirstPosition) return startAt.fromFirstPosition;
            var duration = mediaElement.duration;
            if (!duration || !isFinite(duration)) return _log__WEBPACK_IMPORTED_MODULE_6__.a.warn("startAt.fromLastPosition set but no known duration, beginning at 0."), 
            0;
            if (startAt.fromLastPosition) return Math.max(0, duration + startAt.fromLastPosition);
            if (null != startAt.percentage) {
                var percentage = startAt.percentage;
                return percentage >= 100 ? duration : percentage <= 0 ? 0 : duration * (+percentage / 100);
            }
            return 0;
        }
        /**
 * Initialize stream playback by merging all Observables that are required to
 * make the system cooperate.
 * @param {MediaSource} mediaSource
 * @returns {Observable}
 */        function StreamDirectFile(_ref) {
            var autoPlay = _ref.autoPlay, clock$ = _ref.clock$, keySystems = _ref.keySystems, mediaElement = _ref.mediaElement, speed$ = _ref.speed$, startAt = _ref.startAt, url = _ref.url, warning$ = new rxjs__WEBPACK_IMPORTED_MODULE_0__.a(), warningEvents$ = warning$.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.a)(_stream_events__WEBPACK_IMPORTED_MODULE_11__.a.warning));
            /**
     * Observable through which all warning events will be sent.
     * @type {Subject}
     */            Object(_compat__WEBPACK_IMPORTED_MODULE_5__.c)(mediaElement), _log__WEBPACK_IMPORTED_MODULE_6__.a.debug("calculating initial time");
            var initialTime = function initialTime() {
                return getDirectFileInitialTime(mediaElement, startAt);
            };
            _log__WEBPACK_IMPORTED_MODULE_6__.a.debug("initial time calculated:", initialTime);
            var _handleInitialVideoEv = Object(_video_events__WEBPACK_IMPORTED_MODULE_12__.a)(mediaElement, initialTime, autoPlay), initialSeek$ = _handleInitialVideoEv.initialSeek$, loadAndPlay$ = _handleInitialVideoEv.loadAndPlay$, emeManager$ = Object(_create_eme_manager__WEBPACK_IMPORTED_MODULE_7__.a)(mediaElement, keySystems, warning$), mediaErrorHandler$ = Object(_media_error_handler__WEBPACK_IMPORTED_MODULE_8__.a)(mediaElement), speedManager$ = Object(_speed_manager__WEBPACK_IMPORTED_MODULE_9__.a)(mediaElement, speed$, clock$, {
                pauseWhenStalled: !0
            }).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.a)(_stream_events__WEBPACK_IMPORTED_MODULE_11__.a.speedChanged)), stallingManager$ = Object(_stalling_manager__WEBPACK_IMPORTED_MODULE_10__.a)(mediaElement, clock$).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.a)(_stream_events__WEBPACK_IMPORTED_MODULE_11__.a.stalled)), loadedEvent$ = loadAndPlay$.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.a)(_stream_events__WEBPACK_IMPORTED_MODULE_11__.a.loaded())), linkURL$ = Object(_compat__WEBPACK_IMPORTED_MODULE_5__.k)(mediaElement, url).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.a)()), mutedInitialSeek$ = initialSeek$.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.a)()), directFile$ = Object(rxjs__WEBPACK_IMPORTED_MODULE_1__.a)(loadedEvent$, mutedInitialSeek$, emeManager$, // TODO RxJS do something weird here
            mediaErrorHandler$, // TODO RxJS do something weird here
            speedManager$, stallingManager$, linkURL$);
            /**
     * Create EME Manager, an observable which will manage every EME-related
     * issue.
     * @type {Observable}
     */            return Object(rxjs__WEBPACK_IMPORTED_MODULE_1__.a)(directFile$, warningEvents$);
        }
        /***/    }, 
    /* 121 */
    /***/ function(module, exports) {
        function shim(obj) {
            var keys = [];
            for (var key in obj) keys.push(key);
            return keys;
        }
        /***/        (module.exports = "function" == typeof Object.keys ? Object.keys : shim).shim = shim;
    }, 
    /* 122 */
    /***/ function(module, exports) {
        var supportsArgumentsClass = "[object Arguments]" == function() {
            return Object.prototype.toString.call(arguments);
        }();
        function supported(object) {
            return "[object Arguments]" == Object.prototype.toString.call(object);
        }
        function unsupported(object) {
            return object && "object" == typeof object && "number" == typeof object.length && Object.prototype.hasOwnProperty.call(object, "callee") && !Object.prototype.propertyIsEnumerable.call(object, "callee") || !1;
        }
        (exports = module.exports = supportsArgumentsClass ? supported : unsupported).supported = supported, 
        exports.unsupported = unsupported;
    }, 
    /* 123 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        // EXTERNAL MODULE: ./node_modules/deep-equal/index.js
        var deep_equal = __webpack_require__(110), deep_equal_default = /* */ __webpack_require__.n(deep_equal), Subject = __webpack_require__(36), ReplaySubject = __webpack_require__(126), tslib_es6 = __webpack_require__(2), ObjectUnsubscribedError = __webpack_require__(46), BehaviorSubject_BehaviorSubject = /* */ function(_super) {
            function BehaviorSubject(_value) {
                var _this = _super.call(this) || this;
                return _this._value = _value, _this;
            }
            return tslib_es6.a(BehaviorSubject, _super), Object.defineProperty(BehaviorSubject.prototype, "value", {
                get: function() {
                    return this.getValue();
                },
                enumerable: !0,
                configurable: !0
            }), BehaviorSubject.prototype._subscribe = function(subscriber) {
                var subscription = _super.prototype._subscribe.call(this, subscriber);
                return subscription && !subscription.closed && subscriber.next(this._value), subscription;
            }, BehaviorSubject.prototype.getValue = function() {
                if (this.hasError) throw this.thrownError;
                if (this.closed) throw new ObjectUnsubscribedError.a();
                return this._value;
            }, BehaviorSubject.prototype.next = function(value) {
                _super.prototype.next.call(this, this._value = value);
            }, BehaviorSubject;
        }(Subject.a), merge = __webpack_require__(134), empty = __webpack_require__(26), concat = __webpack_require__(107), combineLatest = __webpack_require__(146), takeUntil = __webpack_require__(141), map = __webpack_require__(54), distinctUntilChanged = __webpack_require__(140), take = __webpack_require__(142), multicast = __webpack_require__(94);
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/publish.js
        /** PURE_IMPORTS_START _Subject,_multicast PURE_IMPORTS_END */
        function publish(selector) {
            return selector ? Object(multicast.a)(function() {
                return new Subject.a();
            }, selector) : Object(multicast.a)(new Subject.a());
        }
        //# sourceMappingURL=publish.js.map
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/filter.js
                var filter = __webpack_require__(137), share = __webpack_require__(150), mapTo = __webpack_require__(136), startWith = __webpack_require__(138), OuterSubscriber = __webpack_require__(23), subscribeToResult = __webpack_require__(24);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/share.js
                // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/skipUntil.js
        /** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
        function skipUntil(notifier) {
            return function(source) {
                return source.lift(new SkipUntilOperator(notifier));
            };
        }
        var SkipUntilOperator = /* */ function() {
            function SkipUntilOperator(notifier) {
                this.notifier = notifier;
            }
            return SkipUntilOperator.prototype.call = function(destination, source) {
                return source.subscribe(new skipUntil_SkipUntilSubscriber(destination, this.notifier));
            }, SkipUntilOperator;
        }(), skipUntil_SkipUntilSubscriber = /* */ function(_super) {
            function SkipUntilSubscriber(destination, notifier) {
                var _this = _super.call(this, destination) || this;
                return _this.hasValue = !1, _this.add(_this.innerSubscription = Object(subscribeToResult.a)(_this, notifier)), 
                _this;
            }
            return tslib_es6.a(SkipUntilSubscriber, _super), SkipUntilSubscriber.prototype._next = function(value) {
                this.hasValue && _super.prototype._next.call(this, value);
            }, SkipUntilSubscriber.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
                this.hasValue = !0, this.innerSubscription && this.innerSubscription.unsubscribe();
            }, SkipUntilSubscriber.prototype.notifyComplete = function() {}, SkipUntilSubscriber;
        }(OuterSubscriber.a), catchError = __webpack_require__(143), config = __webpack_require__(3), log = __webpack_require__(0), eventemitter = __webpack_require__(41), noop = __webpack_require__(29), utils_ranges = __webpack_require__(21), fullscreen = __webpack_require__(56), events = __webpack_require__(8), constants = __webpack_require__(17), features = __webpack_require__(7);
        // CONCATENATED MODULE: ./src/manifest/timings.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        function toWallClockTime(position, manifest) {
            return new Date(1e3 * (position + (manifest.availabilityStartTime || 0)));
        }
        /**
 * TODO This function should have more of a seekTo kind of name
 * ``fromWallClockTime`` should probably just do:
 * ```js
 * (timeInSeconds, manifest) => {
 *   return timeInSeconds - manifest.availabilityStartTime;
 * };
 * ```
 * It should be the exact opposite of ``toWallClockTime``
 */        function fromWallClockTime(timeInMs, manifest) {
            return normalizeWallClockTime(timeInMs, manifest) / 1e3 - (manifest.availabilityStartTime || 0);
        }
        /**
 * TODO This function should have more of a seekTo kind of name
 */        function normalizeWallClockTime(_time, manifest) {
            if (!manifest.isLive) return +_time;
            var spd = manifest.suggestedPresentationDelay || 0, plg = manifest.presentationLiveGap || 0, tsbd = manifest.timeShiftBufferDepth || 0, timeInMs = "number" == typeof _time ? _time : +_time, now = Date.now(), max = now - 1e3 * (plg + spd), min = now - 1e3 * tsbd;
            return Math.max(Math.min(timeInMs, max), min);
        }
        function getMinimumBufferPosition(manifest) {
            return getBufferLimits(manifest)[0];
        }
        /**
 * Get maximum position to which we should be able to construct a buffer.
 * @param {Manifest} manifest
 * @returns {Number}
 */        function getMaximumBufferPosition(manifest) {
            if (!manifest.isLive) return manifest.getDuration();
            var ast = manifest.availabilityStartTime || 0, plg = manifest.presentationLiveGap || 0;
            return Date.now() / 1e3 - ast - plg;
        }
        function getBufferLimits(manifest) {
            if (!manifest.isLive) return [ manifest.minimumTime || 0, manifest.getDuration() ];
            var ast = manifest.availabilityStartTime || 0, plg = manifest.presentationLiveGap || 0, tsbd = manifest.timeShiftBufferDepth || 0, max = Date.now() / 1e3 - ast - plg;
            return [ Math.min(max, Math.max(null != manifest.minimumTime ? manifest.minimumTime : 0, max - tsbd + 5)), max ];
        }
        // EXTERNAL MODULE: ./src/core/eme/index.ts + 23 modules
                var eme = __webpack_require__(66), of = __webpack_require__(75), mergeMap = __webpack_require__(57), ignoreElements = __webpack_require__(145), Subscriber = __webpack_require__(10), Subscription = __webpack_require__(16);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/of.js
                // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/finalize.js
        /** PURE_IMPORTS_START tslib,_Subscriber,_Subscription PURE_IMPORTS_END */
        function finalize(callback) {
            return function(source) {
                return source.lift(new FinallyOperator(callback));
            };
        }
        var FinallyOperator = /* */ function() {
            function FinallyOperator(callback) {
                this.callback = callback;
            }
            return FinallyOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new finalize_FinallySubscriber(subscriber, this.callback));
            }, FinallyOperator;
        }(), finalize_FinallySubscriber = /* */ function(_super) {
            function FinallySubscriber(destination, callback) {
                var _this = _super.call(this, destination) || this;
                return _this.add(new Subscription.a(callback)), _this;
            }
            return tslib_es6.a(FinallySubscriber, _super), FinallySubscriber;
        }(Subscriber.a), tap = __webpack_require__(148), castToObservable = __webpack_require__(15);
        // CONCATENATED MODULE: ./src/utils/rx-throttle.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Throttle an asynchronous function (returning an Observable or Promise) to
 * drop calls done before a previous one has finished or failed.
 *
 * @example
 * ```js
 * const fn = (time) => Observable.timer(time);
 * const throttled = throttle(fn);
 *
 * const Obs1 = throttled(2000); // -> call fn(2000) and returns its Observable
 * const Obs2 = throttled(1000); // -> won't do anything, Obs2 is an empty
 *                               //    observable (it directly completes)
 * setTimeout(() => {
 *   const Obs3 = throttled(1000); // -> will call fn(1000)
 * }, 2001);
 * ```
 *
 * @param {Function} func
 * @returns {Function} - Function taking in argument the arguments you want
 * to give your function, and returning an Observable.
 *
 * TODO Add typings from castToObservable?
 */
        function throttle(func) {
            var isPending = !1;
            return function() {
                return isPending ? empty.a : (isPending = !0, Object(castToObservable.a)(func.apply(void 0, arguments)).pipe(Object(tap.a)(noop.a, function() {
                    return isPending = !1;
                }, function() {
                    return isPending = !1;
                })));
            };
        }
        // CONCATENATED MODULE: ./src/utils/weak_map_memory.ts
                function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Memoize Function results linked to an object, through a WeakMap.
 *
 * @example
 * ```js
 * // Initialize the WeakMapMemory with its logic:
 * const memory = new WeakMapMemory(arg => {
 *   console.log("side-effect");
 *   return [arg.a, arg.b];
 * });
 *
 * const obj = { a: 1, b: 2 };
 *
 * // first time obj is given: call the function, save the result and return it:
 * const arr1 = memory.get(obj);
 * // >  "side-effect"
 * // <- [1, 2]
 *
 * // nth time obj is given, returns the saved result without calling the
 * // function:
 * const arr2 = memory.get(obj);
 * // <- [1, 2]
 *
 * // both of these use the same object, so the result is also the exact same
 * // one
 * console.log(arr1 === arr2); // => true
 *
 * // /!\ with a new object however:
 * const obj2 = { a: 1, b: 2 };
 *
 * const arr3 = memory.get(obj2);
 * // >  "side-effect"
 * // <- [1, 2]
 *
 * console.log(arr1 === arr3); // => false
 * ```
 * @class WeakMapMemory
 */        var weak_map_memory = function() {
            function WeakMapMemory(fn) {
                _classCallCheck(this, WeakMapMemory), this._weakMap = new WeakMap(), this._fn = fn;
            }
            return WeakMapMemory.prototype.get = function get(obj) {
                var fromMemory = this._weakMap.get(obj);
                if (fromMemory) return fromMemory;
                var newElement = this._fn(obj);
                return this._weakMap.set(obj, newElement), newElement;
            }, WeakMapMemory.prototype.destroy = function destroy(obj) {
                this._weakMap.delete(obj);
            }, WeakMapMemory;
        }(), MediaError = __webpack_require__(27), object_assign = __webpack_require__(11), object_assign_default = /* */ __webpack_require__.n(object_assign), switchMap = __webpack_require__(117), shareReplay = __webpack_require__(149);
        /* harmony default export */        
        // CONCATENATED MODULE: ./src/core/abr/ewma.ts
        function ewma_classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Tweaked implementation of an exponential weighted Moving Average.
 * Heavily "inspired" from the shaka-player one (Ewma).
 * @class EWMA
 */        var ewma = function() {
            /**
   * @param {number} halfLife
   */
            function EWMA(halfLife) {
                ewma_classCallCheck(this, EWMA), 
                // (half-life = log(1/2) / log(Decay Factor)
                this._alpha = Math.exp(Math.log(.5) / halfLife), this._lastEstimate = 0, this._totalWeight = 0;
            }
            /**
   * @param {number} weight
   * @param {number} value
   */            return EWMA.prototype.addSample = function addSample(weight, value) {
                var adjAlpha = Math.pow(this._alpha, weight), newEstimate = value * (1 - adjAlpha) + adjAlpha * this._lastEstimate;
                isNaN(newEstimate) || (this._lastEstimate = newEstimate, this._totalWeight += weight);
            }, 
            /**
   * @returns {number} value
   */
            EWMA.prototype.getEstimate = function getEstimate() {
                var zeroFactor = 1 - Math.pow(this._alpha, this._totalWeight);
                return this._lastEstimate / zeroFactor;
            }, EWMA;
        }();
        /* harmony default export */        
        // CONCATENATED MODULE: ./src/core/abr/bandwidth_estimator.ts
        function bandwidth_estimator_classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        var ABR_MINIMUM_TOTAL_BYTES = config.a.ABR_MINIMUM_TOTAL_BYTES, ABR_MINIMUM_CHUNK_SIZE = config.a.ABR_MINIMUM_CHUNK_SIZE, ABR_FAST_EMA = config.a.ABR_FAST_EMA, ABR_SLOW_EMA = config.a.ABR_SLOW_EMA, bandwidth_estimator = function() {
            function BandwidthEstimator() {
                bandwidth_estimator_classCallCheck(this, BandwidthEstimator), 
                /**
     * A fast-moving average.
     * @private
     */
                this._fast = new ewma(ABR_FAST_EMA), 
                /**
     * A slow-moving average.
     * @private
     */
                this._slow = new ewma(ABR_SLOW_EMA), 
                /**
     * Number of bytes sampled.
     * @private
     */
                this._bytesSampled = 0;
            }
            /**
   * Takes a bandwidth sample.
   * @param {number} durationMs - The amount of time, in milliseconds, for a
   *   particular request.
   * @param {number} numBytes - The total number of bytes transferred in that
   *   request.
   */            return BandwidthEstimator.prototype.addSample = function addSample(durationInMs, numberOfBytes) {
                if (!(numberOfBytes < ABR_MINIMUM_CHUNK_SIZE)) {
                    var bandwidth = 8e3 * numberOfBytes / durationInMs, weight = durationInMs / 1e3;
                    this._bytesSampled += numberOfBytes, this._fast.addSample(weight, bandwidth), this._slow.addSample(weight, bandwidth);
                }
            }, 
            /**
   * Get estimate of the bandwidth, in bits per seconds.
   * @returns {Number|undefined}
   */
            BandwidthEstimator.prototype.getEstimate = function getEstimate() {
                if (!(this._bytesSampled < ABR_MINIMUM_TOTAL_BYTES)) 
                // Take the minimum of these two estimates.  This should have the effect of
                // adapting down quickly, but up more slowly.
                return Math.min(this._fast.getEstimate(), this._slow.getEstimate());
            }, 
            /**
   * Reset the bandwidth estimation.
   */
            BandwidthEstimator.prototype.reset = function reset() {
                this._fast = new ewma(ABR_FAST_EMA), this._slow = new ewma(ABR_SLOW_EMA), this._bytesSampled = 0;
            }, BandwidthEstimator;
        }(), array_find_index = __webpack_require__(93), array_find_index_default = /* */ __webpack_require__.n(array_find_index);
        /**
 * Calculate a mean bandwidth based on the bytes downloaded and the amount
 * of time needed to do so.
 *
 * Heavily "inspired" from the Shaka-Player's "ewma bandwidth estimator".
 * @class BandwidthEstimator
 */        
        // CONCATENATED MODULE: ./src/core/abr/filterByBitrate.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Get only representations lower than a given bitrate.
 * @param {Array.<Object>} representations - The representations array
 * @param {Number} bitrate
 * @returns {Array.<Object>}
 */
        function filterByBitrate(representations, bitrate) {
            var firstSuperiorBitrate = array_find_index_default()(representations, function(r) {
                return r.bitrate > bitrate;
            });
            return -1 === firstSuperiorBitrate ? representations : representations.slice(0, firstSuperiorBitrate);
        }
        // EXTERNAL MODULE: ./node_modules/array-find/find.js
                var array_find_find = __webpack_require__(13), find_default = /* */ __webpack_require__.n(array_find_find);
        // CONCATENATED MODULE: ./src/core/abr/filterByWidth.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Filter representations based on their width:
 *   - the highest width considered will be the one linked to the first
 *     representation which has a superior width to the one given.
 * @param {Array.<Object>} representations - The representations array
 * @param {Number} width
 * @returns {Array.<Object>}
 */
        function filterByWidth(representations, width) {
            var sortedRepsByWidth = representations.slice().sort(function(a, b) {
                return (a.width || 0) - (b.width || 0);
            }), repWithMaxWidth = find_default()(sortedRepsByWidth, function(r) {
                return (r.width || 0) >= width;
            });
            if (repWithMaxWidth) {
                var maxWidth = repWithMaxWidth.width || 0;
                return representations.filter(function(r) {
                    return (r.width || 0) <= maxWidth;
                });
            }
            return representations;
        }
        // CONCATENATED MODULE: ./src/core/abr/fromBitrateCeil.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {Array.<Representation>} representations - The representations array
 * @param {Number} bitrate
 * @returns {Representation}
 */        function fromBitrateCeil(representations, bitrate) {
            var tooHighIndex = array_find_index_default()(representations, function(representation) {
                return representation.bitrate > bitrate;
            });
            return -1 === tooHighIndex ? representations[representations.length - 1] : representations[tooHighIndex - 1];
        }
        // CONCATENATED MODULE: ./src/core/abr/representation_chooser.ts
                function representation_chooser_classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        var ABR_REGULAR_FACTOR = config.a.ABR_REGULAR_FACTOR, ABR_STARVATION_FACTOR = config.a.ABR_STARVATION_FACTOR, ABR_STARVATION_GAP = config.a.ABR_STARVATION_GAP, OUT_OF_STARVATION_GAP = config.a.OUT_OF_STARVATION_GAP;
        /**
 * Returns an observable emitting only the representation concerned by the
 * bitrate ceil given.
 * @param {Array.<Representation>} representations
 * @param {number} bitrate
 * @returns {Observable}
 */        function setManualRepresentation(representations, bitrate) {
            var chosenRepresentation = fromBitrateCeil(representations, bitrate) || representations[0];
            return Object(of.a)({
                bitrate: void 0,
                representation: chosenRepresentation
            });
        }
        /**
 * Get the pending request starting with the asked segment position.
 * @param {Object} requests
 * @param {number} position
 * @returns {IRequestInfo|undefined}
 */        function getConcernedRequest(requests, position) {
            for (var currentRequestIds = Object.keys(requests), len = currentRequestIds.length, i = 0; i < len; i++) {
                var request = requests[currentRequestIds[i]];
                // We check that this chunk has a high probability of being the one we want
                                if (null != request && Math.abs(request.time - position) < .3 * request.duration) return request;
            }
        }
        /**
 * Estimate the __VERY__ recent bandwidth based on a single unfinished request.
 * Useful when the current bandwidth seemed to have fallen quickly.
 *
 * @param {Object} request
 * @returns {number|undefined}
 */        function estimateRequestBandwidth(request) {
            if (!(request.progress.length < 2)) {
                for (
                // try to infer quickly the current bitrate based on the
                // progress events
                var ewma1 = new ewma(2), progress = request.progress, i = 1; i < progress.length; i++) {
                    var bytesDownloaded = progress[i].size - progress[i - 1].size, timeElapsed = progress[i].timestamp - progress[i - 1].timestamp, reqBitrate = 8 * bytesDownloaded / (timeElapsed / 1e3);
                    ewma1.addSample(timeElapsed / 1e3, reqBitrate);
                }
                return ewma1.getEstimate();
            }
        }
        /**
 * Filter representations given through filters options.
 * @param {Array.<Representation>} representations
 * @param {Object} filters - Filter Object.
 * _Can_ contain each of the following properties:
 *   - bitrate {Number} - max bitrate authorized (included).
 *   - width {Number} - max width authorized (included).
 * @returns {Array.<Representation>}
 */        function getFilteredRepresentations(representations, filters) {
            var _representations = representations;
            return null != filters.bitrate && (_representations = filterByBitrate(_representations, filters.bitrate)), 
            null != filters.width && (_representations = filterByWidth(_representations, filters.width)), 
            _representations;
        }
        /**
 * Estimate remaining time for a pending request from a progress event.
 * TODO Add time since last progress event?
 * @param {Object} lastProgressEvent
 * @param {number} bandwidthEstimate
 * @returns {number}
 */        function estimateRemainingTime(lastProgressEvent, bandwidthEstimate) {
            var remainingData = 8 * (lastProgressEvent.totalSize - lastProgressEvent.size);
            return Math.max(remainingData / bandwidthEstimate, 0);
        }
        /**
 * Check if the request for the most needed segment is too slow.
 * If that's the case, re-calculate the bandwidth urgently based on
 * this single request.
 * @param {Object} requests - Current pending requests.
 * @param {Object} clock - Informations on the current playback.
 * @param {Number} lastEstimatedBitrate - Last bitrate estimation emitted.
 * @returns {Number|undefined}
 */        function estimateStarvationModeBitrate(requests, clock, lastEstimatedBitrate) {
            var concernedRequest = getConcernedRequest(requests, clock.position + clock.bufferGap);
            if (concernedRequest) {
                var currentBitrate = clock.bitrate, chunkDuration = concernedRequest.duration, now = Date.now(), requestElapsedTime = (now - concernedRequest.requestTimestamp) / 1e3, lastProgressEvent = concernedRequest.progress ? concernedRequest.progress[concernedRequest.progress.length - 1] : null, bandwidthEstimate = estimateRequestBandwidth(concernedRequest);
                if (null != lastProgressEvent && null != bandwidthEstimate) {
                    var remainingTime = 1.2 * estimateRemainingTime(lastProgressEvent, bandwidthEstimate);
                    // if this remaining time is reliable and is not enough to avoid buffering
                                        if ((now - lastProgressEvent.timestamp) / 1e3 <= remainingTime && remainingTime > clock.bufferGap / clock.speed) return bandwidthEstimate;
                }
                if (!(null == currentBitrate || requestElapsedTime <= (1.5 * chunkDuration + 1) / clock.speed)) {
                    // calculate a reduced bitrate from the current one
                    var reducedBitrate = .7 * currentBitrate;
                    return null == lastEstimatedBitrate || reducedBitrate < lastEstimatedBitrate ? reducedBitrate : void 0;
                }
            }
        }
        /**
 * Choose the right representation based on multiple parameters given, such as:
 *   - the current user's bandwidth
 *   - the max bitrate authorized
 *   - the size of the video element
 *   - etc.
 *
 * Those parameters can be set through different subjects and methods.
 * The subjects (undocumented here are):
 *
 *   - manualBitrate$ {Subject}: Set the bitrate manually, if no representation
 *     is found with the given bitrate. An immediately inferior one will be
 *     taken instead. If still, none are found, the representation with the
 *     minimum bitrate will be taken.
 *     Set it to a negative value to go into automatic bitrate mode.
 *
 *   - maxBitrate$ {Subject}: Set the maximum automatic bitrate. If the manual
 *     bitrate is not set / set to a negative value, this will be the maximum
 *     switch-able bitrate. If no representation is found inferior or equal to
 *     this bitrate, the representation with the minimum bitrate will be taken.
 *
 * @class RepresentationChooser
 */        var representation_chooser = function() {
            /**
     * @param {Object} options
     */
            function RepresentationChooser(options) {
                representation_chooser_classCallCheck(this, RepresentationChooser), this._dispose$ = new Subject.a(), 
                this.manualBitrate$ = new BehaviorSubject_BehaviorSubject(null != options.manualBitrate ? options.manualBitrate : -1), 
                this.maxAutoBitrate$ = new BehaviorSubject_BehaviorSubject(null != options.maxAutoBitrate ? options.maxAutoBitrate : Infinity), 
                this.estimator = new bandwidth_estimator(), this._currentRequests = {}, this._initialBitrate = options.initialBitrate || 0, 
                this._limitWidth$ = options.limitWidth$, this._throttle$ = options.throttle$;
            }
            /**
     * @param {Observable} clock$
     * @param {Array.<Object>} representations
     * @returns {Observable}
     */            return RepresentationChooser.prototype.get$ = function get$(clock$, representations) {
                var _this = this;
                if (representations.length < 2) return Object(of.a)({
                    bitrate: void 0,
                    representation: representations.length ? representations[0] : null
                }).pipe(Object(takeUntil.a)(this._dispose$));
                var manualBitrate$ = this.manualBitrate$, maxAutoBitrate$ = this.maxAutoBitrate$, _initialBitrate = this._initialBitrate, _deviceEventsArray = [];
                this._limitWidth$ && _deviceEventsArray.push(this._limitWidth$.pipe(Object(map.a)(function(width) {
                    return {
                        width: width
                    };
                }))), this._throttle$ && _deviceEventsArray.push(this._throttle$.pipe(Object(map.a)(function(bitrate) {
                    return {
                        bitrate: bitrate
                    };
                })))
                /**
         * Emit restrictions on the pools of available representations to choose
         * from.
         * @type {Observable}
         */;
                var deviceEvents$ = _deviceEventsArray.length ? combineLatest.a.apply(void 0, _deviceEventsArray).pipe(Object(map.a)(function(args) {
                    return object_assign_default.a.apply(void 0, [ {} ].concat(args));
                })) : Object(of.a)({}), lastEstimatedBitrate = void 0;
                /**
         * Store the last client's bitrate generated by our estimation algorithms.
         * @type {Number|undefined}
         */                return manualBitrate$.pipe(Object(switchMap.a)(function(manualBitrate) {
                    if (manualBitrate >= 0) 
                    // -- MANUAL mode --
                    return setManualRepresentation(representations, manualBitrate);
                    // -- AUTO mode --
                                        var inStarvationMode = !1;
 // == buffer gap too low == panic mode
                                        return Object(combineLatest.a)(clock$, maxAutoBitrate$, deviceEvents$).pipe(Object(map.a)(function(_ref) {
                        var clock = _ref[0], maxAutoBitrate = _ref[1], deviceEvents = _ref[2], nextBitrate = void 0, bandwidthEstimate = void 0, bufferGap = clock.bufferGap;
                        // If in starvation mode, check if a quick new estimate can be done
                        // from the last requests.
                        // If so, cancel previous estimations and replace it by the new one
                        if (
                        // check if should get in/out of starvation mode
                        !inStarvationMode && bufferGap <= ABR_STARVATION_GAP ? (log.a.info("ABR - enter starvation mode."), 
                        inStarvationMode = !0) : inStarvationMode && bufferGap >= OUT_OF_STARVATION_GAP && (log.a.info("ABR - exit starvation mode."), 
                        inStarvationMode = !1), inStarvationMode && null != (bandwidthEstimate = estimateStarvationModeBitrate(_this._currentRequests, clock, lastEstimatedBitrate))) {
                            log.a.info("ABR - starvation mode emergency estimate:", bandwidthEstimate), _this.resetEstimate();
                            var currentBitrate = clock.bitrate;
                            nextBitrate = null == currentBitrate ? Math.min(bandwidthEstimate, maxAutoBitrate) : Math.min(bandwidthEstimate, maxAutoBitrate, currentBitrate);
                        }
                        // if nextBitrate is not yet defined, do the normal estimation
                                                if (null == nextBitrate) {
                            var nextEstimate = void 0;
                            nextEstimate = null != (bandwidthEstimate = _this.estimator.getEstimate()) ? inStarvationMode ? bandwidthEstimate * ABR_STARVATION_FACTOR : bandwidthEstimate * ABR_REGULAR_FACTOR : null != lastEstimatedBitrate ? inStarvationMode ? lastEstimatedBitrate * ABR_STARVATION_FACTOR : lastEstimatedBitrate * ABR_REGULAR_FACTOR : _initialBitrate, 
                            nextBitrate = Math.min(nextEstimate, maxAutoBitrate);
                        }
                        return clock.speed > 1 && (nextBitrate /= clock.speed), {
                            bitrate: bandwidthEstimate,
                            representation: fromBitrateCeil(getFilteredRepresentations(representations, deviceEvents), nextBitrate) || representations[0]
                        };
                    }), Object(tap.a)(function(_ref2) {
                        var bitrate = _ref2.bitrate;
                        null != bitrate && (log.a.debug("ABR - calculated bitrate:", bitrate), lastEstimatedBitrate = bitrate);
                    }), Object(shareReplay.a)());
                }));
            }, 
            /**
     * Add a bandwidth estimate by giving:
     *   - the duration of the request, in s
     *   - the size of the request in bytes
     * @param {number} duration
     * @param {number} size
     */
            RepresentationChooser.prototype.addEstimate = function addEstimate(duration, size) {
                null != duration && null != size && this.estimator.addSample(duration, size);
            }, 
            /**
     * Reset all the estimates done until now.
     * Useful when the network situation changed completely.
     */
            RepresentationChooser.prototype.resetEstimate = function resetEstimate() {
                this.estimator.reset();
            }, 
            /**
     * Add informations about a new pending request.
     * This can be useful if the network bandwidth drastically changes to infer
     * a new bandwidth through this single request.
     * @param {string|number} id
     * @param {Object} payload
     */
            RepresentationChooser.prototype.addPendingRequest = function addPendingRequest(id, payload) {
                if (this._currentRequests[id]) log.a.warn("ABR: request already added."); else {
                    var _payload$value = payload.value, time = _payload$value.time, duration = _payload$value.duration, requestTimestamp = _payload$value.requestTimestamp;
                    this._currentRequests[id] = {
                        time: time,
                        duration: duration,
                        requestTimestamp: requestTimestamp,
                        progress: []
                    };
                }
            }, 
            /**
     * Add progress informations to a pending request.
     * Progress objects are a key part to calculate the bandwidth from a single
     * request, in the case the user's bandwidth changes drastically while doing
     * it.
     * @param {string|number} id
     * @param {Object} progress
     */
            RepresentationChooser.prototype.addRequestProgress = function addRequestProgress(id, progress) {
                var request = this._currentRequests[id];
                request ? request.progress.push(progress.value) : log.a.warn("ABR: progress for a request not added");
            }, 
            /**
     * Remove a request previously set as pending through the addPendingRequest
     * method.
     * @param {string|number} id
     */
            RepresentationChooser.prototype.removePendingRequest = function removePendingRequest(id) {
                this._currentRequests[id] || log.a.warn("ABR: can't remove unknown request"), delete this._currentRequests[id];
            }, 
            /**
     * Remove informations about all pending requests.
     */
            RepresentationChooser.prototype.resetRequests = function resetRequests() {
                this._currentRequests = {};
            }, 
            /**
     * TODO See if we can avoid this
     */
            RepresentationChooser.prototype.dispose = function dispose() {
                this._dispose$.next(), this.manualBitrate$.complete(), this.maxAutoBitrate$.complete();
            }, RepresentationChooser;
        }();
        /* harmony default export */        
        // CONCATENATED MODULE: ./src/core/abr/index.ts
        function abr_classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        var defaultChooserOptions = {
            limitWidth: {},
            throttle: {},
            initialBitrates: {},
            manualBitrates: {},
            maxAutoBitrates: {}
        }, abr_createChooser = function createChooser(type, options) {
            return new representation_chooser({
                limitWidth$: options.limitWidth[type],
                throttle$: options.throttle[type],
                initialBitrate: options.initialBitrates[type],
                manualBitrate: options.manualBitrates[type],
                maxAutoBitrate: options.maxAutoBitrates[type]
            });
        }, abr = function() {
            /**
     * @param {Observable} requests$ - Emit requests infos as they begin, progress
     * and end.
     * Allows to know if a request take too much time to be finished in
     * emergency times (e.g. when the user's bandwidth falls very quickly).
     *
     * The items emitted are Observables which each emit infos about a SINGLE
     * request. These infos are under the form of objects with the following keys:
     *   - type {string}: the buffer type (example: "video")
     *
     *   - event {string}: Wether the request started, is progressing or has
     *     ended. Should be either one of these three strings:
     *       1. "requestBegin": The request has just begun.
     *
     *       2. "progress": Informations about the request progress were received
     *          (basically the amount of bytes currently received).
     *
     *       2. "requestEnd": The request just ended (successfully/on error/was
     *          canceled)
     *
     *     Note that it should ALWAYS happen in the following order:
     *     1 requestBegin -> 0+ progress -> 1 requestEnd
     *
     *     Also note that EVERY requestBegin should eventually be followed by a
     *     requestEnd at some point. If that's not the case, a memory leak
     *     can happen.
     *
     *   - value {Object|undefined}: The value depends on the type of event
     *     received:
     *       - for "requestBegin" events, it should be an object with the
     *         following keys:
     *           - id {number|String}: The id of this particular request.
     *           - duration {number}: duration, in seconds of the asked segment.
     *           - time {number}: The start time, in seconds of the asked segment.
     *           - requestTimestamp {number}: the timestamp at which the request
     *             was sent, in ms.
     *
     *       - for "progress" events, it should be an object with the following
     *         keys:
     *           - id {number|String}: The id of this particular request.
     *           - size {number}: amount currently downloaded, in bytes
     *           - timestamp {number}: timestamp at which the progress event was
     *             received, in ms
     *         Those events SHOULD be received in order (that is, in increasing
     *         order for both size and timestamp).
     *
     *       - for "requestEnd" events:
     *           - id {number|String}: The id of this particular request.
     *
     * @param {Observable} metrics$ - Emit each times the network downloaded
     * a new segment for a given buffer type. Allows to obtain informations about
     * the user's bitrate.
     *
     * The items emitted are object with the following keys:
     *   - type {string}: the buffer type (example: "video")
     *   - value {Object}:
     *     - duration {number}: duration of the request, in seconds.
     *     - size {number}: size of the downloaded chunks, in bytes.
     *
     * @param {Object|undefined} options
     */
            function ABRManager(requests$, metrics$) {
                var _this = this, options = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : defaultChooserOptions;
                abr_classCallCheck(this, ABRManager), 
                // Subject emitting and completing on dispose.
                // Used to clean up every created observables.
                this._dispose$ = new Subject.a(), 
                // Will contain every RepresentationChooser attached to the ABRManager,
                // by type ("audio"/"video" etc.)
                this._choosers = {}, 
                // -- OPTIONS --
                // Will contain options used when (lazily) instantiating a
                // RepresentationChooser
                this._chooserInstanceOptions = {
                    initialBitrates: options.initialBitrates || {},
                    manualBitrates: options.manualBitrates || {},
                    maxAutoBitrates: options.maxAutoBitrates || {},
                    throttle: options.throttle || {},
                    limitWidth: options.limitWidth || {}
                }, metrics$.pipe(Object(takeUntil.a)(this._dispose$)).subscribe(function(_ref) {
                    var type = _ref.type, value = _ref.value, chooser = _this._lazilyCreateChooser(type), duration = value.duration, size = value.size;
                    // TODO Should we do a single estimate instead of a per-type one?
                    // Test it thoroughly
                    chooser.addEstimate(duration, size);
                }), requests$.pipe(
                // requests$ emits observables which are subscribed to
                Object(mergeMap.a)(function(request$) {
                    return request$;
                }), Object(takeUntil.a)(this._dispose$)).subscribe(function(request) {
                    var type = request.type, value = request.value, chooser = _this._lazilyCreateChooser(type);
                    switch (request.event) {
                      case "requestBegin":
                        // use the id of the segment as in any case, we should only have at
                        // most one active download for the same segment.
                        // This might be not optimal if this changes however. The best I think
                        // for now is to just throw/warn in DEV mode when two pending ids
                        // are identical
                        chooser.addPendingRequest(value.id, request);
                        break;

                      case "requestEnd":
                        chooser.removePendingRequest(value.id);
                        break;

                      case "progress":
                        chooser.addRequestProgress(value.id, request);
                    }
                });
            }
            /**
     * Take type and an array of the available representations, spit out an
     * observable emitting the best representation (given the network/buffer
     * state).
     * @param {string} type
     * @param {Observable<Object>} clock$
     * @param {Array.<Representation>|undefined} representations
     * @returns {Observable}
     */            return ABRManager.prototype.get$ = function get$(type, clock$) {
                var representations = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [];
                return this._lazilyCreateChooser(type).get$(clock$, representations);
            }, 
            /**
     * Set manually the bitrate for a given type.
     *
     * The given number will act as a ceil.
     * If no representation is found with the given bitrate, we will consider:
     *   1. The representation just lower than it
     *   2. If no representation is found in the previous step, the representation
     *   with the lowest bitrate.
     *
     * @param {string} type
     * @param {number} bitrate
     */
            ABRManager.prototype.setManualBitrate = function setManualBitrate(type, bitrate) {
                var chooser = this._choosers[type];
                chooser ? chooser.manualBitrate$.next(bitrate) : 
                // if no chooser yet, store as a chooser option for when it will be
                // effectively instantiated
                this._chooserInstanceOptions.initialBitrates[type] = bitrate;
            }, 
            /**
     * Set a maximum bitrate a given type will be able to automatically switch to.
     * The chooser for the given type can still emit higher bitrates with the
     * setManualBitrate method.
     * @param {string} supportedBufferTypes
     * @param {number} bitrate
     */
            ABRManager.prototype.setMaxAutoBitrate = function setMaxAutoBitrate(type, bitrate) {
                var chooser = this._choosers[type];
                chooser ? chooser.maxAutoBitrate$.next(bitrate) : 
                // if no chooser yet, store as a chooser option for when it will be
                // effectively instantiated
                this._chooserInstanceOptions.maxAutoBitrates[type] = bitrate;
            }, 
            /**
     * Returns the set (and active) manual bitrate for the given type.
     * @param {string} supportedBufferTypes
     * @returns {number|undefined}
     */
            ABRManager.prototype.getManualBitrate = function getManualBitrate(type) {
                var chooser = this._choosers[type];
                return chooser ? chooser.manualBitrate$.getValue() : this._chooserInstanceOptions.manualBitrates[type];
            }, 
            /**
     * Returns the set (and active) maximum auto bitrate for the given type.
     * @param {string} supportedBufferTypes
     * @returns {number|undefined}
     */
            ABRManager.prototype.getMaxAutoBitrate = function getMaxAutoBitrate(type) {
                var chooser = this._choosers[type];
                return chooser ? chooser.maxAutoBitrate$.getValue() : this._chooserInstanceOptions.maxAutoBitrates[type];
            }, 
            /**
     * Clean every ressources linked to the ABRManager.
     * The ABRManager is unusable after calling this method.
     */
            ABRManager.prototype.dispose = function dispose() {
                var _this2 = this;
                Object.keys(this._choosers).forEach(function(type) {
                    _this2._choosers[type].dispose();
                }), this._chooserInstanceOptions = defaultChooserOptions, this._choosers = {}, this._dispose$.next(), 
                this._dispose$.complete();
            }, 
            /**
     * If it doesn't exist, create a RepresentationChooser under the
     * _choosers[bufferType] property.
     * @param {string} bufferType
     * @returns {Object}
     */
            ABRManager.prototype._lazilyCreateChooser = function _lazilyCreateChooser(bufferType) {
                return this._choosers[bufferType] || (this._choosers[bufferType] = abr_createChooser(bufferType, this._chooserInstanceOptions)), 
                this._choosers[bufferType];
            }, ABRManager;
        }(), timer = __webpack_require__(147), defer = __webpack_require__(133), simple_set = __webpack_require__(59), mergeMapTo = __webpack_require__(144), from = __webpack_require__(44), concatAll = __webpack_require__(108), GC_GAP_CALM = config.a.BUFFER_GC_GAPS.CALM, GC_GAP_BEEFY = config.a.BUFFER_GC_GAPS.BEEFY;
        /**
 * Create the right RepresentationChooser instance, from the given data.
 * @param {string} type
 * @param {Object} options
 * @returns {RepresentationChooser} - The RepresentationChooser instance
 */        
        /**
 * Run the garbage collector.
 *
 * Try to clean up buffered ranges from a low gcGap at first.
 * If it does not succeed to clean up space, use a higher gcCap.
 *
 * @param {Observable} timings$
 * @param {QueuedSourceBuffer} bufferingQueue
 * @returns {Observable}
 */
        function forceGarbageCollection(timings$, bufferingQueue) {
            // wait for next timing event
            return timings$.pipe(Object(take.a)(1), Object(mergeMap.a)(function(timing) {
                log.a.warn("buffer: running garbage collector");
                var buffered = bufferingQueue.getBuffered(), cleanedupRanges = selectGCedRanges(timing.currentTime, buffered, GC_GAP_CALM);
                // more aggressive GC if we could not find any range to clean
                return 0 === cleanedupRanges.length && (cleanedupRanges = selectGCedRanges(timing.currentTime, buffered, GC_GAP_BEEFY)), 
                log.a.debug("buffer: gc cleaning", cleanedupRanges), Object(from.a)(cleanedupRanges.map(function(range) {
                    return bufferingQueue.removeBuffer(range);
                })).pipe(Object(concatAll.a)());
            }));
        }
        /**
 * Buffer garbage collector algorithm.
 *
 * Tries to free up some part of the ranges that are distant from the current
 * playing time.
 * See: https://w3c.github.io/media-source/#sourcebuffer-prepare-append
 *
 * @param {Number} currentTime
 * @param {TimeRanges} buffered - current buffered ranges
 * @param {Number} gcGap - delta gap from current timestamp from which we
 * should consider cleaning up.
 * @returns {Array.<Range>} - Ranges selected for clean up
 */        function selectGCedRanges(currentTime, buffered, gcGap) {
            // start by trying to remove all ranges that do not contain the
            // current time and respect the gcGap
            // respect the gcGap? FIXME?
            for (var _getInnerAndOuterTime = Object(utils_ranges.b)(buffered, currentTime), innerRange = _getInnerAndOuterTime.innerRange, outerRanges = _getInnerAndOuterTime.outerRanges, cleanedupRanges = [], i = 0; i < outerRanges.length; i++) {
                var outerRange = outerRanges[i];
                currentTime - gcGap < outerRange.end ? cleanedupRanges.push(outerRange) : currentTime + gcGap > outerRange.start && cleanedupRanges.push(outerRange);
            }
            // try to clean up some space in the current range
                        return innerRange && (log.a.debug("buffer: gc removing part of inner range", cleanedupRanges), 
            currentTime - gcGap > innerRange.start && cleanedupRanges.push({
                start: innerRange.start,
                end: currentTime - gcGap
            }), currentTime + gcGap < innerRange.end && cleanedupRanges.push({
                start: currentTime + gcGap,
                end: innerRange.end
            })), cleanedupRanges;
        }
        // CONCATENATED MODULE: ./src/core/buffer/append_data.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Append buffer to the queuedSourceBuffer.
 * If it leads to a QuotaExceededError, try to run our custom range
 * _garbage collector_.
 *
 * @param {Object} queuedSourceBuffer
 * @param {Object} appendedSegmentInfos
 * @returns {Observable}
 */        function appendDataToSourceBuffer(queuedSourceBuffer, _ref) {
            var segment = _ref.segment, initSegmentData = _ref.initSegmentData, segmentData = _ref.segmentData, segmentOffset = _ref.segmentOffset;
            return segment.isInit ? null == initSegmentData ? Object(of.a)(void 0) : queuedSourceBuffer.appendBuffer(initSegmentData, null, segmentOffset) : null == segmentData ? Object(of.a)(void 0) : queuedSourceBuffer.appendBuffer(initSegmentData, segmentData, segmentOffset);
        }
        /**
 * Append buffer to the queuedSourceBuffer.
 * If it leads to a QuotaExceededError, try to run our custom range
 * _garbage collector_.
 *
 * @param {Observable} clock$
 * @param {Object} queuedSourceBuffer
 * @param {Object} appendedSegmentInfos
 * @returns {Observable}
 */        function appendDataToSourceBufferWithRetries(clock$, queuedSourceBuffer, dataInfos) {
            var append$ = appendDataToSourceBuffer(queuedSourceBuffer, dataInfos);
            return append$.pipe(Object(catchError.a)(function(appendError) {
                if (!appendError || "QuotaExceededError" !== appendError.name) throw new MediaError.a("BUFFER_APPEND_ERROR", appendError, !0);
                return forceGarbageCollection(clock$, queuedSourceBuffer).pipe(Object(mergeMapTo.a)(append$), Object(catchError.a)(function(forcedGCError) {
                    // (weird Typing either due to TypeScript or RxJS bug)
                    throw new MediaError.a("BUFFER_FULL_ERROR", forcedGCError, !0);
                }));
            }));
        }
        // CONCATENATED MODULE: ./src/core/buffer/get_buffer_paddings.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        var BUFFER_PADDING = config.a.BUFFER_PADDING;
        /**
 * Get safety paddings (low and high) for the size of buffer that won't
 * be flushed when switching representation for smooth transitions
 * and avoiding buffer underflows.
 *
 * @param {Object} adaptation
 * @returns {Object}
 */        function getBufferPaddings(adaptation) {
            switch (adaptation.type) {
              case "audio":
              case "video":
                return BUFFER_PADDING[adaptation.type];

              default:
                return BUFFER_PADDING.other;
            }
        }
        // CONCATENATED MODULE: ./src/core/buffer/get_segment_priority.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        var SEGMENT_PRIORITIES_STEPS = config.a.SEGMENT_PRIORITIES_STEPS;
        /**
 * Calculate the priority number of the Segment, in function of the distance
 * with the current time.
 *
 * The lower is this number, the higher should be the priority of the request.
 *
 * @param {Object} segment
 * @param {Object} clockTick
 * @returns {number}
 */        function getSegmentPriority(segment, clockTick) {
            for (var currentTime = clockTick.currentTime + clockTick.wantedTimeOffset, distance = segment.time / segment.timescale - currentTime, priority = 0; priority < SEGMENT_PRIORITIES_STEPS.length; priority++) if (distance < SEGMENT_PRIORITIES_STEPS[priority]) return priority;
            return SEGMENT_PRIORITIES_STEPS.length;
        }
        // CONCATENATED MODULE: ./src/core/buffer/get_segments_needed.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Returns every segments currently wanted.
 *
 * @param {Object} representation - The representation of the chosen
 * adaptation
 * @param {Object} range
 * @param {Object} options
 * @returns {Array.<Object>}
 */        function getSegmentsNeeded(representation, range) {
            var start = range.start, duration = range.end - start;
            // given the current timestamp and the previously calculated time gap and
            // wanted buffer size, we can retrieve the list of segments to inject in
            // our pipelines.
            return representation.index.getSegments(start, duration);
        }
        // CONCATENATED MODULE: ./src/core/buffer/get_wanted_range.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Returns the range of segments needed for a particular point in time.
 *
 * @param {Object} hardLimits
 * @param {TimeRanges} buffered
 * @param {Object} timing
 * @param {number} bufferGoal
 * @param {Object} paddings
 * @returns {Object}
 */        function getWantedRange(hardLimits, buffered, timing, bufferGoal, paddings) {
            var currentTime = timing.currentTime + timing.wantedTimeOffset, limitEnd = null == timing.liveGap ? hardLimits.end : Math.min(hardLimits.end || Infinity, timing.currentTime + timing.liveGap), boundedLimits = {
                start: Math.max(hardLimits.start || 0, currentTime),
                end: limitEnd
            }, lowPadding = paddings.low, highPadding = paddings.high, bufferGap = Object(utils_ranges.c)(buffered, currentTime), timestampPadding = bufferGap > lowPadding && bufferGap < Infinity ? Math.min(bufferGap, highPadding) : 0;
            return {
                start: Math.min(Math.max(currentTime + timestampPadding, boundedLimits.start), boundedLimits.end || Infinity),
                end: Math.min(Math.max(currentTime + bufferGoal, boundedLimits.start), boundedLimits.end || Infinity)
            };
        }
        // CONCATENATED MODULE: ./src/core/buffer/segment_filter.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        var BITRATE_REBUFFERING_RATIO = config.a.BITRATE_REBUFFERING_RATIO, MINIMUM_SEGMENT_SIZE = config.a.MINIMUM_SEGMENT_SIZE;
        /**
 * Returns true if the given Segment should be downloaded.
 * false otherwise.
 *
 * @param {Object} segment
 * @param {Object} content - The content the Segment depends on.
 * @param {Object} segmentBookkeeper
 * @param {Object} wantedRange
 * @param {Object} segmentIDsToIgnore
 * @returns {boolean}
 */        function shouldDownloadSegment(segment, content, segmentBookkeeper, wantedRange, segmentIDsToIgnore) {
            var period = content.period, adaptation = content.adaptation, representation = content.representation;
            if (segmentIDsToIgnore.test(segment.id)) return !1;
            // segment without time info are usually init segments or some
            // kind of metadata segment that we never filter out
                        if (segment.isInit || segment.time < 0) return !0;
            var time = segment.time, duration = segment.duration, timescale = segment.timescale;
            if (!duration) return !0;
            if (duration / timescale < MINIMUM_SEGMENT_SIZE) return !1;
            var currentSegment = segmentBookkeeper.hasPlayableSegment(wantedRange, {
                time: time,
                duration: duration,
                timescale: timescale
            });
            if (!currentSegment) return !0;
            if (currentSegment.infos.period.id !== period.id || currentSegment.infos.adaptation.id !== adaptation.id) return !0;
            // only re-load comparatively-poor bitrates for the same adaptation.
                        var bitrateCeil = currentSegment.infos.representation.bitrate * BITRATE_REBUFFERING_RATIO;
            return representation.bitrate > bitrateCeil;
        }
        // CONCATENATED MODULE: ./src/core/buffer/representation_buffer.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Build up buffer for a single Representation.
 *
 * Download and push segments linked to the given Representation according
 * to what is already in the SourceBuffer and where the playback currently is.
 *
 * Multiple RepresentationBuffer observables can be ran on the same
 * SourceBuffer.
 * This allows for example smooth transitions between multiple periods.
 *
 * @param {Object} opt
 * @returns {Observable}
 */        function RepresentationBuffer(_ref) {
            var clock$ = _ref.clock$, content = _ref.content, queuedSourceBuffer = _ref.queuedSourceBuffer, segmentBookkeeper = _ref.segmentBookkeeper, segmentFetcher = _ref.segmentFetcher, wantedBufferAhead$ = _ref.wantedBufferAhead$, manifest = content.manifest, period = content.period, adaptation = content.adaptation, representation = content.representation, bufferType = adaptation.type, initSegment = representation.index.getInitSegment(), paddings = getBufferPaddings(adaptation), initSegmentObject = null == initSegment ? {
                segmentData: null,
                segmentInfos: null,
                segmentOffset: 0
            } : null, startQueue$ = new ReplaySubject.a(1), downloadQueue = [], currentSegmentRequest = null, sourceBufferWaitingQueue = new simple_set.a();
            // unwrap components of the content
                        /**
     * Update the downloadQueue and start/restart the queue depending on the
     * internalState and the current RepresentationBuffer's data.
     *
     * Returns the new state of the Downloading Queue.
     *
     * @param {Object} state
     * @returns {Object}
     */
            function updateQueueFromInternalState(state) {
                if ("need-segments" !== state.type || !state.value.neededSegments.length) // (re-)start with an empty queue
                return currentSegmentRequest && log.a.debug("interrupting segment request."), downloadQueue = [], 
                startQueue$.next(), "full-buffer" === state.type ? {
                    type: "full-buffer",
                    value: {
                        bufferType: bufferType
                    }
                } : {
                    type: "idle-buffer",
                    value: {
                        bufferType: bufferType
                    }
                };
                var neededSegments = state.value.neededSegments, mostNeededSegment = neededSegments[0];
                if (currentSegmentRequest) if (currentSegmentRequest.segment.id !== mostNeededSegment.segment.id) log.a.debug("canceling old downloading queue and starting a new one", adaptation.type), 
                downloadQueue = neededSegments, startQueue$.next(); else if (currentSegmentRequest.priority !== mostNeededSegment.priority) log.a.debug("updating pending request priority", adaptation.type), 
                segmentFetcher.updatePriority(currentSegmentRequest.request$, mostNeededSegment.priority); else {
                    log.a.debug("updating downloading queue", adaptation.type);
                    // Update the previous queue to be all needed segments but the first one,
                    // for which a request is already pending
                    var newQueue = neededSegments.slice().splice(1, neededSegments.length);
 // remove first element
                    // (pending request)
                                        downloadQueue = newQueue;
                } else log.a.debug("starting downloading queue", adaptation.type), downloadQueue = neededSegments, 
                startQueue$.next();
                return {
                    type: "active-buffer",
                    value: {
                        bufferType: bufferType
                    }
                };
            }
            /**
     * State Checker:
     *   - indicates when the manifest should be refreshed
     *   - indicates if a discontinuity is encountered
     *   - emit state updates
     *   - update the downloadQueue
     *   - start/restart the BufferQueue
     * @type {Observable}
     */            var bufferState$ = Object(combineLatest.a)(clock$, wantedBufferAhead$).pipe(Object(map.a)(
            /**
     * Perform a check-up of the current status of the RepresentationBuffer:
     *   - synchronize the SegmentBookkeeper with the current buffered
     *   - checks if the manifest should be refreshed
     *   - checks if a discontinuity is encountered
     *   - check if segments need to be downloaded
     *   - Emit a description of the current state of the buffer
     *
     * @param {Array} arr
     * @returns {Object}
     */
            function getBufferStatus(_ref3) {
                var timing = _ref3[0], bufferGoal = _ref3[1], buffered = queuedSourceBuffer.getBuffered(), neededRange = getWantedRange(period, buffered, timing, bufferGoal, paddings), discontinuity = getCurrentDiscontinuity(content, timing), shouldRefreshManifest = shouldRefreshManifestForRange(content, neededRange);
                // /!\ Side effect to the SegmentBookkeeper
                segmentBookkeeper.synchronizeBuffered(buffered);
                var neededSegments = getSegmentsNeeded(representation, neededRange).filter(function(segment) {
                    return shouldDownloadSegment(segment, content, segmentBookkeeper, neededRange, sourceBufferWaitingQueue);
                }).map(function(segment) {
                    return {
                        priority: getSegmentPriority(segment, timing),
                        segment: segment
                    };
                });
                return null != initSegment && null == initSegmentObject && (neededSegments = [ {
                    segment: initSegment,
                    priority: getSegmentPriority(initSegment, timing)
                } ].concat(neededSegments)), {
                    discontinuity: discontinuity,
                    shouldRefreshManifest: shouldRefreshManifest,
                    state: neededSegments.length ? {
                        type: "need-segments",
                        value: {
                            neededSegments: neededSegments
                        }
                    } : null != period.end && neededRange.end >= period.end ? {
                        type: "full-buffer",
                        value: void 0
                    } : {
                        type: "idle-buffer",
                        value: void 0
                    }
                };
            }
            /**
     * Exploit the status given by ``getBufferStatus``:
     *   - emit needed actions
     *   - mutates the downloadQueue
     *   - start/restart the current BufferQueue
     *   - emit the state of the Buffer
     * @param {Object} status
     * @returns {Observable}
     */), Object(mergeMap.a)(function handleBufferStatus(status) {
                var discontinuity = status.discontinuity, shouldRefreshManifest = status.shouldRefreshManifest, state = status.state, neededActions = getNeededActions(bufferType, discontinuity, shouldRefreshManifest), downloadQueueState = updateQueueFromInternalState(state);
                return "idle-buffer" === downloadQueueState.type ? of.a.apply(void 0, neededActions) : Object(concat.a)(of.a.apply(void 0, neededActions), Object(of.a)(downloadQueueState));
            })), bufferQueue$ = startQueue$.pipe(Object(switchMap.a)(
            /**
     * Request every Segment in the ``downloadQueue`` on subscription.
     * Emit the data of a segment when a request succeeded.
     * @returns {Observable}
     */
            function requestSegments() {
                var requestNextSegment$ = Object(defer.a)(function() {
                    var currentNeededSegment = downloadQueue.shift();
                    if (null == currentNeededSegment) return empty.a;
                    var initInfos = initSegmentObject && initSegmentObject.segmentInfos || void 0, segment = currentNeededSegment.segment, priority = currentNeededSegment.priority, request$ = segmentFetcher.createRequest({
                        adaptation: adaptation,
                        init: initInfos,
                        manifest: manifest,
                        period: period,
                        representation: representation,
                        segment: segment
                    }, priority);
                    currentSegmentRequest = {
                        segment: segment,
                        priority: priority,
                        request$: request$
                    };
                    var response$ = request$.pipe(Object(map.a)(function(args) {
                        return {
                            segment: segment,
                            value: args.parsed
                        };
                    }));
                    return Object(concat.a)(response$, requestNextSegment$);
                });
                return requestNextSegment$.pipe(finalize(function() {
                    currentSegmentRequest = null;
                }));
            }
            /**
     * Append the given segment to the SourceBuffer.
     * Emit the right event when it succeeds.
     * @param {Object} data
     * @returns {Observable}
     */), Object(mergeMap.a)(function appendSegment(data) {
                return Object(defer.a)(function() {
                    var segment = data.segment, _data$value = data.value, segmentInfos = _data$value.segmentInfos, segmentData = _data$value.segmentData, segmentOffset = _data$value.segmentOffset;
                    if (segment.isInit && (initSegmentObject = data.value), null == segmentData) 
                    // no segmentData to add here (for example, a text init segment)
                    // just complete directly without appending anything
                    return empty.a;
                    var initSegmentData = initSegmentObject && initSegmentObject.segmentData, append$ = appendDataToSourceBufferWithRetries(clock$, queuedSourceBuffer, {
                        initSegmentData: initSegmentData,
                        segmentData: segmentData,
                        segment: segment,
                        segmentOffset: segmentOffset
                    });
                    return sourceBufferWaitingQueue.add(segment.id), append$.pipe(Object(mapTo.a)({
                        type: "added-segment",
                        value: {
                            bufferType: bufferType,
                            segment: segment,
                            segmentData: segmentData
                        }
                    }), Object(tap.a)(function() {
                        if (!segment.isInit) {
                            var _ref2 = segmentInfos || segment, time = _ref2.time, duration = _ref2.duration, timescale = _ref2.timescale;
                            // current segment timings informations are used to update
                            // bufferedRanges informations
                                                        segmentBookkeeper.insert(period, adaptation, representation, segment, time / timescale, // start
                            null != duration ? (time + duration) / timescale : void 0);
                        }
                    }), finalize(function() {
                        sourceBufferWaitingQueue.remove(segment.id);
                    }));
                });
            }));
            /**
     * Buffer Queue:
     *   - download segment
     *   - append them to the SourceBuffer
     * @type {Observable}
     */            return Object(merge.a)(bufferState$, bufferQueue$).pipe(Object(share.a)());
        }
        /**
 * Emit the current discontinuity encountered.
 * Inferior or equal to 0 if no discontinuity is currently happening.
 * @param {Object} content
 * @param {Object} timing
 * @returns {number}
 */        function getCurrentDiscontinuity(_ref4, timing) {
            var manifest = _ref4.manifest, representation = _ref4.representation;
            return timing.stalled && manifest.isLive ? representation.index.checkDiscontinuity(timing.currentTime) : -1;
        }
        /**
 * Returns true if the current Manifest needs to be downloaded.
 * @param {Object} content
 * @param {Object} segmentBookkeeper
 * @param {Object} wantedRange
 * @returns {Boolean}
 */        function shouldRefreshManifestForRange(_ref5, wantedRange) {
            var representation = _ref5.representation, start = wantedRange.start, end = wantedRange.end;
            return representation.index.shouldRefresh(start, end);
        }
        /**
 * @param {number} discontinuity
 * @param {boolean} shouldRefreshManifest
 * @returns {Array.<Object>}
 */        function getNeededActions(bufferType, discontinuity, shouldRefreshManifest) {
            var neededActions = [];
            return discontinuity > 1 && neededActions.push({
                type: "discontinuity-encountered",
                value: {
                    nextTime: discontinuity + 1,
                    bufferType: bufferType
                }
            }), shouldRefreshManifest && neededActions.push({
                type: "needs-manifest-refresh",
                value: {
                    bufferType: bufferType
                }
            }), neededActions;
        }
        // CONCATENATED MODULE: ./src/core/buffer/index.ts
                function buffer_classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Create Buffers linked to an Adaptation.
 *
 * It will rely on the ABRManager to choose at any time the best Representation
 * for this Adaptation and then run the logic to download and push the
 * corresponding segments in the SourceBuffer.
 *
 * @example
 * ```js
 * const bufferManager = new AdaptationBufferManager(
 *   abrManager,
 *   abrClock$
 * );
 *
 * const buffer$ = bufferManager.createBuffer(
 *  bufferClock$,
 *  queuedSourceBuffer,
 *  segmentBookkeeper,
 *  segmentFetcher,
 *  wantedBufferAhead$,
 *  { manifest, period, adaptation},
 * );
 * ```
 * @class AdaptationBufferManager
 */        var core_buffer = function() {
            /**
     * @param {ABRManager} abrManager
     * @param {Observable} abrBaseClock$ - Clock at which the ABR manager will
     * estimate the right Representation to play.
     */
            function AdaptationBufferManager(abrManager, abrBaseClock$) {
                buffer_classCallCheck(this, AdaptationBufferManager), this._abrManager = abrManager, 
                this._abrBaseClock$ = abrBaseClock$;
            }
            /**
     * Create new Buffer Observable linked to the given Adaptation.
     *
     * This Buffer will download and push segments from a single Adaptation,
     * linked to a single Period.
     * It will emit various events to report its status to the caller.
     *
     * @param {Observable} bufferClock$ - Clock at which the Buffer will check
     * for segments download
     * @param {QueuedSourceBuffer} queuedSourceBuffer - QueuedSourceBuffer used
     * to push segments and know about the current real buffer's health.
     * @param {SegmentBookkeeper} segmentBookkeeper - Used to synchronize and
     * retrieve the Segments currently present in the QueuedSourceBuffer
     * @param {Function} segmentFetcher - Function used to download segments
     * @param {Observable} wantedBufferAhead$ - Emits the buffer goal
     * @param {Object} content - Content to download
     * @returns {Observable}
     */            return AdaptationBufferManager.prototype.createBuffer = function createBuffer(bufferClock$, queuedSourceBuffer, segmentBookkeeper, segmentFetcher, wantedBufferAhead$, content) {
                var manifest = content.manifest, period = content.period, adaptation = content.adaptation, abr$ = this._getABRForAdaptation(adaptation).pipe(Object(shareReplay.a)()), bitrateEstimate$ = abr$.pipe(Object(filter.a)(function(_ref) {
                    return null != _ref.bitrate;
                }), Object(map.a)(function(_ref2) {
                    var bitrate = _ref2.bitrate;
                    return {
                        type: "bitrateEstimationChange",
                        value: {
                            type: adaptation.type,
                            bitrate: bitrate
                        }
                    };
                })), buffer$ = abr$.pipe(Object(map.a)(function(abr) {
                    return abr.representation;
                })).pipe(Object(distinctUntilChanged.a)(function(a, b) {
                    return !a || !b || a.bitrate === b.bitrate && a.id === b.id;
                })).pipe(Object(distinctUntilChanged.a)(function(oldRepresentation, newRepresentation) {
                    return oldRepresentation.id === newRepresentation.id;
                })).pipe(Object(switchMap.a)(function(representation) {
                    return Object(concat.a)(Object(of.a)({
                        type: "representationChange",
                        value: {
                            type: adaptation.type,
                            period: period,
                            representation: representation
                        }
                    }), createRepresentationBuffer(representation));
                }));
                return Object(merge.a)(buffer$, bitrateEstimate$);
                /**
         * Create and returns a new RepresentationBuffer Observable, linked to the
         * given Representation.
         * @param {Representation} representation
         * @returns {Observable}
         */                function createRepresentationBuffer(representation) {
                    return log.a.info("changing representation", adaptation.type, representation), RepresentationBuffer({
                        clock$: bufferClock$,
                        content: {
                            representation: representation,
                            adaptation: adaptation,
                            period: period,
                            manifest: manifest
                        },
                        queuedSourceBuffer: queuedSourceBuffer,
                        segmentBookkeeper: segmentBookkeeper,
                        segmentFetcher: segmentFetcher,
                        wantedBufferAhead$: wantedBufferAhead$
                    }).pipe(Object(catchError.a)(function(error) {
                        // TODO only for smooth/to Delete?
                        // TODO Do it in the stream?
                        // for live adaptations, handle 412 errors as precondition-
                        // failed errors, ie: we are requesting for segments before they
                        // exist
                        // (In case of smooth streaming, 412 errors are requests that are
                        // performed to early).
                        if (!manifest.isLive || error.type !== constants.b.NETWORK_ERROR || !error.isHttpError(412)) throw error;
                        return manifest.updateLiveGap(1), // go back 1s for now
                        log.a.warn("precondition failed", manifest.presentationLiveGap), Object(timer.a)(2e3).pipe(Object(mergeMap.a)(function() {
                            return createRepresentationBuffer(representation);
                        }));
                    }));
                }
            }, 
            /**
     * Returns ABR Observable.
     * @param {Object} adaptation
     * @returns {Observable}
     */
            AdaptationBufferManager.prototype._getABRForAdaptation = function _getABRForAdaptation(adaptation) {
                var representations = adaptation.representations, currentRepresentation = null, abrClock$ = this._abrBaseClock$.pipe(Object(map.a)(function(tick) {
                    var bitrate = void 0, lastIndexPosition = void 0;
                    return currentRepresentation && (bitrate = currentRepresentation.bitrate, currentRepresentation.index && (lastIndexPosition = currentRepresentation.index.getLastPosition())), 
                    object_assign_default()({
                        bitrate: bitrate,
                        lastIndexPosition: lastIndexPosition
                    }, tick);
                }));
                /**
         * Keep track of the current representation to add informations to the
         * ABR clock.
         * TODO isn't that a little bit ugly?
         * @type {Object|null}
         */                return this._abrManager.get$(adaptation.type, abrClock$, representations).pipe(Object(tap.a)(function(_ref3) {
                    var representation = _ref3.representation;
                    currentRepresentation = representation;
                }));
            }, AdaptationBufferManager;
        }(), compat = __webpack_require__(12), array_includes = __webpack_require__(14), utils_id = __webpack_require__(18);
        // Re-export RepresentationBuffer events used by the AdaptationBufferManager
        /* harmony default export */        
        // CONCATENATED MODULE: ./src/manifest/representation.ts
        function representation_classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Normalized Representation structure.
 * @class Representation
 */        var manifest_representation = function() {
            /**
     * @constructor
     * @param {Object|undefined} args
     */
            function Representation(args) {
                representation_classCallCheck(this, Representation);
                var nId = Object(utils_id.a)();
                this.id = null == args.id ? nId : args.id, this.bitrate = args.bitrate, this.codec = args.codecs, 
                null != args.height && (this.height = args.height), null != args.width && (this.width = args.width), 
                null != args.mimeType && (this.mimeType = args.mimeType), args.contentProtections && (this.contentProtections = args.contentProtections), 
                this.index = args.index;
            }
            return Representation.prototype.getMimeTypeString = function getMimeTypeString() {
                return this.mimeType + ';codecs="' + this.codec + '"';
            }, Representation;
        }();
        /* harmony default export */        
        // CONCATENATED MODULE: ./src/manifest/adaptation.ts
        function adaptation_classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        var SUPPORTED_ADAPTATIONS_TYPE = [ "audio", "video", "text", "image" ], manifest_adaptation = function() {
            /**
     * @constructor
     */
            function Adaptation(args) {
                var _this = this;
                adaptation_classCallCheck(this, Adaptation);
                var nId = Object(utils_id.a)();
                this.id = null == args.id ? nId : "" + args.id, this.type = args.type, this.representations = Array.isArray(args.representations) ? args.representations.map(function(r) {
                    return new manifest_representation(object_assign_default()({
                        rootId: _this.id
                    }, r));
                }).sort(function(a, b) {
                    return a.bitrate - b.bitrate;
                }) : [], null != args.language && (this.language = args.language), null != args.normalizedLanguage && (this.normalizedLanguage = args.normalizedLanguage), 
                null != args.closedCaption && (this.isClosedCaption = args.closedCaption), null != args.audioDescription && (this.isAudioDescription = args.audioDescription), 
                // TODO move to DASH's Segment private infos
                null != args.contentProtection && (this.contentProtection = args.contentProtection), 
                // for manuallyAdded adaptations (not in the manifest)
                this.manuallyAdded = !!args.manuallyAdded;
            }
            /**
     * @returns {Array.<Number>}
     */            return Adaptation.prototype.getAvailableBitrates = function getAvailableBitrates() {
                return this.representations.map(function(r) {
                    return r.bitrate;
                });
            }, 
            /**
     * @param {Number|string} wantedId
     * @returns {Representation}
     */
            Adaptation.prototype.getRepresentation = function getRepresentation(wantedId) {
                return find_default()(this.representations, function(_ref) {
                    var id = _ref.id;
                    return wantedId === id;
                });
            }, 
            /**
     * @param {Number} bitrate
     * @returns {Array.<Representations>|null}
     */
            Adaptation.prototype.getRepresentationsForBitrate = function getRepresentationsForBitrate(bitrate) {
                return this.representations.filter(function(r) {
                    return r.bitrate === bitrate;
                }) || null;
            }, Adaptation;
        }(), utils_languages = __webpack_require__(40);
        /**
 * Normalized Adaptation structure.
 * @class Adaptation
 */        
        // CONCATENATED MODULE: ./src/manifest/representation_index/static.ts
        function static_classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Simple RepresentationIndex implementation for static files.
 * @class StaticRepresentationIndex
 */        var representation_index_static = function() {
            function StaticRepresentationIndex(infos) {
                static_classCallCheck(this, StaticRepresentationIndex), this._media = infos.media;
            }
            /**
     * Static contents do not have any initialization segments.
     * Just return null.
     * @returns {null}
     */            return StaticRepresentationIndex.prototype.getInitSegment = function getInitSegment() {
                return null;
            }, 
            /**
     * Returns the only Segment available here.
     * @returns {Array.<Object>}
     */
            StaticRepresentationIndex.prototype.getSegments = function getSegments() {
                return [ {
                    id: "0",
                    isInit: !1,
                    number: 0,
                    time: 0,
                    duration: Number.MAX_VALUE,
                    timescale: 1,
                    mediaURL: this._media
                } ];
            }, 
            /**
     * Returns first position in index.
     * @returns {undefined}
     */
            StaticRepresentationIndex.prototype.getFirstPosition = function getFirstPosition() {
                /* tslint:enable return-undefined */}, 
            /**
     * Returns last position in index.
     * @returns {undefined}
     */
            StaticRepresentationIndex.prototype.getLastPosition = function getLastPosition() {
                /* tslint:enable return-undefined */}, 
            /**
     * Returns false as a static file never need to be refreshed.
     * @returns {Boolean}
     */
            StaticRepresentationIndex.prototype.shouldRefresh = function shouldRefresh() {
                return !1;
            }, 
            /**
     * @returns {Number}
     */
            StaticRepresentationIndex.prototype.checkDiscontinuity = function checkDiscontinuity() {
                return -1;
            }, StaticRepresentationIndex.prototype._addSegments = function _addSegments() {
                0;
            }, StaticRepresentationIndex.prototype._update = function _update() {
                log.a.warn("Tried to update a static RepresentationIndex");
            }, StaticRepresentationIndex;
        }();
        /* harmony default export */        
        // CONCATENATED MODULE: ./src/manifest/period.ts
        function period_classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        var manifest_period = function() {
            /**
     * @constructor
     * @param {Object} args
     */
            function Period(args) {
                period_classCallCheck(this, Period), this.id = args.id, this.adaptations = Object.keys(args.adaptations).reduce(function(acc, type) {
                    if (args.adaptations[type]) {
                        var adaptationsForType = args.adaptations[type];
                        adaptationsForType && (acc[type] = adaptationsForType.map(function(adaptation) {
                            return new manifest_adaptation(adaptation);
                        }));
                    }
                    return acc;
                }, {}), this.duration = args.duration, this.start = args.start, null != this.duration && null != this.start && (this.end = this.start + this.duration);
            }
            /**
     * Add supplementary image Adaptation(s) to the manifest.
     * @param {Object|Array.<Object>} imageTracks
     */            return Period.prototype.addSupplementaryImageAdaptations = function addSupplementaryImageAdaptations(imageTracks) {
                var newImageTracks = (Array.isArray(imageTracks) ? imageTracks : [ imageTracks ]).map(function(_ref) {
                    var mimeType = _ref.mimeType, url = _ref.url, adaptationID = "gen-image-ada-" + Object(utils_id.a)(), representationID = "gen-image-rep-" + Object(utils_id.a)();
                    return new manifest_adaptation({
                        id: adaptationID,
                        type: "image",
                        manuallyAdded: !0,
                        representations: [ {
                            bitrate: 0,
                            id: representationID,
                            mimeType: mimeType,
                            index: new representation_index_static({
                                media: url
                            })
                        } ]
                    });
                });
                newImageTracks.length && (this.adaptations.image = this.adaptations.image ? this.adaptations.image.concat(newImageTracks) : newImageTracks);
            }, 
            /**
     * Add supplementary text Adaptation(s) to the manifest.
     * @param {Object|Array.<Object>} textTracks
     */
            Period.prototype.addSupplementaryTextAdaptations = function addSupplementaryTextAdaptations(textTracks) {
                var newTextAdaptations = (Array.isArray(textTracks) ? textTracks : [ textTracks ]).reduce(function(allSubs, _ref2) {
                    var mimeType = _ref2.mimeType, codecs = _ref2.codecs, url = _ref2.url, language = _ref2.language, languages = _ref2.languages, closedCaption = _ref2.closedCaption, langsToMapOn = language ? [ language ] : languages || [];
                    return allSubs.concat(langsToMapOn.map(function(_language) {
                        var adaptationID = "gen-text-ada-" + Object(utils_id.a)(), representationID = "gen-text-rep-" + Object(utils_id.a)();
                        return new manifest_adaptation({
                            id: adaptationID,
                            type: "text",
                            language: _language,
                            normalizedLanguage: Object(utils_languages.a)(_language),
                            closedCaption: closedCaption,
                            manuallyAdded: !0,
                            representations: [ {
                                bitrate: 0,
                                id: representationID,
                                mimeType: mimeType,
                                codecs: codecs,
                                index: new representation_index_static({
                                    media: url
                                })
                            } ]
                        });
                    }));
                }, []);
                newTextAdaptations.length && (this.adaptations.text = this.adaptations.text ? this.adaptations.text.concat(newTextAdaptations) : newTextAdaptations);
            }, 
            /**
     * @returns {Array.<Object>}
     */
            Period.prototype.getAdaptations = function getAdaptations() {
                var adaptationsByType = this.adaptations;
                if (!adaptationsByType) return [];
                var adaptationsList = [];
                for (var adaptationType in adaptationsByType) if (adaptationsByType.hasOwnProperty(adaptationType)) {
                    var adaptations = adaptationsByType[adaptationType];
                    adaptationsList.push.apply(adaptationsList, adaptations);
                }
                return adaptationsList;
            }, Period.prototype.getAdaptationsForType = function getAdaptationsForType(adaptationType) {
                return this.adaptations[adaptationType] || [];
            }, Period.prototype.getAdaptation = function getAdaptation(wantedId) {
                return find_default()(this.getAdaptations(), function(_ref3) {
                    var id = _ref3.id;
                    return wantedId === id;
                });
            }, Period;
        }();
        /* harmony default export */        
        // CONCATENATED MODULE: ./src/manifest/index.ts
        function manifest_classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Normalized Manifest structure.
 * @class Manifest
 */        var src_manifest = function() {
            /**
     * @constructor
     * @param {Object} args
     */
            function Manifest(args) {
                manifest_classCallCheck(this, Manifest);
                var nId = Object(utils_id.a)();
                this.id = null == args.id ? nId : "" + args.id, this.transport = args.transportType || "", 
                // TODO Real period management
                this.periods = args.periods.map(function(period) {
                    return new manifest_period(period);
                }), 
                /**
         * @deprecated TODO It is here to ensure compatibility with the way the
         * v3.x.x manages adaptations at the Manifest level
         */
                this.adaptations = this.periods[0] && this.periods[0].adaptations || [], this.minimumTime = args.minimumTime, 
                this.isLive = "dynamic" === args.type, this.uris = args.uris, this.suggestedPresentationDelay = args.suggestedPresentationDelay, 
                this.availabilityStartTime = args.availabilityStartTime, this.presentationLiveGap = args.presentationLiveGap, 
                this.timeShiftBufferDepth = args.timeShiftBufferDepth, 
                // --------- private data
                this._duration = args.duration;
            }
            /**
     * Add supplementary image Adaptation(s) to the manifest.
     * @param {Object|Array.<Object>} imageTracks
     */            return Manifest.prototype.addSupplementaryImageAdaptations = function addSupplementaryImageAdaptations(imageTracks) {
                var newImageTracks = (Array.isArray(imageTracks) ? imageTracks : [ imageTracks ]).map(function(_ref) {
                    var mimeType = _ref.mimeType, url = _ref.url, adaptationID = "gen-image-ada-" + Object(utils_id.a)(), representationID = "gen-image-rep-" + Object(utils_id.a)();
                    return new manifest_adaptation({
                        id: adaptationID,
                        type: "image",
                        manuallyAdded: !0,
                        representations: [ {
                            bitrate: 0,
                            id: representationID,
                            mimeType: mimeType,
                            index: new representation_index_static({
                                media: url
                            })
                        } ]
                    });
                });
                newImageTracks.length && (this.adaptations.image = this.adaptations.image ? this.adaptations.image.concat(newImageTracks) : newImageTracks);
            }, 
            /**
     * Add supplementary text Adaptation(s) to the manifest.
     * @param {Object|Array.<Object>} textTracks
     */
            Manifest.prototype.addSupplementaryTextAdaptations = function addSupplementaryTextAdaptations(textTracks) {
                var newTextAdaptations = (Array.isArray(textTracks) ? textTracks : [ textTracks ]).reduce(function(allSubs, _ref2) {
                    var mimeType = _ref2.mimeType, codecs = _ref2.codecs, url = _ref2.url, language = _ref2.language, languages = _ref2.languages, closedCaption = _ref2.closedCaption, langsToMapOn = language ? [ language ] : languages || [];
                    return allSubs.concat(langsToMapOn.map(function(_language) {
                        var adaptationID = "gen-text-ada-" + Object(utils_id.a)(), representationID = "gen-text-rep-" + Object(utils_id.a)();
                        return new manifest_adaptation({
                            id: adaptationID,
                            type: "text",
                            language: _language,
                            normalizedLanguage: Object(utils_languages.a)(_language),
                            closedCaption: closedCaption,
                            manuallyAdded: !0,
                            representations: [ {
                                bitrate: 0,
                                id: representationID,
                                mimeType: mimeType,
                                codecs: codecs,
                                index: new representation_index_static({
                                    media: url
                                })
                            } ]
                        });
                    }));
                }, []);
                newTextAdaptations.length && (this.adaptations.text = this.adaptations.text ? this.adaptations.text.concat(newTextAdaptations) : newTextAdaptations);
            }, 
            /**
     * Returns Period encountered at the given time.
     * Returns undefined if there is no Period exactly at the given time.
     * @param {number} time
     * @returns {Period|undefined}
     */
            Manifest.prototype.getPeriodForTime = function getPeriodForTime(time) {
                return find_default()(this.periods, function(period) {
                    return time >= period.start && (null == period.end || period.end > time);
                });
            }, 
            /**
     * Returns period coming just after a given period.
     * Returns undefined if not found.
     * @param {Period} period
     * @returns {Period|null}
     */
            Manifest.prototype.getPeriodAfter = function getPeriodAfter(period) {
                var endOfPeriod = period.end;
                return null == endOfPeriod ? null : find_default()(this.periods, function(_period) {
                    return null == _period.end || endOfPeriod < _period.end;
                }) || null;
            }, 
            /**
     * @returns {Number}
     */
            Manifest.prototype.getDuration = function getDuration() {
                return this._duration;
            }, 
            /**
     * @returns {string|undefined}
     */
            Manifest.prototype.getUrl = function getUrl() {
                return this.uris[0];
            }, 
            /**
     * TODO log deprecation
     * @deprecated only returns adaptations for the first period
     * @returns {Array.<Object>}
     */
            Manifest.prototype.getAdaptations = function getAdaptations() {
                var firstPeriod = this.periods[0];
                if (!firstPeriod) return [];
                var adaptationsByType = firstPeriod.adaptations, adaptationsList = [];
                for (var adaptationType in adaptationsByType) if (adaptationsByType.hasOwnProperty(adaptationType)) {
                    var adaptations = adaptationsByType[adaptationType];
                    adaptationsList.push.apply(adaptationsList, adaptations);
                }
                return adaptationsList;
            }, 
            /**
     * TODO log deprecation
     * @deprecated only returns adaptations for the first period
     * @returns {Array.<Object>}
     */
            Manifest.prototype.getAdaptationsForType = function getAdaptationsForType(adaptationType) {
                var firstPeriod = this.periods[0];
                return firstPeriod && firstPeriod.adaptations[adaptationType] || [];
            }, 
            /**
     * TODO log deprecation
     * @deprecated only returns adaptations for the first period
     * @returns {Array.<Object>}
     */
            Manifest.prototype.getAdaptation = function getAdaptation(wantedId) {
                /* tslint:disable:deprecation */
                return find_default()(this.getAdaptations(), function(_ref3) {
                    var id = _ref3.id;
                    return wantedId === id;
                });
                /* tslint:enable:deprecation */            }, 
            /**
     * @param {number} delta
     */
            Manifest.prototype.updateLiveGap = function updateLiveGap(delta) {
                this.isLive && (this.presentationLiveGap ? this.presentationLiveGap += delta : this.presentationLiveGap = delta);
            }, 
            /**
     * Update the current manifest properties
     * @param {Object} Manifest
     */
            Manifest.prototype.update = function update(newManifest) {
                this._duration = newManifest.getDuration(), this.timeShiftBufferDepth = newManifest.timeShiftBufferDepth, 
                this.availabilityStartTime = newManifest.availabilityStartTime, this.suggestedPresentationDelay = newManifest.suggestedPresentationDelay, 
                this.uris = newManifest.uris;
                for (var oldPeriods = this.periods, newPeriods = newManifest.periods, _loop = function _loop(_i) {
                    var oldPeriod = oldPeriods[_i], newPeriod = find_default()(newPeriods, function(a) {
                        return a.id === oldPeriod.id;
                    });
                    if (newPeriod) {
                        oldPeriod.start = newPeriod.start, oldPeriod.end = newPeriod.end, oldPeriod.duration = newPeriod.duration;
                        for (var oldAdaptations = oldPeriod.getAdaptations(), newAdaptations = newPeriod.getAdaptations(), _loop2 = function _loop2(j) {
                            var oldAdaptation = oldAdaptations[j], newAdaptation = find_default()(newAdaptations, function(a) {
                                return a.id === oldAdaptation.id;
                            });
                            if (newAdaptation) for (var oldRepresentations = oldAdaptations[j].representations, newRepresentations = newAdaptation.representations, _loop3 = function _loop3(k) {
                                var oldRepresentation = oldRepresentations[k], newRepresentation = find_default()(newRepresentations, function(r) {
                                    return r.id === oldRepresentation.id;
                                });
                                newRepresentation ? oldRepresentations[k].index._update(newRepresentation.index) : 
                                /* tslint:disable:max-line-length */
                                log.a.warn('manifest: representation "' + oldRepresentations[k].id + '" not found when merging.');
                            }, k = 0; k < oldRepresentations.length; k++) _loop3(k); else log.a.warn('manifest: adaptation "' + oldAdaptations[j].id + '" not found when merging.');
                        }, j = 0; j < oldAdaptations.length; j++) _loop2(j);
                    } else log.a.info("Period " + oldPeriod.id + " not found after update. Removing."), 
                    oldPeriods.splice(_i, 1), _i--;
                    i = _i;
                }, i = 0; i < oldPeriods.length; i++) _loop(i);
                // adding - perhaps - new Period[s]
                                if (newPeriods.length > oldPeriods.length) {
                    var lastOldPeriod = oldPeriods[oldPeriods.length - 1];
                    if (lastOldPeriod) for (i = 0; i < newPeriods.length - 1; i++) {
                        var _newPeriod = newPeriods[i];
                        _newPeriod.start > lastOldPeriod.start && (log.a.info("Adding new period " + _newPeriod.id), 
                        this.periods.push(_newPeriod));
                    } else for (var _i2 = 0; _i2 < newPeriods.length - 1; _i2++) {
                        var _newPeriod2 = newPeriods[_i2];
                        log.a.info("Adding new period " + _newPeriod2.id), this.periods.push(_newPeriod2);
                    }
                }
            }, Manifest;
        }();
        /* harmony default export */        
        // CONCATENATED MODULE: ./src/manifest/factory.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Run multiple checks before creating the Manifest:
 *   - filter out unsupported adaptation types
 *   - filter out adaptations without representations
 *   - filter out representations with an unsupported codec
 *   - check that every periods have at least one adaptation left
 *   - check that every adaptations have at least one representation left
 *
 * Then create a manifest and:
 *   - add supplementary text tracks
 *   - add supplementary image tracks
 *
 * @param {Object} manifest - the parsed manifest
 * @param {Array.<Object>|Object} externalTextTracks - Will be added to the
 * manifest as an adaptation.
 * @param {Array.<Object>|Object} externalImageTracks - Will be added to the
 * manifest as an adaptation.
 * @returns {Object}
 */
        function createManifest(manifestObject, externalTextTracks, externalImageTracks, warning$) {
            manifestObject.periods = manifestObject.periods.map(function(period) {
                if (Object.keys(period.adaptations).forEach(function(type) {
                    var adaptationsForType = period.adaptations[type];
                    if (adaptationsForType) {
                        var checkedAdaptations = checkAdaptations(adaptationsForType, warning$);
                        checkAdaptations.length ? period.adaptations[type] = checkedAdaptations : delete period.adaptations[type];
                    } else delete period.adaptations[type];
                }), !period.adaptations.video && !period.adaptations.audio) throw new MediaError.a("MANIFEST_PARSE_ERROR", null, !0);
                return period;
            });
            // TODO Better way than this "as"
            var manifest = new src_manifest(manifestObject);
            return manifest.addSupplementaryTextAdaptations(externalTextTracks), manifest.addSupplementaryImageAdaptations(externalImageTracks), 
            manifest;
        }
        /**
 * Performs multiple checks on adaptations from a single period (things not
 * check-able by TypeScript itself like length of arrays).
 * Also filter unsupported codecs and unsupported adaptations types.
 * Throws if something is wrong.
 *
 * @param {Array.<Object>} initialAdaptations
 * @returns {Array.<Object>}
 */        function checkAdaptations(initialAdaptations, warning$) {
            return initialAdaptations.filter(function(adaptation) {
                return !!Object(array_includes.a)(SUPPORTED_ADAPTATIONS_TYPE, adaptation.type) || (log.a.info("not supported adaptation type", adaptation.type), 
                warning$.next(new MediaError.a("MANIFEST_UNSUPPORTED_ADAPTATION_TYPE", null, !1)), 
                !1);
            }).map(function(adaptation) {
                if (adaptation.representations.length && (
                // 2. Filter from codecs and throw if none supported
                adaptation.representations = filterSupportedRepresentations(adaptation.type, adaptation.representations), 
                0 === adaptation.representations.length)) {
                    log.a.warn("Incompatible codecs for adaptation", adaptation);
                    var error = new MediaError.a("MANIFEST_INCOMPATIBLE_CODECS_ERROR", null, !1);
                    warning$.next(error);
                }
                return adaptation;
            }).filter(function(_ref) {
                return _ref.representations.length;
            });
        }
        /**
 * @param {string} adaptationType
 * @param {Array.<Object>} representations
 * @returns {Array.<Object>}
 */        function filterSupportedRepresentations(adaptationType, representations) {
            return "audio" === adaptationType || "video" === adaptationType ? representations.filter(function(representation) {
                return Object(compat.f)(getCodec(representation));
            }) : representations;
            // TODO for the other types
                        /**
     * Construct the codec string from given codecs and mimetype.
     * @param {Object} representation
     * @returns {string}
     */
            function getCodec(representation) {
                var _representation$codec = representation.codecs, codecs = void 0 === _representation$codec ? "" : _representation$codec, _representation$mimeT = representation.mimeType;
                return (void 0 === _representation$mimeT ? "" : _representation$mimeT) + ';codecs="' + codecs + '"';
            }
        }
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Observable.js + 2 modules
                var Observable = __webpack_require__(6), errors = __webpack_require__(22), RequestError = __webpack_require__(81), NetworkError = __webpack_require__(91), OtherError = __webpack_require__(92), rx_tryCatch = __webpack_require__(45), backoff = __webpack_require__(64);
        // EXTERNAL MODULE: ./src/errors/index.ts
                // CONCATENATED MODULE: ./src/core/pipelines/backoff.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Called on a pipeline's loader error.
 * Returns whether the loader request should be retried.
 * @param {Error} error
 * @returns {Boolean}
 */
        function shouldRetry(error) {
            return error instanceof RequestError.a && (error.type === constants.c.ERROR_HTTP_CODE ? error.status >= 500 || 404 === error.status : error.type === constants.c.TIMEOUT || error.type === constants.c.ERROR_EVENT);
        }
        function isOfflineRequestError(error) {
            return error.type === constants.c.ERROR_EVENT && Object(compat.g)();
        }
        /**
 * Specific exponential backoff algorithm used for segments/manifest
 * downloading.
 *
 * The specificty here in comparaison to a "regular" backoff algorithm is
 * the separation between type of errors:
 *   - "offline" errors
 *   - other xhr errors
 * Both have their own counters which are resetted if the error type changes.
 * @param {Observable} obs$
 * @param {Object} options - Configuration options.
 * @returns {Observable}
 */        
        /* harmony default export */ var pipelines_backoff = function downloadingBackoff(obs$, options) {
            var baseDelay = options.baseDelay, maxDelay = options.maxDelay, maxRetryRegular = options.maxRetryRegular, maxRetryOffline = options.maxRetryOffline, onRetry = options.onRetry, retryCount = 0, ERROR_TYPES_REGULAR = 1, ERROR_TYPES_OFFLINE = 2, lastError = 0;
            return obs$.pipe(Object(catchError.a)(function(error, source) {
                if (!shouldRetry(error)) throw error;
                var currentError = error instanceof RequestError.a && isOfflineRequestError(error) ? ERROR_TYPES_OFFLINE : ERROR_TYPES_REGULAR;
                if (currentError !== lastError && (retryCount = 0, lastError = currentError), ++retryCount > (currentError === ERROR_TYPES_OFFLINE ? maxRetryOffline : maxRetryRegular)) throw error;
                onRetry && onRetry(error, retryCount);
                var delay = Math.min(baseDelay * Math.pow(2, retryCount - 1), maxDelay), fuzzedDelay = Object(backoff.b)(delay);
                return Object(timer.a)(fuzzedDelay).pipe(Object(mergeMap.a)(function() {
                    return source;
                }));
            }));
        }, MAX_BACKOFF_DELAY_BASE = config.a.MAX_BACKOFF_DELAY_BASE, INITIAL_BACKOFF_DELAY_BASE = config.a.INITIAL_BACKOFF_DELAY_BASE;
        // CONCATENATED MODULE: ./src/core/pipelines/core_pipeline.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        
        /**
 * Generate a new error from the infos given.
 * Also attach the pipeline type (audio/manifest...) to the _pipelineType_
 * property of the returned error.
 * @param {string} code
 * @param {Error} error
 * @param {Boolean} [fatal=true] - Whether the error is fatal to the content's
 * playback.
 * @returns {Error}
 */
        function errorSelector(code, error) {
            var fatal = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
            return Object(errors.a)(error) ? error : error instanceof RequestError.a ? new NetworkError.a(code, error, fatal) : new OtherError.a(code, error, fatal);
        }
        /**
 * TODO All that any casting is ugly
 *
 * Returns function allowing to download the wanted transport object through
 * the resolver -> loader -> parser pipeline.
 *
 * (A transport object can be for example: the manifest, audio and video
 * segments, text, images...)
 *
 * The function returned takes the initial data in arguments and returns an
 * Observable which will emit:
 *
 *   - each time a request begins (type "request").
 *     This is not emitted if the value is retrieved from a local js cache.
 *     This one emit the payload as a value.
 *
 *   - as the request progresses (type "progress").
 *
 *   - each time a request ends (type "metrics").
 *     This one contains informations about the metrics of the request.
 *
 *   - each time a minor request error is encountered (type "error").
 *     With the error as a value.
 *
 *   - Lastly, with the obtained data (type "data" or "cache).
 *
 *
 * Each of these but "error" can be emitted at most one time.
 *
 * This observable will throw if, following the options given, the request and
 * possible retry all failed.
 *
 * This observable will complete after emitting the data.
 *
 * @param {Object} transportObject
 * @param {Object} options
 * @returns {Function}
 *
 * Type parameters:
 *   T: Argument given to the Net's loader
 *   U: ResponseType of the request
 *   V: Response given by the Net's parser
 */        function core_pipeline_createPipeline(transportPipeline, options) {
            var cache = options.cache, maxRetry = options.maxRetry, maxRetryOffline = options.maxRetryOffline, loader = transportPipeline.loader, parser = transportPipeline.parser, resolver = null != transportPipeline.resolver ? transportPipeline.resolver : of.a.bind(Observable.a), retryErrorSubject = new Subject.a(), backoffOptions = {
                baseDelay: INITIAL_BACKOFF_DELAY_BASE,
                maxDelay: MAX_BACKOFF_DELAY_BASE,
                maxRetryRegular: maxRetry,
                maxRetryOffline: maxRetryOffline,
                onRetry: function onRetry(error) {
                    retryErrorSubject.next(errorSelector("PIPELINE_LOAD_ERROR", error, !1));
                }
            };
            /**
     * Call the transport's resolver - if it exists - with the given data.
     *
     * Throws with the right error if it fails.
     * @param {Object} resolverArgument
     * @returns {Observable}
     */
            function callResolver(resolverArgument) {
                return Object(rx_tryCatch.a)(resolver, resolverArgument).pipe().pipe(Object(catchError.a)(function(error) {
                    throw errorSelector("PIPELINE_RESOLVE_ERROR", error);
                }));
            }
            /**
     * Load wanted data:
     *   - get it from cache if present
     *   - call the transport loader - with an exponential backoff - if not
     *
     * @param {Object} loaderArgument - Input given to the loader
     */            function loadData(loaderArgument) {
                /**
         * Call the Pipeline's loader with an exponential Backoff.
         * @returns {Observable}
         */
                function startLoaderWithBackoff() {
                    var request$ = pipelines_backoff(Object(rx_tryCatch.a)(loader, loaderArgument), backoffOptions).pipe(Object(catchError.a)(function(error) {
                        throw errorSelector("PIPELINE_LOAD_ERROR", error);
                    }), Object(tap.a)(function(arg) {
                        "response" === arg.type && cache && cache.add(loaderArgument, arg.value);
                    }));
                    return Object(concat.a)(Object(of.a)({
                        type: "request",
                        value: loaderArgument
                    }), request$);
                }
                var dataFromCache = cache ? cache.get(loaderArgument) : null;
                return null != dataFromCache ? Object(castToObservable.a)(dataFromCache).pipe(Object(map.a)(function(response) {
                    return {
                        type: "cache",
                        value: response
                    };
                }), Object(catchError.a)(startLoaderWithBackoff)) : startLoaderWithBackoff();
            }
            /**
     * Call the transport's parser with the given data.
     *
     * Throws with the right error if it fails.
     * @param {Object} parserArgument
     * @returns {Observable}
     */            function callParser(parserArgument) {
                return Object(rx_tryCatch.a)(parser, parserArgument).pipe().pipe(Object(catchError.a)(function(error) {
                    throw errorSelector("PIPELINE_PARSING_ERROR", error);
                }));
            }
            return function startPipeline(pipelineInputData) {
                var pipeline$ = callResolver(pipelineInputData).pipe(Object(mergeMap.a)(function(resolverResponse) {
                    return loadData(resolverResponse).pipe(Object(mergeMap.a)(function(arg) {
                        // "cache": data taken from cache by the pipeline
                        // "data": the data is available but no request has been done
                        // "response": data received through a request
                        switch (arg.type) {
                          case "cache":
                          case "data":
                          case "response":
                            var loaderResponse = arg.value, loadedDataInfos = object_assign_default()({
                                response: loaderResponse
                            }, resolverResponse), metrics = "response" === arg.type ? Object(of.a)({
                                type: "metrics",
                                value: {
                                    size: arg.value.size,
                                    duration: arg.value.duration
                                }
                            }) : empty.a;
                            return Object(concat.a)(metrics, callParser(loadedDataInfos).pipe(Object(map.a)(function(parserResponse) {
                                return {
                                    type: "data",
                                    value: object_assign_default()({
                                        parsed: parserResponse
                                    }, loadedDataInfos)
                                };
                            })));

                          default:
                            return Object(of.a)(arg);
                        }
                    }));
                }), finalize(function() {
                    retryErrorSubject.complete();
                })), retryError$ = retryErrorSubject.pipe(Object(map.a)(function(error) {
                    return {
                        type: "error",
                        value: error
                    };
                }));
                return Object(merge.a)(pipeline$, retryError$);
            };
        }
        // CONCATENATED MODULE: ./src/core/pipelines/manifest/index.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Create function allowing to easily fetch and parse the manifest from its URL.
 *
 * @example
 * ```js
 * const manifestPipeline = createManifestPipeline(transport, warning$);
 * manifestPipeline(manifestURL)
 *  .subscribe(manifest => console.log("Manifest:", manifest));
 * ```
 *
 * @param {Object} transport
 * @param {Subject} warning$
 * @param {Array.<Object>|undefined} supplementaryTextTracks
 * @param {Array.<Object>|undefined} supplementaryImageTrack
 * @returns {Function}
 */        function createManifestPipeline(transport, pipelineOptions, warning$) {
            var supplementaryTextTracks = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : [], supplementaryImageTracks = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : [];
            return function fetchManifest(url) {
                return core_pipeline_createPipeline(transport.manifest, pipelineOptions)({
                    url: url
                }).pipe(Object(tap.a)(function(arg) {
                    "error" === arg.type && warning$.next(arg.value);
                }), Object(filter.a)(function(arg) {
                    return "data" === arg.type || "cache" === arg.type;
                }), Object(map.a)(function(_ref) {
                    return createManifest(_ref.value.parsed.manifest, supplementaryTextTracks, supplementaryImageTracks, warning$);
                }), Object(share.a)());
            };
        }
        // CONCATENATED MODULE: ./src/core/pipelines/segment/prioritized_segment_fetcher.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * This function basically put in relation:
 *   - a SegmentFetcher, which will be used to perform the segment request
 *   - a prioritizer, which will handle the priority of a segment request
 *
 * and returns functions to fetch segments with a given priority.
 * @returns {Object}
 */        function applyPrioritizerToSegmentFetcher(prioritizer, fetcher) {
            return {
                /**
     * Create a Segment request with a given priority.
     * @param {Object} content - content to request
     * @param {Number} priority - priority at which the content should be
     * requested.
     * @returns {Observable}
     */
                createRequest: function createRequest(content) {
                    var priority = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                    return prioritizer.create(fetcher(content), priority);
                },
                /**
     * Update the priority of a pending request, created through createRequest.
     * @param {Observable} observable - the corresponding request
     * @param {Number} priority
     */
                updatePriority: function updatePriority(observable, priority) {
                    prioritizer.updatePriority(observable, priority);
                }
            };
        }
        // CONCATENATED MODULE: ./src/core/pipelines/segment/prioritizer.ts
                function prioritizer_classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Create Observables which can be priorized between one another.
 *
 * With this class, you can create Observables with linked priority numbers.
 * The lower this number is, the more priority the resulting Observable will
 * have.
 *
 * Such Observable will then basically wait for pending Observables with more
 * priority to finish before "starting".
 *
 * You can also update the priority of an already-created Observable.
 * This will only have an effect if the Observable is currently "waiting" for
 * its turn (started observable won't be canceled if their priority were
 * lowered).
 *
 * ```js
 * const prioritizer = new ObservablePrioritizer();
 *
 * const observable1 = Observable.of(1);
 * const observable2 = Observable.of(2);
 * const observable3 = Observable.of(3);
 * const observable4 = Observable.of(4);
 * const observable5 = Observable.of(5);
 *
 * const pObservable1 = prioritizer.create(observable1, 4);
 * const pObservable2 = prioritizer.create(observable2, 2);
 * const pObservable3 = prioritizer.create(observable3, 1);
 * const pObservable4 = prioritizer.create(observable4, 3);
 * const pObservable5 = prioritizer.create(observable5, 2);
 *
 * // start every Observables at the same time
 * observableMerge(
 *   pObservable1,
 *   pObservable2,
 *   pObservable3,
 *   pObservable4,
 *   pObservable5
 * ).subscribe((i) => {
 *   // To spice things up, update pObservable1 priority to go before
 *   // pObservable4
 *   if (i === 5) { // if pObservable5 is currently emitting
 *     prioritizer.updatePriority(pObservable1, 1);
 *   }
 *   console.log(i);
 * });
 *
 * // Result:
 * // 3
 * // 2
 * // 5
 * // 1
 * // 4
 *
 * // Note: here "1" goes before "4" only because the former's priority has been
 * // updated before the latter was started.
 * // It would be the other way around if not.
 * ```
 *
 * @class ObservablePrioritizer
 */        var prioritizer = function() {
            function ObservablePrioritizer() {
                prioritizer_classCallCheck(this, ObservablePrioritizer), this._pendingPriority = null, 
                this._numberOfPendingObservables = 0, this._queue = [];
            }
            /**
     * Create a priorized Observable from a base Observable.
     *
     * When subscribed to, this Observable will have its priority compared to
     * all the already-running Observables created from this class.
     * Only if this number is inferior or equal to the priority of the
     * currently-running Observables will it be immediately started.
     * In the opposite case, we will wait for higher-priority Observables to
     * finish before starting it.
     *
     * Note that while this Observable is waiting for its turn, it is possible
     * to update its property through the updatePriority method, by providing
     * the Observable returned by this function and its new priority number.
     *
     * @param {Observable} obs
     * @param {number} priority
     * @returns {Observable}
     */            return ObservablePrioritizer.prototype.create = function create(obs, priority) {
                var _this = this;
                return Object(defer.a)(function() {
                    if (null == _this._pendingPriority || _this._pendingPriority >= priority) 
                    // Update the priority and start immediately the Observable
                    return _this._pendingPriority = priority, _this._startObservable(obs);
                    var trigger = new Subject.a();
                    return _this._queue.push({
                        observable: obs,
                        priority: priority,
                        trigger: trigger
                    }), trigger.pipe(Object(mergeMap.a)(function() {
                        return _this._startObservable(obs);
                    }));
                });
            }, 
            /**
     * Update the priority of an Observable created through the create method.
     *
     * Note that this will only have an effect on Observable which are not yet
     * started.
     * This means it will only have an effect on:
     *   - unsubscribed Observables
     *   - Observables waiting for Observables with an higher priority to
     *     finish
     *
     * @param {Observable} obs
     * @param {number} priority
     */
            ObservablePrioritizer.prototype.updatePriority = function updatePriority(obs, priority) {
                var queueElement = find_default()(this._queue, function(elt) {
                    return elt.observable === obs;
                });
                queueElement && (queueElement.priority = priority);
            }, ObservablePrioritizer.prototype._startObservable = function _startObservable(obs) {
                var _this2 = this;
                return this._numberOfPendingObservables++, obs.pipe(finalize(function onObservableFinish() {
                    if (_this2._numberOfPendingObservables--, !(_this2._numberOfPendingObservables > 0) && (_this2._pendingPriority = null, 
                    0 !== _this2._queue.length)) {
                        _this2._pendingPriority = _this2._queue.reduce(function(acc, elt) {
                            return null == acc || acc > elt.priority ? elt.priority : acc;
                        }, null);
                        for (var i = 0; i < _this2._queue.length; i++) {
                            var elt = _this2._queue[i];
                            elt.priority === _this2._pendingPriority && (_this2._queue.splice(i, 1), i--, elt.trigger.next(), 
                            elt.trigger.complete());
                        }
                    }
                }));
            }, ObservablePrioritizer;
        }();
        /* harmony default export */        
        // CONCATENATED MODULE: ./src/core/pipelines/segment/segment_fetcher.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Create a function which will fetch segments.
 *
 * This function will:
 *   - only emit the resulting data
 *   - dispatch the other infos through the right subjects.
 *
 * @param {string} bufferType
 * @param {Object} transport
 * @param {Subject} network$ - Subject through which network metrics will be
 * sent, for the ABR.
 * @param {Subject} requests$ - Subject through which requests infos will be
 * sent, for the ABR.
 * @param {Subject} warning$ - Subject through which minor requests error will
 * be sent.
 * @param {Object} options
 * @returns {Function}
 */
        function createSegmentFetcher(bufferType, transport, network$, requests$, warning$, options) {
            var basePipeline$ = core_pipeline_createPipeline(transport[bufferType], options), request$ = void 0, id = void 0;
            /**
     * Process a pipeline observable to adapt it to the Stream way:
     *   - use the network$ subject for network metrics (bandwitdh mesure)
     *   - use the requests subject for network requests and their progress
     *   - use the warning$ subject for retries' error messages
     *   - only emit the data
     * @param {string} pipelineType
     * @param {Observable} pipeline$
     * @returns {Observable}
     */
            return function fetchSegment(content) {
                return basePipeline$(content).pipe(Object(tap.a)(function(arg) {
                    switch (arg.type) {
                      case "error":
                        warning$.next(object_assign_default()(arg.value, {
                            pipelineType: bufferType
                        }));
                        break;

                      case "metrics":
                        var value = arg.value, size = value.size, duration = value.duration;
                        // unwrapping for TS
                        // format it for ABR Handling
                        null != size && null != duration && network$.next({
                            type: bufferType,
                            value: {
                                size: size,
                                duration: duration
                            }
                        });
                        break;

                      case "request":
                        var _value = arg.value, segment = _value && _value.segment;
                        // format it for ABR Handling
                                                if (null != segment && null != segment.duration) {
                            request$ = new Subject.a(), requests$.next(request$);
                            var _duration = segment.duration / segment.timescale, time = segment.time / segment.timescale;
                            id = Object(utils_id.a)(), request$.next({
                                type: bufferType,
                                event: "requestBegin",
                                value: {
                                    duration: _duration,
                                    time: time,
                                    requestTimestamp: Date.now(),
                                    id: id
                                }
                            });
                        }
                        break;

                      case "progress":
                        var _value2 = arg.value;
                        null != _value2.totalSize && _value2.size < _value2.totalSize && null != id && null != request$ && request$.next({
                            type: bufferType,
                            event: "progress",
                            value: {
                                duration: _value2.duration,
                                size: _value2.size,
                                totalSize: _value2.totalSize,
                                timestamp: Date.now(),
                                id: id
                            }
                        });
                    }
                }), Object(filter.a)(function(arg) {
                    return "data" === arg.type || "cache" === arg.type;
                }), 
                // take only value from data/cache events
                Object(map.a)(function(_ref) {
                    return _ref.value;
                }), finalize(function() {
                    null != request$ && (null != id && request$.next({
                        type: bufferType,
                        event: "requestEnd",
                        value: {
                            id: id
                        }
                    }), request$.complete());
                }), Object(share.a)());
            };
        }
        // CONCATENATED MODULE: ./src/core/pipelines/segment/index.ts
                function segment_classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Interact with the networking pipelines to download segments and dispatch
 * the related events to the right subjects.
 *
 * @class SegmentPipelinesManager
 *
 * @example
 * ```js
 * const requests$ = new Subject();
 * const metrics$ = new Subject();
 * const warnings$ = new Subject();
 *
 * // 1 - create the manager
 * const segmentPipelinesManager =
 *   new SegmentPipelinesManager(transport, requests$, metrics$, warnings$);
 *
 * // Note:
 * // You can create an ABRManager with the same requests$ and metrics$ subjects.
 * // It will then be informed of when the SegmentPipelinesManager downloads
 * // segments and with which metrics.
 * // The format of those events is kept the same for ease of use.
 * const abrManager = new ABRManager(requests$, metrics$);
 *
 * // 2 - create a new pipeline with its own options
 * const pipeline = segmentPipelinesManager.createPipeline("audio", {
 *   maxRetry: Infinity,
 *   maxRetryOffline: Infinity,
 * });
 *
 * // 3 - request a content with a given priority
 * pipeline.createRequest(myContent, 1)
 *   .subscribe((res) => console.log("audio segment downloaded:", res));
 * ```
 */        var SourceBufferAction, pipelines_segment = function() {
            /**
   * @param {Object} transport
   * @param {Subject} requestsInfos$
   * @param {Subject} metrics$
   * @param {Subject} warning
   */
            function SegmentPipelinesManager(transport, requestsInfos$, metrics$, warning) {
                segment_classCallCheck(this, SegmentPipelinesManager), this._transport = transport, 
                this._metrics$ = metrics$, this._requestsInfos$ = requestsInfos$, this._warning$ = warning, 
                this._prioritizer = new prioritizer();
            }
            /**
   * @param {string} bufferType
   * @param {Object} options
   * @returns {Function}
   */            return SegmentPipelinesManager.prototype.createPipeline = function createPipeline(bufferType, options) {
                var segmentFetcher = createSegmentFetcher(bufferType, this._transport, this._metrics$, this._requestsInfos$, this._warning$, options);
                return applyPrioritizerToSegmentFetcher(this._prioritizer, segmentFetcher);
            }, SegmentPipelinesManager;
        }();
        /* harmony default export */        
        // CONCATENATED MODULE: ./src/core/source_buffers/queued_source_buffer.ts
        function queued_source_buffer_classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        !function(SourceBufferAction) {
            SourceBufferAction[SourceBufferAction.Append = 0] = "Append", SourceBufferAction[SourceBufferAction.Remove = 1] = "Remove";
        }(SourceBufferAction || (SourceBufferAction = {}));
        /**
 * Wrap a SourceBuffer and append/remove segments in it in a queue.
 *
 * Wait for the previous buffer action to be finished (updateend event) to
 * perform the next in the queue.
 *
 * To work correctly, only a single QueuedSourceBuffer per SourceBuffer should
 * be created.
 *
 * @class QueuedSourceBuffer
 */
        var queued_source_buffer = function() {
            /**
     * @constructor
     * @param {SourceBuffer} sourceBuffer
     */
            function QueuedSourceBuffer(sourceBuffer) {
                queued_source_buffer_classCallCheck(this, QueuedSourceBuffer), this._buffer = sourceBuffer, 
                this._queue = [], this._flushing = null, this._lastInitSegment = null, this.__onUpdate = this._onUpdate.bind(this), 
                this.__onError = this._onError.bind(this), this.__flush = this._flush.bind(this), 
                this._buffer.addEventListener("update", this.__onUpdate), this._buffer.addEventListener("error", this.__onError), 
                this._buffer.addEventListener("updateend", this.__flush);
            }
            /**
     * Append media segment to the attached SourceBuffer, in a FIFO queue.
     *
     * Depending on the type of data appended, this might need an associated
     * initialization segment.
     *
     * Such initialization segment will be pushed in the SourceBuffer if the
     * last segment pushed was associated to another initialization segment.
     * This detection is entirely reference-based so make sure that the same
     * initSegment argument given share the same reference.
     *
     * You can deactivate the usage of initialization segment by setting the
     * initSegment argument to null.
     *
     * You can also only push an initialization segment by setting the segment
     * argument to null.
     * @param {*|null} initSegment
     * @param {*|null} segment
     * @param {number|undefined} timestampOffset
     * @returns {Observable}
     */            return QueuedSourceBuffer.prototype.appendBuffer = function appendBuffer(initSegment, segment, timestampOffset) {
                var _this = this;
                return Object(defer.a)(function() {
                    return _this._addToQueue({
                        type: SourceBufferAction.Append,
                        segment: segment,
                        initSegment: initSegment,
                        timestampOffset: timestampOffset
                    });
                });
            }, 
            /**
     * Remove data from the attached SourceBuffer, in a FIFO queue.
     * @param {Object} range - Range of positions. With two properties:
     *   - start {Number} - start position, in seconds
     *   - end {Number} - end position, in seconds
     * @returns {Observable}
     */
            QueuedSourceBuffer.prototype.removeBuffer = function removeBuffer(_ref) {
                var _this2 = this, start = _ref.start, end = _ref.end;
                return Object(defer.a)(function() {
                    return _this2._addToQueue({
                        type: SourceBufferAction.Remove,
                        start: start,
                        end: end
                    });
                });
            }, 
            /**
     * Abort the linked SourceBuffer and dispose of the ressources used by this
     * QueuedSourceBuffer.
     *
     * /!\ You won't be able to use the QueuedSourceBuffer after calling this
     * function.
     * @private
     */
            QueuedSourceBuffer.prototype.abort = function abort() {
                this.dispose(), this._buffer.abort();
            }, 
            /**
     * Returns the currently buffered data, in a TimeRanges object.
     * @returns {TimeRanges}
     */
            QueuedSourceBuffer.prototype.getBuffered = function getBuffered() {
                return this._buffer.buffered;
            }, 
            /**
     * Free up ressources used by this class.
     *
     * /!\ You won't be able to use the QueuedSourceBuffer after calling this
     * function.
     */
            QueuedSourceBuffer.prototype.dispose = function dispose() {
                this._buffer.removeEventListener("update", this.__onUpdate), this._buffer.removeEventListener("error", this.__onError), 
                this._buffer.removeEventListener("updateend", this.__flush), this._queue.length = 0, 
                this._flushing = null;
            }, 
            /**
     * Callback used for the 'update' event, as a segment has been added/removed.
     *
     * Emit and complete the corresponding subject to inform the action caller
     * of completion.
     *
     * @private
     */
            QueuedSourceBuffer.prototype._onUpdate = function _onUpdate() {
                this._flushing && (this._flushing.next(void 0), this._flushing.complete(), this._flushing = null);
            }, 
            /**
     * Callback used for the 'error' event from the SourceBuffer.
     *
     * Emit the error through the corresponding subject to inform the action
     * caller.
     *
     * @private
     * @param {Error} error
     */
            QueuedSourceBuffer.prototype._onError = function _onError(error) {
                this._flushing && (this._flushing.error(error), this._flushing = null);
            }, 
            /**
     * Queue a new action.
     * Begin flushing if no action were previously in the queue.
     * @private
     * @param {Object} action
     * @returns {Subject} - Can be used to follow the buffer action advancement.
     */
            QueuedSourceBuffer.prototype._addToQueue = function _addToQueue(action) {
                var shouldFlush = !this._queue.length, subject = new Subject.a();
                if (action.type === SourceBufferAction.Append) {
                    var segment = action.segment, initSegment = action.initSegment, timestampOffset = action.timestampOffset;
                    if (null === initSegment && null === segment) return log.a.warn("QueuedSourceBuffer: no segment appended."), 
                    Object(of.a)(void 0);
                    if (null === initSegment) this._queue.unshift({
                        type: SourceBufferAction.Append,
                        args: {
                            segment: segment,
                            timestampOffset: timestampOffset
                        },
                        subject: subject
                    }); else if (null === segment) {
                        if (this._lastInitSegment === initSegment) return Object(of.a)(void 0);
                        this._queue.unshift({
                            type: SourceBufferAction.Append,
                            args: {
                                segment: initSegment,
                                timestampOffset: timestampOffset
                            },
                            subject: subject
                        });
                    } else this._lastInitSegment !== initSegment && this._queue.unshift({
                        type: SourceBufferAction.Append,
                        args: {
                            segment: initSegment,
                            timestampOffset: timestampOffset
                        },
                        subject: null
                    }), this._queue.unshift({
                        type: SourceBufferAction.Append,
                        args: {
                            segment: segment,
                            timestampOffset: timestampOffset
                        },
                        subject: subject
                    });
                    this._lastInitSegment = initSegment;
                } else {
                    if (action.type !== SourceBufferAction.Remove) throw new Error("QueuedSourceBuffer: unrecognized action");
                    this._queue.unshift({
                        type: SourceBufferAction.Remove,
                        args: {
                            start: action.start,
                            end: action.end
                        },
                        subject: subject
                    });
                }
                return shouldFlush && this._flush(), subject.pipe(Object(mapTo.a)(void 0));
            }, 
            /**
     * Perform next queued action if one and none are pending.
     * @private
     */
            QueuedSourceBuffer.prototype._flush = function _flush() {
                if (!this._flushing && 0 !== this._queue.length && !this._buffer.updating) {
                    // TODO TypeScrypt do not get the previous length check? Find solution /
                    // open issue
                    var queueItem = this._queue.pop();
                    this._flushing = queueItem.subject;
                    try {
                        switch (queueItem.type) {
                          case SourceBufferAction.Append:
                            var _queueItem$args = queueItem.args, segment = _queueItem$args.segment, _queueItem$args$times = _queueItem$args.timestampOffset, timestampOffset = void 0 === _queueItem$args$times ? 0 : _queueItem$args$times;
                            if (this._buffer.timestampOffset !== timestampOffset) {
                                var newTimestampOffset = timestampOffset || 0;
                                log.a.debug("updating timestampOffset", this._buffer.timestampOffset, newTimestampOffset), 
                                this._buffer.timestampOffset = newTimestampOffset;
                            }
                            log.a.debug("pushing data to source buffer", queueItem.args), this._buffer.appendBuffer(segment);
                            break;

                          case SourceBufferAction.Remove:
                            var _queueItem$args2 = queueItem.args, start = _queueItem$args2.start, end = _queueItem$args2.end;
                            log.a.debug("removing data from source buffer", start, end), this._buffer.remove(start, end);
                        }
                    } catch (e) {
                        this._onError(e);
                    }
                }
            }, QueuedSourceBuffer;
        }();
        /* harmony default export */        
        // CONCATENATED MODULE: ./src/core/source_buffers/index.ts
        function source_buffers_classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        var POSSIBLE_BUFFER_TYPES = [ "audio", "video", "text", "image" ];
        /**
 * Get all currently available buffer types.
 * /!\ This list can evolve at runtime depending on feature switching.
 * @returns {Array.<string>}
 */        function getBufferTypes() {
            var bufferTypes = [ "audio", "video" ];
            return null == features.a.nativeTextTracksBuffer && null == features.a.htmlTextTracksBuffer || bufferTypes.push("text"), 
            null != features.a.imageBuffer && bufferTypes.push("image"), bufferTypes;
        }
        /**
 * Allows to easily create and dispose SourceBuffers.
 *
 * Only one source buffer per type is allowed at the same time:
 *
 *   - source buffers for native types (which depends on the native
 *     SourceBuffer implementation), are reused if one is re-created.
 *
 *   - source buffers for custom types are aborted each time a new one of the
 *     same type is created.
 *
 * The returned SourceBuffer is actually a QueuedSourceBuffer instance which
 * wrap a SourceBuffer implementation to queue all its actions.
 *
 * @class SourceBufferManager
 */        var source_buffers = function() {
            /**
     * @param {HTMLMediaElement} videoElement
     * @param {MediaSource} mediaSource
     * @constructor
     */
            function SourceBufferManager(videoElement, mediaSource) {
                source_buffers_classCallCheck(this, SourceBufferManager), this._videoElement = videoElement, 
                this._mediaSource = mediaSource, this._initializedNativeSourceBuffers = {}, this._initializedCustomSourceBuffers = {};
            }
            /**
     * Returns true if a SourceBuffer with the type given has been created with
     * this instance of the SourceBufferManager.
     * @param {string} bufferType
     * @returns {Boolean}
     */            
            /**
     * Returns true if the source buffer is "native" (has to be attached to the
     * mediaSource at the beginning of the stream.
     * @static
     * @param {string} bufferType
     * @returns {Boolean}
     */
            return SourceBufferManager.isNative = function isNative(bufferType) {
                return shouldHaveNativeSourceBuffer(bufferType);
            }, SourceBufferManager.prototype.has = function has(bufferType) {
                return shouldHaveNativeSourceBuffer(bufferType) ? !!this._initializedNativeSourceBuffers[bufferType] : !!this._initializedCustomSourceBuffers[bufferType];
            }, 
            /**
     * Returns the created QueuedSourceBuffer for the given type.
     * Throws if no QueuedSourceBuffer were created for the given type.
     *
     * @param {string} bufferType
     * @returns {QueuedSourceBuffer}
     */
            SourceBufferManager.prototype.get = function get(bufferType) {
                if (shouldHaveNativeSourceBuffer(bufferType)) {
                    var sourceBufferInfos = this._initializedNativeSourceBuffers[bufferType];
                    if (!sourceBufferInfos) throw new Error("SourceBufferManager: no " + bufferType + " initialized yet");
                    return sourceBufferInfos.sourceBuffer;
                }
                var _sourceBufferInfos = this._initializedCustomSourceBuffers[bufferType];
                if (!_sourceBufferInfos) throw new Error("SourceBufferManager: no " + bufferType + " initialized yet");
                return _sourceBufferInfos.sourceBuffer;
            }, 
            /**
     * Creates a new QueuedSourceBuffer for the given buffer type.
     * Reuse an already created one if a QueuedSourceBuffer for the given type
     * already exists. TODO Throw or abort old one instead?
     * @param {string} bufferType
     * @param {string} codec
     * @param {Object|undefined} options
     * @returns {QueuedSourceBuffer}
     */
            SourceBufferManager.prototype.createSourceBuffer = function createSourceBuffer(bufferType, codec) {
                var options = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                if (shouldHaveNativeSourceBuffer(bufferType)) {
                    var memorizedSourceBuffer = this._initializedNativeSourceBuffers[bufferType];
                    if (memorizedSourceBuffer) return memorizedSourceBuffer.codec !== codec ? log.a.warn("reusing native SourceBuffer with codec", memorizedSourceBuffer.codec, "for codec", codec) : log.a.info("reusing native SourceBuffer with codec", codec), 
                    memorizedSourceBuffer.sourceBuffer;
                    log.a.info("adding native SourceBuffer with codec", codec);
                    var nativeSourceBuffer = createNativeQueuedSourceBuffer(this._mediaSource, codec);
                    return this._initializedNativeSourceBuffers[bufferType] = {
                        codec: codec,
                        sourceBuffer: nativeSourceBuffer
                    }, nativeSourceBuffer;
                }
                var memorizedCustomSourceBuffer = this._initializedCustomSourceBuffers[bufferType];
                if (memorizedCustomSourceBuffer) return log.a.info("reusing a previous custom SourceBuffer for the type", bufferType), 
                memorizedCustomSourceBuffer.sourceBuffer;
                if ("text" === bufferType) {
                    log.a.info("creating a new text SourceBuffer with codec", codec);
                    var sourceBuffer = void 0;
                    if ("html" === options.textTrackMode) {
                        if (null == features.a.htmlTextTracksBuffer) throw new Error("HTML Text track feature not activated");
                        sourceBuffer = new features.a.htmlTextTracksBuffer(this._videoElement, options.textTrackElement);
                    } else {
                        if (null == features.a.nativeTextTracksBuffer) throw new Error("Native Text track feature not activated");
                        sourceBuffer = new features.a.nativeTextTracksBuffer(this._videoElement, !!options.hideNativeSubtitle);
                    }
                    var queuedSourceBuffer = new queued_source_buffer(sourceBuffer);
                    return this._initializedCustomSourceBuffers.text = {
                        codec: codec,
                        sourceBuffer: queuedSourceBuffer
                    }, queuedSourceBuffer;
                }
                if ("image" === bufferType) {
                    if (null == features.a.imageBuffer) throw new Error("Image buffer feature not activated");
                    log.a.info("creating a new image SourceBuffer with codec", codec);
                    var _sourceBuffer = new features.a.imageBuffer(), _queuedSourceBuffer = new queued_source_buffer(_sourceBuffer);
                    return this._initializedCustomSourceBuffers.image = {
                        codec: codec,
                        sourceBuffer: _queuedSourceBuffer
                    }, _queuedSourceBuffer;
                }
                throw log.a.error("unknown buffer type:", bufferType), new MediaError.a("BUFFER_TYPE_UNKNOWN", null, !0);
            }, 
            /**
     * Dispose of the active SourceBuffer for the given type.
     * @param {string} bufferType
     */
            SourceBufferManager.prototype.disposeSourceBuffer = function disposeSourceBuffer(bufferType) {
                if (shouldHaveNativeSourceBuffer(bufferType)) {
                    var memorizedNativeSourceBuffer = this._initializedNativeSourceBuffers[bufferType];
                    if (null == memorizedNativeSourceBuffer) return;
                    if (log.a.info("aborting native source buffer", bufferType), "open" === this._mediaSource.readyState) try {
                        memorizedNativeSourceBuffer.sourceBuffer.abort();
                    } catch (e) {
                        log.a.warn("failed to abort a SourceBuffer:", e);
                    }
                    delete this._initializedNativeSourceBuffers[bufferType];
                } else if ("text" !== bufferType && "image" !== bufferType) log.a.error("cannot dispose an unknown buffer type", bufferType); else {
                    var memorizedSourceBuffer = this._initializedCustomSourceBuffers[bufferType];
                    if (null == memorizedSourceBuffer) return;
                    log.a.info("aborting custom source buffer", bufferType);
                    try {
                        memorizedSourceBuffer.sourceBuffer.abort();
                    } catch (e) {
                        log.a.warn("failed to abort a SourceBuffer:", e);
                    }
                    delete this._initializedCustomSourceBuffers[bufferType];
                }
            }, 
            /**
     * Dispose of all QueuedSourceBuffer created on this SourceBufferManager.
     */
            SourceBufferManager.prototype.disposeAll = function disposeAll() {
                var _this = this;
                POSSIBLE_BUFFER_TYPES.forEach(function(bufferType) {
                    _this.has(bufferType) && _this.disposeSourceBuffer(bufferType);
                });
            }, SourceBufferManager;
        }();
        /**
 * Adds a SourceBuffer to the MediaSource.
 * @param {MediaSource} mediaSource
 * @param {string} codec
 * @returns {SourceBuffer}
 */
        /* harmony default export */        function createNativeQueuedSourceBuffer(mediaSource, codec) {
            var sourceBuffer = mediaSource.addSourceBuffer(codec);
            return new queued_source_buffer(sourceBuffer);
        }
        /**
 * Returns true if the given buffeType is a native buffer, false otherwise.
 * "Native" source buffers are directly added to the MediaSource.
 * @param {string} bufferType
 * @returns {Boolean}
 */        function shouldHaveNativeSourceBuffer(bufferType) {
            return "audio" === bufferType || "video" === bufferType;
        }
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/exhaustMap.js
        /** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult,_map,_observable_from PURE_IMPORTS_END */        function exhaustMap(project, resultSelector) {
            return resultSelector ? function(source) {
                return source.pipe(exhaustMap(function(a, i) {
                    return Object(from.a)(project(a, i)).pipe(Object(map.a)(function(b, ii) {
                        return resultSelector(a, b, i, ii);
                    }));
                }));
            } : function(source) {
                return source.lift(new ExhauseMapOperator(project));
            };
        }
        var ExhauseMapOperator = /* */ function() {
            function ExhauseMapOperator(project) {
                this.project = project;
            }
            return ExhauseMapOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new exhaustMap_ExhaustMapSubscriber(subscriber, this.project));
            }, ExhauseMapOperator;
        }(), exhaustMap_ExhaustMapSubscriber = /* */ function(_super) {
            function ExhaustMapSubscriber(destination, project) {
                var _this = _super.call(this, destination) || this;
                return _this.project = project, _this.hasSubscription = !1, _this.hasCompleted = !1, 
                _this.index = 0, _this;
            }
            return tslib_es6.a(ExhaustMapSubscriber, _super), ExhaustMapSubscriber.prototype._next = function(value) {
                this.hasSubscription || this.tryNext(value);
            }, ExhaustMapSubscriber.prototype.tryNext = function(value) {
                var index = this.index++, destination = this.destination;
                try {
                    var result = this.project(value, index);
                    this.hasSubscription = !0, this.add(Object(subscribeToResult.a)(this, result, value, index));
                } catch (err) {
                    destination.error(err);
                }
            }, ExhaustMapSubscriber.prototype._complete = function() {
                this.hasCompleted = !0, this.hasSubscription || this.destination.complete();
            }, ExhaustMapSubscriber.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
                this.destination.next(innerValue);
            }, ExhaustMapSubscriber.prototype.notifyError = function(err) {
                this.destination.error(err);
            }, ExhaustMapSubscriber.prototype.notifyComplete = function(innerSub) {
                this.remove(innerSub), this.hasSubscription = !1, this.hasCompleted && this.destination.complete();
            }, ExhaustMapSubscriber;
        }(OuterSubscriber.a);
        //# sourceMappingURL=exhaustMap.js.map
        // CONCATENATED MODULE: ./src/utils/initialization_segment_cache.ts
        function initialization_segment_cache_classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Caching object used to cache initialization segments.
 * This allow to have a faster representation switch and faster seeking.
 */        var initialization_segment_cache = function() {
            function InitializationSegmentCache() {
                initialization_segment_cache_classCallCheck(this, InitializationSegmentCache), this._cache = new WeakMap();
            }
            /**
     * @param {Object} obj
     * @param {*} response
     */            return InitializationSegmentCache.prototype.add = function add(_ref, response) {
                var representation = _ref.representation;
                _ref.segment.isInit && this._cache.set(representation, response);
            }, 
            /**
     * @param {Object} obj
     * @returns {*} response
     * TODO just add segment directly, not in an object?
     */
            InitializationSegmentCache.prototype.get = function get(_ref2) {
                var representation = _ref2.representation;
                if (_ref2.segment.isInit) {
                    var value = this._cache.get(representation);
                    if (null != value) return value;
                }
                return null;
            }, InitializationSegmentCache;
        }();
        /* harmony default export */        
        // CONCATENATED MODULE: ./src/utils/sorted_list.ts
        function sorted_list_classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Creates an Array automatically sorted with the sorting function given to the
 * constructor when the add method is called.
 *
 * @example
 * ```js
 * const sortedList = new SortedList((a, b) => a.start - b.start);
 * const element1 = { start: 20 };
 * const element2 = { start: 10 };
 * const element3 = { start: 15 };
 *
 * sortedList.add(element1, element2);
 * console.log(sortedList.unwrap());
 * // -> [{ start: 10 }, { start : 20 }]
 *
 * sortedList.add(element3);
 * console.log(sortedList.unwrap());
 * // -> [{ start: 10 }, { start : 15 }, { start: 20 }]
 *
 * sortedList.removeFirst(element2);
 * // -> [{ start: 10 }, { start: 15 }]
 * ```
 * @class SortedList
 */        var sorted_list = function() {
            /**
     * @param {Function} sortingFunction
     */
            function SortedList(sortingFunction) {
                sorted_list_classCallCheck(this, SortedList), this._array = [], this._sortingFn = sortingFunction;
            }
            /**
     * Returns the nth element. Throws if the index does not exist.
     *
     * /!\ The returned Element shares the same reference with what is used
     * internally, any mutation on your part can lead to an un-sorted SortedList.
     * You can still re-force the sorting to happen by calling forceSort.
     * @throws Error - Throws if the given index is negative or superior to the
     * array's length.
     * @param {number} index
     * @returns {*}
     */            return SortedList.prototype.get = function get(index) {
                if (index < 0 || index >= this._array.length) throw new Error("Invalid index.");
                return this._array[index];
            }, 
            /**
     * Returns this list as a JS array.
     *
     * /!\ The returned Array shares the same reference with what is used
     * internally, any mutation on your part can lead to an un-sorted SortedList.
     * You can still re-force the sorting to happen by calling forceSort.
     * @returns {Array.<*>}
     */
            SortedList.prototype.unwrap = function unwrap() {
                return this._array;
            }, 
            /**
     * Find the first element corresponding to the given predicate.
     *
     * /!\ The returned element shares the same reference with what is used
     * internally, any mutation on your part can lead to an un-sorted SortedList.
     * You can still re-force the sorting to happen by calling forceSort.
     * @param {Function} fn
     * @returns {*}
     */
            SortedList.prototype.find = function find(fn) {
                return find_default()(this._array, fn);
            }, 
            /**
     * Returns the index of the given element in the list.
     * -1 if not found.
     * @param {*} element
     * @returns {number}
     */
            SortedList.prototype.indexOf = function indexOf(element) {
                return this._array.indexOf(element);
            }, 
            /**
     * Returns true if the List contains the given element.
     * @param {*} element
     * @returns {Boolean}
     */
            SortedList.prototype.has = function has(element) {
                return Object(array_includes.a)(this._array, element);
            }, 
            /**
     * Returns the current length of the list.
     * @returns {number}
     */
            SortedList.prototype.length = function length() {
                return this._array.length;
            }, 
            /**
     * Add a new element to the List at the right place for the List to stay
     * sorted.
     *
     * /!\ The added Element will share the same reference than the given
     * argument, any mutation on your part can lead to an un-sorted SortedList.
     * You can still re-force the sorting to happen by calling forceSort.
     * @param {...*} elements
     */
            SortedList.prototype.add = function add() {
                for (var _len = arguments.length, elements = Array(_len), _key = 0; _key < _len; _key++) elements[_key] = arguments[_key];
                elements.sort(this._sortingFn);
                for (var j = 0, i = 0; i < elements.length; i++) {
                    for (var element = elements[i], inserted = !1; !inserted && j < this._array.length; ) this._sortingFn(element, this._array[j]) < 0 ? (this._array.splice(j, 0, element), 
                    inserted = !0) : j++;
                    inserted || this._array.push(element);
                }
            }, 
            /**
     * Remove the first occurence of the given element.
     * Returns the index of the removed element. Undefined if not found.
     * @returns {number|undefined}
     */
            SortedList.prototype.removeFirst = function removeFirst(element) {
                var indexOf = this._array.indexOf(element);
                if (indexOf >= 0) return this._array.splice(indexOf, 1), indexOf;
            }, 
            /**
     * Returns the first element.
     *
     * /!\ The returned Element shares the same reference with what is used
     * internally, any mutation on your part can lead to an un-sorted SortedList.
     * You can still re-force the sorting to happen by calling forceSort.
     * @returns {*}
     */
            SortedList.prototype.head = function head() {
                return this._array[0];
            }, 
            /**
     * Returns the last element.
     *
     * /!\ The returned Element shares the same reference with what is used
     * internally, any mutation on your part can lead to an un-sorted SortedList.
     * You can still re-force the sorting to happen by calling forceSort.
     * @returns {*}
     */
            SortedList.prototype.last = function last() {
                return this._array[this._array.length - 1];
            }, 
            /**
     * Remove the first element.
     * Returns the element removed or undefined if no element were removed.
     * @returns {*}
     */
            SortedList.prototype.shift = function shift() {
                return this._array.shift();
            }, 
            /**
     * Remove the last element.
     * Returns the element removed or undefined if no element were removed.
     * @returns {*}
     */
            SortedList.prototype.pop = function pop() {
                return this._array.pop();
            }, 
            /**
     * Returns true if the given element is before the whole list when sorted.
     * As in, it would be the first element is pushed to the sortedList.
     * @param {*} element
     * @returns {boolean}
     */
            SortedList.prototype.isBefore = function isBefore(element) {
                return !this._array.length || this._sortingFn(element, this._array[0]) < 0;
            }, 
            /**
     * Returns true if the given element is after the whole list when sorted.
     * As in, it would be the last element is pushed to the sortedList.
     * @param {*} element
     * @returns {boolean}
     */
            SortedList.prototype.isAfter = function isAfter(element) {
                return !this._array.length || this._sortingFn(element, this._array[this._array.length - 1]) >= 0;
            }, 
            /**
     * Returns true if the wrapped Array is well-sorted.
     *
     * You might want to call this function to know if a mutation you've done
     * yourself impacted the order of elements.
     * You can then call the forceSort function to sort the list manually.
     *
     * @example
     * ```js
     * const sortedList = new SortedList((a, b) => a.start - b.start);
     * const element1 = { start: 20 };
     * const element2 = { start: 10 };
     *
     * sortedList.add(element1, element2);
     * console.log(sortedList.unwrap()); // -> [{ start: 10 }, { start : 20 }]
     * console.log(sortedList.checkSort()); // -> true
     *
     * element2.start = 5; // Mutation impacting the order of elements
     * console.log(sortedList.unwrap()); // -> [{ start: 10 }, { start : 5 }]
     * console.log(sortedList.checkSort()); // -> false
     *
     * sortedList.forceSort();
     * console.log(sortedList.unwrap()); // -> [{ start: 5 }, { start : 10 }]
     * console.log(sortedList.checkSort()); // -> true
     * ```
     * @returns {Boolean}
     */
            SortedList.prototype.checkSort = function checkSort() {
                for (var i = 0; i < this._array.length - 1; i++) if (this._sortingFn(this._array[i], this._array[i + 1]) > 0) return !1;
                return !0;
            }, 
            /**
     * Force the array to be sorted.
     *
     * You might want to call this function when you're unsure that a mutation
     * you've done yourself impacted the order of the elements in the list.
     */
            SortedList.prototype.forceSort = function forceSort() {
                this._array.sort(this._sortingFn);
            }, SortedList;
        }();
        /* harmony default export */        
        // CONCATENATED MODULE: ./src/core/buffer/create_fake_buffer.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Create empty Buffer Observable, linked to a Period.
 *
 * This observable will never download any segment and just emit a "full"
 * event when reaching the end.
 *
 * @param {Observable} bufferClock$
 * @param {Observable} wantedBufferAhead$
 * @param {string} bufferType
 * @param {Object} content
 * @returns {Observable}
 */
        function createFakeBuffer(bufferClock$, wantedBufferAhead$, bufferType, content) {
            var period = content.period;
            return Object(combineLatest.a)(bufferClock$, wantedBufferAhead$).pipe(Object(filter.a)(function(_ref) {
                var clockTick = _ref[0], wantedBufferAhead = _ref[1];
                return null != period.end && clockTick.currentTime + wantedBufferAhead >= period.end;
            }), Object(map.a)(function() {
                return {
                    type: "full-buffer",
                    value: {
                        bufferType: bufferType
                    }
                };
            }));
        }
        // CONCATENATED MODULE: ./src/core/stream/active_period_emitter.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * This file helps to keep track of the currently active Periods.
 * That is, Periods for which at least a single Buffer is currently active.
 *
 * It also keep track of the currently active period:
 * The first chronological period for which all types of buffers are active.
 */
        /**
 * Emit the active Period each times it changes.
 *
 * The active Period is the first Period (in chronological order) which has
 * a PeriodBuffer for every defined BUFFER_TYPES.
 *
 * Emit null if no Period has PeriodBuffers for all types.
 *
 * @example
 * For 4 BUFFER_TYPES: "AUDIO", "VIDEO", "TEXT" and "IMAGE":
 * ```
 *                     +-------------+
 *         Period 1    | Period 2    | Period 3
 * AUDIO   |=========| | |===      | |
 * VIDEO               | |=====    | |
 * TEXT    |(NO TEXT)| | |(NO TEXT)| | |====    |
 * IMAGE   |=========| | |=        | |
 *                     +-------------+
 *
 * The active Period here is Period 2 as Period 1 has no video PeriodBuffer.
 *
 * If we are missing a or multiple PeriodBuffers in the first chronological
 * Period, like that is the case here, it generally means that we are
 * currently switching between Periods.
 *
 * For here we are surely switching from Period 1 to Period 2 beginning by the
 * video PeriodBuffer. As every PeriodBuffer is ready for Period 2, we can
 * already inform that it is the current Period.
 * ```
 *
 * @param {Observable} addPeriodBuffer$ - Emit PeriodBuffer informations when
 * one is added.
 * @param {Observable} removePeriodBuffer$ - Emit PeriodBuffer informations when
 * one is removed.
 * @returns {Observable}
 */        function ActivePeriodEmitter(bufferTypes, addPeriodBuffer$, removePeriodBuffer$) {
            var periodsList = new sorted_list(function(a, b) {
                return a.period.start - b.period.start;
            }), onItemAdd$ = addPeriodBuffer$.pipe(Object(tap.a)(function(_ref) {
                var period = _ref.period, type = _ref.type, periodItem = periodsList.find(function(p) {
                    return p.period === period;
                });
                // add or update the periodItem
                                periodItem || (periodItem = {
                    period: period,
                    buffers: new Set()
                }, periodsList.add(periodItem)), periodItem.buffers.has(type) && log.a.warn("Buffer type " + type + " already added to the period"), 
                periodItem.buffers.add(type);
            })), onItemRemove$ = removePeriodBuffer$.pipe(Object(tap.a)(function(_ref2) {
                var period = _ref2.period, type = _ref2.type;
                if (periodsList && 0 !== periodsList.length()) {
                    var periodItem = periodsList.find(function(p) {
                        return p.period === period;
                    });
                    periodItem ? (periodItem.buffers.delete(type), periodItem.buffers.size || periodsList.removeFirst(periodItem)) : log.a.error("ActivePeriodStore: cannot remove, unknown period.");
                } else log.a.error("ActivePeriodStore: cannot remove, no period is active.");
            }));
            return Object(merge.a)(onItemAdd$, onItemRemove$).pipe(Object(map.a)(function() {
                if (!periodsList.head()) return null;
                var periodItem = periodsList.find(function(p) {
                    return isBufferListFull(bufferTypes, p.buffers);
                });
                return null != periodItem ? periodItem.period : null;
            }), Object(distinctUntilChanged.a)());
        }
        /**
 * Returns true if the set of given buffer types is complete (has all possible
 * types).
 * @param {Set} bufferList
 * @returns {Boolean}
 */        function isBufferListFull(bufferTypes, bufferList) {
            return bufferList.size >= bufferTypes.length;
        }
        // EXTERNAL MODULE: ./src/core/stream/stream_events.ts
                var stream_events = __webpack_require__(19);
        // CONCATENATED MODULE: ./src/core/stream/buffers_handler.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Create and manage the various Buffer Observables needed for the content to
 * stream:
 *
 *   - Create or dispose SourceBuffers depending on the chosen adaptations.
 *
 *   - Concatenate Buffers for adaptation from separate Periods at the right
 *     time, to allow smooth transitions between periods.
 *
 *   - Emit events as Period or Adaptations change or as new Period are
 *     prepared.
 *
 * Here multiple buffers can be created at the same time to allow smooth
 * transitions between periods.
 * To do this, we dynamically create or destroy buffers as they are needed.
 *
 * @param {Object} content - The content to play. Contains the following
 * properties:
 *   - manifest {Manifest}
 *
 *   - period {Period} - The first period to play in the content
 *
 *   - clock$ {Observable} - Emit current informations about the content
 *     being played. Also regulate the frequencies of the time the Buffer check
 *     for new its status / new segments.
 *
 *   - bufferManager {BufferManager} -  Will be used to create new
 *     AdaptationBuffers at will
 *
 *   - sourceBufferManager {SourceBufferManager} - Will be used to lazily
 *     create SourceBuffer instances associated with the current content.
 *
 *   - segmentPipelinesManager {SegmentPipelinesManager} - Used to download
 *     segments.
 *
 *   - segmentBookkeeper {WeakMapMemory} - Allow to easily retrieve or create
 *     a unique SegmentBookkeeper per SourceBuffer
 *
 *   - garbageCollectors {WeakMapMemory} - Allow to easily retrieve or create
 *     a unique Garbage Collector per SourceBuffer
 *
 *   - options {Object}
 *
 *   - errorStream {Subject} - Subject to emit minor errors
 * @returns {Observable}
 *
 * TODO Special case for image Buffer, where we want data for EVERY active
 * periods.
 *
 * TODO Special garbage collection for text and image buffers, as we want to
 * clean it for potentially very long sessions.
 */        function BuffersHandler(content, clock$, wantedBufferAhead$, bufferManager, sourceBufferManager, segmentPipelinesManager, segmentBookkeepers, garbageCollectors, options, errorStream) {
            var manifest = content.manifest, firstPeriod = content.period;
            // Initialize all native source buffers from the first period at the same
            // time.
            // We cannot lazily create native sourcebuffers since the spec does not
            // allow adding them during playback.
            //
            // From https://w3c.github.io/media-source/#methods
            //    For example, a user agent may throw a QuotaExceededError
            //    exception if the media element has reached the HAVE_METADATA
            //    readyState. This can occur if the user agent's media engine
            //    does not support adding more tracks during playback.
            createNativeSourceBuffersForPeriod(sourceBufferManager, firstPeriod);
            var addPeriodBuffer$ = new Subject.a(), removePeriodBuffer$ = new Subject.a(), bufferTypes = getBufferTypes(), buffersArray = bufferTypes.map(function(bufferType) {
                return manageEveryBuffers(bufferType, firstPeriod).pipe(Object(tap.a)(function(evt) {
                    "periodBufferReady" === evt.type ? addPeriodBuffer$.next(evt.value) : "periodBufferCleared" === evt.type && removePeriodBuffer$.next(evt.value);
                }), Object(share.a)());
            }), activePeriodChanged$ = ActivePeriodEmitter(bufferTypes, addPeriodBuffer$, removePeriodBuffer$).pipe(Object(filter.a)(function(period) {
                return !!period;
            })).pipe(Object(tap.a)(function(period) {
                log.a.info("new active period", period);
            }), Object(map.a)(function(period) {
                return stream_events.a.activePeriodChanged(period);
            })), streamHasEnded$ = buffersAreComplete.apply(void 0, buffersArray).pipe(Object(map.a)(function(areComplete) {
                return areComplete ? stream_events.a.endOfStream() : stream_events.a.resumeStream();
            }));
            return merge.a.apply(void 0, [ activePeriodChanged$ ].concat(buffersArray, [ streamHasEnded$ ]));
            /**
     * Manage creation and removal of Buffers for every Periods.
     *
     * Works by creating consecutive buffers through the
     * manageConsecutivePeriodBuffers function, and restarting it when the clock
     * goes out of the bounds of these buffers.
     * @param {string} bufferType - e.g. "audio" or "video"
     * @param {Period} basePeriod - Initial Period downloaded.
     * @returns {Observable}
     */            function manageEveryBuffers(bufferType, basePeriod) {
                /**
         * Keep a PeriodList for cases such as seeking ahead/before the
         * buffers already created.
         * When that happens, interrupt the previous buffers and create one back
         * from the new initial period.
         * @type {ConsecutivePeriodList}
         */
                var periodList = new sorted_list(function(a, b) {
                    return a.start - b.start;
                });
                /**
         * Returns true if the given time is either:
         *   - less than the start of the chronologically first Period
         *   - more than the end of the chronologically last Period
         * @param {number} time
         * @returns {boolean}
         */                function isOutOfPeriodList(time) {
                    var head = periodList.head(), last = periodList.last();
                    return null == head || null == last || (head.start > time || (last.end || Infinity) < time);
                }
                /**
         * Destroy the current set of consecutive buffers.
         * Used when the clocks goes out of the bounds of those, e.g. when the user
         * seeks.
         * We can then re-create consecutive buffers, from the new point in time.
         * @type {Subject}
         */                var destroyCurrentBuffers = new Subject.a(), restartBuffers$ = clock$.pipe(Object(filter.a)(function(_ref) {
                    var currentTime = _ref.currentTime, wantedTimeOffset = _ref.wantedTimeOffset;
                    return !!manifest.getPeriodForTime(wantedTimeOffset + currentTime) && isOutOfPeriodList(wantedTimeOffset + currentTime);
                }), Object(take.a)(1), Object(tap.a)(function(_ref2) {
                    var currentTime = _ref2.currentTime, wantedTimeOffset = _ref2.wantedTimeOffset;
                    log.a.info("Current position out of the bounds of the active periods,re-creating buffers.", bufferType, currentTime + wantedTimeOffset), 
                    destroyCurrentBuffers.next();
                }), Object(mergeMap.a)(function(_ref3) {
                    var currentTime = _ref3.currentTime, wantedTimeOffset = _ref3.wantedTimeOffset, newInitialPeriod = manifest.getPeriodForTime(currentTime + wantedTimeOffset);
                    if (null == newInitialPeriod) throw new MediaError.a("MEDIA_TIME_NOT_FOUND", null, !0);
                    // Note: For this to work, manageEveryBuffers should always emit the
                    // "periodBufferReady" event for the new InitialPeriod synchronously
                    return manageEveryBuffers(bufferType, newInitialPeriod);
                })), currentBuffers$ = manageConsecutivePeriodBuffers(bufferType, basePeriod, destroyCurrentBuffers).pipe(Object(tap.a)(function(message) {
                    "periodBufferReady" === message.type ? periodList.add(message.value.period) : "periodBufferCleared" === message.type && periodList.removeFirst(message.value.period);
                }), Object(share.a)());
                return Object(merge.a)(currentBuffers$, restartBuffers$);
            }
            /**
     * Manage creation and removal of Buffers for consecutive Periods.
     *
     * This function is called recursively for each successive Periods as needed.
     *
     * This function does not guarantee creation/destruction of the right Buffers
     * when the user seeks or rewind in the content.
     * It only manages regular playback, another layer should be used to manage
     * those cases.
     *
     * You can know about buffers creation and destruction respectively through
     * the "periodBufferReady" and "periodBufferCleared" events.
     *
     * The "periodBufferReady" related to the given period should be sent synchronously
     * on subscription.
     * Further "periodBufferReady" for further Periods should be sent each time the
     * Buffer for the previous Buffer is full.
     *
     * Buffers for each Period are cleared ("periodBufferCleared" event) either:
     *   - when it has finished to play (currentTime is after it)
     *   - when one of the older Buffers becomes active again, in which case the
     *     Buffers coming after will be cleared from the newest to the oldest.
     *   - when the destroy$ observable emits, in which case every created Buffer
     *     here will be cleared from the newest to the oldest.
     *
     * TODO The code here can surely be greatly simplified.
     * @param {string} bufferType - e.g. "audio" or "video"
     * @param {Period} basePeriod - Initial Period downloaded.
     * @param {Observable} destroy$ - Emit when/if all created Buffer from this
     * point should be destroyed.
     * @returns {Observable}
     */            function manageConsecutivePeriodBuffers(bufferType, basePeriod, destroy$) {
                log.a.info("creating new Buffer for", bufferType, basePeriod);
                /**
         * Emits the chosen adaptation for the current type.
         * @type {ReplaySubject}
         */
                var adaptation$ = new ReplaySubject.a(1), createNextPeriodBuffer$ = new Subject.a(), destroyNextBuffers$ = new Subject.a(), endOfCurrentBuffer$ = clock$.pipe(Object(filter.a)(function(_ref4) {
                    var currentTime = _ref4.currentTime, wantedTimeOffset = _ref4.wantedTimeOffset;
                    return !!basePeriod.end && currentTime + wantedTimeOffset >= basePeriod.end;
                })), nextPeriodBuffer$ = createNextPeriodBuffer$.pipe(exhaustMap(function(nextPeriod) {
                    return manageConsecutivePeriodBuffers(bufferType, nextPeriod, destroyNextBuffers$);
                })), destroyAll$ = destroy$.pipe(Object(take.a)(1), Object(tap.a)(function() {
                    // first complete createNextBuffer$ to allow completion of the
                    // nextPeriodBuffer$ observable once every further Buffers have been
                    // cleared.
                    createNextPeriodBuffer$.complete(), 
                    // emit destruction signal to the next Buffer first
                    destroyNextBuffers$.next(), destroyNextBuffers$.complete();
                }), Object(share.a)()), killCurrentBuffer$ = Object(merge.a)(endOfCurrentBuffer$, destroyAll$), periodBuffer$ = createPeriodBuffer(bufferType, basePeriod, adaptation$).pipe(Object(mergeMap.a)(function(evt) {
                    var type = evt.type;
                    if ("full-buffer" === type) {
                        /**
                 * The Period coming just after the current one.
                 * @type {Period|undefined}
                 */
                        var nextPeriod = manifest.getPeriodAfter(basePeriod);
                        if (null == nextPeriod) 
                        // no more period, emits  event
                        return Object(of.a)(stream_events.a.bufferComplete(bufferType));
                        // current buffer is full, create the next one if not
                        createNextPeriodBuffer$.next(nextPeriod);
                    } else "active-buffer" === type && 
                    // current buffer is active, destroy next buffer if created
                    destroyNextBuffers$.next();
                    return Object(of.a)(evt);
                }), Object(share.a)()), currentBuffer$ = Object(concat.a)(Object(of.a)(stream_events.a.periodBufferReady(bufferType, basePeriod, adaptation$)), periodBuffer$.pipe(Object(takeUntil.a)(killCurrentBuffer$)), Object(of.a)(stream_events.a.periodBufferCleared(bufferType, basePeriod)).pipe(Object(tap.a)(function() {
                    log.a.info("destroying buffer for", bufferType, basePeriod);
                })));
                /**
         * Emits the Period of the next Period Buffer when it can be created.
         * @type {Subject}
         */                return Object(merge.a)(currentBuffer$, nextPeriodBuffer$, destroyAll$.pipe(Object(ignoreElements.a)()));
            }
            /**
     * Create single PeriodBuffer Observable:
     *   - Lazily create (or reuse) a SourceBuffer for the given type.
     *   - Create a Buffer linked to an Adaptation each time it changes, to
     *     download and append the corresponding Segments in the SourceBuffer.
     *   - Announce when the Buffer is full or is awaiting new Segments through
     *     events
     *
     * /!\ This Observable has multiple side-effects (creation of SourceBuffers,
     * downloading and appending of Segments etc.) on subscription.
     *
     * @param {string} bufferType
     * @param {Period} period - The period concerned
     * @param {Observable} adaptation$ - Emit the chosen adaptation.
     * Emit null to deactivate a type of adaptation
     * @returns {Observable}
     */            function createPeriodBuffer(bufferType, period, adaptation$) {
                return adaptation$.pipe(Object(switchMap.a)(function(adaptation) {
                    if (null == adaptation) {
                        log.a.info("set no " + bufferType + " Adaptation", period);
                        var cleanBuffer$ = void 0;
                        if (sourceBufferManager.has(bufferType)) log.a.info("clearing previous " + bufferType + " SourceBuffer"), 
                        cleanBuffer$ = sourceBufferManager.get(bufferType).removeBuffer({
                            start: period.start,
                            end: period.end || Infinity
                        }).pipe(Object(mapTo.a)(null)); else cleanBuffer$ = Object(of.a)(null);
                        return Object(concat.a)(cleanBuffer$.pipe(Object(mapTo.a)(stream_events.a.adaptationChange(bufferType, null, period))), createFakeBuffer(clock$, wantedBufferAhead$, bufferType, {
                            manifest: manifest,
                            period: period
                        }));
                    }
                    log.a.info("updating " + bufferType + " adaptation", adaptation, period);
                    // 1 - create or reuse the SourceBuffer
                    var queuedSourceBuffer = void 0;
                    if (sourceBufferManager.has(bufferType)) log.a.info("reusing a previous SourceBuffer for the type", bufferType), 
                    queuedSourceBuffer = sourceBufferManager.get(bufferType); else {
                        var codec = getFirstDeclaredMimeType(adaptation), sourceBufferOptions = "text" === bufferType ? options.textTrackOptions : void 0;
                        queuedSourceBuffer = sourceBufferManager.createSourceBuffer(bufferType, codec, sourceBufferOptions);
                    }
                    // 2 - create or reuse the associated BufferGarbageCollector and
                    // SegmentBookkeeper
                                        var bufferGarbageCollector$ = garbageCollectors.get(queuedSourceBuffer), segmentBookkeeper = segmentBookkeepers.get(queuedSourceBuffer), pipelineOptions = getPipelineOptions(bufferType, options.maxRetry, options.maxRetryOffline), pipeline = segmentPipelinesManager.createPipeline(bufferType, pipelineOptions), adaptationBuffer$ = bufferManager.createBuffer(clock$, queuedSourceBuffer, segmentBookkeeper, pipeline, wantedBufferAhead$, {
                        manifest: manifest,
                        period: period,
                        adaptation: adaptation
                    }).pipe(Object(catchError.a)(function(error) {
                        // non native buffer should not impact the stability of the
                        // player. ie: if a text buffer sends an error, we want to
                        // continue streaming without any subtitles
                        if (!source_buffers.isNative(bufferType)) return log.a.error("custom buffer: ", bufferType, "has crashed. Aborting it.", error), 
                        sourceBufferManager.disposeSourceBuffer(bufferType), errorStream.next(error), createFakeBuffer(clock$, wantedBufferAhead$, bufferType, {
                            manifest: manifest,
                            period: period
                        });
                        throw log.a.error("native buffer: ", bufferType, "has crashed. Stopping playback.", error), 
                        error;
 // else, throw
                                        }));
                    // 5 - Return the buffer and send right events
                    return Object(concat.a)(Object(of.a)(stream_events.a.adaptationChange(bufferType, adaptation, period)), Object(merge.a)(adaptationBuffer$, bufferGarbageCollector$));
                }));
            }
        }
        /**
 * @param {string} bufferType
 * @param {number} retry
 * @param {number} offlineRetry
 * @returns {Object} - Options to give to the Pipeline
 */        function getPipelineOptions(bufferType, retry, offlineRetry) {
            return {
                cache: Object(array_includes.a)([ "audio", "video" ], bufferType) ? new initialization_segment_cache() : void 0,
                maxRetry: "image" === bufferType ? 0 : null != retry ? retry : config.a.DEFAULT_MAX_PIPELINES_RETRY_ON_ERROR,
                maxRetryOffline: null != offlineRetry ? offlineRetry : config.a.DEFAULT_MAX_PIPELINES_RETRY_ON_OFFLINE
            };
        }
        /**
 * Returns an Observable which emits ``undefined`` and complete when all
 * buffers given are _complete_.
 *
 * A PeriodBuffer for a given type is considered _complete_ when both of these
 * conditions are true:
 *   - it is the last PeriodBuffer in the content for the given type
 *   - it has finished downloading segments (it is _full_)
 *
 * Simply put a _complete_ PeriodBuffer for a given type means that every
 * segments needed for this Buffer have been downloaded.
 *
 * When the Observable returned here emits, every Buffer are finished.
 * @param {...Observable} buffers
 * @returns {Observable}
 */        function buffersAreComplete() {
            for (var _len = arguments.length, buffers = Array(_len), _key = 0; _key < _len; _key++) buffers[_key] = arguments[_key];
            /**
     * Array of Observables linked to the Array of Buffers which emit:
     *   - true when the corresponding buffer is considered _complete_.
     *   - false when the corresponding buffer is considered _active_.
     * @type {Array.<Observable>}
     */            var isCompleteArray = buffers.map(function(buffer) {
                return buffer.pipe(Object(filter.a)(function(evt) {
                    return "complete-buffer" === evt.type || "active-buffer" === evt.type;
                }), Object(map.a)(function(evt) {
                    return "complete-buffer" === evt.type;
                }), Object(startWith.a)(!1), Object(distinctUntilChanged.a)());
            });
            return combineLatest.a.apply(void 0, isCompleteArray).pipe(Object(map.a)(function(areComplete) {
                return areComplete.every(function(isComplete) {
                    return isComplete;
                });
            }), Object(distinctUntilChanged.a)());
        }
        /**
 * Get mimetype string of the first representation declared in the given
 * adaptation.
 * @param {Adaptation} adaptation
 * @returns {string}
 */        function getFirstDeclaredMimeType(adaptation) {
            var representations = adaptation.representations;
            return representations[0] && representations[0].getMimeTypeString() || "";
        }
        /**
 * Create all native SourceBuffers needed for a given Period.
 *
 * Native Buffers have the particulary to need to be created at the beginning of
 * the content.
 * Custom source buffers (entirely managed in JS) can generally be created and
 * disposed at will during the lifecycle of the content.
 * @param {SourceBufferManager} sourceBufferManager
 * @param {Period} period
 */        function createNativeSourceBuffersForPeriod(sourceBufferManager, period) {
            Object.keys(period.adaptations).forEach(function(bufferType) {
                if (source_buffers.isNative(bufferType)) {
                    var adaptations = period.adaptations[bufferType] || [], representations = adaptations ? adaptations[0].representations : [];
                    if (representations.length) {
                        var codec = representations[0].getMimeTypeString();
                        sourceBufferManager.createSourceBuffer(bufferType, codec);
                    }
                }
            });
        }
        // CONCATENATED MODULE: ./src/core/stream/clock.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Create clock$ and seekings$ Observables:
 *   - clock$ is the given clock$ observable with added informations.
 *   - seekings$ emits each time the player go in a seeking state.
 * @param {Object} manifest
 * @param {Observable} streamClock$
 * @param {Observable} initialSeek$
 * @param {Number} startTime
 * @returns {Object}
 */        function createBufferClock(manifest, streamClock$, initialSeek$, startTime) {
            /**
   * wantedTimeOffset is an offset to add to the timing's current time to have
   * the "real" wanted position.
   * For now, this is seen when the video has not yet seeked to its initial
   * position, the currentTime will most probably be 0 where the effective
   * starting position will be _startTime_.
   * Thus we initially set a wantedTimeOffset equal to startTime.
   * @type {Number}
   */
            var wantedTimeOffset = startTime, updateTimeOffset$ = initialSeek$.pipe(Object(take.a)(1), Object(tap.a)(function() {
                wantedTimeOffset = 0;
            }), // (initial seek performed)
            Object(ignoreElements.a)()), clock$ = streamClock$.pipe(Object(map.a)(function(timing) {
                return object_assign_default()({
                    liveGap: manifest.isLive ? getMaximumBufferPosition(manifest) - timing.currentTime : Infinity,
                    wantedTimeOffset: wantedTimeOffset
                }, timing);
            }));
            return Object(merge.a)(clock$, updateTimeOffset$);
        }
        // EXTERNAL MODULE: ./src/core/stream/create_eme_manager.ts
                var create_eme_manager = __webpack_require__(87), compat_constants = __webpack_require__(25);
        // EXTERNAL MODULE: ./src/compat/constants.ts
                // CONCATENATED MODULE: ./src/core/stream/create_media_source.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Side effect that set the media duration in the mediaSource.
 *
 * @param {MediaSource} mediaSource
 * @param {number} duration
 */
        function setDurationToMediaSource(mediaSource, duration) {
            var newDuration = Infinity === duration ? Number.MAX_VALUE : duration;
            mediaSource.duration !== newDuration && (log.a.info("set duration", mediaSource.duration), 
            mediaSource.duration = newDuration);
        }
        /**
 * Dispose of ressources taken by the MediaSource:
 *   - Clear the MediaSource' SourceBuffers
 *   - Clear the video's src (stop the video)
 *   - Revoke MediaSource' URL
 * @param {HTMLMediaElement} video
 * @param {MediaSource|null} mediaSource
 * @param {string|null} mediaSourceURL
 */        function resetMediaSource(video, mediaSource, mediaSourceURL) {
            if (mediaSource && "closed" !== mediaSource.readyState) {
                for (var readyState = mediaSource.readyState, sourceBuffers = mediaSource.sourceBuffers, i = sourceBuffers.length - 1; i >= 0; i--) {
                    var sourceBuffer = sourceBuffers[i];
                    try {
                        "open" === readyState && (log.a.info("removing SourceBuffer from mediaSource", sourceBuffer), 
                        sourceBuffer.abort()), mediaSource.removeSourceBuffer(sourceBuffer);
                    } catch (e) {
                        log.a.warn("error while disposing SourceBuffer", e);
                    }
                }
                sourceBuffers.length && log.a.warn("not all SourceBuffers could have been removed.");
            }
            if (Object(compat.c)(video), mediaSourceURL) try {
                log.a.debug("revoking previous URL"), URL.revokeObjectURL(mediaSourceURL);
            } catch (e) {
                log.a.warn("error while revoking the media source URL", e);
            }
        }
        /**
 * Create, on subscription, a MediaSource instance and attach it to the given
 * video element's src attribute.
 *
 * Returns an Observable which emits the MediaSource when created and attached
 * to the video element.
 * This Observable never completes. It can throw if MediaSource is not
 * available in the current environment.
 *
 * On unsubscription, the video.src is cleaned, MediaSource sourceBuffers and
 * customBuffers are aborted and some minor cleaning is done.
 *
 * @param {HTMLMediaElement} video
 * @returns {Observable}
 */        function createMediaSource(video) {
            return Observable.a.create(function(observer) {
                if (!compat_constants.d) throw new MediaError.a("MEDIA_SOURCE_NOT_SUPPORTED", null, !0);
                // make sure the media has been correctly reset
                                resetMediaSource(video, null, video.src || null), log.a.info("creating MediaSource");
                var mediaSource = new compat_constants.d(), objectURL = URL.createObjectURL(mediaSource);
                return log.a.info("attaching MediaSource URL to video element", objectURL), video.src = objectURL, 
                observer.next(mediaSource), function() {
                    resetMediaSource(video, mediaSource, objectURL);
                };
            });
        }
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/isArray.js
                var isArray = __webpack_require__(42), fromArray = __webpack_require__(33);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/fromArray.js
                // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/observable/race.js
        /** PURE_IMPORTS_START tslib,_util_isArray,_fromArray,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
        function race() {
            for (var observables = [], _i = 0; _i < arguments.length; _i++) observables[_i] = arguments[_i];
            if (1 === observables.length) {
                if (!Object(isArray.a)(observables[0])) return observables[0];
                observables = observables[0];
            }
            return Object(fromArray.a)(observables, void 0).lift(new RaceOperator());
        }
        var RaceOperator = /* */ function() {
            function RaceOperator() {}
            return RaceOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new race_RaceSubscriber(subscriber));
            }, RaceOperator;
        }(), race_RaceSubscriber = /* */ function(_super) {
            function RaceSubscriber(destination) {
                var _this = _super.call(this, destination) || this;
                return _this.hasFirst = !1, _this.observables = [], _this.subscriptions = [], _this;
            }
            return tslib_es6.a(RaceSubscriber, _super), RaceSubscriber.prototype._next = function(observable) {
                this.observables.push(observable);
            }, RaceSubscriber.prototype._complete = function() {
                var observables = this.observables, len = observables.length;
                if (0 === len) this.destination.complete(); else {
                    for (var i = 0; i < len && !this.hasFirst; i++) {
                        var observable = observables[i], subscription = Object(subscribeToResult.a)(this, observable, observable, i);
                        this.subscriptions && this.subscriptions.push(subscription), this.add(subscription);
                    }
                    this.observables = null;
                }
            }, RaceSubscriber.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
                if (!this.hasFirst) {
                    this.hasFirst = !0;
                    for (var i = 0; i < this.subscriptions.length; i++) if (i !== outerIndex) {
                        var subscription = this.subscriptions[i];
                        subscription.unsubscribe(), this.remove(subscription);
                    }
                    this.subscriptions = null;
                }
                this.destination.next(innerValue);
            }, RaceSubscriber;
        }(OuterSubscriber.a), ArgumentOutOfRangeError = __webpack_require__(79);
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/takeLast.js
        /** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError,_observable_empty PURE_IMPORTS_END */
        function takeLast(count) {
            return function takeLastOperatorFunction(source) {
                return 0 === count ? Object(empty.b)() : source.lift(new takeLast_TakeLastOperator(count));
            };
        }
        var takeLast_TakeLastOperator = /* */ function() {
            function TakeLastOperator(total) {
                if (this.total = total, this.total < 0) throw new ArgumentOutOfRangeError.a();
            }
            return TakeLastOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new takeLast_TakeLastSubscriber(subscriber, this.total));
            }, TakeLastOperator;
        }(), takeLast_TakeLastSubscriber = /* */ function(_super) {
            function TakeLastSubscriber(destination, total) {
                var _this = _super.call(this, destination) || this;
                return _this.total = total, _this.ring = new Array(), _this.count = 0, _this;
            }
            return tslib_es6.a(TakeLastSubscriber, _super), TakeLastSubscriber.prototype._next = function(value) {
                var ring = this.ring, total = this.total, count = this.count++;
                ring.length < total ? ring.push(value) : ring[count % total] = value;
            }, TakeLastSubscriber.prototype._complete = function() {
                var destination = this.destination, count = this.count;
                if (count > 0) for (var total = this.count >= this.total ? this.total : this.count, ring = this.ring, i = 0; i < total; i++) {
                    var idx = count++ % total;
                    destination.next(ring[idx]);
                }
                destination.complete();
            }, TakeLastSubscriber;
        }(Subscriber.a), concatMap = __webpack_require__(109);
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/concatMapTo.js
        /** PURE_IMPORTS_START _concatMap PURE_IMPORTS_END */
        function concatMapTo(innerObservable, resultSelector) {
            return Object(concatMap.a)(function() {
                return innerObservable;
            }, resultSelector);
        }
        //# sourceMappingURL=concatMapTo.js.map
        // CONCATENATED MODULE: ./src/core/stream/end_of_stream.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Get "updating" SourceBuffers from a SourceBufferList.
 * @param {SourceBufferList} sourceBuffers
 * @returns {Array.<SourceBuffer>}
 */        function getUpdatingSourceBuffers(sourceBuffers) {
            for (var updatingSourceBuffers = [], i = 0; i < sourceBuffers.length; i++) {
                var SourceBuffer = sourceBuffers[i];
                SourceBuffer.updating && updatingSourceBuffers.push(SourceBuffer);
            }
            return updatingSourceBuffers;
        }
        /**
 * Trigger the `endOfStream` method of a MediaSource.
 *
 * If the MediaSource is ended/closed, do not call this method.
 *
 * If SourceBuffers are updating, wait for them to be updated before closing
 * it.
 * @param {MediaSource} mediaSource
 * @returns {Observable}
 */        function triggerEndOfStream(mediaSource) {
            return Object(defer.a)(function() {
                if ("open" !== mediaSource.readyState) 
                // already done, exit
                return Object(of.a)(null);
                var sourceBuffers = mediaSource.sourceBuffers, updatingSourceBuffers = getUpdatingSourceBuffers(sourceBuffers);
                if (!updatingSourceBuffers.length) return log.a.info("triggering end of stream"), 
                mediaSource.endOfStream(), Object(of.a)(null);
                var updatedSourceBuffers$ = updatingSourceBuffers.map(events.p);
                return race(merge.a.apply(void 0, updatedSourceBuffers$).pipe(takeLast(1)), Object(events.k)(sourceBuffers).pipe(Object(take.a)(1))).pipe(Object(mergeMap.a)(function() {
                    return triggerEndOfStream(mediaSource);
                }));
            });
        }
        /**
 * Trigger the `endOfStream` method of a MediaSource each times it opens.
 * @see triggerEndOfStream
 * @param {MediaSource} mediaSource
 * @returns {Observable}
 */        function maintainEndOfStream(mediaSource) {
            return Object(concat.a)(triggerEndOfStream(mediaSource), Object(events.n)(mediaSource).pipe(concatMapTo(triggerEndOfStream(mediaSource))));
        }
        // CONCATENATED MODULE: ./src/core/stream/garbage_collector.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Perform cleaning of the buffer according to the values set by the user
 * at each clock tick and each times the maxBufferBehind/maxBufferAhead values
 * change.
 *
 * @param {Object} opt
 * @returns {Observable}
 */        function BufferGarbageCollector(_ref) {
            var queuedSourceBuffer = _ref.queuedSourceBuffer, clock$ = _ref.clock$, maxBufferBehind$ = _ref.maxBufferBehind$, maxBufferAhead$ = _ref.maxBufferAhead$;
            return Object(combineLatest.a)(clock$, maxBufferBehind$, maxBufferAhead$).pipe(Object(mergeMap.a)(function(_ref2) {
                var currentTime = _ref2[0], maxBufferBehind = _ref2[1], maxBufferAhead = _ref2[2];
                return clearBuffer(queuedSourceBuffer, currentTime, maxBufferBehind, maxBufferAhead);
            }));
        }
        /**
 * Remove buffer from the browser's memory based on the user's
 * maxBufferAhead / maxBufferBehind settings.
 *
 * Normally, the browser garbage-collect automatically old-added chunks of
 * buffer date when memory is scarce. However, you might want to control
 * the size of memory allocated. This function takes the current position
 * and a "depth" behind and ahead wanted for the buffer, in seconds.
 *
 * Anything older than the depth will be removed from the buffer.
 * @param {QueuedSourceBuffer} qSourceBuffer
 * @param {Number} position - The current position
 * @param {Number} maxBufferBehind
 * @param {Number} maxBufferAhead
 * @returns {Observable}
 */        function clearBuffer(qSourceBuffer, position, maxBufferBehind, maxBufferAhead) {
            if (!isFinite(maxBufferBehind) && !isFinite(maxBufferAhead)) return empty.a;
            var cleanedupRanges = [], _getInnerAndOuterTime = Object(utils_ranges.b)(qSourceBuffer.getBuffered(), position), innerRange = _getInnerAndOuterTime.innerRange, outerRanges = _getInnerAndOuterTime.outerRanges;
            return function collectBufferBehind() {
                if (isFinite(maxBufferBehind)) {
                    // begin from the oldest
                    for (var i = 0; i < outerRanges.length; i++) {
                        var outerRange = outerRanges[i];
                        position - maxBufferBehind >= outerRange.end ? cleanedupRanges.push(outerRange) : position >= outerRange.end && position - maxBufferBehind > outerRange.start && position - maxBufferBehind < outerRange.end && cleanedupRanges.push({
                            start: outerRange.start,
                            end: position - maxBufferBehind
                        });
                    }
                    innerRange && position - maxBufferBehind > innerRange.start && cleanedupRanges.push({
                        start: innerRange.start,
                        end: position - maxBufferBehind
                    });
                }
            }(), function collectBufferAhead() {
                if (isFinite(maxBufferAhead)) {
                    // begin from the oldest
                    for (var i = 0; i < outerRanges.length; i++) {
                        var outerRange = outerRanges[i];
                        position + maxBufferAhead <= outerRange.start ? cleanedupRanges.push(outerRange) : position <= outerRange.start && position + maxBufferAhead < outerRange.end && position + maxBufferAhead > outerRange.start && cleanedupRanges.push({
                            start: position + maxBufferAhead,
                            end: outerRange.end
                        });
                    }
                    innerRange && position + maxBufferAhead < innerRange.end && cleanedupRanges.push({
                        start: position + maxBufferAhead,
                        end: innerRange.end
                    });
                }
            }(), Object(from.a)(cleanedupRanges.map(function(range) {
                return log.a.debug("cleaning range from source buffer", range), qSourceBuffer.removeBuffer(range);
            })).pipe(Object(concatAll.a)(), Object(ignoreElements.a)());
        }
        // CONCATENATED MODULE: ./src/core/stream/get_initial_time.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        var DEFAULT_LIVE_GAP = config.a.DEFAULT_LIVE_GAP;
        /**
 * Returns the calculated initial time for the stream described by the given
 * manifest:
 *   1. if a start time is defined by user, calculate video starting time from
 *      the manifest informations
 *   2. else if the video is live, use the live edge and suggested delays from
 *      it
 *   3. else returns the minimum time announced in the manifest
 *
 * @param {Manifest} manifest
 * @param {Object} startAt
 * @returns {Number}
 */        function getInitialTime(manifest, startAt) {
            if (startAt) {
                var _getBufferLimits = getBufferLimits(manifest), min = _getBufferLimits[0], max = _getBufferLimits[1];
                if (null != startAt.position) return Math.max(Math.min(startAt.position, max), min);
                if (null != startAt.wallClockTime) {
                    var position = manifest.isLive ? startAt.wallClockTime - (manifest.availabilityStartTime || 0) : startAt.wallClockTime;
                    return Math.max(Math.min(position, max), min);
                }
                if (null != startAt.fromFirstPosition) {
                    var fromFirstPosition = startAt.fromFirstPosition;
                    return fromFirstPosition <= 0 ? min : Math.min(min + fromFirstPosition, max);
                }
                if (null != startAt.fromLastPosition) {
                    var fromLastPosition = startAt.fromLastPosition;
                    return fromLastPosition >= 0 ? max : Math.max(min, max + fromLastPosition);
                }
                if (null != startAt.percentage) {
                    var percentage = startAt.percentage;
                    return percentage > 100 ? max : percentage < 0 ? min : min + (max - min) * (+percentage / 100);
                }
            }
            if (manifest.isLive) {
                var sgp = manifest.suggestedPresentationDelay;
                return getMaximumBufferPosition(manifest) - (null == sgp ? DEFAULT_LIVE_GAP : sgp);
            }
            return getMinimumBufferPosition(manifest);
        }
        // CONCATENATED MODULE: ./src/core/stream/live_events_handler.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Re-fetch the manifest and merge it with the previous version.
 *
 * /!\ Mutates the given manifest
 * @param {Object} manifest
 * @returns {Observable}
 */        function refreshManifest(manifestPipeline, currentManifest) {
            var refreshURL = currentManifest.getUrl();
            return refreshURL ? manifestPipeline(refreshURL).pipe(Object(tap.a)(function(parsed) {
                currentManifest.update(parsed);
            }), Object(share.a)(), // share the previous side effect
            Object(mapTo.a)(stream_events.a.manifestUpdate(currentManifest))) : (log.a.warn("Cannot refresh the manifest: no url"), 
            empty.a);
        }
        /**
 * Create handler for Buffer events happening only in live contexts.
 * @param {HTMLMediaElement} videoElement
 * @param {Object} manifest
 * @param {Function} fetchManifest
 * @returns {Function}
 */        function liveEventsHandler(videoElement, manifest, fetchManifest) {
            return function handleLiveEvents(message) {
                switch (message.type) {
                  case "discontinuity-encountered":
                    source_buffers.isNative(message.value.bufferType) && (log.a.warn("explicit discontinuity seek", message.value.nextTime), 
                    videoElement.currentTime = message.value.nextTime);
                    break;

                  case "needs-manifest-refresh":
                    // out-of-index messages require a complete reloading of the
                    // manifest to refresh the current index
                    return log.a.debug("needs manifest to be refreshed"), refreshManifest(fetchManifest, manifest);
                }
                return Object(of.a)(message);
            };
        }
        // EXTERNAL MODULE: ./src/core/stream/media_error_handler.ts
                var media_error_handler = __webpack_require__(88);
        // CONCATENATED MODULE: ./src/utils/takeFirstSet.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Returns the first argument given different from undefined or null.
 * @param {...*} args
 * @returns {*}
 */        function takeFirstSet() {
            for (var i = 0, len = arguments.length; i < len; ) {
                if (null != (arguments.length <= i ? void 0 : arguments[i])) return arguments.length <= i ? void 0 : arguments[i];
                i++;
            }
        }
        // CONCATENATED MODULE: ./src/core/stream/segment_bookkeeper.ts
                function segment_bookkeeper_classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        var MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT = config.a.MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT, MAX_BUFFERED_DISTANCE = config.a.MAX_BUFFERED_DISTANCE, segment_bookkeeper_MINIMUM_SEGMENT_SIZE = config.a.MINIMUM_SEGMENT_SIZE, segment_bookkeeper = function() {
            function SegmentBookkeeper() {
                segment_bookkeeper_classCallCheck(this, SegmentBookkeeper), 
                /**
         * The inventory keep track of all the segments which should be currently
         * in the browser's memory.
         * This array contains objects, each being related to a single downloaded
         * segment which is at least partially added in a source buffer.
         * @type {Array.<Object>}
         */
                this.inventory = [];
            }
            /**
     * Infer each segment's bufferedStart and bufferedEnd from the TimeRanges
     * given (coming from the source buffer).
     * @param {TimeRanges}
     *
     * TODO implement management of segments whose end is not known
     */            return SegmentBookkeeper.prototype.synchronizeBuffered = function synchronizeBuffered(buffered) {
                for (var inventory = this.inventory, ranges = Object(utils_ranges.a)(buffered), inventoryIndex = 0, thisSegment = inventory[0], rangesLength = ranges.length, i = 0; i < rangesLength; i++) {
                    if (null == thisSegment) 
                    // If thisSegment is not set, it means that we arrived at the end of
                    // our inventory.
                    // This TimeRange do not link to any segment and neither will any
                    // subsequent one.
                    // (It may be linked to another adaptation, for example)
                    return;
                    var _ranges$i = ranges[i], rangeStart = _ranges$i.start, rangeEnd = _ranges$i.end;
                    // if current TimeRange is too small to contain a segment, go to next one
                                        if (!(rangeEnd - rangeStart < segment_bookkeeper_MINIMUM_SEGMENT_SIZE)) {
                        // Find the first segment either within this TimeRange or past it:
                        // skip until first segment with at least MINIMUM_SEGMENT_SIZE past the
                        // start of that range.
                        for (
                        /**
             * Inventory index of the last segment not contained in the current range.
             * Will be used to know how many segments have been garbage collected.
             * @type {Number}
             */
                        var indexBefore = inventoryIndex; thisSegment && 
                        // TODO better way to indicate to typescript that all is well here
                        takeFirstSet(thisSegment.bufferedEnd, thisSegment.end) - rangeStart < segment_bookkeeper_MINIMUM_SEGMENT_SIZE; ) thisSegment = inventory[++inventoryIndex];
                        /**
             * Contains the end of the last garbage-collected segment before
             * thisSegment.
             * Might be useful to infer later the bufferedStart of thisSegment.
             *
             * -1 if no segment have been garbage-collected before thisSegment.
             * @type {Number}
             */                        var lastDeletedSegmentEnd = -1, numberOfSegmentToDelete = inventoryIndex - indexBefore;
                        // remove garbage-collected segments
                        // (not in that TimeRange nor in the previous one)
                                                if (numberOfSegmentToDelete > 0) {
                            // last garbage-collected segment
                            var lastDeletedSegment = inventory[indexBefore + numberOfSegmentToDelete - 1];
                            // TODO better way to indicate to typescript that all is well here
                                                        lastDeletedSegmentEnd = takeFirstSet(lastDeletedSegment.bufferedEnd, lastDeletedSegment.end), 
                            // mutate inventory
                            inventory.splice(indexBefore, numberOfSegmentToDelete), inventoryIndex = indexBefore;
                        }
                        // if no segment is left for that range (or any other one), quit
                                                if (null == thisSegment) return;
                        // Infer the bufferedStart for this segment, and the bufferedStart and
                        // bufferedEnd for the following segments included in that range.
                        //
                        // If the current segment is actually completely outside that range (it
                        // is contained in one of the next one), skip that part.
                                                if (rangeEnd - 
                        // TODO better way to indicate to typescript that all is well here
                        takeFirstSet(thisSegment.bufferedStart, thisSegment.start) >= segment_bookkeeper_MINIMUM_SEGMENT_SIZE) 
                        // Make contiguous until first segment outside that range
                        // (i.e until the start of the next segment can not constitute a segment
                        // in that range == less than MINIMUM_SEGMENT_SIZE into that range)
                        for (
                        // set the bufferedStart of the first segment in that range
                        null != thisSegment.bufferedStart && thisSegment.bufferedStart < rangeStart ? 
                        // the segment appears to have been partially garbage collected:
                        // Update bufferedStart
                        thisSegment.bufferedStart = rangeStart : null == thisSegment.bufferedStart && (-1 !== lastDeletedSegmentEnd && lastDeletedSegmentEnd > rangeStart && thisSegment.start - lastDeletedSegmentEnd <= MAX_BUFFERED_DISTANCE ? thisSegment.bufferedStart = lastDeletedSegmentEnd : thisSegment.start - rangeStart <= MAX_BUFFERED_DISTANCE ? thisSegment.bufferedStart = rangeStart : thisSegment.bufferedStart = thisSegment.start), 
                        thisSegment = inventory[++inventoryIndex]; thisSegment && rangeEnd - 
                        // TODO better way to indicate to typescript that all is well here
                        takeFirstSet(thisSegment.bufferedStart, thisSegment.start) >= segment_bookkeeper_MINIMUM_SEGMENT_SIZE; ) {
                            var prevSegment = inventory[inventoryIndex - 1];
                            // those segments are contiguous, we have no way to infer their real
                            // end
                                                        null == prevSegment.bufferedEnd && (prevSegment.bufferedEnd = prevSegment.end), 
                            thisSegment.bufferedStart = prevSegment.bufferedEnd, thisSegment = inventory[++inventoryIndex];
                        }
                        // update the bufferedEnd of the last segment in that range
                                                var lastSegmentInRange = inventory[inventoryIndex - 1];
                        lastSegmentInRange && (null != lastSegmentInRange.bufferedEnd && lastSegmentInRange.bufferedEnd > rangeEnd ? 
                        // the segment appears to have been partially garbage collected:
                        // Update bufferedEnd
                        lastSegmentInRange.bufferedEnd = rangeEnd : null == lastSegmentInRange.bufferedEnd && (lastSegmentInRange.bufferedEnd = rangeEnd - lastSegmentInRange.end <= MAX_BUFFERED_DISTANCE ? rangeEnd : lastSegmentInRange.end));
                    }
                }
                // if we still have segments left, they are not affiliated to any range.
                // They might have been garbage collected, delete them from here.
                                thisSegment && inventory.splice(inventoryIndex, inventory.length - inventoryIndex);
            }, 
            /**
     * Add a new segment in the inventory.
     *
     * Note: As new segments can "replace" partially or completely old ones, we
     * have to perform a complex logic and might update previously added segments.
     *
     * @param {Object} segment
     * @param {Number} start - start time of the segment, in seconds
     * @param {Number|undefined} end - end time of the segment, in seconds. Can
     * be undefined in some rare cases
     * @param {Number} bitrate - bitrate of the representation the segment is in
     */
            SegmentBookkeeper.prototype.insert = function insert(period, adaptation, representation, segment, start, end) {
                // TODO (*very* low-priority) manage segments whose end is unknown (rare but
                // could eventually happen).
                // This should be properly managed in this method, but it is not in some
                // other methods of this class, so I decided to not one of those to the
                // inventory by security
                if (null != end) {
                    // begin by the end as in most use cases this will be faster
                    for (var inventory = this.inventory, newSegment = {
                        start: start,
                        end: end,
                        bufferedStart: void 0,
                        bufferedEnd: void 0,
                        infos: {
                            segment: segment,
                            period: period,
                            adaptation: adaptation,
                            representation: representation
                        }
                    }, i = inventory.length - 1
                    // infer start and end from the segment data
                    // /!\ Can be a little different than their real start/end time in the
                    // sourcebuffer.
                    // const start = segment.time / segment.timescale;
                    // const end = (segment.time + segment.duration) / segment.timescale;
                    ; i >= 0; i--) {
                        var segmentI = inventory[i];
                        if (segmentI.start /* - SEGMENT_EPSILON */ <= start) return segmentI.end /* - SEGMENT_EPSILON */ <= start ? 
                        // our segment is after, push it after this one
                        //
                        // Case 1:
                        //   segmentI     : |------|
                        //   newSegment   :        |------|
                        //
                        // Case 2:
                        //   segmentI     : |------|
                        //   newSegment   :          |------|
                        void this.inventory.splice(i + 1, 0, newSegment) : 
                        // /!\ also goes here if end is undefined
                        segmentI.start >= start /* - SEGMENT_EPSILON */ ? 
                        // In those cases, replace
                        // Case 1:
                        //  segmentI     : |-------|
                        //  newSegment   : |-------|
                        //
                        // Case 2:
                        //  segmentI     : |-------|
                        //  newSegment   : |----------|
                        //
                        // Case 3:
                        //  segmentI     : |-------|
                        //  newSegment   : |???*
                        //
                        // Case 4:
                        //  segmentI     : |???*
                        //  newSegment   : |------|
                        //
                        // Case 5:
                        //  segmentI     : |???*
                        //  newSegment   : |???*
                        //
                        // *|??? - unknown end
                        void this.inventory.splice(i, 1, newSegment) : (
                        // our segment has a "complex" relation with this one,
                        // update the old one end and add this one after it.
                        //
                        // Case 1:
                        //  segmentI     : |-------|
                        //  newSegment   :    |------|
                        //
                        // Case 2:
                        //  segmentI     : |-------|
                        //  newSegment   :    |----|
                        //
                        // Case 3:
                        //  segmentI     : |-------|
                        //  newSegment   :    |???*
                        //
                        // Case 4:
                        //  segmentI     : |???*
                        //  newSegment   :    |----|
                        //
                        // Case 5:
                        //  segmentI     : |???*
                        //  newSegment   :    |???*
                        //
                        // *|??? - unknown end
                        // (if segment's end is not known yet, it could perfectly
                        // end before the one we're adding now)
                        null != segmentI.end && (segmentI.end = start), void this.inventory.splice(i + 1, 0, newSegment));
                    }
                    // if we got here, we are the first segment
                    // check bounds of the previous first segment
                                        var firstSegment = this.inventory[0];
                    firstSegment ? null != end ? firstSegment.start >= end ? 
                    // our segment is before, put it before
                    // Case 1:
                    //  firstSegment :      |----|
                    //  newSegment   : |----|
                    //
                    // Case 2:
                    //  firstSegment :        |----|
                    //  newSegment   : |----|
                    //
                    // Case 3:
                    //  firstSegment :        |???*
                    //  newSegment   : |----|
                    //
                    // Case 4:
                    //  firstSegment :      |???*
                    //  newSegment   : |----|
                    //
                    // *|??? - unknown end
                    this.inventory.splice(0, 0, newSegment) : firstSegment.end /* - SEGMENT_EPSILON */ <= end ? 
                    // Our segment is bigger, replace the first
                    // Case 1:
                    //  firstSegment :   |---|
                    //  newSegment   : |-------|
                    //
                    // Case 2:
                    //  firstSegment :   |-----|
                    //  newSegment   : |-------|
                    this.inventory.splice(0, 1, newSegment) : (
                    // our segment has a "complex" relation with the first one,
                    // update the old one start and add this one before it.
                    // Case 1:
                    //  firstSegment :    |------|
                    //  newSegment   : |------|
                    //
                    // Case 2:
                    // firstSegment :   |???*
                    // newSegment   : |-----|
                    //
                    // *|??? - unknown end
                    firstSegment.start = end, this.inventory.splice(0, 0, newSegment)) : firstSegment.start === start ? 
                    // same beginning, unknown end, just replace
                    // Case 1:
                    //  firstSegment : |-------|
                    //  newSegment   : |???*
                    //
                    // Case 2:
                    //  firstSegment : |???*
                    //  newSegment   : |???*
                    //
                    // *|??? - unknown end
                    this.inventory.splice(0, 1, newSegment) : 
                    // our segment begins before this one, push at the beginning
                    // Case 1:
                    // firstSegment :   |-------|
                    // newSegment   : |???*
                    //
                    // Case 2:
                    // firstSegment :   |???*
                    // newSegment   : |???*
                    //
                    // *|??? - unknown end
                    this.inventory.splice(0, 0, newSegment) : 
                    // we do not have any segment yet
                    this.inventory.push(newSegment);
                } else 
                // This leads to excessive re-downloads of segment without an ending time.
                log.a.warn("SegmentBookkeeper: ending time of the segment not defined");
            }, 
            /**
     * Returns segment infos for a segment corresponding to the given time,
     * duration and timescale.
     *
     * Returns null if either:
     *   - no segment can be linked exactly to the given time/duration
     *   - a segment is linked to this information, but is currently considered
     *     "incomplete" to be playable, in the sourceBuffer. We check if all
     *     needed data for playback (from wanted range) is loaded.
     *
     * The main purpose of this method is to know if the segment asked should be
     * downloaded (or re-downloaded).
     *
     * /!\ Make sure that this class is synchronized with the sourceBuffer
     * (see addBufferedInfos method of the same class) before calling this method,
     * as it depends on it to categorize "incomplete" from "complete" segments.
     *
     * @param {Object} wantedRange
     * @param {Number} time
     * @param {Number} duration
     * @param {Number} timescale
     * @returns {Object|null}
     */
            SegmentBookkeeper.prototype.hasPlayableSegment = function hasPlayableSegment(wantedRange, segmentInfos) {
                for (var time = segmentInfos.time, duration = segmentInfos.duration, timescale = segmentInfos.timescale, inventory = this.inventory, i = inventory.length - 1; i >= 0; i--) {
                    var currentSegmentI = inventory[i], prevSegmentI = inventory[i - 1], nextSegmentI = inventory[i + 1], segment = currentSegmentI.infos.segment, _time = time, _duration = duration;
                    if (segment.timescale !== timescale && (
                    // Note: we could get rounding errors here
                    _time = time * segment.timescale / timescale, _duration = duration * segment.timescale / timescale), 
                    segment.time === _time && segment.duration === _duration && hasEnoughInfos(currentSegmentI, prevSegmentI, nextSegmentI) && hasWantedRange(wantedRange, currentSegmentI, prevSegmentI, nextSegmentI)) return currentSegmentI;
                }
                return null;
                // -- Helpers
                /**
         * Check if segment can be evaluated.
         * @param {Object} currentSegmentI
         * @param {Object} prevSegmentI
         * @param {Object} nextSegmentI
         * @returns {Boolean}
         */                function hasEnoughInfos(currentSegmentI, prevSegmentI, nextSegmentI) {
                    return !(prevSegmentI && null == prevSegmentI.bufferedEnd || null == currentSegmentI.bufferedStart) && !(nextSegmentI && null == nextSegmentI.bufferedStart || null == currentSegmentI.bufferedEnd);
                }
                /**
         * Returns true if the segment given can be played for the wanted range.
         * @param {Object} _wantedRange
         * @param {Object} currentSegmentI
         * @param {Object} prevSegmentI
         * @param {Object} nextSegmentI
         * @returns {Boolean}
         */                function hasWantedRange(_wantedRange, currentSegmentI, prevSegmentI, nextSegmentI) {
                    if (!prevSegmentI || null == prevSegmentI.bufferedEnd || null == currentSegmentI.bufferedStart || prevSegmentI.bufferedEnd < currentSegmentI.bufferedStart) {
                        if (null == currentSegmentI.bufferedStart) return !1;
                        var timeDiff = currentSegmentI.bufferedStart - currentSegmentI.start;
                        if (_wantedRange.start > currentSegmentI.start) {
                            if (currentSegmentI.bufferedStart - _wantedRange.start > 0 && timeDiff > MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT) return log.a.debug("The wanted segment has been garbage collected", currentSegmentI), 
                            !1;
                        } else if (timeDiff > MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT) return log.a.debug("The wanted segment has been garbage collected", currentSegmentI), 
                        !1;
                    }
                    if (null === currentSegmentI.end) return !1;
                    if (!nextSegmentI || null == nextSegmentI.bufferedStart || null == currentSegmentI.bufferedEnd || nextSegmentI.bufferedStart > currentSegmentI.bufferedEnd) {
                        if (null == currentSegmentI.bufferedEnd) return !1;
                        var _timeDiff = currentSegmentI.end - currentSegmentI.bufferedEnd;
                        if (_wantedRange.end < currentSegmentI.end) {
                            if (_wantedRange.end - currentSegmentI.bufferedEnd > 0 && _timeDiff > MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT) return log.a.debug("The wanted segment has been garbage collected", currentSegmentI), 
                            !1;
                        } else if (_timeDiff > MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT) return log.a.debug("The wanted segment has been garbage collected", currentSegmentI), 
                        !1;
                    }
                    return !0;
                }
            }, 
            /**
     * Empty the current inventory
     */
            SegmentBookkeeper.prototype.reset = function reset() {
                this.inventory = [];
            }, SegmentBookkeeper;
        }(), speed_manager = __webpack_require__(95), stalling_manager = __webpack_require__(89), video_events = __webpack_require__(86);
        /**
 * Keep track of every segment downloaded and currently in the browser's memory.
 *
 * The main point of this class is to know which CDN segments are already
 * pushed to the SourceBuffer, at which bitrate, and which have been
 * garbage-collected since by the browser (and thus should be re-downloaded).
 * @class SegmentBookkeeper
 */        
        // CONCATENATED MODULE: ./src/core/stream/index.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        function getManifestPipelineOptions(networkConfig) {
            return {
                maxRetry: null != networkConfig.manifestRetry ? networkConfig.manifestRetry : config.a.DEFAULT_MAX_MANIFEST_REQUEST_RETRY,
                maxRetryOffline: null != networkConfig.offlineRetry ? networkConfig.offlineRetry : config.a.DEFAULT_MAX_PIPELINES_RETRY_ON_ERROR
            };
        }
        /**
 * Central part of the player. Play a given stream described by the given
 * manifest with given options.
 *
 * On subscription:
 *  - Creates the MediaSource and attached sourceBuffers instances.
 *  - download the content's manifest
 *  - Perform EME management if needed
 *  - get Buffers for each active adaptations.
 *  - give choice of the adaptation to the caller (e.g. to choose a language)
 *  - returns Observable emitting notifications about the stream lifecycle.
 *
 * @param {Object} args
 * @returns {Observable}
 */        function Stream(_ref) {
            var adaptiveOptions = _ref.adaptiveOptions, autoPlay = _ref.autoPlay, bufferOptions = _ref.bufferOptions, clock$ = _ref.clock$, keySystems = _ref.keySystems, networkConfig = _ref.networkConfig, speed$ = _ref.speed$, startAt = _ref.startAt, supplementaryImageTracks = _ref.supplementaryImageTracks, supplementaryTextTracks = _ref.supplementaryTextTracks, textTrackOptions = _ref.textTrackOptions, transport = _ref.transport, url = _ref.url, videoElement = _ref.videoElement, wantedBufferAhead$ = bufferOptions.wantedBufferAhead$, maxBufferAhead$ = bufferOptions.maxBufferAhead$, maxBufferBehind$ = bufferOptions.maxBufferBehind$, warning$ = new Subject.a(), fetchManifest = throttle(createManifestPipeline(transport, getManifestPipelineOptions(networkConfig), warning$, supplementaryTextTracks, supplementaryImageTracks)), garbageCollectors = new weak_map_memory(function(qSourceBuffer) {
                return BufferGarbageCollector({
                    queuedSourceBuffer: qSourceBuffer,
                    clock$: clock$.pipe(Object(map.a)(function(tick) {
                        return tick.currentTime;
                    })),
                    maxBufferBehind$: maxBufferBehind$,
                    maxBufferAhead$: maxBufferAhead$
                });
            }), segmentBookkeepers = new weak_map_memory(function() {
                return new segment_bookkeeper();
            }), stream$ = createMediaSource(videoElement).pipe(Object(mergeMap.a)(function(mediaSource) {
                return Object(combineLatest.a)(fetchManifest(url), Object(events.n)(mediaSource).pipe(Object(take.a)(1))).pipe(Object(mergeMap.a)(function(_ref2) {
                    var manifest = _ref2[0];
                    return initializeStream(mediaSource, manifest);
                }));
            })), warningEvents$ = warning$.pipe(Object(map.a)(stream_events.a.warning));
            return Object(merge.a)(stream$, warningEvents$);
            /**
   * Initialize stream playback by merging all observable that are required to
   * make the system cooperate.
   * @param {MediaSource} mediaSource
   * @param {Object} manifest
   * @returns {Observable}
   */            function initializeStream(mediaSource, manifest) {
                setDurationToMediaSource(mediaSource, manifest.getDuration()), log.a.debug("calculating initial time");
                var initialTime = getInitialTime(manifest, startAt);
                log.a.debug("initial time calculated:", initialTime);
                var firstPeriodToPlay = manifest.getPeriodForTime(initialTime);
                if (null == firstPeriodToPlay) throw new MediaError.a("MEDIA_STARTING_TIME_NOT_FOUND", null, !0);
                var _handleInitialVideoEv = Object(video_events.a)(videoElement, initialTime, autoPlay), initialSeek$ = _handleInitialVideoEv.initialSeek$, loadAndPlay$ = _handleInitialVideoEv.loadAndPlay$, bufferClock$ = createBufferClock(manifest, clock$, initialSeek$, initialTime), network$ = new Subject.a(), requestsInfos$ = new Subject.a(), segmentPipelinesManager = new pipelines_segment(transport, requestsInfos$, network$, warning$), abrManager = new abr(requestsInfos$, network$, adaptiveOptions), abrClock$ = Object(combineLatest.a)(clock$, speed$).pipe(Object(map.a)(function(_ref3) {
                    var tick = _ref3[0], speed = _ref3[1];
                    return {
                        bufferGap: tick.bufferGap,
                        duration: tick.duration,
                        isLive: manifest.isLive,
                        position: tick.currentTime,
                        speed: speed
                    };
                })), bufferManager = new core_buffer(abrManager, abrClock$), sourceBufferManager = new source_buffers(videoElement, mediaSource), cancelEndOfStream$ = new Subject.a(), bufferEventHandler = manifest.isLive ? liveEventsHandler(videoElement, manifest, fetchManifest) : of.a, buffers$ = BuffersHandler({
                    manifest: manifest,
                    period: firstPeriodToPlay
                }, // content
                bufferClock$, wantedBufferAhead$, bufferManager, sourceBufferManager, segmentPipelinesManager, segmentBookkeepers, garbageCollectors, {
                    maxRetry: networkConfig.segmentRetry,
                    maxRetryOffline: networkConfig.offlineRetry,
                    textTrackOptions: textTrackOptions
                }, warning$).pipe(Object(mergeMap.a)(function(evt) {
                    switch (evt.type) {
                      case "end-of-stream":
                        return maintainEndOfStream(mediaSource).pipe(Object(ignoreElements.a)(), Object(takeUntil.a)(cancelEndOfStream$));

                      case "resume-stream":
                        return cancelEndOfStream$.next(null), empty.a;

                      default:
                        return bufferEventHandler(evt);
                    }
                })), emeManager$ = Object(create_eme_manager.a)(videoElement, keySystems, warning$), mediaErrorHandler$ = Object(media_error_handler.a)(videoElement), speedManager$ = Object(speed_manager.a)(videoElement, speed$, clock$, {
                    pauseWhenStalled: !0
                }).pipe(Object(map.a)(stream_events.a.speedChanged)), stallingManager$ = Object(stalling_manager.a)(videoElement, clock$).pipe(Object(map.a)(stream_events.a.stalled)), manifestReadyEvent$ = Object(of.a)(stream_events.a.manifestReady(abrManager, manifest)), loadedEvent$ = loadAndPlay$.pipe(Object(mapTo.a)(stream_events.a.loaded()));
                return Object(merge.a)(manifestReadyEvent$, loadedEvent$, buffers$, emeManager$, // TODO RxJS Bug?
                mediaErrorHandler$, // TODO RxJS Bug?
                speedManager$, stallingManager$).pipe(finalize(function() {
                    // clean-up every created SourceBuffers
                    sourceBufferManager.disposeAll();
                }));
            }
        }
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/refCount.js
                var refCount = __webpack_require__(90), SAMPLING_INTERVAL_MEDIASOURCE = config.a.SAMPLING_INTERVAL_MEDIASOURCE, SAMPLING_INTERVAL_NO_MEDIASOURCE = config.a.SAMPLING_INTERVAL_NO_MEDIASOURCE, RESUME_GAP_AFTER_SEEKING = config.a.RESUME_GAP_AFTER_SEEKING, RESUME_GAP_AFTER_NOT_ENOUGH_DATA = config.a.RESUME_GAP_AFTER_NOT_ENOUGH_DATA, RESUME_GAP_AFTER_BUFFERING = config.a.RESUME_GAP_AFTER_BUFFERING, STALL_GAP = config.a.STALL_GAP, SCANNED_VIDEO_EVENTS = [ "canplay", "play", "progress", "seeking", "seeked", "loadedmetadata", "canplay", "ratechange" ];
        // CONCATENATED MODULE: ./src/core/api/clock.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * This file defines a global clock for the RxPlayer.
 *
 * Each clock tick also pass informations about the current state of the
 * video element to sub-parts of the player.
 */        
        /**
 * Returns the amount of time in seconds the buffer should have ahead of the
 * current position before resuming playback. Based on the infos of the stall.
 * Waiting time differs between a "seeking" stall and a buffering stall.
 * @param {Object|null} stalled
 * @returns {Number}
 */
        function getResumeGap(stalled) {
            if (!stalled) return 0;
            switch (stalled.reason) {
              case "seeking":
                return RESUME_GAP_AFTER_SEEKING;

              case "not-ready":
                return RESUME_GAP_AFTER_NOT_ENOUGH_DATA;

              default:
                return RESUME_GAP_AFTER_BUFFERING;
            }
        }
        /**
 * TODO I just don't get it for this one.
 * gap + range.end ??? HELP
 * @param {Number} gap
 * @param {Object} range
 * @param {Number} duration
 * @returns {Boolean}
 */        function isEnding(bufferGap, currentRange, duration) {
            return null != currentRange && duration - (bufferGap + currentRange.end) <= STALL_GAP;
        }
        /**
 * Generate a basic timings object from the video element and the eventName
 * which triggered the request.
 * @param {HTMLMediaElement} video
 * @param {string} currentState
 * @returns {Object}
 */        function getVideoInfos(video, currentState) {
            var buffered = video.buffered, currentTime = video.currentTime, duration = video.duration, ended = video.ended, paused = video.paused, playbackRate = video.playbackRate, readyState = video.readyState, seeking = video.seeking;
            return {
                bufferGap: Object(utils_ranges.c)(buffered, currentTime),
                buffered: buffered,
                currentRange: Object(utils_ranges.f)(buffered, currentTime),
                currentTime: currentTime,
                duration: duration,
                ended: ended,
                paused: paused,
                playbackRate: playbackRate,
                readyState: readyState,
                seeking: seeking,
                state: currentState
            };
        }
        /**
 * Infer stalled status of the video based on:
 *   - the return of the function getVideoInfos
 *   - the previous timings object.
 *
 * @param {Object} prevTimings - Previous timings object. See function to know
 * the different properties needed.
 * @param {Object} currentTimings - Current timings object. This does not need
 * to have every single infos, see function to know which properties are needed.
 * @param {Boolean} withMediaSource - False if the directfile API is used.
 * @returns {Object|null}
 */        function getStalledStatus(prevTimings, currentTimings, withMediaSource) {
            var currentState = currentTimings.state, currentTime = currentTimings.currentTime, bufferGap = currentTimings.bufferGap, currentRange = currentTimings.currentRange, duration = currentTimings.duration, paused = currentTimings.paused, readyState = currentTimings.readyState, ended = currentTimings.ended, prevStalled = prevTimings.stalled, prevState = prevTimings.state, prevTime = prevTimings.currentTime, ending = isEnding(bufferGap, currentRange, duration), canStall = readyState >= 1 && "loadedmetadata" !== currentState && !prevStalled && !(ending || ended), shouldStall = void 0, shouldUnstall = void 0;
            if (withMediaSource ? canStall && (bufferGap <= STALL_GAP || Infinity === bufferGap || 1 === readyState) ? shouldStall = !0 : prevStalled && readyState > 1 && bufferGap < Infinity && (bufferGap > getResumeGap(prevStalled) || ending || ended) && (shouldUnstall = !0) : canStall && (!paused && "timeupdate" === currentState && "timeupdate" === prevState && currentTime === prevTime || "seeking" === currentState && Infinity === bufferGap) ? shouldStall = !0 : prevStalled && ("seeking" !== currentState && currentTime !== prevTime || "canplay" === currentState || bufferGap < Infinity && (bufferGap > getResumeGap(prevStalled) || ending || ended)) && (shouldUnstall = !0), 
            shouldStall) {
                return {
                    reason: "seeking" === currentState || currentTimings.seeking ? "seeking" : 1 === readyState ? "not-ready" : "buffering",
                    timestamp: Date.now()
                };
            }
            return shouldUnstall ? null : prevStalled;
        }
        /**
 * Timings observable.
 *
 * This streams samples snapshots of player's current state:
 *   * time position
 *   * playback rate
 *   * current buffered range
 *   * gap with current buffered range ending
 *   * video duration
 *
 * In addition to sampling, this stream also reacts to "seeking" and "play"
 * events.
 *
 * Observable is shared for performance reason: reduces the number of event
 * listeners and intervals/timeouts but also limit access to <video>
 * properties and gap calculations.
 *
 * The sampling is manual instead of based on "timeupdate" to reduce the
 * number of events.
 * @param {HTMLMediaElement} video
 * @param {Object} options
 * @returns {Observable}
 */        
        /* harmony default export */ var api_clock = function createClock(video, _ref) {
            var withMediaSource = _ref.withMediaSource;
            return Observable.a.create(function(obs) {
                var lastTimings = object_assign_default()(getVideoInfos(video, "init"), {
                    stalled: null
                });
                /**
         * Emit timings sample.
         * Meant to be used as a callback on various async events.
         * @param {Event} [evt] - The Event which triggered the callback, if one.
         */                function emitSample(evt) {
                    var timingEventType = evt && evt.type || "timeupdate", videoTimings = getVideoInfos(video, timingEventType), stalledState = getStalledStatus(lastTimings, videoTimings, withMediaSource);
                    // /!\ Mutate videoTimings
                    lastTimings = object_assign_default()(videoTimings, {
                        stalled: stalledState
                    }), obs.next(lastTimings);
                }
                var intervalID = setInterval(emitSample, withMediaSource ? SAMPLING_INTERVAL_MEDIASOURCE : SAMPLING_INTERVAL_NO_MEDIASOURCE);
                return SCANNED_VIDEO_EVENTS.forEach(function(eventName) {
                    return video.addEventListener(eventName, emitSample);
                }), obs.next(lastTimings), function() {
                    clearInterval(intervalID), SCANNED_VIDEO_EVENTS.forEach(function(eventName) {
                        return video.removeEventListener(eventName, emitSample);
                    });
                };
            }).pipe(Object(multicast.a)(function() {
                return new ReplaySubject.a(1);
            }), // Always emit the last
            Object(refCount.a)());
        }, PLAYER_STATES = {
            STOPPED: "STOPPED",
            LOADED: "LOADED",
            LOADING: "LOADING",
            PLAYING: "PLAYING",
            PAUSED: "PAUSED",
            ENDED: "ENDED",
            BUFFERING: "BUFFERING",
            SEEKING: "SEEKING"
        };
        // CONCATENATED MODULE: ./src/core/api/constants.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * This file declares constants useful for every API files.
 */
        /**
 * Player state dictionnary
 * @type {Object}
 */        
        // CONCATENATED MODULE: ./src/core/api/get_player_state.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Get state string for a loaded content.
 * @param {HTMLMediaElement} mediaElement
 * @param {boolean} isPlaying - false when the player is paused. true otherwise.
 * @param {Object} stalledStatus - Current stalled state:
 *   - null when not stalled
 *   - an object with a description of the situation if stalled.
 * @returns {string}
 */
        function getLoadedContentState(mediaElement, isPlaying, stalledStatus) {
            if (mediaElement.ended) return PLAYER_STATES.ENDED;
            if (stalledStatus) {
                // TODO This is a TypeScript bug. Try to reproduce it easily and
                // open an issue:
                // Basically, putting this line at the top of the file would
                // trigger a TypeScript error down the line.
                var FORCED_ENDED_THRESHOLD = config.a.FORCED_ENDED_THRESHOLD, gapBetweenDurationAndCurrentTime = Math.abs(mediaElement.duration - mediaElement.currentTime);
                // On some old browsers (e.g. Chrome 54), the browser does not
                // emit an 'ended' event in some conditions. Detect if we
                // reached the end by comparing the current position and the
                // duration instead.
                                return null != FORCED_ENDED_THRESHOLD && gapBetweenDurationAndCurrentTime < FORCED_ENDED_THRESHOLD ? PLAYER_STATES.ENDED : "seeking" === stalledStatus.reason ? PLAYER_STATES.SEEKING : PLAYER_STATES.BUFFERING;
            }
            return isPlaying ? PLAYER_STATES.PLAYING : PLAYER_STATES.PAUSED;
        }
        // CONCATENATED MODULE: ./src/core/api/language_manager.ts
                var _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
            return typeof obj;
        } : function(obj) {
            return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
        function language_manager_classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * This file is used to abstract the notion of text and audio language-switching
 * for an easier API management.
 */
        /**
 * Manage audio and text tracks for all active periods.
 *
 * Most methods here allow to interact with the first chronologically added
 * Period.
 *
 * Languages for subsequent periods are also chosen accordingly.
 * @class LanguageManager
 */        var language_manager = function() {
            /**
     * @param {Object} defaults
     */
            function LanguageManager() {
                var defaults = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                language_manager_classCallCheck(this, LanguageManager);
                var preferredAudioTracks = defaults.preferredAudioTracks, preferredTextTracks = defaults.preferredTextTracks;
                this._periods = new sorted_list(function(a, b) {
                    return a.period.start - b.period.start;
                }), this._audioChoiceMemory = new WeakMap(), this._textChoiceMemory = new WeakMap(), 
                this._preferredAudioTracks = preferredAudioTracks || [], this._preferredTextTracks = preferredTextTracks || [];
            }
            /**
     * Add Subject to choose Adaptation for new "audio" or "text" Period.
     * @param {string} bufferType
     * @param {Period} period
     * @param {Subject} adaptations
     */            return LanguageManager.prototype.addPeriod = function addPeriod(bufferType, period, adaptation$) {
                var periodItem = getPeriodItem(this._periods, period);
                if (null != periodItem) {
                    if (null != periodItem[bufferType]) return void log.a.warn("LanguageManager: " + bufferType + " already added for period", period);
                    periodItem[bufferType] = {
                        adaptations: period.adaptations[bufferType] || [],
                        adaptation$: adaptation$
                    };
                } else {
                    var _periods$add;
                    this._periods.add(((_periods$add = {
                        period: period
                    })[bufferType] = {
                        adaptations: period.adaptations[bufferType] || [],
                        adaptation$: adaptation$
                    }, _periods$add));
                }
            }, 
            /**
     * Remove Subject to choose an "audio" or "text" Adaptation for a Period.
     * @param {string} bufferType
     * @param {Period} period
     */
            LanguageManager.prototype.removePeriod = function removePeriod(bufferType, period) {
                var periodIndex = findPeriodIndex(this._periods, period);
                if (null != periodIndex) {
                    var periodItem = this._periods.get(periodIndex);
                    null != periodItem[bufferType] ? (delete periodItem[bufferType], null == periodItem.audio && null == periodItem.text && this._periods.removeFirst(periodItem)) : log.a.warn("LanguageManager: " + bufferType + " already removed for period", period);
                } else log.a.warn("LanguageManager: " + bufferType + " not found for period", period);
            }, 
            /**
     * Update the choice of all added Periods based on:
     *   1. What was the last chosen adaptation
     *   2. If not found, the preferences
     */
            LanguageManager.prototype.update = function update() {
                this._updateAudioTrackChoices(), this._updateTextTrackChoices();
            }, 
            /**
     * Emit initial audio Adaptation through the given Subject based on:
     *   - the preferred audio tracks
     *   - the last choice for this period, if one
     * @param {Period} period
     *
     * @throws Error - Throws if the period given has not been added
     */
            LanguageManager.prototype.setInitialAudioTrack = function setInitialAudioTrack(period) {
                var periodItem = getPeriodItem(this._periods, period), audioInfos = periodItem && periodItem.audio;
                if (!audioInfos || !periodItem) throw new Error("LanguageManager: Given Period not found.");
                var preferredAudioTracks = this._preferredAudioTracks, audioAdaptations = period.adaptations.audio || [], chosenAudioAdaptation = this._audioChoiceMemory.get(period);
                if (void 0 !== chosenAudioAdaptation && Object(array_includes.a)(audioAdaptations, chosenAudioAdaptation)) audioInfos.adaptation$.next(chosenAudioAdaptation); else {
                    var optimalAdaptation = findFirstOptimalAudioAdaptation(audioAdaptations, preferredAudioTracks);
                    this._audioChoiceMemory.set(period, optimalAdaptation), audioInfos.adaptation$.next(optimalAdaptation);
                }
            }, 
            /**
     * Emit initial text Adaptation through the given Subject based on:
     *   - the preferred text tracks
     *   - the last choice for this period, if one
     * @param {Period} period
     *
     * @throws Error - Throws if the period given has not been added
     */
            LanguageManager.prototype.setInitialTextTrack = function setInitialTextTrack(period) {
                var periodItem = getPeriodItem(this._periods, period), textInfos = periodItem && periodItem.text;
                if (!textInfos || !periodItem) throw new Error("LanguageManager: Given Period not found.");
                var preferredTextTracks = this._preferredTextTracks, textAdaptations = period.adaptations.text || [], chosenTextAdaptation = this._textChoiceMemory.get(period);
                if (void 0 !== chosenTextAdaptation && Object(array_includes.a)(textAdaptations, chosenTextAdaptation)) textInfos.adaptation$.next(chosenTextAdaptation); else {
                    var optimalAdaptation = findFirstOptimalTextAdaptation(textAdaptations, preferredTextTracks);
                    this._textChoiceMemory.set(period, optimalAdaptation), textInfos.adaptation$.next(optimalAdaptation);
                }
            }, 
            /**
     * Set audio track based on the ID of its adaptation for a given added Period.
     *
     * @param {Period} period - The concerned Period.
     * @param {string} wantedId - adaptation id of the wanted track
     *
     * @throws Error - Throws if the period given has not been added
     * @throws Error - Throws if the given id is not found in any audio adaptation
     * of the given Period.
     */
            LanguageManager.prototype.setAudioTrackByID = function setAudioTrackByID(period, wantedId) {
                var periodItem = getPeriodItem(this._periods, period), audioInfos = periodItem && periodItem.audio;
                if (!audioInfos) throw new Error("LanguageManager: Given Period not found.");
                var wantedAdaptation = find_default()(audioInfos.adaptations, function(_ref) {
                    return _ref.id === wantedId;
                });
                if (void 0 === wantedAdaptation) throw new Error("Audio Track not found.");
                this._audioChoiceMemory.get(period) !== wantedAdaptation && (this._audioChoiceMemory.set(period, wantedAdaptation), 
                audioInfos.adaptation$.next(wantedAdaptation));
            }, 
            /**
     * Set text track based on the ID of its adaptation for a given added Period.
     *
     * @param {Period} period - The concerned Period.
     * @param {string} wantedId - adaptation id of the wanted track
     *
     * @throws Error - Throws if the period given has not been added
     * @throws Error - Throws if the given id is not found in any text adaptation
     * of the given Period.
     */
            LanguageManager.prototype.setTextTrackByID = function setTextTrackByID(period, wantedId) {
                var periodItem = getPeriodItem(this._periods, period), textInfos = periodItem && periodItem.text;
                if (!textInfos) throw new Error("LanguageManager: Given Period not found.");
                var wantedAdaptation = find_default()(textInfos.adaptations, function(_ref2) {
                    return _ref2.id === wantedId;
                });
                if (void 0 === wantedAdaptation) throw new Error("Text Track not found.");
                this._textChoiceMemory.get(period) !== wantedAdaptation && (this._textChoiceMemory.set(period, wantedAdaptation), 
                textInfos.adaptation$.next(wantedAdaptation));
            }, 
            /**
     * Disable the given audio track for a given Period.
     *
     * @param {Period} period - The concerned Period.
     *
     * @throws Error - Throws if the period given has not been added
     */
            LanguageManager.prototype.disableAudioTrack = function disableAudioTrack(period) {
                var periodItem = getPeriodItem(this._periods, period), audioInfos = periodItem && periodItem.audio;
                if (!audioInfos) throw new Error("LanguageManager: Given Period not found.");
                null !== this._audioChoiceMemory.get(period) && (this._audioChoiceMemory.set(period, null), 
                audioInfos.adaptation$.next(null));
            }, 
            /**
     * Disable the current text track for a given period.
     *
     * @param {Period} period - The concerned Period.
     *
     * @throws Error - Throws if the period given has not been added
     */
            LanguageManager.prototype.disableTextTrack = function disableTextTrack(period) {
                var periodItem = getPeriodItem(this._periods, period), textInfos = periodItem && periodItem.text;
                if (!textInfos) throw new Error("LanguageManager: Given Period not found.");
                null !== this._textChoiceMemory.get(period) && (this._textChoiceMemory.set(period, null), 
                textInfos.adaptation$.next(null));
            }, 
            /**
     * Returns an object describing the chosen audio track for the given audio
     * Period.
     *
     * Returns null is the the current audio track is disabled or not
     * set yet.
     *
     * @param {Period} period
     * @returns {Object|null}
     */
            LanguageManager.prototype.getChosenAudioTrack = function getChosenAudioTrack(period) {
                var periodItem = getPeriodItem(this._periods, period);
                if (null == (periodItem && periodItem.audio)) return null;
                var chosenAudioAdaptation = this._audioChoiceMemory.get(period);
                return chosenAudioAdaptation ? {
                    language: chosenAudioAdaptation.language || "",
                    normalized: chosenAudioAdaptation.normalizedLanguage || "",
                    audioDescription: !!chosenAudioAdaptation.isAudioDescription,
                    id: chosenAudioAdaptation.id
                } : null;
            }, 
            /**
     * Returns an object describing the chosen text track for the given text
     * Period.
     *
     * Returns null is the the current text track is disabled or not
     * set yet.
     *
     * @param {Period} period
     * @returns {Object|null}
     */
            LanguageManager.prototype.getChosenTextTrack = function getChosenTextTrack(period) {
                var periodItem = getPeriodItem(this._periods, period);
                if (null == (periodItem && periodItem.text)) return null;
                var chosenTextAdaptation = this._textChoiceMemory.get(period);
                return chosenTextAdaptation ? {
                    language: chosenTextAdaptation.language || "",
                    normalized: chosenTextAdaptation.normalizedLanguage || "",
                    closedCaption: !!chosenTextAdaptation.isClosedCaption,
                    id: chosenTextAdaptation.id
                } : null;
            }, 
            /**
     * Returns all available audio tracks for a given Period, as an array of
     * objects.
     *
     * @returns {Array.<Object>}
     */
            LanguageManager.prototype.getAvailableAudioTracks = function getAvailableAudioTracks(period) {
                var periodItem = getPeriodItem(this._periods, period), audioInfos = periodItem && periodItem.audio;
                if (null == audioInfos) return [];
                var chosenAudioAdaptation = this._audioChoiceMemory.get(period), currentId = chosenAudioAdaptation && chosenAudioAdaptation.id;
                return audioInfos.adaptations.map(function(adaptation) {
                    return {
                        language: adaptation.language || "",
                        normalized: adaptation.normalizedLanguage || "",
                        audioDescription: !!adaptation.isAudioDescription,
                        id: adaptation.id,
                        active: null != currentId && currentId === adaptation.id
                    };
                });
            }, 
            /**
     * Returns all available text tracks for a given Period, as an array of
     * objects.
     *
     * @param {Period} period
     * @returns {Array.<Object>}
     */
            LanguageManager.prototype.getAvailableTextTracks = function getAvailableTextTracks(period) {
                var periodItem = getPeriodItem(this._periods, period), textInfos = periodItem && periodItem.text;
                if (null == textInfos) return [];
                var chosenTextAdaptation = this._textChoiceMemory.get(period), currentId = chosenTextAdaptation && chosenTextAdaptation.id;
                return textInfos.adaptations.map(function(adaptation) {
                    return {
                        language: adaptation.language || "",
                        normalized: adaptation.normalizedLanguage || "",
                        closedCaption: !!adaptation.isClosedCaption,
                        id: adaptation.id,
                        active: null != currentId && currentId === adaptation.id
                    };
                });
            }, LanguageManager.prototype._updateAudioTrackChoices = function _updateAudioTrackChoices() {
                var _this = this, preferredAudioTracks = this._preferredAudioTracks;
                !function recursiveUpdateAudioTrack(index) {
                    if (!(index >= _this._periods.length())) {
                        var periodItem = _this._periods.get(index);
                        if (null != periodItem.audio) {
                            var period = periodItem.period, audioItem = periodItem.audio, audioAdaptations = period.adaptations.audio || [], chosenAudioAdaptation = _this._audioChoiceMemory.get(period);
                            if (null === chosenAudioAdaptation || void 0 !== chosenAudioAdaptation && Object(array_includes.a)(audioAdaptations, chosenAudioAdaptation)) 
                            // Already best audio for this Buffer, check next one
                            recursiveUpdateAudioTrack(index + 1); else {
                                var optimalAdaptation = findFirstOptimalAudioAdaptation(audioAdaptations, preferredAudioTracks);
                                _this._audioChoiceMemory.set(period, optimalAdaptation), audioItem.adaptation$.next(optimalAdaptation), 
                                // previous "next" call could have changed everything, start over
                                recursiveUpdateAudioTrack(0);
                            }
                        } else 
                        // No audio Buffer for this period, check next one
                        recursiveUpdateAudioTrack(index + 1);
                    }
                }(0);
            }, LanguageManager.prototype._updateTextTrackChoices = function _updateTextTrackChoices() {
                var _this2 = this, preferredTextTracks = this._preferredTextTracks;
                !function recursiveUpdateTextTrack(index) {
                    if (!(index >= _this2._periods.length())) {
                        var periodItem = _this2._periods.get(index);
                        if (null != periodItem.text) {
                            var period = periodItem.period, textItem = periodItem.text, textAdaptations = period.adaptations.text || [], chosenTextAdaptation = _this2._textChoiceMemory.get(period);
                            if (null === chosenTextAdaptation || void 0 !== chosenTextAdaptation && Object(array_includes.a)(textAdaptations, chosenTextAdaptation)) 
                            // Already best text for this Buffer, check next one
                            recursiveUpdateTextTrack(index + 1); else {
                                var optimalAdaptation = findFirstOptimalTextAdaptation(textAdaptations, preferredTextTracks);
                                _this2._textChoiceMemory.set(period, optimalAdaptation), textItem.adaptation$.next(optimalAdaptation), 
                                // previous "next" call could have changed everything, start over
                                recursiveUpdateTextTrack(0);
                            }
                        } else 
                        // No text Buffer for this period, check next one
                        recursiveUpdateTextTrack(index + 1);
                    }
                }(0);
            }, LanguageManager;
        }();
        // /**
        //  * Returns true if the given audio adaptation is an optimal choice for a period
        //  * given:
        //  *
        //  *   - the list of audio adaptations in the period
        //  *
        //  *   - an array of preferred audio configurations sorted from the most preferred
        //  *     to the least preferred.
        //  *
        //  * @param {Adaptation|null} adaptation
        //  * @param {Array.<Adaptation>} audioAdaptations
        //  * @param {Array.<Object>} preferredAudioTracks
        //  * @returns {Boolean}
        //  */
        // function isAudioAdaptationOptimal(
        //   adaptation : Adaptation|null,
        //   audioAdaptations : Adaptation[],
        //   preferredAudioTracks : IAudioTrackPreference[]
        // ) : boolean {
        //   if (!audioAdaptations.length) {
        //     return adaptation === null;
        //   }
        //   for (let i = 0; i < preferredAudioTracks.length; i++) {
        //     const preferredAudioTrack = preferredAudioTracks[i];
        //     if (preferredAudioTrack === null) {
        //       return adaptation === null;
        //     }
        //     const foundAdaptation = arrayFind(audioAdaptations, (audioAdaptation) =>
        //       audioAdaptation.normalizedLanguage === preferredAudioTrack.normalized &&
        //       !!audioAdaptation.isAudioDescription === preferredAudioTrack.audioDescription
        //     );
        //     if (foundAdaptation !== undefined) {
        //       if (adaptation === null) {
        //         return false;
        //       }
        //       return (
        //         (foundAdaptation.normalizedLanguage || "") ===
        //         (adaptation.normalizedLanguage || "")
        //       ) && !!foundAdaptation.isAudioDescription === !!adaptation.isAudioDescription;
        //     }
        //   }
        //   return true; // no optimal adaptation, just return true
        // }
        /**
 * Find an optimal audio adaptation given their list and the array of preferred
 * audio tracks sorted from the most preferred to the least preferred.
 *
 * null if the most optimal audio adaptation is no audio adaptation.
 * @param {Array.<Adaptation>} audioAdaptations
 * @returns {Adaptation|null}
 */
        /* harmony default export */        function findFirstOptimalAudioAdaptation(audioAdaptations, preferredAudioTracks) {
            if (!audioAdaptations.length) return null;
            for (var _loop = function _loop(i) {
                var preferredAudioTrack = preferredAudioTracks[i];
                if (null === preferredAudioTrack) return {
                    v: null
                };
                var foundAdaptation = find_default()(audioAdaptations, function(audioAdaptation) {
                    return (audioAdaptation.normalizedLanguage || "") === preferredAudioTrack.normalized && !!audioAdaptation.isAudioDescription === preferredAudioTrack.audioDescription;
                });
                return void 0 !== foundAdaptation ? {
                    v: foundAdaptation
                } : void 0;
            }, i = 0; i < preferredAudioTracks.length; i++) {
                var _ret = _loop(i);
                if ("object" === (void 0 === _ret ? "undefined" : _typeof(_ret))) return _ret.v;
            }
            // no optimal adaptation, just return the first one
                        return audioAdaptations[0];
        }
        // /**
        //  * Returns true if the given text adaptation is an optimal choice for a period
        //  * given:
        //  *
        //  *   - the list of text adaptations in the period
        //  *
        //  *   - an array of preferred text configurations sorted from the most preferred
        //  *     to the least preferred.
        //  *
        //  * @param {Adaptation|null} adaptation
        //  * @param {Array.<Adaptation>} audioAdaptations
        //  * @param {Array.<Object>} preferredAudioTracks
        //  * @returns {Boolean}
        //  */
        // function isTextAdaptationOptimal(
        //   adaptation : Adaptation|null,
        //   textAdaptations : Adaptation[],
        //   preferredTextTracks : ITextTrackPreference[]
        // ) : boolean {
        //   if (!textAdaptations.length) {
        //     return adaptation === null;
        //   }
        //   for (let i = 0; i < preferredTextTracks.length; i++) {
        //     const preferredTextTrack = preferredTextTracks[i];
        //     if (preferredTextTrack === null) {
        //       return adaptation === null;
        //     }
        //     const foundAdaptation = arrayFind(textAdaptations, (textAdaptation) =>
        //       (textAdaptation.normalizedLanguage || "") === preferredTextTrack.normalized &&
        //       !!textAdaptation.isClosedCaption === preferredTextTrack.closedCaption
        //     );
        //     if (foundAdaptation !== undefined) {
        //       if (adaptation === null) {
        //         return false;
        //       }
        //       return (
        //         (foundAdaptation.normalizedLanguage || "") ===
        //         (adaptation.normalizedLanguage || "")
        //       ) && !!foundAdaptation.isClosedCaption === !!adaptation.isClosedCaption;
        //     }
        //   }
        //   return adaptation === null;
        // }
        /**
 * Find an optimal text adaptation given their list and the array of preferred
 * text tracks sorted from the most preferred to the least preferred.
 *
 * null if the most optimal text adaptation is no text adaptation.
 * @param {Array.<Adaptation>} audioAdaptations
 * @returns {Adaptation|null}
 */        function findFirstOptimalTextAdaptation(textAdaptations, preferredTextTracks) {
            if (!textAdaptations.length) return null;
            for (var _loop2 = function _loop2(i) {
                var preferredTextTrack = preferredTextTracks[i];
                if (null === preferredTextTrack) return {
                    v: null
                };
                var foundAdaptation = find_default()(textAdaptations, function(textAdaptation) {
                    return (textAdaptation.normalizedLanguage || "") === preferredTextTrack.normalized && !!textAdaptation.isClosedCaption === preferredTextTrack.closedCaption;
                });
                return void 0 !== foundAdaptation ? {
                    v: foundAdaptation
                } : void 0;
            }, i = 0; i < preferredTextTracks.length; i++) {
                var _ret2 = _loop2(i);
                if ("object" === (void 0 === _ret2 ? "undefined" : _typeof(_ret2))) return _ret2.v;
            }
            // no optimal adaptation
                        return null;
        }
        function findPeriodIndex(periods, period) {
            for (var i = 0; i < periods.length(); i++) {
                if (periods.get(i).period.id === period.id) return i;
            }
        }
        function getPeriodItem(periods, period) {
            for (var i = 0; i < periods.length(); i++) {
                var periodI = periods.get(i);
                if (periodI.period.id === period.id) return periodI;
            }
        }
        // CONCATENATED MODULE: ./src/core/api/option_parsers.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * This file exports various helpers to parse options given to various APIs,
 * throw if something is wrong, and return a normalized option object.
 */        var DEFAULT_AUTO_PLAY = config.a.DEFAULT_AUTO_PLAY, DEFAULT_INITIAL_BITRATES = config.a.DEFAULT_INITIAL_BITRATES, DEFAULT_LIMIT_VIDEO_WIDTH = config.a.DEFAULT_LIMIT_VIDEO_WIDTH, DEFAULT_MAX_BITRATES = config.a.DEFAULT_MAX_BITRATES, DEFAULT_MAX_BUFFER_AHEAD = config.a.DEFAULT_MAX_BUFFER_AHEAD, DEFAULT_MAX_BUFFER_BEHIND = config.a.DEFAULT_MAX_BUFFER_BEHIND, DEFAULT_SHOW_NATIVE_SUBTITLE = config.a.DEFAULT_SHOW_NATIVE_SUBTITLE, DEFAULT_TEXT_TRACK_MODE = config.a.DEFAULT_TEXT_TRACK_MODE, DEFAULT_THROTTLE_WHEN_HIDDEN = config.a.DEFAULT_THROTTLE_WHEN_HIDDEN, DEFAULT_WANTED_BUFFER_AHEAD = config.a.DEFAULT_WANTED_BUFFER_AHEAD;
        /**
 * Parse options given to the API constructor and set default options as found
 * in the config.
 *
 * Do not mutate anything, only cross the given options and sane default options
 * (most coming from the config).
 * @param {Object|undefined} options
 * @returns {Object}
 */        function parseConstructorOptions(options) {
            var limitVideoWidth, throttleWhenHidden, maxBufferAhead = void 0, maxBufferBehind = void 0, wantedBufferAhead = void 0, videoElement = void 0, initialVideoBitrate = void 0, initialAudioBitrate = void 0, maxAudioBitrate = void 0, maxVideoBitrate = void 0, stopAtEnd = void 0;
            if (null == options.maxBufferAhead) maxBufferAhead = DEFAULT_MAX_BUFFER_AHEAD; else if (maxBufferAhead = Number(options.maxBufferAhead), 
            isNaN(maxBufferAhead)) throw new Error("Invalid maxBufferAhead parameter. Should be a number.");
            if (null == options.maxBufferBehind) maxBufferBehind = DEFAULT_MAX_BUFFER_BEHIND; else if (maxBufferBehind = Number(options.maxBufferBehind), 
            isNaN(maxBufferBehind)) throw new Error("Invalid maxBufferBehind parameter. Should be a number.");
            if (null == options.wantedBufferAhead) wantedBufferAhead = DEFAULT_WANTED_BUFFER_AHEAD; else if (wantedBufferAhead = Number(options.wantedBufferAhead), 
            isNaN(wantedBufferAhead)) 
            /* tslint:disable:max-line-length */
            throw new Error("Invalid wantedBufferAhead parameter. Should be a number.");
            /* tslint:enable:max-line-length */            if (limitVideoWidth = null == options.limitVideoWidth ? DEFAULT_LIMIT_VIDEO_WIDTH : !!options.limitVideoWidth, 
            throttleWhenHidden = null == options.throttleWhenHidden ? DEFAULT_THROTTLE_WHEN_HIDDEN : !!options.throttleWhenHidden, 
            null == options.videoElement) videoElement = document.createElement("video"); else {
                if (!(options.videoElement instanceof HTMLMediaElement)) 
                /* tslint:disable:max-line-length */
                throw new Error("Invalid videoElement parameter. Should be a HTMLMediaElement.");
                /* tslint:enable:max-line-length */                videoElement = options.videoElement;
            }
            if (null == options.initialVideoBitrate) initialVideoBitrate = DEFAULT_INITIAL_BITRATES.video; else if (initialVideoBitrate = Number(options.initialVideoBitrate), 
            isNaN(initialVideoBitrate)) 
            /* tslint:disable:max-line-length */
            throw new Error("Invalid initialVideoBitrate parameter. Should be a number.");
            /* tslint:enable:max-line-length */            if (null == options.initialAudioBitrate) initialAudioBitrate = DEFAULT_INITIAL_BITRATES.audio; else if (initialAudioBitrate = Number(options.initialAudioBitrate), 
            isNaN(initialAudioBitrate)) 
            /* tslint:disable:max-line-length */
            throw new Error("Invalid initialAudioBitrate parameter. Should be a number.");
            /* tslint:enable:max-line-length */            if (null == options.maxVideoBitrate) maxVideoBitrate = DEFAULT_MAX_BITRATES.video; else if (maxVideoBitrate = Number(options.maxVideoBitrate), 
            isNaN(maxVideoBitrate)) throw new Error("Invalid maxVideoBitrate parameter. Should be a number.");
            if (null == options.maxAudioBitrate) maxAudioBitrate = DEFAULT_MAX_BITRATES.audio; else if (maxAudioBitrate = Number(options.maxAudioBitrate), 
            isNaN(maxAudioBitrate)) throw new Error("Invalid maxAudioBitrate parameter. Should be a number.");
            if (null == options.stopAtEnd) stopAtEnd = !0; else {
                if ("boolean" != typeof options.stopAtEnd) throw new Error("Invalid stopAtEnd parameter. Should be a boolean.");
                stopAtEnd = options.stopAtEnd;
            }
            return {
                maxBufferAhead: maxBufferAhead,
                maxBufferBehind: maxBufferBehind,
                limitVideoWidth: limitVideoWidth,
                videoElement: videoElement,
                wantedBufferAhead: wantedBufferAhead,
                throttleWhenHidden: throttleWhenHidden,
                initialAudioBitrate: initialAudioBitrate,
                initialVideoBitrate: initialVideoBitrate,
                maxAudioBitrate: maxAudioBitrate,
                maxVideoBitrate: maxVideoBitrate,
                stopAtEnd: stopAtEnd
            };
        }
        /**
 * Parse options given to loadVideo and set default options as found
 * in the config.
 *
 * Do not mutate anything, only cross the given options and sane default options
 * (most coming from the config).
 *
 * Throws if any mandatory option is not set.
 * @param {Object|undefined} options
 * @param {Object} ctx - The player context, needed for some default values.
 * @returns {Object}
 */        function parseLoadVideoOptions(options) {
            var autoPlay, transportOptions, defaultAudioTrack, defaultTextTrack, hideNativeSubtitle, url = void 0, transport = void 0, keySystems = void 0, supplementaryTextTracks = void 0, supplementaryImageTracks = void 0, textTrackMode = void 0, textTrackElement = void 0, startAt = void 0;
            if (!options || null == options.url) throw new Error("No url set on loadVideo");
            if (url = String(options.url), null == options.transport) throw new Error("No transport set on loadVideo");
            if (transport = String(options.transport), autoPlay = null == options.autoPlay ? DEFAULT_AUTO_PLAY : !!options.autoPlay, 
            null == options.keySystems) keySystems = []; else {
                var _iterator = keySystems = Array.isArray(options.keySystems) ? options.keySystems : [ options.keySystems ], _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    var keySystem = _ref;
                    if ("string" != typeof keySystem.type || "function" != typeof keySystem.getLicense) throw new Error("Invalid key system given: Missing type string or getLicense callback");
                }
            }
            if (transportOptions = options.transportOptions, null == options.supplementaryTextTracks) supplementaryTextTracks = []; else {
                var _iterator2 = supplementaryTextTracks = Array.isArray(options.supplementaryTextTracks) ? options.supplementaryTextTracks : [ options.supplementaryTextTracks ], _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                    var _ref2;
                    if (_isArray2) {
                        if (_i2 >= _iterator2.length) break;
                        _ref2 = _iterator2[_i2++];
                    } else {
                        if ((_i2 = _iterator2.next()).done) break;
                        _ref2 = _i2.value;
                    }
                    var supplementaryTextTrack = _ref2;
                    if ("boolean" != typeof supplementaryTextTrack.closedCaption && (supplementaryTextTrack.closedCaption = !!supplementaryTextTrack.closedCaption), 
                    "string" != typeof supplementaryTextTrack.language || "string" != typeof supplementaryTextTrack.mimeType || "string" != typeof supplementaryTextTrack.url) 
                    /* tslint:disable:max-line-length */
                    throw new Error("Invalid supplementary text track given. Missing either language, mimetype or url");
                    /* tslint:enable:max-line-length */                }
            }
            if (null == options.supplementaryImageTracks) supplementaryImageTracks = []; else {
                var _iterator3 = supplementaryImageTracks = Array.isArray(options.supplementaryImageTracks) ? options.supplementaryImageTracks : [ options.supplementaryImageTracks ], _isArray3 = Array.isArray(_iterator3), _i3 = 0;
                for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                    var _ref3;
                    if (_isArray3) {
                        if (_i3 >= _iterator3.length) break;
                        _ref3 = _iterator3[_i3++];
                    } else {
                        if ((_i3 = _iterator3.next()).done) break;
                        _ref3 = _i3.value;
                    }
                    var supplementaryImageTrack = _ref3;
                    if ("string" != typeof supplementaryImageTrack.mimeType || "string" != typeof supplementaryImageTrack.url) 
                    /* tslint:disable:max-line-length */
                    throw new Error("Invalid supplementary image track given. Missing either mimetype or url");
                    /* tslint:enable:max-line-length */                }
            }
            if (null == options.textTrackMode) textTrackMode = DEFAULT_TEXT_TRACK_MODE; else {
                if ("native" !== options.textTrackMode && "html" !== options.textTrackMode) throw new Error("Invalid textTrackMode.");
                textTrackMode = options.textTrackMode;
            }
            if (defaultAudioTrack = Object(utils_languages.b)(options.defaultAudioTrack), defaultTextTrack = Object(utils_languages.c)(options.defaultTextTrack), 
            hideNativeSubtitle = null == options.hideNativeSubtitle ? !DEFAULT_SHOW_NATIVE_SUBTITLE : !!options.hideNativeSubtitle, 
            "html" === textTrackMode) {
                // TODO Better way to express that in TypeScript?
                if (null == options.textTrackElement) 
                /* tslint:disable:max-line-length */
                throw new Error('You have to provide a textTrackElement in "html" textTrackMode.');
                /* tslint:enable:max-line-length */                if (!(options.textTrackElement instanceof HTMLElement)) throw new Error("textTrackElement should be an HTMLElement.");
                textTrackElement = options.textTrackElement;
            } else null != options.textTrackElement && 
            /* tslint:disable:max-line-length */
            log.a.warn('You have set a textTrackElement without being in an "html" textTrackMode. It will be ignored.');
            if (null != options.startAt) 
            // TODO Better way to express that in TypeScript?
            if (options.startAt.wallClockTime instanceof Date) {
                var wallClockTime = options.startAt.wallClockTime.getTime() / 1e3;
                startAt = object_assign_default()({}, options.startAt, {
                    wallClockTime: wallClockTime
                });
            } else startAt = options.startAt;
            // TODO without cast
            /* tslint:disable no-object-literal-type-assertion */
            return {
                autoPlay: autoPlay,
                defaultAudioTrack: defaultAudioTrack,
                defaultTextTrack: defaultTextTrack,
                hideNativeSubtitle: hideNativeSubtitle,
                keySystems: keySystems,
                networkConfig: null == options.networkConfig ? {} : {
                    manifestRetry: options.networkConfig.manifestRetry,
                    offlineRetry: options.networkConfig.offlineRetry,
                    segmentRetry: options.networkConfig.segmentRetry
                },
                startAt: startAt,
                supplementaryImageTracks: supplementaryImageTracks,
                supplementaryTextTracks: supplementaryTextTracks,
                textTrackElement: textTrackElement,
                textTrackMode: textTrackMode,
                transport: transport,
                transportOptions: transportOptions,
                url: url
            };
            /* tslint:enable no-object-literal-type-assertion */        }
        // CONCATENATED MODULE: ./src/core/api/index.ts
                var api_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
            return typeof obj;
        } : function(obj) {
            return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        }, _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                    "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            return function(Constructor, protoProps, staticProps) {
                return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), 
                Constructor;
            };
        }();
        function api_classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        function _possibleConstructorReturn(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" != typeof call && "function" != typeof call ? self : call;
        }
        function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * This file and directory defines the public API for the RxPlayer.
 *
 * It also starts the different sub-parts of the player on various API calls.
 */        var DEFAULT_UNMUTED_VOLUME = config.a.DEFAULT_UNMUTED_VOLUME, api_Player = function(_EventEmitter) {
            /**
     * Note: as the private state from this class can be pretty heavy, every
     * private properties should be initialized here for better visibility.
     * @constructor
     * @param {Object} options
     */
            function Player() {
                var options = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                api_classCallCheck(this, Player);
                var _this = _possibleConstructorReturn(this, _EventEmitter.call(this)), _parseConstructorOpti = parseConstructorOptions(options), initialAudioBitrate = _parseConstructorOpti.initialAudioBitrate, initialVideoBitrate = _parseConstructorOpti.initialVideoBitrate, limitVideoWidth = _parseConstructorOpti.limitVideoWidth, maxAudioBitrate = _parseConstructorOpti.maxAudioBitrate, maxBufferAhead = _parseConstructorOpti.maxBufferAhead, maxBufferBehind = _parseConstructorOpti.maxBufferBehind, maxVideoBitrate = _parseConstructorOpti.maxVideoBitrate, throttleWhenHidden = _parseConstructorOpti.throttleWhenHidden, videoElement = _parseConstructorOpti.videoElement, wantedBufferAhead = _parseConstructorOpti.wantedBufferAhead, stopAtEnd = _parseConstructorOpti.stopAtEnd;
                // Workaround to support Firefox autoplay on FF 42.
                // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1194624
                return videoElement.preload = "auto", _this.version = /*PLAYER_VERSION*/ "3.5.2", 
                _this.log = log.a, _this.state = "STOPPED", _this.videoElement = videoElement, _this._priv_destroy$ = new Subject.a(), 
                Object(events.d)(videoElement).pipe(Object(takeUntil.a)(_this._priv_destroy$)).subscribe(function() {
                    return _this.trigger("fullscreenChange", _this.isFullscreen());
                }), Object(events.o)(videoElement.textTracks).pipe(Object(takeUntil.a)(_this._priv_destroy$), Object(map.a)(function(evt) {
                    for (var target = evt.target, arr = [], i = 0; i < target.length; i++) {
                        var textTrack = target[i];
                        arr.push(textTrack);
                    }
                    return arr;
                }), 
                // We can have two consecutive textTrackChanges with the exact same
                // payload when we perform multiple texttrack operations before the event
                // loop is freed.
                // In that case we only want to fire one time the observable.
                Object(distinctUntilChanged.a)(function(textTracksA, textTracksB) {
                    if (textTracksA.length !== textTracksB.length) return !1;
                    for (var i = 0; i < textTracksA.length; i++) if (textTracksA[i] !== textTracksB[i]) return !1;
                    return !0;
                })).subscribe(function(x) {
                    return _this._priv_onNativeTextTracksNext(x);
                }), _this._priv_playing$ = new ReplaySubject.a(1), _this._priv_speed$ = new BehaviorSubject_BehaviorSubject(videoElement.playbackRate), 
                _this._priv_stopCurrentContent$ = new Subject.a(), _this._priv_streamLock$ = new BehaviorSubject_BehaviorSubject(!1), 
                _this._priv_bufferOptions = {
                    wantedBufferAhead$: new BehaviorSubject_BehaviorSubject(wantedBufferAhead),
                    maxBufferAhead$: new BehaviorSubject_BehaviorSubject(maxBufferAhead),
                    maxBufferBehind$: new BehaviorSubject_BehaviorSubject(maxBufferBehind)
                }, _this._priv_bitrateInfos = {
                    lastBitrates: {
                        audio: initialAudioBitrate,
                        video: initialVideoBitrate
                    },
                    initialMaxAutoBitrates: {
                        audio: maxAudioBitrate,
                        video: maxVideoBitrate
                    },
                    manualBitrates: {
                        audio: -1,
                        video: -1
                    }
                }, _this._priv_throttleWhenHidden = throttleWhenHidden, _this._priv_limitVideoWidth = limitVideoWidth, 
                _this._priv_mutedMemory = DEFAULT_UNMUTED_VOLUME, _this._priv_languageManager = null, 
                _this._priv_abrManager = null, _this._priv_currentError = null, _this._priv_contentInfos = null, 
                _this._priv_contentEventsMemory = {
                    period: null,
                    audioTrack: null,
                    textTrack: null,
                    videoBitrate: null,
                    audioBitrate: null,
                    bitrateEstimation: void 0
                }, _this._priv_stopAtEnd = stopAtEnd, _this._priv_setPlayerState(PLAYER_STATES.STOPPED), 
                _this;
            }
            /**
     * @returns {Object}
     */
            /**
     * Stop the player.
     */            return _inherits(Player, _EventEmitter), Player.prototype.stop = function stop() {
                this.state !== PLAYER_STATES.STOPPED && (this._priv_stopCurrentContent$.next(), 
                this._priv_cleanUpCurrentContentState(), this._priv_setPlayerState(PLAYER_STATES.STOPPED));
            }, 
            /**
     * Free the resources used by the player.
     */
            Player.prototype.dispose = function dispose() {
                // free resources linked to the loaded content
                this.stop(), this.videoElement && 
                // free resources used for EME management
                Object(eme.disposeEME)(this.videoElement), 
                // free Observables linked to the Player instance
                this._priv_destroy$.next(), this._priv_destroy$.complete(), 
                // Complete all subjects
                this._priv_stopCurrentContent$.complete(), this._priv_playing$.complete(), this._priv_speed$.complete(), 
                this._priv_streamLock$.complete(), this._priv_bufferOptions.wantedBufferAhead$.complete(), 
                this._priv_bufferOptions.maxBufferAhead$.complete(), this._priv_bufferOptions.maxBufferBehind$.complete(), 
                // un-attach video element
                this.videoElement = null;
            }, 
            /**
     * Load a new video.
     * @param {Object} opts
     * @returns {Observable}
     * @throws Error - throws if no url is given.
     * @throws Error - throws if no transport is given and no default transport
     * has been set.
     * @throws Error - throws if the asked transport does not exist
     */
            Player.prototype.loadVideo = function loadVideo(opts) {
                var _this2 = this, options = parseLoadVideoOptions(opts);
                log.a.info("loadvideo", options);
                var autoPlay = options.autoPlay, defaultAudioTrack = options.defaultAudioTrack, defaultTextTrack = options.defaultTextTrack, keySystems = options.keySystems, networkConfig = options.networkConfig, startAt = options.startAt, supplementaryImageTracks = options.supplementaryImageTracks, supplementaryTextTracks = options.supplementaryTextTracks, transport = options.transport, transportOptions = options.transportOptions, url = options.url;
                // Perform multiple checks on the given options
                                if (!this.videoElement) throw new Error("the attached video element is disposed");
                // now that every check has passed, stop previous content
                // TODO First stop?
                                this.stop();
                var isDirectFile = "directfile" === transport;
                this._priv_currentError = null, this._priv_contentInfos = {
                    url: url,
                    isDirectFile: isDirectFile,
                    thumbnails: null,
                    manifest: null,
                    currentPeriod: null,
                    activeAdaptations: null,
                    activeRepresentations: null,
                    initialAudioTrack: defaultAudioTrack,
                    initialTextTrack: defaultTextTrack
                }, 
                // inilialize to false
                this._priv_playing$.next(!1);
                // get every properties used from context for clarity
                var videoElement = this.videoElement, clock$ = api_clock(videoElement, {
                    withMediaSource: !isDirectFile
                }), closeStream$ = Object(merge.a)(this._priv_stopCurrentContent$, this._priv_stopAtEnd ? Object(events.c)(videoElement) : empty.a).pipe(Object(take.a)(1)), stream = void 0;
                /**
         * Global clock used for the whole application.
         * @type {Observable.<Object>}
         */                if (isDirectFile) {
                    if (null == features.a.directfile) throw new Error("DirectFile feature not activated in your build.");
                    stream = features.a.directfile({
                        autoPlay: autoPlay,
                        clock$: clock$,
                        keySystems: keySystems,
                        mediaElement: videoElement,
                        speed$: this._priv_speed$,
                        startAt: startAt,
                        url: url
                    }).pipe(Object(takeUntil.a)(closeStream$)).pipe(publish());
                }
                /**
         * Emit a truthy value when the player stalls, a falsy value as it unstalls.
         * TODO Find a way with TS
         * @type {Observable}
         */ else {
                    var transportFn = features.a.transports[transport];
                    if (!transportFn) throw new Error('transport "' + transport + '" not supported');
                    var transportObj = transportFn(transportOptions), adaptiveOptions = {
                        initialBitrates: this._priv_bitrateInfos.lastBitrates,
                        manualBitrates: this._priv_bitrateInfos.manualBitrates,
                        maxAutoBitrates: this._priv_bitrateInfos.initialMaxAutoBitrates,
                        throttle: this._priv_throttleWhenHidden ? {
                            video: Object(events.a)().pipe(Object(map.a)(function(isBg) {
                                return isBg ? 0 : Infinity;
                            }), Object(takeUntil.a)(this._priv_stopCurrentContent$))
                        } : {},
                        limitWidth: this._priv_limitVideoWidth ? {
                            video: Object(events.q)(videoElement).pipe(Object(takeUntil.a)(this._priv_stopCurrentContent$))
                        } : {}
                    }, textTrackOptions = "native" === options.textTrackMode ? {
                        textTrackMode: "native",
                        hideNativeSubtitle: options.hideNativeSubtitle
                    } : {
                        textTrackMode: "html",
                        textTrackElement: options.textTrackElement
                    };
                    /**
             * Options used by the ABR Manager.
             * @type {Object}
             */                    
                    // Stream Observable, through which the content will be launched.
                    stream = Stream({
                        adaptiveOptions: adaptiveOptions,
                        autoPlay: autoPlay,
                        bufferOptions: this._priv_bufferOptions,
                        clock$: clock$,
                        keySystems: keySystems,
                        networkConfig: networkConfig,
                        speed$: this._priv_speed$,
                        startAt: startAt,
                        supplementaryImageTracks: supplementaryImageTracks,
                        supplementaryTextTracks: supplementaryTextTracks,
                        textTrackOptions: textTrackOptions,
                        transport: transportObj,
                        url: url,
                        videoElement: videoElement
                    }).pipe(Object(takeUntil.a)(closeStream$)).pipe(publish());
                }
                var stalled$ = stream.pipe(Object(filter.a)(function(_ref) {
                    return "stalled" === _ref.type;
                }), Object(map.a)(function(x) {
                    return x.value;
                })), loaded = stream.pipe(Object(filter.a)(function(_ref2) {
                    return "loaded" === _ref2.type;
                }), Object(take.a)(1), Object(share.a)()), endedEvent$ = Object(events.c)(videoElement).pipe(Object(mapTo.a)(null)), seekingEvent$ = Object(events.m)(videoElement).pipe(Object(mapTo.a)(null)), stateChanges$ = Object(concat.a)(loaded.pipe(Object(mapTo.a)(PLAYER_STATES.LOADED)), Object(combineLatest.a)(this._priv_playing$, stalled$.pipe(Object(startWith.a)(null)), endedEvent$.pipe(Object(startWith.a)(null)), seekingEvent$.pipe(Object(startWith.a)(null))).pipe(Object(takeUntil.a)(this._priv_stopCurrentContent$), Object(map.a)(function(_ref3) {
                    var isPlaying = _ref3[0], stalledStatus = _ref3[1];
                    return getLoadedContentState(videoElement, isPlaying, stalledStatus);
                }), 
                // begin emitting those only when the content start to play
                skipUntil(this._priv_playing$.pipe(Object(filter.a)(function(isPlaying) {
                    return isPlaying;
                }))))).pipe(Object(distinctUntilChanged.a)(), Object(startWith.a)(PLAYER_STATES.LOADING)), videoPlays$ = Object(events.j)(videoElement).pipe(Object(map.a)(function(evt) {
                    return "play" === evt.type;
                })), streamDisposable = void 0;
                /**
         * Emit when the stream is considered "loaded".
         * @type {Observable}
         */                this._priv_stopCurrentContent$.pipe(Object(take.a)(1)).subscribe(function() {
                    streamDisposable && streamDisposable.unsubscribe();
                }), videoPlays$.pipe(Object(takeUntil.a)(this._priv_stopCurrentContent$)).subscribe(function(x) {
                    return _this2._priv_onPlayPauseNext(x);
                }, noop.a), clock$.pipe(Object(takeUntil.a)(this._priv_stopCurrentContent$)).subscribe(function(x) {
                    return _this2._priv_triggerTimeChange(x);
                }, noop.a), stateChanges$.pipe(Object(takeUntil.a)(this._priv_stopCurrentContent$)).subscribe(function(x) {
                    return _this2._priv_setPlayerState(x);
                }, noop.a), stream.subscribe(function(x) {
                    return _this2._priv_onStreamNext(x);
                }, function(err) {
                    return _this2._priv_onStreamError(err);
                }, function() {
                    return _this2._priv_onStreamComplete();
                }), 
                // connect the stream when the lock is inactive
                this._priv_streamLock$.pipe(Object(filter.a)(function(isLocked) {
                    return !isLocked;
                }), Object(take.a)(1), Object(takeUntil.a)(this._priv_stopCurrentContent$)).subscribe(function() {
                    streamDisposable = stream.connect();
                });
            }, 
            /**
     * Returns fatal error if one for the current content. null otherwise.
     * @returns {Object|null}
     */
            Player.prototype.getError = function getError() {
                return this._priv_currentError;
            }, 
            /**
     * Returns manifest/playlist object.
     * null if the player is STOPPED.
     * @returns {Manifest|null}
     */
            Player.prototype.getManifest = function getManifest() {
                return this._priv_contentInfos && this._priv_contentInfos.manifest;
            }, 
            /**
     * Returns adaptations (tracks) for every currently playing type
     * (audio/video/text...).
     * @returns {Object|null}
     */
            Player.prototype.getCurrentAdaptations = function getCurrentAdaptations() {
                if (!this._priv_contentInfos) return null;
                var _priv_contentInfos = this._priv_contentInfos, currentPeriod = _priv_contentInfos.currentPeriod, activeAdaptations = _priv_contentInfos.activeAdaptations;
                return currentPeriod && activeAdaptations && activeAdaptations.get(currentPeriod) || null;
            }, 
            /**
     * Returns representations (qualities) for every currently playing type
     * (audio/video/text...).
     * @returns {Object|null}
     */
            Player.prototype.getCurrentRepresentations = function getCurrentRepresentations() {
                if (!this._priv_contentInfos) return null;
                var _priv_contentInfos2 = this._priv_contentInfos, currentPeriod = _priv_contentInfos2.currentPeriod, activeRepresentations = _priv_contentInfos2.activeRepresentations;
                return currentPeriod && activeRepresentations && activeRepresentations.get(currentPeriod) || null;
            }, 
            /**
     * Returns the video DOM element used by the player.
     * You should not its HTML5 API directly and use the player's method instead,
     * to ensure a well-behaved player.
     * @returns {HTMLMediaElement|null}
     */
            Player.prototype.getVideoElement = function getVideoElement() {
                return this.videoElement;
            }, 
            /**
     * Returns the text-track element used by the player to inject subtitles.
     * @returns {TextTrack}
     */
            Player.prototype.getNativeTextTrack = function getNativeTextTrack() {
                if (!this.videoElement) throw new Error("Disposed player");
                var videoElement = this.videoElement;
                return videoElement.textTracks.length > 0 ? videoElement.textTracks[0] : null;
            }, 
            /**
     * Returns the player's current state.
     * @returns {string}
     */
            Player.prototype.getPlayerState = function getPlayerState() {
                return this.state;
            }, 
            /**
     * Returns true if:
     *   - a content is loaded
     *   - the content is a live content
     * @returns {Boolean}
     */
            Player.prototype.isLive = function isLive() {
                if (!this._priv_contentInfos) return !1;
                var _priv_contentInfos3 = this._priv_contentInfos, isDirectFile = _priv_contentInfos3.isDirectFile, manifest = _priv_contentInfos3.manifest;
                return !(isDirectFile || !manifest) && manifest.isLive;
            }, 
            /**
     * Returns the url of the content's manifest
     * @returns {string|undefined}
     */
            Player.prototype.getUrl = function getUrl() {
                if (this._priv_contentInfos) {
                    var _priv_contentInfos4 = this._priv_contentInfos, isDirectFile = _priv_contentInfos4.isDirectFile, manifest = _priv_contentInfos4.manifest, url = _priv_contentInfos4.url;
                    return isDirectFile ? url : manifest ? manifest.getUrl() : void 0;
                }
            }, 
            /**
     * Returns the video duration, in seconds.
     * NaN if no video is playing.
     * @returns {Number}
     */
            Player.prototype.getVideoDuration = function getVideoDuration() {
                if (!this.videoElement) throw new Error("Disposed player");
                return this.videoElement.duration;
            }, 
            /**
     * Returns in seconds the difference between:
     *   - the end of the current contiguous loaded range.
     *   - the current time
     * @returns {Number}
     */
            Player.prototype.getVideoBufferGap = function getVideoBufferGap() {
                if (!this.videoElement) throw new Error("Disposed player");
                var videoElement = this.videoElement;
                return Object(utils_ranges.c)(videoElement.buffered, videoElement.currentTime);
            }, 
            /**
     * Returns in seconds the difference between:
     *   - the end of the current contiguous loaded range.
     *   - the start of the current contiguous loaded range.
     * @returns {Number}
     */
            Player.prototype.getVideoLoadedTime = function getVideoLoadedTime() {
                if (!this.videoElement) throw new Error("Disposed player");
                var videoElement = this.videoElement;
                return Object(utils_ranges.g)(videoElement.buffered, videoElement.currentTime);
            }, 
            /**
     * Returns in seconds the difference between:
     *   - the current time.
     *   - the start of the current contiguous loaded range.
     * @returns {Number}
     */
            Player.prototype.getVideoPlayedTime = function getVideoPlayedTime() {
                if (!this.videoElement) throw new Error("Disposed player");
                var videoElement = this.videoElement;
                return Object(utils_ranges.e)(videoElement.buffered, videoElement.currentTime);
            }, 
            /**
     * Get the current position, in s, in wall-clock time.
     * That is:
     *   - for live content, get a timestamp, in s, of the current played content.
     *   - for static content, returns the position from beginning in s.
     *
     * If you do not know if you want to use this method or getPosition:
     *   - If what you want is to display the current time to the user, use this
     *     one.
     *   - If what you want is to interact with the player's API or perform other
     *     actions (like statistics) with the real player data, use getPosition.
     *
     * @returns {Number}
     */
            Player.prototype.getWallClockTime = function getWallClockTime() {
                if (!this.videoElement) throw new Error("Disposed player");
                if (!this._priv_contentInfos) return this.videoElement.currentTime;
                var _priv_contentInfos5 = this._priv_contentInfos, isDirectFile = _priv_contentInfos5.isDirectFile, manifest = _priv_contentInfos5.manifest;
                if (isDirectFile) return this.videoElement.currentTime;
                if (manifest) {
                    var currentTime = this.videoElement.currentTime;
                    return this.isLive() ? +toWallClockTime(currentTime, manifest) / 1e3 : currentTime;
                }
                return 0;
            }, 
            /**
     * Get the current position, in seconds, of the video element.
     *
     * If you do not know if you want to use this method or getWallClockTime:
     *   - If what you want is to display the current time to the user, use
     *     getWallClockTime.
     *   - If what you want is to interact with the player's API or perform other
     *     actions (like statistics) with the real player data, use this one.
     *
     * @returns {Number}
     */
            Player.prototype.getPosition = function getPosition() {
                if (!this.videoElement) throw new Error("Disposed player");
                return this.videoElement.currentTime;
            }, 
            /**
     * Returns the current speed at which the video plays.
     * @returns {Number}
     */
            Player.prototype.getPlaybackRate = function getPlaybackRate() {
                return this._priv_speed$.getValue();
            }, 
            /**
     * @returns {Number}
     */
            Player.prototype.getVolume = function getVolume() {
                if (!this.videoElement) throw new Error("Disposed player");
                return this.videoElement.volume;
            }, 
            /**
     * @returns {Boolean}
     */
            Player.prototype.isFullscreen = function isFullscreen() {
                return Object(fullscreen.b)();
            }, 
            /**
     * @returns {Array.<Number>}
     */
            Player.prototype.getAvailableVideoBitrates = function getAvailableVideoBitrates() {
                if (!this._priv_contentInfos) return [];
                var _priv_contentInfos6 = this._priv_contentInfos, currentPeriod = _priv_contentInfos6.currentPeriod, activeAdaptations = _priv_contentInfos6.activeAdaptations;
                if (!currentPeriod || !activeAdaptations) return [];
                var adaptations = activeAdaptations.get(currentPeriod), videoAdaptation = adaptations && adaptations.video;
                return videoAdaptation ? videoAdaptation.representations.map(function(_ref4) {
                    return _ref4.bitrate;
                }) : [];
            }, 
            /**
     * @returns {Array.<Number>}
     */
            Player.prototype.getAvailableAudioBitrates = function getAvailableAudioBitrates() {
                if (!this._priv_contentInfos) return [];
                var _priv_contentInfos7 = this._priv_contentInfos, currentPeriod = _priv_contentInfos7.currentPeriod, activeAdaptations = _priv_contentInfos7.activeAdaptations;
                if (!currentPeriod || !activeAdaptations) return [];
                var adaptations = activeAdaptations.get(currentPeriod), audioAdaptation = adaptations && adaptations.audio;
                return audioAdaptation ? audioAdaptation.representations.map(function(_ref5) {
                    return _ref5.bitrate;
                }) : [];
            }, 
            /**
     * Returns the manual audio bitrate set. -1 if in AUTO mode.
     * @returns {Number}
     */
            Player.prototype.getManualAudioBitrate = function getManualAudioBitrate() {
                return this._priv_bitrateInfos.manualBitrates.audio;
            }, 
            /**
     * Returns the manual video bitrate set. -1 if in AUTO mode.
     * @returns {Number}
     */
            Player.prototype.getManualVideoBitrate = function getManualVideoBitrate() {
                return this._priv_bitrateInfos.manualBitrates.video;
            }, 
            /**
     * Returns currently considered bitrate for video segments.
     * @returns {Number|undefined}
     */
            Player.prototype.getVideoBitrate = function getVideoBitrate() {
                var representations = this.getCurrentRepresentations();
                if (representations && representations.video) return representations.video.bitrate;
            }, 
            /**
     * Returns currently considered bitrate for audio segments.
     * @returns {Number|undefined}
     */
            Player.prototype.getAudioBitrate = function getAudioBitrate() {
                var representations = this.getCurrentRepresentations();
                if (representations && representations.audio) return representations.audio.bitrate;
            }, 
            /**
     * Returns max wanted video bitrate currently set.
     * @returns {Number}
     */
            Player.prototype.getMaxVideoBitrate = function getMaxVideoBitrate() {
                return this._priv_abrManager ? this._priv_abrManager.getMaxAutoBitrate("video") : this._priv_bitrateInfos.initialMaxAutoBitrates.video;
            }, 
            /**
     * Returns max wanted audio bitrate currently set.
     * @returns {Number}
     */
            Player.prototype.getMaxAudioBitrate = function getMaxAudioBitrate() {
                return this._priv_abrManager ? this._priv_abrManager.getMaxAutoBitrate("audio") : this._priv_bitrateInfos.initialMaxAutoBitrates.audio;
            }, 
            /**
     * Play/Resume the current video.
     */
            Player.prototype.play = function play() {
                if (!this.videoElement) throw new Error("Disposed player");
                /* tslint:disable no-floating-promises */                this.videoElement.play();
            }, 
            /**
     * Pause playback of the video.
     */
            Player.prototype.pause = function pause() {
                if (!this.videoElement) throw new Error("Disposed player");
                this.videoElement.pause();
            }, 
            /**
     * Update the playback rate of the video.
     * @param {Number} rate
     */
            Player.prototype.setPlaybackRate = function setPlaybackRate(rate) {
                this._priv_speed$.next(rate);
            }, 
            /**
     * Seek to a given absolute position.
     * @param {Number|Object} time
     * @returns {Number} - The time the player has seek to
     */
            Player.prototype.seekTo = function seekTo(time) {
                if (!this.videoElement) throw new Error("Disposed player");
                if (!this._priv_contentInfos) throw new Error("player: no content loaded");
                var _priv_contentInfos8 = this._priv_contentInfos, isDirectFile = _priv_contentInfos8.isDirectFile, manifest = _priv_contentInfos8.manifest;
                if (!isDirectFile && !manifest) throw new Error("player: the content did not load yet");
                var positionWanted = void 0, typeOf = void 0 === time ? "undefined" : api_typeof(time);
                if ("number" === typeOf) positionWanted = time; else if ("object" === typeOf) {
                    var currentTs = this.videoElement.currentTime;
                    if (null != time.relative) positionWanted = currentTs + time.relative; else if (null != time.position) positionWanted = time.position; else {
                        if (null == time.wallClockTime) throw new Error('invalid time object. You must set one of the following properties: "relative", "position" or "wallClockTime"');
                        positionWanted = isDirectFile ? time.wallClockTime : fromWallClockTime(1e3 * time.wallClockTime, manifest);
                    }
                }
                if (void 0 === positionWanted) throw new Error("invalid time given");
                return this.videoElement.currentTime = positionWanted, positionWanted;
            }, Player.prototype.exitFullscreen = function exitFullscreen() {
                Object(fullscreen.a)();
            }, 
            /**
     * Set/exit fullScreen.
     * @param {Boolean} [goFull=true] - if false, exit full screen.
     */
            Player.prototype.setFullscreen = function setFullscreen() {
                var goFull = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                if (!this.videoElement) throw new Error("Disposed player");
                goFull ? Object(fullscreen.c)(this.videoElement) : Object(fullscreen.a)();
            }, 
            /**
     * Set the player's volume. From 0 (muted volume) to 1 (maximum volume).
     * @param {Number} volume
     */
            Player.prototype.setVolume = function setVolume(volume) {
                if (!this.videoElement) throw new Error("Disposed player");
                var videoElement = this.videoElement;
                volume !== videoElement.volume && (videoElement.volume = volume, this.trigger("volumeChange", volume));
            }, 
            /**
     * Returns true if the volume is set to 0. false otherwise.
     * @returns {Boolean}
     */
            Player.prototype.isMute = function isMute() {
                return !this.getVolume();
            }, 
            /**
     * Set the volume to 0 and save current one for when unmuted.
     */
            Player.prototype.mute = function mute() {
                this._priv_mutedMemory = this.getVolume(), this.setVolume(0);
            }, 
            /**
     * Set the volume back to when it was when mute was last called.
     * If the volume was set to 0, set a default volume instead (see config).
     */
            Player.prototype.unMute = function unMute() {
                0 === this.getVolume() && this.setVolume(this._priv_mutedMemory || DEFAULT_UNMUTED_VOLUME);
            }, 
            /**
     * Force the video bitrate to a given value. Act as a ceil.
     * -1 to set it on AUTO Mode
     * @param {Number} btr
     */
            Player.prototype.setVideoBitrate = function setVideoBitrate(btr) {
                this._priv_bitrateInfos.manualBitrates.video = btr, this._priv_abrManager && this._priv_abrManager.setManualBitrate("video", btr);
            }, 
            /**
     * Force the audio bitrate to a given value. Act as a ceil.
     * -1 to set it on AUTO Mode
     * @param {Number} btr
     */
            Player.prototype.setAudioBitrate = function setAudioBitrate(btr) {
                this._priv_bitrateInfos.manualBitrates.audio = btr, this._priv_abrManager && this._priv_abrManager.setManualBitrate("audio", btr);
            }, 
            /**
     * Update the maximum video bitrate the user can switch to.
     * @param {Number} btr
     */
            Player.prototype.setMaxVideoBitrate = function setMaxVideoBitrate(btr) {
                // set it for the next content loaded
                this._priv_bitrateInfos.initialMaxAutoBitrates.video = btr, 
                // set it for the current if one is loaded
                this._priv_abrManager && this._priv_abrManager.setMaxAutoBitrate("video", btr);
            }, 
            /**
     * Update the maximum video bitrate the user can switch to.
     * @param {Number} btr
     */
            Player.prototype.setMaxAudioBitrate = function setMaxAudioBitrate(btr) {
                // set it for the next content loaded
                this._priv_bitrateInfos.initialMaxAutoBitrates.audio = btr, 
                // set it for the current if one is loaded
                this._priv_abrManager && this._priv_abrManager.setMaxAutoBitrate("audio", btr);
            }, 
            /**
     * Set the max buffer size for the buffer behind the current position.
     * Every buffer data before will be removed.
     * @param {Number} depthInSeconds
     */
            Player.prototype.setMaxBufferBehind = function setMaxBufferBehind(depthInSeconds) {
                this._priv_bufferOptions.maxBufferBehind$.next(depthInSeconds);
            }, 
            /**
     * Set the max buffer size for the buffer behind the current position.
     * Every buffer data before will be removed.
     * @param {Number} depthInSeconds
     */
            Player.prototype.setMaxBufferAhead = function setMaxBufferAhead(depthInSeconds) {
                this._priv_bufferOptions.maxBufferAhead$.next(depthInSeconds);
            }, 
            /**
     * Set the max buffer size for the buffer ahead of the current position.
     * The player will stop downloading chunks when this size is reached.
     * @param {Number} sizeInSeconds
     */
            Player.prototype.setWantedBufferAhead = function setWantedBufferAhead(sizeInSeconds) {
                this._priv_bufferOptions.wantedBufferAhead$.next(sizeInSeconds);
            }, 
            /**
     * Returns the max buffer size for the buffer behind the current position.
     * @returns {Number}
     */
            Player.prototype.getMaxBufferBehind = function getMaxBufferBehind() {
                return this._priv_bufferOptions.maxBufferBehind$.getValue();
            }, 
            /**
     * Returns the max buffer size for the buffer behind the current position.
     * @returns {Number}
     */
            Player.prototype.getMaxBufferAhead = function getMaxBufferAhead() {
                return this._priv_bufferOptions.maxBufferAhead$.getValue();
            }, 
            /**
     * Returns the max buffer size for the buffer ahead of the current position.
     * @returns {Number}
     */
            Player.prototype.getWantedBufferAhead = function getWantedBufferAhead() {
                return this._priv_bufferOptions.wantedBufferAhead$.getValue();
            }, 
            /**
     * Returns type of current keysystem (e.g. playready, widevine) if the content
     * is encrypted. null otherwise.
     * @returns {string|null}
     */
            Player.prototype.getCurrentKeySystem = function getCurrentKeySystem() {
                if (!this.videoElement) throw new Error("Disposed player");
                return Object(eme.getCurrentKeySystem)(this.videoElement);
            }, 
            /**
     * Returns every available audio tracks for the current Period.
     * @returns {Array.<Object>|null}
     */
            Player.prototype.getAvailableAudioTracks = function getAvailableAudioTracks() {
                if (!this._priv_contentInfos) return [];
                var currentPeriod = this._priv_contentInfos.currentPeriod;
                return this._priv_languageManager && currentPeriod ? this._priv_languageManager.getAvailableAudioTracks(currentPeriod) : [];
            }, 
            /**
     * Returns every available text tracks for the current Period.
     * @returns {Array.<Object>|null}
     */
            Player.prototype.getAvailableTextTracks = function getAvailableTextTracks() {
                if (!this._priv_contentInfos) return [];
                var currentPeriod = this._priv_contentInfos.currentPeriod;
                return this._priv_languageManager && currentPeriod ? this._priv_languageManager.getAvailableTextTracks(currentPeriod) : [];
            }, 
            /**
     * Returns currently chosen audio language for the current Period.
     * @returns {string}
     */
            Player.prototype.getAudioTrack = function getAudioTrack() {
                if (this._priv_contentInfos) {
                    var currentPeriod = this._priv_contentInfos.currentPeriod;
                    if (this._priv_languageManager && currentPeriod) return this._priv_languageManager.getChosenAudioTrack(currentPeriod);
                }
            }, 
            /**
     * Returns currently chosen subtitle for the current Period.
     * @returns {string}
     */
            Player.prototype.getTextTrack = function getTextTrack() {
                if (this._priv_contentInfos) {
                    var currentPeriod = this._priv_contentInfos.currentPeriod;
                    if (this._priv_languageManager && currentPeriod) return this._priv_languageManager.getChosenTextTrack(currentPeriod);
                }
            }, 
            /**
     * Update the audio language for the current Period.
     * @param {string} audioId
     * @throws Error - the current content has no LanguageManager.
     * @throws Error - the given id is linked to no audio track.
     */
            Player.prototype.setAudioTrack = function setAudioTrack(audioId) {
                if (!this._priv_contentInfos) throw new Error("No content loaded");
                var currentPeriod = this._priv_contentInfos.currentPeriod;
                if (!this._priv_languageManager || !currentPeriod) throw new Error("No compatible content launched.");
                try {
                    this._priv_languageManager.setAudioTrackByID(currentPeriod, audioId);
                } catch (e) {
                    throw new Error("player: unknown audio track");
                }
            }, 
            /**
     * Update the text language for the current Period.
     * @param {string} sub
     * @throws Error - the current content has no LanguageManager.
     * @throws Error - the given id is linked to no text track.
     */
            Player.prototype.setTextTrack = function setTextTrack(textId) {
                if (!this._priv_contentInfos) throw new Error("No content loaded");
                var currentPeriod = this._priv_contentInfos.currentPeriod;
                if (!this._priv_languageManager || !currentPeriod) throw new Error("No compatible content launched.");
                try {
                    this._priv_languageManager.setTextTrackByID(currentPeriod, textId);
                } catch (e) {
                    throw new Error("player: unknown text track");
                }
            }, 
            /**
     * Disable subtitles for the current content.
     */
            Player.prototype.disableTextTrack = function disableTextTrack() {
                if (this._priv_contentInfos) {
                    var currentPeriod = this._priv_contentInfos.currentPeriod;
                    if (this._priv_languageManager && currentPeriod) return this._priv_languageManager.disableTextTrack(currentPeriod);
                }
            }, 
            /**
     * @returns {Array.<Object>|null}
     */
            Player.prototype.getImageTrackData = function getImageTrackData() {
                return this._priv_contentInfos && this._priv_contentInfos.thumbnails;
            }, 
            /**
     * Get minimum seek-able position.
     * @returns {number}
     */
            Player.prototype.getMinimumPosition = function getMinimumPosition() {
                if (!this._priv_contentInfos) return null;
                if (this._priv_contentInfos.isDirectFile) return 0;
                var manifest = this._priv_contentInfos.manifest;
                return manifest ? getMinimumBufferPosition(manifest) : null;
            }, 
            /**
     * Get maximum seek-able position.
     * @returns {number}
     */
            Player.prototype.getMaximumPosition = function getMaximumPosition() {
                if (!this._priv_contentInfos) return null;
                var _priv_contentInfos9 = this._priv_contentInfos, isDirectFile = _priv_contentInfos9.isDirectFile, manifest = _priv_contentInfos9.manifest;
                if (isDirectFile) {
                    if (!this.videoElement) throw new Error("Disposed player");
                    return this.videoElement.duration;
                }
                return manifest ? getMaximumBufferPosition(manifest) : null;
            }, 
            /**
     * Reset all state properties relative to a playing content.
     */
            Player.prototype._priv_cleanUpCurrentContentState = function _priv_cleanUpCurrentContentState() {
                var _this3 = this;
                // lock creation of new streams while cleaning up is pending
                                this._priv_streamLock$.next(!0), this._priv_contentInfos = null, 
                this._priv_languageManager = null, this._priv_abrManager && (this._priv_abrManager.dispose(), 
                this._priv_abrManager = null), this._priv_contentEventsMemory = {
                    period: null,
                    audioTrack: null,
                    textTrack: null,
                    videoBitrate: null,
                    audioBitrate: null,
                    bitrateEstimation: void 0
                };
                // EME cleaning
                var freeUpStreamLock = function freeUpStreamLock() {
                    _this3._priv_streamLock$.next(!1);
                };
                this.videoElement ? Object(eme.clearEMESession)(this.videoElement).pipe(Object(catchError.a)(function() {
                    return empty.a;
                })).subscribe(noop.a, freeUpStreamLock, freeUpStreamLock) : freeUpStreamLock();
            }, Player.prototype._priv_triggerContentEvent = function _priv_triggerContentEvent(type, value) {
                var prev = this._priv_contentEventsMemory[type];
                deep_equal_default()(prev, value) || (this._priv_contentEventsMemory[type] = value, 
                // SAD
                this.trigger(type + "Change", value));
            }, 
            /**
     * Triggered each time the Stream Observable emits.
     *
     * React to various events.
     *
     * @param {Object} streamInfos - payload emitted
     */
            Player.prototype._priv_onStreamNext = function _priv_onStreamNext(streamInfos) {
                switch (streamInfos.type) {
                  case "activePeriodChanged":
                    this._priv_onActivePeriodChanged(streamInfos.value);
                    break;

                  case "periodBufferReady":
                    this._priv_onPeriodBufferReady(streamInfos.value);
                    break;

                  case "periodBufferCleared":
                    this._priv_onPeriodBufferCleared(streamInfos.value);
                    break;

                  case "representationChange":
                    this._priv_onRepresentationChange(streamInfos.value);
                    break;

                  case "adaptationChange":
                    this._priv_onAdaptationChange(streamInfos.value);
                    break;

                  case "manifestUpdate":
                    this._priv_onManifestUpdate(streamInfos.value);
                    break;

                  case "bitrateEstimationChange":
                    this._priv_onBitrateEstimationChange(streamInfos.value);
                    break;

                  case "manifestReady":
                    this._priv_onManifestReady(streamInfos.value);
                    break;

                  case "warning":
                    this._priv_onStreamWarning(streamInfos.value);
                    break;

                  case "added-segment":
                    if (!this._priv_contentInfos) return void log.a.error("Added segment while no content is loaded");
                    // Manage image tracks
                    // TODO Better way? Perhaps linked to an ImageSourceBuffer
                    // implementation
                                        var _streamInfos$value = streamInfos.value, bufferType = _streamInfos$value.bufferType, segmentData = _streamInfos$value.segmentData;
                    if ("image" === bufferType && null != segmentData && "bif" === segmentData.type) {
                        var imageData = segmentData.data;
                        // TODO merge multiple data from the same track together
                                                this._priv_contentInfos.thumbnails = imageData, this.trigger("imageTrackUpdate", {
                            data: this._priv_contentInfos.thumbnails
                        });
                    }
                }
            }, 
            /**
     * Triggered when the Stream throws (fatal errors).
     *
     * Clean-up ressources and signal that the content has stopped on error.
     *
     * @param {Error} error
     */
            Player.prototype._priv_onStreamError = function _priv_onStreamError(error) {
                this._priv_stopCurrentContent$.next(), this._priv_cleanUpCurrentContentState(), 
                this._priv_currentError = error, this._priv_setPlayerState(PLAYER_STATES.STOPPED), 
                // TODO This condition is here because the eventual callback called when the
                // player state is updated can launch a new content, thus the error will not
                // be here anymore, in which case triggering the "error" event is unwanted.
                // This is very ugly though, and we should probable have a better solution
                this._priv_currentError === error && this.trigger("error", error);
            }, 
            /**
     * Triggered when the Stream instance ends.
     *
     * Clean-up ressources and signal that the content has ended.
     */
            Player.prototype._priv_onStreamComplete = function _priv_onStreamComplete() {
                this._priv_stopCurrentContent$.next(), this._priv_cleanUpCurrentContentState(), 
                this._priv_setPlayerState(PLAYER_STATES.ENDED);
            }, 
            /**
     * Triggered when the Stream emits a warning.
     *
     * Trigger the right Player event.
     * @param {Object} streamInfos
     */
            Player.prototype._priv_onStreamWarning = function _priv_onStreamWarning(error) {
                this.trigger("warning", error);
            }, 
            /**
     * Triggered when the stream starts.
     *
     * Initialize various private properties and emit initial event.
     *
     * @param {Object} value
     */
            Player.prototype._priv_onManifestReady = function _priv_onManifestReady(value) {
                if (this._priv_contentInfos) {
                    var manifest = value.manifest, abrManager = value.abrManager;
                    this._priv_contentInfos.manifest = manifest, this._priv_abrManager = abrManager;
                    var _priv_contentInfos10 = this._priv_contentInfos, initialAudioTrack = _priv_contentInfos10.initialAudioTrack, initialTextTrack = _priv_contentInfos10.initialTextTrack;
                    this._priv_languageManager = new language_manager({
                        preferredAudioTracks: void 0 === initialAudioTrack ? void 0 : [ initialAudioTrack ],
                        preferredTextTracks: void 0 === initialTextTrack ? void 0 : [ initialTextTrack ]
                    }), this.trigger("manifestChange", manifest);
                } else log.a.error("The manifest is loaded but no content is.");
            }, 
            /**
     * Triggered each times the current Period Changed.
     *
     * Store and emit initial state for the Period.
     *
     * @param {Object} value
     */
            Player.prototype._priv_onActivePeriodChanged = function _priv_onActivePeriodChanged(_ref6) {
                var period = _ref6.period;
                if (this._priv_contentInfos) {
                    // Emit intial events for the Period
                    if (this._priv_contentInfos.currentPeriod = period, this._priv_triggerContentEvent("period", period), 
                    this._priv_languageManager) {
                        var audioTrack = this._priv_languageManager.getChosenAudioTrack(period), textTrack = this._priv_languageManager.getChosenTextTrack(period);
                        this._priv_triggerContentEvent("audioTrack", audioTrack), this._priv_triggerContentEvent("textTrack", textTrack);
                    } else this._priv_triggerContentEvent("audioTrack", null), this._priv_triggerContentEvent("textTrack", null);
                    var activeAudioRepresentations = this.getCurrentRepresentations();
                    if (activeAudioRepresentations && null != activeAudioRepresentations.audio) {
                        var bitrate = activeAudioRepresentations.audio.bitrate;
                        this._priv_triggerContentEvent("audioBitrate", null != bitrate ? bitrate : -1);
                    } else this._priv_triggerContentEvent("audioBitrate", null);
                    var activeVideoRepresentations = this.getCurrentRepresentations();
                    if (activeVideoRepresentations && null != activeVideoRepresentations.video) {
                        var _bitrate = activeVideoRepresentations.video.bitrate;
                        this._priv_triggerContentEvent("videoBitrate", null != _bitrate ? _bitrate : -1);
                    } else this._priv_triggerContentEvent("videoBitrate", null);
                } else log.a.error("The active period changed but no content is loaded");
            }, 
            /**
     * Triggered each times the Stream "prepares" a new Period, and
     * needs the API to send it its chosen Adaptation.
     *
     * Choose the right Adaptation for the Period and emit it.
     *
     * @param {Object} value
     */
            Player.prototype._priv_onPeriodBufferReady = function _priv_onPeriodBufferReady(value) {
                var type = value.type, period = value.period, adaptation$ = value.adaptation$;
                switch (type) {
                  case "audio":
                    this._priv_languageManager ? (this._priv_languageManager.addPeriod(type, period, adaptation$), 
                    this._priv_languageManager.setInitialAudioTrack(period)) : (log.a.error("LanguageManager not instanciated for a new " + type + " period"), 
                    adaptation$.next(null));
                    break;

                  case "text":
                    this._priv_languageManager ? (this._priv_languageManager.addPeriod(type, period, adaptation$), 
                    this._priv_languageManager.setInitialTextTrack(period)) : (log.a.error("LanguageManager not instanciated for a new " + type + " period"), 
                    adaptation$.next(null));
                    break;

                  default:
                    var adaptations = period.adaptations[type];
                    adaptations && adaptations.length ? adaptation$.next(adaptations[0]) : adaptation$.next(null);
                }
            }, 
            /**
     * Triggered each times the Stream "removes" a Period.
     *
     * Update the LanguageManager to remove the corresponding Period.
     *
     * @param {Object} value
     */
            Player.prototype._priv_onPeriodBufferCleared = function _priv_onPeriodBufferCleared(value) {
                var type = value.type, period = value.period;
                "audio" !== type && "text" !== type || this._priv_languageManager && this._priv_languageManager.removePeriod(type, period);
            }, 
            /**
     * Triggered each times the Manifest is updated.
     *
     * Update the LanguageManager and emit events.
     *
     * @param {Object} value
     */
            Player.prototype._priv_onManifestUpdate = function _priv_onManifestUpdate(value) {
                if (this._priv_contentInfos) {
                    var manifest = value.manifest;
                    this._priv_contentInfos.manifest = manifest, 
                    // Update the languages chosen if it changed
                    this._priv_languageManager && this._priv_languageManager.update(), this.trigger("manifestUpdate", manifest);
                } else log.a.error("The manifest is updated but no content is loaded.");
            }, 
            /**
     * Triggered each times a new Adaptation is considered by the Stream.
     *
     * Store given Adaptation and emit it if from the current Period.
     *
     * @param {Object} value
     */
            Player.prototype._priv_onAdaptationChange = function _priv_onAdaptationChange(_ref7) {
                var type = _ref7.type, adaptation = _ref7.adaptation, period = _ref7.period;
                if (this._priv_contentInfos) {
                    // lazily create this._priv_contentInfos.activeAdaptations
                    this._priv_contentInfos.activeAdaptations || (this._priv_contentInfos.activeAdaptations = new Map());
                    var _activeAdaptations$se, _priv_contentInfos11 = this._priv_contentInfos, activeAdaptations = _priv_contentInfos11.activeAdaptations, currentPeriod = _priv_contentInfos11.currentPeriod, activePeriodAdaptations = activeAdaptations.get(period);
                    if (activePeriodAdaptations) activePeriodAdaptations[type] = adaptation; else activeAdaptations.set(period, ((_activeAdaptations$se = {})[type] = adaptation, 
                    _activeAdaptations$se));
                    if (this._priv_languageManager && null != period && period === currentPeriod) if ("audio" === type) {
                        var audioTrack = this._priv_languageManager.getChosenAudioTrack(currentPeriod);
                        this._priv_triggerContentEvent("audioTrack", audioTrack);
                    } else if ("text" === type) {
                        var textTrack = this._priv_languageManager.getChosenTextTrack(currentPeriod);
                        this._priv_triggerContentEvent("textTrack", textTrack);
                    }
                } else log.a.error("The adaptations changed but no content is loaded");
            }, 
            /**
     * Triggered each times a new Representation is considered by the Stream.
     *
     * Store given Representation and emit it if from the current Period.
     *
     * @param {Object} obj
     */
            Player.prototype._priv_onRepresentationChange = function _priv_onRepresentationChange(_ref8) {
                var type = _ref8.type, period = _ref8.period, representation = _ref8.representation;
                if (this._priv_contentInfos) {
                    // lazily create this._priv_contentInfos.activeRepresentations
                    this._priv_contentInfos.activeRepresentations || (this._priv_contentInfos.activeRepresentations = new Map());
                    var _activeRepresentation, _priv_contentInfos12 = this._priv_contentInfos, activeRepresentations = _priv_contentInfos12.activeRepresentations, currentPeriod = _priv_contentInfos12.currentPeriod, activePeriodRepresentations = activeRepresentations.get(period);
                    if (activePeriodRepresentations) activePeriodRepresentations[type] = representation; else activeRepresentations.set(period, ((_activeRepresentation = {})[type] = representation, 
                    _activeRepresentation));
                    var bitrate = representation && representation.bitrate;
                    null != bitrate && (this._priv_bitrateInfos.lastBitrates[type] = bitrate), null != period && currentPeriod === period && ("video" === type ? this._priv_triggerContentEvent("videoBitrate", null != bitrate ? bitrate : -1) : "audio" === type && this._priv_triggerContentEvent("audioBitrate", null != bitrate ? bitrate : -1));
                } else log.a.error("The representations changed but no content is loaded");
            }, 
            /**
     * Triggered each time a bitrate estimate is calculated.
     *
     * Emit it.
     *
     * @param {Object} value
     */
            Player.prototype._priv_onBitrateEstimationChange = function _priv_onBitrateEstimationChange(_ref9) {
                var type = _ref9.type, bitrate = _ref9.bitrate;
                this._priv_triggerContentEvent("bitrateEstimation", {
                    type: type,
                    bitrate: bitrate
                });
            }, 
            /**
     * Triggered each time the videoElement alternates between play and pause.
     *
     * Emit the info through the right Subject.
     *
     * @param {Boolean} isPlaying
     */
            Player.prototype._priv_onPlayPauseNext = function _priv_onPlayPauseNext(isPlaying) {
                if (!this.videoElement) throw new Error("Disposed player");
                this._priv_playing$.next(isPlaying);
            }, 
            /**
     * Triggered each time a textTrack is added to the video DOM Element.
     *
     * Trigger the right Player Event.
     *
     * @param {Array.<TextTrackElement>} tracks
     */
            Player.prototype._priv_onNativeTextTracksNext = function _priv_onNativeTextTracksNext(tracks) {
                this.trigger("nativeTextTracksChange", tracks);
            }, 
            /**
     * Triggered each time the player state updates.
     *
     * Trigger the right Player Event.
     *
     * @param {string} newState
     */
            Player.prototype._priv_setPlayerState = function _priv_setPlayerState(newState) {
                this.state !== newState && (this.state = newState, log.a.info("playerStateChange", newState), 
                this.trigger("playerStateChange", newState));
            }, 
            /**
     * Triggered each time a new clock tick object is emitted.
     *
     * Trigger the right Player Event
     *
     * @param {Object} clockTick
     */
            Player.prototype._priv_triggerTimeChange = function _priv_triggerTimeChange(clockTick) {
                if (this._priv_contentInfos) {
                    var _priv_contentInfos13 = this._priv_contentInfos, isDirectFile = _priv_contentInfos13.isDirectFile, manifest = _priv_contentInfos13.manifest;
                    if ((isDirectFile || manifest) && clockTick) {
                        var positionData = {
                            position: clockTick.currentTime,
                            duration: clockTick.duration,
                            playbackRate: clockTick.playbackRate,
                            // TODO fix higher up?
                            bufferGap: isFinite(clockTick.bufferGap) ? clockTick.bufferGap : 0
                        };
                        manifest && manifest.isLive && clockTick.currentTime > 0 && (positionData.wallClockTime = toWallClockTime(clockTick.currentTime, manifest).getTime() / 1e3, 
                        positionData.liveGap = getMaximumBufferPosition(manifest) - clockTick.currentTime), 
                        this.trigger("positionUpdate", positionData);
                    }
                } else log.a.warn("Cannot perform time update: no content loaded.");
            }, _createClass(Player, null, [ {
                key: "ErrorTypes",
                get: function get() {
                    return constants.b;
                }
                /**
         * @returns {Object}
         */            }, {
                key: "ErrorCodes",
                get: function get() {
                    return constants.a;
                }
                /**
         * @returns {string} - current log level
         */            }, {
                key: "LogLevel",
                get: function get() {
                    return log.a.getLevel();
                }
                /**
         * @param {string} logLevel - should be either (by verbosity ascending):
         *   - "NONE"
         *   - "ERROR"
         *   - "WARNING"
         *   - "INFO"
         *   - "DEBUG"
         * Any other value will be translated to "NONE".
         */ ,
                set: function set(logLevel) {
                    log.a.setLevel(logLevel);
                }
            } ]), Player;
        }(eventemitter.a);
        /**
 * @class Player
 * @extends EventEmitter
 */        
        /**
 * Current version of the RxPlayer.
 * @type {string}
 */
        api_Player.version = "3.5.2";
        /* harmony default export */ var api = api_Player;
        // CONCATENATED MODULE: ./src/features/initialize_features.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Selects the features to include based on environment variables.
 *
 * @param {Object} features
 */        
        // CONCATENATED MODULE: ./src/index.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * This file exports a Player class with a default feature set (depends on the
 * environment variables set at build).
 *
 * This is the class used from a regular build.
 */
        // set initial features according to environment variables
        !function initializeFeaturesObject() {
            features.a.emeManager = __webpack_require__(66).default, features.a.imageBuffer = __webpack_require__(111).default, 
            features.a.imageParser = __webpack_require__(112).default, features.a.transports.smooth = __webpack_require__(125).default, 
            features.a.transports.dash = __webpack_require__(124).default, features.a.nativeTextTracksBuffer = __webpack_require__(130).default, 
            features.a.nativeTextTracksParsers.vtt = __webpack_require__(113).default, features.a.nativeTextTracksParsers.ttml = __webpack_require__(114).default, 
            features.a.nativeTextTracksParsers.sami = __webpack_require__(115).default, features.a.nativeTextTracksParsers.srt = __webpack_require__(116).default, 
            features.a.htmlTextTracksBuffer = __webpack_require__(129).default, features.a.htmlTextTracksParsers.sami = __webpack_require__(118).default, 
            features.a.htmlTextTracksParsers.ttml = __webpack_require__(128).default, features.a.htmlTextTracksParsers.srt = __webpack_require__(119).default, 
            features.a.htmlTextTracksParsers.vtt = __webpack_require__(127).default, features.a.directfile = __webpack_require__(120).default;
        }();
        /* harmony default export */ __webpack_exports__.default = api;
        /***/    }, 
    /* 124 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/of.js
        var of = __webpack_require__(75), features = __webpack_require__(7), isobmff = __webpack_require__(35), config = __webpack_require__(3), log = __webpack_require__(0), array_includes = __webpack_require__(14), utils_id = __webpack_require__(18), languages = __webpack_require__(40), utils_url = __webpack_require__(38), assert = __webpack_require__(9), iso8601Duration = /^P(([\d.]*)Y)?(([\d.]*)M)?(([\d.]*)D)?T?(([\d.]*)H)?(([\d.]*)M)?(([\d.]*)S)?/, rangeRe = /([0-9]+)-([0-9]+)/, frameRateRe = /([0-9]+)(\/([0-9]+))?/;
        // EXTERNAL MODULE: ./src/features/index.ts
                /**
 * Parse MPD boolean attributes.
 * @param {string} str
 * @returns {Boolean}
 */
        function parseBoolean(str) {
            return "true" === str;
        }
        /**
 * Parse some MPD attributes.
 * @param {string} str
 * @returns {Boolean|Number}
 */        function parseIntOrBoolean(str) {
            return "true" === str || "false" !== str && parseInt(str, 10);
        }
        /**
 * Parse MPD date attributes.
 * @param {string} str
 * @returns {Date}
 */        function parseDateTime(str) {
            return new Date(Date.parse(str)).getTime() / 1e3;
        }
        /**
 * Parse MPD ISO8601 duration attributes into seconds.
 * @param {string} date
 * @returns {Number}
 */        function parseDuration(date) {
            if (!date) return 0;
            var match = iso8601Duration.exec(date);
            return Object(assert.b)(!!match, date + " is not a valid ISO8601 duration"), 365 * parseFloat(match[2] || "0") * 24 * 60 * 60 + 30 * parseFloat(match[4] || "0") * 24 * 60 * 60 + // not precise +
            24 * parseFloat(match[6] || "0") * 60 * 60 + 60 * parseFloat(match[8] || "0") * 60 + 60 * parseFloat(match[10] || "0") + parseFloat(match[12] || "0");
        }
        /**
 * Parse MPD frame rate attributes.
 * -1 if the frameRate could not be parsed,
 * @param {string} str
 * @returns {Number}
 */        function parseFrameRate(str) {
            var match = frameRateRe.exec(str);
            if (!match) return -1;
            var nom = parseInt(match[1], 10) || 0, den = parseInt(match[2], 10) || 0;
            return den > 0 ? nom / den : nom;
        }
        /**
 * Parse MPD ratio attributes.
 * @param {string} str
 * @returns {string}
 */        function parseRatio(str) {
            return str;
        }
        /**
 * Parse MPD byterange attributes into arrays of two elements: the start and
 * the end.
 * @param {string} str
 * @returns {Array.<Number>}
 */        function parseByteRange(str) {
            var match = rangeRe.exec(str);
            return match ? [ +match[1], +match[2] ] : null;
        }
        /**
 * Detect if the accessibility given defines an adaptation for the visually
 * impaired.
 * Based on DVB Document A168 (DVB-DASH).
 * @param {Object} accessibility
 * @returns {Boolean}
 */        function isVisuallyImpaired(accessibility) {
            return !!accessibility && ("urn:tva:metadata:cs:AudioPurposeCS:2007" === accessibility.schemeIdUri && "1" === accessibility.value);
        }
        /**
 * Detect if the accessibility given defines an adaptation for the hard of
 * hearing.
 * Based on DVB Document A168 (DVB-DASH).
 * @param {Object} accessibility
 * @returns {Boolean}
 */        function isHardOfHearing(accessibility) {
            return !!accessibility && ("urn:tva:metadata:cs:AudioPurposeCS:2007" === accessibility.schemeIdUri && "2" === accessibility.value);
        }
        /**
 * @param {Element} root
 * @returns {Object}
 */        function parseScheme(root) {
            for (var schemeIdUri = void 0, value = void 0, i = 0; i < root.attributes.length; i++) {
                var attribute = root.attributes[i];
                switch (attribute.name) {
                  case "schemeIdUri":
                    schemeIdUri = attribute.value;
                    break;

                  case "value":
                    value = attribute.value;
                }
            }
            return {
                schemeIdUri: schemeIdUri,
                value: value
            };
        }
        /**
 * Pad with 0 in the left of the given n argument to reach l length
 * @param {Number|string} n
 * @param {Number} l
 * @returns {string}
 */        function pad(n, l) {
            var nToString = n.toString();
            return nToString.length >= l ? nToString : (new Array(l + 1).join("0") + nToString).slice(-l);
        }
        function processFormatedToken(replacer) {
            return function(_match, _format, widthStr) {
                var width = widthStr ? parseInt(widthStr, 10) : 1;
                return pad("" + replacer, width);
            };
        }
        /**
 * @param {string} representationURL
 * @param {string|undefined} media
 * @param {string|undefined} id
 * @param {number|undefined} bitrate
 * @returns {string}
 */        function createIndexURL(representationURL, media, id, bitrate) {
            return replaceRepresentationDASHTokens(Object(utils_url.b)(representationURL, media), id, bitrate);
        }
        /**
 * Replace "tokens" written in a given path (e.g. $RepresentationID$) by the corresponding
 * infos, taken from the given segment.
 * @param {string} path
 * @param {string|undefined} id
 * @param {number|undefined} bitrate
 * @returns {string}
 */        function replaceRepresentationDASHTokens(path, id, bitrate) {
            return -1 === path.indexOf("$") ? path : path.replace(/\$\$/g, "$").replace(/\$RepresentationID\$/g, String(id)).replace(/\$Bandwidth(|\%0(\d+)d)\$/g, processFormatedToken(bitrate || 0));
        }
        /**
 * Replace "tokens" written in a given path (e.g. $Time$) by the corresponding
 * infos, taken from the given segment.
 * @param {string} path
 * @param {number} time
 * @param {number} number
 * @returns {string}
 *
 * @throws Error - Throws if we do not have enough data to construct the URL
 */        function replaceSegmentDASHTokens(path, time, number) {
            return -1 === path.indexOf("$") ? path : path.replace(/\$\$/g, "$").replace(/\$Number(|\%0(\d+)d)\$/g, function(_x, _y, widthStr) {
                if (null == number) throw new Error("Segment number not defined in a $Number$ scheme");
                return processFormatedToken(number)(_x, _y, widthStr);
            }).replace(/\$Time(|\%0(\d+)d)\$/g, function(_x, _y, widthStr) {
                if (null == time) throw new Error("Segment time not defined in a $Time$ scheme");
                return processFormatedToken(time)(_x, _y, widthStr);
            });
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/indexes/helpers.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Calculate the number of times a timeline element repeat based on the next
 * segment.
 * @param {Object} element
 * @param {Object} nextElement
 * @returns {Number}
 */        function calculateRepeat(element, nextElement) {
            var rep = element.r || 0;
            // A negative value of the @r attribute of the S element indicates
            // that the duration indicated in @d attribute repeats until the
            // start of the next S element, the end of the Period or until the
            // next MPD update.
                        if (rep < 0) {
                var repEnd = nextElement ? nextElement.ts : Infinity;
                rep = Math.ceil((repEnd - element.ts) / element.d) - 1;
            }
            return rep;
        }
        /**
 * Convert from `presentationTime`, the time of the segment at the moment it
 * is decoded to `mediaTime`, the original time the segments point at.
 * @param {Object} index
 * @param {number} time
 * @returns {number}
 */        function toIndexTime(index, time) {
            return time * index.timescale + index.indexTimeOffset;
        }
        /**
 * Convert from `mediaTime`, the original time the segments point at to
 * `presentationTime`, the time of the segment at the moment it is decoded.
 * @param {Object} index
 * @param {number} time
 * @returns {number}
 */        function fromIndexTime(index, time) {
            return (time - index.indexTimeOffset) / index.timescale;
        }
        /**
 * @param {Object} index
 * @param {Number} ts
 * @param {Number} duration
 * @returns {Object} - Object with two properties:
 *   - up {Number}: timescaled timestamp of the beginning time
 *   - to {Number}: timescaled timestamp of the end time (start time + duration)
 */        function getTimescaledRange(index, // TODO
        ts, duration) {
            var timescale = index.timescale || 1;
            return {
                up: ts * timescale,
                to: (ts + duration) * timescale
            };
        }
        /**
 * Get start of the given index range, timescaled.
 * @param {Object} element
 * @returns {Number} - absolute start time of the range
 */        function getTimelineItemRangeStart(_ref) {
            var ts = _ref.ts, d = _ref.d, r = _ref.r;
            return -1 === d ? ts : ts + r * d;
        }
        /**
 * Get end of the given index range, timescaled.
 * @param {Object} element
 * @returns {Number} - absolute end time of the range
 */        function getTimelineItemRangeEnd(_ref2) {
            var ts = _ref2.ts, d = _ref2.d, r = _ref2.r;
            return -1 === d ? ts : ts + (r + 1) * d;
        }
        /**
 * Construct init segment for the given index.
 * @param {Object} index
 * @returns {Object}
 */        function helpers_getInitSegment(index) {
            var initialization = index.initialization;
            return {
                id: "init",
                isInit: !0,
                time: 0,
                range: initialization && initialization.range || void 0,
                indexRange: index.indexRange || void 0,
                mediaURL: initialization ? initialization.mediaURL : null,
                timescale: index.timescale,
                timestampOffset: -index.indexTimeOffset / index.timescale
            };
        }
        /**
 * For the given start time and duration of a timeline element, calculate how
 * much this element should be repeated to contain the time given.
 * 0 being the same element, 1 being the next one etc.
 * @param {Number} segmentStartTime
 * @param {Number} segmentDuration
 * @param {Number} wantedTime
 * @returns {Number}
 */        function getWantedRepeatIndex(segmentStartTime, segmentDuration, wantedTime) {
            var diff = wantedTime - segmentStartTime;
            return diff > 0 ? Math.floor(diff / segmentDuration) : 0;
        }
        /**
 * Get a list of Segments for the time range wanted.
 * @param {Object} index - index object, constructed by parsing the manifest.
 * @param {number} from - starting timestamp wanted, in seconds
 * @param {number} duration - duration wanted, in seconds
 * @param {number} indexTimeOffset - offset used to convert from decoding
 * time (used by the `from` argument) to manifest time (used in the `index`
 * argument). Basically, we should be able to convert the `from` argument into
 * manifest time by doing something like:
 * ``from * index.timescale + indexTimeOffset``
 */        function getSegmentsFromTimeline(index, from, duration) {
            for (var scaledUp = toIndexTime(index, from), scaledTo = toIndexTime(index, from + duration), timeline = index.timeline, timescale = index.timescale, mediaURL = index.mediaURL, startNumber = index.startNumber, currentNumber = null != startNumber ? startNumber : void 0, segments = [], timelineLength = timeline.length, maxEncounteredDuration = timeline.length && timeline[0].d || 0, i = 0; i < timelineLength; i++) {
                var timelineItem = timeline[i], d = timelineItem.d, ts = timelineItem.ts, range = timelineItem.range;
                // live-added segments have @d attribute equals to -1
                if (maxEncounteredDuration = Math.max(maxEncounteredDuration, d), d < 0) {
                    // TODO what? May be to play it safe and avoid adding segments which are
                    // not completely generated
                    if (ts + maxEncounteredDuration < scaledTo) {
                        var segmentNumber = null != currentNumber ? currentNumber : void 0, segment = {
                            id: "" + ts,
                            time: ts - index.indexTimeOffset,
                            isInit: !1,
                            range: range,
                            duration: void 0,
                            timescale: timescale,
                            mediaURL: replaceSegmentDASHTokens(mediaURL, ts, segmentNumber),
                            number: segmentNumber,
                            timestampOffset: -index.indexTimeOffset / timescale
                        };
                        segments.push(segment);
                    }
                    return segments;
                }
                for (var repeat = calculateRepeat(timelineItem, timeline[i + 1]), segmentNumberInCurrentRange = getWantedRepeatIndex(ts, d, scaledUp), segmentTime = ts + segmentNumberInCurrentRange * d; segmentTime < scaledTo && segmentNumberInCurrentRange <= repeat; ) {
                    var _segmentNumber = null != currentNumber ? currentNumber + segmentNumberInCurrentRange : void 0, _segment = {
                        id: "" + segmentTime,
                        time: segmentTime - index.indexTimeOffset,
                        isInit: !1,
                        range: range,
                        duration: d,
                        timescale: timescale,
                        mediaURL: replaceSegmentDASHTokens(mediaURL, segmentTime, _segmentNumber),
                        number: _segmentNumber,
                        timestampOffset: -index.indexTimeOffset / timescale
                    };
                    segments.push(_segment), segmentTime = ts + 
                    // update segment number and segment time for the next segment
                    ++segmentNumberInCurrentRange * d;
                }
                if (segmentTime >= scaledTo) 
                // we reached ``scaledTo``, we're done
                return segments;
                null != currentNumber && (currentNumber += repeat + 1);
            }
            return segments;
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/indexes/base.ts
                function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Add a new segment to the index.
 *
 * /!\ Mutate the given index
 * @param {Object} index
 * @param {Object} segmentInfos
 * @returns {Boolean} - true if the segment has been added
 */        function _addSegmentInfos(index, segmentInfos) {
            if (segmentInfos.timescale !== index.timescale) {
                var timescale = index.timescale;
                index.timeline.push({
                    ts: segmentInfos.time / segmentInfos.timescale * timescale,
                    d: segmentInfos.duration / segmentInfos.timescale * timescale,
                    r: segmentInfos.count || 0,
                    range: segmentInfos.range
                });
            } else index.timeline.push({
                ts: segmentInfos.time,
                d: segmentInfos.duration,
                r: segmentInfos.count || 0,
                range: segmentInfos.range
            });
            return !0;
        }
        /**
 * Provide helpers for SegmentBase-based indexes.
 * @type {Object}
 * TODO weird that everything is inherited from Timeline...
 * Reimplement from scratch
 */        var indexes_base = function() {
            /**
     * @param {Object} index
     * @param {Object} context
     */
            function BaseRepresentationIndex(index, context) {
                _classCallCheck(this, BaseRepresentationIndex);
                var periodStart = context.periodStart, representationURL = context.representationURL, representationId = context.representationId, representationBitrate = context.representationBitrate, indexTimeOffset = (null != index.presentationTimeOffset ? index.presentationTimeOffset : 0) - periodStart * index.timescale;
                this._index = {
                    mediaURL: createIndexURL(representationURL, index.media, representationId, representationBitrate),
                    timeline: index.timeline,
                    timescale: index.timescale,
                    duration: index.duration,
                    indexTimeOffset: indexTimeOffset,
                    indexRange: index.indexRange,
                    startNumber: index.startNumber,
                    initialization: index.initialization && {
                        mediaURL: createIndexURL(representationURL, index.initialization.media, representationId, representationBitrate),
                        range: index.initialization.range
                    }
                };
            }
            /**
     * Construct init Segment.
     * @returns {Object}
     */            return BaseRepresentationIndex.prototype.getInitSegment = function getInitSegment() {
                return helpers_getInitSegment(this._index);
            }, 
            /**
     * @param {Number} _up
     * @param {Number} _to
     * @returns {Array.<Object>}
     */
            BaseRepresentationIndex.prototype.getSegments = function getSegments(_up, _to) {
                return getSegmentsFromTimeline(this._index, _up, _to);
            }, 
            /**
     * Returns false as no Segment-Base based index should need to be refreshed.
     * @returns {Boolean}
     */
            BaseRepresentationIndex.prototype.shouldRefresh = function shouldRefresh() {
                return !1;
            }, 
            /**
     * Returns first position in index.
     * @returns {Number|undefined}
     */
            BaseRepresentationIndex.prototype.getFirstPosition = function getFirstPosition() {
                var index = this._index;
                if (index.timeline.length) return fromIndexTime(index, index.timeline[0].ts);
            }, 
            /**
     * Returns last position in index.
     * @returns {Number|undefined}
     */
            BaseRepresentationIndex.prototype.getLastPosition = function getLastPosition() {
                var index = this._index;
                if (index.timeline.length) return fromIndexTime(index, getTimelineItemRangeStart(index.timeline[index.timeline.length - 1]));
            }, 
            /**
     * We do not check for discontinuity in SegmentBase-based indexes.
     * @returns {Number}
     */
            BaseRepresentationIndex.prototype.checkDiscontinuity = function checkDiscontinuity() {
                return -1;
            }, 
            /**
     * @param {Array.<Object>} nextSegments
     * @returns {Array.<Object>}
     */
            BaseRepresentationIndex.prototype._addSegments = function _addSegments(nextSegments) {
                for (var i = 0; i < nextSegments.length; i++) _addSegmentInfos(this._index, nextSegments[i]);
            }, 
            /**
     * @param {Object} newIndex
     */
            BaseRepresentationIndex.prototype._update = function _update(newIndex /* TODO @ index refacto */) {
                this._index = newIndex._index;
            }, BaseRepresentationIndex;
        }();
        /* harmony default export */        
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/indexes/list.ts
        function list_classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Provide helpers for SegmentList-based DASH indexes.
 * @type {Object}
 */        var indexes_list = function() {
            /**
     * @param {Object} index
     * @param {Object} context
     */
            function ListRepresentationIndex(index, context) {
                list_classCallCheck(this, ListRepresentationIndex);
                var periodStart = context.periodStart, representationURL = context.representationURL, representationId = context.representationId, representationBitrate = context.representationBitrate;
                this._periodStart = periodStart;
                var indexTimeOffset = (null != index.presentationTimeOffset ? index.presentationTimeOffset : 0) - periodStart * index.timescale;
                this._index = {
                    list: index.list.map(function(lItem) {
                        return {
                            mediaURL: createIndexURL(representationURL, lItem.media, representationId, representationBitrate),
                            mediaRange: lItem.mediaRange
                        };
                    }),
                    timescale: index.timescale,
                    duration: index.duration,
                    indexTimeOffset: indexTimeOffset,
                    indexRange: index.indexRange,
                    initialization: index.initialization && {
                        mediaURL: createIndexURL(representationURL, index.initialization.media, representationId, representationBitrate),
                        range: index.initialization.range
                    }
                };
            }
            /**
     * Construct init Segment.
     * @returns {Object}
     */            return ListRepresentationIndex.prototype.getInitSegment = function getInitSegment() {
                return helpers_getInitSegment(this._index);
            }, 
            /**
     * @param {Number} fromTime
     * @param {Number} duration
     * @returns {Array.<Object>}
     */
            ListRepresentationIndex.prototype.getSegments = function getSegments(fromTime, dur) {
                for (var index = this._index, _getTimescaledRange = getTimescaledRange(index, fromTime + this._periodStart, dur), up = _getTimescaledRange.up, to = _getTimescaledRange.to, duration = index.duration, list = index.list, timescale = index.timescale, length = Math.min(list.length - 1, Math.floor(to / duration)), segments = [], i = Math.floor(up / duration); i <= length; ) {
                    var args = {
                        id: "" + i,
                        time: i * duration,
                        isInit: !1,
                        range: list[i].mediaRange,
                        duration: duration,
                        timescale: timescale,
                        mediaURL: list[i].mediaURL,
                        timestampOffset: -index.indexTimeOffset / timescale
                    };
                    segments.push(args), i++;
                }
                return segments;
            }, 
            /**
     * Returns true if, based on the arguments, the index should be refreshed.
     * (If we should re-fetch the manifest)
     * @param {Number} _fromTime
     * @param {Number} toTime
     * @returns {Boolean}
     */
            ListRepresentationIndex.prototype.shouldRefresh = function shouldRefresh(_fromTime, toTime) {
                var _index = this._index, timescale = _index.timescale, duration = _index.duration, list = _index.list, scaledTo = toTime * timescale, i = Math.floor(scaledTo / duration);
                return !(i >= 0 && i < list.length);
            }, 
            /**
     * Returns first position in index.
     * @returns {Number}
     */
            ListRepresentationIndex.prototype.getFirstPosition = function getFirstPosition() {
                return this._periodStart;
            }, 
            /**
     * Returns last position in index.
     * @returns {Number}
     */
            ListRepresentationIndex.prototype.getLastPosition = function getLastPosition() {
                var index = this._index, duration = index.duration;
                return index.list.length * duration / index.timescale + this._periodStart;
            }, 
            /**
     * We do not check for discontinuity in SegmentList-based indexes.
     * @returns {Number}
     */
            ListRepresentationIndex.prototype.checkDiscontinuity = function checkDiscontinuity() {
                return -1;
            }, 
            /**
     * @param {Object} newIndex
     */
            ListRepresentationIndex.prototype._update = function _update(newIndex) {
                this._index = newIndex._index;
            }, 
            /**
     * We do not have to add new segments to SegmentList-based indexes.
     * @returns {Array}
     */
            ListRepresentationIndex.prototype._addSegments = function _addSegments() {
                0;
            }, ListRepresentationIndex;
        }();
        /* harmony default export */        
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/indexes/template.ts
        function template_classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        var template = function() {
            /**
     * @param {Object} index
     * @param {Object} context
     */
            function TemplateRepresentationIndex(index, context) {
                template_classCallCheck(this, TemplateRepresentationIndex);
                var periodStart = context.periodStart, representationURL = context.representationURL, representationId = context.representationId, representationBitrate = context.representationBitrate;
                this._periodStart = periodStart;
                var presentationTimeOffset = null != index.presentationTimeOffset ? index.presentationTimeOffset : 0, indexTimeOffset = presentationTimeOffset - periodStart * index.timescale;
                this._index = {
                    duration: index.duration,
                    timescale: index.timescale,
                    indexRange: index.indexRange,
                    indexTimeOffset: indexTimeOffset,
                    initialization: index.initialization && {
                        mediaURL: createIndexURL(representationURL, index.initialization.media, representationId, representationBitrate),
                        range: index.initialization.range
                    },
                    mediaURL: createIndexURL(representationURL, index.media, representationId, representationBitrate),
                    presentationTimeOffset: presentationTimeOffset,
                    startNumber: index.startNumber
                };
            }
            /**
     * Construct init Segment.
     * @returns {Object}
     */            return TemplateRepresentationIndex.prototype.getInitSegment = function getInitSegment() {
                return helpers_getInitSegment(this._index);
            }, 
            /**
     * @param {Number} fromTime
     * @param {Number} dur
     * @returns {Array.<Object>}
     */
            TemplateRepresentationIndex.prototype.getSegments = function getSegments(fromTime, dur) {
                var index = this._index, _getTimescaledRange = getTimescaledRange(index, fromTime, dur), up = _getTimescaledRange.up, to = _getTimescaledRange.to;
                if (to <= up) return [];
                for (var duration = index.duration, startNumber = index.startNumber, timescale = index.timescale, mediaURL = index.mediaURL, segments = [], baseTime = up; baseTime <= to; baseTime += duration) {
                    var periodRelativeStart = baseTime - this._periodStart * timescale, baseNumber = Math.floor(periodRelativeStart / duration), number = baseNumber + (null == startNumber ? 1 : startNumber), manifestTime = baseNumber * duration + (this._index.presentationTimeOffset || 0), args = {
                        id: "" + number,
                        number: number,
                        time: baseNumber * duration + this._periodStart * this._index.timescale,
                        isInit: !1,
                        duration: duration,
                        timescale: timescale,
                        mediaURL: replaceSegmentDASHTokens(mediaURL, manifestTime, number),
                        timestampOffset: -index.indexTimeOffset / timescale
                    };
                    segments.push(args);
                }
                return segments;
            }, 
            /**
     * Returns first position in index.
     * @returns {undefined}
     */
            TemplateRepresentationIndex.prototype.getFirstPosition = function getFirstPosition() {
                /* tslint:enable return-undefined */}, 
            /**
     * Returns last position in index.
     * @returns {undefined}
     */
            TemplateRepresentationIndex.prototype.getLastPosition = function getLastPosition() {
                /* tslint:enable return-undefined */}, 
            /**
     * Returns true if, based on the arguments, the index should be refreshed.
     * We never have to refresh a SegmentTemplate-based manifest.
     * @returns {Boolean}
     */
            TemplateRepresentationIndex.prototype.shouldRefresh = function shouldRefresh() {
                return !1;
            }, 
            /**
     * We cannot check for discontinuity in SegmentTemplate-based indexes.
     * @returns {Number}
     */
            TemplateRepresentationIndex.prototype.checkDiscontinuity = function checkDiscontinuity() {
                return -1;
            }, 
            /**
     * We do not have to add new segments to SegmentList-based indexes.
     * @returns {Array}
     */
            TemplateRepresentationIndex.prototype._addSegments = function _addSegments() {
                0;
            }, 
            /**
     * @param {Object} newIndex
     */
            TemplateRepresentationIndex.prototype._update = function _update(newIndex /* TODO @ index refacto */) {
                this._index = newIndex._index;
            }, TemplateRepresentationIndex;
        }();
        /* harmony default export */        
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/indexes/timeline.ts
        function timeline_classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Get index of the segment containing the given timescaled timestamp.
 * @param {Object} index
 * @param {Number} ts
 * @returns {Number}
 */        function getSegmentIndex(index, ts) {
            for (var timeline = index.timeline, low = 0, high = timeline.length; low < high; ) {
                var mid = low + high >>> 1;
                timeline[mid].ts < ts ? low = mid + 1 : high = mid;
            }
            return low > 0 ? low - 1 : low;
        }
        /**
 * Add a new segment to the index.
 *
 * /!\ Mutate the given index
 * @param {Object} index
 * @param {Object} newSegment
 * @param {Object} currentSegmentInfos
 * @param {Number} indexTimeOffset
 * @returns {Boolean} - true if the segment has been added
 */        function timeline_addSegmentInfos(index, newSegment, currentSegmentInfos) {
            var timeline = index.timeline, timescale = index.timescale, timelineLength = timeline.length, lastItem = timeline[timelineLength - 1], scaledNewSegment = newSegment.timescale === timescale ? {
                time: newSegment.time,
                duration: newSegment.duration
            } : {
                time: newSegment.time / newSegment.timescale * timescale,
                duration: newSegment.duration / newSegment.timescale * timescale
            }, scaledCurrentTime = void 0;
            if (currentSegmentInfos && currentSegmentInfos.timescale && (scaledCurrentTime = (currentSegmentInfos.timescale === timescale ? currentSegmentInfos.time : currentSegmentInfos.time / currentSegmentInfos.timescale * timescale) + index.indexTimeOffset), 
            null != scaledCurrentTime && scaledNewSegment.time === scaledCurrentTime) {
                var newSegmentTs = scaledNewSegment.time + scaledNewSegment.duration, tsDiff = newSegmentTs - (lastItem.ts + lastItem.d * lastItem.r);
                if (tsDiff <= 0) 
                // same segment / behind the lastItem
                return !1;
                // try to use the compact notation with @r attribute on the lastItem
                // to elements of the timeline if we find out they have the same
                // duration
                                if (-1 === lastItem.d) {
                    var prev = timeline[timelineLength - 2];
                    prev && prev.d === tsDiff ? (prev.r++, timeline.pop()) : lastItem.d = tsDiff;
                }
                return index.timeline.push({
                    d: -1,
                    ts: newSegmentTs,
                    r: 0
                }), !0;
            }
            // if the given timing has a timestamp after the timeline end we
            // just need to push a new element in the timeline, or increase
            // the @r attribute of the lastItem element.
                        return scaledNewSegment.time >= getTimelineItemRangeEnd(lastItem) && (lastItem.d === scaledNewSegment.duration ? lastItem.r++ : index.timeline.push({
                d: scaledNewSegment.duration,
                ts: scaledNewSegment.time,
                r: 0
            }), !0);
        }
        var indexes_timeline = function() {
            /**
     * @param {Object} index
     * @param {Object} context
     */
            function TimelineRepresentationIndex(index, context) {
                timeline_classCallCheck(this, TimelineRepresentationIndex);
                var representationURL = context.representationURL, representationId = context.representationId, representationBitrate = context.representationBitrate, periodStart = context.periodStart, indexTimeOffset = (null != index.presentationTimeOffset ? index.presentationTimeOffset : 0) - periodStart * index.timescale;
                this._index = {
                    duration: index.duration,
                    indexTimeOffset: indexTimeOffset,
                    indexRange: index.indexRange,
                    initialization: index.initialization && {
                        mediaURL: createIndexURL(representationURL, index.initialization.media, representationId, representationBitrate),
                        range: index.initialization.range
                    },
                    mediaURL: createIndexURL(representationURL, index.media, representationId, representationBitrate),
                    startNumber: index.startNumber,
                    timeline: index.timeline,
                    timescale: index.timescale
                };
            }
            /**
     * Construct init Segment.
     * @returns {Object}
     */            return TimelineRepresentationIndex.prototype.getInitSegment = function getInitSegment() {
                return helpers_getInitSegment(this._index);
            }, 
            /**
     * Asks for segments to download for a given time range.
     * @param {Number} from - Beginning of the time wanted, in seconds
     * @param {Number} duration - duration wanted, in seconds
     * @returns {Array.<Object>}
     */
            TimelineRepresentationIndex.prototype.getSegments = function getSegments(from, duration) {
                return getSegmentsFromTimeline(this._index, from, duration);
            }, 
            /**
     * Returns true if, based on the arguments, the index should be refreshed.
     * @param {Number} _start
     * @param {Number} end
     * @returns {Boolean}
     */
            TimelineRepresentationIndex.prototype.shouldRefresh = function shouldRefresh(_start, end) {
                var timeline = this._index.timeline, scaledTo = toIndexTime(this._index, end), lastItem = timeline[timeline.length - 1];
                return !!lastItem && (lastItem.d < 0 && (lastItem = {
                    ts: lastItem.ts,
                    d: 0,
                    r: lastItem.r
                }), scaledTo > getTimelineItemRangeEnd(lastItem));
            }, 
            /**
     * Returns first position in index.
     * @returns {Number|undefined}
     */
            TimelineRepresentationIndex.prototype.getFirstPosition = function getFirstPosition() {
                var index = this._index;
                if (index.timeline.length) return fromIndexTime(index, index.timeline[0].ts);
            }, 
            /**
     * Returns lastItem position in index.
     * @returns {Number|undefined}
     */
            TimelineRepresentationIndex.prototype.getLastPosition = function getLastPosition() {
                var index = this._index;
                if (index.timeline.length) return fromIndexTime(index, getTimelineItemRangeEnd(index.timeline[index.timeline.length - 1]));
            }, 
            /**
     * Checks if the time given is in a discontinuity. That is:
     *   - We're on the upper bound of the current range (end of the range - time
     *     is inferior to the timescale)
     *   - The next range starts after the end of the current range.
     * @param {Number} _time
     * @returns {Number} - If a discontinuity is present, this is the Starting ts
     * for the next (discontinuited) range. If not this is equal to -1.
     */
            TimelineRepresentationIndex.prototype.checkDiscontinuity = function checkDiscontinuity(_time) {
                var _index = this._index, timeline = _index.timeline, timescale = _index.timescale, scaledTime = toIndexTime(this._index, _time);
                if (scaledTime <= 0) return -1;
                var segmentIndex = getSegmentIndex(this._index, scaledTime);
                if (segmentIndex < 0 || segmentIndex >= timeline.length - 1) return -1;
                var timelineItem = timeline[segmentIndex];
                if (-1 === timelineItem.d) return -1;
                var nextRange = timeline[segmentIndex + 1];
                if (null == nextRange) return -1;
                var rangeUp = timelineItem.ts, rangeTo = getTimelineItemRangeEnd(timelineItem);
                // when we are actually inside the found range and this range has
                // an explicit discontinuity with the next one
                return rangeTo !== nextRange.ts && scaledTime >= rangeUp && scaledTime <= rangeTo && rangeTo - scaledTime < timescale ? fromIndexTime(this._index, nextRange.ts) : -1;
            }, 
            /**
     * @param {Object} newIndex
     */
            TimelineRepresentationIndex.prototype._update = function _update(newIndex /* TODO @ index refacto */) {
                this._index = newIndex._index;
            }, 
            /**
     * We do not have to add new segments to SegmentList-based indexes.
     * @param {Array.<Object>} nextSegments
     * @param {Object|undefined} currentSegmentInfos
     * @returns {Array}
     */
            TimelineRepresentationIndex.prototype._addSegments = function _addSegments(nextSegments, currentSegmentInfos) {
                for (var i = 0; i < nextSegments.length; i++) timeline_addSegmentInfos(this._index, nextSegments[i], currentSegmentInfos);
            }, TimelineRepresentationIndex;
        }();
        /* harmony default export */        
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/ContentComponent.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Parse a "ContentComponent" Element in a DASH MPD.
 * @param {Element} root
 * @returns {Object}
 */
        function parseContentComponent(root) {
            for (var ret = {}, i = 0; i < root.attributes.length; i++) {
                var attribute = root.attributes[i];
                switch (attribute.name) {
                  case "id":
                    ret.id = attribute.value;
                    break;

                  case "lang":
                    ret.language = attribute.value;
                    break;

                  case "contentType":
                    ret.contentType = attribute.value;
                    break;

                  case "par":
                    ret.par = parseRatio(attribute.value);
                }
            }
            return ret;
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/ContentProtection.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Parse the "ContentProtection" node of a MPD.
 * @param {Element} root
 * @param {Function} [contentProtectionParser]
 * @returns {Object}
 */        function parseContentProtection(root) {
            for (var schemeIdUri = void 0, value = void 0, keyId = void 0, i = 0; i < root.attributes.length; i++) {
                var attribute = root.attributes[i];
                switch (attribute.name) {
                  case "schemeIdUri":
                    schemeIdUri = attribute.value;
                    break;

                  case "value":
                    value = attribute.value;
                    break;

                  case "cenc:default_KID":
                    keyId = attribute.value.toString().split("-").join("").toUpperCase();
                }
            }
            // TODO Take systemId from PSSH?
            // for (let i = 0; i < root.childElementCount; i++) {
            //   const child = root.children[i];
            //   if (child.nodeName === "cenc:pssh" && child.textContent) {
            //     pssh = atob(child.textContent);
            //   }
            // }
                        return {
                schemeIdUri: schemeIdUri,
                value: value,
                keyId: keyId
            };
        }
        // EXTERNAL MODULE: ./node_modules/object-assign/index.js
                var object_assign = __webpack_require__(11), object_assign_default = /* */ __webpack_require__.n(object_assign);
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/Initialization.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {Element} root
 * @returns {Object}
 */
        function parseInitialization(root) {
            for (var parsedInitialization = {}, i = 0; i < root.attributes.length; i++) {
                var attribute = root.attributes[i];
                switch (attribute.name) {
                  case "range":
                    var range = parseByteRange(attribute.value) || void 0;
                    range ? parsedInitialization.range = range : log.a.warn('DASH: invalid range ("' + attribute.value + '")');
                    break;

                  case "sourceURL":
                    parsedInitialization.media = attribute.value;
                }
            }
            return parsedInitialization;
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/SegmentBase.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * TODO Only for SegmentBase not for other types
 * @param {Element} root
 * @returns {Object}
 */        function parseSegmentBase(root) {
            for (var attributes = {}, segmentBaseChildren = root.childNodes, i = 0; i < segmentBaseChildren.length; i++) if (segmentBaseChildren[i].nodeType === Node.ELEMENT_NODE) {
                var currentNode = segmentBaseChildren[i];
                "Initialization" === currentNode.nodeName && (attributes.initialization = parseInitialization(currentNode));
            }
            for (var _i = 0; _i < root.attributes.length; _i++) {
                var attribute = root.attributes[_i];
                switch (attribute.name) {
                  case "timescale":
                    var _timescale = parseInt(attribute.value, 10);
                    isNaN(_timescale) ? log.a.warn('DASH: invalid timescale ("' + attribute.value + '")') : attributes.timescale = _timescale;
                    break;

                  case "timeShiftBufferDepth":
                    var timeShiftBufferDepth = parseDuration(attribute.value);
                    isNaN(timeShiftBufferDepth) ? log.a.warn('DASH: invalid timeShiftBufferDepth ("' + attribute.value + '")') : attributes.timeShiftBufferDepth = timeShiftBufferDepth;
                    break;

                  case "presentationTimeOffset":
                    var _presentationTimeOffset = parseFloat(attribute.value);
                    isNaN(_presentationTimeOffset) ? log.a.warn('DASH: invalid presentationTimeOffset ("' + attribute.value + '")') : attributes.presentationTimeOffset = _presentationTimeOffset;
                    break;

                  case "indexRange":
                    attributes.indexRange = parseByteRange(attribute.value) || void 0;
                    break;

                  case "indexRangeExact":
                    attributes.indexRangeExact = parseBoolean(attribute.value);
                    break;

                  case "availabilityTimeOffset":
                    var availabilityTimeOffset = parseFloat(attribute.value);
                    isNaN(availabilityTimeOffset) ? log.a.warn('DASH: invalid availabilityTimeOffset ("' + attribute.value + '")') : attributes.availabilityTimeOffset = availabilityTimeOffset;
                    break;

                  case "availabilityTimeComplete":
                    attributes.availabilityTimeComplete = parseBoolean(attribute.value);
                    break;

                  case "duration":
                    var duration = parseInt(attribute.value, 10);
                    isNaN(duration) ? log.a.warn('DASH: invalid duration ("' + attribute.value + '")') : attributes.duration = duration;
                    break;

                  case "startNumber":
                    var startNumber = parseInt(attribute.value, 10);
                    isNaN(startNumber) ? log.a.warn('DASH: invalid startNumber ("' + attribute.value + '")') : attributes.startNumber = startNumber;
                }
            }
            var timescale = null == attributes.timescale ? 1 : attributes.timescale, indexRangeExact = !!attributes.indexRangeExact, availabilityTimeComplete = null == attributes.availabilityTimeComplete || attributes.availabilityTimeComplete;
            return object_assign_default()(attributes, {
                availabilityTimeComplete: availabilityTimeComplete,
                indexRangeExact: indexRangeExact,
                timeline: [],
                timescale: timescale
            });
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/SegmentURL.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {Element} root
 * @returns {Object}
 */        function parseSegmentURL(root) {
            for (var parsedSegmentURL = {}, i = 0; i < root.attributes.length; i++) {
                var attribute = root.attributes[i];
                switch (attribute.name) {
                  case "media":
                    parsedSegmentURL.media = attribute.value;
                    break;

                  case "indexRange":
                    var indexRange = parseByteRange(attribute.value) || void 0;
                    indexRange ? parsedSegmentURL.indexRange = indexRange : log.a.warn('DASH: invalid indexRange ("' + attribute.value + '")');
                    break;

                  case "index":
                    parsedSegmentURL.index = attribute.value;
                    break;

                  case "mediaRange":
                    var mediaRange = parseByteRange(attribute.value) || void 0;
                    mediaRange ? parsedSegmentURL.mediaRange = mediaRange : log.a.warn('DASH: invalid mediaRange ("' + attribute.value + '")');
                }
            }
            return parsedSegmentURL;
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/SegmentList.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {Element} root
 * @returns {Object}
 */        function parseSegmentList(root) {
            for (var base = parseSegmentBase(root), list = [], segmentListChildren = root.childNodes, i = 0; i < segmentListChildren.length; i++) if (segmentListChildren[i].nodeType === Node.ELEMENT_NODE) {
                var currentNode = segmentListChildren[i];
                if ("SegmentURL" === currentNode.nodeName) {
                    var segmentURL = parseSegmentURL(currentNode);
                    list.push(segmentURL);
                }
            }
            var baseDuration = base.duration;
            if (null == baseDuration) throw new Error("Invalid SegmentList: no duration");
            return object_assign_default()(base, {
                list: list,
                duration: baseDuration
            });
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/S.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {Element} root
 * @returns {Object}
 */        function parseS(root) {
            for (var ts = void 0, d = void 0, r = void 0, j = 0; j < root.attributes.length; j++) {
                var attribute = root.attributes[j];
                switch (attribute.name) {
                  case "t":
                    ts = parseInt(attribute.value, 10);
                    break;

                  case "d":
                    d = parseInt(attribute.value, 10);
                    break;

                  case "r":
                    r = parseInt(attribute.value, 10);
                }
            }
            return {
                ts: ts,
                d: d,
                r: r
            };
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/SegmentTimeline.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        function fromParsedSToTimelineElement(parsedS, previousS, nextS) {
            var ts = parsedS.ts, d = parsedS.d, r = parsedS.r;
            return null == ts && previousS && null != previousS.d && (ts = previousS.ts + previousS.d * (previousS.r + 1)), 
            null != d && !isNaN(d) || !nextS || null == nextS.ts || isNaN(nextS.ts) || null == ts || isNaN(ts) || (d = nextS.ts - ts), 
            null == ts || isNaN(ts) || null == d || isNaN(d) || null != r && isNaN(r) ? (log.a.warn('DASH: A "S" Element could not have been parsed.'), 
            null) : {
                ts: ts,
                d: d,
                r: r || 0
            };
        }
        /**
 * @param {Element} root
 * @returns {Array.<Object>}
 */        function parseSegmentTimeline(root) {
            for (var timeline = [], parsedS = [], timelineChildren = root.childNodes, i = 0; i < timelineChildren.length; i++) if (timelineChildren[i].nodeType === Node.ELEMENT_NODE) {
                var currentElement = timelineChildren[i];
                if ("S" === currentElement.nodeName) {
                    var s = parseS(currentElement);
                    s && parsedS.push(s);
                }
            }
            for (var _i = 0; _i < parsedS.length; _i++) {
                var timelineElement = fromParsedSToTimelineElement(parsedS[_i], timeline[timeline.length - 1] || null, parsedS[_i + 1] || null);
                timelineElement && timeline.push(timelineElement);
            }
            return timeline;
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/SegmentTemplate.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Parse initialization attribute found in segment Template to
 * correspond to the initialization found in a regular segmentBase.
 * @param {string} attrValue
 * @returns {Object}
 */        function parseInitializationAttribute(attrValue) {
            return {
                media: attrValue
            };
        }
        /**
 * @param {Element} root
 * @returns {Object}
 */        function parseSegmentTemplate(root) {
            for (var base = parseSegmentBase(root), ret = void 0, index = void 0, media = void 0, bitstreamSwitching = void 0, timeline = void 0, i = 0; i < root.childNodes.length; i++) if (root.childNodes[i].nodeType === Node.ELEMENT_NODE) {
                var currentNode = root.childNodes[i];
                "SegmentTimeline" === currentNode.nodeName && (timeline = parseSegmentTimeline(currentNode));
            }
            for (var _i = 0; _i < root.attributes.length; _i++) {
                var attribute = root.attributes[_i];
                switch (attribute.nodeName) {
                  case "initialization":
                    null == base.initialization && (base.initialization = parseInitializationAttribute(attribute.value));
                    break;

                  case "index":
                    index = attribute.value;
                    break;

                  case "media":
                    media = attribute.value;
                    break;

                  case "bitstreamSwitching":
                    bitstreamSwitching = parseBoolean(attribute.value);
                }
            }
            if (null != timeline) ret = object_assign_default()({}, base, {
                indexType: "timeline",
                timeline: timeline
            }); else {
                var segmentDuration = base.duration;
                if (null == segmentDuration) throw new Error("Invalid SegmentTemplate: no duration");
                ret = object_assign_default()({}, base, {
                    indexType: "template",
                    duration: segmentDuration
                });
            }
            return null != index && (ret.index = index), null != media && (ret.media = media), 
            null != bitstreamSwitching && (ret.bitstreamSwitching = bitstreamSwitching), ret;
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/Representation.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {NodeList} representationChildren
 * @returns {Object}
 */        function parseRepresentationChildren(representationChildren) {
            for (var children = {
                baseURL: ""
            }, i = 0; i < representationChildren.length; i++) if (representationChildren[i].nodeType === Node.ELEMENT_NODE) {
                var currentElement = representationChildren[i];
                switch (currentElement.nodeName) {
                  case "BaseURL":
                    children.baseURL = currentElement.textContent || "";
                    break;

                  case "SegmentBase":
                    children.segmentBase = parseSegmentBase(currentElement);
                    break;

                  case "SegmentList":
                    children.segmentList = parseSegmentList(currentElement);
                    break;

                  case "SegmentTemplate":
                    children.segmentTemplate = parseSegmentTemplate(currentElement);
                }
            }
            return children;
        }
        /**
 * @param {Element} representationElement
 * @returns {Object}
 */        function parseRepresentationAttributes(representationElement) {
            for (var attributes = {}, i = 0; i < representationElement.attributes.length; i++) {
                var attribute = representationElement.attributes[i];
                switch (attribute.name) {
                  case "audioSamplingRate":
                    attributes.audioSamplingRate = attribute.value;
                    break;

                  case "bandwidth":
                    var bitrate = parseInt(attribute.value, 10);
                    isNaN(bitrate) ? log.a.warn('DASH: invalid bandwidth ("' + attribute.value + '")') : attributes.bitrate = bitrate;
                    break;

                  case "codecs":
                    attributes.codecs = attribute.value;
                    break;

                  case "codingDependency":
                    attributes.codingDependency = parseBoolean(attribute.value);
                    break;

                  case "frameRate":
                    var frameRate = parseFrameRate(attribute.value);
                    isNaN(frameRate) ? log.a.warn('DASH: invalid frameRate ("' + attribute.value + '")') : attributes.frameRate = frameRate;
                    break;

                  case "height":
                    var height = parseInt(attribute.value, 10);
                    isNaN(height) ? log.a.warn('DASH: invalid height ("' + attribute.value + '")') : attributes.height = height;
                    break;

                  case "id":
                    attributes.id = attribute.value;
                    break;

                  case "maxPlayoutRate":
                    var maxPlayoutRate = parseFloat(attribute.value);
                    isNaN(maxPlayoutRate) ? log.a.warn('DASH: invalid maxPlayoutRate ("' + attribute.value + '")') : attributes.maxPlayoutRate = maxPlayoutRate;
                    break;

                  case "maximumSAPPeriod":
                    var maximumSAPPeriod = parseFloat(attribute.value);
                    isNaN(maximumSAPPeriod) ? log.a.warn('DASH: invalid maximumSAPPeriod ("' + attribute.value + '")') : attributes.maximumSAPPeriod = maximumSAPPeriod;
                    break;

                  case "mimeType":
                    attributes.mimeType = attribute.value;
                    break;

                  case "profiles":
                    attributes.profiles = attribute.value;
                    break;

                  case "qualityRanking":
                    var qualityRanking = parseInt(attribute.value, 10);
                    isNaN(qualityRanking) ? log.a.warn('DASH: invalid qualityRanking ("' + attribute.value + '")') : attributes.qualityRanking = qualityRanking;
                    break;

                  case "segmentProfiles":
                    attributes.segmentProfiles = attribute.value;
                    break;

                  case "width":
                    var width = parseInt(attribute.value, 10);
                    isNaN(width) ? log.a.warn('DASH: invalid width ("' + attribute.value + '")') : attributes.width = width;
                }
            }
            return attributes;
        }
        function createRepresentationIntermediateRepresentation(representationElement) {
            return {
                children: parseRepresentationChildren(representationElement.childNodes),
                attributes: parseRepresentationAttributes(representationElement)
            };
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/AdaptationSet.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        function parseAdaptationSetChildren(adaptationSetChildren) {
            for (var children = {
                baseURL: "",
                representations: []
            }, contentProtections = [], i = 0; i < adaptationSetChildren.length; i++) if (adaptationSetChildren[i].nodeType === Node.ELEMENT_NODE) {
                var currentElement = adaptationSetChildren[i];
                switch (currentElement.nodeName) {
                  case "Accessibility":
                    children.accessibility = parseScheme(currentElement);
                    break;

                  case "BaseURL":
                    children.baseURL = currentElement.textContent || "";
                    break;

                  case "ContentComponent":
                    children.contentComponent = parseContentComponent(currentElement);
                    break;

                  case "Representation":
                    var representation = createRepresentationIntermediateRepresentation(currentElement);
                    children.representations.push(representation);
                    break;

                  case "Role":
                    children.role = parseScheme(currentElement);
                    break;

                  case "SegmentBase":
                    children.segmentBase = parseSegmentBase(currentElement);
                    break;

                  case "SegmentList":
                    children.segmentList = parseSegmentList(currentElement);
                    break;

                  case "SegmentTemplate":
                    children.segmentTemplate = parseSegmentTemplate(currentElement);
                    break;

                  case "ContentProtection":
                    var contentProtection = parseContentProtection(currentElement);
                    contentProtection && contentProtections.push(contentProtection);
 // case "Rating":
                    //   children.rating = currentElement;
                    //   break;
                    // case "Viewpoint":
                    //   children.viewpoint = currentElement;
                    //   break;
                                }
            }
            return contentProtections.length && (children.contentProtections = contentProtections), 
            children;
        }
        function parseAdaptationSetAttributes(root) {
            for (var parsedAdaptation = {}, i = 0; i < root.attributes.length; i++) {
                var attribute = root.attributes[i];
                switch (attribute.name) {
                  case "id":
                    parsedAdaptation.id = attribute.value;
                    break;

                  case "group":
                    var group = parseInt(attribute.value, 10);
                    isNaN(group) ? log.a.warn('DASH: invalid group ("' + attribute.value + '")') : parsedAdaptation.group = group;
                    break;

                  case "lang":
                    parsedAdaptation.language = attribute.value;
                    break;

                  case "contentType":
                    parsedAdaptation.contentType = attribute.value;
                    break;

                  case "par":
                    parsedAdaptation.par = attribute.value;
                    break;

                  case "minBandwidth":
                    var minBitrate = parseInt(attribute.value, 10);
                    isNaN(minBitrate) ? log.a.warn('DASH: invalid minBandwidth ("' + attribute.value + '")') : parsedAdaptation.minBitrate = minBitrate;
                    break;

                  case "maxBandwidth":
                    var maxBitrate = parseInt(attribute.value, 10);
                    isNaN(maxBitrate) ? log.a.warn('DASH: invalid maxBandwidth ("' + attribute.value + '")') : parsedAdaptation.maxBitrate = maxBitrate;
                    break;

                  case "minWidth":
                    var minWidth = parseInt(attribute.value, 10);
                    isNaN(minWidth) ? log.a.warn('DASH: invalid minWidth ("' + attribute.value + '")') : parsedAdaptation.minWidth = minWidth;
                    break;

                  case "maxWidth":
                    var maxWidth = parseInt(attribute.value, 10);
                    isNaN(maxWidth) ? log.a.warn('DASH: invalid maxWidth ("' + attribute.value + '")') : parsedAdaptation.maxWidth = maxWidth;
                    break;

                  case "minHeight":
                    var minHeight = parseInt(attribute.value, 10);
                    isNaN(minHeight) ? log.a.warn('DASH: invalid minHeight ("' + attribute.value + '")') : parsedAdaptation.minHeight = minHeight;
                    break;

                  case "maxHeight":
                    var maxHeight = parseInt(attribute.value, 10);
                    isNaN(maxHeight) ? log.a.warn('DASH: invalid maxHeight ("' + attribute.value + '")') : parsedAdaptation.maxHeight = maxHeight;
                    break;

                  case "minFrameRate":
                    var minFrameRate = parseFrameRate(attribute.value);
                    isNaN(minFrameRate) ? log.a.warn('DASH: invalid minFrameRate ("' + attribute.value + '")') : parsedAdaptation.minFrameRate = minFrameRate;
                    break;

                  case "maxFrameRate":
                    var maxFrameRate = parseFrameRate(attribute.value);
                    isNaN(maxFrameRate) ? log.a.warn('DASH: invalid maxFrameRate ("' + attribute.value + '")') : parsedAdaptation.maxFrameRate = maxFrameRate;
                    break;

                  case "segmentAlignment":
                    var segmentAlignment = parseIntOrBoolean(attribute.value);
                    "number" == typeof segmentAlignment && isNaN(segmentAlignment) ? log.a.warn('DASH: invalid segmentAlignment ("' + attribute.value + '")') : parsedAdaptation.segmentAlignment = segmentAlignment;
                    break;

                  case "subsegmentAlignment":
                    var subsegmentAlignment = parseIntOrBoolean(attribute.value);
                    "number" == typeof subsegmentAlignment && isNaN(subsegmentAlignment) ? log.a.warn('DASH: invalid subsegmentAlignment ("' + attribute.value + '")') : parsedAdaptation.subsegmentAlignment = subsegmentAlignment;
                    break;

                  case "bitstreamSwitching":
                    parsedAdaptation.bitstreamSwitching = parseBoolean(attribute.value);
                    break;

                  case "audioSamplingRate":
                    parsedAdaptation.audioSamplingRate = attribute.value;
                    break;

                  case "codecs":
                    parsedAdaptation.codecs = attribute.value;
                    break;

                  case "codingDependency":
                    parsedAdaptation.codingDependency = parseBoolean(attribute.value);
                    break;

                  case "frameRate":
                    var frameRate = parseFrameRate(attribute.value);
                    isNaN(frameRate) ? log.a.warn('DASH: invalid frameRate ("' + attribute.value + '")') : parsedAdaptation.frameRate = frameRate;
                    break;

                  case "height":
                    var height = parseInt(attribute.value, 10);
                    isNaN(height) ? log.a.warn('DASH: invalid height ("' + attribute.value + '")') : parsedAdaptation.height = height;
                    break;

                  case "maxPlayoutRate":
                    var maxPlayoutRate = parseFloat(attribute.value);
                    isNaN(maxPlayoutRate) ? log.a.warn('DASH: invalid maxPlayoutRate ("' + attribute.value + '")') : parsedAdaptation.maxPlayoutRate = maxPlayoutRate;
                    break;

                  case "maximumSAPPeriod":
                    var maximumSAPPeriod = parseFloat(attribute.value);
                    isNaN(maximumSAPPeriod) ? log.a.warn('DASH: invalid maximumSAPPeriod ("' + attribute.value + '")') : parsedAdaptation.maximumSAPPeriod = maximumSAPPeriod;
                    break;

                  case "mimeType":
                    parsedAdaptation.mimeType = attribute.value;
                    break;

                  case "profiles":
                    parsedAdaptation.profiles = attribute.value;
                    break;

                  case "segmentProfiles":
                    parsedAdaptation.segmentProfiles = attribute.value;
                    break;

                  case "width":
                    var width = parseInt(attribute.value, 10);
                    isNaN(width) ? log.a.warn('DASH: invalid width ("' + attribute.value + '")') : parsedAdaptation.width = width;
                }
            }
            return parsedAdaptation;
        }
        function createAdaptationSetIntermediateRepresentation(adaptationSetElement) {
            return {
                children: parseAdaptationSetChildren(adaptationSetElement.childNodes),
                attributes: parseAdaptationSetAttributes(adaptationSetElement)
            };
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/Period.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {NodeList} periodChildren
 * @returns {Object}
 */        function parsePeriodChildren(periodChildren) {
            for (var baseURL = "", adaptations = [], i = 0; i < periodChildren.length; i++) if (periodChildren[i].nodeType === Node.ELEMENT_NODE) {
                var currentElement = periodChildren[i];
                switch (currentElement.nodeName) {
                  case "BaseURL":
                    baseURL = currentElement.textContent || "";
                    break;

                  case "AdaptationSet":
                    var adaptation = createAdaptationSetIntermediateRepresentation(currentElement);
                    adaptations.push(adaptation);
                }
            }
            return {
                baseURL: baseURL,
                adaptations: adaptations
            };
        }
        /**
 * @param {Element} periodElement
 * @returns {Object}
 */        function parsePeriodAttributes(periodElement) {
            for (var res = {}, i = 0; i < periodElement.attributes.length; i++) {
                var attribute = periodElement.attributes[i];
                switch (attribute.name) {
                  case "id":
                    res.id = attribute.value;
                    break;

                  case "start":
                    var tempStart = parseDuration(attribute.value);
                    isNaN(tempStart) ? log.a.warn("DASH: Unrecognized start in the mpd:", attribute.value) : res.start = tempStart;
                    break;

                  case "duration":
                    var tempDuration = parseDuration(attribute.value);
                    isNaN(tempDuration) ? log.a.warn("DASH: Unrecognized duration in the mpd:", attribute.value) : res.duration = tempDuration;
                    break;

                  case "bitstreamSwitching":
                    res.bitstreamSwitching = parseBoolean(attribute.value);
                }
            }
            return res;
        }
        function createPeriodIntermediateRepresentation(periodElement) {
            return {
                children: parsePeriodChildren(periodElement.childNodes),
                attributes: parsePeriodAttributes(periodElement)
            };
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/MPD.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Parse children of the MPD's root into a simple object.
 * @param {NodeList} mpdChildren
 * @returns {Object}
 */        function parseMPDChildren(mpdChildren) {
            for (var baseURL = "", locations = [], periods = [], i = 0; i < mpdChildren.length; i++) if (mpdChildren[i].nodeType === Node.ELEMENT_NODE) {
                var currentNode = mpdChildren[i];
                switch (currentNode.nodeName) {
                  case "BaseURL":
                    baseURL = currentNode.textContent || "";
                    break;

                  case "Location":
                    locations.push(currentNode.textContent || "");
                    break;

                  case "Period":
                    var period = createPeriodIntermediateRepresentation(currentNode);
                    periods.push(period);
                }
            }
            return {
                baseURL: baseURL,
                locations: locations,
                periods: periods
            };
        }
        /**
 * @param {Element} root
 * @returns {Object}
 */        function parseMPDAttributes(root) {
            for (var res = {}, i = 0; i < root.attributes.length; i++) {
                var attribute = root.attributes[i];
                switch (attribute.name) {
                  case "id":
                    res.id = attribute.value;
                    break;

                  case "profiles":
                    res.profiles = attribute.value;
                    break;

                  case "type":
                    res.type = attribute.value;
                    break;

                  case "availabilityStartTime":
                    res.availabilityStartTime = +parseDateTime(attribute.value);
                    break;

                  case "availabilityEndTime":
                    res.availabilityEndTime = +parseDateTime(attribute.value);
                    break;

                  case "publishTime":
                    res.publishTime = +parseDateTime(attribute.value);
                    break;

                  case "mediaPresentationDuration":
                    res.duration = parseDuration(attribute.value);
                    break;

                  case "minimumUpdatePeriod":
                    res.minimumUpdatePeriod = parseDuration(attribute.value);
                    break;

                  case "minBufferTime":
                    res.minBufferTime = parseDuration(attribute.value);
                    break;

                  case "timeShiftBufferDepth":
                    res.timeShiftBufferDepth = parseDuration(attribute.value);
                    break;

                  case "suggestedPresentationDelay":
                    res.suggestedPresentationDelay = parseDuration(attribute.value);
                    break;

                  case "maxSegmentDuration":
                    res.maxSegmentDuration = parseDuration(attribute.value);
                    break;

                  case "maxSubsegmentDuration":
                    res.maxSubsegmentDuration = parseDuration(attribute.value);
                }
            }
            return res;
        }
        function createMPDIntermediateRepresentation(root) {
            return {
                children: parseMPDChildren(root.childNodes),
                attributes: parseMPDAttributes(root)
            };
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/index.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        var KNOWN_ADAPTATION_TYPES = [ "audio", "video", "text", "image" ], SUPPORTED_TEXT_TYPES = [ "subtitle", "caption" ];
        /**
 * Infers the type of adaptation from codec and mimetypes found in it.
 *
 * This follows the guidelines defined by the DASH-IF IOP:
 *   - one adaptation set contains a single media type
 *   - The order of verifications are:
 *       1. mimeType
 *       2. Role
 *       3. codec
 *
 * Note: This is based on DASH-IF-IOP-v4.0 with some more freedom.
 * @param {Object} adaptation
 * @returns {string} - "audio"|"video"|"text"|"image"|"metadata"|"unknown"
 */
        function inferAdaptationType(adaptationMimeType, representationMimeTypes, adaptationCodecs, representationCodecs, adaptationRole) {
            function fromMimeType(mimeType, role) {
                var topLevel = mimeType.split("/")[0];
                return Object(array_includes.a)(KNOWN_ADAPTATION_TYPES, topLevel) ? topLevel : "application/bif" === mimeType ? "image" : "application/ttml+xml" === mimeType ? "text" : 
                // manage DASH-IF mp4-embedded subtitles and metadata
                "application/mp4" === mimeType ? role && "urn:mpeg:dash:role:2011" === role.schemeIdUri && Object(array_includes.a)(SUPPORTED_TEXT_TYPES, role.value) ? "text" : "metadata" : void 0;
            }
            function fromCodecs(codecs) {
                switch (codecs.substr(0, 3)) {
                  case "avc":
                  case "hev":
                  case "hvc":
                  case "vp8":
                  case "vp9":
                  case "av1":
                    return "video";

                  case "vtt":
                    return "text";

                  case "bif":
                    return "image";
                }
                switch (codecs.substr(0, 4)) {
                  case "mp4a":
                    return "audio";

                  case "wvtt":
                  case "stpp":
                    return "text";
                }
            }
            if (null != adaptationMimeType) {
                var typeFromMimeType = fromMimeType(adaptationMimeType, adaptationRole);
                if (null != typeFromMimeType) return typeFromMimeType;
            }
            if (null != adaptationCodecs) {
                var typeFromCodecs = fromCodecs(adaptationCodecs);
                if (null != typeFromCodecs) return typeFromCodecs;
            }
            for (var i = 0; i < representationMimeTypes.length; i++) {
                var representationMimeType = representationMimeTypes[i];
                if (null != representationMimeType) {
                    var _typeFromMimeType = fromMimeType(representationMimeType, adaptationRole);
                    if (null != _typeFromMimeType) return _typeFromMimeType;
                }
            }
            for (var _i = 0; _i < representationCodecs.length; _i++) {
                var codecs = representationCodecs[_i];
                if (null != codecs) {
                    var _typeFromMimeType2 = fromCodecs(codecs);
                    if (null != _typeFromMimeType2) return _typeFromMimeType2;
                }
            }
            return "unknown";
        }
        /**
 * Returns "last time of reference" from the adaptation given, considering a
 * live content.
 * Undefined if a time could not be found.
 *
 * We consider the earliest last time from every representations in the given
 * adaptation.
 *
 * This is done to calculate a liveGap which is valid for the whole manifest,
 * even in weird ones.
 * @param {Object} adaptation
 * @returns {Number|undefined}
 */        var getLastLiveTimeReference = function getLastLiveTimeReference(adaptation) {
            // Here's how we do, for each possibility:
            //  1. only the adaptation has an index (no representation has):
            //    - returns the index last time reference
            //
            //  2. every representations have an index:
            //    - returns minimum for every representations
            //
            //  3. not all representations have an index but the adaptation has
            //    - returns minimum between all representations and the adaptation
            //
            //  4. no index for 1+ representation(s) and no adaptation index:
            //    - returns undefined
            //
            //  5. Invalid index found somewhere:
            //    - returns undefined
            if (adaptation) {
                var lastLiveTimeReferences = (adaptation.representations || []).map(function(representation) {
                    var lastPosition = representation.index.getLastPosition();
                    return null != lastPosition ? lastPosition - 10 : void 0;
 // TODO
                                });
                if (!lastLiveTimeReferences.some(function(x) {
                    return null == x;
                })) {
                    var representationsMin = Math.min.apply(Math, lastLiveTimeReferences);
                    if (!isNaN(representationsMin)) return representationsMin;
                }
            }
        };
        function parseManifest(root, uri) {
            for (
            // Transform whole MPD into a parsed JS object representation
            var _createMPDIntermediat = createMPDIntermediateRepresentation(root), rootChildren = _createMPDIntermediat.children, rootAttributes = _createMPDIntermediat.attributes, mpdRootURL = Object(utils_url.b)(Object(utils_url.a)(uri), rootChildren.baseURL), parsedPeriods = [], _loop = function _loop(i) {
                var period = rootChildren.periods[i], periodRootURL = Object(utils_url.b)(mpdRootURL, period.children.baseURL), periodID = void 0;
                // 1. Construct partial URL for contents
                                null == period.attributes.id ? (log.a.warn("DASH: No usable id found in the Period. Generating one."), 
                periodID = "gen-dash-period-" + Object(utils_id.a)()) : periodID = period.attributes.id;
                // 3. Find the start of the Period (required)
                                var periodStart = void 0;
                if (null != period.attributes.start) periodStart = period.attributes.start; else if (0 === i) periodStart = "static" === rootAttributes.type || null == rootAttributes.availabilityStartTime ? 0 : rootAttributes.availabilityStartTime; else {
                    var prevPeriod = parsedPeriods[i - 1];
                    if (null == prevPeriod.duration) throw new Error("Not enough informations on the periods: cannot find start.");
                    periodStart = prevPeriod.start + prevPeriod.duration;
                }
                var periodDuration = void 0;
                if (null != period.attributes.duration) periodDuration = period.attributes.duration; else {
                    var nextPeriod = parsedPeriods[i + 1];
                    nextPeriod && null != nextPeriod.start ? periodDuration = nextPeriod.start - periodStart : 0 === i && rootAttributes.duration && !nextPeriod && (periodDuration = rootAttributes.duration);
                }
                // 4. Construct underlying adaptations
                                var adaptations = period.children.adaptations.reduce(function(acc, adaptation) {
                    var parsedAdaptations = acc.adaptations, adaptationRootURL = Object(utils_url.b)(periodRootURL, adaptation.children.baseURL), adaptationChildren = adaptation.children;
                    // 4-1. Find Index
                    function findAdaptationIndex(representation) {
                        var repId = representation.attributes.id || "", repBitrate = representation.attributes.bitrate, baseURL = representation.children.baseURL, representationURL = Object(utils_url.b)(adaptationRootURL, baseURL), adaptationIndex = void 0;
                        if (null != adaptationChildren.segmentBase) {
                            var segmentBase = adaptationChildren.segmentBase;
                            adaptationIndex = new indexes_base(segmentBase, {
                                periodStart: periodStart,
                                representationURL: representationURL,
                                representationId: repId,
                                representationBitrate: repBitrate
                            });
                        } else if (null != adaptationChildren.segmentList) {
                            var segmentList = adaptationChildren.segmentList;
                            adaptationIndex = new indexes_list(segmentList, {
                                periodStart: periodStart,
                                representationURL: representationURL,
                                representationId: repId,
                                representationBitrate: repBitrate
                            });
                        } else if (null != adaptationChildren.segmentTemplate) {
                            var segmentTemplate = adaptationChildren.segmentTemplate;
                            adaptationIndex = "timeline" === segmentTemplate.indexType ? new indexes_timeline(segmentTemplate, {
                                periodStart: periodStart,
                                representationURL: representationURL,
                                representationId: repId,
                                representationBitrate: repBitrate
                            }) : new template(segmentTemplate, {
                                periodStart: periodStart,
                                representationURL: representationURL,
                                representationId: repId,
                                representationBitrate: repBitrate
                            });
                        } else adaptationIndex = new template({
                            duration: Number.MAX_VALUE,
                            timescale: 1,
                            startNumber: 0,
                            initialization: {
                                media: ""
                            },
                            media: ""
                        }, {
                            periodStart: periodStart,
                            representationURL: representationURL,
                            representationId: repId,
                            representationBitrate: repBitrate
                        });
                        return adaptationIndex;
                    }
                    // 4-2. Construct Representations
                                        var representations = adaptation.children.representations.map(function(representation) {
                        var repId = representation.attributes.id || "", repBitrate = representation.attributes.bitrate, baseURL = representation.children.baseURL, representationURL = Object(utils_url.b)(adaptationRootURL, baseURL), representationBitrate = void 0;
                        null == representation.attributes.bitrate ? (log.a.warn("DASH: No usable bitrate found in the Representation."), 
                        representationBitrate = 0) : representationBitrate = representation.attributes.bitrate;
                        // 4-2-2. Find Index
                                                var representationIndex = void 0;
                        if (null != representation.children.segmentBase) {
                            var segmentBase = representation.children.segmentBase;
                            representationIndex = new indexes_base(segmentBase, {
                                periodStart: periodStart,
                                representationURL: representationURL,
                                representationId: repId,
                                representationBitrate: repBitrate
                            });
                        } else if (null != representation.children.segmentList) {
                            var segmentList = representation.children.segmentList;
                            representationIndex = new indexes_list(segmentList, {
                                periodStart: periodStart,
                                representationURL: representationURL,
                                representationId: repId,
                                representationBitrate: repBitrate
                            });
                        } else if (null != representation.children.segmentTemplate) {
                            var segmentTemplate = representation.children.segmentTemplate;
                            representationIndex = "timeline" === segmentTemplate.indexType ? new indexes_timeline(segmentTemplate, {
                                periodStart: periodStart,
                                representationURL: representationURL,
                                representationId: repId,
                                representationBitrate: repBitrate
                            }) : new template(segmentTemplate, {
                                periodStart: periodStart,
                                representationURL: representationURL,
                                representationId: repId,
                                representationBitrate: repBitrate
                            });
                        } else representationIndex = findAdaptationIndex(representation);
                        // 4-2-3. Set ID
                                                var parsedRepresentation = {
                            bitrate: representationBitrate,
                            index: representationIndex,
                            id: null != representation.attributes.id ? representation.attributes.id : representation.attributes.bitrate + (null != representation.attributes.height ? "-" + representation.attributes.height : "") + (null != representation.attributes.width ? "-" + representation.attributes.width : "") + (null != representation.attributes.mimeType ? "-" + representation.attributes.mimeType : "") + (null != representation.attributes.codecs ? "-" + representation.attributes.codecs : "")
                        }, codecs = void 0;
                        // 4-2-4. Construct Representation Base
                                                if (null != representation.attributes.codecs ? codecs = representation.attributes.codecs : null != adaptation.attributes.codecs && (codecs = adaptation.attributes.codecs), 
                        null != codecs && (codecs = "mp4a.40.02" === codecs ? "mp4a.40.2" : codecs, parsedRepresentation.codecs = codecs), 
                        null != representation.attributes.audioSamplingRate ? parsedRepresentation.audioSamplingRate = representation.attributes.audioSamplingRate : null != adaptation.attributes.audioSamplingRate && (parsedRepresentation.audioSamplingRate = adaptation.attributes.audioSamplingRate), 
                        null != representation.attributes.codingDependency ? parsedRepresentation.codingDependency = representation.attributes.codingDependency : null != adaptation.attributes.codingDependency && (parsedRepresentation.codingDependency = adaptation.attributes.codingDependency), 
                        null != representation.attributes.frameRate ? parsedRepresentation.frameRate = representation.attributes.frameRate : null != adaptation.attributes.frameRate && (parsedRepresentation.frameRate = adaptation.attributes.frameRate), 
                        null != representation.attributes.height ? parsedRepresentation.height = representation.attributes.height : null != adaptation.attributes.height && (parsedRepresentation.height = adaptation.attributes.height), 
                        null != representation.attributes.maxPlayoutRate ? parsedRepresentation.maxPlayoutRate = representation.attributes.maxPlayoutRate : null != adaptation.attributes.maxPlayoutRate && (parsedRepresentation.maxPlayoutRate = adaptation.attributes.maxPlayoutRate), 
                        null != representation.attributes.maximumSAPPeriod ? parsedRepresentation.maximumSAPPeriod = representation.attributes.maximumSAPPeriod : null != adaptation.attributes.maximumSAPPeriod && (parsedRepresentation.maximumSAPPeriod = adaptation.attributes.maximumSAPPeriod), 
                        null != representation.attributes.mimeType ? parsedRepresentation.mimeType = representation.attributes.mimeType : null != adaptation.attributes.mimeType && (parsedRepresentation.mimeType = adaptation.attributes.mimeType), 
                        null != representation.attributes.profiles ? parsedRepresentation.profiles = representation.attributes.profiles : null != adaptation.attributes.profiles && (parsedRepresentation.profiles = adaptation.attributes.profiles), 
                        null != representation.attributes.qualityRanking && (parsedRepresentation.qualityRanking = representation.attributes.qualityRanking), 
                        null != representation.attributes.segmentProfiles ? parsedRepresentation.segmentProfiles = representation.attributes.segmentProfiles : null != adaptation.attributes.segmentProfiles && (parsedRepresentation.segmentProfiles = adaptation.attributes.segmentProfiles), 
                        null != representation.attributes.width ? parsedRepresentation.width = representation.attributes.width : null != adaptation.attributes.width && (parsedRepresentation.width = adaptation.attributes.width), 
                        adaptation.children.contentProtections) {
                            for (var contentProtections = [], k = 0; k < adaptation.children.contentProtections.length; k++) {
                                var protection = adaptation.children.contentProtections[k];
                                null != protection.keyId && contentProtections.push({
                                    keyId: protection.keyId
                                });
                            }
                            contentProtections.length && (parsedRepresentation.contentProtections = contentProtections);
                        }
                        return parsedRepresentation;
                    }), adaptationMimeType = adaptation.attributes.mimeType, adaptationCodecs = adaptation.attributes.codecs, representationMimeTypes = representations.map(function(r) {
                        return r.mimeType;
                    }).filter(function(mimeType) {
                        return null != mimeType;
                    }), representationCodecs = representations.map(function(r) {
                        return r.codecs;
                    }).filter(function(codecs) {
                        return null != codecs;
                    }), type = inferAdaptationType(adaptationMimeType || null, representationMimeTypes, adaptationCodecs || null, representationCodecs, adaptationChildren.role || null), isMainAdaptation = !!adaptation.children.role && "main" === adaptation.children.role.value && "urn:mpeg:dash:role:2011" === adaptation.children.role.schemeIdUri, mainAdaptationForType = acc.mainAdaptations[type];
                    if (void 0 !== mainAdaptationForType && isMainAdaptation) {
                        var _mainAdaptationForTyp;
                        (_mainAdaptationForTyp = mainAdaptationForType.representations).push.apply(_mainAdaptationForTyp, representations);
                    } else {
                        var closedCaption = void 0, audioDescription = void 0;
                        "text" === type && adaptationChildren.accessibility && isHardOfHearing(adaptationChildren.accessibility) && (closedCaption = !0), 
                        "audio" === type && adaptationChildren.accessibility && isVisuallyImpaired(adaptationChildren.accessibility) && (audioDescription = !0);
                        var adaptationID = void 0;
                        if (null != adaptation.attributes.id) adaptationID = adaptation.attributes.id; else {
                            var idString = type;
                            adaptation.attributes.language && (idString += "-" + adaptation.attributes.language), 
                            closedCaption && (idString += "-cc"), audioDescription && (idString += "-ad"), adaptation.attributes.contentType && (idString += "-" + adaptation.attributes.contentType), 
                            adaptation.attributes.codecs && (idString += "-" + adaptation.attributes.codecs), 
                            adaptation.attributes.mimeType && (idString += "-" + adaptation.attributes.mimeType), 
                            adaptation.attributes.frameRate && (idString += "-" + adaptation.attributes.frameRate), 
                            idString.length === type.length && (idString += representations.length ? "-" + representations[0].id : "-empty"), 
                            adaptationID = "adaptation-" + idString;
                        }
                        var parsedAdaptationSet = {
                            id: adaptationID,
                            representations: representations,
                            type: type
                        };
                        null != adaptation.attributes.language && (parsedAdaptationSet.language = adaptation.attributes.language, 
                        parsedAdaptationSet.normalizedLanguage = Object(languages.a)(adaptation.attributes.language)), 
                        null != closedCaption && (parsedAdaptationSet.closedCaption = closedCaption), null != audioDescription && (parsedAdaptationSet.audioDescription = audioDescription);
                        var parsedAdaptation = parsedAdaptations[type];
                        parsedAdaptation ? isMainAdaptation ? (
                        // put "main" adaptation as the first
                        parsedAdaptation.unshift(parsedAdaptationSet), acc.mainAdaptations[type] = parsedAdaptationSet) : parsedAdaptation.push(parsedAdaptationSet) : (parsedAdaptations[type] = [ parsedAdaptationSet ], 
                        isMainAdaptation && (acc.mainAdaptations[type] = parsedAdaptationSet));
                    }
                    return {
                        adaptations: parsedAdaptations,
                        mainAdaptations: acc.mainAdaptations
                    };
                }, {
                    mainAdaptations: {},
                    adaptations: {}
                }).adaptations, parsedPeriod = {
                    id: periodID,
                    start: periodStart,
                    duration: periodDuration,
                    adaptations: adaptations
                };
                null != period.attributes.bitstreamSwitching && (parsedPeriod.bitstreamSwitching = period.attributes.bitstreamSwitching), 
                parsedPeriods.push(parsedPeriod);
            }, i = 0; i < rootChildren.periods.length; i++) _loop(i);
            var parsedMPD = {
                availabilityStartTime: "static" === rootAttributes.type || null == rootAttributes.availabilityStartTime ? 0 : rootAttributes.availabilityStartTime,
                duration: null == rootAttributes.duration ? Infinity : rootAttributes.duration,
                id: null != rootAttributes.id ? rootAttributes.id : "gen-dash-manifest-" + Object(utils_id.a)(),
                periods: parsedPeriods,
                transportType: "dash",
                type: rootAttributes.type || "static",
                uris: [ uri ].concat(rootChildren.locations),
                suggestedPresentationDelay: null != rootAttributes.suggestedPresentationDelay ? rootAttributes.suggestedPresentationDelay : config.a.DEFAULT_SUGGESTED_PRESENTATION_DELAY.DASH
            };
            // -- add optional fields --
                        if (null != rootAttributes.profiles && (parsedMPD.profiles = rootAttributes.profiles), 
            "static" !== rootAttributes.type && null != rootAttributes.availabilityEndTime && (parsedMPD.availabilityEndTime = rootAttributes.availabilityEndTime), 
            null != rootAttributes.publishTime && (parsedMPD.publishTime = rootAttributes.publishTime), 
            null != rootAttributes.duration && (parsedMPD.duration = rootAttributes.duration), 
            null != rootAttributes.minimumUpdatePeriod && (parsedMPD.minimumUpdatePeriod = rootAttributes.minimumUpdatePeriod), 
            null != rootAttributes.minBufferTime && (parsedMPD.minBufferTime = rootAttributes.minBufferTime), 
            null != rootAttributes.timeShiftBufferDepth && (parsedMPD.timeShiftBufferDepth = rootAttributes.timeShiftBufferDepth), 
            null != rootAttributes.maxSegmentDuration && (parsedMPD.maxSegmentDuration = rootAttributes.maxSegmentDuration), 
            null != rootAttributes.maxSubsegmentDuration && (parsedMPD.maxSubsegmentDuration = rootAttributes.maxSubsegmentDuration), 
            "dynamic" === parsedMPD.type) {
                var lastPeriodAdaptations = parsedMPD.periods[parsedMPD.periods.length - 1].adaptations, firstAdaptationsFromLastPeriod = lastPeriodAdaptations.video || lastPeriodAdaptations.audio;
                if (!firstAdaptationsFromLastPeriod || !firstAdaptationsFromLastPeriod.length) throw new Error("Can't find first adaptation from last period");
                var firstAdaptationFromLastPeriod = firstAdaptationsFromLastPeriod[0], lastRef = getLastLiveTimeReference(firstAdaptationFromLastPeriod);
                parsedMPD.presentationLiveGap = null != lastRef ? Date.now() / 1e3 - (lastRef + parsedMPD.availabilityStartTime) : 10;
            }
            return parsedMPD;
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/index.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {Document} manifest - Original manifest as returned by the server
 * @param {string} uri
 * @returns {Object} - parsed manifest
 */        function parseFromDocument(document, uri) {
            var root = document.documentElement;
            if (!root || "MPD" !== root.nodeName) throw new Error("document root should be MPD");
            return parseManifest(root, uri /*, contentProtectionParser*/);
        }
        // EXTERNAL MODULE: ./src/utils/request/index.ts
                var request = __webpack_require__(28), manifest_loader = __webpack_require__(82);
        // EXTERNAL MODULE: ./src/net/utils/manifest_loader.ts
                /* harmony default export */ var isobmff_timing_infos = 
        // CONCATENATED MODULE: ./src/net/dash/isobmff_timing_infos.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Get precize start and duration of a segment from ISOBMFF.
 *   1. get start from tfdt
 *   2. get duration from trun
 *   3. if at least one is missing, get both informations from sidx
 *   4. As a fallback take segment infos.
 * @param {Object} segment
 * @param {UInt8Array} buffer - The entire isobmff container
 * @param {Array.<Object>|undefined} sidxSegments - Segments from sidx. Here
 * pre-parsed for performance reasons as it is usually available when
 * this function is called.
 * @param {Object} initInfos
 * @returns {Object}
 */
        function getISOBMFFTimingInfos(segment, buffer, sidxSegments, initInfos) {
            var _sidxSegments = sidxSegments || [], startTime = void 0, duration = void 0, baseDecodeTime = Object(isobmff.d)(buffer), trunDuration = Object(isobmff.a)(buffer), timescale = initInfos && initInfos.timescale ? initInfos.timescale : segment.timescale, maxDecodeTimeDelta = void 0, segmentDuration = void 0, segmentStart = void 0;
            if (timescale === segment.timescale ? (maxDecodeTimeDelta = Math.min(.9 * timescale, null != segment.duration ? segment.duration / 4 : .25), 
            segmentStart = segment.time, segmentDuration = segment.duration) : (maxDecodeTimeDelta = Math.min(.9 * timescale, null != segment.duration ? segment.duration / segment.timescale * timescale / 4 : .25), 
            segmentStart = (segment.time || 0) / segment.timescale * timescale, segmentDuration = null != segment.duration ? segment.duration / segment.timescale * timescale : void 0), 
            baseDecodeTime >= 0 && (startTime = null != segment.timestampOffset ? baseDecodeTime + segment.timestampOffset * timescale : baseDecodeTime), 
            trunDuration >= 0 && (null == segmentDuration || Math.abs(trunDuration - segmentDuration) <= maxDecodeTimeDelta) && (duration = trunDuration), 
            null == startTime) if (0 === _sidxSegments.length) startTime = segmentStart; else {
                var sidxStart = _sidxSegments[0].time;
                if (sidxStart >= 0) {
                    var sidxTimescale = _sidxSegments[0].timescale, baseStartTime = null != sidxTimescale && sidxTimescale !== timescale ? sidxStart / sidxTimescale * timescale : sidxStart;
                    startTime = null != segment.timestampOffset ? baseStartTime + segment.timestampOffset * timescale : baseStartTime;
                } else startTime = segmentStart;
            }
            if (null == duration) if (_sidxSegments.length) {
                var sidxDuration = _sidxSegments.reduce(function(a, b) {
                    return a + (b.duration || 0);
                }, 0);
                duration = sidxDuration >= 0 ? sidxDuration : segmentDuration;
            } else duration = segmentDuration;
            return {
                timescale: timescale,
                time: startTime || 0,
                duration: duration || 0
            };
        }, merge = __webpack_require__(134), Observable = __webpack_require__(6);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/merge.js
                // CONCATENATED MODULE: ./src/net/dash/utils.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {Object} adaptation
 * @param {Object} dlSegment
 * @param {Object} nextSegments
 */
        function addNextSegments(representation, nextSegments, currentSegment) {
            representation.index._addSegments(nextSegments, currentSegment);
        }
        /**
 * Returns true if the given texttrack segment represents a textrack embedded
 * in a mp4 file.
 * @param {Representation} representation
 * @returns {Boolean}
 */        function isMP4EmbeddedTrack(representation) {
            return "application/mp4" === representation.mimeType;
        }
        /**
 * Returns text-formatted byteRange (`bytes=$start-$end?)`
 * @param {Array.<string|Number>} arr
 * @returns {string}
 */        function byteRange(_ref) {
            var start = _ref[0], end = _ref[1];
            return end && Infinity !== end ? "bytes=" + +start + "-" + +end : "bytes=" + +start + "-";
        }
        // CONCATENATED MODULE: ./src/net/dash/segment_loader.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Segment loader triggered if there was no custom-defined one in the API.
 * @param {Object} opt
 * @returns {Observable}
 */        function regularSegmentLoader(_ref) {
            var url = _ref.url, segment = _ref.segment, range = segment.range, indexRange = segment.indexRange;
            // fire a single time contiguous init and index ranges.
            if (range && indexRange && range[1] === indexRange[0] - 1) return Object(request.a)({
                url: url,
                responseType: "arraybuffer",
                headers: {
                    Range: byteRange([ range[0], indexRange[1] ])
                }
            });
            var mediaHeaders = range ? {
                Range: byteRange(range)
            } : null, mediaOrInitRequest = Object(request.a)({
                url: url,
                responseType: "arraybuffer",
                headers: mediaHeaders
            });
            // If init segment has indexRange metadata, we need to fetch
            // both the initialization data and the index metadata. We do
            // this in parallel and send the both blobs into the pipeline.
            if (indexRange) {
                var indexRequest = Object(request.a)({
                    url: url,
                    responseType: "arraybuffer",
                    headers: {
                        Range: byteRange(indexRange)
                    }
                });
                return Object(merge.a)(mediaOrInitRequest, indexRequest);
            }
            return mediaOrInitRequest;
        }
        /**
 * Generate a segment loader for the application
 * @param {Function} [customSegmentLoader]
 * @returns {Function}
 */        var segment_loader = function segmentPreLoader(customSegmentLoader) {
            return function(_ref2) {
                var adaptation = _ref2.adaptation, manifest = _ref2.manifest, period = _ref2.period, representation = _ref2.representation, segment = _ref2.segment, mediaURL = segment.mediaURL;
                if (null == mediaURL) return Object(of.a)({
                    type: "data",
                    value: {
                        responseData: null
                    }
                });
                var args = {
                    adaptation: adaptation,
                    manifest: manifest,
                    period: period,
                    representation: representation,
                    segment: segment,
                    transport: "dash",
                    url: mediaURL
                };
                return customSegmentLoader ? Observable.a.create(function(obs) {
                    var hasFinished = !1, hasFallbacked = !1, abort = customSegmentLoader(args, {
                        reject: function reject() {
                            var err = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                            hasFallbacked || (hasFinished = !0, obs.error(err));
                        },
                        resolve: function resolve(_args) {
                            hasFallbacked || (hasFinished = !0, obs.next({
                                type: "response",
                                value: {
                                    responseData: _args.data,
                                    size: _args.size,
                                    duration: _args.duration
                                }
                            }), obs.complete());
                        },
                        fallback: function fallback() {
                            hasFallbacked = !0, regularSegmentLoader(args).subscribe(obs);
                        }
                    });
                    return function() {
                        hasFinished || hasFallbacked || "function" != typeof abort || abort();
                    };
                }) : regularSegmentLoader(args);
            };
        }, strings = __webpack_require__(83), read = __webpack_require__(55);
        /* harmony default export */        
        // CONCATENATED MODULE: ./src/net/dash/texttracks.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Perform requests for "text" segments
 * @param {Object} infos
 * @returns {Observable.<Object>}
 */
        function TextTrackLoader(_ref) {
            var segment = _ref.segment, representation = _ref.representation, mediaURL = segment.mediaURL, range = segment.range, indexRange = segment.indexRange, responseType = isMP4EmbeddedTrack(representation) ? "arraybuffer" : "text";
            // init segment without initialization media/range/indexRange:
            // we do nothing on the network
            if (null == mediaURL) return Object(of.a)({
                type: "data",
                value: {
                    responseData: null
                }
            });
            // fire a single time for contiguous init and index ranges
                        if (range && indexRange && range[1] === indexRange[0] - 1) return Object(request.a)({
                url: mediaURL,
                responseType: responseType,
                headers: {
                    Range: byteRange([ range[0], indexRange[1] ])
                }
            });
            var mediaRequest = Object(request.a)({
                url: mediaURL,
                responseType: responseType,
                headers: range ? {
                    Range: byteRange(range)
                } : null
            });
            if (!indexRange) return mediaRequest;
            // If init segment has indexRange metadata, we need to fetch
            // both the initialization data and the index metadata. We do
            // this in parallel and send the both blobs into the pipeline.
            // TODO Find a solution for calling only one time the parser
                        var indexRequest = Object(request.a)({
                url: mediaURL,
                responseType: responseType,
                headers: {
                    Range: byteRange(indexRange)
                }
            });
            return Object(merge.a)(mediaRequest, indexRequest);
        }
        /**
 * Parse TextTrack data.
 * @param {Object} infos
 * @returns {Observable.<Object>}
 */        function TextTrackParser(_ref2) {
            var response = _ref2.response, segment = _ref2.segment, adaptation = _ref2.adaptation, representation = _ref2.representation, init = _ref2.init, language = adaptation.language, isInit = segment.isInit, indexRange = segment.indexRange;
            if (null == response.responseData) return Object(of.a)({
                segmentData: null,
                segmentInfos: segment.timescale > 0 ? {
                    duration: segment.isInit ? 0 : segment.duration,
                    time: segment.isInit ? -1 : segment.time,
                    timescale: segment.timescale
                } : null,
                segmentOffset: segment.timestampOffset || 0
            });
            var responseData = void 0, nextSegments = void 0, segmentInfos = void 0, segmentData = void 0, isMP4 = isMP4EmbeddedTrack(representation);
            if (isMP4) {
                Object(assert.b)(response.responseData instanceof ArrayBuffer), responseData = new Uint8Array(response.responseData);
                var sidxSegments = Object(isobmff.c)(responseData, indexRange ? indexRange[0] : 0);
                sidxSegments && (nextSegments = sidxSegments), segmentInfos = isInit ? {
                    time: -1,
                    duration: 0,
                    timescale: segment.timescale
                } : isobmff_timing_infos(segment, responseData, sidxSegments, init);
            } else 
            // if not MP4
            Object(assert.b)("string" == typeof response.responseData), responseData = response.responseData, 
            segmentInfos = isInit ? {
                time: -1,
                duration: 0,
                timescale: segment.timescale
            } : {
                time: segment.time || 0,
                duration: segment.duration,
                timescale: segment.timescale
            };
            if (isInit) {
                if (isMP4) {
                    var timescale = Object(isobmff.b)(responseData);
                    timescale > 0 && (segmentInfos = {
                        time: -1,
                        duration: 0,
                        timescale: timescale
                    });
                }
                segmentData = null;
            } else {
                // if not init
                Object(assert.b)(null != segmentInfos);
                var segmentDataBase = {
                    start: segmentInfos.time,
                    end: segmentInfos.time + (segmentInfos.duration || 0),
                    language: language,
                    timescale: segmentInfos.timescale
                };
                if (isMP4) {
                    var _representation$codec = representation.codec, type = void 0;
                    switch ((void 0 === _representation$codec ? "" : _representation$codec).toLowerCase()) {
                      case "stpp":
                        // stpp === TTML in MP4
                        type = "ttml";
                        break;

                      case "wvtt":
                        // wvtt === WebVTT in MP4
                        type = "vtt";
                    }
                    if (!type) throw new Error("The codec used for the subtitle is not managed yet.");
                    segmentData = object_assign_default()({
                        data: Object(strings.a)(Object(read.a)(responseData)),
                        type: type
                    }, {
                        timescale: 1
                    }, segmentDataBase);
                } else {
                    // not MP4: check for plain text subtitles
                    var _type = void 0, _representation$mimeT = representation.mimeType, mimeType = void 0 === _representation$mimeT ? "" : _representation$mimeT;
                    switch (representation.mimeType) {
                      case "application/ttml+xml":
                        _type = "ttml";
                        break;

                      case "application/x-sami":
                      case "application/smil":
                        _type = "sami";
                        break;

                      case "text/vtt":
                        _type = "vtt";
                    }
                    if (!_type) {
                        var _representation$codec2 = representation.codec;
                        if ("srt" !== (void 0 === _representation$codec2 ? "" : _representation$codec2).toLowerCase()) throw new Error("could not find a text-track parser for the type " + mimeType);
                        _type = "srt";
                    }
                    segmentData = object_assign_default()({
                        data: responseData,
                        type: _type
                    }, {
                        timescale: 1
                    }, segmentDataBase);
                }
            }
            return nextSegments && addNextSegments(representation, nextSegments, segmentInfos), 
            Object(of.a)({
                segmentData: segmentData,
                segmentInfos: segmentInfos,
                segmentOffset: segment.timestampOffset || 0
            });
        }
        // CONCATENATED MODULE: ./src/net/dash/index.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */
        /**
 * Returns pipelines used for DASH streaming.
 * @param {Object} options
 * implementation. Used for each generated http request.
 * @returns {Object}
 */
        /* harmony default export */        __webpack_exports__.default = function() {
            var options = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, manifestLoader = Object(manifest_loader.a)({
                customManifestLoader: options.manifestLoader
            }), segmentLoader = segment_loader(options.segmentLoader), segmentPipeline = {
                loader: function loader(_ref3) {
                    var adaptation = _ref3.adaptation, init = _ref3.init, manifest = _ref3.manifest, period = _ref3.period, representation = _ref3.representation, segment = _ref3.segment;
                    return segmentLoader({
                        adaptation: adaptation,
                        init: init,
                        manifest: manifest,
                        period: period,
                        representation: representation,
                        segment: segment
                    });
                },
                parser: function parser(_ref4) {
                    var segment = _ref4.segment, representation = _ref4.representation, response = _ref4.response, init = _ref4.init, responseData = response.responseData;
                    if (null == responseData) return Object(of.a)({
                        segmentData: null,
                        segmentInfos: null,
                        segmentOffset: 0
                    });
                    var segmentData = responseData instanceof Uint8Array ? responseData : new Uint8Array(responseData), indexRange = segment.indexRange, sidxSegments = Object(isobmff.c)(segmentData, indexRange ? indexRange[0] : 0);
                    if (!segment.isInit) return Object(of.a)({
                        segmentData: segmentData,
                        segmentInfos: isobmff_timing_infos(segment, segmentData, sidxSegments, init),
                        segmentOffset: segment.timestampOffset || 0
                    });
                    sidxSegments && addNextSegments(representation, sidxSegments);
                    var timescale = Object(isobmff.b)(segmentData);
                    return Object(of.a)({
                        segmentData: segmentData,
                        segmentInfos: timescale > 0 ? {
                            time: -1,
                            duration: 0,
                            timescale: timescale
                        } : null,
                        segmentOffset: segment.timestampOffset || 0
                    });
                }
            };
            return {
                manifest: {
                    loader: function loader(_ref) {
                        var url = _ref.url;
                        return manifestLoader(url);
                    },
                    parser: function parser(_ref2) {
                        var response = _ref2.response, reqURL = _ref2.url, url = null == response.url ? reqURL : response.url, data = "string" == typeof response.responseData ? new DOMParser().parseFromString(response.responseData, "text/xml") : response.responseData;
                        return Object(of.a)({
                            manifest: parseFromDocument(data, url),
                            url: url
                        });
                    }
                },
                audio: segmentPipeline,
                video: segmentPipeline,
                text: {
                    loader: TextTrackLoader,
                    parser: TextTrackParser
                },
                image: {
                    loader: function loader(_ref5) {
                        var segment = _ref5.segment;
                        if (segment.isInit || null == segment.mediaURL) return Object(of.a)({
                            type: "data",
                            value: {
                                responseData: null
                            }
                        });
                        var mediaURL = segment.mediaURL;
                        return Object(request.a)({
                            url: mediaURL,
                            responseType: "arraybuffer"
                        });
                    },
                    parser: function parser(_ref6) {
                        var response = _ref6.response, segment = _ref6.segment, responseData = response.responseData;
                        // TODO image Parsing should be more on the sourceBuffer side, no?
                        if (null === responseData || null == features.a.imageParser) return Object(of.a)({
                            segmentData: null,
                            segmentInfos: segment.timescale > 0 ? {
                                duration: segment.isInit ? 0 : segment.duration,
                                time: segment.isInit ? -1 : segment.time,
                                timescale: segment.timescale
                            } : null,
                            segmentOffset: segment.timestampOffset || 0
                        });
                        var bifObject = features.a.imageParser(new Uint8Array(responseData)), data = bifObject.thumbs;
                        return Object(of.a)({
                            segmentData: {
                                data: data,
                                start: 0,
                                end: Number.MAX_VALUE,
                                timescale: 1,
                                type: "bif"
                            },
                            segmentInfos: {
                                time: 0,
                                duration: Number.MAX_VALUE,
                                timescale: bifObject.timescale
                            },
                            segmentOffset: segment.timestampOffset || 0
                        });
                    }
                }
            };
        };
        /***/    }, 
    /* 125 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/of.js
        var of = __webpack_require__(75), map = __webpack_require__(54), features = __webpack_require__(7), config = __webpack_require__(3), assert = __webpack_require__(9), utils_id = __webpack_require__(18), languages = __webpack_require__(40), utils_url = __webpack_require__(38), log = __webpack_require__(0), array_includes = __webpack_require__(14);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/map.js
                // CONCATENATED MODULE: ./src/parsers/manifest/smooth/check_manifest_ids.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Ensure that no two adaptations have the same ID and that no two
 * representations from a same adaptation neither.
 *
 * Log and mutate their ID if not until this is verified.
 *
 * @param {Object} manifest
 */
        function checkManifestIDs(manifest) {
            manifest.periods.forEach(function(_ref) {
                var adaptations = _ref.adaptations, adaptationIDs = [];
                Object.keys(adaptations).forEach(function(type) {
                    (adaptations[type] || []).forEach(function(adaptation) {
                        var adaptationID = adaptation.id;
                        if (Object(array_includes.a)(adaptationIDs, adaptationID)) {
                            log.a.warn("Smooth: Two adaptations with the same ID found. Updating.", adaptationID);
                            var newID = adaptationID + "-";
                            adaptation.id = newID, checkManifestIDs(manifest), adaptationIDs.push(newID);
                        } else adaptationIDs.push(adaptationID);
                        var representationIDs = [];
                        adaptation.representations.forEach(function(representation) {
                            var representationID = representation.id;
                            if (Object(array_includes.a)(representationIDs, representationID)) {
                                log.a.warn("Smooth: Two representations with the same ID found. Updating.", representationID);
                                var _newID = representationID + "-";
                                representation.id = _newID, checkManifestIDs(manifest), representationIDs.push(_newID);
                            } else representationIDs.push(representationID);
                        });
                    });
                });
            });
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/smooth/get_codecs.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {string} fourCC
 * @param {string} codecPrivateData
 * @returns {string}
 */        function getAudioCodecs(fourCC, codecPrivateData) {
            var mpProfile = void 0;
            return (mpProfile = "AACH" === fourCC ? 5 : codecPrivateData ? (248 & parseInt(codecPrivateData.substr(0, 2), 16)) >> 3 : 2) ? "mp4a.40." + mpProfile : "";
        }
        /**
 * @param {string} codecPrivateData
 * @returns {string}
 */        function getVideoCodecs(codecPrivateData) {
            // we can extract codes only if fourCC is on of "H264", "X264", "DAVC", "AVC1"
            var _ref$ = (/00000001\d7([0-9a-fA-F]{6})/.exec(codecPrivateData) || [])[1], avcProfile = void 0 === _ref$ ? "" : _ref$;
            return avcProfile && "avc1." + avcProfile;
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/smooth/parse_C_nodes.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Parse C nodes to build index timeline.
 * @param {Element} nodes
 */        function parseCNodes(nodes) {
            return nodes.reduce(function(timeline, node, i) {
                var dAttr = node.getAttribute("d"), tAttr = node.getAttribute("t"), rAttr = node.getAttribute("r"), r = rAttr ? +rAttr - 1 : 0, ts = tAttr ? +tAttr : void 0, d = dAttr ? +dAttr : void 0;
                if (0 === i) 
                // first node
                ts = ts || 0; else {
                    // from second node to the end
                    var prev = timeline[i - 1];
                    if (null == ts || isNaN(ts)) {
                        if (null == prev.d || isNaN(prev.d)) throw new Error("Smooth: Invalid CNodes. Missing timestamp.");
                        ts = prev.ts + prev.d * (prev.r + 1);
                    }
                }
                if (null == d || isNaN(d)) {
                    var nextNode = nodes[i + 1];
                    if (!nextNode) return timeline;
                    var nextTAttr = nextNode.getAttribute("t"), nextTS = nextTAttr ? +nextTAttr : null;
                    if (null === nextTS) throw new Error("Can't build index timeline from Smooth Manifest.");
                    d = nextTS - ts;
                }
                return timeline.push({
                    d: d,
                    ts: ts,
                    r: r
                }), timeline;
            }, []);
        }
        // EXTERNAL MODULE: ./src/utils/bytes.ts
                var bytes = __webpack_require__(1);
        // CONCATENATED MODULE: ./src/parsers/containers/isobmff/drm/playready.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Parse PlayReady privateData to get its Hexa-coded KeyID.
 * @param {Uint8Array} privateData
 * @returns {string}
 */        function getPlayReadyKIDFromPrivateData(data) {
            var xmlLength = Object(bytes.n)(data, 8), xml = Object(bytes.g)(data.subarray(10, xmlLength + 10)), kidElement = new DOMParser().parseFromString(xml, "application/xml").querySelector("KID");
            if (!kidElement) throw new Error("Cannot parse PlayReady private data: invalid XML");
            var kid = kidElement.textContent || "";
            return Object(bytes.i)(atob(kid)).toLowerCase();
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/smooth/parse_protection_node.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {Uint8Array} keyIdBytes
 * @returns {Array.<Object>}
 */        function createWidevineKeySystem(keyIdBytes) {
            return [ {
                systemId: "edef8ba9-79d6-4ace-a3c8-27dcd51d21ed",
                privateData: Object(bytes.h)([ 8, 1, 18, 16 ], keyIdBytes)
            } ];
        }
        /**
 * Parse "Protection" Node, which contains DRM informations
 * @param {Element} protectionNode
 * @returns {Object}
 */        function parseProtectionNode(protectionNode) {
            var keySystemCreator = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : createWidevineKeySystem;
            if (!protectionNode.firstElementChild || "ProtectionHeader" !== protectionNode.firstElementChild.nodeName) throw new Error("Protection should have ProtectionHeader child");
            var header = protectionNode.firstElementChild, privateData = Object(bytes.p)(atob(header.textContent || "")), keyIdHex = getPlayReadyKIDFromPrivateData(privateData), keyIdBytes = Object(bytes.j)(keyIdHex);
            return {
                keyId: keyIdHex,
                keySystems: [ {
                    systemId: (header.getAttribute("SystemID") || "").toLowerCase().replace(/\{|\}/g, ""),
                    privateData: privateData
                } ].concat(keySystemCreator(keyIdBytes))
            };
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/smooth/utils/tokens.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {string} url
 * @param {Representation} representation
 * @returns {string}
 */        function replaceRepresentationSmoothTokens(url, representation) {
            return url.replace(/\{bitrate\}/g, String(representation.bitrate));
        }
        /**
 * @param {string} url
 * @param {number} time
 * @returns {string}
 */        function replaceSegmentSmoothTokens(url, time) {
            return url.replace(/\{start time\}/g, String(time));
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/smooth/representationIndex.ts
                function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Add a new segment to the index.
 *
 * /!\ Mutate the given index
 * @param {Object} index
 * @param {Object} newSegment
 * @param {Object} currentSegment
 * @returns {Boolean} - true if the segment has been added
 */        function _addSegmentInfos(index, newSegment, currentSegment) {
            var timeline = index.timeline, timescale = index.timescale, timelineLength = timeline.length, last = timeline[timelineLength - 1], scaledNewSegment = newSegment.timescale === timescale ? {
                time: newSegment.time,
                duration: newSegment.duration
            } : {
                time: newSegment.time / newSegment.timescale * timescale,
                duration: newSegment.duration / newSegment.timescale * timescale
            }, scaledCurrentTime = void 0;
            if (currentSegment && currentSegment.timescale && (scaledCurrentTime = currentSegment.timescale === timescale ? currentSegment.time : currentSegment.time / currentSegment.timescale * timescale), 
            null != scaledCurrentTime && scaledNewSegment.time === scaledCurrentTime) {
                var newSegmentTs = scaledNewSegment.time + scaledNewSegment.duration, tsDiff = newSegmentTs - (last.ts + (last.d || 0) * last.r);
                if (tsDiff <= 0) 
                // same segment / behind the last
                return !1;
                // try to use the compact notation with @r attribute on the last
                // to elements of the timeline if we find out they have the same
                // duration
                                if (-1 === last.d) {
                    var prev = timeline[timelineLength - 2];
                    prev && prev.d === tsDiff ? (prev.r++, timeline.pop()) : last.d = tsDiff;
                }
                return index.timeline.push({
                    d: -1,
                    ts: newSegmentTs,
                    r: 0
                }), !0;
            }
            // if the given timing has a timestamp after the timeline end we
            // just need to push a new element in the timeline, or increase
            // the @r attribute of the last element.
                        return scaledNewSegment.time >= getTimelineRangeEnd(last) && (last.d === scaledNewSegment.duration ? last.r++ : index.timeline.push({
                d: scaledNewSegment.duration,
                ts: scaledNewSegment.time,
                r: 0
            }), !0);
        }
        /**
 * Get index of the segment containing the given timescaled timestamp.
 * @param {Object} index
 * @param {Number} ts
 * @returns {Number}
 */        function getSegmentIndex(index, ts) {
            for (var timeline = index.timeline, low = 0, high = timeline.length; low < high; ) {
                var mid = low + high >>> 1;
                timeline[mid].ts < ts ? low = mid + 1 : high = mid;
            }
            return low > 0 ? low - 1 : low;
        }
        /**
 * @param {Number} ts
 * @param {Number} up
 * @param {Number} duration
 * @returns {Number}
 */        function getSegmentNumber(ts, up, duration) {
            if (!duration) return 0;
            var diff = up - ts;
            return diff > 0 ? Math.floor(diff / duration) : 0;
        }
        /**
 * Get end of the given index range, timescaled.
 * @param {Object} range
 * @returns {Number} - absolute end time of the range
 */        function getTimelineRangeEnd(_ref) {
            var ts = _ref.ts, d = _ref.d, r = _ref.r;
            return null == d || -1 === d ? ts : ts + (r + 1) * d;
        }
        // interface ISmoothIndex {
        //   presentationTimeOffset? : number;
        //   timescale : number;
        //   media? : string;
        //   timeline : IIndexSegment[];
        //   startNumber? : number;
        // }
        /**
 * Convert second-based start time and duration to the timescale of the
 * manifest's index.
 * @param {Object} index
 * @param {Number} ts
 * @param {Number} duration
 * @returns {Object} - Object with two properties:
 *   - up {Number}: timescaled timestamp of the beginning time
 *   - to {Number}: timescaled timestamp of the end time (start time + duration)
 */        function normalizeRange(index, // TODO
        ts, duration) {
            var timescale = index.timescale || 1;
            return {
                up: ts * timescale,
                to: (ts + duration) * timescale
            };
        }
        /**
 * Calculate the number of times a segment repeat based on the next segment.
 * @param {Object} segment
 * @param {Object} nextSegment
 * @returns {Number}
 */        function calculateRepeat(segment, nextSegment) {
            var repeatCount = segment.r || 0;
            // A negative value of the @r attribute of the S element indicates
            // that the duration indicated in @d attribute repeats until the
            // start of the next S element, the end of the Period or until the
            // next MPD update.
            // TODO Also for SMOOTH????
                        if (null != segment.d && repeatCount < 0) {
                var repeatEnd = nextSegment ? nextSegment.ts : Infinity;
                repeatCount = Math.ceil((repeatEnd - segment.ts) / segment.d) - 1;
            }
            return repeatCount;
        }
        /**
 * RepresentationIndex implementation for Smooth Manifests.
 *
 * Allows to interact with the index to create new Segments.
 *
 * @class SmoothRepresentationIndex
 */        var representationIndex = function() {
            function SmoothRepresentationIndex(index, infos) {
                _classCallCheck(this, SmoothRepresentationIndex), this._index = index, this._bitsPerSample = infos.bitsPerSample, 
                this._channels = infos.channels, this._codecPrivateData = infos.codecPrivateData, 
                this._packetSize = infos.packetSize, this._samplingRate = infos.samplingRate, this._protection = infos.protection;
            }
            /**
     * Construct init Segment compatible with a Smooth Manifest.
     * @returns {Object}
     */            return SmoothRepresentationIndex.prototype.getInitSegment = function getInitSegment() {
                return {
                    id: "init",
                    isInit: !0,
                    time: 0,
                    timescale: this._index.timescale,
                    privateInfos: {
                        smoothInit: {
                            bitsPerSample: this._bitsPerSample,
                            channels: this._channels,
                            codecPrivateData: this._codecPrivateData,
                            packetSize: this._packetSize,
                            samplingRate: this._samplingRate,
                            protection: this._protection
                        }
                    },
                    mediaURL: null
                };
            }, 
            /**
     * Generate a list of Segments for a particular period of time.
     *
     * @param {Number} _up
     * @param {Number} _to
     * @returns {Array.<Object>}
     */
            SmoothRepresentationIndex.prototype.getSegments = function getSegments(_up, _to) {
                for (var index = this._index, _normalizeRange = normalizeRange(index, _up, _to), up = _normalizeRange.up, to = _normalizeRange.to, timeline = index.timeline, timescale = index.timescale, media = index.media, currentNumber = void 0, segments = [], timelineLength = timeline.length, maxEncounteredDuration = timeline.length && timeline[0].d || 0, i = 0; i < timelineLength; i++) {
                    var segmentRange = timeline[i], d = segmentRange.d, ts = segmentRange.ts;
                    // live-added segments have @d attribute equals to -1
                    if (maxEncounteredDuration = Math.max(maxEncounteredDuration, d || 0), null != d && d < 0) {
                        // TODO what? May be to play it safe and avoid adding segments which are
                        // not completely generated
                        if (ts + maxEncounteredDuration < to) {
                            var segment = {
                                id: "" + ts,
                                time: ts,
                                isInit: !1,
                                timescale: timescale,
                                number: null != currentNumber ? currentNumber : void 0,
                                mediaURL: replaceSegmentSmoothTokens(media, ts)
                            };
                            segments.push(segment);
                        }
                        return segments;
                    }
                    for (var repeat = calculateRepeat(segmentRange, timeline[i + 1]), segmentNumberInCurrentRange = getSegmentNumber(ts, up, d), segmentTime = ts + segmentNumberInCurrentRange * (null == d ? 0 : d); segmentTime < to && segmentNumberInCurrentRange <= repeat; ) {
                        var _segment = {
                            id: "" + segmentTime,
                            time: segmentTime,
                            isInit: !1,
                            duration: d,
                            timescale: timescale,
                            number: null != currentNumber ? currentNumber + segmentNumberInCurrentRange : void 0,
                            mediaURL: replaceSegmentSmoothTokens(media, segmentTime)
                        };
                        segments.push(_segment), segmentTime = ts + 
                        // update segment number and segment time for the next segment
                        ++segmentNumberInCurrentRange * d;
                    }
                    if (segmentTime >= to) 
                    // we reached ``to``, we're done
                    return segments;
                    null != currentNumber && (currentNumber += repeat + 1);
                }
                return segments;
            }, 
            /**
     * Returns true if, based on the arguments, the index should be refreshed.
     * (If we should re-fetch the manifest)
     * @param {Number} from
     * @param {Number} to
     * @returns {Boolean}
     */
            SmoothRepresentationIndex.prototype.shouldRefresh = function shouldRefresh(up, to) {
                var _index = this._index, timeline = _index.timeline, timescale = _index.timescale, lastSegmentInCurrentTimeline = timeline[timeline.length - 1];
                if (!lastSegmentInCurrentTimeline) return !1;
                var repeat = lastSegmentInCurrentTimeline.r || 0, endOfLastSegmentInCurrentTimeline = lastSegmentInCurrentTimeline.ts + (repeat + 1) * lastSegmentInCurrentTimeline.d;
                return !(to * timescale < endOfLastSegmentInCurrentTimeline) && (up * timescale >= endOfLastSegmentInCurrentTimeline || up > lastSegmentInCurrentTimeline.ts + repeat * lastSegmentInCurrentTimeline.d);
            }, 
            /**
     * Returns first position in the index.
     *
     * @param {Object} index
     * @returns {Number}
     */
            SmoothRepresentationIndex.prototype.getFirstPosition = function getFirstPosition() {
                var index = this._index;
                if (index.timeline.length) return index.timeline[0].ts / index.timescale;
            }, 
            /**
     * Returns last position in the index.
     * @param {Object} index
     * @returns {Number}
     */
            SmoothRepresentationIndex.prototype.getLastPosition = function getLastPosition() {
                var index = this._index;
                if (index.timeline.length) return getTimelineRangeEnd(index.timeline[index.timeline.length - 1]) / index.timescale;
            }, 
            /**
     * Checks if the time given is in a discontinuity. That is:
     *   - We're on the upper bound of the current range (end of the range - time
     *     is inferior to the timescale)
     *   - The next range starts after the end of the current range.
     *
     * @param {Number} _time
     * @returns {Number} - If a discontinuity is present, this is the Starting ts
     * for the next (discontinuited) range. If not this is equal to -1.
     */
            SmoothRepresentationIndex.prototype.checkDiscontinuity = function checkDiscontinuity(_time) {
                var index = this._index, timeline = index.timeline, _index$timescale = index.timescale, timescale = void 0 === _index$timescale ? 1 : _index$timescale, time = _time * timescale;
                if (time <= 0) return -1;
                var segmentIndex = getSegmentIndex(index, time);
                if (segmentIndex < 0 || segmentIndex >= timeline.length - 1) return -1;
                var range = timeline[segmentIndex];
                if (-1 === range.d) return -1;
                var rangeUp = range.ts, rangeTo = getTimelineRangeEnd(range), nextRange = timeline[segmentIndex + 1];
                // when we are actually inside the found range and this range has
                // an explicit discontinuity with the next one
                return rangeTo !== nextRange.ts && time >= rangeUp && time <= rangeTo && rangeTo - time < timescale ? nextRange.ts / timescale : -1;
            }, SmoothRepresentationIndex.prototype._update = function _update(newIndex) {
                this._index = newIndex._index;
            }, SmoothRepresentationIndex.prototype._addSegments = function _addSegments(nextSegments, currentSegment) {
                for (var i = 0; i < nextSegments.length; i++) _addSegmentInfos(this._index, nextSegments[i], currentSegment);
            }, SmoothRepresentationIndex;
        }();
        /* harmony default export */        
        // CONCATENATED MODULE: ./src/parsers/manifest/smooth/utils/parseBoolean.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {*} parseBoolean
 * @returns {Boolean}
 */
        function parseBoolean(val) {
            return "boolean" == typeof val ? val : "string" == typeof val && "TRUE" === val.toUpperCase();
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/smooth/utils/reduceChildren.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Reduce implementation for the children of the given element.
 * TODO better typings
 * @param {Element} root
 * @param {Function} fn
 * @param {*} init
 * @returns {*}
 */        function reduceChildren(root, fn, init) {
            for (var node = root.firstElementChild, r = init; node; ) r = fn(r, node.nodeName, node), 
            node = node.nextElementSibling;
            return r;
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/smooth/index.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        var DEFAULT_MIME_TYPES = {
            audio: "audio/mp4",
            video: "video/mp4",
            text: "application/ttml+xml"
        }, DEFAULT_CODECS = {
            audio: "mp4a.40.2",
            video: "avc1.4D401E"
        }, MIME_TYPES = {
            AACL: "audio/mp4",
            AVC1: "video/mp4",
            H264: "video/mp4",
            TTML: "application/ttml+xml+mp4"
        };
        /* harmony default export */ var smooth = 
        /**
 * @param {Object|undefined} parserOptions
 * @returns {Function}
 */
        function createSmoothStreamingParser() {
            var parserOptions = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, SUGGESTED_PERSENTATION_DELAY = null == parserOptions.suggestedPresentationDelay ? config.a.DEFAULT_SUGGESTED_PRESENTATION_DELAY.SMOOTH : parserOptions.suggestedPresentationDelay, REFERENCE_DATE_TIME = parserOptions.referenceDateTime || Date.UTC(1970, 0, 1, 0, 0, 0, 0) / 1e3, MIN_REPRESENTATION_BITRATE = parserOptions.minRepresentationBitrate || 0;
            /**
     * @param {Element} q
     * @param {string} type
     * @return {Object}
     */
            function parseQualityLevel(q, type) {
                /**
         * @param {string} name
         * @returns {string|undefined}
         */
                function getAttribute(name) {
                    var attr = q.getAttribute(name);
                    return null == attr ? void 0 : attr;
                }
                switch (type) {
                  case "audio":
                    var audiotag = getAttribute("AudioTag"), bitrate = getAttribute("Bitrate"), bitsPerSample = getAttribute("BitsPerSample"), channels = getAttribute("Channels"), codecPrivateData = getAttribute("CodecPrivateData"), fourCC = getAttribute("FourCC"), packetSize = getAttribute("PacketSize"), samplingRate = getAttribute("SamplingRate");
                    return {
                        audiotag: void 0 !== audiotag ? parseInt(audiotag, 10) : audiotag,
                        bitrate: bitrate && parseInt(bitrate, 10) || 0,
                        bitsPerSample: void 0 !== bitsPerSample ? parseInt(bitsPerSample, 10) : bitsPerSample,
                        channels: void 0 !== channels ? parseInt(channels, 10) : channels,
                        codecPrivateData: codecPrivateData || "",
                        mimeType: void 0 !== fourCC ? MIME_TYPES[fourCC] : fourCC,
                        packetSize: void 0 !== packetSize ? parseInt(packetSize, 10) : packetSize,
                        samplingRate: void 0 !== samplingRate ? parseInt(samplingRate, 10) : samplingRate
                    };

                  case "video":
                    var _bitrate = getAttribute("Bitrate"), _codecPrivateData = getAttribute("CodecPrivateData"), _fourCC = getAttribute("FourCC"), width = getAttribute("MaxWidth"), height = getAttribute("MaxHeight");
                    return {
                        bitrate: _bitrate && parseInt(_bitrate, 10) || 0,
                        mimeType: void 0 !== _fourCC ? MIME_TYPES[_fourCC] : _fourCC,
                        codecPrivateData: _codecPrivateData || "",
                        codecs: getVideoCodecs(_codecPrivateData || ""),
                        width: void 0 !== width ? parseInt(width, 10) : void 0,
                        height: void 0 !== height ? parseInt(height, 10) : void 0
                    };

                  case "text":
                    var _bitrate2 = getAttribute("Bitrate"), _codecPrivateData2 = getAttribute("CodecPrivateData"), _fourCC2 = getAttribute("FourCC");
                    return {
                        bitrate: _bitrate2 && parseInt(_bitrate2, 10) || 0,
                        mimeType: void 0 !== _fourCC2 ? MIME_TYPES[_fourCC2] : _fourCC2,
                        codecPrivateData: _codecPrivateData2 || ""
                    };

                  default:
                    throw new Error("Unrecognized StreamIndex type: " + type);
                }
            }
            /**
     * Parse the adaptations (<StreamIndex>) tree containing
     * representations (<QualityLevels>) and timestamp indexes (<c>).
     * Indexes can be quite huge, and this function needs to
     * to be optimized.
     * @param {Element} root
     * @param {string} rootURL
     * @param {Number} timescale
     * @returns {Object}
     */            function parseAdaptation(root, rootURL, timescale, protections) {
                var _timescale = root.hasAttribute("Timescale") ? +(root.getAttribute("Timescale") || 0) : timescale, adaptationType = root.getAttribute("Type");
                if (null == adaptationType) throw new Error("StreamIndex without type.");
                var subType = root.getAttribute("Subtype"), name = root.getAttribute("Name"), language = root.getAttribute("Language"), normalizedLanguage = null == language ? language : Object(languages.a)(language), baseURL = root.getAttribute("Url") || "", _reduceChildren = reduceChildren(root, function(res, _name, node) {
                    switch (_name) {
                      case "QualityLevel":
                        var rep = parseQualityLevel(node, adaptationType);
                        if ("audio" === adaptationType) {
                            var fourCC = node.getAttribute("FourCC") || "";
                            rep.codecs = getAudioCodecs(fourCC, rep.codecPrivateData);
                        }
                        // filter out video representations with small bitrates
                                                ("video" !== adaptationType || rep.bitrate > MIN_REPRESENTATION_BITRATE) && res.representations.push(rep);
                        break;

                      case "c":
                        res.cNodes.push(node);
                    }
                    return res;
                }, {
                    representations: [],
                    cNodes: []
                }), representations = _reduceChildren.representations, index = {
                    timeline: parseCNodes(_reduceChildren.cNodes),
                    timescale: _timescale
                };
                // we assume that all representations have the same
                // codec and mimeType
                Object(assert.b)(0 !== representations.length, "adaptation should have at least one representation");
                var id = adaptationType + (language ? "_" + language : "");
                // apply default properties
                                // TODO(pierre): real ad-insert support
                if (representations.forEach(function(representation) {
                    var path = Object(utils_url.b)(rootURL, baseURL), repIndex = {
                        timeline: index.timeline,
                        timescale: index.timescale,
                        media: replaceRepresentationSmoothTokens(path, representation)
                    };
                    representation.mimeType = representation.mimeType || DEFAULT_MIME_TYPES[adaptationType], 
                    representation.codecs = representation.codecs || DEFAULT_CODECS[adaptationType], 
                    representation.id = id + "_" + adaptationType + "-" + representation.mimeType + "-" + representation.codecs + "-" + representation.bitrate;
                    var firstProtection = void 0;
                    if (protections.length) {
                        firstProtection = protections[0];
                        var contentProtections = [];
                        protections.forEach(function(protection) {
                            var keyId = protection.keyId;
                            protection.keySystems.forEach(function(keySystem) {
                                contentProtections.push({
                                    keyId: keyId,
                                    systemId: keySystem.systemId
                                });
                            });
                        }), contentProtections.length && (representation.contentProtections = contentProtections);
                    }
                    var initSegmentInfos = {
                        bitsPerSample: representation.bitsPerSample,
                        channels: representation.channels,
                        codecPrivateData: representation.codecPrivateData || "",
                        packetSize: representation.packetSize,
                        samplingRate: representation.samplingRate,
                        // TODO set multiple protections here instead of the first one
                        protection: null != firstProtection ? {
                            keyId: firstProtection.keyId,
                            keySystems: firstProtection.keySystems
                        } : void 0
                    };
                    representation.index = new representationIndex(repIndex, initSegmentInfos);
                }), "ADVT" === subType) return null;
                var parsedAdaptation = {
                    id: id,
                    type: adaptationType,
                    representations: representations,
                    name: null == name ? void 0 : name,
                    language: null == language ? void 0 : language,
                    normalizedLanguage: null == normalizedLanguage ? void 0 : normalizedLanguage
                };
                return "text" === adaptationType && "DESC" === subType && (parsedAdaptation.closedCaption = !0), 
                parsedAdaptation;
            }
            return function parseFromDocument(doc, url) {
                var rootURL = Object(utils_url.a)(url), root = doc.documentElement;
                Object(assert.b)("SmoothStreamingMedia" === root.nodeName, "document root should be SmoothStreamingMedia"), 
                Object(assert.b)(/^[2]-[0-2]$/.test(root.getAttribute("MajorVersion") + "-" + root.getAttribute("MinorVersion")), "Version should be 2.0, 2.1 or 2.2");
                var timescale = +(root.getAttribute("Timescale") || 1e7), _reduceChildren2 = reduceChildren(root, function(res, name, node) {
                    switch (name) {
                      case "Protection":
                        res.protections.push(parseProtectionNode(node, parserOptions.keySystems));
                        break;

                      case "StreamIndex":
                        res.adaptationNodes.push(node);
                    }
                    return res;
                }, {
                    adaptationNodes: [],
                    protections: []
                }), protections = _reduceChildren2.protections, adaptations = _reduceChildren2.adaptationNodes.map(function(node) {
                    return parseAdaptation(node, rootURL, timescale, protections);
                }).filter(function(adaptation) {
                    return null != adaptation;
                }).reduce(function(acc, adaptation) {
                    var type = adaptation.type;
                    return void 0 === acc[type] ? acc[type] = [ adaptation ] : (acc[type] || []).push(adaptation), 
                    acc;
                }, {}), suggestedPresentationDelay = void 0, presentationLiveGap = void 0, timeShiftBufferDepth = void 0, availabilityStartTime = void 0, duration = void 0, firstVideoAdaptation = adaptations.video ? adaptations.video[0] : void 0, firstAudioAdaptation = adaptations.audio ? adaptations.audio[0] : void 0, firstTimeReference = void 0, lastTimeReference = void 0;
                if (firstVideoAdaptation || firstAudioAdaptation) {
                    var firstTimeReferences = [], lastTimeReferences = [];
                    if (firstVideoAdaptation) {
                        var firstVideoRepresentation = firstVideoAdaptation.representations[0];
                        if (firstVideoRepresentation) {
                            var firstVideoTimeReference = firstVideoRepresentation.index.getFirstPosition(), lastVideoTimeReference = firstVideoRepresentation.index.getLastPosition();
                            null != firstVideoTimeReference && firstTimeReferences.push(firstVideoTimeReference), 
                            null != lastVideoTimeReference && lastTimeReferences.push(lastVideoTimeReference);
                        }
                    }
                    if (firstAudioAdaptation) {
                        var firstAudioRepresentation = firstAudioAdaptation.representations[0];
                        if (firstAudioRepresentation) {
                            var firstAudioTimeReference = firstAudioRepresentation.index.getFirstPosition(), lastAudioTimeReference = firstAudioRepresentation.index.getLastPosition();
                            null != firstAudioTimeReference && firstTimeReferences.push(firstAudioTimeReference), 
                            null != lastAudioTimeReference && lastTimeReferences.push(lastAudioTimeReference);
                        }
                    }
                    firstTimeReferences.length && (firstTimeReference = Math.max.apply(Math, firstTimeReferences)), 
                    lastTimeReferences.length && (lastTimeReference = Math.max.apply(Math, lastTimeReferences));
                }
                var isLive = parseBoolean(root.getAttribute("IsLive"));
                if (isLive) {
                    suggestedPresentationDelay = SUGGESTED_PERSENTATION_DELAY, timeShiftBufferDepth = +(root.getAttribute("DVRWindowLength") || 0) / timescale, 
                    availabilityStartTime = REFERENCE_DATE_TIME, presentationLiveGap = Date.now() / 1e3 - (null != lastTimeReference ? lastTimeReference + availabilityStartTime : 10);
                    var manifestDuration = root.getAttribute("Duration");
                    duration = null != manifestDuration && 0 != +manifestDuration ? +manifestDuration / timescale : Infinity;
                } else {
                    // if non-live and first time reference different than 0. Add first time reference
                    // to duration
                    var _manifestDuration = root.getAttribute("Duration");
                    duration = null != _manifestDuration && 0 != +_manifestDuration ? null == lastTimeReference ? (+_manifestDuration + (firstTimeReference || 0)) / timescale : lastTimeReference : Infinity;
                }
                var minimumTime = null != firstTimeReference ? firstTimeReference / timescale : void 0, manifest = {
                    id: "gen-smooth-manifest-" + Object(utils_id.a)(),
                    availabilityStartTime: availabilityStartTime || 0,
                    duration: duration,
                    presentationLiveGap: presentationLiveGap,
                    suggestedPresentationDelay: suggestedPresentationDelay,
                    timeShiftBufferDepth: timeShiftBufferDepth,
                    transportType: "smooth",
                    type: isLive ? "dynamic" : "static",
                    uris: [ url ],
                    minimumTime: minimumTime,
                    periods: [ {
                        id: "gen-smooth-period-0",
                        duration: duration,
                        adaptations: adaptations,
                        start: 0
                    } ]
                };
                return checkManifestIDs(manifest), manifest;
            };
        }, request = __webpack_require__(28), strings = __webpack_require__(83), manifest_loader = __webpack_require__(82), isobmff = __webpack_require__(35), constants = __webpack_require__(25), read = __webpack_require__(55), SAMPLING_FREQUENCIES = [ 96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350 ], boxNamesMem = {};
        // EXTERNAL MODULE: ./src/utils/request/index.ts
                /**
 * Convert the string name of an ISOBMFF box into the corresponding bytes.
 * Has a memorization mechanism to speed-up if you want to translate the
 * same string multiple times.
 * @param {string} str
 * @returns {Uint8Array}
 */
        function boxName(str) {
            if (boxNamesMem[str]) return boxNamesMem[str];
            var nameInBytes = Object(bytes.p)(str);
            return boxNamesMem[str] = nameInBytes, nameInBytes;
        }
        /**
 * Create a new ISOBMFF "box" with the given name.
 * @param {string} name - name of the box you want to create, must always
 * be 4 characters (uuid boxes not supported)
 * @param {Uint8Array} buff - content of the box
 * @returns {Uint8Array} - The entire ISOBMFF box (length+name+content)
 */        function Atom(name, buff) {
            var len = buff.length + 8;
            return Object(bytes.h)(Object(bytes.l)(len), boxName(name), buff);
        }
        /**
 * @param {Uint8Array} buf
 * @param {Number} id1
 * @param {Number} id2
 * @param {Number} id3
 * @param {Number} id4
 * @returns {Uint8Array|undefined}
 */        function readUuid(buf, id1, id2, id3, id4) {
            for (var l = buf.length, i = 0, len = void 0; i < l; ) {
                if (len = Object(bytes.c)(buf, i), 1970628964 /* === "uuid" */ === Object(bytes.c)(buf, i + 4) && Object(bytes.c)(buf, i + 8) === id1 && Object(bytes.c)(buf, i + 12) === id2 && Object(bytes.c)(buf, i + 16) === id3 && Object(bytes.c)(buf, i + 20) === id4) return buf.subarray(i + 24, i + len);
                i += len;
            }
        }
        var atoms = {
            /**
     * @param {string} name
     * @param {Array.<Uint8Array>} children
     * @returns {Uint8Array}
     */
            mult: function mult(name, children) {
                return Atom(name, bytes.h.apply(null, children));
            },
            /**
     * @param {string} name - "avc1" or "encv"
     * @param {Number} drefIdx - shall be 1
     * @param {Number} width
     * @param {Number} height
     * @param {Number} hRes - horizontal resolution, eg 72
     * @param {Number} vRes - horizontal resolution, eg 72
     * @param {string} encDepth
     * @param {Number} colorDepth - eg 24
     * @param {Uint8Array} avcc - Uint8Array representing the avcC atom
     * @param {Uint8Array} [sinf] - Uint8Array representing the sinf atom,
     * only if name == "encv"
     * @returns {Uint8Array}
     */
            avc1encv: function avc1encv(name, drefIdx, width, height, hRes, vRes, encName, colorDepth, avcc, sinf) {
                return Atom(name, Object(bytes.h)(6, // 6 bytes reserved
                Object(bytes.k)(drefIdx), 16, // drefIdx + QuickTime reserved, zeroes
                Object(bytes.k)(width), // size 2 w
                Object(bytes.k)(height), // size 2 h
                Object(bytes.k)(hRes), 2, // reso 4 h
                Object(bytes.k)(vRes), 6, // reso 4 v + QuickTime reserved, zeroes
                [ 0, 1, encName.length ], // frame count (default 1)
                Object(bytes.p)(encName), // 1byte len + encoder name str
                31 - encName.length, // + padding
                Object(bytes.k)(colorDepth), // color depth
                [ 255, 255 ], // reserved ones
                avcc, // avcc atom,
                "encv" === name && sinf || []));
            },
            /**
     * @param {Uint8Array} sps
     * @param {Uint8Array} pps
     * @param {Number} nalLen - NAL Unit length: 1, 2 or 4 bytes
     * eg: avcc(0x4d, 0x40, 0x0d, 4, 0xe1, "674d400d96560c0efcb80a70505050a0",
     * 1, "68ef3880")
     * @returns {Uint8Array}
     */
            avcc: function avcc(sps, pps, nalLen) {
                var nal = 2 === nalLen ? 1 : 4 === nalLen ? 3 : 0, h264Profile = sps[1], h264CompatibleProfile = sps[2], h264Level = sps[3];
                // Deduce AVC Profile from SPS
                                return Atom("avcC", Object(bytes.h)([ 1, h264Profile, h264CompatibleProfile, h264Level, 252 | nal, 225 ], Object(bytes.k)(sps.length), sps, [ 1 ], Object(bytes.k)(pps.length), pps));
            },
            /**
     * @param {url} Uint8Array
     * @returns {Uint8Array}
     */
            dref: function dref(url) {
                // only one description here... FIXME
                return Atom("dref", Object(bytes.h)(7, [ 1 ], url));
            },
            /**
     * @param {Number} stream
     * @param {string} codecPrivateData - hex string
     * eg: esds(1, 98800, "1190")
     * @returns {Uint8Array}
     */
            esds: function esds(stream, codecPrivateData) {
                return Atom("esds", Object(bytes.h)(4, [ 3, 25 ], Object(bytes.k)(stream), [ 0, 4, 17, 64, 21 ], 11, [ 5, 2 ], Object(bytes.j)(codecPrivateData), [ 6, 1, 2 ]));
            },
            /**
     * @param {string} dataFormat - four letters (eg "avc1")
     * @returns {Uint8Array}
     */
            frma: function frma(dataFormat) {
                return Atom("frma", Object(bytes.p)(dataFormat));
            },
            /**
     * @param {Number} length
     * @returns {Uint8Array}
     */
            free: function free(length) {
                return Atom("free", new Uint8Array(length - 8));
            },
            /**
     * @param {string} majorBrand
     * @param {Array.<string>} brands
     * @returns {Uint8Array}
     */
            ftyp: function ftyp(majorBrand, brands) {
                return Atom("ftyp", bytes.h.apply(null, [ Object(bytes.p)(majorBrand), [ 0, 0, 0, 1 ] ].concat(brands.map(bytes.p))));
            },
            /**
     * @param {string} type - "video" or "audio"
     * @returns {Uint8Array}
     */
            hdlr: function hdlr(type) {
                var name = void 0, handlerName = void 0;
                switch (type) {
                  case "video":
                    name = "vide", handlerName = "VideoHandler";
                    break;

                  case "audio":
                    name = "soun", handlerName = "SoundHandler";
                    break;

                  default:
                    name = "hint", handlerName = "";
                }
                return Atom("hdlr", Object(bytes.h)(8, Object(bytes.p)(name), 12, Object(bytes.p)(handlerName), 1));
            },
            /**
     * @param {number} timescale
     * @returns {Uint8Array}
     */
            mdhd: function mdhd(timescale) {
                return Atom("mdhd", Object(bytes.h)(12, Object(bytes.l)(timescale), 8));
            },
            /**
     * @param {Uint8Array} mfhd
     * @param {Uint8Array} traf
     * @returns {Uint8Array}
     */
            moof: function moof(mfhd, traf) {
                return atoms.mult("moof", [ mfhd, traf ]);
            },
            /**
     * @param {string} name - "mp4a" or "enca"
     * @param {Number} drefIdx
     * @param {Number} channelsCount
     * @param {Number} sampleSize
     * @param {Number} packetSize
     * @param {Number} sampleRate
     * @param {Uint8Array} esds - Uint8Array representing the esds atom
     * @param {Uint8Array} [sinf] - Uint8Array representing the sinf atom,
     * only if name == "enca"
     * @returns {Uint8Array}
     */
            mp4aenca: function mp4aenca(name, drefIdx, channelsCount, sampleSize, packetSize, sampleRate, esds, sinf) {
                return Atom(name, Object(bytes.h)(6, Object(bytes.k)(drefIdx), 8, Object(bytes.k)(channelsCount), Object(bytes.k)(sampleSize), 2, Object(bytes.k)(packetSize), Object(bytes.k)(sampleRate), 2, esds, "enca" === name && sinf || []));
            },
            /**
     * @param {Number} timescale
     * @param {Number} trackId
     * @returns {Uint8Array}
     */
            mvhd: function mvhd(timescale, trackId) {
                return Atom("mvhd", Object(bytes.h)(12, Object(bytes.l)(timescale), 4, [ 0, 1 ], 2, // we assume rate = 1;
                [ 1, 0 ], 10, // we assume volume = 100%;
                [ 0, 1 ], 14, // default matrix
                [ 0, 1 ], 14, // default matrix
                [ 64, 0, 0, 0 ], 26, Object(bytes.k)(trackId + 1)));
            },
            /**
     * @param {string} systemId - Hex string representing the CDM, 16 bytes.
     * @param {Uint8Array|undefined} privateData - Data associated to protection
     * specific system.
     * @param {Array.<Uint8Array>} keyIds - List of key ids contained in the PSSH
     * @returns {Uint8Array}
     */
            pssh: function pssh(systemId) {
                var privateData = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Uint8Array(0), keyIds = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : new Uint8Array(0), _systemId = systemId.replace(/-/g, "");
                Object(assert.b)(32 === _systemId.length, "wrong system id length");
                var version = void 0, kidList = void 0, kidCount = keyIds.length;
                return kidCount > 0 ? (version = 1, kidList = bytes.h.apply(void 0, [ Object(bytes.l)(kidCount) ].concat(keyIds))) : (version = 0, 
                kidList = []), Atom("pssh", Object(bytes.h)([ version, 0, 0, 0 ], Object(bytes.j)(_systemId), kidList, Object(bytes.l)(privateData.length), privateData));
            },
            /**
     * @param {Uint8Array} mfhd
     * @param {Uint8Array} tfhd
     * @param {Uint8Array} tfdt
     * @param {Uint8Array} trun
     * @returns {Uint8Array}
     */
            saio: function saio(mfhd, tfhd, tfdt, trun) {
                return Atom("saio", Object(bytes.h)(4, [ 0, 0, 0, 1 ], // ??
                Object(bytes.l)(mfhd.length + tfhd.length + tfdt.length + trun.length + 8 + 8 + 8 + 8)));
            },
            /**
     * @param {Uint8Array} sencData - including 8 bytes flags and entries count
     * @returns {Uint8Array}
     */
            saiz: function saiz(senc) {
                if (0 === senc.length) return Atom("saiz", new Uint8Array(0));
                var flags = Object(bytes.c)(senc, 0), entries = Object(bytes.c)(senc, 4), arr = new Uint8Array(entries + 9);
                arr.set(Object(bytes.l)(entries), 5);
                for (var i = 9, j = 8, pairsCnt = void 0, pairsLen = void 0; j < senc.length; ) j += 8, 
                // assuming IV is 8 bytes TODO handle 16 bytes IV
                // if we have extradata for each entry
                2 == (2 & flags) ? (pairsLen = 2, j += 6 * (pairsCnt = Object(bytes.a)(senc, j)) + 2) : (pairsCnt = 0, 
                pairsLen = 0), arr[i] = 6 * pairsCnt + 8 + pairsLen, i++;
                return Atom("saiz", arr);
            },
            /**
     * @param {string} schemeType - four letters (eg "cenc" for Common Encryption)
     * @param {Number} schemeVersion - eg 65536
     * @returns {Uint8Array}
     */
            schm: function schm(schemeType, schemeVersion) {
                return Atom("schm", Object(bytes.h)(4, Object(bytes.p)(schemeType), Object(bytes.l)(schemeVersion)));
            },
            /**
     * @param {Uint8Array} buf
     * @returns {Uint8Array}
     */
            senc: function senc(buf) {
                return Atom("senc", buf);
            },
            /**
     * @returns {Uint8Array}
     */
            smhd: function smhd() {
                return Atom("smhd", new Uint8Array(8));
            },
            /**
     * @param {Array.<Uint8Array>} representations - arrays of Uint8Array,
     * typically [avc1] or [encv, avc1]
     * @returns {Uint8Array}
     */
            stsd: function stsd(reps) {
                // only one description here... FIXME
                var arrBase = [ 7, [ reps.length ] ];
                return Atom("stsd", bytes.h.apply(void 0, arrBase.concat(reps)));
            },
            /**
     * @param {Number} width
     * @param {Number} height
     * @param {Number} trackId
     * @returns {Uint8Array}
     */
            tkhd: function tkhd(width, height, trackId) {
                return Atom("tkhd", Object(bytes.h)(Object(bytes.l)(7), 8, // we assume track is enabled,
                // in media and in preview.
                Object(bytes.l)(trackId), 20, // we assume trackId = 1;
                [ 1, 0, 0, 0 ], // we assume volume = 100%;
                [ 0, 1, 0, 0 ], 12, // default matrix
                [ 0, 1, 0, 0 ], 12, // default matrix
                [ 64, 0, 0, 0 ], // ??
                Object(bytes.k)(width), 2, // width (TODO handle fixed)
                Object(bytes.k)(height), 2));
            },
            /**
     * @param {Number} trackId
     * @returns {Uint8Array}
     */
            trex: function trex(trackId) {
                // default sample desc idx = 1
                return Atom("trex", Object(bytes.h)(4, Object(bytes.l)(trackId), [ 0, 0, 0, 1 ], 12));
            },
            /**
     * @param {Number} decodeTime
     * @returns {Uint8Array}
     */
            tfdt: function tfdt(decodeTime) {
                return Atom("tfdt", Object(bytes.h)([ 1, 0, 0, 0 ], Object(bytes.m)(decodeTime)));
            },
            /**
     * @param {Number} algId - eg 1
     * @param {Number} ivSize - eg 8
     * @param {string} keyId - Hex KID 93789920e8d6520098577df8f2dd5546
     * @returns {Uint8Array}
     */
            tenc: function tenc(algId, ivSize, keyId) {
                return Atom("tenc", Object(bytes.h)(6, [ algId, ivSize ], Object(bytes.j)(keyId)));
            },
            /**
     * @param {Uint8Array} tfhd
     * @param {Uint8Array} tfdt
     * @param {Uint8Array} trun
     * @param {Uint8Array} senc
     * @param {Uint8Array} mfhd
     * @returns {Uint8Array}
     */
            traf: function traf(tfhd, tfdt, trun, mfhd, senc) {
                var trafs = [ tfhd, tfdt, trun ];
                return senc && trafs.push(atoms.senc(senc), atoms.saiz(senc), atoms.saio(mfhd, tfhd, tfdt, trun)), 
                atoms.mult("traf", trafs);
            },
            /**
     * @param {Uint8Array} oldtrun
     * @returns {Uint8Array}
     */
            trun: function trun(oldtrun) {
                if (1 & oldtrun[11]) return oldtrun;
                // If no dataoffset is present, we change the headers and add one
                                var trun = new Uint8Array(oldtrun.length + 4);
                return trun.set(Object(bytes.l)(oldtrun.length + 4), 0), trun.set(oldtrun.subarray(4, 16), 4), 
                // name + (version + headers) +
                // samplecount
                trun[11] = 1 | trun[11], // add data offset header info
                trun.set([ 0, 0, 0, 0 ], 16), // data offset
                trun.set(oldtrun.subarray(16, oldtrun.length), 20), trun;
            },
            /**
     * @returns {Uint8Array}
     */
            vmhd: function vmhd() {
                var arr = new Uint8Array(12);
                // QuickTime...
                return arr[3] = 1, Atom("vmhd", arr);
            }
        }, reads_senc = function senc(traf) {
            return readUuid(traf, 2721664850, 1520127764, 2722393154, 2086964724);
        }, reads_tfxd = function tfxd(traf) {
            return readUuid(traf, 1830656773, 1121273062, 2162299933, 2952222642);
        }, reads_tfrf = function tfrf(traf) {
            return readUuid(traf, 3565190898, 3392751253, 2387879627, 2655430559);
        };
        /**
 * Return AAC ES Header (hexstr form)
 *
 * @param {Number} type
 *          1 = AAC Main
 *          2 = AAC LC
 *          cf http://wiki.multimedia.cx/index.php?title=MPEG-4_Audio
 * @param {Number} frequency
 * @param {Number} chans (1 or 2)
 * @returns {string}
 */
        function aacesHeader(type, frequency, chans) {
            var val = void 0;
            return val = ((val = ((val = (63 & type) << 4) | 31 & SAMPLING_FREQUENCIES.indexOf(frequency)) << 4) | 31 & chans) << 3, 
            Object(bytes.e)(Object(bytes.k)(val));
        }
        /**
 * @param {Uint8Array} mvhd
 * @param {Uint8Array} mvex
 * @param {Uint8Array} trak
 * @param {Object} pssList
 * @returns {Array.<Uint8Array>}
 */        function moovChildren(mvhd, mvex, trak, pssList) {
            var moov = [ mvhd, mvex, trak ];
            return pssList.forEach(function(pss) {
                var pssh = atoms.pssh(pss.systemId, pss.privateData, pss.keyIds);
                moov.push(pssh);
            }), moov;
        }
        /**
 * /!\ Mutates given segment
 * @param {Uint8Array} segment
 * @param {Number} trunoffset
 * @param {Number} dataoffset
 */        function patchTrunDataOffset(segment, trunoffset, dataOffset) {
            // patch trun dataoffset with new moof atom size
            segment.set(Object(bytes.l)(dataOffset), trunoffset + 16);
        }
        /**
 * @param {Uint8Array} segment
 * @param {Uint8Array} newmoof
 * @param {Uint8Array} oldmoof
 * @param {Number} trunoffset
 * @returns {Uint8Array}
 */        function createNewSegment(segment, newmoof, oldmoof, trunoffset) {
            var segmentlen = segment.length, newmooflen = newmoof.length, oldmooflen = oldmoof.length, mdat = segment.subarray(oldmooflen, segmentlen), newSegment = new Uint8Array(newmooflen + (segmentlen - oldmooflen));
            return newSegment.set(newmoof, 0), newSegment.set(mdat, newmooflen), patchTrunDataOffset(newSegment, trunoffset, newmoof.length + 8), 
            newSegment;
        }
        /**
 * /!\ Mutates given segment
 * @param {Uint8Array} segment
 * @param {Uint8Array} newmoof
 * @param {Uint8Array} oldmoof
 * @param {Number} trunoffset
 * @returns {Uint8Array}
 */        function patchSegmentInPlace(segment, newmoof, oldmoof, trunoffset) {
            var free = oldmoof.length - newmoof.length;
            return segment.set(newmoof, 0), segment.set(atoms.free(free), newmoof.length), patchTrunDataOffset(segment, trunoffset, newmoof.length + 8 + free), 
            segment;
        }
        /**
 * @param {Number} timescale
 * @param {string} type
 * @param {Uint8Array} stsd
 * @param {Uint8Array} mhd
 * @param {Number} width
 * @param {Number} height
 * @param {Array.<Object>} pssList - List of dict, example:
 * {systemId: "DEADBEEF", codecPrivateData: "DEAFBEEF}
 * @returns {Uint8Array}
 */        function createInitSegment(timescale, type, stsd, mhd, width, height, pssList) {
            var stbl = atoms.mult("stbl", [ stsd, Atom("stts", new Uint8Array(8)), Atom("stsc", new Uint8Array(8)), Atom("stsz", new Uint8Array(12)), Atom("stco", new Uint8Array(8)) ]), url = Atom("url ", new Uint8Array([ 0, 0, 0, 1 ])), dref = atoms.dref(url), dinf = atoms.mult("dinf", [ dref ]), minf = atoms.mult("minf", [ mhd, dinf, stbl ]), hdlr = atoms.hdlr(type), mdhd = atoms.mdhd(timescale), mdia = atoms.mult("mdia", [ mdhd, hdlr, minf ]), tkhd = atoms.tkhd(width, height, 1), trak = atoms.mult("trak", [ tkhd, mdia ]), trex = atoms.trex(1), mvex = atoms.mult("mvex", [ trex ]), mvhd = atoms.mvhd(timescale, 1), moov = atoms.mult("moov", moovChildren(mvhd, mvex, trak, pssList)), ftyp = atoms.ftyp("isom", [ "isom", "iso2", "iso6", "avc1", "dash" ]);
            return Object(bytes.h)(ftyp, moov);
        }
        // TODO
        /* harmony default export */        var mp4 = {
            getMdat: read.a,
            getTraf: read.c,
            /**
     * @param {Uint8Array} traf
     * @returns {Array.<Object>}
     */
            parseTfrf: function parseTfrf(traf) {
                var tfrf = reads_tfrf(traf);
                if (!tfrf) return [];
                for (var frags = [], version = tfrf[0], fragCount = tfrf[4], i = 0; i < fragCount; i++) {
                    var duration = void 0, time = void 0;
                    1 === version ? (time = Object(bytes.d)(tfrf, 16 * i + 5), duration = Object(bytes.d)(tfrf, 16 * i + 5 + 8)) : (time = Object(bytes.c)(tfrf, 8 * i + 5), 
                    duration = Object(bytes.c)(tfrf, 8 * i + 5 + 4)), frags.push({
                        time: time,
                        duration: duration
                    });
                }
                return frags;
            },
            /**
     * @param {Uint8Array} traf
     * @returns {Object|undefined}
     */
            parseTfxd: function parseTfxd(traf) {
                var tfxd = reads_tfxd(traf);
                if (tfxd) return {
                    duration: Object(bytes.d)(tfxd, 12),
                    time: Object(bytes.d)(tfxd, 4)
                };
            },
            /**
     * Return full video Init segment as Uint8Array
     * @param {Number} timescale - lowest number, this one will be set into mdhd
     * *10000 in mvhd, e.g. 1000
     * @param {Number} width
     * @param {Number} height
     * @param {Number} hRes
     * @param {Number} vRes
     * @param {Number} nalLength (1, 2 or 4)
     * @param {string} codecPrivateData
     * @param {string} keyId - hex string representing the key Id,
     * 32 chars. eg. a800dbed49c12c4cb8e0b25643844b9b
     * @param {Array.<Object>} [pssList] - List of dict, example:
     * {systemId: "DEADBEEF", codecPrivateData: "DEAFBEEF}
     * @returns {Uint8Array}
     */
            createVideoInitSegment: function createVideoInitSegment(timescale, width, height, hRes, vRes, nalLength, codecPrivateData, keyId, pssList) {
                var _pssList = pssList || [], _codecPrivateData$spl = codecPrivateData.split("00000001"), spsHex = _codecPrivateData$spl[1], ppsHex = _codecPrivateData$spl[2], sps = Object(bytes.j)(spsHex), pps = Object(bytes.j)(ppsHex), avcc = atoms.avcc(sps, pps, nalLength), stsd = void 0;
                if (_pssList.length && null != keyId) {
                    var tenc = atoms.tenc(1, 8, keyId), schi = atoms.mult("schi", [ tenc ]), schm = atoms.schm("cenc", 65536), frma = atoms.frma("avc1"), sinf = atoms.mult("sinf", [ frma, schm, schi ]), encv = atoms.avc1encv("encv", 1, width, height, hRes, vRes, "AVC Coding", 24, avcc, sinf);
                    stsd = atoms.stsd([ encv ]);
                } else {
                    var avc1 = atoms.avc1encv("avc1", // name
                    1, // drefIdx
                    width, height, hRes, vRes, "AVC Coding", // encName
                    24, // color depth
                    avcc);
                    stsd = atoms.stsd([ avc1 ]);
                }
                return createInitSegment(timescale, "video", stsd, atoms.vmhd(), width, height, _pssList);
            },
            /**
     * Return full audio Init segment as Uint8Array
     * @param {Number} timescale
     * @param {Number} channelsCount
     * @param {Number} sampleSize
     * @param {Number} packetSize
     * @param {Number} sampleRate
     * @param {string} codecPrivateData
     * @param {string} keyId - hex string representing the key Id, 32 chars.
     * eg. a800dbed49c12c4cb8e0b25643844b9b
     * @param {Array.<Object>} [pssList] - List of dict, example:
     * {systemId: "DEADBEEF", codecPrivateData: "DEAFBEEF"}
     * @returns {Uint8Array}
     */
            createAudioInitSegment: function createAudioInitSegment(timescale, channelsCount, sampleSize, packetSize, sampleRate, codecPrivateData, keyId, pssList) {
                var _pssList = pssList || [], _codecPrivateData = codecPrivateData || aacesHeader(2, sampleRate, channelsCount), esds = atoms.esds(1, _codecPrivateData), stsd = void 0;
                if (_pssList.length && null != keyId) {
                    var tenc = atoms.tenc(1, 8, keyId), schi = atoms.mult("schi", [ tenc ]), schm = atoms.schm("cenc", 65536), frma = atoms.frma("mp4a"), sinf = atoms.mult("sinf", [ frma, schm, schi ]), enca = atoms.mp4aenca("enca", 1, channelsCount, sampleSize, packetSize, sampleRate, esds, sinf);
                    stsd = atoms.stsd([ enca ]);
                } else {
                    var mp4a = atoms.mp4aenca("mp4a", 1, channelsCount, sampleSize, packetSize, sampleRate, esds);
                    stsd = atoms.stsd([ mp4a ]);
                }
                return createInitSegment(timescale, "audio", stsd, atoms.smhd(), 0, 0, _pssList);
            },
            /**
     * Add decodeTime info in a segment (tfdt box)
     * @param {Uint8Array} segment
     * @param {Number} decodeTime
     * @return {Uint8Array}
     */
            patchSegment: function patchSegment(segment, decodeTime) {
                var oldmoof = segment.subarray(0, Object(bytes.c)(segment, 0)), newtfdt = atoms.tfdt(decodeTime), tfdtlen = newtfdt.length, mfhdlen = Object(bytes.c)(oldmoof, 8), traflen = Object(bytes.c)(oldmoof, mfhdlen + 8), tfhdlen = Object(bytes.c)(oldmoof, mfhdlen + 8 + 8), trunlen = Object(bytes.c)(oldmoof, mfhdlen + 8 + 8 + tfhdlen), oldmfhd = oldmoof.subarray(8, mfhdlen + 8), oldtraf = oldmoof.subarray(mfhdlen + 8 + 8, mfhdlen + 8 + 8 + traflen - 8), oldtfhd = oldtraf.subarray(0, tfhdlen), oldtrun = oldtraf.subarray(tfhdlen, tfhdlen + trunlen);
                // force trackId=1 since trackIds are not always reliable...
                oldtfhd.set([ 0, 0, 0, 1 ], 12);
                // TODO fallback?
                var oldsenc = reads_senc(oldtraf), newtrun = atoms.trun(oldtrun), newtraf = atoms.traf(oldtfhd, newtfdt, newtrun, oldmfhd, oldsenc), newmoof = atoms.moof(oldmfhd, newtraf), trunoffset = mfhdlen + 8 + 8 + tfhdlen + tfdtlen;
                // writes [moof[mfhd|traf[tfhd|tfdt|trun|senc|saiz|saio]]]
                                // TODO(pierre): fix patchSegmentInPlace to work with IE11. Maybe
                // try to put free atom inside traf children
                return constants.h ? createNewSegment(segment, newmoof, oldmoof, trunoffset) : oldmoof.length - newmoof.length >= 8 /* minimum "free" atom size */ ? patchSegmentInPlace(segment, newmoof, oldmoof, trunoffset) : createNewSegment(segment, newmoof, oldmoof, trunoffset);
            }
        }, getTraf = mp4.getTraf, isobmff_timings_infos_parseTfrf = mp4.parseTfrf, isobmff_timings_infos_parseTfxd = mp4.parseTfxd;
        // CONCATENATED MODULE: ./src/net/smooth/isobmff_timings_infos.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        
        /* harmony default export */ var isobmff_timings_infos = function extractTimingsInfos(responseData, segment, isLive) {
            var nextSegments = [], segmentInfos = void 0, tfxdSegment = void 0, tfrfSegments = void 0;
            if (isLive) {
                var traf = getTraf(responseData);
                traf ? (tfrfSegments = isobmff_timings_infos_parseTfrf(traf), tfxdSegment = isobmff_timings_infos_parseTfxd(traf)) : log.a.warn("smooth: could not find traf atom");
            }
            if (tfxdSegment) segmentInfos = {
                time: tfxdSegment.time,
                duration: tfxdSegment.duration,
                timescale: segment.timescale
            }; else {
                // we could always make a mistake when reading a container.
                // If the estimate is too far from what the segment seems to imply, take
                // the segment infos instead.
                var maxDecodeTimeDelta = Math.min(.9 * segment.timescale, null != segment.duration ? segment.duration / 4 : .25), trunDuration = Object(isobmff.a)(responseData);
                segmentInfos = trunDuration >= 0 && (null == segment.duration || Math.abs(trunDuration - segment.duration) <= maxDecodeTimeDelta) ? {
                    time: segment.time,
                    duration: trunDuration,
                    timescale: segment.timescale
                } : {
                    time: segment.time,
                    duration: segment.duration,
                    timescale: segment.timescale
                };
            }
            if (tfrfSegments) for (var i = 0; i < tfrfSegments.length; i++) nextSegments.push({
                time: tfrfSegments[i].time,
                duration: tfrfSegments[i].duration,
                timescale: segment.timescale
            });
            return {
                nextSegments: nextSegments,
                segmentInfos: segmentInfos
            };
        }, Observable = __webpack_require__(6), ISM_REG = /\.(isml?)(\?token=\S+)?$/, TOKEN_REG = /\?token=(\S+)/;
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Observable.js + 2 modules
                function byteRange(_ref) {
            var start = _ref[0], end = _ref[1];
            return end && Infinity !== end ? "bytes=" + +start + "-" + +end : "bytes=" + +start + "-";
        }
        /**
 * TODO Remove this logic completely from the player
 * @returns {string|null}
 */        function extractISML(doc) {
            return doc.getElementsByTagName("media")[0].getAttribute("src");
        }
        /**
 * Returns string corresponding to the token contained in the url's querystring.
 * Empty string if no token is found.
 * @param {string} url
 * @returns {string}
 */        function extractToken(url) {
            var tokenMatch = url.match(TOKEN_REG);
            return tokenMatch && tokenMatch[1] || "";
        }
        /**
 * Replace/Remove token from the url's querystring
 * @param {string} url
 * @param {string} [token]
 * @returns {string}
 */        function replaceToken(url, token) {
            return token ? url.replace(TOKEN_REG, "?token=" + token) : url.replace(TOKEN_REG, "");
        }
        /**
 * @param {string} url
 * @returns {string}
 */        function resolveManifest(url) {
            var ismMatch = url.match(ISM_REG);
            return ismMatch ? url.replace(ismMatch[1], ismMatch[1] + "/manifest") : url;
        }
        // CONCATENATED MODULE: ./src/net/smooth/segment_loader.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        var segment_loader_createVideoInitSegment = mp4.createVideoInitSegment, createAudioInitSegment = mp4.createAudioInitSegment;
        /**
 * Segment loader triggered if there was no custom-defined one in the API.
 * @param {Object} opt
 * @returns {Observable}
 */        function regularSegmentLoader(_ref) {
            var url = _ref.url, headers = void 0, range = _ref.segment.range;
            return range && (headers = {
                Range: byteRange(range)
            }), Object(request.a)({
                url: url,
                responseType: "arraybuffer",
                headers: headers
            });
        }
        /**
 * Defines the url for the request, load the right loader (custom/default
 * one).
 */        var segment_loader = function generateSegmentLoader(customSegmentLoader) {
            return function(_ref2) {
                var segment = _ref2.segment, representation = _ref2.representation, adaptation = _ref2.adaptation, period = _ref2.period, manifest = _ref2.manifest, init = _ref2.init;
                if (segment.isInit) {
                    if (!segment.privateInfos || null == segment.privateInfos.smoothInit) throw new Error("Smooth: Invalid segment format");
                    var smoothInitPrivateInfos = segment.privateInfos.smoothInit, responseData = void 0, protection = smoothInitPrivateInfos.protection;
                    switch (adaptation.type) {
                      case "video":
                        responseData = segment_loader_createVideoInitSegment(segment.timescale, representation.width || 0, representation.height || 0, 72, 72, 4, // vRes, hRes, nal
                        smoothInitPrivateInfos.codecPrivateData || "", protection && protection.keyId, // keyId
                        protection && protection.keySystems);
                        break;

                      case "audio":
                        responseData = createAudioInitSegment(segment.timescale, smoothInitPrivateInfos.channels || 0, smoothInitPrivateInfos.bitsPerSample || 0, smoothInitPrivateInfos.packetSize || 0, smoothInitPrivateInfos.samplingRate || 0, smoothInitPrivateInfos.codecPrivateData || "", protection && protection.keyId, // keyId
                        protection && protection.keySystems);
                        break;

                      default:
                        responseData = new Uint8Array(0);
                    }
                    return Object(of.a)({
                        type: "data",
                        value: {
                            responseData: responseData
                        }
                    });
                }
                if (null == segment.mediaURL) return Object(of.a)({
                    type: "data",
                    value: {
                        responseData: null
                    }
                });
                var args = {
                    adaptation: adaptation,
                    init: init,
                    manifest: manifest,
                    period: period,
                    representation: representation,
                    segment: segment,
                    transport: "smooth",
                    url: segment.mediaURL
                };
                return customSegmentLoader ? Observable.a.create(function(obs) {
                    var hasFinished = !1, hasFallbacked = !1, abort = customSegmentLoader(args, {
                        reject: function reject() {
                            var err = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                            hasFallbacked || (hasFinished = !0, obs.error(err));
                        },
                        resolve: function resolve(_args) {
                            hasFallbacked || (hasFinished = !0, obs.next({
                                type: "response",
                                value: {
                                    responseData: _args.data,
                                    size: _args.size,
                                    duration: _args.duration
                                }
                            }), obs.complete());
                        },
                        fallback: function fallback() {
                            hasFallbacked = !0, regularSegmentLoader(args).subscribe(obs);
                        }
                    });
                    return function() {
                        hasFinished || hasFallbacked || "function" != typeof abort || abort();
                    };
                }) : regularSegmentLoader(args);
            };
        }, smooth_patchSegment = mp4.patchSegment, getMdat = mp4.getMdat, WSX_REG = /\.wsx?(\?token=\S+)?/;
        /* harmony default export */        
        /**
 * @param {Object} adaptation
 * @param {Object} dlSegment
 * @param {Object} nextSegments
 */
        function addNextSegments(adaptation, nextSegments, dlSegment) {
            for (var representations = adaptation.representations, i = 0; i < representations.length; i++) {
                representations[i].index._addSegments(nextSegments, dlSegment);
            }
        }
        /* harmony default export */        __webpack_exports__.default = function() {
            var options = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, smoothManifestParser = smooth(options), segmentLoader = segment_loader(options.segmentLoader), manifestLoaderOptions = {
                customManifestLoader: options.manifestLoader,
                ignoreProgressEvents: !0
            }, manifestLoader = Object(manifest_loader.a)(manifestLoaderOptions), segmentPipeline = {
                loader: function loader(_ref5) {
                    var adaptation = _ref5.adaptation, init = _ref5.init, manifest = _ref5.manifest, period = _ref5.period, representation = _ref5.representation, segment = _ref5.segment;
                    return segmentLoader({
                        adaptation: adaptation,
                        init: init,
                        manifest: manifest,
                        period: period,
                        representation: representation,
                        segment: segment
                    });
                },
                parser: function parser(_ref6) {
                    var segment = _ref6.segment, response = _ref6.response, adaptation = _ref6.adaptation, manifest = _ref6.manifest, responseData = response.responseData;
                    if (null == responseData) return Object(of.a)({
                        segmentData: null,
                        segmentInfos: null,
                        segmentOffset: 0
                    });
                    if (segment.isInit) {
                        // smooth init segments are crafted by hand. Their timescale is the one
                        // from the manifest.
                        var initSegmentInfos = {
                            timescale: segment.timescale,
                            time: -1,
                            duration: 0
                        };
                        return Object(of.a)({
                            segmentData: responseData,
                            segmentInfos: initSegmentInfos,
                            segmentOffset: 0
                        });
                    }
                    var responseBuffer = responseData instanceof Uint8Array ? responseData : new Uint8Array(responseData), _extractTimingsInfos = isobmff_timings_infos(responseBuffer, segment, manifest.isLive), nextSegments = _extractTimingsInfos.nextSegments, segmentInfos = _extractTimingsInfos.segmentInfos, segmentData = smooth_patchSegment(responseBuffer, segmentInfos.time);
                    return nextSegments && addNextSegments(adaptation, nextSegments, segmentInfos), 
                    Object(of.a)({
                        segmentData: segmentData,
                        segmentInfos: segmentInfos,
                        segmentOffset: 0
                    });
                }
            };
            return {
                manifest: {
                    resolver: function resolver(_ref) {
                        var url = _ref.url, token = extractToken(url);
                        // TODO Remove WSX logic
                        return (WSX_REG.test(url) ? Object(request.a)({
                            url: replaceToken(url, ""),
                            responseType: "document",
                            ignoreProgressEvents: !0
                        }).pipe(Object(map.a)(function(_ref2) {
                            var extractedURL = extractISML(_ref2.value.responseData);
                            if (!extractedURL) throw new Error("Invalid ISML");
                            return extractedURL;
                        })) : Object(of.a)(url)).pipe(Object(map.a)(function(_url) {
                            return {
                                url: replaceToken(resolveManifest(_url), token)
                            };
                        }));
                    },
                    loader: function loader(_ref3) {
                        var url = _ref3.url;
                        return manifestLoader(url);
                    },
                    parser: function parser(_ref4) {
                        var response = _ref4.response, reqURL = _ref4.url, url = null == response.url ? reqURL : response.url, data = "string" == typeof response.responseData ? new DOMParser().parseFromString(response.responseData, "text/xml") : response.responseData, manifest = smoothManifestParser(data, url);
                        return Object(of.a)({
                            manifest: manifest,
                            url: url
                        });
                    }
                },
                audio: segmentPipeline,
                video: segmentPipeline,
                text: {
                    loader: function loader(_ref7) {
                        var segment = _ref7.segment, representation = _ref7.representation;
                        if (segment.isInit || null == segment.mediaURL) return Object(of.a)({
                            type: "data",
                            value: {
                                responseData: null
                            }
                        });
                        var responseType = isMP4EmbeddedTrack(representation) ? "arraybuffer" : "text";
                        return Object(request.a)({
                            url: segment.mediaURL,
                            responseType: responseType
                        });
                    },
                    parser: function parser(_ref8) {
                        var response = _ref8.response, segment = _ref8.segment, representation = _ref8.representation, adaptation = _ref8.adaptation, manifest = _ref8.manifest, language = adaptation.language, _representation$mimeT = representation.mimeType, mimeType = void 0 === _representation$mimeT ? "" : _representation$mimeT, _representation$codec = representation.codec, codec = void 0 === _representation$codec ? "" : _representation$codec;
                        var responseData = response.responseData;
                        if (null === responseData) return Object(of.a)({
                            segmentData: null,
                            segmentInfos: segment.timescale > 0 ? {
                                duration: segment.isInit ? 0 : segment.duration,
                                time: segment.isInit ? -1 : segment.time,
                                timescale: segment.timescale
                            } : null,
                            segmentOffset: 0
                        });
                        var parsedResponse = void 0, nextSegments = void 0, segmentInfos = null, isMP4 = mimeType.indexOf("mp4") >= 0, _sdStart = void 0, _sdEnd = void 0, _sdTimescale = void 0, _sdData = void 0, _sdType = void 0;
                        if (isMP4) {
                            0, parsedResponse = new Uint8Array(responseData);
                            var timings = isobmff_timings_infos(parsedResponse, segment, manifest.isLive);
                            nextSegments = timings.nextSegments, _sdStart = (segmentInfos = timings.segmentInfos).time, 
                            _sdEnd = null != segmentInfos.duration ? segmentInfos.time + segmentInfos.duration : void 0, 
                            _sdTimescale = segmentInfos.timescale;
                        } else {
                            0, parsedResponse = responseData;
                            var segmentTime = segment.time || 0;
                            // vod is simple WebVTT or TTML text
                                                        _sdStart = segmentTime, _sdEnd = null != segment.duration ? segmentTime + segment.duration : void 0, 
                            _sdTimescale = segment.timescale;
                        }
                        if (isMP4) {
                            var lcCodec = codec.toLowerCase();
                            if ("application/ttml+xml+mp4" === mimeType || "stpp" === lcCodec) _sdType = "ttml"; else {
                                if ("wvtt" !== lcCodec) throw new Error("could not find a text-track parser for the type " + mimeType);
                                _sdType = "vtt";
                            }
                            var mdat = getMdat(parsedResponse);
                            _sdData = Object(strings.a)(mdat);
                        } else {
                            switch (mimeType) {
                              case "application/x-sami":
                              case "application/smil":
                                // TODO SMIL should be its own format, no?
                                _sdType = "sami";
                                break;

                              case "application/ttml+xml":
                                _sdType = "ttml";
                                break;

                              case "text/vtt":
                                _sdType = "vtt";
                            }
                            if (!_sdType) {
                                if ("srt" !== codec.toLowerCase()) throw new Error("could not find a text-track parser for the type " + mimeType);
                                _sdType = "srt";
                            }
                            _sdData = responseData;
                        }
                        return null != segmentInfos && nextSegments && addNextSegments(adaptation, nextSegments, segmentInfos), 
                        Object(of.a)({
                            segmentData: {
                                type: _sdType,
                                data: _sdData,
                                language: language,
                                timescale: _sdTimescale,
                                start: _sdStart,
                                end: _sdEnd
                            },
                            segmentInfos: segmentInfos,
                            segmentOffset: _sdStart / _sdTimescale
                        });
                    }
                },
                image: {
                    loader: function loader(_ref9) {
                        var segment = _ref9.segment;
                        return segment.isInit || null == segment.mediaURL ? Object(of.a)({
                            type: "data",
                            value: {
                                responseData: null
                            }
                        }) : Object(request.a)({
                            url: segment.mediaURL,
                            responseType: "arraybuffer"
                        });
                    },
                    parser: function parser(_ref10) {
                        var response = _ref10.response, segment = _ref10.segment, responseData = response.responseData;
                        // TODO image Parsing should be more on the sourceBuffer side, no?
                        if (null === responseData || null == features.a.imageParser) return Object(of.a)({
                            segmentData: null,
                            segmentInfos: segment.timescale > 0 ? {
                                duration: segment.isInit ? 0 : segment.duration,
                                time: segment.isInit ? -1 : segment.time,
                                timescale: segment.timescale
                            } : null,
                            segmentOffset: 0
                        });
                        var bifObject = features.a.imageParser(new Uint8Array(responseData)), data = bifObject.thumbs;
                        return Object(of.a)({
                            segmentData: {
                                data: data,
                                start: 0,
                                end: Number.MAX_VALUE,
                                timescale: 1,
                                type: "bif"
                            },
                            segmentInfos: {
                                time: 0,
                                duration: Number.MAX_VALUE,
                                timescale: bifObject.timescale
                            },
                            segmentOffset: 0
                        });
                    }
                }
            };
        };
        /**
 * Returns true if the given texttrack segment represents a textrack embedded
 * in a mp4 file.
 * @param {Representation} representation
 * @returns {Boolean}
 */        function isMP4EmbeddedTrack(representation) {
            return !!representation.mimeType && representation.mimeType.indexOf("mp4") >= 0;
        }
        /***/    }, 
    /* 126 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js
                var tslib_es6 = __webpack_require__(2), Subject = __webpack_require__(36), QueueAction_QueueAction = /* */ function(_super) {
            function QueueAction(scheduler, work) {
                var _this = _super.call(this, scheduler, work) || this;
                return _this.scheduler = scheduler, _this.work = work, _this;
            }
            return tslib_es6.a(QueueAction, _super), QueueAction.prototype.schedule = function(state, delay) {
                return void 0 === delay && (delay = 0), delay > 0 ? _super.prototype.schedule.call(this, state, delay) : (this.delay = delay, 
                this.state = state, this.scheduler.flush(this), this);
            }, QueueAction.prototype.execute = function(state, delay) {
                return delay > 0 || this.closed ? _super.prototype.execute.call(this, state, delay) : this._execute(state, delay);
            }, QueueAction.prototype.requestAsyncId = function(scheduler, id, delay) {
                return void 0 === delay && (delay = 0), null !== delay && delay > 0 || null === delay && this.delay > 0 ? _super.prototype.requestAsyncId.call(this, scheduler, id, delay) : scheduler.flush(this);
            }, QueueAction;
        }(__webpack_require__(100).a), queue = /* */ new (/* */ function(_super) {
            function QueueScheduler() {
                return null !== _super && _super.apply(this, arguments) || this;
            }
            return tslib_es6.a(QueueScheduler, _super), QueueScheduler;
        }(__webpack_require__(101).a))(QueueAction_QueueAction), Subscription = __webpack_require__(16), Subscriber = __webpack_require__(10), empty = __webpack_require__(26), of = __webpack_require__(75), throwError = __webpack_require__(78), Notification_Notification = /* */ function() {
            function Notification(kind, value, error) {
                this.kind = kind, this.value = value, this.error = error, this.hasValue = "N" === kind;
            }
            return Notification.prototype.observe = function(observer) {
                switch (this.kind) {
                  case "N":
                    return observer.next && observer.next(this.value);

                  case "E":
                    return observer.error && observer.error(this.error);

                  case "C":
                    return observer.complete && observer.complete();
                }
            }, Notification.prototype.do = function(next, error, complete) {
                switch (this.kind) {
                  case "N":
                    return next && next(this.value);

                  case "E":
                    return error && error(this.error);

                  case "C":
                    return complete && complete();
                }
            }, Notification.prototype.accept = function(nextOrObserver, error, complete) {
                return nextOrObserver && "function" == typeof nextOrObserver.next ? this.observe(nextOrObserver) : this.do(nextOrObserver, error, complete);
            }, Notification.prototype.toObservable = function() {
                switch (this.kind) {
                  case "N":
                    return Object(of.a)(this.value);

                  case "E":
                    return Object(throwError.a)(this.error);

                  case "C":
                    return Object(empty.b)();
                }
                throw new Error("unexpected notification kind value");
            }, Notification.createNext = function(value) {
                return void 0 !== value ? new Notification("N", value) : Notification.undefinedValueNotification;
            }, Notification.createError = function(err) {
                return new Notification("E", void 0, err);
            }, Notification.createComplete = function() {
                return Notification.completeNotification;
            }, Notification.completeNotification = new Notification("C"), Notification.undefinedValueNotification = new Notification("N", void 0), 
            Notification;
        }();
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subject.js
                var observeOn_ObserveOnSubscriber = /* */ function(_super) {
            function ObserveOnSubscriber(destination, scheduler, delay) {
                void 0 === delay && (delay = 0);
                var _this = _super.call(this, destination) || this;
                return _this.scheduler = scheduler, _this.delay = delay, _this;
            }
            return tslib_es6.a(ObserveOnSubscriber, _super), ObserveOnSubscriber.dispatch = function(arg) {
                var notification = arg.notification, destination = arg.destination;
                notification.observe(destination), this.unsubscribe();
            }, ObserveOnSubscriber.prototype.scheduleMessage = function(notification) {
                this.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));
            }, ObserveOnSubscriber.prototype._next = function(value) {
                this.scheduleMessage(Notification_Notification.createNext(value));
            }, ObserveOnSubscriber.prototype._error = function(err) {
                this.scheduleMessage(Notification_Notification.createError(err));
            }, ObserveOnSubscriber.prototype._complete = function() {
                this.scheduleMessage(Notification_Notification.createComplete());
            }, ObserveOnSubscriber;
        }(Subscriber.a), ObserveOnMessage = /* */ function() {
            return function ObserveOnMessage(notification, destination) {
                this.notification = notification, this.destination = destination;
            };
        }(), ObjectUnsubscribedError = __webpack_require__(46), SubjectSubscription = __webpack_require__(77);
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/ReplaySubject.js
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return ReplaySubject_ReplaySubject;
        });
        /** PURE_IMPORTS_START tslib,_Subject,_scheduler_queue,_Subscription,_operators_observeOn,_util_ObjectUnsubscribedError,_SubjectSubscription PURE_IMPORTS_END */
        var ReplaySubject_ReplaySubject = /* */ function(_super) {
            function ReplaySubject(bufferSize, windowTime, scheduler) {
                void 0 === bufferSize && (bufferSize = Number.POSITIVE_INFINITY), void 0 === windowTime && (windowTime = Number.POSITIVE_INFINITY);
                var _this = _super.call(this) || this;
                return _this.scheduler = scheduler, _this._events = [], _this._infiniteTimeWindow = !1, 
                _this._bufferSize = bufferSize < 1 ? 1 : bufferSize, _this._windowTime = windowTime < 1 ? 1 : windowTime, 
                windowTime === Number.POSITIVE_INFINITY ? (_this._infiniteTimeWindow = !0, _this.next = _this.nextInfiniteTimeWindow) : _this.next = _this.nextTimeWindow, 
                _this;
            }
            return tslib_es6.a(ReplaySubject, _super), ReplaySubject.prototype.nextInfiniteTimeWindow = function(value) {
                var _events = this._events;
                _events.push(value), _events.length > this._bufferSize && _events.shift(), _super.prototype.next.call(this, value);
            }, ReplaySubject.prototype.nextTimeWindow = function(value) {
                this._events.push(new ReplayEvent(this._getNow(), value)), this._trimBufferThenGetEvents(), 
                _super.prototype.next.call(this, value);
            }, ReplaySubject.prototype._subscribe = function(subscriber) {
                var subscription, _infiniteTimeWindow = this._infiniteTimeWindow, _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents(), scheduler = this.scheduler, len = _events.length;
                if (this.closed) throw new ObjectUnsubscribedError.a();
                if (this.isStopped || this.hasError ? subscription = Subscription.a.EMPTY : (this.observers.push(subscriber), 
                subscription = new SubjectSubscription.a(this, subscriber)), scheduler && subscriber.add(subscriber = new observeOn_ObserveOnSubscriber(subscriber, scheduler)), 
                _infiniteTimeWindow) for (var i = 0; i < len && !subscriber.closed; i++) subscriber.next(_events[i]); else for (i = 0; i < len && !subscriber.closed; i++) subscriber.next(_events[i].value);
                return this.hasError ? subscriber.error(this.thrownError) : this.isStopped && subscriber.complete(), 
                subscription;
            }, ReplaySubject.prototype._getNow = function() {
                return (this.scheduler || queue).now();
            }, ReplaySubject.prototype._trimBufferThenGetEvents = function() {
                for (var now = this._getNow(), _bufferSize = this._bufferSize, _windowTime = this._windowTime, _events = this._events, eventsCount = _events.length, spliceCount = 0; spliceCount < eventsCount && !(now - _events[spliceCount].time < _windowTime); ) spliceCount++;
                return eventsCount > _bufferSize && (spliceCount = Math.max(spliceCount, eventsCount - _bufferSize)), 
                spliceCount > 0 && _events.splice(0, spliceCount), _events;
            }, ReplaySubject;
        }(Subject.a), ReplayEvent = /* */ function() {
            return function ReplayEvent(time, value) {
                this.time = time, this.value = value;
            };
        }();
    }, 
    /* 127 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        // EXTERNAL MODULE: ./src/parsers/texttracks/webvtt/getCueBlocks.ts
        var getCueBlocks = __webpack_require__(84), utils = __webpack_require__(48);
        // EXTERNAL MODULE: ./src/parsers/texttracks/webvtt/utils.ts
                // CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/getStyleBlocks.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Get cue blocks from a WebVTT file.
 * @param {Array.<string>} linified - Whole WebVTT file. Each new element in
 * this array is a new line.
 * @param {number} headerOffset - index of the first line after the header.
 * Used to avoid taking the header into consideration.
 * @returns {Array.<Array.<string>>}
 */
        function getStyleBlocks(linified, headerOffset) {
            for (var styleBlocks = [], i = headerOffset; i < linified.length; i++) 
            //
            if (Object(utils.d)(linified, i)) {
                var startOfStyleBlock = i;
                // continue incrementing i until either:
                //   - empty line
                //   - end of file
                for (i++; linified[i]; ) i++;
                var styleBlock = linified.slice(startOfStyleBlock, i);
                styleBlocks.push(styleBlock);
            } else if (linified[i]) 
            // continue incrementing i until either:
            //   - empty line
            //   - end
            for (;linified[i]; ) i++;
            return styleBlocks;
        }
        // EXTERNAL MODULE: ./src/parsers/texttracks/webvtt/parseCueBlock.ts + 1 modules
                var parseCueBlock = __webpack_require__(99), array_includes = __webpack_require__(14);
        // EXTERNAL MODULE: ./src/utils/array-includes.ts
                // CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/html/convertPayloadToHTML.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Construct an HTMLElement/TextNode representing the given node and apply
 * the right styling on it.
 * @param {Node} baseNode
 * @param {Array.<Object>} styleElements
 * @param {Array.<string>} styleClasses
 * @returns {Node}
 */
        function createStyledElement(baseNode, styleElements, styleClasses) {
            var HTMLTags = [ "u", "i", "b" ], mainNodeName = baseNode.nodeName.toLowerCase().split(".")[0], nodeWithStyle = void 0;
            if (Object(array_includes.a)([ "u", "i", "b", "c", "#text" ], mainNodeName)) if ("#text" === mainNodeName) {
                var linifiedText = baseNode.wholeText.split("\n");
                nodeWithStyle = document.createElement("span");
                for (var i = 0; i < linifiedText.length; i++) if (i && nodeWithStyle.appendChild(document.createElement("br")), 
                linifiedText[i].length > 0) {
                    var textNode = document.createTextNode(linifiedText[i]);
                    nodeWithStyle.appendChild(textNode);
                }
            } else {
                var classIndexes = [];
                if (baseNode.nodeName.toLowerCase().split(".").forEach(function(nodeClass) {
                    -1 !== styleClasses.indexOf(nodeClass) && classIndexes.push(styleClasses.indexOf(nodeClass));
                }), 0 !== classIndexes.length) {
                    // If style must be applied
                    var attr = document.createAttribute("style");
                    classIndexes.forEach(function(index) {
                        styleElements[index] && (attr.value += styleElements[index].styleContent);
                    });
                    var nameClass = Object(array_includes.a)(HTMLTags, mainNodeName) ? mainNodeName : "span";
                    (nodeWithStyle = document.createElement(nameClass)).setAttributeNode(attr);
                } else {
                    // If style mustn't be applied. Rebuild element with tag name
                    var elementTag = Object(array_includes.a)(HTMLTags, mainNodeName) ? mainNodeName : "span";
                    nodeWithStyle = document.createElement(elementTag);
                }
                for (var j = 0; j < baseNode.childNodes.length; j++) {
                    var child = createStyledElement(baseNode.childNodes[j], styleElements, styleClasses);
                    nodeWithStyle.appendChild(child);
                }
            } else {
                nodeWithStyle = document.createElement("span");
                for (var _j = 0; _j < baseNode.childNodes.length; _j++) {
                    var _child = createStyledElement(baseNode.childNodes[_j], styleElements, styleClasses);
                    nodeWithStyle.appendChild(_child);
                }
            }
            return nodeWithStyle;
        }
        /**
 * @param {string} text
 * @param {Array.<Object>} styleElements
 * @returns {Array.<HTMLElement>}
 */        function convertPayloadToHTML(text, styleElements) {
            for (var styleClasses = styleElements.map(function(styleElement) {
                return styleElement.className;
            }).filter(function(className) {
                return null != className;
            }), filteredText = text.replace(/<[0-9]{2}:[0-9]{2}.[0-9]{3}>/, "").replace(/<([u,i,b,c])(\..*?)?(?: .*?)?>(.*?)<\/\1>/g, "<$1$2>$3</$1$2>"), nodes = new DOMParser().parseFromString(filteredText, "text/html").body.childNodes, styledElements = [], i = 0; i < nodes.length; i++) styledElements.push(createStyledElement(nodes[i], styleElements, styleClasses));
            return styledElements;
        }
        // CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/html/parseStyleBlock.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 *
 * Parse style element from WebVTT.
 * @param {Array.<string>} styleBlock
 * @return {Array.<Object>} styleElements
 */        function parseStyleBlock(styleBlock) {
            var styleElements = [], index = 1, classNames = [];
            if (styleBlock.length < 2) return [];
            if (styleBlock[1].match(/::cue {/)) classNames.push({
                isGlobalStyle: !0
            }), index++; else for (var cueClassLine = void 0; styleBlock[index] && (cueClassLine = styleBlock[index].match(/::cue\(\.?(.*?)\)(?:,| {)/)); ) classNames.push({
                className: cueClassLine[1],
                isGlobalStyle: !1
            }), index++;
            for (var styleContent = ""; styleBlock[index] && !styleBlock[index].match(/}/) && 0 !== styleBlock[index].length; ) styleContent += styleBlock[index], 
            index++;
            return classNames.forEach(function(name) {
                styleElements.push({
                    className: name.className,
                    isGlobalStyle: name.isGlobalStyle,
                    styleContent: styleContent.replace(/\s/g, "")
                });
            }), styleElements;
        }
        // CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/html/index.ts
        /* harmony export (binding) */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */
        /**
 * Parse WebVTT from text. Returns an array with:
 * - start : start of current cue, in seconds
 * - end : end of current cue, in seconds
 * - content : HTML formatted cue.
 *
 * Global style is parsed and applied to div element.
 * Specific style is parsed and applied to class element.
 *
 * @param {string} text
 * @param {Number} timeOffset
 * @return {Array.<Object>}
 * @throws Error - Throws if the given WebVTT string is invalid.
 */
        function parseWebVTT(text, timeOffset) {
            var linified = text.split(/\r\n|\n|\r/g);
            if (!linified.length) return [];
            var cuesArray = [], styleElements = [];
            if (!linified[0].match(/^WEBVTT( |\t|\n|\r|$)/)) throw new Error("Can't parse WebVTT: Invalid File.");
            for (var firstLineAfterHeader = Object(utils.b)(linified), styleBlocks = getStyleBlocks(linified, firstLineAfterHeader), cueBlocks = Object(getCueBlocks.a)(linified, firstLineAfterHeader), i = 0; i < styleBlocks.length; i++) {
                var parsedStyles = parseStyleBlock(styleBlocks[i]);
                styleElements.push.apply(styleElements, parsedStyles);
            }
            for (var _i = 0; _i < cueBlocks.length; _i++) {
                var cueObject = Object(parseCueBlock.a)(cueBlocks[_i], timeOffset);
                if (null != cueObject) {
                    var htmlCue = toHTML(cueObject, styleElements);
                    htmlCue && cuesArray.push(htmlCue);
                }
            }
            return cuesArray;
        }
        /**
 * Parse cue block into an object with the following properties:
 *   - start {number}: start time at which the cue should be displayed
 *   - end {number}: end time at which the cue should be displayed
 *   - element {HTMLElement}: the cue text, translated into an HTMLElement
 *
 * Returns undefined if the cue block could not be parsed.
 * @param {Array.<string>} cueBlock
 * @param {Number} timeOffset
 * @param {Array.<Object>} styleElements
 * @returns {Object|undefined}
 */        function toHTML(cueObj, styleElements) {
            var start = cueObj.start, end = cueObj.end, header = cueObj.header, payload = cueObj.payload, region = document.createElement("div"), regionAttr = document.createAttribute("style");
            regionAttr.value = "width:100%;height:100%;display:flex;flex-direction:column;justify-content:flex-end;align-items:center;", 
            region.setAttributeNode(regionAttr);
            // Get content, format and apply style.
            var pElement = document.createElement("p"), pAttr = document.createAttribute("style");
            pAttr.value = "text-align:center", pElement.setAttributeNode(pAttr);
            var spanElement = document.createElement("span"), attr = document.createAttribute("style");
            // set color and background-color default values, as indicated in:
            // https://www.w3.org/TR/webvtt1/#applying-css-properties
            attr.value = "background-color:rgba(0,0,0,0.8);color:white;", spanElement.setAttributeNode(attr);
            var styles = styleElements.filter(function(styleElement) {
                return styleElement.className === header && !styleElement.isGlobalStyle || styleElement.isGlobalStyle;
            }).map(function(styleElement) {
                return styleElement.styleContent;
            });
            return attr.value += styles.join(), spanElement.setAttributeNode(attr), convertPayloadToHTML(payload.join("\n"), styleElements).forEach(function(element) {
                spanElement.appendChild(element);
            }), region.appendChild(pElement), pElement.appendChild(spanElement), {
                start: start,
                end: end,
                element: region
            };
        }
        /***/        __webpack_require__.d(__webpack_exports__, "default", function() {
            return parseWebVTT;
        });
    }, 
    /* 128 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        // EXTERNAL MODULE: ./node_modules/array-find/find.js
        var find = __webpack_require__(13), find_default = /* */ __webpack_require__.n(find), object_assign = __webpack_require__(11), object_assign_default = /* */ __webpack_require__.n(object_assign), getParameters = __webpack_require__(85), getParentElementsByTagName = __webpack_require__(60), nodes = __webpack_require__(58), ttml_style = __webpack_require__(30), STYLE_ATTRIBUTES = [ "backgroundColor", "color", "direction", "display", "displayAlign", "extent", "fontFamily", "fontSize", "fontStyle", "fontWeight", "lineHeight", "opacity", "origin", "overflow", "padding", "textAlign", "textDecoration", "textOutline", "unicodeBidi", "visibility", "wrapOption", "writingMode" ], getTimeDelimiters = __webpack_require__(98), regexps = __webpack_require__(20), SPAN_LEVEL_ATTRIBUTES = [ "color", "direction", "display", "fontFamily", "fontSize", "fontStyle", "fontWeight", "textDecoration", "textOutline", "unicodeBidi", "visibility", "wrapOption" ];
        /**
 * Translate a color indicated in TTML-style to a CSS-style color.
 * @param {string} color
 * @returns {string} color
 */
        function ttmlColorToCSSColor(color) {
            // TODO check all possible color fomats
            var regRes = void 0;
            return null != (regRes = regexps.b.exec(color)) ? "rgba(" + parseInt(regRes[1], 16) + "," + parseInt(regRes[2], 16) + "," + parseInt(regRes[3], 16) + "," + parseInt(regRes[4], 16) / 255 + ")" : null != (regRes = regexps.a.exec(color)) ? "rgba(" + parseInt(regRes[1] + regRes[1], 16) + "," + parseInt(regRes[2] + regRes[2], 16) + "," + parseInt(regRes[3] + regRes[3], 16) + "," + parseInt(regRes[4] + regRes[4], 16) / 255 + ")" : color;
        }
        /**
 * Try to replicate the textOutline TTML style property into CSS.
 *
 * We mock it throught the text-shadow property, translating the TTML thickness
 * into blur radius and the blur-radius into... nothing.
 *
 * @param {string} color
 * @param {string|number} thickness
 * @returns {string}
 */        function generateCSSTextOutline(color, thickness) {
            return "-1px -1px " + thickness + " " + color + ",1px -1px " + thickness + " " + color + ",-1px 1px " + thickness + " " + color + ",1px 1px " + thickness + " " + color;
        }
        // TODO
        // tts:showBackground (applies to region)
        // tts:zIndex (applies to region)
        /**
 * Apply style set for a singular text span of the current cue.
 * @param {HTMLElement} element - The text span
 * @param {Object} style - The style to apply
 */        function applyTextStyle(element, style) {
            // applies to span
            var color = style.color;
            color && (element.style.color = ttmlColorToCSSColor(color));
            // applies to body, div, p, region, span
                        var backgroundColor = style.backgroundColor;
            backgroundColor && (element.style.backgroundColor = ttmlColorToCSSColor(backgroundColor));
            // applies to span
                        var wrapOption = style.wrapOption;
            wrapOption && "noWrap" === wrapOption && (element.style.whiteSpace = "nowrap");
            // applies to span
                        var textOutline = style.textOutline;
            if (textOutline) {
                var outlineData = textOutline.trim().replace(/\s+/g, " ").split(" "), len = outlineData.length;
                if (3 === len) {
                    var outlineColor = ttmlColorToCSSColor(outlineData[0]), thickness = outlineData[1];
                    element.style.textShadow = generateCSSTextOutline(outlineColor, thickness);
                } else if (color && 1 === len) {
                    var _thickness = outlineData[0];
                    element.style.textShadow = generateCSSTextOutline(color, _thickness);
                } else if (2 === len) {
                    var isFirstArgAColor = /^[#A-Z]/i.test(outlineData[0]);
                    // XOR-ing to be sure we get what we have
                    if (isFirstArgAColor !== /^[0-9]/.test(outlineData[0])) if (isFirstArgAColor) {
                        var _outlineColor = ttmlColorToCSSColor(outlineData[0]), _thickness2 = outlineData[1];
                        element.style.textShadow = generateCSSTextOutline(_outlineColor, _thickness2);
                    } else if (color) {
                        var _thickness3 = outlineData[0];
                        element.style.textShadow = generateCSSTextOutline(color, _thickness3);
                    }
                }
            }
            // applies to span
                        var textDecoration = style.textDecoration;
            if (textDecoration) switch (textDecoration) {
              case "noUnderline":
              case "noLineThrough":
              case "noOverline":
                element.style.textDecoration = "none";
                break;

              case "lineThrough":
                element.style.textDecoration = "line-through";
                break;

              default:
                element.style.textDecoration = textDecoration;
            }
            // applies to span
                        var fontFamily = style.fontFamily;
            if (fontFamily) switch (fontFamily) {
              case "proportionalSansSerif":
                element.style.fontFamily = "Arial, Helvetica, Liberation Sans, sans-serif";
                break;

                // TODO monospace or sans-serif or font with both?
                              case "monospaceSansSerif":
              case "sansSerif":
                element.style.fontFamily = "sans-serif";
                break;

              case "monospaceSerif":
              case "default":
                element.style.fontFamily = "Courier New, Liberation Mono, monospace";
                break;

                // TODO font with both?
                              case "proportionalSerif":
                element.style.fontFamily = "serif";
                break;

              default:
                element.style.fontFamily = fontFamily;
            }
            // applies to span
                        var fontStyle = style.fontStyle;
            fontStyle && (element.style.fontStyle = fontStyle);
            // applies to span
                        var fontWeight = style.fontWeight;
            fontWeight && (element.style.fontWeight = fontWeight);
            // applies to span
                        var fontSize = style.fontSize;
            fontSize && (
            // TODO Check if formats are always really 1:1
            element.style.fontSize = fontSize);
            // applies to p, span
                        var direction = style.direction;
            direction && (element.style.direction = direction);
            // applies to p, span
                        var unicodeBidi = style.unicodeBidi;
            if (unicodeBidi) switch (unicodeBidi) {
              case "bidiOverride":
                element.style.unicodeBidi = "bidi-override";
                break;

              case "embed":
                element.style.unicodeBidi = "embed";
                break;

              default:
                element.style.unicodeBidi = "normal";
            }
            // applies to body, div, p, region, span
                        var visibility = style.visibility;
            visibility && (element.style.visibility = visibility), "none" === style.display && (element.style.display = "none");
            // applies to body, div, p, region, span
                }
        /**
 * Apply style for the general text track div.
 * @param {HTMLElement} element - The <div> the style will be applied on.
 * @param {Object} style - The general style object of the paragraph.
 */        function applyGeneralStyle(element, style) {
            // applies to tt, region
            var extent = style.extent;
            if (extent) {
                var results = regexps.c.exec(extent);
                null != results && (element.style.width = results[1] + "%", element.style.height = results[2] + "%");
            }
            // applies to region
                        style.writingMode;
            var overflow = style.overflow;
            element.style.overflow = overflow || "hidden";
            // applies to region
            var padding = style.padding;
            padding && (element.style.padding = padding);
            // applies to region
                        var origin = style.origin;
            if (origin) {
                var resultsPercent = regexps.c.exec(origin);
                null != resultsPercent && (element.style.position = "relative", element.style.left = resultsPercent[1] + "%", 
                element.style.top = resultsPercent[2] + "%");
            }
            // applies to region
                        var displayAlign = style.displayAlign;
            if (element.style.display = "flex", element.style.flexDirection = "column", displayAlign) switch (displayAlign) {
              case "before":
                element.style.justifyContent = "flex-start";
                break;

              case "center":
                element.style.justifyContent = "center";
                break;

              case "after":
                element.style.justifyContent = "flex-end";
            }
            // applies to region
                        var opacity = style.opacity;
            opacity && (element.style.opacity = opacity);
            // applies to body, div, p, region, span
                        var visibility = style.visibility;
            visibility && (element.style.visibility = visibility), "none" === style.display && (element.style.display = "none");
            // applies to body, div, p, region, span
                }
        /**
 * Apply style set for a <p> element
 * @param {HTMLElement} element - The <p> element
 * @param {Object} style - The general style object of the paragraph.
 */        function applyPStyle(element, style) {
            // applies to body, div, p, region, span
            var paragraphBackgroundColor = style.backgroundColor;
            paragraphBackgroundColor && (element.style.backgroundColor = ttmlColorToCSSColor(paragraphBackgroundColor));
            // applies to p
                        var lineHeight = style.lineHeight;
            lineHeight && (element.style.lineHeight = lineHeight);
            // applies to p
                        var textAlign = style.textAlign;
            if (textAlign) switch (textAlign) {
              case "center":
                element.style.textAlign = "center";
                break;

              case "left":
              case "start":
                // TODO check what start means (difference with left, writing direction?)
                element.style.textAlign = "left";
                break;

              case "right":
              case "end":
                // TODO check what end means (difference with right, writing direction?)
                element.style.textAlign = "right";
            }
        }
        /**
 * Creates span of text for the given #text element, with the right style.
 *
 * TODO create text elements as string? Might help performances.
 * @param {Element} el - the #text element, which text content should be
 * displayed
 * @param {Object} style - the style object for the given text
 * @param {Boolean} shouldTrimWhiteSpaceParam - True if the space should be
 * trimmed by default. From the <tt> xml:space parameter.
 * @returns {HTMLElement}
 */        function createTextElement(el, style, shouldTrimWhiteSpaceParam) {
            var textElement = document.createElement("span"), textContent = el.textContent || "";
            // TODO Also parse it from parent elements
            // const spaceAttr = getAttributeInElements("xml:space", [
            //   ...spans, p, ...divs, body,
            // ]);
            // const shouldTrimWhiteSpace = spaceAttr ?
            //   spaceAttr === "default" : shouldTrimWhiteSpaceParam;
            if (shouldTrimWhiteSpaceParam) {
                // 1. Trim leading and trailing whitespace.
                // 2. Collapse multiple spaces into one.
                var trimmed = textContent.trim();
                textContent = trimmed = trimmed.replace(/\s+/g, " ");
            }
            return textElement.innerHTML = textContent, textElement.className = "rxp-texttrack-span", 
            applyTextStyle(textElement, style), textElement;
        }
        /**
 * Generate every text elements to display in a given paragraph.
 * @param {Element} paragraph - The <p> tag.
 * @param {Array.<Object>} regions
 * @param {Array.<Object>} styles
 * @param {Object} paragraphStyle - The general style object of the paragraph.
 * @param {Boolean} shouldTrimWhiteSpace
 * @returns {Array.<HTMLElement>}
 */        function generateTextContent(paragraph, regions, styles, paragraphStyle, shouldTrimWhiteSpace) {
            /**
     * Recursive function, taking a node in argument and returning the
     * corresponding array of HTMLElement in order.
     * @param {Node} node - the node in question
     * @param {Object} style - the current state of the style for the node.
     * /!\ The style object can be mutated, provide a copy of it.
     * @param {Array.<Element>} spans - The spans parent of this node.
     * @returns {Array.<HTMLElement>}
     */
            return function loop(node, style, spans) {
                for (var childNodes = node.childNodes, elements = [], i = 0; i < childNodes.length; i++) {
                    var currentNode = childNodes[i];
                    if ("#text" === currentNode.nodeName) {
                        var backgroundColor = Object(ttml_style.a)([ "backgroundColor" ], spans, styles, regions).backgroundColor;
                        backgroundColor ? style.backgroundColor = backgroundColor : delete style.backgroundColor;
                        var el = createTextElement(currentNode, style, shouldTrimWhiteSpace);
                        elements.push(el);
                    } else if ("br" === currentNode.nodeName) {
                        var br = document.createElement("BR");
                        elements.push(br);
                    } else if ("span" === currentNode.nodeName && currentNode.childNodes.length > 0) {
                        // compute the new applyable style
                        var newStyle = object_assign_default()({}, style, Object(ttml_style.a)(SPAN_LEVEL_ATTRIBUTES, [ currentNode ], styles, regions));
                        elements.push.apply(elements, loop(currentNode, newStyle, [ currentNode ].concat(spans)));
                    }
                }
                return elements;
            }(paragraph, object_assign_default()({}, paragraphStyle), []);
        }
        /**
 * @param {Element} paragraph
 * @param {Element} body
 * @param {Array.<Object>} regions
 * @param {Array.<Object>} styles
 * @param {Object} paragraphStyle
 * @param {Boolean} shouldTrimWhiteSpace
 * @returns {HTMLElement}
 */        function createElement(paragraph, body, regions, styles, paragraphStyle, shouldTrimWhiteSpace) {
            var divs = Object(getParentElementsByTagName.a)(paragraph, "div"), parentElement = document.createElement("DIV");
            if (parentElement.className = "rxp-texttrack-region", applyGeneralStyle(parentElement, paragraphStyle), 
            body) {
                // applies to body, div, p, region, span
                var bodyBackgroundColor = Object(ttml_style.a)([ "backgroundColor" ], [].concat(divs, [ body ]), styles, regions).bodyBackgroundColor;
                bodyBackgroundColor && (parentElement.style.backgroundColor = ttmlColorToCSSColor(bodyBackgroundColor));
            }
            var pElement = document.createElement("p");
            pElement.className = "rxp-texttrack-p", applyPStyle(pElement, paragraphStyle);
            for (var textContent = generateTextContent(paragraph, regions, styles, paragraphStyle, shouldTrimWhiteSpace), i = 0; i < textContent.length; i++) pElement.appendChild(textContent[i]);
            // NOTE:
            // The following code is for the inclusion of div elements. This has no
            // advantage for now, and might only with future evolutions.
            // (This is only an indication of what the base of the code could look like).
            // if (divs.length) {
            //   let container = parentElement;
            //   for (let i = divs.length - 1; i >= 0; i--) {
            //     // TODO manage style at div level?
            //     // They are: visibility, display and backgroundColor
            //     // All these do not have any difference if applied to the <p> element
            //     // instead of the div.
            //     // The advantage might only be for multiple <p> elements dispatched
            //     // in multiple div Which we do not manage anyway for now.
            //     const divEl = document.createElement("DIV");
            //     divEl.className = "rxp-texttrack-div";
            //     container.appendChild(divEl);
            //     container = divEl;
            //   }
            //   container.appendChild(pElement);
            //   parentElement.appendChild(container);
            // } else {
            //   parentElement.appendChild(pElement);
            // }
                        return parentElement.appendChild(pElement), parentElement;
        }
        // CONCATENATED MODULE: ./src/parsers/texttracks/ttml/html/parseCue.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {Element} paragraph
 * @param {Number} offset
 * @param {Array.<Object>} styles
 * @param {Array.<Object>} regions
 * @param {Element} body
 * @param {Object} styleBase
 * @param {Object} ttParams
 * @returns {Object|null}
 */        function parseCue(paragraph, offset, styles, regions, body, styleBase, ttParams) {
            // Disregard empty elements:
            // TTML allows for empty elements like <div></div>.
            // If paragraph has neither time attributes, nor
            // non-whitespace text, don't try to make a cue out of it.
            if (!paragraph.hasAttribute("begin") && !paragraph.hasAttribute("end") && /^\s*$/.test(paragraph.textContent || "")) return null;
            var _getTimeDelimiters = Object(getTimeDelimiters.a)(paragraph, ttParams);
            return {
                start: _getTimeDelimiters.start + offset,
                end: _getTimeDelimiters.end + offset,
                element: createElement(paragraph, body, regions, styles, styleBase, "default" === ttParams.spaceStyle)
            };
        }
        // CONCATENATED MODULE: ./src/parsers/texttracks/ttml/html/index.ts
        /* harmony export (binding) */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */
        /**
 * Create array of objects which should represent the given TTML text track.
 * These objects have the following structure
 *   - start {Number}: start time, in seconds, at which the cue should
 *     be displayed
 *   - end {Number}: end time, in seconds, at which the cue should
 *     be displayed
 *   - element {HTMLElement}: <div> element representing the cue, with the
 *     right style. This div should then be appended to an element having
 *     the exact size of the wanted region the text track provide cues for.
 *
 * TODO TTML parsing is still pretty heavy on the CPU.
 * Optimizations have been done, principally to avoid using too much XML APIs,
 * but we can still do better.
 * @param {string} str
 * @param {Number} timeOffset
 * @returns {Array.<Object>}
 */
        function parseTTMLStringToDIV(str, timeOffset) {
            var ret = [], xml = new DOMParser().parseFromString(str, "text/xml");
            if (xml) {
                var tt = xml.getElementsByTagName("tt")[0];
                if (!tt) throw new Error("invalid XML");
                for (var body = Object(nodes.a)(tt), styleNodes = Object(nodes.c)(tt), regionNodes = Object(nodes.b)(tt), textNodes = Object(nodes.d)(tt), params = Object(getParameters.a)(tt), styles = [], i = 0; i <= styleNodes.length - 1; i++) {
                    var styleNode = styleNodes[i];
                    if (styleNode instanceof Element) {
                        var styleID = styleNode.getAttribute("xml:id");
                        null !== styleID && 
                        // TODO styles referencing other styles
                        styles.push({
                            id: styleID,
                            style: Object(ttml_style.b)(styleNode)
                        });
                    }
                }
                // construct regions array based on the xml as an optimization
                                for (var regions = [], _i = 0; _i <= regionNodes.length - 1; _i++) {
                    var regionNode = regionNodes[_i];
                    if (regionNode instanceof Element) {
                        var regionID = regionNode.getAttribute("xml:id");
                        null !== regionID && function() {
                            var regionStyle = Object(ttml_style.b)(regionNode), associatedStyle = regionNode.getAttribute("style");
                            if (associatedStyle) {
                                var style = find_default()(styles, function(x) {
                                    return x.id === associatedStyle;
                                });
                                style && (regionStyle = object_assign_default()({}, style.style, regionStyle));
                            }
                            regions.push({
                                id: regionID,
                                style: regionStyle
                            });
                        }();
                    }
                }
                // Computing the style takes a lot of ressources.
                // To avoid too much re-computation, let's compute the body style right
                // now and do the rest progressively.
                // TODO Compute corresponding CSS style here (as soon as we now the TTML
                // style) to speed up the process even
                // more.
                                for (var bodyStyle = null !== body ? Object(ttml_style.a)(STYLE_ATTRIBUTES, [ body ], styles, regions) : Object(ttml_style.a)(STYLE_ATTRIBUTES, [], styles, regions), _i2 = 0; _i2 < textNodes.length; _i2++) {
                    var paragraph = textNodes[_i2];
                    if (paragraph instanceof Element) {
                        var divs = Object(getParentElementsByTagName.a)(paragraph, "div"), paragraphStyle = object_assign_default()({}, bodyStyle, Object(ttml_style.a)(STYLE_ATTRIBUTES, [ paragraph ].concat(divs), styles, regions)), cue = parseCue(paragraph, timeOffset, styles, regions, body, paragraphStyle, params);
                        cue && ret.push(cue);
                    }
                }
            }
            return ret;
        }
        /***/        __webpack_require__.d(__webpack_exports__, "default", function() {
            return parseTTMLStringToDIV;
        });
    }, 
    /* 129 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/merge.js
        var merge = __webpack_require__(134), interval = __webpack_require__(139), concat = __webpack_require__(107), of = __webpack_require__(75), Subject = __webpack_require__(36), mapTo = __webpack_require__(136), startWith = __webpack_require__(138), switchMap = __webpack_require__(117);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/interval.js
                // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/switchMapTo.js
        /** PURE_IMPORTS_START _switchMap PURE_IMPORTS_END */
        function switchMapTo(innerObservable, resultSelector) {
            return resultSelector ? Object(switchMap.a)(function() {
                return innerObservable;
            }, resultSelector) : Object(switchMap.a)(function() {
                return innerObservable;
            });
        }
        //# sourceMappingURL=switchMapTo.js.map
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/takeUntil.js
                var takeUntil = __webpack_require__(141), events = __webpack_require__(8), config = __webpack_require__(3), log = __webpack_require__(0), abstract_source_buffer = __webpack_require__(61);
        // EXTERNAL MODULE: ./src/compat/events.ts + 2 modules
                // CONCATENATED MODULE: ./src/core/source_buffers/text/html/buffer_manager.ts
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Maximum time difference, in seconds, between two text segment's start times
 * and/or end times for them to be considered the same in the custom text's
 * source buffer used for the "html" textTrackMode.
 *
 * For example for two segments s1 and s2 which have a start time respectively
 * of st1 and st2 and end time of et1 and et2:
 *   - if both the absolute difference between st1 and st2 AND the one between
 *     et1 and et2 is inferior or equal to the MAX_DELTA_BUFFER_TIME, s1 and s2
 *     are considered to target the exact same time. As a consequence, if s2 is
 *     added after s1 in the source buffer, s1 will be completely replaced by
 *     it and vice-versa.
 *   - if only one of the two (absolute difference between st1 and st2 OR et1
 *     and et2) is inferior to the MAX_DELTA_BUFFER_TIME then the last added
 *     is not completely considered the same. It WILL still replace - either
 *     partially or completely (depending on the sign of the other difference) -
 *     the previously added segment.
 *   - if both differences are strictly superior to the MAX_DELTA_BUFFER_TIME,
 *     then they are not considered to have the same start nor the same end.
 *     They can still overlap however, and MIGHT thus still replace partially
 *     or completely each other.
 *
 * Setting a value too low might lead to two segments targeting the same time,
 * both being present in the source buffer. In worst case scenarios, this could
 * lead to indicate that an unwanted text track is still here (theorically
 * though, this is a case that should never happen for reasons that might be too
 * long to explain here).
 *
 * Setting a value too high might lead to two segments targeting different times
 * to be wrongly believed to target the same time. In worst case scenarios, this
 * could lead to wanted text tracks being removed.
 * @type Number
 */        var MAX_DELTA_BUFFER_TIME = .2;
        /**
 * @see MAX_DELTA_BUFFER_TIME
 * @param {Number} a
 * @param {Number} b
 * @returns {Boolean}
 */        function areNearlyEqual(a, b) {
            return Math.abs(a - b) <= MAX_DELTA_BUFFER_TIME;
        }
        /**
 * Get all cues strictly before the given time.
 * @param {Object} cues
 * @param {Number} time
 * @returns {Array.<Object>}
 */        function getCuesBefore(cues, time) {
            for (var i = 0; i < cues.length; i++) {
                var cue = cues[i];
                if (time < cue.end) return time >= cue.start ? cues.slice(0, i) : cues.slice(0, i + 1);
            }
            return cues.slice();
        }
        /**
 * Get all cues strictly after the given time.
 * @param {Object} cues
 * @param {Number} time
 * @returns {Array.<Object>}
 */        function getCuesAfter(cues, time) {
            for (var i = 0; i < cues.length; i++) {
                var cue = cues[i];
                if (time < cue.end) return time >= cue.start ? cues.slice(i + 1, cues.length) : cues.slice(i, cues.length);
            }
            return [];
        }
        /**
 * @param {Object} cuesInfos
 * @param {Number} start
 * @param {Number} end
 * @returns {Array.<Object>}
 */        function removeCuesInfosBetween(cuesInfos, start, end) {
            var end1 = Math.max(cuesInfos.start, start);
            return [ {
                start: cuesInfos.start,
                end: end1,
                cues: getCuesBefore(cuesInfos.cues, start)
            }, {
                start: Math.min(end, cuesInfos.end),
                end: cuesInfos.end,
                cues: getCuesAfter(cuesInfos.cues, end)
            } ];
        }
        /**
 * Manage the buffer of the HTML text Sourcebuffer.
 * Allows to add, remove and recuperate cues at given times.
 * @class TextBufferManager
 */        var buffer_manager = function() {
            function TextBufferManager() {
                _classCallCheck(this, TextBufferManager), this._cuesBuffer = [];
            }
            /**
     * Get corresponding cue for the given time.
     * A cue is an object with three properties:
     *   - start {Number}: start time for which the cue should be displayed.
     *   - end {Number}: end time for which the cue should be displayed.
     *   - element {HTMLElement}: The cue to diplay
     *
     * We do not mutate individual cue here.
     * That is, if the ``get`` method returns the same cue's reference than a
     * previous ``get`` call, its properties are guaranteed to have the exact same
     * values than before, if you did not mutate it on your side.
     * The inverse is true, if the values are the same than before, the reference
     * will stay the same (this is useful to easily check if the DOM should be
     * updated, for example).
     *
     * @param {Number} time
     * @returns {HTMLElement|undefined} - The cue to display
     */            return TextBufferManager.prototype.get = function get(time) {
                // begins at the end as most of the time the player will ask for the last
                // CuesGroup
                for (var cuesBuffer = this._cuesBuffer, i = cuesBuffer.length - 1; i >= 0; i--) for (var cues = cuesBuffer[i].cues, j = cues.length - 1; j >= 0; j--) {
                    var cue = cues[j];
                    if (time >= cue.start) return time < cue.end ? cue : void 0;
                }
            }, 
            /**
     * Remove cue from a certain range of time.
     * @param {Number} from
     * @param {Number} to
     */
            TextBufferManager.prototype.remove = function remove(from, _to) {
                for (var to = Math.max(from, _to), cuesBuffer = this._cuesBuffer, len = cuesBuffer.length, i = 0; i < len; i++) if (cuesBuffer[i].end > from) {
                    var startCuesInfos = cuesBuffer[i];
                    if (startCuesInfos.start >= to) 
                    // our cue is strictly after this interval, we have nothing to do
                    return;
                    // ``to`` is within this segment
                                        if (startCuesInfos.end >= to) {
                        var _removeCuesInfosBetwe = removeCuesInfosBetween(startCuesInfos, from, to), cuesInfos1 = _removeCuesInfosBetwe[0], cuesInfos2 = _removeCuesInfosBetwe[1];
                        return this._cuesBuffer[i] = cuesInfos1, void cuesBuffer.splice(i + 1, 0, cuesInfos2);
                    }
                    // Else remove the part of the segment after ``from``, and the concerned
                    // segments after that
                                        startCuesInfos.cues = getCuesBefore(startCuesInfos.cues, from), 
                    startCuesInfos.end = Math.max(from, startCuesInfos.start);
                    for (var j = i + 1; j < len; j++) {
                        var endCuesInfos = cuesBuffer[i];
                        if (to <= endCuesInfos.end) 
                        // remove all cues from the start to this one non-included
                        return cuesBuffer.splice(i + 1, j - (i + 1)), void (
                        // if ``to`` is in the middle of the last segment
                        to > endCuesInfos.start && (endCuesInfos.cues = getCuesAfter(endCuesInfos.cues, to), 
                        endCuesInfos.start = to));
                    }
                    return void cuesBuffer.splice(i + 1, cuesBuffer.length - (i + 1));
                }
            }, 
            /**
     * Insert new cues in our text buffer.
     * cues is an array of objects with three properties:
     *   - start {Number}: start time for which the cue should be displayed.
     *   - end {Number}: end time for which the cue should be displayed.
     *   - element {HTMLElement}: The cue to diplay
     *
     * @param {Array.<Object>} cues - CuesGroups, array of objects with the
     * following properties:
     *   - start {Number}: the time at which the cue will start to be displayed
     *   - end {Number}: the time at which the cue will end to be displayed
     *   - cue {HTMLElement}: The cue
     * @param {Number} start - Start time at which the CuesGroup applies.
     * This is different than the start of the first cue to display in it, this
     * has more to do with the time at which the _text segment_ starts.
     * @param {Number} end - End time at which the CuesGroup applies.
     * This is different than the end of the last cue to display in it, this
     * has more to do with the time at which the _text segment_ ends.
     *
     * TODO add securities to ensure that:
     *   - the start of a CuesGroup is inferior or equal to the start of the first
     *     cue in it
     *   - the end of a CuesGroup is superior or equal to the end of the last
     *     cue in it
     * If those requirements are not met, we could delete some cues when adding
     * a CuesGroup before/after. Find a solution.
     */
            TextBufferManager.prototype.insert = function insert(cues, start, end) {
                for (var cuesBuffer = this._cuesBuffer, cuesInfosToInsert = {
                    start: start,
                    end: end,
                    cues: cues
                }, i = 0; i < cuesBuffer.length; i++) {
                    var cuesInfos = cuesBuffer[i];
                    if (start < cuesInfos.end) {
                        if (areNearlyEqual(start, cuesInfos.start)) {
                            if (areNearlyEqual(end, cuesInfos.end)) 
                            // exact same segment
                            //   ours:            |AAAAA|
                            //   the current one: |BBBBB|
                            //   Result:          |AAAAA|
                            // Which means:
                            //   1. replace the current cue with ours
                            return void (cuesBuffer[i] = cuesInfosToInsert);
                            // our cue goes beyond the current one:
                            //   ours:            |AAAAAAA|
                            //   the current one: |BBBB|
                            //   Result:          |AAAAAAA|
                            // Here we have to delete any cuesInfos which end before ours end,
                            // and see about the following one.
                                                        if (end < cuesInfos.end) 
                            // our cue overlaps with the current one:
                            //   ours:            |AAAAA|
                            //   the current one: |BBBBBBBB|
                            //   Result:          |AAAAABBB|
                            // Which means:
                            //   1. remove some cues at the start of the current one
                            //   2. update start of current one
                            //   3. add ours before the current one
                            return cuesInfos.cues = getCuesAfter(cuesInfos.cues, end), cuesInfos.start = end, 
                            void cuesBuffer.splice(i, 0, cuesInfosToInsert);
                            do {
                                cuesBuffer.splice(i, 1), cuesInfos = cuesBuffer[i];
                            } while (cuesInfos && end > cuesInfos.end);
                            return !cuesInfos || // There is no cue here
                            areNearlyEqual(end, cuesInfos.end) ? 
                            // put in place
                            void (cuesBuffer[i] = cuesInfosToInsert) : (
                            // else -> end < cuesInfos.end (overlapping case)
                            //   ours:            |AAAAA|
                            //   the current one: |BBBBBBBB|
                            //   Result:          |AAAAABBB|
                            cuesInfos.cues = getCuesAfter(cuesInfos.cues, end), cuesInfos.start = end, void cuesBuffer.splice(i, 0, cuesInfosToInsert));
                        }
                        // else -> start > cuesInfos.start
                                                if (start < cuesInfos.start) return end < cuesInfos.start ? 
                        // our cue goes strictly before the current one:
                        //   ours:            |AAAAAAA|
                        //   the current one:           |BBBB|
                        //   Result:          |AAAAAAA| |BBBB|
                        // Which means:
                        //   - add ours before the current one
                        void cuesBuffer.splice(i, 0, cuesInfosToInsert) : areNearlyEqual(end, cuesInfos.start) ? (
                        // our cue goes just before the current one:
                        //   ours:            |AAAAAAA|
                        //   the current one:         |BBBB|
                        //   Result:          |AAAAAAA|BBBB|
                        // Which means:
                        //   - update start time of the current one to be sure
                        //   - add ours before the current one
                        cuesInfos.start = end, void cuesBuffer.splice(i, 0, cuesInfosToInsert)) : (
                        // our cue overlaps the current one:
                        //   ours:            |AAAAAAA|
                        //   the current one:     |BBBBB|
                        //   Result:          |AAAAAAABB|
                        // Which means:
                        //   1. remove some cues at the start of the current one
                        //   2. update start of current one
                        //   3. add ours before the current one
                        cuesInfos.cues = getCuesAfter(cuesInfos.cues, end), cuesInfos.start = end, void cuesBuffer.splice(i, 0, cuesInfosToInsert));
                        if (end > cuesInfos.end || areNearlyEqual(end, cuesInfos.end)) 
                        // our cue overlaps the current one:
                        //   ours:              |AAAAAA|
                        //   the current one: |BBBBB|
                        //   Result:          |BBAAAAAA|
                        //   - or -
                        //   ours:              |AAAA|
                        //   the current one: |BBBBBB|
                        //   Result:          |BBAAAA|
                        // Which means:
                        //   1. remove some cues at the end of the current one
                        //   2. update end of current one
                        //   3. add ours after current one
                        return cuesInfos.cues = getCuesBefore(cuesInfos.cues, start), cuesInfos.end = start, 
                        void cuesBuffer.splice(i + 1, 0, cuesInfosToInsert);
                        // else -> end < cuesInfos.end
                        // our cue is in the current one:
                        //   ours:              |AAA|
                        //   the current one: |BBBBBBB|
                        //   Result:          |BBAAABB|
                        // Which means:
                        //   1. split current one in two parts based on our cue.
                        //   2. insert our cue into it.
                                                var _removeCuesInfosBetwe2 = removeCuesInfosBetween(cuesInfos, start, end), cuesInfos1 = _removeCuesInfosBetwe2[0], cuesInfos2 = _removeCuesInfosBetwe2[1];
                        return this._cuesBuffer[i] = cuesInfos1, cuesBuffer.splice(i + 1, 0, cuesInfosToInsert), 
                        void cuesBuffer.splice(i + 2, 0, cuesInfos2);
                    }
                }
                // no cues group has the end after our current start.
                // These cues should be the last one
                                cuesBuffer.push(cuesInfosToInsert);
            }, TextBufferManager;
        }(), features = __webpack_require__(7);
        /* harmony default export */        
        // CONCATENATED MODULE: ./src/core/source_buffers/text/html/parsers.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Convert text track data into timed HTML Cues.
 * @param {string} type - Text track format wanted
 * @param {string} data - Text track data
 * @param {Number} timestampOffset - offset to apply to every timed text
 * @param {string} [language] - language of the text tracks
 * @returns {Array.<Object>}
 * @throws Error - Throw if no parser is found for the given type
 */
        function parseTextTrackToElements(type, data, timestampOffset, language) {
            log.a.debug("finding parser for html text tracks:", type);
            var parser = features.a.htmlTextTracksParsers[type];
            if (!parser) throw new Error("no parser found for the given text track");
            log.a.debug("parser found, parsing...");
            var parsed = parser(data, timestampOffset, language);
            return log.a.debug("parsed successfully!", parsed), parsed;
        }
        // CONCATENATED MODULE: ./src/core/source_buffers/text/html/index.ts
                function html_classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        function _possibleConstructorReturn(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" != typeof call && "function" != typeof call ? self : call;
        }
        function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */        var MAXIMUM_HTML_TEXT_TRACK_UPDATE_INTERVAL = config.a.MAXIMUM_HTML_TEXT_TRACK_UPDATE_INTERVAL;
        /**
 * Generate the clock at which TextTrack HTML Cues should be refreshed.
 * @param {HTMLMediaElement} videoElement
 * @returns {Observable}
 */        function generateClock(videoElement) {
            var seeking$ = Object(events.m)(videoElement).pipe(Object(mapTo.a)(null)), seeked$ = Object(events.l)(videoElement).pipe(Object(mapTo.a)(null)), ended$ = Object(events.c)(videoElement).pipe(Object(mapTo.a)(null)), manualRefresh$ = Object(merge.a)(seeked$, ended$), autoRefresh$ = Object(interval.a)(MAXIMUM_HTML_TEXT_TRACK_UPDATE_INTERVAL).pipe(Object(mapTo.a)(null), Object(startWith.a)(null));
            // TODO Better way to express that
            return manualRefresh$.pipe(Object(startWith.a)(null), switchMapTo(Object(concat.a)(autoRefresh$.pipe(Object(mapTo.a)(!0), Object(takeUntil.a)(seeking$)), Object(of.a)(!1))));
        }
        /**
 * @param {Element} element
 * @param {Element|null} [child]
 */        function safelyRemoveChild(element, child) {
            if (child) try {
                element.removeChild(child);
            } catch (e) {
                log.a.warn("Can't remove text track: not in the element.");
            }
        }
        /**
 * Source buffer to display TextTracks in the given HTML element.
 * @class HTMLTextTrackSourceBuffer
 */        var html_HTMLTextTrackSourceBuffer = function(_AbstractSourceBuffer) {
            /**
     * @param {HTMLMediaElement} videoElement
     * @param {HTMLElement} textTrackElement
     */
            function HTMLTextTrackSourceBuffer(videoElement, textTrackElement) {
                html_classCallCheck(this, HTMLTextTrackSourceBuffer), log.a.debug("creating html text track source buffer");
                var _this = _possibleConstructorReturn(this, _AbstractSourceBuffer.call(this));
                return _this._videoElement = videoElement, _this._textTrackElement = textTrackElement, 
                _this._destroy$ = new Subject.a(), _this._buffer = new buffer_manager(), _this._currentElement = null, 
                generateClock(_this._videoElement).pipe(Object(takeUntil.a)(_this._destroy$)).subscribe(function(shouldDisplay) {
                    if (!shouldDisplay) return safelyRemoveChild(textTrackElement, _this._currentElement), 
                    void (_this._currentElement = null);
                    // to spread the time error, we divide the regular chosen interval.
                    // As the clock is also based on real video events, we cannot just
                    // divide by two the regular interval.
                                        var time = Math.max(_this._videoElement.currentTime - MAXIMUM_HTML_TEXT_TRACK_UPDATE_INTERVAL / 2e3, 0), cue = _this._buffer.get(time);
                    if (!cue) return safelyRemoveChild(textTrackElement, _this._currentElement), void (_this._currentElement = null);
                    _this._currentElement !== cue.element && (safelyRemoveChild(textTrackElement, _this._currentElement), 
                    _this._currentElement = cue.element, textTrackElement.appendChild(_this._currentElement));
                }), _this;
            }
            /**
     * Append text tracks.
     * @param {Object} data
     */            return _inherits(HTMLTextTrackSourceBuffer, _AbstractSourceBuffer), HTMLTextTrackSourceBuffer.prototype._append = function _append(data) {
                log.a.debug("appending new html text tracks", data);
                var timescale = data.timescale, timescaledStart = data.start, timescaledEnd = data.end, dataString = data.data, type = data.type, language = data.language;
                if (timescaledEnd && timescaledEnd - timescaledStart <= 0) 
                // this is accepted for error resilience, just skip that case.
                /* tslint:disable:max-line-length */
                log.a.warn("Invalid text track appended: the start time is inferior or equal to the end time."); else {
                    var startTime = timescaledStart / timescale, endTime = null != timescaledEnd ? timescaledEnd / timescale : void 0, cues = parseTextTrackToElements(type, dataString, this.timestampOffset, language), start = startTime, end = null != endTime ? endTime : cues[cues.length - 1].end;
                    this._buffer.insert(cues, start, end), this.buffered.insert(start, end);
                }
            }, 
            /**
     * @param {Number} from
     * @param {Number} to
     */
            HTMLTextTrackSourceBuffer.prototype._remove = function _remove(from, to) {
                log.a.debug("removing html text track data", from, to), this._buffer.remove(from, to), 
                this.buffered.remove(from, to);
            }, 
            /**
     * Free up ressources from this sourceBuffer
     */
            HTMLTextTrackSourceBuffer.prototype._abort = function _abort() {
                log.a.debug("aborting html text track source buffer"), this._destroy$.next(), this._destroy$.complete(), 
                safelyRemoveChild(this._textTrackElement, this._currentElement);
            }, HTMLTextTrackSourceBuffer;
        }(abstract_source_buffer.a);
        /* harmony default export */        __webpack_exports__.default = html_HTMLTextTrackSourceBuffer;
    }, 
    /* 130 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        // EXTERNAL MODULE: ./src/compat/index.ts
        var compat = __webpack_require__(12), log = __webpack_require__(0), abstract_source_buffer = __webpack_require__(61), features = __webpack_require__(7);
        // EXTERNAL MODULE: ./src/log.ts + 1 modules
                // CONCATENATED MODULE: ./src/core/source_buffers/text/native/parsers.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Convert text track data into timed VTT Cues.
 * @param {string} type - Text track format wanted
 * @param {string} data - Text track data
 * @param {Number} timestampOffset - offset to apply to every timed text
 * @param {string} [language] - language of the text tracks
 * @returns {Array.<VTTCue>}
 * @throws Error - Throw if no parser is found for the given type
 */
        function parseTextTrackToCues(type, data, timestampOffset, language) {
            log.a.debug("finding parser for native text tracks:", type);
            var parser = features.a.nativeTextTracksParsers[type];
            if (!parser) throw new Error("no parser found for the given text track");
            log.a.debug("parser found, parsing...");
            var parsed = parser(data, timestampOffset, language);
            return log.a.debug("parsed successfully!", parsed), parsed;
        }
        // CONCATENATED MODULE: ./src/core/source_buffers/text/native/index.ts
                function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        function _possibleConstructorReturn(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" != typeof call && "function" != typeof call ? self : call;
        }
        function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */
        /**
 * Source buffer to display TextTracks in a <track> element, in the given
 * video element.
 * @class NativeTextTrackSourceBuffer
 * @extends AbstractSourceBuffer
 */        var native_NativeTextTrackSourceBuffer = function(_AbstractSourceBuffer) {
            /**
     * @param {HTMLMediaElement} videoElement
     * @param {Boolean} hideNativeSubtitle
     */
            function NativeTextTrackSourceBuffer(videoElement, hideNativeSubtitle) {
                _classCallCheck(this, NativeTextTrackSourceBuffer), log.a.debug("creating native text track source buffer");
                var _this = _possibleConstructorReturn(this, _AbstractSourceBuffer.call(this)), _addTextTrack = Object(compat.a)(videoElement, hideNativeSubtitle), track = _addTextTrack.track, trackElement = _addTextTrack.trackElement;
                return _this._videoElement = videoElement, _this._track = track, _this._trackElement = trackElement, 
                _this;
            }
            /**
     * Append text tracks.
     * @param {Object} data
     */            return _inherits(NativeTextTrackSourceBuffer, _AbstractSourceBuffer), NativeTextTrackSourceBuffer.prototype._append = function _append(data) {
                log.a.debug("appending new native text tracks", data);
                var timescale = data.timescale, timescaledStart = data.start, timescaledEnd = data.end, dataString = data.data, type = data.type, language = data.language;
                if (null != timescaledEnd && timescaledEnd - timescaledStart <= 0) 
                // this is accepted for error resilience, just skip that case.
                log.a.warn("Invalid subtitles appended"); else {
                    var startTime = timescaledStart / timescale, endTime = null != timescaledEnd ? timescaledEnd / timescale : void 0, cues = parseTextTrackToCues(type, dataString, this.timestampOffset, language);
                    if (cues.length > 0) {
                        var firstCue = cues[0], currentCues = this._track.cues;
                        // NOTE(compat): cleanup all current cues if the newly added
                        // ones are in the past. this is supposed to fix an issue on
                        // IE/Edge.
                                                currentCues.length > 0 && firstCue.startTime < currentCues[currentCues.length - 1].startTime && this._remove(firstCue.startTime, Infinity);
                        for (var i = 0; i < cues.length; i++) this._track.addCue(cues[i]);
                        this.buffered.insert(startTime, null != endTime ? endTime : cues[cues.length - 1].endTime);
                    } else null != endTime && this.buffered.insert(startTime, endTime);
                }
            }, 
            /**
     * @param {Number} from
     * @param {Number} to
     */
            NativeTextTrackSourceBuffer.prototype._remove = function _remove(from, to) {
                log.a.debug("removing native text track data", from, to);
                for (var track = this._track, cues = track.cues, i = cues.length - 1; i >= 0; i--) {
                    var cue = cues[i], startTime = cue.startTime, endTime = cue.endTime;
                    startTime >= from && startTime <= to && endTime <= to && track.removeCue(cue);
                }
                this.buffered.remove(from, to);
            }, NativeTextTrackSourceBuffer.prototype._abort = function _abort() {
                log.a.debug("aborting native text track source buffer");
                var _trackElement = this._trackElement, _videoElement = this._videoElement;
                if (_trackElement && _videoElement && _videoElement.hasChildNodes()) try {
                    _videoElement.removeChild(_trackElement);
                } catch (e) {
                    log.a.warn("Can't remove track element from the video");
                }
                this._track && (this._track.mode = "disabled"), this._trackElement && (this._trackElement.innerHTML = "");
            }, NativeTextTrackSourceBuffer;
        }(abstract_source_buffer.a);
        /* harmony default export */        __webpack_exports__.default = native_NativeTextTrackSourceBuffer;
    }, 
    /* 131 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subject.js
                var Subject = __webpack_require__(36), merge = __webpack_require__(134), throwError = __webpack_require__(78), of = __webpack_require__(75), takeUntil = __webpack_require__(141), bytes = __webpack_require__(1), castToObservable = __webpack_require__(15), eventemitter = __webpack_require__(41), constants = __webpack_require__(25), events = __webpack_require__(8), _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                    "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            return function(Constructor, protoProps, staticProps) {
                return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), 
                Constructor;
            };
        }();
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/merge.js
                function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Simple implementation of the MediaKeySystemAccess EME API.
 *
 * All needed arguments are given to the constructor
 * @class CustomMediaKeySystemAccess
 */        var keySystemAccess = function() {
            function CustomMediaKeySystemAccess(_keyType, _mediaKeys, _configuration) {
                _classCallCheck(this, CustomMediaKeySystemAccess), this._keyType = _keyType, this._mediaKeys = _mediaKeys, 
                this._configuration = _configuration;
            }
            return CustomMediaKeySystemAccess.prototype.createMediaKeys = function createMediaKeys() {
                var _this = this;
                return new Promise(function(res) {
                    return res(_this._mediaKeys);
                });
            }, CustomMediaKeySystemAccess.prototype.getConfiguration = function getConfiguration() {
                return this._configuration;
            }, _createClass(CustomMediaKeySystemAccess, [ {
                key: "keySystem",
                get: function get() {
                    return this._keyType;
                }
            } ]), CustomMediaKeySystemAccess;
        }();
        /* harmony default export */        function _possibleConstructorReturn(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" != typeof call && "function" != typeof call ? self : call;
        }
        function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
        }
        function MediaKeys_classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        
        // CONCATENATED MODULE: ./src/compat/eme/MediaKeys.ts
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return MockMediaKeys;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() {
            return MediaKeys_requestMediaKeySystemAccess;
        });
        var MediaKeys_requestMediaKeySystemAccess = void 0, MockMediaKeys = function() {
            function MockMediaKeys() {
                MediaKeys_classCallCheck(this, MockMediaKeys);
            }
            return MockMediaKeys.prototype._setVideo = function _setVideo() {
                throw new Error("MediaKeys is not implemented in your browser");
            }, MockMediaKeys.prototype.createSession = function createSession() {
                throw new Error("MediaKeys is not implemented in your browser");
            }, MockMediaKeys.prototype.setServerCertificate = function setServerCertificate() {
                throw new Error("MediaKeys is not implemented in your browser");
            }, MockMediaKeys;
        }();
        // Default MockMediaKeys implementation
                if (navigator.requestMediaKeySystemAccess) MediaKeys_requestMediaKeySystemAccess = function requestMediaKeySystemAccess(a, b) {
            return Object(castToObservable.a)(navigator.requestMediaKeySystemAccess(a, b));
        }; else {
            // Wrap "MediaKeys.prototype.update" form an event based system to a
            // Promise based function.
            var wrapUpdate = function wrapUpdate(memUpdate) {
                return function(license, sessionId) {
                    var _this = this;
                    return new Promise(function(resolve, reject) {
                        try {
                            memUpdate.call(_this, license, sessionId), resolve();
                        } catch (e) {
                            reject(e);
                        }
                    });
                };
            };
            // This is for Chrome with unprefixed EME api
                        if (HTMLVideoElement.prototype.webkitGenerateKeyRequest) {
                var MediaKeys_WebkitMediaKeySession = function(_EventEmitter) {
                    function WebkitMediaKeySession(video, keySystem) {
                        MediaKeys_classCallCheck(this, WebkitMediaKeySession);
                        var _this2 = _possibleConstructorReturn(this, _EventEmitter.call(this));
                        return _this2._closeSession$ = new Subject.a(), _this2._vid = video, _this2._key = keySystem, 
                        _this2.sessionId = "", _this2.closed = new Promise(function(resolve) {
                            _this2._closeSession$.subscribe(resolve);
                        }), _this2.keyStatuses = new Map(), _this2.expiration = NaN, Object(merge.a)(events.g(video), events.e(video), events.f(video)).pipe(Object(takeUntil.a)(_this2._closeSession$)).subscribe(function(evt) {
                            return _this2.trigger(evt.type, evt);
                        }), _this2.update = wrapUpdate(function(license, sessionId) {
                            if (_this2._key.indexOf("clearkey") >= 0) {
                                var json = JSON.parse(Object(bytes.f)(license)), key = Object(bytes.p)(atob(json.keys[0].k)), kid = Object(bytes.p)(atob(json.keys[0].kid));
                                _this2._vid.webkitAddKey(_this2._key, key, kid, sessionId);
                            } else _this2._vid.webkitAddKey(_this2._key, license, null, sessionId);
                            _this2.sessionId = sessionId;
                        }), _this2;
                    }
                    return _inherits(WebkitMediaKeySession, _EventEmitter), WebkitMediaKeySession.prototype.generateRequest = function generateRequest(_initDataType, initData) {
                        var _this3 = this;
                        return new Promise(function(resolve) {
                            if ("function" != typeof _this3._vid.webkitGenerateKeyRequest) throw new Error("impossible to generate a key request");
                            _this3._vid.webkitGenerateKeyRequest(_this3._key, initData), resolve();
                        });
                    }, WebkitMediaKeySession.prototype.close = function close() {
                        var _this4 = this;
                        return new Promise(function(resolve) {
                            _this4._closeSession$.next(), _this4._closeSession$.complete(), resolve();
                        });
                    }, WebkitMediaKeySession.prototype.load = function load() {
                        return Promise.resolve(!1);
                    }, WebkitMediaKeySession.prototype.remove = function remove() {
                        return Promise.resolve();
                    }, WebkitMediaKeySession;
                }(eventemitter.a);
                MockMediaKeys = function() {
                    function MockMediaKeys(keySystem) {
                        MediaKeys_classCallCheck(this, MockMediaKeys), this.ks_ = keySystem;
                    }
                    return MockMediaKeys.prototype._setVideo = function _setVideo(vid) {
                        this._vid = vid;
                    }, MockMediaKeys.prototype.createSession = function createSession() {
                        if (!this._vid) throw new Error("Video not attached to the MediaKeys");
                        return new MediaKeys_WebkitMediaKeySession(this._vid, this.ks_);
                    }, MockMediaKeys.prototype.setServerCertificate = function setServerCertificate() {
                        throw new Error("Server certificate is not implemented in your browser");
                    }, MockMediaKeys;
                }();
                var isTypeSupported = function isTypeSupported(keyType) {
                    // get any <video> element from the DOM or create one
                    // and try the `canPlayType` method
                    var video = document.querySelector("video") || document.createElement("video");
                    return !(!video || !video.canPlayType) && !!video.canPlayType("video/mp4", keyType);
                };
                MediaKeys_requestMediaKeySystemAccess = function requestMediaKeySystemAccess(keyType, keySystemConfigurations) {
                    if (!isTypeSupported(keyType)) return Object(throwError.a)(void 0);
                    for (var i = 0; i < keySystemConfigurations.length; i++) {
                        var keySystemConfiguration = keySystemConfigurations[i], videoCapabilities = keySystemConfiguration.videoCapabilities, audioCapabilities = keySystemConfiguration.audioCapabilities, initDataTypes = keySystemConfiguration.initDataTypes, sessionTypes = keySystemConfiguration.sessionTypes, distinctiveIdentifier = keySystemConfiguration.distinctiveIdentifier, persistentState = keySystemConfiguration.persistentState, supported = !0;
                        if (supported = (supported = (supported = (supported = supported && (!initDataTypes || !!initDataTypes.filter(function(initDataType) {
                            return "cenc" === initDataType;
                        })[0])) && (!sessionTypes || sessionTypes.filter(function(sessionType) {
                            return "temporary" === sessionType;
                        }).length === sessionTypes.length)) && "required" !== distinctiveIdentifier) && "required" !== persistentState) {
                            var keySystemConfigurationResponse = {
                                videoCapabilities: videoCapabilities,
                                audioCapabilities: audioCapabilities,
                                initDataTypes: [ "cenc" ],
                                sessionTypes: [ "temporary" ],
                                // TODO TypesScript bug or what? Check and open an issue
                                distinctiveIdentifier: "not-allowed",
                                persistentState: "not-allowed"
                            };
                            return Object(of.a)(new keySystemAccess(keyType, new MockMediaKeys(keyType), keySystemConfigurationResponse));
                        }
                    }
                    return Object(throwError.a)(void 0);
                };
            }
            // This is for IE11
             else if (constants.c && constants.c.prototype && "function" == typeof constants.c.prototype.createSession && "function" == typeof constants.c.isTypeSupported) {
                // TODO implement MediaKeySession completely
                var MediaKeys_IE11MediaKeySession = function(_EventEmitter2) {
                    function IE11MediaKeySession(mk) {
                        MediaKeys_classCallCheck(this, IE11MediaKeySession);
                        var _this5 = _possibleConstructorReturn(this, _EventEmitter2.call(this));
                        return _this5.sessionId = "", _this5.expiration = NaN, _this5.keyStatuses = new Map(), 
                        _this5._mk = mk, _this5._closeSession$ = new Subject.a(), _this5.closed = new Promise(function(resolve) {
                            _this5._closeSession$.subscribe(resolve);
                        }), _this5.update = wrapUpdate(function(license, sessionId) {
                            if (!_this5._ss) throw new Error("MediaKeySession not set");
                            _this5._ss.update(license, sessionId), _this5.sessionId = sessionId;
                        }), _this5;
                    }
                    return _inherits(IE11MediaKeySession, _EventEmitter2), IE11MediaKeySession.prototype.generateRequest = function generateRequest(_initDataType, initData) {
                        var _this6 = this;
                        return new Promise(function(resolve) {
                            _this6._ss = _this6._mk.memCreateSession("video/mp4", initData), Object(merge.a)(events.g(_this6._ss), events.e(_this6._ss), events.f(_this6._ss)).pipe(Object(takeUntil.a)(_this6._closeSession$)).subscribe(function(evt) {
                                return _this6.trigger(evt.type, evt);
                            }), resolve();
                        });
                    }, IE11MediaKeySession.prototype.close = function close() {
                        var _this7 = this;
                        return new Promise(function(resolve) {
                            _this7._ss && (
                            /* tslint:disable no-floating-promises */
                            _this7._ss.close(), 
                            /* tslint:enable no-floating-promises */
                            _this7._ss = void 0), _this7._closeSession$.next(), _this7._closeSession$.complete(), 
                            resolve();
                        });
                    }, IE11MediaKeySession.prototype.load = function load() {
                        return Promise.resolve(!1);
                    }, IE11MediaKeySession.prototype.remove = function remove() {
                        return Promise.resolve();
                    }, IE11MediaKeySession;
                }(eventemitter.a);
                // on IE11, each created session needs to be created on a new
                // MediaKeys object
                                constants.c.prototype.alwaysRenew = !0, constants.c.prototype.memCreateSession = constants.c.prototype.createSession, 
                constants.c.prototype.createSession = function() {
                    /* tslint:disable no-invalid-this */
                    return new MediaKeys_IE11MediaKeySession(this);
                    /* tslint:enable no-invalid-this */                }, MediaKeys_requestMediaKeySystemAccess = function requestMediaKeySystemAccess(keyType, keySystemConfigurations) {
                    // TODO Why TS Do not understand that isTypeSupported exists here?
                    if (!constants.c.isTypeSupported(keyType)) return Object(throwError.a)(void 0);
                    for (var i = 0; i < keySystemConfigurations.length; i++) {
                        var keySystemConfiguration = keySystemConfigurations[i], videoCapabilities = keySystemConfiguration.videoCapabilities, audioCapabilities = keySystemConfiguration.audioCapabilities, initDataTypes = keySystemConfiguration.initDataTypes, distinctiveIdentifier = keySystemConfiguration.distinctiveIdentifier, supported = !0;
                        if (supported = (supported = supported && (!initDataTypes || !!initDataTypes.filter(function(idt) {
                            return "cenc" === idt;
                        })[0])) && "required" !== distinctiveIdentifier) {
                            var keySystemConfigurationResponse = {
                                videoCapabilities: videoCapabilities,
                                audioCapabilities: audioCapabilities,
                                initDataTypes: [ "cenc" ],
                                distinctiveIdentifier: "not-allowed",
                                persistentState: "required",
                                sessionTypes: [ "temporary", "persistent-license" ]
                            };
                            return Object(of.a)(new keySystemAccess(keyType, 
                            // TODO Authorize 1 argument for IE?
                            new constants.c(keyType), keySystemConfigurationResponse));
                        }
                    }
                    return Object(throwError.a)(void 0);
                };
            } else MediaKeys_requestMediaKeySystemAccess = null;
        }
        /***/    }, 
    /* 132 */ 
    /* 133 */
    /***/ , 
    /* 133 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return defer;
        });
        /* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6), _from__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(44), _empty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(26);
        /* harmony import */        
        /** PURE_IMPORTS_START _Observable,_from,_empty PURE_IMPORTS_END */
        function defer(observableFactory) {
            return new _Observable__WEBPACK_IMPORTED_MODULE_0__.a(function(subscriber) {
                var input;
                try {
                    input = observableFactory();
                } catch (err) {
                    return void subscriber.error(err);
                }
                return (input ? Object(_from__WEBPACK_IMPORTED_MODULE_1__.a)(input) : Object(_empty__WEBPACK_IMPORTED_MODULE_2__.b)()).subscribe(subscriber);
            });
        }
        //# sourceMappingURL=defer.js.map
        /***/    }, 
    /* 134 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return merge;
        });
        /* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6), _util_isScheduler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(34), _operators_mergeAll__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(102), _fromArray__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(33);
        /* harmony import */        
        /** PURE_IMPORTS_START _Observable,_util_isScheduler,_operators_mergeAll,_fromArray PURE_IMPORTS_END */
        function merge() {
            for (var observables = [], _i = 0; _i < arguments.length; _i++) observables[_i] = arguments[_i];
            var concurrent = Number.POSITIVE_INFINITY, scheduler = null, last = observables[observables.length - 1];
            return Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_1__.a)(last) ? (scheduler = observables.pop(), 
            observables.length > 1 && "number" == typeof observables[observables.length - 1] && (concurrent = observables.pop())) : "number" == typeof last && (concurrent = observables.pop()), 
            null === scheduler && 1 === observables.length && observables[0] instanceof _Observable__WEBPACK_IMPORTED_MODULE_0__.a ? observables[0] : Object(_operators_mergeAll__WEBPACK_IMPORTED_MODULE_2__.a)(concurrent)(Object(_fromArray__WEBPACK_IMPORTED_MODULE_3__.a)(observables, scheduler));
        }
        //# sourceMappingURL=merge.js.map
        /***/    }, 
    /* 135 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return fromEvent;
        });
        /* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6), _util_isArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(42), _util_isFunction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(47), _operators_map__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(54);
        /* harmony import */        Object.prototype.toString;
        function fromEvent(target, eventName, options, resultSelector) {
            return Object(_util_isFunction__WEBPACK_IMPORTED_MODULE_2__.a)(options) && (resultSelector = options, 
            options = void 0), resultSelector ? fromEvent(target, eventName, options).pipe(Object(_operators_map__WEBPACK_IMPORTED_MODULE_3__.a)(function(args) {
                return Object(_util_isArray__WEBPACK_IMPORTED_MODULE_1__.a)(args) ? resultSelector.apply(void 0, args) : resultSelector(args);
            })) : new _Observable__WEBPACK_IMPORTED_MODULE_0__.a(function(subscriber) {
                setupSubscription(target, eventName, function handler(e) {
                    arguments.length > 1 ? subscriber.next(Array.prototype.slice.call(arguments)) : subscriber.next(e);
                }, subscriber, options);
            });
        }
        function setupSubscription(sourceObj, eventName, handler, subscriber, options) {
            var unsubscribe;
            if (isEventTarget(sourceObj)) {
                var source_1 = sourceObj;
                sourceObj.addEventListener(eventName, handler, options), unsubscribe = function() {
                    return source_1.removeEventListener(eventName, handler, options);
                };
            } else if (isJQueryStyleEventEmitter(sourceObj)) {
                var source_2 = sourceObj;
                sourceObj.on(eventName, handler), unsubscribe = function() {
                    return source_2.off(eventName, handler);
                };
            } else if (isNodeStyleEventEmitter(sourceObj)) {
                var source_3 = sourceObj;
                sourceObj.addListener(eventName, handler), unsubscribe = function() {
                    return source_3.removeListener(eventName, handler);
                };
            } else {
                if (!sourceObj || !sourceObj.length) throw new TypeError("Invalid event target");
                for (var i = 0, len = sourceObj.length; i < len; i++) setupSubscription(sourceObj[i], eventName, handler, subscriber, options);
            }
            subscriber.add(unsubscribe);
        }
        function isNodeStyleEventEmitter(sourceObj) {
            return sourceObj && "function" == typeof sourceObj.addListener && "function" == typeof sourceObj.removeListener;
        }
        function isJQueryStyleEventEmitter(sourceObj) {
            return sourceObj && "function" == typeof sourceObj.on && "function" == typeof sourceObj.off;
        }
        function isEventTarget(sourceObj) {
            return sourceObj && "function" == typeof sourceObj.addEventListener && "function" == typeof sourceObj.removeEventListener;
        }
        //# sourceMappingURL=fromEvent.js.map
        /***/    }, 
    /* 136 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return mapTo;
        });
        /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2), _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);
        /* harmony import */        
        /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
        function mapTo(value) {
            return function(source) {
                return source.lift(new MapToOperator(value));
            };
        }
        var MapToOperator = /* */ function() {
            function MapToOperator(value) {
                this.value = value;
            }
            return MapToOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new MapToSubscriber(subscriber, this.value));
            }, MapToOperator;
        }(), MapToSubscriber = /* */ function(_super) {
            function MapToSubscriber(destination, value) {
                var _this = _super.call(this, destination) || this;
                return _this.value = value, _this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(MapToSubscriber, _super), MapToSubscriber.prototype._next = function(x) {
                this.destination.next(this.value);
            }, MapToSubscriber;
        }(_Subscriber__WEBPACK_IMPORTED_MODULE_1__.a);
    }, 
    /* 137 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return filter;
        });
        /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2), _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);
        /* harmony import */        
        /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
        function filter(predicate, thisArg) {
            return function filterOperatorFunction(source) {
                return source.lift(new FilterOperator(predicate, thisArg));
            };
        }
        var FilterOperator = /* */ function() {
            function FilterOperator(predicate, thisArg) {
                this.predicate = predicate, this.thisArg = thisArg;
            }
            return FilterOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
            }, FilterOperator;
        }(), FilterSubscriber = /* */ function(_super) {
            function FilterSubscriber(destination, predicate, thisArg) {
                var _this = _super.call(this, destination) || this;
                return _this.predicate = predicate, _this.thisArg = thisArg, _this.count = 0, _this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(FilterSubscriber, _super), FilterSubscriber.prototype._next = function(value) {
                var result;
                try {
                    result = this.predicate.call(this.thisArg, value, this.count++);
                } catch (err) {
                    return void this.destination.error(err);
                }
                result && this.destination.next(value);
            }, FilterSubscriber;
        }(_Subscriber__WEBPACK_IMPORTED_MODULE_1__.a);
    }, 
    /* 138 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return startWith;
        });
        /* harmony import */ var _observable_fromArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(33), _observable_scalar__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(76), _observable_empty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(26), _observable_concat__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(107), _util_isScheduler__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(34);
        /* harmony import */        
        /** PURE_IMPORTS_START _observable_fromArray,_observable_scalar,_observable_empty,_observable_concat,_util_isScheduler PURE_IMPORTS_END */
        function startWith() {
            for (var array = [], _i = 0; _i < arguments.length; _i++) array[_i] = arguments[_i];
            return function(source) {
                var scheduler = array[array.length - 1];
                Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_4__.a)(scheduler) ? array.pop() : scheduler = null;
                var len = array.length;
                return 1 !== len || scheduler ? len > 0 ? Object(_observable_concat__WEBPACK_IMPORTED_MODULE_3__.a)(Object(_observable_fromArray__WEBPACK_IMPORTED_MODULE_0__.a)(array, scheduler), source) : Object(_observable_concat__WEBPACK_IMPORTED_MODULE_3__.a)(Object(_observable_empty__WEBPACK_IMPORTED_MODULE_2__.b)(scheduler), source) : Object(_observable_concat__WEBPACK_IMPORTED_MODULE_3__.a)(Object(_observable_scalar__WEBPACK_IMPORTED_MODULE_1__.a)(array[0]), source);
            };
        }
        //# sourceMappingURL=startWith.js.map
        /***/    }, 
    /* 139 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return interval;
        });
        /* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6), _scheduler_async__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(39), _util_isNumeric__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(65);
        /* harmony import */        
        /** PURE_IMPORTS_START _Observable,_scheduler_async,_util_isNumeric PURE_IMPORTS_END */
        function interval(period, scheduler) {
            return void 0 === period && (period = 0), void 0 === scheduler && (scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_1__.a), 
            (!Object(_util_isNumeric__WEBPACK_IMPORTED_MODULE_2__.a)(period) || period < 0) && (period = 0), 
            scheduler && "function" == typeof scheduler.schedule || (scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_1__.a), 
            new _Observable__WEBPACK_IMPORTED_MODULE_0__.a(function(subscriber) {
                return subscriber.add(scheduler.schedule(dispatch, period, {
                    subscriber: subscriber,
                    counter: 0,
                    period: period
                })), subscriber;
            });
        }
        function dispatch(state) {
            var subscriber = state.subscriber, counter = state.counter, period = state.period;
            subscriber.next(counter), this.schedule({
                subscriber: subscriber,
                counter: counter + 1,
                period: period
            }, period);
        }
        //# sourceMappingURL=interval.js.map
        /***/    }, 
    /* 140 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return distinctUntilChanged;
        });
        /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2), _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10), _util_tryCatch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(63), _util_errorObject__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(31);
        /* harmony import */        
        /** PURE_IMPORTS_START tslib,_Subscriber,_util_tryCatch,_util_errorObject PURE_IMPORTS_END */
        function distinctUntilChanged(compare, keySelector) {
            return function(source) {
                return source.lift(new DistinctUntilChangedOperator(compare, keySelector));
            };
        }
        var DistinctUntilChangedOperator = /* */ function() {
            function DistinctUntilChangedOperator(compare, keySelector) {
                this.compare = compare, this.keySelector = keySelector;
            }
            return DistinctUntilChangedOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));
            }, DistinctUntilChangedOperator;
        }(), DistinctUntilChangedSubscriber = /* */ function(_super) {
            function DistinctUntilChangedSubscriber(destination, compare, keySelector) {
                var _this = _super.call(this, destination) || this;
                return _this.keySelector = keySelector, _this.hasKey = !1, "function" == typeof compare && (_this.compare = compare), 
                _this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(DistinctUntilChangedSubscriber, _super), 
            DistinctUntilChangedSubscriber.prototype.compare = function(x, y) {
                return x === y;
            }, DistinctUntilChangedSubscriber.prototype._next = function(value) {
                var key = value;
                if (this.keySelector && (key = Object(_util_tryCatch__WEBPACK_IMPORTED_MODULE_2__.a)(this.keySelector)(value)) === _util_errorObject__WEBPACK_IMPORTED_MODULE_3__.a) return this.destination.error(_util_errorObject__WEBPACK_IMPORTED_MODULE_3__.a.e);
                var result = !1;
                if (this.hasKey) {
                    if ((result = Object(_util_tryCatch__WEBPACK_IMPORTED_MODULE_2__.a)(this.compare)(this.key, key)) === _util_errorObject__WEBPACK_IMPORTED_MODULE_3__.a) return this.destination.error(_util_errorObject__WEBPACK_IMPORTED_MODULE_3__.a.e);
                } else this.hasKey = !0;
                !1 === Boolean(result) && (this.key = key, this.destination.next(value));
            }, DistinctUntilChangedSubscriber;
        }(_Subscriber__WEBPACK_IMPORTED_MODULE_1__.a);
    }, 
    /* 141 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return takeUntil;
        });
        /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2), _OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(23), _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(24);
        /* harmony import */        
        /** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
        function takeUntil(notifier) {
            return function(source) {
                return source.lift(new TakeUntilOperator(notifier));
            };
        }
        var TakeUntilOperator = /* */ function() {
            function TakeUntilOperator(notifier) {
                this.notifier = notifier;
            }
            return TakeUntilOperator.prototype.call = function(subscriber, source) {
                var takeUntilSubscriber = new TakeUntilSubscriber(subscriber), notifierSubscription = Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__.a)(takeUntilSubscriber, this.notifier);
                return notifierSubscription && !notifierSubscription.closed ? (takeUntilSubscriber.add(notifierSubscription), 
                source.subscribe(takeUntilSubscriber)) : takeUntilSubscriber;
            }, TakeUntilOperator;
        }(), TakeUntilSubscriber = /* */ function(_super) {
            function TakeUntilSubscriber(destination) {
                return _super.call(this, destination) || this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(TakeUntilSubscriber, _super), TakeUntilSubscriber.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
                this.complete();
            }, TakeUntilSubscriber.prototype.notifyComplete = function() {}, TakeUntilSubscriber;
        }(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__.a);
    }, 
    /* 142 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return take;
        });
        /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2), _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10), _util_ArgumentOutOfRangeError__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(79), _observable_empty__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(26);
        /* harmony import */        
        /** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError,_observable_empty PURE_IMPORTS_END */
        function take(count) {
            return function(source) {
                return 0 === count ? Object(_observable_empty__WEBPACK_IMPORTED_MODULE_3__.b)() : source.lift(new TakeOperator(count));
            };
        }
        var TakeOperator = /* */ function() {
            function TakeOperator(total) {
                if (this.total = total, this.total < 0) throw new _util_ArgumentOutOfRangeError__WEBPACK_IMPORTED_MODULE_2__.a();
            }
            return TakeOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new TakeSubscriber(subscriber, this.total));
            }, TakeOperator;
        }(), TakeSubscriber = /* */ function(_super) {
            function TakeSubscriber(destination, total) {
                var _this = _super.call(this, destination) || this;
                return _this.total = total, _this.count = 0, _this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(TakeSubscriber, _super), TakeSubscriber.prototype._next = function(value) {
                var total = this.total, count = ++this.count;
                count <= total && (this.destination.next(value), count === total && (this.destination.complete(), 
                this.unsubscribe()));
            }, TakeSubscriber;
        }(_Subscriber__WEBPACK_IMPORTED_MODULE_1__.a);
    }, 
    /* 143 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return catchError;
        });
        /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2), _OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(23), _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(24);
        /* harmony import */        
        /** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
        function catchError(selector) {
            return function catchErrorOperatorFunction(source) {
                var operator = new CatchOperator(selector), caught = source.lift(operator);
                return operator.caught = caught;
            };
        }
        var CatchOperator = /* */ function() {
            function CatchOperator(selector) {
                this.selector = selector;
            }
            return CatchOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));
            }, CatchOperator;
        }(), CatchSubscriber = /* */ function(_super) {
            function CatchSubscriber(destination, selector, caught) {
                var _this = _super.call(this, destination) || this;
                return _this.selector = selector, _this.caught = caught, _this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(CatchSubscriber, _super), CatchSubscriber.prototype.error = function(err) {
                if (!this.isStopped) {
                    var result = void 0;
                    try {
                        result = this.selector(err, this.caught);
                    } catch (err2) {
                        return void _super.prototype.error.call(this, err2);
                    }
                    this._unsubscribeAndRecycle(), this.add(Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__.a)(this, result));
                }
            }, CatchSubscriber;
        }(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__.a);
    }, 
    /* 144 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return mergeMapTo;
        });
        /* harmony import */ var _mergeMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(57);
        /** PURE_IMPORTS_START _mergeMap PURE_IMPORTS_END */        function mergeMapTo(innerObservable, resultSelector, concurrent) {
            return void 0 === concurrent && (concurrent = Number.POSITIVE_INFINITY), "function" == typeof resultSelector ? Object(_mergeMap__WEBPACK_IMPORTED_MODULE_0__.a)(function() {
                return innerObservable;
            }, resultSelector, concurrent) : ("number" == typeof resultSelector && (concurrent = resultSelector), 
            Object(_mergeMap__WEBPACK_IMPORTED_MODULE_0__.a)(function() {
                return innerObservable;
            }, concurrent));
        }
        //# sourceMappingURL=mergeMapTo.js.map
        /***/    }, 
    /* 145 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return ignoreElements;
        });
        /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2), _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);
        /* harmony import */        
        /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
        function ignoreElements() {
            return function ignoreElementsOperatorFunction(source) {
                return source.lift(new IgnoreElementsOperator());
            };
        }
        var IgnoreElementsOperator = /* */ function() {
            function IgnoreElementsOperator() {}
            return IgnoreElementsOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new IgnoreElementsSubscriber(subscriber));
            }, IgnoreElementsOperator;
        }(), IgnoreElementsSubscriber = /* */ function(_super) {
            function IgnoreElementsSubscriber() {
                return null !== _super && _super.apply(this, arguments) || this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(IgnoreElementsSubscriber, _super), IgnoreElementsSubscriber.prototype._next = function(unused) {}, 
            IgnoreElementsSubscriber;
        }(_Subscriber__WEBPACK_IMPORTED_MODULE_1__.a);
    }, 
    /* 146 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return combineLatest;
        });
        /* unused harmony export CombineLatestOperator */
        /* unused harmony export CombineLatestSubscriber */
        /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2), _util_isScheduler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(34), _util_isArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(42), _OuterSubscriber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(23), _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(24), _fromArray__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(33), NONE = {};
        /* harmony import */        function combineLatest() {
            for (var observables = [], _i = 0; _i < arguments.length; _i++) observables[_i] = arguments[_i];
            var resultSelector = null, scheduler = null;
            return Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_1__.a)(observables[observables.length - 1]) && (scheduler = observables.pop()), 
            "function" == typeof observables[observables.length - 1] && (resultSelector = observables.pop()), 
            1 === observables.length && Object(_util_isArray__WEBPACK_IMPORTED_MODULE_2__.a)(observables[0]) && (observables = observables[0]), 
            Object(_fromArray__WEBPACK_IMPORTED_MODULE_5__.a)(observables, scheduler).lift(new CombineLatestOperator(resultSelector));
        }
        var CombineLatestOperator = /* */ function() {
            function CombineLatestOperator(resultSelector) {
                this.resultSelector = resultSelector;
            }
            return CombineLatestOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new CombineLatestSubscriber(subscriber, this.resultSelector));
            }, CombineLatestOperator;
        }(), CombineLatestSubscriber = /* */ function(_super) {
            function CombineLatestSubscriber(destination, resultSelector) {
                var _this = _super.call(this, destination) || this;
                return _this.resultSelector = resultSelector, _this.active = 0, _this.values = [], 
                _this.observables = [], _this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(CombineLatestSubscriber, _super), CombineLatestSubscriber.prototype._next = function(observable) {
                this.values.push(NONE), this.observables.push(observable);
            }, CombineLatestSubscriber.prototype._complete = function() {
                var observables = this.observables, len = observables.length;
                if (0 === len) this.destination.complete(); else {
                    this.active = len, this.toRespond = len;
                    for (var i = 0; i < len; i++) {
                        var observable = observables[i];
                        this.add(Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_4__.a)(this, observable, observable, i));
                    }
                }
            }, CombineLatestSubscriber.prototype.notifyComplete = function(unused) {
                0 == (this.active -= 1) && this.destination.complete();
            }, CombineLatestSubscriber.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
                var values = this.values, oldVal = values[outerIndex], toRespond = this.toRespond ? oldVal === NONE ? --this.toRespond : this.toRespond : 0;
                values[outerIndex] = innerValue, 0 === toRespond && (this.resultSelector ? this._tryResultSelector(values) : this.destination.next(values.slice()));
            }, CombineLatestSubscriber.prototype._tryResultSelector = function(values) {
                var result;
                try {
                    result = this.resultSelector.apply(this, values);
                } catch (err) {
                    return void this.destination.error(err);
                }
                this.destination.next(result);
            }, CombineLatestSubscriber;
        }(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_3__.a);
    }, 
    /* 147 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return timer;
        });
        /* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6), _scheduler_async__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(39), _util_isNumeric__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(65), _util_isScheduler__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(34);
        /* harmony import */        
        /** PURE_IMPORTS_START _Observable,_scheduler_async,_util_isNumeric,_util_isScheduler PURE_IMPORTS_END */
        function timer(dueTime, periodOrScheduler, scheduler) {
            void 0 === dueTime && (dueTime = 0);
            var period = -1;
            return Object(_util_isNumeric__WEBPACK_IMPORTED_MODULE_2__.a)(periodOrScheduler) ? period = Number(periodOrScheduler) < 1 ? 1 : Number(periodOrScheduler) : Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_3__.a)(periodOrScheduler) && (scheduler = periodOrScheduler), 
            Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_3__.a)(scheduler) || (scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_1__.a), 
            new _Observable__WEBPACK_IMPORTED_MODULE_0__.a(function(subscriber) {
                var due = Object(_util_isNumeric__WEBPACK_IMPORTED_MODULE_2__.a)(dueTime) ? dueTime : +dueTime - scheduler.now();
                return scheduler.schedule(dispatch, due, {
                    index: 0,
                    period: period,
                    subscriber: subscriber
                });
            });
        }
        function dispatch(state) {
            var index = state.index, period = state.period, subscriber = state.subscriber;
            if (subscriber.next(index), !subscriber.closed) {
                if (-1 === period) return subscriber.complete();
                state.index = index + 1, this.schedule(state, period);
            }
        }
        //# sourceMappingURL=timer.js.map
        /***/    }, 
    /* 148 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return tap;
        });
        /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2), _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10), _util_noop__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(37), _util_isFunction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(47);
        /* harmony import */        
        /** PURE_IMPORTS_START tslib,_Subscriber,_util_noop,_util_isFunction PURE_IMPORTS_END */
        function tap(nextOrObserver, error, complete) {
            return function tapOperatorFunction(source) {
                return source.lift(new DoOperator(nextOrObserver, error, complete));
            };
        }
        var DoOperator = /* */ function() {
            function DoOperator(nextOrObserver, error, complete) {
                this.nextOrObserver = nextOrObserver, this.error = error, this.complete = complete;
            }
            return DoOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new TapSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));
            }, DoOperator;
        }(), TapSubscriber = /* */ function(_super) {
            function TapSubscriber(destination, observerOrNext, error, complete) {
                var _this = _super.call(this, destination) || this;
                return _this._tapNext = _util_noop__WEBPACK_IMPORTED_MODULE_2__.a, _this._tapError = _util_noop__WEBPACK_IMPORTED_MODULE_2__.a, 
                _this._tapComplete = _util_noop__WEBPACK_IMPORTED_MODULE_2__.a, _this._tapError = error || _util_noop__WEBPACK_IMPORTED_MODULE_2__.a, 
                _this._tapComplete = complete || _util_noop__WEBPACK_IMPORTED_MODULE_2__.a, Object(_util_isFunction__WEBPACK_IMPORTED_MODULE_3__.a)(observerOrNext) ? (_this._context = _this, 
                _this._tapNext = observerOrNext) : observerOrNext && (_this._context = observerOrNext, 
                _this._tapNext = observerOrNext.next || _util_noop__WEBPACK_IMPORTED_MODULE_2__.a, 
                _this._tapError = observerOrNext.error || _util_noop__WEBPACK_IMPORTED_MODULE_2__.a, 
                _this._tapComplete = observerOrNext.complete || _util_noop__WEBPACK_IMPORTED_MODULE_2__.a), 
                _this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(TapSubscriber, _super), TapSubscriber.prototype._next = function(value) {
                try {
                    this._tapNext.call(this._context, value);
                } catch (err) {
                    return void this.destination.error(err);
                }
                this.destination.next(value);
            }, TapSubscriber.prototype._error = function(err) {
                try {
                    this._tapError.call(this._context, err);
                } catch (err) {
                    return void this.destination.error(err);
                }
                this.destination.error(err);
            }, TapSubscriber.prototype._complete = function() {
                try {
                    this._tapComplete.call(this._context);
                } catch (err) {
                    return void this.destination.error(err);
                }
                return this.destination.complete();
            }, TapSubscriber;
        }(_Subscriber__WEBPACK_IMPORTED_MODULE_1__.a);
    }, 
    /* 149 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return shareReplay;
        });
        /* harmony import */ var _ReplaySubject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(126);
        /** PURE_IMPORTS_START _ReplaySubject PURE_IMPORTS_END */        function shareReplay(bufferSize, windowTime, scheduler) {
            return function(source) {
                return source.lift(shareReplayOperator(bufferSize, windowTime, scheduler));
            };
        }
        function shareReplayOperator(bufferSize, windowTime, scheduler) {
            var subject, subscription, refCount = 0, hasError = !1, isComplete = !1;
            return function shareReplayOperation(source) {
                refCount++, subject && !hasError || (hasError = !1, subject = new _ReplaySubject__WEBPACK_IMPORTED_MODULE_0__.a(bufferSize, windowTime, scheduler), 
                subscription = source.subscribe({
                    next: function(value) {
                        subject.next(value);
                    },
                    error: function(err) {
                        hasError = !0, subject.error(err);
                    },
                    complete: function() {
                        isComplete = !0, subject.complete();
                    }
                }));
                var innerSub = subject.subscribe(this);
                return function() {
                    refCount--, innerSub.unsubscribe(), subscription && 0 === refCount && isComplete && subscription.unsubscribe();
                };
            };
        }
        //# sourceMappingURL=shareReplay.js.map
        /***/    }, 
    /* 150 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return share;
        });
        /* harmony import */ var _multicast__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(94), _refCount__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(90), _Subject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(36);
        /* harmony import */        
        /** PURE_IMPORTS_START _multicast,_refCount,_Subject PURE_IMPORTS_END */
        function shareSubjectFactory() {
            return new _Subject__WEBPACK_IMPORTED_MODULE_2__.a();
        }
        function share() {
            return function(source) {
                return Object(_refCount__WEBPACK_IMPORTED_MODULE_1__.a)()(Object(_multicast__WEBPACK_IMPORTED_MODULE_0__.a)(shareSubjectFactory)(source));
            };
        }
        //# sourceMappingURL=share.js.map
        /***/    }
    /******/ ]);
});